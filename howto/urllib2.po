# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Phate <phate334@gmail.com>, 2015
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-24 00:16+0000\n"
"PO-Revision-Date: 2022-06-27 09:36+0800\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.1\n"

#: ../../howto/urllib2.rst:5
msgid "HOWTO Fetch Internet Resources Using The urllib Package"
msgstr "如何使用 urllib 套件取得網路資源"

#: ../../howto/urllib2.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/urllib2.rst:7
msgid "`Michael Foord <https://agileabstractions.com/>`_"
msgstr "`Michael Foord <https://agileabstractions.com/>`_"

#: ../../howto/urllib2.rst:11
msgid ""
"There is a French translation of an earlier revision of this HOWTO, "
"available at `urllib2 - Le Manuel manquant <https://web.archive.org/"
"web/20200910051922/http://www.voidspace.org.uk/python/articles/"
"urllib2_francais.shtml>`_."
msgstr ""
"這份指南出自於早期版本的法文翻譯 `urllib2 - Le Manuel manquant <https://web."
"archive.org/web/20200910051922/http://www.voidspace.org.uk/python/articles/"
"urllib2_francais.shtml>`_\\ 。"

#: ../../howto/urllib2.rst:18
msgid "Introduction"
msgstr "簡介"

#: ../../howto/urllib2.rst:22
msgid ""
"You may also find useful the following article on fetching web resources "
"with Python:"
msgstr "以下這些與 Python 有關的文章說不定能幫到你::"

#: ../../howto/urllib2.rst:25
msgid ""
"`Basic Authentication <https://web.archive.org/web/20201215133350/http://www."
"voidspace.org.uk/python/articles/authentication.shtml>`_"
msgstr ""
"`Basic Authentication <https://web.archive.org/web/20201215133350/http://www."
"voidspace.org.uk/python/articles/authentication.shtml>`_"

#: ../../howto/urllib2.rst:27
msgid "A tutorial on *Basic Authentication*, with examples in Python."
msgstr "以 Python 為例的 *Basic Authentication* 教學。"

#: ../../howto/urllib2.rst:29
msgid ""
"**urllib.request** is a Python module for fetching URLs (Uniform Resource "
"Locators). It offers a very simple interface, in the form of the *urlopen* "
"function. This is capable of fetching URLs using a variety of different "
"protocols. It also offers a slightly more complex interface for handling "
"common situations - like basic authentication, cookies, proxies and so on. "
"These are provided by objects called handlers and openers."
msgstr ""
"**urllib.request** 是一個用來從 URLs (Uniform Resource Locators) 取得資料的"
"Python模組。它提供一個了非常簡單的介面能接受多種不同的協定，*urlopen* 函數。"
"也提供了較複雜的介面用於處理一些常見的狀況，例如：基本的 authentication、"
"cookies、proxies 等等，這些都可以由 handler 或 opener 物件操作。"

#: ../../howto/urllib2.rst:36
#, fuzzy
msgid ""
"urllib.request supports fetching URLs for many \"URL schemes\" (identified "
"by the string before the ``\":\"`` in URL - for example ``\"ftp\"`` is the "
"URL scheme of ``\"ftp://python.org/\"``) using their associated network "
"protocols (e.g. FTP, HTTP). This tutorial focuses on the most common case, "
"HTTP."
msgstr ""
"urllib.request 支援獲取許多“URL 方案”的 URL（由 URL "
"中 ``:``之前的字串標識——例如 ``ftp``是“ftp://”的 URL 方案） python.org/\"``) "
"使用它們相關的網絡協定（例如 FTP、HTTP）。本教程重點關注最常見的情況，即 "
"HTTP。"

#: ../../howto/urllib2.rst:41
msgid ""
"For straightforward situations *urlopen* is very easy to use. But as soon as "
"you encounter errors or non-trivial cases when opening HTTP URLs, you will "
"need some understanding of the HyperText Transfer Protocol. The most "
"comprehensive and authoritative reference to HTTP is :rfc:`2616`. This is a "
"technical document and not intended to be easy to read. This HOWTO aims to "
"illustrate using *urllib*, with enough detail about HTTP to help you "
"through. It is not intended to replace the :mod:`urllib.request` docs, but "
"is supplementary to them."
msgstr ""
"一般情形下 *urlopen* 是非常容易使用的，但當你遇到錯誤或者較複雜的情況下，你可"
"能需要對超文本協定 HyperText Transfer Protocol 有一定的了解。最完整且具參考價"
"值的是 :rfc:`2616`，不過它是一份技術文件並不容易閱讀，以下的教學會提供足夠的 "
"HTTP 知識來幫助你使用 *urllib*。這份教學並非要取代 :mod:`urllib.request` 這份"
"文件，你還是會需要它。"

#: ../../howto/urllib2.rst:51
msgid "Fetching URLs"
msgstr "從 URL 取得資源"

#: ../../howto/urllib2.rst:53
msgid "The simplest way to use urllib.request is as follows::"
msgstr "以下是使用 urllib.request 最簡單的方法::"

#: ../../howto/urllib2.rst:59
#, fuzzy
msgid ""
"If you wish to retrieve a resource via URL and store it in a temporary "
"location, you can do so via the :func:`shutil.copyfileobj` and :func:"
"`tempfile.NamedTemporaryFile` functions::"
msgstr ""
"如果您希望通過 URL 檢索資源並將其儲存在臨時位置，您可以通過 :func:`shutil."
"copyfileobj` 和 :func:`tempfile.NamedTemporaryFile` 函式實作："

#: ../../howto/urllib2.rst:74
#, fuzzy
msgid ""
"Many uses of urllib will be that simple (note that instead of an 'http:' URL "
"we could have used a URL starting with 'ftp:', 'file:', etc.).  However, "
"it's the purpose of this tutorial to explain the more complicated cases, "
"concentrating on HTTP."
msgstr ""
"urllib 的許多用途就是這麼簡單（請注意，我們可以使用以“ftp:”、“file:”等開頭的 "
"URL 而不是“http:”URL）。然而，本教程的目的是解釋更複雜的情況，重點是 HTTP。"

#: ../../howto/urllib2.rst:79
#, fuzzy
msgid ""
"HTTP is based on requests and responses - the client makes requests and "
"servers send responses. urllib.request mirrors this with a ``Request`` "
"object which represents the HTTP request you are making. In its simplest "
"form you create a Request object that specifies the URL you want to fetch. "
"Calling ``urlopen`` with this Request object returns a response object for "
"the URL requested. This response is a file-like object, which means you can "
"for example call ``.read()`` on the response::"
msgstr ""
"HTTP 基於請求和響應——客戶端發出請求，伺服器發送響應。 urllib.request "
"使用代表您正在發出的 HTTP 請求的 ``Request`` "
"物件來反映這一點。在最簡單的形式中，您建立了一個 Request 物件，"
"該物件指定了您要獲取的 URL。使用此 Request 物件呼叫 urlopen 會回傳所請求 URL "
"的響應物件。這個響應是一個類似文件的物件，這意味著你可以在響應上呼叫 ``."
"read()``："

#: ../../howto/urllib2.rst:93
#, fuzzy
msgid ""
"Note that urllib.request makes use of the same Request interface to handle "
"all URL schemes.  For example, you can make an FTP request like so::"
msgstr "請注意，urllib.request 使用相同的 Request 介面來處理所有 URL 方案。例如，"
"您可以像這樣發出 FTP 請求："

#: ../../howto/urllib2.rst:98
#, fuzzy
msgid ""
"In the case of HTTP, there are two extra things that Request objects allow "
"you to do: First, you can pass data to be sent to the server.  Second, you "
"can pass extra information (\"metadata\") *about* the data or about the "
"request itself, to the server - this information is sent as HTTP "
"\"headers\".  Let's look at each of these in turn."
msgstr ""
"在 HTTP 的情況下，Request 物件允許您做兩件額外的事情：首先，您可以傳遞要發送"
"到伺服器的資料。其次，您可以將額外資訊（“元資料”）*關於*"
"資料或關於請求本身傳遞給伺服器 - 此資訊作為 "
"HTTP“標頭”發送。讓我們依次看看這些。"

#: ../../howto/urllib2.rst:105
#, fuzzy
msgid "Data"
msgstr "資料"

#: ../../howto/urllib2.rst:107
#, fuzzy
msgid ""
"Sometimes you want to send data to a URL (often the URL will refer to a CGI "
"(Common Gateway Interface) script or other web application). With HTTP, this "
"is often done using what's known as a **POST** request. This is often what "
"your browser does when you submit a HTML form that you filled in on the web. "
"Not all POSTs have to come from forms: you can use a POST to transmit "
"arbitrary data to your own application. In the common case of HTML forms, "
"the data needs to be encoded in a standard way, and then passed to the "
"Request object as the ``data`` argument. The encoding is done using a "
"function from the :mod:`urllib.parse` library. ::"
msgstr ""
"有時您希望將資料發送到 URL（通常 URL 將引用 CGI（通用網關介面）腳本或其他 "
"Web 應用程式）。對於 HTTP，這通常是使用所謂的 **POST** 請求來完成的。"
"當您提交在 Web 上填寫的 HTML 表單時，瀏覽器通常會執行此操作。並非所有 POST "
"都必須來自表單：您可以使用 POST 將任意資料傳輸到您自己的應用程式。在 HTML "
"表單的常見情況下，資料需要以標準方式編碼，然後作為 ``data``參數傳遞給 Request "
"物件。編碼是使用 :mod:`urllib.parse` 庫中的函式完成的。 ::"

#: ../../howto/urllib2.rst:131
#, fuzzy
msgid ""
"Note that other encodings are sometimes required (e.g. for file upload from "
"HTML forms - see `HTML Specification, Form Submission <https://www.w3.org/TR/"
"REC-html40/interact/forms.html#h-17.13>`_ for more details)."
msgstr ""
"請注意，有時需要其他編碼（例如，從 HTML 表單上傳文件 - 請參閱`HTML 規範，"
"表單提交 <https://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13> `_ "
"了解更多詳情）。"

#: ../../howto/urllib2.rst:136
#, fuzzy
msgid ""
"If you do not pass the ``data`` argument, urllib uses a **GET** request. One "
"way in which GET and POST requests differ is that POST requests often have "
"\"side-effects\": they change the state of the system in some way (for "
"example by placing an order with the website for a hundredweight of tinned "
"spam to be delivered to your door).  Though the HTTP standard makes it clear "
"that POSTs are intended to *always* cause side-effects, and GET requests "
"*never* to cause side-effects, nothing prevents a GET request from having "
"side-effects, nor a POST requests from having no side-effects. Data can also "
"be passed in an HTTP GET request by encoding it in the URL itself."
msgstr ""
"如果您不傳遞 ``data`` 參數，urllib 將使用 **GET** 請求。 GET 和 POST "
"請求不同的一種方式是 POST 請求通常有“副作用”：它們以某種方式改變系統的狀態（"
"例如通過向網站下訂單以交付一英擔罐裝垃圾郵件到你家門口）。儘管 HTTP "
"標準明確指出 POST 旨在*總是*引起副作用，而 GET 請求*從不*引起副作用，"
"但沒有什麼可以阻止 GET 請求產生副作用，也沒有什麼能阻止 POST "
"請求沒有副作用副作用。資料也可以通過在 URL 本身中編碼的方式在 HTTP GET "
"請求中傳遞。"

#: ../../howto/urllib2.rst:146
#, fuzzy
msgid "This is done as follows::"
msgstr "這是按如下方式完成的："

#: ../../howto/urllib2.rst:161
#, fuzzy
msgid ""
"Notice that the full URL is created by adding a ``?`` to the URL, followed "
"by the encoded values."
msgstr "請注意，完整的 URL 是通過向 URL 新增一個 ``?`` 後跟編碼值來建立的。"

#: ../../howto/urllib2.rst:165
#, fuzzy
msgid "Headers"
msgstr "標頭"

#: ../../howto/urllib2.rst:167
#, fuzzy
msgid ""
"We'll discuss here one particular HTTP header, to illustrate how to add "
"headers to your HTTP request."
msgstr "我們將在這裡討論一個特定的 HTTP 標頭，以說明如何將標頭新增到您的 HTTP 請求。"

#: ../../howto/urllib2.rst:170
#, fuzzy
msgid ""
"Some websites [#]_ dislike being browsed by programs, or send different "
"versions to different browsers [#]_. By default urllib identifies itself as "
"``Python-urllib/x.y`` (where ``x`` and ``y`` are the major and minor version "
"numbers of the Python release, e.g. ``Python-urllib/2.5``), which may "
"confuse the site, or just plain not work. The way a browser identifies "
"itself is through the ``User-Agent`` header [#]_. When you create a Request "
"object you can pass a dictionary of headers in. The following example makes "
"the same request as above, but identifies itself as a version of Internet "
"Explorer [#]_. ::"
msgstr ""
"一些網站[#]_不喜歡被程式瀏覽，或者向不同的瀏覽器發送不同的版本"
"[#]_。預設情況下，urllib 將自己標識為 ``Python-urllib/x.y``（其中 ``x`` 和 "
"``y`` 是 Python 版本的主要和次要版本號，例如 ``Python-urllib/2.5`` "
")，這可能會使網站感到困惑，或者根本無法正常工作。瀏覽器識別自身的方式是通過 "
"``User-Agent`` 標頭 [#]_。當您建立一個 Request "
"物件時，您可以傳入一個標頭字典。以下示例發出與上面相同的請求，"
"但將其自身標識為 Internet Explorer [#]_ 版本。 ::"

#: ../../howto/urllib2.rst:197
#, fuzzy
msgid ""
"The response also has two useful methods. See the section on `info and "
"geturl`_ which comes after we have a look at what happens when things go "
"wrong."
msgstr "響應還有兩個有用的方法。請參閱有關 info 和 geturl "
"的部分，該部分是在我們了解出現問題時會發生什麼之後出現的。"

#: ../../howto/urllib2.rst:202
#, fuzzy
msgid "Handling Exceptions"
msgstr "處理例外"

#: ../../howto/urllib2.rst:204
#, fuzzy
msgid ""
"*urlopen* raises :exc:`URLError` when it cannot handle a response (though as "
"usual with Python APIs, built-in exceptions such as :exc:`ValueError`, :exc:"
"`TypeError` etc. may also be raised)."
msgstr ""
"*urlopen* 在無法處理響應時引發 :exc:`URLError`（儘管與 Python API "
"一樣，也可能引發內建例外，例如 :exc:`ValueError`、:exc:`TypeError` 等） ."

#: ../../howto/urllib2.rst:208
#, fuzzy
msgid ""
":exc:`HTTPError` is the subclass of :exc:`URLError` raised in the specific "
"case of HTTP URLs."
msgstr ":exc:`HTTPError` 是 :exc:`URLError` 的子類別，在 HTTP URL 的特定情況下引發。"

#: ../../howto/urllib2.rst:211
#, fuzzy
msgid "The exception classes are exported from the :mod:`urllib.error` module."
msgstr "例外類是從 :mod:`urllib.error` 模組導出的。"

#: ../../howto/urllib2.rst:214
msgid "URLError"
msgstr "URLError"

#: ../../howto/urllib2.rst:216
#, fuzzy
msgid ""
"Often, URLError is raised because there is no network connection (no route "
"to the specified server), or the specified server doesn't exist.  In this "
"case, the exception raised will have a 'reason' attribute, which is a tuple "
"containing an error code and a text error message."
msgstr ""
"通常，引發 URLError 是因為沒有網絡連接（沒有到指定伺服器的路由），或者指定的"
"伺服器不存在。在這種情況下，引發的例外將具有“原因”屬性，它是一個包含錯誤程式"
"碼和文本錯誤消息的元組。"

#: ../../howto/urllib2.rst:221
#, fuzzy
msgid "e.g. ::"
msgstr "例如::"

#: ../../howto/urllib2.rst:232
msgid "HTTPError"
msgstr "HTTPError"

#: ../../howto/urllib2.rst:234
#, fuzzy
msgid ""
"Every HTTP response from the server contains a numeric \"status code\". "
"Sometimes the status code indicates that the server is unable to fulfil the "
"request. The default handlers will handle some of these responses for you "
"(for example, if the response is a \"redirection\" that requests the client "
"fetch the document from a different URL, urllib will handle that for you). "
"For those it can't handle, urlopen will raise an :exc:`HTTPError`. Typical "
"errors include '404' (page not found), '403' (request forbidden), and "
"'401' (authentication required)."
msgstr ""
"來自伺服器的每個 HTTP 響應都包含一個數字“狀態程式碼”。有時狀態程式碼表示服務"
"器無法滿足請求。預設處理程式將為您處理其中一些響應（例如，"
"如果響應是請求客戶端從不同 URL 獲取文檔的“重定向”，則 urllib "
"將為您處理）。對於它無法處理的那些，urlopen 將引發 :exc:`HTTPError`。典型錯誤"
"包括 ``404``（未找到頁面）、 ``403``（禁止請求）和 ``401``（需要身份驗證）。"

#: ../../howto/urllib2.rst:242
#, fuzzy
msgid ""
"See section 10 of :rfc:`2616` for a reference on all the HTTP error codes."
msgstr "有關所有 HTTP 錯誤程式碼的參考，請參閱 :rfc:`2616` 的第 10 節。"

#: ../../howto/urllib2.rst:244
#, fuzzy
msgid ""
"The :exc:`HTTPError` instance raised will have an integer 'code' attribute, "
"which corresponds to the error sent by the server."
msgstr "引發的 :exc:`HTTPError` 實例將具有整數“程式碼”屬性，對應於伺服器發送的錯誤。"

#: ../../howto/urllib2.rst:248
#, fuzzy
msgid "Error Codes"
msgstr "錯誤程式碼"

#: ../../howto/urllib2.rst:250
#, fuzzy
msgid ""
"Because the default handlers handle redirects (codes in the 300 range), and "
"codes in the 100--299 range indicate success, you will usually only see "
"error codes in the 400--599 range."
msgstr ""
"因為預設處理程式處理重定向（300 範圍內的程式碼），而 100--299 "
"範圍內的程式碼表示成功，您通常只會看到 400--599 範圍內的錯誤程式碼。"

#: ../../howto/urllib2.rst:254
#, fuzzy
msgid ""
":attr:`http.server.BaseHTTPRequestHandler.responses` is a useful dictionary "
"of response codes in that shows all the response codes used by :rfc:`2616`. "
"The dictionary is reproduced here for convenience ::"
msgstr ""
":attr:`http.server.BaseHTTPRequestHandler.responses` "
"是一個有用的響應程式碼字典，其中顯示了 :rfc:`2616` "
"使用的所有響應程式碼。為方便起見，在此轉載該詞典："

#: ../../howto/urllib2.rst:326
#, fuzzy
msgid ""
"When an error is raised the server responds by returning an HTTP error code "
"*and* an error page. You can use the :exc:`HTTPError` instance as a response "
"on the page returned. This means that as well as the code attribute, it also "
"has read, geturl, and info, methods as returned by the ``urllib.response`` "
"module::"
msgstr ""
"當出現錯誤時，伺服器通過回傳 HTTP 錯誤程式碼*和*錯誤頁面來響應。您可以使用 "
":exc:`HTTPError` 實例作為回傳頁面上的響應。這意味著除了 code 屬性外，"
"它還具有 read、geturl 和 info 方法，這些方法由 ``urllib.response`` 模組回傳："

#: ../../howto/urllib2.rst:346
#, fuzzy
msgid "Wrapping it Up"
msgstr "總結起來"

#: ../../howto/urllib2.rst:348
#, fuzzy
msgid ""
"So if you want to be prepared for :exc:`HTTPError` *or* :exc:`URLError` "
"there are two basic approaches. I prefer the second approach."
msgstr "因此，如果您想為 :exc:`HTTPError` *或* :exc:`URLError` "
"做好準備，有兩種基本方法。我更喜歡第二種方法。"

#: ../../howto/urllib2.rst:352
#, fuzzy
msgid "Number 1"
msgstr "1號"

#: ../../howto/urllib2.rst:374
#, fuzzy
msgid ""
"The ``except HTTPError`` *must* come first, otherwise ``except URLError`` "
"will *also* catch an :exc:`HTTPError`."
msgstr ""
"``except HTTPError`` *必須*先出現，否則 ``except URLError`` 也會*捕獲 "
":exc:`HTTPError`。"

#: ../../howto/urllib2.rst:378
#, fuzzy
msgid "Number 2"
msgstr "2號"

#: ../../howto/urllib2.rst:399
#, fuzzy
msgid "info and geturl"
msgstr "資訊和 geturl"

#: ../../howto/urllib2.rst:401
#, fuzzy
msgid ""
"The response returned by urlopen (or the :exc:`HTTPError` instance) has two "
"useful methods :meth:`info` and :meth:`geturl` and is defined in the module :"
"mod:`urllib.response`.."
msgstr ""
"urlopen 回傳的響應（或 :exc:`HTTPError` 實例）有兩個有用的方法 :meth:`info` "
"和 :meth:`geturl` 並在模組 :mod:`urllib.response` 中定義。"

#: ../../howto/urllib2.rst:405
#, fuzzy
msgid ""
"**geturl** - this returns the real URL of the page fetched. This is useful "
"because ``urlopen`` (or the opener object used) may have followed a "
"redirect. The URL of the page fetched may not be the same as the URL "
"requested."
msgstr ""
"**geturl** - 這將回傳所獲取頁面的真實 URL。這很有用，因為 "
"``urlopen``（或使用的開啟物件）可能遵循了重定向。獲取的頁面的 URL "
"可能與請求的 URL 不同。"

#: ../../howto/urllib2.rst:409
#, fuzzy
msgid ""
"**info** - this returns a dictionary-like object that describes the page "
"fetched, particularly the headers sent by the server. It is currently an :"
"class:`http.client.HTTPMessage` instance."
msgstr ""
"**info** - 這會回傳一個類似字典的物件，它描述了所獲取的頁面，尤其是伺服器發送"
"的標題。它目前是一個 :class:`http.client.HTTPMessage` 實例。"

#: ../../howto/urllib2.rst:413
#, fuzzy
msgid ""
"Typical headers include 'Content-length', 'Content-type', and so on. See the "
"`Quick Reference to HTTP Headers <https://jkorpela.fi/http.html>`_ for a "
"useful listing of HTTP headers with brief explanations of their meaning and "
"use."
msgstr ""
"典型的標頭包括 ``Content-length`` 、 ``Content-type`` 等。請參閱`HTTP 標頭快速參考 "
"<https://jkorpela.fi/http.html>`_ 以獲得有用的 HTTP "
"標頭列表及其含義和用途的簡要說明。"

#: ../../howto/urllib2.rst:420
#, fuzzy
msgid "Openers and Handlers"
msgstr "開瓶器和處理程式"

#: ../../howto/urllib2.rst:422
#, fuzzy
msgid ""
"When you fetch a URL you use an opener (an instance of the perhaps "
"confusingly named :class:`urllib.request.OpenerDirector`). Normally we have "
"been using the default opener - via ``urlopen`` - but you can create custom "
"openers. Openers use handlers. All the \"heavy lifting\" is done by the "
"handlers. Each handler knows how to open URLs for a particular URL scheme "
"(http, ftp, etc.), or how to handle an aspect of URL opening, for example "
"HTTP redirections or HTTP cookies."
msgstr ""
"當你獲取一個 URL 時，你會使用一個 opener（一個可能容易混淆的名字 "
":class:`urllib.request.OpenerDirector` 的實例）。"
"通常我們一直在使用預設的開啟器 - 通過 ``urlopen`` - 但您可以建立自定義開啟器"
"。開瓶器使用處理程式。所有“繁重的工作”都由處理程式完成。"
"每個處理程式都知道如何打開特定 URL 方案（http、ftp 等）的 URL，或者如何處理 "
"URL 打開的某個方面，例如 HTTP 重定向或 HTTP cookie。"

#: ../../howto/urllib2.rst:430
#, fuzzy
msgid ""
"You will want to create openers if you want to fetch URLs with specific "
"handlers installed, for example to get an opener that handles cookies, or to "
"get an opener that does not handle redirections."
msgstr "如果要獲取安裝了特定處理程式的 URL，則需要建立開啟器，例如獲取處理 cookie "
"的開啟器，或獲取不處理重定向的開啟器。"

#: ../../howto/urllib2.rst:434
#, fuzzy
msgid ""
"To create an opener, instantiate an ``OpenerDirector``, and then call ``."
"add_handler(some_handler_instance)`` repeatedly."
msgstr ""
"要建立一個開啟者，實例化一個 ``OpenerDirector``，然後重複呼叫 ``."
"add_handler(some_handler_instance)``。"

#: ../../howto/urllib2.rst:437
#, fuzzy
msgid ""
"Alternatively, you can use ``build_opener``, which is a convenience function "
"for creating opener objects with a single function call.  ``build_opener`` "
"adds several handlers by default, but provides a quick way to add more and/"
"or override the default handlers."
msgstr ""
"或者，您可以使用 ``build_opener``，這是一個方便的函式，"
"用於通過單個函式呼叫建立 opener 物件。 ``build_opener`` "
"預設新增幾個處理程式，但提供了一種快速新增更多和/或覆蓋預設處理程式的方法。"

#: ../../howto/urllib2.rst:442
#, fuzzy
msgid ""
"Other sorts of handlers you might want to can handle proxies, "
"authentication, and other common but slightly specialised situations."
msgstr "您可能想要的其他型別的處理程式可以處理代理、身份驗證和其他常見但稍微特殊的情"
"況。"

#: ../../howto/urllib2.rst:445
#, fuzzy
msgid ""
"``install_opener`` can be used to make an ``opener`` object the (global) "
"default opener. This means that calls to ``urlopen`` will use the opener you "
"have installed."
msgstr ""
"``install_opener`` 可用於使 ``opener`` 物件成為（全局）預設開啟器。"
"這意味著對 urlopen 的呼叫將使用您安裝的開啟器。"

#: ../../howto/urllib2.rst:449
#, fuzzy
msgid ""
"Opener objects have an ``open`` method, which can be called directly to "
"fetch urls in the same way as the ``urlopen`` function: there's no need to "
"call ``install_opener``, except as a convenience."
msgstr ""
"Opener 對像有一個 ``open`` 方法，可以像 ``urlopen`` 函式一樣直接呼叫它來獲取 "
"url：不需要呼叫 ``install_opener``，除非是為了方便。"

#: ../../howto/urllib2.rst:455
#, fuzzy
msgid "Basic Authentication"
msgstr "基本認證"

#: ../../howto/urllib2.rst:457
#, fuzzy
msgid ""
"To illustrate creating and installing a handler we will use the "
"``HTTPBasicAuthHandler``. For a more detailed discussion of this subject -- "
"including an explanation of how Basic Authentication works - see the `Basic "
"Authentication Tutorial <https://web.archive.org/web/20201215133350/http://"
"www.voidspace.org.uk/python/articles/authentication.shtml>`__."
msgstr ""
"為了說明建立和安裝處理程式，我們將使用 ``HTTPBasicAuthHandler``。有關此主題的"
"更詳細討論——包括基本身份驗證如何工作的解釋——請參閱“基本身份驗證教程”<https://"
"web.archive.org/web/20201215133350/http://www.voidspace.org。英國/python/"
"articles/authentication.shtml>`__。"

#: ../../howto/urllib2.rst:463
#, fuzzy
msgid ""
"When authentication is required, the server sends a header (as well as the "
"401 error code) requesting authentication.  This specifies the "
"authentication scheme and a 'realm'. The header looks like: ``WWW-"
"Authenticate: SCHEME realm=\"REALM\"``."
msgstr ""
"當需要身份驗證時，伺服器會發送請求身份驗證的標頭（以及 401 "
"錯誤程式碼）。這指定了身份驗證方案和“領域”。標題看起來像：``WWW-Authenticate:"
" SCHEME realm=\"REALM\"``。"

#: ../../howto/urllib2.rst:468
#, fuzzy
msgid "e.g."
msgstr "例如"

#: ../../howto/urllib2.rst:475
#, fuzzy
msgid ""
"The client should then retry the request with the appropriate name and "
"password for the realm included as a header in the request. This is 'basic "
"authentication'. In order to simplify this process we can create an instance "
"of ``HTTPBasicAuthHandler`` and an opener to use this handler."
msgstr ""
"然後，客戶端應使用包含在請求標頭中的領域的適當名稱和密碼重試請求。這是“基本身"
"份驗證”。為了簡化這個過程，我們可以建立一個 ``HTTPBasicAuthHandler`` "
"的實例和一個使用這個處理程式的開啟器。"

#: ../../howto/urllib2.rst:480
#, fuzzy
msgid ""
"The ``HTTPBasicAuthHandler`` uses an object called a password manager to "
"handle the mapping of URLs and realms to passwords and usernames. If you "
"know what the realm is (from the authentication header sent by the server), "
"then you can use a ``HTTPPasswordMgr``. Frequently one doesn't care what the "
"realm is. In that case, it is convenient to use "
"``HTTPPasswordMgrWithDefaultRealm``. This allows you to specify a default "
"username and password for a URL. This will be supplied in the absence of you "
"providing an alternative combination for a specific realm. We indicate this "
"by providing ``None`` as the realm argument to the ``add_password`` method."
msgstr ""
"``HTTPBasicAuthHandler`` 使用一個稱為密碼管理器的物件來處理 URL 和領域到密碼"
"和使用者名的映射。如果您知道領域是什麼（從伺服器發送的身份驗證標頭），"
"那麼您可以使用 ``HTTPPasswordMgr``。人們通常不關心領域是什麼。在這種情況下，"
"使用 ``HTTPPasswordMgrWithDefaultRealm`` 會很方便。這允許您為 URL 指定預設的"
"使用者名和密碼。這將在您沒有為特定領域提供替代組合的情況下提供。我們通過提供“"
"None”作為“add_password”方法的領域參數來表明這一點。"

#: ../../howto/urllib2.rst:490
#, fuzzy
msgid ""
"The top-level URL is the first URL that requires authentication. URLs "
"\"deeper\" than the URL you pass to .add_password() will also match. ::"
msgstr "頂級 URL 是第一個需要身份驗證的 URL。比您傳遞給 .add_password() 的 URL“更深”"
"的 URL 也將匹配。 ::"

#: ../../howto/urllib2.rst:515
#, fuzzy
msgid ""
"In the above example we only supplied our ``HTTPBasicAuthHandler`` to "
"``build_opener``. By default openers have the handlers for normal situations "
"-- ``ProxyHandler`` (if a proxy setting such as an :envvar:`http_proxy` "
"environment variable is set), ``UnknownHandler``, ``HTTPHandler``, "
"``HTTPDefaultErrorHandler``, ``HTTPRedirectHandler``, ``FTPHandler``, "
"``FileHandler``, ``DataHandler``, ``HTTPErrorProcessor``."
msgstr ""
"在上面的示例中，我們只將我們的 ``HTTPBasicAuthHandler`` 提供給 "
"``build_opener``。預設情況下，opener 具有正常情況下的處理程式——``ProxyHandler"
"``（如果設定了代理設定，例如 :envvar:`http_proxy` "
"環境變數），``UnknownHandler``，``HTTPHandler``，`` HTTPDefaultErrorHandler``"
"、``HTTPRedirectHandler``、``FTPHandler``、``FileHandler``、``DataHandler``、"
"``HTTPErrorProcessor``。"

#: ../../howto/urllib2.rst:522
#, fuzzy
msgid ""
"``top_level_url`` is in fact *either* a full URL (including the 'http:' "
"scheme component and the hostname and optionally the port number) e.g. "
"``\"http://example.com/\"`` *or* an \"authority\" (i.e. the hostname, "
"optionally including the port number) e.g. ``\"example.com\"`` or "
"``\"example.com:8080\"`` (the latter example includes a port number).  The "
"authority, if present, must NOT contain the \"userinfo\" component - for "
"example ``\"joe:password@example.com\"`` is not correct."
msgstr ""
"``top_level_url`` 實際上*要么*是一個完整的 "
"URL（包括“http:”方案組件和主機名以及可選的端口號），例如``\"http://example."
"com/\"`` *或*一個“權限”（即主機名，可選地包括端口號）例如``\"example.com\"`` "
"或 ``\"example.com:8080\""
"``（後一個示例包含端口號）。權限（如果存在）不得包含 ``userinfo`` 組件 - "
"例如“joe:password@example.com”是不正確的。"

#: ../../howto/urllib2.rst:532
#, fuzzy
msgid "Proxies"
msgstr "代理"

#: ../../howto/urllib2.rst:534
#, fuzzy
msgid ""
"**urllib** will auto-detect your proxy settings and use those. This is "
"through the ``ProxyHandler``, which is part of the normal handler chain when "
"a proxy setting is detected.  Normally that's a good thing, but there are "
"occasions when it may not be helpful [#]_. One way to do this is to setup "
"our own ``ProxyHandler``, with no proxies defined. This is done using "
"similar steps to setting up a `Basic Authentication`_ handler: ::"
msgstr ""
"**urllib** 將自動檢測您的代理設定並使用它們。這是通過 ``ProxyHandler`` 實作的，當"
"檢測到代理設定時，它是正常處理程式鏈的一部分。通常這是一件好事，"
"但有時它可能沒有幫助 [#]_。一種方法是設定我們自己的 ``ProxyHandler`` ，不定義任何"
"代理。這是使用與設定“基本身份驗證”處理程式類似的步驟完成的：::"

#: ../../howto/urllib2.rst:547
#, fuzzy
msgid ""
"Currently ``urllib.request`` *does not* support fetching of ``https`` "
"locations through a proxy.  However, this can be enabled by extending urllib."
"request as shown in the recipe [#]_."
msgstr ""
"當前 ``urllib.request`` *不* 支援通過代理獲取 ``https`` 位置。然而，"
"這可以通過擴充 urllib.request 來啟用，如食譜 [#]_ 所示。"

#: ../../howto/urllib2.rst:553
#, fuzzy
msgid ""
"``HTTP_PROXY`` will be ignored if a variable ``REQUEST_METHOD`` is set; see "
"the documentation on :func:`~urllib.request.getproxies`."
msgstr ""
"如果設定了變數“REQUEST_METHOD”，“HTTP_PROXY”將被忽略；請參閱有關 "
":func:`~urllib.request.getproxies` 的文檔。"

#: ../../howto/urllib2.rst:558
#, fuzzy
msgid "Sockets and Layers"
msgstr " socket 和層"

#: ../../howto/urllib2.rst:560
#, fuzzy
msgid ""
"The Python support for fetching resources from the web is layered.  urllib "
"uses the :mod:`http.client` library, which in turn uses the socket library."
msgstr ""
"Python 對從 Web 獲取資源的支援是分層的。 urllib 使用 :mod:`http.client` 庫，"
"後者又使用 socket 庫。"

#: ../../howto/urllib2.rst:563
#, fuzzy
msgid ""
"As of Python 2.3 you can specify how long a socket should wait for a "
"response before timing out. This can be useful in applications which have to "
"fetch web pages. By default the socket module has *no timeout* and can hang. "
"Currently, the socket timeout is not exposed at the http.client or urllib."
"request levels. However, you can set the default timeout globally for all "
"sockets using ::"
msgstr ""
"從 Python 2.3 開始，您可以指定 socket 在超時之前應等待響應的時間。這在必須獲取"
"網頁的應用程式中很有用。預設情況下， socket 模組*沒有超時*並且可以掛起。目前，"
" socket 超時未在 http.client 或 urllib.request 級別公開。但是，您可以使用 :: "
"為所有 socket 全局設定預設超時"

#: ../../howto/urllib2.rst:586
msgid "Footnotes"
msgstr "註解"

#: ../../howto/urllib2.rst:588
#, fuzzy
msgid "This document was reviewed and revised by John Lee."
msgstr "本文檔由 John Lee 審閱和修訂。"

#: ../../howto/urllib2.rst:590
#, fuzzy
msgid "Google for example."
msgstr "以穀歌為例。"

#: ../../howto/urllib2.rst:591
#, fuzzy
msgid ""
"Browser sniffing is a very bad practice for website design - building sites "
"using web standards is much more sensible. Unfortunately a lot of sites "
"still send different versions to different browsers."
msgstr ""
"瀏覽器嗅探對於網站設計來說是一種非常糟糕的做法——使用網絡標準構建網站更為明智"
"。不幸的是，許多站點仍然向不同的瀏覽器發送不同的版本。"

#: ../../howto/urllib2.rst:594
#, fuzzy
msgid ""
"The user agent for MSIE 6 is *'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT "
"5.1; SV1; .NET CLR 1.1.4322)'*"
msgstr ""
"MSIE 6 的使用者代理是 *'Mozilla/4.0（相容；MSIE 6.0；Windows NT 5.1；SV1；."
"NET CLR 1.1.4322）'*"

#: ../../howto/urllib2.rst:596
#, fuzzy
msgid ""
"For details of more HTTP request headers, see `Quick Reference to HTTP "
"Headers`_."
msgstr "有關更多 HTTP 請求標頭的詳細資訊，請參閱`HTTP 標頭快速參考`_。"

#: ../../howto/urllib2.rst:598
#, fuzzy
msgid ""
"In my case I have to use a proxy to access the internet at work. If you "
"attempt to fetch *localhost* URLs through this proxy it blocks them. IE is "
"set to use the proxy, which urllib picks up on. In order to test scripts "
"with a localhost server, I have to prevent urllib from using the proxy."
msgstr ""
"就我而言，我必須使用代理才能在工作中訪問網際網路。如果您嘗試通過此代理獲取 "
"*localhost* URL，它會阻止它們。 IE 設定為使用代理，urllib "
"將在其上拾取。為了使用本地主機伺服器測試腳本，我必須阻止 urllib 使用代理。"

#: ../../howto/urllib2.rst:603
#, fuzzy
msgid ""
"urllib opener for SSL proxy (CONNECT method): `ASPN Cookbook Recipe <https://"
"code.activestate.com/recipes/456195/>`_."
msgstr ""
"SSL 代理的 urllib 開啟器（CONNECT 方法）：`ASPN Cookbook Recipe <https://code"
".activestate.com/recipes/456195/>`_。"
