# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-14 00:14+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../howto/enum.rst:3
#, fuzzy
msgid "Enum HOWTO"
msgstr "枚舉指南"

#: ../../howto/enum.rst:9
#, fuzzy
msgid ""
"An :class:`Enum` is a set of symbolic names bound to unique values.  They "
"are similar to global variables, but they offer a more useful :func:"
"`repr()`, grouping, type-safety, and a few other features."
msgstr ""
":class:`Enum` 是一組綁定到唯一值的符號名稱。它們類似於全局變數，"
"但它們提供了更有用的 :func:`repr()`、分組、型別安全和一些其他功能。"

#: ../../howto/enum.rst:13
#, fuzzy
msgid ""
"They are most useful when you have a variable that can take one of a limited "
"selection of values.  For example, the days of the week::"
msgstr "當您有一個可以採用有限的值選擇之一的變數時，它們最有用。例如，星期幾::"

#: ../../howto/enum.rst:26
#, fuzzy
msgid "Or perhaps the RGB primary colors::"
msgstr "或者也許是 RGB 原色::"

#: ../../howto/enum.rst:34
#, fuzzy
msgid ""
"As you can see, creating an :class:`Enum` is as simple as writing a class "
"that inherits from :class:`Enum` itself."
msgstr "如您所見，建立 Enum 就像編寫一個繼承自 Enum 本身的類一樣簡單。"

#: ../../howto/enum.rst:37
#, fuzzy
msgid "Case of Enum Members"
msgstr "枚舉成員案例"

#: ../../howto/enum.rst:39
#, fuzzy
msgid ""
"Because Enums are used to represent constants we recommend using UPPER_CASE "
"names for members, and will be using that style in our examples."
msgstr "因為枚舉用於表示常數，所以我們建議為成員使用 UPPER_CASE "
"名稱，並將在我們的示例中使用該樣式。"

#: ../../howto/enum.rst:42
#, fuzzy
msgid ""
"Depending on the nature of the enum a member's value may or may not be "
"important, but either way that value can be used to get the corresponding "
"member::"
msgstr "根據枚舉的性質，成員的值可能重要也可能不重要，但無論哪種方式，該值都可用於獲"
"取相應的成員::"

#: ../../howto/enum.rst:49
#, fuzzy
msgid ""
"As you can see, the ``repr()`` of a member shows the enum name, the member "
"name, and the value.  The ``str()`` of a member shows only the enum name and "
"member name::"
msgstr "如您所見，成員的 ``repr()`` 顯示枚舉名稱、成員名稱和值。成員的 ``str()`` "
"僅顯示枚舉名稱和成員名稱::"

#: ../../howto/enum.rst:56
#, fuzzy
msgid "The *type* of an enumeration member is the enum it belongs to::"
msgstr "枚舉成員的 *type* 是它所屬的枚舉::"

#: ../../howto/enum.rst:63
#, fuzzy
msgid "Enum members have an attribute that contains just their :attr:`name`::"
msgstr "枚舉成員有一個屬性只包含他們的 :attr:`name`::"

#: ../../howto/enum.rst:68
#, fuzzy
msgid "Likewise, they have an attribute for their :attr:`value`::"
msgstr "同樣，它們的 :attr:`value`:: 也有一個屬性："

#: ../../howto/enum.rst:74
#, fuzzy
msgid ""
"Unlike many languages that treat enumerations solely as name/value pairs, "
"Python Enums can have behavior added.  For example, :class:`datetime.date` "
"has two methods for returning the weekday: :meth:`weekday` and :meth:"
"`isoweekday`. The difference is that one of them counts from 0-6 and the "
"other from 1-7. Rather than keep track of that ourselves we can add a method "
"to the :class:`Weekday` enum to extract the day from the :class:`date` "
"instance and return the matching enum member::"
msgstr ""
"與許多僅將枚舉視為名稱/值對的語言不同，Python "
"枚舉可以新增行為。例如，:class:`datetime.date` "
"有兩種回傳工作日的方法：:meth:`weekday` 和 :meth:`isoweekday`。不同之處在於，"
"其中一個從 0-6 計數，另一個從 1-7 計數。我們可以向 :class:`Weekday` "
"枚舉新增一個方法，以從 :class:`date` "
"實例中提取日期並回傳匹配的枚舉成員，而不是我們自己跟踪它："

#: ../../howto/enum.rst:86
#, fuzzy
msgid "The complete :class:`Weekday` enum now looks like this::"
msgstr "完整的 :class:`Weekday` 枚舉現在看起來像這樣："

#: ../../howto/enum.rst:101
#, fuzzy
msgid "Now we can find out what today is!  Observe::"
msgstr "現在我們可以找出今天是什麼日子了！觀察：："

#: ../../howto/enum.rst:107
#, fuzzy
msgid ""
"Of course, if you're reading this on some other day, you'll see that day "
"instead."
msgstr "當然，如果您在其他某天閱讀本文，您會看到那一天。"

#: ../../howto/enum.rst:109
#, fuzzy
msgid ""
"This :class:`Weekday` enum is great if our variable only needs one day, but "
"what if we need several?  Maybe we're writing a function to plot chores "
"during a week, and don't want to use a :class:`list` -- we could use a "
"different type of :class:`Enum`::"
msgstr ""
"如果我們的變數只需要一天，這個 :class:`Weekday` 枚舉很好，但是如果我們需要多"
"天呢？也許我們正在編寫一個函式來繪製一周內的瑣事，並且不想使用 :class:`list` "
"-- 我們可以使用不同型別的 :class:`Enum`::"

#: ../../howto/enum.rst:124
#, fuzzy
msgid ""
"We've changed two things: we're inherited from :class:`Flag`, and the values "
"are all powers of 2."
msgstr "我們改變了兩件事：我們繼承自 :class:`Flag`，並且值都是 2 的冪。"

#: ../../howto/enum.rst:127
#, fuzzy
msgid ""
"Just like the original :class:`Weekday` enum above, we can have a single "
"selection::"
msgstr "就像上面原始的 :class:`Weekday` 枚舉一樣，我們可以有一個選擇::"

#: ../../howto/enum.rst:133
#, fuzzy
msgid ""
"But :class:`Flag` also allows us to combine several members into a single "
"variable::"
msgstr "但是 :class:`Flag` 還允許我們將多個成員組合成一個變數::"

#: ../../howto/enum.rst:140
#, fuzzy
msgid "You can even iterate over a :class:`Flag` variable::"
msgstr "你甚至可以疊代一個 :class:`Flag` 變數::"

#: ../../howto/enum.rst:147
#, fuzzy
msgid "Okay, let's get some chores set up::"
msgstr "好的，讓我們設定一些雜務::"

#: ../../howto/enum.rst:155
#, fuzzy
msgid "And a function to display the chores for a given day::"
msgstr "以及顯示給定日期的雜務的功能::"

#: ../../howto/enum.rst:164
#, fuzzy
msgid ""
"In cases where the actual values of the members do not matter, you can save "
"yourself some work and use :func:`auto()` for the values::"
msgstr "在成員的實際值無關緊要的情況下，您可以節省一些工作並使用 :func:`auto()` "
"作為值::"

#: ../../howto/enum.rst:183
#, fuzzy
msgid "Programmatic access to enumeration members and their attributes"
msgstr "對枚舉成員及其屬性的編程訪問"

#: ../../howto/enum.rst:185
#, fuzzy
msgid ""
"Sometimes it's useful to access members in enumerations programmatically (i."
"e. situations where ``Color.RED`` won't do because the exact color is not "
"known at program-writing time).  ``Enum`` allows such access::"
msgstr ""
"有時，以編程方式訪問枚舉中的成員很有用（即，``Color.RED`` "
"不會這樣做的情況，因為在編寫程式時不知道確切的顏色）。 ``Enum`` "
"允許這樣的訪問::"

#: ../../howto/enum.rst:194
#, fuzzy
msgid "If you want to access enum members by *name*, use item access::"
msgstr "如果你想通過 *name* 訪問枚舉成員，使用 item access::"

#: ../../howto/enum.rst:201
#, fuzzy
msgid "If you have an enum member and need its :attr:`name` or :attr:`value`::"
msgstr "如果你有一個枚舉成員並且需要它的 :attr:`name` 或 :attr:`value`::"

#: ../../howto/enum.rst:211
#, fuzzy
msgid "Duplicating enum members and values"
msgstr "複製枚舉成員和值"

#: ../../howto/enum.rst:213
#, fuzzy
msgid "Having two enum members with the same name is invalid::"
msgstr "有兩個同名的枚舉成員是無效的::"

#: ../../howto/enum.rst:223
#, fuzzy
msgid ""
"However, an enum member can have other names associated with it.  Given two "
"entries ``A`` and ``B`` with the same value (and ``A`` defined first), ``B`` "
"is an alias for the member ``A``.  By-value lookup of the value of ``A`` "
"will return the member ``A``.  By-name lookup of ``A`` will return the "
"member ``A``. By-name lookup of ``B`` will also return the member ``A``::"
msgstr ""
"但是，枚舉成員可以有其他名稱與之關聯。給定兩個具有相同值的條目 ``A``和 ``B``（並且“"
"A”首先定義）， ``B``是成員 ``A``的別名。按值查找 ``A``的值將回傳成員 ``A``。 ``A`` "
"的按名稱查找將回傳成員 ``A``。 ``B`` 的按名稱查找也將回傳成員 ``A``::"

#: ../../howto/enum.rst:244
#, fuzzy
msgid ""
"Attempting to create a member with the same name as an already defined "
"attribute (another member, a method, etc.) or attempting to create an "
"attribute with the same name as a member is not allowed."
msgstr "不允許嘗試建立與已定義屬性（另一個成員、方法等）同名的成員或嘗試建立與成員同"
"名的屬性。"

#: ../../howto/enum.rst:250
#, fuzzy
msgid "Ensuring unique enumeration values"
msgstr "確保唯一的枚舉值"

#: ../../howto/enum.rst:252
#, fuzzy
msgid ""
"By default, enumerations allow multiple names as aliases for the same value. "
"When this behavior isn't desired, you can use the :func:`unique` decorator::"
msgstr "預設情況下，枚舉允許多個名稱作為同一值的別名。當不需要這種行為時，您可以使用 "
":func:`unique` 裝飾器::"

#: ../../howto/enum.rst:269
#, fuzzy
msgid "Using automatic values"
msgstr "使用自動值"

#: ../../howto/enum.rst:271
#, fuzzy
msgid "If the exact value is unimportant you can use :class:`auto`::"
msgstr "如果確切的值不重要，你可以使用 :class:`auto`::"

#: ../../howto/enum.rst:282
#, fuzzy
msgid ""
"The values are chosen by :func:`_generate_next_value_`, which can be "
"overridden::"
msgstr "這些值由 :func:`_generate_next_value_` 選擇，它可以被覆蓋::"

#: ../../howto/enum.rst:300
#, fuzzy
msgid ""
"The :meth:`_generate_next_value_` method must be defined before any members."
msgstr ":meth:`_generate_next_value_` 方法必須在任何成員之前定義。"

#: ../../howto/enum.rst:303
#, fuzzy
msgid "Iteration"
msgstr "疊代"

#: ../../howto/enum.rst:305
#, fuzzy
msgid "Iterating over the members of an enum does not provide the aliases::"
msgstr "疊代枚舉的成員不提供別名::"

#: ../../howto/enum.rst:312
#, fuzzy
msgid ""
"Note that the aliases ``Shape.ALIAS_FOR_SQUARE`` and ``Weekday.WEEKEND`` "
"aren't shown."
msgstr "請注意，別名“Shape.ALIAS_FOR_SQUARE”和“Weekday.WEEKEND”未顯示。"

#: ../../howto/enum.rst:314
#, fuzzy
msgid ""
"The special attribute ``__members__`` is a read-only ordered mapping of "
"names to members.  It includes all names defined in the enumeration, "
"including the aliases::"
msgstr "特殊屬性 __members__ "
"是名稱到成員的只讀有序映射。它包括枚舉中定義的所有名稱，包括別名::"

#: ../../howto/enum.rst:326
#, fuzzy
msgid ""
"The ``__members__`` attribute can be used for detailed programmatic access "
"to the enumeration members.  For example, finding all the aliases::"
msgstr "``__members__`` 屬性可用於對枚舉成員進行詳細的編程訪問。例如，查找所有別名::"

#: ../../howto/enum.rst:334
#, fuzzy
msgid ""
"Aliases for flags include values with multiple flags set, such as ``3``, and "
"no flags set, i.e. ``0``."
msgstr "旗標的別名包括設定了多個旗標的值，例如 ``3``，以及沒有設定旗標的值，即 ``0``。"

#: ../../howto/enum.rst:339
#, fuzzy
msgid "Comparisons"
msgstr "比較"

#: ../../howto/enum.rst:341
#, fuzzy
msgid "Enumeration members are compared by identity::"
msgstr "枚舉成員按身份比較::"

#: ../../howto/enum.rst:350
#, fuzzy
msgid ""
"Ordered comparisons between enumeration values are *not* supported.  Enum "
"members are not integers (but see `IntEnum`_ below)::"
msgstr "*不*支援枚舉值之間的有序比較。枚舉成員不是整數（但請參閱下面的 ``IntEnum`` ）：："

#: ../../howto/enum.rst:358
#, fuzzy
msgid "Equality comparisons are defined though::"
msgstr "雖然定義了相等比較::"

#: ../../howto/enum.rst:367
#, fuzzy
msgid ""
"Comparisons against non-enumeration values will always compare not equal "
"(again, :class:`IntEnum` was explicitly designed to behave differently, see "
"below)::"
msgstr "與非枚舉值的比較將始終比較不相等（同樣，IntEnum "
"被明確設計為表現不同，見下文）：："

#: ../../howto/enum.rst:376
#, fuzzy
msgid ""
"It is possible to reload modules -- if a reloaded module contains enums, "
"they will be recreated, and the new members may not compare identical/equal "
"to the original members."
msgstr "可以重新加載模組——如果重新加載的模組包含枚舉，它們將被重新建立，並且新成員可"
"能不會與原始成員比較相同/相等。"

#: ../../howto/enum.rst:381
#, fuzzy
msgid "Allowed members and attributes of enumerations"
msgstr "枚舉的允許成員和屬性"

#: ../../howto/enum.rst:383
#, fuzzy
msgid ""
"Most of the examples above use integers for enumeration values.  Using "
"integers is short and handy (and provided by default by the `Functional "
"API`_), but not strictly enforced.  In the vast majority of use-cases, one "
"doesn't care what the actual value of an enumeration is.  But if the value "
"*is* important, enumerations can have arbitrary values."
msgstr ""
"上面的大多數示例都使用整數作為枚舉值。使用整數既簡短又方便（預設情況下由 `"
"Functional API`_ 提供），但並未嚴格執行。在絕大多數用例中，人們並不關心枚舉的"
"實際值是多少。但是如果值*很重要，枚舉可以有任意值。"

#: ../../howto/enum.rst:389
#, fuzzy
msgid ""
"Enumerations are Python classes, and can have methods and special methods as "
"usual.  If we have this enumeration::"
msgstr "枚舉是 Python 類，可以像往常一樣具有方法和特殊方法。如果我們有這個枚舉::"

#: ../../howto/enum.rst:409
#, fuzzy
msgid "Then::"
msgstr "然後：："

#: ../../howto/enum.rst:418
#, fuzzy
msgid ""
"The rules for what is allowed are as follows: names that start and end with "
"a single underscore are reserved by enum and cannot be used; all other "
"attributes defined within an enumeration will become members of this "
"enumeration, with the exception of special methods (:meth:`__str__`, :meth:"
"`__add__`, etc.), descriptors (methods are also descriptors), and variable "
"names listed in :attr:`_ignore_`."
msgstr ""
"允許的規則如下：以單個底線開頭和結尾的名稱是枚舉保留的，不能使用；枚舉中定"
"義的所有其他屬性都將成為該枚舉的成員，特殊方法（:meth:`__str__`、:meth:`__add"
"__` 等）、描述器（方法也是描述器）和變數名除外在 :attr:`_ignore_` 中列出。"

#: ../../howto/enum.rst:425
#, fuzzy
msgid ""
"Note:  if your enumeration defines :meth:`__new__` and/or :meth:`__init__` "
"then any value(s) given to the enum member will be passed into those "
"methods. See `Planet`_ for an example."
msgstr ""
"注意：如果您的枚舉定義了 :meth:`__new__` 和/或 :meth:`__init__` "
"那麼任何賦予枚舉成員的值都將被傳遞到這些方法中。有關示例，請參見“行星”。"

#: ../../howto/enum.rst:431
#, fuzzy
msgid "Restricted Enum subclassing"
msgstr "受限枚舉子類別化"

#: ../../howto/enum.rst:433
#, fuzzy
msgid ""
"A new :class:`Enum` class must have one base enum class, up to one concrete "
"data type, and as many :class:`object`-based mixin classes as needed.  The "
"order of these base classes is::"
msgstr ""
"一個新的 :class:`Enum` 類必須有一個基本枚舉類，最多一種具體資料型別，"
"以及根據需要盡可能多的基於 :class:`object` 的混合類。這些基底類別的順序是："

#: ../../howto/enum.rst:440
#, fuzzy
msgid ""
"Also, subclassing an enumeration is allowed only if the enumeration does not "
"define any members.  So this is forbidden::"
msgstr "此外，僅當枚舉未定義任何成員時才允許對枚舉進行子類別化。所以這是被禁止的::"

#: ../../howto/enum.rst:450
#, fuzzy
msgid "But this is allowed::"
msgstr "但這是允許的::"

#: ../../howto/enum.rst:461
#, fuzzy
msgid ""
"Allowing subclassing of enums that define members would lead to a violation "
"of some important invariants of types and instances.  On the other hand, it "
"makes sense to allow sharing some common behavior between a group of "
"enumerations. (See `OrderedEnum`_ for an example.)"
msgstr ""
"允許對定義成員的枚舉進行子類別化會導致違反型別和實例的一些重要不變數。另一方"
"面，允許在一組枚舉之間共享一些共同的行為是有意義的。 （有關示例，請參見 "
"`OrderedEnum`_。）"

#: ../../howto/enum.rst:468
#, fuzzy
msgid "Pickling"
msgstr "酸洗"

#: ../../howto/enum.rst:470
#, fuzzy
msgid "Enumerations can be pickled and unpickled::"
msgstr "枚舉可以被 pickled 和 unpickled::"

#: ../../howto/enum.rst:477
#, fuzzy
msgid ""
"The usual restrictions for pickling apply: picklable enums must be defined "
"in the top level of a module, since unpickling requires them to be "
"importable from that module."
msgstr "pickling 的通常限制適用：picklable 枚舉必須在模組的頂層定義，因為 unpickling "
"要求它們可以從該模組導入。"

#: ../../howto/enum.rst:483
#, fuzzy
msgid ""
"With pickle protocol version 4 it is possible to easily pickle enums nested "
"in other classes."
msgstr "使用 pickle 協定版本 4，可以輕鬆地 pickle 嵌套在其他類中的枚舉。"

#: ../../howto/enum.rst:486
#, fuzzy
msgid ""
"It is possible to modify how enum members are pickled/unpickled by defining :"
"meth:`__reduce_ex__` in the enumeration class."
msgstr "可以通過在枚舉類中定義 :meth:`__reduce_ex__` 來修改枚舉成員的 pickled/"
"unpickled 方式。"

#: ../../howto/enum.rst:491
#, fuzzy
msgid "Functional API"
msgstr "函式式API"

#: ../../howto/enum.rst:493
#, fuzzy
msgid ""
"The :class:`Enum` class is callable, providing the following functional API::"
msgstr ":class:`Enum` 類是可呼叫的，提供以下功能 API::"

#: ../../howto/enum.rst:503
#, fuzzy
msgid ""
"The semantics of this API resemble :class:`~collections.namedtuple`. The "
"first argument of the call to :class:`Enum` is the name of the enumeration."
msgstr "此 API 的語義類似於 :class:`~collections.namedtuple`。呼叫 Enum "
"的第一個參數是枚舉的名稱。"

#: ../../howto/enum.rst:506
#, fuzzy
msgid ""
"The second argument is the *source* of enumeration member names.  It can be "
"a whitespace-separated string of names, a sequence of names, a sequence of 2-"
"tuples with key/value pairs, or a mapping (e.g. dictionary) of names to "
"values.  The last two options enable assigning arbitrary values to "
"enumerations; the others auto-assign increasing integers starting with 1 "
"(use the ``start`` parameter to specify a different starting value).  A new "
"class derived from :class:`Enum` is returned.  In other words, the above "
"assignment to :class:`Animal` is equivalent to::"
msgstr ""
"第二個參數是枚舉成員名稱的*來源*。它可以是以空格分隔的名稱字串、名稱序列、具"
"有鍵/值對的二元組序列或名稱到值的映射（例如字典）。最後兩個選項允許為枚舉分配"
"任意值；其他自動分配從 1 開始遞增的整數（使用 ``start`` "
"參數指定不同的起始值）。回傳一個派生自 Enum 的新類。換句話說，上面對 "
":class:`Animal` 的賦值等同於："

#: ../../howto/enum.rst:522
#, fuzzy
msgid ""
"The reason for defaulting to ``1`` as the starting number and not ``0`` is "
"that ``0`` is ``False`` in a boolean sense, but by default enum members all "
"evaluate to ``True``."
msgstr ""
"預設為 ``1`` 而不是 ``0`` 的原因是 ``0`` 在布爾意義上是 ``False``，"
"但預設情況下枚舉成員都評估為 ``True ``。"

#: ../../howto/enum.rst:526
#, fuzzy
msgid ""
"Pickling enums created with the functional API can be tricky as frame stack "
"implementation details are used to try and figure out which module the "
"enumeration is being created in (e.g. it will fail if you use a utility "
"function in a separate module, and also may not work on IronPython or "
"Jython). The solution is to specify the module name explicitly as follows::"
msgstr ""
"使用函式式 API 建立的 Pickling 枚舉可能很棘手，因為框架堆疊實作細節用於嘗試找"
"出枚舉是在哪個模組中建立的（例如，如果您在單獨的模組中使用實用程式函式，它將"
"失敗，也可能不會在 IronPython 或 Jython "
"上工作）。解決方案是顯式指定模組名稱，如下所示："

#: ../../howto/enum.rst:536
#, fuzzy
msgid ""
"If ``module`` is not supplied, and Enum cannot determine what it is, the new "
"Enum members will not be unpicklable; to keep errors closer to the source, "
"pickling will be disabled."
msgstr "如果未提供 ``module``，並且 Enum 無法確定它是什麼，則新的 Enum "
"成員將無法取消選擇；為了使錯誤更接近源頭，酸洗將被禁用。"

#: ../../howto/enum.rst:540
#, fuzzy
msgid ""
"The new pickle protocol 4 also, in some circumstances, relies on :attr:"
"`~definition.__qualname__` being set to the location where pickle will be "
"able to find the class.  For example, if the class was made available in "
"class SomeData in the global scope::"
msgstr ""
"在某些情況下，新的 pickle 協定 4 還依賴於 :attr:`~definition.__qualname__` "
"被設定為 pickle 能夠找到類的位置。例如，如果該類在全局範圍內的 SomeData "
"類中可用："

#: ../../howto/enum.rst:547
#, fuzzy
msgid "The complete signature is::"
msgstr "完整的簽名是："

#: ../../howto/enum.rst:0
#, fuzzy
msgid "value"
msgstr "價值"

#: ../../howto/enum.rst:559
#, fuzzy
msgid "What the new enum class will record as its name."
msgstr "新的枚舉類將記錄什麼作為它的名字。"

#: ../../howto/enum.rst:0
#, fuzzy
msgid "names"
msgstr "名字"

#: ../../howto/enum.rst:561
#, fuzzy
msgid ""
"The enum members.  This can be a whitespace- or comma-separated string "
"(values will start at 1 unless otherwise specified)::"
msgstr "枚舉成員。這可以是空格或逗號分隔的字串（除非另有說明，否則值將從 1 開始）："

#: ../../howto/enum.rst:566
#, fuzzy
msgid "or an iterator of names::"
msgstr "或名稱的疊代器::"

#: ../../howto/enum.rst:570
#, fuzzy
msgid "or an iterator of (name, value) pairs::"
msgstr "或 (name, value) 對的疊代器::"

#: ../../howto/enum.rst:574
#, fuzzy
msgid "or a mapping::"
msgstr "或映射::"

#: ../../howto/enum.rst:0
#, fuzzy
msgid "module"
msgstr "模組"

#: ../../howto/enum.rst:578
#, fuzzy
msgid "name of module where new enum class can be found."
msgstr "可以找到新枚舉類的模組名稱。"

#: ../../howto/enum.rst:0
#, fuzzy
msgid "qualname"
msgstr "質量名稱"

#: ../../howto/enum.rst:580
#, fuzzy
msgid "where in module new enum class can be found."
msgstr "在模組中可以找到新枚舉類的位置。"

#: ../../howto/enum.rst:0
#, fuzzy
msgid "type"
msgstr "型別"

#: ../../howto/enum.rst:582
#, fuzzy
msgid "type to mix in to new enum class."
msgstr "鍵入以混合到新的枚舉類中。"

#: ../../howto/enum.rst:0
#, fuzzy
msgid "start"
msgstr "開始"

#: ../../howto/enum.rst:584
#, fuzzy
msgid "number to start counting at if only names are passed in."
msgstr "如果只傳入名稱，則開始計數的數字。"

#: ../../howto/enum.rst:586
#, fuzzy
msgid "The *start* parameter was added."
msgstr "新增了 *start* 參數。"

#: ../../howto/enum.rst:591
#, fuzzy
msgid "Derived Enumerations"
msgstr "派生枚舉"

#: ../../howto/enum.rst:594
#, fuzzy
msgid "IntEnum"
msgstr "整數枚舉"

#: ../../howto/enum.rst:596
#, fuzzy
msgid ""
"The first variation of :class:`Enum` that is provided is also a subclass of :"
"class:`int`.  Members of an :class:`IntEnum` can be compared to integers; by "
"extension, integer enumerations of different types can also be compared to "
"each other::"
msgstr "提供的 Enum 的第一個變體也是 int 的子類別。 IntEnum "
"的成員可以與整數進行比較；通過擴充，不同型別的整數枚舉也可以相互比較："

#: ../../howto/enum.rst:617
#, fuzzy
msgid ""
"However, they still can't be compared to standard :class:`Enum` "
"enumerations::"
msgstr "然而，它們仍然無法與標準的 Enum 枚舉相比較："

#: ../../howto/enum.rst:630
#, fuzzy
msgid ""
":class:`IntEnum` values behave like integers in other ways you'd expect::"
msgstr ":class:`IntEnum` 值在您期望的其他方面表現得像整數::"

#: ../../howto/enum.rst:641
#, fuzzy
msgid "StrEnum"
msgstr "鍊錶"

#: ../../howto/enum.rst:643
#, fuzzy
msgid ""
"The second variation of :class:`Enum` that is provided is also a subclass "
"of :class:`str`.  Members of a :class:`StrEnum` can be compared to strings; "
"by extension, string enumerations of different types can also be compared to "
"each other."
msgstr ""
"提供的 Enum 的第二個變體也是 str 的子類別。 :class:`StrEnum` "
"的成員可以與字串進行比較；推而廣之，不同型別的字串枚舉也可以相互比較。"

#: ../../howto/enum.rst:652
#, fuzzy
msgid "IntFlag"
msgstr "旗標位"

#: ../../howto/enum.rst:654
#, fuzzy
msgid ""
"The next variation of :class:`Enum` provided, :class:`IntFlag`, is also "
"based on :class:`int`.  The difference being :class:`IntFlag` members can be "
"combined using the bitwise operators (&, \\|, ^, ~) and the result is still "
"an :class:`IntFlag` member, if possible.  Like :class:`IntEnum`, :class:"
"`IntFlag` members are also integers and can be used wherever an :class:`int` "
"is used."
msgstr ""
"提供的 Enum 的下一個變體 IntFlag 也是基於 int "
"的。不同之處在於 :class:`IntFlag` 成員可以使用按位運算符（&、\\"
"|、^、~）組合，如果可能的話，結果仍然是 :class:`IntFlag` 成員。與 IntEnum "
"一樣，IntFlag 成員也是整數，可以在任何使用 int 的地方使用。"

#: ../../howto/enum.rst:662
#, fuzzy
msgid ""
"Any operation on an :class:`IntFlag` member besides the bit-wise operations "
"will lose the :class:`IntFlag` membership."
msgstr "除按位操作外，對 IntFlag 成員的任何操作都將失去 IntFlag 成員資格。"

#: ../../howto/enum.rst:665
#, fuzzy
msgid ""
"Bit-wise operations that result in invalid :class:`IntFlag` values will lose "
"the :class:`IntFlag` membership.  See :class:`FlagBoundary` for details."
msgstr ""
"導致無效 :class:`IntFlag` 值的按位運算將失去 :class:`IntFlag` "
"成員資格。有關詳細資訊，請參閱 :class:`FlagBoundary`。"

#: ../../howto/enum.rst:672
#, fuzzy
msgid "Sample :class:`IntFlag` class::"
msgstr "示例 :class:`IntFlag` 類：："

#: ../../howto/enum.rst:688
#, fuzzy
msgid "It is also possible to name the combinations::"
msgstr "也可以命名組合::"

#: ../../howto/enum.rst:704
#, fuzzy
msgid ""
"Named combinations are considered aliases.  Aliases do not show up during "
"iteration, but can be returned from by-value lookups."
msgstr "命名組合被視為別名。別名在疊代期間不會出現，但可以從按值查找回傳。"

#: ../../howto/enum.rst:709
#, fuzzy
msgid ""
"Another important difference between :class:`IntFlag` and :class:`Enum` is "
"that if no flags are set (the value is 0), its boolean evaluation is :data:"
"`False`::"
msgstr ""
":class:`IntFlag` 和 :class:`Enum` 之間的另一個重要區別是，如果沒有設定旗標（"
"值為 0），其布爾值評估為 :data:`False`::"

#: ../../howto/enum.rst:717
#, fuzzy
msgid ""
"Because :class:`IntFlag` members are also subclasses of :class:`int` they "
"can be combined with them (but may lose :class:`IntFlag` membership::"
msgstr ""
"因為 :class:`IntFlag` 成員也是 :class:`int` "
"的子類別，所以它們可以與它們組合（但可能會失去 :class:`IntFlag` 成員資格::"

#: ../../howto/enum.rst:728
#, fuzzy
msgid ""
"The negation operator, ``~``, always returns an :class:`IntFlag` member with "
"a positive value::"
msgstr "否定運算符 ``~`` 總是回傳一個具有正值的 IntFlag 成員::"

#: ../../howto/enum.rst:734
#, fuzzy
msgid ":class:`IntFlag` members can also be iterated over::"
msgstr ":class:`IntFlag` 成員也可以疊代::"

#: ../../howto/enum.rst:743
#, fuzzy
msgid "Flag"
msgstr "旗幟"

#: ../../howto/enum.rst:745
#, fuzzy
msgid ""
"The last variation is :class:`Flag`.  Like :class:`IntFlag`, :class:`Flag` "
"members can be combined using the bitwise operators (&, \\|, ^, ~).  Unlike :"
"class:`IntFlag`, they cannot be combined with, nor compared against, any "
"other :class:`Flag` enumeration, nor :class:`int`.  While it is possible to "
"specify the values directly it is recommended to use :class:`auto` as the "
"value and let :class:`Flag` select an appropriate value."
msgstr ""
"最後一個變體是 :class:`Flag`。與 :class:`IntFlag` 一樣，:class:`Flag` "
"成員可以使用按位運算符（&、\\|、^、~）組合。與 :class:`IntFlag` 不同，"
"它們不能與任何其他 :class:`Flag` 枚舉或 :class:`int` "
"結合，也不能與之比較。雖然可以直接指定值，但建議使用 :class:`auto` "
"作為值並讓 :class:`Flag` 選擇適當的值。"

#: ../../howto/enum.rst:754
#, fuzzy
msgid ""
"Like :class:`IntFlag`, if a combination of :class:`Flag` members results in "
"no flags being set, the boolean evaluation is :data:`False`::"
msgstr "與 IntFlag 一樣，如果 Flag "
"成員的組合沒有設定任何旗標，則布爾值評估為 :data:`False`::"

#: ../../howto/enum.rst:768
#, fuzzy
msgid ""
"Individual flags should have values that are powers of two (1, 2, 4, "
"8, ...), while combinations of flags will not::"
msgstr "單個旗標的值應該是 2 的冪（1、2、4、8、...），而旗標的組合不會::"

#: ../../howto/enum.rst:780
#, fuzzy
msgid ""
"Giving a name to the \"no flags set\" condition does not change its boolean "
"value::"
msgstr "為“未設定旗標”條件命名不會更改其布爾值::"

#: ../../howto/enum.rst:794
#, fuzzy
msgid ":class:`Flag` members can also be iterated over::"
msgstr ":class:`Flag` 成員也可以疊代::"

#: ../../howto/enum.rst:804
#, fuzzy
msgid ""
"For the majority of new code, :class:`Enum` and :class:`Flag` are strongly "
"recommended, since :class:`IntEnum` and :class:`IntFlag` break some semantic "
"promises of an enumeration (by being comparable to integers, and thus by "
"transitivity to other unrelated enumerations).  :class:`IntEnum` and :class:"
"`IntFlag` should be used only in cases where :class:`Enum` and :class:`Flag` "
"will not do; for example, when integer constants are replaced with "
"enumerations, or for interoperability with other systems."
msgstr ""
"對於大多數新程式碼，強烈建議使用 Enum 和 Flag，因為 IntEnum 和 IntFlag "
"破壞了枚舉的一些語義承諾（通過與整數，因此可以傳遞給其他不相關的枚舉）。 "
":class:`IntEnum` 和 :class:`IntFlag` 應該只在 :class:`Enum` 和 :class:`Flag` "
"不起作用的情況下使用；例如，當整數常數被枚舉替換時，或者為了與其他系統的互操"
"作性。"

#: ../../howto/enum.rst:814
#, fuzzy
msgid "Others"
msgstr "其他的"

#: ../../howto/enum.rst:816
#, fuzzy
msgid ""
"While :class:`IntEnum` is part of the :mod:`enum` module, it would be very "
"simple to implement independently::"
msgstr "雖然 :class:`IntEnum` 是 :mod:`enum` 模組的一部分，但獨立實作將非常簡單::"

#: ../../howto/enum.rst:822
#, fuzzy
msgid ""
"This demonstrates how similar derived enumerations can be defined; for "
"example a :class:`FloatEnum` that mixes in :class:`float` instead of :class:"
"`int`."
msgstr ""
"這演示瞭如何定義相似的派生枚舉；例如 :class:`FloatEnum` 混合了 :class:`float`"
" 而不是 :class:`int`。"

#: ../../howto/enum.rst:825
#, fuzzy
msgid "Some rules:"
msgstr "一些規則："

#: ../../howto/enum.rst:827
#, fuzzy
msgid ""
"When subclassing :class:`Enum`, mix-in types must appear before :class:"
"`Enum` itself in the sequence of bases, as in the :class:`IntEnum` example "
"above."
msgstr "當對 Enum 進行子類別化時，混合型別必須出現在基序列中的 Enum 本身之前，"
"如上面的 IntEnum 示例所示。"

#: ../../howto/enum.rst:830
#, fuzzy
msgid ""
"Mix-in types must be subclassable. For example, :class:`bool` and :class:"
"`range` are not subclassable and will throw an error during Enum creation if "
"used as the mix-in type."
msgstr ""
"混合型別必須是可繼承的。例如，:class:`bool` 和:class:`range` "
"不可子類別化，如果用作混合型別，將在 Enum 建立期間拋出錯誤。"

#: ../../howto/enum.rst:833
#, fuzzy
msgid ""
"While :class:`Enum` can have members of any type, once you mix in an "
"additional type, all the members must have values of that type, e.g. :class:"
"`int` above.  This restriction does not apply to mix-ins which only add "
"methods and don't specify another type."
msgstr ""
"雖然 Enum 可以包含任何型別的成員，但一旦混合了其他型別，所有成員都必須具有該"
"型別的值，例如 :class:`int` "
"上面。此限制不適用於僅新增方法而不指定其他型別的混合。"

#: ../../howto/enum.rst:837
#, fuzzy
msgid ""
"When another data type is mixed in, the :attr:`value` attribute is *not the "
"same* as the enum member itself, although it is equivalent and will compare "
"equal."
msgstr "當混合了另一種資料型別時，:attr:`value` "
"屬性與枚舉成員本身*不同*，儘管它是等價的並且比較相等。"

#: ../../howto/enum.rst:840
#, fuzzy
msgid "A ``data type`` is a mixin that defines :meth:`__new__`."
msgstr "``資料型別`` 是定義 :meth:`__new__` 的混入。"

#: ../../howto/enum.rst:841
#, fuzzy
msgid ""
"%-style formatting:  ``%s`` and ``%r`` call the :class:`Enum` class's :meth:"
"`__str__` and :meth:`__repr__` respectively; other codes (such as ``%i`` or "
"``%h`` for IntEnum) treat the enum member as its mixed-in type."
msgstr ""
"%-style 格式：``%s`` 和 ``%r`` 分別呼叫 Enum 類的 __str__ 和 __repr__ "
"；其他程式碼（例如 IntEnum 的 ``%i`` 或 ``%h``）將枚舉成員視為其混合型別。"

#: ../../howto/enum.rst:844
#, fuzzy
msgid ""
":ref:`Formatted string literals <f-strings>`, :meth:`str.format`, and :func:"
"`format` will use the enum's :meth:`__str__` method."
msgstr ""
":ref:`格式化字串文字 <f-strings>`、:meth:`str.format` 和 :func:`format` "
"將使用枚舉的 :meth:`__str__` 方法。"

#: ../../howto/enum.rst:849
#, fuzzy
msgid ""
"Because :class:`IntEnum`, :class:`IntFlag`, and :class:`StrEnum` are "
"designed to be drop-in replacements for existing constants, their :meth:"
"`__str__` method has been reset to their data types' :meth:`__str__` method."
msgstr ""
"因為 :class:`IntEnum`、:class:`IntFlag` 和 :class:`StrEnum` "
"被設計為現有常數的直接替換，它們的 :meth:`__str__` "
"方法已被重置為它們的資料型別。 :meth:`__str__` 方法。"

#: ../../howto/enum.rst:855
#, fuzzy
msgid "When to use :meth:`__new__` vs. :meth:`__init__`"
msgstr "何時使用 :meth:`__new__` 與 :meth:`__init__`"

#: ../../howto/enum.rst:857
#, fuzzy
msgid ""
":meth:`__new__` must be used whenever you want to customize the actual value "
"of the :class:`Enum` member.  Any other modifications may go in either :meth:"
"`__new__` or :meth:`__init__`, with :meth:`__init__` being preferred."
msgstr ""
"每當您想自定義 Enum 成員的實際值時，都必須使用 :meth:`__new__`。"
"任何其他修改都可以在 :meth:`__new__` 或 :meth:`__init__` 中進行，首選 "
":meth:`__init__` 。"

#: ../../howto/enum.rst:861
#, fuzzy
msgid ""
"For example, if you want to pass several items to the constructor, but only "
"want one of them to be the value::"
msgstr "例如，如果你想將幾個項目傳遞給構造函式，但只希望其中一個是值::"

#: ../../howto/enum.rst:888
#, fuzzy
msgid "Finer Points"
msgstr "更好的點"

#: ../../howto/enum.rst:891
#, fuzzy
msgid "Supported ``__dunder__`` names"
msgstr "支援的 ``__dunder__`` 名稱"

#: ../../howto/enum.rst:893
#, fuzzy
msgid ""
":attr:`__members__` is a read-only ordered mapping of ``member_name``:"
"``member`` items.  It is only available on the class."
msgstr ":attr:`__members__` 是``member_name``:``member`` "
"項的只讀有序映射。它僅在課堂上可用。"

#: ../../howto/enum.rst:896
#, fuzzy
msgid ""
":meth:`__new__`, if specified, must create and return the enum members; it "
"is also a very good idea to set the member's :attr:`_value_` appropriately.  "
"Once all the members are created it is no longer used."
msgstr ""
":meth:`__new__`，如果指定，必須建立並回傳枚舉成員；適當地設定成員的 "
":attr:`_value_` 也是一個很好的主意。一旦建立了所有成員，就不再使用它。"

#: ../../howto/enum.rst:902
#, fuzzy
msgid "Supported ``_sunder_`` names"
msgstr "支援的 ``_sunder_`` 名稱"

#: ../../howto/enum.rst:904
#, fuzzy
msgid "``_name_`` -- name of the member"
msgstr "``_name_`` -- 成員的名字"

#: ../../howto/enum.rst:905
#, fuzzy
msgid ""
"``_value_`` -- value of the member; can be set / modified in ``__new__``"
msgstr "``_value_`` -- 成員的值；可以在``__new__``中設定/修改"

#: ../../howto/enum.rst:907
#, fuzzy
msgid ""
"``_missing_`` -- a lookup function used when a value is not found; may be "
"overridden"
msgstr "``_missing_`` -- 找不到值時使用的查找函式；可能被覆蓋"

#: ../../howto/enum.rst:909
#, fuzzy
msgid ""
"``_ignore_`` -- a list of names, either as a :class:`list` or a :class:"
"`str`, that will not be transformed into members, and will be removed from "
"the final class"
msgstr "``_ignore_`` -- 名稱列表，作為 :class:`list` 或 "
":class:`str`，不會轉換為成員，並將從最終類中刪除"

#: ../../howto/enum.rst:912
#, fuzzy
msgid ""
"``_order_`` -- used in Python 2/3 code to ensure member order is consistent "
"(class attribute, removed during class creation)"
msgstr "``_order_`` -- 在 Python 2/3 "
"程式碼中使用以確保成員順序一致（類屬性，在建立類時移除）"

#: ../../howto/enum.rst:914
#, fuzzy
msgid ""
"``_generate_next_value_`` -- used by the `Functional API`_ and by :class:"
"`auto` to get an appropriate value for an enum member; may be overridden"
msgstr ""
"``_generate_next_value_`` -- 由 `Functional API`_ 和 :class:`auto` "
"用於為枚舉成員獲取適當的值；可能被覆蓋"

#: ../../howto/enum.rst:920
#, fuzzy
msgid ""
"For standard :class:`Enum` classes the next value chosen is the last value "
"seen incremented by one."
msgstr "對於標準 :class:`Enum` 類，選擇的下一個值是最後看到的值加一。"

#: ../../howto/enum.rst:923
#, fuzzy
msgid ""
"For :class:`Flag` classes the next value chosen will be the next highest "
"power-of-two, regardless of the last value seen."
msgstr "對於 :class:`Flag` 類，選擇的下一個值將是下一個最高的 2 "
"的冪，而不管看到的最後一個值。"

#: ../../howto/enum.rst:926
#, fuzzy
msgid "``_missing_``, ``_order_``, ``_generate_next_value_``"
msgstr "``_missing_``，``_order_``，``_generate_next_value_``"

#: ../../howto/enum.rst:927
#, fuzzy
msgid "``_ignore_``"
msgstr "``_忽略_``"

#: ../../howto/enum.rst:929
#, fuzzy
msgid ""
"To help keep Python 2 / Python 3 code in sync an :attr:`_order_` attribute "
"can be provided.  It will be checked against the actual order of the "
"enumeration and raise an error if the two do not match::"
msgstr ""
"為了幫助保持 Python 2 / Python 3 程式碼同步，可以提供 :attr:`_order_` "
"屬性。它將根據枚舉的實際順序進行檢查，如果兩者不匹配則引發錯誤::"

#: ../../howto/enum.rst:947
#, fuzzy
msgid ""
"In Python 2 code the :attr:`_order_` attribute is necessary as definition "
"order is lost before it can be recorded."
msgstr "在 Python 2 程式碼中，:attr:`_order_` "
"屬性是必需的，因為定義順序在記錄之前丟失了。"

#: ../../howto/enum.rst:952
#, fuzzy
msgid "_Private__names"
msgstr "_Private__名字"

#: ../../howto/enum.rst:954
#, fuzzy
msgid ""
":ref:`Private names <private-name-mangling>` are not converted to enum "
"members, but remain normal attributes."
msgstr ":ref:`私有名稱 <private-name-mangling>` "
"不會轉換為枚舉成員，而是保留正常屬性。"

#: ../../howto/enum.rst:961
#, fuzzy
msgid "``Enum`` member type"
msgstr "``Enum`` 成員型別"

#: ../../howto/enum.rst:963
#, fuzzy
msgid ""
"Enum members are instances of their enum class, and are normally accessed as "
"``EnumClass.member``.  In certain situations, such as writing custom enum "
"behavior, being able to access one member directly from another is useful, "
"and is supported."
msgstr ""
"枚舉成員是其枚舉類的實例，通常作為“EnumClass.member”訪問。在某些情況下，例如"
"編寫自定義枚舉行為，能夠直接從一個成員訪問另一個成員是有用的，並且是受支援的"
"。"

#: ../../howto/enum.rst:972
#, fuzzy
msgid "Creating members that are mixed with other data types"
msgstr "建立與其他資料型別混合的成員"

#: ../../howto/enum.rst:974
#, fuzzy
msgid ""
"When subclassing other data types, such as :class:`int` or :class:`str`, "
"with an :class:`Enum`, all values after the ``=`` are passed to that data "
"type's constructor.  For example::"
msgstr ""
"當使用 :class:`Enum` 對其他資料型別進行子類別化時，例如 :class:`int` 或 "
":class:`str`，所有在 ``=`` 之後的值都被傳遞給該資料型別的構造函式。例如：："

#: ../../howto/enum.rst:986
#, fuzzy
msgid "Boolean value of ``Enum`` classes and members"
msgstr "``Enum`` 類和成員的布爾值"

#: ../../howto/enum.rst:988
#, fuzzy
msgid ""
"Enum classes that are mixed with non-:class:`Enum` types (such as :class:"
"`int`, :class:`str`, etc.) are evaluated according to the mixed-in type's "
"rules; otherwise, all members evaluate as :data:`True`.  To make your own "
"enum's boolean evaluation depend on the member's value add the following to "
"your class::"
msgstr ""
"與非 :class:`Enum` 型別（例如 :class:`int`， :class:`str` "
"等）混合的枚舉類根據混合型別的規則進行評估；否則，所有成員都評估為 :data:`Tru"
"e`。要使您自己的枚舉的布爾值評估取決於成員的值，請將以下內容新增到您的類中："

#: ../../howto/enum.rst:997
#, fuzzy
msgid "Plain :class:`Enum` classes always evaluate as :data:`True`."
msgstr "普通 :class:`Enum` 類總是評估為 :data:`True`。"

#: ../../howto/enum.rst:1001
#, fuzzy
msgid "``Enum`` classes with methods"
msgstr "帶有方法的``枚舉``類"

#: ../../howto/enum.rst:1003
#, fuzzy
msgid ""
"If you give your enum subclass extra methods, like the `Planet`_ class "
"below, those methods will show up in a :func:`dir` of the member, but not of "
"the class::"
msgstr "如果你給枚舉子類別額外的方法，比如下面的 Planet 類，這些方法將出現在成員的 "
":func:`dir` 中，但不會出現在類中::"

#: ../../howto/enum.rst:1014
#, fuzzy
msgid "Combining members of ``Flag``"
msgstr "結合``Flag``的成員"

#: ../../howto/enum.rst:1016
#, fuzzy
msgid ""
"Iterating over a combination of :class:`Flag` members will only return the "
"members that are comprised of a single bit::"
msgstr "疊代 :class:`Flag` 成員的組合將只回傳由單個位組成的成員::"

#: ../../howto/enum.rst:1034
#, fuzzy
msgid "``Flag`` and ``IntFlag`` minutia"
msgstr "``Flag`` 和 ``IntFlag`` 細節"

#: ../../howto/enum.rst:1036
#, fuzzy
msgid "Using the following snippet for our examples::"
msgstr "在我們的示例中使用以下程式碼段::"

#: ../../howto/enum.rst:1047
#, fuzzy
msgid "the following are true:"
msgstr "以下是正確的："

#: ../../howto/enum.rst:1049
#, fuzzy
msgid "single-bit flags are canonical"
msgstr "一位旗標是規範的"

#: ../../howto/enum.rst:1050
#, fuzzy
msgid "multi-bit and zero-bit flags are aliases"
msgstr "多位和零位旗標是別名"

#: ../../howto/enum.rst:1051
#, fuzzy
msgid "only canonical flags are returned during iteration::"
msgstr "疊代期間僅回傳規範旗標::"

#: ../../howto/enum.rst:1056
#, fuzzy
msgid ""
"negating a flag or flag set returns a new flag/flag set with the "
"corresponding positive integer value::"
msgstr "取反一個旗標或旗標集回傳一個新的旗標/旗標集與相應的正整數值::"

#: ../../howto/enum.rst:1065
#, fuzzy
msgid "names of pseudo-flags are constructed from their members' names::"
msgstr "偽旗標的名稱由其成員的名稱構成::"

#: ../../howto/enum.rst:1070
#, fuzzy
msgid "multi-bit flags, aka aliases, can be returned from operations::"
msgstr "多位旗標，又名別名，可以從操作回傳："

#: ../../howto/enum.rst:1081
#, fuzzy
msgid ""
"membership / containment checking: zero-valued flags are always considered "
"to be contained::"
msgstr "成員資格/包含檢查：零值旗標始終被視為包含::"

#: ../../howto/enum.rst:1087
#, fuzzy
msgid ""
"otherwise, only if all bits of one flag are in the other flag will True be "
"returned::"
msgstr "否則，只有當一個旗標的所有位都在另一個旗標中時，才會回傳 True::"

#: ../../howto/enum.rst:1096
#, fuzzy
msgid ""
"There is a new boundary mechanism that controls how out-of-range / invalid "
"bits are handled: ``STRICT``, ``CONFORM``, ``EJECT``, and ``KEEP``:"
msgstr "有一種新的邊界機制可以控制如何處理超出範圍/無效的位：``STRICT``、``CONFORM``"
"、``EJECT`` 和 ``KEEP``："

#: ../../howto/enum.rst:1099
#, fuzzy
msgid "STRICT --> raises an exception when presented with invalid values"
msgstr "STRICT --> 出現無效值時引發例外"

#: ../../howto/enum.rst:1100
#, fuzzy
msgid "CONFORM --> discards any invalid bits"
msgstr "CONFORM --> 丟棄任何無效位"

#: ../../howto/enum.rst:1101
#, fuzzy
msgid "EJECT --> lose Flag status and become a normal int with the given value"
msgstr "EJECT --> 失去 Flag 狀態並成為具有給定值的普通 int"

#: ../../howto/enum.rst:1105
#, fuzzy
msgid "KEEP --> keep the extra bits"
msgstr "KEEP --> 保留額外的位"

#: ../../howto/enum.rst:1103
#, fuzzy
msgid "keeps Flag status and extra bits"
msgstr "保持旗標狀態和額外位"

#: ../../howto/enum.rst:1104
#, fuzzy
msgid "extra bits do not show up in iteration"
msgstr "額外的位不會出現在疊代中"

#: ../../howto/enum.rst:1105
#, fuzzy
msgid "extra bits do show up in repr() and str()"
msgstr "額外的位確實出現在 repr() 和 str() 中"

#: ../../howto/enum.rst:1107
#, fuzzy
msgid ""
"The default for Flag is ``STRICT``, the default for ``IntFlag`` is "
"``EJECT``, and the default for ``_convert_`` is ``KEEP`` (see ``ssl."
"Options`` for an example of when ``KEEP`` is needed)."
msgstr ""
"Flag 的預設值為 ``STRICT``， ``IntFlag`` 的預設值為 ``EJECT``，“_convert_”的預設值為“KE"
"EP”（參見“ssl.Options”）例如，何時需要 ``KEEP``）。"

#: ../../howto/enum.rst:1115
#, fuzzy
msgid "How are Enums and Flags different?"
msgstr "枚舉和旗標有何不同？"

#: ../../howto/enum.rst:1117
#, fuzzy
msgid ""
"Enums have a custom metaclass that affects many aspects of both derived :"
"class:`Enum` classes and their instances (members)."
msgstr "枚舉有一個自定義元類，它會影響派生的 Enum 類及其實例（成員）的許多方面。"

#: ../../howto/enum.rst:1122
#, fuzzy
msgid "Enum Classes"
msgstr "枚舉類"

#: ../../howto/enum.rst:1124
#, fuzzy
msgid ""
"The :class:`EnumType` metaclass is responsible for providing the :meth:"
"`__contains__`, :meth:`__dir__`, :meth:`__iter__` and other methods that "
"allow one to do things with an :class:`Enum` class that fail on a typical "
"class, such as ``list(Color)`` or ``some_enum_var in Color``.  :class:"
"`EnumType` is responsible for ensuring that various other methods on the "
"final :class:`Enum` class are correct (such as :meth:`__new__`, :meth:"
"`__getnewargs__`, :meth:`__str__` and :meth:`__repr__`)."
msgstr ""
":class:`EnumType` 元類負責提供 "
":meth:`__contains__`、:meth:`__dir__`、:meth:`__iter__` 和其他允許使用 "
":class:`Enum` 做事的方法在典型類上失敗的類，例如 ``list(Color)`` 或 ``Color "
"中的 some_enum_var``。 :class:`EnumType` 負責確保最終 :class:`Enum` 類上的各"
"種其他方法是正確的（例如 :meth:`__new__`、:meth:`__getnewargs__`、:meth:`__st"
"r__` 和 :meth:`__repr__`)。"

#: ../../howto/enum.rst:1133
#, fuzzy
msgid "Flag Classes"
msgstr "旗標類"

#: ../../howto/enum.rst:1135
#, fuzzy
msgid ""
"Flags have an expanded view of aliasing: to be canonical, the value of a "
"flag needs to be a power-of-two value, and not a duplicate name.  So, in "
"addition to the :class:`Enum` definition of alias, a flag with no value (a.k."
"a. ``0``) or with more than one power-of-two value (e.g. ``3``) is "
"considered an alias."
msgstr ""
"旗標具有別名的擴充視圖：要規範化，旗標的值需要是二次冪值，而不是重複名稱。因"
"此，除了別名的 Enum 定義之外，還考慮了一個沒有值（又名 "
"``0``）或具有多個二次冪值（例如 ``3``）的旗標別名。"

#: ../../howto/enum.rst:1141
#, fuzzy
msgid "Enum Members (aka instances)"
msgstr "枚舉成員（又名實例）"

#: ../../howto/enum.rst:1143
#, fuzzy
msgid ""
"The most interesting thing about enum members is that they are singletons. :"
"class:`EnumType` creates them all while it is creating the enum class "
"itself, and then puts a custom :meth:`__new__` in place to ensure that no "
"new ones are ever instantiated by returning only the existing member "
"instances."
msgstr ""
"枚舉成員最有趣的地方在於它們是單例。 :class:`EnumType` "
"在建立枚舉類本身的同時建立它們，然後放置一個自定義的 :meth:`__new__` "
"以確保不會通過僅回傳現有成員實例來實例化新的成員實例。"

#: ../../howto/enum.rst:1149
#, fuzzy
msgid "Flag Members"
msgstr "標記會員"

#: ../../howto/enum.rst:1151
#, fuzzy
msgid ""
"Flag members can be iterated over just like the :class:`Flag` class, and "
"only the canonical members will be returned.  For example::"
msgstr "Flag 成員可以像 :class:`Flag` 類一樣被疊代，並且只會回傳規范成員。例如：："

#: ../../howto/enum.rst:1157
#, fuzzy
msgid "(Note that ``BLACK``, ``PURPLE``, and ``WHITE`` do not show up.)"
msgstr "（注意 ``BLACK``、``PURPLE`` 和 ``WHITE`` 不會出現。）"

#: ../../howto/enum.rst:1159
#, fuzzy
msgid ""
"Inverting a flag member returns the corresponding positive value, rather "
"than a negative value --- for example::"
msgstr "反轉旗標成員回傳相應的正值，而不是負值 --- 例如："

#: ../../howto/enum.rst:1165
#, fuzzy
msgid ""
"Flag members have a length corresponding to the number of power-of-two "
"values they contain.  For example::"
msgstr "旗標成員的長度對應於它們包含的二次冪值的數量。例如：："

#: ../../howto/enum.rst:1175
#, fuzzy
msgid "Enum Cookbook"
msgstr "枚舉食譜"

#: ../../howto/enum.rst:1178
#, fuzzy
msgid ""
"While :class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :class:`Flag`, and :"
"class:`IntFlag` are expected to cover the majority of use-cases, they cannot "
"cover them all.  Here are recipes for some different types of enumerations "
"that can be used directly, or as examples for creating one's own."
msgstr ""
"雖然 Enum、IntEnum、StrEnum、Flag 和 IntFlag 有望涵蓋大多數用例，但它們無法涵"
"蓋商場。以下是一些可以直接使用的不同型別枚舉的方法，或者作為建立自己的枚舉的"
"示例。"

#: ../../howto/enum.rst:1185
#, fuzzy
msgid "Omitting values"
msgstr "省略值"

#: ../../howto/enum.rst:1187
#, fuzzy
msgid ""
"In many use-cases, one doesn't care what the actual value of an enumeration "
"is. There are several ways to define this type of simple enumeration:"
msgstr "在許多用例中，人們並不關心枚舉的實際值是多少。有幾種方法可以定義這種型別的簡"
"單枚舉："

#: ../../howto/enum.rst:1190
#, fuzzy
msgid "use instances of :class:`auto` for the value"
msgstr "使用 :class:`auto` 的實例作為值"

#: ../../howto/enum.rst:1191
#, fuzzy
msgid "use instances of :class:`object` as the value"
msgstr "使用 :class:`object` 的實例作為值"

#: ../../howto/enum.rst:1192
#, fuzzy
msgid "use a descriptive string as the value"
msgstr "使用描述性字串作為值"

#: ../../howto/enum.rst:1193
#, fuzzy
msgid ""
"use a tuple as the value and a custom :meth:`__new__` to replace the tuple "
"with an :class:`int` value"
msgstr "使用元組作為值和自定義 :meth:`__new__` 將元組替換為 :class:`int` 值"

#: ../../howto/enum.rst:1196
#, fuzzy
msgid ""
"Using any of these methods signifies to the user that these values are not "
"important, and also enables one to add, remove, or reorder members without "
"having to renumber the remaining members."
msgstr "使用這些方法中的任何一種都向使用者表明這些值並不重要，並且還使使用者能夠新增"
"、刪除或重新排序成員而不必對其餘成員重新編號。"

#: ../../howto/enum.rst:1202
#, fuzzy
msgid "Using :class:`auto`"
msgstr "使用 :class:`自動`"

#: ../../howto/enum.rst:1204
#, fuzzy
msgid "Using :class:`auto` would look like::"
msgstr "使用 :class:`auto` 看起來像::"

#: ../../howto/enum.rst:1216
#, fuzzy
msgid "Using :class:`object`"
msgstr "使用 :class:`物件`"

#: ../../howto/enum.rst:1218
#, fuzzy
msgid "Using :class:`object` would look like::"
msgstr "使用 :class:`object` 看起來像："

#: ../../howto/enum.rst:1228
#, fuzzy
msgid ""
"This is also a good example of why you might want to write your own :meth:"
"`__repr__`::"
msgstr "這也是一個很好的例子，說明為什麼你可能想要自己編寫 :meth:`__repr__`::"

#: ../../howto/enum.rst:1244
#, fuzzy
msgid "Using a descriptive string"
msgstr "使用描述性字串"

#: ../../howto/enum.rst:1246
#, fuzzy
msgid "Using a string as the value would look like::"
msgstr "使用字串作為值看起來像："

#: ../../howto/enum.rst:1258
#, fuzzy
msgid "Using a custom :meth:`__new__`"
msgstr "使用自定義 :meth:`__new__`"

#: ../../howto/enum.rst:1260
#, fuzzy
msgid "Using an auto-numbering :meth:`__new__` would look like::"
msgstr "使用自動編號 :meth:`__new__` 看起來像::"

#: ../../howto/enum.rst:1277
#, fuzzy
msgid ""
"To make a more general purpose ``AutoNumber``, add ``*args`` to the "
"signature::"
msgstr "要製作更通用的 ``AutoNumber``，請將 ``*args`` 新增到簽名中："

#: ../../howto/enum.rst:1287
#, fuzzy
msgid ""
"Then when you inherit from ``AutoNumber`` you can write your own "
"``__init__`` to handle any extra arguments::"
msgstr "然後，當您繼承自 ``AutoNumber`` 時，您可以編寫自己的 ``__init__`` "
"來處理任何額外的參數::"

#: ../../howto/enum.rst:1306
#, fuzzy
msgid ""
"The :meth:`__new__` method, if defined, is used during creation of the Enum "
"members; it is then replaced by Enum's :meth:`__new__` which is used after "
"class creation for lookup of existing members."
msgstr ""
":meth:`__new__` 方法（如果已定義）在建立 Enum 成員期間使用；然後它被 Enum 的 "
":meth:`__new__` 取代，它在類建立後用於查找現有成員。"

#: ../../howto/enum.rst:1312
#, fuzzy
msgid "OrderedEnum"
msgstr "有序枚舉"

#: ../../howto/enum.rst:1314
#, fuzzy
msgid ""
"An ordered enumeration that is not based on :class:`IntEnum` and so "
"maintains the normal :class:`Enum` invariants (such as not being comparable "
"to other enumerations)::"
msgstr "一個不基於 IntEnum 的有序枚舉，因此保持正常的 Enum "
"不變數（例如不能與其他枚舉相比較）::"

#: ../../howto/enum.rst:1348
#, fuzzy
msgid "DuplicateFreeEnum"
msgstr "DuplicateFreeEnum"

#: ../../howto/enum.rst:1350
#, fuzzy
msgid ""
"Raises an error if a duplicate member value is found instead of creating an "
"alias::"
msgstr "如果找到重複的成員值而不是建立別名，則會引發錯誤::"

#: ../../howto/enum.rst:1375
#, fuzzy
msgid ""
"This is a useful example for subclassing Enum to add or change other "
"behaviors as well as disallowing aliases.  If the only desired change is "
"disallowing aliases, the :func:`unique` decorator can be used instead."
msgstr ""
"這是一個有用的示例，用於子類別化 Enum "
"以新增或更改其他行為以及禁止別名。如果唯一需要的更改是不允許別名，則可以改用 "
":func:`unique` 裝飾器。"

#: ../../howto/enum.rst:1381
#, fuzzy
msgid "Planet"
msgstr "行星"

#: ../../howto/enum.rst:1383
#, fuzzy
msgid ""
"If :meth:`__new__` or :meth:`__init__` is defined, the value of the enum "
"member will be passed to those methods::"
msgstr "如果定義了 :meth:`__new__` 或 :meth:`__init__` "
"，枚舉成員的值將傳遞給這些方法::"

#: ../../howto/enum.rst:1412
#, fuzzy
msgid "TimePeriod"
msgstr "時間段"

#: ../../howto/enum.rst:1414
#, fuzzy
msgid "An example to show the :attr:`_ignore_` attribute in use::"
msgstr "顯示正在使用的 :attr:`_ignore_` 屬性的示例::"

#: ../../howto/enum.rst:1433
#, fuzzy
msgid "Subclassing EnumType"
msgstr "子類別化 EnumType"

#: ../../howto/enum.rst:1435
#, fuzzy
msgid ""
"While most enum needs can be met by customizing :class:`Enum` subclasses, "
"either with class decorators or custom functions, :class:`EnumType` can be "
"subclassed to provide a different Enum experience."
msgstr ""
"雖然大多數枚舉需求可以通過自定義 Enum "
"子類別來滿足，無論是使用類裝飾器還是自定義函式，EnumType "
"都可以被子類別化以提供不同的 Enum 體驗。"
