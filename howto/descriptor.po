# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Leon H., 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-25 00:20+0000\n"
"PO-Revision-Date: 2018-05-23 14:36+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/descriptor.rst:5
msgid "Descriptor HowTo Guide"
msgstr "修飾器 HowTo 指南"

#: ../../howto/descriptor.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/descriptor.rst:7
msgid "Raymond Hettinger"
msgstr "Raymond Hettinger"

#: ../../howto/descriptor.rst:0
msgid "Contact"
msgstr "聯絡方式"

#: ../../howto/descriptor.rst:8
msgid "<python at rcn dot com>"
msgstr "<python at rcn dot com>"

#: ../../howto/descriptor.rst:11
msgid "Contents"
msgstr "目錄"

#: ../../howto/descriptor.rst:13
#, fuzzy
msgid ""
":term:`Descriptors <descriptor>` let objects customize attribute lookup, "
"storage, and deletion."
msgstr ":term:`Descriptors <descriptor>` 讓物件自定義屬性查找、儲存和刪除。"

#: ../../howto/descriptor.rst:16
#, fuzzy
msgid "This guide has four major sections:"
msgstr "本指南分為四個主要部分："

#: ../../howto/descriptor.rst:18
#, fuzzy
msgid ""
"The \"primer\" gives a basic overview, moving gently from simple examples, "
"adding one feature at a time.  Start here if you're new to descriptors."
msgstr "“入門”給出了一個基本的概述，從簡單的例子慢慢地移動，一次新增一個特性。如果您"
"不熟悉描述器，請從這裡開始。"

#: ../../howto/descriptor.rst:21
#, fuzzy
msgid ""
"The second section shows a complete, practical descriptor example.  If you "
"already know the basics, start there."
msgstr "第二部分展示了一個完整、實用的描述器示例。如果您已經了解基礎知識，請從這裡開"
"始。"

#: ../../howto/descriptor.rst:24
#, fuzzy
msgid ""
"The third section provides a more technical tutorial that goes into the "
"detailed mechanics of how descriptors work.  Most people don't need this "
"level of detail."
msgstr "第三部分提供了一個更技術性的教程，詳細介紹了描述器如何工作的機制。大多數人不"
"需要這種詳細程度。"

#: ../../howto/descriptor.rst:28
#, fuzzy
msgid ""
"The last section has pure Python equivalents for built-in descriptors that "
"are written in C.  Read this if you're curious about how functions turn into "
"bound methods or about the implementation of common tools like :func:"
"`classmethod`, :func:`staticmethod`, :func:`property`, and :term:`__slots__`."
msgstr ""
"最後一節是用 C 語言編寫的內建描述器的純 Python "
"等價物。如果您對函式如何變成綁定方法或常見工具（如 "
":func:`classmethod`、:func: 的實作）感到好奇，請閱讀此部分： "
"`staticmethod`、:func:`property` 和 :term:`__slots__`。"

#: ../../howto/descriptor.rst:36
#, fuzzy
msgid "Primer"
msgstr "底漆"

#: ../../howto/descriptor.rst:38
#, fuzzy
msgid ""
"In this primer, we start with the most basic possible example and then we'll "
"add new capabilities one by one."
msgstr "在本入門教程中，我們從最基本的可能示例開始，然後我們將一一新增新功能。"

#: ../../howto/descriptor.rst:43
#, fuzzy
msgid "Simple example: A descriptor that returns a constant"
msgstr "簡單示例：回傳常數的描述器"

#: ../../howto/descriptor.rst:45
#, fuzzy
msgid ""
"The :class:`Ten` class is a descriptor whose :meth:`__get__` method always "
"returns the constant ``10``:"
msgstr ":class:`Ten` 類是一個描述器，其 :meth:`__get__` 方法總是回傳常數 ``10``："

#: ../../howto/descriptor.rst:54
#, fuzzy
msgid ""
"To use the descriptor, it must be stored as a class variable in another "
"class:"
msgstr "要使用描述器，它必須作為類變數儲存在另一個類中："

#: ../../howto/descriptor.rst:62
#, fuzzy
msgid ""
"An interactive session shows the difference between normal attribute lookup "
"and descriptor lookup:"
msgstr "交互式會話顯示了普通屬性查找和描述器查找之間的區別："

#: ../../howto/descriptor.rst:73
#, fuzzy
msgid ""
"In the ``a.x`` attribute lookup, the dot operator finds ``'x': 5`` in the "
"class dictionary.  In the ``a.y`` lookup, the dot operator finds a "
"descriptor instance, recognized by its ``__get__`` method. Calling that "
"method returns ``10``."
msgstr ""
"在 ``a.x`` 屬性查找中，點運算符在類字典中找到 ``'x': 5``。在 ``a.y`` "
"查找中，點運算符找到一個描述器實例，由其 ``__get__`` "
"方法識別。呼叫該方法回傳 ``10``。"

#: ../../howto/descriptor.rst:78
#, fuzzy
msgid ""
"Note that the value ``10`` is not stored in either the class dictionary or "
"the instance dictionary.  Instead, the value ``10`` is computed on demand."
msgstr "請注意，值 ``10``既沒有儲存在類字典也沒有儲存在實例字典中。相反，值 ``10``是按需計"
"算的。"

#: ../../howto/descriptor.rst:81
#, fuzzy
msgid ""
"This example shows how a simple descriptor works, but it isn't very useful. "
"For retrieving constants, normal attribute lookup would be better."
msgstr "這個例子展示了一個簡單的描述器是如何工作的，但它不是很有用。對於檢索常數，普"
"通屬性查找會更好。"

#: ../../howto/descriptor.rst:84
#, fuzzy
msgid ""
"In the next section, we'll create something more useful, a dynamic lookup."
msgstr "在下一節中，我們將建立更有用的東西，一個動態查找。"

#: ../../howto/descriptor.rst:88
#, fuzzy
msgid "Dynamic lookups"
msgstr "動態查找"

#: ../../howto/descriptor.rst:90
#, fuzzy
msgid ""
"Interesting descriptors typically run computations instead of returning "
"constants:"
msgstr "有趣的描述器通常運行計算而不是回傳常數："

#: ../../howto/descriptor.rst:109
#, fuzzy
msgid ""
"An interactive session shows that the lookup is dynamic — it computes "
"different, updated answers each time::"
msgstr "交互式會話顯示查找是動態的——它每次都計算不同的、更新的答案::"

#: ../../howto/descriptor.rst:122
#, fuzzy
msgid ""
"Besides showing how descriptors can run computations, this example also "
"reveals the purpose of the parameters to :meth:`__get__`.  The *self* "
"parameter is *size*, an instance of *DirectorySize*.  The *obj* parameter is "
"either *g* or *s*, an instance of *Directory*.  It is the *obj* parameter "
"that lets the :meth:`__get__` method learn the target directory.  The "
"*objtype* parameter is the class *Directory*."
msgstr ""
"除了展示描述器如何運行計算之外，這個例子還揭示了 :meth:`__get__` "
"的參數的用途。 *self* 參數是 *size*，*DirectorySize* 的一個實例。 *obj* "
"參數是 *g* 或 *s*，*Directory* 的一個實例。它是讓 :meth:`__get__` "
"方法學習目標目錄的 *obj* 參數。 *objtype* 參數是類 *Directory*。"

#: ../../howto/descriptor.rst:131
#, fuzzy
msgid "Managed attributes"
msgstr "託管屬性"

#: ../../howto/descriptor.rst:133
#, fuzzy
msgid ""
"A popular use for descriptors is managing access to instance data.  The "
"descriptor is assigned to a public attribute in the class dictionary while "
"the actual data is stored as a private attribute in the instance "
"dictionary.  The descriptor's :meth:`__get__` and :meth:`__set__` methods "
"are triggered when the public attribute is accessed."
msgstr ""
"描述器的一個流行用途是管理對實例資料的訪問。描述器被分配給類字典中的公開屬性"
"，而實際資料作為私有屬性儲存在實例字典中。當訪問公開屬性時，將觸發描述器的 "
":meth:`__get__` 和 :meth:`__set__` 方法。"

#: ../../howto/descriptor.rst:139
#, fuzzy
msgid ""
"In the following example, *age* is the public attribute and *_age* is the "
"private attribute.  When the public attribute is accessed, the descriptor "
"logs the lookup or update:"
msgstr "在以下示例中，*age* 是公開屬性，*_age* "
"是私有屬性。訪問公開屬性時，描述器會記錄查找或更新："

#: ../../howto/descriptor.rst:172
#, fuzzy
msgid ""
"An interactive session shows that all access to the managed attribute *age* "
"is logged, but that the regular attribute *name* is not logged:"
msgstr "交互式會話顯示對託管屬性 *age* 的所有訪問都已記錄，但未記錄常規屬性 *name*："

#: ../../howto/descriptor.rst:206
#, fuzzy
msgid ""
"One major issue with this example is that the private name *_age* is "
"hardwired in the *LoggedAgeAccess* class.  That means that each instance can "
"only have one logged attribute and that its name is unchangeable.  In the "
"next example, we'll fix that problem."
msgstr ""
"此示例的一個主要問題是私有名稱 *_age* 硬連接到 *LoggedAgeAccess* 類中。這意味"
"著每個實例只能有一個記錄的屬性，並且它的名稱是不可更改的。在下一個示例中，我"
"們將解決該問題。"

#: ../../howto/descriptor.rst:213
#, fuzzy
msgid "Customized names"
msgstr "自定義名稱"

#: ../../howto/descriptor.rst:215
#, fuzzy
msgid ""
"When a class uses descriptors, it can inform each descriptor about which "
"variable name was used."
msgstr "當一個類使用描述器時，它可以通知每個描述器使用了哪個變數名。"

#: ../../howto/descriptor.rst:218
#, fuzzy
msgid ""
"In this example, the :class:`Person` class has two descriptor instances, "
"*name* and *age*.  When the :class:`Person` class is defined, it makes a "
"callback to :meth:`__set_name__` in *LoggedAccess* so that the field names "
"can be recorded, giving each descriptor its own *public_name* and "
"*private_name*:"
msgstr ""
"在這個例子中，:class:`Person` 類有兩個描述器實例，*name* 和 *age*。定義 "
":class:`Person` 類時，它會回呼 *LoggedAccess* 中的 :meth:`__set_name__` "
"以便記錄欄位名稱，為每個描述器提供自己的 *public_name* 和 *private_name*："

#: ../../howto/descriptor.rst:256
#, fuzzy
msgid ""
"An interactive session shows that the :class:`Person` class has called :meth:"
"`__set_name__` so that the field names would be recorded.  Here we call :"
"func:`vars` to look up the descriptor without triggering it:"
msgstr ""
"交互式會話顯示 :class:`Person` 類呼叫了 :meth:`__set_name__` "
"以便記錄欄位名稱。這裡我們呼叫 :func:`vars` 來查找描述器而不觸發它："

#: ../../howto/descriptor.rst:267
#, fuzzy
msgid "The new class now logs access to both *name* and *age*:"
msgstr "新類現在記錄對 *name* 和 *age* 的訪問："

#: ../../howto/descriptor.rst:284
#, fuzzy
msgid "The two *Person* instances contain only the private names:"
msgstr "兩個 *Person* 實例僅包含私有名稱："

#: ../../howto/descriptor.rst:295
#, fuzzy
msgid "Closing thoughts"
msgstr "結語"

#: ../../howto/descriptor.rst:297
#, fuzzy
msgid ""
"A :term:`descriptor` is what we call any object that defines :meth:"
"`__get__`, :meth:`__set__`, or :meth:`__delete__`."
msgstr ""
":term:`descriptor` 是我們所說的定義 :meth:`__get__`、:meth:`__set__` 或 "
":meth:`__delete__` 的任何物件。"

#: ../../howto/descriptor.rst:300
#, fuzzy
msgid ""
"Optionally, descriptors can have a :meth:`__set_name__` method.  This is "
"only used in cases where a descriptor needs to know either the class where "
"it was created or the name of class variable it was assigned to.  (This "
"method, if present, is called even if the class is not a descriptor.)"
msgstr ""
"可選地，描述器可以有一個 :meth:`__set_name__` "
"方法。這僅用於描述器需要知道建立它的類或分配給它的類變數的名稱的情況。 "
"（這個方法，如果存在，即使類不是描述器也會被呼叫。）"

#: ../../howto/descriptor.rst:305
#, fuzzy
msgid ""
"Descriptors get invoked by the dot operator during attribute lookup.  If a "
"descriptor is accessed indirectly with ``vars(some_class)"
"[descriptor_name]``, the descriptor instance is returned without invoking it."
msgstr ""
"描述器在屬性查找期間由點運算符呼叫。如果使用 "
"``vars(some_class)[descriptor_name]`` "
"間接訪問描述器，則回傳描述器實例而不呼叫它。"

#: ../../howto/descriptor.rst:309
#, fuzzy
msgid ""
"Descriptors only work when used as class variables.  When put in instances, "
"they have no effect."
msgstr "描述器僅在用作類變數時才起作用。當放在實例中時，它們沒有效果。"

#: ../../howto/descriptor.rst:312
#, fuzzy
msgid ""
"The main motivation for descriptors is to provide a hook allowing objects "
"stored in class variables to control what happens during attribute lookup."
msgstr "描述器的主要動機是提供一個鉤子，允許儲存在類變數中的物件控制屬性查找期間發生"
"的事情。"

#: ../../howto/descriptor.rst:315
#, fuzzy
msgid ""
"Traditionally, the calling class controls what happens during lookup. "
"Descriptors invert that relationship and allow the data being looked-up to "
"have a say in the matter."
msgstr "傳統上，呼叫類控制查找期間發生的事情。描述器顛倒了這種關係，並允許被查找的資"
"料在這個問題上有發言權。"

#: ../../howto/descriptor.rst:319
#, fuzzy
msgid ""
"Descriptors are used throughout the language.  It is how functions turn into "
"bound methods.  Common tools like :func:`classmethod`, :func:"
"`staticmethod`, :func:`property`, and :func:`functools.cached_property` are "
"all implemented as descriptors."
msgstr ""
"描述器在整個語言中使用。這就是函式如何變成綁定方法的方式。 "
":func:`classmethod`、:func:`staticmethod`、:func:`property` 和 "
":func:`functools.cached_property` 等常用工具都是作為描述器實作的。"

#: ../../howto/descriptor.rst:326
#, fuzzy
msgid "Complete Practical Example"
msgstr "完整的實例"

#: ../../howto/descriptor.rst:328
#, fuzzy
msgid ""
"In this example, we create a practical and powerful tool for locating "
"notoriously hard to find data corruption bugs."
msgstr "在此示例中，我們建立了一個實用且功能強大的工具，用於定位眾所周知難以發現的資"
"料損壞錯誤。"

#: ../../howto/descriptor.rst:333
#, fuzzy
msgid "Validator class"
msgstr "驗證器類"

#: ../../howto/descriptor.rst:335
#, fuzzy
msgid ""
"A validator is a descriptor for managed attribute access.  Prior to storing "
"any data, it verifies that the new value meets various type and range "
"restrictions.  If those restrictions aren't met, it raises an exception to "
"prevent data corruption at its source."
msgstr ""
"驗證器是用於託管屬性訪問的描述器。在儲存任何資料之前，它會驗證新值是否滿足各"
"種型別和範圍限制。如果不滿足這些限制，它會引發例外以防止資料在源頭上損壞。"

#: ../../howto/descriptor.rst:340
#, fuzzy
msgid ""
"This :class:`Validator` class is both an :term:`abstract base class` and a "
"managed attribute descriptor:"
msgstr "這個 :class:`Validator` 類既是一個 :term:`抽象基底類別` "
"也是一個託管屬性描述器："

#: ../../howto/descriptor.rst:363
#, fuzzy
msgid ""
"Custom validators need to inherit from :class:`Validator` and must supply a :"
"meth:`validate` method to test various restrictions as needed."
msgstr "自定義驗證器需要繼承自 :class:`Validator` 並且必須提供一個 :meth:`validate` "
"方法來根據需要測試各種限制。"

#: ../../howto/descriptor.rst:368
#, fuzzy
msgid "Custom validators"
msgstr "自定義驗證器"

#: ../../howto/descriptor.rst:370
#, fuzzy
msgid "Here are three practical data validation utilities:"
msgstr "以下是三個實用的資料驗證實用程式："

#: ../../howto/descriptor.rst:372
#, fuzzy
msgid ""
":class:`OneOf` verifies that a value is one of a restricted set of options."
msgstr ":class:`OneOf` 驗證一個值是一組受限制的選項之一。"

#: ../../howto/descriptor.rst:374
#, fuzzy
msgid ""
":class:`Number` verifies that a value is either an :class:`int` or :class:"
"`float`.  Optionally, it verifies that a value is between a given minimum or "
"maximum."
msgstr ""
":class:`Number` 驗證一個值是 :class:`int` 還是 "
":class:`float`。可選地，它驗證值是否介於給定的最小值或最大值之間。"

#: ../../howto/descriptor.rst:378
#, fuzzy
msgid ""
":class:`String` verifies that a value is a :class:`str`.  Optionally, it "
"validates a given minimum or maximum length.  It can validate a user-defined "
"`predicate <https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)>`_ "
"as well."
msgstr ""
":class:`String` 驗證一個值是否為 "
":class:`str`。可選地，它驗證給定的最小或最大長度。"
"它還可以驗證使用者定義的謂詞 <https://en.wikipedia.org/wiki/"
"Predicate_(mathematical_logic)>`_。"

#: ../../howto/descriptor.rst:437
#, fuzzy
msgid "Practical application"
msgstr "實際應用"

#: ../../howto/descriptor.rst:439
#, fuzzy
msgid "Here's how the data validators can be used in a real class:"
msgstr "以下是資料驗證器如何在真實類中使用："

#: ../../howto/descriptor.rst:454
#, fuzzy
msgid "The descriptors prevent invalid instances from being created:"
msgstr "描述器防止建立無效實例："

#: ../../howto/descriptor.rst:481
#, fuzzy
msgid "Technical Tutorial"
msgstr "技術教程"

#: ../../howto/descriptor.rst:483
#, fuzzy
msgid ""
"What follows is a more technical tutorial for the mechanics and details of "
"how descriptors work."
msgstr "接下來是關於描述器如何工作的機制和細節的更技術性的教程。"

#: ../../howto/descriptor.rst:488
msgid "Abstract"
msgstr "摘要"

#: ../../howto/descriptor.rst:490
#, fuzzy
msgid ""
"Defines descriptors, summarizes the protocol, and shows how descriptors are "
"called.  Provides an example showing how object relational mappings work."
msgstr "定義描述器，總結協定，並展示如何呼叫描述器。提供一個示例，說明物件關係映射的"
"工作原理。"

#: ../../howto/descriptor.rst:493
#, fuzzy
msgid ""
"Learning about descriptors not only provides access to a larger toolset, it "
"creates a deeper understanding of how Python works."
msgstr "了解描述器不僅可以訪問更大的工具集，還可以更深入地了解 Python 的工作原理。"

#: ../../howto/descriptor.rst:498
#, fuzzy
msgid "Definition and introduction"
msgstr "定義與介紹"

#: ../../howto/descriptor.rst:500
#, fuzzy
msgid ""
"In general, a descriptor is an attribute value that has one of the methods "
"in the descriptor protocol.  Those methods are :meth:`__get__`, :meth:"
"`__set__`, and :meth:`__delete__`.  If any of those methods are defined for "
"an attribute, it is said to be a :term:`descriptor`."
msgstr ""
"通常，描述器是一個屬性值，它具有描述器協定中的方法之一。這些方法是 :meth:`__ge"
"t__`、:meth:`__set__` "
"和 :meth:`__delete__`。如果為屬性定義了這些方法中的任何一個，則稱其為描述器。"

#: ../../howto/descriptor.rst:505
#, fuzzy
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary.  For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the method resolution order of ``type(a)``. If the looked-"
"up value is an object defining one of the descriptor methods, then Python "
"may override the default behavior and invoke the descriptor method instead. "
"Where this occurs in the precedence chain depends on which descriptor "
"methods were defined."
msgstr ""
"屬性訪問的預設行為是從物件的字典中獲取、設定或刪除屬性。例如，``a.x`` "
"有一個以``a.__dict__['x']`` 開頭的查找鏈，然後是``type(a)."
"__dict__['x']``，並繼續通過方法解析``type(a)`` "
"的順序。如果查找的值是定義描述器方法之一的物件，則 Python 可能會覆蓋預設行為"
"並改為呼叫描述器方法。這在優先鏈中發生的位置取決於定義了哪些描述器方法。"

#: ../../howto/descriptor.rst:514
#, fuzzy
msgid ""
"Descriptors are a powerful, general purpose protocol.  They are the "
"mechanism behind properties, methods, static methods, class methods, and :"
"func:`super()`.  They are used throughout Python itself.  Descriptors "
"simplify the underlying C code and offer a flexible set of new tools for "
"everyday Python programs."
msgstr ""
"描述器是一種功能強大的通用協定。它們是屬性、方法、靜態方法、類方法和 "
":func:`super()` 背後的機制。它們在整個 Python 本身中使用。描述器簡化了底層 C "
"程式碼，並為日常 Python 程式提供了一組靈活的新工具。"

#: ../../howto/descriptor.rst:522
#, fuzzy
msgid "Descriptor protocol"
msgstr "描述器協定"

#: ../../howto/descriptor.rst:524
msgid "``descr.__get__(self, obj, type=None) -> value``"
msgstr "``descr.__get__(self, obj, type=None) -> value``"

#: ../../howto/descriptor.rst:526
msgid "``descr.__set__(self, obj, value) -> None``"
msgstr "``descr.__set__(self, obj, value) -> None``"

#: ../../howto/descriptor.rst:528
msgid "``descr.__delete__(self, obj) -> None``"
msgstr "``descr.__delete__(self, obj) -> None``"

#: ../../howto/descriptor.rst:530
#, fuzzy
msgid ""
"That is all there is to it.  Define any of these methods and an object is "
"considered a descriptor and can override default behavior upon being looked "
"up as an attribute."
msgstr "這就是它的全部。定義這些方法中的任何一個，對像被視為描述器，並且可以在作為屬"
"性查找時覆蓋預設行為。"

#: ../../howto/descriptor.rst:534
#, fuzzy
msgid ""
"If an object defines :meth:`__set__` or :meth:`__delete__`, it is considered "
"a data descriptor.  Descriptors that only define :meth:`__get__` are called "
"non-data descriptors (they are often used for methods but other uses are "
"possible)."
msgstr ""
"如果一個物件定義了 :meth:`__set__` 或 "
":meth:`__delete__`，它被認為是一個資料描述器。僅定義 :meth:`__get__` "
"的描述器稱為非資料描述器（它們通常用於方法，但也可能用於其他用途）。"

#: ../../howto/descriptor.rst:539
#, fuzzy
msgid ""
"Data and non-data descriptors differ in how overrides are calculated with "
"respect to entries in an instance's dictionary.  If an instance's dictionary "
"has an entry with the same name as a data descriptor, the data descriptor "
"takes precedence.  If an instance's dictionary has an entry with the same "
"name as a non-data descriptor, the dictionary entry takes precedence."
msgstr ""
"資料和非資料描述器的不同之處在於如何根據實例字典中的條目計算覆蓋。如果一個實"
"例的字典有一個與資料描述器同名的條目，則資料描述器優先。如果一個實例的字典有"
"一個與非資料描述器同名的條目，則該字典條目優先。"

#: ../../howto/descriptor.rst:545
#, fuzzy
msgid ""
"To make a read-only data descriptor, define both :meth:`__get__` and :meth:"
"`__set__` with the :meth:`__set__` raising an :exc:`AttributeError` when "
"called.  Defining the :meth:`__set__` method with an exception raising "
"placeholder is enough to make it a data descriptor."
msgstr ""
"要建立只讀資料描述器，請定義 :meth:`__get__` 和 :meth:`__set__` "
"並在呼叫時使用 :meth:`__set__` 引發 :exc:`AttributeError`。"
"使用引發例外的佔位符定義 :meth:`__set__` 方法足以使其成為資料描述器。"

#: ../../howto/descriptor.rst:552
#, fuzzy
msgid "Overview of descriptor invocation"
msgstr "描述器呼叫概述"

#: ../../howto/descriptor.rst:554
#, fuzzy
msgid ""
"A descriptor can be called directly with ``desc.__get__(obj)`` or ``desc."
"__get__(None, cls)``."
msgstr "可以使用“desc.__get__(obj)”或“desc.__get__(None, cls)”直接呼叫描述器。"

#: ../../howto/descriptor.rst:557
#, fuzzy
msgid ""
"But it is more common for a descriptor to be invoked automatically from "
"attribute access."
msgstr "但更常見的是從屬性訪問中自動呼叫描述器。"

#: ../../howto/descriptor.rst:560
#, fuzzy
msgid ""
"The expression ``obj.x`` looks up the attribute ``x`` in the chain of "
"namespaces for ``obj``.  If the search finds a descriptor outside of the "
"instance ``__dict__``, its :meth:`__get__` method is invoked according to "
"the precedence rules listed below."
msgstr ""
"表達式“obj.x”在 ``obj``的命名空間鏈中查找屬性 ``x``。如果搜索在實例 ``__dict__`` "
"之外找到描述器，則根據下面列出的優先規則呼叫其 :meth:`__get__` 方法。"

#: ../../howto/descriptor.rst:565
#, fuzzy
msgid ""
"The details of invocation depend on whether ``obj`` is an object, class, or "
"instance of super."
msgstr "呼叫的細節取決於 ``obj`` 是物件、類還是 super 的實例。"

#: ../../howto/descriptor.rst:570
#, fuzzy
msgid "Invocation from an instance"
msgstr "從實例呼叫"

#: ../../howto/descriptor.rst:572
#, fuzzy
msgid ""
"Instance lookup scans through a chain of namespaces giving data descriptors "
"the highest priority, followed by instance variables, then non-data "
"descriptors, then class variables, and lastly :meth:`__getattr__` if it is "
"provided."
msgstr ""
"實例查找掃描命名空間鏈，給予資料描述器最高優先級，其次是實例變數，然後是非資"
"料描述器，然後是類變數，最後是 :meth:`__getattr__`（如果提供）。"

#: ../../howto/descriptor.rst:577
#, fuzzy
msgid ""
"If a descriptor is found for ``a.x``, then it is invoked with: ``desc."
"__get__(a, type(a))``."
msgstr "如果為 ``a.x`` 找到描述器，則呼叫它：``desc.__get__(a, type(a))``。"

#: ../../howto/descriptor.rst:580
#, fuzzy
msgid ""
"The logic for a dotted lookup is in :meth:`object.__getattribute__`.  Here "
"is a pure Python equivalent:"
msgstr "點式查找的邏輯在 :meth:`object.__getattribute__` 中。這是一個純 Python "
"等價物："

#: ../../howto/descriptor.rst:719
#, fuzzy
msgid ""
"Note, there is no :meth:`__getattr__` hook in the :meth:`__getattribute__` "
"code.  That is why calling :meth:`__getattribute__` directly or with "
"``super().__getattribute__`` will bypass :meth:`__getattr__` entirely."
msgstr ""
"請注意，在 :meth:`__getattribute__` 程式碼中沒有 :meth:`__getattr__` 鉤子。"
"這就是為什麼直接呼叫 :meth:`__getattribute__` 或使用 ``super()."
"__getattribute__`` 將完全繞過 :meth:`__getattr__` 的原因。"

#: ../../howto/descriptor.rst:723
#, fuzzy
msgid ""
"Instead, it is the dot operator and the :func:`getattr` function that are "
"responsible for invoking :meth:`__getattr__` whenever :meth:"
"`__getattribute__` raises an :exc:`AttributeError`.  Their logic is "
"encapsulated in a helper function:"
msgstr ""
"相反，每當 :meth:`__getattribute__` 引發 :exc:`AttributeError` 時，負責呼叫 "
":meth:`__getattr__` 的是點運算符和 :func:`getattr` "
"函式。它們的邏輯封裝在輔助函式中："

#: ../../howto/descriptor.rst:773
#, fuzzy
msgid "Invocation from a class"
msgstr "從類中呼叫"

#: ../../howto/descriptor.rst:775
#, fuzzy
msgid ""
"The logic for a dotted lookup such as ``A.x`` is in :meth:`type."
"__getattribute__`.  The steps are similar to those for :meth:`object."
"__getattribute__` but the instance dictionary lookup is replaced by a search "
"through the class's :term:`method resolution order`."
msgstr ""
"諸如 ``A.x`` 的點式查找的邏輯在 :meth:`type.__getattribute__` 中。這些步驟與 "
":meth:`object.__getattribute__` 的步驟類似，但實例字典查找被替換為通過類的 "
":term:`method resolution order` 進行搜索。"

#: ../../howto/descriptor.rst:780
#, fuzzy
msgid "If a descriptor is found, it is invoked with ``desc.__get__(None, A)``."
msgstr "如果找到描述器，則使用 desc.__get__(None, A) 呼叫它。"

#: ../../howto/descriptor.rst:782
#, fuzzy
msgid ""
"The full C implementation can be found in :c:func:`type_getattro()` and :c:"
"func:`_PyType_Lookup()` in :source:`Objects/typeobject.c`."
msgstr ""
"完整的 C 實作可以在 :c:func:`type_getattro()` 和 :c:func:`_PyType_Lookup()` "
"中找到 :source:`Objects/typeobject.c`。"

#: ../../howto/descriptor.rst:787
#, fuzzy
msgid "Invocation from super"
msgstr "從超級呼叫"

#: ../../howto/descriptor.rst:789
#, fuzzy
msgid ""
"The logic for super's dotted lookup is in the :meth:`__getattribute__` "
"method for object returned by :class:`super()`."
msgstr "super 的點式查找邏輯在 :meth:`super()` 回傳的物件的 :meth:`__getattribute__` "
"方法中。"

#: ../../howto/descriptor.rst:792
#, fuzzy
msgid ""
"A dotted lookup such as ``super(A, obj).m`` searches ``obj.__class__."
"__mro__`` for the base class ``B`` immediately following ``A`` and then "
"returns ``B.__dict__['m'].__get__(obj, A)``.  If not a descriptor, ``m`` is "
"returned unchanged."
msgstr ""
"諸如 ``super(A, obj).m`` 之類的點查找在 ``A`` 之後搜索 ``obj.__class__."
"__mro__`` 以查找基底類別 ``B``，然後回傳 ``B。 __dict__['m'].__get__(obj, "
"A)``。如果不是描述器，則 ``m``不變地回傳。"

#: ../../howto/descriptor.rst:797
#, fuzzy
msgid ""
"The full C implementation can be found in :c:func:`super_getattro()` in :"
"source:`Objects/typeobject.c`.  A pure Python equivalent can be found in "
"`Guido's Tutorial <https://www.python.org/download/releases/2.2.3/descrintro/"
"#cooperation>`_."
msgstr ""
"完整的 C 實作可以在 :source:`Objects/typeobject.c` 的 "
":c:func:`super_getattro()` 中找到。可以在“Guido 的教程 <https://www.python."
"org/download/releases/2.2.3/descrintro/#cooperation>”中找到純 Python 等效項。"

#: ../../howto/descriptor.rst:804
#, fuzzy
msgid "Summary of invocation logic"
msgstr "呼叫邏輯總結"

#: ../../howto/descriptor.rst:806
#, fuzzy
msgid ""
"The mechanism for descriptors is embedded in the :meth:`__getattribute__()` "
"methods for :class:`object`, :class:`type`, and :func:`super`."
msgstr "描述器機制嵌入在 object、type 和 super 的 __getattribute__() 方法中。"

#: ../../howto/descriptor.rst:809
#, fuzzy
msgid "The important points to remember are:"
msgstr "要記住的要點是："

#: ../../howto/descriptor.rst:811
#, fuzzy
msgid "Descriptors are invoked by the :meth:`__getattribute__` method."
msgstr "描述器由 :meth:`__getattribute__` 方法呼叫。"

#: ../../howto/descriptor.rst:813
#, fuzzy
msgid ""
"Classes inherit this machinery from :class:`object`, :class:`type`, or :func:"
"`super`."
msgstr "類從 :class:`object`、:class:`type` 或 :func:`super` 繼承這種機制。"

#: ../../howto/descriptor.rst:816
#, fuzzy
msgid ""
"Overriding :meth:`__getattribute__` prevents automatic descriptor calls "
"because all the descriptor logic is in that method."
msgstr "重寫 :meth:`__getattribute__` "
"會阻止自動描述器呼叫，因為所有描述器邏輯都在該方法中。"

#: ../../howto/descriptor.rst:819
#, fuzzy
msgid ""
":meth:`object.__getattribute__` and :meth:`type.__getattribute__` make "
"different calls to :meth:`__get__`.  The first includes the instance and may "
"include the class.  The second puts in ``None`` for the instance and always "
"includes the class."
msgstr ""
":meth:`object.__getattribute__` 和 :meth:`type.__getattribute__` 對 "
":meth:`__get__` 進行不同的呼叫。第一個包括實例，也可能包括類。第二個為實例放"
"入 ``None`` 並始終包含類。"

#: ../../howto/descriptor.rst:824
#, fuzzy
msgid "Data descriptors always override instance dictionaries."
msgstr "資料描述器總是覆蓋實例字典。"

#: ../../howto/descriptor.rst:826
#, fuzzy
msgid "Non-data descriptors may be overridden by instance dictionaries."
msgstr "非資料描述器可能會被實例字典覆蓋。"

#: ../../howto/descriptor.rst:830
#, fuzzy
msgid "Automatic name notification"
msgstr "自動名稱通知"

#: ../../howto/descriptor.rst:832
#, fuzzy
msgid ""
"Sometimes it is desirable for a descriptor to know what class variable name "
"it was assigned to.  When a new class is created, the :class:`type` "
"metaclass scans the dictionary of the new class.  If any of the entries are "
"descriptors and if they define :meth:`__set_name__`, that method is called "
"with two arguments.  The *owner* is the class where the descriptor is used, "
"and the *name* is the class variable the descriptor was assigned to."
msgstr ""
"有時需要描述器知道它被分配給什麼類變數名。建立新類時，:class:`type` "
"元類會掃描新類的字典。如果任何條目是描述器，並且如果它們定義了 "
":meth:`__set_name__`，則使用兩個參數呼叫該方法。 *owner* "
"是使用描述器的類，*name* 是描述器分配給的類變數。"

#: ../../howto/descriptor.rst:839
#, fuzzy
msgid ""
"The implementation details are in :c:func:`type_new()` and :c:func:"
"`set_names()` in :source:`Objects/typeobject.c`."
msgstr ""
"實作細節在:c:func:`type_new()` 和:c:func:`set_names()` 在 :source:`Objects/"
"typeobject.c` 中。"

#: ../../howto/descriptor.rst:842
#, fuzzy
msgid ""
"Since the update logic is in :meth:`type.__new__`, notifications only take "
"place at the time of class creation.  If descriptors are added to the class "
"afterwards, :meth:`__set_name__` will need to be called manually."
msgstr ""
"由於更新邏輯在 :meth:`type.__new__` "
"中，通知僅在類建立時發生。如果之後將描述器新增到類中，則需要手動呼叫 "
":meth:`__set_name__`。"

#: ../../howto/descriptor.rst:848
msgid "ORM example"
msgstr "ORM 範例"

#: ../../howto/descriptor.rst:850
#, fuzzy
msgid ""
"The following code is a simplified skeleton showing how data descriptors "
"could be used to implement an `object relational mapping <https://en."
"wikipedia.org/wiki/Object%E2%80%93relational_mapping>`_."
msgstr ""
"以下程式碼是一個簡化的框架，展示瞭如何使用資料描述器來實作“物件關係映射 "
"<https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping>”。"

#: ../../howto/descriptor.rst:854
#, fuzzy
msgid ""
"The essential idea is that the data is stored in an external database.  The "
"Python instances only hold keys to the database's tables.  Descriptors take "
"care of lookups or updates:"
msgstr "基本思想是資料儲存在外部資料庫中。 Python "
"實例僅保存資料庫表的鍵。描述器負責查找或更新："

#: ../../howto/descriptor.rst:873
#, fuzzy
msgid ""
"We can use the :class:`Field` class to define `models <https://en.wikipedia."
"org/wiki/Database_model>`_ that describe the schema for each table in a "
"database:"
msgstr ""
"我們可以使用 Field 類來定義描述資料庫中每個表的模式的模型<https://en."
"wikipedia.org/wiki/Database_model>："

#: ../../howto/descriptor.rst:898
#, fuzzy
msgid "To use the models, first connect to the database::"
msgstr "要使用模型，首先連接到資料庫::"

#: ../../howto/descriptor.rst:903
#, fuzzy
msgid ""
"An interactive session shows how data is retrieved from the database and how "
"it can be updated:"
msgstr "交互式會話顯示瞭如何從資料庫中檢索資料以及如何更新資料："

#: ../../howto/descriptor.rst:948
#, fuzzy
msgid "Pure Python Equivalents"
msgstr "純 Python 等價物"

#: ../../howto/descriptor.rst:950
#, fuzzy
msgid ""
"The descriptor protocol is simple and offers exciting possibilities.  "
"Several use cases are so common that they have been prepackaged into built-"
"in tools. Properties, bound methods, static methods, class methods, and "
"\\_\\_slots\\_\\_ are all based on the descriptor protocol."
msgstr ""
"描述器協定很簡單，並提供了令人興奮的可能性。一些用例是如此常見，以至於它們已"
"被預先打包到內建工具中。屬性、綁定方法、靜態方法、類方法和 \\_\\_slots\\_\\_ "
"都基於描述器協定。"

#: ../../howto/descriptor.rst:957
#, fuzzy
msgid "Properties"
msgstr "特性"

#: ../../howto/descriptor.rst:959
#, fuzzy
msgid ""
"Calling :func:`property` is a succinct way of building a data descriptor "
"that triggers a function call upon access to an attribute.  Its signature "
"is::"
msgstr "呼叫 :func:`property` 是一種構建資料描述器的簡潔方法，該資料描述器在訪問屬性"
"時觸發函式呼叫。它的簽名是："

#: ../../howto/descriptor.rst:964
#, fuzzy
msgid ""
"The documentation shows a typical use to define a managed attribute ``x``:"
msgstr "該文檔顯示了定義託管屬性 ``x``的典型用法："

#: ../../howto/descriptor.rst:988
#, fuzzy
msgid ""
"To see how :func:`property` is implemented in terms of the descriptor "
"protocol, here is a pure Python equivalent:"
msgstr "要了解 :func:`property` 是如何根據描述器協定實作的，這裡有一個純 Python "
"等效項："

#: ../../howto/descriptor.rst:1091
#, fuzzy
msgid ""
"The :func:`property` builtin helps whenever a user interface has granted "
"attribute access and then subsequent changes require the intervention of a "
"method."
msgstr ":func:`property` "
"內建函式在使用者界面授予屬性訪問權限並且隨後的更改需要方法干預時提供幫助。"

#: ../../howto/descriptor.rst:1095
#, fuzzy
msgid ""
"For instance, a spreadsheet class may grant access to a cell value through "
"``Cell('b10').value``. Subsequent improvements to the program require the "
"cell to be recalculated on every access; however, the programmer does not "
"want to affect existing client code accessing the attribute directly.  The "
"solution is to wrap access to the value attribute in a property data "
"descriptor:"
msgstr ""
"例如，電子表格類可以通過“Cell('b10').value”授予對單元格值的訪問權限。程式的後"
"續改進要求在每次訪問時重新計算單元格；但是，程式員不想影響直接訪問該屬性的現"
"有客戶端程式碼。解決方案是將對 value 屬性的訪問包裝在屬性資料描述器中："

#: ../../howto/descriptor.rst:1112
#, fuzzy
msgid ""
"Either the built-in :func:`property` or our :func:`Property` equivalent "
"would work in this example."
msgstr "內建的 :func:`property` 或我們的 :func:`Property` "
"等價物都可以在這個例子中使用。"

#: ../../howto/descriptor.rst:1117
#, fuzzy
msgid "Functions and methods"
msgstr "函式和方法"

#: ../../howto/descriptor.rst:1119
#, fuzzy
msgid ""
"Python's object oriented features are built upon a function based "
"environment. Using non-data descriptors, the two are merged seamlessly."
msgstr "Python "
"的面向物件特性是建立在基於函式的環境之上的。使用非資料描述器，兩者無縫合併。"

#: ../../howto/descriptor.rst:1122
#, fuzzy
msgid ""
"Functions stored in class dictionaries get turned into methods when invoked. "
"Methods only differ from regular functions in that the object instance is "
"prepended to the other arguments.  By convention, the instance is called "
"*self* but could be called *this* or any other variable name."
msgstr ""
"儲存在類字典中的函式在呼叫時會變成方法。方法與常規函式的唯一區別在於物件實例"
"被新增到其他參數之前。按照慣例，該實例稱為 *self*，但也可以稱為 *this* "
"或任何其他變數名。"

#: ../../howto/descriptor.rst:1127
#, fuzzy
msgid ""
"Methods can be created manually with :class:`types.MethodType` which is "
"roughly equivalent to:"
msgstr "可以使用 types.MethodType 手動建立方法，大致相當於："

#: ../../howto/descriptor.rst:1144
#, fuzzy
msgid ""
"To support automatic creation of methods, functions include the :meth:"
"`__get__` method for binding methods during attribute access.  This means "
"that functions are non-data descriptors that return bound methods during "
"dotted lookup from an instance.  Here's how it works:"
msgstr ""
"為了支援自動建立方法，函式包括 :meth:`__get__` 方法，用於在屬性訪問期間綁定方"
"法。這意味著函式是非資料描述器，在從實例進行點式查找期間回傳綁定方法。它是這"
"樣工作的："

#: ../../howto/descriptor.rst:1160
#, fuzzy
msgid ""
"Running the following class in the interpreter shows how the function "
"descriptor works in practice:"
msgstr "在直譯器中運行以下類顯示函式描述器在實踐中是如何工作的："

#: ../../howto/descriptor.rst:1169
#, fuzzy
msgid ""
"The function has a :term:`qualified name` attribute to support introspection:"
msgstr "該函式有一個 :term:`qualified name` 屬性來支援內省："

#: ../../howto/descriptor.rst:1176
#, fuzzy
msgid ""
"Accessing the function through the class dictionary does not invoke :meth:"
"`__get__`.  Instead, it just returns the underlying function object::"
msgstr "通過類字典訪問函式不會呼叫 :meth:`__get__`。相反，它只回傳底層函式物件::"

#: ../../howto/descriptor.rst:1182
#, fuzzy
msgid ""
"Dotted access from a class calls :meth:`__get__` which just returns the "
"underlying function unchanged::"
msgstr "來自類呼叫的點式訪問 :meth:`__get__` 只回傳未改變的底層函式::"

#: ../../howto/descriptor.rst:1188
#, fuzzy
msgid ""
"The interesting behavior occurs during dotted access from an instance.  The "
"dotted lookup calls :meth:`__get__` which returns a bound method object::"
msgstr "有趣的行為發生在從實例進行點式訪問期間。點式查找呼叫 :meth:`__get__` "
"回傳綁定方法物件::"

#: ../../howto/descriptor.rst:1195
#, fuzzy
msgid ""
"Internally, the bound method stores the underlying function and the bound "
"instance::"
msgstr "在內部，綁定方法儲存底層函式和綁定實例::"

#: ../../howto/descriptor.rst:1204
#, fuzzy
msgid ""
"If you have ever wondered where *self* comes from in regular methods or "
"where *cls* comes from in class methods, this is it!"
msgstr "如果您曾經想知道 *self* 在常規方法中的來源或 *cls* "
"在類方法中的來源，就是這樣！"

#: ../../howto/descriptor.rst:1209
#, fuzzy
msgid "Kinds of methods"
msgstr "方法種類"

#: ../../howto/descriptor.rst:1211
#, fuzzy
msgid ""
"Non-data descriptors provide a simple mechanism for variations on the usual "
"patterns of binding functions into methods."
msgstr "非資料描述器為將函式綁定到方法的常用模式的變體提供了一種簡單的機制。"

#: ../../howto/descriptor.rst:1214
#, fuzzy
msgid ""
"To recap, functions have a :meth:`__get__` method so that they can be "
"converted to a method when accessed as attributes.  The non-data descriptor "
"transforms an ``obj.f(*args)`` call into ``f(obj, *args)``.  Calling ``cls."
"f(*args)`` becomes ``f(*args)``."
msgstr ""
"回顧一下，函式有一個 :meth:`__get__` "
"方法，因此當它們作為屬性訪問時可以轉換為方法。非資料描述器將 ``obj.f(*args)``"
" 呼叫轉換為 ``f(obj, *args)``。呼叫 ``cls.f(*args)`` 變成 ``f(*args)``。"

#: ../../howto/descriptor.rst:1219
#, fuzzy
msgid "This chart summarizes the binding and its two most useful variants:"
msgstr "此圖表總結了綁定及其兩個最有用的變體："

#: ../../howto/descriptor.rst:1222
#, fuzzy
msgid "Transformation"
msgstr "轉型"

#: ../../howto/descriptor.rst:1222
#, fuzzy
msgid "Called from an object"
msgstr "從物件呼叫"

#: ../../howto/descriptor.rst:1222
#, fuzzy
msgid "Called from a class"
msgstr "從類中呼叫"

#: ../../howto/descriptor.rst:1225
msgid "function"
msgstr "函式"

#: ../../howto/descriptor.rst:1225
msgid "f(obj, \\*args)"
msgstr "f(obj, \\*args)"

#: ../../howto/descriptor.rst:1225 ../../howto/descriptor.rst:1227
msgid "f(\\*args)"
msgstr "f(\\*args)"

#: ../../howto/descriptor.rst:1227
msgid "staticmethod"
msgstr "staticmethod"

#: ../../howto/descriptor.rst:1229
msgid "classmethod"
msgstr "classmethod"

#: ../../howto/descriptor.rst:1229
msgid "f(type(obj), \\*args)"
msgstr "f(type(obj), \\*args)"

#: ../../howto/descriptor.rst:1229
msgid "f(cls, \\*args)"
msgstr "f(cls, \\*args)"

#: ../../howto/descriptor.rst:1234
#, fuzzy
msgid "Static methods"
msgstr "靜態方法"

#: ../../howto/descriptor.rst:1236
#, fuzzy
msgid ""
"Static methods return the underlying function without changes.  Calling "
"either ``c.f`` or ``C.f`` is the equivalent of a direct lookup into ``object."
"__getattribute__(c, \"f\")`` or ``object.__getattribute__(C, \"f\")``. As a "
"result, the function becomes identically accessible from either an object or "
"a class."
msgstr ""
"靜態方法回傳底層函式而不做任何更改。呼叫 ``c.f`` 或 ``C.f`` 等同於直接查找 "
"``object.__getattribute__(c, \"f\")`` 或 ``object.__getattribute__(C, \"f\""
")`` .結果，該函式變得可以從對像或類中以相同的方式訪問。"

#: ../../howto/descriptor.rst:1242
#, fuzzy
msgid ""
"Good candidates for static methods are methods that do not reference the "
"``self`` variable."
msgstr "靜態方法的良好候選者是不引用 ``self`` 變數的方法。"

#: ../../howto/descriptor.rst:1245
#, fuzzy
msgid ""
"For instance, a statistics package may include a container class for "
"experimental data.  The class provides normal methods for computing the "
"average, mean, median, and other descriptive statistics that depend on the "
"data. However, there may be useful functions which are conceptually related "
"but do not depend on the data.  For instance, ``erf(x)`` is handy conversion "
"routine that comes up in statistical work but does not directly depend on a "
"particular dataset. It can be called either from an object or the class:  "
"``s.erf(1.5) --> .9332`` or ``Sample.erf(1.5) --> .9332``."
msgstr ""
"例如，統計資料包可能包含實驗資料的容器類。該類提供了用於計算平均值、平均數、"
"中位數和其他依賴於資料的描述性統計量的常規方法。然而，可能存在概念上相關但不"
"依賴於資料的有用函式。例如，``erf(x)`` 是統計工作中出現的便捷轉換例程，但不直"
"接依賴於特定資料集。它可以從對像或類中呼叫：``s.erf(1.5) --> .9332`` 或 "
"``Sample.erf(1.5) --> .9332``。"

#: ../../howto/descriptor.rst:1254
#, fuzzy
msgid ""
"Since static methods return the underlying function with no changes, the "
"example calls are unexciting:"
msgstr "由於靜態方法回傳的底層函式沒有任何變化，因此示例呼叫並不令人興奮："

#: ../../howto/descriptor.rst:1271
#, fuzzy
msgid ""
"Using the non-data descriptor protocol, a pure Python version of :func:"
"`staticmethod` would look like this:"
msgstr "使用非資料描述器協定，:func:`staticmethod` 的純 Python 版本如下所示："

#: ../../howto/descriptor.rst:1291
#, fuzzy
msgid ""
"The :func:`functools.update_wrapper` call adds a ``__wrapped__`` attribute "
"that refers to the underlying function.  Also it carries forward the "
"attributes necessary to make the wrapper look like the wrapped function: "
"``__name__``, ``__qualname__``, ``__doc__``, and ``__annotations__``."
msgstr ""
":func:`functools.update_wrapper` 呼叫新增了一個指向底層函式的 ``__wrapped__``"
" 屬性。它還繼承了使包裝器看起來像包裝函式所必需的屬性：``__name__``、``__qual"
"name__``、``__doc__`` 和 ``__annotations__``。"

#: ../../howto/descriptor.rst:1359
#, fuzzy
msgid "Class methods"
msgstr "類方法"

#: ../../howto/descriptor.rst:1361
#, fuzzy
msgid ""
"Unlike static methods, class methods prepend the class reference to the "
"argument list before calling the function.  This format is the same for "
"whether the caller is an object or a class:"
msgstr "與靜態方法不同，類方法在呼叫函式之前將類引用新增到參數列表中。對於呼叫者是對"
"像還是類，這種格式是相同的："

#: ../../howto/descriptor.rst:1379
#, fuzzy
msgid ""
"This behavior is useful whenever the method only needs to have a class "
"reference and does not rely on data stored in a specific instance.  One use "
"for class methods is to create alternate class constructors.  For example, "
"the classmethod :func:`dict.fromkeys` creates a new dictionary from a list "
"of keys.  The pure Python equivalent is:"
msgstr ""
"當方法只需要有一個類引用而不依賴於儲存在特定實例中的資料時，此行為很有用。類"
"方法的一種用途是建立備用類構造函式。例如，類方法 :func:`dict.fromkeys` "
"從鍵列表建立一個新字典。純 Python 等價物是："

#: ../../howto/descriptor.rst:1396
#, fuzzy
msgid "Now a new dictionary of unique keys can be constructed like this:"
msgstr "現在可以像這樣構造一個新的唯一鍵字典："

#: ../../howto/descriptor.rst:1406
#, fuzzy
msgid ""
"Using the non-data descriptor protocol, a pure Python version of :func:"
"`classmethod` would look like this:"
msgstr "使用非資料描述器協定，:func:`classmethod` 的純 Python 版本將如下所示："

#: ../../howto/descriptor.rst:1484
#, fuzzy
msgid ""
"The code path for ``hasattr(type(self.f), '__get__')`` was added in Python "
"3.9 and makes it possible for :func:`classmethod` to support chained "
"decorators.  For example, a classmethod and property could be chained "
"together.  In Python 3.11, this functionality was deprecated."
msgstr ""
"在 Python 3.9 中新增了``hasattr(type(self.f), '__get__')`` 的程式碼路徑，"
"使得 :func:`classmethod` "
"可以支援鍊式裝飾器。例如，類方法和屬性可以鏈接在一起。在 Python 3.11 "
"中，此功能已棄用。"

#: ../../howto/descriptor.rst:1502
#, fuzzy
msgid ""
"The :func:`functools.update_wrapper` call in ``ClassMethod`` adds a "
"``__wrapped__`` attribute that refers to the underlying function.  Also it "
"carries forward the attributes necessary to make the wrapper look like the "
"wrapped function: ``__name__``, ``__qualname__``, ``__doc__``, and "
"``__annotations__``."
msgstr ""
"``ClassMethod`` 中的 :func:`functools.update_wrapper` "
"呼叫新增了一個指向底層函式的 `__wrapped__`` 屬性。它還繼承了使包裝器看起來像"
"包裝函式所必需的屬性：``__name__``、``__qualname__``、``__doc__`` 和 "
"``__annotations__``。"

#: ../../howto/descriptor.rst:1510
#, fuzzy
msgid "Member objects and __slots__"
msgstr "成員物件和 __slots__"

#: ../../howto/descriptor.rst:1512
#, fuzzy
msgid ""
"When a class defines ``__slots__``, it replaces instance dictionaries with a "
"fixed-length array of slot values.  From a user point of view that has "
"several effects:"
msgstr "當一個類定義 ``__slots__`` "
"時，它用固定長度的槽值數組替換實例字典。從使用者的角度來看有幾個影響："

#: ../../howto/descriptor.rst:1516
#, fuzzy
msgid ""
"1. Provides immediate detection of bugs due to misspelled attribute "
"assignments.  Only attribute names specified in ``__slots__`` are allowed:"
msgstr "1. 提供對由於拼寫錯誤的屬性分配引起的錯誤的即時檢測。只允許在 ``__slots__`` "
"中指定的屬性名稱："

#: ../../howto/descriptor.rst:1532
#, fuzzy
msgid ""
"2. Helps create immutable objects where descriptors manage access to private "
"attributes stored in ``__slots__``:"
msgstr "2. 幫助建立不可變物件，其中描述器管理對儲存在 ``__slots__`` "
"中的私有屬性的訪問："

#: ../../howto/descriptor.rst:1567
#, fuzzy
msgid ""
"3. Saves memory.  On a 64-bit Linux build, an instance with two attributes "
"takes 48 bytes with ``__slots__`` and 152 bytes without.  This `flyweight "
"design pattern <https://en.wikipedia.org/wiki/Flyweight_pattern>`_ likely "
"only matters when a large number of instances are going to be created."
msgstr ""
"3. 節省記憶體。在 64 位 Linux 構建中，具有兩個屬性的實例佔用 48 個位元組的 "
"``__slots__`` 和 152 個位元組而沒有。這種“享元設計模式 <https://en.wikipedia."
"org/wiki/Flyweight_pattern>”可能只在要建立大量實例時才有意義。"

#: ../../howto/descriptor.rst:1572
#, fuzzy
msgid ""
"4. Improves speed.  Reading instance variables is 35% faster with "
"``__slots__`` (as measured with Python 3.10 on an Apple M1 processor)."
msgstr ""
"4. 提高速度。使用 ``__slots__`` 讀取實例變數的速度提高了 35%（在 Apple M1 "
"處理器上使用 Python 3.10 測量）。"

#: ../../howto/descriptor.rst:1575
#, fuzzy
msgid ""
"5. Blocks tools like :func:`functools.cached_property` which require an "
"instance dictionary to function correctly:"
msgstr "5. 像 :func:`functools.cached_property` "
"這樣的塊工具需要實例字典才能正常運行："

#: ../../howto/descriptor.rst:1597
#, fuzzy
msgid ""
"It is not possible to create an exact drop-in pure Python version of "
"``__slots__`` because it requires direct access to C structures and control "
"over object memory allocation.  However, we can build a mostly faithful "
"simulation where the actual C structure for slots is emulated by a private "
"``_slotvalues`` list.  Reads and writes to that private structure are "
"managed by member descriptors:"
msgstr ""
"不可能建立 ``__slots__`` 的精確嵌入式純 Python 版本，因為它需要直接訪問 C "
"結構並控制物件記憶體分配。然而，我們可以建立一個最忠實的模擬，其中槽的實際 C "
"結構由私有的 _slotvalues 列表模擬。對該私有結構的讀寫由成員描述器管理："

#: ../../howto/descriptor.rst:1642
#, fuzzy
msgid ""
"The :meth:`type.__new__` method takes care of adding member objects to class "
"variables:"
msgstr ":meth:`type.__new__` 方法負責將成員物件新增到類變數中："

#: ../../howto/descriptor.rst:1658
#, fuzzy
msgid ""
"The :meth:`object.__new__` method takes care of creating instances that have "
"slots instead of an instance dictionary.  Here is a rough simulation in pure "
"Python:"
msgstr ":meth:`object.__new__` 方法負責建立具有槽而不是實例字典的實例。這是純 Python "
"中的粗略模擬："

#: ../../howto/descriptor.rst:1693
#, fuzzy
msgid ""
"To use the simulation in a real class, just inherit from :class:`Object` and "
"set the :term:`metaclass` to :class:`Type`:"
msgstr "要在真實類中使用模擬，只需繼承 :class:`Object` 並將 :term:`metaclass` 設定為 "
":class:`Type`："

#: ../../howto/descriptor.rst:1707
#, fuzzy
msgid ""
"At this point, the metaclass has loaded member objects for *x* and *y*::"
msgstr "此時，元類已經加載了 *x* 和 *y*:: 的成員物件："

#: ../../howto/descriptor.rst:1728
#, fuzzy
msgid ""
"When instances are created, they have a ``slot_values`` list where the "
"attributes are stored:"
msgstr "建立實例時，它們有一個儲存屬性的 ``slot_values`` 列表："

#: ../../howto/descriptor.rst:1740
#, fuzzy
msgid "Misspelled or unassigned attributes will raise an exception:"
msgstr "拼寫錯誤或未分配的屬性將引發例外："
