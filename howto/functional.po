# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Leon H., 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-24 00:16+0000\n"
"PO-Revision-Date: 2018-05-23 14:36+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/functional.rst:3
msgid "Functional Programming HOWTO"
msgstr "函式編程 HOWTO"

#: ../../howto/functional.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/functional.rst:5
msgid "A. M. Kuchling"
msgstr "A. M. Kuchling"

#: ../../howto/functional.rst:0
msgid "Release"
msgstr "發佈版本"

#: ../../howto/functional.rst:6
msgid "0.32"
msgstr "0.32"

#: ../../howto/functional.rst:8
#, fuzzy
msgid ""
"In this document, we'll take a tour of Python's features suitable for "
"implementing programs in a functional style.  After an introduction to the "
"concepts of functional programming, we'll look at language features such as :"
"term:`iterator`\\s and :term:`generator`\\s and relevant library modules "
"such as :mod:`itertools` and :mod:`functools`."
msgstr ""
"在本文檔中，我們將瀏覽適用於以函式式風格實作程式的 Python "
"特性。在介紹了函式式編程的概念之後，我們將看看語言特性，例如 :term:`iterator`"
"\\s 和 :term:`generator`\\s 以及相關的庫模組，例如 :mod:`itertools` 和： "
"mod:`functools`。"

#: ../../howto/functional.rst:16
msgid "Introduction"
msgstr "簡介"

#: ../../howto/functional.rst:18
#, fuzzy
msgid ""
"This section explains the basic concept of functional programming; if you're "
"just interested in learning about Python language features, skip to the next "
"section on :ref:`functional-howto-iterators`."
msgstr ""
"本節解釋函式式編程的基本概念；如果您只是對學習 Python "
"語言特性感興趣，請跳到下一節 :ref:`functional-howto-iterators`。"

#: ../../howto/functional.rst:22
#, fuzzy
msgid ""
"Programming languages support decomposing problems in several different ways:"
msgstr "編程語言支援以幾種不同的方式分解問題："

#: ../../howto/functional.rst:24
#, fuzzy
msgid ""
"Most programming languages are **procedural**: programs are lists of "
"instructions that tell the computer what to do with the program's input.  C, "
"Pascal, and even Unix shells are procedural languages."
msgstr ""
"大多數編程語言都是**過程性的**：程式是指令列表，告訴計算機如何處理程式的輸入"
"。 C、Pascal 甚至 Unix shell 都是過程語言。"

#: ../../howto/functional.rst:28
#, fuzzy
msgid ""
"In **declarative** languages, you write a specification that describes the "
"problem to be solved, and the language implementation figures out how to "
"perform the computation efficiently.  SQL is the declarative language you're "
"most likely to be familiar with; a SQL query describes the data set you want "
"to retrieve, and the SQL engine decides whether to scan tables or use "
"indexes, which subclauses should be performed first, etc."
msgstr ""
"在**聲明性**語言中，您編寫了一個描述要解決的問題的規範，而語言實作則確定瞭如"
"何有效地執行計算。 SQL 是您最有可能熟悉的聲明性語言； SQL "
"查詢描述了你要檢索的資料集，SQL "
"引擎決定是掃描表還是使用索引，應該先執行哪些子句等。"

#: ../../howto/functional.rst:35
#, fuzzy
msgid ""
"**Object-oriented** programs manipulate collections of objects.  Objects "
"have internal state and support methods that query or modify this internal "
"state in some way. Smalltalk and Java are object-oriented languages.  C++ "
"and Python are languages that support object-oriented programming, but don't "
"force the use of object-oriented features."
msgstr ""
"**面向物件**程式操作物件集合。物件具有內部狀態和支援以某種方式查詢或修改此內"
"部狀態的方法。 Smalltalk 和 Java 是面向物件的語言。 "
"C++和Python是支援面向物件編程的語言，但並不強制使用面向物件的特性。"

#: ../../howto/functional.rst:41
#, fuzzy
msgid ""
"**Functional** programming decomposes a problem into a set of functions. "
"Ideally, functions only take inputs and produce outputs, and don't have any "
"internal state that affects the output produced for a given input.  Well-"
"known functional languages include the ML family (Standard ML, OCaml, and "
"other variants) and Haskell."
msgstr ""
"**函式式**編程將問題分解為一組函式。理想情況下，函式只接受輸入並產生輸出，並"
"且沒有任何內部狀態會影響針對給定輸入產生的輸出。眾所周知的函式式語言包括 ML "
"家族（Standard ML、OCaml 和其他變體）和 Haskell。"

#: ../../howto/functional.rst:47
#, fuzzy
msgid ""
"The designers of some computer languages choose to emphasize one particular "
"approach to programming.  This often makes it difficult to write programs "
"that use a different approach.  Other languages are multi-paradigm languages "
"that support several different approaches. Lisp, C++, and Python are multi-"
"paradigm; you can write programs or libraries that are largely procedural, "
"object-oriented, or functional in all of these languages.  In a large "
"program, different sections might be written using different approaches; the "
"GUI might be object-oriented while the processing logic is procedural or "
"functional, for example."
msgstr ""
"某些計算機語言的設計者選擇強調一種特定的編程方法。這通常使編寫使用不同方法的"
"程式變得困難。其他語言是支援多種不同方法的多範式語言。 Lisp、C++ 和 Python 是"
"多範式的；您可以使用所有這些語言編寫主要是過程性、面向對像或功能性的程式或庫"
"。在大型程式中，不同的部分可能使用不同的方法編寫；例如，GUI "
"可能是面向物件的，而處理邏輯是過程性的或功能性的。"

#: ../../howto/functional.rst:58
#, fuzzy
msgid ""
"In a functional program, input flows through a set of functions. Each "
"function operates on its input and produces some output.  Functional style "
"discourages functions with side effects that modify internal state or make "
"other changes that aren't visible in the function's return value.  Functions "
"that have no side effects at all are called **purely functional**.  Avoiding "
"side effects means not using data structures that get updated as a program "
"runs; every function's output must only depend on its input."
msgstr ""
"在函式式程式中，輸入流經一組函式。每個函式對其輸入進行操作並產生一些輸出。函"
"式式風格不鼓勵具有修改內部狀態或進行函式回傳值中不可見的其他更改的副作用的函"
"式。完全沒有副作用的函式被稱為**純函式**。避免副作用意味著不使用在程式運行時"
"更新的資料結構；每個函式的輸出必須只依賴於它的輸入。"

#: ../../howto/functional.rst:66
#, fuzzy
msgid ""
"Some languages are very strict about purity and don't even have assignment "
"statements such as ``a=3`` or ``c = a + b``, but it's difficult to avoid all "
"side effects, such as printing to the screen or writing to a disk file. "
"Another example is a call to the :func:`print` or :func:`time.sleep` "
"function, neither of which returns a useful value. Both are called only for "
"their side effects of sending some text to the screen or pausing execution "
"for a second."
msgstr ""
"有些語言對純度非常嚴格，甚至沒有諸如 ``a=3`` 或 ``c = a + b`` "
"之類的賦值語句，但很難避免所有副作用，例如印出到屏幕或寫入磁盤文件。"
"另一個例子是呼叫 :func:`print` 或 :func:`time.sleep` 函式，它們都沒有回傳有用"
"的值。兩者都被呼叫只是因為它們將一些文本發送到屏幕或暫停執行一秒鐘的副作用。"

#: ../../howto/functional.rst:73
#, fuzzy
msgid ""
"Python programs written in functional style usually won't go to the extreme "
"of avoiding all I/O or all assignments; instead, they'll provide a "
"functional-appearing interface but will use non-functional features "
"internally. For example, the implementation of a function will still use "
"assignments to local variables, but won't modify global variables or have "
"other side effects."
msgstr ""
"以函式式風格編寫的 Python 程式通常不會走到避免所有 I/O 或所有賦值的極端；相反"
"，它們將提供一個功能性的界面，但在內部使用非功能性特徵。例如，函式的實作仍將"
"使用對局部變數的賦值，但不會修改全局變數或產生其他副作用。"

#: ../../howto/functional.rst:79
#, fuzzy
msgid ""
"Functional programming can be considered the opposite of object-oriented "
"programming.  Objects are little capsules containing some internal state "
"along with a collection of method calls that let you modify this state, and "
"programs consist of making the right set of state changes.  Functional "
"programming wants to avoid state changes as much as possible and works with "
"data flowing between functions.  In Python you might combine the two "
"approaches by writing functions that take and return instances representing "
"objects in your application (e-mail messages, transactions, etc.)."
msgstr ""
"函式式編程可以被認為是面向物件編程的對立面。對像是包含一些內部狀態的小膠囊，"
"以及一組允許您修改此狀態的方法呼叫，而程式包括進行正確的一組狀態更改。函式式"
"編程希望盡可能避免狀態變化，並處理函式之間的資料流動。在 Python 中，您可以通"
"過編寫函式來結合這兩種方法，這些函式接受和回傳表示應用程式中物件（電子郵件消"
"息、交易等）的實例。"

#: ../../howto/functional.rst:88
#, fuzzy
msgid ""
"Functional design may seem like an odd constraint to work under.  Why should "
"you avoid objects and side effects?  There are theoretical and practical "
"advantages to the functional style:"
msgstr "功能設計似乎是一種奇怪的工作約束。為什麼要避免物件和副作用？函式式風格具有理"
"論和實踐優勢："

#: ../../howto/functional.rst:92
#, fuzzy
msgid "Formal provability."
msgstr "形式可證明性。"

#: ../../howto/functional.rst:93
#, fuzzy
msgid "Modularity."
msgstr "模組化。"

#: ../../howto/functional.rst:94
#, fuzzy
msgid "Composability."
msgstr "可組合性。"

#: ../../howto/functional.rst:95
#, fuzzy
msgid "Ease of debugging and testing."
msgstr "便於除錯和測試。"

#: ../../howto/functional.rst:99
#, fuzzy
msgid "Formal provability"
msgstr "形式可證明性"

#: ../../howto/functional.rst:101
#, fuzzy
msgid ""
"A theoretical benefit is that it's easier to construct a mathematical proof "
"that a functional program is correct."
msgstr "理論上的好處是更容易構建函式程式正確的數學證明。"

#: ../../howto/functional.rst:104
#, fuzzy
msgid ""
"For a long time researchers have been interested in finding ways to "
"mathematically prove programs correct.  This is different from testing a "
"program on numerous inputs and concluding that its output is usually "
"correct, or reading a program's source code and concluding that the code "
"looks right; the goal is instead a rigorous proof that a program produces "
"the right result for all possible inputs."
msgstr ""
"很長一段時間以來，研究人員一直對尋找從數學上證明程式正確的方法很感興趣。這不"
"同於在大量輸入上測試程式並得出其輸出通常正確的結論，或閱讀程式的源程式碼並得"
"出程式碼看起來正確的結論；相反，目標是嚴格證明程式會為所有可能的輸入產生正確"
"的結果。"

#: ../../howto/functional.rst:111
#, fuzzy
msgid ""
"The technique used to prove programs correct is to write down "
"**invariants**, properties of the input data and of the program's variables "
"that are always true.  For each line of code, you then show that if "
"invariants X and Y are true **before** the line is executed, the slightly "
"different invariants X' and Y' are true **after** the line is executed.  "
"This continues until you reach the end of the program, at which point the "
"invariants should match the desired conditions on the program's output."
msgstr ""
"用於證明程式正確的技術是寫下**不變數**，輸入資料和程式變數的屬性始終為真。然"
"後，對於每一行程式碼，您表明如果不變數 X 和 Y "
"在執行該行之前**為真，那麼在執行該行之後**X' 和 Y' 稍有不同的不變數為真。這一"
"直持續到程式結束，此時不變數應與程式輸出中的所需條件相匹配。"

#: ../../howto/functional.rst:119
#, fuzzy
msgid ""
"Functional programming's avoidance of assignments arose because assignments "
"are difficult to handle with this technique; assignments can break "
"invariants that were true before the assignment without producing any new "
"invariants that can be propagated onward."
msgstr "函式式編程避免賦值的出現是因為賦值很難用這種技術處理；賦值可以破壞在賦值之前"
"為真的不變數，而不會產生任何可以向前傳播的新不變數。"

#: ../../howto/functional.rst:124
#, fuzzy
msgid ""
"Unfortunately, proving programs correct is largely impractical and not "
"relevant to Python software. Even trivial programs require proofs that are "
"several pages long; the proof of correctness for a moderately complicated "
"program would be enormous, and few or none of the programs you use daily "
"(the Python interpreter, your XML parser, your web browser) could be proven "
"correct.  Even if you wrote down or generated a proof, there would then be "
"the question of verifying the proof; maybe there's an error in it, and you "
"wrongly believe you've proved the program correct."
msgstr ""
"不幸的是，證明程式正確在很大程度上是不切實際的，而且與 Python 軟件無關。即使"
"是微不足道的程式也需要幾頁長的證明；一個中等複雜程式的正確性證明將是巨大的，"
"而你日常使用的程式（Python 直譯器、XML 解析器、Web 瀏覽器）很少或根本沒有被證"
"明是正確的。即使你寫下或生成一個證明，也會有驗證證明的問題；也許其中有錯誤，"
"你錯誤地認為你已經證明程式是正確的。"

#: ../../howto/functional.rst:135
#, fuzzy
msgid "Modularity"
msgstr "模組化"

#: ../../howto/functional.rst:137
#, fuzzy
msgid ""
"A more practical benefit of functional programming is that it forces you to "
"break apart your problem into small pieces.  Programs are more modular as a "
"result.  It's easier to specify and write a small function that does one "
"thing than a large function that performs a complicated transformation.  "
"Small functions are also easier to read and to check for errors."
msgstr ""
"函式式編程的一個更實際的好處是它迫使您將問題分解成小塊。結果，程式更加模組化"
"。指定和編寫一個只做一件事的小函式比執行複雜轉換的大函式更容易。小函式也更容"
"易閱讀和檢查錯誤。"

#: ../../howto/functional.rst:145
#, fuzzy
msgid "Ease of debugging and testing"
msgstr "易於除錯和測試"

#: ../../howto/functional.rst:147
#, fuzzy
msgid "Testing and debugging a functional-style program is easier."
msgstr "測試和除錯函式式程式更容易。"

#: ../../howto/functional.rst:149
#, fuzzy
msgid ""
"Debugging is simplified because functions are generally small and clearly "
"specified.  When a program doesn't work, each function is an interface point "
"where you can check that the data are correct.  You can look at the "
"intermediate inputs and outputs to quickly isolate the function that's "
"responsible for a bug."
msgstr ""
"除錯被簡化了，因為功能通常很小並且明確指定。當程式不工作時，每個函式都是一個"
"介面點，您可以在其中檢查資料是否正確。您可以查看中間輸入和輸出以快速隔離導致"
"錯誤的函式。"

#: ../../howto/functional.rst:154
#, fuzzy
msgid ""
"Testing is easier because each function is a potential subject for a unit "
"test. Functions don't depend on system state that needs to be replicated "
"before running a test; instead you only have to synthesize the right input "
"and then check that the output matches expectations."
msgstr ""
"測試更容易，因為每個功能都是單元測試的潛在主題。函式不依賴於在運行測試之前需"
"要復制的系統狀態；相反，您只需合成正確的輸入，然後檢查輸出是否符合預期。"

#: ../../howto/functional.rst:161
#, fuzzy
msgid "Composability"
msgstr "可組合性"

#: ../../howto/functional.rst:163
#, fuzzy
msgid ""
"As you work on a functional-style program, you'll write a number of "
"functions with varying inputs and outputs.  Some of these functions will be "
"unavoidably specialized to a particular application, but others will be "
"useful in a wide variety of programs.  For example, a function that takes a "
"directory path and returns all the XML files in the directory, or a function "
"that takes a filename and returns its contents, can be applied to many "
"different situations."
msgstr ""
"在處理函式式程式時，您將編寫許多具有不同輸入和輸出的函式。其中一些功能將不可"
"避免地專門用於特定應用程式，但其他功能將在各種程式中都有用。例如，"
"接受目錄路徑並回傳目錄中所有 XML "
"文件的函式，或接受文件名並回傳其內容的函式，可以應用於許多不同的情況。"

#: ../../howto/functional.rst:170
#, fuzzy
msgid ""
"Over time you'll form a personal library of utilities.  Often you'll "
"assemble new programs by arranging existing functions in a new configuration "
"and writing a few functions specialized for the current task."
msgstr "隨著時間的推移，您將形成一個個人實用程式庫。通常，您將通過在新配置中安排現有"
"功能並編寫一些專門用於當前任務的功能來組裝新程式。"

#: ../../howto/functional.rst:178
#, fuzzy
msgid "Iterators"
msgstr "疊代器"

#: ../../howto/functional.rst:180
#, fuzzy
msgid ""
"I'll start by looking at a Python language feature that's an important "
"foundation for writing functional-style programs: iterators."
msgstr "我將首先介紹一種 Python 語言特性，它是編寫函式式程式的重要基礎：疊代器。"

#: ../../howto/functional.rst:183
#, fuzzy
msgid ""
"An iterator is an object representing a stream of data; this object returns "
"the data one element at a time.  A Python iterator must support a method "
"called :meth:`~iterator.__next__` that takes no arguments and always returns "
"the next element of the stream.  If there are no more elements in the "
"stream, :meth:`~iterator.__next__` must raise the :exc:`StopIteration` "
"exception. Iterators don't have to be finite, though; it's perfectly "
"reasonable to write an iterator that produces an infinite stream of data."
msgstr ""
"疊代器是表示資料流的物件；該對像一次回傳一個元素的資料。 Python "
"疊代器必須支援一種名為 :meth:`~iterator.__next__` 的方法，該方法不接受任何參"
"數並始終回傳流的下一個元素。如果流中沒有更多元素，:meth:`~iterator.__next__` "
"必須引發 :exc:`StopIteration` "
"例外。不過，疊代器不必是有限的；編寫一個產生無限資料流的疊代器是完全合理的。"

#: ../../howto/functional.rst:191
#, fuzzy
msgid ""
"The built-in :func:`iter` function takes an arbitrary object and tries to "
"return an iterator that will return the object's contents or elements, "
"raising :exc:`TypeError` if the object doesn't support iteration.  Several "
"of Python's built-in data types support iteration, the most common being "
"lists and dictionaries.  An object is called :term:`iterable` if you can get "
"an iterator for it."
msgstr ""
"內建的 :func:`iter` "
"函式接受一個任意物件並嘗試回傳一個疊代器，該疊代器將回傳物件的內容或元素，"
"如果對像不支援疊代則引發 :exc:`TypeError`。 Python 的一些內建資料型別支援疊代"
"，最常見的是列表和字典。如果您可以獲得一個物件的疊代器，則該物件稱為 "
":term:`iterable`。"

#: ../../howto/functional.rst:198
#, fuzzy
msgid "You can experiment with the iteration interface manually:"
msgstr "您可以手動試驗疊代界面："

#: ../../howto/functional.rst:216
#, fuzzy
msgid ""
"Python expects iterable objects in several different contexts, the most "
"important being the :keyword:`for` statement.  In the statement ``for X in "
"Y``, Y must be an iterator or some object for which :func:`iter` can create "
"an iterator.  These two statements are equivalent::"
msgstr ""
"Python 期望在幾個不同的上下文中使用可疊代物件，最重要的是 :keyword:`for` "
"語句。在語句 ``for X in Y`` 中，Y 必須是一個疊代器或 :func:`iter` "
"可以為其建立疊代器的某個物件。這兩個語句是等價的："

#: ../../howto/functional.rst:228
#, fuzzy
msgid ""
"Iterators can be materialized as lists or tuples by using the :func:`list` "
"or :func:`tuple` constructor functions:"
msgstr "疊代器可以通過使用 :func:`list` 或 :func:`tuple` 構造函式具體化為列表或元組："

#: ../../howto/functional.rst:237
#, fuzzy
msgid ""
"Sequence unpacking also supports iterators: if you know an iterator will "
"return N elements, you can unpack them into an N-tuple:"
msgstr "序列解包也支援疊代器：如果你知道疊代器將回傳 N 個元素，"
"你可以將它們解包到一個 N 元組中："

#: ../../howto/functional.rst:246
#, fuzzy
msgid ""
"Built-in functions such as :func:`max` and :func:`min` can take a single "
"iterator argument and will return the largest or smallest element.  The "
"``\"in\"`` and ``\"not in\"`` operators also support iterators: ``X in "
"iterator`` is true if X is found in the stream returned by the iterator.  "
"You'll run into obvious problems if the iterator is infinite; :func:`max`, :"
"func:`min` will never return, and if the element X never appears in the "
"stream, the ``\"in\"`` and ``\"not in\"`` operators won't return either."
msgstr ""
":func:`max` 和 :func:`min` "
"等內建函式可以採用單個疊代器參數，並將回傳最大或最小元素。 ``\"in\"`` 和 ``"
"\"not in\"`` 運算符也支援疊代器：如果在疊代器回傳的流中找到 X，則 ``X in "
"iterator`` 為真。如果疊代器是無限的，你會遇到明顯的問題； :func:`max`, "
":func:`min` 將永遠不會回傳，如果元素 X 從未出現在流中，則 ``\"in\"`` 和 ``"
"\"not in\"`` 運算符將不會回傳任何一個。"

#: ../../howto/functional.rst:254
#, fuzzy
msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it.  Iterator "
"objects can optionally provide these additional capabilities, but the "
"iterator protocol only specifies the :meth:`~iterator.__next__` method.  "
"Functions may therefore consume all of the iterator's output, and if you "
"need to do something different with the same stream, you'll have to create a "
"new iterator."
msgstr ""
"請注意，您只能在疊代器中前進；無法獲取前一個元素、重置疊代器或複制它。疊代器"
"物件可以選擇性地提供這些附加功能，但是疊代器協定只指定了 :meth:`~iterator."
"__next__` 方法。因此，函式可能會消耗疊代器的所有輸出，如果您需要對同一流執行"
"不同的操作，則必須建立一個新的疊代器。"

#: ../../howto/functional.rst:264
#, fuzzy
msgid "Data Types That Support Iterators"
msgstr "支援疊代器的資料型別"

#: ../../howto/functional.rst:266
#, fuzzy
msgid ""
"We've already seen how lists and tuples support iterators.  In fact, any "
"Python sequence type, such as strings, will automatically support creation "
"of an iterator."
msgstr "我們已經看到列表和元組如何支援疊代器。事實上，任何 Python "
"序列型別，例如字串，都會自動支援疊代器的建立。"

#: ../../howto/functional.rst:270
#, fuzzy
msgid ""
"Calling :func:`iter` on a dictionary returns an iterator that will loop over "
"the dictionary's keys::"
msgstr "在字典上呼叫 :func:`iter` 會回傳一個疊代器，該疊代器將循環遍歷字典的鍵::"

#: ../../howto/functional.rst:290
#, fuzzy
msgid ""
"Note that starting with Python 3.7, dictionary iteration order is guaranteed "
"to be the same as the insertion order. In earlier versions, the behaviour "
"was unspecified and could vary between implementations."
msgstr "請注意，從 Python 3.7 開始，字典疊代順序保證與插入順序相同。在早期版本中，行"
"為未指定並且可能因實作而異。"

#: ../../howto/functional.rst:294
#, fuzzy
msgid ""
"Applying :func:`iter` to a dictionary always loops over the keys, but "
"dictionaries have methods that return other iterators.  If you want to "
"iterate over values or key/value pairs, you can explicitly call the :meth:"
"`~dict.values` or :meth:`~dict.items` methods to get an appropriate iterator."
msgstr ""
"將 :func:`iter` 應用於字典總是在鍵上循環，但字典有回傳其他疊代器的方法。如果"
"你想疊代值或鍵/值對，你可以顯式呼叫 :meth:`~dict.values` 或 :meth:`~dict.items`"
" 方法來獲得合適的疊代器。"

#: ../../howto/functional.rst:300
#, fuzzy
msgid ""
"The :func:`dict` constructor can accept an iterator that returns a finite "
"stream of ``(key, value)`` tuples:"
msgstr ":func:`dict` 構造函式可以接受一個疊代器，該疊代器回傳有限的 `(key, value)`` "
"元組流："

#: ../../howto/functional.rst:307
#, fuzzy
msgid ""
"Files also support iteration by calling the :meth:`~io.TextIOBase.readline` "
"method until there are no more lines in the file.  This means you can read "
"each line of a file like this::"
msgstr ""
"文件還支援通過呼叫 :meth:`~io.TextIOBase.readline` "
"方法進行疊代，直到文件中不再有行。這意味著您可以像這樣讀取文件的每一行::"

#: ../../howto/functional.rst:315
#, fuzzy
msgid ""
"Sets can take their contents from an iterable and let you iterate over the "
"set's elements::"
msgstr "集合可以從可疊代對像中獲取它們的內容，並讓您疊代集合的元素::"

#: ../../howto/functional.rst:331
#, fuzzy
msgid "Generator expressions and list comprehensions"
msgstr "生成器表達式和列表理解"

#: ../../howto/functional.rst:333
#, fuzzy
msgid ""
"Two common operations on an iterator's output are 1) performing some "
"operation for every element, 2) selecting a subset of elements that meet "
"some condition. For example, given a list of strings, you might want to "
"strip off trailing whitespace from each line or extract all the strings "
"containing a given substring."
msgstr ""
"疊代器輸出的兩個常見操作是 1) 對每個元素執行一些操作，2) 選擇滿足某些條件的元"
"素子集。例如，給定一個字串列表，您可能希望從每一行中去除尾隨空格或提取包含給"
"定子字串的所有字串。"

#: ../../howto/functional.rst:339
#, fuzzy
msgid ""
"List comprehensions and generator expressions (short form: \"listcomps\" and "
"\"genexps\") are a concise notation for such operations, borrowed from the "
"functional programming language Haskell (https://www.haskell.org/).  You can "
"strip all the whitespace from a stream of strings with the following code::"
msgstr ""
"列表推導式和生成器表達式（簡稱： ``listcomps`` 和 ``genexps`` ）是此類操作的簡明表示"
"法，借鑒了函式式編程語言 Haskell (https://www.haskell.org/"
")。您可以使用以下程式碼從字串流中去除所有空格："

#: ../../howto/functional.rst:352
#, fuzzy
msgid ""
"You can select only certain elements by adding an ``\"if\"`` condition::"
msgstr "您可以通過新增 ``\"if\"`` 條件來僅選擇某些元素："

#: ../../howto/functional.rst:357
#, fuzzy
msgid ""
"With a list comprehension, you get back a Python list; ``stripped_list`` is "
"a list containing the resulting lines, not an iterator.  Generator "
"expressions return an iterator that computes the values as necessary, not "
"needing to materialize all the values at once.  This means that list "
"comprehensions aren't useful if you're working with iterators that return an "
"infinite stream or a very large amount of data.  Generator expressions are "
"preferable in these situations."
msgstr ""
"通過列表推導，你會得到一個 Python 列表； ``stripped_list`` 是包含結果行的列表"
"，而不是疊代器。生成器表達式回傳一個疊代器，該疊代器根據需要計算值，不需要一"
"次具體化所有值。這意味著如果您正在使用回傳無限流或大量資料的疊代器，則列表推"
"導式沒有用。在這些情況下，生成器表達式更可取。"

#: ../../howto/functional.rst:364
#, fuzzy
msgid ""
"Generator expressions are surrounded by parentheses (\"()\") and list "
"comprehensions are surrounded by square brackets (\"[]\").  Generator "
"expressions have the form::"
msgstr "生成器表達式用圓括號 (\"()\") 括起來，列表推導式用方括號 (\"[]\") "
"括起來。生成器表達式具有以下形式："

#: ../../howto/functional.rst:378
#, fuzzy
msgid ""
"Again, for a list comprehension only the outside brackets are different "
"(square brackets instead of parentheses)."
msgstr "同樣，對於列表理解，只有外括號不同（方括號而不是圓括號）。"

#: ../../howto/functional.rst:381
#, fuzzy
msgid ""
"The elements of the generated output will be the successive values of "
"``expression``.  The ``if`` clauses are all optional; if present, "
"``expression`` is only evaluated and added to the result when ``condition`` "
"is true."
msgstr "生成的輸出的元素將是“表達式”的連續值。 ``if`` "
"子句都是可選的；如果存在，“表達式”僅在“條件”為真時被評估並新增到結果中。"

#: ../../howto/functional.rst:385
#, fuzzy
msgid ""
"Generator expressions always have to be written inside parentheses, but the "
"parentheses signalling a function call also count.  If you want to create an "
"iterator that will be immediately passed to a function you can write::"
msgstr "生成器表達式始終必須寫在圓括號內，但表示函式呼叫的圓括號也很重要。如果你想建"
"立一個將立即傳遞給函式的疊代器，你可以這樣寫："

#: ../../howto/functional.rst:391
#, fuzzy
msgid ""
"The ``for...in`` clauses contain the sequences to be iterated over.  The "
"sequences do not have to be the same length, because they are iterated over "
"from left to right, **not** in parallel.  For each element in ``sequence1``, "
"``sequence2`` is looped over from the beginning.  ``sequence3`` is then "
"looped over for each resulting pair of elements from ``sequence1`` and "
"``sequence2``."
msgstr ""
"``for...in`` 子句包含要疊代的序列。序列不必具有相同的長度，因為它們是從左到右"
"疊代的，**不是**並行的。對於 ``sequence1`` 中的每個元素， ``sequence2`` 從頭開始循環"
"。 ``sequence3`` 然後從 ``sequence1`` 和 ``sequence2`` "
"的每一對結果元素中循環。"

#: ../../howto/functional.rst:397
#, fuzzy
msgid ""
"To put it another way, a list comprehension or generator expression is "
"equivalent to the following Python code::"
msgstr "換句話說，列表理解或生成器表達式等同於以下 Python 程式碼："

#: ../../howto/functional.rst:414
#, fuzzy
msgid ""
"This means that when there are multiple ``for...in`` clauses but no ``if`` "
"clauses, the length of the resulting output will be equal to the product of "
"the lengths of all the sequences.  If you have two lists of length 3, the "
"output list is 9 elements long:"
msgstr ""
"這意味著當有多個 ``for...in`` 子句但沒有 ``if`` "
"子句時，結果輸出的長度將等於所有序列長度的乘積。如果您有兩個長度為 3 的列表，"
"則輸出列表的長度為 9 個元素："

#: ../../howto/functional.rst:426
#, fuzzy
msgid ""
"To avoid introducing an ambiguity into Python's grammar, if ``expression`` "
"is creating a tuple, it must be surrounded with parentheses.  The first list "
"comprehension below is a syntax error, while the second one is correct::"
msgstr ""
"為了避免在 Python 的語法中引入歧義，如果 ``expression`` 正在建立一個元組，它"
"必須用括號括起來。下面的第一個列表理解是語法錯誤，而第二個是正確的::"

#: ../../howto/functional.rst:437
#, fuzzy
msgid "Generators"
msgstr "發電機"

#: ../../howto/functional.rst:439
#, fuzzy
msgid ""
"Generators are a special class of functions that simplify the task of "
"writing iterators.  Regular functions compute a value and return it, but "
"generators return an iterator that returns a stream of values."
msgstr "生成器是一類特殊的函式，可以簡化編寫疊代器的任務。常規函式計算一個值並回傳它"
"，但是生成器回傳一個回傳值流的疊代器。"

#: ../../howto/functional.rst:443
#, fuzzy
msgid ""
"You're doubtless familiar with how regular function calls work in Python or "
"C. When you call a function, it gets a private namespace where its local "
"variables are created.  When the function reaches a ``return`` statement, "
"the local variables are destroyed and the value is returned to the caller.  "
"A later call to the same function creates a new private namespace and a "
"fresh set of local variables. But, what if the local variables weren't "
"thrown away on exiting a function?  What if you could later resume the "
"function where it left off?  This is what generators provide; they can be "
"thought of as resumable functions."
msgstr ""
"您無疑熟悉 Python 或 C 中常規函式呼叫的工作方式。當您呼叫一個函式時，它會獲得"
"一個私有名稱空間，在該名稱空間中建立了它的局部變數。當函式到達 ``return``語句時"
"，局部變數被銷毀並將值回傳給呼叫者。稍後呼叫同一函式會建立一個新的私有名稱空"
"間和一組新的局部變數。但是，如果局部變數在退出函式時沒有被丟棄怎麼辦？如果您"
"稍後可以在它停止的地方恢復功能怎麼辦？這就是生成器提供的；它們可以被認為是可"
"恢復的功能。"

#: ../../howto/functional.rst:452
#, fuzzy
msgid "Here's the simplest example of a generator function:"
msgstr "這是生成器函式的最簡單示例："

#: ../../howto/functional.rst:458
#, fuzzy
msgid ""
"Any function containing a :keyword:`yield` keyword is a generator function; "
"this is detected by Python's :term:`bytecode` compiler which compiles the "
"function specially as a result."
msgstr ""
"任何包含 :keyword:`yield` 關鍵字的函式都是生成器函式；這是由 Python 的 "
":term:`bytecode` 編譯器檢測到的，它會專門編譯函式作為結果。"

#: ../../howto/functional.rst:462
#, fuzzy
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the ``yield`` expression, the generator outputs the value of "
"``i``, similar to a ``return`` statement.  The big difference between "
"``yield`` and a ``return`` statement is that on reaching a ``yield`` the "
"generator's state of execution is suspended and local variables are "
"preserved.  On the next call to the generator's :meth:`~generator.__next__` "
"method, the function will resume executing."
msgstr ""
"當您呼叫生成器函式時，它不會回傳單個值；相反，它回傳一個支援疊代器協定的生成"
"器物件。在執行 ``yield`` 表達式時，生成器輸出 ``i`` 的值，類似於 ``return`` "
"語句。 ``yield`` 和 ``return`` 語句之間的最大區別在於，在達到 ``yield`` "
"時，生成器的執行狀態被掛起並保留局部變數。在下一次呼叫生成器的 "
":meth:`~generator.__next__` 方法時，該函式將繼續執行。"

#: ../../howto/functional.rst:471
#, fuzzy
msgid "Here's a sample usage of the ``generate_ints()`` generator:"
msgstr "以下是 ``generate_ints()`` 生成器的示例用法："

#: ../../howto/functional.rst:488
#, fuzzy
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a, b, c = "
"generate_ints(3)``."
msgstr "你同樣可以寫 ``for i in generate_ints(5)`` 或 ``a, b, c = "
"generate_ints(3)``。"

#: ../../howto/functional.rst:491
#, fuzzy
msgid ""
"Inside a generator function, ``return value`` causes "
"``StopIteration(value)`` to be raised from the :meth:`~generator.__next__` "
"method.  Once this happens, or the bottom of the function is reached, the "
"procession of values ends and the generator cannot yield any further values."
msgstr ""
"在生成器函式中，``return value`` 導致從 :meth:`~generator.__next__` "
"方法中引發 ``StopIteration(value)``。一旦發生這種情況，或者到達函式的底部，值"
"的處理就會結束，生成器將無法產生任何進一步的值。"

#: ../../howto/functional.rst:496
#, fuzzy
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`~iterator.__next__` "
"method increment ``self.count`` and return it. However, for a moderately "
"complicated generator, writing a corresponding class can be much messier."
msgstr ""
"您可以通過編寫自己的類並將生成器的所有局部變數儲存為實例變數來手動實作生成器"
"的效果。例如，回傳一個整數列表可以通過將 ``self.count`` 設定為 0 並讓 "
":meth:`~iterator.__next__` 方法遞增 ``self.count`` 並回傳它來完成。然而，對於"
"一個中等複雜的生成器，編寫一個相應的類可能會更加混亂。"

#: ../../howto/functional.rst:504
#, fuzzy
msgid ""
"The test suite included with Python's library, :source:`Lib/test/"
"test_generators.py`, contains a number of more interesting examples.  Here's "
"one generator that implements an in-order traversal of a tree using "
"generators recursively. ::"
msgstr ""
"Python 庫中包含的測試套件 Lib/test/test_generators.py "
"包含許多更有趣的示例。這是一個生成器，它遞迴地使用生成器實作樹的有序遍歷。 ::"

#: ../../howto/functional.rst:520
#, fuzzy
msgid ""
"Two other examples in ``test_generators.py`` produce solutions for the N-"
"Queens problem (placing N queens on an NxN chess board so that no queen "
"threatens another) and the Knight's Tour (finding a route that takes a "
"knight to every square of an NxN chessboard without visiting any square "
"twice)."
msgstr ""
"``test_generators.py`` 中的另外兩個示例為 N-Queens 問題（將 N 個皇后放在 NxN "
"棋盤上，這樣沒有皇后會威脅到另一個）和 Knight's Tour（"
"找到一條讓騎士到達每個方格的路線一個 NxN 棋盤而無需訪問任何方格兩次）。"

#: ../../howto/functional.rst:528
#, fuzzy
msgid "Passing values into a generator"
msgstr "將值傳遞給生成器"

#: ../../howto/functional.rst:530
#, fuzzy
msgid ""
"In Python 2.4 and earlier, generators only produced output.  Once a "
"generator's code was invoked to create an iterator, there was no way to pass "
"any new information into the function when its execution is resumed.  You "
"could hack together this ability by making the generator look at a global "
"variable or by passing in some mutable object that callers then modify, but "
"these approaches are messy."
msgstr ""
"在 Python 2.4 及更早版本中，生成器僅產生輸出。一旦呼叫了生成器的程式碼來建立"
"疊代器，就無法在恢復執行時將任何新資訊傳遞到函式中。您可以通過讓生成器查看全"
"局變數或傳入一些呼叫者隨後修改的可變物件來破解這種能力，但這些方法很麻煩。"

#: ../../howto/functional.rst:537
#, fuzzy
msgid ""
"In Python 2.5 there's a simple way to pass values into a generator. :keyword:"
"`yield` became an expression, returning a value that can be assigned to a "
"variable or otherwise operated on::"
msgstr ""
"在 Python 2.5 中，有一種將值傳遞到生成器的簡單方法。 :keyword:`yield` "
"變成了一個表達式，回傳一個可以分配給變數或以其他方式操作的值::"

#: ../../howto/functional.rst:543
#, fuzzy
msgid ""
"I recommend that you **always** put parentheses around a ``yield`` "
"expression when you're doing something with the returned value, as in the "
"above example. The parentheses aren't always necessary, but it's easier to "
"always add them instead of having to remember when they're needed."
msgstr ""
"我建議您在對回傳值執行某些操作時，**始終**在 ``yield`` 表達式兩邊加上括號，如"
"上例所示。括號並不總是必需的，但始終新增它們比在需要時記住它們更容易。"

#: ../../howto/functional.rst:548
#, fuzzy
msgid ""
"(:pep:`342` explains the exact rules, which are that a ``yield``-expression "
"must always be parenthesized except when it occurs at the top-level "
"expression on the right-hand side of an assignment.  This means you can "
"write ``val = yield i`` but have to use parentheses when there's an "
"operation, as in ``val = (yield i) + 12``.)"
msgstr ""
"(:pep:`342` 解釋了確切的規則，即 ``yield`` "
"表達式必須始終用括號括起來，除非它出現在賦值右側的頂級表達式中。"
"這意味著你可以寫 ``val = yield i`` 但是當有操作時必須使用括號，如 ``val = ("
"yield i) + 12``。）"

#: ../../howto/functional.rst:554
#, fuzzy
msgid ""
"Values are sent into a generator by calling its :meth:`send(value) "
"<generator.send>` method.  This method resumes the generator's code and the "
"``yield`` expression returns the specified value.  If the regular :meth:"
"`~generator.__next__` method is called, the ``yield`` returns ``None``."
msgstr ""
"通過呼叫其 :meth:`send(value) <generator.send>` "
"方法將值發送到生成器中。此方法恢復生成器的程式碼，並且 ``yield`` "
"表達式回傳指定的值。如果呼叫常規 :meth:`~generator.__next__` 方法，則 "
"``yield`` 回傳 ``None``。"

#: ../../howto/functional.rst:559
#, fuzzy
msgid ""
"Here's a simple counter that increments by 1 and allows changing the value "
"of the internal counter."
msgstr "這是一個簡單的計數器，它以 1 遞增並允許更改內部計數器的值。"

#: ../../howto/functional.rst:574
#, fuzzy
msgid "And here's an example of changing the counter:"
msgstr "這是更改計數器的示例："

#: ../../howto/functional.rst:591
#, fuzzy
msgid ""
"Because ``yield`` will often be returning ``None``, you should always check "
"for this case.  Don't just use its value in expressions unless you're sure "
"that the :meth:`~generator.send` method will be the only method used to "
"resume your generator function."
msgstr ""
"因為 ``yield`` 通常會回傳 "
"``None``，所以你應該經常檢查這種情況。不要只在表達式中使用它的值，除非你確定 "
":meth:`~generator.send` 方法將是唯一用於恢復生成器函式的方法。"

#: ../../howto/functional.rst:596
#, fuzzy
msgid ""
"In addition to :meth:`~generator.send`, there are two other methods on "
"generators:"
msgstr "除了 :meth:`~generator.send` 之外，生成器還有另外兩個方法："

#: ../../howto/functional.rst:599
#, fuzzy
msgid ""
":meth:`throw(value) <generator.throw>` is used to raise an exception inside "
"the generator; the exception is raised by the ``yield`` expression where the "
"generator's execution is paused."
msgstr ""
":meth:`throw(value) <generator.throw>` 用於在生成器內部引發例外；"
"例外是由生成器暫停執行的 ``yield`` 表達式引發的。"

#: ../../howto/functional.rst:603
#, fuzzy
msgid ""
":meth:`~generator.close` raises a :exc:`GeneratorExit` exception inside the "
"generator to terminate the iteration.  On receiving this exception, the "
"generator's code must either raise :exc:`GeneratorExit` or :exc:"
"`StopIteration`; catching the exception and doing anything else is illegal "
"and will trigger a :exc:`RuntimeError`.  :meth:`~generator.close` will also "
"be called by Python's garbage collector when the generator is garbage-"
"collected."
msgstr ""
":meth:`~generator.close` 在生成器內部引發 :exc:`GeneratorExit` "
"例外以終止疊代。收到此例外時，生成器的程式碼必須引發 :exc:`GeneratorExit` 或 "
":exc:`StopIteration`；捕獲例外並執行任何其他操作都是非法的，並且會觸發 "
":exc:`RuntimeError`。 :meth:`~generator.close` 也會在生成器被垃圾收集時被 "
"Python 的垃圾收集器呼叫。"

#: ../../howto/functional.rst:611
#, fuzzy
msgid ""
"If you need to run cleanup code when a :exc:`GeneratorExit` occurs, I "
"suggest using a ``try: ... finally:`` suite instead of catching :exc:"
"`GeneratorExit`."
msgstr ""
"如果您需要在 :exc:`GeneratorExit` 發生時運行清理程式碼，我建議使用 ``try: "
"... finally:`` 套件而不是捕獲 :exc:`GeneratorExit`。"

#: ../../howto/functional.rst:614
#, fuzzy
msgid ""
"The cumulative effect of these changes is to turn generators from one-way "
"producers of information into both producers and consumers."
msgstr "這些變化的累積效應是將生成者從單向資訊生產者轉變為生產者和消費者。"

#: ../../howto/functional.rst:617
#, fuzzy
msgid ""
"Generators also become **coroutines**, a more generalized form of "
"subroutines. Subroutines are entered at one point and exited at another "
"point (the top of the function, and a ``return`` statement), but coroutines "
"can be entered, exited, and resumed at many different points (the ``yield`` "
"statements)."
msgstr ""
"生成器也變成了**協同程式**，一種更通用的子程式形式。子例程在一個點進入並在另"
"一個點退出（函式的頂部，和一個``return``語句），但是協程可以在許多不同的點進"
"入，退出和恢復（``yield``語句)."

#: ../../howto/functional.rst:624
#, fuzzy
msgid "Built-in functions"
msgstr "內建函式"

#: ../../howto/functional.rst:626
#, fuzzy
msgid ""
"Let's look in more detail at built-in functions often used with iterators."
msgstr "讓我們更詳細地了解經常與疊代器一起使用的內建函式。"

#: ../../howto/functional.rst:628
#, fuzzy
msgid ""
"Two of Python's built-in functions, :func:`map` and :func:`filter` duplicate "
"the features of generator expressions:"
msgstr "Python 的兩個內建函式 :func:`map` 和 :func:`filter` "
"複製了生成器表達式的特性："

#: ../../howto/functional.rst:640
#, fuzzy
msgid ""
":func:`map(f, iterA, iterB, ...) <map>` returns an iterator over the sequence"
msgstr ":func:`map(f, iterA, iterB, ...) <map>` 回傳序列上的疊代器"

#: ../../howto/functional.rst:632
#, fuzzy
msgid ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), ...``."
msgstr ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), "
"...``。"

#: ../../howto/functional.rst:642
#, fuzzy
msgid "You can of course achieve the same effect with a list comprehension."
msgstr "您當然可以通過列表理解來達到相同的效果。"

#: ../../howto/functional.rst:644
#, fuzzy
msgid ""
":func:`filter(predicate, iter) <filter>` returns an iterator over all the "
"sequence elements that meet a certain condition, and is similarly duplicated "
"by list comprehensions.  A **predicate** is a function that returns the "
"truth value of some condition; for use with :func:`filter`, the predicate "
"must take a single value."
msgstr ""
":func:`filter(predicate, iter) <filter>` "
"回傳滿足特定條件的所有序列元素的疊代器，並且類似地被列表理解複製。 "
"**謂詞**是一個回傳某些條件真值的函式；為了與 :func:`filter` "
"一起使用，謂詞必須採用單個值。"

#: ../../howto/functional.rst:657
#, fuzzy
msgid "This can also be written as a list comprehension:"
msgstr "這也可以寫成列表理解："

#: ../../howto/functional.rst:663
#, fuzzy
msgid ""
":func:`enumerate(iter, start=0) <enumerate>` counts off the elements in the "
"iterable returning 2-tuples containing the count (from *start*) and each "
"element. ::"
msgstr ""
":func:`enumerate(iter, start=0) <enumerate>` 對包含計數（從 *start* "
"開始）和每個元素的可疊代回傳二元組中的元素進行計數。 ::"

#: ../../howto/functional.rst:673
#, fuzzy
msgid ""
":func:`enumerate` is often used when looping through a list and recording "
"the indexes at which certain conditions are met::"
msgstr ":func:`enumerate` 通常在遍歷列表並記錄滿足特定條件的索引時使用::"

#: ../../howto/functional.rst:681
#, fuzzy
msgid ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` collects all the "
"elements of the iterable into a list, sorts the list, and returns the sorted "
"result.  The *key* and *reverse* arguments are passed through to the "
"constructed list's :meth:`~list.sort` method. ::"
msgstr ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>`將iterable的所有元"
"素收集到一個列表中，對列表進行排序，並回傳排序後的結果。 *key* 和 *reverse* "
"參數被傳遞給構造列表的 :meth:`~list.sort` 方法。 ::"

#: ../../howto/functional.rst:696
#, fuzzy
msgid ""
"(For a more detailed discussion of sorting, see the :ref:`sortinghowto`.)"
msgstr "（有關排序的更詳細討論，請參閱 :ref:`sortinghowto`。）"

#: ../../howto/functional.rst:699
#, fuzzy
msgid ""
"The :func:`any(iter) <any>` and :func:`all(iter) <all>` built-ins look at "
"the truth values of an iterable's contents.  :func:`any` returns ``True`` if "
"any element in the iterable is a true value, and :func:`all` returns "
"``True`` if all of the elements are true values:"
msgstr ""
":func:`any(iter) <any>` 和 :func:`all(iter) <all>` "
"內建函式查看可疊代內容的真值。 :func:`any` 如果 iterable 中的任何元素為真值，"
"則回傳 ``True``，如果所有元素均為真值，則 :func:`all` 回傳 ``True``："

#: ../../howto/functional.rst:718
#, fuzzy
msgid ""
":func:`zip(iterA, iterB, ...) <zip>` takes one element from each iterable "
"and returns them in a tuple::"
msgstr ":func:`zip(iterA, iterB, ...) <zip>` "
"從每個可疊代對像中取出一個元素並以元組形式回傳它們::"

#: ../../howto/functional.rst:724
#, fuzzy
msgid ""
"It doesn't construct an in-memory list and exhaust all the input iterators "
"before returning; instead tuples are constructed and returned only if "
"they're requested.  (The technical term for this behaviour is `lazy "
"evaluation <https://en.wikipedia.org/wiki/Lazy_evaluation>`__.)"
msgstr ""
"它不會構造記憶體列表並在回傳之前耗盡所有輸入疊代器；相反，元組僅在被請求時才"
"被構造和回傳。 （這種行為的技術術語是`惰性求值 <https://en.wikipedia.org/"
"wiki/Lazy_evaluation>`__。）"

#: ../../howto/functional.rst:729
#, fuzzy
msgid ""
"This iterator is intended to be used with iterables that are all of the same "
"length.  If the iterables are of different lengths, the resulting stream "
"will be the same length as the shortest iterable. ::"
msgstr "此疊代器旨在與長度相同的疊代器一起使用。如果可疊代物件的長度不同，則生成的流"
"將與最短可疊代物件的長度相同。 ::"

#: ../../howto/functional.rst:736
#, fuzzy
msgid ""
"You should avoid doing this, though, because an element may be taken from "
"the longer iterators and discarded.  This means you can't go on to use the "
"iterators further because you risk skipping a discarded element."
msgstr "但是，您應該避免這樣做，因為一個元素可能會從較長的疊代器中取出並丟棄。這意味"
"著您不能繼續使用疊代器，因為您可能會跳過被丟棄的元素。"

#: ../../howto/functional.rst:742
#, fuzzy
msgid "The itertools module"
msgstr "itertools 模組"

#: ../../howto/functional.rst:744
#, fuzzy
msgid ""
"The :mod:`itertools` module contains a number of commonly used iterators as "
"well as functions for combining several iterators.  This section will "
"introduce the module's contents by showing small examples."
msgstr ":mod:`itertools` 模組包含許多常用的疊代器以及用於組合多個疊代器的函式。本節將"
"通過展示小例子來介紹模組的內容。"

#: ../../howto/functional.rst:748
#, fuzzy
msgid "The module's functions fall into a few broad classes:"
msgstr "該模組的功能分為幾大類："

#: ../../howto/functional.rst:750
#, fuzzy
msgid "Functions that create a new iterator based on an existing iterator."
msgstr "基於現有疊代器建立新疊代器的函式。"

#: ../../howto/functional.rst:751
#, fuzzy
msgid "Functions for treating an iterator's elements as function arguments."
msgstr "將疊代器的元素視為函式參數的函式。"

#: ../../howto/functional.rst:752
#, fuzzy
msgid "Functions for selecting portions of an iterator's output."
msgstr "用於選擇疊代器輸出部分的函式。"

#: ../../howto/functional.rst:753
#, fuzzy
msgid "A function for grouping an iterator's output."
msgstr "用於對疊代器的輸出進行分組的函式。"

#: ../../howto/functional.rst:756
#, fuzzy
msgid "Creating new iterators"
msgstr "建立新的疊代器"

#: ../../howto/functional.rst:758
#, fuzzy
msgid ""
":func:`itertools.count(start, step) <itertools.count>` returns an infinite "
"stream of evenly spaced values.  You can optionally supply the starting "
"number, which defaults to 0, and the interval between numbers, which "
"defaults to 1::"
msgstr ""
":func:`itertools.count(start, step) <itertools.count>` "
"回傳無限的均勻間隔值流。您可以選擇提供起始數字（預設為 0）和數字之間的間隔（"
"預設為 1）::"

#: ../../howto/functional.rst:769
#, fuzzy
msgid ""
":func:`itertools.cycle(iter) <itertools.cycle>` saves a copy of the contents "
"of a provided iterable and returns a new iterator that returns its elements "
"from first to last.  The new iterator will repeat these elements "
"infinitely. ::"
msgstr ""
":func:`itertools.cycle(iter) <itertools.cycle>` 保存提供的可疊代內容的副本，"
"並回傳一個新的疊代器，該疊代器從頭到尾回傳其元素。新的疊代器將無限重複這些元"
"素。 ::"

#: ../../howto/functional.rst:776
#, fuzzy
msgid ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` returns the provided "
"element *n* times, or returns the element endlessly if *n* is not "
"provided. ::"
msgstr ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` 回傳提供的元素 *n* "
"次，如果沒有提供 *n* 則無限回傳元素。 ::"

#: ../../howto/functional.rst:784
#, fuzzy
msgid ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` takes an "
"arbitrary number of iterables as input, and returns all the elements of the "
"first iterator, then all the elements of the second, and so on, until all of "
"the iterables have been exhausted. ::"
msgstr ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` 將任意數量的可疊"
"代對像作為輸入，回傳第一個疊代器的所有元素，然後是第二個疊代器的所有元素，最"
"後依此類推，直到所有可疊代對像都用完。 ::"

#: ../../howto/functional.rst:792
#, fuzzy
msgid ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"returns a stream that's a slice of the iterator.  With a single *stop* "
"argument, it will return the first *stop* elements.  If you supply a "
"starting index, you'll get *stop-start* elements, and if you supply a value "
"for *step*, elements will be skipped accordingly.  Unlike Python's string "
"and list slicing, you can't use negative values for *start*, *stop*, or "
"*step*. ::"
msgstr ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"回傳一個流，它是疊代器的一部分。使用單個 *stop* 參數，它將回傳第一個 *stop* "
"元素。如果您提供起始索引，您將獲得 *stop-start* 元素，如果您為 *step* "
"提供值，將相應地跳過元素。與 Python 的字串和列表切片不同，您不能為 "
"*start*、*stop* 或 *step* 使用負值。 ::"

#: ../../howto/functional.rst:806
#, fuzzy
msgid ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` replicates an iterator; it "
"returns *n* independent iterators that will all return the contents of the "
"source iterator. If you don't supply a value for *n*, the default is 2.  "
"Replicating iterators requires saving some of the contents of the source "
"iterator, so this can consume significant memory if the iterator is large "
"and one of the new iterators is consumed more than the others. ::"
msgstr ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` 複製一個疊代器；它回傳 *n* "
"個獨立的疊代器，這些疊代器將全部回傳源疊代器的內容。如果不為 *n* 提供值，"
"則預設值為 2。複製疊代器需要保存源疊代器的一些內容，因此如果疊代器很大並且消"
"耗了其中一個新疊代器，這會消耗大量記憶體比其他人更多。 ::"

#: ../../howto/functional.rst:825
#, fuzzy
msgid "Calling functions on elements"
msgstr "在元素上呼叫函式"

#: ../../howto/functional.rst:827
#, fuzzy
msgid ""
"The :mod:`operator` module contains a set of functions corresponding to "
"Python's operators.  Some examples are :func:`operator.add(a, b) <operator."
"add>` (adds two values), :func:`operator.ne(a, b)  <operator.ne>` (same as "
"``a != b``), and :func:`operator.attrgetter('id') <operator.attrgetter>` "
"(returns a callable that fetches the ``.id`` attribute)."
msgstr ""
":mod:`operator` 模組包含一組對應於 Python 運算符的函式。一些示例是 "
":func:`operator.add(a, b) <operator.add>`（新增兩個值），:func:`operator.ne("
"a, b) <operator.ne>`（與 `` a != b``) 和 :func:`operator.attrgetter('id') "
"<operator.attrgetter>`（回傳一個獲取 ``.id`` 屬性的可呼叫物件）。"

#: ../../howto/functional.rst:833
#, fuzzy
msgid ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` assumes that the "
"iterable will return a stream of tuples, and calls *func* using these tuples "
"as the arguments::"
msgstr ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` "
"假定可疊代物件將回傳元組流，並使用這些元組作為參數呼叫 *func*::"

#: ../../howto/functional.rst:845
#, fuzzy
msgid "Selecting elements"
msgstr "選擇元素"

#: ../../howto/functional.rst:847
#, fuzzy
msgid ""
"Another group of functions chooses a subset of an iterator's elements based "
"on a predicate."
msgstr "另一組函式根據謂詞選擇疊代器元素的子集。"

#: ../../howto/functional.rst:850
#, fuzzy
msgid ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` is "
"the opposite of :func:`filter`, returning all elements for which the "
"predicate returns false::"
msgstr ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` 與 "
":func:`filter` 相反，回傳所有 predicate 回傳 false 的元素::"

#: ../../howto/functional.rst:857
#, fuzzy
msgid ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` returns "
"elements for as long as the predicate returns true.  Once the predicate "
"returns false, the iterator will signal the end of its results. ::"
msgstr ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` "
"只要謂詞回傳 true 就回傳元素。一旦謂詞回傳 "
"false，疊代器將發出結果結束的信號。 ::"

#: ../../howto/functional.rst:870
#, fuzzy
msgid ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` discards "
"elements while the predicate returns true, and then returns the rest of the "
"iterable's results. ::"
msgstr ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` "
"在謂詞回傳 true 時丟棄元素，然後回傳可疊代結果的其餘部分。 ::"

#: ../../howto/functional.rst:880
#, fuzzy
msgid ""
":func:`itertools.compress(data, selectors) <itertools.compress>` takes two "
"iterators and returns only those elements of *data* for which the "
"corresponding element of *selectors* is true, stopping whenever either one "
"is exhausted::"
msgstr ""
":func:`itertools.compress(data, selectors) <itertools.compress>` "
"接受兩個疊代器並只回傳 *data* 中*selectors* "
"的對應元素為真的那些元素，只要其中一個疊代器用完就停止："

#: ../../howto/functional.rst:889
#, fuzzy
msgid "Combinatoric functions"
msgstr "組合函式"

#: ../../howto/functional.rst:891
#, fuzzy
msgid ""
"The :func:`itertools.combinations(iterable, r) <itertools.combinations>` "
"returns an iterator giving all possible *r*-tuple combinations of the "
"elements contained in *iterable*.  ::"
msgstr ""
":func:`itertools.combinations(iterable, r) <itertools.combinations>` "
"回傳一個疊代器，給出 *iterable* 中包含的元素的所有可能的 *r* 元組組合。 ::"

#: ../../howto/functional.rst:906
#, fuzzy
msgid ""
"The elements within each tuple remain in the same order as *iterable* "
"returned them.  For example, the number 1 is always before 2, 3, 4, or 5 in "
"the examples above.  A similar function, :func:`itertools."
"permutations(iterable, r=None) <itertools.permutations>`, removes this "
"constraint on the order, returning all possible arrangements of length *r*::"
msgstr ""
"每個元組中的元素保持與 *iterable* 回傳它們相同的順序。例如，在上面的示例中，"
"數字 1 始終位於 2、3、4 或 5 之前。類似的函式 :func:`itertools.permutations("
"iterable, r=None) <itertools.permutations>` 消除了對順序的限制，"
"回傳所有可能的長度 *r*::"

#: ../../howto/functional.rst:925
#, fuzzy
msgid ""
"If you don't supply a value for *r* the length of the iterable is used, "
"meaning that all the elements are permuted."
msgstr "如果您不為 *r* 提供值，則使用 iterable 的長度，這意味著所有元素都被置換。"

#: ../../howto/functional.rst:928
#, fuzzy
msgid ""
"Note that these functions produce all of the possible combinations by "
"position and don't require that the contents of *iterable* are unique::"
msgstr "請注意，這些函式按位置生成所有可能的組合，並且不要求 *iterable* "
"的內容是唯一的::"

#: ../../howto/functional.rst:935
#, fuzzy
msgid ""
"The identical tuple ``('a', 'a', 'b')`` occurs twice, but the two 'a' "
"strings came from different positions."
msgstr "相同的元組 ``('a', 'a', 'b')`` 出現了兩次，但是兩個 'a' 字串來自不同的位置。"

#: ../../howto/functional.rst:938
#, fuzzy
msgid ""
"The :func:`itertools.combinations_with_replacement(iterable, r) <itertools."
"combinations_with_replacement>` function relaxes a different constraint: "
"elements can be repeated within a single tuple.  Conceptually an element is "
"selected for the first position of each tuple and then is replaced before "
"the second element is selected.  ::"
msgstr ""
":func:`itertools.combinations_with_replacement(iterable, r) <itertools."
"combinations_with_replacement>` 函式放寬了一個不同的約束：元素可以在單個元組"
"中重複。從概念上講，為每個元組的第一個位置選擇一個元素，然後在選擇第二個元素"
"之前將其替換。 ::"

#: ../../howto/functional.rst:953
#, fuzzy
msgid "Grouping elements"
msgstr "分組元素"

#: ../../howto/functional.rst:955
#, fuzzy
msgid ""
"The last function I'll discuss, :func:`itertools.groupby(iter, "
"key_func=None) <itertools.groupby>`, is the most complicated.  "
"``key_func(elem)`` is a function that can compute a key value for each "
"element returned by the iterable.  If you don't supply a key function, the "
"key is simply each element itself."
msgstr ""
"我要討論的最後一個函式 :func:`itertools.groupby(iter, key_func=None) "
"<itertools.groupby>` 是最複雜的。 ``key_func(elem)`` 是一個可以為可疊代物件回"
"傳的每個元素計算鍵值的函式。如果您不提供鍵函式，則鍵就是每個元素本身。"

#: ../../howto/functional.rst:960
#, fuzzy
msgid ""
":func:`~itertools.groupby` collects all the consecutive elements from the "
"underlying iterable that have the same key value, and returns a stream of 2-"
"tuples containing a key value and an iterator for the elements with that key."
msgstr ""
":func:`~itertools.groupby` 從底層可疊代對像中收集具有相同鍵值的所有連續元素，"
"並回傳包含鍵值的二元組流和具有該鍵的元素的疊代器。"

#: ../../howto/functional.rst:988
#, fuzzy
msgid ""
":func:`~itertools.groupby` assumes that the underlying iterable's contents "
"will already be sorted based on the key.  Note that the returned iterators "
"also use the underlying iterable, so you have to consume the results of "
"iterator-1 before requesting iterator-2 and its corresponding key."
msgstr ""
":func:`~itertools.groupby` 假定底層可疊代物件的內容已經根據鍵進行了排序。請注"
"意，回傳的疊代器還使用底層的可疊代物件，因此您必須在請求 iterator-2 "
"及其對應的鍵之前使用 iterator-1 的結果。"

#: ../../howto/functional.rst:995
#, fuzzy
msgid "The functools module"
msgstr "功能工具模組"

#: ../../howto/functional.rst:997
#, fuzzy
msgid ""
"The :mod:`functools` module contains some higher-order functions. A **higher-"
"order function** takes one or more functions as input and returns a new "
"function.  The most useful tool in this module is the :func:`functools."
"partial` function."
msgstr ""
":mod:`functools` 模組包含一些高階函式。 "
"**高階函式**將一個或多個函式作為輸入並回傳一個新函式。該模組中最有用的工具是 "
"func:`functools.partial` 函式。"

#: ../../howto/functional.rst:1002
#, fuzzy
msgid ""
"For programs written in a functional style, you'll sometimes want to "
"construct variants of existing functions that have some of the parameters "
"filled in. Consider a Python function ``f(a, b, c)``; you may wish to create "
"a new function ``g(b, c)`` that's equivalent to ``f(1, b, c)``; you're "
"filling in a value for one of ``f()``'s parameters.  This is called "
"\"partial function application\"."
msgstr ""
"對於以函式式風格編寫的程式，有時您會希望構建填充了一些參數的現有函式的變體。"
"考慮一個 Python 函式“f(a, b, c)”；你可能希望建立一個新函式 ``g(b, c)`` "
"等價於 ``f(1, b, c)``；您正在為 ``f()`` "
"的其中一個參數填寫一個值。這稱為“部分功能應用程式”。"

#: ../../howto/functional.rst:1008
#, fuzzy
msgid ""
"The constructor for :func:`~functools.partial` takes the arguments "
"``(function, arg1, arg2, ..., kwarg1=value1, kwarg2=value2)``.  The "
"resulting object is callable, so you can just call it to invoke ``function`` "
"with the filled-in arguments."
msgstr ""
":func:`~functools.partial` 的構造函式採用參數``(function, arg1, arg2, ..., "
"kwarg1=value1, kwarg2=value2)``。生成的對像是可呼叫的，因此您可以呼叫它以使用"
"填充的參數呼叫“函式”。"

#: ../../howto/functional.rst:1013
msgid "Here's a small but realistic example::"
msgstr ""
"以下是個很小但實際的範例：\n"
"\n"
"::"

#: ../../howto/functional.rst:1025
#, fuzzy
msgid ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"cumulatively performs an operation on all the iterable's elements and, "
"therefore, can't be applied to infinite iterables. *func* must be a function "
"that takes two elements and returns a single value.  :func:`functools."
"reduce` takes the first two elements A and B returned by the iterator and "
"calculates ``func(A, B)``.  It then requests the third element, C, "
"calculates ``func(func(A, B), C)``, combines this result with the fourth "
"element returned, and continues until the iterable is exhausted.  If the "
"iterable returns no values at all, a :exc:`TypeError` exception is raised.  "
"If the initial value is supplied, it's used as a starting point and "
"``func(initial_value, A)`` is the first calculation. ::"
msgstr ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"累積地對所有可疊代元素執行操作，因此不能應用於無限可疊代。 *func* "
"必須是一個接受兩個元素並回傳一個值的函式。 :func:`functools.reduce` "
"獲取疊代器回傳的前兩個元素 A 和 B 併計算``func(A, B)``。然後它請求第三個元素 "
"C，計算``func(func(A, B), C)``，將此結果與回傳的第四個元素組合，並繼續直到疊"
"代器耗盡。如果可疊代對像根本不回傳任何值，則會引發 :exc:`TypeError` "
"例外。如果提供了初始值，則將其用作起點，並且“func(initial_value, "
"A)”是第一個計算。 ::"

#: ../../howto/functional.rst:1049
#, fuzzy
msgid ""
"If you use :func:`operator.add` with :func:`functools.reduce`, you'll add up "
"all the elements of the iterable.  This case is so common that there's a "
"special built-in called :func:`sum` to compute it:"
msgstr ""
"如果您將 :func:`operator.add` 與 :func:`functools.reduce` "
"一起使用，您將累加可疊代物件的所有元素。這種情況很常見，"
"所以有一個特殊的內建函式 :func:`sum` 來計算它："

#: ../../howto/functional.rst:1061
#, fuzzy
msgid ""
"For many uses of :func:`functools.reduce`, though, it can be clearer to just "
"write the obvious :keyword:`for` loop::"
msgstr "但是，對於 :func:`functools.reduce` 的許多用途，只寫明顯的 :keyword:`for` "
"循環可能會更清楚："

#: ../../howto/functional.rst:1073
#, fuzzy
msgid ""
"A related function is :func:`itertools.accumulate(iterable, func=operator."
"add) <itertools.accumulate>`.  It performs the same calculation, but instead "
"of returning only the final result, :func:`accumulate` returns an iterator "
"that also yields each partial result::"
msgstr ""
"一個相關的函式是 :func:`itertools.accumulate(iterable, func=operator.add) "
"<itertools.accumulate>`。它執行相同的計算，但不是只回傳最終結果，而是回傳一個"
"疊代器，該疊代器也產生每個部分結果::"

#: ../../howto/functional.rst:1086
#, fuzzy
msgid "The operator module"
msgstr "運營商模組"

#: ../../howto/functional.rst:1088
#, fuzzy
msgid ""
"The :mod:`operator` module was mentioned earlier.  It contains a set of "
"functions corresponding to Python's operators.  These functions are often "
"useful in functional-style code because they save you from writing trivial "
"functions that perform a single operation."
msgstr ""
"前面提到了 :mod:`operator` 模組。它包含一組對應於 Python 運算符的函式。這些函"
"式在函式式程式碼中通常很有用，因為它們使您無需編寫執行單個操作的瑣碎函式。"

#: ../../howto/functional.rst:1093
#, fuzzy
msgid "Some of the functions in this module are:"
msgstr "該模組中的一些功能是："

#: ../../howto/functional.rst:1095
#, fuzzy
msgid ""
"Math operations: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, "
"``abs()``, ..."
msgstr "數學運算：``add()``, ``sub()``, ``mul()``, ``floordiv()``, ``abs()``, ..."

#: ../../howto/functional.rst:1096
#, fuzzy
msgid "Logical operations: ``not_()``, ``truth()``."
msgstr "邏輯運算：``not_()``、``truth()``。"

#: ../../howto/functional.rst:1097
#, fuzzy
msgid "Bitwise operations: ``and_()``, ``or_()``, ``invert()``."
msgstr "按位運算：``and_()``、``or_()``、``invert()``。"

#: ../../howto/functional.rst:1098
#, fuzzy
msgid ""
"Comparisons: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, and ``ge()``."
msgstr "比較：``eq()``、``ne()``、``lt()``、``le()``、``gt()`` 和 ``ge()`` ."

#: ../../howto/functional.rst:1099
#, fuzzy
msgid "Object identity: ``is_()``, ``is_not()``."
msgstr "物件身份：``is_()``，``is_not()``。"

#: ../../howto/functional.rst:1101
#, fuzzy
msgid "Consult the operator module's documentation for a complete list."
msgstr "有關完整列表，請參閱操作員模組的文檔。"

#: ../../howto/functional.rst:1105
#, fuzzy
msgid "Small functions and the lambda expression"
msgstr "小函式和 lambda 表達式"

#: ../../howto/functional.rst:1107
#, fuzzy
msgid ""
"When writing functional-style programs, you'll often need little functions "
"that act as predicates or that combine elements in some way."
msgstr "在編寫函式式程式時，您通常需要一些小函式來充當謂詞或以某種方式組合元素。"

#: ../../howto/functional.rst:1110
#, fuzzy
msgid ""
"If there's a Python built-in or a module function that's suitable, you don't "
"need to define a new function at all::"
msgstr "如果有適合的 Python 內建函式或模組函式，則根本不需要定義新函式::"

#: ../../howto/functional.rst:1116
#, fuzzy
msgid ""
"If the function you need doesn't exist, you need to write it.  One way to "
"write small functions is to use the :keyword:`lambda` expression.  "
"``lambda`` takes a number of parameters and an expression combining these "
"parameters, and creates an anonymous function that returns the value of the "
"expression::"
msgstr ""
"如果您需要的功能不存在，則需要編寫它。編寫小函式的一種方法是使用 "
":keyword:`lambda` 表達式。 ``lambda`` "
"採用多個參數和一個組合這些參數的表達式，並建立一個回傳表達式值的匿名函式："

#: ../../howto/functional.rst:1125
#, fuzzy
msgid ""
"An alternative is to just use the ``def`` statement and define a function in "
"the usual way::"
msgstr "另一種方法是只使用 ``def`` 語句並以通常的方式定義一個函式："

#: ../../howto/functional.rst:1134
#, fuzzy
msgid ""
"Which alternative is preferable?  That's a style question; my usual course "
"is to avoid using ``lambda``."
msgstr "哪種選擇更可取？這是一個風格問題；我通常的做法是避免使用 ``lambda``。"

#: ../../howto/functional.rst:1137
#, fuzzy
msgid ""
"One reason for my preference is that ``lambda`` is quite limited in the "
"functions it can define.  The result has to be computable as a single "
"expression, which means you can't have multiway ``if... elif... else`` "
"comparisons or ``try... except`` statements.  If you try to do too much in a "
"``lambda`` statement, you'll end up with an overly complicated expression "
"that's hard to read.  Quick, what's the following code doing? ::"
msgstr ""
"我偏愛的原因之一是 ``lambda`` 在它可以定義的函式方面非常有限。結果必須作為單"
"個表達式進行計算，這意味著您不能進行多路“if...elif...else”比較或“try..."
"except”語句。如果您嘗試在 ``lambda`` 語句中做太多事情，您最終會得到一個難以閱"
"讀的過於復雜的表達式。快點，下面的程式碼在做什麼？ ::"

#: ../../howto/functional.rst:1147
#, fuzzy
msgid ""
"You can figure it out, but it takes time to disentangle the expression to "
"figure out what's going on.  Using a short nested ``def`` statements makes "
"things a little bit better::"
msgstr "您可以弄清楚，但需要時間來解開表達式以弄清楚發生了什麼。使用一個簡短的嵌套 "
"``def`` 語句讓事情變得更好一些::"

#: ../../howto/functional.rst:1157
#, fuzzy
msgid "But it would be best of all if I had simply used a ``for`` loop::"
msgstr "但如果我只使用一個 ``for`` 循環，那將是最好的："

#: ../../howto/functional.rst:1163
#, fuzzy
msgid "Or the :func:`sum` built-in and a generator expression::"
msgstr "或者內建的 :func:`sum` 和生成器表達式::"

#: ../../howto/functional.rst:1167
#, fuzzy
msgid ""
"Many uses of :func:`functools.reduce` are clearer when written as ``for`` "
"loops."
msgstr ":func:`functools.reduce` 的許多用法在寫成 ``for`` 循環時更清晰。"

#: ../../howto/functional.rst:1169
#, fuzzy
msgid ""
"Fredrik Lundh once suggested the following set of rules for refactoring uses "
"of ``lambda``:"
msgstr "Fredrik Lundh 曾經建議使用以下一組重構 lambda 的規則："

#: ../../howto/functional.rst:1172
#, fuzzy
msgid "Write a lambda function."
msgstr "編寫一個 lambda 函式。"

#: ../../howto/functional.rst:1173
#, fuzzy
msgid "Write a comment explaining what the heck that lambda does."
msgstr "寫一條評論解釋 lambda 到底做了什麼。"

#: ../../howto/functional.rst:1174
#, fuzzy
msgid ""
"Study the comment for a while, and think of a name that captures the essence "
"of the comment."
msgstr "研究一下評論，想出一個能抓住評論本質的名字。"

#: ../../howto/functional.rst:1176
#, fuzzy
msgid "Convert the lambda to a def statement, using that name."
msgstr "使用該名稱將 lambda 轉換為 def 語句。"

#: ../../howto/functional.rst:1177
#, fuzzy
msgid "Remove the comment."
msgstr "刪除評論。"

#: ../../howto/functional.rst:1179
#, fuzzy
msgid ""
"I really like these rules, but you're free to disagree about whether this "
"lambda-free style is better."
msgstr "我真的很喜歡這些規則，但對於這種無 lambda 的風格是否更好，你可以有不同意見。"

#: ../../howto/functional.rst:1184
#, fuzzy
msgid "Revision History and Acknowledgements"
msgstr "修訂歷史和致謝"

#: ../../howto/functional.rst:1186
#, fuzzy
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article: "
"Ian Bicking, Nick Coghlan, Nick Efford, Raymond Hettinger, Jim Jewett, Mike "
"Krell, Leandro Lameiro, Jussi Salmela, Collin Winter, Blake Winton."
msgstr ""
"作者要感謝以下人員為本文的各種草稿提供的建議、更正和幫助：Ian Bicking、Nick "
"Coghlan、Nick Efford、Raymond Hettinger、Jim Jewett、Mike Krell、Leandro "
"Lameiro、Jussi Salmela、Collin Winter、布萊克·溫頓。"

#: ../../howto/functional.rst:1191
#, fuzzy
msgid "Version 0.1: posted June 30 2006."
msgstr "0.1 版：2006 年 6 月 30 日發布。"

#: ../../howto/functional.rst:1193
#, fuzzy
msgid "Version 0.11: posted July 1 2006.  Typo fixes."
msgstr "版本 0.11：2006 年 7 月 1 日發布。錯字修復。"

#: ../../howto/functional.rst:1195
#, fuzzy
msgid ""
"Version 0.2: posted July 10 2006.  Merged genexp and listcomp sections into "
"one. Typo fixes."
msgstr "版本 0.2：2006 年 7 月 10 日發布。將 genexp 和 listcomp "
"部分合併為一個部分。錯別字修復。"

#: ../../howto/functional.rst:1198
#, fuzzy
msgid ""
"Version 0.21: Added more references suggested on the tutor mailing list."
msgstr "0.21 版：在導師郵件列表中新增了更多建議的參考資料。"

#: ../../howto/functional.rst:1200
#, fuzzy
msgid ""
"Version 0.30: Adds a section on the ``functional`` module written by Collin "
"Winter; adds short section on the operator module; a few other edits."
msgstr "0.30 版：新增了由 Collin Winter "
"編寫的 ``functional``模組部分；在操作員模組上新增簡短部分；其他一些編輯。"

#: ../../howto/functional.rst:1205
#, fuzzy
msgid "References"
msgstr "參考"

#: ../../howto/functional.rst:1208
#, fuzzy
msgid "General"
msgstr "一般的"

#: ../../howto/functional.rst:1210
#, fuzzy
msgid ""
"**Structure and Interpretation of Computer Programs**, by Harold Abelson and "
"Gerald Jay Sussman with Julie Sussman.  The book can be found at https://"
"mitpress.mit.edu/sicp.  In this classic textbook of computer science, "
"chapters 2 and 3 discuss the use of sequences and streams to organize the "
"data flow inside a program.  The book uses Scheme for its examples, but many "
"of the design approaches described in these chapters are applicable to "
"functional-style Python code."
msgstr ""
"**計算機程式的結構和解釋**，Harold Abelson 和 Gerald Jay Sussman 與 Julie "
"Sussman 合著。這本書可以在 https://mitpress.mit.edu/sicp "
"找到。在這本經典的計算機科學教科書中，第 2 章和第 3 "
"章討論了使用序列和流來組織程式內部的資料流。本書使用 Scheme 作為示例，"
"但這些章節中描述的許多設計方法都適用於函式式 Python 程式碼。"

#: ../../howto/functional.rst:1218
#, fuzzy
msgid ""
"https://www.defmacro.org/ramblings/fp.html: A general introduction to "
"functional programming that uses Java examples and has a lengthy historical "
"introduction."
msgstr ""
"https://www.defmacro.org/ramblings/fp."
"html：函式式編程的一般介紹，使用Java示例，有冗長的歷史介紹。"

#: ../../howto/functional.rst:1221
#, fuzzy
msgid ""
"https://en.wikipedia.org/wiki/Functional_programming: General Wikipedia "
"entry describing functional programming."
msgstr "https://en.wikipedia.org/wiki/"
"Functional_programming：描述函式式編程的通用維基百科條目。"

#: ../../howto/functional.rst:1224
msgid "https://en.wikipedia.org/wiki/Coroutine: Entry for coroutines."
msgstr "https://en.wikipedia.org/wiki/Coroutine: Coroutines 的條目。"

#: ../../howto/functional.rst:1226
msgid ""
"https://en.wikipedia.org/wiki/Currying: Entry for the concept of currying."
msgstr "https://en.wikipedia.org/wiki/Currying: currying 概念的條目。"

#: ../../howto/functional.rst:1229
#, fuzzy
msgid "Python-specific"
msgstr "特定於 Python"

#: ../../howto/functional.rst:1231
#, fuzzy
msgid ""
"https://gnosis.cx/TPiP/: The first chapter of David Mertz's book :title-"
"reference:`Text Processing in Python` discusses functional programming for "
"text processing, in the section titled \"Utilizing Higher-Order Functions in "
"Text Processing\"."
msgstr ""
"https://gnosis.cx/TPiP/：David Mertz 的書 :title-reference:`Text Processing "
"in Python` "
"的第一章在標題為“在文本處理中使用高階函式”的部分中討論了文本處理的函式式編程."

#: ../../howto/functional.rst:1236
#, fuzzy
msgid ""
"Mertz also wrote a 3-part series of articles on functional programming for "
"IBM's DeveloperWorks site; see `part 1 <https://developer.ibm.com/articles/l-"
"prog/>`__, `part 2 <https://developer.ibm.com/tutorials/l-prog2/>`__, and "
"`part 3 <https://developer.ibm.com/tutorials/l-prog3/>`__,"
msgstr ""
"Mertz 還為 IBM 的 DeveloperWorks 站點撰寫了由 3 "
"部分組成的關於函式式編程的系列文章；請參閱`第 1 部分 <https://developer.ibm."
"com/articles/l-prog/>`__、`第 2 部分 <https://developer.ibm.com/tutorials/"
"l-prog2/>`__，以及`第 3 部分 <https://developer.ibm.com/tutorials/l-prog3/"
">`__，"

#: ../../howto/functional.rst:1244
msgid "Python documentation"
msgstr "Python 說明文件"

#: ../../howto/functional.rst:1246
msgid "Documentation for the :mod:`itertools` module."
msgstr ":mod:`itertools` 模組的說明文件。"

#: ../../howto/functional.rst:1248
msgid "Documentation for the :mod:`functools` module."
msgstr ":mod:`functools` 模組的說明文件。"

#: ../../howto/functional.rst:1250
msgid "Documentation for the :mod:`operator` module."
msgstr ":mod:`operator` 模組的說明文件。"

#: ../../howto/functional.rst:1252
#, fuzzy
msgid ":pep:`289`: \"Generator Expressions\""
msgstr ":pep:`289`: “生成器表達式”"

#: ../../howto/functional.rst:1254
#, fuzzy
msgid ""
":pep:`342`: \"Coroutines via Enhanced Generators\" describes the new "
"generator features in Python 2.5."
msgstr ""
":pep:`342`: “Coroutines via Enhanced Generators”描述了 Python 2.5 "
"中的新生成器特性。"
