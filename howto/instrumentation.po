# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-06 00:17+0000\n"
"PO-Revision-Date: 2018-07-15 18:56+0800\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/instrumentation.rst:7
#, fuzzy
msgid "Instrumenting CPython with DTrace and SystemTap"
msgstr "使用 DTrace 和 SystemTap 檢測 CPython"

#: ../../howto/instrumentation.rst:0
msgid "author"
msgstr "作者"

#: ../../howto/instrumentation.rst:9
msgid "David Malcolm"
msgstr "David Malcolm"

#: ../../howto/instrumentation.rst:10
msgid "Łukasz Langa"
msgstr "Łukasz Langa"

#: ../../howto/instrumentation.rst:12
#, fuzzy
msgid ""
"DTrace and SystemTap are monitoring tools, each providing a way to inspect "
"what the processes on a computer system are doing.  They both use domain-"
"specific languages allowing a user to write scripts which:"
msgstr ""
"DTrace 和 SystemTap 是監控工具，每一種都提供了一種方法來檢查計算機系統上的行"
"程正在做什麼。它們都使用特定領域的語言，允許使用者編寫腳本："

#: ../../howto/instrumentation.rst:16
#, fuzzy
msgid "filter which processes are to be observed"
msgstr "過濾要觀察的過程"

#: ../../howto/instrumentation.rst:17
#, fuzzy
msgid "gather data from the processes of interest"
msgstr "從感興趣的過程中收集資料"

#: ../../howto/instrumentation.rst:18
#, fuzzy
msgid "generate reports on the data"
msgstr "生成資料報告"

#: ../../howto/instrumentation.rst:20
#, fuzzy
msgid ""
"As of Python 3.6, CPython can be built with embedded \"markers\", also known "
"as \"probes\", that can be observed by a DTrace or SystemTap script, making "
"it easier to monitor what the CPython processes on a system are doing."
msgstr ""
"從 Python 3.6 開始，CPython 可以使用嵌入式“標記”（也稱為“探針”）構建，"
"可以通過 DTrace 或 SystemTap 腳本進行觀察，從而更容易監視系統上的 CPython "
"行程正在做什麼。"

#: ../../howto/instrumentation.rst:27
#, fuzzy
msgid ""
"DTrace markers are implementation details of the CPython interpreter. No "
"guarantees are made about probe compatibility between versions of CPython. "
"DTrace scripts can stop working or work incorrectly without warning when "
"changing CPython versions."
msgstr ""
"DTrace 標記是 CPython 直譯器的實作細節。不保證 CPython 版本之間的探針相容性。"
"更改 CPython 版本時，DTrace "
"腳本可能會在沒有警告的情況下停止工作或工作不正常。"

#: ../../howto/instrumentation.rst:34
#, fuzzy
msgid "Enabling the static markers"
msgstr "啟用靜態標記"

#: ../../howto/instrumentation.rst:36
#, fuzzy
msgid ""
"macOS comes with built-in support for DTrace.  On Linux, in order to build "
"CPython with the embedded markers for SystemTap, the SystemTap development "
"tools must be installed."
msgstr ""
"macOS 內建了對 DTrace 的支援。在 Linux 上，為了使用 SystemTap "
"的嵌入式標記構建 CPython，必須安裝 SystemTap 開發工具。"

#: ../../howto/instrumentation.rst:40
#, fuzzy
msgid "On a Linux machine, this can be done via::"
msgstr "在 Linux 機器上，這可以通過以下方式完成："

#: ../../howto/instrumentation.rst:44
msgid "or::"
msgstr ""
"或是：\n"
"\n"
"::"

#: ../../howto/instrumentation.rst:49
#, fuzzy
msgid ""
"CPython must then be :option:`configured with the --with-dtrace option <--"
"with-dtrace>`:"
msgstr "然後必須使用 --with-dtrace 選項 <--with-dtrace> 配置 CPython :option:`："

#: ../../howto/instrumentation.rst:56
#, fuzzy
msgid ""
"On macOS, you can list available DTrace probes by running a Python process "
"in the background and listing all probes made available by the Python "
"provider::"
msgstr ""
"在 macOS 上，您可以通過在後台運行 Python 行程並列出 Python "
"提供程式提供的所有可用探測器來列出可用的 DTrace 探測器："

#: ../../howto/instrumentation.rst:73
#, fuzzy
msgid ""
"On Linux, you can verify if the SystemTap static markers are present in the "
"built binary by seeing if it contains a \".note.stapsdt\" section."
msgstr ""
"在 Linux 上，您可以通過查看構建的二進位文件是否包含“.note.stapsdt”部分來驗證 "
"SystemTap 靜態標記是否存在於構建的二進位文件中。"

#: ../../howto/instrumentation.rst:81
#, fuzzy
msgid ""
"If you've built Python as a shared library (with the :option:`--enable-"
"shared` configure option), you need to look instead within the shared "
"library.  For example::"
msgstr "如果您已將 Python 構建為共享庫（使用 :option:`--enable-shared` "
"配置選項），則需要在共享庫中查看。例如：："

#: ../../howto/instrumentation.rst:88
#, fuzzy
msgid "Sufficiently modern readelf can print the metadata::"
msgstr "足夠現代的 readelf 可以印出元資料::"

#: ../../howto/instrumentation.rst:125
#, fuzzy
msgid ""
"The above metadata contains information for SystemTap describing how it can "
"patch strategically placed machine code instructions to enable the tracing "
"hooks used by a SystemTap script."
msgstr "上述元資料包含 SystemTap 的資訊，"
"描述了它如何修補戰略性放置的機器程式碼指令以啟用 SystemTap "
"腳本使用的跟踪掛鉤。"

#: ../../howto/instrumentation.rst:131
#, fuzzy
msgid "Static DTrace probes"
msgstr "靜態 DTrace 探測器"

#: ../../howto/instrumentation.rst:133
#, fuzzy
msgid ""
"The following example DTrace script can be used to show the call/return "
"hierarchy of a Python script, only tracing within the invocation of a "
"function called \"start\". In other words, import-time function invocations "
"are not going to be listed:"
msgstr ""
"以下示例 DTrace 腳本可用於顯示 Python 腳本的呼叫/回傳層次結構，僅在呼叫名為“s"
"tart”的函式內進行跟踪。換句話說，不會列出導入時函式呼叫："

#: ../../howto/instrumentation.rst:172 ../../howto/instrumentation.rst:230
#, fuzzy
msgid "It can be invoked like this::"
msgstr "它可以像這樣呼叫::"

#: ../../howto/instrumentation.rst:176 ../../howto/instrumentation.rst:236
#, fuzzy
msgid "The output looks like this:"
msgstr "輸出如下所示："

#: ../../howto/instrumentation.rst:201
#, fuzzy
msgid "Static SystemTap markers"
msgstr "靜態 SystemTap 標記"

#: ../../howto/instrumentation.rst:203
#, fuzzy
msgid ""
"The low-level way to use the SystemTap integration is to use the static "
"markers directly.  This requires you to explicitly state the binary file "
"containing them."
msgstr "使用 SystemTap "
"集成的低階方法是直接使用靜態標記。這要求您明確說明包含它們的二進位文件。"

#: ../../howto/instrumentation.rst:207
#, fuzzy
msgid ""
"For example, this SystemTap script can be used to show the call/return "
"hierarchy of a Python script:"
msgstr "例如，此 SystemTap 腳本可用於顯示 Python 腳本的呼叫/回傳層次結構："

#: ../../howto/instrumentation.rst:247
#, fuzzy
msgid "where the columns are:"
msgstr "其中列是："

#: ../../howto/instrumentation.rst:249
#, fuzzy
msgid "time in microseconds since start of script"
msgstr "自腳本開始以來的時間（以微秒為單位）"

#: ../../howto/instrumentation.rst:251
#, fuzzy
msgid "name of executable"
msgstr "可執行文件的名稱"

#: ../../howto/instrumentation.rst:253
#, fuzzy
msgid "PID of process"
msgstr "行程的PID"

#: ../../howto/instrumentation.rst:255
#, fuzzy
msgid ""
"and the remainder indicates the call/return hierarchy as the script executes."
msgstr "其餘部分錶示腳本執行時的呼叫/回傳層次結構。"

#: ../../howto/instrumentation.rst:257
#, fuzzy
msgid ""
"For a :option:`--enable-shared` build of CPython, the markers are contained "
"within the libpython shared library, and the probe's dotted path needs to "
"reflect this. For example, this line from the above example:"
msgstr ""
"對於 CPython 的 :option:`--enable-shared` 構建，標記包含在 libpython "
"共享庫中，探針的虛線路徑需要反映這一點。例如，上面示例中的這一行："

#: ../../howto/instrumentation.rst:265
#, fuzzy
msgid "should instead read:"
msgstr "應該改為："

#: ../../howto/instrumentation.rst:271
#, fuzzy
msgid "(assuming a :ref:`debug build <debug-build>` of CPython 3.6)"
msgstr "（假設 CPython 3.6 的 :ref:`debug build <debug-build>`）"

#: ../../howto/instrumentation.rst:275
#, fuzzy
msgid "Available static markers"
msgstr "可用的靜態標記"

#: ../../howto/instrumentation.rst:279
#, fuzzy
msgid ""
"This marker indicates that execution of a Python function has begun. It is "
"only triggered for pure-Python (bytecode) functions."
msgstr "此標記表示 Python 函式的執行已經開始。它僅針對純 Python（位元組碼）函式觸發。"

#: ../../howto/instrumentation.rst:282
#, fuzzy
msgid ""
"The filename, function name, and line number are provided back to the "
"tracing script as positional arguments, which must be accessed using ``"
"$arg1``, ``$arg2``, ``$arg3``:"
msgstr "文件名、函式名和行號作為位置參數提供回跟踪腳本，必須使用“$arg1”、“$arg2”、“$a"
"rg3”訪問："

#: ../../howto/instrumentation.rst:286
#, fuzzy
msgid ""
"``$arg1`` : ``(const char *)`` filename, accessible using "
"``user_string($arg1)``"
msgstr "``$arg1`` : ``(const char *)`` 文件名，可以使用 ``user_string($arg1)`` 訪問"

#: ../../howto/instrumentation.rst:288
#, fuzzy
msgid ""
"``$arg2`` : ``(const char *)`` function name, accessible using "
"``user_string($arg2)``"
msgstr "``$arg2`` : ``(const char *)`` 函式名，可以使用 ``user_string($arg2)`` 訪問"

#: ../../howto/instrumentation.rst:291
#, fuzzy
msgid "``$arg3`` : ``int`` line number"
msgstr "``$arg3`` : ``int`` 行號"

#: ../../howto/instrumentation.rst:295
#, fuzzy
msgid ""
"This marker is the converse of :c:func:`function__entry`, and indicates that "
"execution of a Python function has ended (either via ``return``, or via an "
"exception).  It is only triggered for pure-Python (bytecode) functions."
msgstr ""
"此標記與 :c:func:`function__entry` 相反，表示 Python 函式的執行已結束（通過 "
"``return`` 或通過例外）。它僅針對純 Python（位元組碼）函式觸發。"

#: ../../howto/instrumentation.rst:299
#, fuzzy
msgid "The arguments are the same as for :c:func:`function__entry`"
msgstr "參數與 :c:func:`function__entry` 相同"

#: ../../howto/instrumentation.rst:303
#, fuzzy
msgid ""
"This marker indicates a Python line is about to be executed.  It is the "
"equivalent of line-by-line tracing with a Python profiler.  It is not "
"triggered within C functions."
msgstr "此標記表示即將執行 Python 行。它相當於使用 Python 分析器進行逐行跟踪。"
"它不會在 C 函式中觸發。"

#: ../../howto/instrumentation.rst:307
#, fuzzy
msgid "The arguments are the same as for :c:func:`function__entry`."
msgstr "參數與 :c:func:`function__entry` 相同。"

#: ../../howto/instrumentation.rst:311
#, fuzzy
msgid ""
"Fires when the Python interpreter starts a garbage collection cycle. "
"``arg0`` is the generation to scan, like :func:`gc.collect()`."
msgstr "當 Python 直譯器開始垃圾回收週期時觸發。 ``arg0`` "
"是要掃描的世代，例如 :func:`gc.collect()`。"

#: ../../howto/instrumentation.rst:316
#, fuzzy
msgid ""
"Fires when the Python interpreter finishes a garbage collection cycle. "
"``arg0`` is the number of collected objects."
msgstr "當 Python 直譯器完成垃圾回收週期時觸發。 ``arg0`` 是收集物件的數量。"

#: ../../howto/instrumentation.rst:321
#, fuzzy
msgid ""
"Fires before :mod:`importlib` attempts to find and load the module. ``arg0`` "
"is the module name."
msgstr "在 :mod:`importlib` 嘗試查找和加載模組之前觸發。 ``arg0`` 是模組名稱。"

#: ../../howto/instrumentation.rst:328
#, fuzzy
msgid ""
"Fires after :mod:`importlib`'s find_and_load function is called. ``arg0`` is "
"the module name, ``arg1`` indicates if module was successfully loaded."
msgstr ""
"在 :mod:`importlib` 的 find_and_load 函式被呼叫後觸發。 ``arg0`` "
"是模組名稱，``arg1`` 表示模組是否加載成功。"

#: ../../howto/instrumentation.rst:337
#, fuzzy
msgid ""
"Fires when :func:`sys.audit` or :c:func:`PySys_Audit` is called. ``arg0`` is "
"the event name as C string, ``arg1`` is a :c:type:`PyObject` pointer to a "
"tuple object."
msgstr ""
"當 :func:`sys.audit` 或 :c:func:`PySys_Audit` 被呼叫時觸發。 ``arg0`` 是 C "
"字串形式的事件名稱，``arg1`` 是指向元組物件的 PyObject 指標。"

#: ../../howto/instrumentation.rst:345
#, fuzzy
msgid "SystemTap Tapsets"
msgstr "SystemTap 水龍頭"

#: ../../howto/instrumentation.rst:347
#, fuzzy
msgid ""
"The higher-level way to use the SystemTap integration is to use a \"tapset"
"\": SystemTap's equivalent of a library, which hides some of the lower-level "
"details of the static markers."
msgstr "使用 SystemTap 集成的更高階別的方法是使用 ``tapset``：SystemTap "
"相當於一個庫，它隱藏了靜態標記的一些較低階別的細節。"

#: ../../howto/instrumentation.rst:351
#, fuzzy
msgid "Here is a tapset file, based on a non-shared build of CPython:"
msgstr "這是一個基於非共享 CPython 構建的 tapset 文件："

#: ../../howto/instrumentation.rst:374
#, fuzzy
msgid ""
"If this file is installed in SystemTap's tapset directory (e.g. ``/usr/share/"
"systemtap/tapset``), then these additional probepoints become available:"
msgstr ""
"如果此文件安裝在 SystemTap 的 tapset 目錄中（例如 ``/usr/share/systemtap/"
"tapset``），那麼這些額外的探測點將變得可用："

#: ../../howto/instrumentation.rst:380
#, fuzzy
msgid ""
"This probe point indicates that execution of a Python function has begun. It "
"is only triggered for pure-Python (bytecode) functions."
msgstr "這個探測點表示 Python 函式的執行已經開始。它僅針對純 "
"Python（位元組碼）函式觸發。"

#: ../../howto/instrumentation.rst:385
#, fuzzy
msgid ""
"This probe point is the converse of ``python.function.return``, and "
"indicates that execution of a Python function has ended (either via "
"``return``, or via an exception).  It is only triggered for pure-Python "
"(bytecode) functions."
msgstr ""
"這個探測點與 ``python.function.return`` 相反，表示 Python "
"函式的執行已經結束（通過 ``return`` 或通過例外）。它僅針對純 "
"Python（位元組碼）函式觸發。"

#: ../../howto/instrumentation.rst:392
msgid "Examples"
msgstr "範例"

#: ../../howto/instrumentation.rst:393
#, fuzzy
msgid ""
"This SystemTap script uses the tapset above to more cleanly implement the "
"example given above of tracing the Python function-call hierarchy, without "
"needing to directly name the static markers:"
msgstr ""
"這個 SystemTap 腳本使用上面的 tapset 來更乾淨地實作上面給出的跟踪 Python "
"函式呼叫層次結構的示例，而不需要直接命名靜態標記："

#: ../../howto/instrumentation.rst:412
#, fuzzy
msgid ""
"The following script uses the tapset above to provide a top-like view of all "
"running CPython code, showing the top 20 most frequently entered bytecode "
"frames, each second, across the whole system:"
msgstr ""
"以下腳本使用上面的 tapset 提供所有正在運行的 CPython 程式碼的類似頂部的視圖，"
"顯示整個系統每秒前 20 個最常輸入的位元組碼幀："
