# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Ching-Lung Chuang, 2015
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-31 08:13+0000\n"
"PO-Revision-Date: 2018-05-23 14:37+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/sorting.rst:4
msgid "Sorting HOW TO"
msgstr "如何排序"

#: ../../howto/sorting.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/sorting.rst:6
msgid "Andrew Dalke and Raymond Hettinger"
msgstr "Andrew Dalke 和 Raymond Hettinger"

#: ../../howto/sorting.rst:0
msgid "Release"
msgstr "發佈版本"

#: ../../howto/sorting.rst:7
msgid "0.1"
msgstr "0.1"

#: ../../howto/sorting.rst:10
#, fuzzy
msgid ""
"Python lists have a built-in :meth:`list.sort` method that modifies the list "
"in-place.  There is also a :func:`sorted` built-in function that builds a "
"new sorted list from an iterable."
msgstr ""
"Python 列表有一個內建的 list.sort 方法，可以就地修改列表。還有一個 "
":func:`sorted` 內建函式，可以從可疊代物件構建一個新的排序列表。"

#: ../../howto/sorting.rst:14
msgid ""
"In this document, we explore the various techniques for sorting data using "
"Python."
msgstr "在此文件，我們使用Python進行各種方式排序資料"

#: ../../howto/sorting.rst:18
msgid "Sorting Basics"
msgstr "基礎排序"

#: ../../howto/sorting.rst:20
#, fuzzy
msgid ""
"A simple ascending sort is very easy: just call the :func:`sorted` function. "
"It returns a new sorted list:"
msgstr "簡單的升序排序非常簡單：只需呼叫 :func:`sorted` "
"函式即可。它回傳一個新的排序列表："

#: ../../howto/sorting.rst:28
#, fuzzy
msgid ""
"You can also use the :meth:`list.sort` method. It modifies the list in-place "
"(and returns ``None`` to avoid confusion). Usually it's less convenient "
"than :func:`sorted` - but if you don't need the original list, it's slightly "
"more efficient."
msgstr ""
"您還可以使用 :meth:`list.sort` 方法。它就地修改列表（並回傳 ``None`` 以避免混淆）。"
"通常它不如 :func:`sorted` 方便 - 但如果您不需要原始列表，它會稍微高效一些。"

#: ../../howto/sorting.rst:40
#, fuzzy
msgid ""
"Another difference is that the :meth:`list.sort` method is only defined for "
"lists. In contrast, the :func:`sorted` function accepts any iterable."
msgstr "另一個區別是 :meth:`list.sort` 方法僅為列表定義。相反，:func:`sorted` "
"函式接受任何可疊代物件。"

#: ../../howto/sorting.rst:49
#, fuzzy
msgid "Key Functions"
msgstr "主要功能"

#: ../../howto/sorting.rst:51
#, fuzzy
msgid ""
"Both :meth:`list.sort` and :func:`sorted` have a *key* parameter to specify "
"a function (or other callable) to be called on each list element prior to "
"making comparisons."
msgstr ""
":meth:`list.sort` 和 :func:`sorted` 都有一個 *key* "
"參數來指定在進行比較之前在每個列表元素上呼叫的函式（或其他可呼叫函式）。"

#: ../../howto/sorting.rst:55
#, fuzzy
msgid "For example, here's a case-insensitive string comparison:"
msgstr "例如，這是一個不區分大小寫的字串比較："

#: ../../howto/sorting.rst:62
#, fuzzy
msgid ""
"The value of the *key* parameter should be a function (or other callable) "
"that takes a single argument and returns a key to use for sorting purposes. "
"This technique is fast because the key function is called exactly once for "
"each input record."
msgstr ""
"*key* 參數的值應該是一個函式（或其他可呼叫函式），它接受一個參數並回傳一個用"
"於排序目的的鍵。這種技術很快，因為鍵函式只為每個輸入記錄呼叫一次。"

#: ../../howto/sorting.rst:67
#, fuzzy
msgid ""
"A common pattern is to sort complex objects using some of the object's "
"indices as keys. For example:"
msgstr "一種常見的模式是使用物件的某些索引作為鍵對複雜物件進行排序。例如："

#: ../../howto/sorting.rst:80
#, fuzzy
msgid ""
"The same technique works for objects with named attributes. For example:"
msgstr "同樣的技術適用於具有命名屬性的物件。例如："

#: ../../howto/sorting.rst:101
#, fuzzy
msgid "Operator Module Functions"
msgstr "操作員模組功能"

#: ../../howto/sorting.rst:103
#, fuzzy
msgid ""
"The key-function patterns shown above are very common, so Python provides "
"convenience functions to make accessor functions easier and faster. The :mod:"
"`operator` module has :func:`~operator.itemgetter`, :func:`~operator."
"attrgetter`, and a :func:`~operator.methodcaller` function."
msgstr ""
"上面顯示的鍵函式模式非常常見，因此 Python "
"提供了方便的函式來使訪問函式更容易和更快。 :mod:`operator` 模組具有 "
":func:`~operator.itemgetter`、:func:`~operator.attrgetter` 和一個 "
":func:`~operator.methodcaller` 函式。"

#: ../../howto/sorting.rst:108
#, fuzzy
msgid "Using those functions, the above examples become simpler and faster:"
msgstr "使用這些函式，上面的例子變得更簡單和更快："

#: ../../howto/sorting.rst:120
#, fuzzy
msgid ""
"The operator module functions allow multiple levels of sorting. For example, "
"to sort by *grade* then by *age*:"
msgstr "運算符模組函式允許多級排序。例如，要按 *grade* 然後按 *age* 排序："

#: ../../howto/sorting.rst:132
msgid "Ascending and Descending"
msgstr "升冪與降冪"

#: ../../howto/sorting.rst:134
#, fuzzy
msgid ""
"Both :meth:`list.sort` and :func:`sorted` accept a *reverse* parameter with "
"a boolean value. This is used to flag descending sorts. For example, to get "
"the student data in reverse *age* order:"
msgstr ""
":meth:`list.sort` 和 :func:`sorted` 都接受一個帶有布爾值的 *reverse* "
"參數。這用於標記降序排序。例如，要以反向 *age* 順序獲取學生資料："

#: ../../howto/sorting.rst:147
#, fuzzy
msgid "Sort Stability and Complex Sorts"
msgstr "排序穩定性和復雜排序"

#: ../../howto/sorting.rst:149
#, fuzzy
msgid ""
"Sorts are guaranteed to be `stable <https://en.wikipedia.org/wiki/"
"Sorting_algorithm#Stability>`_\\. That means that when multiple records have "
"the same key, their original order is preserved."
msgstr ""
"排序保證是`穩定的 <https://en.wikipedia.org/wiki/"
"Sorting_algorithm#Stability>`_\\"
"。這意味著當多個記錄具有相同的鍵時，它們的原始順序將被保留。"

#: ../../howto/sorting.rst:159
#, fuzzy
msgid ""
"Notice how the two records for *blue* retain their original order so that "
"``('blue', 1)`` is guaranteed to precede ``('blue', 2)``."
msgstr "請注意 *blue* 的兩個記錄如何保留其原始順序，以便保證 ``('blue', 1)`` 在 ``("
"'blue', 2)`` 之前。"

#: ../../howto/sorting.rst:162
#, fuzzy
msgid ""
"This wonderful property lets you build complex sorts in a series of sorting "
"steps. For example, to sort the student data by descending *grade* and then "
"ascending *age*, do the *age* sort first and then sort again using *grade*:"
msgstr ""
"這個奇妙的屬性使您可以在一系列排序步驟中構建複雜的排序。例如，要按 *grade* "
"降序然後 *age* 升序對學生資料進行排序，請先執行 *age* 排序，然後使用 *grade* "
"再次排序："

#: ../../howto/sorting.rst:172
#, fuzzy
msgid ""
"This can be abstracted out into a wrapper function that can take a list and "
"tuples of field and order to sort them on multiple passes."
msgstr "這可以抽象成一個包裝函式，該函式可以獲取欄位的列表和元組，並在多次傳遞時對它"
"們進行排序。"

#: ../../howto/sorting.rst:185
#, fuzzy
msgid ""
"The `Timsort <https://en.wikipedia.org/wiki/Timsort>`_ algorithm used in "
"Python does multiple sorts efficiently because it can take advantage of any "
"ordering already present in a dataset."
msgstr ""
"Python 中使用的 `Timsort <https://en.wikipedia.org/wiki/Timsort>`_ "
"演算法可以高效地進行多種排序，因為它可以利用資料集中已經存在的任何排序。"

#: ../../howto/sorting.rst:190
#, fuzzy
msgid "Decorate-Sort-Undecorate"
msgstr "裝飾-排序-取消裝飾"

#: ../../howto/sorting.rst:192
#, fuzzy
msgid "This idiom is called Decorate-Sort-Undecorate after its three steps:"
msgstr "這個成語在它的三個步驟之後被稱為 Decorate-Sort-Undecorate："

#: ../../howto/sorting.rst:194
#, fuzzy
msgid ""
"First, the initial list is decorated with new values that control the sort "
"order."
msgstr "首先，初始列表裝飾有控制排序順序的新值。"

#: ../../howto/sorting.rst:196
#, fuzzy
msgid "Second, the decorated list is sorted."
msgstr "二是對裝飾列表進行排序。"

#: ../../howto/sorting.rst:198
#, fuzzy
msgid ""
"Finally, the decorations are removed, creating a list that contains only the "
"initial values in the new order."
msgstr "最後，刪除裝飾，建立一個僅包含新順序中的初始值的列表。"

#: ../../howto/sorting.rst:201
#, fuzzy
msgid ""
"For example, to sort the student data by *grade* using the DSU approach:"
msgstr "例如，要使用 DSU 方法按 *grade* 對學生資料進行排序："

#: ../../howto/sorting.rst:208
#, fuzzy
msgid ""
"This idiom works because tuples are compared lexicographically; the first "
"items are compared; if they are the same then the second items are compared, "
"and so on."
msgstr "這個習慣用法之所以有效，是因為元組是按字典順序進行比較的；比較第一項；如果它"
"們相同，則比較第二項，依此類推。"

#: ../../howto/sorting.rst:212
#, fuzzy
msgid ""
"It is not strictly necessary in all cases to include the index *i* in the "
"decorated list, but including it gives two benefits:"
msgstr "並非在所有情況下都必須在修飾列表中包含索引 *i*，但包含它有兩個好處："

#: ../../howto/sorting.rst:215
#, fuzzy
msgid ""
"The sort is stable -- if two items have the same key, their order will be "
"preserved in the sorted list."
msgstr "排序是穩定的——如果兩個項目具有相同的鍵，它們的順序將保留在排序列表中。"

#: ../../howto/sorting.rst:218
#, fuzzy
msgid ""
"The original items do not have to be comparable because the ordering of the "
"decorated tuples will be determined by at most the first two items. So for "
"example the original list could contain complex numbers which cannot be "
"sorted directly."
msgstr "原始項不必具有可比性，因為裝飾元組的順序最多由前兩項決定。因此，例如原始列表"
"可能包含無法直接排序的複數。"

#: ../../howto/sorting.rst:223
#, fuzzy
msgid ""
"Another name for this idiom is `Schwartzian transform <https://en.wikipedia."
"org/wiki/Schwartzian_transform>`_\\, after Randal L. Schwartz, who "
"popularized it among Perl programmers."
msgstr ""
"這個習語的另一個名字是`Schwartzian 變換 <https://en.wikipedia.org/wiki/"
"Schwartzian_transform>`_\\，以 Randal L. Schwartz 的名字命名，他在 Perl "
"程式員中推廣了它。"

#: ../../howto/sorting.rst:227
#, fuzzy
msgid ""
"Now that Python sorting provides key-functions, this technique is not often "
"needed."
msgstr "既然 Python 排序提供了鍵函式，這種技術就不再需要了。"

#: ../../howto/sorting.rst:230
#, fuzzy
msgid "Comparison Functions"
msgstr "比較函式"

#: ../../howto/sorting.rst:232
#, fuzzy
msgid ""
"Unlike key functions that return an absolute value for sorting, a comparison "
"function computes the relative ordering for two inputs."
msgstr "與回傳排序絕對值的鍵函式不同，比較函式計算兩個輸入的相對順序。"

#: ../../howto/sorting.rst:235
#, fuzzy
msgid ""
"For example, a `balance scale <https://upload.wikimedia.org/wikipedia/"
"commons/1/17/Balance_à_tabac_1850.JPG>`_ compares two samples giving a "
"relative ordering: lighter, equal, or heavier. Likewise, a comparison "
"function such as ``cmp(a, b)`` will return a negative value for less-than, "
"zero if the inputs are equal, or a positive value for greater-than."
msgstr ""
"例如，`天平 <https://upload.wikimedia.org/wikipedia/commons/1/17/"
"Balance_à_tabac_1850.JPG>`_ "
"比較兩個樣本，給出相對順序：更輕、相等或更重。同樣，諸如“cmp(a, "
"b)”之類的比較函式將在小於時回傳負值，在輸入相等時回傳零，或在大於時回傳正值。"

#: ../../howto/sorting.rst:242
#, fuzzy
msgid ""
"It is common to encounter comparison functions when translating algorithms "
"from other languages.  Also, some libraries provide comparison functions as "
"part of their API.  For example, :func:`locale.strcoll` is a comparison "
"function."
msgstr ""
"從其他語言翻譯演算法時，經常會遇到比較函式。此外，一些庫提供比較功能作為其 "
"API 的一部分。例如，:func:`locale.strcoll` 是一個比較函式。"

#: ../../howto/sorting.rst:246
#, fuzzy
msgid ""
"To accommodate those situations, Python provides :class:`functools."
"cmp_to_key` to wrap the comparison function to make it usable as a key "
"function::"
msgstr "為了適應這些情況，Python 提供 functools.cmp_to_key "
"來包裝比較函式，使其可用作鍵函式::"

#: ../../howto/sorting.rst:253
#, fuzzy
msgid "Odds and Ends"
msgstr "什物"

#: ../../howto/sorting.rst:255
#, fuzzy
msgid ""
"For locale aware sorting, use :func:`locale.strxfrm` for a key function or :"
"func:`locale.strcoll` for a comparison function.  This is necessary because "
"\"alphabetical\" sort orderings can vary across cultures even if the "
"underlying alphabet is the same."
msgstr ""
"對於區域設定感知排序，使用 :func:`locale.strxfrm` 作為關鍵函式或使用 "
":func:`locale.strcoll` 作為比較函式。這是必要的，因為即使底層字母表相同，“字"
"母”排序也可能因文化而異。"

#: ../../howto/sorting.rst:260
#, fuzzy
msgid ""
"The *reverse* parameter still maintains sort stability (so that records with "
"equal keys retain the original order). Interestingly, that effect can be "
"simulated without the parameter by using the builtin :func:`reversed` "
"function twice:"
msgstr ""
"*reverse* "
"參數仍然保持排序穩定性（以便具有相同鍵的記錄保持原始順序）。有趣的是，"
"這種效果可以在沒有參數的情況下通過使用內建的 reversed 函式兩次來模擬："

#: ../../howto/sorting.rst:274
#, fuzzy
msgid ""
"The sort routines use ``<`` when making comparisons between two objects. So, "
"it is easy to add a standard sort order to a class by defining an :meth:"
"`__lt__` method:"
msgstr "在兩個物件之間進行比較時，排序例程使用 ``<``。因此，通過定義 :meth:`__lt__` "
"方法可以很容易地向類新增標準排序順序："

#: ../../howto/sorting.rst:284
#, fuzzy
msgid ""
"However, note that ``<`` can fall back to using :meth:`__gt__` if :meth:"
"`__lt__` is not implemented (see :func:`object.__lt__`)."
msgstr ""
"但是，請注意，如果 :meth:`__lt__` 未實作，``<`` 可以回退到使用 "
":meth:`__gt__`（參見 :func:`object.__lt__`）。"

#: ../../howto/sorting.rst:287
#, fuzzy
msgid ""
"Key functions need not depend directly on the objects being sorted. A key "
"function can also access external resources. For instance, if the student "
"grades are stored in a dictionary, they can be used to sort a separate list "
"of student names:"
msgstr "關鍵函式不需要直接依賴於被排序的物件。關鍵功能還可以訪問外部資源。例如，如果"
"學生成績儲存在字典中，它們可用於對單獨的學生姓名列表進行排序："
