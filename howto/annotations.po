# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-25 00:16+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../howto/annotations.rst:5
msgid "Annotations Best Practices"
msgstr "註釋最佳實踐"

#: ../../howto/annotations.rst:0
msgid "author"
msgstr "作者"

#: ../../howto/annotations.rst:7
msgid "Larry Hastings"
msgstr "Larry Hastings"

#: ../../howto/annotations.rst:-1
msgid "Abstract"
msgstr "摘要"

#: ../../howto/annotations.rst:11
#, fuzzy
msgid ""
"This document is designed to encapsulate the best practices for working with "
"annotations dicts.  If you write Python code that examines "
"``__annotations__`` on Python objects, we encourage you to follow the "
"guidelines described below."
msgstr ""
"本文檔旨在封裝使用註釋字典的最佳實踐。如果您編寫 Python 程式碼來檢查 Python "
"對像上的“__annotations__”，我們鼓勵您遵循下面描述的準則。"

#: ../../howto/annotations.rst:16
#, fuzzy
msgid ""
"The document is organized into four sections: best practices for accessing "
"the annotations of an object in Python versions 3.10 and newer, best "
"practices for accessing the annotations of an object in Python versions 3.9 "
"and older, other best practices for ``__annotations__`` that apply to any "
"Python version, and quirks of ``__annotations__``."
msgstr ""
"該文檔分為四個部分：在 Python 3.10 及更高版本中訪問物件註釋的最佳實踐，在 "
"Python 3.9 及更早版本中訪問物件註釋的最佳實踐，“__annotations__”"
"的其他最佳實踐適用於任何 Python 版本，以及 ``__annotations__`` 的怪癖。"

#: ../../howto/annotations.rst:26
#, fuzzy
msgid ""
"Note that this document is specifically about working with "
"``__annotations__``, not uses *for* annotations. If you're looking for "
"information on how to use \"type hints\" in your code, please see the :mod:"
"`typing` module."
msgstr ""
"請注意，本文檔專門介紹如何使用 ``__annotations__``，而不是使用 *for* "
"註釋。如果您正在尋找有關如何在程式碼中使用“型別提示”的資訊，請參閱 "
":mod:`typing` 模組。"

#: ../../howto/annotations.rst:33
#, fuzzy
msgid "Accessing The Annotations Dict Of An Object In Python 3.10 And Newer"
msgstr "在 Python 3.10 及更新版本中訪問物件的註解字典"

#: ../../howto/annotations.rst:35
#, fuzzy
msgid ""
"Python 3.10 adds a new function to the standard library: :func:`inspect."
"get_annotations`.  In Python versions 3.10 and newer, calling this function "
"is the best practice for accessing the annotations dict of any object that "
"supports annotations.  This function can also \"un-stringize\" stringized "
"annotations for you."
msgstr ""
"Python 3.10 向標準庫新增了一個新函式：:func:`inspect.get_annotations`。在 "
"Python 3.10 及更新版本中，呼叫此函式是訪問支援註釋的任何物件的註釋字典的最佳"
"實踐。該功能還可以為您“取消字串化”字串化註釋。"

#: ../../howto/annotations.rst:42
#, fuzzy
msgid ""
"If for some reason :func:`inspect.get_annotations` isn't viable for your use "
"case, you may access the ``__annotations__`` data member manually.  Best "
"practice for this changed in Python 3.10 as well: as of Python 3.10, ``o."
"__annotations__`` is guaranteed to *always* work on Python functions, "
"classes, and modules.  If you're certain the object you're examining is one "
"of these three *specific* objects, you may simply use ``o.__annotations__`` "
"to get at the object's annotations dict."
msgstr ""
"如果出於某種原因 :func:`inspect.get_annotations` 對於您的用例不可行，"
"您可以手動訪問 ``__annotations__`` 資料成員。最佳實踐在 Python 3.10 "
"中也發生了變化：從 Python 3.10 開始，``o.__annotations__`` 保證*始終*在 "
"Python "
"函式、類和模組上工作。如果你確定你正在檢查的對像是這三個*特定*物件之一，"
"你可以簡單地使用 ``o.__annotations__`` 來獲取物件的註釋字典。"

#: ../../howto/annotations.rst:52
#, fuzzy
msgid ""
"However, other types of callables--for example, callables created by :func:"
"`functools.partial`--may not have an ``__annotations__`` attribute defined.  "
"When accessing the ``__annotations__`` of a possibly unknown object,  best "
"practice in Python versions 3.10 and newer is to call :func:`getattr` with "
"three arguments, for example ``getattr(o, '__annotations__', None)``."
msgstr ""
"但是，其他型別的可呼叫物件——例如，由 :func:`functools.partial` "
"建立的可呼叫物件——可能沒有定義 ``__annotations__`` 屬性。"
"當訪問一個可能未知的物件的 ``__annotations__`` 時，Python 3.10 "
"及更新版本中的最佳實踐是使用三個參數呼叫 :func:`getattr`，例如 ``getattr(o, "
"'__annotations__', None)` `。"

#: ../../howto/annotations.rst:60
#, fuzzy
msgid ""
"Before Python 3.10, accessing ``__annotations__`` on a class that defines no "
"annotations but that has a parent class with annotations would return the "
"parent's ``__annotations__``. In Python 3.10 and newer, the child class's "
"annotations will be an empty dict instead."
msgstr ""
"在 Python 3.10 之前，在沒有定義註解但具有帶註解的父類的類上訪問“__annotations"
"__”將回傳父類的“__annotations__”。在 Python 3.10 "
"及更新版本中，子類別的註釋將改為空字典。"

#: ../../howto/annotations.rst:68
#, fuzzy
msgid "Accessing The Annotations Dict Of An Object In Python 3.9 And Older"
msgstr "在 Python 3.9 及更早版本中訪問物件的註解字典"

#: ../../howto/annotations.rst:70
#, fuzzy
msgid ""
"In Python 3.9 and older, accessing the annotations dict of an object is much "
"more complicated than in newer versions. The problem is a design flaw in "
"these older versions of Python, specifically to do with class annotations."
msgstr ""
"在 Python 3.9 及更早版本中，訪問物件的註解字典比在較新版本中復雜得多。"
"問題是這些舊版本 Python 中的設計缺陷，特別是與類註釋有關的缺陷。"

#: ../../howto/annotations.rst:75
#, fuzzy
msgid ""
"Best practice for accessing the annotations dict of other objects--"
"functions, other callables, and modules--is the same as best practice for "
"3.10, assuming you aren't calling :func:`inspect.get_annotations`: you "
"should use three-argument :func:`getattr` to access the object's "
"``__annotations__`` attribute."
msgstr ""
"訪問其他物件（函式、其他可呼叫物件和模組）的註釋字典的最佳實踐與 3.10 "
"的最佳實踐相同，假設您不呼叫 :func:`inspect.get_annotations`：您應該使用三個 "
"- argument :func:`getattr` 訪問物件的 ``__annotations__`` 屬性。"

#: ../../howto/annotations.rst:82
#, fuzzy
msgid ""
"Unfortunately, this isn't best practice for classes.  The problem is that, "
"since ``__annotations__`` is optional on classes, and because classes can "
"inherit attributes from their base classes, accessing the "
"``__annotations__`` attribute of a class may inadvertently return the "
"annotations dict of a *base class.* As an example::"
msgstr ""
"不幸的是，這不是課堂的最佳實踐。問題是，由於 ``__annotations__`` "
"在類上是可選的，並且因為類可以從它們的基底類別繼承屬性，訪問類的 "
"``__annotations__`` 屬性可能會無意中回傳*基底類別的註釋字典。 * 舉個例子：："

#: ../../howto/annotations.rst:98
#, fuzzy
msgid "This will print the annotations dict from ``Base``, not ``Derived``."
msgstr "這將從 ``Base`` 而不是 ``Derived`` 印出註釋字典。"

#: ../../howto/annotations.rst:101
#, fuzzy
msgid ""
"Your code will have to have a separate code path if the object you're "
"examining is a class (``isinstance(o, type)``). In that case, best practice "
"relies on an implementation detail of Python 3.9 and before: if a class has "
"annotations defined, they are stored in the class's ``__dict__`` "
"dictionary.  Since the class may or may not have annotations defined, best "
"practice is to call the ``get`` method on the class dict."
msgstr ""
"如果您正在檢查的對像是一個類（``isinstance(o, "
"type)``），您的程式碼將必須有一個單獨的程式碼路徑。在這種情況下，"
"最佳實踐依賴於 Python 3.9 及之前的實作細節：如果一個類定義了註釋，"
"它們將儲存在該類的 ``__dict__`` 字典中。由於類可能有也可能沒有定義註釋，"
"最佳做法是在類字典上呼叫 ``get`` 方法。"

#: ../../howto/annotations.rst:109
#, fuzzy
msgid ""
"To put it all together, here is some sample code that safely accesses the "
"``__annotations__`` attribute on an arbitrary object in Python 3.9 and "
"before::"
msgstr ""
"總而言之，這裡有一些示例程式碼，可以在 Python 3.9 "
"及之前的版本中安全地訪問任意對像上的 ``__annotations__`` 屬性："

#: ../../howto/annotations.rst:118
#, fuzzy
msgid ""
"After running this code, ``ann`` should be either a dictionary or ``None``.  "
"You're encouraged to double-check the type of ``ann`` using :func:"
"`isinstance` before further examination."
msgstr ""
"運行此程式碼後，``ann`` 應該是字典或 ``None``。"
"我們鼓勵您在進一步檢查之前使用 isinstance 仔細檢查 ``ann`` 的型別。"

#: ../../howto/annotations.rst:123
#, fuzzy
msgid ""
"Note that some exotic or malformed type objects may not have a ``__dict__`` "
"attribute, so for extra safety you may also wish to use :func:`getattr` to "
"access ``__dict__``."
msgstr ""
"請注意，一些奇異或格式錯誤的型別物件可能沒有 ``__dict__`` "
"屬性，因此為了額外的安全，您可能還希望使用 :func:`getattr` 來訪問 "
"``__dict__``。"

#: ../../howto/annotations.rst:129
#, fuzzy
msgid "Manually Un-Stringizing Stringized Annotations"
msgstr "手動取消字串化字串化註釋"

#: ../../howto/annotations.rst:131
#, fuzzy
msgid ""
"In situations where some annotations may be \"stringized\", and you wish to "
"evaluate those strings to produce the Python values they represent, it "
"really is best to call :func:`inspect.get_annotations` to do this work for "
"you."
msgstr ""
"在某些註釋可能被“字串化”的情況下，並且您希望評估這些字串以生成它們所代表的 "
"Python 值，最好呼叫 inspect.get_annotations 為您完成這項工作。"

#: ../../howto/annotations.rst:137
#, fuzzy
msgid ""
"If you're using Python 3.9 or older, or if for some reason you can't use :"
"func:`inspect.get_annotations`, you'll need to duplicate its logic.  You're "
"encouraged to examine the implementation of :func:`inspect.get_annotations` "
"in the current Python version and follow a similar approach."
msgstr ""
"如果您使用的是 Python 3.9 或更早版本，或者由於某種原因您無法使用 inspect."
"get_annotations，則需要復制其邏輯。我們鼓勵您在當前 Python 版本中檢查 "
":func:`inspect.get_annotations` 的實作並遵循類似的方法。"

#: ../../howto/annotations.rst:143
#, fuzzy
msgid ""
"In a nutshell, if you wish to evaluate a stringized annotation on an "
"arbitrary object ``o``:"
msgstr "簡而言之，如果您希望評估任意物件 ``o`` 上的字串化註釋："

#: ../../howto/annotations.rst:146
#, fuzzy
msgid ""
"If ``o`` is a module, use ``o.__dict__`` as the ``globals`` when calling :"
"func:`eval`."
msgstr "如果 ``o`` 是一個模組，在呼叫 :func:`eval` 時使用 ``o.__dict__`` 作為 "
"``globals``。"

#: ../../howto/annotations.rst:148
#, fuzzy
msgid ""
"If ``o`` is a class, use ``sys.modules[o.__module__].__dict__`` as the "
"``globals``, and ``dict(vars(o))`` as the ``locals``, when calling :func:"
"`eval`."
msgstr ""
"如果``o``是一個類，使用``sys.modules[o.__module__]."
"__dict__``作為``globals``，使用``dict(vars(o))``作為``locals ``，當呼叫 "
":func:`eval` 時。"

#: ../../howto/annotations.rst:151
#, fuzzy
msgid ""
"If ``o`` is a wrapped callable using :func:`functools.update_wrapper`, :func:"
"`functools.wraps`, or :func:`functools.partial`, iteratively unwrap it by "
"accessing either ``o.__wrapped__`` or ``o.func`` as appropriate, until you "
"have found the root unwrapped function."
msgstr ""
"如果 ``o`` 是使用 :func:`functools.update_wrapper`、:func:`functools.wraps` "
"或 :func:`functools.partial` 的可呼叫包裝，則通過訪問 ``o.__wrapped__ "
"疊代解包它`` 或 ``o.func`` 視情況而定，直到找到根解包函式。"

#: ../../howto/annotations.rst:155
#, fuzzy
msgid ""
"If ``o`` is a callable (but not a class), use ``o.__globals__`` as the "
"globals when calling :func:`eval`."
msgstr "如果 ``o`` 是可呼叫的（但不是類），請在呼叫 :func:`eval` 時使用 ``o."
"__globals__`` 作為全局變數。"

#: ../../howto/annotations.rst:158
#, fuzzy
msgid ""
"However, not all string values used as annotations can be successfully "
"turned into Python values by :func:`eval`. String values could theoretically "
"contain any valid string, and in practice there are valid use cases for type "
"hints that require annotating with string values that specifically *can't* "
"be evaluated.  For example:"
msgstr ""
"但是，並不是所有用作註釋的字串值都可以通過 eval 成功地轉換為 Python 值。字串"
"值在理論上可以包含任何有效的字串，並且在實踐中存在型別提示的有效用例，這些用"
"例需要使用特別*無法*評估的字串值進行註釋。例如："

#: ../../howto/annotations.rst:165
#, fuzzy
msgid ""
":pep:`604` union types using ``|``, before support for this was added to "
"Python 3.10."
msgstr ":pep:`604` 使用``|`` 的聯合型別，在對它的支援被新增到 Python 3.10 之前。"

#: ../../howto/annotations.rst:167
#, fuzzy
msgid ""
"Definitions that aren't needed at runtime, only imported when :const:`typing."
"TYPE_CHECKING` is true."
msgstr "運行時不需要的定義，僅在 :const:`typing.TYPE_CHECKING` 為真時導入。"

#: ../../howto/annotations.rst:170
#, fuzzy
msgid ""
"If :func:`eval` attempts to evaluate such values, it will fail and raise an "
"exception.  So, when designing a library API that works with annotations, "
"it's recommended to only attempt to evaluate string values when explicitly "
"requested to by the caller."
msgstr ""
"如果 :func:`eval` 嘗試評估這些值，它將失敗並引發例外。因此，"
"在設計使用註釋的庫 API 時，建議僅在呼叫者明確請求時才嘗試評估字串值。"

#: ../../howto/annotations.rst:178
#, fuzzy
msgid "Best Practices For ``__annotations__`` In Any Python Version"
msgstr "任何 Python 版本中 ``__annotations__`` 的最佳實踐"

#: ../../howto/annotations.rst:180
#, fuzzy
msgid ""
"You should avoid assigning to the ``__annotations__`` member of objects "
"directly.  Let Python manage setting ``__annotations__``."
msgstr "您應該避免直接分配給物件的 ``__annotations__`` 成員。讓 Python 管理設定 "
"``__annotations__``。"

#: ../../howto/annotations.rst:183
#, fuzzy
msgid ""
"If you do assign directly to the ``__annotations__`` member of an object, "
"you should always set it to a ``dict`` object."
msgstr "如果你直接賦值給一個物件的 ``__annotations__`` 成員，"
"你應該總是將它設定為一個 ``dict`` 物件。"

#: ../../howto/annotations.rst:186
#, fuzzy
msgid ""
"If you directly access the ``__annotations__`` member of an object, you "
"should ensure that it's a dictionary before attempting to examine its "
"contents."
msgstr "如果您直接訪問物件的 ``__annotations__`` "
"成員，您應該在嘗試檢查其內容之前確保它是一個字典。"

#: ../../howto/annotations.rst:190
#, fuzzy
msgid "You should avoid modifying ``__annotations__`` dicts."
msgstr "你應該避免修改 ``__annotations__`` 指令。"

#: ../../howto/annotations.rst:192
#, fuzzy
msgid ""
"You should avoid deleting the ``__annotations__`` attribute of an object."
msgstr "您應該避免刪除物件的 ``__annotations__`` 屬性。"

#: ../../howto/annotations.rst:197
#, fuzzy
msgid "``__annotations__`` Quirks"
msgstr "``__annotations__`` 怪癖"

#: ../../howto/annotations.rst:199
#, fuzzy
msgid ""
"In all versions of Python 3, function objects lazy-create an annotations "
"dict if no annotations are defined on that object.  You can delete the "
"``__annotations__`` attribute using ``del fn.__annotations__``, but if you "
"then access ``fn.__annotations__`` the object will create a new empty dict "
"that it will store and return as its annotations.  Deleting the annotations "
"on a function before it has lazily created its annotations dict will throw "
"an ``AttributeError``; using ``del fn.__annotations__`` twice in a row is "
"guaranteed to always throw an ``AttributeError``."
msgstr ""
"在 Python 3 "
"的所有版本中，如果沒有在該對像上定義註釋，函式物件將延遲建立一個註釋字典。"
"您可以使用 del fn.__annotations__ 刪除 __annotations__ 屬性，"
"但如果您隨後訪問 fn.__annotations__ "
"物件將建立一個新的空字典，它將儲存並作為其註釋回傳。"
"在懶惰地建立其註釋字典之前刪除函式上的註釋將拋出 ``AttributeError``；"
"連續兩次使用 ``del fn.__annotations__`` 保證總是拋出 ``AttributeError``。"

#: ../../howto/annotations.rst:209
#, fuzzy
msgid ""
"Everything in the above paragraph also applies to class and module objects "
"in Python 3.10 and newer."
msgstr "上一段中的所有內容也適用於 Python 3.10 及更新版本中的類和模組物件。"

#: ../../howto/annotations.rst:212
#, fuzzy
msgid ""
"In all versions of Python 3, you can set ``__annotations__`` on a function "
"object to ``None``.  However, subsequently accessing the annotations on that "
"object using ``fn.__annotations__`` will lazy-create an empty dictionary as "
"per the first paragraph of this section.  This is *not* true of modules and "
"classes, in any Python version; those objects permit setting "
"``__annotations__`` to any Python value, and will retain whatever value is "
"set."
msgstr ""
"在 Python 3 的所有版本中，您可以將函式對像上的 ``__annotations__`` 設定為 "
"``None``。但是，隨後使用 fn.__annotations__ "
"訪問該對像上的註釋將根據本節的第一段延遲建立一個空字典。在任何 Python "
"版本中，模組和類都*不*如此；這些物件允許將 ``__annotations__`` 設定為任何 "
"Python 值，並將保留設定的任何值。"

#: ../../howto/annotations.rst:220
#, fuzzy
msgid ""
"If Python stringizes your annotations for you (using ``from __future__ "
"import annotations``), and you specify a string as an annotation, the string "
"will itself be quoted.  In effect the annotation is quoted *twice.*  For "
"example::"
msgstr ""
"如果 Python 為您將註釋字串化（使用 ``from __future__ import "
"annotations``），並且您指定一個字串作為註釋，則該字串本身將被引用。實際上，"
"註釋被引用 *兩次。* 例如："

#: ../../howto/annotations.rst:231
#, fuzzy
msgid ""
"This prints ``{'a': \"'str'\"}``.  This shouldn't really be considered a "
"\"quirk\"; it's mentioned here simply because it might be surprising."
msgstr "這會印出 ``{\\'a\\': \"\\'str\\'\""
"}``。這真的不應該被認為是一個“怪癖”；在這裡提到它只是因為它可能令人驚訝。"
