# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-10 00:16+0000\n"
"PO-Revision-Date: 2018-05-23 14:37+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/sockets.rst:5
#, fuzzy
msgid "Socket Programming HOWTO"
msgstr " socket 編程指南"

#: ../../howto/sockets.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/sockets.rst:7
msgid "Gordon McMillan"
msgstr "Gordon McMillan"

#: ../../howto/sockets.rst:-1
msgid "Abstract"
msgstr "摘要"

#: ../../howto/sockets.rst:12
#, fuzzy
msgid ""
"Sockets are used nearly everywhere, but are one of the most severely "
"misunderstood technologies around. This is a 10,000 foot overview of "
"sockets. It's not really a tutorial - you'll still have work to do in "
"getting things operational. It doesn't cover the fine points (and there are "
"a lot of them), but I hope it will give you enough background to begin using "
"them decently."
msgstr ""
" socket 幾乎無處不在，但卻是周圍被誤解最嚴重的技術之一。這是 10,000 英尺插座的"
"概述。這並不是一個真正的教程——您仍然需要做一些工作才能讓事情變得可操作。它沒"
"有涵蓋要點（並且有很多），但我希望它能為您提供足夠的背景知識，以便開始正確地"
"使用它們。"

#: ../../howto/sockets.rst:20
#, fuzzy
msgid "Sockets"
msgstr "插座"

#: ../../howto/sockets.rst:22
#, fuzzy
msgid ""
"I'm only going to talk about INET (i.e. IPv4) sockets, but they account for "
"at least 99% of the sockets in use. And I'll only talk about STREAM (i.e. "
"TCP) sockets - unless you really know what you're doing (in which case this "
"HOWTO isn't for you!), you'll get better behavior and performance from a "
"STREAM socket than anything else. I will try to clear up the mystery of what "
"a socket is, as well as some hints on how to work with blocking and non-"
"blocking sockets. But I'll start by talking about blocking sockets. You'll "
"need to know how they work before dealing with non-blocking sockets."
msgstr ""
"我只打算談論 INET（即 IPv4） socket ，但它們至少佔使用中 socket 的 99%。"
"我只會談論 STREAM（即 TCP） socket ——除非你真的知道你在做什麼（在這種情況下，"
"本 HOWTO 不適合你！），你會從 STREAM  socket 獲得比 STREAM  socket 更好的行為和性"
"能還要別的嗎。我將嘗試揭開什麼是 socket 的謎團，以及關於如何使用阻塞和非阻塞套"
"接字的一些提示。但我將從談論阻塞 socket 開始。在處理非阻塞 socket 之前，您需要了"
"解它們的工作原理。"

#: ../../howto/sockets.rst:31
#, fuzzy
msgid ""
"Part of the trouble with understanding these things is that \"socket\" can "
"mean a number of subtly different things, depending on context. So first, "
"let's make a distinction between a \"client\" socket - an endpoint of a "
"conversation, and a \"server\" socket, which is more like a switchboard "
"operator. The client application (your browser, for example) uses \"client\" "
"sockets exclusively; the web server it's talking to uses both \"server\" "
"sockets and \"client\" sockets."
msgstr ""
"理解這些東西的部分困難在於“ socket ”可能意味著許多微妙的不同事物，具體取決於上"
"下文。因此，首先，讓我們區分“客戶端” socket （對話的端點）和“伺服器” socket （更"
"像是總機接線員）。客戶端應用程式（例如您的瀏覽器）專門使用“客戶端” socket ；"
"與之通信的 Web 伺服器同時使用“伺服器” socket 和“客戶端” socket 。"

#: ../../howto/sockets.rst:40
#, fuzzy
msgid "History"
msgstr "歷史"

#: ../../howto/sockets.rst:42
#, fuzzy
msgid ""
"Of the various forms of :abbr:`IPC (Inter Process Communication)`, sockets "
"are by far the most popular.  On any given platform, there are likely to be "
"other forms of IPC that are faster, but for cross-platform communication, "
"sockets are about the only game in town."
msgstr ""
"在各種形式的 :abbr:`IPC（行程間通信）` "
"中， socket 是迄今為止最受歡迎的。在任何給定的平台上，都可能有其他形式的 IPC "
"更快，但對於跨平台通信， socket 幾乎是唯一的選擇。"

#: ../../howto/sockets.rst:47
#, fuzzy
msgid ""
"They were invented in Berkeley as part of the BSD flavor of Unix. They "
"spread like wildfire with the internet. With good reason --- the combination "
"of sockets with INET makes talking to arbitrary machines around the world "
"unbelievably easy (at least compared to other schemes)."
msgstr ""
"它們是在伯克利發明的，是 Unix BSD "
"風格的一部分。它們通過網際網路像野火一樣蔓延開來。有充分的理由—— socket 與 INET "
"的結合使得與世界各地的任意機器的對話變得難以置信的容易（至少與其他方案相比）"
"。"

#: ../../howto/sockets.rst:54
#, fuzzy
msgid "Creating a Socket"
msgstr "建立 socket "

#: ../../howto/sockets.rst:56
#, fuzzy
msgid ""
"Roughly speaking, when you clicked on the link that brought you to this "
"page, your browser did something like the following::"
msgstr "粗略地說，當您單擊將您帶到此頁面的鏈接時，您的瀏覽器會執行如下操作："

#: ../../howto/sockets.rst:64
#, fuzzy
msgid ""
"When the ``connect`` completes, the socket ``s`` can be used to send in a "
"request for the text of the page. The same socket will read the reply, and "
"then be destroyed. That's right, destroyed. Client sockets are normally only "
"used for one exchange (or a small set of sequential exchanges)."
msgstr ""
"當“連接”完成時， socket  ``s``可用於發送對頁面文本的請求。相同的 socket 將讀取回覆，"
"然後被銷毀。沒錯，毀了。客戶端 socket 通常僅用於一次交換（或一小組順序交換）。"

#: ../../howto/sockets.rst:70
#, fuzzy
msgid ""
"What happens in the web server is a bit more complex. First, the web server "
"creates a \"server socket\"::"
msgstr "Web 伺服器中發生的事情有點複雜。首先，網絡伺服器建立一個“伺服器 socket ”::"

#: ../../howto/sockets.rst:80
#, fuzzy
msgid ""
"A couple things to notice: we used ``socket.gethostname()`` so that the "
"socket would be visible to the outside world.  If we had used ``s."
"bind(('localhost', 80))`` or ``s.bind(('127.0.0.1', 80))`` we would still "
"have a \"server\" socket, but one that was only visible within the same "
"machine.  ``s.bind(('', 80))`` specifies that the socket is reachable by any "
"address the machine happens to have."
msgstr ""
"有幾件事需要注意：我們使用了 ``socket.gethostname()`` 以便 socket 對外界可見。"
"如果我們使用了 ``s.bind(('localhost', 80))`` 或 ``s.bind(('127.0.0.1', 80))``"
" 我們仍然會有一個“伺服器” socket ，但是一個只在同一台機器中可見的。 ``s.bind(("
"'', 80))`` 指定 socket 可以通過機器碰巧擁有的任何地址訪問。"

#: ../../howto/sockets.rst:87
#, fuzzy
msgid ""
"A second thing to note: low number ports are usually reserved for \"well "
"known\" services (HTTP, SNMP etc). If you're playing around, use a nice high "
"number (4 digits)."
msgstr "第二件需要注意的事情：低端口號通常保留給“知名”服務（HTTP、SNMP "
"等）。如果您正在玩耍，請使用一個不錯的大數字（4 位數）。"

#: ../../howto/sockets.rst:91
#, fuzzy
msgid ""
"Finally, the argument to ``listen`` tells the socket library that we want it "
"to queue up as many as 5 connect requests (the normal max) before refusing "
"outside connections. If the rest of the code is written properly, that "
"should be plenty."
msgstr ""
"最後，``listen`` 的參數告訴 socket 庫我們希望它在拒絕外部連接之前排隊多達 5 "
"個連接請求（正常最大值）。如果其餘程式碼編寫正確，那應該足夠了。"

#: ../../howto/sockets.rst:95
#, fuzzy
msgid ""
"Now that we have a \"server\" socket, listening on port 80, we can enter the "
"mainloop of the web server::"
msgstr "現在我們有了一個“伺服器” socket ，偵聽端口 80，我們可以進入 Web "
"伺服器的主循環::"

#: ../../howto/sockets.rst:106
#, fuzzy
msgid ""
"There's actually 3 general ways in which this loop could work - dispatching "
"a thread to handle ``clientsocket``, create a new process to handle "
"``clientsocket``, or restructure this app to use non-blocking sockets, and "
"multiplex between our \"server\" socket and any active ``clientsocket``\\ s "
"using ``select``. More about that later. The important thing to understand "
"now is this: this is *all* a \"server\" socket does. It doesn't send any "
"data. It doesn't receive any data. It just produces \"client\" sockets. Each "
"``clientsocket`` is created in response to some *other* \"client\" socket "
"doing a ``connect()`` to the host and port we're bound to. As soon as we've "
"created that ``clientsocket``, we go back to listening for more connections. "
"The two \"clients\" are free to chat it up - they are using some dynamically "
"allocated port which will be recycled when the conversation ends."
msgstr ""
"這個循環實際上有 3 種通用的工作方式——分派一個執行緒來處理 ``clientsocket`` ，建立"
"一個新行程來處理 ``clientsocket`` ，或者重構這個應用程式以使用非阻塞 socket ，並在"
"我們之間多路復用“伺服器” socket 和任何使用“選擇”的活動“客戶端 socket ”。稍後會詳"
"細介紹。現在要理解的重要一點是：這是*所有*“伺服器” socket 所做的。它不發送任何"
"資料。它不接收任何資料。它只產生“客戶端” socket 。每個 ``clientsocket`` "
"都是為了響應某些*其他*“客戶端” socket 而建立的，"
"這些 socket 對我們綁定到的主機和端口執行 ``connect()``。一旦我們建立了那個``cli"
"entsocket``，我們就回去監聽更多的連接。這兩個“客戶”可以自由地聊天——他們正在使"
"用一些動態分配的端口，這些端口將在對話結束時被回收。"

#: ../../howto/sockets.rst:121
msgid "IPC"
msgstr "IPC"

#: ../../howto/sockets.rst:123
#, fuzzy
msgid ""
"If you need fast IPC between two processes on one machine, you should look "
"into pipes or shared memory.  If you do decide to use AF_INET sockets, bind "
"the \"server\" socket to ``'localhost'``. On most platforms, this will take "
"a shortcut around a couple of layers of network code and be quite a bit "
"faster."
msgstr ""
"如果您需要一台機器上兩個行程之間的快速 IPC，您應該查看管道或共享記憶體。"
"如果您決定使用 AF_INET  socket ，請將“伺服器” socket 綁定到 ``'localhost'``。在大多數平"
"台上，這將圍繞幾層網絡程式碼採取捷徑，並且速度要快得多。"

#: ../../howto/sockets.rst:129
#, fuzzy
msgid ""
"The :mod:`multiprocessing` integrates cross-platform IPC into a higher-level "
"API."
msgstr ":mod:`multiprocessing` 將跨平台 IPC 集成到更高階別的 API 中。"

#: ../../howto/sockets.rst:134
#, fuzzy
msgid "Using a Socket"
msgstr "使用 socket "

#: ../../howto/sockets.rst:136
#, fuzzy
msgid ""
"The first thing to note, is that the web browser's \"client\" socket and the "
"web server's \"client\" socket are identical beasts. That is, this is a "
"\"peer to peer\" conversation. Or to put it another way, *as the designer, "
"you will have to decide what the rules of etiquette are for a conversation*. "
"Normally, the ``connect``\\ ing socket starts the conversation, by sending "
"in a request, or perhaps a signon. But that's a design decision - it's not a "
"rule of sockets."
msgstr ""
"首先要注意的是，Web 瀏覽器的“客戶端” socket 和 Web 伺服器的“客戶端” socket 是相同"
"的野獸。也就是說，這是一個“點對點”對話。或者換句話說，*作為設計師，您必須決定"
"談話的禮儀規則是什麼*。通常，“連接” socket 通過發送請求或登錄來啟動對話。但這是"
"一個設計決定——它不是 socket 的規則。"

#: ../../howto/sockets.rst:143
#, fuzzy
msgid ""
"Now there are two sets of verbs to use for communication. You can use "
"``send`` and ``recv``, or you can transform your client socket into a file-"
"like beast and use ``read`` and ``write``. The latter is the way Java "
"presents its sockets. I'm not going to talk about it here, except to warn "
"you that you need to use ``flush`` on sockets. These are buffered \"files\", "
"and a common mistake is to ``write`` something, and then ``read`` for a "
"reply. Without a ``flush`` in there, you may wait forever for the reply, "
"because the request may still be in your output buffer."
msgstr ""
"現在有兩組動詞可用於交流。您可以使用 ``send`` 和 ``recv``，"
"或者您可以將客戶端 socket 轉換為類似文件的野獸並使用 ``read`` 和 ``write``。"
"後者是 Java 呈現其 socket 的方式。我不打算在這裡談論它，"
"只是警告你需要在 socket 上使用 ``flush``。這些是緩衝的“文件”，一個常見的錯誤是“"
"寫”一些東西，然後“讀取”以獲得回覆。如果那裡沒有 "
"``flush``，您可能會永遠等待回覆，因為請求可能仍在您的輸出緩衝區中。"

#: ../../howto/sockets.rst:152
#, fuzzy
msgid ""
"Now we come to the major stumbling block of sockets - ``send`` and ``recv`` "
"operate on the network buffers. They do not necessarily handle all the bytes "
"you hand them (or expect from them), because their major focus is handling "
"the network buffers. In general, they return when the associated network "
"buffers have been filled (``send``) or emptied (``recv``). They then tell "
"you how many bytes they handled. It is *your* responsibility to call them "
"again until your message has been completely dealt with."
msgstr ""
"現在我們來到 socket 的主要障礙 - ``send`` 和 ``recv`` 在網絡緩衝區上操作。它們"
"不一定處理您交給它們（或期望來自它們）的所有位元組，因為它們的主要重點是處理"
"網絡緩衝區。通常，當關聯的網絡緩衝區已被填充（``send``）或清空（``recv``）時"
"，它們會回傳。然後他們會告訴您他們處理了多少位元組。在您的消息得到完全處理之"
"前，*您*有責任再次呼叫他們。"

#: ../../howto/sockets.rst:160
#, fuzzy
msgid ""
"When a ``recv`` returns 0 bytes, it means the other side has closed (or is "
"in the process of closing) the connection.  You will not receive any more "
"data on this connection. Ever.  You may be able to send data successfully; "
"I'll talk more about this later."
msgstr ""
"當 ``recv`` 回傳 0 位元組時，這意味著另一方已經關閉（或正在關閉）連接。您將不"
"會在此連接上收到更多資料。曾經。您可能能夠成功發送資料；我稍後會詳細討論這個"
"。"

#: ../../howto/sockets.rst:165
#, fuzzy
msgid ""
"A protocol like HTTP uses a socket for only one transfer. The client sends a "
"request, then reads a reply.  That's it. The socket is discarded. This means "
"that a client can detect the end of the reply by receiving 0 bytes."
msgstr ""
"像 HTTP 這樣的協定只使用 socket 進行一次傳輸。客戶端發送請求，然後讀取回覆。就"
"是這樣。 socket 被丟棄。這意味著客戶端可以通過接收 0 位元組來檢測回覆的結束。"

#: ../../howto/sockets.rst:169
#, fuzzy
msgid ""
"But if you plan to reuse your socket for further transfers, you need to "
"realize that *there is no* :abbr:`EOT (End of Transfer)` *on a socket.* I "
"repeat: if a socket ``send`` or ``recv`` returns after handling 0 bytes, the "
"connection has been broken.  If the connection has *not* been broken, you "
"may wait on a ``recv`` forever, because the socket will *not* tell you that "
"there's nothing more to read (for now).  Now if you think about that a bit, "
"you'll come to realize a fundamental truth of sockets: *messages must either "
"be fixed length* (yuck), *or be delimited* (shrug), *or indicate how long "
"they are* (much better), *or end by shutting down the connection*. The "
"choice is entirely yours, (but some ways are righter than others)."
msgstr ""
"但是如果你打算重用你的 socket 進行進一步的傳輸，你需要意識到 *沒有* "
":abbr:`EOT（傳輸結束）` *在 socket 上。*我重複：如果一個 socket ``發送``或 "
"``recv`` 在處理 0 個位元組後回傳，連接已斷開。如果連接*沒有*被中斷，您可能會"
"永遠等待``recv``，因為 socket *不會*告訴您沒有更多內容可讀（暫時）。現在，如果"
"你稍微考慮一下，你就會意識到 socket 的一個基本事實：*消息必須是固定長度*（噁心"
"），*或被定界*（聳肩），*或指示它們有多長* （好多了），*或通過關閉連接*結束。"
"選擇完全是你的，（但有些方法比其他方法更正確）。"

#: ../../howto/sockets.rst:180
#, fuzzy
msgid ""
"Assuming you don't want to end the connection, the simplest solution is a "
"fixed length message::"
msgstr "假設您不想結束連接，最簡單的解決方案是固定長度的消息::"

#: ../../howto/sockets.rst:217
#, fuzzy
msgid ""
"The sending code here is usable for almost any messaging scheme - in Python "
"you send strings, and you can use ``len()`` to determine its length (even if "
"it has embedded ``\\0`` characters). It's mostly the receiving code that "
"gets more complex. (And in C, it's not much worse, except you can't use "
"``strlen`` if the message has embedded ``\\0``\\ s.)"
msgstr ""
"此處的發送程式碼幾乎可用於任何消息傳遞方案——在 Python 中，您發送字串，"
"您可以使用 ``len()`` 來確定其長度（即使它嵌入了 ``\\0`` "
"字元）。主要是接收程式碼變得更加複雜。 （在 C 中，情況並沒有更糟，"
"除瞭如果消息嵌入了 ``\\0``\\ 就不能使用 ``strlen``。）"

#: ../../howto/sockets.rst:223
#, fuzzy
msgid ""
"The easiest enhancement is to make the first character of the message an "
"indicator of message type, and have the type determine the length. Now you "
"have two ``recv``\\ s - the first to get (at least) that first character so "
"you can look up the length, and the second in a loop to get the rest. If you "
"decide to go the delimited route, you'll be receiving in some arbitrary "
"chunk size, (4096 or 8192 is frequently a good match for network buffer "
"sizes), and scanning what you've received for a delimiter."
msgstr ""
"最簡單的增強是將消息的第一個字元作為消息型別的指示符，並讓型別決定長度。"
"現在您有兩個 ``recv``\\ s - 第一個獲取（至少）第一個字元，以便您可以查找長度"
"，第二個循環獲取其餘字元。如果您決定採用分隔路線，您將接收到一些任意塊大小（"
"4096 或 8192 "
"通常是網絡緩衝區大小的良好匹配），並掃描您收到的內容以查找分隔符。"

#: ../../howto/sockets.rst:231
#, fuzzy
msgid ""
"One complication to be aware of: if your conversational protocol allows "
"multiple messages to be sent back to back (without some kind of reply), and "
"you pass ``recv`` an arbitrary chunk size, you may end up reading the start "
"of a following message. You'll need to put that aside and hold onto it, "
"until it's needed."
msgstr ""
"需要注意的一個問題是：如果你的會話協定允許背靠背發送多條消息（沒有某種回覆）"
"，並且你傳遞任意塊大小的 ``recv``，你可能最終會讀取一個消息的開頭以下消息。你"
"需要把它放在一邊並堅持下去，直到需要它為止。"

#: ../../howto/sockets.rst:237
#, fuzzy
msgid ""
"Prefixing the message with its length (say, as 5 numeric characters) gets "
"more complex, because (believe it or not), you may not get all 5 characters "
"in one ``recv``. In playing around, you'll get away with it; but in high "
"network loads, your code will very quickly break unless you use two ``recv`` "
"loops - the first to determine the length, the second to get the data part "
"of the message. Nasty. This is also when you'll discover that ``send`` does "
"not always manage to get rid of everything in one pass. And despite having "
"read this, you will eventually get bit by it!"
msgstr ""
"以消息的長度作為前綴（例如，5 "
"個數字字元）會變得更加複雜，因為（信不信由你），您可能無法在一個 ``recv`` "
"中獲得所有 5 個字元。玩玩，你會僥倖逃脫；但是在高網絡負載下，您的程式碼將很快"
"中斷，除非您使用兩個 ``recv``循環——第一個循環確定長度，第二個循環獲取消息的資料"
"部分。可惡的。這也是你會發現 ``send`` "
"並不總能一次處理掉所有東西的時候。儘管讀過這篇文章，你最終還是會被它咬住！"

#: ../../howto/sockets.rst:246
#, fuzzy
msgid ""
"In the interests of space, building your character, (and preserving my "
"competitive position), these enhancements are left as an exercise for the "
"reader. Lets move on to cleaning up."
msgstr "為了空間的利益，建立你的性格，（並保持我的競爭地位），這些增強功能留給讀者作"
"為練習。讓我們繼續清理。"

#: ../../howto/sockets.rst:252
#, fuzzy
msgid "Binary Data"
msgstr "二進位資料"

#: ../../howto/sockets.rst:254
#, fuzzy
msgid ""
"It is perfectly possible to send binary data over a socket. The major "
"problem is that not all machines use the same formats for binary data. For "
"example, `network byte order <https://en.wikipedia.org/wiki/"
"Endianness#Networking>`_ is big-endian, with the most significant byte "
"first, so a 16 bit integer with the value ``1`` would be the two hex bytes "
"``00 01``. However, most common processors (x86/AMD64, ARM, RISC-V), are "
"little-endian, with the least significant byte first - that same ``1`` would "
"be ``01 00``."
msgstr ""
"完全可以通過 socket 發送二進位資料。主要問題是並非所有機器都使用相同格式的二進"
"制資料。例如，`network byte order <https://en.wikipedia.org/wiki/"
"Endianness#Networking>`_ 是 big-endian，最高有效位元組在前，因此值為 ``1` 的 "
"16 位整數` 將是兩個十六進位位元組 ``00 01``。然而，大多數常見的處理器（x86/"
"AMD64、ARM、RISC-V）都是小端法，最低有效位元組在前——同樣的 ``1``將是“01 00”。"

#: ../../howto/sockets.rst:262
#, fuzzy
msgid ""
"Socket libraries have calls for converting 16 and 32 bit integers - ``ntohl, "
"htonl, ntohs, htons`` where \"n\" means *network* and \"h\" means *host*, \"s"
"\" means *short* and \"l\" means *long*. Where network order is host order, "
"these do nothing, but where the machine is byte-reversed, these swap the "
"bytes around appropriately."
msgstr ""
" socket 庫要求轉換 16 位和 32 位整數 - ``ntohl, htonl, ntohs, htons`` "
"其中 ``n``表示*network*， ``h``表示*host*， ``s``表示*short*， ``l`` \" 表示*長*。在網絡"
"順序是主機順序的情況下，它們什麼都不做，但是在機器是位元組反轉的情況下，它們"
"會適當地交換位元組。"

#: ../../howto/sockets.rst:268
#, fuzzy
msgid ""
"In these days of 64-bit machines, the ASCII representation of binary data is "
"frequently smaller than the binary representation. That's because a "
"surprising amount of the time, most integers have the value 0, or maybe 1. "
"The string ``\"0\"`` would be two bytes, while a full 64-bit integer would "
"be 8. Of course, this doesn't fit well with fixed-length messages. "
"Decisions, decisions."
msgstr ""
"在如今的 64 位機器中，二進位資料的 ASCII "
"表示形式通常比二進位表示形式小。這是因為令人驚訝的是，大多數整數的值通常為 "
"0，或者可能為 1。字串 ``0``將是兩個位元組，而完整的 64 位整數將是 8。當然，"
"這不是' 非常適合固定長度的消息。決定，決定。"

#: ../../howto/sockets.rst:277
#, fuzzy
msgid "Disconnecting"
msgstr "斷開連接"

#: ../../howto/sockets.rst:279
#, fuzzy
msgid ""
"Strictly speaking, you're supposed to use ``shutdown`` on a socket before "
"you ``close`` it.  The ``shutdown`` is an advisory to the socket at the "
"other end. Depending on the argument you pass it, it can mean \"I'm not "
"going to send anymore, but I'll still listen\", or \"I'm not listening, good "
"riddance!\".  Most socket libraries, however, are so used to programmers "
"neglecting to use this piece of etiquette that normally a ``close`` is the "
"same as ``shutdown(); close()``.  So in most situations, an explicit "
"``shutdown`` is not needed."
msgstr ""
"嚴格來說，您應該在 ``close`` 之前在 socket 上使用 ``shutdown``。 ``shutdown`` "
"是對另一端 socket 的建議。根據你傳遞的參數，它可能意味著“我不會再發送了，但我仍"
"然會聽”，或者“我沒有在聽，好吧！”。然而，大多數 socket 庫已經習慣了程式員而忽略"
"了使用通常 ``close``與“shutdown();”相同的禮儀。關閉（）``。所以在大多數情況下，"
"不需要顯式的“關閉”。"

#: ../../howto/sockets.rst:287
#, fuzzy
msgid ""
"One way to use ``shutdown`` effectively is in an HTTP-like exchange. The "
"client sends a request and then does a ``shutdown(1)``. This tells the "
"server \"This client is done sending, but can still receive.\"  The server "
"can detect \"EOF\" by a receive of 0 bytes. It can assume it has the "
"complete request.  The server sends a reply. If the ``send`` completes "
"successfully then, indeed, the client was still receiving."
msgstr ""
"一種有效使用 ``shutdown`` 的方法是在類似 HTTP 的交換中。客戶端發送請求，"
"然後執行 ``shutdown(1)``。這告訴伺服器“此客戶端已完成發送，但仍可以接收。”"
"伺服器可以通過接收 0 位元組來檢測 ``EOF``。它可以假設它有完整的請求。伺服器發送"
"回覆。如果“發送”成功完成，那麼實際上，客戶端仍在接收。"

#: ../../howto/sockets.rst:294
#, fuzzy
msgid ""
"Python takes the automatic shutdown a step further, and says that when a "
"socket is garbage collected, it will automatically do a ``close`` if it's "
"needed. But relying on this is a very bad habit. If your socket just "
"disappears without doing a ``close``, the socket at the other end may hang "
"indefinitely, thinking you're just being slow. *Please* ``close`` your "
"sockets when you're done."
msgstr ""
"Python 將自動關閉更進一步，並表示當垃圾回收 socket 時，如果需要，它會自動執行“"
"關閉”。但是依賴這個是一個很不好的習慣。如果你的 socket 沒有做 ``close`` "
"就消失了，另一端的 socket 可能會無限期地掛起，認為你只是太慢了。 "
"*請*完成後``關閉``您的 socket 。"

#: ../../howto/sockets.rst:302
#, fuzzy
msgid "When Sockets Die"
msgstr "當 socket 死亡時"

#: ../../howto/sockets.rst:304
#, fuzzy
msgid ""
"Probably the worst thing about using blocking sockets is what happens when "
"the other side comes down hard (without doing a ``close``). Your socket is "
"likely to hang. TCP is a reliable protocol, and it will wait a long, long "
"time before giving up on a connection. If you're using threads, the entire "
"thread is essentially dead. There's not much you can do about it. As long as "
"you aren't doing something dumb, like holding a lock while doing a blocking "
"read, the thread isn't really consuming much in the way of resources. Do "
"*not* try to kill the thread - part of the reason that threads are more "
"efficient than processes is that they avoid the overhead associated with the "
"automatic recycling of resources. In other words, if you do manage to kill "
"the thread, your whole process is likely to be screwed up."
msgstr ""
"使用阻塞 socket 最糟糕的事情可能是當另一端硬下來（沒有做 "
"``close``）時發生的事情。您的 socket 可能會掛起。 TCP 是一種可靠的協定，它會等"
"待很長時間才能放棄連接。如果您正在使用執行緒，則整個執行緒基本上已經死了。你"
"對此無能為力。只要您沒有做一些愚蠢的事情，比如在進行阻塞讀取時持有鎖，執行緒"
"就不會真正消耗太多資源。不要*不要*試圖殺死執行緒——執行緒比行程更高效的部分原"
"因是它們避免了與資源自動回收相關的開銷。換句話說，如果您設法終止執行緒，您的"
"整個過程很可能會搞砸。"

#: ../../howto/sockets.rst:318
#, fuzzy
msgid "Non-blocking Sockets"
msgstr "非阻塞 socket "

#: ../../howto/sockets.rst:320
#, fuzzy
msgid ""
"If you've understood the preceding, you already know most of what you need "
"to know about the mechanics of using sockets. You'll still use the same "
"calls, in much the same ways. It's just that, if you do it right, your app "
"will be almost inside-out."
msgstr ""
"如果您理解了前面的內容，那麼您已經了解了大部分您需要了解的關於使用 socket 的機"
"制。您仍將以幾乎相同的方式使用相同的呼叫。只是，如果你做對了，你的應用程式幾"
"乎會由內而外。"

#: ../../howto/sockets.rst:325
#, fuzzy
msgid ""
"In Python, you use ``socket.setblocking(False)`` to make it non-blocking. In "
"C, it's more complex, (for one thing, you'll need to choose between the BSD "
"flavor ``O_NONBLOCK`` and the almost indistinguishable POSIX flavor "
"``O_NDELAY``, which is completely different from ``TCP_NODELAY``), but it's "
"the exact same idea. You do this after creating the socket, but before using "
"it. (Actually, if you're nuts, you can switch back and forth.)"
msgstr ""
"在 Python 中，您使用 ``socket.setblocking(False)`` 使其成為非阻塞的。在 C "
"中，它更複雜，（一方面，您需要在 BSD 風格的“O_NONBLOCK”和幾乎無法區分的 "
"POSIX 風格的“O_NDELAY”之間做出選擇，後者與“TCP_NODELAY”完全不同） "
"，但這是完全相同的想法。您在建立 socket 之後但在使用它之前執行此操作。 "
"（實際上，如果你瘋了，你可以來回切換。）"

#: ../../howto/sockets.rst:332
#, fuzzy
msgid ""
"The major mechanical difference is that ``send``, ``recv``, ``connect`` and "
"``accept`` can return without having done anything. You have (of course) a "
"number of choices. You can check return code and error codes and generally "
"drive yourself crazy. If you don't believe me, try it sometime. Your app "
"will grow large, buggy and suck CPU. So let's skip the brain-dead solutions "
"and do it right."
msgstr ""
"主要的機械差異是“發送”、“接收”、“連接”和“接受”可以在不做任何事情的情況下回傳"
"。您（當然）有多種選擇。您可以檢查回傳程式碼和錯誤程式碼，通常會讓自己發瘋。"
"如果你不相信我，找個時間試試看。你的應用會變得越來越大，出現錯誤並且 CPU "
"很爛。因此，讓我們跳過腦死亡解決方案並正確執行。"

#: ../../howto/sockets.rst:339
msgid "Use ``select``."
msgstr "使用 ``select``。"

#: ../../howto/sockets.rst:341
#, fuzzy
msgid ""
"In C, coding ``select`` is fairly complex. In Python, it's a piece of cake, "
"but it's close enough to the C version that if you understand ``select`` in "
"Python, you'll have little trouble with it in C::"
msgstr ""
"在 C 語言中，編寫 ``select`` 相當複雜。在 Python 中，這是小菜一碟，但它與 C "
"版本非常接近，如果你理解 Python 中的 ``select``，那麼在 C:: "
"中使用它就不會有什麼問題："

#: ../../howto/sockets.rst:352
#, fuzzy
msgid ""
"You pass ``select`` three lists: the first contains all sockets that you "
"might want to try reading; the second all the sockets you might want to try "
"writing to, and the last (normally left empty) those that you want to check "
"for errors. You should note that a socket can go into more than one list. "
"The ``select`` call is blocking, but you can give it a timeout. This is "
"generally a sensible thing to do - give it a nice long timeout (say a "
"minute) unless you have good reason to do otherwise."
msgstr ""
"您傳遞 ``select`` 三個列表：第一個包含您可能想要嘗試閱讀的所有 socket ；第二個"
"是您可能想嘗試寫入的所有 socket ，最後一個（通常留空）是您要檢查錯誤的 socket 。"
"您應該注意，一個 socket 可以進入多個列表。 ``select`` 呼叫是阻塞的，但你可以給"
"它一個超時。這通常是一件明智的事情——給它一個很好的超時時間（比如一分鐘），除"
"非你有充分的理由不這樣做。"

#: ../../howto/sockets.rst:360
#, fuzzy
msgid ""
"In return, you will get three lists. They contain the sockets that are "
"actually readable, writable and in error. Each of these lists is a subset "
"(possibly empty) of the corresponding list you passed in."
msgstr "作為回報，您將獲得三個列表。它們包含實際可讀、可寫和錯誤的 socket 。這些列表中"
"的每一個都是您傳入的相應列表的子集（可能為空）。"

#: ../../howto/sockets.rst:364
#, fuzzy
msgid ""
"If a socket is in the output readable list, you can be as-close-to-certain-"
"as-we-ever-get-in-this-business that a ``recv`` on that socket will return "
"*something*. Same idea for the writable list. You'll be able to send "
"*something*. Maybe not all you want to, but *something* is better than "
"nothing.  (Actually, any reasonably healthy socket will return as writable - "
"it just means outbound network buffer space is available.)"
msgstr ""
"如果一個 socket 在輸出可讀列表中，那麼您可以非常確定地知道該 socket 上的 ``recv``"
"將回傳 *something*。可寫列表的想法相同。您將能夠發送*東西*。也許不是所有你想"
"要的，但*有總比沒有好。 （實際上，任何相當健康的 socket 都將回傳為可寫 - "
"這僅意味著出站網絡緩衝區空間可用。）"

#: ../../howto/sockets.rst:371
#, fuzzy
msgid ""
"If you have a \"server\" socket, put it in the potential_readers list. If it "
"comes out in the readable list, your ``accept`` will (almost certainly) "
"work. If you have created a new socket to ``connect`` to someone else, put "
"it in the potential_writers list. If it shows up in the writable list, you "
"have a decent chance that it has connected."
msgstr ""
"如果你有一個“伺服器” socket ，把它放在 potential_readers 列表中。如果它出現在可"
"讀列表中，您的“接受”將（幾乎可以肯定）起作用。如果你已經建立了一個新的 socket "
"來“連接”到其他人，把它放在 potential_writers "
"列表中。如果它出現在可寫列表中，則很有可能它已連接。"

#: ../../howto/sockets.rst:377
#, fuzzy
msgid ""
"Actually, ``select`` can be handy even with blocking sockets. It's one way "
"of determining whether you will block - the socket returns as readable when "
"there's something in the buffers.  However, this still doesn't help with the "
"problem of determining whether the other end is done, or just busy with "
"something else."
msgstr ""
"實際上，``select`` 即使在阻塞 socket 的情況下也很方便。"
"這是確定您是否會阻塞的一種方法 - 當緩衝區中有內容時， socket 回傳為可讀。然而，"
"這仍然無助於確定另一端是否已完成，或者只是忙於其他事情的問題。"

#: ../../howto/sockets.rst:382
#, fuzzy
msgid ""
"**Portability alert**: On Unix, ``select`` works both with the sockets and "
"files. Don't try this on Windows. On Windows, ``select`` works with sockets "
"only. Also note that in C, many of the more advanced socket options are done "
"differently on Windows. In fact, on Windows I usually use threads (which "
"work very, very well) with my sockets."
msgstr ""
"**可移植性警報**：在 Unix 上，``select`` 適用於 socket 和文件。不要在 Windows "
"上嘗試這個。在 Windows 上，``select`` 僅適用於 socket 。另請注意，在 C 中，"
"許多更高階的 socket 選項在 Windows 上的執行方式不同。事實上，在 Windows "
"上，我通常將執行緒（工作得非常非常好）與我的 socket 一起使用。"
