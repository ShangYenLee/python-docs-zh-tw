# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# jerrychen <jerrychen.ee@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-03 00:13+0000\n"
"PO-Revision-Date: 2018-05-23 14:37+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/pyporting.rst:5
msgid "Porting Python 2 Code to Python 3"
msgstr "Python 2 的程式碼移植到Python 3"

#: ../../howto/pyporting.rst:0
msgid "author"
msgstr "作者"

#: ../../howto/pyporting.rst:7
msgid "Brett Cannon"
msgstr "Brett Cannon"

#: ../../howto/pyporting.rst:-1
msgid "Abstract"
msgstr "摘要"

#: ../../howto/pyporting.rst:11
#, fuzzy
msgid ""
"With Python 3 being the future of Python while Python 2 is still in active "
"use, it is good to have your project available for both major releases of "
"Python. This guide is meant to help you figure out how best to support both "
"Python 2 & 3 simultaneously."
msgstr ""
"由於 Python 3 是 Python 的未來，而 Python 2 仍在積極使用，"
"因此最好讓您的項目可用於 Python 的兩個主要版本。"
"本指南旨在幫助您了解如何最好地同時支援 Python 2 和 3。"

#: ../../howto/pyporting.rst:16
#, fuzzy
msgid ""
"If you are looking to port an extension module instead of pure Python code, "
"please see :ref:`cporting-howto`."
msgstr "如果您希望移植擴充模組而不是純 Python 程式碼，請參閱 :ref:`cporting-howto`。"

#: ../../howto/pyporting.rst:19
#, fuzzy
msgid ""
"If you would like to read one core Python developer's take on why Python 3 "
"came into existence, you can read Nick Coghlan's `Python 3 Q & A`_ or Brett "
"Cannon's `Why Python 3 exists`_."
msgstr ""
"如果您想閱讀一位核心 Python 開發人員對 Python 3 為何誕生的看法，您可以閱讀 "
"Nick Coghlan 的“Python 3 問答”或 Brett Cannon 的“為什麼存在 Python 3”。"

#: ../../howto/pyporting.rst:24
#, fuzzy
msgid ""
"For help with porting, you can view the archived python-porting_ mailing "
"list."
msgstr "如需移植方面的幫助，您可以查看存檔的 python-porting_ 郵件列表。"

#: ../../howto/pyporting.rst:27
msgid "The Short Explanation"
msgstr "簡短的說明"

#: ../../howto/pyporting.rst:29
#, fuzzy
msgid ""
"To make your project be single-source Python 2/3 compatible, the basic steps "
"are:"
msgstr "要使您的項目與單源 Python 2/3 相容，基本步驟是："

#: ../../howto/pyporting.rst:32
#, fuzzy
msgid "Only worry about supporting Python 2.7"
msgstr "只擔心支援 Python 2.7"

#: ../../howto/pyporting.rst:33
#, fuzzy
msgid ""
"Make sure you have good test coverage (coverage.py_ can help; ``python -m "
"pip install coverage``)"
msgstr "確保你有良好的測試覆蓋率（coverage.py_ 可以提供幫助；``python -m pip install "
"coverage``）"

#: ../../howto/pyporting.rst:35 ../../howto/pyporting.rst:122
msgid "Learn the differences between Python 2 & 3"
msgstr "瞭解Python 2 & 3的差異"

#: ../../howto/pyporting.rst:36
#, fuzzy
msgid ""
"Use Futurize_ (or Modernize_) to update your code (e.g. ``python -m pip "
"install future``)"
msgstr "使用 Futurize_（或 Modernize_）更新您的程式碼（例如 ``python -m pip install "
"future``）"

#: ../../howto/pyporting.rst:37
#, fuzzy
msgid ""
"Use Pylint_ to help make sure you don't regress on your Python 3 support "
"(``python -m pip install pylint``)"
msgstr "使用 Pylint_ 幫助確保您不會在 Python 3 支援上倒退（``python -m pip install "
"pylint``）"

#: ../../howto/pyporting.rst:39
#, fuzzy
msgid ""
"Use caniusepython3_ to find out which of your dependencies are blocking your "
"use of Python 3 (``python -m pip install caniusepython3``)"
msgstr ""
"使用 caniusepython3_ 找出哪些依賴項阻止您使用 Python 3（``python -m pip "
"install caniusepython3``）"

#: ../../howto/pyporting.rst:41
#, fuzzy
msgid ""
"Once your dependencies are no longer blocking you, use continuous "
"integration to make sure you stay compatible with Python 2 & 3 (tox_ can "
"help test against multiple versions of Python; ``python -m pip install tox``)"
msgstr ""
"一旦你的依賴不再阻礙你，使用持續集成來確保你與 Python 2 和 3 保持相容（tox_ "
"可以幫助測試多個版本的 Python；``python -m pip install tox``）"

#: ../../howto/pyporting.rst:44
#, fuzzy
msgid ""
"Consider using optional static type checking to make sure your type usage "
"works in both Python 2 & 3 (e.g. use mypy_ to check your typing under both "
"Python 2 & Python 3; ``python -m pip install mypy``)."
msgstr ""
"考慮使用可選的靜態型別檢查來確保您的型別使用在 Python 2 和 3 中都有效（例如，"
"使用 mypy_ 檢查您在 Python 2 和 Python 3 下的型別；``python -m pip install "
"mypy``）。"

#: ../../howto/pyporting.rst:50
#, fuzzy
msgid ""
"Note: Using ``python -m pip install`` guarantees that the ``pip`` you invoke "
"is the one installed for the Python currently in use, whether it be a system-"
"wide ``pip`` or one installed within a :ref:`virtual environment <tut-venv>`."
msgstr ""
"注意：使用 ``python -m pip install`` 保證您呼叫的 ``pip`` 是為當前使用的 "
"Python 安裝的，無論它是系統範圍的 ``pip`` 還是安裝在 :ref:`虛擬環境 <tut-"
"venv>`。"

#: ../../howto/pyporting.rst:56
msgid "Details"
msgstr "詳細的"

#: ../../howto/pyporting.rst:58
#, fuzzy
msgid ""
"A key point about supporting Python 2 & 3 simultaneously is that you can "
"start **today**! Even if your dependencies are not supporting Python 3 yet "
"that does not mean you can't modernize your code **now** to support Python "
"3. Most changes required to support Python 3 lead to cleaner code using "
"newer practices even in Python 2 code."
msgstr ""
"同時支援 Python 2 和 3 的一個關鍵點是您可以**今天**開始！"
"即使您的依賴項不支援 Python 3，但這並不意味著您不能**現在** "
"現代化您的程式碼以支援 Python 3。支援 Python 3 "
"所需的大多數更改導致使用更新的實踐的更清晰的程式碼，即使在 Python 2 "
"程式碼中也是如此."

#: ../../howto/pyporting.rst:64
#, fuzzy
msgid ""
"Another key point is that modernizing your Python 2 code to also support "
"Python 3 is largely automated for you. While you might have to make some API "
"decisions thanks to Python 3 clarifying text data versus binary data, the "
"lower-level work is now mostly done for you and thus can at least benefit "
"from the automated changes immediately."
msgstr ""
"另一個關鍵點是，現代化您的 Python 2 程式碼以支援 Python 3 "
"對您來說很大程度上是自動化的。由於 Python 3 澄清了文本資料與二進位資料，"
"雖然您可能不得不做出一些 API 決策，但較低階別的工作現在大部分已為您完成，因此"
"至少可以立即從自動更改中受益。"

#: ../../howto/pyporting.rst:70
#, fuzzy
msgid ""
"Keep those key points in mind while you read on about the details of porting "
"your code to support Python 2 & 3 simultaneously."
msgstr "在閱讀有關移植程式碼以同時支援 Python 2 和 3 的詳細資訊時，請牢記這些關鍵點。"

#: ../../howto/pyporting.rst:75
msgid "Drop support for Python 2.6 and older"
msgstr "向下支援Python 2.6和更舊的版本"

#: ../../howto/pyporting.rst:77
#, fuzzy
msgid ""
"While you can make Python 2.5 work with Python 3, it is **much** easier if "
"you only have to work with Python 2.7. If dropping Python 2.5 is not an "
"option then the six_ project can help you support Python 2.5 & 3 "
"simultaneously (``python -m pip install six``). Do realize, though, that "
"nearly all the projects listed in this HOWTO will not be available to you."
msgstr ""
"雖然您可以使 Python 2.5 與 Python 3 一起工作，但如果您只需要與 Python 2.7 "
"一起工作，它會**容易得多**。如果放棄 Python 2.5 不是一個選項，那麼 six_ "
"項目可以幫助您同時支援 Python 2.5 和 3（``python -m pip install "
"six``）。但是請注意，本 HOWTO 中列出的幾乎所有項目都對您不可用。"

#: ../../howto/pyporting.rst:83
#, fuzzy
msgid ""
"If you are able to skip Python 2.5 and older, then the required changes to "
"your code should continue to look and feel like idiomatic Python code. At "
"worst you will have to use a function instead of a method in some instances "
"or have to import a function instead of using a built-in one, but otherwise "
"the overall transformation should not feel foreign to you."
msgstr ""
"如果您能夠跳過 Python 2.5 及更早版本，"
"那麼對程式碼所做的必要更改應該繼續看起來和感覺起來像慣用的 Python 程式碼。在"
"最壞的情況下，您將不得不在某些情況下使用函式而不是方法，或者必須導入函式而不"
"是使用內建函式，否則整體轉換對您來說應該不會感到陌生。"

#: ../../howto/pyporting.rst:89
#, fuzzy
msgid ""
"But you should aim for only supporting Python 2.7. Python 2.6 is no longer "
"freely supported and thus is not receiving bugfixes. This means **you** will "
"have to work around any issues you come across with Python 2.6. There are "
"also some tools mentioned in this HOWTO which do not support Python 2.6 (e."
"g., Pylint_), and this will become more commonplace as time goes on. It will "
"simply be easier for you if you only support the versions of Python that you "
"have to support."
msgstr ""
"但是你的目標應該是只支援 Python 2.7。 Python 2.6 "
"不再免費支援，因此沒有收到錯誤修復。這意味著**您**將不得不解決您在使用 "
"Python 2.6 時遇到的任何問題。本 HOWTO 中還提到了一些不支援 Python 2.6 "
"的工具（例如 Pylint_），隨著時間的推移，這將變得更加普遍。"
"如果您只支援您必須支援的 Python 版本，這對您來說會更容易。"

#: ../../howto/pyporting.rst:98
#, fuzzy
msgid ""
"Make sure you specify the proper version support in your ``setup.py`` file"
msgstr "確保在 ``setup.py`` 文件中指定正確的版本支援"

#: ../../howto/pyporting.rst:100
#, fuzzy
msgid ""
"In your ``setup.py`` file you should have the proper `trove classifier`_ "
"specifying what versions of Python you support. As your project does not "
"support Python 3 yet you should at least have ``Programming Language :: "
"Python :: 2 :: Only`` specified. Ideally you should also specify each major/"
"minor version of Python that you do support, e.g. ``Programming Language :: "
"Python :: 2.7``."
msgstr ""
"在你的 ``setup.py`` 文件中，你應該有適當的 `trove 分類器`_ 指定你支援的 "
"Python 版本。由於您的項目不支援 Python 3，因此您至少應該指定“Programming "
"Language :: Python :: 2 :: Only”。理想情況下，您還應該指定您支援的 Python "
"的每個主要/次要版本，例如 ``Programming Language :: Python :: 2.7``。"

#: ../../howto/pyporting.rst:109
msgid "Have good test coverage"
msgstr "有好的測試覆蓋率"

#: ../../howto/pyporting.rst:111
#, fuzzy
msgid ""
"Once you have your code supporting the oldest version of Python 2 you want "
"it to, you will want to make sure your test suite has good coverage. A good "
"rule of thumb is that if you want to be confident enough in your test suite "
"that any failures that appear after having tools rewrite your code are "
"actual bugs in the tools and not in your code. If you want a number to aim "
"for, try to get over 80% coverage (and don't feel bad if you find it hard to "
"get better than 90% coverage). If you don't already have a tool to measure "
"test coverage then coverage.py_ is recommended."
msgstr ""
"一旦您的程式碼支援您想要的最舊版本的 Python 2，您將需要確保您的測試套件具有良"
"好的覆蓋率。一個好的經驗法則是，如果你想對你的測試套件有足夠的信心，那麼在用"
"工具重寫你的程式碼後出現的任何失敗都是工具中的實際錯誤，而不是你的程式碼中的"
"錯誤。如果您想要一個數字作為目標，請嘗試獲得超過 80% 的覆蓋率（"
"如果您發現很難超過 90% "
"的覆蓋率，也不要感到難過）。如果您還沒有測量測試覆蓋率的工具，那麼建議使用 "
"coverage.py_。"

#: ../../howto/pyporting.rst:124
#, fuzzy
msgid ""
"Once you have your code well-tested you are ready to begin porting your code "
"to Python 3! But to fully understand how your code is going to change and "
"what you want to look out for while you code, you will want to learn what "
"changes Python 3 makes in terms of Python 2. Typically the two best ways of "
"doing that is reading the :ref:`\"What's New\" <whatsnew-index>` doc for "
"each release of Python 3 and the `Porting to Python 3`_ book (which is free "
"online). There is also a handy `cheat sheet`_ from the Python-Future project."
msgstr ""
"一旦您的程式碼經過良好測試，您就可以開始將程式碼移植到 Python 3 "
"了！但是要完全了解您的程式碼將如何更改以及您在編寫程式碼時要注意什麼，"
"您將需要了解 Python 3 相對於 Python 2 "
"所做的更改。通常最好的兩種方法是閱讀 :ref:`\"What\\'s New\" <whatsnew-index>` "
"Python 3 的每個版本和 `Porting to Python 3`_ 書（在線免費）的文檔。"
"還有一個來自 Python-Future 項目的方便的“備忘單”。"

#: ../../howto/pyporting.rst:134
msgid "Update your code"
msgstr "更新你的程式碼"

#: ../../howto/pyporting.rst:136
#, fuzzy
msgid ""
"Once you feel like you know what is different in Python 3 compared to Python "
"2, it's time to update your code! You have a choice between two tools in "
"porting your code automatically: Futurize_ and Modernize_. Which tool you "
"choose will depend on how much like Python 3 you want your code to be. "
"Futurize_ does its best to make Python 3 idioms and practices exist in "
"Python 2, e.g. backporting the ``bytes`` type from Python 3 so that you have "
"semantic parity between the major versions of Python. Modernize_, on the "
"other hand, is more conservative and targets a Python 2/3 subset of Python, "
"directly relying on six_ to help provide compatibility. As Python 3 is the "
"future, it might be best to consider Futurize to begin adjusting to any new "
"practices that Python 3 introduces which you are not accustomed to yet."
msgstr ""
"一旦您覺得自己知道 Python 3 與 Python 2 相比有何不同，就該更新您的程式碼了！"
"您可以在兩種自動移植程式碼的工具之間進行選擇：Futurize_ 和 Modernize_。"
"您選擇哪種工具將取決於您希望您的程式碼與 Python 3 的相似程度。 Futurize_ "
"盡最大努力使 Python 2 中存在 Python 3 習語和實踐，例如從 Python 3 "
"向後移植“位元組”型別，以便您在 Python "
"的主要版本之間具有語義奇偶校驗。另一方面，Modernize_ 更為保守，它針對 Python "
"的 Python 2/3 子集，直接依賴 six_ 來幫助提供相容性。由於 Python 3 是未來，"
"最好考慮 Futurize 開始適應 Python 3 引入的任何您還不習慣的新實踐。"

#: ../../howto/pyporting.rst:148
#, fuzzy
msgid ""
"Regardless of which tool you choose, they will update your code to run under "
"Python 3 while staying compatible with the version of Python 2 you started "
"with. Depending on how conservative you want to be, you may want to run the "
"tool over your test suite first and visually inspect the diff to make sure "
"the transformation is accurate. After you have transformed your test suite "
"and verified that all the tests still pass as expected, then you can "
"transform your application code knowing that any tests which fail is a "
"translation failure."
msgstr ""
"無論您選擇哪種工具，它們都會更新您的程式碼以在 Python 3 下運行，"
"同時與您開始使用的 Python 2 版本保持相容。根據您想要的保守程度，您可能希望首"
"先在您的測試套件上運行該工具並目視檢查差異以確保轉換準確。在轉換測試套件並驗"
"證所有測試仍按預期通過後，您可以轉換應用程式程式碼，知道任何失敗的測試都是轉"
"換失敗。"

#: ../../howto/pyporting.rst:156
#, fuzzy
msgid ""
"Unfortunately the tools can't automate everything to make your code work "
"under Python 3 and so there are a handful of things you will need to update "
"manually to get full Python 3 support (which of these steps are necessary "
"vary between the tools). Read the documentation for the tool you choose to "
"use to see what it fixes by default and what it can do optionally to know "
"what will (not) be fixed for you and what you may have to fix on your own (e."
"g. using ``io.open()`` over the built-in ``open()`` function is off by "
"default in Modernize). Luckily, though, there are only a couple of things to "
"watch out for which can be considered large issues that may be hard to debug "
"if not watched for."
msgstr ""
"不幸的是，這些工具無法自動執行所有操作以使您的程式碼在 Python 3 下工作，"
"因此您需要手動更新一些內容以獲得完整的 Python 3 支援（這些步驟中哪些是必要的"
"因工具而異）。閱讀您選擇使用的工具的文檔，以查看它預設修復的內容以及它可以選"
"擇執行的操作，以了解將（不）為您修復的內容以及您可能必須自行修復的內容（例如"
"使用``io .open()`` 內建的 ``open()`` 函式在 Modernize 中預設關閉）。不過，幸"
"運的是，只有幾件事需要注意，如果不注意，這些問題可能被認為是大問題，可能很難"
"除錯。"

#: ../../howto/pyporting.rst:168
#, fuzzy
msgid "Division"
msgstr "分配"

#: ../../howto/pyporting.rst:170
#, fuzzy
msgid ""
"In Python 3, ``5 / 2 == 2.5`` and not ``2``; all division between ``int`` "
"values result in a ``float``. This change has actually been planned since "
"Python 2.2 which was released in 2002. Since then users have been encouraged "
"to add ``from __future__ import division`` to any and all files which use "
"the ``/`` and ``//`` operators or to be running the interpreter with the ``-"
"Q`` flag. If you have not been doing this then you will need to go through "
"your code and do two things:"
msgstr ""
"在 Python 3 中，``5 / 2 == 2.5`` 而不是 ``2``； ``int`` "
"值之間的所有除法都會導致 ``float``。實際上，自 2002 年發布的 Python 2.2 "
"以來就計劃進行此更改。從那時起，就鼓勵使用者將“from __future__ import "
"division”新增到使用 ``/``和“//”的任何和所有文件中` 運算符或使用 ``-Q`` "
"旗標運行直譯器。如果您還沒有這樣做，那麼您將需要檢查您的程式碼並做兩件事："

#: ../../howto/pyporting.rst:178
#, fuzzy
msgid "Add ``from __future__ import division`` to your files"
msgstr "新增``from __future__ import division``到你的文件"

#: ../../howto/pyporting.rst:179
#, fuzzy
msgid ""
"Update any division operator as necessary to either use ``//`` to use floor "
"division or continue using ``/`` and expect a float"
msgstr "根據需要更新任何除法運算符，以使用``//``來使用地板除法或繼續使用``/``並期待一"
"個浮點數"

#: ../../howto/pyporting.rst:182
#, fuzzy
msgid ""
"The reason that ``/`` isn't simply translated to ``//`` automatically is "
"that if an object defines a ``__truediv__`` method but not ``__floordiv__`` "
"then your code would begin to fail (e.g. a user-defined class that uses ``/"
"`` to signify some operation but not ``//`` for the same thing or at all)."
msgstr ""
"``/`` 沒有簡單地自動轉換為 ``//`` 的原因是，如果物件定義了 ``__truediv__`` "
"方法而不是 ``__floordiv__`` "
"那麼您的程式碼將開始失敗（例如一個使用者定義的類，它使用 ``/`` "
"來表示一些操作而不是 ``//`` 來表示相同的東西或根本沒有）。"

#: ../../howto/pyporting.rst:189
msgid "Text versus binary data"
msgstr "文本與二進位資料"

#: ../../howto/pyporting.rst:191
#, fuzzy
msgid ""
"In Python 2 you could use the ``str`` type for both text and binary data. "
"Unfortunately this confluence of two different concepts could lead to "
"brittle code which sometimes worked for either kind of data, sometimes not. "
"It also could lead to confusing APIs if people didn't explicitly state that "
"something that accepted ``str`` accepted either text or binary data instead "
"of one specific type. This complicated the situation especially for anyone "
"supporting multiple languages as APIs wouldn't bother explicitly supporting "
"``unicode`` when they claimed text data support."
msgstr ""
"在 Python 2 中，您可以對文本和二進位資料使用 ``str`` 型別。不幸的是，這兩種不"
"同概念的融合可能會導致脆弱的程式碼，有時對任何一種資料都有效，有時卻無效。"
"如果人們沒有明確聲明接受 ``str`` "
"的東西接受文本或二進位資料而不是一種特定型別，它也可能導致混淆 "
"API。這使情況變得複雜，尤其是對於任何支援多種語言的人來說，因為當 API "
"聲稱支援文本資料時，他們不會費心去明確支援 ``unicode`` 。"

#: ../../howto/pyporting.rst:200
#, fuzzy
msgid ""
"To make the distinction between text and binary data clearer and more "
"pronounced, Python 3 did what most languages created in the age of the "
"internet have done and made text and binary data distinct types that cannot "
"blindly be mixed together (Python predates widespread access to the "
"internet). For any code that deals only with text or only binary data, this "
"separation doesn't pose an issue. But for code that has to deal with both, "
"it does mean you might have to now care about when you are using text "
"compared to binary data, which is why this cannot be entirely automated."
msgstr ""
"為了使文本和二進位資料之間的區別更加清晰和明顯，Python 3 做了網際網路時代建立的"
"大多數語言所做的事情，將文本和二進位資料區分為不同型別，不能盲目地混合在一起"
"（Python 早於廣泛訪問網際網路）。對於任何只處理文本或二進位資料的程式碼，這種分"
"離不會造成問題。但是對於必須處理這兩者的程式碼，這確實意味著您現在可能必須關"
"心何時使用文本而不是二進位資料，這就是為什麼這不能完全自動化的原因。"

#: ../../howto/pyporting.rst:209
#, fuzzy
msgid ""
"To start, you will need to decide which APIs take text and which take binary "
"(it is **highly** recommended you don't design APIs that can take both due "
"to the difficulty of keeping the code working; as stated earlier it is "
"difficult to do well). In Python 2 this means making sure the APIs that take "
"text can work with ``unicode`` and those that work with binary data work "
"with the ``bytes`` type from Python 3 (which is a subset of ``str`` in "
"Python 2 and acts as an alias for ``bytes`` type in Python 2). Usually the "
"biggest issue is realizing which methods exist on which types in Python 2 & "
"3 simultaneously (for text that's ``unicode`` in Python 2 and ``str`` in "
"Python 3, for binary that's ``str``/``bytes`` in Python 2 and ``bytes`` in "
"Python 3). The following table lists the **unique** methods of each data "
"type across Python 2 & 3 (e.g., the ``decode()`` method is usable on the "
"equivalent binary data type in either Python 2 or 3, but it can't be used by "
"the textual data type consistently between Python 2 and 3 because ``str`` in "
"Python 3 doesn't have the method). Do note that as of Python 3.5 the "
"``__mod__`` method was added to the bytes type."
msgstr ""
"首先，您需要決定哪些 API 採用文本，哪些採用二進位（**強烈**"
"建議您不要設計可以同時採用這兩種方式的 "
"API，因為很難保持程式碼正常工作；如前所述，它是很難做好）。在 Python 2 中，"
"這意味著確保接受文本的 API 可以與 ``unicode`` 一起工作，"
"而那些與二進位資料一起工作的 API 可以與來自 Python 3 的 ``bytes`` 型別（它是 "
"``str`` 的子集）一起工作在 Python 2 中並作為 Python 2 中 ``bytes``型別的別名）。"
"通常最大的問題是同時意識到 Python 2 和 3 中哪些型別存在哪些方法（對於 Python "
"2 中的 ``unicode`` 和 Python 3 中的 ``str`` 文本，對於二進位是 ``str``/` "
"Python 2 中的 ``bytes``和 Python 3 中的 ``bytes``）。下表列出了 Python 2 和 3 "
"中每種資料型別的**獨特**方法（例如，``decode()`` 方法可用於 Python 2 或 3 "
"中的等效二進位資料型別，但它可以't 被 Python 2 和 3 "
"之間一致的文本資料型別使用，因為 Python 3 中的 ``str`` 沒有該方法）。請注意，"
"從 Python 3.5 開始，``__mod__`` 方法已新增到 bytes 型別。"

#: ../../howto/pyporting.rst:226
#, fuzzy
msgid "**Text data**"
msgstr "**文本資料**"

#: ../../howto/pyporting.rst:226
#, fuzzy
msgid "**Binary data**"
msgstr "**二進位資料**"

#: ../../howto/pyporting.rst:228
msgid "\\"
msgstr "\\"

#: ../../howto/pyporting.rst:228
#, fuzzy
msgid "decode"
msgstr "解碼"

#: ../../howto/pyporting.rst:230
#, fuzzy
msgid "encode"
msgstr "編碼"

#: ../../howto/pyporting.rst:232
#, fuzzy
msgid "format"
msgstr "格式"

#: ../../howto/pyporting.rst:234
msgid "isdecimal"
msgstr "isdecimal"

#: ../../howto/pyporting.rst:236
msgid "isnumeric"
msgstr "isnumeric"

#: ../../howto/pyporting.rst:239
#, fuzzy
msgid ""
"Making the distinction easier to handle can be accomplished by encoding and "
"decoding between binary data and text at the edge of your code. This means "
"that when you receive text in binary data, you should immediately decode it. "
"And if your code needs to send text as binary data then encode it as late as "
"possible. This allows your code to work with only text internally and thus "
"eliminates having to keep track of what type of data you are working with."
msgstr ""
"通過在程式碼邊緣對二進位資料和文本進行編碼和解碼，可以使區分更容易處理。這意"
"味著當您收到二進位資料的文本時，您應該立即對其進行解碼。如果您的程式碼需要將"
"文本作為二進位資料發送，那麼請盡可能晚地對其進行編碼。這允許您的程式碼在內部"
"僅處理文本，從而無需跟踪您正在處理的資料型別。"

#: ../../howto/pyporting.rst:246
#, fuzzy
msgid ""
"The next issue is making sure you know whether the string literals in your "
"code represent text or binary data. You should add a ``b`` prefix to any "
"literal that presents binary data. For text you should add a ``u`` prefix to "
"the text literal. (there is a :mod:`__future__` import to force all "
"unspecified literals to be Unicode, but usage has shown it isn't as "
"effective as adding a ``b`` or ``u`` prefix to all literals explicitly)"
msgstr ""
"下一個問題是確保您知道程式碼中的字串文字代表文本還是二進位資料。"
"您應該為任何表示二進位資料的文字新增一個 ``b`` 前綴。對於文本，"
"您應該為文本文字新增一個 ``u`` 前綴。 （有一個 :mod:`__future__` "
"導入強制所有未指定的文字為 Unicode，但使用表明它不如向所有文字顯式新增 ``b`` "
"或 ``u`` 前綴有效）"

#: ../../howto/pyporting.rst:253
#, fuzzy
msgid ""
"As part of this dichotomy you also need to be careful about opening files. "
"Unless you have been working on Windows, there is a chance you have not "
"always bothered to add the ``b`` mode when opening a binary file (e.g., "
"``rb`` for binary reading).  Under Python 3, binary files and text files are "
"clearly distinct and mutually incompatible; see the :mod:`io` module for "
"details. Therefore, you **must** make a decision of whether a file will be "
"used for binary access (allowing binary data to be read and/or written) or "
"textual access (allowing text data to be read and/or written). You should "
"also use :func:`io.open` for opening files instead of the built-in :func:"
"`open` function as the :mod:`io` module is consistent from Python 2 to 3 "
"while the built-in :func:`open` function is not (in Python 3 it's actually :"
"func:`io.open`). Do not bother with the outdated practice of using :func:"
"`codecs.open` as that's only necessary for keeping compatibility with Python "
"2.5."
msgstr ""
"作為這種二分法的一部分，您還需要小心打開文件。除非你一直在 Windows 上工作，"
"否則你有可能在打開二進位文件時並不總是費心新增 ``b`` 模式（例如，"
"用於二進位讀取的 ``rb``）。在 Python 3 "
"下，二進位文件和文本文件明顯不同且互不相容；有關詳細資訊，請參閱 :mod:`io` 模"
"組。因此，您**必須**決定文件是用於二進位訪問（允許讀取和/或寫入二進位資料）還"
"是用於文本訪問（允許讀取和/或寫入文本資料）。您還應該使用 :func:`io.open` "
"來打開文件，而不是內建的 :func:`open` 函式，因為 :mod:`io` 模組在 Python 2 "
"到 3 中是一致的，而內建的： func:`open` 函式不是（在 Python 3 中它實際上是 "
":func:`io.open`）。不要理會使用 :func:`codecs.open` 的過時做法，"
"因為這只是保持與 Python 2.5 的相容性所必需的。"

#: ../../howto/pyporting.rst:267
#, fuzzy
msgid ""
"The constructors of both ``str`` and ``bytes`` have different semantics for "
"the same arguments between Python 2 & 3. Passing an integer to ``bytes`` in "
"Python 2 will give you the string representation of the integer: ``bytes(3) "
"== '3'``. But in Python 3, an integer argument to ``bytes`` will give you a "
"bytes object as long as the integer specified, filled with null bytes: "
"``bytes(3) == b'\\x00\\x00\\x00'``. A similar worry is necessary when "
"passing a bytes object to ``str``. In Python 2 you just get the bytes object "
"back: ``str(b'3') == b'3'``. But in Python 3 you get the string "
"representation of the bytes object: ``str(b'3') == \"b'3'\"``."
msgstr ""
"``str`` 和``bytes`` 的構造函式對於 Python 2 和 3 "
"之間的相同參數具有不同的語義。在 Python 2 中將整數傳遞給 ``bytes`` "
"將為您提供整數的字串表示形式： ``bytes(3) == '3'``。但是在 Python 3 "
"中，``bytes`` "
"的整數參數會給你一個位元組物件，只要指定的整數，填充了空位元組：``bytes(3) "
"== b\\'\\x00\\x00\\x00\\'` `。將位元組對像傳遞給 ``str`` 時也需要類似的擔心。"
"在 Python 2 中，你只需回傳位元組物件：``str(b'3') == b'3'``。但是在 "
"Python 3 中，你得到位元組物件的字串表示：``str(b'3') == \"b'3'\"``。"

#: ../../howto/pyporting.rst:277
#, fuzzy
msgid ""
"Finally, the indexing of binary data requires careful handling (slicing does "
"**not** require any special handling). In Python 2, ``b'123'[1] == b'2'`` "
"while in Python 3 ``b'123'[1] == 50``. Because binary data is simply a "
"collection of binary numbers, Python 3 returns the integer value for the "
"byte you index on. But in Python 2 because ``bytes == str``, indexing "
"returns a one-item slice of bytes. The six_ project has a function named "
"``six.indexbytes()`` which will return an integer like in Python 3: ``six."
"indexbytes(b'123', 1)``."
msgstr ""
"最後，二進位資料的索引需要小心處理（切片不需要任何特殊處理）。在 Python 2 "
"中，``b'123'[1] == b'2'`` 而在 Python 3 中，``b'123'[1] == "
"50``。因為二進位資料只是二進位數字的集合，所以 Python 3 "
"回傳索引位元組的整數值。但在 Python 2 中，因為 ``bytes == "
"str``，索引回傳一個位元組的單項切片。 six_ 項目有一個名為 ``six."
"indexbytes()`` 的函式，它將像 Python 3 中那樣回傳一個整數：``six.indexbytes("
"b'123', 1)``。"

#: ../../howto/pyporting.rst:286
msgid "To summarize:"
msgstr "總結一下："

#: ../../howto/pyporting.rst:288
#, fuzzy
msgid "Decide which of your APIs take text and which take binary data"
msgstr "決定哪些 API 接受文本，哪些接受二進位資料"

#: ../../howto/pyporting.rst:289
#, fuzzy
msgid ""
"Make sure that your code that works with text also works with ``unicode`` "
"and code for binary data works with ``bytes`` in Python 2 (see the table "
"above for what methods you cannot use for each type)"
msgstr ""
"確保您處理文本的程式碼也適用於 ``unicode`` 並且二進位資料程式碼適用於 Python "
"2 中的``bytes``（請參閱上表了解您不能對每種型別使用的方法）"

#: ../../howto/pyporting.rst:292
#, fuzzy
msgid ""
"Mark all binary literals with a ``b`` prefix, textual literals with a ``u`` "
"prefix"
msgstr "用 ``b`` 前綴標記所有二進位文字，用 ``u``前綴標記文本文字"

#: ../../howto/pyporting.rst:294
#, fuzzy
msgid ""
"Decode binary data to text as soon as possible, encode text as binary data "
"as late as possible"
msgstr "盡快將二進位資料解碼為文本，盡可能晚地將文本編碼為二進位資料"

#: ../../howto/pyporting.rst:296
#, fuzzy
msgid ""
"Open files using :func:`io.open` and make sure to specify the ``b`` mode "
"when appropriate"
msgstr "使用 :func:`io.open` 打開文件並確保在適當的時候指定 ``b`` 模式"

#: ../../howto/pyporting.rst:298
#, fuzzy
msgid "Be careful when indexing into binary data"
msgstr "索引二進位資料時要小心"

#: ../../howto/pyporting.rst:302
#, fuzzy
msgid "Use feature detection instead of version detection"
msgstr "使用功能檢測而不是版本檢測"

#: ../../howto/pyporting.rst:304
#, fuzzy
msgid ""
"Inevitably you will have code that has to choose what to do based on what "
"version of Python is running. The best way to do this is with feature "
"detection of whether the version of Python you're running under supports "
"what you need. If for some reason that doesn't work then you should make the "
"version check be against Python 2 and not Python 3. To help explain this, "
"let's look at an example."
msgstr ""
"不可避免地，您將擁有必鬚根據運行的 Python 版本選擇要執行的操作的程式碼。"
"最好的方法是通過功能檢測來檢測您正在運行的 Python "
"版本是否支援您需要的功能。如果由於某種原因不起作用，那麼您應該針對 Python 2 "
"而不是 Python 3 進行版本檢查。為了幫助解釋這一點，讓我們看一個示例。"

#: ../../howto/pyporting.rst:311
#, fuzzy
msgid ""
"Let's pretend that you need access to a feature of :mod:`importlib` that is "
"available in Python's standard library since Python 3.3 and available for "
"Python 2 through importlib2_ on PyPI. You might be tempted to write code to "
"access e.g. the :mod:`importlib.abc` module by doing the following::"
msgstr ""
"假設您需要訪問 :mod:`importlib` 的一項功能，該功能自 Python 3.3 起在 Python "
"的標準庫中可用，並且可通過 PyPI 上的 importlib2_ 用於 Python "
"2。您可能很想編寫程式碼來訪問，例如 :mod:`importlib.abc` "
"模組通過執行以下操作::"

#: ../../howto/pyporting.rst:323
#, fuzzy
msgid ""
"The problem with this code is what happens when Python 4 comes out? It would "
"be better to treat Python 2 as the exceptional case instead of Python 3 and "
"assume that future Python versions will be more compatible with Python 3 "
"than Python 2::"
msgstr ""
"這段程式碼的問題是當 Python 4 出來時會發生什麼？最好將 Python 2 "
"視為例外情況而不是 Python 3，並假設未來的 Python 版本將比 Python 2 更相容 "
"Python 3::"

#: ../../howto/pyporting.rst:335
#, fuzzy
msgid ""
"The best solution, though, is to do no version detection at all and instead "
"rely on feature detection. That avoids any potential issues of getting the "
"version detection wrong and helps keep you future-compatible::"
msgstr "不過，最好的解決方案是完全不進行版本檢測，而是依靠功能檢測。這避免了版本檢測"
"錯誤的任何潛在問題，並幫助您保持未來相容性::"

#: ../../howto/pyporting.rst:346
#, fuzzy
msgid "Prevent compatibility regressions"
msgstr "防止相容性倒退"

#: ../../howto/pyporting.rst:348
#, fuzzy
msgid ""
"Once you have fully translated your code to be compatible with Python 3, you "
"will want to make sure your code doesn't regress and stop working under "
"Python 3. This is especially true if you have a dependency which is blocking "
"you from actually running under Python 3 at the moment."
msgstr ""
"一旦您將程式碼完全轉換為與 Python 3 相容，"
"您將希望確保您的程式碼不會倒退並停止在 Python 3 下工作。"
"如果您有一個依賴項阻止您實際運行在 Python 3 下，則尤其如此目前是 Python 3。"

#: ../../howto/pyporting.rst:353
#, fuzzy
msgid ""
"To help with staying compatible, any new modules you create should have at "
"least the following block of code at the top of it::"
msgstr "為了保持相容性，您建立的任何新模組的頂部至少應包含以下程式碼塊："

#: ../../howto/pyporting.rst:360
#, fuzzy
msgid ""
"You can also run Python 2 with the ``-3`` flag to be warned about various "
"compatibility issues your code triggers during execution. If you turn "
"warnings into errors with ``-Werror`` then you can make sure that you don't "
"accidentally miss a warning."
msgstr ""
"您還可以使用 ``-3`` 旗標運行 Python "
"2，以收到有關程式碼在執行期間觸發的各種相容性問題的警告。如果你用 ``-Werror``"
" 將警告變成錯誤，那麼你可以確保你不會不小心錯過警告。"

#: ../../howto/pyporting.rst:365
#, fuzzy
msgid ""
"You can also use the Pylint_ project and its ``--py3k`` flag to lint your "
"code to receive warnings when your code begins to deviate from Python 3 "
"compatibility. This also prevents you from having to run Modernize_ or "
"Futurize_ over your code regularly to catch compatibility regressions. This "
"does require you only support Python 2.7 and Python 3.4 or newer as that is "
"Pylint's minimum Python version support."
msgstr ""
"您還可以使用 Pylint_ 項目及其 ``--py3k`` 旗標來檢查您的程式碼，"
"以便在您的程式碼開始偏離 Python 3 相容性時收到警告。"
"這也使您不必定期對程式碼運行 Modernize_ 或 Futurize_ 來捕獲相容性回歸。"
"這確實要求您僅支援 Python 2.7 和 Python 3.4 或更新版本，因為這是 Pylint "
"的最低 Python 版本支援。"

#: ../../howto/pyporting.rst:374
#, fuzzy
msgid "Check which dependencies block your transition"
msgstr "檢查哪些依賴項會阻止您的轉換"

#: ../../howto/pyporting.rst:376
#, fuzzy
msgid ""
"**After** you have made your code compatible with Python 3 you should begin "
"to care about whether your dependencies have also been ported. The "
"caniusepython3_ project was created to help you determine which projects -- "
"directly or indirectly -- are blocking you from supporting Python 3. There "
"is both a command-line tool as well as a web interface at https://"
"caniusepython3.com."
msgstr ""
"**在**你的程式碼與 Python 3 相容後，你應該開始關心你的依賴項是否也被移植了。"
"建立 caniusepython3_ 項目是為了幫助您確定哪些項目（直接或間接）阻礙您支援 "
"Python 3。在 https://caniusepython3.com 上既有命令列工具也有 Web 界面。"

#: ../../howto/pyporting.rst:383
#, fuzzy
msgid ""
"The project also provides code which you can integrate into your test suite "
"so that you will have a failing test when you no longer have dependencies "
"blocking you from using Python 3. This allows you to avoid having to "
"manually check your dependencies and to be notified quickly when you can "
"start running on Python 3."
msgstr ""
"該項目還提供了可以集成到測試套件中的程式碼，這樣當您不再有依賴項阻止您使用 "
"Python 3 時，您的測試就會失敗。"
"這使您可以避免手動檢查依賴項并快速收到通知什麼時候可以開始在 Python 3 "
"上運行。"

#: ../../howto/pyporting.rst:390
#, fuzzy
msgid "Update your ``setup.py`` file to denote Python 3 compatibility"
msgstr "更新您的 ``setup.py`` 文件以表示 Python 3 相容性"

#: ../../howto/pyporting.rst:392
#, fuzzy
msgid ""
"Once your code works under Python 3, you should update the classifiers in "
"your ``setup.py`` to contain ``Programming Language :: Python :: 3`` and to "
"not specify sole Python 2 support. This will tell anyone using your code "
"that you support Python 2 **and** 3. Ideally you will also want to add "
"classifiers for each major/minor version of Python you now support."
msgstr ""
"一旦您的程式碼在 Python 3 下運行，您應該更新 ``setup.py`` 中的分類器以包含 ``"
"Programming Language :: Python :: 3`` 並且不指定唯一的 Python 2 支援。"
"這將告訴任何使用您的程式碼的人您支援 Python 2 ** 和 ** "
"3。理想情況下，您還希望為您現在支援的每個主要/次要版本的 Python 新增分類器。"

#: ../../howto/pyporting.rst:400
#, fuzzy
msgid "Use continuous integration to stay compatible"
msgstr "使用持續集成來保持相容性"

#: ../../howto/pyporting.rst:402
#, fuzzy
msgid ""
"Once you are able to fully run under Python 3 you will want to make sure "
"your code always works under both Python 2 & 3. Probably the best tool for "
"running your tests under multiple Python interpreters is tox_. You can then "
"integrate tox with your continuous integration system so that you never "
"accidentally break Python 2 or 3 support."
msgstr ""
"一旦您能夠在 Python 3 下完全運行，您將希望確保您的程式碼始終在 Python 2 和 3 "
"下運行。在多個 Python 直譯器下運行測試的最佳工具可能是 tox_。然後，您可以將 "
"tox 與您的持續集成系統集成，這樣您就不會意外破壞 Python 2 或 3 的支援。"

#: ../../howto/pyporting.rst:408
#, fuzzy
msgid ""
"You may also want to use the ``-bb`` flag with the Python 3 interpreter to "
"trigger an exception when you are comparing bytes to strings or bytes to an "
"int (the latter is available starting in Python 3.5). By default type-"
"differing comparisons simply return ``False``, but if you made a mistake in "
"your separation of text/binary data handling or indexing on bytes you "
"wouldn't easily find the mistake. This flag will raise an exception when "
"these kinds of comparisons occur, making the mistake much easier to track "
"down."
msgstr ""
"當您將位元組與字串或位元組與 int 進行比較（後者從 Python 3.5 開始可用）時，"
"您可能還希望將 ``-bb`` 旗標與 Python 3 直譯器一起使用以觸發例外。預設情況下，"
"型別差異比較只回傳 ``False``，但如果您在分離文本/二進位資料處理或位元組索引時犯"
"了錯誤，您將不會輕易發現錯誤。當發生這些型別的比較時，此旗標將引發例外，從而"
"更容易追踪錯誤。"

#: ../../howto/pyporting.rst:416
#, fuzzy
msgid ""
"And that's mostly it! At this point your code base is compatible with both "
"Python 2 and 3 simultaneously. Your testing will also be set up so that you "
"don't accidentally break Python 2 or 3 compatibility regardless of which "
"version you typically run your tests under while developing."
msgstr ""
"僅此而已！此時您的程式碼庫同時相容 Python 2 和 3。您的測試也將被設定，"
"這樣您就不會意外破壞 Python 2 或 3 "
"的相容性，無論您在開發時通常在哪個版本下運行測試。"

#: ../../howto/pyporting.rst:423
#, fuzzy
msgid "Consider using optional static type checking"
msgstr "考慮使用可選的靜態型別檢查"

#: ../../howto/pyporting.rst:425
#, fuzzy
msgid ""
"Another way to help port your code is to use a static type checker like "
"mypy_ or pytype_ on your code. These tools can be used to analyze your code "
"as if it's being run under Python 2, then you can run the tool a second time "
"as if your code is running under Python 3. By running a static type checker "
"twice like this you can discover if you're e.g. misusing binary data type in "
"one version of Python compared to another. If you add optional type hints to "
"your code you can also explicitly state whether your APIs use textual or "
"binary data, helping to make sure everything functions as expected in both "
"versions of Python."
msgstr ""
"另一種幫助移植程式碼的方法是在程式碼上使用靜態型別檢查器，如 mypy_ 或 "
"pytype_。這些工具可用於分析您的程式碼，就像它在 Python 2 "
"下運行一樣，然後您可以再次運行該工具，就像您的程式碼在 Python 3 "
"下運行一樣。通過像這樣運行靜態型別檢查器兩次，"
"您可以發現是否你是與另一個版本的 Python "
"相比，濫用二進位資料型別。如果您向程式碼中新增可選的型別提示，"
"您還可以明確說明您的 API 使用文本資料還是二進位資料，"
"有助於確保所有功能在兩個版本的 Python 中都按預期運行。"
