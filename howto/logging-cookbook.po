# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-30 00:16+0000\n"
"PO-Revision-Date: 2018-05-23 14:36+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/logging-cookbook.rst:5
#, fuzzy
msgid "Logging Cookbook"
msgstr "記錄食譜"

#: ../../howto/logging-cookbook.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/logging-cookbook.rst:7
msgid "Vinay Sajip <vinay_sajip at red-dove dot com>"
msgstr "Vinay Sajip <vinay_sajip at red-dove dot com>"

#: ../../howto/logging-cookbook.rst:9
#, fuzzy
msgid ""
"This page contains a number of recipes related to logging, which have been "
"found useful in the past. For links to tutorial and reference information, "
"please see :ref:`cookbook-ref-links`."
msgstr ""
"此頁麵包含許多與日誌記錄相關的方法，這些方法在過去被發現很有用。有關教程和參"
"考資訊的鏈接，請參閱 :ref:`cookbook-ref-links`。"

#: ../../howto/logging-cookbook.rst:16
#, fuzzy
msgid "Using logging in multiple modules"
msgstr "在多個模組中使用日誌記錄"

#: ../../howto/logging-cookbook.rst:18
#, fuzzy
msgid ""
"Multiple calls to ``logging.getLogger('someLogger')`` return a reference to "
"the same logger object.  This is true not only within the same module, but "
"also across modules as long as it is in the same Python interpreter "
"process.  It is true for references to the same object; additionally, "
"application code can define and configure a parent logger in one module and "
"create (but not configure) a child logger in a separate module, and all "
"logger calls to the child will pass up to the parent.  Here is a main "
"module::"
msgstr ""
"對 logging.getLogger('someLogger') 的多次呼叫回傳對同一記錄器物件的引用。不僅"
"在同一個模組內如此，跨模組也是如此，只要是在同一個 Python 直譯器行程中。對同"
"一物件的引用也是如此；此外，應用程式程式碼可以在一個模組中定義和配置父記錄器"
"，並在單獨的模組中建立（但不配置）子記錄器，所有對子記錄器的呼叫都將傳遞給父"
"記錄器。這是一個主要模組::"

#: ../../howto/logging-cookbook.rst:56
#, fuzzy
msgid "Here is the auxiliary module::"
msgstr "這是輔助模組::"

#: ../../howto/logging-cookbook.rst:76
#, fuzzy
msgid "The output looks like this:"
msgstr "輸出如下所示："

#: ../../howto/logging-cookbook.rst:102
#, fuzzy
msgid "Logging from multiple threads"
msgstr "從多個執行緒記錄"

#: ../../howto/logging-cookbook.rst:104
#, fuzzy
msgid ""
"Logging from multiple threads requires no special effort. The following "
"example shows logging from the main (initial) thread and another thread::"
msgstr "從多個執行緒記錄不需要特別的努力。以下示例顯示了來自主（初始）執行緒和另一個"
"執行緒的日誌記錄："

#: ../../howto/logging-cookbook.rst:133
#, fuzzy
msgid "When run, the script should print something like the following:"
msgstr "運行時，腳本應印出如下內容："

#: ../../howto/logging-cookbook.rst:155
#, fuzzy
msgid ""
"This shows the logging output interspersed as one might expect. This "
"approach works for more threads than shown here, of course."
msgstr "這顯示了日誌記錄輸出，正如人們所期望的那樣。當然，這種方法適用於比此處所示更"
"多的執行緒。"

#: ../../howto/logging-cookbook.rst:159
#, fuzzy
msgid "Multiple handlers and formatters"
msgstr "多個處理程式和格式化程式"

#: ../../howto/logging-cookbook.rst:161
#, fuzzy
msgid ""
"Loggers are plain Python objects.  The :meth:`~Logger.addHandler` method has "
"no minimum or maximum quota for the number of handlers you may add.  "
"Sometimes it will be beneficial for an application to log all messages of "
"all severities to a text file while simultaneously logging errors or above "
"to the console.  To set this up, simply configure the appropriate handlers.  "
"The logging calls in the application code will remain unchanged.  Here is a "
"slight modification to the previous simple module-based configuration "
"example::"
msgstr ""
"記錄器是普通的 Python 物件。 :meth:`~Logger.addHandler` 方法對於您可以新增的"
"處理程式數量沒有最小或最大配額。有時，應用程式將所有嚴重性的所有消息記錄到文"
"本文件，同時將錯誤或以上錯誤記錄到控制台是有益的。要設定它，只需配置適當的處"
"理程式。應用程式程式碼中的日誌記錄呼叫將保持不變。這是對前面簡單的基於模組的"
"配置示例的輕微修改："

#: ../../howto/logging-cookbook.rst:194
#, fuzzy
msgid ""
"Notice that the 'application' code does not care about multiple handlers.  "
"All that changed was the addition and configuration of a new handler named "
"*fh*."
msgstr "請注意，“應用程式”程式碼不關心多個處理程式。"
"所發生的變化只是新增和配置了一個名為 *fh* 的新處理程式。"

#: ../../howto/logging-cookbook.rst:197
#, fuzzy
msgid ""
"The ability to create new handlers with higher- or lower-severity filters "
"can be very helpful when writing and testing an application.  Instead of "
"using many ``print`` statements for debugging, use ``logger.debug``: Unlike "
"the print statements, which you will have to delete or comment out later, "
"the logger.debug statements can remain intact in the source code and remain "
"dormant until you need them again.  At that time, the only change that needs "
"to happen is to modify the severity level of the logger and/or handler to "
"debug."
msgstr ""
"在編寫和測試應用程式時，建立具有更高或更低嚴重性過濾器的新處理程式的能力非常"
"有用。不要使用許多 ``print`` 語句進行除錯，而是使用 ``logger.debug``："
"與稍後必須刪除或註釋掉的 print 語句不同，logger.debug 語句可以在源程式碼中保"
"持完整並保持休眠狀態，直到您再次需要它們。那時，唯一需要發生的變化是修改記錄"
"器和/或處理程式的嚴重級別以進行除錯。"

#: ../../howto/logging-cookbook.rst:208
#, fuzzy
msgid "Logging to multiple destinations"
msgstr "記錄到多個目的地"

#: ../../howto/logging-cookbook.rst:210
#, fuzzy
msgid ""
"Let's say you want to log to console and file with different message formats "
"and in differing circumstances. Say you want to log messages with levels of "
"DEBUG and higher to file, and those messages at level INFO and higher to the "
"console. Let's also assume that the file should contain timestamps, but the "
"console messages should not. Here's how you can achieve this::"
msgstr ""
"假設您想在不同的情況下使用不同的消息格式登錄到控制台和文件。假設您想將 DEBUG "
"和更高階別的消息記錄到文件，並將 INFO 和更高階別的消息記錄到控制台。我們還假"
"設文件應該包含時間戳，但控制台消息不應該。這是實作此目標的方法::"

#: ../../howto/logging-cookbook.rst:248
#, fuzzy
msgid "When you run this, on the console you will see"
msgstr "當你運行它時，你會在控制台上看到"

#: ../../howto/logging-cookbook.rst:257
#, fuzzy
msgid "and in the file you will see something like"
msgstr "在文件中你會看到類似"

#: ../../howto/logging-cookbook.rst:267
#, fuzzy
msgid ""
"As you can see, the DEBUG message only shows up in the file. The other "
"messages are sent to both destinations."
msgstr "如您所見，DEBUG 消息僅顯示在文件中。其他消息被發送到兩個目的地。"

#: ../../howto/logging-cookbook.rst:270
#, fuzzy
msgid ""
"This example uses console and file handlers, but you can use any number and "
"combination of handlers you choose."
msgstr "此示例使用控制台和文件處理程式，但您可以使用您選擇的任意數量和組合的處理程式"
"。"

#: ../../howto/logging-cookbook.rst:273
#, fuzzy
msgid ""
"Note that the above choice of log filename ``/tmp/myapp.log`` implies use of "
"a standard location for temporary files on POSIX systems. On Windows, you "
"may need to choose a different directory name for the log - just ensure that "
"the directory exists and that you have the permissions to create and update "
"files in it."
msgstr ""
"請注意，上面選擇的日誌文件名“/tmp/myapp.log”意味著在 POSIX "
"系統上使用臨時文件的標準位置。在 Windows 上，"
"您可能需要為日誌選擇不同的目錄名稱 - "
"只需確保該目錄存在並且您有權在其中建立和更新文件。"

#: ../../howto/logging-cookbook.rst:282
#, fuzzy
msgid "Custom handling of levels"
msgstr "級別的自定義處理"

#: ../../howto/logging-cookbook.rst:284
#, fuzzy
msgid ""
"Sometimes, you might want to do something slightly different from the "
"standard handling of levels in handlers, where all levels above a threshold "
"get processed by a handler. To do this, you need to use filters. Let's look "
"at a scenario where you want to arrange things as follows:"
msgstr ""
"有時，您可能想要做一些與處理程式中級別的標準處理略有不同的事情，其中"
"所有高於閾值的級別都由處理程式處理"
"。為此，您需要使用過濾器。讓我們看一下您要按如下方式安排事情的場景："

#: ../../howto/logging-cookbook.rst:289
#, fuzzy
msgid "Send messages of severity ``INFO`` and ``WARNING`` to ``sys.stdout``"
msgstr "將嚴重程度為 ``INFO``和 ``WARNING`` 的消息發送到“sys.stdout”"

#: ../../howto/logging-cookbook.rst:290
#, fuzzy
msgid "Send messages of severity ``ERROR`` and above to ``sys.stderr``"
msgstr "將嚴重程度為 ``ERROR``及以上的消息發送到“sys.stderr”"

#: ../../howto/logging-cookbook.rst:291
#, fuzzy
msgid "Send messages of severity ``DEBUG`` and above to file ``app.log``"
msgstr "將嚴重程度為 ``DEBUG``及以上的消息發送到文件“app.log”"

#: ../../howto/logging-cookbook.rst:293
#, fuzzy
msgid "Suppose you configure logging with the following JSON:"
msgstr "假設您使用以下 JSON 配置日誌記錄："

#: ../../howto/logging-cookbook.rst:335
#, fuzzy
msgid ""
"This configuration does *almost* what we want, except that ``sys.stdout`` "
"would show messages of severity ``ERROR`` and above as well as ``INFO`` and "
"``WARNING`` messages. To prevent this, we can set up a filter which excludes "
"those messages and add it to the relevant handler. This can be configured by "
"adding a ``filters`` section parallel to ``formatters`` and ``handlers``:"
msgstr ""
"這個配置 *幾乎* 我們想要的，除了 ``sys.stdout`` 會顯示嚴重程度為 ``ERROR`` "
"及以上的消息以及 ``INFO`` 和 ``WARNING`` 消息。為了防止這種情況，我們可以設定"
"一個過濾器來排除這些消息並將其新增到相關的處理程式中。這可以通過新增與 "
"``formatters`` 和 ``handlers`` 並行的 ``filters`` 部分來配置："

#: ../../howto/logging-cookbook.rst:352
#, fuzzy
msgid "and changing the section on the ``stdout`` handler to add it:"
msgstr "並更改 ``stdout`` 處理程式上的部分以新增它："

#: ../../howto/logging-cookbook.rst:366
#, fuzzy
msgid ""
"A filter is just a function, so we can define the ``filter_maker`` (a "
"factory function) as follows:"
msgstr "過濾器只是一個函式，所以我們可以定義``filter_maker``（工廠函式）如下："

#: ../../howto/logging-cookbook.rst:379
#, fuzzy
msgid ""
"This converts the string argument passed in to a numeric level, and returns "
"a function which only returns ``True`` if the level of the passed in record "
"is at or below the specified level. Note that in this example I have defined "
"the ``filter_maker`` in a test script ``main.py`` that I run from the "
"command line, so its module will be ``__main__`` - hence the ``__main__."
"filter_maker`` in the filter configuration. You will need to change that if "
"you define it in a different module."
msgstr ""
"這會將傳入的字串參數轉換為數字級別，並回傳一個函式，該函式僅在傳入記錄的級別"
"等於或低於指定級別時才回傳 ``True``。請注意，在此示例中，我在從命令列運行的測試"
"腳本“main."
"py”中定義了“filter_maker”，因此它的模組將是“__main__”——因此是“__main__”。 "
"filter_maker`` 在過濾器配置中。如果您在不同的模組中定義它，則需要更改它。"

#: ../../howto/logging-cookbook.rst:387
#, fuzzy
msgid "With the filter added, we can run ``main.py``, which in full is:"
msgstr "新增過濾器後，我們可以運行 ``main.py``，完整的是："

#: ../../howto/logging-cookbook.rst:457
#, fuzzy
msgid "And after running it like this:"
msgstr "像這樣運行之後："

#: ../../howto/logging-cookbook.rst:463
#, fuzzy
msgid "We can see the results are as expected:"
msgstr "我們可以看到結果符合預期："

#: ../../howto/logging-cookbook.rst:489
#, fuzzy
msgid "Configuration server example"
msgstr "配置伺服器示例"

#: ../../howto/logging-cookbook.rst:491
#, fuzzy
msgid "Here is an example of a module using the logging configuration server::"
msgstr "下面是一個使用日誌配置伺服器的模組示例："

#: ../../howto/logging-cookbook.rst:522
#, fuzzy
msgid ""
"And here is a script that takes a filename and sends that file to the "
"server, properly preceded with the binary-encoded length, as the new logging "
"configuration::"
msgstr "這是一個腳本，它接受一個文件名並將該文件發送到伺服器，正確地以二進位編碼的長"
"度作為新的日誌記錄配置："

#: ../../howto/logging-cookbook.rst:547
#, fuzzy
msgid "Dealing with handlers that block"
msgstr "處理阻塞的處理程式"

#: ../../howto/logging-cookbook.rst:551
#, fuzzy
msgid ""
"Sometimes you have to get your logging handlers to do their work without "
"blocking the thread you're logging from. This is common in web applications, "
"though of course it also occurs in other scenarios."
msgstr "有時您必須讓您的日誌處理程式在不阻塞您正在登錄的執行緒的情況下完成它們的工作"
"。這在 web 應用程式中很常見，當然它也會出現在其他場景中。"

#: ../../howto/logging-cookbook.rst:555
#, fuzzy
msgid ""
"A common culprit which demonstrates sluggish behaviour is the :class:"
"`SMTPHandler`: sending emails can take a long time, for a number of reasons "
"outside the developer's control (for example, a poorly performing mail or "
"network infrastructure). But almost any network-based handler can block: "
"Even a :class:`SocketHandler` operation may do a DNS query under the hood "
"which is too slow (and this query can be deep in the socket library code, "
"below the Python layer, and outside your control)."
msgstr ""
"SMTPHandler 是表現遲緩行為的常見罪魁禍首：發送電子郵件可能會花費很長時間，原"
"因有很多是開發人員無法控制的（例如，性能不佳的郵件或網絡基礎設施）。但是幾乎"
"任何基於網絡的處理程式都可以阻止：即使是 :class:`SocketHandler` "
"操作也可能在後台進行 DNS "
"查詢，這太慢了（而且這個查詢可能深入到 socket 庫程式碼中，在 Python "
"層之下，並且在你的控制之外）。"

#: ../../howto/logging-cookbook.rst:563
#, fuzzy
msgid ""
"One solution is to use a two-part approach. For the first part, attach only "
"a :class:`QueueHandler` to those loggers which are accessed from performance-"
"critical threads. They simply write to their queue, which can be sized to a "
"large enough capacity or initialized with no upper bound to their size. The "
"write to the queue will typically be accepted quickly, though you will "
"probably need to catch the :exc:`queue.Full` exception as a precaution in "
"your code. If you are a library developer who has performance-critical "
"threads in their code, be sure to document this (together with a suggestion "
"to attach only ``QueueHandlers`` to your loggers) for the benefit of other "
"developers who will use your code."
msgstr ""
"一種解決方案是使用兩部分方法。對於第一部分，僅將 QueueHandler 附加到那些從性"
"能關鍵執行緒訪問的記錄器。他們只是簡單地寫入他們的隊列，隊列的大小可以設定為"
"足夠大的容量，或者在沒有大小上限的情況下進行初始化。對隊列的寫入通常會很快被"
"接受，但您可能需要在程式碼中捕獲 :exc:`queue.Full` 例外作為預防措施。如果您是"
"程式碼中具有性能關鍵執行緒的庫開發人員，請務必將其記錄下來（連同建議僅將“Queu"
"eHandlers”附加到您的記錄器），以便其他將使用您的程式碼的開發人員受益。"

#: ../../howto/logging-cookbook.rst:574
#, fuzzy
msgid ""
"The second part of the solution is :class:`QueueListener`, which has been "
"designed as the counterpart to :class:`QueueHandler`.  A :class:"
"`QueueListener` is very simple: it's passed a queue and some handlers, and "
"it fires up an internal thread which listens to its queue for LogRecords "
"sent from ``QueueHandlers`` (or any other source of ``LogRecords``, for that "
"matter). The ``LogRecords`` are removed from the queue and passed to the "
"handlers for processing."
msgstr ""
"解決方案的第二部分是 QueueListener，它被設計為 QueueHandler 的對應部分。 "
":class:`QueueListener` 非常簡單：它傳遞了一個隊列和一些處理程式，它啟動了一個"
"內部執行緒，該執行緒偵聽其隊列中從``QueueHandlers``（或任何其他 ``LogRecords`"
" 來源）發送的 LogRecords `，就此而言）。 ``LogRecords`` "
"從隊列中移除並傳遞給處理程式進行處理。"

#: ../../howto/logging-cookbook.rst:582
#, fuzzy
msgid ""
"The advantage of having a separate :class:`QueueListener` class is that you "
"can use the same instance to service multiple ``QueueHandlers``. This is "
"more resource-friendly than, say, having threaded versions of the existing "
"handler classes, which would eat up one thread per handler for no particular "
"benefit."
msgstr ""
"擁有一個單獨的 QueueListener 類的好處是您可以使用同一個實例來為多個 "
"QueueHandlers 提供服務。這比現有處理程式類的執行緒版本更加資源友好，後者會佔"
"用每個處理程式一個執行緒而沒有特別的好處。"

#: ../../howto/logging-cookbook.rst:587
#, fuzzy
msgid "An example of using these two classes follows (imports omitted)::"
msgstr "使用這兩個類的示例如下（省略導入）::"

#: ../../howto/logging-cookbook.rst:605
#, fuzzy
msgid "which, when run, will produce:"
msgstr "運行時，將產生："

#: ../../howto/logging-cookbook.rst:611
#, fuzzy
msgid ""
"Although the earlier discussion wasn't specifically talking about async "
"code, but rather about slow logging handlers, it should be noted that when "
"logging from async code, network and even file handlers could lead to "
"problems (blocking the event loop) because some logging is done from :mod:"
"`asyncio` internals. It might be best, if any async code is used in an "
"application, to use the above approach for logging, so that any blocking "
"code runs only in the ``QueueListener`` thread."
msgstr ""
"雖然之前的討論並沒有專門討論非同步程式碼，而是關於慢速日誌處理程式，但應該注"
"意的是，當從非同步程式碼、網絡甚至文件處理程式進行日誌記錄時，可能會導致問題"
"（阻塞事件循環），因為某些日誌記錄是從 :mod:`asyncio` 內部完成。如果在應用程"
"序中使用任何非同步程式碼，最好使用上述方法進行日誌記錄，以便任何阻塞程式碼僅"
"在 ``QueueListener`` 執行緒中運行。"

#: ../../howto/logging-cookbook.rst:619
#, fuzzy
msgid ""
"Prior to Python 3.5, the :class:`QueueListener` always passed every message "
"received from the queue to every handler it was initialized with. (This was "
"because it was assumed that level filtering was all done on the other side, "
"where the queue is filled.) From 3.5 onwards, this behaviour can be changed "
"by passing a keyword argument ``respect_handler_level=True`` to the "
"listener's constructor. When this is done, the listener compares the level "
"of each message with the handler's level, and only passes a message to a "
"handler if it's appropriate to do so."
msgstr ""
"在 Python 3.5 之前，:class:`QueueListener` "
"總是將從隊列接收到的每條消息傳遞給它初始化的每個處理程式。 "
"（這是因為假定級別過濾全部在隊列已滿的另一側完成。）從 3.5 開始，可以通過將關"
"鍵字參數“respect_handler_level=True”傳遞給偵聽器的構造函式來更改此行為.完成此"
"操作後，偵聽器將每條消息的級別與處理程式的級別進行比較，並且僅在適當的情況下"
"才將消息傳遞給處理程式。"

#: ../../howto/logging-cookbook.rst:632
#, fuzzy
msgid "Sending and receiving logging events across a network"
msgstr "通過網絡發送和接收日誌記錄事件"

#: ../../howto/logging-cookbook.rst:634
#, fuzzy
msgid ""
"Let's say you want to send logging events across a network, and handle them "
"at the receiving end. A simple way of doing this is attaching a :class:"
"`SocketHandler` instance to the root logger at the sending end::"
msgstr "假設您想通過網絡發送日誌記錄事件，並在接收端處理它們。"
"一種簡單的方法是在發送端將一個 SocketHandler 實例附加到根記錄器："

#: ../../howto/logging-cookbook.rst:662
#, fuzzy
msgid ""
"At the receiving end, you can set up a receiver using the :mod:"
"`socketserver` module. Here is a basic working example::"
msgstr "在接收端，您可以使用 :mod:`socketserver` "
"模組設定接收器。這是一個基本的工作示例::"

#: ../../howto/logging-cookbook.rst:750
#, fuzzy
msgid ""
"First run the server, and then the client. On the client side, nothing is "
"printed on the console; on the server side, you should see something like:"
msgstr "先運行伺服器，再運行客戶端。在客戶端，控制台上沒有印出任何內容；在伺服器端，"
"您應該會看到如下內容："

#: ../../howto/logging-cookbook.rst:762
#, fuzzy
msgid ""
"Note that there are some security issues with pickle in some scenarios. If "
"these affect you, you can use an alternative serialization scheme by "
"overriding the :meth:`~handlers.SocketHandler.makePickle` method and "
"implementing your alternative there, as well as adapting the above script to "
"use your alternative serialization."
msgstr ""
"請注意，在某些情況下，pickle 存在一些安全問題。如果這些影響到您，"
"您可以通過覆蓋 :meth:`~handlers.SocketHandler.makePickle` 方法並在那裡實作您"
"的替代方案來使用替代序列化方案，以及調整上述腳本以使用您的替代序列化。"

#: ../../howto/logging-cookbook.rst:770
#, fuzzy
msgid "Running a logging socket listener in production"
msgstr "在生產環境中運行一個日誌 socket 監聽器"

#: ../../howto/logging-cookbook.rst:774
#, fuzzy
msgid ""
"To run a logging listener in production, you may need to use a process-"
"management tool such as `Supervisor <http://supervisord.org/>`_. `Here is a "
"Gist <socket-listener-gist_>`__ which provides the bare-bones files to run "
"the above functionality using Supervisor. It consists of the following files:"
msgstr ""
"要在生產環境中運行日誌監聽器，您可能需要使用行程管理工具，例如 `Supervisor "
"<http://supervisord.org/>`_。 `這是一個 Gist <socket-listener-gist_>`__，"
"它提供了使用 Supervisor 運行上述功能的基本文件。它由以下文件組成："

#: ../../howto/logging-cookbook.rst:781
#, fuzzy
msgid "File"
msgstr "文件"

#: ../../howto/logging-cookbook.rst:781
#, fuzzy
msgid "Purpose"
msgstr "目的"

#: ../../howto/logging-cookbook.rst:783
#, fuzzy
msgid ":file:`prepare.sh`"
msgstr ":file:`prepare.sh`"

#: ../../howto/logging-cookbook.rst:783
#, fuzzy
msgid "A Bash script to prepare the environment for testing"
msgstr "用於準備測試環境的 Bash 腳本"

#: ../../howto/logging-cookbook.rst:786
#, fuzzy
msgid ":file:`supervisor.conf`"
msgstr ":file:`supervisor.conf`"

#: ../../howto/logging-cookbook.rst:786
#, fuzzy
msgid ""
"The Supervisor configuration file, which has entries for the listener and a "
"multi-process web application"
msgstr "Supervisor 配置文件，其中包含用於偵聽器和多行程 Web 應用程式的條目"

#: ../../howto/logging-cookbook.rst:790
#, fuzzy
msgid ":file:`ensure_app.sh`"
msgstr ":file:`ensure_app.sh`"

#: ../../howto/logging-cookbook.rst:790
#, fuzzy
msgid ""
"A Bash script to ensure that Supervisor is running with the above "
"configuration"
msgstr "確保 Supervisor 以上述配置運行的 Bash 腳本"

#: ../../howto/logging-cookbook.rst:793
#, fuzzy
msgid ":file:`log_listener.py`"
msgstr ":file:`log_listener.py`"

#: ../../howto/logging-cookbook.rst:793
#, fuzzy
msgid ""
"The socket listener program which receives log events and records them to a "
"file"
msgstr "接收日誌事件並將其記錄到文件中的 socket 偵聽器程式"

#: ../../howto/logging-cookbook.rst:796
#, fuzzy
msgid ":file:`main.py`"
msgstr ":file:`main.py`"

#: ../../howto/logging-cookbook.rst:796
#, fuzzy
msgid ""
"A simple web application which performs logging via a socket connected to "
"the listener"
msgstr "一個簡單的 Web 應用程式，它通過連接到偵聽器的 socket 執行日誌記錄"

#: ../../howto/logging-cookbook.rst:799
#, fuzzy
msgid ":file:`webapp.json`"
msgstr ":file:`webapp.json`"

#: ../../howto/logging-cookbook.rst:799
#, fuzzy
msgid "A JSON configuration file for the web application"
msgstr "Web 應用程式的 JSON 配置文件"

#: ../../howto/logging-cookbook.rst:801
#, fuzzy
msgid ":file:`client.py`"
msgstr ":file:`客戶端.py`"

#: ../../howto/logging-cookbook.rst:801
#, fuzzy
msgid "A Python script to exercise the web application"
msgstr "用於運行 Web 應用程式的 Python 腳本"

#: ../../howto/logging-cookbook.rst:804
#, fuzzy
msgid ""
"The web application uses `Gunicorn <https://gunicorn.org/>`_, which is a "
"popular web application server that starts multiple worker processes to "
"handle requests. This example setup shows how the workers can write to the "
"same log file without conflicting with one another --- they all go through "
"the socket listener."
msgstr ""
"Web 應用程式使用`Gunicorn <https://gunicorn.org/>`_，這是一種流行的 Web 應用"
"程式伺服器，它啟動多個工作行程來處理請求。這個示例設定顯示了工作人員如何在不"
"相互衝突的情況下寫入同一個日誌文件——他們都通過 socket 偵聽器。"

#: ../../howto/logging-cookbook.rst:809
#, fuzzy
msgid "To test these files, do the following in a POSIX environment:"
msgstr "要測試這些文件，請在 POSIX 環境中執行以下操作："

#: ../../howto/logging-cookbook.rst:811
#, fuzzy
msgid ""
"Download `the Gist <socket-listener-gist_>`__ as a ZIP archive using the :"
"guilabel:`Download ZIP` button."
msgstr ""
"使用 :guilabel:`Download ZIP` 按鈕下載 `Gist <socket-listener-gist_>`__ 作為 "
"ZIP 存檔。"

#: ../../howto/logging-cookbook.rst:814
#, fuzzy
msgid "Unzip the above files from the archive into a scratch directory."
msgstr "將上述文件從存檔中解壓縮到臨時目錄中。"

#: ../../howto/logging-cookbook.rst:816
#, fuzzy
msgid ""
"In the scratch directory, run ``bash prepare.sh`` to get things ready. This "
"creates a :file:`run` subdirectory to contain Supervisor-related and log "
"files, and a :file:`venv` subdirectory to contain a virtual environment into "
"which ``bottle``, ``gunicorn`` and ``supervisor`` are installed."
msgstr ""
"在 scratch 目錄中，運行 bash prepare.sh 準備好一切。這將建立一個 :file:`run` "
"子目錄來包含與 Supervisor 相關的文件和日誌文件，以及一個 :file:`venv` "
"子目錄來包含一個虛擬環境，``bottle``、``gunicorn`` 和 ``supervisor `` "
"已安裝。"

#: ../../howto/logging-cookbook.rst:821
#, fuzzy
msgid ""
"Run ``bash ensure_app.sh`` to ensure that Supervisor is running with the "
"above configuration."
msgstr "運行 ``bash ensure_app.sh`` 以確保 Supervisor 以上述配置運行。"

#: ../../howto/logging-cookbook.rst:824
#, fuzzy
msgid ""
"Run ``venv/bin/python client.py`` to exercise the web application, which "
"will lead to records being written to the log."
msgstr "運行 ``venv/bin/python client.py`` 運行 web "
"應用程式，這將導致記錄被寫入日誌。"

#: ../../howto/logging-cookbook.rst:827
#, fuzzy
msgid ""
"Inspect the log files in the :file:`run` subdirectory. You should see the "
"most recent log lines in files matching the pattern :file:`app.log*`. They "
"won't be in any particular order, since they have been handled concurrently "
"by different worker processes in a non-deterministic way."
msgstr ""
"檢查 :file:`run` 子目錄中的日誌文件。您應該會在與模式 :file:`app.log*` 匹配的"
"文件中看到最新的日誌行。它們不會有任何特定的順序，因為它們已經由不同的工作行"
"程以不確定的方式並發處理。"

#: ../../howto/logging-cookbook.rst:832
#, fuzzy
msgid ""
"You can shut down the listener and the web application by running ``venv/bin/"
"supervisorctl -c supervisor.conf shutdown``."
msgstr ""
"您可以通過運行 ``venv/bin/supervisorctl -c supervisor.conf shutdown`` "
"關閉偵聽器和 Web 應用程式。"

#: ../../howto/logging-cookbook.rst:835
#, fuzzy
msgid ""
"You may need to tweak the configuration files in the unlikely event that the "
"configured ports clash with something else in your test environment."
msgstr "萬一配置的端口與測試環境中的其他內容髮生衝突，您可能需要調整配置文件。"

#: ../../howto/logging-cookbook.rst:841
#, fuzzy
msgid "Adding contextual information to your logging output"
msgstr "將上下文資訊新增到日誌輸出"

#: ../../howto/logging-cookbook.rst:843
#, fuzzy
msgid ""
"Sometimes you want logging output to contain contextual information in "
"addition to the parameters passed to the logging call. For example, in a "
"networked application, it may be desirable to log client-specific "
"information in the log (e.g. remote client's username, or IP address). "
"Although you could use the *extra* parameter to achieve this, it's not "
"always convenient to pass the information in this way. While it might be "
"tempting to create :class:`Logger` instances on a per-connection basis, this "
"is not a good idea because these instances are not garbage collected. While "
"this is not a problem in practice, when the number of :class:`Logger` "
"instances is dependent on the level of granularity you want to use in "
"logging an application, it could be hard to manage if the number of :class:"
"`Logger` instances becomes effectively unbounded."
msgstr ""
"有時，除了傳遞給日誌記錄呼叫的參數之外，您還希望日誌記錄輸出包含上下文資訊。"
"例如，在網絡應用程式中，可能需要在日誌中記錄特定於客戶端的資訊（"
"例如遠程客戶端的使用者名或 IP 地址）。儘管您可以使用 *extra* "
"參數來實作此目的，但以這種方式傳遞資訊並不總是很方便。"
"雖然在每個連接的基礎上建立 :class:`Logger` 實例可能很誘人，但這不是一個好主意"
"，因為這些實例不會被垃圾收集。雖然這在實踐中不是問題，但當 Logger "
"實例的數量取決於您要在記錄應用程式時使用的粒度級別時，如果 :class: "
"的數量可能難以管理Logger 實例變得有效無界。"

#: ../../howto/logging-cookbook.rst:858
#, fuzzy
msgid "Using LoggerAdapters to impart contextual information"
msgstr "使用 LoggerAdapters 傳遞上下文資訊"

#: ../../howto/logging-cookbook.rst:860
#, fuzzy
msgid ""
"An easy way in which you can pass contextual information to be output along "
"with logging event information is to use the :class:`LoggerAdapter` class. "
"This class is designed to look like a :class:`Logger`, so that you can call :"
"meth:`debug`, :meth:`info`, :meth:`warning`, :meth:`error`, :meth:"
"`exception`, :meth:`critical` and :meth:`log`. These methods have the same "
"signatures as their counterparts in :class:`Logger`, so you can use the two "
"types of instances interchangeably."
msgstr ""
"傳遞上下文資訊與日誌事件資訊一起輸出的一種簡單方法是使用 "
":class:`LoggerAdapter` 類。這個類被設計成看起來像一個 :class:`Logger`，這樣"
"你就可以呼叫 :meth:`debug`， :meth:`info`， :meth:`warning`， :meth:`erro"
"r`，：meth :`exception`, :meth:`critical` 和 :meth:`log`。這些方法與 Logger "
"中的對應方法具有相同的簽名，因此您可以互換使用這兩種型別的實例。"

#: ../../howto/logging-cookbook.rst:868
#, fuzzy
msgid ""
"When you create an instance of :class:`LoggerAdapter`, you pass it a :class:"
"`Logger` instance and a dict-like object which contains your contextual "
"information. When you call one of the logging methods on an instance of :"
"class:`LoggerAdapter`, it delegates the call to the underlying instance of :"
"class:`Logger` passed to its constructor, and arranges to pass the "
"contextual information in the delegated call. Here's a snippet from the code "
"of :class:`LoggerAdapter`::"
msgstr ""
"當您建立 :class:`LoggerAdapter` 的實例時，您將傳遞給它一個 :class:`Logger` "
"實例和一個包含上下文資訊的類字典物件。當您在 :class:`LoggerAdapter` "
"的實例上呼叫其中一種日誌記錄方法時，它將呼叫委託給傳遞給其構造函式的 "
":class:`Logger` 的基礎實例，並安排在委託呼叫中傳遞上下文資訊.這是 "
":class:`LoggerAdapter`:: 的程式碼片段："

#: ../../howto/logging-cookbook.rst:884
#, fuzzy
msgid ""
"The :meth:`~LoggerAdapter.process` method of :class:`LoggerAdapter` is where "
"the contextual information is added to the logging output. It's passed the "
"message and keyword arguments of the logging call, and it passes back "
"(potentially) modified versions of these to use in the call to the "
"underlying logger. The default implementation of this method leaves the "
"message alone, but inserts an 'extra' key in the keyword argument whose "
"value is the dict-like object passed to the constructor. Of course, if you "
"had passed an 'extra' keyword argument in the call to the adapter, it will "
"be silently overwritten."
msgstr ""
"LoggerAdapter 的 :meth:`~LoggerAdapter.process 方法是將上下文資訊新增到日誌輸"
"出的地方。它傳遞了日誌記錄呼叫的消息和關鍵字參數，並將它們（可能）修改後的版"
"本傳回以用於對底層記錄器的呼叫。此方法的預設實作單獨保留消息，但在關鍵字參數"
"中插入一個“額外”鍵，其值是傳遞給構造函式的類字典物件。當然，如果您在對適配器"
"的呼叫中傳遞了一個“額外”關鍵字參數，它將被靜默覆蓋。"

#: ../../howto/logging-cookbook.rst:893
#, fuzzy
msgid ""
"The advantage of using 'extra' is that the values in the dict-like object "
"are merged into the :class:`LogRecord` instance's __dict__, allowing you to "
"use customized strings with your :class:`Formatter` instances which know "
"about the keys of the dict-like object. If you need a different method, e.g. "
"if you want to prepend or append the contextual information to the message "
"string, you just need to subclass :class:`LoggerAdapter` and override :meth:"
"`~LoggerAdapter.process` to do what you need. Here is a simple example::"
msgstr ""
"使用 'extra' 的優點是類字典對像中的值被合併到 LogRecord 實例的 __dict__ 中，"
"允許您將自定義字串與知道鍵的 Formatter 實例一起使用類似字典的物件。如果您需要"
"不同的方法，例如如果你想將上下文資訊新增到消息字串中，你只需要繼承 "
"LoggerAdapter 並覆蓋 :meth:`~LoggerAdapter.process` "
"來做你需要的。這是一個簡單的例子::"

#: ../../howto/logging-cookbook.rst:909
#, fuzzy
msgid "which you can use like this::"
msgstr "你可以像這樣使用::"

#: ../../howto/logging-cookbook.rst:914
#, fuzzy
msgid ""
"Then any events that you log to the adapter will have the value of "
"``some_conn_id`` prepended to the log messages."
msgstr "然後，您記錄到適配器的任何事件都將在日誌消息前加上 ``some_conn_id`` 的值。"

#: ../../howto/logging-cookbook.rst:918
#, fuzzy
msgid "Using objects other than dicts to pass contextual information"
msgstr "使用字典以外的對像傳遞上下文資訊"

#: ../../howto/logging-cookbook.rst:920
#, fuzzy
msgid ""
"You don't need to pass an actual dict to a :class:`LoggerAdapter` - you "
"could pass an instance of a class which implements ``__getitem__`` and "
"``__iter__`` so that it looks like a dict to logging. This would be useful "
"if you want to generate values dynamically (whereas the values in a dict "
"would be constant)."
msgstr ""
"您不需要將實際的字典傳遞給 :class:`LoggerAdapter` - 您可以傳遞一個實作了 "
"``__getitem__`` 和 ``__iter__`` 的類的實例，這樣它看起來就像一個用於日誌記錄"
"的字典。如果您想動態生成值（而字典中的值將是常數），這將很有用。"

#: ../../howto/logging-cookbook.rst:929
#, fuzzy
msgid "Using Filters to impart contextual information"
msgstr "使用過濾器傳遞上下文資訊"

#: ../../howto/logging-cookbook.rst:931
#, fuzzy
msgid ""
"You can also add contextual information to log output using a user-defined :"
"class:`Filter`. ``Filter`` instances are allowed to modify the "
"``LogRecords`` passed to them, including adding additional attributes which "
"can then be output using a suitable format string, or if needed a custom :"
"class:`Formatter`."
msgstr ""
"您還可以使用使用者定義的過濾器將上下文資訊新增到日誌輸出。 ``Filter`` "
"實例可以修改傳遞給它們的 ``LogRecords``，包括新增額外的屬性，然後可以使用合適"
"的格式字串輸出這些屬性，或者如果需要，可以使用自定義的 :class:`Formatter`。"

#: ../../howto/logging-cookbook.rst:936
#, fuzzy
msgid ""
"For example in a web application, the request being processed (or at least, "
"the interesting parts of it) can be stored in a threadlocal (:class:"
"`threading.local`) variable, and then accessed from a ``Filter`` to add, "
"say, information from the request - say, the remote IP address and remote "
"user's username - to the ``LogRecord``, using the attribute names 'ip' and "
"'user' as in the ``LoggerAdapter`` example above. In that case, the same "
"format string can be used to get similar output to that shown above. Here's "
"an example script::"
msgstr ""
"例如，在 Web 應用程式中，正在處理的請求（或者至少是其中有趣的部分）可以儲存在"
"執行緒本地（:class:`threading.local`）變數中，然後從``Filter`` "
"訪問將來自請求的資訊（例如，遠程 IP 地址和遠程使用者的使用者名）新增到 "
"``LogRecord``，使用上面``LoggerAdapter`` 示例中的屬性名稱 ``ip``和 ``user`` .在這種"
"情況下，可以使用相同的格式字串來獲得與上面所示類似的輸出。這是一個示例腳本::"

#: ../../howto/logging-cookbook.rst:982
#, fuzzy
msgid "which, when run, produces something like:"
msgstr "它在運行時會產生如下內容："

#: ../../howto/logging-cookbook.rst:1000
#, fuzzy
msgid "Use of ``contextvars``"
msgstr "使用``contextvars``"

#: ../../howto/logging-cookbook.rst:1002
#, fuzzy
msgid ""
"Since Python 3.7, the :mod:`contextvars` module has provided context-local "
"storage which works for both :mod:`threading` and :mod:`asyncio` processing "
"needs. This type of storage may thus be generally preferable to thread-"
"locals. The following example shows how, in a multi-threaded environment, "
"logs can populated with contextual information such as, for example, request "
"attributes handled by web applications."
msgstr ""
"從 Python 3.7 開始，:mod:`contextvars` "
"模組提供了上下文本地儲存，適用於 :mod:`threading` 和 :mod:`asyncio` 處理需求。"
"因此，這種型別的儲存通常比執行緒局部儲存更可取。以下示例顯示了在多執行緒環境"
"中，日誌如何填充上下文資訊，例如 Web 應用程式處理的請求屬性。"

#: ../../howto/logging-cookbook.rst:1008
#, fuzzy
msgid ""
"For the purposes of illustration, say that you have different web "
"applications, each independent of the other but running in the same Python "
"process and using a library common to them. How can each of these "
"applications have their own log, where all logging messages from the library "
"(and other request processing code) are directed to the appropriate "
"application's log file, while including in the log additional contextual "
"information such as client IP, HTTP request method and client username?"
msgstr ""
"為了便於說明，假設您有不同的 Web 應用程式，每個應用程式彼此獨立，但在同一個 "
"Python 行程中運行並使用它們通用的庫。這些應用程式中的每一個如何擁有自己的日誌"
"，其中來自庫的所有日誌記錄消息（和其他請求處理程式碼）都被定向到適當應用程式"
"的日誌文件，同時在日誌中包含其他上下文資訊，例如客戶端 IP、HTTP "
"請求方法和客戶使用者名？"

#: ../../howto/logging-cookbook.rst:1015
#, fuzzy
msgid "Let's assume that the library can be simulated by the following code:"
msgstr "假設可以通過以下程式碼模擬該庫："

#: ../../howto/logging-cookbook.rst:1031
#, fuzzy
msgid ""
"We can simulate the multiple web applications by means of two simple "
"classes, ``Request`` and ``WebApp``. These simulate how real threaded web "
"applications work - each request is handled by a thread:"
msgstr ""
"我們可以通過兩個簡單的類``Request`` 和``WebApp`` 來模擬多個Web 應用程式。"
"這些模擬了真正的執行緒 Web 應用程式是如何工作的——每個請求都由一個執行緒處理："

#: ../../howto/logging-cookbook.rst:1175
#, fuzzy
msgid ""
"If you run the above, you should find that roughly half the requests go "
"into :file:`app1.log` and the rest into :file:`app2.log`, and the all the "
"requests are logged to :file:`app.log`. Each webapp-specific log will "
"contain only log entries for only that webapp, and the request information "
"will be displayed consistently in the log (i.e. the information in each "
"dummy request will always appear together in a log line). This is "
"illustrated by the following shell output:"
msgstr ""
"如果你運行上面的程式碼，你會發現大約一半的請求進入 :file:`app1.log`，"
"其餘的進入 :file:`app2.log`，所有請求都記錄到 :file:`app .log`。每個特定於 "
"webapp 的日誌將僅包含該 webapp 的日誌條目，並且請求資訊將在日誌中一致顯示（即"
"，每個虛擬請求中的資訊將始終一起出現在日誌行中）。以下 shell "
"輸出說明了這一點："

#: ../../howto/logging-cookbook.rst:1222
#, fuzzy
msgid "Imparting contextual information in handlers"
msgstr "在處理程式中傳遞上下文資訊"

#: ../../howto/logging-cookbook.rst:1224
#, fuzzy
msgid ""
"Each :class:`~Handler` has its own chain of filters. If you want to add "
"contextual information to a :class:`LogRecord` without leaking it to other "
"handlers, you can use a filter that returns a new :class:`~LogRecord` "
"instead of modifying it in-place, as shown in the following script::"
msgstr ""
"每個 :class:`~Handler` 都有自己的過濾器鏈。如果您想將上下文資訊新增到 "
":class:`LogRecord` 而不將其洩露給其他處理程式，"
"您可以使用一個過濾器來回傳一個新的 :class:`~LogRecord` "
"而不是就地修改它，如以下腳本::"

#: ../../howto/logging-cookbook.rst:1251
#, fuzzy
msgid "Logging to a single file from multiple processes"
msgstr "從多個行程記錄到單個文件"

#: ../../howto/logging-cookbook.rst:1253
#, fuzzy
msgid ""
"Although logging is thread-safe, and logging to a single file from multiple "
"threads in a single process *is* supported, logging to a single file from "
"*multiple processes* is *not* supported, because there is no standard way to "
"serialize access to a single file across multiple processes in Python. If "
"you need to log to a single file from multiple processes, one way of doing "
"this is to have all the processes log to a :class:`~handlers.SocketHandler`, "
"and have a separate process which implements a socket server which reads "
"from the socket and logs to file. (If you prefer, you can dedicate one "
"thread in one of the existing processes to perform this function.) :ref:"
"`This section <network-logging>` documents this approach in more detail and "
"includes a working socket receiver which can be used as a starting point for "
"you to adapt in your own applications."
msgstr ""
"儘管日誌記錄是執行緒安全的，並且*支援*從單個行程中的多個執行緒記錄到單個文件"
"，但*不*支援從*多個行程*記錄到單個文件，因為沒有標準的方法來序列化訪問到 "
"Python 中跨多個行程的單個文件。如果您需要從多個行程記錄到單個文件，"
"一種方法是讓所有行程記錄到一個 :class:`~handlers.SocketHandler`，並有一個單獨"
"的行程實作一個 socket 伺服器，從 socket 並記錄到文件。 （如果您願意，您可以在現有"
"行程之一中指定一個執行緒來執行此功能。）作為您適應自己的應用程式的起點。"

#: ../../howto/logging-cookbook.rst:1266
#, fuzzy
msgid ""
"You could also write your own handler which uses the :class:"
"`~multiprocessing.Lock` class from the :mod:`multiprocessing` module to "
"serialize access to the file from your processes. The existing :class:"
"`FileHandler` and subclasses do not make use of :mod:`multiprocessing` at "
"present, though they may do so in the future. Note that at present, the :mod:"
"`multiprocessing` module does not provide working lock functionality on all "
"platforms (see https://bugs.python.org/issue3770)."
msgstr ""
"您還可以編寫自己的處理程式，它使用 :mod:`multiprocessing` 模組中的 "
":class:`~multiprocessing.Lock` 類來序列化行程對文件的訪問。現有的 "
":class:`FileHandler` 和子類別目前不使用 :mod:`multiprocessing`，儘管他們將來"
"可能會這樣做。請注意，目前，:mod:`multiprocessing` "
"模組並未在所有平台上提供工作鎖定功能（請參閱 https://bugs.python.org/"
"issue3770）。"

#: ../../howto/logging-cookbook.rst:1276
#, fuzzy
msgid ""
"Alternatively, you can use a ``Queue`` and a :class:`QueueHandler` to send "
"all logging events to one of the processes in your multi-process "
"application. The following example script demonstrates how you can do this; "
"in the example a separate listener process listens for events sent by other "
"processes and logs them according to its own logging configuration. Although "
"the example only demonstrates one way of doing it (for example, you may want "
"to use a listener thread rather than a separate listener process -- the "
"implementation would be analogous) it does allow for completely different "
"logging configurations for the listener and the other processes in your "
"application, and can be used as the basis for code meeting your own specific "
"requirements::"
msgstr ""
"或者，您可以使用 ``Queue`` 和 :class:`QueueHandler` 將所有日誌記錄事件發送到"
"多行程應用程式中的行程之一。以下示例腳本演示瞭如何執行此操作；在示例中，一個"
"單獨的偵聽器行程偵聽其他行程發送的事件，並根據自己的日誌記錄配置記錄它們。儘"
"管該示例僅演示了一種實作方法（例如，您可能希望使用偵聽器執行緒而不是單獨的偵"
"聽器行程——實作方式類似），但它確實允許偵聽器和另一個完全不同的日誌記錄配置您"
"的應用程式中的流程，並且可以用作滿足您自己的特定要求的程式碼的基礎::"

#: ../../howto/logging-cookbook.rst:1392
#, fuzzy
msgid ""
"A variant of the above script keeps the logging in the main process, in a "
"separate thread::"
msgstr "上述腳本的一個變體將日誌記錄保存在主行程中，在一個單獨的執行緒中::"

#: ../../howto/logging-cookbook.rst:1487
#, fuzzy
msgid ""
"This variant shows how you can e.g. apply configuration for particular "
"loggers - e.g. the ``foo`` logger has a special handler which stores all "
"events in the ``foo`` subsystem in a file ``mplog-foo.log``. This will be "
"used by the logging machinery in the main process (even though the logging "
"events are generated in the worker processes) to direct the messages to the "
"appropriate destinations."
msgstr ""
"此變體顯示了您如何可以，例如為特定記錄器應用配置 - 例如``foo`` "
"記錄器有一個特殊的處理程式，它將``foo`` 子系統中的所有事件儲存在文件``mplog-"
"foo.log`` 中。這將被主行程中的日誌記錄機制使用（即使日誌記錄事件是在工作行程"
"中生成的）將消息定向到適當的目的地。"

#: ../../howto/logging-cookbook.rst:1494
#, fuzzy
msgid "Using concurrent.futures.ProcessPoolExecutor"
msgstr "使用 concurrent.futures.ProcessPoolExecutor"

#: ../../howto/logging-cookbook.rst:1496
#, fuzzy
msgid ""
"If you want to use :class:`concurrent.futures.ProcessPoolExecutor` to start "
"your worker processes, you need to create the queue slightly differently. "
"Instead of"
msgstr ""
"如果你想使用 :class:`concurrent.futures.ProcessPoolExecutor` "
"來啟動你的工作行程，你需要稍微不同地建立隊列。代替"

#: ../../howto/logging-cookbook.rst:1504
#, fuzzy
msgid "you should use"
msgstr "你應該使用"

#: ../../howto/logging-cookbook.rst:1510
#, fuzzy
msgid "and you can then replace the worker creation from this::"
msgstr "然後您可以從此替換工人建立::"

#: ../../howto/logging-cookbook.rst:1521
#, fuzzy
msgid "to this (remembering to first import :mod:`concurrent.futures`)::"
msgstr "為此（記得首先導入 :mod:`concurrent.futures`)::"

#: ../../howto/logging-cookbook.rst:1528
#, fuzzy
msgid "Deploying Web applications using Gunicorn and uWSGI"
msgstr "使用 Gunicorn 和 uWSGI 部署 Web 應用程式"

#: ../../howto/logging-cookbook.rst:1530
#, fuzzy
msgid ""
"When deploying Web applications using `Gunicorn <https://gunicorn.org/>`_ or "
"`uWSGI <https://uwsgi-docs.readthedocs.io/en/latest/>`_ (or similar), "
"multiple worker processes are created to handle client requests. In such "
"environments, avoid creating file-based handlers directly in your web "
"application. Instead, use a :class:`SocketHandler` to log from the web "
"application to a listener in a separate process. This can be set up using a "
"process management tool such as Supervisor - see `Running a logging socket "
"listener in production`_ for more details."
msgstr ""
"使用`Gunicorn <https://gunicorn.org/>`_ 或`uWSGI <https://uwsgi-docs."
"readthedocs.io/en/latest/>`_（或類似）部署 Web "
"應用程式時，多個工作行程建立來處理客戶端請求。在此類環境中，請避免直接在您的 "
"Web 應用程式中建立基於文件的處理程式。相反，使用 :class:`SocketHandler` 將 "
"Web 應用程式的日誌記錄到單獨行程中的偵聽器。這可以使用諸如 Supervisor 之類的"
"行程管理工具來設定——有關更多詳細資訊，請參閱“在生產中運行日誌 socket 偵聽器”。"

#: ../../howto/logging-cookbook.rst:1540
#, fuzzy
msgid "Using file rotation"
msgstr "使用文件輪換"

#: ../../howto/logging-cookbook.rst:1545
#, fuzzy
msgid ""
"Sometimes you want to let a log file grow to a certain size, then open a new "
"file and log to that. You may want to keep a certain number of these files, "
"and when that many files have been created, rotate the files so that the "
"number of files and the size of the files both remain bounded. For this "
"usage pattern, the logging package provides a :class:`~handlers."
"RotatingFileHandler`::"
msgstr ""
"有時您想讓日誌文件增長到一定大小，然後打開一個新文件並記錄到該文件。您可能希"
"望保留一定數量的這些文件，當建立了那麼多文件後，輪換文件以使文件數量和文件大"
"小都保持在一定範圍內。對於這種使用模式，日誌包提供了一個 :class:`~handlers."
"RotatingFileHandler`::"

#: ../../howto/logging-cookbook.rst:1577
#, fuzzy
msgid ""
"The result should be 6 separate files, each with part of the log history for "
"the application:"
msgstr "結果應該是 6 個單獨的文件，每個文件都有應用程式的部分日誌歷史記錄："

#: ../../howto/logging-cookbook.rst:1589
#, fuzzy
msgid ""
"The most current file is always :file:`logging_rotatingfile_example.out`, "
"and each time it reaches the size limit it is renamed with the suffix "
"``.1``. Each of the existing backup files is renamed to increment the suffix "
"(``.1`` becomes ``.2``, etc.)  and the ``.6`` file is erased."
msgstr ""
"最新的文件始終是 :file:`logging_rotatingfile_example."
"out`，每次達到大小限制時，它都會使用後綴 ``.1`` "
"重命名。每個現有的備份文件都被重命名以增加後綴（``.1`` 變為 ``.2`` 等）並且 "
"``.6`` 文件被刪除。"

#: ../../howto/logging-cookbook.rst:1594
#, fuzzy
msgid ""
"Obviously this example sets the log length much too small as an extreme "
"example.  You would want to set *maxBytes* to an appropriate value."
msgstr "顯然這個例子把日誌長度設定得太小了，作為一個極端的例子。您可能希望將 "
"*maxBytes* 設定為適當的值。"

#: ../../howto/logging-cookbook.rst:1600
#, fuzzy
msgid "Use of alternative formatting styles"
msgstr "使用替代格式樣式"

#: ../../howto/logging-cookbook.rst:1602
#, fuzzy
msgid ""
"When logging was added to the Python standard library, the only way of "
"formatting messages with variable content was to use the %-formatting "
"method. Since then, Python has gained two new formatting approaches: :class:"
"`string.Template` (added in Python 2.4) and :meth:`str.format` (added in "
"Python 2.6)."
msgstr ""
"當日誌記錄被新增到 Python 標準庫中時，"
"格式化具有可變內容的消息的唯一方法是使用 %-formatting 方法。從那時起，Python "
"獲得了兩種新的格式化方法：:class:`string.Template`（在 Python 2.4 "
"中新增）和 :meth:`str.format`（在 Python 2.6 中新增）。"

#: ../../howto/logging-cookbook.rst:1608
#, fuzzy
msgid ""
"Logging (as of 3.2) provides improved support for these two additional "
"formatting styles. The :class:`Formatter` class been enhanced to take an "
"additional, optional keyword parameter named ``style``. This defaults to "
"``'%'``, but other possible values are ``'{'`` and ``'$'``, which correspond "
"to the other two formatting styles. Backwards compatibility is maintained by "
"default (as you would expect), but by explicitly specifying a style "
"parameter, you get the ability to specify format strings which work with :"
"meth:`str.format` or :class:`string.Template`. Here's an example console "
"session to show the possibilities:"
msgstr ""
"日誌記錄（從 3.2 開始）為這兩種額外的格式樣式提供了改進的支援。 "
":class:`Formatter` 類已得到增強，可以採用一個名為 ``style`` "
"的附加可選關鍵字參數。這預設為 ``'%'``，但其他可能的值是 ``'{'`` 和 ``'$'``，"
"它們對應於其他兩種格式樣式。預設情況下保持向後相容性（正如您所期望的那樣），"
"但是通過顯式指定樣式參數，您可以指定與 :meth:`str.format` 或 :class:`string."
"Template` 一起使用的格式字串。這是一個示例控制台會話，用於顯示可能性："

#: ../../howto/logging-cookbook.rst:1642
#, fuzzy
msgid ""
"Note that the formatting of logging messages for final output to logs is "
"completely independent of how an individual logging message is constructed. "
"That can still use %-formatting, as shown here::"
msgstr "請注意，最終輸出到日誌的日誌消息的格式完全獨立於單個日誌消息的構造方式。"
"仍然可以使用 % 格式，如下所示："

#: ../../howto/logging-cookbook.rst:1650
#, fuzzy
msgid ""
"Logging calls (``logger.debug()``, ``logger.info()`` etc.) only take "
"positional parameters for the actual logging message itself, with keyword "
"parameters used only for determining options for how to handle the actual "
"logging call (e.g. the ``exc_info`` keyword parameter to indicate that "
"traceback information should be logged, or the ``extra`` keyword parameter "
"to indicate additional contextual information to be added to the log). So "
"you cannot directly make logging calls using :meth:`str.format` or :class:"
"`string.Template` syntax, because internally the logging package uses %-"
"formatting to merge the format string and the variable arguments. There "
"would be no changing this while preserving backward compatibility, since all "
"logging calls which are out there in existing code will be using %-format "
"strings."
msgstr ""
"記錄呼叫（``logger.debug()``、``logger.info()`` 等）僅採用實際記錄消息本身的"
"位置參數，關鍵字參數僅用於確定如何處理實際記錄的選項日誌記錄呼叫（例如 "
"``exc_info`` 關鍵字參數指示應記錄回溯資訊，或 ``extra`` "
"關鍵字參數指示要新增到日誌中的附加上下文資訊）。因此，您不能直接使用 "
":meth:`str.format` 或 :class:`string.Template` 語法進行日誌呼叫，"
"因為日誌包在內部使用 %-formatting "
"來合併格式字串和變數參數。在保持向後相容性的同時不會改變這一點，"
"因為現有程式碼中的所有日誌記錄呼叫都將使用 %-format 字串。"

#: ../../howto/logging-cookbook.rst:1663
#, fuzzy
msgid ""
"There is, however, a way that you can use {}- and $- formatting to construct "
"your individual log messages. Recall that for a message you can use an "
"arbitrary object as a message format string, and that the logging package "
"will call ``str()`` on that object to get the actual format string. Consider "
"the following two classes::"
msgstr ""
"但是，有一種方法可以使用 {}- 和 $- 格式來構建您的個人日誌消息。回想一下，對於"
"一條消息，您可以使用任意對像作為消息格式字串，並且日誌記錄包將對該物件呼叫 "
"``str()`` 以獲取實際的格式字串。考慮以下兩個類："

#: ../../howto/logging-cookbook.rst:1687
#, fuzzy
msgid ""
"Either of these can be used in place of a format string, to allow {}- or $-"
"formatting to be used to build the actual \"message\" part which appears in "
"the formatted log output in place of \"%(message)s\" or \"{message}\" or "
"\"$message\". It's a little unwieldy to use the class names whenever you "
"want to log something, but it's quite palatable if you use an alias such as "
"__ (double underscore --- not to be confused with _, the single underscore "
"used as a synonym/alias for :func:`gettext.gettext` or its brethren)."
msgstr ""
"這些中的任何一個都可以用來代替格式字串，以允許使用 {}- 或 $-formatting 來構建"
"實際的“消息”部分，該部分出現在格式化日誌輸出中代替“%(message)s”或“{message}”"
"或“$message”。每當你想記錄一些東西時使用類名有點笨拙，但如果你使用別名如 __ "
"（雙底線---不要與 _ 混淆，單底線用作同義詞/別名）對於 :func:`gettext."
"gettext` 或其兄弟）。"

#: ../../howto/logging-cookbook.rst:1695
#, fuzzy
msgid ""
"The above classes are not included in Python, though they're easy enough to "
"copy and paste into your own code. They can be used as follows (assuming "
"that they're declared in a module called ``wherever``):"
msgstr ""
"上面的類不包含在 Python 中，儘管它們很容易複製並粘貼到您自己的程式碼中。它們"
"可以按如下方式使用（假設它們在名為 ``wherever`` 的模組中聲明）："

#: ../../howto/logging-cookbook.rst:1717
#, fuzzy
msgid ""
"While the above examples use ``print()`` to show how the formatting works, "
"you would of course use ``logger.debug()`` or similar to actually log using "
"this approach."
msgstr ""
"雖然上面的示例使用 ``print()`` 來顯示格式化的工作原理，但您當然可以使用 "
"``logger.debug()`` 或類似的方法來使用這種方法進行實際記錄。"

#: ../../howto/logging-cookbook.rst:1721
#, fuzzy
msgid ""
"One thing to note is that you pay no significant performance penalty with "
"this approach: the actual formatting happens not when you make the logging "
"call, but when (and if) the logged message is actually about to be output to "
"a log by a handler. So the only slightly unusual thing which might trip you "
"up is that the parentheses go around the format string and the arguments, "
"not just the format string. That's because the __ notation is just syntax "
"sugar for a constructor call to one of the XXXMessage classes."
msgstr ""
"需要注意的一件事是，您使用這種方法不會付出明顯的性能損失：實際的格式化不是在"
"您進行日誌記錄呼叫時發生的，而是在（以及是否）記錄的消息實際上將由處理程式輸"
"出到日誌中時發生的。因此，唯一可能使您感到困惑的稍微不尋常的事情是括號圍繞著"
"格式字串和參數，而不僅僅是格式字串。那是因為 __ 符號只是構造函式呼叫 "
"XXXMessage 類之一的語法糖。"

#: ../../howto/logging-cookbook.rst:1729
#, fuzzy
msgid ""
"If you prefer, you can use a :class:`LoggerAdapter` to achieve a similar "
"effect to the above, as in the following example::"
msgstr "如果您願意，可以使用 :class:`LoggerAdapter` "
"來實作與上述類似的效果，如以下示例所示："

#: ../../howto/logging-cookbook.rst:1760
#, fuzzy
msgid ""
"The above script should log the message ``Hello, world!`` when run with "
"Python 3.2 or later."
msgstr "當使用 Python 3.2 或更高版本運行時，上面的腳本應該記錄消息“Hello, world!”。"

#: ../../howto/logging-cookbook.rst:1769
#, fuzzy
msgid "Customizing ``LogRecord``"
msgstr "自定義 ``LogRecord``"

#: ../../howto/logging-cookbook.rst:1771
#, fuzzy
msgid ""
"Every logging event is represented by a :class:`LogRecord` instance. When an "
"event is logged and not filtered out by a logger's level, a :class:"
"`LogRecord` is created, populated with information about the event and then "
"passed to the handlers for that logger (and its ancestors, up to and "
"including the logger where further propagation up the hierarchy is "
"disabled). Before Python 3.2, there were only two places where this creation "
"was done:"
msgstr ""
"每個日誌記錄事件都由一個 :class:`LogRecord` "
"實例表示。當一個事件被記錄並且沒有被記錄器的級別過濾掉時，一個 "
":class:`LogRecord` 被建立，填充了關於事件的資訊，然後傳遞給該記錄器的處理程式"
"（及其祖先，直到並包括記錄器其中禁用進一步向上傳播層次結構）。在 Python 3.2 "
"之前，只有兩個地方可以完成這個建立："

#: ../../howto/logging-cookbook.rst:1778
#, fuzzy
msgid ""
":meth:`Logger.makeRecord`, which is called in the normal process of logging "
"an event. This invoked :class:`LogRecord` directly to create an instance."
msgstr ""
":meth:`Logger.makeRecord`，在記錄事件的正常過程中呼叫。這直接呼叫了 "
":class:`LogRecord` 來建立一個實例。"

#: ../../howto/logging-cookbook.rst:1781
#, fuzzy
msgid ""
":func:`makeLogRecord`, which is called with a dictionary containing "
"attributes to be added to the LogRecord. This is typically invoked when a "
"suitable dictionary has been received over the network (e.g. in pickle form "
"via a :class:`~handlers.SocketHandler`, or in JSON form via an :class:"
"`~handlers.HTTPHandler`)."
msgstr ""
":func:`makeLogRecord`，使用包含要新增到 LogRecord "
"的屬性的字典呼叫。這通常在通過網絡接收到合適的字典時呼叫（例如，通過 "
":class:`~handlers.SocketHandler` 以 pickle 形式，或通過 :class:`~handlers."
"HTTPHandler` 以 JSON 形式）。"

#: ../../howto/logging-cookbook.rst:1787
#, fuzzy
msgid ""
"This has usually meant that if you need to do anything special with a :class:"
"`LogRecord`, you've had to do one of the following."
msgstr "這通常意味著如果您需要對 :class:`LogRecord` "
"做任何特殊的事情，您必須執行以下操作之一。"

#: ../../howto/logging-cookbook.rst:1790
#, fuzzy
msgid ""
"Create your own :class:`Logger` subclass, which overrides :meth:`Logger."
"makeRecord`, and set it using :func:`~logging.setLoggerClass` before any "
"loggers that you care about are instantiated."
msgstr ""
"建立您自己的 Logger 子類別，它覆蓋 Logger.makeRecord，"
"並在實例化您關心的任何記錄器之前使用 ~logging.setLoggerClass 對其進行設定。"

#: ../../howto/logging-cookbook.rst:1793
#, fuzzy
msgid ""
"Add a :class:`Filter` to a logger or handler, which does the necessary "
"special manipulation you need when its :meth:`~Filter.filter` method is "
"called."
msgstr ""
"新增一個 :class:`Filter` 到記錄器或處理程式，當它的 :meth:`~Filter.filter` "
"方法被呼叫時，它會執行您需要的必要的特殊操作。"

#: ../../howto/logging-cookbook.rst:1797
#, fuzzy
msgid ""
"The first approach would be a little unwieldy in the scenario where (say) "
"several different libraries wanted to do different things. Each would "
"attempt to set its own :class:`Logger` subclass, and the one which did this "
"last would win."
msgstr ""
"在（比如說）幾個不同的圖書館想要做不同的事情的情況下，第一種方法會有點笨拙。"
"每個人都會嘗試設定自己的 :class:`Logger` 子類別，最後完成的那個將獲勝。"

#: ../../howto/logging-cookbook.rst:1802
#, fuzzy
msgid ""
"The second approach works reasonably well for many cases, but does not allow "
"you to e.g. use a specialized subclass of :class:`LogRecord`. Library "
"developers can set a suitable filter on their loggers, but they would have "
"to remember to do this every time they introduced a new logger (which they "
"would do simply by adding new packages or modules and doing ::"
msgstr ""
"第二種方法在許多情況下效果相當好，但不允許您例如使用 :class:`LogRecord` 的專"
"門子類別。庫開發人員可以在他們的記錄器上設定一個合適的過濾器，但他們必須記住"
"在每次引入新記錄器時都這樣做（他們只需新增新的包或模組並執行 ::"

#: ../../howto/logging-cookbook.rst:1810
#, fuzzy
msgid ""
"at module level). It's probably one too many things to think about. "
"Developers could also add the filter to a :class:`~logging.NullHandler` "
"attached to their top-level logger, but this would not be invoked if an "
"application developer attached a handler to a lower-level library logger --- "
"so output from that handler would not reflect the intentions of the library "
"developer."
msgstr ""
"在模組級別）。這可能是一件需要考慮的事情太多了。"
"開發人員還可以將過濾器新增到附加到其頂級記錄器的 :class:`~logging."
"NullHandler` 中，但是如果應用程式開發人員將處理程式附加到較低階別的庫記錄器，"
"則不會呼叫此過濾器 --- 所以輸出來自該處理程式的請求不會反映庫開發人員的意圖。"

#: ../../howto/logging-cookbook.rst:1816
#, fuzzy
msgid ""
"In Python 3.2 and later, :class:`~logging.LogRecord` creation is done "
"through a factory, which you can specify. The factory is just a callable you "
"can set with :func:`~logging.setLogRecordFactory`, and interrogate with :"
"func:`~logging.getLogRecordFactory`. The factory is invoked with the same "
"signature as the :class:`~logging.LogRecord` constructor, as :class:"
"`LogRecord` is the default setting for the factory."
msgstr ""
"在 Python 3.2 及更高版本中，:class:`~logging.LogRecord` "
"建立是通過您可以指定的工廠完成的。工廠只是一個可呼叫物件，您可以使用 "
":func:`~logging.setLogRecordFactory` 進行設定，並使用 :func:`~logging."
"getLogRecordFactory` 進行查詢。工廠使用與 :class:`~logging.LogRecord` "
"構造函式相同的簽名呼叫，因為 :class:`LogRecord` 是工廠的預設設定。"

#: ../../howto/logging-cookbook.rst:1823
#, fuzzy
msgid ""
"This approach allows a custom factory to control all aspects of LogRecord "
"creation. For example, you could return a subclass, or just add some "
"additional attributes to the record once created, using a pattern similar to "
"this::"
msgstr ""
"這種方法允許自定義工廠控制 LogRecord 建立的所有方面。例如，您可以回傳一個子類"
"別，或者在建立後僅向記錄新增一些附加屬性，使用類似於以下的模式："

#: ../../howto/logging-cookbook.rst:1836
#, fuzzy
msgid ""
"This pattern allows different libraries to chain factories together, and as "
"long as they don't overwrite each other's attributes or unintentionally "
"overwrite the attributes provided as standard, there should be no surprises. "
"However, it should be borne in mind that each link in the chain adds run-"
"time overhead to all logging operations, and the technique should only be "
"used when the use of a :class:`Filter` does not provide the desired result."
msgstr ""
"這種模式允許不同的庫將工廠鏈接在一起，只要它們不覆蓋彼此的屬性或無意中覆蓋作"
"為標準提供的屬性，就不會有意外。但是，應該記住鏈中的每個鏈接都會增加所有日誌"
"記錄操作的運行時開銷，並且只有在使用 Filter "
"不能提供所需結果時才應使用該技術。"

#: ../../howto/logging-cookbook.rst:1847
#, fuzzy
msgid "Subclassing QueueHandler - a ZeroMQ example"
msgstr "子類別化 QueueHandler - ZeroMQ 示例"

#: ../../howto/logging-cookbook.rst:1849
#, fuzzy
msgid ""
"You can use a :class:`QueueHandler` subclass to send messages to other kinds "
"of queues, for example a ZeroMQ 'publish' socket. In the example below,the "
"socket is created separately and passed to the handler (as its 'queue')::"
msgstr ""
"您可以使用 QueueHandler 子類別將消息發送到其他型別的隊列，例如 ZeroMQ“發布”套"
"接字。在下面的示例中， socket 是單獨建立的並傳遞給處理程式（作為其“隊列”）::"

#: ../../howto/logging-cookbook.rst:1868
#, fuzzy
msgid ""
"Of course there are other ways of organizing this, for example passing in "
"the data needed by the handler to create the socket::"
msgstr "當然還有其他組織方式，例如傳遞處理程式建立 socket 所需的資料::"

#: ../../howto/logging-cookbook.rst:1886
#, fuzzy
msgid "Subclassing QueueListener - a ZeroMQ example"
msgstr "子類別化 QueueListener - ZeroMQ 示例"

#: ../../howto/logging-cookbook.rst:1888
#, fuzzy
msgid ""
"You can also subclass :class:`QueueListener` to get messages from other "
"kinds of queues, for example a ZeroMQ 'subscribe' socket. Here's an example::"
msgstr "您還可以繼承 QueueListener 以從其他型別的隊列獲取消息，例如 "
"ZeroMQ“訂閱” socket 。這是一個例子::"

#: ../../howto/logging-cookbook.rst:1907 ../../howto/logging-cookbook.rst:3948
msgid "Module :mod:`logging`"
msgstr ":mod:`logging` 模組"

#: ../../howto/logging-cookbook.rst:1907 ../../howto/logging-cookbook.rst:3948
#, fuzzy
msgid "API reference for the logging module."
msgstr "日誌記錄模組的 API 參考。"

#: ../../howto/logging-cookbook.rst:1910 ../../howto/logging-cookbook.rst:3951
msgid "Module :mod:`logging.config`"
msgstr ":mod:`logging.config` 模組"

#: ../../howto/logging-cookbook.rst:1910 ../../howto/logging-cookbook.rst:3951
#, fuzzy
msgid "Configuration API for the logging module."
msgstr "日誌記錄模組的配置 API。"

#: ../../howto/logging-cookbook.rst:1913 ../../howto/logging-cookbook.rst:3954
msgid "Module :mod:`logging.handlers`"
msgstr ":mod:`logging.handlers` 模組"

#: ../../howto/logging-cookbook.rst:1913 ../../howto/logging-cookbook.rst:3954
#, fuzzy
msgid "Useful handlers included with the logging module."
msgstr "日誌記錄模組中包含有用的處理程式。"

#: ../../howto/logging-cookbook.rst:1915
#, fuzzy
msgid ":ref:`A basic logging tutorial <logging-basic-tutorial>`"
msgstr ":ref:`基本的日誌記錄教程 <logging-basic-tutorial>`"

#: ../../howto/logging-cookbook.rst:1917
#, fuzzy
msgid ":ref:`A more advanced logging tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`更高階的日誌記錄教程 <logging-advanced-tutorial>`"

#: ../../howto/logging-cookbook.rst:1921
#, fuzzy
msgid "An example dictionary-based configuration"
msgstr "基於字典的配置示例"

#: ../../howto/logging-cookbook.rst:1923
#, fuzzy
msgid ""
"Below is an example of a logging configuration dictionary - it's taken from "
"the `documentation on the Django project <https://docs.djangoproject.com/en/"
"stable/topics/logging/#configuring-logging>`_. This dictionary is passed to :"
"func:`~config.dictConfig` to put the configuration into effect::"
msgstr ""
"下面是日誌記錄配置字典的示例 - 它取自`Django 項目文檔 <https://docs."
"djangoproject.com/en/stable/topics/logging/#configuring-logging>`_。"
"這個字典被傳遞給 :func:`~config.dictConfig` 使配置生效::"

#: ../../howto/logging-cookbook.rst:1979
#, fuzzy
msgid ""
"For more information about this configuration, you can see the `relevant "
"section <https://docs.djangoproject.com/en/stable/topics/logging/"
"#configuring-logging>`_ of the Django documentation."
msgstr ""
"有關此配置的更多資訊，您可以參閱 Django 文檔的`相關部分 <https://docs."
"djangoproject.com/en/stable/topics/logging/#configuring-logging>`_。"

#: ../../howto/logging-cookbook.rst:1986
#, fuzzy
msgid "Using a rotator and namer to customize log rotation processing"
msgstr "使用旋轉器和命名器自定義日誌旋轉處理"

#: ../../howto/logging-cookbook.rst:1988
#, fuzzy
msgid ""
"An example of how you can define a namer and rotator is given in the "
"following runnable script, which shows gzip compression of the log file::"
msgstr "以下可運行腳本給出瞭如何定義命名器和旋轉器的示例，該腳本顯示了日誌文件的 "
"gzip 壓縮："

#: ../../howto/logging-cookbook.rst:2019
#, fuzzy
msgid ""
"After running this, you will see six new files, five of which are compressed:"
msgstr "運行此命令後，您將看到六個新文件，其中五個是壓縮文件："

#: ../../howto/logging-cookbook.rst:2032
#, fuzzy
msgid "A more elaborate multiprocessing example"
msgstr "一個更詳細的多處理示例"

#: ../../howto/logging-cookbook.rst:2034
#, fuzzy
msgid ""
"The following working example shows how logging can be used with "
"multiprocessing using configuration files. The configurations are fairly "
"simple, but serve to illustrate how more complex ones could be implemented "
"in a real multiprocessing scenario."
msgstr "以下工作示例顯示瞭如何使用配置文件將日誌記錄與多處理一起使用。配置相當簡單，"
"但可以用來說明如何在真實的多處理場景中實作更複雜的配置。"

#: ../../howto/logging-cookbook.rst:2039
#, fuzzy
msgid ""
"In the example, the main process spawns a listener process and some worker "
"processes. Each of the main process, the listener and the workers have three "
"separate configurations (the workers all share the same configuration). We "
"can see logging in the main process, how the workers log to a QueueHandler "
"and how the listener implements a QueueListener and a more complex logging "
"configuration, and arranges to dispatch events received via the queue to the "
"handlers specified in the configuration. Note that these configurations are "
"purely illustrative, but you should be able to adapt this example to your "
"own scenario."
msgstr ""
"在示例中，主行程生成一個偵聽器行程和一些工作行程。每個主行程、偵聽器和工作人"
"員都有三個獨立的配置（工作人員都共享相同的配置）。我們可以看到主行程中的日誌"
"記錄，工作人員如何記錄到 QueueHandler 以及偵聽器如何實作 QueueListener 和更複"
"雜的日誌記錄配置，並安排將通過隊列接收的事件分派到配置中指定的處理程式。請注"
"意，這些配置純粹是說明性的，但您應該能夠根據自己的情況調整此示例。"

#: ../../howto/logging-cookbook.rst:2049
#, fuzzy
msgid ""
"Here's the script - the docstrings and the comments hopefully explain how it "
"works::"
msgstr "這是腳本 - 文檔字串和註釋有望解釋它是如何工作的::"

#: ../../howto/logging-cookbook.rst:2261
#, fuzzy
msgid "Inserting a BOM into messages sent to a SysLogHandler"
msgstr "將 BOM 插入到發送到 SysLogHandler 的消息中"

#: ../../howto/logging-cookbook.rst:2263
#, fuzzy
msgid ""
":rfc:`5424` requires that a Unicode message be sent to a syslog daemon as a "
"set of bytes which have the following structure: an optional pure-ASCII "
"component, followed by a UTF-8 Byte Order Mark (BOM), followed by Unicode "
"encoded using UTF-8. (See the :rfc:`relevant section of the specification "
"<5424#section-6>`.)"
msgstr ""
":rfc:`5424` 要求將 Unicode 消息作為一組具有以下結構的位元組發送到 syslog "
"守護行程：一個可選的純 ASCII 組件，後跟一個 UTF-8 位元組順序標記 (BOM)，"
"然後是使用 UTF-8 編碼的 Unicode。 （請參閱規範 <5424#section-6> 的 :rfc:` "
"相關部分。）"

#: ../../howto/logging-cookbook.rst:2269
#, fuzzy
msgid ""
"In Python 3.1, code was added to :class:`~logging.handlers.SysLogHandler` to "
"insert a BOM into the message, but unfortunately, it was implemented "
"incorrectly, with the BOM appearing at the beginning of the message and "
"hence not allowing any pure-ASCII component to appear before it."
msgstr ""
"在 Python 3.1 中，程式碼被新增到 :class:`~logging.handlers.SysLogHandler` "
"以在消息中插入 BOM，但不幸的是，它實作不正確，BOM 出現在消息的開頭，"
"因此不允許任何純 ASCII 組件出現在它之前。"

#: ../../howto/logging-cookbook.rst:2275
#, fuzzy
msgid ""
"As this behaviour is broken, the incorrect BOM insertion code is being "
"removed from Python 3.2.4 and later. However, it is not being replaced, and "
"if you want to produce :rfc:`5424`-compliant messages which include a BOM, "
"an optional pure-ASCII sequence before it and arbitrary Unicode after it, "
"encoded using UTF-8, then you need to do the following:"
msgstr ""
"由於此行為被破壞，因此從 Python 3.2.4 及更高版本中刪除了不正確的 BOM "
"插入程式碼。但是，它沒有被替換，如果你想生成符合 :rfc:`5424` 的消息，"
"其中包括一個 BOM，一個可選的純 ASCII 序列在它之前，它之後是任意 Unicode，"
"使用 UTF-8 編碼，那麼你需要做以下事情："

#: ../../howto/logging-cookbook.rst:2281
#, fuzzy
msgid ""
"Attach a :class:`~logging.Formatter` instance to your :class:`~logging."
"handlers.SysLogHandler` instance, with a format string such as::"
msgstr ""
"將 :class:`~logging.Formatter` 實例附加到您的 :class:`~logging.handlers."
"SysLogHandler` 實例，格式字串如下："

#: ../../howto/logging-cookbook.rst:2287
#, fuzzy
msgid ""
"The Unicode code point U+FEFF, when encoded using UTF-8, will be encoded as "
"a UTF-8 BOM -- the byte-string ``b'\\xef\\xbb\\xbf'``."
msgstr ""
"當使用 UTF-8 編碼時，Unicode 程式碼點 U+FEFF 將被編碼為 UTF-8 "
"BOM——位元組串 ``b'\\xef\\xbb\\xbf'``。"

#: ../../howto/logging-cookbook.rst:2290
#, fuzzy
msgid ""
"Replace the ASCII section with whatever placeholders you like, but make sure "
"that the data that appears in there after substitution is always ASCII (that "
"way, it will remain unchanged after UTF-8 encoding)."
msgstr ""
"用你喜歡的任何占位符替換 ASCII 部分，但要確保替換後出現"
"在其中的資料始終是 ASCII（這樣，它在 UTF-8 編碼後將保持不變）。"

#: ../../howto/logging-cookbook.rst:2294
#, fuzzy
msgid ""
"Replace the Unicode section with whatever placeholders you like; if the data "
"which appears there after substitution contains characters outside the ASCII "
"range, that's fine -- it will be encoded using UTF-8."
msgstr ""
"用你喜歡的任何占位符替換 Unicode 部分；如果替換後出現"
"在那裡的資料包含 ASCII 範圍之外的字元，那很好——它將使用 UTF-8 編碼。"

#: ../../howto/logging-cookbook.rst:2298
#, fuzzy
msgid ""
"The formatted message *will* be encoded using UTF-8 encoding by "
"``SysLogHandler``. If you follow the above rules, you should be able to "
"produce :rfc:`5424`-compliant messages. If you don't, logging may not "
"complain, but your messages will not be RFC 5424-compliant, and your syslog "
"daemon may complain."
msgstr ""
"格式化消息*將*由``SysLogHandler``使用UTF-8編碼進行編碼。如果您遵循上述規則，"
"您應該能夠生成符合 :rfc:`5424` 的消息。如果不這樣做，日誌記錄可能不會抱怨，"
"但您的消息將不符合 RFC 5424，並且您的系統日誌守護程式可能會抱怨。"

#: ../../howto/logging-cookbook.rst:2305
#, fuzzy
msgid "Implementing structured logging"
msgstr "實施結構化日誌記錄"

#: ../../howto/logging-cookbook.rst:2307
#, fuzzy
msgid ""
"Although most logging messages are intended for reading by humans, and thus "
"not readily machine-parseable, there might be circumstances where you want "
"to output messages in a structured format which *is* capable of being parsed "
"by a program (without needing complex regular expressions to parse the log "
"message). This is straightforward to achieve using the logging package. "
"There are a number of ways in which this could be achieved, but the "
"following is a simple approach which uses JSON to serialise the event in a "
"machine-parseable manner::"
msgstr ""
"儘管大多數日誌消息旨在供人類閱讀，因此不易被機器解析，但在某些情況下，您可能"
"希望以結構化格式輸出消息，這種格式*能夠*被程式解析（不需要復雜的正則表達式）"
"解析日誌消息）。使用 logging "
"包可以直接實作這一點。有多種方法可以實作這一點，但以下是一種簡單的方法，"
"它使用 JSON 以機器可解析的方式序列化事件："

#: ../../howto/logging-cookbook.rst:2331
#, fuzzy
msgid "If the above script is run, it prints:"
msgstr "如果運行上面的腳本，它會印出："

#: ../../howto/logging-cookbook.rst:2337 ../../howto/logging-cookbook.rst:2379
#, fuzzy
msgid ""
"Note that the order of items might be different according to the version of "
"Python used."
msgstr "請注意，項目的順序可能會根據使用的 Python 版本而有所不同。"

#: ../../howto/logging-cookbook.rst:2340
#, fuzzy
msgid ""
"If you need more specialised processing, you can use a custom JSON encoder, "
"as in the following complete example::"
msgstr "如果您需要更專業的處理，您可以使用自定義 JSON 編碼器，如以下完整示例所示："

#: ../../howto/logging-cookbook.rst:2373
#, fuzzy
msgid "When the above script is run, it prints:"
msgstr "當上面的腳本運行時，它會印出："

#: ../../howto/logging-cookbook.rst:2388
#, fuzzy
msgid "Customizing handlers with :func:`dictConfig`"
msgstr "使用 :func:`dictConfig` 自定義處理程式"

#: ../../howto/logging-cookbook.rst:2390
#, fuzzy
msgid ""
"There are times when you want to customize logging handlers in particular "
"ways, and if you use :func:`dictConfig` you may be able to do this without "
"subclassing. As an example, consider that you may want to set the ownership "
"of a log file. On POSIX, this is easily done using :func:`shutil.chown`, but "
"the file handlers in the stdlib don't offer built-in support. You can "
"customize handler creation using a plain function such as::"
msgstr ""
"有時您希望以特定方式自定義日誌記錄處理程式，如果您使用 :func:`dictConfig`，您"
"可以在不子類別化的情況下執行此操作。例如，假設您可能想要設定日誌文件的所有權"
"。在 POSIX 上，使用 :func:`shutil.chown` 很容易做到這一點，但 stdlib "
"中的文件處理程式不提供內建支援。您可以使用普通函式自定義處理程式建立，例如："

#: ../../howto/logging-cookbook.rst:2404
#, fuzzy
msgid ""
"You can then specify, in a logging configuration passed to :func:"
"`dictConfig`, that a logging handler be created by calling this function::"
msgstr "然後，您可以在傳遞給 :func:`dictConfig` "
"的日誌配置中指定通過呼叫此函式建立日誌處理程式::"

#: ../../howto/logging-cookbook.rst:2437
#, fuzzy
msgid ""
"In this example I am setting the ownership using the ``pulse`` user and "
"group, just for the purposes of illustration. Putting it together into a "
"working script, ``chowntest.py``::"
msgstr "在此示例中，我使用 ``pulse`` "
"使用者和組設定所有權，僅用於說明目的。把它放在一個工作腳本中，``chowntest."
"py``::"

#: ../../howto/logging-cookbook.rst:2484
#, fuzzy
msgid "To run this, you will probably need to run as ``root``:"
msgstr "要運行它，您可能需要以 ``root`` 身份運行："

#: ../../howto/logging-cookbook.rst:2494
#, fuzzy
msgid ""
"Note that this example uses Python 3.3 because that's where :func:`shutil."
"chown` makes an appearance. This approach should work with any Python "
"version that supports :func:`dictConfig` - namely, Python 2.7, 3.2 or later. "
"With pre-3.3 versions, you would need to implement the actual ownership "
"change using e.g. :func:`os.chown`."
msgstr ""
"請注意，此示例使用 Python 3.3，因為這是 :func:`shutil.chown` 出現的地方。"
"這種方法應該適用於支援 :func:`dictConfig` 的任何 Python 版本——即 Python 2.7、"
"3.2 或更高版本。對於 3.3 之前的版本，您需要使用例如 :func:`os.chown`。"

#: ../../howto/logging-cookbook.rst:2500
#, fuzzy
msgid ""
"In practice, the handler-creating function may be in a utility module "
"somewhere in your project. Instead of the line in the configuration::"
msgstr "實際上，建立處理程式的函式可能位於項目中某處的實用程式模組中。而不是配置中的"
"行::"

#: ../../howto/logging-cookbook.rst:2505
#, fuzzy
msgid "you could use e.g.::"
msgstr "你可以使用例如："

#: ../../howto/logging-cookbook.rst:2509
#, fuzzy
msgid ""
"where ``project.util`` can be replaced with the actual name of the package "
"where the function resides. In the above working script, using ``'ext://"
"__main__.owned_file_handler'`` should work. Here, the actual callable is "
"resolved by :func:`dictConfig` from the ``ext://`` specification."
msgstr ""
"其中 ``project.util`` 可以替換為函式所在包的實際名稱。在上面的工作腳本中，"
"使用 ``'ext://__main__.owned_file_handler'`` 應該可以。在這裡，"
"實際的可呼叫物件由 ext:// 規範中的 :func:`dictConfig` 解析。"

#: ../../howto/logging-cookbook.rst:2514
#, fuzzy
msgid ""
"This example hopefully also points the way to how you could implement other "
"types of file change - e.g. setting specific POSIX permission bits - in the "
"same way, using :func:`os.chmod`."
msgstr ""
"希望這個例子也為您如何實作其他型別的文件更改指明了方向——例如設定特定的 POSIX "
"權限位 - 以同樣的方式，使用 :func:`os.chmod`。"

#: ../../howto/logging-cookbook.rst:2518
#, fuzzy
msgid ""
"Of course, the approach could also be extended to types of handler other "
"than a :class:`~logging.FileHandler` - for example, one of the rotating file "
"handlers, or a different type of handler altogether."
msgstr ""
"當然，該方法也可以擴充到 :class:`~logging.FileHandler` 以外的處理程式型別 - "
"例如，旋轉文件處理程式之一，或完全不同型別的處理程式。"

#: ../../howto/logging-cookbook.rst:2528
#, fuzzy
msgid "Using particular formatting styles throughout your application"
msgstr "在整個應用程式中使用特定的格式樣式"

#: ../../howto/logging-cookbook.rst:2530
#, fuzzy
msgid ""
"In Python 3.2, the :class:`~logging.Formatter` gained a ``style`` keyword "
"parameter which, while defaulting to ``%`` for backward compatibility, "
"allowed the specification of ``{`` or ``$`` to support the formatting "
"approaches supported by :meth:`str.format` and :class:`string.Template`. "
"Note that this governs the formatting of logging messages for final output "
"to logs, and is completely orthogonal to how an individual logging message "
"is constructed."
msgstr ""
"在 Python 3.2 中，:class:`~logging.Formatter` 獲得了一個 ``style`` "
"關鍵字參數，雖然為了向後相容而預設為 ``%``，但允許指定 ``{`` 或 ``$ `` 支援 "
":meth:`str.format` 和 :class:`string.Template` 支援的格式化方法。請注意，這控"
"制著最終輸出到日誌的日誌消息的格式，並且與單個日誌消息的構造方式完全正交。"

#: ../../howto/logging-cookbook.rst:2537
#, fuzzy
msgid ""
"Logging calls (:meth:`~Logger.debug`, :meth:`~Logger.info` etc.) only take "
"positional parameters for the actual logging message itself, with keyword "
"parameters used only for determining options for how to handle the logging "
"call (e.g. the ``exc_info`` keyword parameter to indicate that traceback "
"information should be logged, or the ``extra`` keyword parameter to indicate "
"additional contextual information to be added to the log). So you cannot "
"directly make logging calls using :meth:`str.format` or :class:`string."
"Template` syntax, because internally the logging package uses %-formatting "
"to merge the format string and the variable arguments. There would be no "
"changing this while preserving backward compatibility, since all logging "
"calls which are out there in existing code will be using %-format strings."
msgstr ""
"日誌記錄呼叫（:meth:`~Logger.debug`、:meth:`~Logger.info` 等）僅採用實際日誌"
"消息本身的位置參數，關鍵字參數僅用於確定如何處理日誌記錄的選項呼叫（例如 "
"``exc_info`` 關鍵字參數指示應記錄回溯資訊，或 ``extra`` "
"關鍵字參數指示要新增到日誌中的附加上下文資訊）。因此，您不能直接使用 "
":meth:`str.format` 或 :class:`string.Template` 語法進行日誌呼叫，"
"因為日誌包在內部使用 %-formatting "
"來合併格式字串和變數參數。在保持向後相容性的同時不會改變這一點，"
"因為現有程式碼中的所有日誌記錄呼叫都將使用 %-format 字串。"

#: ../../howto/logging-cookbook.rst:2549
#, fuzzy
msgid ""
"There have been suggestions to associate format styles with specific "
"loggers, but that approach also runs into backward compatibility problems "
"because any existing code could be using a given logger name and using %-"
"formatting."
msgstr ""
"有人建議將格式樣式與特定記錄器相關聯，但這種方法也會遇到向後相容性問題，"
"因為任何現有程式碼都可能使用給定的記錄器名稱並使用 %-formatting。"

#: ../../howto/logging-cookbook.rst:2553
#, fuzzy
msgid ""
"For logging to work interoperably between any third-party libraries and your "
"code, decisions about formatting need to be made at the level of the "
"individual logging call. This opens up a couple of ways in which alternative "
"formatting styles can be accommodated."
msgstr ""
"為了使日誌記錄能夠在任何第三方庫和您的程式碼之間互操作，需要在單個日誌記錄呼"
"叫級別做出有關格式化的決定。這開闢了幾種可以容納替代格式樣式的方法。"

#: ../../howto/logging-cookbook.rst:2560
#, fuzzy
msgid "Using LogRecord factories"
msgstr "使用 LogRecord 工廠"

#: ../../howto/logging-cookbook.rst:2562
#, fuzzy
msgid ""
"In Python 3.2, along with the :class:`~logging.Formatter` changes mentioned "
"above, the logging package gained the ability to allow users to set their "
"own :class:`LogRecord` subclasses, using the :func:`setLogRecordFactory` "
"function. You can use this to set your own subclass of :class:`LogRecord`, "
"which does the Right Thing by overriding the :meth:`~LogRecord.getMessage` "
"method. The base class implementation of this method is where the ``msg % "
"args`` formatting happens, and where you can substitute your alternate "
"formatting; however, you should be careful to support all formatting styles "
"and allow %-formatting as the default, to ensure interoperability with other "
"code. Care should also be taken to call ``str(self.msg)``, just as the base "
"implementation does."
msgstr ""
"在 Python 3.2 中，隨著上面提到的 :class:`~logging.Formatter` 更改，"
"日誌包獲得了允許使用者設定自己的 :class:`LogRecord` 子類別的能力，使用 "
":func:`setLogRecordFactory` 函式.您可以使用它來設定您自己的 "
":class:`LogRecord` 子類別，它通過覆蓋 :meth:`~LogRecord.getMessage` "
"方法來做正確的事情。此方法的基底類別實作是 ``msg % args`` "
"格式化發生的地方，您可以在其中替換您的替代格式；但是，"
"您應該小心支援所有格式樣式並允許 %-formatting "
"作為預設值，以確保與其他程式碼的互操作性。還應注意呼叫 ``str(self."
"msg)``，就像基本實作一樣。"

#: ../../howto/logging-cookbook.rst:2573
#, fuzzy
msgid ""
"Refer to the reference documentation on :func:`setLogRecordFactory` and :"
"class:`LogRecord` for more information."
msgstr "有關詳細資訊，請參閱有關 setLogRecordFactory 和 LogRecord 的參考文檔。"

#: ../../howto/logging-cookbook.rst:2578
#, fuzzy
msgid "Using custom message objects"
msgstr "使用自定義消息物件"

#: ../../howto/logging-cookbook.rst:2580
#, fuzzy
msgid ""
"There is another, perhaps simpler way that you can use {}- and $- formatting "
"to construct your individual log messages. You may recall (from :ref:"
"`arbitrary-object-messages`) that when logging you can use an arbitrary "
"object as a message format string, and that the logging package will call :"
"func:`str` on that object to get the actual format string. Consider the "
"following two classes::"
msgstr ""
"還有另一種可能更簡單的方法，您可以使用 {}- 和 $- "
"格式來構建您的個人日誌消息。您可能還記得（來自 :ref:`arbitrary-object-"
"messages`），在記錄日誌時，您可以使用任意對像作為消息格式字串，"
"並且日誌記錄包將呼叫該物件的 :func:`str` 來獲取實際格式字串。考慮以下兩個類："

#: ../../howto/logging-cookbook.rst:2605
#, fuzzy
msgid ""
"Either of these can be used in place of a format string, to allow {}- or $-"
"formatting to be used to build the actual \"message\" part which appears in "
"the formatted log output in place of “%(message)s” or “{message}” or "
"“$message”. If you find it a little unwieldy to use the class names whenever "
"you want to log something, you can make it more palatable if you use an "
"alias such as ``M`` or ``_`` for the message (or perhaps ``__``, if you are "
"using ``_`` for localization)."
msgstr ""
"這些中的任何一個都可以用來代替格式字串，以允許使用 {}- 或 $-formatting 來構建"
"實際的“消息”部分，該部分出現在格式化日誌輸出中代替“%(message)s”或“{message}”"
"或“$message”。如果你發現每當你想記錄一些東西時使用類名有點笨拙，你可以使用一"
"個別名，比如 ``M`` 或 ``_`` 作為消息的別名（或者可能是 ` `__``，如果您使用 "
"``_`` 進行本地化）。"

#: ../../howto/logging-cookbook.rst:2613
#, fuzzy
msgid ""
"Examples of this approach are given below. Firstly, formatting with :meth:"
"`str.format`::"
msgstr "下面給出了這種方法的示例。首先，使用 :meth:`str.format`:: 進行格式化："

#: ../../howto/logging-cookbook.rst:2627
#, fuzzy
msgid "Secondly, formatting with :class:`string.Template`::"
msgstr "其次，使用 :class:`string.Template`:: 進行格式化："

#: ../../howto/logging-cookbook.rst:2634
#, fuzzy
msgid ""
"One thing to note is that you pay no significant performance penalty with "
"this approach: the actual formatting happens not when you make the logging "
"call, but when (and if) the logged message is actually about to be output to "
"a log by a handler. So the only slightly unusual thing which might trip you "
"up is that the parentheses go around the format string and the arguments, "
"not just the format string. That’s because the __ notation is just syntax "
"sugar for a constructor call to one of the ``XXXMessage`` classes shown "
"above."
msgstr ""
"需要注意的一件事是，您使用這種方法不會付出明顯的性能損失：實際的格式化不是在"
"您進行日誌記錄呼叫時發生的，而是在（以及是否）記錄的消息實際上將由處理程式輸"
"出到日誌中時發生的。因此，唯一可能使您感到困惑的稍微不尋常的事情是括號圍繞著"
"格式字串和參數，而不僅僅是格式字串。這是因為 __ "
"符號只是構造函式呼叫上面顯示的 ``XXXMessage``類之一的語法糖。"

#: ../../howto/logging-cookbook.rst:2648
#, fuzzy
msgid "Configuring filters with :func:`dictConfig`"
msgstr "使用 :func:`dictConfig` 配置過濾器"

#: ../../howto/logging-cookbook.rst:2650
#, fuzzy
msgid ""
"You *can* configure filters using :func:`~logging.config.dictConfig`, though "
"it might not be obvious at first glance how to do it (hence this recipe). "
"Since :class:`~logging.Filter` is the only filter class included in the "
"standard library, and it is unlikely to cater to many requirements (it's "
"only there as a base class), you will typically need to define your own :"
"class:`~logging.Filter` subclass with an overridden :meth:`~logging.Filter."
"filter` method. To do this, specify the ``()`` key in the configuration "
"dictionary for the filter, specifying a callable which will be used to "
"create the filter (a class is the most obvious, but you can provide any "
"callable which returns a :class:`~logging.Filter` instance). Here is a "
"complete example::"
msgstr ""
"你*可以*使用 :func:`~logging.config.dictConfig` "
"配置過濾器，雖然乍一看可能並不明顯如何去做（因此有這個秘訣）。由於 "
":class:`~logging.Filter` 是標準庫中唯一包含的過濾器類，它不太可能滿足許多需求"
"（它僅作為基底類別存在），您通常需要定義自己的 :class :`~logging.Filter` "
"子類別具有重寫的 :meth:`~logging.Filter.filter` 方法。為此，"
"請在過濾器的配置字典中指定 ``()`` "
"鍵，指定將用於建立過濾器的可呼叫物件（一個類是最明顯的，但您可以提供任何回傳 "
"a 的可呼叫物件 :class:`~logging.Filter` 實例）。這是一個完整的例子::"

#: ../../howto/logging-cookbook.rst:2703
#, fuzzy
msgid ""
"This example shows how you can pass configuration data to the callable which "
"constructs the instance, in the form of keyword parameters. When run, the "
"above script will print:"
msgstr "此示例顯示如何以關鍵字參數的形式將配置資料傳遞給構造實例的可呼叫物件。運行時"
"，上面的腳本將印出："

#: ../../howto/logging-cookbook.rst:2711
#, fuzzy
msgid "which shows that the filter is working as configured."
msgstr "這表明過濾器正在按配置工作。"

#: ../../howto/logging-cookbook.rst:2713
#, fuzzy
msgid "A couple of extra points to note:"
msgstr "需要注意的幾點："

#: ../../howto/logging-cookbook.rst:2715
#, fuzzy
msgid ""
"If you can't refer to the callable directly in the configuration (e.g. if it "
"lives in a different module, and you can't import it directly where the "
"configuration dictionary is), you can use the form ``ext://...`` as "
"described in :ref:`logging-config-dict-externalobj`. For example, you could "
"have used the text ``'ext://__main__.MyFilter'`` instead of ``MyFilter`` in "
"the above example."
msgstr ""
"如果您不能在配置中直接引用可呼叫物件（例如，如果它位於不同的模組中，並且您不"
"能直接在配置字典所在的位置導入它），您可以使用“ext://”的形式。 ..`` 如 :ref"
":`logging-config-dict-externalobj` 中所述。例如，"
"您可以在上面的示例中使用文本 ``'ext://__main__.MyFilter'`` 而不是 "
"``MyFilter``。"

#: ../../howto/logging-cookbook.rst:2722
#, fuzzy
msgid ""
"As well as for filters, this technique can also be used to configure custom "
"handlers and formatters. See :ref:`logging-config-dict-userdef` for more "
"information on how logging supports using user-defined objects in its "
"configuration, and see the other cookbook recipe :ref:`custom-handlers` "
"above."
msgstr ""
"與過濾器一樣，此技術還可用於配置自定義處理程式和格式化程式。有關日誌記錄如何"
"支援在其配置中使用使用者定義物件的更多資訊，請參閱 :ref:`logging-config-dict-"
"userdef`，並參閱上面的其他食譜食譜 :ref:`custom-handlers`。"

#: ../../howto/logging-cookbook.rst:2731
#, fuzzy
msgid "Customized exception formatting"
msgstr "自定義例外格式"

#: ../../howto/logging-cookbook.rst:2733
#, fuzzy
msgid ""
"There might be times when you want to do customized exception formatting - "
"for argument's sake, let's say you want exactly one line per logged event, "
"even when exception information is present. You can do this with a custom "
"formatter class, as shown in the following example::"
msgstr ""
"有時您可能想要進行自定義的例外格式化——為了論證，假設您希望每個記錄的事件只佔"
"一行，即使存在例外資訊也是如此。您可以使用自定義格式化程式類來執行此操作，如"
"以下示例所示："

#: ../../howto/logging-cookbook.rst:2774
#, fuzzy
msgid "When run, this produces a file with exactly two lines:"
msgstr "運行時，這會生成一個只有兩行的文件："

#: ../../howto/logging-cookbook.rst:2781
#, fuzzy
msgid ""
"While the above treatment is simplistic, it points the way to how exception "
"information can be formatted to your liking. The :mod:`traceback` module may "
"be helpful for more specialized needs."
msgstr "雖然上面的處理很簡單，但它指明瞭如何根據您的喜好格式化例外資訊。 "
":mod:`traceback` 模組可能有助於滿足更特殊的需求。"

#: ../../howto/logging-cookbook.rst:2788
#, fuzzy
msgid "Speaking logging messages"
msgstr "說出日誌消息"

#: ../../howto/logging-cookbook.rst:2790
#, fuzzy
msgid ""
"There might be situations when it is desirable to have logging messages "
"rendered in an audible rather than a visible format. This is easy to do if "
"you have text-to-speech (TTS) functionality available in your system, even "
"if it doesn't have a Python binding. Most TTS systems have a command line "
"program you can run, and this can be invoked from a handler using :mod:"
"`subprocess`. It's assumed here that TTS command line programs won't expect "
"to interact with users or take a long time to complete, and that the "
"frequency of logged messages will be not so high as to swamp the user with "
"messages, and that it's acceptable to have the messages spoken one at a time "
"rather than concurrently, The example implementation below waits for one "
"message to be spoken before the next is processed, and this might cause "
"other handlers to be kept waiting. Here is a short example showing the "
"approach, which assumes that the ``espeak`` TTS package is available::"
msgstr ""
"在某些情況下，希望以可聽而不是可見的格式呈現日誌消息。"
"如果您的系統中有可用的文本轉語音 (TTS) 功能，即使它沒有 Python "
"綁定，這也很容易做到。大多數 TTS 系統都有一個可以運行的命令列程式，可以使用 "
":mod:`subprocess` 從處理程式中呼叫它。這裡假設 TTS 命令列程式不會期望與使用者"
"交互或需要很長時間才能完成，並且記錄消息的頻率不會高到讓使用者淹沒消息，並且"
"可以接受一次說出一條消息而不是同時說出，下面的示例實作在處理下一條消息之前等"
"待一條消息說出，這可能會導致其他處理程式一直等待。這是一個顯示該方法的簡短示"
"例，它假設 ``espeak`` TTS 包可用："

#: ../../howto/logging-cookbook.rst:2832
#, fuzzy
msgid ""
"When run, this script should say \"Hello\" and then \"Goodbye\" in a female "
"voice."
msgstr "運行時，此腳本應以女聲說“你好”，然後說“再見”。"

#: ../../howto/logging-cookbook.rst:2834
#, fuzzy
msgid ""
"The above approach can, of course, be adapted to other TTS systems and even "
"other systems altogether which can process messages via external programs "
"run from a command line."
msgstr "當然，上述方法可以適用於其他 TTS "
"系統，甚至適用於可以通過從命令列運行的外部程式處理消息的其他系統。"

#: ../../howto/logging-cookbook.rst:2842
#, fuzzy
msgid "Buffering logging messages and outputting them conditionally"
msgstr "緩沖日志消息並有條件地輸出它們"

#: ../../howto/logging-cookbook.rst:2844
#, fuzzy
msgid ""
"There might be situations where you want to log messages in a temporary area "
"and only output them if a certain condition occurs. For example, you may "
"want to start logging debug events in a function, and if the function "
"completes without errors, you don't want to clutter the log with the "
"collected debug information, but if there is an error, you want all the "
"debug information to be output as well as the error."
msgstr ""
"在某些情況下，您可能希望在臨時區域中記錄消息，並且僅在特定情況發生時才輸出它"
"們。例如，您可能想要開始記錄函式中的除錯事件，如果函式完成時沒有錯誤，您不希"
"望日誌中包含收集到的除錯資訊，但如果出現錯誤，您需要所有除錯資訊要輸出的資訊"
"以及錯誤。"

#: ../../howto/logging-cookbook.rst:2851
#, fuzzy
msgid ""
"Here is an example which shows how you could do this using a decorator for "
"your functions where you want logging to behave this way. It makes use of "
"the :class:`logging.handlers.MemoryHandler`, which allows buffering of "
"logged events until some condition occurs, at which point the buffered "
"events are ``flushed`` - passed to another handler (the ``target`` handler) "
"for processing. By default, the ``MemoryHandler`` flushed when its buffer "
"gets filled up or an event whose level is greater than or equal to a "
"specified threshold is seen. You can use this recipe with a more specialised "
"subclass of ``MemoryHandler`` if you want custom flushing behavior."
msgstr ""
"這是一個示例，它顯示瞭如何使用裝飾器為您希望日誌記錄以這種方式運行的函式執行"
"此操作。它使用 :class:`logging.handlers.MemoryHandler`，它允許緩衝記錄的事件"
"直到發生某些情況，此時緩衝的事件被“刷新”-傳遞給另一個處理程式（“目標” "
"`handler) 進行處理。預設情況下，``MemoryHandler`` 在其緩衝區被填滿或看到級別"
"大於或等於指定閾值的事件時刷新。如果您想要自定義刷新行為，您可以將此方法與更"
"專業的 ``MemoryHandler`` 子類別一起使用。"

#: ../../howto/logging-cookbook.rst:2861
#, fuzzy
msgid ""
"The example script has a simple function, ``foo``, which just cycles through "
"all the logging levels, writing to ``sys.stderr`` to say what level it's "
"about to log at, and then actually logging a message at that level. You can "
"pass a parameter to ``foo`` which, if true, will log at ERROR and CRITICAL "
"levels - otherwise, it only logs at DEBUG, INFO and WARNING levels."
msgstr ""
"示例腳本有一個簡單的函式，``foo``，它只是循環遍歷所有日誌記錄級別，寫入 ``sys"
".stderr`` 以說明它要記錄的級別，然後實際記錄一條消息等級。"
"您可以將一個參數傳遞給 ``foo``，如果該參數為真，將在 ERROR 和 CRITICAL "
"級別記錄 - 否則，它僅在 DEBUG、INFO 和 WARNING 級別記錄。"

#: ../../howto/logging-cookbook.rst:2867
#, fuzzy
msgid ""
"The script just arranges to decorate ``foo`` with a decorator which will do "
"the conditional logging that's required. The decorator takes a logger as a "
"parameter and attaches a memory handler for the duration of the call to the "
"decorated function. The decorator can be additionally parameterised using a "
"target handler, a level at which flushing should occur, and a capacity for "
"the buffer (number of records buffered). These default to a :class:`~logging."
"StreamHandler` which writes to ``sys.stderr``, ``logging.ERROR`` and ``100`` "
"respectively."
msgstr ""
"該腳本只是安排用裝飾器裝飾 ``foo``，裝飾器將執行所需的條件日誌記錄。裝飾器將記錄"
"器作為參數，並在呼叫裝飾函式期間附加記憶體處理程式。可以使用目標處理程式、刷"
"新應該發生的級別以及緩衝區的容量（緩衝的記錄數）對裝飾器進行額外參數化。"
"這些預設為 :class:`~logging.StreamHandler`，分別寫入 ``sys."
"stderr``、``logging.ERROR`` 和 ``100``。"

#: ../../howto/logging-cookbook.rst:2875
#, fuzzy
msgid "Here's the script::"
msgstr "這是腳本::"

#: ../../howto/logging-cookbook.rst:2938
#, fuzzy
msgid "When this script is run, the following output should be observed:"
msgstr "運行此腳本時，應觀察到以下輸出："

#: ../../howto/logging-cookbook.rst:2968
#, fuzzy
msgid ""
"As you can see, actual logging output only occurs when an event is logged "
"whose severity is ERROR or greater, but in that case, any previous events at "
"lower severities are also logged."
msgstr "如您所見，實際日誌記錄輸出僅在記錄嚴重性為 ERROR "
"或更高的事件時發生，但在這種情況下，還會記錄任何先前嚴重性較低的事件。"

#: ../../howto/logging-cookbook.rst:2972
#, fuzzy
msgid "You can of course use the conventional means of decoration::"
msgstr "你當然可以使用常規的裝飾方式::"

#: ../../howto/logging-cookbook.rst:2982
#, fuzzy
msgid "Sending logging messages to email, with buffering"
msgstr "將日誌消息發送到電子郵件，帶緩衝"

#: ../../howto/logging-cookbook.rst:2984
#, fuzzy
msgid ""
"To illustrate how you can send log messages via email, so that a set number "
"of messages are sent per email, you can subclass :class:`~logging.handlers."
"BufferingHandler`. In the following  example, which you can adapt to suit "
"your specific needs, a simple test harness is provided which allows you to "
"run the script with command line arguments specifying what you typically "
"need to send things via SMTP. (Run the downloaded script with the ``-h`` "
"argument to see the required and optional arguments.)"
msgstr ""
"為了說明如何通過電子郵件發送日誌消息，以便每封電子郵件發送一定數量的消息，"
"您可以繼承 :class:`~logging.handlers.BufferingHandler`。在以下示例中，您可以"
"根據自己的特定需求對其進行調整，其中提供了一個簡單的測試工具，它允許您使用命"
"令行參數運行腳本，指定您通常需要通過 SMTP 發送內容的內容。 "
"（使用 ``-h``參數運行下載的腳本以查看必需參數和可選參數。）"

#: ../../howto/logging-cookbook.rst:3056
#, fuzzy
msgid ""
"If you run this script and your SMTP server is correctly set up, you should "
"find that it sends eleven emails to the addressee you specify. The first ten "
"emails will each have ten log messages, and the eleventh will have two "
"messages. That makes up 102 messages as specified in the script."
msgstr ""
"如果您運行此腳本並且您的 SMTP 伺服器設定正確，"
"您應該會發現它向您指定的收件人發送了 11 封電子郵件。前 10 封郵件每封都有 10 "
"條日誌消息，第 11 封郵件有兩條。這構成了腳本中指定的 102 條消息。"

#: ../../howto/logging-cookbook.rst:3064
#, fuzzy
msgid "Formatting times using UTC (GMT) via configuration"
msgstr "通過配置使用 UTC (GMT) 格式化時間"

#: ../../howto/logging-cookbook.rst:3066
#, fuzzy
msgid ""
"Sometimes you want to format times using UTC, which can be done using a "
"class such as ``UTCFormatter``, shown below::"
msgstr "有時您想使用 UTC "
"格式化時間，這可以使用諸如 ``UTCFormatter`` 之類的類來完成，如下所示："

#: ../../howto/logging-cookbook.rst:3075
#, fuzzy
msgid ""
"and you can then use the ``UTCFormatter`` in your code instead of :class:"
"`~logging.Formatter`. If you want to do that via configuration, you can use "
"the :func:`~logging.config.dictConfig` API with an approach illustrated by "
"the following complete example::"
msgstr ""
"然後您可以在程式碼中使用 ``UTCFormatter`` 而不是 :class:`~logging."
"Formatter`。如果你想通過配置來做到這一點，你可以使用 :func:`~logging.config."
"dictConfig` API 以及以下完整示例所示的方法："

#: ../../howto/logging-cookbook.rst:3118
#, fuzzy
msgid "When this script is run, it should print something like:"
msgstr "運行此腳本時，它應該印出如下內容："

#: ../../howto/logging-cookbook.rst:3125
#, fuzzy
msgid ""
"showing how the time is formatted both as local time and UTC, one for each "
"handler."
msgstr "顯示時間如何格式化為本地時間和 UTC，每個處理程式一個。"

#: ../../howto/logging-cookbook.rst:3132
#, fuzzy
msgid "Using a context manager for selective logging"
msgstr "使用上下文管理器進行選擇性日誌記錄"

#: ../../howto/logging-cookbook.rst:3134
#, fuzzy
msgid ""
"There are times when it would be useful to temporarily change the logging "
"configuration and revert it back after doing something. For this, a context "
"manager is the most obvious way of saving and restoring the logging context. "
"Here is a simple example of such a context manager, which allows you to "
"optionally change the logging level and add a logging handler purely in the "
"scope of the context manager::"
msgstr ""
"有時臨時更改日誌記錄配置並在執行某些操作後將其還原會很有用。為此，上下文管理"
"器是保存和恢復日誌上下文的最明顯方法。這是此類上下文管理器的一個簡單示例，它"
"允許您有選擇地更改日誌記錄級別並新增純粹在上下文管理器範圍內的日誌記錄處理程"
"序："

#: ../../howto/logging-cookbook.rst:3167
#, fuzzy
msgid ""
"If you specify a level value, the logger's level is set to that value in the "
"scope of the with block covered by the context manager. If you specify a "
"handler, it is added to the logger on entry to the block and removed on exit "
"from the block. You can also ask the manager to close the handler for you on "
"block exit - you could do this if you don't need the handler any more."
msgstr ""
"如果您指定一個級別值，記錄器的級別將設定為上下文管理器覆蓋的 with 塊範圍內的"
"該值。如果您指定一個處理程式，它會在進入塊時新增到記錄器中，並在退出塊時被刪"
"除。您還可以要求經理在塊退出時為您關閉處理程式 - "
"如果您不再需要處理程式，您可以這樣做。"

#: ../../howto/logging-cookbook.rst:3173
#, fuzzy
msgid ""
"To illustrate how it works, we can add the following block of code to the "
"above::"
msgstr "為了說明它是如何工作的，我們可以將以下程式碼塊新增到上面的::"

#: ../../howto/logging-cookbook.rst:3191
#, fuzzy
msgid ""
"We initially set the logger's level to ``INFO``, so message #1 appears and "
"message #2 doesn't. We then change the level to ``DEBUG`` temporarily in the "
"following ``with`` block, and so message #3 appears. After the block exits, "
"the logger's level is restored to ``INFO`` and so message #4 doesn't appear. "
"In the next ``with`` block, we set the level to ``DEBUG`` again but also add "
"a handler writing to ``sys.stdout``. Thus, message #5 appears twice on the "
"console (once via ``stderr`` and once via ``stdout``). After the ``with`` "
"statement's completion, the status is as it was before so message #6 appears "
"(like message #1) whereas message #7 doesn't (just like message #2)."
msgstr ""
"我們最初將記錄器的級別設定為 ``INFO``，因此消息 #1 出現而消息 #2 不出現。"
"然後我們在下面的 ``with`` 塊中暫時將級別更改為 ``DEBUG``，因此出現消息 "
"#3。塊退出後，記錄器的級別恢復為 ``INFO``，因此消息 #4 不會出現。在下一個 ``with``"
"塊中，我們再次將級別設定為 ``DEBUG``，但還新增了一個寫入“sys."
"stdout”的處理程式。因此，消息 #5 在控制台上出現兩次（一次通過 ``stderr``，"
"一次通過 ``stdout``）。在 ``with`` 語句完成後，狀態與之前一樣，因此出現消息 "
"#6（如消息 #1），而消息 #7 不會出現（如消息 #2）。"

#: ../../howto/logging-cookbook.rst:3201
#, fuzzy
msgid "If we run the resulting script, the result is as follows:"
msgstr "如果我們運行生成的腳本，結果如下："

#: ../../howto/logging-cookbook.rst:3212
#, fuzzy
msgid ""
"If we run it again, but pipe ``stderr`` to ``/dev/null``, we see the "
"following, which is the only message written to ``stdout``:"
msgstr ""
"如果我們再次運行它，但是將 ``stderr`` 傳遞給 ``/dev/"
"null``，我們會看到以下內容，這是寫入 ``stdout`` 的唯一消息："

#: ../../howto/logging-cookbook.rst:3220
#, fuzzy
msgid "Once again, but piping ``stdout`` to ``/dev/null``, we get:"
msgstr "再一次，通過管道將 ``stdout`` 傳送到 ``/dev/null``，我們得到："

#: ../../howto/logging-cookbook.rst:3230
#, fuzzy
msgid ""
"In this case, the message #5 printed to ``stdout`` doesn't appear, as "
"expected."
msgstr "在這種情況下，印出到 ``stdout`` 的消息 #5 沒有像預期的那樣出現。"

#: ../../howto/logging-cookbook.rst:3232
#, fuzzy
msgid ""
"Of course, the approach described here can be generalised, for example to "
"attach logging filters temporarily. Note that the above code works in Python "
"2 as well as Python 3."
msgstr "當然，這裡描述的方法可以推廣，例如臨時附加日誌過濾器。請注意，上面的程式碼在 "
"Python 2 和 Python 3 中都有效。"

#: ../../howto/logging-cookbook.rst:3240
#, fuzzy
msgid "A CLI application starter template"
msgstr "CLI 應用程式入門模板"

#: ../../howto/logging-cookbook.rst:3242
#, fuzzy
msgid "Here's an example which shows how you can:"
msgstr "這是一個示例，說明您可以如何："

#: ../../howto/logging-cookbook.rst:3244
#, fuzzy
msgid "Use a logging level based on command-line arguments"
msgstr "使用基於命令列參數的日誌記錄級別"

#: ../../howto/logging-cookbook.rst:3245
#, fuzzy
msgid ""
"Dispatch to multiple subcommands in separate files, all logging at the same "
"level in a consistent way"
msgstr "分派到單獨文件中的多個子命令，以一致的方式在同一級別進行所有記錄"

#: ../../howto/logging-cookbook.rst:3247
#, fuzzy
msgid "Make use of simple, minimal configuration"
msgstr "使用簡單、最小的配置"

#: ../../howto/logging-cookbook.rst:3249
#, fuzzy
msgid ""
"Suppose we have a command-line application whose job is to stop, start or "
"restart some services. This could be organised for the purposes of "
"illustration as a file ``app.py`` that is the main script for the "
"application, with individual commands implemented in ``start.py``, ``stop."
"py`` and ``restart.py``. Suppose further that we want to control the "
"verbosity of the application via a command-line argument, defaulting to "
"``logging.INFO``. Here's one way that ``app.py`` could be written::"
msgstr ""
"假設我們有一個命令列應用程式，其工作是停止、啟動或重新啟動某些服務。為了說明"
"的目的，這可以組織為一個文件 ``app.py``，它是應用程式的主要腳本，在 ``start."
"py``、``stop.py`` 和 ` `重新啟動``。進一步假設我們想通過命令列參數控制應用程"
"序的冗長程度，預設為“logging.INFO”。這是 ``app.py`` 的一種寫法："

#: ../../howto/logging-cookbook.rst:3298
#, fuzzy
msgid ""
"And the ``start``, ``stop`` and ``restart`` commands can be implemented in "
"separate modules, like so for starting::"
msgstr "並且 ``start``、``stop`` 和 ``restart`` 命令可以在單獨的模組中實作，例如 "
"starting::"

#: ../../howto/logging-cookbook.rst:3311
#, fuzzy
msgid "and thus for stopping::"
msgstr "從而停止::"

#: ../../howto/logging-cookbook.rst:3332
#, fuzzy
msgid "and similarly for restarting::"
msgstr "並且類似地重新啟動::"

#: ../../howto/logging-cookbook.rst:3353
#, fuzzy
msgid ""
"If we run this application with the default log level, we get output like "
"this:"
msgstr "如果我們以預設日誌級別運行此應用程式，我們將得到如下輸出："

#: ../../howto/logging-cookbook.rst:3366
#, fuzzy
msgid ""
"The first word is the logging level, and the second word is the module or "
"package name of the place where the event was logged."
msgstr "第一個詞是日誌記錄級別，第二個詞是記錄事件的地方的模組或包名稱。"

#: ../../howto/logging-cookbook.rst:3369
#, fuzzy
msgid ""
"If we change the logging level, then we can change the information sent to "
"the log. For example, if we want more information:"
msgstr "如果我們更改日誌記錄級別，那麼我們可以更改發送到日誌的資訊。例如，如果我們想"
"要更多資訊："

#: ../../howto/logging-cookbook.rst:3386
#, fuzzy
msgid "And if we want less:"
msgstr "如果我們想要更少："

#: ../../howto/logging-cookbook.rst:3394
#, fuzzy
msgid ""
"In this case, the commands don't print anything to the console, since "
"nothing at ``WARNING`` level or above is logged by them."
msgstr "在這種情況下，命令不會向控制台印出任何內容，因為它們不會記錄“警告”或更高階別"
"的任何內容。"

#: ../../howto/logging-cookbook.rst:3400
#, fuzzy
msgid "A Qt GUI for logging"
msgstr "用於日誌記錄的 Qt GUI"

#: ../../howto/logging-cookbook.rst:3402
#, fuzzy
msgid ""
"A question that comes up from time to time is about how to log to a GUI "
"application. The `Qt <https://www.qt.io/>`_ framework is a popular cross-"
"platform UI framework with Python bindings using `PySide2 <https://pypi.org/"
"project/PySide2/>`_ or `PyQt5 <https://pypi.org/project/PyQt5/>`_ libraries."
msgstr ""
"不時出現的一個問題是關於如何登錄到 GUI 應用程式。 `Qt <https://www.qt.io/>`_ "
"框架是一種流行的跨平台 UI 框架，使用 `PySide2 <https://pypi.org/project/"
"PySide2/>`_ 或 ` PyQt5 <https://pypi.org/project/PyQt5/>`_ 庫。"

#: ../../howto/logging-cookbook.rst:3408
#, fuzzy
msgid ""
"The following example shows how to log to a Qt GUI. This introduces a simple "
"``QtHandler`` class which takes a callable, which should be a slot in the "
"main thread that does GUI updates. A worker thread is also created to show "
"how you can log to the GUI from both the UI itself (via a button for manual "
"logging) as well as a worker thread doing work in the background (here, just "
"logging messages at random levels with random short delays in between)."
msgstr ""
"以下示例顯示如何登錄到 Qt "
"GUI。這引入了一個簡單的 ``QtHandler`` 類，它接受一個可呼叫物件，"
"它應該是主執行緒中進行 GUI 更新的槽。還建立了一個工作執行緒來展示如何從 UI 本"
"身（通過用於手動記錄的按鈕）以及在後台工作的工作執行緒（這裡，只是隨機記錄隨"
"機級別的消息）登錄到 GUI之間的短暫延遲）。"

#: ../../howto/logging-cookbook.rst:3415
#, fuzzy
msgid ""
"The worker thread is implemented using Qt's ``QThread`` class rather than "
"the :mod:`threading` module, as there are circumstances where one has to use "
"``QThread``, which offers better integration with other ``Qt`` components."
msgstr ""
"工作執行緒是使用 Qt 的 ``QThread`` 類而不是 :mod:`threading` 模組實作的，"
"因為在某些情況下必須使用 ``QThread``，它提供了與其他 ``Qt`` 更好的集成成分。"

#: ../../howto/logging-cookbook.rst:3419
#, fuzzy
msgid ""
"The code should work with recent releases of either ``PySide2`` or "
"``PyQt5``. You should be able to adapt the approach to earlier versions of "
"Qt. Please refer to the comments in the code snippet for more detailed "
"information."
msgstr ""
"該程式碼應該適用於最新版本的 ``PySide2`` 或 ``PyQt5``。"
"您應該能夠使該方法適用於早期版本的 "
"Qt。有關更多詳細資訊，請參閱程式碼段中的註釋。"

#: ../../howto/logging-cookbook.rst:3633
#, fuzzy
msgid "Logging to syslog with RFC5424 support"
msgstr "使用 RFC5424 支援記錄到系統日誌"

#: ../../howto/logging-cookbook.rst:3635
#, fuzzy
msgid ""
"Although :rfc:`5424` dates from 2009, most syslog servers are configured by "
"detault to use the older :rfc:`3164`, which hails from 2001. When "
"``logging`` was added to Python in 2003, it supported the earlier (and only "
"existing) protocol at the time. Since RFC5424 came out, as there has not "
"been widespread deployment of it in syslog servers, the :class:`~logging."
"handlers.SysLogHandler` functionality has not been updated."
msgstr ""
"雖然 :rfc:`5424` 的日期是 2009 年，"
"但大多數係統日誌伺服器預設配置為使用較舊的 :rfc:`3164`，它來自 2001 年。當 "
"``logging`` 在 2003 年被新增到 Python "
"時，它支援當時較早的（也是唯一存在的）協定。自從 RFC5424 "
"出來後，由於它還沒有在系統日誌伺服器中廣泛部署，:class:`~logging.handlers."
"SysLogHandler` 功能還沒有更新。"

#: ../../howto/logging-cookbook.rst:3642
#, fuzzy
msgid ""
"RFC 5424 contains some useful features such as support for structured data, "
"and if you need to be able to log to a syslog server with support for it, "
"you can do so with a subclassed handler which looks something like this::"
msgstr ""
"RFC 5424 包含一些有用的功能，例如支援結構化資料，如果您需要能夠記錄到支援它的"
"系統日誌伺服器，您可以使用如下所示的子類別處理程式來實作："

#: ../../howto/logging-cookbook.rst:3708
#, fuzzy
msgid ""
"You'll need to be familiar with RFC 5424 to fully understand the above code, "
"and it may be that you have slightly different needs (e.g. for how you pass "
"structural data to the log). Nevertheless, the above should be adaptable to "
"your speciric needs. With the above handler, you'd pass structured data "
"using something like this::"
msgstr ""
"您需要熟悉 RFC 5424 才能完全理解上述程式碼，並且您的需求可能略有不同（例如，"
"如何將結構資料傳遞到日誌）。儘管如此，以上內容應該適合您的特定需求。使用上述"
"處理程式，您將使用類似這樣的方式傳遞結構化資料："

#: ../../howto/logging-cookbook.rst:3722
#, fuzzy
msgid "How to treat a logger like an output stream"
msgstr "如何將記錄器視為輸出流"

#: ../../howto/logging-cookbook.rst:3724
#, fuzzy
msgid ""
"Sometimes, you need to interface to a third-party API which expects a file-"
"like object to write to, but you want to direct the API's output to a "
"logger. You can do this using a class which wraps a logger with a file-like "
"API. Here's a short script illustrating such a class:"
msgstr ""
"有時，您需要連接到第三方 API，該 API 需要寫入類似文件的物件，但您希望將 API "
"的輸出定向到記錄器。您可以使用一個類來完成此操作，該類使用類似文件的 API "
"包裝記錄器。這是一個說明此類的簡短腳本："

#: ../../howto/logging-cookbook.rst:3764
#, fuzzy
msgid "When this script is run, it prints"
msgstr "運行此腳本時，它會印出"

#: ../../howto/logging-cookbook.rst:3771
#, fuzzy
msgid ""
"You could also use ``LoggerWriter`` to redirect ``sys.stdout`` and ``sys."
"stderr`` by doing something like this:"
msgstr "您還可以使用 ``LoggerWriter`` 通過執行以下操作來重定向 ``sys.stdout`` 和 "
"``sys.stderr``："

#: ../../howto/logging-cookbook.rst:3781
#, fuzzy
msgid ""
"You should do this *after* configuring logging for your needs. In the above "
"example, the :func:`~logging.basicConfig` call does this (using the ``sys."
"stderr`` value *before* it is overwritten by a ``LoggerWriter`` instance). "
"Then, you'd get this kind of result:"
msgstr ""
"您應該*在*根據您的需要配置日誌記錄後執行此操作。在上面的示例中，:func:`~loggi"
"ng.basicConfig` 呼叫執行此操作（使用 ``sys.stderr`` 值*之前*它被 "
"``LoggerWriter`` 實例覆蓋）。然後，你會得到這樣的結果："

#: ../../howto/logging-cookbook.rst:3794
#, fuzzy
msgid ""
"Of course, the examples above show output according to the format used by :"
"func:`~logging.basicConfig`, but you can use a different formatter when you "
"configure logging."
msgstr ""
"當然，上面的示例根據 :func:`~logging.basicConfig` "
"使用的格式顯示輸出，但是您可以在配置日誌記錄時使用不同的格式化程式。"

#: ../../howto/logging-cookbook.rst:3798
#, fuzzy
msgid ""
"Note that with the above scheme, you are somewhat at the mercy of buffering "
"and the sequence of write calls which you are intercepting. For example, "
"with the definition of ``LoggerWriter`` above, if you have the snippet"
msgstr ""
"請注意，使用上述方案，您在某種程度上受制於緩沖和您攔截的寫入呼叫的順序。例如"
"，對於上面 ``LoggerWriter`` 的定義，如果您有程式碼片段"

#: ../../howto/logging-cookbook.rst:3807
#, fuzzy
msgid "then running the script results in"
msgstr "然後運行腳本結果"

#: ../../howto/logging-cookbook.rst:3825
#, fuzzy
msgid ""
"As you can see, this output isn't ideal. That's because the underlying code "
"which writes to ``sys.stderr`` makes mutiple writes, each of which results "
"in a separate logged line (for example, the last three lines above). To get "
"around this problem, you need to buffer things and only output log lines "
"when newlines are seen. Let's use a slghtly better implementation of "
"``LoggerWriter``:"
msgstr ""
"如您所見，此輸出並不理想。這是因為寫入“sys.stderr”的底層程式碼進行了多次寫入"
"，每次寫入都會產生一個單獨的記錄行（例如，上面的最後三行）。為了解決這個問題"
"，您需要緩沖一些東西並且只在看到換行符時輸出日誌行。讓我們使用一個更好的 "
"``LoggerWriter`` 實作："

#: ../../howto/logging-cookbook.rst:3850
#, fuzzy
msgid ""
"This just buffers up stuff until a newline is seen, and then logs complete "
"lines. With this approach, you get better output:"
msgstr "這只是緩衝內容，直到看到換行符，然後記錄完整的行。使用這種方法，您可以獲得更"
"好的輸出："

#: ../../howto/logging-cookbook.rst:3866
#, fuzzy
msgid "Patterns to avoid"
msgstr "要避免的模式"

#: ../../howto/logging-cookbook.rst:3868
#, fuzzy
msgid ""
"Although the preceding sections have described ways of doing things you "
"might need to do or deal with, it is worth mentioning some usage patterns "
"which are *unhelpful*, and which should therefore be avoided in most cases. "
"The following sections are in no particular order."
msgstr ""
"儘管前面的部分描述了您可能需要做或處理的事情的處理方法，但值得一提的是一些*無"
"用*的使用模式，因此在大多數情況下應避免使用這些模式。以下部分沒有特定的順序。"

#: ../../howto/logging-cookbook.rst:3874
#, fuzzy
msgid "Opening the same log file multiple times"
msgstr "多次打開同一個日誌文件"

#: ../../howto/logging-cookbook.rst:3876
#, fuzzy
msgid ""
"On Windows, you will generally not be able to open the same file multiple "
"times as this will lead to a \"file is in use by another process\" error. "
"However, on POSIX platforms you'll not get any errors if you open the same "
"file multiple times. This could be done accidentally, for example by:"
msgstr ""
"在 Windows 上，您通常無法多次打開同一個文件，因為這會導致“文件正在被另一個行"
"程使用”錯誤。但是，在 POSIX 平台上，如果您多次打開同一個文件，您將不會收到任"
"何錯誤。這可能是意外完成的，例如："

#: ../../howto/logging-cookbook.rst:3881
#, fuzzy
msgid ""
"Adding a file handler more than once which references the same file (e.g. by "
"a copy/paste/forget-to-change error)."
msgstr "多次新增引用同一文件的文件處理程式（例如，通過複製/粘貼/忘記更改錯誤）。"

#: ../../howto/logging-cookbook.rst:3884
#, fuzzy
msgid ""
"Opening two files that look different, as they have different names, but are "
"the same because one is a symbolic link to the other."
msgstr "打開兩個看起來不同的文件，因為它們具有不同的名稱，但它們是相同的，因為一個是"
"另一個的符號鏈接。"

#: ../../howto/logging-cookbook.rst:3887
#, fuzzy
msgid ""
"Forking a process, following which both parent and child have a reference to "
"the same file. This might be through use of the :mod:`multiprocessing` "
"module, for example."
msgstr "分叉一個行程，之後父行程和子行程都引用同一個文件。例如，這可能是通過使用 "
":mod:`multiprocessing` 模組實作的。"

#: ../../howto/logging-cookbook.rst:3891
#, fuzzy
msgid ""
"Opening a file multiple times might *appear* to work most of the time, but "
"can lead to a number of problems in practice:"
msgstr "多次打開一個文件可能*看起來*大部分時間都可以工作，但在實踐中可能會導致許多問"
"題："

#: ../../howto/logging-cookbook.rst:3894
#, fuzzy
msgid ""
"Logging output can be garbled because multiple threads or processes try to "
"write to the same file. Although logging guards against concurrent use of "
"the same handler instance by multiple threads, there is no such protection "
"if concurrent writes are attempted by two different threads using two "
"different handler instances which happen to point to the same file."
msgstr ""
"日誌輸出可能是亂碼，因為多個執行緒或行程試圖寫入同一個文件。儘管日誌記錄可以"
"防止多個執行緒並發使用同一個處理程式實例，但是如果兩個不同的執行緒使用恰好指"
"向同一個文件的兩個不同處理程式實例嘗試並發寫入，則沒有這種保護。"

#: ../../howto/logging-cookbook.rst:3900
#, fuzzy
msgid ""
"An attempt to delete a file (e.g. during file rotation) silently fails, "
"because there is another reference pointing to it. This can lead to "
"confusion and wasted debugging time - log entries end up in unexpected "
"places, or are lost altogether. Or a file that was supposed to be moved "
"remains in place, and grows in size unexpectedly despite size-based rotation "
"being supposedly in place."
msgstr ""
"嘗試刪除文件（例如，在文件輪換期間）會悄無聲息地失敗，因為有另一個引用指向它"
"。這可能會導致混亂和浪費除錯時間——日誌條目最終出現在意想不到的地方，或者完全"
"丟失。或者，一個應該被移動的文件保留在原地，並且儘管基於大小的輪換被認為是適"
"當的，但它的大小卻意外地增加了。"

#: ../../howto/logging-cookbook.rst:3907
#, fuzzy
msgid ""
"Use the techniques outlined in :ref:`multiple-processes` to circumvent such "
"issues."
msgstr "使用 :ref:`multiple-processes` 中概述的技術來規避此類問題。"

#: ../../howto/logging-cookbook.rst:3911
#, fuzzy
msgid "Using loggers as attributes in a class or passing them as parameters"
msgstr "使用記錄器作為類中的屬性或將它們作為參數傳遞"

#: ../../howto/logging-cookbook.rst:3913
#, fuzzy
msgid ""
"While there might be unusual cases where you'll need to do this, in general "
"there is no point because loggers are singletons. Code can always access a "
"given logger instance by name using ``logging.getLogger(name)``, so passing "
"instances around and holding them as instance attributes is pointless. Note "
"that in other languages such as Java and C#, loggers are often static class "
"attributes. However, this pattern doesn't make sense in Python, where the "
"module (and not the class) is the unit of software decomposition."
msgstr ""
"雖然可能存在您需要執行此操作的不尋常情況，但通常沒有意義，因為記錄器是單例。"
"程式碼始終可以使用“logging.getLogger(name)”按名稱訪問給定的記錄器實例，因此傳"
"遞實例並將它們作為實例屬性保存是沒有意義的。請注意，在 Java 和 C# "
"等其他語言中，記錄器通常是靜態類屬性。然而，這種模式在 Python "
"中沒有意義，其中模組（而不是類）是軟件分解的單元。"

#: ../../howto/logging-cookbook.rst:3922
#, fuzzy
msgid ""
"Adding handlers other than :class:`NullHandler` to a logger in a library"
msgstr "將 :class:`NullHandler` 以外的處理程式新增到庫中的記錄器"

#: ../../howto/logging-cookbook.rst:3924
#, fuzzy
msgid ""
"Configuring logging by adding handlers, formatters and filters is the "
"responsibility of the application developer, not the library developer. If "
"you are maintaining a library, ensure that you don't add handlers to any of "
"your loggers other than a :class:`~logging.NullHandler` instance."
msgstr ""
"通過新增處理程式、格式化程式和過濾器來配置日誌記錄是應用程式開發人員的責任，"
"而不是庫開發人員的責任。如果您正在維護一個庫，請確保您不會將處理程式新增到除 "
":class:`~logging.NullHandler` 實例之外的任何記錄器。"

#: ../../howto/logging-cookbook.rst:3930
#, fuzzy
msgid "Creating a lot of loggers"
msgstr "建立大量記錄器"

#: ../../howto/logging-cookbook.rst:3932
#, fuzzy
msgid ""
"Loggers are singletons that are never freed during a script execution, and "
"so creating lots of loggers will use up memory which can't then be freed. "
"Rather than create a logger per e.g. file processed or network connection "
"made, use the :ref:`existing mechanisms <context-info>` for passing "
"contextual information into your logs and restrict the loggers created to "
"those describing areas within your application (generally modules, but "
"occasionally slightly more fine-grained than that)."
msgstr ""
"記錄器是在腳本執行期間永遠不會釋放的單例，因此建立大量記錄器會耗盡記憶體，而"
"這些記憶體隨後無法釋放。而不是建立一個記錄器，例如處理文件或建立網絡連接，"
"使用 :ref:`existing mechanisms <context-info>` 將上下文資訊傳遞到您的日誌中，"
"並將建立的記錄器限制為那些描述應用程式中區域的記錄器（通常是模組，但偶爾會更"
"精細-顆粒度比那個）。"

#: ../../howto/logging-cookbook.rst:3943
#, fuzzy
msgid "Other resources"
msgstr "其他資源"

#: ../../howto/logging-cookbook.rst:3956
#, fuzzy
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`基礎教程 <logging-basic-tutorial>`"

#: ../../howto/logging-cookbook.rst:3958
#, fuzzy
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`高階教程 <logging-advanced-tutorial>`"
