# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-15 20:43+0000\n"
"PO-Revision-Date: 2018-05-23 14:36+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/curses.rst:5
#, fuzzy
msgid "Curses Programming with Python"
msgstr "使用 Python 進行 Curses 編程"

#: ../../howto/curses.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/curses.rst:7
msgid "A.M. Kuchling, Eric S. Raymond"
msgstr "A.M. Kuchling, Eric S. Raymond"

#: ../../howto/curses.rst:0
msgid "Release"
msgstr "發佈版本"

#: ../../howto/curses.rst:8
msgid "2.04"
msgstr "2.04"

#: ../../howto/curses.rst:-1
msgid "Abstract"
msgstr "摘要"

#: ../../howto/curses.rst:13
#, fuzzy
msgid ""
"This document describes how to use the :mod:`curses` extension module to "
"control text-mode displays."
msgstr "本文檔描述瞭如何使用 :mod:`curses` 擴充模組來控制文本模式顯示。"

#: ../../howto/curses.rst:18
#, fuzzy
msgid "What is curses?"
msgstr "什麼是詛咒？"

#: ../../howto/curses.rst:20
#, fuzzy
msgid ""
"The curses library supplies a terminal-independent screen-painting and "
"keyboard-handling facility for text-based terminals; such terminals include "
"VT100s, the Linux console, and the simulated terminal provided by various "
"programs.  Display terminals support various control codes to perform common "
"operations such as moving the cursor, scrolling the screen, and erasing "
"areas.  Different terminals use widely differing codes, and often have their "
"own minor quirks."
msgstr ""
"curses 庫為基於文本的終端提供獨立於終端的屏幕繪製和鍵盤處理工具；此類終端包括"
"VT100s、Linux控制台和各種程式提供的模擬終端。顯示終端支援多種控制程式碼，可以"
"實作光標移動、屏幕滾動、區域擦除等常用操作。不同的終端使用差異很大的程式碼，"
"並且通常有自己的小怪癖。"

#: ../../howto/curses.rst:28
#, fuzzy
msgid ""
"In a world of graphical displays, one might ask \"why bother\"?  It's true "
"that character-cell display terminals are an obsolete technology, but there "
"are niches in which being able to do fancy things with them are still "
"valuable.  One niche is on small-footprint or embedded Unixes that don't run "
"an X server.  Another is tools such as OS installers and kernel "
"configurators that may have to run before any graphical support is available."
msgstr ""
"在圖形顯示的世界裡，有人可能會問“何必費心”？字元單元顯示終端確實是一項過時的"
"技術，但在某些利基市場中，能夠用它們做一些奇特的事情仍然很有價值。"
"一個利基是在不運行 X 伺服器的小型或嵌入式 Unix 上。另一個是操作系統安裝程式和"
"內核配置程式等工具，它們可能必須在任何圖形支援可用之前運行。"

#: ../../howto/curses.rst:36
#, fuzzy
msgid ""
"The curses library provides fairly basic functionality, providing the "
"programmer with an abstraction of a display containing multiple non-"
"overlapping windows of text.  The contents of a window can be changed in "
"various ways---adding text, erasing it, changing its appearance---and the "
"curses library will figure out what control codes need to be sent to the "
"terminal to produce the right output.  curses doesn't provide many user-"
"interface concepts such as buttons, checkboxes, or dialogs; if you need such "
"features, consider a user interface library such as `Urwid <https://pypi.org/"
"project/urwid/>`_."
msgstr ""
"curses 庫提供相當基本的功能，為程式員提供包含多個非重疊文本窗口的抽象顯示。可"
"以通過多種方式更改窗口的內容——新增文本、刪除文本、更改其外觀——並且 curses "
"庫將找出需要將哪些控制程式碼發送到終端以產生正確的輸出。 curses 不提供許多使"
"用者界面概念，例如按鈕、複選框或對話框；如果您需要此類功能，請考慮使用使用者"
"界面庫，例如`Urwid <https://pypi.org/project/urwid/>`_。"

#: ../../howto/curses.rst:46
#, fuzzy
msgid ""
"The curses library was originally written for BSD Unix; the later System V "
"versions of Unix from AT&T added many enhancements and new functions. BSD "
"curses is no longer maintained, having been replaced by ncurses, which is an "
"open-source implementation of the AT&T interface.  If you're using an open-"
"source Unix such as Linux or FreeBSD, your system almost certainly uses "
"ncurses.  Since most current commercial Unix versions are based on System V "
"code, all the functions described here will probably be available.  The "
"older versions of curses carried by some proprietary Unixes may not support "
"everything, though."
msgstr ""
"curses 庫最初是為 BSD Unix 編寫的； AT&T 的 Unix 系統 V "
"版本增加了許多增強功能和新功能。 BSD curses 不再維護，已被 ncurses 取代，"
"ncurses 是 AT&T 介面的開源實作。如果您使用的是開源 Unix，例如 Linux 或 "
"FreeBSD，您的系統幾乎肯定會使用 ncurses。由於大多數當前的商業 Unix "
"版本都基於 System V 程式碼，因此這裡描述的所有功能都可能可用。不過，一些專有 "
"Unix 所攜帶的舊版本的 curses 可能並不支援所有的東西。"

#: ../../howto/curses.rst:56
#, fuzzy
msgid ""
"The Windows version of Python doesn't include the :mod:`curses` module.  A "
"ported version called `UniCurses <https://pypi.org/project/UniCurses>`_ is "
"available."
msgstr ""
"Windows 版本的 Python 不包含 :mod:`curses` 模組。一個名為 `UniCurses "
"<https://pypi.org/project/UniCurses>`_ 的移植版本可用。"

#: ../../howto/curses.rst:62
#, fuzzy
msgid "The Python curses module"
msgstr "Python curses 模組"

#: ../../howto/curses.rst:64
#, fuzzy
msgid ""
"The Python module is a fairly simple wrapper over the C functions provided "
"by curses; if you're already familiar with curses programming in C, it's "
"really easy to transfer that knowledge to Python.  The biggest difference is "
"that the Python interface makes things simpler by merging different C "
"functions such as :c:func:`addstr`, :c:func:`mvaddstr`, and :c:func:"
"`mvwaddstr` into a single :meth:`~curses.window.addstr` method.  You'll see "
"this covered in more detail later."
msgstr ""
"Python 模組是 curses 提供的 C 函式的一個相當簡單的包裝器；如果您已經熟悉 C "
"中的 curses 編程，那麼將這些知識轉移到 Python 中真的很容易。最大的區別是 "
"Python 介面通過將不同的 C 函式（例如 :c:func:`addstr`、:c:func:`mvaddstr` "
"和:c:func:`mvwaddstr` 合併到一個 :meth 中來簡化事情:`~curses.window.addstr` "
"方法。稍後您將看到更詳細的內容。"

#: ../../howto/curses.rst:72
#, fuzzy
msgid ""
"This HOWTO is an introduction to writing text-mode programs with curses and "
"Python. It doesn't attempt to be a complete guide to the curses API; for "
"that, see the Python library guide's section on ncurses, and the C manual "
"pages for ncurses.  It will, however, give you the basic ideas."
msgstr ""
"這份 HOWTO 是對使用 curses 和 Python 編寫文本模式程式的介紹。它並不試圖成為 "
"curses API 的完整指南；為此，請參閱 Python 庫指南中關於 ncurses 的部分，以及 "
"ncurses 的 C 手冊頁。但是，它將為您提供基本概念。"

#: ../../howto/curses.rst:79
#, fuzzy
msgid "Starting and ending a curses application"
msgstr "啟動和結束 curses 應用程式"

#: ../../howto/curses.rst:81
#, fuzzy
msgid ""
"Before doing anything, curses must be initialized.  This is done by calling "
"the :func:`~curses.initscr` function, which will determine the terminal "
"type, send any required setup codes to the terminal, and create various "
"internal data structures.  If successful, :func:`initscr` returns a window "
"object representing the entire screen; this is usually called ``stdscr`` "
"after the name of the corresponding C variable. ::"
msgstr ""
"在做任何事情之前，curses 必須被初始化。這是通過呼叫 :func:`~curses.initscr` "
"函式來完成的，該函式將確定終端型別，將任何所需的設定程式碼發送到終端，並建立"
"各種內部資料結構。如果成功，:func:`initscr` 回傳一個代表整個屏幕的窗口物件；"
"這通常在相應的 C 變數名稱之後稱為 ``stdscr``。 ::"

#: ../../howto/curses.rst:92
#, fuzzy
msgid ""
"Usually curses applications turn off automatic echoing of keys to the "
"screen, in order to be able to read keys and only display them under certain "
"circumstances.  This requires calling the :func:`~curses.noecho` function. ::"
msgstr ""
"通常 curses "
"應用程式會關閉按鍵自動回顯到屏幕，以便能夠讀取按鍵並僅在特定情況下顯示它們。"
"這需要呼叫 :func:`~curses.noecho` 函式。 ::"

#: ../../howto/curses.rst:99
#, fuzzy
msgid ""
"Applications will also commonly need to react to keys instantly, without "
"requiring the Enter key to be pressed; this is called cbreak mode, as "
"opposed to the usual buffered input mode. ::"
msgstr "應用程式通常還需要立即對按鍵做出反應，而不需要按下 Enter 鍵；這稱為 cbreak "
"模式，與通常的緩衝輸入模式相反。 ::"

#: ../../howto/curses.rst:105
#, fuzzy
msgid ""
"Terminals usually return special keys, such as the cursor keys or navigation "
"keys such as Page Up and Home, as a multibyte escape sequence.  While you "
"could write your application to expect such sequences and process them "
"accordingly, curses can do it for you, returning a special value such as :"
"const:`curses.KEY_LEFT`.  To get curses to do the job, you'll have to enable "
"keypad mode. ::"
msgstr ""
"終端通常回傳特殊鍵，如光標鍵或導航鍵，如 Page Up 和 Home，作為多位元組轉義序"
"列。雖然您可以編寫您的應用程式以期望此類序列並相應地處理它們，但 curses "
"可以為您完成，回傳一個特殊值，例如 :const:`curses.KEY_LEFT`。要讓 curses "
"完成這項工作，您必須啟用鍵盤模式。 ::"

#: ../../howto/curses.rst:114
#, fuzzy
msgid ""
"Terminating a curses application is much easier than starting one. You'll "
"need to call::"
msgstr "終止一個 curses 應用程式比啟動一個應用程式容易得多。您需要呼叫::"

#: ../../howto/curses.rst:121
#, fuzzy
msgid ""
"to reverse the curses-friendly terminal settings. Then call the :func:"
"`~curses.endwin` function to restore the terminal to its original operating "
"mode. ::"
msgstr "反轉 curses 友好的終端設定。然後呼叫 :func:`~curses.endwin` "
"函式將終端恢復到原來的運行模式。 ::"

#: ../../howto/curses.rst:127
#, fuzzy
msgid ""
"A common problem when debugging a curses application is to get your terminal "
"messed up when the application dies without restoring the terminal to its "
"previous state.  In Python this commonly happens when your code is buggy and "
"raises an uncaught exception.  Keys are no longer echoed to the screen when "
"you type them, for example, which makes using the shell difficult."
msgstr ""
"除錯 curses 應用程式時的一個常見問題是，當應用程式死機而沒有將終端恢復到之前"
"的狀態時，終端會變得一團糟。在 Python 中，當您的程式碼存在錯誤並引發未捕獲的"
"例外時，通常會發生這種情況。例如，當您鍵入鍵時，鍵不再回顯到屏幕上，"
"這使得使用 shell 變得困難。"

#: ../../howto/curses.rst:133
#, fuzzy
msgid ""
"In Python you can avoid these complications and make debugging much easier "
"by importing the :func:`curses.wrapper` function and using it like this::"
msgstr "在 Python 中，您可以通過導入 :func:`curses.wrapper` "
"函式並像這樣使用它來避免這些複雜情況並使除錯變得更加容易："

#: ../../howto/curses.rst:152
#, fuzzy
msgid ""
"The :func:`~curses.wrapper` function takes a callable object and does the "
"initializations described above, also initializing colors if color support "
"is present.  :func:`wrapper` then runs your provided callable. Once the "
"callable returns, :func:`wrapper` will restore the original state of the "
"terminal.  The callable is called inside a :keyword:`try`...\\ :keyword:"
"`except` that catches exceptions, restores the state of the terminal, and "
"then re-raises the exception.  Therefore your terminal won't be left in a "
"funny state on exception and you'll be able to read the exception's message "
"and traceback."
msgstr ""
":func:`~curses.wrapper` "
"函式接受一個可呼叫物件並進行上述初始化，如果存在顏色支援，還會初始化顏色。 "
":func:`wrapper` 然後運行你提供的可呼叫物件。一旦可呼叫回傳，:func:`wrapper` "
"將恢復終端的原始狀態。可呼叫函式在 :keyword:`try`...\\ :keyword:`except` "
"中呼叫，它捕獲例外，恢復終端狀態，然後重新引發例外。因此，您的"
"終端不會因例外而處於有趣的狀態，您將能夠閱讀例外的消息和回溯。"

#: ../../howto/curses.rst:164
#, fuzzy
msgid "Windows and Pads"
msgstr "窗戶和墊子"

#: ../../howto/curses.rst:166
#, fuzzy
msgid ""
"Windows are the basic abstraction in curses.  A window object represents a "
"rectangular area of the screen, and supports methods to display text, erase "
"it, allow the user to input strings, and so forth."
msgstr "Windows 是 curses 中的基本抽象。窗口物件表示屏幕的一個矩形區域，支援顯示文本"
"、擦除文本、允許使用者輸入字串等方法。"

#: ../../howto/curses.rst:170
#, fuzzy
msgid ""
"The ``stdscr`` object returned by the :func:`~curses.initscr` function is a "
"window object that covers the entire screen.  Many programs may need only "
"this single window, but you might wish to divide the screen into smaller "
"windows, in order to redraw or clear them separately. The :func:`~curses."
"newwin` function creates a new window of a given size, returning the new "
"window object. ::"
msgstr ""
":func:`~curses.initscr` 函式回傳的 ``stdscr`` 對像是一個覆蓋整個屏幕的窗口物"
"件。許多程式可能只需要這個單一窗口，但您可能希望將屏幕分成更小的窗口，以便單"
"獨重繪或清除它們。 :func:`~curses.newwin` "
"函式建立一個給定大小的新窗口，回傳新的窗口物件。 ::"

#: ../../howto/curses.rst:181
#, fuzzy
msgid ""
"Note that the coordinate system used in curses is unusual. Coordinates are "
"always passed in the order *y,x*, and the top-left corner of a window is "
"coordinate (0,0).  This breaks the normal convention for handling "
"coordinates where the *x* coordinate comes first.  This is an unfortunate "
"difference from most other computer applications, but it's been part of "
"curses since it was first written, and it's too late to change things now."
msgstr ""
"請注意，curses 中使用的坐標係是不尋常的。坐標始終按*y,x* "
"的順序傳遞，窗口左上角的坐標為(0,0)。這打破了處理 *x* 坐標首先出現的坐標的常"
"規約定。這是與大多數其他計算機應用程式的一個不幸差異，但自從它首次編寫以來，"
"它就一直是 curses 的一部分，現在改變一切為時已晚。"

#: ../../howto/curses.rst:189
#, fuzzy
msgid ""
"Your application can determine the size of the screen by using the :data:"
"`curses.LINES` and :data:`curses.COLS` variables to obtain the *y* and *x* "
"sizes.  Legal coordinates will then extend from ``(0,0)`` to ``(curses.LINES "
"- 1, curses.COLS - 1)``."
msgstr ""
"您的應用程式可以通過使用 curses.LINES 和 curses.COLS 變數獲取 *y* 和 *x* "
"大小來確定屏幕的大小。合法坐標將從“(0,0)”擴充到“(curses.LINES - 1, "
"curses.COLS - 1)”。"

#: ../../howto/curses.rst:194
#, fuzzy
msgid ""
"When you call a method to display or erase text, the effect doesn't "
"immediately show up on the display.  Instead you must call the :meth:"
"`~curses.window.refresh` method of window objects to update the screen."
msgstr ""
"當您呼叫方法來顯示或擦除文本時，效果不會立即顯示在顯示屏上。相反，"
"您必須呼叫窗口物件的 :meth:`~curses.window.refresh` 方法來更新屏幕。"

#: ../../howto/curses.rst:199
#, fuzzy
msgid ""
"This is because curses was originally written with slow 300-baud terminal "
"connections in mind; with these terminals, minimizing the time required to "
"redraw the screen was very important.  Instead curses accumulates changes to "
"the screen and displays them in the most efficient manner when you call :"
"meth:`refresh`.  For example, if your program displays some text in a window "
"and then clears the window, there's no need to send the original text "
"because they're never visible."
msgstr ""
"這是因為 curses 最初是在考慮 300 波特終端連接的情況下編寫的；對於這些終端，盡"
"量減少重繪屏幕所需的時間非常重要。相反，當您呼叫 refresh 時，curses 會累積對"
"屏幕的更改並以最有效的方式顯示它們。例如，如果您的程式在窗口中顯示一些文本然"
"後清除窗口，則無需發送原始文本，因為它們永遠不可見。"

#: ../../howto/curses.rst:208
#, fuzzy
msgid ""
"In practice, explicitly telling curses to redraw a window doesn't really "
"complicate programming with curses much. Most programs go into a flurry of "
"activity, and then pause waiting for a keypress or some other action on the "
"part of the user.  All you have to do is to be sure that the screen has been "
"redrawn before pausing to wait for user input, by first calling ``stdscr."
"refresh()`` or the :meth:`refresh` method of some other relevant window."
msgstr ""
"在實踐中，顯式地告訴 curses 重繪窗口並沒有真正使使用 curses 的編程複雜化。大"
"多數程式進入一連串的活動，然後暫停等待使用者的按鍵或其他一些操作。您所要做的"
"就是確保在暫停等待使用者輸入之前重繪屏幕，方法是首先呼叫 ``stdscr.refresh()``"
" 或其他相關窗口的 :meth:`refresh` 方法。"

#: ../../howto/curses.rst:216
#, fuzzy
msgid ""
"A pad is a special case of a window; it can be larger than the actual "
"display screen, and only a portion of the pad displayed at a time. Creating "
"a pad requires the pad's height and width, while refreshing a pad requires "
"giving the coordinates of the on-screen area where a subsection of the pad "
"will be displayed.  ::"
msgstr ""
"pad 是窗口的一個特例；它可以比實際顯示屏幕大，並且一次只顯示鍵盤的一部分。"
"建立一個 pad 需要 pad 的高度和寬度，而刷新 pad 需要給出將顯示 pad "
"的一個子部分的屏幕區域的坐標。 ::"

#: ../../howto/curses.rst:237
#, fuzzy
msgid ""
"The :meth:`refresh` call displays a section of the pad in the rectangle "
"extending from coordinate (5,5) to coordinate (20,75) on the screen; the "
"upper left corner of the displayed section is coordinate (0,0) on the pad.  "
"Beyond that difference, pads are exactly like ordinary windows and support "
"the same methods."
msgstr ""
":meth:`refresh` 呼叫在屏幕上顯示從坐標 (5,5) 到坐標 (20,75) "
"的矩形中的焊盤部分；顯示部分的左上角是焊盤上的坐標（0,0）。除了這種差異之外，"
"pad 與普通窗口完全一樣，並且支援相同的方法。"

#: ../../howto/curses.rst:243
#, fuzzy
msgid ""
"If you have multiple windows and pads on screen there is a more efficient "
"way to update the screen and prevent annoying screen flicker as each part of "
"the screen gets updated.  :meth:`refresh` actually does two things:"
msgstr ""
"如果屏幕上有多個窗口和平板，則有一種更有效的方法來更新屏幕並防止在屏幕的每個"
"部分更新時出現煩人的屏幕閃爍。 :meth:`refresh` 實際上做了兩件事："

#: ../../howto/curses.rst:248
#, fuzzy
msgid ""
"Calls the :meth:`~curses.window.noutrefresh` method of each window to update "
"an underlying data structure representing the desired state of the screen."
msgstr "呼叫每個窗口的 :meth:`~curses.window.noutrefresh` "
"方法來更新代表屏幕所需狀態的底層資料結構。"

#: ../../howto/curses.rst:251
#, fuzzy
msgid ""
"Calls the function :func:`~curses.doupdate` function to change the physical "
"screen to match the desired state recorded in the data structure."
msgstr "呼叫 :func:`~curses.doupdate` "
"函式來更改物理屏幕以匹配資料結構中記錄的所需狀態。"

#: ../../howto/curses.rst:254
#, fuzzy
msgid ""
"Instead you can call :meth:`noutrefresh` on a number of windows to update "
"the data structure, and then call :func:`doupdate` to update the screen."
msgstr "相反，您可以在多個窗口上呼叫 :meth:`noutrefresh` "
"來更新資料結構，然後呼叫 :func:`doupdate` 來更新屏幕。"

#: ../../howto/curses.rst:260
#, fuzzy
msgid "Displaying Text"
msgstr "顯示文字"

#: ../../howto/curses.rst:262
#, fuzzy
msgid ""
"From a C programmer's point of view, curses may sometimes look like a twisty "
"maze of functions, all subtly different.  For example, :c:func:`addstr` "
"displays a string at the current cursor location in the ``stdscr`` window, "
"while :c:func:`mvaddstr` moves to a given y,x coordinate first before "
"displaying the string. :c:func:`waddstr` is just like :c:func:`addstr`, but "
"allows specifying a window to use instead of using ``stdscr`` by default. :c:"
"func:`mvwaddstr` allows specifying both a window and a coordinate."
msgstr ""
"從 C 程式員的角度來看，curses 有時可能看起來像函式的曲折迷宮，所有的函式都有"
"微妙的不同。例如，:c:func:`addstr` 在 ``stdscr`` "
"窗口中的當前光標位置顯示字串，而 :c:func:`mvaddstr` "
"在顯示字串之前首先移動到給定的 y,x 坐標. :c:func:`waddstr` 就像 "
":c:func:`addstr` 一樣，但允許指定要使用的窗口，而不是預設使用 ``stdscr``。 "
":c:func:`mvwaddstr` 允許同時指定窗口和坐標。"

#: ../../howto/curses.rst:271
#, fuzzy
msgid ""
"Fortunately the Python interface hides all these details.  ``stdscr`` is a "
"window object like any other, and methods such as :meth:`~curses.window."
"addstr` accept multiple argument forms.  Usually there are four different "
"forms."
msgstr ""
"幸運的是，Python 界面隱藏了所有這些細節。 ``stdscr`` "
"是一個像任何其他窗口對像一樣的窗口物件，方法如 :meth:`~curses.window.addstr` "
"接受多個參數形式。通常有四種不同的形式。"

#: ../../howto/curses.rst:277
#, fuzzy
msgid "Form"
msgstr "形式"

#: ../../howto/curses.rst:277 ../../howto/curses.rst:345
msgid "Description"
msgstr "描述"

#: ../../howto/curses.rst:279
#, fuzzy
msgid "*str* or *ch*"
msgstr "*str* 或 *ch*"

#: ../../howto/curses.rst:279
#, fuzzy
msgid "Display the string *str* or character *ch* at the current position"
msgstr "在當前位置顯示字串 *str* 或字元 *ch*"

#: ../../howto/curses.rst:282
#, fuzzy
msgid "*str* or *ch*, *attr*"
msgstr "*str* 或 *ch*, *attr*"

#: ../../howto/curses.rst:282
#, fuzzy
msgid ""
"Display the string *str* or character *ch*, using attribute *attr* at the "
"current position"
msgstr "在當前位置使用屬性 *attr* 顯示字串 *str* 或字元 *ch*"

#: ../../howto/curses.rst:286
msgid "*y*, *x*, *str* or *ch*"
msgstr "*y*\\ 、\\ *x*\\ 、\\ *str* 或 *ch*"

#: ../../howto/curses.rst:286
#, fuzzy
msgid "Move to position *y,x* within the window, and display *str* or *ch*"
msgstr "移動到窗口內的*y,x*位置，顯示*str*或*ch*"

#: ../../howto/curses.rst:289
msgid "*y*, *x*, *str* or *ch*, *attr*"
msgstr "*y*\\ 、\\ *x*\\ 、\\ *str* 或 *ch*\\ 、\\ *attr*"

#: ../../howto/curses.rst:289
#, fuzzy
msgid ""
"Move to position *y,x* within the window, and display *str* or *ch*, using "
"attribute *attr*"
msgstr "移動到窗口內的位置 *y,x*，並使用屬性 *attr* 顯示 *str* 或 *ch*"

#: ../../howto/curses.rst:293
#, fuzzy
msgid ""
"Attributes allow displaying text in highlighted forms such as boldface, "
"underline, reverse code, or in color.  They'll be explained in more detail "
"in the next subsection."
msgstr "屬性允許以突出顯示的形式顯示文本，例如粗體、底線、反向程式碼或顏色。它們將"
"在下一小節中進行更詳細的解釋。"

#: ../../howto/curses.rst:298
#, fuzzy
msgid ""
"The :meth:`~curses.window.addstr` method takes a Python string or bytestring "
"as the value to be displayed.  The contents of bytestrings are sent to the "
"terminal as-is.  Strings are encoded to bytes using the value of the "
"window's :attr:`encoding` attribute; this defaults to the default system "
"encoding as returned by :func:`locale.getencoding`."
msgstr ""
":meth:`~curses.window.addstr` 方法將 Python 字串或位元組串作為要顯示的值。 "
"bytestrings 的內容按原樣發送到終端。使用窗口的 encoding "
"屬性的值將字串編碼為位元組；這預設為 locale.getencoding 回傳的預設系統編碼。"

#: ../../howto/curses.rst:304
#, fuzzy
msgid ""
"The :meth:`~curses.window.addch` methods take a character, which can be "
"either a string of length 1, a bytestring of length 1, or an integer."
msgstr ":meth:`~curses.window.addch` 方法接受一個字元，它可以是長度為 1 的字串、"
"長度為 1 的位元組串或整數。"

#: ../../howto/curses.rst:307
#, fuzzy
msgid ""
"Constants are provided for extension characters; these constants are "
"integers greater than 255.  For example, :const:`ACS_PLMINUS` is a +/- "
"symbol, and :const:`ACS_ULCORNER` is the upper left corner of a box (handy "
"for drawing borders).  You can also use the appropriate Unicode character."
msgstr ""
"為擴充字元提供常數；這些常數是大於 255 的整數。例如，:const:`ACS_PLMINUS` 是 "
"+/- 符號，:const:`ACS_ULCORNER` 是框的左上角（方便繪製邊框）。"
"您還可以使用適當的 Unicode 字元。"

#: ../../howto/curses.rst:313
#, fuzzy
msgid ""
"Windows remember where the cursor was left after the last operation, so if "
"you leave out the *y,x* coordinates, the string or character will be "
"displayed wherever the last operation left off.  You can also move the "
"cursor with the ``move(y,x)`` method.  Because some terminals always display "
"a flashing cursor, you may want to ensure that the cursor is positioned in "
"some location where it won't be distracting; it can be confusing to have the "
"cursor blinking at some apparently random location."
msgstr ""
"Windows 會記住上次操作後光標所在的位置，因此如果您省略 *y、x* "
"坐標，則字串或字元將顯示在上次操作停止的位置。您還可以使用 ``move(y,x)`` 方法"
"移動光標。因為某些終端總是顯示閃爍的光標，您可能希望確保光標位於不會分散注意"
"力的某個位置；讓光標在某個明顯隨機的位置閃爍可能會造成混淆。"

#: ../../howto/curses.rst:321
#, fuzzy
msgid ""
"If your application doesn't need a blinking cursor at all, you can call "
"``curs_set(False)`` to make it invisible.  For compatibility with older "
"curses versions, there's a ``leaveok(bool)`` function that's a synonym for :"
"func:`~curses.curs_set`.  When *bool* is true, the curses library will "
"attempt to suppress the flashing cursor, and you won't need to worry about "
"leaving it in odd locations."
msgstr ""
"如果您的應用程式根本不需要閃爍的光標，您可以呼叫 curs_set(False) 使其不可見。"
"為了與舊的 curses 版本相容，有一個 ``leaveok(bool)`` 函式，它是 "
":func:`~curses.curs_set` 的同義詞。當 *bool* 為真時，curses "
"庫將嘗試抑制閃爍的光標，您無需擔心將其留在奇怪的位置。"

#: ../../howto/curses.rst:330
#, fuzzy
msgid "Attributes and Color"
msgstr "屬性和顏色"

#: ../../howto/curses.rst:332
#, fuzzy
msgid ""
"Characters can be displayed in different ways.  Status lines in a text-based "
"application are commonly shown in reverse video, or a text viewer may need "
"to highlight certain words.  curses supports this by allowing you to specify "
"an attribute for each cell on the screen."
msgstr ""
"字元可以以不同的方式顯示。基於文本的應用程式中的狀態行通常以反向視頻顯示，或"
"者文本查看器可能需要突出顯示某些單詞。 curses "
"通過允許您為屏幕上的每個單元格指定一個屬性來支援這一點。"

#: ../../howto/curses.rst:337
#, fuzzy
msgid ""
"An attribute is an integer, each bit representing a different attribute.  "
"You can try to display text with multiple attribute bits set, but curses "
"doesn't guarantee that all the possible combinations are available, or that "
"they're all visually distinct.  That depends on the ability of the terminal "
"being used, so it's safest to stick to the most commonly available "
"attributes, listed here."
msgstr ""
"一個屬性是一個整數，每一位代表一個不同的屬性。您可以嘗試顯示設定了多個屬性位"
"的文本，但 curses 不保證所有可能的組合都可用，或者它們在視覺上都是不同的。這"
"取決於所使用的終端的能力，因此最安全的做法是使用此處列出的最常用的屬性。"

#: ../../howto/curses.rst:345
msgid "Attribute"
msgstr "屬性"

#: ../../howto/curses.rst:347
msgid ":const:`A_BLINK`"
msgstr ":const:`A_BLINK`"

#: ../../howto/curses.rst:347
#, fuzzy
msgid "Blinking text"
msgstr "閃爍文字"

#: ../../howto/curses.rst:349
msgid ":const:`A_BOLD`"
msgstr ":const:`A_BOLD`"

#: ../../howto/curses.rst:349
#, fuzzy
msgid "Extra bright or bold text"
msgstr "超亮或粗體文本"

#: ../../howto/curses.rst:351
msgid ":const:`A_DIM`"
msgstr ":const:`A_DIM`"

#: ../../howto/curses.rst:351
#, fuzzy
msgid "Half bright text"
msgstr "半亮文字"

#: ../../howto/curses.rst:353
msgid ":const:`A_REVERSE`"
msgstr ":const:`A_REVERSE`"

#: ../../howto/curses.rst:353
#, fuzzy
msgid "Reverse-video text"
msgstr "反向視頻文本"

#: ../../howto/curses.rst:355
msgid ":const:`A_STANDOUT`"
msgstr ":const:`A_STANDOUT`"

#: ../../howto/curses.rst:355
#, fuzzy
msgid "The best highlighting mode available"
msgstr "可用的最佳突出顯示模式"

#: ../../howto/curses.rst:357
msgid ":const:`A_UNDERLINE`"
msgstr ":const:`A_UNDERLINE`"

#: ../../howto/curses.rst:357
#, fuzzy
msgid "Underlined text"
msgstr "帶底線的文字"

#: ../../howto/curses.rst:360
#, fuzzy
msgid ""
"So, to display a reverse-video status line on the top line of the screen, "
"you could code::"
msgstr "因此，要在屏幕的頂行顯示反向視頻狀態行，您可以編寫程式碼："

#: ../../howto/curses.rst:367
#, fuzzy
msgid ""
"The curses library also supports color on those terminals that provide it. "
"The most common such terminal is probably the Linux console, followed by "
"color xterms."
msgstr "curses 庫還支援那些提供顏色的終端。最常見的此類終端可能是 Linux 控制台，"
"其次是彩色 xterms。"

#: ../../howto/curses.rst:371
#, fuzzy
msgid ""
"To use color, you must call the :func:`~curses.start_color` function soon "
"after calling :func:`~curses.initscr`, to initialize the default color set "
"(the :func:`curses.wrapper` function does this automatically).  Once that's "
"done, the :func:`~curses.has_colors` function returns TRUE if the terminal "
"in use can actually display color.  (Note: curses uses the American spelling "
"'color', instead of the Canadian/British spelling 'colour'.  If you're used "
"to the British spelling, you'll have to resign yourself to misspelling it "
"for the sake of these functions.)"
msgstr ""
"要使用顏色，您必須在呼叫 :func:`~curses.initscr` 後立即呼叫 :func:`~curses."
"start_color` 函式，以初始化預設顏色集（:func:`curses.wrapper` "
"函式執行此操作自動地）。完成後，如果正在使用的終端實際上可以顯示顏色，則 "
":func:`~curses.has_colors` 函式回傳 TRUE。 （注意：curses 使用美式拼寫 ``color``"
"，而不是加拿大/英式拼寫 ``colour``。如果您習慣了英式拼寫，您將不得不為了這些功能"
"而拼寫錯誤。 )"

#: ../../howto/curses.rst:381
#, fuzzy
msgid ""
"The curses library maintains a finite number of color pairs, containing a "
"foreground (or text) color and a background color.  You can get the "
"attribute value corresponding to a color pair with the :func:`~curses."
"color_pair` function; this can be bitwise-OR'ed with other attributes such "
"as :const:`A_REVERSE`, but again, such combinations are not guaranteed to "
"work on all terminals."
msgstr ""
"curses 庫維護有限數量的顏色對，包含前景（或文本）顏色和背景顏色。您可以使用 "
":func:`~curses.color_pair` 函式獲取顏色對對應的屬性值；這可以與其他屬性（例如"
" :const:`A_REVERSE`）進行按位或運算，但同樣，不能保證此類組合適用於所有終端。"

#: ../../howto/curses.rst:388
#, fuzzy
msgid "An example, which displays a line of text using color pair 1::"
msgstr "一個示例，它使用顏色對 1 顯示一行文本："

#: ../../howto/curses.rst:393
#, fuzzy
msgid ""
"As I said before, a color pair consists of a foreground and background "
"color. The ``init_pair(n, f, b)`` function changes the definition of color "
"pair *n*, to foreground color f and background color b.  Color pair 0 is "
"hard-wired to white on black, and cannot be changed."
msgstr ""
"正如我之前所說，顏色對由前景色和背景色組成。 ``init_pair(n, f, b)`` "
"函式將顏色對 *n* 的定義更改為前景色 f 和背景色 b。顏色對 0 "
"硬連線為黑底白字，無法更改。"

#: ../../howto/curses.rst:398
#, fuzzy
msgid ""
"Colors are numbered, and :func:`start_color` initializes 8 basic colors when "
"it activates color mode.  They are: 0:black, 1:red, 2:green, 3:yellow, 4:"
"blue, 5:magenta, 6:cyan, and 7:white.  The :mod:`curses` module defines "
"named constants for each of these colors: :const:`curses.COLOR_BLACK`, :"
"const:`curses.COLOR_RED`, and so forth."
msgstr ""
"顏色被編號，並且 :func:`start_color` 在激活顏色模式時初始化 8 種基本顏色。它"
"們是：0：黑色、1：紅色、2：綠色、3：黃色、4：藍色、5：品紅色、6：青色和 "
"7：白色。 :mod:`curses` 模組為以下每種顏色定義命名常數：:const:`curses."
"COLOR_BLACK`、:const:`curses.COLOR_RED` 等等。"

#: ../../howto/curses.rst:404
#, fuzzy
msgid ""
"Let's put all this together. To change color 1 to red text on a white "
"background, you would call::"
msgstr "讓我們把所有這些放在一起。要將顏色 1 更改為白色背景上的紅色文本，您可以呼叫："

#: ../../howto/curses.rst:409
#, fuzzy
msgid ""
"When you change a color pair, any text already displayed using that color "
"pair will change to the new colors.  You can also display new text in this "
"color with::"
msgstr "當您更改顏色對時，已經使用該顏色對顯示的任何文本都將更改為新顏色。您還可以使"
"用這種顏色顯示新文本："

#: ../../howto/curses.rst:415
#, fuzzy
msgid ""
"Very fancy terminals can change the definitions of the actual colors to a "
"given RGB value.  This lets you change color 1, which is usually red, to "
"purple or blue or any other color you like.  Unfortunately, the Linux "
"console doesn't support this, so I'm unable to try it out, and can't provide "
"any examples.  You can check if your terminal can do this by calling :func:"
"`~curses.can_change_color`, which returns ``True`` if the capability is "
"there.  If you're lucky enough to have such a talented terminal, consult "
"your system's man pages for more information."
msgstr ""
"非常奇特的終端可以將實際顏色的定義更改為給定的 RGB 值。"
"這使您可以將通常為紅色的顏色 1 "
"更改為紫色或藍色或您喜歡的任何其他顏色。不幸的是，Linux "
"控制台不支援這個，所以我無法嘗試，也無法提供任何示例。您可以通過呼叫 "
":func:`~curses.can_change_color` "
"來檢查您的終端是否可以執行此操作，如果該功能存在，它會回傳 ``True``。如果您有"
"幸擁有這樣一個有才華的終端，請查閱您系統的手冊頁以獲取更多資訊。"

#: ../../howto/curses.rst:426
#, fuzzy
msgid "User Input"
msgstr "使用者輸入"

#: ../../howto/curses.rst:428
#, fuzzy
msgid ""
"The C curses library offers only very simple input mechanisms. Python's :mod:"
"`curses` module adds a basic text-input widget.  (Other libraries such as "
"`Urwid <https://pypi.org/project/urwid/>`_ have more extensive collections "
"of widgets.)"
msgstr ""
"C curses 庫只提供非常簡單的輸入機制。 Python 的 :mod:`curses` "
"模組新增了一個基本的文本輸入小部件。 （其他庫，如`Urwid <https://pypi.org/"
"project/urwid/>`_ 有更廣泛的小部件集合。）"

#: ../../howto/curses.rst:433
#, fuzzy
msgid "There are two methods for getting input from a window:"
msgstr "從窗口獲取輸入有兩種方法："

#: ../../howto/curses.rst:435
#, fuzzy
msgid ""
":meth:`~curses.window.getch` refreshes the screen and then waits for the "
"user to hit a key, displaying the key if :func:`~curses.echo` has been "
"called earlier.  You can optionally specify a coordinate to which the cursor "
"should be moved before pausing."
msgstr ""
":meth:`~curses.window.getch` 刷新屏幕，然後等待使用者按下一個鍵，"
"如果之前呼叫了 :func:`~curses.echo` "
"則顯示該鍵。您可以選擇指定暫停前光標應移動到的坐標。"

#: ../../howto/curses.rst:440
#, fuzzy
msgid ""
":meth:`~curses.window.getkey` does the same thing but converts the integer "
"to a string.  Individual characters are returned as 1-character strings, and "
"special keys such as function keys return longer strings containing a key "
"name such as ``KEY_UP`` or ``^G``."
msgstr ""
":meth:`~curses.window.getkey` 做同樣的事情，但將整數轉換為字串。單個字元作為 "
"1 個字元的字串回傳，而特殊鍵（如功能鍵）回傳包含鍵名稱（如“KEY_UP”或“^G”）的"
"較長字串。"

#: ../../howto/curses.rst:445
#, fuzzy
msgid ""
"It's possible to not wait for the user using the :meth:`~curses.window."
"nodelay` window method. After ``nodelay(True)``, :meth:`getch` and :meth:"
"`getkey` for the window become non-blocking. To signal that no input is "
"ready, :meth:`getch` returns ``curses.ERR`` (a value of -1) and :meth:"
"`getkey` raises an exception. There's also a :func:`~curses.halfdelay` "
"function, which can be used to (in effect) set a timer on each :meth:"
"`getch`; if no input becomes available within a specified delay (measured in "
"tenths of a second), curses raises an exception."
msgstr ""
"使用 :meth:`~curses.window.nodelay` 窗口方法可以不等待使用者。在 "
"``nodelay(True)`` 之後，窗口的 :meth:`getch` 和 :meth:`getkey` "
"變成非阻塞的。為了表示沒有輸入準備就緒，getch 回傳 curses.ERR（值為 -1）並且 "
"getkey 引發例外。還有一個 :func:`~curses.halfdelay` 函式，可用於（實際上）"
"在每個 :meth:`getch` "
"上設定一個計時器；如果在指定的延遲（以十分之一秒為單位）內沒有輸入可用，則 "
"curses 會引發例外。"

#: ../../howto/curses.rst:455
#, fuzzy
msgid ""
"The :meth:`getch` method returns an integer; if it's between 0 and 255, it "
"represents the ASCII code of the key pressed.  Values greater than 255 are "
"special keys such as Page Up, Home, or the cursor keys. You can compare the "
"value returned to constants such as :const:`curses.KEY_PPAGE`, :const:"
"`curses.KEY_HOME`, or :const:`curses.KEY_LEFT`.  The main loop of your "
"program may look something like this::"
msgstr ""
":meth:`getch` 方法回傳一個整數；如果它在 0 到 255 之間，則表示按下的鍵的 "
"ASCII 程式碼。大於 255 的值是特殊鍵，例如 Page Up、Home "
"或光標鍵。您可以將回傳的值與常數進行比較，例如 curses.KEY_PPAGE、"
"curses.KEY_HOME 或 curses.KEY_LEFT。您的程式的主循環可能看起來像這樣："

#: ../../howto/curses.rst:471
#, fuzzy
msgid ""
"The :mod:`curses.ascii` module supplies ASCII class membership functions "
"that take either integer or 1-character string arguments; these may be "
"useful in writing more readable tests for such loops.  It also supplies "
"conversion functions  that take either integer or 1-character-string "
"arguments and return the same type.  For example, :func:`curses.ascii.ctrl` "
"returns the control character corresponding to its argument."
msgstr ""
":mod:`curses.ascii` 模組提供 ASCII 類成員函式，這些函式採用整數或 1 "
"個字元的字串參數；這些可能有助於為此類循環編寫更具可讀性的測試。"
"它還提供採用整數或 1 "
"個字元的字串參數並回傳相同型別的轉換函式。例如，:func:`curses.ascii.ctrl` "
"回傳與其參數對應的控制字元。"

#: ../../howto/curses.rst:478
#, fuzzy
msgid ""
"There's also a method to retrieve an entire string, :meth:`~curses.window."
"getstr`.  It isn't used very often, because its functionality is quite "
"limited; the only editing keys available are the backspace key and the Enter "
"key, which terminates the string.  It can optionally be limited to a fixed "
"number of characters. ::"
msgstr ""
"還有一種檢索整個字串的方法，:meth:`~curses.window."
"getstr`。它不常使用，因為它的功能非常有限；"
"唯一可用的編輯鍵是退格鍵和終止字串的 Enter "
"鍵。它可以選擇限制為固定數量的字元。 ::"

#: ../../howto/curses.rst:489
#, fuzzy
msgid ""
"The :mod:`curses.textpad` module supplies a text box that supports an Emacs-"
"like set of keybindings.  Various methods of the :class:`~curses.textpad."
"Textbox` class support editing with input validation and gathering the edit "
"results either with or without trailing spaces.  Here's an example::"
msgstr ""
":mod:`curses.textpad` 模組提供了一個文本框，支援一組類似 Emacs 的鍵綁定。 "
":class:`~curses.textpad.Textbox` 類的各種方法支援使用輸入驗證進行編輯，並收集"
"帶有或不帶尾隨空格的編輯結果。這是一個例子::"

#: ../../howto/curses.rst:513
#, fuzzy
msgid ""
"See the library documentation on :mod:`curses.textpad` for more details."
msgstr "有關詳細資訊，請參閱有關 curses.textpad 的庫文檔。"

#: ../../howto/curses.rst:517
#, fuzzy
msgid "For More Information"
msgstr "了解更多資訊"

#: ../../howto/curses.rst:519
#, fuzzy
msgid ""
"This HOWTO doesn't cover some advanced topics, such as reading the contents "
"of the screen or capturing mouse events from an xterm instance, but the "
"Python library page for the :mod:`curses` module is now reasonably "
"complete.  You should browse it next."
msgstr ""
"這份 HOWTO 沒有涵蓋一些高階主題，例如讀取屏幕內容或從 xterm "
"實例捕獲鼠標事件，但 :mod:`curses` 模組的 Python "
"庫頁面現在相當完整。接下來你應該瀏覽它。"

#: ../../howto/curses.rst:524
#, fuzzy
msgid ""
"If you're in doubt about the detailed behavior of the curses functions, "
"consult the manual pages for your curses implementation, whether it's "
"ncurses or a proprietary Unix vendor's.  The manual pages will document any "
"quirks, and provide complete lists of all the functions, attributes, and :"
"const:`ACS_\\*` characters available to you."
msgstr ""
"如果您對 curses 函式的詳細行為有疑問，請查閱您的 curses 實作的手冊頁，"
"無論它是 ncurses 還是專有的 Unix "
"供應商的。手冊頁將記錄任何怪癖，並提供所有可用的函式、屬性和 :const:`ACS_\\*` "
"字元的完整列表。"

#: ../../howto/curses.rst:531
#, fuzzy
msgid ""
"Because the curses API is so large, some functions aren't supported in the "
"Python interface.  Often this isn't because they're difficult to implement, "
"but because no one has needed them yet.  Also, Python doesn't yet support "
"the menu library associated with ncurses. Patches adding support for these "
"would be welcome; see `the Python Developer's Guide <https://devguide.python."
"org/>`_ to learn more about submitting patches to Python."
msgstr ""
"由於 curses API 太大，Python 介面不支援某些函式。通常這不是因為它們難以實施，"
"而是因為還沒有人需要它們。此外，Python 還不支援與 ncurses "
"關聯的菜單庫。歡迎補丁新增對這些的支援；請參閱`Python 開發人員指南 "
"<https://devguide.python.org/>`_ 以了解有關向 Python 提交補丁的更多資訊。"

#: ../../howto/curses.rst:539
#, fuzzy
msgid ""
"`Writing Programs with NCURSES <https://invisible-island.net/ncurses/ncurses-"
"intro.html>`_: a lengthy tutorial for C programmers."
msgstr ""
"`使用 NCURSES <https://invisible-island.net/ncurses/ncurses-intro.html>`_：C "
"程式員的冗長教程。"

#: ../../howto/curses.rst:541
msgid "`The ncurses man page <https://linux.die.net/man/3/ncurses>`_"
msgstr "`ncurses 使用者手冊 <https://linux.die.net/man/3/ncurses>`_"

#: ../../howto/curses.rst:542
msgid ""
"`The ncurses FAQ <https://invisible-island.net/ncurses/ncurses.faq.html>`_"
msgstr ""
"`ncurses 問答集 <https://invisible-island.net/ncurses/ncurses.faq.html>`_"

#: ../../howto/curses.rst:543
#, fuzzy
msgid ""
"`\"Use curses... don't swear\" <https://www.youtube.com/watch?"
"v=eN1eZtjLEnU>`_: video of a PyCon 2013 talk on controlling terminals using "
"curses or Urwid."
msgstr ""
"`“使用詛咒……不要發誓”<https://www.youtube.com/watch?v=eN1eZtjLEnU>`_：PyCon "
"2013 上關於使用 curses 或 Urwid 控制終端的演講視頻。"

#: ../../howto/curses.rst:545
#, fuzzy
msgid ""
"`\"Console Applications with Urwid\" <https://pyvideo.org/video/1568/console-"
"applications-with-urwid>`_: video of a PyCon CA 2012 talk demonstrating some "
"applications written using Urwid."
msgstr ""
"`“使用 Urwid 的控制台應用程式”<https://pyvideo.org/video/1568/console-"
"applications-with-urwid>`_：PyCon CA 2012 演講視頻演示了一些使用 Urwid "
"編寫的應用程式。"
