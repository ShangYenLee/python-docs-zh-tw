# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-09-26 00:21+0000\n"
"PO-Revision-Date: 2018-05-23 14:37+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/unicode.rst:5
#, fuzzy
msgid "Unicode HOWTO"
msgstr "統一碼指南"

#: ../../howto/unicode.rst:0
msgid "Release"
msgstr "發佈版本"

#: ../../howto/unicode.rst:7
msgid "1.12"
msgstr "1.12"

#: ../../howto/unicode.rst:9
#, fuzzy
msgid ""
"This HOWTO discusses Python's support for the Unicode specification for "
"representing textual data, and explains various problems that people "
"commonly encounter when trying to work with Unicode."
msgstr ""
"這份 HOWTO 討論了 Python 對錶示文本資料的 Unicode 規範的支援，"
"並解釋了人們在嘗試使用 Unicode 時經常遇到的各種問題。"

#: ../../howto/unicode.rst:15
#, fuzzy
msgid "Introduction to Unicode"
msgstr "Unicode簡介"

#: ../../howto/unicode.rst:18
msgid "Definitions"
msgstr "定義"

#: ../../howto/unicode.rst:20
#, fuzzy
msgid ""
"Today's programs need to be able to handle a wide variety of characters.  "
"Applications are often internationalized to display messages and output in a "
"variety of user-selectable languages; the same program might need to output "
"an error message in English, French, Japanese, Hebrew, or Russian.  Web "
"content can be written in any of these languages and can also include a "
"variety of emoji symbols. Python's string type uses the Unicode Standard for "
"representing characters, which lets Python programs work with all these "
"different possible characters."
msgstr ""
"今天的程式需要能夠處理各種各樣的字元。應用程式通常被國際化以顯示消息並以多種"
"使用者可選擇的語言輸出；同一個程式可能需要用英語、法語、日語、希伯來語或俄語"
"輸出錯誤消息。 Web "
"內容可以用這些語言中的任何一種編寫，還可以包含各種表情符號。 Python "
"的字串型別使用 Unicode 標準來表示字元，這讓 Python "
"程式可以處理所有這些不同的可能字元。"

#: ../../howto/unicode.rst:30
#, fuzzy
msgid ""
"Unicode (https://www.unicode.org/) is a specification that aims to list "
"every character used by human languages and give each character its own "
"unique code.  The Unicode specifications are continually revised and updated "
"to add new languages and symbols."
msgstr ""
"Unicode (https://www.unicode.org/) 是一種規範，旨在列出人類語言使用的每個字元"
"，並為每個字元賦予其自己的唯一程式碼。 Unicode "
"規範不斷修訂和更新以新增新的語言和符號。"

#: ../../howto/unicode.rst:35
#, fuzzy
msgid ""
"A **character** is the smallest possible component of a text.  'A', 'B', "
"'C', etc., are all different characters.  So are 'È' and 'Í'.  Characters "
"vary depending on the language or context you're talking about.  For "
"example, there's a character for \"Roman Numeral One\", 'Ⅰ', that's separate "
"from the uppercase letter 'I'.  They'll usually look the same, but these are "
"two different characters that have different meanings."
msgstr ""
"**字元**是文本的最小可能組成部分。 'A'、'B'、'C'等，都是不同的字元。  ``È``和 ``Í``"
"也是如此。字元因您所談論的語言或上下文而異。例如，“羅馬數字一”有一個字元 ``Ⅰ``，"
"它與大寫字母 ``I``分開。它們通常看起來相同，但這是兩個具有不同含義的不同字元。"

#: ../../howto/unicode.rst:42
#, fuzzy
msgid ""
"The Unicode standard describes how characters are represented by **code "
"points**.  A code point value is an integer in the range 0 to 0x10FFFF "
"(about 1.1 million values, the `actual number assigned <https://www.unicode."
"org/versions/latest/#Summary>`_ is less than that). In the standard and in "
"this document, a code point is written using the notation ``U+265E`` to mean "
"the character with value ``0x265e`` (9,822 in decimal)."
msgstr ""
"Unicode 標準描述了字元如何由**程式碼點**表示。程式碼點值是 0 到 0x10FFFF "
"範圍內的整數（大約 110 萬個值，分配的實際數量<https://www.unicode.org/"
"versions/latest/#Summary>`_ "
"小於該值）。在標準和本文檔中，程式碼點使用符號 ``U+265E``來表示值為 ``0x265e``（"
"十進位為 9,822）的字元。"

#: ../../howto/unicode.rst:50
#, fuzzy
msgid ""
"The Unicode standard contains a lot of tables listing characters and their "
"corresponding code points:"
msgstr "Unicode 標準包含許多列出字元及其對應程式碼點的表格："

#: ../../howto/unicode.rst:71
#, fuzzy
msgid ""
"Strictly, these definitions imply that it's meaningless to say 'this is "
"character ``U+265E``'.  ``U+265E`` is a code point, which represents some "
"particular character; in this case, it represents the character 'BLACK CHESS "
"KNIGHT', '♞'.  In informal contexts, this distinction between code points "
"and characters will sometimes be forgotten."
msgstr ""
"嚴格來說，這些定義意味著說“這是字元 ``U+265E``' 是沒有意義的。 ``U+265E`` 是"
"一個程式碼點，代表一些特定的字元；在本例中，它代表字元“黑棋騎士”、 ``♞``。在非正"
"式環境中，程式碼點和字元之間的區別有時會被遺忘。"

#: ../../howto/unicode.rst:78
#, fuzzy
msgid ""
"A character is represented on a screen or on paper by a set of graphical "
"elements that's called a **glyph**.  The glyph for an uppercase A, for "
"example, is two diagonal strokes and a horizontal stroke, though the exact "
"details will depend on the font being used.  Most Python code doesn't need "
"to worry about glyphs; figuring out the correct glyph to display is "
"generally the job of a GUI toolkit or a terminal's font renderer."
msgstr ""
"字元在屏幕上或紙上由一組稱為 **字形** 的圖形元素表示。例如，大寫字母 A "
"的字形是兩個對角線筆劃和一個水平筆劃，但具體細節將取決於所使用的字體。大多數 "
"Python 程式碼不需要擔心字形；確定要顯示的正確字形通常是 GUI "
"工具包或終端字體渲染器的工作。"

#: ../../howto/unicode.rst:87
#, fuzzy
msgid "Encodings"
msgstr "編碼"

#: ../../howto/unicode.rst:89
#, fuzzy
msgid ""
"To summarize the previous section: a Unicode string is a sequence of code "
"points, which are numbers from 0 through ``0x10FFFF`` (1,114,111 decimal).  "
"This sequence of code points needs to be represented in memory as a set of "
"**code units**, and **code units** are then mapped to 8-bit bytes.  The "
"rules for translating a Unicode string into a sequence of bytes are called a "
"**character encoding**, or just an **encoding**."
msgstr ""
"總結上一節：Unicode 字串是程式碼點序列，程式碼點是從 0 到 0x10FFFF（十進位 1,"
"114,111）的數字。這個程式碼點序列需要在記憶體中表示為一組**程式碼單元**，然後"
"將**程式碼單元**映射到8位位元組。將 Unicode 字串轉換為位元組序列的規則稱為 "
"**字元編碼**，或簡稱為 **編碼**。"

#: ../../howto/unicode.rst:97
#, fuzzy
msgid ""
"The first encoding you might think of is using 32-bit integers as the code "
"unit, and then using the CPU's representation of 32-bit integers. In this "
"representation, the string \"Python\" might look like this:"
msgstr ""
"您可能首先想到的編碼是使用 32 位整數作為程式碼單元，然後使用 CPU 對 32 "
"位整數的表示。在此表示中，字串 ``Python``可能如下所示："

#: ../../howto/unicode.rst:107
#, fuzzy
msgid ""
"This representation is straightforward but using it presents a number of "
"problems."
msgstr "這種表示很簡單，但使用它會帶來許多問題。"

#: ../../howto/unicode.rst:110
#, fuzzy
msgid "It's not portable; different processors order the bytes differently."
msgstr "它不是便攜式的；不同的處理器對位元組的排序不同。"

#: ../../howto/unicode.rst:112
#, fuzzy
msgid ""
"It's very wasteful of space.  In most texts, the majority of the code points "
"are less than 127, or less than 255, so a lot of space is occupied by "
"``0x00`` bytes.  The above string takes 24 bytes compared to the 6 bytes "
"needed for an ASCII representation.  Increased RAM usage doesn't matter too "
"much (desktop computers have gigabytes of RAM, and strings aren't usually "
"that large), but expanding our usage of disk and network bandwidth by a "
"factor of 4 is intolerable."
msgstr ""
"這是非常浪費空間的。在大多數文本中，大多數程式碼點小於 127，或小於 "
"255，因此大量空間被 ``0x00``位元組佔用。與 ASCII 表示所需的 6 個位元組相比，"
"上述字串佔用 24 個位元組。增加 RAM 使用量並不重要（台式計算機有 GB 的 "
"RAM，字串通常不會那麼大），但是將我們的磁盤和網絡帶寬使用量增加 4 "
"倍是無法容忍的。"

#: ../../howto/unicode.rst:120
#, fuzzy
msgid ""
"It's not compatible with existing C functions such as ``strlen()``, so a new "
"family of wide string functions would need to be used."
msgstr "它與現有的 C 函式不相容，例如 "
"``strlen()``，因此需要使用一系列新的寬字串函式。"

#: ../../howto/unicode.rst:123
#, fuzzy
msgid ""
"Therefore this encoding isn't used very much, and people instead choose "
"other encodings that are more efficient and convenient, such as UTF-8."
msgstr "因此這種編碼使用不多，人們轉而選擇其他更高效、更方便的編碼，如UTF-8。"

#: ../../howto/unicode.rst:126
#, fuzzy
msgid ""
"UTF-8 is one of the most commonly used encodings, and Python often defaults "
"to using it.  UTF stands for \"Unicode Transformation Format\", and the '8' "
"means that 8-bit values are used in the encoding.  (There are also UTF-16 "
"and UTF-32 encodings, but they are less frequently used than UTF-8.)  UTF-8 "
"uses the following rules:"
msgstr ""
"UTF-8 是最常用的編碼之一，Python 通常預設使用它。 UTF 代表“Unicode "
"Transformation Format”，'8' 表示在編碼中使用 8 位值。 （還有 UTF-16 和 UTF-"
"32 編碼，但它們的使用頻率低於 UTF-8。）UTF-8 使用以下規則："

#: ../../howto/unicode.rst:132
#, fuzzy
msgid ""
"If the code point is < 128, it's represented by the corresponding byte value."
msgstr "如果程式碼點 < 128，則由相應的位元組值表示。"

#: ../../howto/unicode.rst:133
#, fuzzy
msgid ""
"If the code point is >= 128, it's turned into a sequence of two, three, or "
"four bytes, where each byte of the sequence is between 128 and 255."
msgstr "如果程式碼點 >= 128，它會變成兩個、三個或四個位元組的序列，"
"其中序列的每個位元組都在 128 到 255 之間。"

#: ../../howto/unicode.rst:136
#, fuzzy
msgid "UTF-8 has several convenient properties:"
msgstr "UTF-8 有幾個方便的屬性："

#: ../../howto/unicode.rst:138
#, fuzzy
msgid "It can handle any Unicode code point."
msgstr "它可以處理任何 Unicode 程式碼點。"

#: ../../howto/unicode.rst:139
#, fuzzy
msgid ""
"A Unicode string is turned into a sequence of bytes that contains embedded "
"zero bytes only where they represent the null character (U+0000). This means "
"that UTF-8 strings can be processed by C functions such as ``strcpy()`` and "
"sent through protocols that can't handle zero bytes for anything other than "
"end-of-string markers."
msgstr ""
"一個 Unicode 字串被轉換成一個位元組序列，其中僅在代表空字元 (U+0000) "
"的地方包含嵌入的零位元組。這意味著 UTF-8 字串可以由 C 函式處理，例如 "
"``strcpy()`` 並通過不能處理除字串結束標記之外的任何零位元組的協定發送。"

#: ../../howto/unicode.rst:144
#, fuzzy
msgid "A string of ASCII text is also valid UTF-8 text."
msgstr "ASCII 文本字串也是有效的 UTF-8 文本。"

#: ../../howto/unicode.rst:145
#, fuzzy
msgid ""
"UTF-8 is fairly compact; the majority of commonly used characters can be "
"represented with one or two bytes."
msgstr "UTF-8 相當緊湊；大多數常用字元可以用一個或兩個位元組表示。"

#: ../../howto/unicode.rst:147
#, fuzzy
msgid ""
"If bytes are corrupted or lost, it's possible to determine the start of the "
"next UTF-8-encoded code point and resynchronize.  It's also unlikely that "
"random 8-bit data will look like valid UTF-8."
msgstr "如果位元組損壞或丟失，則可以確定下一個 UTF-8 編碼程式碼點的開始並重新同步。"
"隨機 8 位資料也不太可能看起來像有效的 UTF-8。"

#: ../../howto/unicode.rst:150
#, fuzzy
msgid ""
"UTF-8 is a byte oriented encoding. The encoding specifies that each "
"character is represented by a specific sequence of one or more bytes. This "
"avoids the byte-ordering issues that can occur with integer and word "
"oriented encodings, like UTF-16 and UTF-32, where the sequence of bytes "
"varies depending on the hardware on which the string was encoded."
msgstr ""
"UTF-8 是一種面向位元組的編碼。編碼指定每個字元由一個或多個位元組的特定序列表"
"示。這避免了整數和麵向字的編碼（如 UTF-16 和 "
"UTF-32）可能出現的位元組順序問題，其中位元組序列因編碼字串的硬件而異。"

#: ../../howto/unicode.rst:158 ../../howto/unicode.rst:514
#: ../../howto/unicode.rst:735
#, fuzzy
msgid "References"
msgstr "參考"

#: ../../howto/unicode.rst:160
#, fuzzy
msgid ""
"The `Unicode Consortium site <https://www.unicode.org>`_ has character "
"charts, a glossary, and PDF versions of the Unicode specification.  Be "
"prepared for some difficult reading.  `A chronology <https://www.unicode.org/"
"history/>`_ of the origin and development of Unicode is also available on "
"the site."
msgstr ""
"`Unicode 聯盟網站 <https://www.unicode.org>`_ 有字元表、詞彙表和 Unicode "
"規範的 PDF 版本。為一些困難的閱讀做好準備。網站上還提供了 Unicode "
"起源和發展的年表 <https://www.unicode.org/history/>。"

#: ../../howto/unicode.rst:165
#, fuzzy
msgid ""
"On the Computerphile Youtube channel, Tom Scott briefly `discusses the "
"history of Unicode and UTF-8 <https://www.youtube.com/watch?v=MijmeoH9LT4>`_ "
"(9 minutes 36 seconds)."
msgstr ""
"在 Computerphile Youtube 頻道上，Tom Scott 簡要地`討論了 Unicode 和 UTF-8 "
"的歷史 <https://www.youtube.com/watch?v=MijmeoH9LT4>`_（9 分 36 秒）。"

#: ../../howto/unicode.rst:169
#, fuzzy
msgid ""
"To help understand the standard, Jukka Korpela has written `an introductory "
"guide <https://jkorpela.fi/unicode/guide.html>`_ to reading the Unicode "
"character tables."
msgstr ""
"為了幫助理解該標準，Jukka Korpela 編寫了`一個介紹性指南 <https://jkorpela.fi/"
"unicode/guide.html>`_ 來閱讀 Unicode 字元表。"

#: ../../howto/unicode.rst:173
#, fuzzy
msgid ""
"Another `good introductory article <https://www.joelonsoftware."
"com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-"
"positively-must-know-about-unicode-and-character-sets-no-excuses/>`_ was "
"written by Joel Spolsky. If this introduction didn't make things clear to "
"you, you should try reading this alternate article before continuing."
msgstr ""
"另一篇很好的介紹性文章 <https://www.joelonsoftware.com/2003/10/08/the-"
"absolute-minimum-every-software-developer-absolutely-positively-must-know-"
"about-unicode-and-character- sets-no-excuses/>`_ 由 Joel Spolsky "
"編寫。如果這篇介紹沒有讓您明白，您應該在繼續之前嘗試閱讀這篇替代文章。"

#: ../../howto/unicode.rst:178
#, fuzzy
msgid ""
"Wikipedia entries are often helpful; see the entries for \"`character "
"encoding <https://en.wikipedia.org/wiki/Character_encoding>`_\" and `UTF-8 "
"<https://en.wikipedia.org/wiki/UTF-8>`_, for example."
msgstr ""
"維基百科條目通常很有幫助；查看“`字元編碼<https://en.wikipedia.org/wiki/"
"Character_encoding>`_”和`UTF-8 <https://en.wikipedia.org/wiki/"
"UTF-8>`_的條目， 例如。"

#: ../../howto/unicode.rst:184
#, fuzzy
msgid "Python's Unicode Support"
msgstr "Python 的 Unicode 支援"

#: ../../howto/unicode.rst:186
#, fuzzy
msgid ""
"Now that you've learned the rudiments of Unicode, we can look at Python's "
"Unicode features."
msgstr "現在您已經了解了 Unicode 的基本知識，我們可以看看 Python 的 Unicode 特性。"

#: ../../howto/unicode.rst:190
#, fuzzy
msgid "The String Type"
msgstr "字串型別"

#: ../../howto/unicode.rst:192
#, fuzzy
msgid ""
"Since Python 3.0, the language's :class:`str` type contains Unicode "
"characters, meaning any string created using ``\"unicode rocks!\"``, "
"``'unicode rocks!'``, or the triple-quoted string syntax is stored as "
"Unicode."
msgstr ""
"從 Python 3.0 開始，該語言的 str 型別包含 Unicode 字元，這意味著使用“unicode "
"rocks!”、“unicode rocks!”或三引號字串語法建立的任何字串都是儲存為 Unicode。"

#: ../../howto/unicode.rst:196
#, fuzzy
msgid ""
"The default encoding for Python source code is UTF-8, so you can simply "
"include a Unicode character in a string literal::"
msgstr "Python 源程式碼的預設編碼是 UTF-8，因此您可以簡單地在字串文字中包含一個 "
"Unicode 字元："

#: ../../howto/unicode.rst:206
#, fuzzy
msgid ""
"Side note: Python 3 also supports using Unicode characters in identifiers::"
msgstr "旁注：Python 3 還支援在標識符中使用 Unicode 字元::"

#: ../../howto/unicode.rst:212
#, fuzzy
msgid ""
"If you can't enter a particular character in your editor or want to keep the "
"source code ASCII-only for some reason, you can also use escape sequences in "
"string literals. (Depending on your system, you may see the actual capital-"
"delta glyph instead of a \\u escape.) ::"
msgstr ""
"如果您不能在編輯器中輸入特定字元，或者出於某種原因想要保留源程式碼僅 "
"ASCII，您還可以在字串文字中使用轉義序列。 （根據您的系統，"
"您可能會看到實際的大寫字母三角符號而不是 \\u 轉義符。）::"

#: ../../howto/unicode.rst:224
#, fuzzy
msgid ""
"In addition, one can create a string using the :func:`~bytes.decode` method "
"of :class:`bytes`.  This method takes an *encoding* argument, such as "
"``UTF-8``, and optionally an *errors* argument."
msgstr ""
"此外，可以使用 bytes 的 :func:`~bytes.decode` 方法建立一個字串。此方法採用 "
"*encoding* 參數，例如 ``UTF-8`` 和可選的 *errors* 參數。"

#: ../../howto/unicode.rst:228
#, fuzzy
msgid ""
"The *errors* argument specifies the response when the input string can't be "
"converted according to the encoding's rules.  Legal values for this argument "
"are ``'strict'`` (raise a :exc:`UnicodeDecodeError` exception), "
"``'replace'`` (use ``U+FFFD``, ``REPLACEMENT CHARACTER``), ``'ignore'`` "
"(just leave the character out of the Unicode result), or "
"``'backslashreplace'`` (inserts a ``\\xNN`` escape sequence). The following "
"examples show the differences::"
msgstr ""
"*errors* "
"參數指定無法根據編碼規則轉換輸入字串時的響應。此參數的合法值是 ``'strict'``（引發 "
"UnicodeDecodeError 例外）、 ``'replace'`` （使用 ``U+FFFD``、“REPLACEMENT "
"CHARACTER”）、 ``'ignore'``（將字元從 Unicode 結果中刪除），或 "
"``'backslashreplace'``（插入一個 ``\\xNN`` 轉義序列）。以下示例顯示了差異::"

#: ../../howto/unicode.rst:248
#, fuzzy
msgid ""
"Encodings are specified as strings containing the encoding's name.  Python "
"comes with roughly 100 different encodings; see the Python Library Reference "
"at :ref:`standard-encodings` for a list.  Some encodings have multiple "
"names; for example, ``'latin-1'``, ``'iso_8859_1'`` and ``'8859``' are all "
"synonyms for the same encoding."
msgstr ""
"編碼被指定為包含編碼名稱的字串。 Python 帶有大約 100 種不同的編碼；"
"請參閱位於 :ref:`standard-encodings` 的 Python "
"庫參考以獲取列表。一些編碼有多個名稱；例如，``'latin-1'``、``'iso_8859_1'`` "
"和 ``'8859``' 都是相同編碼的同義詞。"

#: ../../howto/unicode.rst:254
#, fuzzy
msgid ""
"One-character Unicode strings can also be created with the :func:`chr` built-"
"in function, which takes integers and returns a Unicode string of length 1 "
"that contains the corresponding code point.  The reverse operation is the "
"built-in :func:`ord` function that takes a one-character Unicode string and "
"returns the code point value::"
msgstr ""
"單字元 Unicode 字串也可以使用 :func:`chr` 內建函式建立，"
"該函式接受整數並回傳長度為 1 的包含相應程式碼點的 Unicode 字串。"
"反向操作是內建的 :func:`ord` 函式，它接受一個字元的 Unicode "
"字串並回傳程式碼點值::"

#: ../../howto/unicode.rst:266
#, fuzzy
msgid "Converting to Bytes"
msgstr "轉換為位元組"

#: ../../howto/unicode.rst:268
#, fuzzy
msgid ""
"The opposite method of :meth:`bytes.decode` is :meth:`str.encode`, which "
"returns a :class:`bytes` representation of the Unicode string, encoded in "
"the requested *encoding*."
msgstr ""
":meth:`bytes.decode` 的相反方法是 :meth:`str.encode`，它回傳 :class:`bytes` "
"表示的 Unicode 字串，以請求的 *encoding* 編碼。"

#: ../../howto/unicode.rst:272
#, fuzzy
msgid ""
"The *errors* parameter is the same as the parameter of the :meth:`~bytes."
"decode` method but supports a few more possible handlers. As well as "
"``'strict'``, ``'ignore'``, and ``'replace'`` (which in this case inserts a "
"question mark instead of the unencodable character), there is also "
"``'xmlcharrefreplace'`` (inserts an XML character reference), "
"``backslashreplace`` (inserts a ``\\uNNNN`` escape sequence) and "
"``namereplace`` (inserts a ``\\N{...}`` escape sequence)."
msgstr ""
"*errors* 參數與 :meth:`~bytes.decode` 方法的參數相同，但支援更多可能的處理程"
"序。除了 ``'strict'``、``'ignore'`` 和 ``'replace'``（在本例中插入問號而不是不可編碼字元）之外，還"
"有 ``'xmlcharrefreplace'`` '``（插入一個 XML 字元引用），``backslashreplace``（"
"插入一個 ``\\uNNNN`` 轉義序列）和 ``namereplace``（插入一個 ``\\N{...}`` "
"轉義序列)."

#: ../../howto/unicode.rst:280
#, fuzzy
msgid "The following example shows the different results::"
msgstr "以下示例顯示了不同的結果："

#: ../../howto/unicode.rst:301
#, fuzzy
msgid ""
"The low-level routines for registering and accessing the available encodings "
"are found in the :mod:`codecs` module.  Implementing new encodings also "
"requires understanding the :mod:`codecs` module. However, the encoding and "
"decoding functions returned by this module are usually more low-level than "
"is comfortable, and writing new encodings is a specialized task, so the "
"module won't be covered in this HOWTO."
msgstr ""
"在 :mod:`codecs` 模組中可以找到用於註冊和訪問可用編碼的低階例程。"
"實施新編碼還需要了解 :mod:`codecs` 模組。然而，這個模組回傳的編碼和解碼函式通"
"常比舒適的更底層，編寫新的編碼是一項專門的任務，因此本 HOWTO 不會涵蓋該模組。"

#: ../../howto/unicode.rst:310
#, fuzzy
msgid "Unicode Literals in Python Source Code"
msgstr "Python 源程式碼中的 Unicode 文字"

#: ../../howto/unicode.rst:312
#, fuzzy
msgid ""
"In Python source code, specific Unicode code points can be written using the "
"``\\u`` escape sequence, which is followed by four hex digits giving the "
"code point.  The ``\\U`` escape sequence is similar, but expects eight hex "
"digits, not four::"
msgstr ""
"在 Python 源程式碼中，可以使用 ``\\u`` 轉義序列編寫特定的 Unicode "
"程式碼點，後跟四個十六進位數字給出程式碼點。 ``\\U`` "
"轉義序列類似，但需要八個十六進位數字，而不是四個::"

#: ../../howto/unicode.rst:324
#, fuzzy
msgid ""
"Using escape sequences for code points greater than 127 is fine in small "
"doses, but becomes an annoyance if you're using many accented characters, as "
"you would in a program with messages in French or some other accent-using "
"language.  You can also assemble strings using the :func:`chr` built-in "
"function, but this is even more tedious."
msgstr ""
"對大於 127 的程式碼點使用轉義序列少量使用是沒問題的，但如果您使用許多重音字元"
"，就像在使用法語或其他使用重音的語言的消息的程式中一樣，就會變得很煩人。"
"您還可以使用 :func:`chr` 內建函式組裝字串，但這更加乏味。"

#: ../../howto/unicode.rst:330
#, fuzzy
msgid ""
"Ideally, you'd want to be able to write literals in your language's natural "
"encoding.  You could then edit Python source code with your favorite editor "
"which would display the accented characters naturally, and have the right "
"characters used at runtime."
msgstr ""
"理想情況下，您希望能夠以您的語言的自然編碼編寫文字。"
"然後你可以用你最喜歡的編輯器編輯 Python "
"源程式碼，它會自然地顯示重音字元，並在運行時使用正確的字元。"

#: ../../howto/unicode.rst:335
#, fuzzy
msgid ""
"Python supports writing source code in UTF-8 by default, but you can use "
"almost any encoding if you declare the encoding being used.  This is done by "
"including a special comment as either the first or second line of the source "
"file::"
msgstr ""
"Python 預設支援以 UTF-8 編寫源程式碼，但如果您聲明所使用的編碼，則幾乎可以使"
"用任何編碼。這是通過在源文件的第一行或第二行包含特殊註釋來完成的："

#: ../../howto/unicode.rst:345
#, fuzzy
msgid ""
"The syntax is inspired by Emacs's notation for specifying variables local to "
"a file.  Emacs supports many different variables, but Python only supports "
"'coding'.  The ``-*-`` symbols indicate to Emacs that the comment is "
"special; they have no significance to Python but are a convention.  Python "
"looks for ``coding: name`` or ``coding=name`` in the comment."
msgstr ""
"該語法的靈感來自 Emacs 用於指定文件局部變數的符號。 Emacs "
"支援許多不同的變數，但 Python 只支援“編碼”。 ``-*-`` 符號向 Emacs "
"表明註釋是特殊的；它們對 Python 沒有意義，而是一種約定。 Python 在註釋中查找 "
"``coding: name`` 或 ``coding=name``。"

#: ../../howto/unicode.rst:351
#, fuzzy
msgid ""
"If you don't include such a comment, the default encoding used will be UTF-8 "
"as already mentioned.  See also :pep:`263` for more information."
msgstr "如果您不包含這樣的註釋，則使用的預設編碼將是已經提到的 UTF-8。另請參閱 "
":pep:`263` 了解更多資訊。"

#: ../../howto/unicode.rst:356
#, fuzzy
msgid "Unicode Properties"
msgstr "Unicode 屬性"

#: ../../howto/unicode.rst:358
#, fuzzy
msgid ""
"The Unicode specification includes a database of information about code "
"points.  For each defined code point, the information includes the "
"character's name, its category, the numeric value if applicable (for "
"characters representing numeric concepts such as the Roman numerals, "
"fractions such as one-third and four-fifths, etc.).  There are also display-"
"related properties, such as how to use the code point in bidirectional text."
msgstr ""
"Unicode 規範包括一個關於程式碼點的資訊資料庫。對於每個定義的程式碼點，資訊包"
"括字元的名稱、類別、數值（如果適用）（對於表示數字概念的字元，例如羅馬數字、"
"分數，例如三分之一和五分之四等）。還有與顯示相關的屬性，例如如何在雙向文本中"
"使用程式碼點。"

#: ../../howto/unicode.rst:366
#, fuzzy
msgid ""
"The following program displays some information about several characters, "
"and prints the numeric value of one particular character::"
msgstr "下面的程式顯示了一些關於幾個字元的資訊，並印出了一個特定字元的數值："

#: ../../howto/unicode.rst:380
#, fuzzy
msgid "When run, this prints:"
msgstr "運行時，印出："

#: ../../howto/unicode.rst:391
#, fuzzy
msgid ""
"The category codes are abbreviations describing the nature of the character. "
"These are grouped into categories such as \"Letter\", \"Number\", "
"\"Punctuation\", or \"Symbol\", which in turn are broken up into "
"subcategories.  To take the codes from the above output, ``'Ll'`` means "
"'Letter, lowercase', ``'No'`` means \"Number, other\", ``'Mn'`` is \"Mark, "
"nonspacing\", and ``'So'`` is \"Symbol, other\".  See `the General Category "
"Values section of the Unicode Character Database documentation <https://www."
"unicode.org/reports/tr44/#General_Category_Values>`_ for a list of category "
"codes."
msgstr ""
"類別程式碼是描述字元性質的縮寫。這些被分組為“字母”、“數字”、“標點符號”或“符號"
"”等類別，這些類別又被分解為子類別別。從上面的輸出中獲取程式碼， ``Ll``表示“字母"
"，小寫”， ``No``表示“其他數字”， ``Mn``表示“標記，非間距” "
"，而``'So'``是“符號，其他”。有關類別程式碼列表，請參閱 Unicode "
"字元資料庫文檔 <https://www.unicode.org/reports/tr44/#"
"General_Category_Values> 的“常規類別值”部分。"

#: ../../howto/unicode.rst:402
#, fuzzy
msgid "Comparing Strings"
msgstr "比較字串"

#: ../../howto/unicode.rst:404
#, fuzzy
msgid ""
"Unicode adds some complication to comparing strings, because the same set of "
"characters can be represented by different sequences of code points.  For "
"example, a letter like 'ê' can be represented as a single code point U+00EA, "
"or as U+0065 U+0302, which is the code point for 'e' followed by a code "
"point for 'COMBINING CIRCUMFLEX ACCENT'.  These will produce the same output "
"when printed, but one is a string of length 1 and the other is of length 2."
msgstr ""
"Unicode 為比較字串增加了一些複雜性，因為同一組字元可以由不同的程式碼點序列表"
"示。例如，像 ``ê``這樣的字母可以表示為單個程式碼點 U+00EA，或表示為 U+0065 "
"U+0302，即 ``e``的程式碼點後跟“COMBINING CIRCUMFLEX ACCENT”的程式碼點."
"它們在印出時會產生相同的輸出，但一個是長度為 1 的字串，另一個是長度為 2 "
"的字串。"

#: ../../howto/unicode.rst:412
#, fuzzy
msgid ""
"One tool for a case-insensitive comparison is the :meth:`~str.casefold` "
"string method that converts a string to a case-insensitive form following an "
"algorithm described by the Unicode Standard.  This algorithm has special "
"handling for characters such as the German letter 'ß' (code point U+00DF), "
"which becomes the pair of lowercase letters 'ss'."
msgstr ""
"一種不區分大小寫比較的工具是 :meth:`~str.casefold` 字串方法，它按照 Unicode "
"標準描述的演算法將字串轉換為不區分大小寫的形式。該演算法對字元有特殊處理，例"
"如德語字母 ``ß``（程式碼點 U+00DF），它變成一對小寫字母 ``ss``。"

#: ../../howto/unicode.rst:425
#, fuzzy
msgid ""
"A second tool is the :mod:`unicodedata` module's :func:`~unicodedata."
"normalize` function that converts strings to one of several normal forms, "
"where letters followed by a combining character are replaced with single "
"characters.  :func:`normalize` can be used to perform string comparisons "
"that won't falsely report inequality if two strings use combining characters "
"differently:"
msgstr ""
"第二個工具是 :mod:`unicodedata` 模組的 :func:`~unicodedata.normalize` "
"函式，它將字串轉換為幾種正常形式之一，其中字母后跟組合字元被替換為單個字元。 "
":func:`normalize` "
"可用於執行字串比較，如果兩個字串使用不同的組合字元，則不會錯誤地報告不平等："

#: ../../howto/unicode.rst:448
#, fuzzy
msgid "When run, this outputs:"
msgstr "運行時，輸出："

#: ../../howto/unicode.rst:457
#, fuzzy
msgid ""
"The first argument to the :func:`~unicodedata.normalize` function is a "
"string giving the desired normalization form, which can be one of 'NFC', "
"'NFKC', 'NFD', and 'NFKD'."
msgstr ""
":func:`~unicodedata.normalize` 函式的第一個參數是給出所需規範化形式的字串，可"
"以是 ``NFC``、 ``NFKC``、 ``NFD``和 ``NFKD``之一。"

#: ../../howto/unicode.rst:461
#, fuzzy
msgid "The Unicode Standard also specifies how to do caseless comparisons::"
msgstr "Unicode 標準還指定瞭如何進行不區分大小寫的比較："

#: ../../howto/unicode.rst:477
#, fuzzy
msgid ""
"This will print ``True``.  (Why is :func:`NFD` invoked twice?  Because there "
"are a few characters that make :meth:`casefold` return a non-normalized "
"string, so the result needs to be normalized again. See section 3.13 of the "
"Unicode Standard for a discussion and an example.)"
msgstr ""
"這將印出 ``True``。 （為什麼 :func:`NFD` 被呼叫了兩次？因為有幾個字元使得 "
":meth:`casefold` 回傳一個非規範化的字串，所以結果需要再次規範化。參見 "
"Unicode Standard 的 section 3.13 for一個討論和一個例子。）"

#: ../../howto/unicode.rst:484
#, fuzzy
msgid "Unicode Regular Expressions"
msgstr "Unicode 正則表達式"

#: ../../howto/unicode.rst:486
#, fuzzy
msgid ""
"The regular expressions supported by the :mod:`re` module can be provided "
"either as bytes or strings.  Some of the special character sequences such as "
"``\\d`` and ``\\w`` have different meanings depending on whether the pattern "
"is supplied as bytes or a string.  For example, ``\\d`` will match the "
"characters ``[0-9]`` in bytes but in strings will match any character that's "
"in the ``'Nd'`` category."
msgstr ""
":mod:`re` "
"模組支援的正則表達式可以以位元組或字串的形式提供。一些特殊字元序列，如 ``\\d"
"`` 和 ``\\w`` "
"具有不同的含義，具體取決於模式是以位元組還是字串形式提供的。例如，“\\d"
"”將匹配位元組中的字元“[0-9]”，但在字串中將匹配 ``Nd``類別中的任何字元。"

#: ../../howto/unicode.rst:493
#, fuzzy
msgid ""
"The string in this example has the number 57 written in both Thai and Arabic "
"numerals::"
msgstr "此示例中的字串包含以泰語和阿拉伯數字書寫的數字 57::"

#: ../../howto/unicode.rst:503
#, fuzzy
msgid ""
"When executed, ``\\d+`` will match the Thai numerals and print them out.  If "
"you supply the :const:`re.ASCII` flag to :func:`~re.compile`, ``\\d+`` will "
"match the substring \"57\" instead."
msgstr ""
"執行時，``\\d+`` 將匹配泰文數字並印出出來。如果您向 :func:`~re.compile` 提供 "
":const:`re.ASCII` 旗標，``\\d+`` 將匹配子字串 ``57``。"

#: ../../howto/unicode.rst:507
#, fuzzy
msgid ""
"Similarly, ``\\w`` matches a wide variety of Unicode characters but only "
"``[a-zA-Z0-9_]`` in bytes or if :const:`re.ASCII` is supplied, and ``\\s`` "
"will match either Unicode whitespace characters or ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"類似地，``\\w`` 匹配多種 Unicode 字元，但僅以位元組為單位匹配``[a-zA-Z0-9_]``"
" 或者如果提供了 :const:`re.ASCII`，並且``\\s `` 將匹配 Unicode 空白字元或 ``[ "
"\\t\\n"
"\\r\\f\\v]``。"

#: ../../howto/unicode.rst:518
#, fuzzy
msgid "Some good alternative discussions of Python's Unicode support are:"
msgstr "Python 的 Unicode 支援的一些很好的替代討論是："

#: ../../howto/unicode.rst:520
#, fuzzy
msgid ""
"`Processing Text Files in Python 3 <https://python-notes.curiousefficiency."
"org/en/latest/python3/text_file_processing.html>`_, by Nick Coghlan."
msgstr ""
"`在 Python 3 中處理文本文件 <https://python-notes.curiousefficiency.org/en/"
"latest/python3/text_file_processing.html>`_，作者 Nick Coghlan。"

#: ../../howto/unicode.rst:521
#, fuzzy
msgid ""
"`Pragmatic Unicode <https://nedbatchelder.com/text/unipain.html>`_, a PyCon "
"2012 presentation by Ned Batchelder."
msgstr ""
"`Pragmatic Unicode <https://nedbatchelder.com/text/unipain.html>`_，Ned "
"Batchelder 在 PyCon 2012 上的演講。"

#: ../../howto/unicode.rst:523
#, fuzzy
msgid ""
"The :class:`str` type is described in the Python library reference at :ref:"
"`textseq`."
msgstr ":class:`str` 型別在 :ref:`textseq` 的 Python 庫參考中進行了描述。"

#: ../../howto/unicode.rst:526
#, fuzzy
msgid "The documentation for the :mod:`unicodedata` module."
msgstr ":mod:`unicodedata` 模組的文檔。"

#: ../../howto/unicode.rst:528
#, fuzzy
msgid "The documentation for the :mod:`codecs` module."
msgstr ":mod:`codecs` 模組的文檔。"

#: ../../howto/unicode.rst:530
#, fuzzy
msgid ""
"Marc-André Lemburg gave `a presentation titled \"Python and Unicode\" (PDF "
"slides) <https://downloads.egenix.com/python/Unicode-EPC2002-Talk.pdf>`_ at "
"EuroPython 2002.  The slides are an excellent overview of the design of "
"Python 2's Unicode features (where the Unicode string type is called "
"``unicode`` and literals start with ``u``)."
msgstr ""
"Marc-André Lemburg 在 EuroPython 2002 上作了題為“Python 和 Unicode”的演講（"
"PDF 幻燈片）<https://downloads.egenix.com/python/Unicode-EPC2002-Talk."
"pdf>`_。這些幻燈片非常出色Python 2 的 Unicode 特性設計概述（其中 Unicode "
"字串型別稱為 ``unicode``，文字以 ``u`` 開頭）。"

#: ../../howto/unicode.rst:538
#, fuzzy
msgid "Reading and Writing Unicode Data"
msgstr "讀寫 Unicode 資料"

#: ../../howto/unicode.rst:540
#, fuzzy
msgid ""
"Once you've written some code that works with Unicode data, the next problem "
"is input/output.  How do you get Unicode strings into your program, and how "
"do you convert Unicode into a form suitable for storage or transmission?"
msgstr ""
"一旦您編寫了一些使用 Unicode 資料的程式碼，下一個問題就是輸入/輸出。如何將 "
"Unicode 字串放入程式中，如何將 Unicode 轉換成適合儲存或傳輸的形式？"

#: ../../howto/unicode.rst:544
#, fuzzy
msgid ""
"It's possible that you may not need to do anything depending on your input "
"sources and output destinations; you should check whether the libraries used "
"in your application support Unicode natively.  XML parsers often return "
"Unicode data, for example.  Many relational databases also support Unicode-"
"valued columns and can return Unicode values from an SQL query."
msgstr ""
"根據您的輸入源和輸出目的地，您可能不需要做任何事情；"
"您應該檢查您的應用程式中使用的庫是否原生支援 Unicode。例如，XML "
"解析器經常回傳 Unicode 資料。許多關係資料庫還支援 Unicode 值列，並且可以從 "
"SQL 查詢回傳 Unicode 值。"

#: ../../howto/unicode.rst:550
#, fuzzy
msgid ""
"Unicode data is usually converted to a particular encoding before it gets "
"written to disk or sent over a socket.  It's possible to do all the work "
"yourself: open a file, read an 8-bit bytes object from it, and convert the "
"bytes with ``bytes.decode(encoding)``.  However, the manual approach is not "
"recommended."
msgstr ""
"Unicode 資料通常在寫入磁盤或通過 socket 發送之前轉換為特定編碼。可以自己完成所"
"有工作：打開一個文件，從中讀取一個 8 位位元組物件，然後使用 ``bytes."
"decode(encoding)`` 轉換位元組。但是，不推薦手動方法。"

#: ../../howto/unicode.rst:555
#, fuzzy
msgid ""
"One problem is the multi-byte nature of encodings; one Unicode character can "
"be represented by several bytes.  If you want to read the file in arbitrary-"
"sized chunks (say, 1024 or 4096 bytes), you need to write error-handling "
"code to catch the case where only part of the bytes encoding a single "
"Unicode character are read at the end of a chunk.  One solution would be to "
"read the entire file into memory and then perform the decoding, but that "
"prevents you from working with files that are extremely large; if you need "
"to read a 2 GiB file, you need 2 GiB of RAM. (More, really, since for at "
"least a moment you'd need to have both the encoded string and its Unicode "
"version in memory.)"
msgstr ""
"一個問題是編碼的多位元組性質；一個 Unicode "
"字元可以用幾個位元組表示。如果你想以任意大小的塊（比如 1024 或 4096 "
"位元組）讀取文件，你需要編寫錯誤處理程式碼來捕獲在文件末尾只讀取編碼單個 "
"Unicode 字元的部分位元組的情況。一塊。一種解決方案是將整個文件讀入記憶體，然"
"後執行解碼，但這會阻止您處理非常大的文件；如果您需要讀取 2 GiB 的文件，"
"則需要 2 GiB 的 RAM。 （更多，真的，"
"因為至少有一段時間你需要在記憶體中同時擁有編碼字串和它的 Unicode 版本。）"

#: ../../howto/unicode.rst:565
#, fuzzy
msgid ""
"The solution would be to use the low-level decoding interface to catch the "
"case of partial coding sequences.  The work of implementing this has already "
"been done for you: the built-in :func:`open` function can return a file-like "
"object that assumes the file's contents are in a specified encoding and "
"accepts Unicode parameters for methods such as :meth:`~io.TextIOBase.read` "
"and :meth:`~io.TextIOBase.write`.  This works through :func:`open`\\'s "
"*encoding* and *errors* parameters which are interpreted just like those in :"
"meth:`str.encode` and :meth:`bytes.decode`."
msgstr ""
"解決方案是使用低階解碼介面來捕獲部分編碼序列的情況。實作這個的工作已經為你完"
"成了：內建的 :func:`open` 函式可以回傳一個類似文件的物件，"
"該物件假定文件的內容採用指定的編碼並接受 :meth 等方法的 Unicode 參數:`~io."
"TextIOBase.read` 和 :meth:`~io.TextIOBase.write`。這通過 :func:`open`\\ 的 "
"*encoding* 和 *errors* 參數實作，它們的解釋與 :meth:`str.encode` 和 "
":meth:`bytes.decode` 中的參數相同。"

#: ../../howto/unicode.rst:574
#, fuzzy
msgid "Reading Unicode from a file is therefore simple::"
msgstr "因此從文件中讀取 Unicode 很簡單::"

#: ../../howto/unicode.rst:580
#, fuzzy
msgid ""
"It's also possible to open files in update mode, allowing both reading and "
"writing::"
msgstr "也可以在更新模式下打開文件，允許讀取和寫入::"

#: ../../howto/unicode.rst:588
#, fuzzy
msgid ""
"The Unicode character ``U+FEFF`` is used as a byte-order mark (BOM), and is "
"often written as the first character of a file in order to assist with "
"autodetection of the file's byte ordering.  Some encodings, such as UTF-16, "
"expect a BOM to be present at the start of a file; when such an encoding is "
"used, the BOM will be automatically written as the first character and will "
"be silently dropped when the file is read.  There are variants of these "
"encodings, such as 'utf-16-le' and 'utf-16-be' for little-endian and big-"
"endian encodings, that specify one particular byte ordering and don't skip "
"the BOM."
msgstr ""
"Unicode 字元 ``U+FEFF``用作位元組順序標記 "
"(BOM)，通常寫為文件的第一個字元，以幫助自動檢測文件的位元組順序。一些編碼，"
"例如 UTF-16，期望 BOM 出現在文件的開頭；當使用這種編碼時，BOM 將自動寫入第一"
"個字元，並在讀取文件時靜默刪除。這些編碼有多種變體，例如用於小端和大端編碼的“"
"utf-16-le”和 ``utf-16-be`` ，它們指定一種特定的位元組順序並且不跳過 BOM。"

#: ../../howto/unicode.rst:597
#, fuzzy
msgid ""
"In some areas, it is also convention to use a \"BOM\" at the start of UTF-8 "
"encoded files; the name is misleading since UTF-8 is not byte-order "
"dependent. The mark simply announces that the file is encoded in UTF-8.  For "
"reading such files, use the 'utf-8-sig' codec to automatically skip the mark "
"if present."
msgstr ""
"在某些地區，在 UTF-8 編碼文件的開頭使用 ``BOM``也是慣例；該名稱具有誤導性，因為 "
"UTF-8 不依賴於位元組順序。該標記只是表明該文件是用 UTF-8 "
"編碼的。要讀取此類文件，請使用 ``utf-8-sig`` 編解碼器自動跳過標記（如果存在）。"

#: ../../howto/unicode.rst:604
#, fuzzy
msgid "Unicode filenames"
msgstr "Unicode 文件名"

#: ../../howto/unicode.rst:606
#, fuzzy
msgid ""
"Most of the operating systems in common use today support filenames that "
"contain arbitrary Unicode characters.  Usually this is implemented by "
"converting the Unicode string into some encoding that varies depending on "
"the system.  Today Python is converging on using UTF-8: Python on MacOS has "
"used UTF-8 for several versions, and Python 3.6 switched to using UTF-8 on "
"Windows as well.  On Unix systems, there will only be a :term:`filesystem "
"encoding <filesystem encoding and error handler>`. if you've set the "
"``LANG`` or ``LC_CTYPE`` environment variables; if you haven't, the default "
"encoding is again UTF-8."
msgstr ""
"當今大多數常用的操作系統都支援包含任意 Unicode 字元的文件名。通常這是通過將 "
"Unicode 字串轉換為一些因係統而異的編碼來實作的。今天 Python 正在集中使用 "
"UTF-8：MacOS 上的 Python 已經有幾個版本使用 UTF-8，Python 3.6 也切換到在 "
"Windows 上使用 UTF-8。在 Unix 系統上，只有一個 :term:`filesystem encoding "
"<filesystem encoding and error handler>`。如果您設定了 ``LANG`` 或 "
"``LC_CTYPE`` 環境變數；如果沒有，預設編碼又是 UTF-8。"

#: ../../howto/unicode.rst:616
#, fuzzy
msgid ""
"The :func:`sys.getfilesystemencoding` function returns the encoding to use "
"on your current system, in case you want to do the encoding manually, but "
"there's not much reason to bother.  When opening a file for reading or "
"writing, you can usually just provide the Unicode string as the filename, "
"and it will be automatically converted to the right encoding for you::"
msgstr ""
":func:`sys.getfilesystemencoding` 函式回傳在您當前系統上使用的編碼，以防您想"
"手動進行編碼，但沒有太多理由去打擾。打開文件進行讀寫時，通常只需提供 Unicode "
"字串作為文件名，它會自動轉換為適合您的編碼："

#: ../../howto/unicode.rst:626
#, fuzzy
msgid ""
"Functions in the :mod:`os` module such as :func:`os.stat` will also accept "
"Unicode filenames."
msgstr ":mod:`os` 模組中的函式，例如 :func:`os.stat` 也將接受 Unicode 文件名。"

#: ../../howto/unicode.rst:629
#, fuzzy
msgid ""
"The :func:`os.listdir` function returns filenames, which raises an issue: "
"should it return the Unicode version of filenames, or should it return bytes "
"containing the encoded versions?  :func:`os.listdir` can do both, depending "
"on whether you provided the directory path as bytes or a Unicode string.  If "
"you pass a Unicode string as the path, filenames will be decoded using the "
"filesystem's encoding and a list of Unicode strings will be returned, while "
"passing a byte path will return the filenames as bytes.  For example, "
"assuming the default :term:`filesystem encoding <filesystem encoding and "
"error handler>` is UTF-8, running the following program::"
msgstr ""
":func:`os.listdir` 函式回傳文件名，這引發了一個問題：它應該回傳文件名的 "
"Unicode 版本，還是應該回傳包含編碼版本的位元組？ :func:`os.listdir` "
"可以同時執行這兩種操作，具體取決於您提供的目錄路徑是位元組還是 Unicode 字串。"
"如果傳遞 Unicode 字串作為路徑，文件名將使用文件系統的編碼進行解碼，並回傳 "
"Unicode 字串列表，而傳遞位元組路徑將以位元組形式回傳文件名。例如，假設預設的 "
":term:`filesystem encoding <filesystem encoding and error handler>` 是 "
"UTF-8，運行以下程式："

#: ../../howto/unicode.rst:647
#, fuzzy
msgid "will produce the following output:"
msgstr "將產生以下輸出："

#: ../../howto/unicode.rst:655
#, fuzzy
msgid ""
"The first list contains UTF-8-encoded filenames, and the second list "
"contains the Unicode versions."
msgstr "第一個列表包含 UTF-8 編碼的文件名，第二個列表包含 Unicode 版本。"

#: ../../howto/unicode.rst:658
#, fuzzy
msgid ""
"Note that on most occasions, you should can just stick with using Unicode "
"with these APIs.  The bytes APIs should only be used on systems where "
"undecodable file names can be present; that's pretty much only Unix systems "
"now."
msgstr ""
"請注意，在大多數情況下，您應該堅持對這些 API 使用 Unicode。 bytes API "
"應該只用在可能存在不可解碼文件名的系統上；現在幾乎只有 Unix 系統。"

#: ../../howto/unicode.rst:665
#, fuzzy
msgid "Tips for Writing Unicode-aware Programs"
msgstr "編寫支援 Unicode 的程式的技巧"

#: ../../howto/unicode.rst:667
#, fuzzy
msgid ""
"This section provides some suggestions on writing software that deals with "
"Unicode."
msgstr "本節提供有關編寫處理 Unicode 的軟件的一些建議。"

#: ../../howto/unicode.rst:670
#, fuzzy
msgid "The most important tip is:"
msgstr "最重要的提示是："

#: ../../howto/unicode.rst:672
#, fuzzy
msgid ""
"Software should only work with Unicode strings internally, decoding the "
"input data as soon as possible and encoding the output only at the end."
msgstr "軟件應該只在內部使用 Unicode 字串，盡快解碼輸入資料並只在最後編碼輸出。"

#: ../../howto/unicode.rst:675
#, fuzzy
msgid ""
"If you attempt to write processing functions that accept both Unicode and "
"byte strings, you will find your program vulnerable to bugs wherever you "
"combine the two different kinds of strings.  There is no automatic encoding "
"or decoding: if you do e.g. ``str + bytes``, a :exc:`TypeError` will be "
"raised."
msgstr ""
"如果您嘗試編寫同時接受 Unicode 和位元組字串的處理函式，您會發現您的程式在組合"
"兩種不同型別的字串的任何地方都容易出現錯誤。沒有自動編碼或解碼：如果你這樣做"
"，例如``str + bytes``，將引發 :exc:`TypeError`。"

#: ../../howto/unicode.rst:680
#, fuzzy
msgid ""
"When using data coming from a web browser or some other untrusted source, a "
"common technique is to check for illegal characters in a string before using "
"the string in a generated command line or storing it in a database.  If "
"you're doing this, be careful to check the decoded string, not the encoded "
"bytes data; some encodings may have interesting properties, such as not "
"being bijective or not being fully ASCII-compatible.  This is especially "
"true if the input data also specifies the encoding, since the attacker can "
"then choose a clever way to hide malicious text in the encoded bytestream."
msgstr ""
"當使用來自 Web 瀏覽器或其他一些不受信任的來源的資料時，一種常見的技術是在生成"
"的命令列中使用字串或將其儲存在資料庫中之前檢查字串中的非法字元。如果您這樣做"
"，請小心檢查解碼後的字串，而不是編碼後的位元組資料；某些編碼可能具有有趣的屬"
"性，例如不是雙射的或不是完全相容 ASCII 的。如果輸入資料還指定了編碼，則尤其如"
"此，因為攻擊者隨後可以選擇一種巧妙的方式將惡意文本隱藏在編碼的位元組流中。"

#: ../../howto/unicode.rst:691
#, fuzzy
msgid "Converting Between File Encodings"
msgstr "在文件編碼之間轉換"

#: ../../howto/unicode.rst:693
#, fuzzy
msgid ""
"The :class:`~codecs.StreamRecoder` class can transparently convert between "
"encodings, taking a stream that returns data in encoding #1 and behaving "
"like a stream returning data in encoding #2."
msgstr ""
":class:`~codecs.StreamRecoder` 類可以透明地在編碼之間進行轉換，"
"採用以編碼 #1 回傳資料的流，並且表現得像以編碼 #2 回傳資料的流。"

#: ../../howto/unicode.rst:697
#, fuzzy
msgid ""
"For example, if you have an input file *f* that's in Latin-1, you can wrap "
"it with a :class:`~codecs.StreamRecoder` to return bytes encoded in UTF-8::"
msgstr ""
"例如，如果您有一個 Latin-1 格式的輸入文件 *f*，您可以用 :class:`~codecs."
"StreamRecoder` 包裝它以回傳以 UTF-8 編碼的位元組："

#: ../../howto/unicode.rst:711
#, fuzzy
msgid "Files in an Unknown Encoding"
msgstr "未知編碼的文件"

#: ../../howto/unicode.rst:713
#, fuzzy
msgid ""
"What can you do if you need to make a change to a file, but don't know the "
"file's encoding?  If you know the encoding is ASCII-compatible and only want "
"to examine or modify the ASCII parts, you can open the file with the "
"``surrogateescape`` error handler::"
msgstr ""
"如果您需要更改文件，但不知道文件的編碼，您可以做什麼？如果您知道編碼是 ASCII "
"相容的並且只想檢查或修改 ASCII 部分，則可以使用 ``surrogateescape`` "
"錯誤處理程式打開文件："

#: ../../howto/unicode.rst:727
#, fuzzy
msgid ""
"The ``surrogateescape`` error handler will decode any non-ASCII bytes as "
"code points in a special range running from U+DC80 to U+DCFF.  These code "
"points will then turn back into the same bytes when the ``surrogateescape`` "
"error handler is used to encode the data and write it back out."
msgstr ""
"``surrogateescape`` 錯誤處理程式會將任何非 ASCII 位元組解碼為從 U+DC80 到 U+"
"DCFF 的特殊範圍內的程式碼點。當使用 ``surrogateescape`` 錯誤處理程式對資料進行編"
"碼並將其寫回時，這些程式碼點將變回相同的位元組。"

#: ../../howto/unicode.rst:737
#, fuzzy
msgid ""
"One section of `Mastering Python 3 Input/Output <https://pyvideo.org/"
"video/289/pycon-2010--mastering-python-3-i-o>`_, a PyCon 2010 talk by David "
"Beazley, discusses text processing and binary data handling."
msgstr ""
"`Mastering Python 3 Input/Output <https://pyvideo.org/video/289/pycon-2010"
"--mastering-python-3-i-o>`_ 的一部分是 David Beazley 在 PyCon 2010 "
"上的演講，討論了文本處理和二進位資料處理。"

#: ../../howto/unicode.rst:741
#, fuzzy
msgid ""
"The `PDF slides for Marc-André Lemburg's presentation \"Writing Unicode-"
"aware Applications in Python\" <https://downloads.egenix.com/python/LSM2005-"
"Developing-Unicode-aware-applications-in-Python.pdf>`_ discuss questions of "
"character encodings as well as how to internationalize and localize an "
"application.  These slides cover Python 2.x only."
msgstr ""
"Marc-André Lemburg 的演講“用 Python 編寫支援 Unicode 的應用程式”的 `PDF "
"幻燈片 <https://downloads.egenix.com/python/LSM2005-Developing-Uni"
"code-aware-applications-in-Python."
"pdf>`_討論字元編碼問題以及如何國際化和本地化應用程式。這些幻燈片僅涵蓋 "
"Python 2.x。"

#: ../../howto/unicode.rst:747
#, fuzzy
msgid ""
"`The Guts of Unicode in Python <https://pyvideo.org/video/1768/the-guts-of-"
"unicode-in-python>`_ is a PyCon 2013 talk by Benjamin Peterson that "
"discusses the internal Unicode representation in Python 3.3."
msgstr ""
"`Python 中 Unicode 的核心 <https://pyvideo.org/video/1768/the-guts-of-"
"unicode-in-python>`_ 是 Benjamin Peterson 在 PyCon 2013 上的一次演講，討論了 "
"Python 中的內部 Unicode 表示3.3."

#: ../../howto/unicode.rst:754
msgid "Acknowledgements"
msgstr "致謝"

#: ../../howto/unicode.rst:756
#, fuzzy
msgid ""
"The initial draft of this document was written by Andrew Kuchling. It has "
"since been revised further by Alexander Belopolsky, Georg Brandl, Andrew "
"Kuchling, and Ezio Melotti."
msgstr ""
"本文檔的初稿由 Andrew Kuchling 撰寫。此後，Alexander Belopolsky、Georg "
"Brandl、Andrew Kuchling 和 Ezio Melotti 對其進行了進一步修訂。"

#: ../../howto/unicode.rst:760
#, fuzzy
msgid ""
"Thanks to the following people who have noted errors or offered suggestions "
"on this article: Éric Araujo, Nicholas Bastin, Nick Coghlan, Marius "
"Gedminas, Kent Johnson, Ken Krugler, Marc-André Lemburg, Martin von Löwis, "
"Terry J. Reedy, Serhiy Storchaka, Eryk Sun, Chad Whitacre, Graham Wideman."
msgstr ""
"感謝以下指出本文錯誤或提出建議的人員：Éric Araujo、Nicholas Bastin、Nick "
"Coghlan、Marius Gedminas、Kent Johnson、Ken Krugler、Marc-André Lemburg、"
"Martin von Löwis、Terry J. Reedy、Serhiy Storchaka , Eryk Sun, Chad "
"Whitacre, Graham Wideman。"
