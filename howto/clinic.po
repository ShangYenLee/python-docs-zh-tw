# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-31 08:13+0000\n"
"PO-Revision-Date: 2018-05-23 14:36+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/clinic.rst:7
#, fuzzy
msgid "Argument Clinic How-To"
msgstr "爭論診所操作方法"

#: ../../howto/clinic.rst:0
msgid "author"
msgstr "作者"

#: ../../howto/clinic.rst:9
msgid "Larry Hastings"
msgstr "Larry Hastings"

#: ../../howto/clinic.rst:-1
msgid "Abstract"
msgstr "摘要"

#: ../../howto/clinic.rst:14
#, fuzzy
msgid ""
"Argument Clinic is a preprocessor for CPython C files. Its purpose is to "
"automate all the boilerplate involved with writing argument parsing code for "
"\"builtins\". This document shows you how to convert your first C function "
"to work with Argument Clinic, and then introduces some advanced topics on "
"Argument Clinic usage."
msgstr ""
"Argument Clinic 是 CPython C "
"文件的預處理器。它的目的是自動化所有涉及為“內建”編寫參數解析程式碼的樣板。"
"本文檔向您展示瞭如何將您的第一個 C 函式轉換為與 Argument Clinic 一起使用，"
"然後介紹了有關 Argument Clinic 使用的一些高階主題。"

#: ../../howto/clinic.rst:21
#, fuzzy
msgid ""
"Currently Argument Clinic is considered internal-only for CPython.  Its use "
"is not supported for files outside CPython, and no guarantees are made "
"regarding backwards compatibility for future versions.  In other words: if "
"you maintain an external C extension for CPython, you're welcome to "
"experiment with Argument Clinic in your own code.  But the version of "
"Argument Clinic that ships with the next version of CPython *could* be "
"totally incompatible and break all your code."
msgstr ""
"目前，Argument Clinic 被認為僅供 CPython 內部使用。 CPython "
"之外的文件不支援使用它，並且不保證未來版本的向後相容性。換句話說：如果您為 "
"CPython 維護一個外部 C 擴充，歡迎您在自己的程式碼中試驗 Argument Clinic。"
"但是下一個 CPython 版本附帶的 Argument Clinic "
"版本*可能*完全不相容並破壞您的所有程式碼。"

#: ../../howto/clinic.rst:31
#, fuzzy
msgid "The Goals Of Argument Clinic"
msgstr "爭論診所的目標"

#: ../../howto/clinic.rst:33
#, fuzzy
msgid ""
"Argument Clinic's primary goal is to take over responsibility for all "
"argument parsing code inside CPython.  This means that, when you convert a "
"function to work with Argument Clinic, that function should no longer do any "
"of its own argument parsing—the code generated by Argument Clinic should be "
"a \"black box\" to you, where CPython calls in at the top, and your code "
"gets called at the bottom, with ``PyObject *args`` (and maybe ``PyObject "
"*kwargs``) magically converted into the C variables and types you need."
msgstr ""
"Argument Clinic 的主要目標是接管 CPython "
"中所有參數解析程式碼的責任。這意味著，當您將函式轉換為與 Argument Clinic "
"一起使用時，該函式不應再進行任何它自己的參數解析——Argument Clinic "
"生成的程式碼對您來說應該是一個“黑匣子”，CPython "
"在其中呼叫頂部，你的程式碼在底部被呼叫，用``PyObject *args``（也許還有``"
"PyObject *kwargs``）神奇地轉換成你需要的C變數和型別。"

#: ../../howto/clinic.rst:43
#, fuzzy
msgid ""
"In order for Argument Clinic to accomplish its primary goal, it must be easy "
"to use.  Currently, working with CPython's argument parsing library is a "
"chore, requiring maintaining redundant information in a surprising number of "
"places. When you use Argument Clinic, you don't have to repeat yourself."
msgstr ""
"為了讓 Argument Clinic 實作其主要目標，它必須易於使用。目前，使用 CPython "
"的參數解析庫是一件苦差事，需要在數量驚人的地方維護冗餘資訊。當您使用 "
"Argument Clinic 時，您不必重複自己。"

#: ../../howto/clinic.rst:49
#, fuzzy
msgid ""
"Obviously, no one would want to use Argument Clinic unless it's solving "
"their problem—and without creating new problems of its own. So it's "
"paramount that Argument Clinic generate correct code. It'd be nice if the "
"code was faster, too, but at the very least it should not introduce a major "
"speed regression.  (Eventually Argument Clinic *should* make a major speedup "
"possible—we could rewrite its code generator to produce tailor-made argument "
"parsing code, rather than calling the general-purpose CPython argument "
"parsing library.  That would make for the fastest argument parsing possible!)"
msgstr ""
"顯然，沒有人願意使用 Argument "
"Clinic，除非它能解決他們的問題——而且不會產生自己的新問題。因此，Argument "
"Clinic 生成正確的程式碼至關重要。如果程式碼也更快，那就太好了，但至少它不應該"
"引入主要的速度倒退。 （最終 Argument Clinic *應該* "
"可以實作主要的加速——我們可以重寫它的程式碼生成器來生成定制的參數解析程式碼，"
"而不是呼叫通用的 CPython 參數解析庫。這將使最快的參數解析成為可能！ )"

#: ../../howto/clinic.rst:61
#, fuzzy
msgid ""
"Additionally, Argument Clinic must be flexible enough to work with any "
"approach to argument parsing.  Python has some functions with some very "
"strange parsing behaviors; Argument Clinic's goal is to support all of them."
msgstr ""
"此外，Argument Clinic 必須足夠靈活，可以使用任何參數解析方法。 Python "
"有一些函式有一些非常奇怪的解析行為； Argument Clinic 的目標是支援他們所有人。"

#: ../../howto/clinic.rst:66
#, fuzzy
msgid ""
"Finally, the original motivation for Argument Clinic was to provide "
"introspection \"signatures\" for CPython builtins. It used to be, the "
"introspection query functions would throw an exception if you passed in a "
"builtin.  With Argument Clinic, that's a thing of the past!"
msgstr ""
"最後，Argument Clinic 的最初動機是為 CPython "
"內建函式提供內省“簽名”。過去，如果您傳入內建函式，內省查詢函式會拋出例外。"
"有了 Argument Clinic，這已成為過去！"

#: ../../howto/clinic.rst:72
#, fuzzy
msgid ""
"One idea you should keep in mind, as you work with Argument Clinic: the more "
"information you give it, the better job it'll be able to do. Argument Clinic "
"is admittedly relatively simple right now.  But as it evolves it will get "
"more sophisticated, and it should be able to do many interesting and smart "
"things with all the information you give it."
msgstr ""
"當您使用 Argument Clinic "
"時，您應該牢記一個想法：您提供的資訊越多，它就能做得越好。不可否認，Argument "
"Clinic 現在相對簡單。但隨著它的發展，它將變得更加複雜，並且它應該能夠利用您提"
"供的所有資訊來做許多有趣和聰明的事情。"

#: ../../howto/clinic.rst:82
#, fuzzy
msgid "Basic Concepts And Usage"
msgstr "基本概念和用法"

#: ../../howto/clinic.rst:84
#, fuzzy
msgid ""
"Argument Clinic ships with CPython; you'll find it in ``Tools/clinic/clinic."
"py``. If you run that script, specifying a C file as an argument:"
msgstr ""
"Argument Clinic 附帶 CPython；你會在 ``Tools/clinic/clinic.py`` "
"中找到它。如果運行該腳本，將 C 文件指定為參數："

#: ../../howto/clinic.rst:91
#, fuzzy
msgid ""
"Argument Clinic will scan over the file looking for lines that look exactly "
"like this:"
msgstr "Argument Clinic 將掃描文件以查找看起來完全像這樣的行："

#: ../../howto/clinic.rst:98
#, fuzzy
msgid ""
"When it finds one, it reads everything up to a line that looks exactly like "
"this:"
msgstr "當它找到一個時，它會讀取所有內容，直到一行看起來完全像這樣："

#: ../../howto/clinic.rst:105
#, fuzzy
msgid ""
"Everything in between these two lines is input for Argument Clinic. All of "
"these lines, including the beginning and ending comment lines, are "
"collectively called an Argument Clinic \"block\"."
msgstr ""
"這兩行之間的所有內容都是 Argument Clinic "
"的輸入。所有這些行，包括開頭和結尾的註釋行，統稱為 Argument Clinic「塊」。"

#: ../../howto/clinic.rst:109
#, fuzzy
msgid ""
"When Argument Clinic parses one of these blocks, it generates output.  This "
"output is rewritten into the C file immediately after the block, followed by "
"a comment containing a checksum. The Argument Clinic block now looks like "
"this:"
msgstr ""
"當 Argument Clinic 解析這些塊之一時，它會生成輸出。此輸出在塊之後立即重寫到 "
"C 文件中，隨後是包含校驗和的註釋。 Argument Clinic 區塊現在看起來像這樣："

#: ../../howto/clinic.rst:122
#, fuzzy
msgid ""
"If you run Argument Clinic on the same file a second time, Argument Clinic "
"will discard the old output and write out the new output with a fresh "
"checksum line.  However, if the input hasn't changed, the output won't "
"change either."
msgstr ""
"如果您第二次對同一個文件運行 Argument Clinic，Argument Clinic 將丟棄舊輸出並"
"寫出帶有新校驗和行的新輸出。但是，如果輸入沒有改變，輸出也不會改變。"

#: ../../howto/clinic.rst:126
#, fuzzy
msgid ""
"You should never modify the output portion of an Argument Clinic block.  "
"Instead, change the input until it produces the output you want.  (That's "
"the purpose of the checksum—to detect if someone changed the output, as "
"these edits would be lost the next time Argument Clinic writes out fresh "
"output.)"
msgstr ""
"您永遠不應修改 Argument Clinic "
"塊的輸出部分。相反，改變輸入直到它產生你想要的輸出。 "
"（這就是校驗和的目的——檢測是否有人更改了輸出，因為這些編輯將在下次 Argument "
"Clinic 寫出新輸出時丟失。）"

#: ../../howto/clinic.rst:131
#, fuzzy
msgid ""
"For the sake of clarity, here's the terminology we'll use with Argument "
"Clinic:"
msgstr "為了清楚起見，以下是我們將在 Argument Clinic 中使用的術語："

#: ../../howto/clinic.rst:133
#, fuzzy
msgid ""
"The first line of the comment (``/*[clinic input]``) is the *start line*."
msgstr "註釋的第一行 (``/*[clinic input]``) 是*起始行*。"

#: ../../howto/clinic.rst:134
#, fuzzy
msgid ""
"The last line of the initial comment (``[clinic start generated code]*/``) "
"is the *end line*."
msgstr "初始註釋的最後一行（``[clinic start generated code]*/``）是*結束行*。"

#: ../../howto/clinic.rst:135
#, fuzzy
msgid ""
"The last line (``/*[clinic end generated code: checksum=...]*/``) is the "
"*checksum line*."
msgstr "最後一行（``/*[診所結束生成的程式碼：校驗和=...]*/``）是*校驗和行*。"

#: ../../howto/clinic.rst:136
#, fuzzy
msgid "In between the start line and the end line is the *input*."
msgstr "在起始行和結束行之間是 *input*。"

#: ../../howto/clinic.rst:137
#, fuzzy
msgid "In between the end line and the checksum line is the *output*."
msgstr "在結束行和校驗和行之間是*輸出*。"

#: ../../howto/clinic.rst:138
#, fuzzy
msgid ""
"All the text collectively, from the start line to the checksum line "
"inclusively, is the *block*.  (A block that hasn't been successfully "
"processed by Argument Clinic yet doesn't have output or a checksum line, but "
"it's still considered a block.)"
msgstr ""
"所有文本，從起始行到校驗和行，包括在內，就是*塊*。 （一個尚未被 Argument "
"Clinic 成功處理但沒有輸出或校驗和行的塊，但它仍然被認為是一個塊。）"

#: ../../howto/clinic.rst:145
#, fuzzy
msgid "Converting Your First Function"
msgstr "轉換你的第一個函式"

#: ../../howto/clinic.rst:147
#, fuzzy
msgid ""
"The best way to get a sense of how Argument Clinic works is to convert a "
"function to work with it.  Here, then, are the bare minimum steps you'd need "
"to follow to convert a function to work with Argument Clinic.  Note that for "
"code you plan to check in to CPython, you really should take the conversion "
"farther, using some of the advanced concepts you'll see later on in the "
"document (like \"return converters\" and \"self converters\"). But we'll "
"keep it simple for this walkthrough so you can learn."
msgstr ""
"了解 Argument Clinic 如何工作的最好方法是轉換一個函式來使用它。那麼，"
"這裡是將函式轉換為與 Argument Clinic 一起使用所需遵循的最少步驟。請注意，"
"對於您計劃簽入 CPython 的程式碼，您確實應該進一步進行轉換，使用您稍後將在文檔"
"中看到的一些高階概念（例如“回傳轉換器”和“自轉換器”）。但我們會在本演練中保持"
"簡單，以便您學習。"

#: ../../howto/clinic.rst:156
#, fuzzy
msgid "Let's dive in!"
msgstr "讓我們開始吧！"

#: ../../howto/clinic.rst:158
#, fuzzy
msgid ""
"Make sure you're working with a freshly updated checkout of the CPython "
"trunk."
msgstr "確保您使用的是最新更新的 CPython 主幹檢出。"

#: ../../howto/clinic.rst:161
#, fuzzy
msgid ""
"Find a Python builtin that calls either :c:func:`PyArg_ParseTuple` or :c:"
"func:`PyArg_ParseTupleAndKeywords`, and hasn't been converted to work with "
"Argument Clinic yet. For my example I'm using ``_pickle.Pickler.dump()``."
msgstr ""
"找到一個呼叫 :c:func:`PyArg_ParseTuple` 或 "
":c:func:`PyArg_ParseTupleAndKeywords` 並且尚未轉換為與 Argument Clinic "
"一起使用的 Python 內建函式。對於我的示例，我使用的是 ``_pickle.Pickler."
"dump()``。"

#: ../../howto/clinic.rst:166
#, fuzzy
msgid ""
"If the call to the ``PyArg_Parse`` function uses any of the following format "
"units:"
msgstr "如果對 ``PyArg_Parse`` 函式的呼叫使用以下任何格式單元："

#: ../../howto/clinic.rst:178
#, fuzzy
msgid ""
"or if it has multiple calls to :c:func:`PyArg_ParseTuple`, you should choose "
"a different function.  Argument Clinic *does* support all of these "
"scenarios.  But these are advanced topics—let's do something simpler for "
"your first function."
msgstr ""
"或者如果它多次呼叫 :c:func:`PyArg_ParseTuple`，您應該選擇不同的函式。 "
"Argument Clinic *確實*支援所有這些場景。但這些都是高階主題——讓我們為您的第一"
"個函式做一些更簡單的事情。"

#: ../../howto/clinic.rst:183
#, fuzzy
msgid ""
"Also, if the function has multiple calls to :c:func:`PyArg_ParseTuple` or :c:"
"func:`PyArg_ParseTupleAndKeywords` where it supports different types for the "
"same argument, or if the function uses something besides PyArg_Parse "
"functions to parse its arguments, it probably isn't suitable for conversion "
"to Argument Clinic.  Argument Clinic doesn't support generic functions or "
"polymorphic parameters."
msgstr ""
"此外，如果函式多次呼叫 PyArg_ParseTuple 或 PyArg_ParseTupleAndKeywords "
"，其中它支援同一參數的不同型別，或者如果函式使用 PyArg_Parse "
"函式以外的東西來解析其參數，它可能不適合轉換為 Argument Clinic。 Argument "
"Clinic 不支援通用函式或多態參數。"

#: ../../howto/clinic.rst:190
#, fuzzy
msgid "Add the following boilerplate above the function, creating our block::"
msgstr "在函式上方新增以下樣板，建立我們的塊::"

#: ../../howto/clinic.rst:195
#, fuzzy
msgid ""
"Cut the docstring and paste it in between the ``[clinic]`` lines, removing "
"all the junk that makes it a properly quoted C string. When you're done you "
"should have just the text, based at the left margin, with no line wider than "
"80 characters. (Argument Clinic will preserve indents inside the docstring.)"
msgstr ""
"剪切文檔字串並將其粘貼到 ``[clinic]`` 行之間，刪除所有使其成為正確引用的 C "
"字串的垃圾。當你完成後，你應該只有文本，基於左邊距，每行不超過 80 個字元。 （"
"Argument Clinic 將在文檔字串中保留縮進。）"

#: ../../howto/clinic.rst:201
#, fuzzy
msgid ""
"If the old docstring had a first line that looked like a function signature, "
"throw that line away.  (The docstring doesn't need it anymore—when you use "
"``help()`` on your builtin in the future, the first line will be built "
"automatically based on the function's signature.)"
msgstr ""
"如果舊文檔字串的第一行看起來像函式簽名，請將其丟棄。 （文檔字串不再需要它了——"
"當你將來在你的內建函式上使用 ``help()`` "
"時，第一行將根據函式的簽名自動構建。）"

#: ../../howto/clinic.rst:207 ../../howto/clinic.rst:228
#: ../../howto/clinic.rst:252 ../../howto/clinic.rst:310
#: ../../howto/clinic.rst:350 ../../howto/clinic.rst:377
#: ../../howto/clinic.rst:483 ../../howto/clinic.rst:535
#, fuzzy
msgid "Sample::"
msgstr "樣本：："

#: ../../howto/clinic.rst:213
#, fuzzy
msgid ""
"If your docstring doesn't have a \"summary\" line, Argument Clinic will "
"complain.  So let's make sure it has one.  The \"summary\" line should be a "
"paragraph consisting of a single 80-column line at the beginning of the "
"docstring."
msgstr ""
"如果您的文檔字串沒有“摘要”行，Argument Clinic "
"會抱怨。所以讓我們確保它有一個。 “摘要”行應該是一個段落，"
"由文檔字串開頭的一個 80 列行組成。"

#: ../../howto/clinic.rst:218
#, fuzzy
msgid ""
"(Our example docstring consists solely of a summary line, so the sample code "
"doesn't have to change for this step.)"
msgstr "（我們的示例文檔字串僅包含一個摘要行，因此不必為此步驟更改示例程式碼。）"

#: ../../howto/clinic.rst:221
#, fuzzy
msgid ""
"Above the docstring, enter the name of the function, followed by a blank "
"line.  This should be the Python name of the function, and should be the "
"full dotted path to the function—it should start with the name of the "
"module, include any sub-modules, and if the function is a method on a class "
"it should include the class name too."
msgstr ""
"在文檔字串上方，輸入函式名稱，後跟一個空行。這應該是函式的 Python 名稱，並且"
"應該是函式的完整路徑——它應該以模組的名稱開頭，包括任何子模組，如果函式是類的"
"方法，它應該包括類名也是。"

#: ../../howto/clinic.rst:236
#, fuzzy
msgid ""
"If this is the first time that module or class has been used with Argument "
"Clinic in this C file, you must declare the module and/or class.  Proper "
"Argument Clinic hygiene prefers declaring these in a separate block "
"somewhere near the top of the C file, in the same way that include files and "
"statics go at the top.  (In our sample code we'll just show the two blocks "
"next to each other.)"
msgstr ""
"如果這是此 C 文件中該模組或類第一次與 Argument Clinic "
"一起使用，則您必須聲明該模組和/或類。 Proper Argument Clinic hygiene "
"更喜歡在靠近 C "
"文件頂部的某個單獨塊中聲明這些，就像包含文件和靜態文件放在頂部一樣。 "
"（在我們的示例程式碼中，我們將只顯示彼此相鄰的兩個塊。）"

#: ../../howto/clinic.rst:244
#, fuzzy
msgid ""
"The name of the class and module should be the same as the one seen by "
"Python.  Check the name defined in the :c:type:`PyModuleDef` or :c:type:"
"`PyTypeObject` as appropriate."
msgstr ""
"類名和模組名應該和Python看到的一樣。檢查 :c:type:`PyModuleDef` 或 "
":c:type:`PyTypeObject` 中定義的名稱是否合適。"

#: ../../howto/clinic.rst:248
#, fuzzy
msgid ""
"When you declare a class, you must also specify two aspects of its type in "
"C: the type declaration you'd use for a pointer to an instance of this "
"class, and a pointer to the :c:type:`PyTypeObject` for this class."
msgstr ""
"當您聲明一個類時，您還必須在 C "
"中指定其型別的兩個方面：您將用於指向此類實例的指標的型別聲明，以及指向此類的 "
"PyTypeObject 的指標班級。"

#: ../../howto/clinic.rst:268
#, fuzzy
msgid ""
"Declare each of the parameters to the function.  Each parameter should get "
"its own line.  All the parameter lines should be indented from the function "
"name and the docstring."
msgstr "聲明函式的每個參數。每個參數都應該有自己的行。所有參數行都應從函式名稱和文檔"
"字串中縮進。"

#: ../../howto/clinic.rst:272
#, fuzzy
msgid "The general form of these parameter lines is as follows:"
msgstr "這些參數行的一般形式如下："

#: ../../howto/clinic.rst:278
#, fuzzy
msgid "If the parameter has a default value, add that after the converter:"
msgstr "如果參數有預設值，在轉換器後面新增："

#: ../../howto/clinic.rst:285
#, fuzzy
msgid ""
"Argument Clinic's support for \"default values\" is quite sophisticated; "
"please see :ref:`the section below on default values <default_values>` for "
"more information."
msgstr ""
"Argument Clinic 對“預設值”的支援非常複雜；請參閱 :ref:`下面關於預設值 "
"<default_values> 的部分以獲取更多資訊。"

#: ../../howto/clinic.rst:289
#, fuzzy
msgid "Add a blank line below the parameters."
msgstr "在參數下面新增一個空行。"

#: ../../howto/clinic.rst:291
#, fuzzy
msgid ""
"What's a \"converter\"?  It establishes both the type of the variable used "
"in C, and the method to convert the Python value into a C value at runtime. "
"For now you're going to use what's called a \"legacy converter\"—a "
"convenience syntax intended to make porting old code into Argument Clinic "
"easier."
msgstr ""
"什麼是“轉換器”？它建立了 C 中使用的變數型別，以及在運行時將 Python 值轉換為 "
"C 值的方法。現在您將使用所謂的“遺留轉換器”——"
"一種旨在使將舊程式碼更容易地移植到 Argument Clinic 中的便利語法。"

#: ../../howto/clinic.rst:298
#, fuzzy
msgid ""
"For each parameter, copy the \"format unit\" for that parameter from the "
"``PyArg_Parse()`` format argument and specify *that* as its converter, as a "
"quoted string.  (\"format unit\" is the formal name for the one-to-three "
"character substring of the ``format`` parameter that tells the argument "
"parsing function what the type of the variable is and how to convert it.  "
"For more on format units please see :ref:`arg-parsing`.)"
msgstr ""
"對於每個參數，從 ``PyArg_Parse()`` 格式參數中復制該參數的“格式單元”，並指定 "
"*that* 作為其轉換器，作為帶引號的字串。 （“格式單元”是 ``format`` 參數的一到"
"三個字元子字串的正式名稱，它告訴參數解析函式變數的型別是什麼以及如何轉換它。"
"有關格式單元的更多資訊請參閱 :ref:`arg-parsing`。）"

#: ../../howto/clinic.rst:307
#, fuzzy
msgid ""
"For multicharacter format units like ``z#``, use the entire two-or-three "
"character string."
msgstr "對於像 ``z#`` 這樣的多字元格式單元，使用整個兩個或三個字元的字串。"

#: ../../howto/clinic.rst:325
#, fuzzy
msgid ""
"If your function has ``|`` in the format string, meaning some parameters "
"have default values, you can ignore it.  Argument Clinic infers which "
"parameters are optional based on whether or not they have default values."
msgstr ""
"如果你的函式在格式字串中有``|``，意味著一些參數有預設值，你可以忽略它。 "
"Argument Clinic 根據參數是否具有預設值來推斷哪些參數是可選的。"

#: ../../howto/clinic.rst:330
#, fuzzy
msgid ""
"If your function has ``$`` in the format string, meaning it takes keyword-"
"only arguments, specify ``*`` on a line by itself before the first keyword-"
"only argument, indented the same as the parameter lines."
msgstr "如果您的函式在格式字串中有 ``$``，這意味著它只接受關鍵字參數，請在第一個僅關鍵字"
"參數之前單獨在一行上指定 ``*``，縮進與參數行相同。"

#: ../../howto/clinic.rst:335
#, fuzzy
msgid "(``_pickle.Pickler.dump`` has neither, so our sample is unchanged.)"
msgstr "（``_pickle.Pickler.dump`` 兩者都沒有，所以我們的樣本沒有改變。）"

#: ../../howto/clinic.rst:338
#, fuzzy
msgid ""
"If the existing C function calls :c:func:`PyArg_ParseTuple` (as opposed to :"
"c:func:`PyArg_ParseTupleAndKeywords`), then all its arguments are positional-"
"only."
msgstr ""
"如果現有的 C 函式呼叫 PyArg_ParseTuple（與 PyArg_ParseTupleAndKeywords "
"相反），那麼它的所有參數都是位置參數。"

#: ../../howto/clinic.rst:342
#, fuzzy
msgid ""
"To mark all parameters as positional-only in Argument Clinic, add a ``/`` on "
"a line by itself after the last parameter, indented the same as the "
"parameter lines."
msgstr "要在 Argument Clinic 中將所有參數標記為僅位置，請在最後一個參數之後單獨在一行"
"上新增一個``/``，縮進與參數行相同。"

#: ../../howto/clinic.rst:346
#, fuzzy
msgid ""
"Currently this is all-or-nothing; either all parameters are positional-only, "
"or none of them are.  (In the future Argument Clinic may relax this "
"restriction.)"
msgstr "目前這是全有或全無；要么所有參數都是位置參數，要么都不是。 （未來Argument "
"Clinic可能會放寬此限制。）"

#: ../../howto/clinic.rst:366
#, fuzzy
msgid ""
"It's helpful to write a per-parameter docstring for each parameter. But per-"
"parameter docstrings are optional; you can skip this step if you prefer."
msgstr "為每個參數編寫每個參數的文檔字串很有幫助。但是每個參數的文檔字串是可選的；如"
"果您願意，可以跳過此步驟。"

#: ../../howto/clinic.rst:370
#, fuzzy
msgid ""
"Here's how to add a per-parameter docstring.  The first line of the per-"
"parameter docstring must be indented further than the parameter definition.  "
"The left margin of this first line establishes the left margin for the whole "
"per-parameter docstring; all the text you write will be outdented by this "
"amount.  You can write as much text as you like, across multiple lines if "
"you wish."
msgstr ""
"下面是如何新增每個參數的文檔字串。每個參數文檔字串的第一行必須比參數定義縮進"
"更多。第一行的左邊距為整個每個參數的文檔字串建立了左邊距；你寫的所有文字都會"
"縮進這個數量。如果願意，您可以跨多行編寫任意多的文本。"

#: ../../howto/clinic.rst:394
#, fuzzy
msgid ""
"Save and close the file, then run ``Tools/clinic/clinic.py`` on it.  With "
"luck everything worked---your block now has output, and a ``.c.h`` file has "
"been generated! Reopen the file in your text editor to see::"
msgstr ""
"保存並關閉文件，然後在其上運行 ``Tools/clinic/clinic."
"py``。幸運的是，一切正常——你的塊現在有輸出，並且生成了一個 ``.c.h`` "
"文件！在文本編輯器中重新打開文件以查看："

#: ../../howto/clinic.rst:413
#, fuzzy
msgid ""
"Obviously, if Argument Clinic didn't produce any output, it's because it "
"found an error in your input.  Keep fixing your errors and retrying until "
"Argument Clinic processes your file without complaint."
msgstr ""
"顯然，如果 Argument Clinic "
"沒有產生任何輸出，那是因為它在您的輸入中發現了錯誤。繼續修復您的錯誤並重試，"
"直到 Argument Clinic 處理您的文件而沒有投訴。"

#: ../../howto/clinic.rst:417
#, fuzzy
msgid ""
"For readability, most of the glue code has been generated to a ``.c.h`` "
"file.  You'll need to include that in your original ``.c`` file, typically "
"right after the clinic module block::"
msgstr "為了可讀性，大部分膠水程式碼已生成為 .c.h 文件。您需要將其包含在原始的 ``.c``"
" 文件中，通常就在診所模組塊之後："

#: ../../howto/clinic.rst:423
#, fuzzy
msgid ""
"Double-check that the argument-parsing code Argument Clinic generated looks "
"basically the same as the existing code."
msgstr "仔細檢查 Argument Clinic 生成的參數解析程式碼看起來與現有程式碼基本相同。"

#: ../../howto/clinic.rst:426
#, fuzzy
msgid ""
"First, ensure both places use the same argument-parsing function. The "
"existing code must call either :c:func:`PyArg_ParseTuple` or :c:func:"
"`PyArg_ParseTupleAndKeywords`; ensure that the code generated by Argument "
"Clinic calls the *exact* same function."
msgstr ""
"首先，確保兩個地方使用相同的參數解析函式。現有程式碼必須呼叫 "
":c:func:`PyArg_ParseTuple` 或 :c:func:`PyArg_ParseTupleAndKeywords`；確保 "
"Argument Clinic 生成的程式碼呼叫*完全*相同的函式。"

#: ../../howto/clinic.rst:432
#, fuzzy
msgid ""
"Second, the format string passed in to :c:func:`PyArg_ParseTuple` or :c:func:"
"`PyArg_ParseTupleAndKeywords` should be *exactly* the same as the hand-"
"written one in the existing function, up to the colon or semi-colon."
msgstr ""
"其次，傳遞給 :c:func:`PyArg_ParseTuple` 或 "
":c:func:`PyArg_ParseTupleAndKeywords` "
"的格式字串應該*完全*與現有函式中的手寫格式字串相同，直到冒號或半-冒號。"

#: ../../howto/clinic.rst:437
#, fuzzy
msgid ""
"(Argument Clinic always generates its format strings with a ``:`` followed "
"by the name of the function.  If the existing code's format string ends with "
"``;``, to provide usage help, this change is harmless—don't worry about it.)"
msgstr ""
"（Argument Clinic "
"總是生成其格式字串，其後跟函式名稱： ``:``。如果現有程式碼的格式字串以``;`` "
"結尾，以提供使用幫助，此更改是無害的 - 不要擔心它。）"

#: ../../howto/clinic.rst:442
#, fuzzy
msgid ""
"Third, for parameters whose format units require two arguments (like a "
"length variable, or an encoding string, or a pointer to a conversion "
"function), ensure that the second argument is *exactly* the same between the "
"two invocations."
msgstr "第三，對於格式單元需要兩個參數（如長度變數、編碼字串或指向轉換函式的指標）的"
"參數，確保第二個參數在兩次呼叫之間*完全*相同。"

#: ../../howto/clinic.rst:447
#, fuzzy
msgid ""
"Fourth, inside the output portion of the block you'll find a preprocessor "
"macro defining the appropriate static :c:type:`PyMethodDef` structure for "
"this builtin::"
msgstr "第四，在塊的輸出部分內，您將找到一個預處理器巨集，"
"為這個內建函式定義適當的靜態 PyMethodDef 結構："

#: ../../howto/clinic.rst:454
#, fuzzy
msgid ""
"This static structure should be *exactly* the same as the existing static :c:"
"type:`PyMethodDef` structure for this builtin."
msgstr "此靜態結構應與此內建函式的現有靜態 :c:type:`PyMethodDef` 結構*完全*相同。"

#: ../../howto/clinic.rst:457
#, fuzzy
msgid ""
"If any of these items differ in *any way*, adjust your Argument Clinic "
"function specification and rerun ``Tools/clinic/clinic.py`` until they *are* "
"the same."
msgstr ""
"如果這些項目中的任何一項*以任何方式*不同，請調整您的 Argument Clinic "
"函式規範並重新運行 ``Tools/clinic/clinic.py`` 直到它們**相同。"

#: ../../howto/clinic.rst:462
#, fuzzy
msgid ""
"Notice that the last line of its output is the declaration of your \"impl\" "
"function.  This is where the builtin's implementation goes. Delete the "
"existing prototype of the function you're modifying, but leave the opening "
"curly brace.  Now delete its argument parsing code and the declarations of "
"all the variables it dumps the arguments into. Notice how the Python "
"arguments are now arguments to this impl function; if the implementation "
"used different names for these variables, fix it."
msgstr ""
"請注意，其輸出的最後一行是 ``impl``函式的聲明。這就是內建實作的地方。刪除您正在"
"修改的函式的現有原型，但保留左大括號。現在刪除它的參數解析程式碼和它轉儲參數"
"的所有變數的聲明。注意 Python 參數現在是這個 impl "
"函式的參數；如果實作對這些變數使用了不同的名稱，請修復它。"

#: ../../howto/clinic.rst:470
#, fuzzy
msgid ""
"Let's reiterate, just because it's kind of weird.  Your code should now look "
"like this::"
msgstr "讓我們重申一下，只是因為它有點奇怪。您的程式碼現在應該如下所示："

#: ../../howto/clinic.rst:479
#, fuzzy
msgid ""
"Argument Clinic generated the checksum line and the function prototype just "
"above it.  You should write the opening (and closing) curly braces for the "
"function, and the implementation inside."
msgstr "Argument Clinic 生成了校驗和行和它上面的函式原型。您應該為函式編寫左（和右）"
"花括號，以及其中的實作。"

#: ../../howto/clinic.rst:524
#, fuzzy
msgid ""
"Remember the macro with the :c:type:`PyMethodDef` structure for this "
"function?  Find the existing :c:type:`PyMethodDef` structure for this "
"function and replace it with a reference to the macro.  (If the builtin is "
"at module scope, this will probably be very near the end of the file; if the "
"builtin is a class method, this will probably be below but relatively near "
"to the implementation.)"
msgstr ""
"還記得這個函式的 PyMethodDef 結構巨集嗎？找到此函式的現有 "
":c:type:`PyMethodDef` 結構並將其替換為對巨集的引用。 （如果內建函式在模組範圍"
"內，這可能非常接近文件末尾；如果內建函式是類方法，這可能在下面但相對接近實作"
"。）"

#: ../../howto/clinic.rst:531
#, fuzzy
msgid ""
"Note that the body of the macro contains a trailing comma.  So when you "
"replace the existing static :c:type:`PyMethodDef` structure with the macro, "
"*don't* add a comma to the end."
msgstr "請注意，巨集的主體包含尾隨逗號。因此，當您用巨集替換現有的靜態 "
":c:type:`PyMethodDef` 結構時，*不要*在末尾新增逗號。"

#: ../../howto/clinic.rst:544
#, fuzzy
msgid ""
"Compile, then run the relevant portions of the regression-test suite. This "
"change should not introduce any new compile-time warnings or errors, and "
"there should be no externally visible change to Python's behavior."
msgstr "編譯，然後運行回歸測試套件的相關部分。此更改不應引入任何新的編譯時警告或錯誤"
"，並且 Python 的行為不應有任何外部可見的更改。"

#: ../../howto/clinic.rst:548
#, fuzzy
msgid ""
"Well, except for one difference: ``inspect.signature()`` run on your "
"function should now provide a valid signature!"
msgstr "好吧，除了一個區別：在你的函式上運行的``inspect."
"signature()``現在應該提供一個有效的簽名！"

#: ../../howto/clinic.rst:551
#, fuzzy
msgid ""
"Congratulations, you've ported your first function to work with Argument "
"Clinic!"
msgstr "恭喜，您已將第一個函式移植到 Argument Clinic 中！"

#: ../../howto/clinic.rst:554
#, fuzzy
msgid "Advanced Topics"
msgstr "高階主題"

#: ../../howto/clinic.rst:556
#, fuzzy
msgid ""
"Now that you've had some experience working with Argument Clinic, it's time "
"for some advanced topics."
msgstr "現在您已經有了一些使用 Argument Clinic 的經驗，是時候討論一些高階主題了。"

#: ../../howto/clinic.rst:561
#, fuzzy
msgid "Symbolic default values"
msgstr "符號預設值"

#: ../../howto/clinic.rst:563
#, fuzzy
msgid ""
"The default value you provide for a parameter can't be any arbitrary "
"expression.  Currently the following are explicitly supported:"
msgstr "您為參數提供的預設值不能是任意表達式。目前明確支援以下內容："

#: ../../howto/clinic.rst:566
#, fuzzy
msgid "Numeric constants (integer and float)"
msgstr "數值常數（整數和浮點數）"

#: ../../howto/clinic.rst:567
#, fuzzy
msgid "String constants"
msgstr "字串常數"

#: ../../howto/clinic.rst:568
#, fuzzy
msgid "``True``, ``False``, and ``None``"
msgstr " ``True``、 ``False``和 ``None`` "

#: ../../howto/clinic.rst:569
#, fuzzy
msgid ""
"Simple symbolic constants like ``sys.maxsize``, which must start with the "
"name of the module"
msgstr "簡單的符號常數，如“sys.maxsize”，必須以模組名稱開頭"

#: ../../howto/clinic.rst:572
#, fuzzy
msgid ""
"(In the future, this may need to get even more elaborate, to allow full "
"expressions like ``CONSTANT - 1``.)"
msgstr "（在未來，這可能需要變得更加精細，以允許像 ``CONSTANT - 1`` "
"這樣的完整表達式。）"

#: ../../howto/clinic.rst:577
#, fuzzy
msgid "Renaming the C functions and variables generated by Argument Clinic"
msgstr "重命名 Argument Clinic 生成的 C 函式和變數"

#: ../../howto/clinic.rst:579
#, fuzzy
msgid ""
"Argument Clinic automatically names the functions it generates for you. "
"Occasionally this may cause a problem, if the generated name collides with "
"the name of an existing C function.  There's an easy solution: override the "
"names used for the C functions.  Just add the keyword ``\"as\"`` to your "
"function declaration line, followed by the function name you wish to use. "
"Argument Clinic will use that function name for the base (generated) "
"function, then add ``\"_impl\"`` to the end and use that for the name of the "
"impl function."
msgstr ""
"Argument Clinic 會自動為它生成的函式命名。如果生成的名稱與現有 C "
"函式的名稱衝突，有時這可能會導致問題。有一個簡單的解決方案：覆蓋用於 C "
"函式的名稱。只需將關鍵字 ``\"as\"`` "
"新增到您的函式聲明行，然後是您要使用的函式名稱。 Argument Clinic "
"將使用該函式名稱作為基本（生成的）函式，然後將“_impl”新增到末尾並將其用作 "
"impl 函式的名稱。"

#: ../../howto/clinic.rst:587
#, fuzzy
msgid ""
"For example, if we wanted to rename the C function names generated for "
"``pickle.Pickler.dump``, it'd look like this::"
msgstr "例如，如果我們想重命名為 ``pickle.Pickler.dump`` 生成的 C "
"函式名稱，它看起來像這樣："

#: ../../howto/clinic.rst:595
#, fuzzy
msgid ""
"The base function would now be named ``pickler_dumper()``, and the impl "
"function would now be named ``pickler_dumper_impl()``."
msgstr "基函式現在將命名為“pickler_dumper()”，impl "
"函式現在將命名為“pickler_dumper_impl()”。"

#: ../../howto/clinic.rst:599
#, fuzzy
msgid ""
"Similarly, you may have a problem where you want to give a parameter a "
"specific Python name, but that name may be inconvenient in C.  Argument "
"Clinic allows you to give a parameter different names in Python and in C, "
"using the same ``\"as\"`` syntax::"
msgstr ""
"同樣，您可能會遇到問題，您想要為參數指定一個特定的 Python 名稱，但該名稱在 C "
"中可能不方便。Argument Clinic 允許您使用相同的 ``\" 在 Python 和 C "
"中為參數指定不同的名稱作為“``語法::"

#: ../../howto/clinic.rst:613
#, fuzzy
msgid ""
"Here, the name used in Python (in the signature and the ``keywords`` array) "
"would be ``file``, but the C variable would be named ``file_obj``."
msgstr ""
"在這裡，Python 中使用的名稱（在簽名和 ``keywords`` 數組中）將是 ``file``，但 "
"C 變數將被命名為 ``file_obj``。"

#: ../../howto/clinic.rst:616
#, fuzzy
msgid "You can use this to rename the ``self`` parameter too!"
msgstr "您也可以使用它來重命名 ``self`` 參數！"

#: ../../howto/clinic.rst:620
#, fuzzy
msgid "Converting functions using PyArg_UnpackTuple"
msgstr "使用 PyArg_UnpackTuple 轉換函式"

#: ../../howto/clinic.rst:622
#, fuzzy
msgid ""
"To convert a function parsing its arguments with :c:func:"
"`PyArg_UnpackTuple`, simply write out all the arguments, specifying each as "
"an ``object``.  You may specify the ``type`` argument to cast the type as "
"appropriate.  All arguments should be marked positional-only (add a ``/`` on "
"a line by itself after the last argument)."
msgstr ""
"要轉換使用 PyArg_UnpackTuple "
"解析其參數的函式，只需寫出所有參數，將每個參數指定為一個“物件”。您可以指定 "
"``type`` 參數以適當地轉換型別。所有參數都應標記為僅限位置（在最後一個參數後單"
"獨在一行上新增一個``/``）。"

#: ../../howto/clinic.rst:628
#, fuzzy
msgid ""
"Currently the generated code will use :c:func:`PyArg_ParseTuple`, but this "
"will change soon."
msgstr "目前生成的程式碼將使用 :c:func:`PyArg_ParseTuple`，但這很快就會改變。"

#: ../../howto/clinic.rst:632
#, fuzzy
msgid "Optional Groups"
msgstr "可選組"

#: ../../howto/clinic.rst:634
#, fuzzy
msgid ""
"Some legacy functions have a tricky approach to parsing their arguments: "
"they count the number of positional arguments, then use a ``switch`` "
"statement to call one of several different :c:func:`PyArg_ParseTuple` calls "
"depending on how many positional arguments there are.  (These functions "
"cannot accept keyword-only arguments.)  This approach was used to simulate "
"optional arguments back before :c:func:`PyArg_ParseTupleAndKeywords` was "
"created."
msgstr ""
"一些遺留函式有一種巧妙的方法來解析它們的參數：它們計算位置參數的數量，"
"然後使用 ``switch`` "
"語句根據位置參數的數量呼叫幾個不同的:c:func:`PyArg_ParseTuple` 呼叫之一有。 "
"（這些函式不能接受僅限關鍵字的參數。）這種方法用於在建立 "
":c:func:`PyArg_ParseTupleAndKeywords` 之前模擬可選參數。"

#: ../../howto/clinic.rst:641
#, fuzzy
msgid ""
"While functions using this approach can often be converted to use :c:func:"
"`PyArg_ParseTupleAndKeywords`, optional arguments, and default values, it's "
"not always possible.  Some of these legacy functions have behaviors :c:func:"
"`PyArg_ParseTupleAndKeywords` doesn't directly support. The most obvious "
"example is the builtin function ``range()``, which has an optional argument "
"on the *left* side of its required argument! Another example is ``curses."
"window.addch()``, which has a group of two arguments that must always be "
"specified together.  (The arguments are called ``x`` and ``y``; if you call "
"the function passing in ``x``, you must also pass in ``y``—and if you don't "
"pass in ``x`` you may not pass in ``y`` either.)"
msgstr ""
"雖然使用這種方法的函式通常可以轉換為使用 :c:func:`PyArg_ParseTupleAndKeywords"
"`、可選參數和預設值，但這並不總是可行的。其中一些遺留函式具有不直接支援的行為"
" :c:func:`PyArg_ParseTupleAndKeywords`。最明顯的例子是內建函式 ``range()``，"
"它在必需參數的 *左側* 側有一個可選參數！另一個例子是“curses.window."
"addch()”，它有一組必須始終一起指定的兩個參數。 （參數稱為 ``x`` 和 ``y``；"
"如果您呼叫傳入 ``x`` 的函式，則還必須傳入 ``y`` —— 如果您不傳入 ` `x`` "
"你也不能傳入 ``y``。）"

#: ../../howto/clinic.rst:653
#, fuzzy
msgid ""
"In any case, the goal of Argument Clinic is to support argument parsing for "
"all existing CPython builtins without changing their semantics. Therefore "
"Argument Clinic supports this alternate approach to parsing, using what are "
"called *optional groups*. Optional groups are groups of arguments that must "
"all be passed in together. They can be to the left or the right of the "
"required arguments.  They can *only* be used with positional-only parameters."
msgstr ""
"無論如何，Argument Clinic 的目標是在不改變語義的情況下支援所有現有 CPython "
"內建函式的參數解析。因此，Argument Clinic 支援這種替代的解析方法，使用所謂的*"
"可選組*。可選組是必須全部一起傳遞的參數組。它們可以位於所需參數的左側或右側。"
"它們*只能*與僅限位置的參數一起使用。"

#: ../../howto/clinic.rst:661
#, fuzzy
msgid ""
"Optional groups are *only* intended for use when converting functions that "
"make multiple calls to :c:func:`PyArg_ParseTuple`! Functions that use *any* "
"other approach for parsing arguments should *almost never* be converted to "
"Argument Clinic using optional groups.  Functions using optional groups "
"currently cannot have accurate signatures in Python, because Python just "
"doesn't understand the concept.  Please avoid using optional groups wherever "
"possible."
msgstr ""
"可選組*僅*用於轉換多次呼叫 :c:func:`PyArg_ParseTuple` "
"的函式時使用！使用*任何*其他方法解析參數的函式應該*幾乎永遠不會*"
"使用可選組轉換為 Argument Clinic。使用可選組的函式目前在 Python "
"中不能有準確的簽名，因為 Python 不理解這個概念。請盡可能避免使用可選組。"

#: ../../howto/clinic.rst:670
#, fuzzy
msgid ""
"To specify an optional group, add a ``[`` on a line by itself before the "
"parameters you wish to group together, and a ``]`` on a line by itself after "
"these parameters.  As an example, here's how ``curses.window.addch`` uses "
"optional groups to make the first two parameters and the last parameter "
"optional::"
msgstr ""
"要指定一個可選組，請在您希望組合在一起的參數之前單獨在一行中新增一個 ``[``，"
"並在這些參數之後單獨在一行中新增一個 ``]``。例如，以下是 ``curses.window."
"addch`` 如何使用可選組來使前兩個參數和最後一個參數可選："

#: ../../howto/clinic.rst:699
msgid "Notes:"
msgstr "註解："

#: ../../howto/clinic.rst:701
#, fuzzy
msgid ""
"For every optional group, one additional parameter will be passed into the "
"impl function representing the group.  The parameter will be an int named "
"``group_{direction}_{number}``, where ``{direction}`` is either ``right`` or "
"``left`` depending on whether the group is before or after the required "
"parameters, and ``{number}`` is a monotonically increasing number (starting "
"at 1) indicating how far away the group is from the required parameters.  "
"When the impl is called, this parameter will be set to zero if this group "
"was unused, and set to non-zero if this group was used. (By used or unused, "
"I mean whether or not the parameters received arguments in this invocation.)"
msgstr ""
"對於每個可選組，一個附加參數將被傳遞到表示該組的 impl 函式中。"
"該參數將是一個名為 ``group_{direction}_{number}`` 的整數，其中 "
"``{direction}`` 是 ``right`` 或 ``left`` "
"取決於組是在之前還是之後所需的參數，``{number}`` 是一個單調遞增的數字（從 1 "
"開始），表示該組與所需參數的距離。呼叫 impl "
"時，如果未使用該組，則此參數將設定為零，如果使用該組，則設定為非零。 "
"（使用或未使用，我的意思是參數是否在此呼叫中接收到參數。）"

#: ../../howto/clinic.rst:712
#, fuzzy
msgid ""
"If there are no required arguments, the optional groups will behave as if "
"they're to the right of the required arguments."
msgstr "如果沒有必需參數，則可選組的行為就好像它們位於必需參數的右側一樣。"

#: ../../howto/clinic.rst:715
#, fuzzy
msgid ""
"In the case of ambiguity, the argument parsing code favors parameters on the "
"left (before the required parameters)."
msgstr "在歧義的情況下，參數解析程式碼傾向於左側的參數（在必需參數之前）。"

#: ../../howto/clinic.rst:718
#, fuzzy
msgid "Optional groups can only contain positional-only parameters."
msgstr "可選組只能包含位置參數。"

#: ../../howto/clinic.rst:720
#, fuzzy
msgid ""
"Optional groups are *only* intended for legacy code.  Please do not use "
"optional groups for new code."
msgstr "可選組*僅*用於遺留程式碼。請不要為新程式碼使用可選組。"

#: ../../howto/clinic.rst:725
#, fuzzy
msgid "Using real Argument Clinic converters, instead of \"legacy converters\""
msgstr "使用真正的 Argument Clinic 轉換器，而不是“傳統轉換器”"

#: ../../howto/clinic.rst:727
#, fuzzy
msgid ""
"To save time, and to minimize how much you need to learn to achieve your "
"first port to Argument Clinic, the walkthrough above tells you to use "
"\"legacy converters\".  \"Legacy converters\" are a convenience, designed "
"explicitly to make porting existing code to Argument Clinic easier.  And to "
"be clear, their use is acceptable when porting code for Python 3.4."
msgstr ""
"為了節省時間，並最大程度地減少實作第一個 Argument Clinic "
"端口所需的學習量，上面的演練告訴您使用“遺留轉換器”。 “遺留轉換器”是一種便利，"
"明確設計用於使將現有程式碼移植到 Argument Clinic 更容易。需要明確的是，在為 "
"Python 3.4 移植程式碼時，它們的使用是可以接受的。"

#: ../../howto/clinic.rst:734
#, fuzzy
msgid ""
"However, in the long term we probably want all our blocks to use Argument "
"Clinic's real syntax for converters.  Why?  A couple reasons:"
msgstr "然而，從長遠來看，我們可能希望我們所有的塊都使用 Argument Clinic "
"的轉換器的真實語法。為什麼？幾個原因："

#: ../../howto/clinic.rst:738
#, fuzzy
msgid ""
"The proper converters are far easier to read and clearer in their intent."
msgstr "適當的轉換器更容易閱讀，其意圖也更清晰。"

#: ../../howto/clinic.rst:739
#, fuzzy
msgid ""
"There are some format units that are unsupported as \"legacy converters\", "
"because they require arguments, and the legacy converter syntax doesn't "
"support specifying arguments."
msgstr "有些格式單元不支援作為“遺留轉換器”，因為它們需要參數，而遺留轉換器語法不支援"
"指定參數。"

#: ../../howto/clinic.rst:742
#, fuzzy
msgid ""
"In the future we may have a new argument parsing library that isn't "
"restricted to what :c:func:`PyArg_ParseTuple` supports; this flexibility "
"won't be available to parameters using legacy converters."
msgstr ""
"將來我們可能會有一個新的參數解析庫，它不限於 :c:func:`PyArg_ParseTuple` "
"支援的內容；使用傳統轉換器的參數將無法使用這種靈活性。"

#: ../../howto/clinic.rst:746
#, fuzzy
msgid ""
"Therefore, if you don't mind a little extra effort, please use the normal "
"converters instead of legacy converters."
msgstr "因此，如果您不介意多花點功夫，請使用普通轉換器而不是傳統轉換器。"

#: ../../howto/clinic.rst:749
#, fuzzy
msgid ""
"In a nutshell, the syntax for Argument Clinic (non-legacy) converters looks "
"like a Python function call.  However, if there are no explicit arguments to "
"the function (all functions take their default values), you may omit the "
"parentheses.  Thus ``bool`` and ``bool()`` are exactly the same converters."
msgstr ""
"簡而言之，Argument Clinic（非遺留）轉換器的語法看起來像 Python 函式呼叫。但是"
"，如果函式沒有顯式參數（所有函式都採用預設值），則可以省略括號。因此，``bool`"
"` 和 ``bool()`` 是完全相同的轉換器。"

#: ../../howto/clinic.rst:755
#, fuzzy
msgid ""
"All arguments to Argument Clinic converters are keyword-only. All Argument "
"Clinic converters accept the following arguments:"
msgstr "Argument Clinic 轉換器的所有參數都是關鍵字。所有 Argument Clinic "
"轉換器都接受以下參數："

#: ../../howto/clinic.rst:763 ../../howto/clinic.rst:1313
msgid "``c_default``"
msgstr "``c_default``"

#: ../../howto/clinic.rst:759
#, fuzzy
msgid ""
"The default value for this parameter when defined in C. Specifically, this "
"will be the initializer for the variable declared in the \"parse function"
"\".  See :ref:`the section on default values <default_values>` for how to "
"use this. Specified as a string."
msgstr ""
"在 C 中定義時此參數的預設值。具體來說，這將是“解析函式”中聲明的變數的初始值設"
"定項。請參閱 :ref:`關於預設值 <default_values> "
"的部分了解如何使用它。指定為字串。"

#: ../../howto/clinic.rst:768
msgid "``annotation``"
msgstr "``annotation``"

#: ../../howto/clinic.rst:766
#, fuzzy
msgid ""
"The annotation value for this parameter.  Not currently supported, because :"
"pep:`8` mandates that the Python library may not use annotations."
msgstr "此參數的註釋值。目前不支援，因為 :pep:`8` 要求 Python 庫不能使用註釋。"

#: ../../howto/clinic.rst:770
#, fuzzy
msgid ""
"In addition, some converters accept additional arguments.  Here is a list of "
"these arguments, along with their meanings:"
msgstr "此外，一些轉換器接受額外的參數。以下是這些參數及其含義的列表："

#: ../../howto/clinic.rst:779
msgid "``accept``"
msgstr "``accept``"

#: ../../howto/clinic.rst:774
#, fuzzy
msgid ""
"A set of Python types (and possibly pseudo-types); this restricts the "
"allowable Python argument to values of these types. (This is not a general-"
"purpose facility; as a rule it only supports specific lists of types as "
"shown in the legacy converter table.)"
msgstr ""
"一組 Python 型別（可能還有偽型別）；這將允許的 Python "
"參數限制為這些型別的值。 "
"（這不是通用設施；通常它只支援特定的型別列表，如遺留轉換器表中所示。）"

#: ../../howto/clinic.rst:779
#, fuzzy
msgid "To accept ``None``, add ``NoneType`` to this set."
msgstr "要接受 ``None``，請將 ``NoneType`` 新增到此集合。"

#: ../../howto/clinic.rst:784
msgid "``bitwise``"
msgstr "``bitwise``"

#: ../../howto/clinic.rst:782
#, fuzzy
msgid ""
"Only supported for unsigned integers.  The native integer value of this "
"Python argument will be written to the parameter without any range checking, "
"even for negative values."
msgstr "僅支援無符號整數。此 Python "
"參數的本機整數值將在不進行任何範圍檢查的情況下寫入參數，即使是負值也是如此。"

#: ../../howto/clinic.rst:789 ../../howto/clinic.rst:1327
msgid "``converter``"
msgstr "``converter``"

#: ../../howto/clinic.rst:787
#, fuzzy
msgid ""
"Only supported by the ``object`` converter.  Specifies the name of a :ref:`C "
"\"converter function\" <o_ampersand>` to use to convert this object to a "
"native type."
msgstr "僅受 ``object`` 轉換器支援。指定 :ref:`C“轉換器函式”<o_ampersand>` "
"的名稱，用於將此物件轉換為本機型別。"

#: ../../howto/clinic.rst:794
msgid "``encoding``"
msgstr "``encoding``"

#: ../../howto/clinic.rst:792
#, fuzzy
msgid ""
"Only supported for strings.  Specifies the encoding to use when converting "
"this string from a Python str (Unicode) value into a C ``char *`` value."
msgstr "僅支援字串。指定將此字串從 Python str (Unicode) 值轉換為 C ``char *`` "
"值時使用的編碼。"

#: ../../howto/clinic.rst:798
msgid "``subclass_of``"
msgstr "``subclass_of``"

#: ../../howto/clinic.rst:797
#, fuzzy
msgid ""
"Only supported for the ``object`` converter.  Requires that the Python value "
"be a subclass of a Python type, as expressed in C."
msgstr "僅支援 ``object`` 轉換器。要求 Python 值是 Python 型別的子類別，如 C "
"中所表達的那樣。"

#: ../../howto/clinic.rst:803 ../../howto/clinic.rst:1299
msgid "``type``"
msgstr "``type``"

#: ../../howto/clinic.rst:801
#, fuzzy
msgid ""
"Only supported for the ``object`` and ``self`` converters.  Specifies the C "
"type that will be used to declare the variable.  Default value is ``"
"\"PyObject *\"``."
msgstr "僅支援 ``object`` 和 ``self`` 轉換器。指定將用於聲明變數的 C 型別。預設值為``"
"\"PyObject *\"``。"

#: ../../howto/clinic.rst:809
msgid "``zeroes``"
msgstr "``zeroes``"

#: ../../howto/clinic.rst:806
#, fuzzy
msgid ""
"Only supported for strings.  If true, embedded NUL bytes (``'\\\\0'``) are "
"permitted inside the value.  The length of the string will be passed in to "
"the impl function, just after the string parameter, as a parameter named "
"``<parameter_name>_length``."
msgstr ""
"僅支援字串。如果為真，則值內允許嵌入 NUL 位元組（``'\\\\0"
"'``）。字串的長度將作為名為“<parameter_name>_length”的參數傳遞給 impl "
"函式，就在字串參數之後。"

#: ../../howto/clinic.rst:811
#, fuzzy
msgid ""
"Please note, not every possible combination of arguments will work. Usually "
"these arguments are implemented by specific ``PyArg_ParseTuple`` *format "
"units*, with specific behavior.  For example, currently you cannot call "
"``unsigned_short`` without also specifying ``bitwise=True``. Although it's "
"perfectly reasonable to think this would work, these semantics don't map to "
"any existing format unit.  So Argument Clinic doesn't support it.  (Or, at "
"least, not yet.)"
msgstr ""
"請注意，並非所有可能的參數組合都有效。通常這些參數由特定的``PyArg_ParseTuple`"
"`*格式單元*實作，具有特定的行為。例如，目前您不能在不指定 ``bitwise=True`` "
"的情況下呼叫 ``unsigned_short``。雖然認為這行得通是完全合理的，但這些語義並不"
"映射到任何現有的格式單元。所以 Argument Clinic 不支援它。 "
"（或者，至少，現在還沒有。）"

#: ../../howto/clinic.rst:819
#, fuzzy
msgid ""
"Below is a table showing the mapping of legacy converters into real Argument "
"Clinic converters.  On the left is the legacy converter, on the right is the "
"text you'd replace it with."
msgstr "下表顯示了遺留轉換器到真正的 Argument Clinic "
"轉換器的映射。左邊是舊版轉換器，右邊是你要替換它的文本。"

#: ../../howto/clinic.rst:824
msgid "``'B'``"
msgstr "``'B'``"

#: ../../howto/clinic.rst:824
msgid "``unsigned_char(bitwise=True)``"
msgstr "``unsigned_char(bitwise=True)``"

#: ../../howto/clinic.rst:825
msgid "``'b'``"
msgstr "``'b'``"

#: ../../howto/clinic.rst:825
msgid "``unsigned_char``"
msgstr "``unsigned_char``"

#: ../../howto/clinic.rst:826
msgid "``'c'``"
msgstr "``'c'``"

#: ../../howto/clinic.rst:826
msgid "``char``"
msgstr "``char``"

#: ../../howto/clinic.rst:827
msgid "``'C'``"
msgstr "``'C'``"

#: ../../howto/clinic.rst:827
msgid "``int(accept={str})``"
msgstr "``int(accept={str})``"

#: ../../howto/clinic.rst:828
msgid "``'d'``"
msgstr "``'d'``"

#: ../../howto/clinic.rst:828
msgid "``double``"
msgstr "``double``"

#: ../../howto/clinic.rst:829
msgid "``'D'``"
msgstr "``'D'``"

#: ../../howto/clinic.rst:829
msgid "``Py_complex``"
msgstr "``Py_complex``"

#: ../../howto/clinic.rst:830
msgid "``'es'``"
msgstr "``'es'``"

#: ../../howto/clinic.rst:830
msgid "``str(encoding='name_of_encoding')``"
msgstr "``str(encoding='name_of_encoding')``"

#: ../../howto/clinic.rst:831
msgid "``'es#'``"
msgstr "``'es#'``"

#: ../../howto/clinic.rst:831
msgid "``str(encoding='name_of_encoding', zeroes=True)``"
msgstr "``str(encoding='name_of_encoding', zeroes=True)``"

#: ../../howto/clinic.rst:832
msgid "``'et'``"
msgstr "``'et'``"

#: ../../howto/clinic.rst:832
msgid "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"
msgstr "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"

#: ../../howto/clinic.rst:833
msgid "``'et#'``"
msgstr "``'et#'``"

#: ../../howto/clinic.rst:833
#, fuzzy
msgid ""
"``str(encoding='name_of_encoding', accept={bytes, bytearray, str}, "
"zeroes=True)``"
msgstr ""
"``str(encoding='name_of_encoding', accept={bytes, bytearray, str}, "
"zeroes=True)``"

#: ../../howto/clinic.rst:834
msgid "``'f'``"
msgstr "``'f'``"

#: ../../howto/clinic.rst:834
msgid "``float``"
msgstr "``float``"

#: ../../howto/clinic.rst:835
msgid "``'h'``"
msgstr "``'h'``"

#: ../../howto/clinic.rst:835
msgid "``short``"
msgstr "``short``"

#: ../../howto/clinic.rst:836
msgid "``'H'``"
msgstr "``'H'``"

#: ../../howto/clinic.rst:836
msgid "``unsigned_short(bitwise=True)``"
msgstr "``unsigned_short(bitwise=True)``"

#: ../../howto/clinic.rst:837
msgid "``'i'``"
msgstr "``'i'``"

#: ../../howto/clinic.rst:837
msgid "``int``"
msgstr "``int``"

#: ../../howto/clinic.rst:838
msgid "``'I'``"
msgstr "``'I'``"

#: ../../howto/clinic.rst:838
msgid "``unsigned_int(bitwise=True)``"
msgstr "``unsigned_int(bitwise=True)``"

#: ../../howto/clinic.rst:839
msgid "``'k'``"
msgstr "``'k'``"

#: ../../howto/clinic.rst:839
msgid "``unsigned_long(bitwise=True)``"
msgstr "``unsigned_long(bitwise=True)``"

#: ../../howto/clinic.rst:840
msgid "``'K'``"
msgstr "``'K'``"

#: ../../howto/clinic.rst:840
msgid "``unsigned_long_long(bitwise=True)``"
msgstr "``unsigned_long_long(bitwise=True)``"

#: ../../howto/clinic.rst:841
msgid "``'l'``"
msgstr "``'l'``"

#: ../../howto/clinic.rst:841
msgid "``long``"
msgstr "``long``"

#: ../../howto/clinic.rst:842
msgid "``'L'``"
msgstr "``'L'``"

#: ../../howto/clinic.rst:842
msgid "``long long``"
msgstr "``long long``"

#: ../../howto/clinic.rst:843
msgid "``'n'``"
msgstr "``'n'``"

#: ../../howto/clinic.rst:843
msgid "``Py_ssize_t``"
msgstr "``Py_ssize_t``"

#: ../../howto/clinic.rst:844
msgid "``'O'``"
msgstr "``'O'``"

#: ../../howto/clinic.rst:844
msgid "``object``"
msgstr "``object``"

#: ../../howto/clinic.rst:845
msgid "``'O!'``"
msgstr "``'O!'``"

#: ../../howto/clinic.rst:845
msgid "``object(subclass_of='&PySomething_Type')``"
msgstr "``object(subclass_of='&PySomething_Type')``"

#: ../../howto/clinic.rst:846
msgid "``'O&'``"
msgstr "``'O&'``"

#: ../../howto/clinic.rst:846
msgid "``object(converter='name_of_c_function')``"
msgstr "``object(converter='name_of_c_function')``"

#: ../../howto/clinic.rst:847
msgid "``'p'``"
msgstr "``'p'``"

#: ../../howto/clinic.rst:847
msgid "``bool``"
msgstr "``bool``"

#: ../../howto/clinic.rst:848
msgid "``'S'``"
msgstr "``'S'``"

#: ../../howto/clinic.rst:848
msgid "``PyBytesObject``"
msgstr "``PyBytesObject``"

#: ../../howto/clinic.rst:849
msgid "``'s'``"
msgstr "``'s'``"

#: ../../howto/clinic.rst:849
msgid "``str``"
msgstr "``str``"

#: ../../howto/clinic.rst:850
msgid "``'s#'``"
msgstr "``'s#'``"

#: ../../howto/clinic.rst:850
msgid "``str(zeroes=True)``"
msgstr "``str(zeroes=True)``"

#: ../../howto/clinic.rst:851
msgid "``'s*'``"
msgstr "``'s*'``"

#: ../../howto/clinic.rst:851
msgid "``Py_buffer(accept={buffer, str})``"
msgstr "``Py_buffer(accept={buffer, str})``"

#: ../../howto/clinic.rst:852
msgid "``'U'``"
msgstr "``'U'``"

#: ../../howto/clinic.rst:852
msgid "``unicode``"
msgstr "``unicode``"

#: ../../howto/clinic.rst:853
msgid "``'u'``"
msgstr "``'u'``"

#: ../../howto/clinic.rst:853
msgid "``Py_UNICODE``"
msgstr "``Py_UNICODE``"

#: ../../howto/clinic.rst:854
msgid "``'u#'``"
msgstr "``'u#'``"

#: ../../howto/clinic.rst:854
msgid "``Py_UNICODE(zeroes=True)``"
msgstr "``Py_UNICODE(zeroes=True)``"

#: ../../howto/clinic.rst:855
msgid "``'w*'``"
msgstr "``'w*'``"

#: ../../howto/clinic.rst:855
msgid "``Py_buffer(accept={rwbuffer})``"
msgstr "``Py_buffer(accept={rwbuffer})``"

#: ../../howto/clinic.rst:856
msgid "``'Y'``"
msgstr "``'Y'``"

#: ../../howto/clinic.rst:856
msgid "``PyByteArrayObject``"
msgstr "``PyByteArrayObject``"

#: ../../howto/clinic.rst:857
msgid "``'y'``"
msgstr "``'y'``"

#: ../../howto/clinic.rst:857
msgid "``str(accept={bytes})``"
msgstr "``str(accept={bytes})``"

#: ../../howto/clinic.rst:858
msgid "``'y#'``"
msgstr "``'y#'``"

#: ../../howto/clinic.rst:858
msgid "``str(accept={robuffer}, zeroes=True)``"
msgstr "``str(accept={robuffer}, zeroes=True)``"

#: ../../howto/clinic.rst:859
msgid "``'y*'``"
msgstr "``'y*'``"

#: ../../howto/clinic.rst:859
msgid "``Py_buffer``"
msgstr "``Py_buffer``"

#: ../../howto/clinic.rst:860
msgid "``'Z'``"
msgstr "``'Z'``"

#: ../../howto/clinic.rst:860
msgid "``Py_UNICODE(accept={str, NoneType})``"
msgstr "``Py_UNICODE(accept={str, NoneType})``"

#: ../../howto/clinic.rst:861
msgid "``'Z#'``"
msgstr "``'Z#'``"

#: ../../howto/clinic.rst:861
msgid "``Py_UNICODE(accept={str, NoneType}, zeroes=True)``"
msgstr "``Py_UNICODE(accept={str, NoneType}, zeroes=True)``"

#: ../../howto/clinic.rst:862
msgid "``'z'``"
msgstr "``'z'``"

#: ../../howto/clinic.rst:862
msgid "``str(accept={str, NoneType})``"
msgstr "``str(accept={str, NoneType})``"

#: ../../howto/clinic.rst:863
msgid "``'z#'``"
msgstr "``'z#'``"

#: ../../howto/clinic.rst:863
msgid "``str(accept={str, NoneType}, zeroes=True)``"
msgstr "``str(accept={str, NoneType}, zeroes=True)``"

#: ../../howto/clinic.rst:864
msgid "``'z*'``"
msgstr "``'z*'``"

#: ../../howto/clinic.rst:864
msgid "``Py_buffer(accept={buffer, str, NoneType})``"
msgstr "``Py_buffer(accept={buffer, str, NoneType})``"

#: ../../howto/clinic.rst:867
#, fuzzy
msgid ""
"As an example, here's our sample ``pickle.Pickler.dump`` using the proper "
"converter::"
msgstr "例如，這是我們使用適當轉換器的示例 ``pickle.Pickler.dump``::"

#: ../../howto/clinic.rst:880
#, fuzzy
msgid ""
"One advantage of real converters is that they're more flexible than legacy "
"converters.  For example, the ``unsigned_int`` converter (and all the "
"``unsigned_`` converters) can be specified without ``bitwise=True``.  Their "
"default behavior performs range checking on the value, and they won't accept "
"negative numbers.  You just can't do that with a legacy converter!"
msgstr ""
"真實轉換器的優勢之一是它們比傳統轉換器更靈活。例如，``unsigned_int`` "
"轉換器（以及所有``unsigned_`` 轉換器）可以在沒有``bitwise=True`` 的情況下指定"
"。它們的預設行為是對值執行範圍檢查，並且不接受負數。你不能用傳統的轉換器來做"
"到這一點！"

#: ../../howto/clinic.rst:886
#, fuzzy
msgid ""
"Argument Clinic will show you all the converters it has available.  For each "
"converter it'll show you all the parameters it accepts, along with the "
"default value for each parameter. Just run ``Tools/clinic/clinic.py --"
"converters`` to see the full list."
msgstr ""
"Argument Clinic 將向您展示它可用的所有轉換器。對於每個轉換器，它會向您顯示它"
"接受的所有參數，以及每個參數的預設值。只需運行“Tools/clinic/clinic.py "
"--converters”即可查看完整列表。"

#: ../../howto/clinic.rst:892
msgid "Py_buffer"
msgstr "Py_buffer"

#: ../../howto/clinic.rst:894
#, fuzzy
msgid ""
"When using the ``Py_buffer`` converter (or the ``'s*'``, ``'w*'``, ``'*y'``, "
"or ``'z*'`` legacy converters), you *must* not call :c:func:"
"`PyBuffer_Release` on the provided buffer. Argument Clinic generates code "
"that does it for you (in the parsing function)."
msgstr ""
"當使用 ``Py_buffer`` 轉換器（或 ``'s*'``、``'w*'``、``'*y'`` 或 ``'z*'`` "
"遺留轉換器時)，您*不得*不在提供的緩衝區上呼叫 :c:func:`PyBuffer_Release`。 "
"Argument Clinic 生成的程式碼可以為您完成（在解析函式中）。"

#: ../../howto/clinic.rst:902
#, fuzzy
msgid "Advanced converters"
msgstr "高階轉換器"

#: ../../howto/clinic.rst:904
#, fuzzy
msgid ""
"Remember those format units you skipped for your first time because they "
"were advanced?  Here's how to handle those too."
msgstr "還記得那些因為高階而第一次跳過的格式單元嗎？這也是處理這些問題的方法。"

#: ../../howto/clinic.rst:907
#, fuzzy
msgid ""
"The trick is, all those format units take arguments—either conversion "
"functions, or types, or strings specifying an encoding. (But \"legacy "
"converters\" don't support arguments.  That's why we skipped them for your "
"first function.)  The argument you specified to the format unit is now an "
"argument to the converter; this argument is either ``converter`` (for "
"``O&``), ``subclass_of`` (for ``O!``), or ``encoding`` (for all the format "
"units that start with ``e``)."
msgstr ""
"訣竅在於，所有這些格式單元都採用參數——轉換函式、型別或指定編碼的字串。 （但是"
"“遺留轉換器”不支援參數。這就是我們在您的第一個函式中跳過它們的原因。）您指定"
"給格式單元的參數現在是轉換器的參數；這個參數是``converter``（對於``O&``），``"
"subclass_of``（對於``O!``），或者``encoding``（對於所有以``開頭的格式單元） "
"e``)."

#: ../../howto/clinic.rst:915
#, fuzzy
msgid ""
"When using ``subclass_of``, you may also want to use the other custom "
"argument for ``object()``: ``type``, which lets you set the type actually "
"used for the parameter.  For example, if you want to ensure that the object "
"is a subclass of ``PyUnicode_Type``, you probably want to use the converter "
"``object(type='PyUnicodeObject *', subclass_of='&PyUnicode_Type')``."
msgstr ""
"使用 ``subclass_of`` 時，您可能還想為 ``object()`` "
"使用另一個自定義參數：``type``，它允許您設定實際用於參數的型別。例如，"
"如果你想確保對像是 PyUnicode_Type 的子類別，你可能想使用轉換器 object("
"type='PyUnicodeObject *', subclass_of='&PyUnicode_Type')``。"

#: ../../howto/clinic.rst:921
#, fuzzy
msgid ""
"One possible problem with using Argument Clinic: it takes away some possible "
"flexibility for the format units starting with ``e``.  When writing a "
"``PyArg_Parse`` call by hand, you could theoretically decide at runtime what "
"encoding string to pass in to :c:func:`PyArg_ParseTuple`.   But now this "
"string must be hard-coded at Argument-Clinic-preprocessing-time.  This "
"limitation is deliberate; it made supporting this format unit much easier, "
"and may allow for future optimizations. This restriction doesn't seem "
"unreasonable; CPython itself always passes in static hard-coded encoding "
"strings for parameters whose format units start with ``e``."
msgstr ""
"使用 Argument Clinic "
"的一個可能問題是：它剝奪了以 ``e``開頭的格式單元的一些可能的靈活性。手動編寫 "
"``PyArg_Parse`` 呼叫時，理論上您可以在運行時決定將什麼編碼字串傳遞給 "
":c:func:`PyArg_ParseTuple`。但現在這個字串必須在 Argument-Clinic-"
"preprocessing-time 進行硬編碼。這種限制是有意的；它使支援此格式單元變得更加容"
"易，並且可能允許將來進行最佳化。這種限制似乎不無道理； CPython "
"本身總是為格式單元以 ``e``開頭的參數傳入靜態硬編碼編碼字串。"

#: ../../howto/clinic.rst:934
#, fuzzy
msgid "Parameter default values"
msgstr "參數預設值"

#: ../../howto/clinic.rst:936
#, fuzzy
msgid ""
"Default values for parameters can be any of a number of values. At their "
"simplest, they can be string, int, or float literals:"
msgstr "參數的預設值可以是許多值中的任何一個。在最簡單的情況下，它們可以是字串、整數"
"或浮點文字："

#: ../../howto/clinic.rst:945
#, fuzzy
msgid "They can also use any of Python's built-in constants:"
msgstr "它們還可以使用任何 Python 的內建常數："

#: ../../howto/clinic.rst:953
#, fuzzy
msgid ""
"There's also special support for a default value of ``NULL``, and for simple "
"expressions, documented in the following sections."
msgstr "還有對預設值 NULL 和簡單表達式的特殊支援，在以下部分中記錄。"

#: ../../howto/clinic.rst:958
#, fuzzy
msgid "The ``NULL`` default value"
msgstr "``NULL`` 預設值"

#: ../../howto/clinic.rst:960
#, fuzzy
msgid ""
"For string and object parameters, you can set them to ``None`` to indicate "
"that there's no default.  However, that means the C variable will be "
"initialized to ``Py_None``.  For convenience's sakes, there's a special "
"value called ``NULL`` for just this reason: from Python's perspective it "
"behaves like a default value of ``None``, but the C variable is initialized "
"with ``NULL``."
msgstr ""
"對於字串和物件參數，您可以將它們設定為 ``None`` 以指示沒有預設值。然而，這意味著 C "
"變數將被初始化為“Py_None”。為方便起見，有一個名為 ``NULL`` 的特殊值，正是出於這個"
"原因：從 Python 的角度來看，它的行為類似於預設值 ``None``，但 C "
"變數是用 ``NULL`` 初始化的。"

#: ../../howto/clinic.rst:968
#, fuzzy
msgid "Expressions specified as default values"
msgstr "指定為預設值的表達式"

#: ../../howto/clinic.rst:970
#, fuzzy
msgid ""
"The default value for a parameter can be more than just a literal value. It "
"can be an entire expression, using math operators and looking up attributes "
"on objects.  However, this support isn't exactly simple, because of some non-"
"obvious semantics."
msgstr "參數的預設值可以不僅僅是文字值。它可以是一個完整的表達式，使用數學運算符並查"
"找物件的屬性。然而，由於一些不明顯的語義，這種支援並不十分簡單。"

#: ../../howto/clinic.rst:975
#, fuzzy
msgid "Consider the following example:"
msgstr "考慮以下示例："

#: ../../howto/clinic.rst:981
#, fuzzy
msgid ""
"``sys.maxsize`` can have different values on different platforms.  Therefore "
"Argument Clinic can't simply evaluate that expression locally and hard-code "
"it in C.  So it stores the default in such a way that it will get evaluated "
"at runtime, when the user asks for the function's signature."
msgstr ""
"``sys.maxsize`` 在不同的平台上可以有不同的值。因此，Argument Clinic "
"不能簡單地在本地評估該表達式並在 C 中對其進行硬編碼。因此，它以這樣一種方式存"
"儲預設值，即當使用者要求函式簽名時，它會在運行時進行評估。"

#: ../../howto/clinic.rst:986
#, fuzzy
msgid ""
"What namespace is available when the expression is evaluated?  It's "
"evaluated in the context of the module the builtin came from.  So, if your "
"module has an attribute called \"``max_widgets``\", you may simply use it:"
msgstr ""
"計算表達式時什麼命名空間可用？它是在內建模組來自的模組的上下文中進行評估的。"
"所以，如果你的模組有一個名為“``max_widgets``”的屬性，您可以簡單地使用它："

#: ../../howto/clinic.rst:994
#, fuzzy
msgid ""
"If the symbol isn't found in the current module, it fails over to looking in "
"``sys.modules``.  That's how it can find ``sys.maxsize`` for example.  "
"(Since you don't know in advance what modules the user will load into their "
"interpreter, it's best to restrict yourself to modules that are preloaded by "
"Python itself.)"
msgstr ""
"如果在當前模組中找不到該符號，它會失敗並轉到“sys.modules”中查找。"
"這就是它如何找到 ``sys.maxsize`` 的例子。 "
"（因為事先不知道使用者將加載哪些模組到他們的直譯器中，所以最好將自己限制在 "
"Python 本身預加載的模組中。）"

#: ../../howto/clinic.rst:999
#, fuzzy
msgid ""
"Evaluating default values only at runtime means Argument Clinic can't "
"compute the correct equivalent C default value.  So you need to tell it "
"explicitly. When you use an expression, you must also specify the equivalent "
"expression in C, using the ``c_default`` parameter to the converter:"
msgstr ""
"僅在運行時評估預設值意味著 Argument Clinic 無法計算正確的等效 C "
"預設值。所以你需要明確地告訴它。使用表達式時，還必須使用轉換器的“c_default”"
"參數指定 C 中的等效表達式："

#: ../../howto/clinic.rst:1008
#, fuzzy
msgid ""
"Another complication: Argument Clinic can't know in advance whether or not "
"the expression you supply is valid.  It parses it to make sure it looks "
"legal, but it can't *actually* know.  You must be very careful when using "
"expressions to specify values that are guaranteed to be valid at runtime!"
msgstr ""
"另一個並發症：Argument Clinic 無法提前知道您提供的表達是否有效。它解析它以確"
"保它看起來合法，但它不能*實際上*知道。在使用表達式指定保證在運行時有效的值時"
"，您必須非常小心！"

#: ../../howto/clinic.rst:1013
#, fuzzy
msgid ""
"Finally, because expressions must be representable as static C values, there "
"are many restrictions on legal expressions.  Here's a list of Python "
"features you're not permitted to use:"
msgstr "最後，因為表達式必須表示為靜態 C 值，所以對合法表達式有很多限制。"
"以下是您不允許使用的 Python 功能列表："

#: ../../howto/clinic.rst:1017
#, fuzzy
msgid "Function calls."
msgstr "函式呼叫。"

#: ../../howto/clinic.rst:1018
#, fuzzy
msgid "Inline if statements (``3 if foo else 5``)."
msgstr "內聯 if 語句（``3 if foo else 5``）。"

#: ../../howto/clinic.rst:1019
#, fuzzy
msgid "Automatic sequence unpacking (``*[1, 2, 3]``)."
msgstr "自動序列解包（``*[1, 2, 3]``）。"

#: ../../howto/clinic.rst:1020
#, fuzzy
msgid "List/set/dict comprehensions and generator expressions."
msgstr "列表/集合/字典理解和生成器表達式。"

#: ../../howto/clinic.rst:1021
#, fuzzy
msgid "Tuple/list/set/dict literals."
msgstr "元組/列表/集合/字典文字。"

#: ../../howto/clinic.rst:1026
#, fuzzy
msgid "Using a return converter"
msgstr "使用回傳轉換器"

#: ../../howto/clinic.rst:1028
#, fuzzy
msgid ""
"By default the impl function Argument Clinic generates for you returns "
"``PyObject *``. But your C function often computes some C type, then "
"converts it into the ``PyObject *`` at the last moment.  Argument Clinic "
"handles converting your inputs from Python types into native C types—why not "
"have it convert your return value from a native C type into a Python type "
"too?"
msgstr ""
"預設情況下，Argument Clinic 為您生成的 impl 函式回傳“PyObject *”。但是您的 C "
"函式通常會計算一些 C 型別，然後在最後一刻將其轉換為“PyObject *”。 Argument "
"Clinic 負責將您的輸入從 Python 型別轉換為本機 C 型別——"
"為什麼不讓它也將您的回傳值從本機 C 型別轉換為 Python 型別呢？"

#: ../../howto/clinic.rst:1034
#, fuzzy
msgid ""
"That's what a \"return converter\" does.  It changes your impl function to "
"return some C type, then adds code to the generated (non-impl) function to "
"handle converting that value into the appropriate ``PyObject *``."
msgstr ""
"這就是“回傳轉換器”的作用。它更改您的 impl 函式以回傳一些 C "
"型別，然後將程式碼新增到生成的（非 impl）函式以處理將該值轉換為適當的“"
"PyObject *”。"

#: ../../howto/clinic.rst:1038
#, fuzzy
msgid ""
"The syntax for return converters is similar to that of parameter converters. "
"You specify the return converter like it was a return annotation on the "
"function itself.  Return converters behave much the same as parameter "
"converters; they take arguments, the arguments are all keyword-only, and if "
"you're not changing any of the default arguments you can omit the "
"parentheses."
msgstr ""
"回傳轉換器的語法類似於參數轉換器的語法。您指定回傳轉換器，就像它是函式本身的"
"回傳註釋一樣。回傳轉換器的行為與參數轉換器非常相似；他們接受參數，參數都是關"
"鍵字，如果你不改變任何預設參數，你可以省略括號。"

#: ../../howto/clinic.rst:1044
#, fuzzy
msgid ""
"(If you use both ``\"as\"`` *and* a return converter for your function, the "
"``\"as\"`` should come before the return converter.)"
msgstr "（如果你同時使用 ``\"as\"`` *和* 函式的回傳轉換器，則 ``\"as\"`` "
"應該在回傳轉換器之前。）"

#: ../../howto/clinic.rst:1047
#, fuzzy
msgid ""
"There's one additional complication when using return converters: how do you "
"indicate an error has occurred?  Normally, a function returns a valid (non-"
"``NULL``) pointer for success, and ``NULL`` for failure.  But if you use an "
"integer return converter, all integers are valid.  How can Argument Clinic "
"detect an error?  Its solution: each return converter implicitly looks for a "
"special value that indicates an error.  If you return that value, and an "
"error has been set (``PyErr_Occurred()`` returns a true value), then the "
"generated code will propagate the error.  Otherwise it will encode the value "
"you return like normal."
msgstr ""
"使用回傳轉換器時還有一個額外的複雜問題：如何指示發生了錯誤？通常，函式回傳一"
"個有效的（非 ``NULL`` ）指標表示成功， ``NULL`` 表示失敗。但是如果你使用一個整數回傳"
"轉換器，所有的整數都是有效的。 Argument Clinic 如何檢測錯誤？它的解決方案：每"
"個回傳轉換器隱式地尋找一個指示錯誤的特殊值。如果您回傳該值，並且已設定錯誤（`"
"`PyErr_Occurred()`` 回傳真值），則生成的程式碼將傳播錯誤。否則它會像平常一樣"
"對您回傳的值進行編碼。"

#: ../../howto/clinic.rst:1056
#, fuzzy
msgid "Currently Argument Clinic supports only a few return converters:"
msgstr "目前 Argument Clinic 僅支援少數回傳轉換器："

#: ../../howto/clinic.rst:1071
#, fuzzy
msgid ""
"None of these take parameters.  For the first three, return -1 to indicate "
"error.  For ``DecodeFSDefault``, the return type is ``const char *``; return "
"a ``NULL`` pointer to indicate an error."
msgstr ""
"這些都不帶參數。對於前三個，回傳 -1 "
"表示錯誤。對於 ``DecodeFSDefault`` ，回傳型別為“const char *”；回傳一個 ``NULL`` "
"指標以指示錯誤。"

#: ../../howto/clinic.rst:1075
#, fuzzy
msgid ""
"(There's also an experimental ``NoneType`` converter, which lets you return "
"``Py_None`` on success or ``NULL`` on failure, without having to increment "
"the reference count on ``Py_None``.  I'm not sure it adds enough clarity to "
"be worth using.)"
msgstr ""
"（還有一個實驗性的 ``NoneType`` 轉換器，它允許您在成功時回傳“Py_None”或在失敗時回"
"傳 ``NULL`` ，而不必增加“Py_None”上的引用計數。我不是確保它增加了足夠的清晰度以值"
"得使用。）"

#: ../../howto/clinic.rst:1080
#, fuzzy
msgid ""
"To see all the return converters Argument Clinic supports, along with their "
"parameters (if any), just run ``Tools/clinic/clinic.py --converters`` for "
"the full list."
msgstr ""
"要查看 Argument Clinic 支援的所有回傳轉換器及其參數（如果有），只需運行“"
"Tools/clinic/clinic.py --converters”以獲得完整列表。"

#: ../../howto/clinic.rst:1086
#, fuzzy
msgid "Cloning existing functions"
msgstr "克隆現有功能"

#: ../../howto/clinic.rst:1088
#, fuzzy
msgid ""
"If you have a number of functions that look similar, you may be able to use "
"Clinic's \"clone\" feature.  When you clone an existing function, you reuse:"
msgstr "如果您有許多看起來相似的功能，則可以使用 Clinic "
"的“克隆”功能。克隆現有函式時，您可以重用："

#: ../../howto/clinic.rst:1092
#, fuzzy
msgid "its parameters, including"
msgstr "它的參數包括"

#: ../../howto/clinic.rst:1094
#, fuzzy
msgid "their names,"
msgstr "他們的名字，"

#: ../../howto/clinic.rst:1096
#, fuzzy
msgid "their converters, with all parameters,"
msgstr "他們的轉換器，具有所有參數，"

#: ../../howto/clinic.rst:1098
#, fuzzy
msgid "their default values,"
msgstr "他們的預設值，"

#: ../../howto/clinic.rst:1100
#, fuzzy
msgid "their per-parameter docstrings,"
msgstr "他們的每個參數文檔字串，"

#: ../../howto/clinic.rst:1102
#, fuzzy
msgid ""
"their *kind* (whether they're positional only, positional or keyword, or "
"keyword only), and"
msgstr "他們的*種類*（無論是位置、位置或關鍵字，還是關鍵字），以及"

#: ../../howto/clinic.rst:1105
#, fuzzy
msgid "its return converter."
msgstr "它的回傳轉換器。"

#: ../../howto/clinic.rst:1107
#, fuzzy
msgid ""
"The only thing not copied from the original function is its docstring; the "
"syntax allows you to specify a new docstring."
msgstr "唯一沒有從原始函式複製的是它的文檔字串；該語法允許您指定一個新的文檔字串。"

#: ../../howto/clinic.rst:1110
#, fuzzy
msgid "Here's the syntax for cloning a function::"
msgstr "這是克隆函式的語法："

#: ../../howto/clinic.rst:1118
#, fuzzy
msgid ""
"(The functions can be in different modules or classes.  I wrote ``module."
"class`` in the sample just to illustrate that you must use the full path to "
"*both* functions.)"
msgstr "（函式可以在不同的模組或類中。我在示例中寫了``module."
"class``只是為了說明您必須使用*兩個*函式的完整路徑。）"

#: ../../howto/clinic.rst:1122
#, fuzzy
msgid ""
"Sorry, there's no syntax for partially cloning a function, or cloning a "
"function then modifying it.  Cloning is an all-or nothing proposition."
msgstr "抱歉，沒有用於部分克隆函式或克隆函式然後修改它的語法。克隆是一個全有或全無的"
"命題。"

#: ../../howto/clinic.rst:1125
#, fuzzy
msgid ""
"Also, the function you are cloning from must have been previously defined in "
"the current file."
msgstr "此外，您從中克隆的函式必須先前已在當前文件中定義。"

#: ../../howto/clinic.rst:1129
#, fuzzy
msgid "Calling Python code"
msgstr "呼叫 Python 程式碼"

#: ../../howto/clinic.rst:1131
#, fuzzy
msgid ""
"The rest of the advanced topics require you to write Python code which lives "
"inside your C file and modifies Argument Clinic's runtime state.  This is "
"simple: you simply define a Python block."
msgstr ""
"其餘高階主題要求您編寫 Python 程式碼，該程式碼位於您的 C 文件中並修改 "
"Argument Clinic 的運行時狀態。這很簡單：您只需定義一個 Python 塊。"

#: ../../howto/clinic.rst:1135
#, fuzzy
msgid ""
"A Python block uses different delimiter lines than an Argument Clinic "
"function block.  It looks like this::"
msgstr "Python 塊使用與 Argument Clinic 功能塊不同的分隔符行。它看起來像這樣::"

#: ../../howto/clinic.rst:1142
#, fuzzy
msgid ""
"All the code inside the Python block is executed at the time it's parsed.  "
"All text written to stdout inside the block is redirected into the \"output"
"\" after the block."
msgstr "Python 塊中的所有程式碼都在解析時執行。塊內寫入標準輸出的所有文本都被重定向到"
"塊後的“輸出”。"

#: ../../howto/clinic.rst:1146
#, fuzzy
msgid ""
"As an example, here's a Python block that adds a static integer variable to "
"the C code::"
msgstr "例如，這裡有一個 Python 塊，它向 C 程式碼新增了一個靜態整數變數："

#: ../../howto/clinic.rst:1157
#, fuzzy
msgid "Using a \"self converter\""
msgstr "使用“自轉換器”"

#: ../../howto/clinic.rst:1159
#, fuzzy
msgid ""
"Argument Clinic automatically adds a \"self\" parameter for you using a "
"default converter.  It automatically sets the ``type`` of this parameter to "
"the \"pointer to an instance\" you specified when you declared the type.  "
"However, you can override Argument Clinic's converter and specify one "
"yourself. Just add your own ``self`` parameter as the first parameter in a "
"block, and ensure that its converter is an instance of ``self_converter`` or "
"a subclass thereof."
msgstr ""
"Argument Clinic 使用預設轉換器自動為您新增一個 ``self``參數。它會自動將此參數的“"
"型別”設定為您在聲明型別時指定的“指向實例的指標”。但是，您可以覆蓋 Argument "
"Clinic 的轉換器並自己指定一個。只需新增您自己的 ``self`` "
"參數作為塊中的第一個參數，並確保其轉換器是 ``self_converter`` "
"或其子類別的實例。"

#: ../../howto/clinic.rst:1168
#, fuzzy
msgid ""
"What's the point?  This lets you override the type of ``self``, or give it a "
"different default name."
msgstr "重點是什麼？這讓你可以覆蓋 ``self`` 的型別，或者給它一個不同的預設名稱。"

#: ../../howto/clinic.rst:1171
#, fuzzy
msgid ""
"How do you specify the custom type you want to cast ``self`` to? If you only "
"have one or two functions with the same type for ``self``, you can directly "
"use Argument Clinic's existing ``self`` converter, passing in the type you "
"want to use as the ``type`` parameter::"
msgstr ""
"如何指定要將 ``self`` 轉換為的自定義型別？如果 ``self`` "
"只有一兩個相同型別的函式，您可以直接使用 Argument Clinic 現有的 ``self`` "
"轉換器，將您要使用的型別作為 ``type`` 參數傳入： :"

#: ../../howto/clinic.rst:1187
#, fuzzy
msgid ""
"On the other hand, if you have a lot of functions that will use the same "
"type for ``self``, it's best to create your own converter, subclassing "
"``self_converter`` but overwriting the ``type`` member::"
msgstr ""
"另一方面，如果你有很多函式將使用相同型別的 self，最好建立你自己的轉換器，"
"子類別化 self_converter 但覆蓋 type 成員::"

#: ../../howto/clinic.rst:1209
#, fuzzy
msgid "Using a \"defining class\" converter"
msgstr "使用“定義類”轉換器"

#: ../../howto/clinic.rst:1211
#, fuzzy
msgid ""
"Argument Clinic facilitates gaining access to the defining class of a "
"method. This is useful for :ref:`heap type <heap-types>` methods that need "
"to fetch module level state.  Use :c:func:`PyType_FromModuleAndSpec` to "
"associate a new heap type with a module.  You can now use :c:func:"
"`PyType_GetModuleState` on the defining class to fetch the module state, for "
"example from a module method."
msgstr ""
"Argument Clinic 有助於訪問方法的定義類。這對於需要獲取模組級狀態的 :ref:`"
"heap type <heap-types>` 方法很有用。使用 :c:func:`PyType_FromModuleAndSpec` "
"將新堆型別與模組相關聯。您現在可以在定義類上使用 "
":c:func:`PyType_GetModuleState` 來獲取模組狀態，例如從模組方法中獲取。"

#: ../../howto/clinic.rst:1217
#, fuzzy
msgid ""
"Example from ``Modules/zlibmodule.c``.  First, ``defining_class`` is added "
"to the clinic input::"
msgstr "來自``Modules/zlibmodule.c`` 的示例。首先，將``defining_class`` "
"新增到診所輸入::"

#: ../../howto/clinic.rst:1229
#, fuzzy
msgid ""
"After running the Argument Clinic tool, the following function signature is "
"generated::"
msgstr "運行 Argument Clinic 工具後，生成以下函式簽名："

#: ../../howto/clinic.rst:1239
#, fuzzy
msgid ""
"The following code can now use ``PyType_GetModuleState(cls)`` to fetch the "
"module state::"
msgstr "以下程式碼現在可以使用 PyType_GetModuleState(cls) 來獲取模組狀態："

#: ../../howto/clinic.rst:1245
#, fuzzy
msgid ""
"Each method may only have one argument using this converter, and it must "
"appear after ``self``, or, if ``self`` is not used, as the first argument.  "
"The argument will be of type ``PyTypeObject *``.  The argument will not "
"appear in the ``__text_signature__``."
msgstr ""
"每個方法只能有一個使用此轉換器的參數，並且它必須出現在 ``self``之後，或者，如果"
"未使用 ``self``，則作為第一個參數。參數將是“PyTypeObject *”型別。"
"該參數不會出現在 ``__text_signature__`` 中。"

#: ../../howto/clinic.rst:1250
#, fuzzy
msgid ""
"The ``defining_class`` converter is not compatible with ``__init__`` and "
"``__new__`` methods, which cannot use the ``METH_METHOD`` convention."
msgstr ""
"``defining_class`` 轉換器與``__init__`` 和``__new__`` "
"方法不相容，它們不能使用``METH_METHOD`` 約定。"

#: ../../howto/clinic.rst:1253
#, fuzzy
msgid ""
"It is not possible to use ``defining_class`` with slot methods.  In order to "
"fetch the module state from such methods, use :c:func:"
"`PyType_GetModuleByDef` to look up the module and then :c:func:"
"`PyModule_GetState` to fetch the module state.  Example from the "
"``setattro`` slot method in ``Modules/_threadmodule.c``::"
msgstr ""
"不能將 ``defining_class`` 與插槽方法一起使用。為了從這些方法中獲取模組狀態，"
"請使用:c:func:`PyType_GetModuleByDef` "
"查找模組，然後使用:c:func:`PyModule_GetState` 獲取模組狀態。 ``Modules/"
"_threadmodule.c`` 中的 ``setattro`` 插槽方法的示例："

#: ../../howto/clinic.rst:1268
msgid "See also :pep:`573`."
msgstr "也請見 :pep:`573`\\ 。"

#: ../../howto/clinic.rst:1272
#, fuzzy
msgid "Writing a custom converter"
msgstr "編寫自定義轉換器"

#: ../../howto/clinic.rst:1274
#, fuzzy
msgid ""
"As we hinted at in the previous section... you can write your own "
"converters! A converter is simply a Python class that inherits from "
"``CConverter``. The main purpose of a custom converter is if you have a "
"parameter using the ``O&`` format unit—parsing this parameter means calling "
"a :c:func:`PyArg_ParseTuple` \"converter function\"."
msgstr ""
"正如我們在上一節中暗示的那樣……您可以編寫自己的轉換器！轉換器只是一個繼承自“CC"
"onverter”的 Python 類。自定義轉換器的主要目的是，如果您有一個使用 ``O&`` "
"格式單元的參數——解析此參數意味著呼叫 PyArg_ParseTuple 的“轉換器函式”。"

#: ../../howto/clinic.rst:1280
#, fuzzy
msgid ""
"Your converter class should be named ``*something*_converter``. If the name "
"follows this convention, then your converter class will be automatically "
"registered with Argument Clinic; its name will be the name of your class "
"with the ``_converter`` suffix stripped off.  (This is accomplished with a "
"metaclass.)"
msgstr ""
"你的轉換器類應該命名為``*something*_converter``。如果名稱遵循此約定，"
"那麼您的轉換器類將自動註冊到 Argument Clinic；它的名字將是你的班級的名字，"
"去掉了 ``_converter`` 後綴。 （這是通過元類完成的。）"

#: ../../howto/clinic.rst:1286
#, fuzzy
msgid ""
"You shouldn't subclass ``CConverter.__init__``.  Instead, you should write a "
"``converter_init()`` function.  ``converter_init()`` always accepts a "
"``self`` parameter; after that, all additional parameters *must* be keyword-"
"only.  Any arguments passed in to the converter in Argument Clinic will be "
"passed along to your ``converter_init()``."
msgstr ""
"你不應該繼承``CConverter.__init__``。相反，您應該編寫一個 "
"``converter_init()`` 函式。 ``converter_init()`` 總是接受一個 ``self`` "
"參數；之後，所有附加參數*必須*是關鍵字。傳遞給 Argument Clinic "
"中轉換器的任何參數都將傳遞給您的 ``converter_init()``。"

#: ../../howto/clinic.rst:1293
#, fuzzy
msgid ""
"There are some additional members of ``CConverter`` you may wish to specify "
"in your subclass.  Here's the current list:"
msgstr "您可能希望在子類別中指定一些額外的 ``CConverter``成員。這是當前列表："

#: ../../howto/clinic.rst:1297
#, fuzzy
msgid ""
"The C type to use for this variable. ``type`` should be a Python string "
"specifying the type, e.g. ``int``. If this is a pointer type, the type "
"string should end with ``' *'``."
msgstr ""
"用於此變數的 C 型別。 ``type`` 應該是指定型別的 Python "
"字串，例如``int``。如果這是一個指標型別，型別字串應該以``' *'``結尾。"

#: ../../howto/clinic.rst:1303
msgid "``default``"
msgstr "``default``"

#: ../../howto/clinic.rst:1302
#, fuzzy
msgid ""
"The Python default value for this parameter, as a Python value. Or the magic "
"value ``unspecified`` if there is no default."
msgstr "此參數的 Python 預設值，作為 Python "
"值。或者如果沒有預設值，則為魔法值“未指定”。"

#: ../../howto/clinic.rst:1308
msgid "``py_default``"
msgstr "``py_default``"

#: ../../howto/clinic.rst:1306
#, fuzzy
msgid ""
"``default`` as it should appear in Python code, as a string. Or ``None`` if "
"there is no default."
msgstr "``default`` 應該作為字串出現在 Python 程式碼中。如果沒有預設值，則為 "
"``None``。"

#: ../../howto/clinic.rst:1311
#, fuzzy
msgid ""
"``default`` as it should appear in C code, as a string. Or ``None`` if there "
"is no default."
msgstr "``default`` 因為它應該出現在 C 程式碼中，作為一個字串。如果沒有預設值，則為 "
"``None``。"

#: ../../howto/clinic.rst:1324
msgid "``c_ignored_default``"
msgstr "``c_ignored_default``"

#: ../../howto/clinic.rst:1316
#, fuzzy
msgid ""
"The default value used to initialize the C variable when there is no "
"default, but not specifying a default may result in an \"uninitialized "
"variable\" warning.  This can easily happen when using option groups—"
"although properly written code will never actually use this value, the "
"variable does get passed in to the impl, and the C compiler will complain "
"about the \"use\" of the uninitialized value.  This value should always be a "
"non-empty string."
msgstr ""
"沒有預設值時用於初始化C變數的預設值，但不指定預設值可能會導致“未初始化的變數”"
"警告。這在使用選項組時很容易發生——雖然正確編寫的程式碼永遠不會實際使用這個值"
"，但變數確實被傳遞給了 impl，C "
"編譯器會抱怨“使用”了未初始化的值。該值應始終為非空字串。"

#: ../../howto/clinic.rst:1327
#, fuzzy
msgid "The name of the C converter function, as a string."
msgstr "C 轉換器函式的名稱，作為字串。"

#: ../../howto/clinic.rst:1332
msgid "``impl_by_reference``"
msgstr "``impl_by_reference``"

#: ../../howto/clinic.rst:1330
#, fuzzy
msgid ""
"A boolean value.  If true, Argument Clinic will add a ``&`` in front of the "
"name of the variable when passing it into the impl function."
msgstr "一個布爾值。如果為真，Argument Clinic 將在將變數傳遞給 impl "
"函式時在變數名稱前新增一個 ``&``。"

#: ../../howto/clinic.rst:1338
msgid "``parse_by_reference``"
msgstr "``parse_by_reference``"

#: ../../howto/clinic.rst:1335
#, fuzzy
msgid ""
"A boolean value.  If true, Argument Clinic will add a ``&`` in front of the "
"name of the variable when passing it into :c:func:`PyArg_ParseTuple`."
msgstr "一個布爾值。如果為真，Argument Clinic 將在將變數傳遞給 PyArg_ParseTuple "
"時在變數名稱前新增一個 ``&``。"

#: ../../howto/clinic.rst:1340
#, fuzzy
msgid ""
"Here's the simplest example of a custom converter, from ``Modules/zlibmodule."
"c``::"
msgstr "這是自定義轉換器的最簡單示例，來自 ``Modules/zlibmodule.c``::"

#: ../../howto/clinic.rst:1351
#, fuzzy
msgid ""
"This block adds a converter to Argument Clinic named ``ssize_t``.  "
"Parameters declared as ``ssize_t`` will be declared as type :c:type:"
"`Py_ssize_t`, and will be parsed by the ``'O&'`` format unit, which will "
"call the ``ssize_t_converter`` converter function.  ``ssize_t`` variables "
"automatically support default values."
msgstr ""
"此塊向名為“ssize_t”的 Argument Clinic 新增了一個轉換器。聲明為 ``ssize_t`` "
"的參數將被聲明為 :c:type:`Py_ssize_t` 型別，並將由 ``'O&'`` 格式單元解析，"
"這將呼叫 ``ssize_t_converter`` 轉換器函式。 ``ssize_t`` 變數自動支援預設值。"

#: ../../howto/clinic.rst:1357
#, fuzzy
msgid ""
"More sophisticated custom converters can insert custom C code to handle "
"initialization and cleanup. You can see more examples of custom converters "
"in the CPython source tree; grep the C files for the string ``CConverter``."
msgstr ""
"更複雜的自定義轉換器可以插入自定義 C 程式碼來處理初始化和清理。您可以在 "
"CPython 源程式碼樹中看到更多自定義轉換器的示例； grep 字串 ``CConverter``的 C "
"文件。"

#: ../../howto/clinic.rst:1363
#, fuzzy
msgid "Writing a custom return converter"
msgstr "編寫自定義回傳轉換器"

#: ../../howto/clinic.rst:1365
#, fuzzy
msgid ""
"Writing a custom return converter is much like writing a custom converter.  "
"Except it's somewhat simpler, because return converters are themselves much "
"simpler."
msgstr "編寫自定義回傳轉換器與編寫自定義轉換器非常相似。除了它更簡單一些，因為回傳轉"
"換器本身更簡單。"

#: ../../howto/clinic.rst:1369
#, fuzzy
msgid ""
"Return converters must subclass ``CReturnConverter``. There are no examples "
"yet of custom return converters, because they are not widely used yet.  If "
"you wish to write your own return converter, please read ``Tools/clinic/"
"clinic.py``, specifically the implementation of ``CReturnConverter`` and all "
"its subclasses."
msgstr ""
"回傳轉換器必須繼承 ``CReturnConverter`` 。目前還沒有自定義回傳轉換器的例子，因為"
"它們還沒有被廣泛使用。如果您想編寫自己的回傳轉換器，請閱讀 ``Tools/clinic/"
"clinic.py``，特別是``CReturnConverter`` 及其所有子類別的實作。"

#: ../../howto/clinic.rst:1377
#, fuzzy
msgid "METH_O and METH_NOARGS"
msgstr "METH_O 和 METH_NOARGS"

#: ../../howto/clinic.rst:1379
#, fuzzy
msgid ""
"To convert a function using ``METH_O``, make sure the function's single "
"argument is using the ``object`` converter, and mark the arguments as "
"positional-only::"
msgstr "要使用 ``METH_O`` 轉換函式，請確保函式的單個參數使用 ``object`` "
"轉換器，並將參數標記為僅位置："

#: ../../howto/clinic.rst:1391
#, fuzzy
msgid ""
"To convert a function using ``METH_NOARGS``, just don't specify any "
"arguments."
msgstr "要使用 METH_NOARGS 轉換函式，只需不指定任何參數即可。"

#: ../../howto/clinic.rst:1394
#, fuzzy
msgid ""
"You can still use a self converter, a return converter, and specify a "
"``type`` argument to the object converter for ``METH_O``."
msgstr "您仍然可以使用自轉換器、回傳轉換器，並為 METH_O 的物件轉換器指定一個 type "
"參數。"

#: ../../howto/clinic.rst:1398
#, fuzzy
msgid "tp_new and tp_init functions"
msgstr "tp_new 和 tp_init 函式"

#: ../../howto/clinic.rst:1400
#, fuzzy
msgid ""
"You can convert ``tp_new`` and ``tp_init`` functions.  Just name them "
"``__new__`` or ``__init__`` as appropriate.  Notes:"
msgstr ""
"您可以轉換 ``tp_new`` 和 ``tp_init`` 函式。只需將它們命名為 ``__new__`` 或 "
"``__init__`` 即可。筆記："

#: ../../howto/clinic.rst:1403
#, fuzzy
msgid ""
"The function name generated for ``__new__`` doesn't end in ``__new__`` like "
"it would by default.  It's just the name of the class, converted into a "
"valid C identifier."
msgstr "為 ``__new__`` 生成的函式名稱不像預設情況下那樣以 ``__new__`` "
"結尾。它只是類的名稱，已轉換為有效的 C 標識符。"

#: ../../howto/clinic.rst:1407
#, fuzzy
msgid "No ``PyMethodDef`` ``#define`` is generated for these functions."
msgstr "沒有為這些函式生成 ``PyMethodDef`` ``#define``。"

#: ../../howto/clinic.rst:1409
#, fuzzy
msgid "``__init__`` functions return ``int``, not ``PyObject *``."
msgstr "``__init__`` 函式回傳``int``，而不是``PyObject *``。"

#: ../../howto/clinic.rst:1411
#, fuzzy
msgid "Use the docstring as the class docstring."
msgstr "使用文檔字串作為類文檔字串。"

#: ../../howto/clinic.rst:1413
#, fuzzy
msgid ""
"Although ``__new__`` and ``__init__`` functions must always accept both the "
"``args`` and ``kwargs`` objects, when converting you may specify any "
"signature for these functions that you like. (If your function doesn't "
"support keywords, the parsing function generated will throw an exception if "
"it receives any.)"
msgstr ""
"儘管 ``__new__`` 和 ``__init__`` 函式必須始終接受 ``args`` 和 ``kwargs`` "
"物件，但在轉換時您可以為這些函式指定您喜歡的任何簽名。 "
"（如果您的函式不支援關鍵字，則生成的解析函式在接收到關鍵字時會拋出例外。）"

#: ../../howto/clinic.rst:1420
#, fuzzy
msgid "Changing and redirecting Clinic's output"
msgstr "更改和重定向 Clinic 的輸出"

#: ../../howto/clinic.rst:1422
#, fuzzy
msgid ""
"It can be inconvenient to have Clinic's output interspersed with your "
"conventional hand-edited C code.  Luckily, Clinic is configurable: you can "
"buffer up its output for printing later (or earlier!), or write its output "
"to a separate file.  You can also add a prefix or suffix to every line of "
"Clinic's generated output."
msgstr ""
"將 Clinic 的輸出與您傳統的手工編輯的 C "
"程式碼交織在一起可能會很不方便。幸運的是，Clinic 是可配置的：您可以緩衝其輸出"
"以便稍後（或更早！）印出，或將其輸出寫入單獨的文件。您還可以為 Clinic "
"生成的輸出的每一行新增前綴或後綴。"

#: ../../howto/clinic.rst:1428
#, fuzzy
msgid ""
"While changing Clinic's output in this manner can be a boon to readability, "
"it may result in Clinic code using types before they are defined, or your "
"code attempting to use Clinic-generated code before it is defined. These "
"problems can be easily solved by rearranging the declarations in your file, "
"or moving where Clinic's generated code goes.  (This is why the default "
"behavior of Clinic is to output everything into the current block; while "
"many people consider this hampers readability, it will never require "
"rearranging your code to fix definition-before-use problems.)"
msgstr ""
"雖然以這種方式更改 Clinic 的輸出可以提高可讀性，但它可能會導致 Clinic "
"程式碼在定義之前使用型別，或者您的程式碼在定義之前嘗試使用 Clinic "
"生成的程式碼。通過重新排列文件中的聲明或移動 Clinic "
"生成的程式碼所在的位置，可以輕鬆解決這些問題。 （這就是為什麼 Clinic 的預設行"
"為是將所有內容輸出到當前塊；雖然許多人認為這會妨礙可讀性，但它永遠不需要重新"
"安排程式碼來解決使用前定義問題。）"

#: ../../howto/clinic.rst:1437
#, fuzzy
msgid "Let's start with defining some terminology:"
msgstr "讓我們從定義一些術語開始："

#: ../../howto/clinic.rst:1464
#, fuzzy
msgid "*field*"
msgstr "*場地*"

#: ../../howto/clinic.rst:1440
#, fuzzy
msgid ""
"A field, in this context, is a subsection of Clinic's output. For example, "
"the ``#define`` for the ``PyMethodDef`` structure is a field, called "
"``methoddef_define``.  Clinic has seven different fields it can output per "
"function definition:"
msgstr ""
"在這種情況下，欄位是 Clinic 輸出的一部分。例如，``PyMethodDef`` "
"結構的``#define`` 是一個名為``methoddef_define`` 的欄位。 Clinic "
"有七個不同的欄位，它可以根據函式定義輸出："

#: ../../howto/clinic.rst:1455
#, fuzzy
msgid ""
"All the names are of the form ``\"<a>_<b>\"``, where ``\"<a>\"`` is the "
"semantic object represented (the parsing function, the impl function, the "
"docstring, or the methoddef structure) and ``\"<b>\"`` represents what kind "
"of statement the field is.  Field names that end in ``\"_prototype\"`` "
"represent forward declarations of that thing, without the actual body/data "
"of the thing; field names that end in ``\"_definition\"`` represent the "
"actual definition of the thing, with the body/data of the thing.  (``"
"\"methoddef\"`` is special, it's the only one that ends with ``\"_define"
"\"``, representing that it's a preprocessor #define.)"
msgstr ""
"所有名稱的形式都是``\"<a>_<b>\"``，其中``\"<a>\""
"``是表示的語義物件（解析函式、impl函式、文檔字串或methoddef 結構）和``\"<b>\""
"`` 表示欄位是什麼型別的語句。以 ``\"_prototype\"`` 結尾的欄位名稱表示該事物的"
"前向聲明，沒有該事物的實際主體/資料；以“_definition”結尾的欄位名稱代表事物的"
"實際定義，以及事物的主體/資料。 （``\"methoddef\"`` 比較特殊，它是唯一以``"
"\"_define\"`` 結尾的，代表它是一個預處理器#define。）"

#: ../../howto/clinic.rst:1498
#, fuzzy
msgid "*destination*"
msgstr "*目的地*"

#: ../../howto/clinic.rst:1467
#, fuzzy
msgid ""
"A destination is a place Clinic can write output to.  There are five built-"
"in destinations:"
msgstr "目的地是 Clinic 可以寫入輸出的地方。有五個內建目的地："

#: ../../howto/clinic.rst:1472 ../../howto/clinic.rst:1547
#: ../../howto/clinic.rst:1625
msgid "``block``"
msgstr "``block``"

#: ../../howto/clinic.rst:1471
#, fuzzy
msgid ""
"The default destination: printed in the output section of the current Clinic "
"block."
msgstr "預設目的地：印出在當前診所塊的輸出部分。"

#: ../../howto/clinic.rst:1478 ../../howto/clinic.rst:1574
#: ../../howto/clinic.rst:1628
msgid "``buffer``"
msgstr "``buffer``"

#: ../../howto/clinic.rst:1475
#, fuzzy
msgid ""
"A text buffer where you can save text for later.  Text sent here is appended "
"to the end of any existing text.  It's an error to have any text left in the "
"buffer when Clinic finishes processing a file."
msgstr ""
"一個文本緩衝區，您可以在其中保存文本供以後使用。此處發送的文本附加到任何現有"
"文本的末尾。當 Clinic 完成處理文件時，在緩衝區中留下任何文本是錯誤的。"

#: ../../howto/clinic.rst:1489 ../../howto/clinic.rst:1560
#: ../../howto/clinic.rst:1654
msgid "``file``"
msgstr "``file``"

#: ../../howto/clinic.rst:1481
#, fuzzy
msgid ""
"A separate \"clinic file\" that will be created automatically by Clinic. The "
"filename chosen for the file is ``{basename}.clinic{extension}``, where "
"``basename`` and ``extension`` were assigned the output from ``os.path."
"splitext()`` run on the current file.  (Example: the ``file`` destination "
"for ``_pickle.c`` would be written to ``_pickle.clinic.c``.)"
msgstr ""
"一個單獨的“診所文件”，將由診所自動建立。為文件選擇的文件名是``{basename}."
"clinic{extension}``，其中``basename``和``extension``被分配了``os.path."
"splitext（）``的輸出運行當前文件。 （例如：``_pickle.c`` 的``file`` "
"目的地將被寫入``_pickle.clinic.c``。）"

#: ../../howto/clinic.rst:1488
#, fuzzy
msgid ""
"**Important: When using a** ``file`` **destination, you** *must check in* "
"**the generated file!**"
msgstr "**重要：當使用**``文件``**目的地時，您** *必須簽入* **生成的文件！**"

#: ../../howto/clinic.rst:1494 ../../howto/clinic.rst:1587
#: ../../howto/clinic.rst:1658
msgid "``two-pass``"
msgstr "``two-pass``"

#: ../../howto/clinic.rst:1492
#, fuzzy
msgid ""
"A buffer like ``buffer``.  However, a two-pass buffer can only be dumped "
"once, and it prints out all text sent to it during all processing, even from "
"Clinic blocks *after* the dumping point."
msgstr ""
"像``buffer`` 這樣的緩衝區。然而，一個兩次通過的緩衝區只能被轉儲一次，它會印出"
"出所有處理過程中發送給它的所有文本，即使是來自轉儲點*之後*的 Clinic 塊。"

#: ../../howto/clinic.rst:1498 ../../howto/clinic.rst:1621
msgid "``suppress``"
msgstr "``suppress``"

#: ../../howto/clinic.rst:1497
#, fuzzy
msgid "The text is suppressed—thrown away."
msgstr "文本被壓制——被丟棄。"

#: ../../howto/clinic.rst:1500
#, fuzzy
msgid "Clinic defines five new directives that let you reconfigure its output."
msgstr "Clinic 定義了五個新指令，可讓您重新配置其輸出。"

#: ../../howto/clinic.rst:1502
#, fuzzy
msgid "The first new directive is ``dump``:"
msgstr "第一個新指令是“轉儲”："

#: ../../howto/clinic.rst:1508
#, fuzzy
msgid ""
"This dumps the current contents of the named destination into the output of "
"the current block, and empties it.  This only works with ``buffer`` and "
"``two-pass`` destinations."
msgstr "這會將指定目標的當前內容轉儲到當前塊的輸出中，並將其清空。這僅適用於 "
"``buffer`` 和 ``two-pass`` 目的地。"

#: ../../howto/clinic.rst:1512
#, fuzzy
msgid ""
"The second new directive is ``output``.  The most basic form of ``output`` "
"is like this:"
msgstr "第二個新指令是 ``output``。 ``output`` 的最基本形式是這樣的："

#: ../../howto/clinic.rst:1519
#, fuzzy
msgid ""
"This tells Clinic to output *field* to *destination*.  ``output`` also "
"supports a special meta-destination, called ``everything``, which tells "
"Clinic to output *all* fields to that *destination*."
msgstr ""
"這告訴 Clinic 將 *field* 輸出到 *destination*。 ``output`` "
"還支援一個特殊的元目標，稱為 ``everything``，它告訴 Clinic 將 *所有* "
"欄位輸出到該 *destination*。"

#: ../../howto/clinic.rst:1523
#, fuzzy
msgid "``output`` has a number of other functions:"
msgstr "``output`` 還有許多其他功能："

#: ../../howto/clinic.rst:1532
#, fuzzy
msgid ""
"``output push`` and ``output pop`` allow you to push and pop configurations "
"on an internal configuration stack, so that you can temporarily modify the "
"output configuration, then easily restore the previous configuration.  "
"Simply push before your change to save the current configuration, then pop "
"when you wish to restore the previous configuration."
msgstr ""
"``output push`` 和 ``output pop`` 允許您在內部配置堆疊上推送和彈出配置，以便"
"您可以臨時修改輸出配置，然後輕鬆恢復以前的配置。只需在更改前按下即可保存當前"
"配置，然後在您希望恢復之前的配置時彈出。"

#: ../../howto/clinic.rst:1539
#, fuzzy
msgid ""
"``output preset`` sets Clinic's output to one of several built-in preset "
"configurations, as follows:"
msgstr "``output preset`` 將 Clinic 的輸出設定為幾個內建預設配置之一，如下所示："

#: ../../howto/clinic.rst:1543
#, fuzzy
msgid ""
"Clinic's original starting configuration.  Writes everything immediately "
"after the input block."
msgstr "診所的原始啟動配置。在輸入塊之後立即寫入所有內容。"

#: ../../howto/clinic.rst:1546
#, fuzzy
msgid ""
"Suppress the ``parser_prototype`` and ``docstring_prototype``, write "
"everything else to ``block``."
msgstr "抑制``parser_prototype``和``docstring_prototype``，將其他所有內容寫入``block`"
"`。"

#: ../../howto/clinic.rst:1550
#, fuzzy
msgid ""
"Designed to write everything to the \"clinic file\" that it can. You then "
"``#include`` this file near the top of your file. You may need to rearrange "
"your file to make this work, though usually this just means creating forward "
"declarations for various ``typedef`` and ``PyTypeObject`` definitions."
msgstr ""
"旨在將所有內容寫入它可以寫入的“診所文件”。然後你在文件頂部附近``#include``這"
"個文件。您可能需要重新安排您的文件以使其工作，儘管通常這只是意味著為各種 "
"``typedef`` 和 ``PyTypeObject`` 定義建立前向聲明。"

#: ../../howto/clinic.rst:1556
#, fuzzy
msgid ""
"Suppress the ``parser_prototype`` and ``docstring_prototype``, write the "
"``impl_definition`` to ``block``, and write everything else to ``file``."
msgstr ""
"抑制``parser_prototype``和``docstring_prototype``，將``impl_definition``寫入`"
"`block``，並將其他所有內容寫入``file``。"

#: ../../howto/clinic.rst:1560
#, fuzzy
msgid "The default filename is ``\"{dirname}/clinic/{basename}.h\"``."
msgstr "預設文件名是``\"{dirname}/clinic/{basename}.h\"``。"

#: ../../howto/clinic.rst:1563
#, fuzzy
msgid ""
"Save up most of the output from Clinic, to be written into your file near "
"the end.  For Python files implementing modules or builtin types, it's "
"recommended that you dump the buffer just above the static structures for "
"your module or builtin type; these are normally very near the end.  Using "
"``buffer`` may require even more editing than ``file``, if your file has "
"static ``PyMethodDef`` arrays defined in the middle of the file."
msgstr ""
"保存 Clinic 的大部分輸出，以便在接近尾聲時寫入您的文件。"
"對於實作模組或內建型別的 Python 文件，建議您將緩衝區轉儲到模組或內建型別的靜"
"態結構之上；這些通常非常接近尾聲。如果您的文件在文件中間定義了靜態 "
"``PyMethodDef`` 數組，則使用 ``buffer`` 可能需要比 ``file`` 更多的編輯。"

#: ../../howto/clinic.rst:1572
#, fuzzy
msgid ""
"Suppress the ``parser_prototype``, ``impl_prototype``, and "
"``docstring_prototype``, write the ``impl_definition`` to ``block``, and "
"write everything else to ``file``."
msgstr ""
"抑制``parser_prototype``、``impl_prototype`` "
"和``docstring_prototype``，將``impl_definition`` "
"寫入``block``，並將其他所有內容寫入``file``。"

#: ../../howto/clinic.rst:1577
#, fuzzy
msgid ""
"Similar to the ``buffer`` preset, but writes forward declarations to the "
"``two-pass`` buffer, and definitions to the ``buffer``. This is similar to "
"the ``buffer`` preset, but may require less editing than ``buffer``.  Dump "
"the ``two-pass`` buffer near the top of your file, and dump the ``buffer`` "
"near the end just like you would when using the ``buffer`` preset."
msgstr ""
"類似於 ``buffer`` 預設，但將前向聲明寫入 ``two-pass`` 緩衝區，並將定義寫入 "
"``buffer``。這類似於 ``buffer`` 預設，但可能需要比 ``buffer`` 更少的編輯。"
"轉儲文件頂部附近的 ``two-pass`` 緩衝區，並轉儲靠近末尾的 ``buffer`` 就像使用 "
"``buffer`` 預設時一樣。"

#: ../../howto/clinic.rst:1584
#, fuzzy
msgid ""
"Suppresses the ``impl_prototype``, write the ``impl_definition`` to "
"``block``, write ``docstring_prototype``, ``methoddef_define``, and "
"``parser_prototype`` to ``two-pass``, write everything else to ``buffer``."
msgstr ""
"抑制``impl_prototype``，將``impl_definition``寫入``block``，將``docstring_pro"
"totype``，``methoddef_define``和``parser_prototype``寫入``two-"
"pass``，將其他所有內容寫入“緩衝區”。"

#: ../../howto/clinic.rst:1598
msgid "``partial-buffer``"
msgstr "``partial-buffer``"

#: ../../howto/clinic.rst:1590
#, fuzzy
msgid ""
"Similar to the ``buffer`` preset, but writes more things to ``block``, only "
"writing the really big chunks of generated code to ``buffer``. This avoids "
"the definition-before-use problem of ``buffer`` completely, at the small "
"cost of having slightly more stuff in the block's output. Dump the "
"``buffer`` near the end, just like you would when using the ``buffer`` "
"preset."
msgstr ""
"類似於 ``buffer`` 預設，但將更多內容寫入 ``block``，"
"僅將真正大塊的生成程式碼寫入 ``buffer``。這完全避免了 ``buffer`` "
"的使用前定義問題，代價是在塊的輸出中有更多的東西。在末尾附近轉儲 ``buffer``，"
"就像使用 ``buffer`` 預設時一樣。"

#: ../../howto/clinic.rst:1597
#, fuzzy
msgid ""
"Suppresses the ``impl_prototype``, write the ``docstring_definition`` and "
"``parser_definition`` to ``buffer``, write everything else to ``block``."
msgstr ""
"抑制``impl_prototype``，將``docstring_definition``和``parser_definition``寫入"
"``buffer``，將其他所有內容寫入``block``。"

#: ../../howto/clinic.rst:1600
#, fuzzy
msgid "The third new directive is ``destination``:"
msgstr "第三個新指令是“目的地”："

#: ../../howto/clinic.rst:1606
#, fuzzy
msgid "This performs an operation on the destination named ``name``."
msgstr "這對名為 ``name``的目的地執行操作。"

#: ../../howto/clinic.rst:1608
#, fuzzy
msgid "There are two defined subcommands: ``new`` and ``clear``."
msgstr "有兩個定義的子命令：``new`` 和``clear``。"

#: ../../howto/clinic.rst:1610
#, fuzzy
msgid "The ``new`` subcommand works like this:"
msgstr "``new`` 子命令的工作方式如下："

#: ../../howto/clinic.rst:1616
#, fuzzy
msgid ""
"This creates a new destination with name ``<name>`` and type ``<type>``."
msgstr "這將建立一個名為“<name>”且型別為“<type>”的新目的地。"

#: ../../howto/clinic.rst:1618
#, fuzzy
msgid "There are five destination types:"
msgstr "有五種目的地型別："

#: ../../howto/clinic.rst:1621
#, fuzzy
msgid "Throws the text away."
msgstr "扔掉文本。"

#: ../../howto/clinic.rst:1624
#, fuzzy
msgid ""
"Writes the text to the current block.  This is what Clinic originally did."
msgstr "將文本寫入當前塊。這就是 Clinic 最初所做的。"

#: ../../howto/clinic.rst:1628
#, fuzzy
msgid "A simple text buffer, like the \"buffer\" builtin destination above."
msgstr "一個簡單的文本緩衝區，如上面的“緩衝區”內建目標。"

#: ../../howto/clinic.rst:1631
#, fuzzy
msgid ""
"A text file.  The file destination takes an extra argument, a template to "
"use for building the filename, like so:"
msgstr "一個文本文件。文件目標有一個額外的參數，一個用於構建文件名的模板，如下所示："

#: ../../howto/clinic.rst:1634
#, fuzzy
msgid "destination <name> new <type> <file_template>"
msgstr "目的地 <名稱> 新 <型別> <文件模板>"

#: ../../howto/clinic.rst:1636
#, fuzzy
msgid ""
"The template can use three strings internally that will be replaced by bits "
"of the filename:"
msgstr "該模板可以在內部使用三個字串，這些字串將被文件名的位替換："

#: ../../howto/clinic.rst:1639
#, fuzzy
msgid "{path}"
msgstr "{小路}"

#: ../../howto/clinic.rst:1640
#, fuzzy
msgid "The full path to the file, including directory and full filename."
msgstr "文件的完整路徑，包括目錄和完整文件名。"

#: ../../howto/clinic.rst:1641
#, fuzzy
msgid "{dirname}"
msgstr "{目錄名}"

#: ../../howto/clinic.rst:1642
#, fuzzy
msgid "The name of the directory the file is in."
msgstr "文件所在目錄的名稱。"

#: ../../howto/clinic.rst:1643
#, fuzzy
msgid "{basename}"
msgstr "{basename}"

#: ../../howto/clinic.rst:1644
#, fuzzy
msgid "Just the name of the file, not including the directory."
msgstr "只是文件名，不包括目錄。"

#: ../../howto/clinic.rst:1646
#, fuzzy
msgid "{basename_root}"
msgstr "{basename_root}"

#: ../../howto/clinic.rst:1646
#, fuzzy
msgid ""
"Basename with the extension clipped off (everything up to but not including "
"the last '.')."
msgstr "刪除了擴充名的基本名稱（所有內容直到但不包括最後一個 ``.``）。"

#: ../../howto/clinic.rst:1650
#, fuzzy
msgid "{basename_extension}"
msgstr "{basename_extension}"

#: ../../howto/clinic.rst:1649
#, fuzzy
msgid ""
"The last '.' and everything after it.  If the basename does not contain a "
"period, this will be the empty string."
msgstr "最後 '。'以及之後的一切。如果基本名稱不包含句點，則這將是空字串。"

#: ../../howto/clinic.rst:1652
#, fuzzy
msgid ""
"If there are no periods in the filename, {basename} and {filename} are the "
"same, and {extension} is empty.  \"{basename}{extension}\" is always exactly "
"the same as \"{filename}\".\""
msgstr ""
"如果文件名中沒有句點，則 {basename} 和 {filename} 相同，並且 {extension} "
"為空。 “{basename}{extension}”始終與“{filename}”完全相同。”"

#: ../../howto/clinic.rst:1657
#, fuzzy
msgid "A two-pass buffer, like the \"two-pass\" builtin destination above."
msgstr "兩次通過緩衝區，如上面的“兩次通過”內建目標。"

#: ../../howto/clinic.rst:1660
#, fuzzy
msgid "The ``clear`` subcommand works like this:"
msgstr "``clear`` 子命令的工作方式如下："

#: ../../howto/clinic.rst:1666
#, fuzzy
msgid ""
"It removes all the accumulated text up to this point in the destination. (I "
"don't know what you'd need this for, but I thought maybe it'd be useful "
"while someone's experimenting.)"
msgstr "它會刪除目標中到目前為止累積的所有文本。 "
"（我不知道你需要這個做什麼，但我認為它在某人進行實驗時可能會有用。）"

#: ../../howto/clinic.rst:1670
#, fuzzy
msgid "The fourth new directive is ``set``:"
msgstr "第四個新指令是 ``set``："

#: ../../howto/clinic.rst:1677
#, fuzzy
msgid ""
"``set`` lets you set two internal variables in Clinic. ``line_prefix`` is a "
"string that will be prepended to every line of Clinic's output; "
"``line_suffix`` is a string that will be appended to every line of Clinic's "
"output."
msgstr ""
"``set`` 允許您在 Clinic 中設定兩個內部變數。 ``line_prefix`` 是一個字串，"
"它將被新增到 Clinic 輸出的每一行之前； ``line_suffix`` 是一個字串，將附加到 "
"Clinic 輸出的每一行。"

#: ../../howto/clinic.rst:1681
#, fuzzy
msgid "Both of these support two format strings:"
msgstr "這兩個都支援兩種格式字串："

#: ../../howto/clinic.rst:1684
msgid "``{block comment start}``"
msgstr "``{block comment start}``"

#: ../../howto/clinic.rst:1684
#, fuzzy
msgid ""
"Turns into the string ``/*``, the start-comment text sequence for C files."
msgstr "變成字串 ``/*``，C 文件的開始註釋文本序列。"

#: ../../howto/clinic.rst:1687
msgid "``{block comment end}``"
msgstr "``{block comment end}``"

#: ../../howto/clinic.rst:1687
#, fuzzy
msgid ""
"Turns into the string ``*/``, the end-comment text sequence for C files."
msgstr "變成字串 ``*/``，C 文件的結束註釋文本序列。"

#: ../../howto/clinic.rst:1689
#, fuzzy
msgid ""
"The final new directive is one you shouldn't need to use directly, called "
"``preserve``:"
msgstr "最後一個新指令是一個你不需要直接使用的指令，叫做 ``preserve``："

#: ../../howto/clinic.rst:1696
#, fuzzy
msgid ""
"This tells Clinic that the current contents of the output should be kept, "
"unmodified. This is used internally by Clinic when dumping output into "
"``file`` files; wrapping it in a Clinic block lets Clinic use its existing "
"checksum functionality to ensure the file was not modified by hand before it "
"gets overwritten."
msgstr ""
"這告訴 Clinic 輸出的當前內容應該保持不變。 Clinic 在將輸出轉儲到 ``file`` "
"文件時在內部使用它；將它包裝在一個 Clinic 塊中，讓 Clinic "
"使用其現有的校驗和功能來確保文件在被覆蓋之前沒有被手動修改。"

#: ../../howto/clinic.rst:1703
#, fuzzy
msgid "The #ifdef trick"
msgstr "#ifdef 技巧"

#: ../../howto/clinic.rst:1705
#, fuzzy
msgid ""
"If you're converting a function that isn't available on all platforms, "
"there's a trick you can use to make life a little easier.  The existing code "
"probably looks like this::"
msgstr "如果您要轉換並非在所有平台上都可用的功能，可以使用一個技巧讓生活變得更輕鬆。"
"現有程式碼可能如下所示："

#: ../../howto/clinic.rst:1716
#, fuzzy
msgid ""
"And then in the ``PyMethodDef`` structure at the bottom the existing code "
"will have:"
msgstr "然後在底部的 ``PyMethodDef`` 結構中，現有程式碼將具有："

#: ../../howto/clinic.rst:1725
#, fuzzy
msgid ""
"In this scenario, you should enclose the body of your impl function inside "
"the ``#ifdef``, like so::"
msgstr "在這種情況下，您應該將 impl 函式的主體包含在 ``#ifdef`` 中，如下所示："

#: ../../howto/clinic.rst:1739
#, fuzzy
msgid ""
"Then, remove those three lines from the ``PyMethodDef`` structure, replacing "
"them with the macro Argument Clinic generated:"
msgstr "然後，從 ``PyMethodDef`` 結構中刪除這三行，用生成的巨集 Argument Clinic "
"替換它們："

#: ../../howto/clinic.rst:1746
#, fuzzy
msgid ""
"(You can find the real name for this macro inside the generated code. Or you "
"can calculate it yourself: it's the name of your function as defined on the "
"first line of your block, but with periods changed to underscores, "
"uppercased, and ``\"_METHODDEF\"`` added to the end.)"
msgstr ""
"（你可以在生成的程式碼中找到這個巨集的真實名稱。或者你可以自己計算它：它是你"
"的塊第一行定義的函式的名稱，但句點改為底線，大寫和`` “_METHODDEF”`` "
"新增到末尾。）"

#: ../../howto/clinic.rst:1751
#, fuzzy
msgid ""
"Perhaps you're wondering: what if ``HAVE_FUNCTIONNAME`` isn't defined? The "
"``MODULE_FUNCTIONNAME_METHODDEF`` macro won't be defined either!"
msgstr ""
"也許您想知道：如果沒有定義 ``HAVE_FUNCTIONNAME`` 怎麼辦？ "
"``MODULE_FUNCTIONNAME_METHODDEF`` 巨集也不會被定義！"

#: ../../howto/clinic.rst:1754
#, fuzzy
msgid ""
"Here's where Argument Clinic gets very clever.  It actually detects that the "
"Argument Clinic block might be deactivated by the ``#ifdef``.  When that "
"happens, it generates a little extra code that looks like this::"
msgstr ""
"這就是 Argument Clinic 變得非常聰明的地方。它實際上檢測到 Argument Clinic "
"塊可能被 ``#ifdef`` "
"停用。發生這種情況時，它會生成一些額外的程式碼，如下所示："

#: ../../howto/clinic.rst:1762
#, fuzzy
msgid ""
"That means the macro always works.  If the function is defined, this turns "
"into the correct structure, including the trailing comma.  If the function "
"is undefined, this turns into nothing."
msgstr "這意味著巨集始終有效。如果定義了函式，這將變成正確的結構，包括結尾的逗號。如"
"果函式未定義，則這將變為空。"

#: ../../howto/clinic.rst:1766
#, fuzzy
msgid ""
"However, this causes one ticklish problem: where should Argument Clinic put "
"this extra code when using the \"block\" output preset?  It can't go in the "
"output block, because that could be deactivated by the ``#ifdef``.  (That's "
"the whole point!)"
msgstr ""
"然而，這會導致一個棘手的問題：當使用「塊」輸出預設時，Argument Clinic "
"應該把這個額外的程式碼放在哪裡？它不能進入輸出塊，因為它可以被 ``#ifdef`` "
"停用。 （這就是重點！）"

#: ../../howto/clinic.rst:1770
#, fuzzy
msgid ""
"In this situation, Argument Clinic writes the extra code to the \"buffer\" "
"destination. This may mean that you get a complaint from Argument Clinic:"
msgstr ""
"在這種情況下，Argument Clinic 將額外程式碼寫入“緩衝區”目的地。"
"這可能意味著您會收到來自 Argument Clinic 的投訴："

#: ../../howto/clinic.rst:1778
#, fuzzy
msgid ""
"When this happens, just open your file, find the ``dump buffer`` block that "
"Argument Clinic added to your file (it'll be at the very bottom), then move "
"it above the ``PyMethodDef`` structure where that macro is used."
msgstr ""
"發生這種情況時，只需打開您的文件，找到 Argument Clinic 新增到您文件中的“轉儲"
"緩衝區”塊（它將在最底部），然後將其移動到該巨集所在的 ``PyMethodDef`` 結構上方用"
"來。"

#: ../../howto/clinic.rst:1785
#, fuzzy
msgid "Using Argument Clinic in Python files"
msgstr "在 Python 文件中使用 Argument Clinic"

#: ../../howto/clinic.rst:1787
#, fuzzy
msgid ""
"It's actually possible to use Argument Clinic to preprocess Python files. "
"There's no point to using Argument Clinic blocks, of course, as the output "
"wouldn't make any sense to the Python interpreter.  But using Argument "
"Clinic to run Python blocks lets you use Python as a Python preprocessor!"
msgstr ""
"實際上可以使用 Argument Clinic 來預處理 Python 文件。當然，使用 Argument "
"Clinic 塊沒有意義，因為輸出對 Python 直譯器沒有任何意義。但是使用 Argument "
"Clinic 運行 Python 塊可以讓您將 Python 用作 Python 預處理器！"

#: ../../howto/clinic.rst:1792
#, fuzzy
msgid ""
"Since Python comments are different from C comments, Argument Clinic blocks "
"embedded in Python files look slightly different.  They look like this:"
msgstr "由於 Python 註釋與 C 註釋不同，Python 文件中嵌入的 Argument Clinic "
"塊看起來略有不同。它們看起來像這樣："
