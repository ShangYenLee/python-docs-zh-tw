# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-31 08:13+0000\n"
"PO-Revision-Date: 2018-05-23 16:17+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/import.rst:6
#, fuzzy
msgid "The import system"
msgstr "匯入系統"

#: ../../reference/import.rst:10
#, fuzzy
msgid ""
"Python code in one :term:`module` gains access to the code in another module "
"by the process of :term:`importing` it.  The :keyword:`import` statement is "
"the most common way of invoking the import machinery, but it is not the only "
"way.  Functions such as :func:`importlib.import_module` and built-in :func:"
"`__import__` can also be used to invoke the import machinery."
msgstr ""
"一個 :term:`module` 中的 Python 程式碼通過 :term:`importing` "
"過程獲得對另一個模組中程式碼的訪問權限。 :keyword:`import` "
"語句是呼叫匯入機制的最常見方式，但它不是唯一的方式。 :func:`importlib."
"import_module` 和內建 :func:`__import__` 等函式也可用於呼叫匯入機制。"

#: ../../reference/import.rst:16
#, fuzzy
msgid ""
"The :keyword:`import` statement combines two operations; it searches for the "
"named module, then it binds the results of that search to a name in the "
"local scope.  The search operation of the :keyword:`!import` statement is "
"defined as a call to the :func:`__import__` function, with the appropriate "
"arguments. The return value of :func:`__import__` is used to perform the "
"name binding operation of the :keyword:`!import` statement.  See the :"
"keyword:`!import` statement for the exact details of that name binding "
"operation."
msgstr ""
":keyword:`import` "
"語句結合了兩個操作；它搜索命名模組，然後將搜索結果綁定到本地範圍內的名稱。 "
":keyword:`!import` 語句的搜索操作被定義為使用適當的參數呼叫 "
":func:`__import__` 函式。 :func:`__import__` "
"的回傳值用於執行 :keyword:`!import` "
"語句的名稱綁定操作。有關該名稱綁定操作的確切細節，請參閱 :keyword:`!import` "
"語句。"

#: ../../reference/import.rst:25
#, fuzzy
msgid ""
"A direct call to :func:`__import__` performs only the module search and, if "
"found, the module creation operation.  While certain side-effects may occur, "
"such as the importing of parent packages, and the updating of various caches "
"(including :data:`sys.modules`), only the :keyword:`import` statement "
"performs a name binding operation."
msgstr ""
"直接呼叫 :func:`__import__` 只執行模組搜索，如果找到，則執行模組建立操作。雖"
"然可能會出現某些副作用，例如父包的匯入和各種快取的更新（包括 :data:`sys."
"modules`），但只有 :keyword:`import` 語句執行名稱綁定操作。"

#: ../../reference/import.rst:31
#, fuzzy
msgid ""
"When an :keyword:`import` statement is executed, the standard builtin :func:"
"`__import__` function is called. Other mechanisms for invoking the import "
"system (such as :func:`importlib.import_module`) may choose to bypass :func:"
"`__import__` and use their own solutions to implement import semantics."
msgstr ""
"執行 :keyword:`import` 語句時，將呼叫標準內建 :func:`__import__` "
"函式。呼叫匯入系統的其他機制（例如 :func:`importlib.import_module`）"
"可能會選擇繞過 :func:`__import__` 並使用他們自己的解決方案來實作匯入語義。"

#: ../../reference/import.rst:36
#, fuzzy
msgid ""
"When a module is first imported, Python searches for the module and if "
"found, it creates a module object [#fnmo]_, initializing it.  If the named "
"module cannot be found, a :exc:`ModuleNotFoundError` is raised.  Python "
"implements various strategies to search for the named module when the import "
"machinery is invoked.  These strategies can be modified and extended by "
"using various hooks described in the sections below."
msgstr ""
"首次匯入模組時，Python 會搜索該模組，如果找到，它會建立一個模組物件 [#fnmo]_"
"，並對其進行初始化。如果找不到指定的模組，則會引發 :exec:`ModuleNotFoundError`"
"。呼叫匯入機制時，Python 會實施各種策略來搜索命名模組。可以使用以下部分中描述"
"的各種掛鉤來修改和擴充這些策略。"

#: ../../reference/import.rst:43
#, fuzzy
msgid ""
"The import system has been updated to fully implement the second phase of :"
"pep:`302`. There is no longer any implicit import machinery - the full "
"import system is exposed through :data:`sys.meta_path`. In addition, native "
"namespace package support has been implemented (see :pep:`420`)."
msgstr ""
"匯入系統已更新，以全面實施 :pep:`302` 的第二階段。不再有任何隱式匯入機制 - "
"完整的匯入系統通過 :data:`sys.meta_path` "
"公開。此外，還實作了本地命名空間包支援（參見 :pep:`420`）。"

#: ../../reference/import.rst:51
msgid ":mod:`importlib`"
msgstr ":mod:`importlib`"

#: ../../reference/import.rst:53
#, fuzzy
msgid ""
"The :mod:`importlib` module provides a rich API for interacting with the "
"import system.  For example :func:`importlib.import_module` provides a "
"recommended, simpler API than built-in :func:`__import__` for invoking the "
"import machinery.  Refer to the :mod:`importlib` library documentation for "
"additional detail."
msgstr ""
":mod:`importlib` 模組提供了豐富的 API 用於與匯入系統交互。例如 "
":func:`importlib.import_module` 提供了一個推薦的、比內建 :func:`__import__` "
"更簡單的 API 來呼叫匯入機制。有關更多詳細資訊，請參閱 :mod:`importlib` "
"庫文檔。"

#: ../../reference/import.rst:62
#, fuzzy
msgid "Packages"
msgstr "套餐"

#: ../../reference/import.rst:67
#, fuzzy
msgid ""
"Python has only one type of module object, and all modules are of this type, "
"regardless of whether the module is implemented in Python, C, or something "
"else.  To help organize modules and provide a naming hierarchy, Python has a "
"concept of :term:`packages <package>`."
msgstr ""
"Python 只有一種型別的模組物件，所有的模組都是這種型別，不管該模組是用 "
"Python、C 還是其他語言實作的。為了幫助組織模組並提供命名層次結構，Python "
"有一個概念 :term:`packages <package>`。"

#: ../../reference/import.rst:72
#, fuzzy
msgid ""
"You can think of packages as the directories on a file system and modules as "
"files within directories, but don't take this analogy too literally since "
"packages and modules need not originate from the file system.  For the "
"purposes of this documentation, we'll use this convenient analogy of "
"directories and files.  Like file system directories, packages are organized "
"hierarchically, and packages may themselves contain subpackages, as well as "
"regular modules."
msgstr ""
"您可以將包視為文件系統上的目錄，將模組視為目錄中的文件，但不要從字面上理解這"
"個類比，因為包和模組不需要源自文件系統。出於本文檔的目的，我們將使用目錄和文"
"件的這種方便類比。與文件系統目錄一樣，包是按層次組織的，包本身可能包含子包以"
"及常規模組。"

#: ../../reference/import.rst:80
#, fuzzy
msgid ""
"It's important to keep in mind that all packages are modules, but not all "
"modules are packages.  Or put another way, packages are just a special kind "
"of module.  Specifically, any module that contains a ``__path__`` attribute "
"is considered a package."
msgstr ""
"重要的是要記住所有包都是模組，但並非所有模組都是包。或者換句話說，包只是一種"
"特殊的模組。具體來說，任何包含 __path__ 屬性的模組都被視為一個包。"

#: ../../reference/import.rst:85
#, fuzzy
msgid ""
"All modules have a name.  Subpackage names are separated from their parent "
"package name by a dot, akin to Python's standard attribute access syntax.  "
"Thus you might have a package called :mod:`email`, which in turn has a "
"subpackage called :mod:`email.mime` and a module within that subpackage "
"called :mod:`email.mime.text`."
msgstr ""
"所有模組都有一個名稱。子包名稱通過點與其父包名稱分隔，類似於 Python "
"的標準屬性訪問語法。因此，您可能有一個名為 :mod:`email` 的包，"
"它又具有一個名為 :mod:`email.mime` 的子包和該子包中的一個名為 :mod:`email."
"mime.text` 的模組。"

#: ../../reference/import.rst:93
#, fuzzy
msgid "Regular packages"
msgstr "常規套餐"

#: ../../reference/import.rst:98
#, fuzzy
msgid ""
"Python defines two types of packages, :term:`regular packages <regular "
"package>` and :term:`namespace packages <namespace package>`.  Regular "
"packages are traditional packages as they existed in Python 3.2 and earlier. "
"A regular package is typically implemented as a directory containing an "
"``__init__.py`` file.  When a regular package is imported, this ``__init__."
"py`` file is implicitly executed, and the objects it defines are bound to "
"names in the package's namespace.  The ``__init__.py`` file can contain the "
"same Python code that any other module can contain, and Python will add some "
"additional attributes to the module when it is imported."
msgstr ""
"Python 定義了兩種型別的包，:term:`regular packages <regular package>` 和 "
":term:`namespace packages <namespace package>`。常規包是傳統包，"
"因為它們存在於 Python 3.2 及更早版本中。常規包通常實作為包含 "
"``__init__.py`` 文件的目錄。當一個常規包被匯入時，這個 ``__init__.py`` "
"文件被隱式執行，它定義的對像被綁定到包命名空間中的名稱。 ``__init__.py`` "
"文件可以包含任何其他模組可以包含的相同 Python 程式碼，並且 Python "
"會在模組匯入時新增一些額外的屬性。"

#: ../../reference/import.rst:108
#, fuzzy
msgid ""
"For example, the following file system layout defines a top level ``parent`` "
"package with three subpackages::"
msgstr "例如，以下文件系統佈局定義了一個包含三個子包的頂級 ``parent``包："

#: ../../reference/import.rst:120
#, fuzzy
msgid ""
"Importing ``parent.one`` will implicitly execute ``parent/__init__.py`` and "
"``parent/one/__init__.py``.  Subsequent imports of ``parent.two`` or "
"``parent.three`` will execute ``parent/two/__init__.py`` and ``parent/three/"
"__init__.py`` respectively."
msgstr ""
"匯入 ``parent.one`` 將隱式執行 ``parent/__init__.py`` 和 ``parent/one/"
"__init__.py``。 ``parent.two`` 或``parent.three`` 的後續匯入將分別執行``"
"parent/two/__init__.py`` 和``parent/three/__init__.py``。"

#: ../../reference/import.rst:127
#, fuzzy
msgid "Namespace packages"
msgstr "命名空間包"

#: ../../reference/import.rst:133
#, fuzzy
msgid ""
"A namespace package is a composite of various :term:`portions <portion>`, "
"where each portion contributes a subpackage to the parent package.  Portions "
"may reside in different locations on the file system.  Portions may also be "
"found in zip files, on the network, or anywhere else that Python searches "
"during import.  Namespace packages may or may not correspond directly to "
"objects on the file system; they may be virtual modules that have no "
"concrete representation."
msgstr ""
"命名空間包是各種 :term:`部分 <部分>` "
"的組合，其中每個部分為父包貢獻一個子包。部分可能駐留在文件系統上的不同位置。"
"部分也可以在 zip 文件、網絡或 Python 在匯入過程中搜索的任何其他地方找到。命名"
"空間包可能會也可能不會直接對應於文件系統上的物件；它們可能是沒有具體表示的虛"
"擬模組。"

#: ../../reference/import.rst:141
#, fuzzy
msgid ""
"Namespace packages do not use an ordinary list for their ``__path__`` "
"attribute. They instead use a custom iterable type which will automatically "
"perform a new search for package portions on the next import attempt within "
"that package if the path of their parent package (or :data:`sys.path` for a "
"top level package) changes."
msgstr ""
"命名空間包不為其 ``__path__`` "
"屬性使用普通列表。他們改為使用自定義可疊代型別，如果父包的路徑（或頂層包的 "
"sys.path "
"）發生變化，該型別將在該包中的下一次匯入嘗試中自動執行新的包部分搜索。"

#: ../../reference/import.rst:147
#, fuzzy
msgid ""
"With namespace packages, there is no ``parent/__init__.py`` file.  In fact, "
"there may be multiple ``parent`` directories found during import search, "
"where each one is provided by a different portion.  Thus ``parent/one`` may "
"not be physically located next to ``parent/two``.  In this case, Python will "
"create a namespace package for the top-level ``parent`` package whenever it "
"or one of its subpackages is imported."
msgstr ""
"對於命名空間包，沒有 parent/__init__.py 文件。事實上，"
"在匯入搜索過程中可能會找到多個 ``parent`` "
"目錄，其中每個目錄由不同的部分提供。因此 ``parent/one`` 在物理上可能不位於 ``"
"parent/two`` 旁邊。在這種情況下，每當匯入頂級 ``父``包或其子包之一時，Python "
"都會為頂級 ``父``包建立一個命名空間包。"

#: ../../reference/import.rst:154
#, fuzzy
msgid "See also :pep:`420` for the namespace package specification."
msgstr "另請參閱 :pep:`420` 以了解命名空間包規範。"

#: ../../reference/import.rst:158
#, fuzzy
msgid "Searching"
msgstr "搜索中"

#: ../../reference/import.rst:160
#, fuzzy
msgid ""
"To begin the search, Python needs the :term:`fully qualified <qualified "
"name>` name of the module (or package, but for the purposes of this "
"discussion, the difference is immaterial) being imported.  This name may "
"come from various arguments to the :keyword:`import` statement, or from the "
"parameters to the :func:`importlib.import_module` or :func:`__import__` "
"functions."
msgstr ""
"要開始搜索，Python "
"需要被匯入的模組（或包，但出於本次討論的目的，區別並不重要）的 :term:`"
"完全限定 <qualified name>` 名稱。此名稱可能來自 :keyword:`import` "
"語句的各種參數，或來自 :func:`importlib.import_module` 或 :func:`__import__` "
"函式的參數。"

#: ../../reference/import.rst:166
#, fuzzy
msgid ""
"This name will be used in various phases of the import search, and it may be "
"the dotted path to a submodule, e.g. ``foo.bar.baz``.  In this case, Python "
"first tries to import ``foo``, then ``foo.bar``, and finally ``foo.bar."
"baz``. If any of the intermediate imports fail, a :exc:`ModuleNotFoundError` "
"is raised."
msgstr ""
"此名稱將用於匯入搜索的各個階段，它可能是子模組的虛線路徑，例如``foo.bar."
"baz``。在這種情況下，Python 首先嘗試匯入 ``foo``，然後是“foo.bar”，最後是“foo."
"bar.baz”。如果任何中間匯入失敗，則會引發 ModuleNotFoundError。"

#: ../../reference/import.rst:173
#, fuzzy
msgid "The module cache"
msgstr "模組快取"

#: ../../reference/import.rst:178
#, fuzzy
msgid ""
"The first place checked during import search is :data:`sys.modules`.  This "
"mapping serves as a cache of all modules that have been previously imported, "
"including the intermediate paths.  So if ``foo.bar.baz`` was previously "
"imported, :data:`sys.modules` will contain entries for ``foo``, ``foo.bar``, "
"and ``foo.bar.baz``.  Each key will have as its value the corresponding "
"module object."
msgstr ""
"匯入搜索時檢查的第一個地方是 :data:`sys."
"modules`。此映射用作先前匯入的所有模組的快取，包括中間路徑。因此，"
"如果之前匯入了 ``foo.bar.baz``，則 :data:`sys.modules` 將包含 ``foo``、``foo."
"bar`` 和 ``foo.bar.baz` 的條目`。每個鍵都將具有相應的模組對像作為其值。"

#: ../../reference/import.rst:185
#, fuzzy
msgid ""
"During import, the module name is looked up in :data:`sys.modules` and if "
"present, the associated value is the module satisfying the import, and the "
"process completes.  However, if the value is ``None``, then a :exc:"
"`ModuleNotFoundError` is raised.  If the module name is missing, Python will "
"continue searching for the module."
msgstr ""
"在匯入過程中，模組名稱在 :data:`sys.modules` "
"中查找，如果存在，關聯值是滿足匯入的模組，過程完成。但是，如果值為 ``None``，"
"則會引發 ModuleNotFoundError。如果缺少模組名稱，Python 將繼續搜索該模組。"

#: ../../reference/import.rst:191
#, fuzzy
msgid ""
":data:`sys.modules` is writable.  Deleting a key may not destroy the "
"associated module (as other modules may hold references to it), but it will "
"invalidate the cache entry for the named module, causing Python to search "
"anew for the named module upon its next import. The key can also be assigned "
"to ``None``, forcing the next import of the module to result in a :exc:"
"`ModuleNotFoundError`."
msgstr ""
":data:`sys.modules` 是可寫的。刪除一個鍵可能不會破壞關聯的模組（因為其他模組"
"可能持有對它的引用），但它會使命名模組的快取條目無效，導致 Python 在下一次導"
"入時重新搜索命名模組。密鑰也可以分配給 ``None`` ，強制模組的下一次匯入導致 :exc:`M"
"oduleNotFoundError`。"

#: ../../reference/import.rst:198
#, fuzzy
msgid ""
"Beware though, as if you keep a reference to the module object, invalidate "
"its cache entry in :data:`sys.modules`, and then re-import the named module, "
"the two module objects will *not* be the same. By contrast, :func:`importlib."
"reload` will reuse the *same* module object, and simply reinitialise the "
"module contents by rerunning the module's code."
msgstr ""
"但是請注意，如果您保留對模組物件的引用，使其在 :data:`sys.modules` 中的快取條"
"目無效，然後重新匯入命名模組，那麼兩個模組物件將*不*相同。相比之下，:func:`im"
"portlib.reload` 將重用 *same* "
"模組物件，並通過重新運行模組程式碼簡單地重新初始化模組內容。"

#: ../../reference/import.rst:208
#, fuzzy
msgid "Finders and loaders"
msgstr "探測器和裝載機"

#: ../../reference/import.rst:215
#, fuzzy
msgid ""
"If the named module is not found in :data:`sys.modules`, then Python's "
"import protocol is invoked to find and load the module.  This protocol "
"consists of two conceptual objects, :term:`finders <finder>` and :term:"
"`loaders <loader>`. A finder's job is to determine whether it can find the "
"named module using whatever strategy it knows about. Objects that implement "
"both of these interfaces are referred to as :term:`importers <importer>` - "
"they return themselves when they find that they can load the requested "
"module."
msgstr ""
"如果在 :data:`sys.modules` 中找不到命名模組，則呼叫 Python "
"的匯入協定來查找和加載模組。該協定由兩個概念物件組成，:term:`finders "
"<finder>` 和 :term:`loaders "
"<loader>`。查找器的工作是確定它是否可以使用它知道的任何策略找到命名模組。"
"實作這兩個介面的物件稱為 :term:`importers <importer>` - "
"當它們發現可以加載請求的模組時，它們會自行回傳。"

#: ../../reference/import.rst:223
#, fuzzy
msgid ""
"Python includes a number of default finders and importers.  The first one "
"knows how to locate built-in modules, and the second knows how to locate "
"frozen modules.  A third default finder searches an :term:`import path` for "
"modules.  The :term:`import path` is a list of locations that may name file "
"system paths or zip files.  It can also be extended to search for any "
"locatable resource, such as those identified by URLs."
msgstr ""
"Python 包括許多預設查找器和匯入器。第一個知道如何定位內建模組，第二個知道如何"
"定位凍結模組。第三個預設查找器在 :term:`import path` 中搜索模組。 :term:`"
"import path` 是可以命名文件系統路徑或 zip "
"文件的位置列表。它還可以擴充為搜索任何可定位的資源，例如由 URL 標識的資源。"

#: ../../reference/import.rst:230
#, fuzzy
msgid ""
"The import machinery is extensible, so new finders can be added to extend "
"the range and scope of module searching."
msgstr "匯入機制是可擴充的，因此可以新增新的查找器來擴充模組搜索的範圍和範圍。"

#: ../../reference/import.rst:233
#, fuzzy
msgid ""
"Finders do not actually load modules.  If they can find the named module, "
"they return a :dfn:`module spec`, an encapsulation of the module's import-"
"related information, which the import machinery then uses when loading the "
"module."
msgstr ""
"Finders 實際上並不加載模組。如果他們能找到指定的模組，他們會回傳一個 :dfn:`"
"module spec`，這是模組匯入相關資訊的封裝，然後匯入機制在加載模組時使用它。"

#: ../../reference/import.rst:237
#, fuzzy
msgid ""
"The following sections describe the protocol for finders and loaders in more "
"detail, including how you can create and register new ones to extend the "
"import machinery."
msgstr "以下部分更詳細地描述了查找器和加載器的協定，包括如何建立和註冊新協定以擴充導"
"入機制。"

#: ../../reference/import.rst:241
#, fuzzy
msgid ""
"In previous versions of Python, finders returned :term:`loaders <loader>` "
"directly, whereas now they return module specs which *contain* loaders. "
"Loaders are still used during import but have fewer responsibilities."
msgstr ""
"在以前的 Python 版本中，finders 直接回傳 :term:`loaders <loader>`，"
"而現在它們回傳模組規格 *包含* "
"加載器。加載程式在匯入過程中仍然使用，但職責較少。"

#: ../../reference/import.rst:247
#, fuzzy
msgid "Import hooks"
msgstr "匯入鉤子"

#: ../../reference/import.rst:257
#, fuzzy
msgid ""
"The import machinery is designed to be extensible; the primary mechanism for "
"this are the *import hooks*.  There are two types of import hooks: *meta "
"hooks* and *import path hooks*."
msgstr "進口機械設計為可擴充；主要機制是 *import "
"hooks*。匯入掛鉤有兩種型別：*元掛鉤*和*匯入路徑掛鉤*。"

#: ../../reference/import.rst:261
#, fuzzy
msgid ""
"Meta hooks are called at the start of import processing, before any other "
"import processing has occurred, other than :data:`sys.modules` cache look "
"up. This allows meta hooks to override :data:`sys.path` processing, frozen "
"modules, or even built-in modules.  Meta hooks are registered by adding new "
"finder objects to :data:`sys.meta_path`, as described below."
msgstr ""
"元掛鉤在匯入處理開始時被呼叫，在任何其他匯入處理髮生之前，除了 :data:`sys."
"modules` 快取查找。這允許元掛鉤覆蓋 :data:`sys.path` "
"處理、凍結模組，甚至內建模組。元掛鉤通過將新的查找器物件新增到 :data:`sys."
"meta_path` 來註冊，如下所述。"

#: ../../reference/import.rst:267
#, fuzzy
msgid ""
"Import path hooks are called as part of :data:`sys.path` (or ``package."
"__path__``) processing, at the point where their associated path item is "
"encountered.  Import path hooks are registered by adding new callables to :"
"data:`sys.path_hooks` as described below."
msgstr ""
"匯入路徑掛鉤作為 :data:`sys.path`（或 ``package."
"__path__``）處理的一部分被呼叫，在遇到它們的關聯路徑項時。匯入路徑掛鉤通過向 "
":data:`sys.path_hooks` 新增新的可呼叫物件來註冊，如下所述。"

#: ../../reference/import.rst:274
#, fuzzy
msgid "The meta path"
msgstr "元路徑"

#: ../../reference/import.rst:280
#, fuzzy
msgid ""
"When the named module is not found in :data:`sys.modules`, Python next "
"searches :data:`sys.meta_path`, which contains a list of meta path finder "
"objects.  These finders are queried in order to see if they know how to "
"handle the named module.  Meta path finders must implement a method called :"
"meth:`~importlib.abc.MetaPathFinder.find_spec()` which takes three "
"arguments: a name, an import path, and (optionally) a target module.  The "
"meta path finder can use any strategy it wants to determine whether it can "
"handle the named module or not."
msgstr ""
"當在 :data:`sys.modules` 中找不到命名模組時，Python 接下來會搜索 :data:`sys.m"
"eta_path`，其中包含元路徑查找器物件的列表。查詢這些查找器以查看它們是否知道如"
"何處理命名模組。元路徑查找器必須實作一個名為 :meth:`~importlib.abc."
"MetaPathFinder.find_spec()` 的方法，該方法採用三個參數：名稱、匯入路徑和（可"
"選）目標模組。元路徑查找器可以使用它想要的任何策略來確定它是否可以處理命名模"
"組。"

#: ../../reference/import.rst:289
#, fuzzy
msgid ""
"If the meta path finder knows how to handle the named module, it returns a "
"spec object.  If it cannot handle the named module, it returns ``None``.  "
"If :data:`sys.meta_path` processing reaches the end of its list without "
"returning a spec, then a :exc:`ModuleNotFoundError` is raised.  Any other "
"exceptions raised are simply propagated up, aborting the import process."
msgstr ""
"如果元路徑查找器知道如何處理命名模組，它會回傳一個規範物件。如果它無法處理命"
"名模組，則回傳 ``None`` 。如果 :data:`sys.meta_path` "
"處理到達其列表的末尾而沒有回傳規範，則會引發 :exc:`ModuleNotFoundError`。引發"
"的任何其他例外都會向上傳播，從而中止匯入過程。"

#: ../../reference/import.rst:295
#, fuzzy
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec()` method of meta path "
"finders is called with two or three arguments.  The first is the fully "
"qualified name of the module being imported, for example ``foo.bar.baz``. "
"The second argument is the path entries to use for the module search.  For "
"top-level modules, the second argument is ``None``, but for submodules or "
"subpackages, the second argument is the value of the parent package's "
"``__path__`` attribute. If the appropriate ``__path__`` attribute cannot be "
"accessed, a :exc:`ModuleNotFoundError` is raised.  The third argument is an "
"existing module object that will be the target of loading later. The import "
"system passes in a target module only during reload."
msgstr ""
"元路徑查找器的 :meth:`~importlib.abc.MetaPathFinder.find_spec()` "
"方法使用兩個或三個參數呼叫。第一個是被匯入模組的完全限定名稱，例如“foo.bar.ba"
"z”。第二個參數是用於模組搜索的路徑條目。對於頂級模組，第二個參數是 ``None`` ，但對"
"於子模組或子包，第二個參數是父包的“__path__”屬性的值。如果無法訪問適當的 "
"__path__ 屬性，則會引發 ModuleNotFoundError。第三個參數是一個現有的模組物件，"
"它將成為稍後加載的目標。匯入系統僅在重新加載期間傳入目標模組。"

#: ../../reference/import.rst:306
#, fuzzy
msgid ""
"The meta path may be traversed multiple times for a single import request. "
"For example, assuming none of the modules involved has already been cached, "
"importing ``foo.bar.baz`` will first perform a top level import, calling "
"``mpf.find_spec(\"foo\", None, None)`` on each meta path finder (``mpf``). "
"After ``foo`` has been imported, ``foo.bar`` will be imported by traversing "
"the meta path a second time, calling ``mpf.find_spec(\"foo.bar\", foo."
"__path__, None)``. Once ``foo.bar`` has been imported, the final traversal "
"will call ``mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, None)``."
msgstr ""
"對於單個匯入請求，可能會多次遍曆元路徑。例如，假設所涉及的模組都沒有被快取，"
"匯入``foo.bar.baz`` 將首先執行頂級匯入，呼叫``mpf.find_spec(\"foo\", None, "
"None)``每個元路徑查找器（``mpf``）。 ``foo`` 被匯入後，``foo.bar`` "
"將通過第二次遍曆元路徑匯入，呼叫 ``mpf.find_spec(\"foo.bar\", foo.__path__, "
"None)`` .一旦 ``foo.bar`` 被匯入，最後的遍歷將呼叫 ``mpf.find_spec(\"foo.bar."
"baz\", foo.bar.__path__, None)``。"

#: ../../reference/import.rst:316
#, fuzzy
msgid ""
"Some meta path finders only support top level imports. These importers will "
"always return ``None`` when anything other than ``None`` is passed as the "
"second argument."
msgstr "一些元路徑查找器只支援頂級匯入。當將 ``None``以外的任何內容作為第二個參數傳遞時"
"，這些匯入器將始終回傳 ``None``。"

#: ../../reference/import.rst:320
#, fuzzy
msgid ""
"Python's default :data:`sys.meta_path` has three meta path finders, one that "
"knows how to import built-in modules, one that knows how to import frozen "
"modules, and one that knows how to import modules from an :term:`import "
"path` (i.e. the :term:`path based finder`)."
msgstr ""
"Python 的預設 :data:`sys.meta_path` "
"有三個元路徑查找器，一個知道如何匯入內建模組，一個知道如何匯入凍結模組，"
"一個知道如何從 :term: 匯入模組import path`（即 :term:`path based finder`）。"

#: ../../reference/import.rst:325
#, fuzzy
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec` method of meta path "
"finders replaced :meth:`~importlib.abc.MetaPathFinder.find_module`, which is "
"now deprecated.  While it will continue to work without change, the import "
"machinery will try it only if the finder does not implement ``find_spec()``."
msgstr ""
"元路徑查找器的 :meth:`~importlib.abc.MetaPathFinder.find_spec` 方法替換了 "
":meth:`~importlib.abc.MetaPathFinder.find_module`，現在已棄用。雖然它會在沒有"
"變化的情況下繼續工作，但只有當查找器沒有實作“find_spec()”時，匯入機制才會嘗試"
"它。"

#: ../../reference/import.rst:332
#, fuzzy
msgid ""
"Use of :meth:`~importlib.abc.MetaPathFinder.find_module` by the import "
"system now raises :exc:`ImportWarning`."
msgstr ""
"匯入系統使用 :meth:`~importlib.abc.MetaPathFinder.find_module` 現在會引發 "
":exc:`ImportWarning`。"

#: ../../reference/import.rst:338
#, fuzzy
msgid "Loading"
msgstr "加載中"

#: ../../reference/import.rst:340
#, fuzzy
msgid ""
"If and when a module spec is found, the import machinery will use it (and "
"the loader it contains) when loading the module.  Here is an approximation "
"of what happens during the loading portion of import::"
msgstr "如果找到模組規範，匯入機制將在加載模組時使用它（以及它包含的加載器）。這是 "
"import:: 的加載部分期間發生的事情的近似值："

#: ../../reference/import.rst:374
#, fuzzy
msgid "Note the following details:"
msgstr "請注意以下細節："

#: ../../reference/import.rst:376
#, fuzzy
msgid ""
"If there is an existing module object with the given name in :data:`sys."
"modules`, import will have already returned it."
msgstr "如果在 :data:`sys.modules` 中存在具有給定名稱的現有模組物件，import "
"將已經回傳它。"

#: ../../reference/import.rst:379
#, fuzzy
msgid ""
"The module will exist in :data:`sys.modules` before the loader executes the "
"module code.  This is crucial because the module code may (directly or "
"indirectly) import itself; adding it to :data:`sys.modules` beforehand "
"prevents unbounded recursion in the worst case and multiple loading in the "
"best."
msgstr ""
"在加載程式執行模組程式碼之前，模組將存在於 :data:`sys.modules` "
"中。這是至關重要的，因為模組程式碼可能（直接或間接）匯入自身；預先將它新增到 "
":data:`sys.modules` 可以防止最壞情況下的無限遞迴和最好情況下的多次加載。"

#: ../../reference/import.rst:385
#, fuzzy
msgid ""
"If loading fails, the failing module -- and only the failing module -- gets "
"removed from :data:`sys.modules`.  Any module already in the :data:`sys."
"modules` cache, and any module that was successfully loaded as a side-"
"effect, must remain in the cache.  This contrasts with reloading where even "
"the failing module is left in :data:`sys.modules`."
msgstr ""
"如果加載失敗，失敗的模組——並且只有失敗的模組——會從 :data:`sys.modules` "
"中移除。任何已經在 :data:`sys.modules` 快取中的模組，以及作為副作用成功加載的"
"任何模組，都必須保留在快取中。這與重新加載形成對比，"
"重新加載甚至失敗的模組都留在 :data:`sys.modules` 中。"

#: ../../reference/import.rst:391
#, fuzzy
msgid ""
"After the module is created but before execution, the import machinery sets "
"the import-related module attributes (\"_init_module_attrs\" in the pseudo-"
"code example above), as summarized in a :ref:`later section <import-mod-"
"attrs>`."
msgstr ""
"在建立模組之後但在執行之前，匯入機制設定與匯入相關的模組屬性（上面偽程式碼示"
"例中的“_init_module_attrs”），如 :ref:`後面的部分 <import-mod-attrs>` "
"中所總結的."

#: ../../reference/import.rst:396
#, fuzzy
msgid ""
"Module execution is the key moment of loading in which the module's "
"namespace gets populated.  Execution is entirely delegated to the loader, "
"which gets to decide what gets populated and how."
msgstr "模組執行是加載模組命名空間的關鍵時刻。執行完全委託給加載器，它決定填充什麼以"
"及如何填充。"

#: ../../reference/import.rst:400
#, fuzzy
msgid ""
"The module created during loading and passed to exec_module() may not be the "
"one returned at the end of import [#fnlo]_."
msgstr "在加載期間建立並傳遞給 exec_module() 的模組可能不是在 import [#fnlo]_ "
"結束時回傳的模組。"

#: ../../reference/import.rst:403
#, fuzzy
msgid ""
"The import system has taken over the boilerplate responsibilities of "
"loaders.  These were previously performed by the :meth:`importlib.abc.Loader."
"load_module` method."
msgstr "匯入系統接管了裝載機的樣板責任。這些以前是由 "
"importlib.abc.Loader.load_module 方法執行的。"

#: ../../reference/import.rst:409
#, fuzzy
msgid "Loaders"
msgstr "裝載機"

#: ../../reference/import.rst:411
#, fuzzy
msgid ""
"Module loaders provide the critical function of loading: module execution. "
"The import machinery calls the :meth:`importlib.abc.Loader.exec_module` "
"method with a single argument, the module object to execute.  Any value "
"returned from :meth:`~importlib.abc.Loader.exec_module` is ignored."
msgstr ""
"模組加載器提供加載的關鍵功能：模組執行。匯入機制使用單個參數呼叫 "
"importlib.abc.Loader.exec_module 方法，即要執行的模組物件。從 "
":meth:`~importlib.abc.Loader.exec_module` 回傳的任何值都將被忽略。"

#: ../../reference/import.rst:416
#, fuzzy
msgid "Loaders must satisfy the following requirements:"
msgstr "裝載機必須滿足以下要求："

#: ../../reference/import.rst:418
#, fuzzy
msgid ""
"If the module is a Python module (as opposed to a built-in module or a "
"dynamically loaded extension), the loader should execute the module's code "
"in the module's global name space (``module.__dict__``)."
msgstr ""
"如果模組是 Python 模組（而不是內建模組或動態加載的擴充），加載器應該在模組的"
"全局命名空間（``module.__dict__``）中執行模組的程式碼。"

#: ../../reference/import.rst:422
#, fuzzy
msgid ""
"If the loader cannot execute the module, it should raise an :exc:"
"`ImportError`, although any other exception raised during :meth:`~importlib."
"abc.Loader.exec_module` will be propagated."
msgstr ""
"如果加載器無法執行模組，它應該引發 ImportError，儘管在 :meth:`~importlib.abc."
"Loader.exec_module` 期間引發的任何其他例外都將被傳播。"

#: ../../reference/import.rst:426
#, fuzzy
msgid ""
"In many cases, the finder and loader can be the same object; in such cases "
"the :meth:`~importlib.abc.MetaPathFinder.find_spec` method would just return "
"a spec with the loader set to ``self``."
msgstr ""
"在很多情況下，finder 和 loader "
"可以是同一個物件；在這種情況下，:meth:`~importlib.abc.MetaPathFinder."
"find_spec` 方法只會回傳一個規範，其中加載器設定為 ``self``。"

#: ../../reference/import.rst:430
#, fuzzy
msgid ""
"Module loaders may opt in to creating the module object during loading by "
"implementing a :meth:`~importlib.abc.Loader.create_module` method. It takes "
"one argument, the module spec, and returns the new module object to use "
"during loading.  ``create_module()`` does not need to set any attributes on "
"the module object.  If the method returns ``None``, the import machinery "
"will create the new module itself."
msgstr ""
"模組加載器可以通過實作 :meth:`~importlib.abc.Loader.create_module` 方法選擇在"
"加載期間建立模組物件。它接受一個參數，即模組規範，並回傳要在加載期間使用的新"
"模組物件。 ``create_module()`` 不需要在模組對像上設定任何屬性。如果該方法回傳"
" ``None``，匯入機制將自己建立新模組。"

#: ../../reference/import.rst:437
#, fuzzy
msgid "The :meth:`~importlib.abc.Loader.create_module` method of loaders."
msgstr "加載器的 :meth:`~importlib.abc.Loader.create_module` 方法。"

#: ../../reference/import.rst:440
#, fuzzy
msgid ""
"The :meth:`~importlib.abc.Loader.load_module` method was replaced by :meth:"
"`~importlib.abc.Loader.exec_module` and the import machinery assumed all the "
"boilerplate responsibilities of loading."
msgstr ""
":meth:`~importlib.abc.Loader.load_module` 方法被 :meth:`~importlib.abc.Loader"
".exec_module` 取代，匯入機制承擔了加載的所有樣板責任。"

#: ../../reference/import.rst:445
#, fuzzy
msgid ""
"For compatibility with existing loaders, the import machinery will use the "
"``load_module()`` method of loaders if it exists and the loader does not "
"also implement ``exec_module()``.  However, ``load_module()`` has been "
"deprecated and loaders should implement ``exec_module()`` instead."
msgstr ""
"為了與現有加載器相容，匯入機制將使用加載器的 ``load_module()`` "
"方法（如果存在）並且加載器不實作 ``exec_module()``。但是，``load_module()`` "
"已被棄用，加載程式應改為實作 ``exec_module()``。"

#: ../../reference/import.rst:450
#, fuzzy
msgid ""
"The ``load_module()`` method must implement all the boilerplate loading "
"functionality described above in addition to executing the module.  All the "
"same constraints apply, with some additional clarification:"
msgstr "除了執行模組之外，``load_module()`` 方法還必須實作上述所有樣板加載功能。所有"
"相同的限制都適用，但有一些額外的說明："

#: ../../reference/import.rst:454
#, fuzzy
msgid ""
"If there is an existing module object with the given name in :data:`sys."
"modules`, the loader must use that existing module. (Otherwise, :func:"
"`importlib.reload` will not work correctly.)  If the named module does not "
"exist in :data:`sys.modules`, the loader must create a new module object and "
"add it to :data:`sys.modules`."
msgstr ""
"如果在 :data:`sys.modules` "
"中存在具有給定名稱的現有模組物件，則加載程式必須使用該現有模組。 "
"（否則，:func:`importlib.reload` "
"將無法正常工作。）如果命名模組不存在於 :data:`sys.modules` "
"中，加載程式必須建立一個新的模組物件並將其新增到 :data:`系統模組`。"

#: ../../reference/import.rst:460
#, fuzzy
msgid ""
"The module *must* exist in :data:`sys.modules` before the loader executes "
"the module code, to prevent unbounded recursion or multiple loading."
msgstr "在加載程式執行模組程式碼之前，模組*必須*存在於 :data:`sys.modules` "
"中，以防止無限遞迴或多重加載。"

#: ../../reference/import.rst:464
#, fuzzy
msgid ""
"If loading fails, the loader must remove any modules it has inserted into :"
"data:`sys.modules`, but it must remove **only** the failing module(s), and "
"only if the loader itself has loaded the module(s) explicitly."
msgstr ""
"如果加載失敗，加載器必須刪除它插入到 :data:`sys.modules` 中的任何模組，但它必"
"須刪除**僅**失敗的模組，並且只有加載器本身已經加載了模組（ s) 明確地。"

#: ../../reference/import.rst:469
#, fuzzy
msgid ""
"A :exc:`DeprecationWarning` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
"A :exc:`DeprecationWarning` 在定義了 `exec_module()`` 但沒有定義 "
"``create_module()`` 時引發。"

#: ../../reference/import.rst:473
#, fuzzy
msgid ""
"An :exc:`ImportError` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
"當 `exec_module()`` 被定義但 `create_module()`` 沒有被定義時，一個 "
":exc:`ImportError` 被引發。"

#: ../../reference/import.rst:477
#, fuzzy
msgid "Use of ``load_module()`` will raise :exc:`ImportWarning`."
msgstr "使用 ``load_module()`` 會引發 :exec:`ImportWarning`。"

#: ../../reference/import.rst:481
#, fuzzy
msgid "Submodules"
msgstr "子模組"

#: ../../reference/import.rst:483
#, fuzzy
msgid ""
"When a submodule is loaded using any mechanism (e.g. ``importlib`` APIs, the "
"``import`` or ``import-from`` statements, or built-in ``__import__()``) a "
"binding is placed in the parent module's namespace to the submodule object. "
"For example, if package ``spam`` has a submodule ``foo``, after importing "
"``spam.foo``, ``spam`` will have an attribute ``foo`` which is bound to the "
"submodule.  Let's say you have the following directory structure::"
msgstr ""
"當使用任何機制（例如 ``importlib`` API，``import`` 或 ``import-from`` 語句，"
"或內建的 ``__import__()``）加載子模組時，綁定被放置在父模組的命名空間到子模組"
"物件。例如，如果包 ``spam`` 有一個子模組 ``foo``，在匯入 ``spam.foo`` "
"之後，``spam`` 將有一個屬性 ``foo`` 綁定到子模組。假設您具有以下目錄結構::"

#: ../../reference/import.rst:494
#, fuzzy
msgid "and ``spam/__init__.py`` has the following line in it::"
msgstr "``spam/__init__.py`` 中有以下行："

#: ../../reference/import.rst:498
#, fuzzy
msgid ""
"then executing the following puts name bindings for ``foo`` and ``Foo`` in "
"the ``spam`` module::"
msgstr "然後執行以下命令，將 ``foo`` 和 ``Foo`` 的名稱綁定放入 ``spam`` 模組中："

#: ../../reference/import.rst:507
#, fuzzy
msgid ""
"Given Python's familiar name binding rules this might seem surprising, but "
"it's actually a fundamental feature of the import system.  The invariant "
"holding is that if you have ``sys.modules['spam']`` and ``sys.modules['spam."
"foo']`` (as you would after the above import), the latter must appear as the "
"``foo`` attribute of the former."
msgstr ""
"考慮到 Python 熟悉的名稱綁定規則，這可能看起來令人驚訝，但它實際上是匯入系統"
"的一個基本功能。不變的持有是，如果你有 ``sys.modules['spam']`` 和 ``sys."
"modules['spam.foo']``（就像你在上面匯入之後所做的那樣），"
"後者必須顯示為前者的 ``foo`` 屬性。"

#: ../../reference/import.rst:514
#, fuzzy
msgid "Module spec"
msgstr "模組規格"

#: ../../reference/import.rst:516
#, fuzzy
msgid ""
"The import machinery uses a variety of information about each module during "
"import, especially before loading.  Most of the information is common to all "
"modules.  The purpose of a module's spec is to encapsulate this import-"
"related information on a per-module basis."
msgstr ""
"匯入機制在匯入期間使用有關每個模組的各種資訊，尤其是在加載之前。大多數資訊對"
"所有模組都是通用的。模組規範的目的是在每個模組的基礎上封裝與匯入相關的資訊。"

#: ../../reference/import.rst:521
#, fuzzy
msgid ""
"Using a spec during import allows state to be transferred between import "
"system components, e.g. between the finder that creates the module spec and "
"the loader that executes it.  Most importantly, it allows the import "
"machinery to perform the boilerplate operations of loading, whereas without "
"a module spec the loader had that responsibility."
msgstr ""
"在匯入期間使用規範允許在匯入系統組件之間傳輸狀態，例如在建立模組規範的查找器"
"和執行它的加載器之間。最重要的是，它允許匯入機器執行加載的樣板操作，而如果沒"
"有模組規範，加載程式就有責任。"

#: ../../reference/import.rst:527
#, fuzzy
msgid ""
"The module's spec is exposed as the ``__spec__`` attribute on a module "
"object. See :class:`~importlib.machinery.ModuleSpec` for details on the "
"contents of the module spec."
msgstr ""
"模組的規範作為模組對像上的 __spec__ "
"屬性公開。有關模組規範內容的詳細資訊，請參閱 :class:`~importlib.machinery."
"ModuleSpec`。"

#: ../../reference/import.rst:536
#, fuzzy
msgid "Import-related module attributes"
msgstr "匯入相關模組屬性"

#: ../../reference/import.rst:538
#, fuzzy
msgid ""
"The import machinery fills in these attributes on each module object during "
"loading, based on the module's spec, before the loader executes the module."
msgstr "在加載器執行模組之前，匯入機制根據模組的規範在加載期間在每個模組對像上填充這"
"些屬性。"

#: ../../reference/import.rst:544
#, fuzzy
msgid ""
"The ``__name__`` attribute must be set to the fully qualified name of the "
"module.  This name is used to uniquely identify the module in the import "
"system."
msgstr "``__name__`` "
"屬性必須設定為模組的完全限定名稱。該名稱用於唯一標識匯入系統中的模組。"

#: ../../reference/import.rst:550
#, fuzzy
msgid ""
"The ``__loader__`` attribute must be set to the loader object that the "
"import machinery used when loading the module.  This is mostly for "
"introspection, but can be used for additional loader-specific functionality, "
"for example getting data associated with a loader."
msgstr ""
"``__loader__`` 屬性必須設定為匯入機制在加載模組時使用的加載器物件。這主要用於"
"自省，但也可用於其他特定於加載程式的功能，例如獲取與加載程式關聯的資料。"

#: ../../reference/import.rst:557
#, fuzzy
msgid ""
"The module's ``__package__`` attribute must be set.  Its value must be a "
"string, but it can be the same value as its ``__name__``.  When the module "
"is a package, its ``__package__`` value should be set to its ``__name__``.  "
"When the module is not a package, ``__package__`` should be set to the empty "
"string for top-level modules, or for submodules, to the parent package's "
"name.  See :pep:`366` for further details."
msgstr ""
"必須設定模組的 ``__package__`` 屬性。它的值必須是一個字串，但它可以與它的 "
"__name__ 相同。當模組是一個包時，它的 ``__package__`` 值應該設定為它的 "
"``__name__``。當模組不是包時，``__package__`` 應該設定為頂級模組的空字串，或"
"者對於子模組，設定為父包的名稱。有關詳細資訊，請參閱 :pep:`366`。"

#: ../../reference/import.rst:565
#, fuzzy
msgid ""
"This attribute is used instead of ``__name__`` to calculate explicit "
"relative imports for main modules, as defined in :pep:`366`. It is expected "
"to have the same value as ``__spec__.parent``."
msgstr ""
"此屬性用於代替 __name__ 來計算主要模組的顯式相對匯入，如 :pep:`366` "
"中所定義。它應該與 __spec__.parent 具有相同的值。"

#: ../../reference/import.rst:569
#, fuzzy
msgid ""
"The value of ``__package__`` is expected to be the same as ``__spec__."
"parent``."
msgstr "``__package__`` 的值預計與 ``__spec__.parent`` 相同。"

#: ../../reference/import.rst:575
#, fuzzy
msgid ""
"The ``__spec__`` attribute must be set to the module spec that was used when "
"importing the module. Setting ``__spec__`` appropriately applies equally to :"
"ref:`modules initialized during interpreter startup <programs>`.  The one "
"exception is ``__main__``, where ``__spec__`` is :ref:`set to None in some "
"cases <main_spec>`."
msgstr ""
"``__spec__`` 屬性必須設定為匯入模組時使用的模組規範。適當地設定 ``__spec__`` "
"同樣適用於 :ref:`在直譯器啟動期間初始化的模組 <programs>`。一個例外是 "
"``__main__``，其中 ``__spec__`` 在某些情況下設定為 None <main_spec>`。"

#: ../../reference/import.rst:581
#, fuzzy
msgid ""
"When ``__package__`` is not defined, ``__spec__.parent`` is used as a "
"fallback."
msgstr "當未定義 ``__package__`` 時，``__spec__.parent`` 用作後備。"

#: ../../reference/import.rst:586
#, fuzzy
msgid ""
"``__spec__.parent`` is used as a fallback when ``__package__`` is not "
"defined."
msgstr "``__spec__.parent`` 在未定義 ``__package__`` 時用作回退。"

#: ../../reference/import.rst:592
#, fuzzy
msgid ""
"If the module is a package (either regular or namespace), the module "
"object's ``__path__`` attribute must be set.  The value must be iterable, "
"but may be empty if ``__path__`` has no further significance. If "
"``__path__`` is not empty, it must produce strings when iterated over. More "
"details on the semantics of ``__path__`` are given :ref:`below <package-path-"
"rules>`."
msgstr ""
"如果模組是包（常規包或命名空間），則必須設定模組物件的“__path__”屬性。該值必"
"須是可疊代的，但如果 __path__ 沒有進一步的意義，則可以為空。如果 ``__path__``"
" 不為空，則它在疊代時必須生成字串。在 <package-path-rules> 下方給出了有關 "
"__path__ 語義的更多詳細資訊 :ref:`。"

#: ../../reference/import.rst:599
#, fuzzy
msgid "Non-package modules should not have a ``__path__`` attribute."
msgstr "非包模組不應該有 __path__ 屬性。"

#: ../../reference/import.rst:604
#, fuzzy
msgid ""
"``__file__`` is optional (if set, value must be a string). It indicates the "
"pathname of the file from which the module was loaded (if loaded from a "
"file), or the pathname of the shared library file for extension modules "
"loaded dynamically from a shared library. It might be missing for certain "
"types of modules, such as C modules that are statically linked into the "
"interpreter, and the import system may opt to leave it unset if it has no "
"semantic meaning (e.g. a module loaded from a database)."
msgstr ""
"``__file__`` 是可選的（如果設定，值必須是字串）。它指示從中加載模組的文件的路"
"徑名（如果從文件加載），或從共享庫動態加載的擴充模組的共享庫文件的路徑名。對"
"於某些型別的模組，它可能會丟失，例如靜態鏈接到直譯器的 C 模組，如果它沒有語義"
"意義（例如從資料庫加載的模組），匯入系統可能會選擇將其保留為未設定。"

#: ../../reference/import.rst:613
#, fuzzy
msgid ""
"If ``__file__`` is set then the ``__cached__`` attribute might also be set,  "
"which is the path to any compiled version of the code (e.g. byte-compiled "
"file). The file does not need to exist to set this attribute; the path can "
"simply point to where the compiled file would exist (see :pep:`3147`)."
msgstr ""
"如果設定了``__file__``，那麼``__cached__`` 屬性也可能被設定，這是程式碼的任何"
"編譯版本（例如位元組編譯文件）的路徑。該文件不需要存在即可設定此屬性；該路徑"
"可以簡單地指向編譯文件所在的位置（參見 :pep:`3147`）。"

#: ../../reference/import.rst:619
#, fuzzy
msgid ""
"Note that ``__cached__`` may be set even if ``__file__`` is not set.  "
"However, that scenario is quite atypical.  Ultimately, the loader is what "
"makes use of the module spec provided by the finder (from which ``__file__`` "
"and ``__cached__`` are derived).  So if a loader can load from a cached "
"module but otherwise does not load from a file, that atypical scenario may "
"be appropriate."
msgstr ""
"請注意，即使未設定 __file__ 也可以設定 __cached__ "
"。但是，這種情況非常不典型。最終，加載器使用了查找器提供的模組規範（"
"從中派生了 ``__file__`` 和 ``__cached__``）。因此，如果加載程式可以從快取模組"
"加載但不能從文件加載，那麼這種非典型場景可能是合適的。"

#: ../../reference/import.rst:629
msgid "module.__path__"
msgstr "module.__path__"

#: ../../reference/import.rst:631
#, fuzzy
msgid ""
"By definition, if a module has a ``__path__`` attribute, it is a package."
msgstr "根據定義，如果一個模組有一個 __path__ 屬性，它就是一個包。"

#: ../../reference/import.rst:633
#, fuzzy
msgid ""
"A package's ``__path__`` attribute is used during imports of its "
"subpackages. Within the import machinery, it functions much the same as :"
"data:`sys.path`, i.e. providing a list of locations to search for modules "
"during import. However, ``__path__`` is typically much more constrained "
"than :data:`sys.path`."
msgstr ""
"包的 ``__path__`` 屬性在匯入其子包期間使用。在匯入機制中，它的功能與 "
":data:`sys.path` "
"非常相似，即提供一個位置列表以在匯入期間搜索模組。但是，``__path__`` 通常比 "
":data:`sys.path` 受到更多限制。"

#: ../../reference/import.rst:639
#, fuzzy
msgid ""
"``__path__`` must be an iterable of strings, but it may be empty. The same "
"rules used for :data:`sys.path` also apply to a package's ``__path__``, and :"
"data:`sys.path_hooks` (described below) are consulted when traversing a "
"package's ``__path__``."
msgstr ""
"``__path__`` 必須是一個可疊代的字串，但它可以是空的。用於 :data:`sys.path` "
"的相同規則也適用於包的 ``__path__``，並且 :data:`sys.path_hooks`（如下所述）"
"在遍歷包的 ``__path__`` 時被參考。"

#: ../../reference/import.rst:644
#, fuzzy
msgid ""
"A package's ``__init__.py`` file may set or alter the package's ``__path__`` "
"attribute, and this was typically the way namespace packages were "
"implemented prior to :pep:`420`.  With the adoption of :pep:`420`, namespace "
"packages no longer need to supply ``__init__.py`` files containing only "
"``__path__`` manipulation code; the import machinery automatically sets "
"``__path__`` correctly for the namespace package."
msgstr ""
"包的 ``__init__.py`` 文件可以設定或改變包的 ``__path__`` 屬性，"
"這通常是命名空間包在 :pep:`420` 之前實作的方式。隨著 :pep:`420` 的採用，"
"命名空間包不再需要提供僅包含 ``__path__`` 操作程式碼的 ``__init__.py`` 文件；"
"匯入機制自動為命名空間包正確設定 __path__ 。"

#: ../../reference/import.rst:652
#, fuzzy
msgid "Module reprs"
msgstr "模組代表"

#: ../../reference/import.rst:654
#, fuzzy
msgid ""
"By default, all modules have a usable repr, however depending on the "
"attributes set above, and in the module's spec, you can more explicitly "
"control the repr of module objects."
msgstr "預設情況下，所有模組都有一個可用的 "
"repr，但是根據上面設定的屬性，在模組的規範中，您可以更明確地控制模組物件的 "
"repr。"

#: ../../reference/import.rst:658
#, fuzzy
msgid ""
"If the module has a spec (``__spec__``), the import machinery will try to "
"generate a repr from it.  If that fails or there is no spec, the import "
"system will craft a default repr using whatever information is available on "
"the module.  It will try to use the ``module.__name__``, ``module."
"__file__``, and ``module.__loader__`` as input into the repr, with defaults "
"for whatever information is missing."
msgstr ""
"如果模組有規範（``__spec__``），匯入機制將嘗試從中生成一個 "
"repr。如果失敗或沒有規範，匯入系統將使用模組上可用的任何資訊製作一個預設的 "
"repr。它將嘗試使用 ``module.__name__``、``module.__file__`` 和 ``module."
"__loader__`` 作為 repr 的輸入，無論缺少什麼資訊都使用預設值。"

#: ../../reference/import.rst:665
#, fuzzy
msgid "Here are the exact rules used:"
msgstr "以下是使用的確切規則："

#: ../../reference/import.rst:667
#, fuzzy
msgid ""
"If the module has a ``__spec__`` attribute, the information in the spec is "
"used to generate the repr.  The \"name\", \"loader\", \"origin\", and "
"\"has_location\" attributes are consulted."
msgstr ""
"如果模組具有 ``__spec__`` 屬性，規範中的資訊將用於生成 "
"repr。參考“名稱”、“加載器”、“來源”和“has_location”屬性。"

#: ../../reference/import.rst:671
#, fuzzy
msgid ""
"If the module has a ``__file__`` attribute, this is used as part of the "
"module's repr."
msgstr "如果模組有一個 ``__file__`` 屬性，這將用作模組 repr 的一部分。"

#: ../../reference/import.rst:674
#, fuzzy
msgid ""
"If the module has no ``__file__`` but does have a ``__loader__`` that is not "
"``None``, then the loader's repr is used as part of the module's repr."
msgstr ""
"如果模組沒有 ``__file__`` 但確實有一個 ``__loader__`` 不是 ``None``，"
"那麼加載程式的 repr 將用作模組 repr 的一部分。"

#: ../../reference/import.rst:677
#, fuzzy
msgid "Otherwise, just use the module's ``__name__`` in the repr."
msgstr "否則，只需在 repr 中使用模組的 __name__ 即可。"

#: ../../reference/import.rst:679
#, fuzzy
msgid ""
"Use of :meth:`loader.module_repr() <importlib.abc.Loader.module_repr>` has "
"been deprecated and the module spec is now used by the import machinery to "
"generate a module repr."
msgstr ""
":meth:`loader.module_repr() <importlib.abc.Loader.module_repr>` "
"的使用已被棄用，匯入機制現在使用模組規範來生成模組 repr。"

#: ../../reference/import.rst:684
#, fuzzy
msgid ""
"For backward compatibility with Python 3.3, the module repr will be "
"generated by calling the loader's :meth:`~importlib.abc.Loader.module_repr` "
"method, if defined, before trying either approach described above.  However, "
"the method is deprecated."
msgstr ""
"為了與 Python 3.3 向後相容，模組 repr 將通過呼叫加載器的 :meth:`~importlib."
"abc.Loader.module_repr` "
"方法（如果已定義）在嘗試上述任何一種方法之前生成。但是，該方法已被棄用。"

#: ../../reference/import.rst:691
#, fuzzy
msgid ""
"Calling :meth:`~importlib.abc.Loader.module_repr` now occurs after trying to "
"use a module's ``__spec__`` attribute but before falling back on "
"``__file__``. Use of :meth:`~importlib.abc.Loader.module_repr` is slated to "
"stop in Python 3.12."
msgstr ""
"呼叫 :meth:`~importlib.abc.Loader.module_repr` 現在發生在嘗試使用模組的 "
"``__spec__`` 屬性之後，但在回傳到 ``__file__`` 之前。 :meth:`~importlib.abc."
"Loader.module_repr` 的使用計劃在 Python 3.12 中停止。"

#: ../../reference/import.rst:699
#, fuzzy
msgid "Cached bytecode invalidation"
msgstr "快取位元組碼失效"

#: ../../reference/import.rst:701
#, fuzzy
msgid ""
"Before Python loads cached bytecode from a ``.pyc`` file, it checks whether "
"the cache is up-to-date with the source ``.py`` file. By default, Python "
"does this by storing the source's last-modified timestamp and size in the "
"cache file when writing it. At runtime, the import system then validates the "
"cache file by checking the stored metadata in the cache file against the "
"source's metadata."
msgstr ""
"在 Python 從 ``.pyc`` 文件加載快取的位元組碼之前，它會檢查快取是否與源 ``."
"py`` 文件保持同步。預設情況下，Python 通過在寫入時將源的最後修改時間戳和大小"
"儲存在快取文件中來實作這一點。在運行時，匯入系統然後通過根據源的元資料檢查快"
"取文件中儲存的元資料來驗證快取文件。"

#: ../../reference/import.rst:708
#, fuzzy
msgid ""
"Python also supports \"hash-based\" cache files, which store a hash of the "
"source file's contents rather than its metadata. There are two variants of "
"hash-based ``.pyc`` files: checked and unchecked. For checked hash-based ``."
"pyc`` files, Python validates the cache file by hashing the source file and "
"comparing the resulting hash with the hash in the cache file. If a checked "
"hash-based cache file is found to be invalid, Python regenerates it and "
"writes a new checked hash-based cache file. For unchecked hash-based ``."
"pyc`` files, Python simply assumes the cache file is valid if it exists. "
"Hash-based ``.pyc`` files validation behavior may be overridden with the :"
"option:`--check-hash-based-pycs` flag."
msgstr ""
"Python 還支援“基於散列”的快取文件，它儲存源文件內容的散列而不是其元資料。"
"基於散列的 .pyc 文件有兩種變體：選中和未選中。對於已檢查的基於雜湊的“."
"pyc”文件，Python 通過對源文件進行雜湊處理並將生成的雜湊值與快取文件中的雜湊值"
"進行比較來驗證快取文件。如果發現已檢查的基於雜湊的快取文件無效，Python "
"會重新生成它並寫入一個新的已檢查的基於雜湊的快取文件。"
"對於未經檢查的基於散列的 .pyc 文件，Python "
"簡單地假定快取文件在存在時是有效的。基於雜湊的``.pyc`` 文件驗證行為可能會被 "
":option:`--check-hash-based-pycs` 旗標覆蓋。"

#: ../../reference/import.rst:719
#, fuzzy
msgid ""
"Added hash-based ``.pyc`` files. Previously, Python only supported timestamp-"
"based invalidation of bytecode caches."
msgstr "新增了基於散列的 ``.pyc`` 文件。以前，Python "
"只支援基於時間戳的位元組碼快取失效。"

#: ../../reference/import.rst:725
#, fuzzy
msgid "The Path Based Finder"
msgstr "基於路徑的查找器"

#: ../../reference/import.rst:730
#, fuzzy
msgid ""
"As mentioned previously, Python comes with several default meta path "
"finders. One of these, called the :term:`path based finder` (:class:"
"`~importlib.machinery.PathFinder`), searches an :term:`import path`, which "
"contains a list of :term:`path entries <path entry>`.  Each path entry names "
"a location to search for modules."
msgstr ""
"如前所述，Python "
"帶有幾個預設的元路徑查找器。其中之一，稱為基於路徑的查找器（類：~importlib."
"machinery.PathFinder），搜索一個匯入路徑，其中包含一個路徑條目列表<路徑條目>`"
"。每個路徑條目命名一個位置來搜索模組。"

#: ../../reference/import.rst:736
#, fuzzy
msgid ""
"The path based finder itself doesn't know how to import anything. Instead, "
"it traverses the individual path entries, associating each of them with a "
"path entry finder that knows how to handle that particular kind of path."
msgstr "基於路徑的查找器本身不知道如何匯入任何東西。相反，它遍歷各個路徑條目，將它們"
"中的每一個與知道如何處理該特定型別路徑的路徑條目查找器相關聯。"

#: ../../reference/import.rst:740
#, fuzzy
msgid ""
"The default set of path entry finders implement all the semantics for "
"finding modules on the file system, handling special file types such as "
"Python source code (``.py`` files), Python byte code (``.pyc`` files) and "
"shared libraries (e.g. ``.so`` files). When supported by the :mod:"
"`zipimport` module in the standard library, the default path entry finders "
"also handle loading all of these file types (other than shared libraries) "
"from zipfiles."
msgstr ""
"預設的路徑條目查找器集實作了在文件系統上查找模組的所有語義，處理特殊文件型別"
"，例如 Python 源程式碼（``.py`` 文件）、Python 位元組碼（``.pyc`` "
"文件）和共享庫（例如 ``.so`` 文件）。當標準庫中的 :mod:`zipimport` "
"模組支援時，預設路徑條目查找器還處理從 zipfiles "
"加載所有這些文件型別（共享庫除外）。"

#: ../../reference/import.rst:747
#, fuzzy
msgid ""
"Path entries need not be limited to file system locations.  They can refer "
"to URLs, database queries, or any other location that can be specified as a "
"string."
msgstr "路徑條目不必限於文件系統位置。它們可以引用 "
"URL、資料庫查詢或任何其他可以指定為字串的位置。"

#: ../../reference/import.rst:751
#, fuzzy
msgid ""
"The path based finder provides additional hooks and protocols so that you "
"can extend and customize the types of searchable path entries.  For example, "
"if you wanted to support path entries as network URLs, you could write a "
"hook that implements HTTP semantics to find modules on the web.  This hook "
"(a callable) would return a :term:`path entry finder` supporting the "
"protocol described below, which was then used to get a loader for the module "
"from the web."
msgstr ""
"基於路徑的查找器提供了額外的掛鉤和協定，以便您可以擴充和自定義可搜索路徑條目"
"的型別。例如，如果你想支援路徑條目作為網絡 URL，你可以編寫一個實作 HTTP "
"語義的鉤子來查找網絡上的模組。這個鉤子（一個可呼叫的）"
"將回傳一個支援下面描述的協定的 :term:`path entry finder`，然後用於從 web "
"獲取模組的加載器。"

#: ../../reference/import.rst:759
#, fuzzy
msgid ""
"A word of warning: this section and the previous both use the term *finder*, "
"distinguishing between them by using the terms :term:`meta path finder` and :"
"term:`path entry finder`.  These two types of finders are very similar, "
"support similar protocols, and function in similar ways during the import "
"process, but it's important to keep in mind that they are subtly different. "
"In particular, meta path finders operate at the beginning of the import "
"process, as keyed off the :data:`sys.meta_path` traversal."
msgstr ""
"一句警告：本節和上一節都使用術語 *finder*，通過使用術語 :term:`meta path "
"finder` 和 :term:`path entry finder` 來區分它們。這兩種型別的查找器非常相似，"
"支援相似的協定，並且在匯入過程中以相似的方式運行，但重要的是要記住它們有細微"
"的不同。特別是，元路徑查找器在匯入過程開始時運行，作為 :data:`sys.meta_path` "
"遍歷的關鍵。"

#: ../../reference/import.rst:767
#, fuzzy
msgid ""
"By contrast, path entry finders are in a sense an implementation detail of "
"the path based finder, and in fact, if the path based finder were to be "
"removed from :data:`sys.meta_path`, none of the path entry finder semantics "
"would be invoked."
msgstr ""
"相比之下，路徑入口查找器在某種意義上是基於路徑的查找器的實作細節，事實上，"
"如果基於路徑的查找器要從 :data:`sys.meta_path` "
"中刪除，則路徑入口查找器語義都不會被呼叫。"

#: ../../reference/import.rst:774
#, fuzzy
msgid "Path entry finders"
msgstr "路徑條目查找器"

#: ../../reference/import.rst:782
#, fuzzy
msgid ""
"The :term:`path based finder` is responsible for finding and loading Python "
"modules and packages whose location is specified with a string :term:`path "
"entry`.  Most path entries name locations in the file system, but they need "
"not be limited to this."
msgstr ""
":term:`path based finder` 負責查找和加載其位置由字串 :term:`path entry` "
"指定的 Python "
"模組和包。大多數路徑條目命名文件系統中的位置，但它們不必限於此。"

#: ../../reference/import.rst:787
#, fuzzy
msgid ""
"As a meta path finder, the :term:`path based finder` implements the :meth:"
"`~importlib.abc.MetaPathFinder.find_spec` protocol previously described, "
"however it exposes additional hooks that can be used to customize how "
"modules are found and loaded from the :term:`import path`."
msgstr ""
"作為元路徑查找器，:term:`path based finder` 實作了前面描述的 :meth:`~importlib"
".abc.MetaPathFinder.find_spec` 協定，但是它公開了額外的鉤子，"
"可用於自定義模組的查找方式和從 :term:`import path` 加載。"

#: ../../reference/import.rst:792
#, fuzzy
msgid ""
"Three variables are used by the :term:`path based finder`, :data:`sys."
"path`, :data:`sys.path_hooks` and :data:`sys.path_importer_cache`.  The "
"``__path__`` attributes on package objects are also used.  These provide "
"additional ways that the import machinery can be customized."
msgstr ""
":term:`path based finder`, :data:`sys.path`, :data:`sys.path_hooks` 和 "
":data:`sys.path_importer_cache` 使用了三個變數。還使用了包對像上的 __path__ "
"屬性。這些提供了可以定制進口機械的其他方式。"

#: ../../reference/import.rst:797
#, fuzzy
msgid ""
":data:`sys.path` contains a list of strings providing search locations for "
"modules and packages.  It is initialized from the :data:`PYTHONPATH` "
"environment variable and various other installation- and implementation-"
"specific defaults.  Entries in :data:`sys.path` can name directories on the "
"file system, zip files, and potentially other \"locations\" (see the :mod:"
"`site` module) that should be searched for modules, such as URLs, or "
"database queries.  Only strings should be present on :data:`sys.path`; all "
"other data types are ignored."
msgstr ""
":data:`sys.path` 包含一個字串列表，提供模組和包的搜索位置。它是從 PYTHONPATH "
"環境變數和各種其他特定於安裝和實作的預設值初始化的。 :data:`sys.path` "
"中的條目可以命名文件系統上的目錄、zip 文件和可能的其他“位置”（請參閱 "
":mod:`site` 模組）應該搜索模組，例如 URL，或者資料庫查詢。 :data:`sys.path` "
"中只應出現字串；所有其他資料型別都將被忽略。"

#: ../../reference/import.rst:806
#, fuzzy
msgid ""
"The :term:`path based finder` is a :term:`meta path finder`, so the import "
"machinery begins the :term:`import path` search by calling the path based "
"finder's :meth:`~importlib.machinery.PathFinder.find_spec` method as "
"described previously.  When the ``path`` argument to :meth:`~importlib."
"machinery.PathFinder.find_spec` is given, it will be a list of string paths "
"to traverse - typically a package's ``__path__`` attribute for an import "
"within that package.  If the ``path`` argument is ``None``, this indicates a "
"top level import and :data:`sys.path` is used."
msgstr ""
":term:`path based finder` 是一個 :term:`meta path finder`，"
"因此匯入機制通過呼叫基於路徑的 finder 的 :meth:`~"
"importlib.machinery.PathFinder 開始 :term:`import path` 搜索.find_spec` "
"方法，如前所述。當給出 :meth:`~importlib.machinery.PathFinder.find_spec` 的 "
"``path`` 參數時，它將是要遍歷的字串路徑列表 - 通常是一個包的 `__path__`` "
"屬性，用於其中的匯入包裹。如果 ``path`` 參數為 ``None``，"
"這表示頂級匯入並使用 :data:`sys.path`。"

#: ../../reference/import.rst:815
#, fuzzy
msgid ""
"The path based finder iterates over every entry in the search path, and for "
"each of these, looks for an appropriate :term:`path entry finder` (:class:"
"`~importlib.abc.PathEntryFinder`) for the path entry.  Because this can be "
"an expensive operation (e.g. there may be ``stat()`` call overheads for this "
"search), the path based finder maintains a cache mapping path entries to "
"path entry finders.  This cache is maintained in :data:`sys."
"path_importer_cache` (despite the name, this cache actually stores finder "
"objects rather than being limited to :term:`importer` objects). In this way, "
"the expensive search for a particular :term:`path entry` location's :term:"
"`path entry finder` need only be done once.  User code is free to remove "
"cache entries from :data:`sys.path_importer_cache` forcing the path based "
"finder to perform the path entry search again [#fnpic]_."
msgstr ""
"基於路徑的查找器遍歷搜索路徑中的每個條目，並為其中的每一個尋找合適的 :term:`"
"path entry finder` (:class:`~importlib.abc.PathEntryFinder`) "
"作為路徑條目。因為這可能是一項昂貴的操作（例如，此搜索可能有 ``stat()`` "
"呼叫開銷），基於路徑的查找器維護快取映射路徑條目到路徑條目查找器。此快取在 "
":data:`sys.path_importer_cache` 中維護（儘管名稱如此，"
"此快取實際上儲存查找器物件而不是僅限於 :term:`importer` "
"物件）。通過這種方式，對特定 :term:`path entry` 位置的 :term:`path entry "
"finder` 的昂貴搜索只需執行一次。使用者程式碼可以自由地從 :data:`sys."
"path_importer_cache` 中刪除快取條目，"
"強制基於路徑的查找器再次執行路徑條目搜索 [#fnpic]_。"

#: ../../reference/import.rst:828
#, fuzzy
msgid ""
"If the path entry is not present in the cache, the path based finder "
"iterates over every callable in :data:`sys.path_hooks`.  Each of the :term:"
"`path entry hooks <path entry hook>` in this list is called with a single "
"argument, the path entry to be searched.  This callable may either return a :"
"term:`path entry finder` that can handle the path entry, or it may raise :"
"exc:`ImportError`.  An :exc:`ImportError` is used by the path based finder "
"to signal that the hook cannot find a :term:`path entry finder` for that :"
"term:`path entry`.  The exception is ignored and :term:`import path` "
"iteration continues.  The hook should expect either a string or bytes "
"object; the encoding of bytes objects is up to the hook (e.g. it may be a "
"file system encoding, UTF-8, or something else), and if the hook cannot "
"decode the argument, it should raise :exc:`ImportError`."
msgstr ""
"如果快取中不存在路徑條目，則基於路徑的查找器將遍歷 :data:`sys.path_hooks` "
"中的每個可呼叫物件。此列表中的每個 :term:`path entry hooks <path entry hook>`"
" 都使用單個參數呼叫，即要搜索的路徑條目。這個可呼叫物件可能會回傳一個可以處理"
"路徑條目的路徑條目查找器，或者它可能會引發 :exec:`ImportError`。"
"基於路徑的查找器使用 :exc:`ImportError` 來表示鉤子無法找到該 :term:`path "
"entry` 的 :term:`path entry finder`。例外被忽略並且 :term:`import path` 疊代"
"繼續。鉤子應該期望一個字串或位元組物件；位元組物件的編碼取決於掛鉤（例如，它"
"可能是文件系統編碼、UTF-8 或其他編碼），如果掛鉤無法解碼參數，它應該引發 "
":exc:`ImportError`。"

#: ../../reference/import.rst:842
#, fuzzy
msgid ""
"If :data:`sys.path_hooks` iteration ends with no :term:`path entry finder` "
"being returned, then the path based finder's :meth:`~importlib.machinery."
"PathFinder.find_spec` method will store ``None`` in :data:`sys."
"path_importer_cache` (to indicate that there is no finder for this path "
"entry) and return ``None``, indicating that this :term:`meta path finder` "
"could not find the module."
msgstr ""
"如果 :data:`sys.path_hooks` 疊代結束時沒有回傳 :term:`path entry finder`，"
"那麼基於路徑的 finder 的 :meth:`~importlib.machinery.PathFinder.find_spec` "
"方法將儲存 ``None``在 :data:`sys.path_importer_cache` "
"中（表示此路徑條目沒有查找器）並回傳 ``None``，表示此 :term:`meta path "
"finder` 找不到模組。"

#: ../../reference/import.rst:849
#, fuzzy
msgid ""
"If a :term:`path entry finder` *is* returned by one of the :term:`path entry "
"hook` callables on :data:`sys.path_hooks`, then the following protocol is "
"used to ask the finder for a module spec, which is then used when loading "
"the module."
msgstr ""
"如果 :term:`path entry finder` *由 :term:`sys.path_hooks` 上的 :term:`path "
"entry hook` callables "
"之一回傳*，則以下協定用於向查找器詢問模組spec，然後在加載模組時使用。"

#: ../../reference/import.rst:854
#, fuzzy
msgid ""
"The current working directory -- denoted by an empty string -- is handled "
"slightly differently from other entries on :data:`sys.path`. First, if the "
"current working directory is found to not exist, no value is stored in :data:"
"`sys.path_importer_cache`. Second, the value for the current working "
"directory is looked up fresh for each module lookup. Third, the path used "
"for :data:`sys.path_importer_cache` and returned by :meth:`importlib."
"machinery.PathFinder.find_spec` will be the actual current working directory "
"and not the empty string."
msgstr ""
"當前工作目錄——由空字串表示——與 :data:`sys.path` "
"上的其他條目的處理方式略有不同。首先，如果發現當前工作目錄不存在，則不會在 "
":data:`sys.path_importer_cache` "
"中儲存任何值。其次，當前工作目錄的值在每次模組查找時都會被重新查找。第三，"
"用於 :data:`sys.path_importer_cache` 並由 :meth:`importlib.machinery."
"PathFinder.find_spec` 回傳的路徑將是實際的當前工作目錄，而不是空字串。"

#: ../../reference/import.rst:864
#, fuzzy
msgid "Path entry finder protocol"
msgstr "路徑條目查找器協定"

#: ../../reference/import.rst:866
#, fuzzy
msgid ""
"In order to support imports of modules and initialized packages and also to "
"contribute portions to namespace packages, path entry finders must implement "
"the :meth:`~importlib.abc.PathEntryFinder.find_spec` method."
msgstr ""
"為了支援模組和初始化包的匯入，並為命名空間包貢獻部分，路徑條目查找器必須實作:"
"meth:`~importlib.abc.PathEntryFinder.find_spec` 方法。"

#: ../../reference/import.rst:870
#, fuzzy
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` takes two arguments: the "
"fully qualified name of the module being imported, and the (optional) target "
"module.  ``find_spec()`` returns a fully populated spec for the module. This "
"spec will always have \"loader\" set (with one exception)."
msgstr ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` "
"有兩個參數：被匯入模組的完全限定名稱和（可選）目標模組。 ``find_spec()`` "
"回傳模組的完全填充規範。此規範將始終設定“加載程式”（有一個例外）。"

#: ../../reference/import.rst:875
#, fuzzy
msgid ""
"To indicate to the import machinery that the spec represents a namespace :"
"term:`portion`, the path entry finder sets \"submodule_search_locations\" to "
"a list containing the portion."
msgstr ""
"為了嚮匯入機製表明該規范代表一個命名空間 :term:`portion`，路徑條目查找器將“su"
"bmodule_search_locations”設定為包含該部分的列表。"

#: ../../reference/import.rst:879
#, fuzzy
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` replaced :meth:`~importlib."
"abc.PathEntryFinder.find_loader` and :meth:`~importlib.abc.PathEntryFinder."
"find_module`, both of which are now deprecated, but will be used if "
"``find_spec()`` is not defined."
msgstr ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` 替換了 :meth:`~importlib.abc"
".PathEntryFinder.find_loader` 和 :meth:`~importlib.abc.PathEntryFinder."
"find_module`，它們現在都已棄用，但是如果未定義 find_spec() 將被使用。"

#: ../../reference/import.rst:885
#, fuzzy
msgid ""
"Older path entry finders may implement one of these two deprecated methods "
"instead of ``find_spec()``.  The methods are still respected for the sake of "
"backward compatibility.  However, if ``find_spec()`` is implemented on the "
"path entry finder, the legacy methods are ignored."
msgstr ""
"較舊的路徑條目查找器可能會實作這兩個已棄用的方法之一，而不是“find_spec()”。為"
"了向後相容，這些方法仍然受到尊重。但是，如果在路徑條目查找器上實作了“find_spe"
"c()”，則遺留方法將被忽略。"

#: ../../reference/import.rst:890
#, fuzzy
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_loader` takes one argument, the "
"fully qualified name of the module being imported.  ``find_loader()`` "
"returns a 2-tuple where the first item is the loader and the second item is "
"a namespace :term:`portion`."
msgstr ""
":meth:`~importlib.abc.PathEntryFinder.find_loader` "
"接受一個參數，即被匯入模組的完全限定名稱。 ``find_loader()`` "
"回傳一個二元組，其中第一項是加載器，第二項是命名空間 :term:`portion`。"

#: ../../reference/import.rst:895
#, fuzzy
msgid ""
"For backwards compatibility with other implementations of the import "
"protocol, many path entry finders also support the same, traditional "
"``find_module()`` method that meta path finders support. However path entry "
"finder ``find_module()`` methods are never called with a ``path`` argument "
"(they are expected to record the appropriate path information from the "
"initial call to the path hook)."
msgstr ""
"為了與匯入協定的其他實作向後相容，許多路徑條目查找器也支援元路徑查找器支援的"
"相同的傳統“find_module()”方法。然而，路徑條目查找器“find_module()”方法永遠不"
"會使用 ``path``參數呼叫（它們應該記錄從初始呼叫到路徑掛鉤的適當路徑資訊）。"

#: ../../reference/import.rst:902
#, fuzzy
msgid ""
"The ``find_module()`` method on path entry finders is deprecated, as it does "
"not allow the path entry finder to contribute portions to namespace "
"packages.  If both ``find_loader()`` and ``find_module()`` exist on a path "
"entry finder, the import system will always call ``find_loader()`` in "
"preference to ``find_module()``."
msgstr ""
"路徑條目查找器上的 ``find_module()`` "
"方法已被棄用，因為它不允許路徑條目查找器將部分內容貢獻給命名空間包。如果 "
"``find_loader()`` 和 ``find_module()`` 都存在於路徑條目查找器中，"
"匯入系統將始終呼叫 ``find_loader()`` 而不是 ``find_module()``。"

#: ../../reference/import.rst:908
#, fuzzy
msgid ""
"Calls to :meth:`~importlib.abc.PathEntryFinder.find_module` and :meth:"
"`~importlib.abc.PathEntryFinder.find_loader` by the import system will "
"raise :exc:`ImportWarning`."
msgstr ""
"匯入系統呼叫 :meth:`~importlib.abc.PathEntryFinder.find_module` 和 "
":meth:`~importlib.abc.PathEntryFinder.find_loader` 將引發 "
":exc:`ImportWarning`。"

#: ../../reference/import.rst:915
#, fuzzy
msgid "Replacing the standard import system"
msgstr "替換標準匯入系統"

#: ../../reference/import.rst:917
#, fuzzy
msgid ""
"The most reliable mechanism for replacing the entire import system is to "
"delete the default contents of :data:`sys.meta_path`, replacing them "
"entirely with a custom meta path hook."
msgstr "替換整個匯入系統的最可靠機制是刪除 :data:`sys.meta_path` "
"的預設內容，將它們完全替換為自定義元路徑掛鉤。"

#: ../../reference/import.rst:921
#, fuzzy
msgid ""
"If it is acceptable to only alter the behaviour of import statements without "
"affecting other APIs that access the import system, then replacing the "
"builtin :func:`__import__` function may be sufficient. This technique may "
"also be employed at the module level to only alter the behaviour of import "
"statements within that module."
msgstr ""
"如果只改變匯入語句的行為而不影響訪問匯入系統的其他 API 是可以接受的，"
"那麼替換內建 :func:`__import__` 函式可能就足夠了。這種技術也可以在模組級別使"
"用，以僅更改該模組內匯入語句的行為。"

#: ../../reference/import.rst:927
#, fuzzy
msgid ""
"To selectively prevent the import of some modules from a hook early on the "
"meta path (rather than disabling the standard import system entirely), it is "
"sufficient to raise :exc:`ModuleNotFoundError` directly from :meth:"
"`~importlib.abc.MetaPathFinder.find_spec` instead of returning ``None``. The "
"latter indicates that the meta path search should continue, while raising an "
"exception terminates it immediately."
msgstr ""
"要有選擇地阻止從元路徑早期的鉤子匯入某些模組（而不是完全禁用標準匯入系統），"
"直接從 :exc:`~importlib.abc.MetaPathFinder 引發 ModuleNotFoundError` 就足夠了"
".find_spec` 而不是回傳 "
"``None``。後者表示元路徑搜索應該繼續，同時引發例外會立即終止它。"

#: ../../reference/import.rst:937
#, fuzzy
msgid "Package Relative Imports"
msgstr "包相關匯入"

#: ../../reference/import.rst:939
#, fuzzy
msgid ""
"Relative imports use leading dots. A single leading dot indicates a relative "
"import, starting with the current package. Two or more leading dots indicate "
"a relative import to the parent(s) of the current package, one level per dot "
"after the first. For example, given the following package layout::"
msgstr ""
"相對匯入使用前導點。單個前導點表示相對匯入，從當前包開始。兩個或多個前導點表"
"示對當前包的父級的相對匯入，第一個之後每個點一個級別。例如，給定以下包佈局："

#: ../../reference/import.rst:955
#, fuzzy
msgid ""
"In either ``subpackage1/moduleX.py`` or ``subpackage1/__init__.py``, the "
"following are valid relative imports::"
msgstr ""
"在 ``subpackage1/moduleX.py`` 或 ``subpackage1/__init__.py`` "
"中，以下是有效的相對匯入："

#: ../../reference/import.rst:965
#, fuzzy
msgid ""
"Absolute imports may use either the ``import <>`` or ``from <> import <>`` "
"syntax, but relative imports may only use the second form; the reason for "
"this is that::"
msgstr "絕對匯入可以使用``import <>`` 或``from <> import <>`` "
"語法，但相對匯入只能使用第二種形式；這樣做的原因是："

#: ../../reference/import.rst:971
#, fuzzy
msgid ""
"should expose ``XXX.YYY.ZZZ`` as a usable expression, but .moduleY is not a "
"valid expression."
msgstr "應將 ``XXX.YYY.ZZZ`` 公開為可用表達式，但 .moduleY 不是有效表達式。"

#: ../../reference/import.rst:978
#, fuzzy
msgid "Special considerations for __main__"
msgstr "__main__ 的特殊注意事項"

#: ../../reference/import.rst:980
#, fuzzy
msgid ""
"The :mod:`__main__` module is a special case relative to Python's import "
"system.  As noted :ref:`elsewhere <programs>`, the ``__main__`` module is "
"directly initialized at interpreter startup, much like :mod:`sys` and :mod:"
"`builtins`.  However, unlike those two, it doesn't strictly qualify as a "
"built-in module.  This is because the manner in which ``__main__`` is "
"initialized depends on the flags and other options with which the "
"interpreter is invoked."
msgstr ""
":mod:`__main__` 模組是相對於 Python 匯入系統的特例。如 :ref:`elsewhere "
"<programs>` 所述，``__main__`` 模組在直譯器啟動時直接初始化，很像 :mod:`sys` "
"和 :mod:`builtins`。但是，與這兩個不同，它嚴格來說不符合內建模組的條件。"
"這是因為 ``__main__`` 的初始化方式取決於呼叫直譯器的旗標和其他選項。"

#: ../../reference/import.rst:991
msgid "__main__.__spec__"
msgstr "__main__.__spec__"

#: ../../reference/import.rst:993
#, fuzzy
msgid ""
"Depending on how :mod:`__main__` is initialized, ``__main__.__spec__`` gets "
"set appropriately or to ``None``."
msgstr "根據 :mod:`__main__` 的初始化方式，``__main__.__spec__`` 被適當設定或設定為 "
"``None``。"

#: ../../reference/import.rst:996
#, fuzzy
msgid ""
"When Python is started with the :option:`-m` option, ``__spec__`` is set to "
"the module spec of the corresponding module or package. ``__spec__`` is also "
"populated when the ``__main__`` module is loaded as part of executing a "
"directory, zipfile or other :data:`sys.path` entry."
msgstr ""
"當使用 :option:`-m` 選項啟動 Python 時，``__spec__`` "
"被設定為相應模組或包的模組規範。 ``__spec__`` 也會在 ``__main__`` "
"模組作為執行目錄、壓縮文件或其他 :data:`sys.path` 條目的一部分加載時填充。"

#: ../../reference/import.rst:1001
#, fuzzy
msgid ""
"In :ref:`the remaining cases <using-on-interface-options>` ``__main__."
"__spec__`` is set to ``None``, as the code used to populate the :mod:"
"`__main__` does not correspond directly with an importable module:"
msgstr ""
"在 :ref:` 其餘情況 <using-on-interface-options>` ``__main__.__spec__`` "
"設定為 ``None``，因為用於填充 :mod:`__main__` "
"的程式碼不對應直接使用可匯入模組："

#: ../../reference/import.rst:1005
#, fuzzy
msgid "interactive prompt"
msgstr "交互式提示"

#: ../../reference/import.rst:1006
msgid ":option:`-c` option"
msgstr ":option:`-c` 選項"

#: ../../reference/import.rst:1007
#, fuzzy
msgid "running from stdin"
msgstr "從標準輸入運行"

#: ../../reference/import.rst:1008
#, fuzzy
msgid "running directly from a source or bytecode file"
msgstr "直接從源程式碼或位元組碼文件運行"

#: ../../reference/import.rst:1010
#, fuzzy
msgid ""
"Note that ``__main__.__spec__`` is always ``None`` in the last case, *even "
"if* the file could technically be imported directly as a module instead. Use "
"the :option:`-m` switch if valid module metadata is desired in :mod:"
"`__main__`."
msgstr ""
"請注意，``__main__.__spec__`` 在最後一種情況下始終為 "
"``None``，*即使*該文件在技術上可以直接作為模組匯入。如果在 :mod:`__main__` "
"中需要有效的模組元資料，請使用 :option:`-m` 開關。"

#: ../../reference/import.rst:1015
#, fuzzy
msgid ""
"Note also that even when ``__main__`` corresponds with an importable module "
"and ``__main__.__spec__`` is set accordingly, they're still considered "
"*distinct* modules. This is due to the fact that blocks guarded by ``if "
"__name__ == \"__main__\":`` checks only execute when the module is used to "
"populate the ``__main__`` namespace, and not during normal import."
msgstr ""
"還要注意，即使 ``__main__`` 對應於一個可匯入模組並且 ``__main__.__spec__`` "
"被相應地設定，它們仍然被認為是 *distinct* 模組。這是因為由 ``if __name__ == "
"\"__main__\":`` 保護的塊檢查僅在模組用於填充 ``__main__`` "
"命名空間時執行，而不是在正常匯入期間執行。"

#: ../../reference/import.rst:1023
#, fuzzy
msgid "References"
msgstr "參考"

#: ../../reference/import.rst:1025
#, fuzzy
msgid ""
"The import machinery has evolved considerably since Python's early days.  "
"The original `specification for packages <https://www.python.org/doc/essays/"
"packages/>`_ is still available to read, although some details have changed "
"since the writing of that document."
msgstr ""
"自 Python 早期以來，匯入機制已經有了很大的發展。原始的`包規範 <https://www."
"python.org/doc/essays/packages/>`_ "
"仍然可供閱讀，儘管自該文檔編寫以來一些細節已經改變。"

#: ../../reference/import.rst:1030
#, fuzzy
msgid ""
"The original specification for :data:`sys.meta_path` was :pep:`302`, with "
"subsequent extension in :pep:`420`."
msgstr ":data:`sys.meta_path` 的原始規範是 :pep:`302`，隨後擴充為 :pep:`420`。"

#: ../../reference/import.rst:1033
#, fuzzy
msgid ""
":pep:`420` introduced :term:`namespace packages <namespace package>` for "
"Python 3.3.  :pep:`420` also introduced the :meth:`find_loader` protocol as "
"an alternative to :meth:`find_module`."
msgstr ""
":pep:`420` 為 Python 3.3 引入了 :term:`namespace packages <namespace "
"package>`。 :pep:`420` 還引入了 :meth:`find_loader` 協定作為 "
":meth:`find_module` 的替代方案。"

#: ../../reference/import.rst:1037
#, fuzzy
msgid ""
":pep:`366` describes the addition of the ``__package__`` attribute for "
"explicit relative imports in main modules."
msgstr ":pep:`366` 描述了在主模組中為顯式相對匯入新增 ``__package__`` 屬性。"

#: ../../reference/import.rst:1040
#, fuzzy
msgid ""
":pep:`328` introduced absolute and explicit relative imports and initially "
"proposed ``__name__`` for semantics :pep:`366` would eventually specify for "
"``__package__``."
msgstr ""
":pep:`328` 引入了絕對和顯式相對匯入，最初為語義提出了 ``__name__`` :pep:`366`"
" 最終將指定用於 ``__package__``。"

#: ../../reference/import.rst:1044
#, fuzzy
msgid ":pep:`338` defines executing modules as scripts."
msgstr ":pep:`338` 將執行模組定義為腳本。"

#: ../../reference/import.rst:1046
#, fuzzy
msgid ""
":pep:`451` adds the encapsulation of per-module import state in spec "
"objects.  It also off-loads most of the boilerplate responsibilities of "
"loaders back onto the import machinery.  These changes allow the deprecation "
"of several APIs in the import system and also addition of new methods to "
"finders and loaders."
msgstr ""
":pep:`451` 在規範對像中新增每個模組匯入狀態的封裝。它還將裝載機的大部分樣板責"
"任卸載回進口機器。這些更改允許在匯入系統中棄用多個 "
"API，並向查找器和加載器新增新方法。"

#: ../../reference/import.rst:1053
msgid "Footnotes"
msgstr "註解"

#: ../../reference/import.rst:1054
msgid "See :class:`types.ModuleType`."
msgstr "參閱 :class:`types.ModuleType`\\ 。"

#: ../../reference/import.rst:1056
#, fuzzy
msgid ""
"The importlib implementation avoids using the return value directly. "
"Instead, it gets the module object by looking the module name up in :data:"
"`sys.modules`.  The indirect effect of this is that an imported module may "
"replace itself in :data:`sys.modules`.  This is implementation-specific "
"behavior that is not guaranteed to work in other Python implementations."
msgstr ""
"importlib 實作避免直接使用回傳值。相反，它通過在 :data:`sys.modules` "
"中查找模組名稱來獲取模組物件。這樣做的間接影響是匯入的模組可能會在 :data:`sys"
".modules` 中替換自身。這是特定於實作的行為，不能保證在其他 Python "
"實作中起作用。"

#: ../../reference/import.rst:1063
#, fuzzy
msgid ""
"In legacy code, it is possible to find instances of :class:`imp."
"NullImporter` in the :data:`sys.path_importer_cache`.  It is recommended "
"that code be changed to use ``None`` instead.  See :ref:`portingpythoncode` "
"for more details."
msgstr ""
"在遺留程式碼中，可以在 sys.path_importer_cache 中找到 imp.NullImporter 的實例"
"。建議將程式碼更改為使用 ``None`` 。有關詳細資訊，請參閱 :ref:`portingpythoncode`"
"。"
