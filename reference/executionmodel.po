# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-23 00:16+0000\n"
"PO-Revision-Date: 2018-05-23 16:17+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../reference/executionmodel.rst:6
#, fuzzy
msgid "Execution model"
msgstr "執行模型"

#: ../../reference/executionmodel.rst:15
#, fuzzy
msgid "Structure of a program"
msgstr "程式結構"

#: ../../reference/executionmodel.rst:19
#, fuzzy
msgid ""
"A Python program is constructed from code blocks. A :dfn:`block` is a piece "
"of Python program text that is executed as a unit. The following are blocks: "
"a module, a function body, and a class definition. Each command typed "
"interactively is a block.  A script file (a file given as standard input to "
"the interpreter or specified as a command line argument to the interpreter) "
"is a code block.  A script command (a command specified on the interpreter "
"command line with the :option:`-c` option) is a code block. A module run as "
"a top level script (as module ``__main__``) from the command line using a :"
"option:`-m` argument is also a code block. The string argument passed to the "
"built-in functions :func:`eval` and :func:`exec` is a code block."
msgstr ""
"Python 程式由程式碼塊構成。 :dfn:`block` 是作為一個單元執行的一段 Python 程式"
"文本。以下是塊：模組、函式體和類定義。交互鍵入的每個命令都是一個塊。腳本文件"
"（作為直譯器的標準輸入或指定為直譯器的命令列參數的文件）是一個程式碼塊。腳本"
"命令（在直譯器命令列上使用 :option:`-c` 選項指定的命令）是一個程式碼塊。使"
"用 :option:`-m` 參數從命令列作為頂級腳本（作為模組 __main__``）運行的模組也是"
"一個程式碼塊。傳遞給內建函式 :func:`eval` 和 :func:`exec` 的字串參數是一個程"
"式碼塊。"

#: ../../reference/executionmodel.rst:33
#, fuzzy
msgid ""
"A code block is executed in an :dfn:`execution frame`.  A frame contains "
"some administrative information (used for debugging) and determines where "
"and how execution continues after the code block's execution has completed."
msgstr "程式碼塊在 :dfn:`執行框架` 中執行。框架包含一些管理資訊（用於除錯）並確定在程"
"式碼塊執行完成後繼續執行的位置和方式。"

#: ../../reference/executionmodel.rst:40
#, fuzzy
msgid "Naming and binding"
msgstr "命名和綁定"

#: ../../reference/executionmodel.rst:49
#, fuzzy
msgid "Binding of names"
msgstr "姓名綁定"

#: ../../reference/executionmodel.rst:55
#, fuzzy
msgid ""
":dfn:`Names` refer to objects.  Names are introduced by name binding "
"operations."
msgstr ":dfn:`Names` 是指物件。名稱由名稱綁定操作引入。"

#: ../../reference/executionmodel.rst:59
#, fuzzy
msgid "The following constructs bind names:"
msgstr "以下構造綁定名稱："

#: ../../reference/executionmodel.rst:61
#, fuzzy
msgid "formal parameters to functions,"
msgstr "函式的形式參數，"

#: ../../reference/executionmodel.rst:62
#, fuzzy
msgid "class definitions,"
msgstr "類定義，"

#: ../../reference/executionmodel.rst:63
#, fuzzy
msgid "function definitions,"
msgstr "功能定義，"

#: ../../reference/executionmodel.rst:64
#, fuzzy
msgid "assignment expressions,"
msgstr "賦值表達式，"

#: ../../reference/executionmodel.rst:65
#, fuzzy
msgid ""
":ref:`targets <assignment>` that are identifiers if occurring in an "
"assignment:"
msgstr ":ref:`targets <assignment>` 如果出現在賦值中則為標識符："

#: ../../reference/executionmodel.rst:68
#, fuzzy
msgid ":keyword:`for` loop header,"
msgstr ":keyword:`for` 循環頭，"

#: ../../reference/executionmodel.rst:69
#, fuzzy
msgid ""
"after :keyword:`!as` in a :keyword:`with` statement, :keyword:`except` "
"clause, :keyword:`except* <except_star>` clause, or in the as-pattern in "
"structural pattern matching,"
msgstr ""
"在 :keyword:`with` 語句中的 :keyword:`!as` 之後， :keyword:`except` 子句， :"
"keyword:`except* <except_star>` 子句中，或在結構模式匹配中的 as-pattern 中，"

#: ../../reference/executionmodel.rst:71
#, fuzzy
msgid "in a capture pattern in structural pattern matching"
msgstr "在結構模式匹配中的捕獲模式中"

#: ../../reference/executionmodel.rst:73
#, fuzzy
msgid ":keyword:`import` statements."
msgstr ":keyword:`import` 語句。"

#: ../../reference/executionmodel.rst:75
#, fuzzy
msgid ""
"The :keyword:`!import` statement of the form ``from ... import *`` binds all "
"names defined in the imported module, except those beginning with an "
"underscore. This form may only be used at the module level."
msgstr ""
"``from ... import *`` 形式的 :keyword:`!import` 語句綁定導入模組中定義的所有"
"名稱，以底線開頭的除外。這種形式只能在模組級別使用。"

#: ../../reference/executionmodel.rst:79
#, fuzzy
msgid ""
"A target occurring in a :keyword:`del` statement is also considered bound "
"for this purpose (though the actual semantics are to unbind the name)."
msgstr ""
"出現在 :keyword:`del` 語句中的目標也被認為是為此目的而綁定的（儘管實際語義是"
"取消綁定名稱）。"

#: ../../reference/executionmodel.rst:82
#, fuzzy
msgid ""
"Each assignment or import statement occurs within a block defined by a class "
"or function definition or at the module level (the top-level code block)."
msgstr ""
"每個賦值或導入語句都出現在由類或函式定義定義的塊中，或者出現在模組級別（頂級"
"程式碼塊）。"

#: ../../reference/executionmodel.rst:87
#, fuzzy
msgid ""
"If a name is bound in a block, it is a local variable of that block, unless "
"declared as :keyword:`nonlocal` or :keyword:`global`.  If a name is bound at "
"the module level, it is a global variable.  (The variables of the module "
"code block are local and global.)  If a variable is used in a code block but "
"not defined there, it is a :dfn:`free variable`."
msgstr ""
"如果名稱綁定在塊中，則它是該塊的局部變數，除非聲明為 :keyword:`nonlocal` 或 :"
"keyword:`global`。如果名稱綁定在模組級別，則它是一個全局變數。 （模組程式碼塊"
"的變數是局部的和全局的。）如果一個變數在程式碼塊中使用但沒有在那裡定義，它是"
"一個 :dfn:`自由變數`。"

#: ../../reference/executionmodel.rst:93
#, fuzzy
msgid ""
"Each occurrence of a name in the program text refers to the :dfn:`binding` "
"of that name established by the following name resolution rules."
msgstr ""
"程式文本中每次出現的名稱都是指由以下名稱解析規則建立的該名稱的 :dfn:"
"`binding`。"

#: ../../reference/executionmodel.rst:99
#, fuzzy
msgid "Resolution of names"
msgstr "名稱解析"

#: ../../reference/executionmodel.rst:103
#, fuzzy
msgid ""
"A :dfn:`scope` defines the visibility of a name within a block.  If a local "
"variable is defined in a block, its scope includes that block.  If the "
"definition occurs in a function block, the scope extends to any blocks "
"contained within the defining one, unless a contained block introduces a "
"different binding for the name."
msgstr ""
":dfn:`scope` 定義塊中名稱的可見性。如果在塊中定義局部變數，則其作用域包括該"
"塊。如果定義出現在功能塊中，則範圍擴充到定義塊中包含的任何塊，除非包含的塊為"
"名稱引入了不同的綁定。"

#: ../../reference/executionmodel.rst:111
#, fuzzy
msgid ""
"When a name is used in a code block, it is resolved using the nearest "
"enclosing scope.  The set of all such scopes visible to a code block is "
"called the block's :dfn:`environment`."
msgstr ""
"當在程式碼塊中使用一個名稱時，它會使用最近的封閉範圍進行解析。程式碼塊可見的"
"所有此類範圍的集合稱為塊的 :dfn:`environment`。"

#: ../../reference/executionmodel.rst:119
#, fuzzy
msgid ""
"When a name is not found at all, a :exc:`NameError` exception is raised. If "
"the current scope is a function scope, and the name refers to a local "
"variable that has not yet been bound to a value at the point where the name "
"is used, an :exc:`UnboundLocalError` exception is raised. :exc:"
"`UnboundLocalError` is a subclass of :exc:`NameError`."
msgstr ""
"如果根本找不到名稱，則會引發 :exc:`NameError` 例外。如果當前作用域是一個函式"
"作用域，並且該名稱引用的局部變數在使用該名稱時尚未綁定到某個值，則會引發 :"
"exc:`UnboundLocalError` 例外。 :exc:`UnboundLocalError` 是 :exc:`NameError` "
"的子類別。"

#: ../../reference/executionmodel.rst:125
#, fuzzy
msgid ""
"If a name binding operation occurs anywhere within a code block, all uses of "
"the name within the block are treated as references to the current block.  "
"This can lead to errors when a name is used within a block before it is "
"bound.  This rule is subtle.  Python lacks declarations and allows name "
"binding operations to occur anywhere within a code block.  The local "
"variables of a code block can be determined by scanning the entire text of "
"the block for name binding operations. See :ref:`the FAQ entry on "
"UnboundLocalError <faq-unboundlocalerror>` for examples."
msgstr ""
"如果名稱綁定操作發生在程式碼塊中的任何位置，則塊中名稱的所有使用都被視為對當"
"前塊的引用。當名稱在綁定之前在塊中使用時，這可能會導致錯誤。這個規則很微妙。 "
"Python 缺少聲明並允許名稱綁定操作發生在程式碼塊中的任何位置。程式碼塊的局部變"
"數可以通過掃描塊的整個文本以進行名稱綁定操作來確定。有關示例，請參閱 :ref:`關"
"於 UnboundLocalError <faq-unboundlocalerror>` 的 FAQ 條目。"

#: ../../reference/executionmodel.rst:134
#, fuzzy
msgid ""
"If the :keyword:`global` statement occurs within a block, all uses of the "
"names specified in the statement refer to the bindings of those names in the "
"top-level namespace.  Names are resolved in the top-level namespace by "
"searching the global namespace, i.e. the namespace of the module containing "
"the code block, and the builtins namespace, the namespace of the module :mod:"
"`builtins`.  The global namespace is searched first.  If the names are not "
"found there, the builtins namespace is searched.  The :keyword:`!global` "
"statement must precede all uses of the listed names."
msgstr ""
"如果 :keyword:`global` 語句出現在一個塊中，則語句中指定名稱的所有使用都指的是"
"頂級命名空間中這些名稱的綁定。通過搜索全局命名空間（即包含程式碼塊的模組的命"
"名空間）和內建命名空間（模組 :mod:`builtins` 的命名空間）在頂級命名空間中解析"
"名稱。首先搜索全局命名空間。如果在那裡找不到名稱，則搜索內建命名空間。 :"
"keyword:`!global` 語句必須在所有使用列出的名稱之前。"

#: ../../reference/executionmodel.rst:143
#, fuzzy
msgid ""
"The :keyword:`global` statement has the same scope as a name binding "
"operation in the same block.  If the nearest enclosing scope for a free "
"variable contains a global statement, the free variable is treated as a "
"global."
msgstr ""
":keyword:`global` 語句與同一塊中的名稱綁定操作具有相同的作用域。如果自由變數"
"的最近封閉範圍包含全局語句，則自由變數被視為全局變數。"

#: ../../reference/executionmodel.rst:149
#, fuzzy
msgid ""
"The :keyword:`nonlocal` statement causes corresponding names to refer to "
"previously bound variables in the nearest enclosing function scope. :exc:"
"`SyntaxError` is raised at compile time if the given name does not exist in "
"any enclosing function scope."
msgstr ""
":keyword:`nonlocal` 語句導致相應的名稱引用最近的封閉函式作用域中先前綁定的變"
"數。 :exc:`SyntaxError` 如果給定名稱不存在於任何封閉函式範圍內，則會在編譯時"
"引發。"

#: ../../reference/executionmodel.rst:156
#, fuzzy
msgid ""
"The namespace for a module is automatically created the first time a module "
"is imported.  The main module for a script is always called :mod:`__main__`."
msgstr ""
"模組的命名空間在第一次導入模組時自動建立。腳本的主模組始終稱為 :mod:"
"`__main__`。"

#: ../../reference/executionmodel.rst:159
#, fuzzy
msgid ""
"Class definition blocks and arguments to :func:`exec` and :func:`eval` are "
"special in the context of name resolution. A class definition is an "
"executable statement that may use and define names. These references follow "
"the normal rules for name resolution with an exception that unbound local "
"variables are looked up in the global namespace. The namespace of the class "
"definition becomes the attribute dictionary of the class. The scope of names "
"defined in a class block is limited to the class block; it does not extend "
"to the code blocks of methods -- this includes comprehensions and generator "
"expressions since they are implemented using a function scope.  This means "
"that the following will fail::"
msgstr ""
":func:`exec` 和 :func:`eval` 的類定義塊和參數在名稱解析上下文中是特殊的。類定"
"義是可以使用和定義名稱的可執行語句。這些引用遵循名稱解析的一般規則，但在全局"
"命名空間中查找未綁定的局部變數除外。類定義的命名空間成為類的屬性字典。類塊中"
"定義的名稱範圍僅限於類塊；它不會擴充到方法的程式碼塊——這包括理解和生成器表達"
"式，因為它們是使用函式作用域實作的。這意味著以下將失敗::"

#: ../../reference/executionmodel.rst:177
#, fuzzy
msgid "Builtins and restricted execution"
msgstr "內建和受限執行"

#: ../../reference/executionmodel.rst:183
#, fuzzy
msgid ""
"Users should not touch ``__builtins__``; it is strictly an implementation "
"detail.  Users wanting to override values in the builtins namespace should :"
"keyword:`import` the :mod:`builtins` module and modify its attributes "
"appropriately."
msgstr ""
"使用者不應觸摸 ``__builtins__``；它嚴格來說是一個實作細節。想要覆蓋 builtins "
"命名空間中的值的使用者應該 :keyword:`import` :mod:`builtins` 模組並適當地修改"
"它的屬性。"

#: ../../reference/executionmodel.rst:188
#, fuzzy
msgid ""
"The builtins namespace associated with the execution of a code block is "
"actually found by looking up the name ``__builtins__`` in its global "
"namespace; this should be a dictionary or a module (in the latter case the "
"module's dictionary is used).  By default, when in the :mod:`__main__` "
"module, ``__builtins__`` is the built-in module :mod:`builtins`; when in any "
"other module, ``__builtins__`` is an alias for the dictionary of the :mod:"
"`builtins` module itself."
msgstr ""
"與程式碼塊執行相關聯的內建命名空間實際上是通過在其全局命名空間"
"中查找名稱“__builtins__”來找到的；這應該是字典或模組（在後一種情況下使用模組"
"的字典）。預設情況下，在 :mod:`__main__` 模組中， ``__builtins__`` 是內建模"
"組 :mod:`builtins`；在任何其他模組中，``__builtins__`` 是 :mod:`builtins` 模"
"組本身的字典的別名。"

#: ../../reference/executionmodel.rst:200
#, fuzzy
msgid "Interaction with dynamic features"
msgstr "與動態特徵的交互"

#: ../../reference/executionmodel.rst:202
#, fuzzy
msgid ""
"Name resolution of free variables occurs at runtime, not at compile time. "
"This means that the following code will print 42::"
msgstr ""
"自由變數的名稱解析發生在運行時，而不是編譯時。這意味著以下程式碼將印出 42::"

#: ../../reference/executionmodel.rst:213
#, fuzzy
msgid ""
"The :func:`eval` and :func:`exec` functions do not have access to the full "
"environment for resolving names.  Names may be resolved in the local and "
"global namespaces of the caller.  Free variables are not resolved in the "
"nearest enclosing namespace, but in the global namespace.  [#]_ The :func:"
"`exec` and :func:`eval` functions have optional arguments to override the "
"global and local namespace.  If only one namespace is specified, it is used "
"for both."
msgstr ""
":func:`eval` 和 :func:`exec` 函式無法訪問解析名稱的完整環境。名稱可以在呼叫者"
"的本地和全局命名空間中解析。自由變數不是在最近的封閉命名空間中解析，而是在全"
"局命名空間中解析。 [#]_ :func:`exec` 和 :func:`eval` 函式有可選參數來覆蓋全局"
"和局部命名空間。如果只指定了一個名稱空間，則它會同時用於兩者。"

#: ../../reference/executionmodel.rst:224
msgid "Exceptions"
msgstr "例外"

#: ../../reference/executionmodel.rst:235
#, fuzzy
msgid ""
"Exceptions are a means of breaking out of the normal flow of control of a "
"code block in order to handle errors or other exceptional conditions.  An "
"exception is *raised* at the point where the error is detected; it may be "
"*handled* by the surrounding code block or by any code block that directly "
"or indirectly invoked the code block where the error occurred."
msgstr ""
"例外是一種打破程式碼塊的正常控制流以處理錯誤或其他例外情況的方法。在檢測到錯"
"誤的地方*引發*例外；它可能由周圍的程式碼塊或任何直接或間接呼叫發生錯誤的程式"
"碼塊的程式碼塊*處理*。"

#: ../../reference/executionmodel.rst:241
#, fuzzy
msgid ""
"The Python interpreter raises an exception when it detects a run-time error "
"(such as division by zero).  A Python program can also explicitly raise an "
"exception with the :keyword:`raise` statement. Exception handlers are "
"specified with the :keyword:`try` ... :keyword:`except` statement.  The :"
"keyword:`finally` clause of such a statement can be used to specify cleanup "
"code which does not handle the exception, but is executed whether an "
"exception occurred or not in the preceding code."
msgstr ""
"Python 直譯器在檢測到運行時錯誤（例如被零除）時會引發例外。 Python 程式還可以"
"使用 :keyword:`raise` 語句顯式引發例外。例外處理程式使用 :keyword:`try` ... :"
"keyword:`except` 語句指定。此類語句的 :keyword:`finally` 子句可用於指定不處理"
"例外的清理程式碼，但無論前面程式碼是否發生例外都會執行。"

#: ../../reference/executionmodel.rst:251
#, fuzzy
msgid ""
"Python uses the \"termination\" model of error handling: an exception "
"handler can find out what happened and continue execution at an outer level, "
"but it cannot repair the cause of the error and retry the failing operation "
"(except by re-entering the offending piece of code from the top)."
msgstr ""
"Python 使用錯誤處理的“終止”模型：例外處理程式可以找出發生了什麼並在外層繼續執"
"行，但它無法修復錯誤原因並重試失敗的操作（除非重新進入有問題的部分頂部的程式"
"碼）。"

#: ../../reference/executionmodel.rst:258
#, fuzzy
msgid ""
"When an exception is not handled at all, the interpreter terminates "
"execution of the program, or returns to its interactive main loop.  In "
"either case, it prints a stack traceback, except when the exception is :exc:"
"`SystemExit`."
msgstr ""
"當一個例外根本沒有被處理時，直譯器終止程式的執行，或者回傳到它的交互式主循"
"環。在任何一種情況下，它都會印出堆疊回溯，除非例外是 :exc:`SystemExit`。"

#: ../../reference/executionmodel.rst:262
#, fuzzy
msgid ""
"Exceptions are identified by class instances.  The :keyword:`except` clause "
"is selected depending on the class of the instance: it must reference the "
"class of the instance or a :term:`non-virtual base class <abstract base "
"class>` thereof. The instance can be received by the handler and can carry "
"additional information about the exceptional condition."
msgstr ""
"例外由類實例標識。 :keyword:`except` 子句的選擇取決於實例的類：它必須引用實例"
"的類或其非虛擬基底類別 <abstract base class>`。該實例可由處理程式接收，並可攜"
"帶有關例外情況的附加資訊。"

#: ../../reference/executionmodel.rst:270
#, fuzzy
msgid ""
"Exception messages are not part of the Python API.  Their contents may "
"change from one version of Python to the next without warning and should not "
"be relied on by code which will run under multiple versions of the "
"interpreter."
msgstr ""
"例外消息不是 Python API 的一部分。它們的內容可能會在沒有警告的情況下從一個 "
"Python 版本更改為下一個版本，並且將在多個版本的直譯器下運行的程式碼不應依賴它"
"們。"

#: ../../reference/executionmodel.rst:274
#, fuzzy
msgid ""
"See also the description of the :keyword:`try` statement in section :ref:"
"`try` and :keyword:`raise` statement in section :ref:`raise`."
msgstr ""
"另請參閱 :ref:`try` 部分中的 :keyword:`try` 語句和 :ref:`raise` 部分中的 :"
"keyword:`raise` 語句的描述。"

#: ../../reference/executionmodel.rst:279
msgid "Footnotes"
msgstr "註解"

#: ../../reference/executionmodel.rst:280
#, fuzzy
msgid ""
"This limitation occurs because the code that is executed by these operations "
"is not available at the time the module is compiled."
msgstr "出現此限制是因為這些操作執行的程式碼在編譯模組時不可用。"
