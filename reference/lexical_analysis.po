# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-15 20:43+0000\n"
"PO-Revision-Date: 2018-05-23 16:17+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr "詞法分析"

#: ../../reference/lexical_analysis.rst:10
#, fuzzy
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of "
"*tokens*, generated by the *lexical analyzer*.  This chapter describes how "
"the lexical analyzer breaks a file into tokens."
msgstr "Python 程式由 *parser* 讀取。解析器的輸入是由*詞法分析器*生成的*令牌*流。本章"
"描述詞法分析器如何將文件分解為標記。"

#: ../../reference/lexical_analysis.rst:14
#, fuzzy
msgid ""
"Python reads program text as Unicode code points; the encoding of a source "
"file can be given by an encoding declaration and defaults to UTF-8, see :pep:"
"`3120` for details.  If the source file cannot be decoded, a :exc:"
"`SyntaxError` is raised."
msgstr ""
"Python 將程式文本讀取為 Unicode 程式碼點；源文件的編碼可以通過編碼聲明給出，"
"預設為 UTF-8，詳見 :pep:`3120`。如果無法解碼源文件，則會引發 "
":exc:`SyntaxError`。"

#: ../../reference/lexical_analysis.rst:23
#, fuzzy
msgid "Line structure"
msgstr "線路結構"

#: ../../reference/lexical_analysis.rst:27
#, fuzzy
msgid "A Python program is divided into a number of *logical lines*."
msgstr "一個 Python 程式被分成許多*邏輯行*。"

#: ../../reference/lexical_analysis.rst:33
#, fuzzy
msgid "Logical lines"
msgstr "邏輯線"

#: ../../reference/lexical_analysis.rst:37
#, fuzzy
msgid ""
"The end of a logical line is represented by the token NEWLINE.  Statements "
"cannot cross logical line boundaries except where NEWLINE is allowed by the "
"syntax (e.g., between statements in compound statements). A logical line is "
"constructed from one or more *physical lines* by following the explicit or "
"implicit *line joining* rules."
msgstr ""
"邏輯行的結尾由標記 NEWLINE 表示。語句不能跨越邏輯行邊界，除非語法允許換行（例"
"如，複合語句中的語句之間）。通過遵循顯式或隱式*行連接*規則，邏輯行由一個或多"
"個*物理行*構成。"

#: ../../reference/lexical_analysis.rst:47
#, fuzzy
msgid "Physical lines"
msgstr "實體線"

#: ../../reference/lexical_analysis.rst:49
#, fuzzy
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files and strings, any of the standard platform line "
"termination sequences can be used - the Unix form using ASCII LF (linefeed), "
"the Windows form using the ASCII sequence CR LF (return followed by "
"linefeed), or the old Macintosh form using the ASCII CR (return) character.  "
"All of these forms can be used equally, regardless of platform. The end of "
"input also serves as an implicit terminator for the final physical line."
msgstr ""
"物理行是由行尾序列終止的字元序列。在源文件和字串中，"
"可以使用任何標準平台行終止序列 - 使用 ASCII LF（換行）的 Unix 形式，使用 "
"ASCII 序列 CR LF（回車後跟換行）的 Windows 形式，或使用舊的 Macintosh "
"形式ASCII CR（回傳）字元。無論平台如何，所有這些形式都可以平等地使用。輸入的"
"結尾也作為最終物理行的隱式終止符。"

#: ../../reference/lexical_analysis.rst:57
#, fuzzy
msgid ""
"When embedding Python, source code strings should be passed to Python APIs "
"using the standard C conventions for newline characters (the ``\\n`` "
"character, representing ASCII LF, is the line terminator)."
msgstr ""
"嵌入 Python 時，應使用換行符的標準 C 約定將源程式碼字串傳遞給 Python API（"
"表示 ASCII LF 的 ``\\n"
"`` 字元是行終止符）。"

#: ../../reference/lexical_analysis.rst:65
#, fuzzy
msgid "Comments"
msgstr "評論"

#: ../../reference/lexical_analysis.rst:70
#, fuzzy
msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax."
msgstr "註釋以不屬於字串文字的散列字元 (``#``) 開頭，並在物理行的末尾結束。除非呼叫隱"
"式行連接規則，否則註釋表示邏輯行的結尾。註釋被語法忽略。"

#: ../../reference/lexical_analysis.rst:79
#, fuzzy
msgid "Encoding declarations"
msgstr "編碼聲明"

#: ../../reference/lexical_analysis.rst:84
#, fuzzy
msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The encoding declaration must appear on a "
"line of its own. If it is the second line, the first line must also be a "
"comment-only line. The recommended forms of an encoding expression are ::"
msgstr ""
"如果 Python 腳本第一行或第二行中的註釋與正則表達式 ``coding[=:]\\s*([-\\w"
".]+)`` 匹配，則此註釋將作為編碼聲明處理；該表達式的第一組命名源程式碼文件的編"
"碼。編碼聲明必須獨占一行。如果是第二行，第一行也必須是註釋行。"
"編碼表達式的推薦形式是 ::"

#: ../../reference/lexical_analysis.rst:93
#, fuzzy
msgid "which is recognized also by GNU Emacs, and ::"
msgstr "它也被 GNU Emacs 識別，並且 ::"

#: ../../reference/lexical_analysis.rst:97
#, fuzzy
msgid "which is recognized by Bram Moolenaar's VIM."
msgstr "它被 Bram Moolenaar 的 VIM 識別。"

#: ../../reference/lexical_analysis.rst:99
#, fuzzy
msgid ""
"If no encoding declaration is found, the default encoding is UTF-8.  In "
"addition, if the first bytes of the file are the UTF-8 byte-order mark "
"(``b'\\xef\\xbb\\xbf'``), the declared file encoding is UTF-8 (this is "
"supported, among others, by Microsoft's :program:`notepad`)."
msgstr ""
"如果未找到編碼聲明，則預設編碼為 UTF-8。此外，如果文件的第一個位元組是 UTF-8 "
"位元組順序標記（``b'\\xef\\xbb\\xbf'``），則聲明的文件編碼為 "
"UTF-8（支援，等等） ，由微軟的 :program:`notepad`)。"

#: ../../reference/lexical_analysis.rst:104
#, fuzzy
msgid ""
"If an encoding is declared, the encoding name must be recognized by Python "
"(see :ref:`standard-encodings`). The encoding is used for all lexical "
"analysis, including string literals, comments and identifiers."
msgstr ""
"如果聲明了編碼，則編碼名稱必須被 Python 識別（請參閱 :ref:`standard-"
"encodings`）。編碼用於所有詞法分析，包括字串文字、註釋和標識符。"

#: ../../reference/lexical_analysis.rst:113
#, fuzzy
msgid "Explicit line joining"
msgstr "顯式行加入"

#: ../../reference/lexical_analysis.rst:117
#, fuzzy
msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr ""
"兩個或多個物理行可以使用反斜杠字元 (``\\``) 連接成邏輯行，如下所示：當物理行"
"以不屬於字串文字或註釋的反斜杠結尾時，它與以下內容連接形成一個單一的邏輯行，"
"刪除反斜杠和隨後的行尾字元。例如：："

#: ../../reference/lexical_analysis.rst:128
#, fuzzy
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string "
"literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr ""
"以反斜杠結尾的行不能包含註釋。反斜杠不會繼續評論。反斜杠不會繼續除字串文字之"
"外的標記（即，字串文字以外的標記不能使用反斜杠跨物理行拆分）。反斜杠在字串文"
"字之外的行的其他地方是非法的。"

#: ../../reference/lexical_analysis.rst:138
#, fuzzy
msgid "Implicit line joining"
msgstr "隱式行連接"

#: ../../reference/lexical_analysis.rst:140
#, fuzzy
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr "括號、方括號或花括號中的表達式可以在多於一行的物理行上拆分，而無需使用反斜杠"
"。例如：："

#: ../../reference/lexical_analysis.rst:148
#, fuzzy
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr ""
"隱式續行可以攜帶註釋。續行的縮進並不重要。允許有空白續行。隱式續行之間沒有 "
"NEWLINE 標記。隱式續行也可以出現在三引號字串中（見下文）；在那種情況下，他們"
"不能發表評論。"

#: ../../reference/lexical_analysis.rst:158
#, fuzzy
msgid "Blank lines"
msgstr "空行"

#: ../../reference/lexical_analysis.rst:162
#, fuzzy
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard interactive interpreter, an entirely blank logical line (i.e. one "
"containing not even whitespace or a comment) terminates a multi-line "
"statement."
msgstr ""
"僅包含空格、製表符、換頁符和可能的註釋的邏輯行將被忽略（即，不生成 NEWLINE 標"
"記）。在語句的交互式輸入期間，空行的處理可能因讀取-評估-印出循環的實作而異。"
"在標準的交互式直譯器中，一個完全空白的邏輯行（即不包含空格或註釋的行）終止多"
"行語句。"

#: ../../reference/lexical_analysis.rst:173
#, fuzzy
msgid "Indentation"
msgstr "縮進"

#: ../../reference/lexical_analysis.rst:177
#, fuzzy
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr "邏輯行開頭的前導空白（空格和製表符）用於計算行的縮進級別，而縮進級別又用於確"
"定語句的分組。"

#: ../../reference/lexical_analysis.rst:181
#, fuzzy
msgid ""
"Tabs are replaced (from left to right) by one to eight spaces such that the "
"total number of characters up to and including the replacement is a multiple "
"of eight (this is intended to be the same rule as used by Unix).  The total "
"number of spaces preceding the first non-blank character then determines the "
"line's indentation.  Indentation cannot be split over multiple physical "
"lines using backslashes; the whitespace up to the first backslash determines "
"the indentation."
msgstr ""
"製表符被（從左到右）替換為一到八個空格，使得包括替換在內的字元總數是八的倍數"
"（這與 Unix 使用的規則相同）。第一個非空白字元之前的空格總數決定了該行的縮進"
"。不能使用反斜杠將縮進拆分為多個物理行；第一個反斜杠之前的空格決定了縮進。"

#: ../../reference/lexical_analysis.rst:189
#, fuzzy
msgid ""
"Indentation is rejected as inconsistent if a source file mixes tabs and "
"spaces in a way that makes the meaning dependent on the worth of a tab in "
"spaces; a :exc:`TabError` is raised in that case."
msgstr ""
"如果源文件以一種使含義取決於空格中製表符的值的方式混合製表符和空格，則縮進會"
"因為不一致而被拒絕；在這種情況下會引發 :exc:`TabError`。"

#: ../../reference/lexical_analysis.rst:193
#, fuzzy
msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors "
"on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for "
"the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr ""
"**跨平台相容性說明：**由於非 UNIX 平台上文本編輯器的性質，在單個源文件中混合"
"使用空格和製表符進行縮進是不明智的。還應該注意的是，不同的平台可能會明確限制"
"最大縮進級別。"

#: ../../reference/lexical_analysis.rst:198
#, fuzzy
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr ""
"換頁字元可能出現在行的開頭；對於上面的縮進計算，它將被忽略。出現在前導空格中"
"其他地方的換頁字元具有未定義的效果（例如，它們可能會將空格計數重置為零）。"

#: ../../reference/lexical_analysis.rst:205
#, fuzzy
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT and "
"DEDENT tokens, using a stack, as follows."
msgstr "連續行的縮進級別用於使用堆疊生成 INDENT 和 DEDENT 標記，如下所示。"

#: ../../reference/lexical_analysis.rst:208
#, fuzzy
msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack "
"will always be strictly increasing from bottom to top.  At the beginning of "
"each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on "
"the stack, and one INDENT token is generated.  If it is smaller, it *must* "
"be one of the numbers occurring on the stack; all numbers on the stack that "
"are larger are popped off, and for each number popped off a DEDENT token is "
"generated.  At the end of the file, a DEDENT token is generated for each "
"number remaining on the stack that is larger than zero."
msgstr ""
"在讀取文件的第一行之前，將單個零壓入堆疊；這將永遠不會再次彈出。壓入堆疊的數"
"字總是從下到上嚴格遞增。在每個邏輯行的開頭，將行的縮進級別與堆疊的頂部進行比"
"較。如果相等，則什麼也不會發生。如果較大，則將其壓入堆疊，並生成一個 INDENT "
"令牌。如果它更小，它*必須*是堆疊中出現的數字之一；堆疊上所有較大的數字都會被"
"彈出，並且對於彈出的每個數字都會生成一個 DEDENT 令牌。在文件末尾，"
"為堆疊中剩餘的每個大於零的數字生成一個 DEDENT 標記。"

#: ../../reference/lexical_analysis.rst:219
#, fuzzy
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr "這是一段正確（儘管令人困惑）縮進的 Python 程式碼示例："

#: ../../reference/lexical_analysis.rst:234
#, fuzzy
msgid "The following example shows various indentation errors::"
msgstr "以下示例顯示了各種縮進錯誤::"

#: ../../reference/lexical_analysis.rst:244
#, fuzzy
msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr "（實際上，解析器檢測到前三個錯誤；詞法分析器只發現最後一個錯誤 --- ``return "
"r`` 的縮進與從堆疊彈出的級別不匹配。）"

#: ../../reference/lexical_analysis.rst:252
#, fuzzy
msgid "Whitespace between tokens"
msgstr "標記之間的空白"

#: ../../reference/lexical_analysis.rst:254
#, fuzzy
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to "
"separate tokens.  Whitespace is needed between two tokens only if their "
"concatenation could otherwise be interpreted as a different token (e.g., ab "
"is one token, but a b is two tokens)."
msgstr ""
"除了在邏輯行的開頭或字串文字中，空白字元 space、tab 和 formfeed "
"可以互換使用以分隔標記。只有當它們的串聯可以被解釋為不同的標記（例如，ab "
"是一個標記，但 a b 是兩個標記）時，兩個標記之間才需要空格。"

#: ../../reference/lexical_analysis.rst:264
#, fuzzy
msgid "Other tokens"
msgstr "其他代幣"

#: ../../reference/lexical_analysis.rst:266
#, fuzzy
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*. "
"Whitespace characters (other than line terminators, discussed earlier) are "
"not tokens, but serve to delimit tokens. Where ambiguity exists, a token "
"comprises the longest possible string that forms a legal token, when read "
"from left to right."
msgstr ""
"除了 NEWLINE、INDENT 和 DEDENT 之外，還存在以下類別的標記：*identifiers*、*ke"
"ywords*、*literals*、*operators* 和 *delimiters*。空白字元（除前面討論的行終"
"止符外）不是標記，但用於分隔標記。在存在歧義的情況下，從左到右閱讀時，令牌包"
"含構成合法令牌的最長可能字串。"

#: ../../reference/lexical_analysis.rst:276
#, fuzzy
msgid "Identifiers and keywords"
msgstr "標識符和關鍵字"

#: ../../reference/lexical_analysis.rst:280
#, fuzzy
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions."
msgstr "標識符（也稱為 *names*）由以下詞彙定義描述。"

#: ../../reference/lexical_analysis.rst:283
#, fuzzy
msgid ""
"The syntax of identifiers in Python is based on the Unicode standard annex "
"UAX-31, with elaboration and changes as defined below; see also :pep:`3131` "
"for further details."
msgstr ""
"Python 中標識符的語法基於 Unicode 標準附件 UAX-31，詳細說明和更改如下定義；"
"另請參閱 :pep:`3131` 了解更多詳情。"

#: ../../reference/lexical_analysis.rst:287
#, fuzzy
msgid ""
"Within the ASCII range (U+0001..U+007F), the valid characters for "
"identifiers are the same as in Python 2.x: the uppercase and lowercase "
"letters ``A`` through ``Z``, the underscore ``_`` and, except for the first "
"character, the digits ``0`` through ``9``."
msgstr ""
"在 ASCII 範圍內 (U+0001..U+007F)，標識符的有效字元與 Python 2.x "
"中的相同：大寫和小寫字母 ``A``到 ``Z``，底線“ `_`` 以及除第一個字元外的數字 ``0``"
" 到 ``9``。"

#: ../../reference/lexical_analysis.rst:292
#, fuzzy
msgid ""
"Python 3.0 introduces additional characters from outside the ASCII range "
"(see :pep:`3131`).  For these characters, the classification uses the "
"version of the Unicode Character Database as included in the :mod:"
"`unicodedata` module."
msgstr ""
"Python 3.0 引入了 ASCII 範圍之外的其他字元（參見 "
":pep:`3131`）。對於這些字元，分類使用 :mod:`unicodedata` 模組中包含的 "
"Unicode 字元資料庫版本。"

#: ../../reference/lexical_analysis.rst:296
#, fuzzy
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr "標識符的長度沒有限制。案例很重要。"

#: ../../reference/lexical_analysis.rst:305
#, fuzzy
msgid "The Unicode category codes mentioned above stand for:"
msgstr "上面提到的Unicode類別程式碼代表："

#: ../../reference/lexical_analysis.rst:307
#, fuzzy
msgid "*Lu* - uppercase letters"
msgstr "*Lu* - 大寫字母"

#: ../../reference/lexical_analysis.rst:308
#, fuzzy
msgid "*Ll* - lowercase letters"
msgstr "*Ll* - 小寫字母"

#: ../../reference/lexical_analysis.rst:309
#, fuzzy
msgid "*Lt* - titlecase letters"
msgstr "*Lt* - 標題字母"

#: ../../reference/lexical_analysis.rst:310
#, fuzzy
msgid "*Lm* - modifier letters"
msgstr "*Lm* - 修飾字母"

#: ../../reference/lexical_analysis.rst:311
#, fuzzy
msgid "*Lo* - other letters"
msgstr "*Lo* - 其他字母"

#: ../../reference/lexical_analysis.rst:312
#, fuzzy
msgid "*Nl* - letter numbers"
msgstr "*Nl* - 字母數字"

#: ../../reference/lexical_analysis.rst:313
#, fuzzy
msgid "*Mn* - nonspacing marks"
msgstr "*Mn* - 非間距標記"

#: ../../reference/lexical_analysis.rst:314
#, fuzzy
msgid "*Mc* - spacing combining marks"
msgstr "*Mc* - 間距組合標記"

#: ../../reference/lexical_analysis.rst:315
#, fuzzy
msgid "*Nd* - decimal numbers"
msgstr "*Nd* - 小數"

#: ../../reference/lexical_analysis.rst:316
#, fuzzy
msgid "*Pc* - connector punctuations"
msgstr "*Pc* - 連接符標點符號"

#: ../../reference/lexical_analysis.rst:317
#, fuzzy
msgid ""
"*Other_ID_Start* - explicit list of characters in `PropList.txt <https://www."
"unicode.org/Public/14.0.0/ucd/PropList.txt>`_ to support backwards "
"compatibility"
msgstr ""
"*Other_ID_Start* - `PropList.txt <https://www.unicode.org/Public/14.0.0/ucd/"
"PropList.txt>`_ 中的明確字元列表，以支援向後相容"

#: ../../reference/lexical_analysis.rst:320
#, fuzzy
msgid "*Other_ID_Continue* - likewise"
msgstr "*Other_ID_Continue* - 同樣"

#: ../../reference/lexical_analysis.rst:322
#, fuzzy
msgid ""
"All identifiers are converted into the normal form NFKC while parsing; "
"comparison of identifiers is based on NFKC."
msgstr "所有的標識符在解析時都被轉換成正常形式的NFKC；標識符的比較基於 NFKC。"

#: ../../reference/lexical_analysis.rst:325
#, fuzzy
msgid ""
"A non-normative HTML file listing all valid identifier characters for "
"Unicode 14.0.0 can be found at https://www.unicode.org/Public/14.0.0/ucd/"
"DerivedCoreProperties.txt"
msgstr ""
"可以在 https://www.unicode.org/Public/14.0.0/ucd/DerivedCoreProperties.txt "
"找到列出 Unicode 14.0.0 所有有效標識符字元的非規範 HTML 文件"

#: ../../reference/lexical_analysis.rst:333
#, fuzzy
msgid "Keywords"
msgstr "關鍵字"

#: ../../reference/lexical_analysis.rst:339
#, fuzzy
msgid ""
"The following identifiers are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr "以下標識符作為語言的保留字或*關鍵字*使用，不能作為普通標識符使用。它們的拼寫"
"必須與這裡寫的完全一樣："

#: ../../reference/lexical_analysis.rst:357
#, fuzzy
msgid "Soft Keywords"
msgstr "軟關鍵字"

#: ../../reference/lexical_analysis.rst:363
#, fuzzy
msgid ""
"Some identifiers are only reserved under specific contexts. These are known "
"as *soft keywords*.  The identifiers ``match``, ``case`` and ``_`` can "
"syntactically act as keywords in contexts related to the pattern matching "
"statement, but this distinction is done at the parser level, not when "
"tokenizing."
msgstr ""
"某些標識符僅在特定上下文中保留。這些被稱為*軟關鍵字*。標識符``match``、``case"
"`` 和``_`` 在句法上可以充當與模式匹配語句相關的上下文中的關鍵字，但這種區分是"
"在解析器級別完成的，而不是在標記化時完成的。"

#: ../../reference/lexical_analysis.rst:369
#, fuzzy
msgid ""
"As soft keywords, their use with pattern matching is possible while still "
"preserving compatibility with existing code that uses ``match``, ``case`` "
"and ``_`` as identifier names."
msgstr ""
"作為軟關鍵字，它們可以與模式匹配一起使用"
"，同時仍然保持與使用 ``match``、 ``case``和 ``_``作為標識符名稱的現有程式碼的相容性。"

#: ../../reference/lexical_analysis.rst:380
#, fuzzy
msgid "Reserved classes of identifiers"
msgstr "保留類別的標識符"

#: ../../reference/lexical_analysis.rst:382
#, fuzzy
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr "某些類別的標識符（除了關鍵字）具有特殊含義。這些類由前導和尾隨底線字元的模"
"式標識："

#: ../../reference/lexical_analysis.rst:387
msgid "``_*``"
msgstr "``_*``"

#: ../../reference/lexical_analysis.rst:387
#, fuzzy
msgid "Not imported by ``from module import *``."
msgstr "不是由``from module import *`` 導入的。"

#: ../../reference/lexical_analysis.rst:408
msgid "``_``"
msgstr "``_``"

#: ../../reference/lexical_analysis.rst:390
#, fuzzy
msgid ""
"In a ``case`` pattern within a :keyword:`match` statement, ``_`` is a :ref:"
"`soft keyword <soft-keywords>` that denotes a :ref:`wildcard <wildcard-"
"patterns>`."
msgstr ""
"在 :keyword:`match` 語句中的 ``case`` 模式中，``_`` 是一個 :ref:`soft "
"keyword <soft-keywords>` 表示一個 :ref:`wildcard <wildcard-patterns> `。"

#: ../../reference/lexical_analysis.rst:394
#, fuzzy
msgid ""
"Separately, the interactive interpreter makes the result of the last "
"evaluation available in the variable ``_``. (It is stored in the :mod:"
"`builtins` module, alongside built-in functions like ``print``.)"
msgstr ""
"另外，交互式直譯器使最後一次評估的結果在變數 ``_``中可用。 （它儲存在 "
":mod:`builtins` 模組中，與 ``print`` 等內建函式一起。）"

#: ../../reference/lexical_analysis.rst:399
#, fuzzy
msgid ""
"Elsewhere, ``_`` is a regular identifier. It is often used to name \"special"
"\" items, but it is not special to Python itself."
msgstr "在其他地方，``_`` 是常規標識符。它經常被用來命名“特殊”的項目，但它對 Python "
"本身來說並不特殊。"

#: ../../reference/lexical_analysis.rst:404
#, fuzzy
msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer "
"to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr "名稱 ``_`` 通常與國際化結合使用；有關此約定的更多資訊，請參閱 :mod:`gettext` "
"模組的文檔。"

#: ../../reference/lexical_analysis.rst:408
#, fuzzy
msgid "It is also commonly used for unused variables."
msgstr "它也常用於未使用的變數。"

#: ../../reference/lexical_analysis.rst:416
msgid "``__*__``"
msgstr "``__*__``"

#: ../../reference/lexical_analysis.rst:411
#, fuzzy
msgid ""
"System-defined names, informally known as \"dunder\" names. These names are "
"defined by the interpreter and its implementation (including the standard "
"library). Current system names are discussed in the :ref:`specialnames` "
"section and elsewhere. More will likely be defined in future versions of "
"Python.  *Any* use of ``__*__`` names, in any context, that does not follow "
"explicitly documented use, is subject to breakage without warning."
msgstr ""
"系統定義的名稱，非正式地稱為 ``dunder``名稱。這些名稱由直譯器及其實作（包括標準"
"庫）定義。當前系統名稱在 :ref:`specialnames` 部分和其他地方討論。在未來的 "
"Python 版本中可能會定義更多。 *任何*使用``__*__``名稱，在任何上下文中，如果不"
"遵循明確記錄的使用，就會在沒有警告的情況下被破壞。"

#: ../../reference/lexical_analysis.rst:423
msgid "``__*``"
msgstr "``__*``"

#: ../../reference/lexical_analysis.rst:419
#, fuzzy
msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See "
"section :ref:`atom-identifiers`."
msgstr ""
"類私有名稱。當在類定義的上下文中使用時，此類中的名稱將被重寫為使用錯位形式，"
"以幫助避免基底類別和派生類的“私有”屬性之間的名稱衝突。請參閱 :ref:`atom-"
"identifiers` 部分。"

#: ../../reference/lexical_analysis.rst:428
#, fuzzy
msgid "Literals"
msgstr "文字"

#: ../../reference/lexical_analysis.rst:432
#, fuzzy
msgid "Literals are notations for constant values of some built-in types."
msgstr "文字是一些內建型別的常數值的符號。"

#: ../../reference/lexical_analysis.rst:443
#, fuzzy
msgid "String and Bytes literals"
msgstr "字串和位元組文字"

#: ../../reference/lexical_analysis.rst:445
#, fuzzy
msgid "String literals are described by the following lexical definitions:"
msgstr "字串文字由以下詞法定義描述："

#: ../../reference/lexical_analysis.rst:470
#, fuzzy
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`~python-grammar:stringprefix` "
"or :token:`~python-grammar:bytesprefix` and the rest of the literal. The "
"source character set is defined by the encoding declaration; it is UTF-8 if "
"no encoding declaration is given in the source file; see section :ref:"
"`encodings`."
msgstr ""
"這些產生式未指出的一種語法限制是 :token:`~python-grammar:stringprefix` 或 "
":token:`~python-grammar:bytesprefix` 與文字的其餘部分之間不允許有空格。源字元"
"集由編碼聲明定義；如果源文件中沒有給出編碼聲明，則為UTF-8；請參閱 "
":ref:`encodings` 部分。"

#: ../../reference/lexical_analysis.rst:480
#, fuzzy
msgid ""
"In plain English: Both types of literals can be enclosed in matching single "
"quotes (``'``) or double quotes (``\"``).  They can also be enclosed in "
"matching groups of three single or double quotes (these are generally "
"referred to as *triple-quoted strings*).  The backslash (``\\``) character "
"is used to escape characters that otherwise have a special meaning, such as "
"newline, backslash itself, or the quote character."
msgstr ""
"用簡單的英語來說：兩種型別的文字都可以用匹配的單引號 (``\\'``) 或雙引號 (``\""
"``) 括起來。它們也可以用三個單引號或雙引號組成的匹配組括起來（這些是通常稱為*"
"三引號字串*）。反斜杠（``\\"
"``）字元用於轉義其他具有特殊含義的字元，例如換行符、反斜杠本身或引號字元。"

#: ../../reference/lexical_analysis.rst:491
#, fuzzy
msgid ""
"Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce an "
"instance of the :class:`bytes` type instead of the :class:`str` type.  They "
"may only contain ASCII characters; bytes with a numeric value of 128 or "
"greater must be expressed with escapes."
msgstr ""
"位元組文字總是以 ``'b'`` 或 ``'B'`` 為前綴；它們生成一個 bytes 型別的實例，"
"而不是 str 型別的實例。它們只能包含 ASCII 字元；數值為 128 "
"或更大的位元組必須用轉義符表示。"

#: ../../reference/lexical_analysis.rst:500
#, fuzzy
msgid ""
"Both string and bytes literals may optionally be prefixed with a letter "
"``'r'`` or ``'R'``; such strings are called :dfn:`raw strings` and treat "
"backslashes as literal characters.  As a result, in string literals, "
"``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated specially. "
"Given that Python 2.x's raw unicode literals behave differently than Python "
"3.x's the ``'ur'`` syntax is not supported."
msgstr ""
"字串和位元組文字都可以選擇以字母 ``r``或 ``R``作為前綴；這樣的字串稱為 :dfn:`raw "
"strings` 並將反斜杠視為文字字元。因此，在字串文字中，原始字串中的 ``'\\U'`` "
"和 ``'\\u'`` 轉義不會被特殊處理。鑑於 Python 2.x 的原始 unicode 文字與 "
"Python 3.x 的行為不同，因此不支援“你的”語法。"

#: ../../reference/lexical_analysis.rst:507
#, fuzzy
msgid ""
"The ``'rb'`` prefix of raw bytes literals has been added as a synonym of "
"``'br'``."
msgstr "原始位元組文字的 ``'rb'`` 前綴已新增為 ``'br'`` 的同義詞。"

#: ../../reference/lexical_analysis.rst:511
#, fuzzy
msgid ""
"Support for the unicode legacy literal (``u'value'``) was reintroduced to "
"simplify the maintenance of dual Python 2.x and 3.x codebases. See :pep:"
"`414` for more information."
msgstr ""
"重新引入了對 unicode 遺留文字（``u'value'``）的支援，以簡化雙 Python 2.x 和 "
"3.x 程式碼庫的維護。有關更多資訊，請參見 :pep:`414`。"

#: ../../reference/lexical_analysis.rst:520
#, fuzzy
msgid ""
"A string literal with ``'f'`` or ``'F'`` in its prefix is a :dfn:`formatted "
"string literal`; see :ref:`f-strings`.  The ``'f'`` may be combined with "
"``'r'``, but not with ``'b'`` or ``'u'``, therefore raw formatted strings "
"are possible, but formatted bytes literals are not."
msgstr ""
"前綴中帶有 ``'f'`` 或 ``'F'`` "
"的字串文字是 :dfn:`格式化字串文字`；參見 :ref:`f-strings`。 ``'f'`` 可以與 "
"``'r'`` 組合，但不能與 ``'b'`` 或 ``'u'`` "
"組合，因此原始格式化字串是可能的，但格式化位元組文字不是。"

#: ../../reference/lexical_analysis.rst:525
#, fuzzy
msgid ""
"In triple-quoted literals, unescaped newlines and quotes are allowed (and "
"are retained), except that three unescaped quotes in a row terminate the "
"literal.  (A \"quote\" is the character used to open the literal, i.e. "
"either ``'`` or ``\"``.)"
msgstr ""
"在三重引號文字中，允許（並保留）未轉義的換行符和引號，除了連續三個未轉義的引"
"號終止文字。 （“引號”是用於打開文字的字元，即 ``\\'`` 或 ``\"``。）"

#: ../../reference/lexical_analysis.rst:544
#, fuzzy
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in string "
"and bytes literals are interpreted according to rules similar to those used "
"by Standard C.  The recognized escape sequences are:"
msgstr ""
"除非存在 ``'r'`` 或 ``'R'`` 前綴，"
"否則字串和位元組文字中的轉義序列將根據類似於標準 C "
"使用的規則進行解釋。可識別的轉義序列是："

#: ../../reference/lexical_analysis.rst:549
#: ../../reference/lexical_analysis.rst:582
#, fuzzy
msgid "Escape Sequence"
msgstr "轉義序列"

#: ../../reference/lexical_analysis.rst:549
#: ../../reference/lexical_analysis.rst:582
#, fuzzy
msgid "Meaning"
msgstr "意義"

#: ../../reference/lexical_analysis.rst:549
#: ../../reference/lexical_analysis.rst:582
msgid "Notes"
msgstr "註解"

#: ../../reference/lexical_analysis.rst:551
msgid "``\\``\\ <newline>"
msgstr "``\\``\\ <newline>"

#: ../../reference/lexical_analysis.rst:551
#, fuzzy
msgid "Backslash and newline ignored"
msgstr "反斜杠和換行符被忽略"

#: ../../reference/lexical_analysis.rst:551
msgid "\\(1)"
msgstr "\\(1)"

#: ../../reference/lexical_analysis.rst:553
msgid "``\\\\``"
msgstr "``\\\\``"

#: ../../reference/lexical_analysis.rst:553
#, fuzzy
msgid "Backslash (``\\``)"
msgstr "反斜杠 (``\\``)"

#: ../../reference/lexical_analysis.rst:555
msgid "``\\'``"
msgstr "``\\'``"

#: ../../reference/lexical_analysis.rst:555
#, fuzzy
msgid "Single quote (``'``)"
msgstr "單引號（``'``）"

#: ../../reference/lexical_analysis.rst:557
msgid "``\\\"``"
msgstr "``\\\"``"

#: ../../reference/lexical_analysis.rst:557
#, fuzzy
msgid "Double quote (``\"``)"
msgstr "雙引號 (``\"``)"

#: ../../reference/lexical_analysis.rst:559
msgid "``\\a``"
msgstr "``\\a``"

#: ../../reference/lexical_analysis.rst:559
#, fuzzy
msgid "ASCII Bell (BEL)"
msgstr "ASCII 貝爾 (BEL)"

#: ../../reference/lexical_analysis.rst:561
msgid "``\\b``"
msgstr "``\\b``"

#: ../../reference/lexical_analysis.rst:561
#, fuzzy
msgid "ASCII Backspace (BS)"
msgstr "ASCII 退格鍵 (BS)"

#: ../../reference/lexical_analysis.rst:563
msgid "``\\f``"
msgstr "``\\f``"

#: ../../reference/lexical_analysis.rst:563
#, fuzzy
msgid "ASCII Formfeed (FF)"
msgstr "ASCII 換頁 (FF)"

#: ../../reference/lexical_analysis.rst:565
msgid "``\\n``"
msgstr "``\\n``"

#: ../../reference/lexical_analysis.rst:565
#, fuzzy
msgid "ASCII Linefeed (LF)"
msgstr "ASCII 換行 (LF)"

#: ../../reference/lexical_analysis.rst:567
msgid "``\\r``"
msgstr "``\\r``"

#: ../../reference/lexical_analysis.rst:567
#, fuzzy
msgid "ASCII Carriage Return (CR)"
msgstr "ASCII 回車 (CR)"

#: ../../reference/lexical_analysis.rst:569
msgid "``\\t``"
msgstr "``\\t``"

#: ../../reference/lexical_analysis.rst:569
#, fuzzy
msgid "ASCII Horizontal Tab (TAB)"
msgstr "ASCII 水平製表符 (TAB)"

#: ../../reference/lexical_analysis.rst:571
msgid "``\\v``"
msgstr "``\\v``"

#: ../../reference/lexical_analysis.rst:571
#, fuzzy
msgid "ASCII Vertical Tab (VT)"
msgstr "ASCII 垂直製表符 (VT)"

#: ../../reference/lexical_analysis.rst:573
msgid "``\\ooo``"
msgstr "``\\ooo``"

#: ../../reference/lexical_analysis.rst:573
#, fuzzy
msgid "Character with octal value *ooo*"
msgstr "具有八進位值的字元 *ooo*"

#: ../../reference/lexical_analysis.rst:573
msgid "(2,4)"
msgstr "(2,4)"

#: ../../reference/lexical_analysis.rst:576
msgid "``\\xhh``"
msgstr "``\\xhh``"

#: ../../reference/lexical_analysis.rst:576
#, fuzzy
msgid "Character with hex value *hh*"
msgstr "具有十六進位值的字元 *hh*"

#: ../../reference/lexical_analysis.rst:576
msgid "(3,4)"
msgstr "(3,4)"

#: ../../reference/lexical_analysis.rst:579
#, fuzzy
msgid "Escape sequences only recognized in string literals are:"
msgstr "僅在字串文字中識別的轉義序列是："

#: ../../reference/lexical_analysis.rst:584
msgid "``\\N{name}``"
msgstr "``\\N{name}``"

#: ../../reference/lexical_analysis.rst:584
#, fuzzy
msgid "Character named *name* in the Unicode database"
msgstr "Unicode 資料庫中名為 *name* 的字元"

#: ../../reference/lexical_analysis.rst:584
msgid "\\(5)"
msgstr "\\(5)"

#: ../../reference/lexical_analysis.rst:587
msgid "``\\uxxxx``"
msgstr "``\\uxxxx``"

#: ../../reference/lexical_analysis.rst:587
#, fuzzy
msgid "Character with 16-bit hex value *xxxx*"
msgstr "具有 16 位十六進位值的字元 *xxxx*"

#: ../../reference/lexical_analysis.rst:587
msgid "\\(6)"
msgstr "\\(6)"

#: ../../reference/lexical_analysis.rst:590
msgid "``\\Uxxxxxxxx``"
msgstr "``\\Uxxxxxxxx``"

#: ../../reference/lexical_analysis.rst:590
#, fuzzy
msgid "Character with 32-bit hex value *xxxxxxxx*"
msgstr "具有 32 位十六進位值的字元 *xxxxxxxx*"

#: ../../reference/lexical_analysis.rst:590
msgid "\\(7)"
msgstr "\\(7)"

#: ../../reference/lexical_analysis.rst:594
msgid "Notes:"
msgstr "註解："

#: ../../reference/lexical_analysis.rst:597
#, fuzzy
msgid "A backslash can be added at the end of a line to ignore the newline::"
msgstr "可以在行尾新增反斜杠以忽略換行符::"

#: ../../reference/lexical_analysis.rst:603
#, fuzzy
msgid ""
"The same result can be achieved using :ref:`triple-quoted strings "
"<strings>`, or parentheses and :ref:`string literal concatenation <string-"
"concatenation>`."
msgstr ""
"使用 :ref:`三引號字串 <strings>` 或括號和 :ref:`字串文字連接 <string-"
"concatenation>` 可以達到相同的結果。"

#: ../../reference/lexical_analysis.rst:608
#, fuzzy
msgid "As in Standard C, up to three octal digits are accepted."
msgstr "與標準 C 一樣，最多接受三個八進位數字。"

#: ../../reference/lexical_analysis.rst:610
#, fuzzy
msgid ""
"Octal escapes with value larger than ``0o377`` produce a :exc:"
"`DeprecationWarning`. In a future Python version they will be a :exc:"
"`SyntaxWarning` and eventually a :exc:`SyntaxError`."
msgstr ""
"值大於 ``0o377`` 的八進位轉義會產生一個 :exc:`DeprecationWarning`。在未來的 "
"Python 版本中，它們將是 :exc:`SyntaxWarning`，最終是 :exc:`SyntaxError`。"

#: ../../reference/lexical_analysis.rst:616
#, fuzzy
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr "與標準 C 不同，它只需要兩個十六進位數字。"

#: ../../reference/lexical_analysis.rst:619
#, fuzzy
msgid ""
"In a bytes literal, hexadecimal and octal escapes denote the byte with the "
"given value. In a string literal, these escapes denote a Unicode character "
"with the given value."
msgstr "在位元組文字中，十六進位和八進位轉義表示具有給定值的位元組。在字串文字中，"
"這些轉義表示具有給定值的 Unicode 字元。"

#: ../../reference/lexical_analysis.rst:624
#, fuzzy
msgid "Support for name aliases [#]_ has been added."
msgstr "新增了對名稱別名 [#]_ 的支援。"

#: ../../reference/lexical_analysis.rst:628
#, fuzzy
msgid "Exactly four hex digits are required."
msgstr "正好需要四個十六進位數字。"

#: ../../reference/lexical_analysis.rst:631
#, fuzzy
msgid ""
"Any Unicode character can be encoded this way.  Exactly eight hex digits are "
"required."
msgstr "任何 Unicode 字元都可以用這種方式編碼。需要恰好八個十六進位數字。"

#: ../../reference/lexical_analysis.rst:637
#, fuzzy
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the string "
"unchanged, i.e., *the backslash is left in the result*.  (This behavior is "
"useful when debugging: if an escape sequence is mistyped, the resulting "
"output is more easily recognized as broken.)  It is also important to note "
"that the escape sequences only recognized in string literals fall into the "
"category of unrecognized escapes for bytes literals."
msgstr ""
"與標準 C 不同，所有無法識別的轉義序列都保留在字串中不變，即 "
"*反斜杠保留在結果中*。 （此行為在除錯時很有用：如果轉義序列輸入錯誤，則結果輸"
"出更容易被識別為損壞。）同樣重要的是要注意，僅在字串文字中識別的轉義序列屬於"
"無法識別的位元組轉義類別文字。"

#: ../../reference/lexical_analysis.rst:644
#, fuzzy
msgid ""
"Unrecognized escape sequences produce a :exc:`DeprecationWarning`.  In a "
"future Python version they will be a :exc:`SyntaxWarning` and eventually a :"
"exc:`SyntaxError`."
msgstr ""
"無法識別的轉義序列會產生 :exc:`DeprecationWarning`。在未來的 Python "
"版本中，它們將是 :exc:`SyntaxWarning`，最終是 :exc:`SyntaxError`。"

#: ../../reference/lexical_analysis.rst:649
#, fuzzy
msgid ""
"Even in a raw literal, quotes can be escaped with a backslash, but the "
"backslash remains in the result; for example, ``r\"\\\"\"`` is a valid "
"string literal consisting of two characters: a backslash and a double quote; "
"``r\"\\\"`` is not a valid string literal (even a raw string cannot end in "
"an odd number of backslashes).  Specifically, *a raw literal cannot end in a "
"single backslash* (since the backslash would escape the following quote "
"character).  Note also that a single backslash followed by a newline is "
"interpreted as those two characters as part of the literal, *not* as a line "
"continuation."
msgstr ""
"即使在原始文字中，引號也可以用反斜杠轉義，但反斜杠仍保留在結果中；例如，``r\""
"\\\"\"`` 是由兩個字元組成的有效字串文字：一個反斜杠和一個雙引號；``r\"\\\"`` "
"不是一個有效的字串文字（即使是原始字串也不能結束在奇數個反斜杠中。具體來說，*"
"原始文字不能以單個反斜杠結尾*（因為反斜杠會轉義後面的引號字元）。還要注意，單"
"個反斜杠後跟一個換行符被解釋為這兩個字元文字的一部分，*不*作為續行。"

#: ../../reference/lexical_analysis.rst:662
#, fuzzy
msgid "String literal concatenation"
msgstr "字串文字連接"

#: ../../reference/lexical_analysis.rst:664
#, fuzzy
msgid ""
"Multiple adjacent string or bytes literals (delimited by whitespace), "
"possibly using different quoting conventions, are allowed, and their meaning "
"is the same as their concatenation.  Thus, ``\"hello\" 'world'`` is "
"equivalent to ``\"helloworld\"``.  This feature can be used to reduce the "
"number of backslashes needed, to split long strings conveniently across long "
"lines, or even to add comments to parts of strings, for example::"
msgstr ""
"允許使用多個相鄰的字串或位元組文字（由空格分隔），可能使用不同的引用約定，它"
"們的含義與它們的連接相同。因此，``\"hello\" \\'world\\'`` 等同於 ``"
"\"helloworld\"``。此功能可用於減少所需反斜杠的數量，方便地將長字串拆分成長行"
"，甚至可以向部分字串新增註釋，例如："

#: ../../reference/lexical_analysis.rst:675
#, fuzzy
msgid ""
"Note that this feature is defined at the syntactical level, but implemented "
"at compile time.  The '+' operator must be used to concatenate string "
"expressions at run time.  Also note that literal concatenation can use "
"different quoting styles for each component (even mixing raw strings and "
"triple quoted strings), and formatted string literals may be concatenated "
"with plain string literals."
msgstr ""
"請注意，此功能是在語法級別定義的，但在編譯時實作。  ``+``運算符必須用於在運行時"
"連接字串表達式。另請注意，文字連接可以為每個組件使用不同的引號樣式（甚至混合"
"原始字串和三重引號字串），並且格式化字串文字可以與普通字串文字連接。"

#: ../../reference/lexical_analysis.rst:696
#, fuzzy
msgid "Formatted string literals"
msgstr "格式化字串文字"

#: ../../reference/lexical_analysis.rst:700
#, fuzzy
msgid ""
"A :dfn:`formatted string literal` or :dfn:`f-string` is a string literal "
"that is prefixed with ``'f'`` or ``'F'``.  These strings may contain "
"replacement fields, which are expressions delimited by curly braces ``{}``. "
"While other string literals always have a constant value, formatted strings "
"are really expressions evaluated at run time."
msgstr ""
":dfn:`格式化字串文字` 或 :dfn:`f-string` 是一個以 ``'f'`` 或 ``'F'`` 為前綴的"
"字串文字。這些字串可能包含替換欄位，它們是由大括號“{}”分隔的表達式。雖然其他"
"字串文字始終具有常數值，但格式化字串實際上是在運行時評估的表達式。"

#: ../../reference/lexical_analysis.rst:706
#, fuzzy
msgid ""
"Escape sequences are decoded like in ordinary string literals (except when a "
"literal is also marked as a raw string).  After decoding, the grammar for "
"the contents of the string is:"
msgstr "轉義序列像在普通字串文字中一樣被解碼（除非文字也被標記為原始字串）。解碼後，"
"字串內容的語法為："

#: ../../reference/lexical_analysis.rst:720
#, fuzzy
msgid ""
"The parts of the string outside curly braces are treated literally, except "
"that any doubled curly braces ``'{{'`` or ``'}}'`` are replaced with the "
"corresponding single curly brace.  A single opening curly bracket ``'{'`` "
"marks a replacement field, which starts with a Python expression. To display "
"both the expression text and its value after evaluation, (useful in "
"debugging), an equal sign ``'='`` may be added after the expression. A "
"conversion field, introduced by an exclamation point ``'!'`` may follow.  A "
"format specifier may also be appended, introduced by a colon ``':'``. A "
"replacement field ends with a closing curly bracket ``'}'``."
msgstr ""
"大括號外的字串部分按字面意思處理，除了任何雙大括號``'{{'``或``'}}'``被相應的"
"單大括號替換。一個左大括號 ``{```` 標記一個替換欄位，它以 Python 表達式開頭。要"
"在求值後顯示表達式文本及其值（在除錯中很有用），可以在表達式後新增等號 ``=``。由"
"感嘆號 ``！``引入的轉換欄位可能會跟在後面。也可以附加格式說明符，由冒號 ``:``引入。"
"替換欄位以右大括號``'}'``結尾。"

#: ../../reference/lexical_analysis.rst:730
#, fuzzy
msgid ""
"Expressions in formatted string literals are treated like regular Python "
"expressions surrounded by parentheses, with a few exceptions. An empty "
"expression is not allowed, and both :keyword:`lambda`  and assignment "
"expressions ``:=`` must be surrounded by explicit parentheses. Replacement "
"expressions can contain line breaks (e.g. in triple-quoted strings), but "
"they cannot contain comments.  Each expression is evaluated in the context "
"where the formatted string literal appears, in order from left to right."
msgstr ""
"格式化字串文字中的表達式被視為被括號包圍的常規 Python "
"表達式，但有一些例外。不允許使用空表達式，並且 :keyword:`lambda` "
"和賦值表達式 ``:=`` 都必須用顯式括號括起來。替換錶達式可以包含換行符（例如在"
"三引號字串中），但它們不能包含註釋。每個表達式都在格式化字串文字出現的上下文"
"中按從左到右的順序求值。"

#: ../../reference/lexical_analysis.rst:739
#, fuzzy
msgid ""
"Prior to Python 3.7, an :keyword:`await` expression and comprehensions "
"containing an :keyword:`async for` clause were illegal in the expressions in "
"formatted string literals due to a problem with the implementation."
msgstr ""
"在 Python 3.7 之前，由於實作問題，一個 :keyword:`await` 表達式和包含一個 "
":keyword:`async for` 子句的理解在格式化字串文字的表達式中是非法的。"

#: ../../reference/lexical_analysis.rst:744
#, fuzzy
msgid ""
"When the equal sign ``'='`` is provided, the output will have the expression "
"text, the ``'='`` and the evaluated value. Spaces after the opening brace "
"``'{'``, within the expression and after the ``'='`` are all retained in the "
"output. By default, the ``'='`` causes the :func:`repr` of the expression to "
"be provided, unless there is a format specified. When a format is specified "
"it defaults to the :func:`str` of the expression unless a conversion ``'!"
"r'`` is declared."
msgstr ""
"當提供等號 ``'='`` 時，輸出將包含表達式文本、``'='`` "
"和評估值。左大括號``'{'`` 之後、表達式內和``'='`` "
"之後的空格都保留在輸出中。預設情況下，``'='`` 導致提供表達式的 :func:`repr` "
"，除非指定了格式。當指定格式時，它預設為表達式的 :func:`str` 除非聲明了轉換 "
"``'!r'``。"

#: ../../reference/lexical_analysis.rst:752
#, fuzzy
msgid "The equal sign ``'='``."
msgstr "等號 ``'='``。"

#: ../../reference/lexical_analysis.rst:755
#, fuzzy
msgid ""
"If a conversion is specified, the result of evaluating the expression is "
"converted before formatting.  Conversion ``'!s'`` calls :func:`str` on the "
"result, ``'!r'`` calls :func:`repr`, and ``'!a'`` calls :func:`ascii`."
msgstr ""
"如果指定了轉換，則在格式化之前轉換錶達式的計算結果。轉換 ``'!s'`` "
"在結果上呼叫 :func:`str`，``'!r'`` 呼叫 :func:`repr`，而 ``'!a'`` 呼叫 "
":func:` ascii`。"

#: ../../reference/lexical_analysis.rst:759
#, fuzzy
msgid ""
"The result is then formatted using the :func:`format` protocol.  The format "
"specifier is passed to the :meth:`__format__` method of the expression or "
"conversion result.  An empty string is passed when the format specifier is "
"omitted.  The formatted result is then included in the final value of the "
"whole string."
msgstr ""
"然後使用 :func:`format` 協定對結果進行格式化。"
"格式說明符傳遞給表達式或轉換結果的 :meth:`__format__` 方法。省略格式說明符時"
"將傳遞一個空字串。然後格式化結果包含在整個字串的最終值中。"

#: ../../reference/lexical_analysis.rst:765
#, fuzzy
msgid ""
"Top-level format specifiers may include nested replacement fields. These "
"nested fields may include their own conversion fields and :ref:`format "
"specifiers <formatspec>`, but may not include more deeply nested replacement "
"fields. The :ref:`format specifier mini-language <formatspec>` is the same "
"as that used by the :meth:`str.format` method."
msgstr ""
"頂級格式說明符可能包含嵌套的替換欄位。"
"這些嵌套欄位可能包括它們自己的轉換欄位和 :ref:`格式說明符 "
"<formatspec>`，但可能不包括更深層嵌套的替換欄位。 :ref:`format specifier "
"mini-language <formatspec>` 與 :meth:`str.format` 方法使用的相同。"

#: ../../reference/lexical_analysis.rst:771
#, fuzzy
msgid ""
"Formatted string literals may be concatenated, but replacement fields cannot "
"be split across literals."
msgstr "格式化字串文字可以連接起來，但替換欄位不能跨文字拆分。"

#: ../../reference/lexical_analysis.rst:774
#, fuzzy
msgid "Some examples of formatted string literals::"
msgstr "格式化字串文字的一些示例::"

#: ../../reference/lexical_analysis.rst:806
#, fuzzy
msgid ""
"A consequence of sharing the same syntax as regular string literals is that "
"characters in the replacement fields must not conflict with the quoting used "
"in the outer formatted string literal::"
msgstr "與常規字串文字共享相同語法的結果是替換欄位中的字元不得與外部格式化字串文字中"
"使用的引號衝突："

#: ../../reference/lexical_analysis.rst:813
#, fuzzy
msgid ""
"Backslashes are not allowed in format expressions and will raise an error::"
msgstr "格式表達式中不允許使用反斜杠，否則會引發錯誤::"

#: ../../reference/lexical_analysis.rst:818
#, fuzzy
msgid ""
"To include a value in which a backslash escape is required, create a "
"temporary variable."
msgstr "要包含需要反斜杠轉義的值，請建立一個臨時變數。"

#: ../../reference/lexical_analysis.rst:825
#, fuzzy
msgid ""
"Formatted string literals cannot be used as docstrings, even if they do not "
"include expressions."
msgstr "格式化字串文字不能用作文檔字串，即使它們不包含表達式。"

#: ../../reference/lexical_analysis.rst:836
#, fuzzy
msgid ""
"See also :pep:`498` for the proposal that added formatted string literals, "
"and :meth:`str.format`, which uses a related format string mechanism."
msgstr "另請參閱 :pep:`498` 以了解新增格式化字串文字的提案，以及 :meth:`str."
"format`，它使用相關的格式字串機制。"

#: ../../reference/lexical_analysis.rst:843
#, fuzzy
msgid "Numeric literals"
msgstr "數字文字"

#: ../../reference/lexical_analysis.rst:849
#, fuzzy
msgid ""
"There are three types of numeric literals: integers, floating point numbers, "
"and imaginary numbers.  There are no complex literals (complex numbers can "
"be formed by adding a real number and an imaginary number)."
msgstr "數字字面量分為三種型別：整數、浮點數和虛數。沒有復雜的文字（複數可以通過新增"
"實數和虛數來形成）。"

#: ../../reference/lexical_analysis.rst:853
#, fuzzy
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr "請注意，數字文字不包含符號；像 ``-1``這樣的短語實際上是由一元運算符 ``-``和文字 ``1``"
"組成的表達式。"

#: ../../reference/lexical_analysis.rst:867
#, fuzzy
msgid "Integer literals"
msgstr "整數文字"

#: ../../reference/lexical_analysis.rst:869
#, fuzzy
msgid "Integer literals are described by the following lexical definitions:"
msgstr "整數文字由以下詞法定義描述："

#: ../../reference/lexical_analysis.rst:883
#, fuzzy
msgid ""
"There is no limit for the length of integer literals apart from what can be "
"stored in available memory."
msgstr "除了可以儲存在可用記憶體中的內容外，整數文字的長度沒有限制。"

#: ../../reference/lexical_analysis.rst:886
#, fuzzy
msgid ""
"Underscores are ignored for determining the numeric value of the literal.  "
"They can be used to group digits for enhanced readability.  One underscore "
"can occur between digits, and after base specifiers like ``0x``."
msgstr "在確定文字的數值時忽略底線。它們可用於對數字進行分組以增強可讀性。一個下劃"
"線可以出現在數字之間，也可以出現在像 ``0x``這樣的基本說明符之後。"

#: ../../reference/lexical_analysis.rst:890
#, fuzzy
msgid ""
"Note that leading zeros in a non-zero decimal number are not allowed. This "
"is for disambiguation with C-style octal literals, which Python used before "
"version 3.0."
msgstr "請注意，不允許在非零十進位數中使用前導零。這是為了消除 C "
"風格八進位文字的歧義，Python 在 3.0 版之前使用它。"

#: ../../reference/lexical_analysis.rst:894
#, fuzzy
msgid "Some examples of integer literals::"
msgstr "整數文字的一些示例::"

#: ../../reference/lexical_analysis.rst:900
#: ../../reference/lexical_analysis.rst:932
#, fuzzy
msgid "Underscores are now allowed for grouping purposes in literals."
msgstr "現在允許在文字中使用底線進行分組。"

#: ../../reference/lexical_analysis.rst:911
#, fuzzy
msgid "Floating point literals"
msgstr "浮點字面量"

#: ../../reference/lexical_analysis.rst:913
#, fuzzy
msgid ""
"Floating point literals are described by the following lexical definitions:"
msgstr "浮點文字由以下詞法定義描述："

#: ../../reference/lexical_analysis.rst:923
#, fuzzy
msgid ""
"Note that the integer and exponent parts are always interpreted using radix "
"10. For example, ``077e010`` is legal, and denotes the same number as "
"``77e10``. The allowed range of floating point literals is implementation-"
"dependent.  As in integer literals, underscores are supported for digit "
"grouping."
msgstr ""
"請注意，整數和指數部分始終使用基數 10 進行解釋。例如， ``077e010`` 是合法的，表示"
"與 ``77e10``相同的數字。浮點文字的允許範圍是依賴於實作的。與整數文字一樣，數字分"
"組支援底線。"

#: ../../reference/lexical_analysis.rst:928
#, fuzzy
msgid "Some examples of floating point literals::"
msgstr "浮點文字的一些示例::"

#: ../../reference/lexical_analysis.rst:941
#, fuzzy
msgid "Imaginary literals"
msgstr "虛字面量"

#: ../../reference/lexical_analysis.rst:943
#, fuzzy
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr "虛字面量由以下詞法定義描述："

#: ../../reference/lexical_analysis.rst:948
#, fuzzy
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and have "
"the same restrictions on their range.  To create a complex number with a "
"nonzero real part, add a floating point number to it, e.g., ``(3+4j)``.  "
"Some examples of imaginary literals::"
msgstr ""
"虛數字面值產生一個實部為 0.0 的複數。複數表示為一對浮點數，並且對它們的範圍有"
"相同的限制。要建立具有非零實部的複數，請向其新增浮點數，例如，``(3+4j)``。虛"
"構文字的一些示例::"

#: ../../reference/lexical_analysis.rst:960
#, fuzzy
msgid "Operators"
msgstr "運營商"

#: ../../reference/lexical_analysis.rst:964
#, fuzzy
msgid "The following tokens are operators:"
msgstr "以下標記是運算符："

#: ../../reference/lexical_analysis.rst:977
#, fuzzy
msgid "Delimiters"
msgstr "分隔符"

#: ../../reference/lexical_analysis.rst:981
#, fuzzy
msgid "The following tokens serve as delimiters in the grammar:"
msgstr "以下標記用作語法中的分隔符："

#: ../../reference/lexical_analysis.rst:990
#, fuzzy
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis literal. The "
"second half of the list, the augmented assignment operators, serve lexically "
"as delimiters, but also perform an operation."
msgstr ""
"句點也可以出現在浮點數和虛數文字中。三個句點的序列作為省略號文字具有特殊含義"
"。列表的後半部分，增強的賦值運算符，在詞法上用作分隔符，但也執行操作。"

#: ../../reference/lexical_analysis.rst:995
#, fuzzy
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer:"
msgstr "以下印出 ASCII "
"字元作為其他標記的一部分具有特殊含義，或者對詞法分析器具有其他重要意義："

#: ../../reference/lexical_analysis.rst:1002
#, fuzzy
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional error:"
msgstr "Python 中不使用以下印出 ASCII "
"字元。它們出現在字串文字和註釋之外是一個無條件錯誤："

#: ../../reference/lexical_analysis.rst:1011
msgid "Footnotes"
msgstr "註解"

#: ../../reference/lexical_analysis.rst:1012
msgid "https://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"
msgstr "https://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"
