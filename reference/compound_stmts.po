# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-14 00:15+0000\n"
"PO-Revision-Date: 2018-05-23 16:17+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr "複合陳述式"

#: ../../reference/compound_stmts.rst:9
#, fuzzy
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr "複合語句包含（組）其他語句；它們以某種方式影響或控制其他語句的執行。通常，複"
"合語句跨越多行，儘管在簡單的化身中，整個複合語句可能包含在一行中。"

#: ../../reference/compound_stmts.rst:14
#, fuzzy
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements, while the :keyword:"
"`with` statement allows the execution of initialization and finalization "
"code around a block of code.  Function and class definitions are also "
"syntactically compound statements."
msgstr ""
":keyword:`if`、:keyword:`while` 和 :keyword:`for` "
"語句實作了傳統的控制流結構。 :keyword:`try` "
"為一組語句指定例外處理程式和/或清理程式碼，而 :keyword:`with` 語句允許圍繞程式"
"碼塊執行初始化和結束程式碼。函式和類定義在句法上也是複合語句。"

#: ../../reference/compound_stmts.rst:26
#, fuzzy
msgid ""
"A compound statement consists of one or more 'clauses.'  A clause consists "
"of a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of a suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be "
"clear to which :keyword:`if` clause a following :keyword:`else` clause would "
"belong::"
msgstr ""
"複合語句由一個或多個“子句”組成。子句由標題和“套件”組成。特定複合語句的子句標"
"題都處於同一縮進級別。每個子句標題都以唯一標識的關鍵字開頭，並以冒號結尾。套"
"件是由子句控制的一組語句。套件可以是一個或多個分號分隔的簡單語句，位於與標題"
"相同的行中，跟在標題的冒號之後，也可以是後續行中的一個或多個縮進語句。只有後"
"一種形式的套件可以包含嵌套的複合語句；以下是非法的，主要是因為不清楚以下 "
":keyword:`else` 子句屬於哪個 :keyword:`if` 子句::"

#: ../../reference/compound_stmts.rst:39
#, fuzzy
msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :func:`print` "
"calls are executed::"
msgstr "另請注意，在此上下文中，分號比冒號綁定得更緊密，因此在以下示例中，"
"將執行所有或不執行任何 :func:`print` 呼叫::"

#: ../../reference/compound_stmts.rst:45
#, fuzzy
msgid "Summarizing:"
msgstr "總結："

#: ../../reference/compound_stmts.rst:69
#, fuzzy
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin with "
"a keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring nested :"
"keyword:`if` statements to be indented)."
msgstr ""
"請注意，語句總是以 ``NEWLINE`` 結尾，可能後跟一個 ``DEDENT``。另請注意，可選"
"的延續子句始終以不能啟動語句的關鍵字開頭，因此沒有歧義（'懸空 :keyword:`else`"
"'問題在 Python 中通過要求嵌套 :keyword:`if` 語句來解決縮進）。"

#: ../../reference/compound_stmts.rst:75
#, fuzzy
msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr "為了清楚起見，以下部分中語法規則的格式將每個子句放在單獨的行中。"

#: ../../reference/compound_stmts.rst:84
#, fuzzy
msgid "The :keyword:`!if` statement"
msgstr ":keyword:`!if` 語句"

#: ../../reference/compound_stmts.rst:92
#, fuzzy
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr ":keyword:`if` 語句用於條件執行："

#: ../../reference/compound_stmts.rst:99
#, fuzzy
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""
"它通過一個一個地評估表達式直到找到一個為真來選擇其中一個套件（有關 true 和 "
"false 的定義，請參閱 :ref:`booleans` 部分）；然後執行該套件（"
"並且不執行或評估 :keyword:`if` 語句的其他部分）。如果所有表達式均為假，"
"則執行 :keyword:`else` 子句的套件（如果存在）。"

#: ../../reference/compound_stmts.rst:109
#, fuzzy
msgid "The :keyword:`!while` statement"
msgstr ":keyword:`!while` 語句"

#: ../../reference/compound_stmts.rst:117
#, fuzzy
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ":keyword:`while` 語句用於重複執行，只要表達式為真："

#: ../../reference/compound_stmts.rst:124
#, fuzzy
msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested) "
"the suite of the :keyword:`!else` clause, if present, is executed and the "
"loop terminates."
msgstr ""
"這會反複測試表達式，如果為真，則執行第一個套件；如果表達式為假（這可能是它第"
"一次被測試），則執行 :keyword:`!else` 子句組（如果存在）並終止循環。"

#: ../../reference/compound_stmts.rst:133
#, fuzzy
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and goes back to testing the expression."
msgstr ""
"在第一個套件中執行的 :keyword:`break` 語句終止循環而不執行 :keyword:`!else` "
"子句的套件。在第一個套件中執行的 :keyword:`continue` "
"語句會跳過套件的其餘部分並回傳測試表達式。"

#: ../../reference/compound_stmts.rst:142
#, fuzzy
msgid "The :keyword:`!for` statement"
msgstr ":keyword:`!for` 語句"

#: ../../reference/compound_stmts.rst:153
#, fuzzy
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ":keyword:`for` "
"語句用於疊代序列（例如字串、元組或列表）或其他可疊代物件的元素："

#: ../../reference/compound_stmts.rst:160
#, fuzzy
msgid ""
"The ``starred_list`` expression is evaluated once; it should yield an :term:"
"`iterable` object.  An :term:`iterator` is created for that iterable. The "
"first item provided by the iterator is then assigned to the target list "
"using the standard rules for assignments (see :ref:`assignment`), and the "
"suite is executed.  This repeats for each item provided by the iterator.  "
"When the iterator is exhausted, the suite in the :keyword:`!else` clause, if "
"present, is executed, and the loop terminates."
msgstr ""
"``starred_list`` 表達式被計算一次；它應該產生一個 :term:`iterable` 物件。"
"一個 :term:`iterator` 是為那個可疊代物件建立的。疊代器提供的第一項然後使用標"
"準分配規則分配給目標列表（請參閱 :ref:`assignment`），然後執行套件。這對疊代"
"器提供的每個項目重複。當疊代器耗盡時，執行 :keyword:`!else` "
"子句中的套件（如果存在），然後循環終止。"

#: ../../reference/compound_stmts.rst:173
#, fuzzy
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and continues with the next item, or with the :keyword:`!else` clause if "
"there is no next item."
msgstr ""
"在第一個套件中執行的 :keyword:`break` 語句終止循環而不執行 :keyword:`!else` "
"子句的套件。在第一個套件中執行的 :keyword:`continue` "
"語句會跳過套件的其餘部分並繼續下一項，或者如果沒有下一項則使用 "
":keyword:`!else` 子句。"

#: ../../reference/compound_stmts.rst:179
#, fuzzy
msgid ""
"The for-loop makes assignments to the variables in the target list. This "
"overwrites all previous assignments to those variables including those made "
"in the suite of the for-loop::"
msgstr "for 循環對目標列表中的變數進行賦值。這將覆蓋所有以前對這些變數的賦值，"
"包括那些在 for 循環中所做的賦值："

#: ../../reference/compound_stmts.rst:193
#, fuzzy
msgid ""
"Names in the target list are not deleted when the loop is finished, but if "
"the sequence is empty, they will not have been assigned to at all by the "
"loop.  Hint: the built-in type :func:`range` represents immutable arithmetic "
"sequences of integers. For instance, iterating ``range(3)`` successively "
"yields 0, 1, and then 2."
msgstr ""
"循環結束時目標列表中的名稱不會被刪除，但如果序列為空，則循環根本不會分配給它"
"們。提示：內建型別 :func:`range` 表示不可變的整數算術序列。例如，依次疊代 "
"``range(3)`` 會產生 0、1，然後是 2。"

#: ../../reference/compound_stmts.rst:198
#, fuzzy
msgid "Starred elements are now allowed in the expression list."
msgstr "表達式列表中現在允許加星號的元素。"

#: ../../reference/compound_stmts.rst:205
#, fuzzy
msgid "The :keyword:`!try` statement"
msgstr ":keyword:`!try` 語句"

#: ../../reference/compound_stmts.rst:215
#, fuzzy
msgid ""
"The :keyword:`!try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ":keyword:`!try` 語句為一組語句指定例外處理程式和/或清理程式碼："

#: ../../reference/compound_stmts.rst:231
#, fuzzy
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information on using the :keyword:`raise` statement to "
"generate exceptions may be found in section :ref:`raise`."
msgstr ""
"有關例外的更多資訊可以在 :ref:`exceptions` 部分找到，有關使用 "
":keyword:`raise` 語句生成例外的資訊可以在 :ref:`raise` 部分找到。"

#: ../../reference/compound_stmts.rst:239
#, fuzzy
msgid ":keyword:`!except` clause"
msgstr ":keyword:`!except` 子句"

#: ../../reference/compound_stmts.rst:241
#, fuzzy
msgid ""
"The :keyword:`!except` clause(s) specify one or more exception handlers. "
"When no exception occurs in the :keyword:`try` clause, no exception handler "
"is executed. When an exception occurs in the :keyword:`!try` suite, a search "
"for an exception handler is started. This search inspects the :keyword:`!"
"except` clauses in turn until one is found that matches the exception. An "
"expression-less :keyword:`!except` clause, if present, must be last; it "
"matches any exception. For an :keyword:`!except` clause with an expression, "
"that expression is evaluated, and the clause matches the exception if the "
"resulting object is \"compatible\" with the exception.  An object is "
"compatible with an exception if the object is the class or a :term:`non-"
"virtual base class <abstract base class>` of the exception object, or a "
"tuple containing an item that is the class or a non-virtual base class of "
"the exception object."
msgstr ""
":keyword:`!except` 子句指定一個或多個例外處理程式。當 :keyword:`try` "
"子句中沒有例外發生時，不執行任何例外處理程式。當 :keyword:`!try` "
"套件中發生例外時，將開始搜索例外處理程式。此搜索依次檢查 :keyword:`!except` "
"子句，直到找到與例外匹配的子句。一個無表達式的 :keyword:`!except` "
"子句，如果存在，必須放在最後；它匹配任何例外。對於帶有表達式的 "
":keyword:`!except` "
"子句，計算該表達式，如果結果物件與例外“相容”，則該子句匹配例外。"
"如果對像是例外物件的類或非虛擬基底類別 <abstract base class> "
"，或者包含作為類或非虛擬項的元組，則該物件與例外相容例外物件的基底類別。"

#: ../../reference/compound_stmts.rst:256
#, fuzzy
msgid ""
"If no :keyword:`!except` clause matches the exception, the search for an "
"exception handler continues in the surrounding code and on the invocation "
"stack.  [#]_"
msgstr "如果沒有 :keyword:`!except` "
"子句匹配例外，則在周圍程式碼和呼叫堆疊中繼續搜索例外處理程式。 [#]_"

#: ../../reference/compound_stmts.rst:260
#, fuzzy
msgid ""
"If the evaluation of an expression in the header of an :keyword:`!except` "
"clause raises an exception, the original search for a handler is canceled "
"and a search starts for the new exception in the surrounding code and on the "
"call stack (it is treated as if the entire :keyword:`try` statement raised "
"the exception)."
msgstr ""
"如果 :keyword:`!except` 子句頭部的表達式求值引發例外，則取消對處理程式的原始"
"搜索，並開始在周圍程式碼和呼叫堆疊中搜索新例外（它被視為整個 :keyword:`try` "
"語句引發了例外）。"

#: ../../reference/compound_stmts.rst:268
#, fuzzy
msgid ""
"When a matching :keyword:`!except` clause is found, the exception is "
"assigned to the target specified after the :keyword:`!as` keyword in that :"
"keyword:`!except` clause, if present, and the :keyword:`!except` clause's "
"suite is executed. All :keyword:`!except` clauses must have an executable "
"block. When the end of this block is reached, execution continues normally "
"after the entire :keyword:`try` statement. (This means that if two nested "
"handlers exist for the same exception, and the exception occurs in the :"
"keyword:`!try` clause of the inner handler, the outer handler will not "
"handle the exception.)"
msgstr ""
"當找到匹配的 :keyword:`!except` 子句時，將例外分配給在該 :keyword:`!except` "
"子句中的 :keyword:`!as` 關鍵字之後指定的目標，如果存在，以及 :keyword "
":`!except` 子句的套件被執行。所有 :keyword:`!except` "
"子句都必須有一個可執行塊。當到達此塊的末尾時，在整個 :keyword:`try` "
"語句之後繼續正常執行。 （這意味著如果同一個例外存在兩個嵌套處理程式，"
"並且例外發生在內部處理程式的 :keyword:`!try` "
"子句中，外部處理程式將不會處理該例外。）"

#: ../../reference/compound_stmts.rst:279
#, fuzzy
msgid ""
"When an exception has been assigned using ``as target``, it is cleared at "
"the end of the :keyword:`!except` clause.  This is as if ::"
msgstr "當使用 ``as target`` 分配例外時，它會在 :keyword:`!except` "
"子句的末尾被清除。這好像::"

#: ../../reference/compound_stmts.rst:285
#, fuzzy
msgid "was translated to ::"
msgstr "被翻譯成::"

#: ../../reference/compound_stmts.rst:293
#, fuzzy
msgid ""
"This means the exception must be assigned to a different name to be able to "
"refer to it after the :keyword:`!except` clause. Exceptions are cleared "
"because with the traceback attached to them, they form a reference cycle "
"with the stack frame, keeping all locals in that frame alive until the next "
"garbage collection occurs."
msgstr ""
"這意味著必須將例外分配給不同的名稱才能在 :keyword:`!except` 子句之後引用它。"
"例外被清除是因為附加了追溯，它們與堆疊幀形成了一個引用循環，使該幀中的所有局"
"部變數保持活動狀態，直到下一次垃圾收集發生。"

#: ../../reference/compound_stmts.rst:303
#, fuzzy
msgid ""
"Before an :keyword:`!except` clause's suite is executed, the exception is "
"stored in the :mod:`sys` module, where it can be accessed from within the "
"body of the :keyword:`!except` clause by calling :func:`sys.exception`. When "
"leaving an exception handler, the exception stored in the :mod:`sys` module "
"is reset to its previous value::"
msgstr ""
"在執行 :keyword:`!except` 子句的套件之前，例外儲存在 :mod:`sys` 模組中，"
"可以通過呼叫從 :keyword:`!except` 子句的主體中訪問它 :func:`sys."
"exception`。離開例外處理程式時，儲存在 :mod:`sys` "
"模組中的例外將重置為其先前的值::"

#: ../../reference/compound_stmts.rst:334
#, fuzzy
msgid ":keyword:`!except*` clause"
msgstr ":keyword:`!except*` 子句"

#: ../../reference/compound_stmts.rst:336
#, fuzzy
msgid ""
"The :keyword:`!except*` clause(s) are used for handling :exc:"
"`ExceptionGroup`\\s. The exception type for matching is interpreted as in "
"the case of :keyword:`except`, but in the case of exception groups we can "
"have partial matches when the type matches some of the exceptions in the "
"group. This means that multiple :keyword:`!except*` clauses can execute, "
"each handling part of the exception group. Each clause executes at most once "
"and handles an exception group of all matching exceptions.  Each exception "
"in the group is handled by at most one :keyword:`!except*` clause, the first "
"that matches it. ::"
msgstr ""
":keyword:`!except*` 子句用於處理 :exc:`ExceptionGroup`\\s。"
"匹配的例外型別被解釋為在 :keyword:`except` 的情況下，但在例外組的情況下，當型"
"別與組中的某些例外匹配時，我們可以進行部分匹配。這意味著可以執行多個 "
":keyword:`!except*` 子句，每個子句處理例外組的一部分。每個子句最多執行一次並"
"處理所有匹配例外的例外組。組中的每個例外最多由一個 :keyword:`!except*` "
"子句處理，第一個匹配它。 ::"

#: ../../reference/compound_stmts.rst:364
#, fuzzy
msgid ""
"Any remaining exceptions that were not handled by any :keyword:`!except*` "
"clause are re-raised at the end, combined into an exception group along with "
"all exceptions that were raised from within :keyword:`!except*` clauses."
msgstr ""
"任何未被任何 :keyword:`!except*` 子句處理的剩餘例外在末尾重新引發，與所有從 "
":keyword:`!except*` 子句中引發的例外一起組合到一個例外組中。"

#: ../../reference/compound_stmts.rst:368
#, fuzzy
msgid ""
"If the raised exception is not an exception group and its type matches one "
"of the :keyword:`!except*` clauses, it is caught and wrapped by an exception "
"group with an empty message string. ::"
msgstr "如果引發的例外不是例外組並且其型別與 :keyword:`!except*` "
"子句之一匹配，則它會被例外組捕獲並包裝為空消息字串。 ::"

#: ../../reference/compound_stmts.rst:379
#, fuzzy
msgid ""
"An :keyword:`!except*` clause must have a matching type, and this type "
"cannot be a subclass of :exc:`BaseExceptionGroup`. It is not possible to "
"mix :keyword:`except` and :keyword:`!except*` in the same :keyword:`try`. :"
"keyword:`break`, :keyword:`continue` and :keyword:`return` cannot appear in "
"an :keyword:`!except*` clause."
msgstr ""
":keyword:`!except*` 子句必須具有匹配型別，並且此型別不能是 "
":exc:`BaseExceptionGroup` 的子類別。不能在同一個 :keyword:`try` 中混合使用 "
":keyword:`except` 和 :keyword:`!except*` 。 "
":keyword:`break`、:keyword:`continue` 和 :keyword:`return` "
"不能出現在 :keyword:`!except*` 子句中。"

#: ../../reference/compound_stmts.rst:396
#, fuzzy
msgid ":keyword:`!else` clause"
msgstr ":keyword:`!else` 子句"

#: ../../reference/compound_stmts.rst:398
#, fuzzy
msgid ""
"The optional :keyword:`!else` clause is executed if the control flow leaves "
"the :keyword:`try` suite, no exception was raised, and no :keyword:"
"`return`, :keyword:`continue`, or :keyword:`break` statement was executed.  "
"Exceptions in the :keyword:`!else` clause are not handled by the preceding :"
"keyword:`except` clauses."
msgstr ""
"如果控制流離開 :keyword:`try` "
"套件，沒有引發例外，並且沒有 :keyword:`return`、 :keyword:`continue` "
"或：keyword，則執行可選的 :keyword:`!else` 子句:`break` 語句被執行。 "
":keyword:`!else` 子句中的例外不由前面的 :keyword:`except` 子句處理。"

#: ../../reference/compound_stmts.rst:410
#, fuzzy
msgid ":keyword:`!finally` clause"
msgstr ":keyword:`!finally` 子句"

#: ../../reference/compound_stmts.rst:412
#, fuzzy
msgid ""
"If :keyword:`!finally` is present, it specifies a 'cleanup' handler.  The :"
"keyword:`try` clause is executed, including any :keyword:`except` and :"
"keyword:`else` clauses.  If an exception occurs in any of the clauses and is "
"not handled, the exception is temporarily saved. The :keyword:`!finally` "
"clause is executed.  If there is a saved exception it is re-raised at the "
"end of the :keyword:`!finally` clause.  If the :keyword:`!finally` clause "
"raises another exception, the saved exception is set as the context of the "
"new exception. If the :keyword:`!finally` clause executes a :keyword:"
"`return`, :keyword:`break` or :keyword:`continue` statement, the saved "
"exception is discarded::"
msgstr ""
"如果 :keyword:`!finally` 存在，它指定了一個“清理”處理程式。執行 "
":keyword:`try` 子句，包括任何 :keyword:`except` 和 :keyword:`else` "
"子句。如果任何一個子句出現例外，沒有處理，則暫時保存該例外。 "
":keyword:`!finally` 子句被執行。如果存在已保存的例外，則會在 "
":keyword:`!finally` 子句的末尾重新引發。如果 :keyword:`!finally` "
"子句引發另一個例外，保存的例外將設定為新例外的上下文。如果 :keyword:`!finally`"
" 子句執行 :keyword:`return`、:keyword:`break` 或 :keyword:`continue` "
"語句，保存的例外將被丟棄::"

#: ../../reference/compound_stmts.rst:431
#, fuzzy
msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`!finally` clause."
msgstr "在 :keyword:`!finally` 子句執行期間，程式無法使用例外資訊。"

#: ../../reference/compound_stmts.rst:439
#, fuzzy
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`!try`...\\ :keyword:`!"
"finally` statement, the :keyword:`!finally` clause is also executed 'on the "
"way out.'"
msgstr ""
"當 :keyword:`return`、:keyword:`break` 或 :keyword:`continue` "
"語句在 :keyword:`!try` 的 :keyword:`try` 套件中執行...\\ :keyword: `!finally` "
"語句，:keyword:`!finally` 子句也在“輸出的路上”執行。"

#: ../../reference/compound_stmts.rst:443
#, fuzzy
msgid ""
"The return value of a function is determined by the last :keyword:`return` "
"statement executed.  Since the :keyword:`!finally` clause always executes, "
"a :keyword:`!return` statement executed in the :keyword:`!finally` clause "
"will always be the last one executed::"
msgstr ""
"函式的回傳值由最後執行的 :keyword:`return` 語句決定。由於 :keyword:`!finally` "
"子句始終執行，因此在 :keyword:`!finally` 子句中執行的 :keyword:`!return` "
"語句將始終是最後執行的語句::"

#: ../../reference/compound_stmts.rst:457
#, fuzzy
msgid ""
"Prior to Python 3.8, a :keyword:`continue` statement was illegal in the :"
"keyword:`!finally` clause due to a problem with the implementation."
msgstr ""
"在 Python 3.8 之前，由於實作問題，:keyword:`continue` 語句在 "
":keyword:`!finally` 子句中是非法的。"

#: ../../reference/compound_stmts.rst:466
#, fuzzy
msgid "The :keyword:`!with` statement"
msgstr ":keyword:`!with` 語句"

#: ../../reference/compound_stmts.rst:475
#, fuzzy
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`...\\ :keyword:"
"`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""
":keyword:`with` 語句用於使用上下文管理器定義的方法包裝塊的執行（請參閱 :ref"
":`context-managers` 部分）。這允許封裝常見的 :keyword:`try`...\\ "
":keyword:`except`...\\ :keyword:`finally` 使用模式以便於重用。"

#: ../../reference/compound_stmts.rst:485
#, fuzzy
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as "
"follows:"
msgstr "帶有一個 ``item``的 :keyword:`with` 語句的執行過程如下："

#: ../../reference/compound_stmts.rst:487
#, fuzzy
msgid ""
"The context expression (the expression given in the :token:`~python-grammar:"
"with_item`) is evaluated to obtain a context manager."
msgstr "評估上下文表達式（在 :token:`~python-grammar:with_item` "
"中給出的表達式）以獲得上下文管理器。"

#: ../../reference/compound_stmts.rst:490
#, fuzzy
msgid "The context manager's :meth:`__enter__` is loaded for later use."
msgstr "加載上下文管理器的 :meth:`__enter__` 供以後使用。"

#: ../../reference/compound_stmts.rst:492
#, fuzzy
msgid "The context manager's :meth:`__exit__` is loaded for later use."
msgstr "加載上下文管理器的 :meth:`__exit__` 供以後使用。"

#: ../../reference/compound_stmts.rst:494
#, fuzzy
msgid "The context manager's :meth:`__enter__` method is invoked."
msgstr "上下文管理器的 :meth:`__enter__` 方法被呼叫。"

#: ../../reference/compound_stmts.rst:496
#, fuzzy
msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`__enter__` is assigned to it."
msgstr "如果目標包含在 :keyword:`with` 語句中，則 :meth:`__enter__` "
"的回傳值將分配給它。"

#: ../../reference/compound_stmts.rst:501
#, fuzzy
msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`__enter__` "
"method returns without an error, then :meth:`__exit__` will always be "
"called. Thus, if an error occurs during the assignment to the target list, "
"it will be treated the same as an error occurring within the suite would be. "
"See step 7 below."
msgstr ""
":keyword:`with` 語句保證如果 :meth:`__enter__` 方法沒有錯誤回傳，那麼 "
":meth:`__exit__` 將始終被呼叫。因此，如果在分配給目標列表期間發生錯誤，它將被"
"視為與套件內發生的錯誤相同。請參閱下面的步驟 7。"

#: ../../reference/compound_stmts.rst:507
#, fuzzy
msgid "The suite is executed."
msgstr "該套件已執行。"

#: ../../reference/compound_stmts.rst:509
#, fuzzy
msgid ""
"The context manager's :meth:`__exit__` method is invoked.  If an exception "
"caused the suite to be exited, its type, value, and traceback are passed as "
"arguments to :meth:`__exit__`. Otherwise, three :const:`None` arguments are "
"supplied."
msgstr ""
"上下文管理器的 :meth:`__exit__` 方法被呼叫。如果例外導致套件退出，其型別、"
"值和回溯將作為參數傳遞給 :meth:`__exit__`。否則，提供三個 :const:`None` "
"參數。"

#: ../../reference/compound_stmts.rst:514
#, fuzzy
msgid ""
"If the suite was exited due to an exception, and the return value from the :"
"meth:`__exit__` method was false, the exception is reraised.  If the return "
"value was true, the exception is suppressed, and execution continues with "
"the statement following the :keyword:`with` statement."
msgstr ""
"如果套件因例外而退出，並且 :meth:`__exit__` 方法的回傳值為 false，則會重新引"
"發例外。如果回傳值為真，則例外被抑制，並繼續執行 :keyword:`with` "
"語句之後的語句。"

#: ../../reference/compound_stmts.rst:519
#, fuzzy
msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`__exit__` is ignored, and execution proceeds at the normal "
"location for the kind of exit that was taken."
msgstr "如果套件因例外以外的任何原因退出，則 :meth:`__exit__` "
"的回傳值將被忽略，並在正常位置繼續執行所採用的退出型別。"

#: ../../reference/compound_stmts.rst:523
#: ../../reference/compound_stmts.rst:1514
#: ../../reference/compound_stmts.rst:1555
#, fuzzy
msgid "The following code::"
msgstr "以下程式碼：："

#: ../../reference/compound_stmts.rst:528
#: ../../reference/compound_stmts.rst:553
#: ../../reference/compound_stmts.rst:1560
#, fuzzy
msgid "is semantically equivalent to::"
msgstr "在語義上等同於：："

#: ../../reference/compound_stmts.rst:547
#, fuzzy
msgid ""
"With more than one item, the context managers are processed as if multiple :"
"keyword:`with` statements were nested::"
msgstr "對於多個項目，上下文管理器的處理就像嵌套了多個 :keyword:`with` 語句::"

#: ../../reference/compound_stmts.rst:559
#, fuzzy
msgid ""
"You can also write multi-item context managers in multiple lines if the "
"items are surrounded by parentheses. For example::"
msgstr "如果項目被括號括起來，您還可以在多行中編寫多項目上下文管理器。例如：："

#: ../../reference/compound_stmts.rst:568
#, fuzzy
msgid "Support for multiple context expressions."
msgstr "支援多個上下文表達式。"

#: ../../reference/compound_stmts.rst:571
#, fuzzy
msgid ""
"Support for using grouping parentheses to break the statement in multiple "
"lines."
msgstr "支援使用分組括號將語句分成多行。"

#: ../../reference/compound_stmts.rst:577
#, fuzzy
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` -  ``with``語句"

#: ../../reference/compound_stmts.rst:577
#, fuzzy
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Python :keyword:`with` 語句的規範、背景和示例。"

#: ../../reference/compound_stmts.rst:583
#, fuzzy
msgid "The :keyword:`!match` statement"
msgstr ":keyword:`!match` 語句"

#: ../../reference/compound_stmts.rst:597
#, fuzzy
msgid "The match statement is used for pattern matching.  Syntax:"
msgstr "match 語句用於模式匹配。句法："

#: ../../reference/compound_stmts.rst:606
#, fuzzy
msgid ""
"This section uses single quotes to denote :ref:`soft keywords <soft-"
"keywords>`."
msgstr "本節使用單引號表示 :ref:`soft keywords <soft-keywords>`。"

#: ../../reference/compound_stmts.rst:609
#, fuzzy
msgid ""
"Pattern matching takes a pattern as input (following ``case``) and a subject "
"value (following ``match``).  The pattern (which may contain subpatterns) is "
"matched against the subject value.  The outcomes are:"
msgstr "模式匹配將模式作為輸入（在 ``case``之後）和主題值（在 ``match``之後）。模式（可能包"
"含子模式）與主題值匹配。結果是："

#: ../../reference/compound_stmts.rst:613
#, fuzzy
msgid "A match success or failure (also termed a pattern success or failure)."
msgstr "匹配成功或失敗（也稱為模式成功或失敗）。"

#: ../../reference/compound_stmts.rst:615
#, fuzzy
msgid ""
"Possible binding of matched values to a name.  The prerequisites for this "
"are further discussed below."
msgstr "可能將匹配值綁定到名稱。其先決條件將在下文進一步討論。"

#: ../../reference/compound_stmts.rst:618
#, fuzzy
msgid ""
"The ``match`` and ``case`` keywords are :ref:`soft keywords <soft-keywords>`."
msgstr "``match`` 和 ``case`` 關鍵字是 :ref:`soft keywords <soft-keywords>`。"

#: ../../reference/compound_stmts.rst:622
#: ../../reference/compound_stmts.rst:1177
#, fuzzy
msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` -- 結構模式匹配：規範"

#: ../../reference/compound_stmts.rst:623
#: ../../reference/compound_stmts.rst:1178
#, fuzzy
msgid ":pep:`636` -- Structural Pattern Matching: Tutorial"
msgstr ":pep:`636` -- 結構模式匹配：教程"

#: ../../reference/compound_stmts.rst:627
#, fuzzy
msgid "Overview"
msgstr "概述"

#: ../../reference/compound_stmts.rst:629
#, fuzzy
msgid "Here's an overview of the logical flow of a match statement:"
msgstr "以下是匹配語句邏輯流程的概述："

#: ../../reference/compound_stmts.rst:632
#, fuzzy
msgid ""
"The subject expression ``subject_expr`` is evaluated and a resulting subject "
"value obtained. If the subject expression contains a comma, a tuple is "
"constructed using :ref:`the standard rules <typesseq-tuple>`."
msgstr ""
"評估主題表達式“subject_expr”並獲得結果主題值。如果主題表達式包含逗號，"
"則使用標準規則 <typesseq-tuple> 構造元組。"

#: ../../reference/compound_stmts.rst:636
#, fuzzy
msgid ""
"Each pattern in a ``case_block`` is attempted to match with the subject "
"value. The specific rules for success or failure are described below. The "
"match attempt can also bind some or all of the standalone names within the "
"pattern. The precise pattern binding rules vary per pattern type and are "
"specified below.  **Name bindings made during a successful pattern match "
"outlive the executed block and can be used after the match statement**."
msgstr ""
"``case_block`` 中的每個模式都試圖與主題值匹配。成功或失敗的具體規則如下所述。"
"匹配嘗試還可以綁定模式中的部分或全部獨立名稱。精確的模式綁定規則因模式型別而"
"異，如下所述。 **在成功的模式匹配期間進行的名稱綁定比執行的塊更有效，並且可以"
"在匹配語句之後使用**。"

#: ../../reference/compound_stmts.rst:645
#, fuzzy
msgid ""
"During failed pattern matches, some subpatterns may succeed.  Do not rely on "
"bindings being made for a failed match.  Conversely, do not rely on "
"variables remaining unchanged after a failed match.  The exact behavior is "
"dependent on implementation and may vary.  This is an intentional decision "
"made to allow different implementations to add optimizations."
msgstr ""
"在模式匹配失敗期間，一些子模式可能會成功。不要依賴為失敗的匹配所做的綁定。相"
"反，不要依賴在匹配失敗後保持不變的變數。確切的行為取決於實作並且可能會有所不"
"同。這是一個有意的決定，允許不同的實作新增最佳化。"

#: ../../reference/compound_stmts.rst:652
#, fuzzy
msgid ""
"If the pattern succeeds, the corresponding guard (if present) is evaluated. "
"In this case all name bindings are guaranteed to have happened."
msgstr "如果模式成功，則評估相應的守衛（如果存在）。在這種情況下，所有名稱綁定都可以"
"保證發生。"

#: ../../reference/compound_stmts.rst:655
#, fuzzy
msgid ""
"If the guard evaluates as true or is missing, the ``block`` inside "
"``case_block`` is executed."
msgstr "如果守衛評估為真或缺失，則執行 ``case_block`` 中的``block``。"

#: ../../reference/compound_stmts.rst:658
#, fuzzy
msgid "Otherwise, the next ``case_block`` is attempted as described above."
msgstr "否則，將如上所述嘗試下一個“case_block”。"

#: ../../reference/compound_stmts.rst:660
#, fuzzy
msgid "If there are no further case blocks, the match statement is completed."
msgstr "如果沒有更多的 case 塊，則匹配語句完成。"

#: ../../reference/compound_stmts.rst:664
#, fuzzy
msgid ""
"Users should generally never rely on a pattern being evaluated.  Depending "
"on implementation, the interpreter may cache values or use other "
"optimizations which skip repeated evaluations."
msgstr "使用者通常不應依賴正在評估的模式。根據實作，直譯器可以快取值或使用其他跳過重"
"複評估的最佳化。"

#: ../../reference/compound_stmts.rst:668
#, fuzzy
msgid "A sample match statement::"
msgstr "示例匹配語句::"

#: ../../reference/compound_stmts.rst:684
#, fuzzy
msgid ""
"In this case, ``if flag`` is a guard.  Read more about that in the next "
"section."
msgstr "在這種情況下，``if flag`` 是一個守衛。在下一節中閱讀更多相關資訊。"

#: ../../reference/compound_stmts.rst:687
#, fuzzy
msgid "Guards"
msgstr "衛兵"

#: ../../reference/compound_stmts.rst:694
#, fuzzy
msgid ""
"A ``guard`` (which is part of the ``case``) must succeed for code inside the "
"``case`` block to execute.  It takes the form: :keyword:`if` followed by an "
"expression."
msgstr ""
"``guard``（它是``case`` 的一部分）必須成功才能執行``case`` "
"塊中的程式碼。它採用以下形式： :keyword:`if` 後跟一個表達式。"

#: ../../reference/compound_stmts.rst:699
#, fuzzy
msgid "The logical flow of a ``case`` block with a ``guard`` follows:"
msgstr "帶有 ``guard`` 的 ``case`` 塊的邏輯流程如下："

#: ../../reference/compound_stmts.rst:701
#, fuzzy
msgid ""
"Check that the pattern in the ``case`` block succeeded.  If the pattern "
"failed, the ``guard`` is not evaluated and the next ``case`` block is "
"checked."
msgstr "檢查 ``case`` 塊中的模式是否成功。如果模式失敗，則不評估 ``guard`` "
"並檢查下一個 ``case`` 塊。"

#: ../../reference/compound_stmts.rst:705
#, fuzzy
msgid "If the pattern succeeded, evaluate the ``guard``."
msgstr "如果模式成功，則評估 ``guard``。"

#: ../../reference/compound_stmts.rst:707
#, fuzzy
msgid ""
"If the ``guard`` condition evaluates as true, the case block is selected."
msgstr "如果 ``guard`` 條件評估為真，則選擇 case 塊。"

#: ../../reference/compound_stmts.rst:710
#, fuzzy
msgid ""
"If the ``guard`` condition evaluates as false, the case block is not "
"selected."
msgstr "如果 ``guard`` 條件評估為 false，則不會選擇 case 塊。"

#: ../../reference/compound_stmts.rst:713
#, fuzzy
msgid ""
"If the ``guard`` raises an exception during evaluation, the exception "
"bubbles up."
msgstr "如果 ``guard`` 在評估期間引發例外，例外就會冒出來。"

#: ../../reference/compound_stmts.rst:716
#, fuzzy
msgid ""
"Guards are allowed to have side effects as they are expressions.  Guard "
"evaluation must proceed from the first to the last case block, one at a "
"time, skipping case blocks whose pattern(s) don't all succeed. (I.e., guard "
"evaluation must happen in order.) Guard evaluation must stop once a case "
"block is selected."
msgstr ""
"守衛可以有副作用，因為它們是表達式。保護評估必須從第一個 case "
"塊開始到最後一個 case 塊，一次一個，跳過模式不全部成功的 case 塊。 "
"（即，守衛評估必須按順序進行。）一旦選擇了一個案例塊，守衛評估就必須停止。"

#: ../../reference/compound_stmts.rst:726
#, fuzzy
msgid "Irrefutable Case Blocks"
msgstr "無可辯駁的案例塊"

#: ../../reference/compound_stmts.rst:730
#, fuzzy
msgid ""
"An irrefutable case block is a match-all case block.  A match statement may "
"have at most one irrefutable case block, and it must be last."
msgstr ""
"無可辯駁的 case 塊是 match-all case 塊。一個 match 語句最多可以有一個 "
"irrefutable case 塊，而且它必須是最後一個。"

#: ../../reference/compound_stmts.rst:733
#, fuzzy
msgid ""
"A case block is considered irrefutable if it has no guard and its pattern is "
"irrefutable.  A pattern is considered irrefutable if we can prove from its "
"syntax alone that it will always succeed.  Only the following patterns are "
"irrefutable:"
msgstr ""
"如果一個 case 塊沒有守衛並且它的模式是無可辯駁的，那麼它被認為是無可辯駁的。"
"如果我們可以僅從其語法證明它總是成功，則該模式被認為是無可辯駁的。只有以下模"
"式是無可辯駁的："

#: ../../reference/compound_stmts.rst:738
#, fuzzy
msgid ":ref:`as-patterns` whose left-hand side is irrefutable"
msgstr ":ref:`as-patterns` 左邊是無可辯駁的"

#: ../../reference/compound_stmts.rst:740
#, fuzzy
msgid ":ref:`or-patterns` containing at least one irrefutable pattern"
msgstr ":ref:`or-patterns` 包含至少一個無可辯駁的模式"

#: ../../reference/compound_stmts.rst:742
msgid ":ref:`capture-patterns`"
msgstr ":ref:`capture-patterns`"

#: ../../reference/compound_stmts.rst:744
msgid ":ref:`wildcard-patterns`"
msgstr ":ref:`wildcard-patterns`"

#: ../../reference/compound_stmts.rst:746
#, fuzzy
msgid "parenthesized irrefutable patterns"
msgstr "括號內的無可辯駁的模式"

#: ../../reference/compound_stmts.rst:750
#, fuzzy
msgid "Patterns"
msgstr "圖案"

#: ../../reference/compound_stmts.rst:757
#, fuzzy
msgid "This section uses grammar notations beyond standard EBNF:"
msgstr "本節使用標準 EBNF 之外的語法符號："

#: ../../reference/compound_stmts.rst:759
#, fuzzy
msgid "the notation ``SEP.RULE+`` is shorthand for ``RULE (SEP RULE)*``"
msgstr "符號 ``SEP.RULE+`` 是 ``RULE (SEP RULE)*`` 的簡寫"

#: ../../reference/compound_stmts.rst:761
#, fuzzy
msgid "the notation ``!RULE`` is shorthand for a negative lookahead assertion"
msgstr "符號 `!RULE`` 是否定先行斷言的簡寫"

#: ../../reference/compound_stmts.rst:764
#, fuzzy
msgid "The top-level syntax for ``patterns`` is:"
msgstr "``patterns`` 的頂級語法是："

#: ../../reference/compound_stmts.rst:778
#, fuzzy
msgid ""
"The descriptions below will include a description \"in simple terms\" of "
"what a pattern does for illustration purposes (credits to Raymond Hettinger "
"for a document that inspired most of the descriptions). Note that these "
"descriptions are purely for illustration purposes and **may not** reflect "
"the underlying implementation.  Furthermore, they do not cover all valid "
"forms."
msgstr ""
"下面的描述將包括一個“簡單的”描述，用於說明模式的作用（對 Raymond Hettinger 的"
"文檔的貢獻，該文檔激發了大部分描述）。請注意，這些描述僅用於說明目的，**可能"
"不**反映底層實作。此外，它們並未涵蓋所有有效形式。"

#: ../../reference/compound_stmts.rst:788
#, fuzzy
msgid "OR Patterns"
msgstr "或模式"

#: ../../reference/compound_stmts.rst:790
#, fuzzy
msgid ""
"An OR pattern is two or more patterns separated by vertical bars ``|``.  "
"Syntax:"
msgstr "OR 模式是由豎線 ``|``分隔的兩個或多個模式。句法："

#: ../../reference/compound_stmts.rst:796
#, fuzzy
msgid ""
"Only the final subpattern may be :ref:`irrefutable <irrefutable_case>`, and "
"each subpattern must bind the same set of names to avoid ambiguity."
msgstr ""
"只有最終的子模式可能是 :ref:`irrefutable "
"<irrefutable_case>`，並且每個子模式必須綁定同一組名稱以避免歧義。"

#: ../../reference/compound_stmts.rst:799
#, fuzzy
msgid ""
"An OR pattern matches each of its subpatterns in turn to the subject value, "
"until one succeeds.  The OR pattern is then considered successful.  "
"Otherwise, if none of the subpatterns succeed, the OR pattern fails."
msgstr "OR 模式依次將其每個子模式與主題值匹配，直到一個成功。 OR "
"模式然後被認為是成功的。否則，如果沒有一個子模式成功，則 OR 模式失敗。"

#: ../../reference/compound_stmts.rst:803
#, fuzzy
msgid ""
"In simple terms, ``P1 | P2 | ...`` will try to match ``P1``, if it fails it "
"will try to match ``P2``, succeeding immediately if any succeeds, failing "
"otherwise."
msgstr "簡單來說，``P1 | P2 | ...`` 將嘗試匹配 ``P1``，如果失敗，它將嘗試匹配 "
"``P2``，如果成功則立即成功，否則失敗。"

#: ../../reference/compound_stmts.rst:809
#, fuzzy
msgid "AS Patterns"
msgstr "作為模式"

#: ../../reference/compound_stmts.rst:811
#, fuzzy
msgid ""
"An AS pattern matches an OR pattern on the left of the :keyword:`as` keyword "
"against a subject.  Syntax:"
msgstr "AS 模式將 :keyword:`as` 關鍵字左側的 OR 模式與主題相匹配。句法："

#: ../../reference/compound_stmts.rst:817
#, fuzzy
msgid ""
"If the OR pattern fails, the AS pattern fails.  Otherwise, the AS pattern "
"binds the subject to the name on the right of the as keyword and succeeds. "
"``capture_pattern`` cannot be a ``_``."
msgstr ""
"如果 OR 模式失敗，則 AS 模式失敗。否則，AS 模式將主題綁定到 as "
"關鍵字右側的名稱並成功。 ``capture_pattern`` 不能是 ``_``。"

#: ../../reference/compound_stmts.rst:821
#, fuzzy
msgid ""
"In simple terms ``P as NAME`` will match with ``P``, and on success it will "
"set ``NAME = <subject>``."
msgstr "簡單來說，``P as NAME`` 將與 ``P`` 匹配，成功時它將設定 ``NAME = "
"<subject>``。"

#: ../../reference/compound_stmts.rst:828
#, fuzzy
msgid "Literal Patterns"
msgstr "文字模式"

#: ../../reference/compound_stmts.rst:830
#, fuzzy
msgid ""
"A literal pattern corresponds to most :ref:`literals <literals>` in Python.  "
"Syntax:"
msgstr "文字模式對應於 Python 中的大多數 :ref:`literals <literals>`。句法："

#: ../../reference/compound_stmts.rst:843
#, fuzzy
msgid ""
"The rule ``strings`` and the token ``NUMBER`` are defined in the :doc:"
"`standard Python grammar <./grammar>`.  Triple-quoted strings are "
"supported.  Raw strings and byte strings are supported.  :ref:`f-strings` "
"are not supported."
msgstr ""
"規則``strings`` 和標記``NUMBER`` 在 :doc:`標準Python 語法<./grammar>` "
"中定義。支援三引號字串。支援原始字串和位元組字串。 :ref: 不支援 f-strings。"

#: ../../reference/compound_stmts.rst:848
#, fuzzy
msgid ""
"The forms ``signed_number '+' NUMBER`` and ``signed_number '-' NUMBER`` are "
"for expressing :ref:`complex numbers <imaginary>`; they require a real "
"number on the left and an imaginary number on the right. E.g. ``3 + 4j``."
msgstr ""
"形式 ``signed_number '+' NUMBER`` 和 ``signed_number '-' NUMBER`` "
"用於表示 :ref:`複數 <imaginary>`；他們要求左邊是實數，右邊是虛數。例如。 ``"
"3 + 4j``。"

#: ../../reference/compound_stmts.rst:852
#, fuzzy
msgid ""
"In simple terms, ``LITERAL`` will succeed only if ``<subject> == LITERAL``. "
"For the singletons ``None``, ``True`` and ``False``, the :keyword:`is` "
"operator is used."
msgstr ""
"簡單來說，只有在 ``<subject> == LITERAL`` 時，``LITERAL`` "
"才會成功。對於單例``None``、``True`` 和``False``，使用了 :keyword:`is` "
"運算符。"

#: ../../reference/compound_stmts.rst:858
#, fuzzy
msgid "Capture Patterns"
msgstr "捕獲模式"

#: ../../reference/compound_stmts.rst:860
#, fuzzy
msgid "A capture pattern binds the subject value to a name. Syntax:"
msgstr "捕獲模式將主題值綁定到名稱。句法："

#: ../../reference/compound_stmts.rst:866
#, fuzzy
msgid ""
"A single underscore ``_`` is not a capture pattern (this is what ``!'_'`` "
"expresses). It is instead treated as a :token:`~python-grammar:"
"wildcard_pattern`."
msgstr ""
"單個底線 ``_`` 不是捕獲模式（這是 ``!'_'`` 表達的意思）。它被視為 :token"
":`~python-grammar:wildcard_pattern`。"

#: ../../reference/compound_stmts.rst:870
#, fuzzy
msgid ""
"In a given pattern, a given name can only be bound once.  E.g. ``case x, "
"x: ...`` is invalid while ``case [x] | x: ...`` is allowed."
msgstr ""
"在給定的模式中，給定的名稱只能綁定一次。例如。 ``case x, x: ...`` 在``case "
"[x] | 時無效x: ...`` 是允許的。"

#: ../../reference/compound_stmts.rst:873
#, fuzzy
msgid ""
"Capture patterns always succeed.  The binding follows scoping rules "
"established by the assignment expression operator in :pep:`572`; the name "
"becomes a local variable in the closest containing function scope unless "
"there's an applicable :keyword:`global` or :keyword:`nonlocal` statement."
msgstr ""
"捕獲模式總是成功的。綁定遵循 :pep:`572` 中的賦值表達式運算符建立的範圍規則；"
"除非有適用的 :keyword:`global` 或 :keyword:`nonlocal` "
"語句，否則該名稱將成為最近的包含函式作用域中的局部變數。"

#: ../../reference/compound_stmts.rst:878
#, fuzzy
msgid ""
"In simple terms ``NAME`` will always succeed and it will set ``NAME = "
"<subject>``."
msgstr "簡單來說，``NAME`` 總是會成功，它會設定 ``NAME = <subject>``。"

#: ../../reference/compound_stmts.rst:883
#, fuzzy
msgid "Wildcard Patterns"
msgstr "通配符模式"

#: ../../reference/compound_stmts.rst:885
#, fuzzy
msgid ""
"A wildcard pattern always succeeds (matches anything) and binds no name.  "
"Syntax:"
msgstr "通配符模式總是成功（匹配任何內容）並且不綁定任何名稱。句法："

#: ../../reference/compound_stmts.rst:891
#, fuzzy
msgid ""
"``_`` is a :ref:`soft keyword <soft-keywords>` within any pattern, but only "
"within patterns.  It is an identifier, as usual, even within ``match`` "
"subject expressions, ``guard``\\ s, and ``case`` blocks."
msgstr ""
"``_`` 是任何模式中的 :ref:`軟關鍵字 <soft-keywords>`，但僅限於模式內。像往常"
"一樣，它是一個標識符，即使在“匹配”主題表達式、“保護”和“案例”塊中也是如此。"

#: ../../reference/compound_stmts.rst:895
#, fuzzy
msgid "In simple terms, ``_`` will always succeed."
msgstr "簡單來說，``_`` 總會成功。"

#: ../../reference/compound_stmts.rst:900
#, fuzzy
msgid "Value Patterns"
msgstr "價值模式"

#: ../../reference/compound_stmts.rst:902
#, fuzzy
msgid "A value pattern represents a named value in Python. Syntax:"
msgstr "值模式表示 Python 中的命名值。句法："

#: ../../reference/compound_stmts.rst:910
#, fuzzy
msgid ""
"The dotted name in the pattern is looked up using standard Python :ref:`name "
"resolution rules <resolve_names>`.  The pattern succeeds if the value found "
"compares equal to the subject value (using the ``==`` equality operator)."
msgstr ""
"使用標準 Python :ref:`name resolution rules <resolve_names>` "
"查找模式中的點名。如果找到的值等於主題值（使用“==”相等運算符），則模式成功。"

#: ../../reference/compound_stmts.rst:915
#, fuzzy
msgid ""
"In simple terms ``NAME1.NAME2`` will succeed only if ``<subject> == NAME1."
"NAME2``"
msgstr "簡單來說，只有在 ``<subject> == NAME1.NAME2`` 時，``NAME1.NAME2`` 才會成功"

#: ../../reference/compound_stmts.rst:919
#, fuzzy
msgid ""
"If the same value occurs multiple times in the same match statement, the "
"interpreter may cache the first value found and reuse it rather than repeat "
"the same lookup.  This cache is strictly tied to a given execution of a "
"given match statement."
msgstr ""
"如果相同的值在同一個匹配語句中多次出現，直譯器可能會快取找到的第一個值並重新"
"使用它，而不是重複相同的查找。此快取與給定匹配語句的給定執行嚴格相關。"

#: ../../reference/compound_stmts.rst:927
#, fuzzy
msgid "Group Patterns"
msgstr "組模式"

#: ../../reference/compound_stmts.rst:929
#, fuzzy
msgid ""
"A group pattern allows users to add parentheses around patterns to emphasize "
"the intended grouping.  Otherwise, it has no additional syntax. Syntax:"
msgstr "組模式允許使用者在模式周圍新增括號以強調預期的分組。否則，它沒有額外的語法。"
"句法："

#: ../../reference/compound_stmts.rst:936
#, fuzzy
msgid "In simple terms ``(P)`` has the same effect as ``P``."
msgstr "簡單來說，``(P)`` 與 ``P`` 具有相同的效果。"

#: ../../reference/compound_stmts.rst:941
#, fuzzy
msgid "Sequence Patterns"
msgstr "序列模式"

#: ../../reference/compound_stmts.rst:943
#, fuzzy
msgid ""
"A sequence pattern contains several subpatterns to be matched against "
"sequence elements. The syntax is similar to the unpacking of a list or tuple."
msgstr "序列模式包含多個子模式以與序列元素匹配。語法類似於列表或元組的解包。"

#: ../../reference/compound_stmts.rst:954
#, fuzzy
msgid ""
"There is no difference if parentheses  or square brackets are used for "
"sequence patterns (i.e. ``(...)`` vs ``[...]`` )."
msgstr "如果括號或方括號用於序列模式（即 ``(...)`` 與 ``[...]`` ）沒有區別。"

#: ../../reference/compound_stmts.rst:958
#, fuzzy
msgid ""
"A single pattern enclosed in parentheses without a trailing comma (e.g. ``(3 "
"| 4)``) is a :ref:`group pattern <group-patterns>`. While a single pattern "
"enclosed in square brackets (e.g. ``[3 | 4]``) is still a sequence pattern."
msgstr ""
"括號中沒有尾隨逗號的單個模式（例如 ``(3 | 4)``）是 :ref:`group pattern "
"<group-patterns>`。雖然用方括號括起來的單個模式（例如 ``[3 | "
"4]``）仍然是序列模式。"

#: ../../reference/compound_stmts.rst:963
#, fuzzy
msgid ""
"At most one star subpattern may be in a sequence pattern.  The star "
"subpattern may occur in any position. If no star subpattern is present, the "
"sequence pattern is a fixed-length sequence pattern; otherwise it is a "
"variable-length sequence pattern."
msgstr ""
"至多一個星形子模式可以在一個序列模式中。星號子模式可以出現在任何位置。如果不"
"存在星形子模式，則序列模式是固定長度的序列模式；否則它是一個可變長度的序列模"
"式。"

#: ../../reference/compound_stmts.rst:968
#, fuzzy
msgid ""
"The following is the logical flow for matching a sequence pattern against a "
"subject value:"
msgstr "以下是將序列模式與主題值進行匹配的邏輯流程："

#: ../../reference/compound_stmts.rst:971
#, fuzzy
msgid ""
"If the subject value is not a sequence [#]_, the sequence pattern fails."
msgstr "如果主題值不是序列 [#]_，則序列模式失敗。"

#: ../../reference/compound_stmts.rst:974
#, fuzzy
msgid ""
"If the subject value is an instance of ``str``, ``bytes`` or ``bytearray`` "
"the sequence pattern fails."
msgstr "如果主題值是 ``str``、``bytes`` 或 ``bytearray`` 的實例，則序列模式失敗。"

#: ../../reference/compound_stmts.rst:977
#, fuzzy
msgid ""
"The subsequent steps depend on whether the sequence pattern is fixed or "
"variable-length."
msgstr "後續步驟取決於序列模式是固定長度還是可變長度。"

#: ../../reference/compound_stmts.rst:980
#, fuzzy
msgid "If the sequence pattern is fixed-length:"
msgstr "如果序列模式是固定長度的："

#: ../../reference/compound_stmts.rst:982
#, fuzzy
msgid ""
"If the length of the subject sequence is not equal to the number of "
"subpatterns, the sequence pattern fails"
msgstr "如果主題序列的長度不等於子模式的數量，則序列模式失敗"

#: ../../reference/compound_stmts.rst:985
#, fuzzy
msgid ""
"Subpatterns in the sequence pattern are matched to their corresponding items "
"in the subject sequence from left to right.  Matching stops as soon as a "
"subpattern fails.  If all subpatterns succeed in matching their "
"corresponding item, the sequence pattern succeeds."
msgstr "序列模式中的子模式從左到右與主題序列中的相應項目匹配。一旦子模式失敗，匹配就"
"會停止。如果所有子模式都成功匹配它們對應的項，則序列模式成功。"

#: ../../reference/compound_stmts.rst:990
#, fuzzy
msgid "Otherwise, if the sequence pattern is variable-length:"
msgstr "否則，如果序列模式是可變長度的："

#: ../../reference/compound_stmts.rst:992
#, fuzzy
msgid ""
"If the length of the subject sequence is less than the number of non-star "
"subpatterns, the sequence pattern fails."
msgstr "如果主題序列的長度小於非星形子模式的數量，則序列模式失敗。"

#: ../../reference/compound_stmts.rst:995
#, fuzzy
msgid ""
"The leading non-star subpatterns are matched to their corresponding items as "
"for fixed-length sequences."
msgstr "前導非星形子模式與固定長度序列的相應項目匹配。"

#: ../../reference/compound_stmts.rst:998
#, fuzzy
msgid ""
"If the previous step succeeds, the star subpattern matches a list formed of "
"the remaining subject items, excluding the remaining items corresponding to "
"non-star subpatterns following the star subpattern."
msgstr "如果上一步成功，則星形子模式匹配由剩餘主題項組成的列表，不包括對應於星形子模"
"式之後的非星形子模式的剩餘項。"

#: ../../reference/compound_stmts.rst:1002
#, fuzzy
msgid ""
"Remaining non-star subpatterns are matched to their corresponding subject "
"items, as for a fixed-length sequence."
msgstr "對於固定長度的序列，剩餘的非星形子模式與其相應的主題項匹配。"

#: ../../reference/compound_stmts.rst:1005
#, fuzzy
msgid ""
"The length of the subject sequence is obtained via :func:`len` (i.e. via "
"the :meth:`__len__` protocol).  This length may be cached by the interpreter "
"in a similar manner as :ref:`value patterns <value-patterns>`."
msgstr ""
"主題序列的長度是通過 :func:`len`（即通過 :meth:`__len__` 協定）獲得的。"
"這個長度可以由直譯器以類似於 :ref:`value patterns <value-patterns>` "
"的方式快取。"

#: ../../reference/compound_stmts.rst:1011
#, fuzzy
msgid ""
"In simple terms ``[P1, P2, P3,`` ... ``, P<N>]`` matches only if all the "
"following happens:"
msgstr "簡單來說，``[P1, P2, P3,`` ... ``, P<N>]`` 只有在以下所有情況發生時才匹配："

#: ../../reference/compound_stmts.rst:1014
#, fuzzy
msgid "check ``<subject>`` is a sequence"
msgstr "檢查``<subject>``是一個序列"

#: ../../reference/compound_stmts.rst:1015
msgid "``len(subject) == <N>``"
msgstr "``len(subject) == <N>``"

#: ../../reference/compound_stmts.rst:1016
#, fuzzy
msgid ""
"``P1`` matches ``<subject>[0]`` (note that this match can also bind names)"
msgstr "``P1`` 匹配``<subject>[0]``（注意這個匹配也可以綁定名字）"

#: ../../reference/compound_stmts.rst:1017
#, fuzzy
msgid ""
"``P2`` matches ``<subject>[1]`` (note that this match can also bind names)"
msgstr "``P2`` 匹配``<subject>[1]``（注意這個匹配也可以綁定名字）"

#: ../../reference/compound_stmts.rst:1018
#, fuzzy
msgid "... and so on for the corresponding pattern/element."
msgstr "...等等對應的模式/元素。"

#: ../../reference/compound_stmts.rst:1023
#, fuzzy
msgid "Mapping Patterns"
msgstr "映射模式"

#: ../../reference/compound_stmts.rst:1025
#, fuzzy
msgid ""
"A mapping pattern contains one or more key-value patterns.  The syntax is "
"similar to the construction of a dictionary. Syntax:"
msgstr "映射模式包含一個或多個鍵值模式。語法類似於字典的構造。句法："

#: ../../reference/compound_stmts.rst:1036
#, fuzzy
msgid ""
"At most one double star pattern may be in a mapping pattern.  The double "
"star pattern must be the last subpattern in the mapping pattern."
msgstr "至多一個雙星圖案可以在一個映射圖案中。雙星模式必須是映射模式中的最後一個子模"
"式。"

#: ../../reference/compound_stmts.rst:1039
#, fuzzy
msgid ""
"Duplicate keys in mapping patterns are disallowed. Duplicate literal keys "
"will raise a :exc:`SyntaxError`. Two keys that otherwise have the same value "
"will raise a :exc:`ValueError` at runtime."
msgstr ""
"映射模式中的重複鍵是不允許的。重複的文字鍵將引發一個 :exc:`SyntaxError`。"
"兩個具有相同值的鍵將在運行時引發 :exc:`ValueError`。"

#: ../../reference/compound_stmts.rst:1043
#, fuzzy
msgid ""
"The following is the logical flow for matching a mapping pattern against a "
"subject value:"
msgstr "以下是將映射模式與主題值進行匹配的邏輯流程："

#: ../../reference/compound_stmts.rst:1046
#, fuzzy
msgid "If the subject value is not a mapping [#]_,the mapping pattern fails."
msgstr "如果主題值不是映射 [#]_，則映射模式失敗。"

#: ../../reference/compound_stmts.rst:1048
#, fuzzy
msgid ""
"If every key given in the mapping pattern is present in the subject mapping, "
"and the pattern for each key matches the corresponding item of the subject "
"mapping, the mapping pattern succeeds."
msgstr "如果映射模式中給出的每個鍵都出現在主題映射中，並且每個鍵的模式與主題映射的相"
"應項匹配，則映射模式成功。"

#: ../../reference/compound_stmts.rst:1052
#, fuzzy
msgid ""
"If duplicate keys are detected in the mapping pattern, the pattern is "
"considered invalid. A :exc:`SyntaxError` is raised for duplicate literal "
"values; or a :exc:`ValueError` for named keys of the same value."
msgstr ""
"如果在映射模式中檢測到重複鍵，則該模式被視為無效。一個 :exc:`SyntaxError` "
"被引發重複的文字值；或具有相同值的命名鍵的 :exc:`ValueError`。"

#: ../../reference/compound_stmts.rst:1056
#, fuzzy
msgid ""
"Key-value pairs are matched using the two-argument form of the mapping "
"subject's ``get()`` method.  Matched key-value pairs must already be present "
"in the mapping, and not created on-the-fly via :meth:`__missing__` or :meth:"
"`__getitem__`."
msgstr ""
"使用映射主題的“get()”方法的雙參數形式匹配鍵值對。匹配的鍵值對必須已經存在於映"
"射中，而不是通過 :meth:`__missing__` 或 :meth:`__getitem__` 即時建立。"

#: ../../reference/compound_stmts.rst:1061
#, fuzzy
msgid ""
"In simple terms ``{KEY1: P1, KEY2: P2, ... }`` matches only if all the "
"following happens:"
msgstr "簡單來說，``{KEY1: P1, KEY2: P2, ... }`` 只有在以下所有情況發生時才匹配："

#: ../../reference/compound_stmts.rst:1064
#, fuzzy
msgid "check ``<subject>`` is a mapping"
msgstr "檢查``<subject>``是一個映射"

#: ../../reference/compound_stmts.rst:1065
msgid "``KEY1 in <subject>``"
msgstr "``KEY1 in <subject>``"

#: ../../reference/compound_stmts.rst:1066
#, fuzzy
msgid "``P1`` matches ``<subject>[KEY1]``"
msgstr "``P1`` 匹配``<subject>[KEY1]``"

#: ../../reference/compound_stmts.rst:1067
#, fuzzy
msgid "... and so on for the corresponding KEY/pattern pair."
msgstr "...對應的 KEY/pattern 對依此類推。"

#: ../../reference/compound_stmts.rst:1073
#, fuzzy
msgid "Class Patterns"
msgstr "類模式"

#: ../../reference/compound_stmts.rst:1075
#, fuzzy
msgid ""
"A class pattern represents a class and its positional and keyword arguments "
"(if any).  Syntax:"
msgstr "類模式代表一個類及其位置參數和關鍵字參數（如果有的話）。句法："

#: ../../reference/compound_stmts.rst:1086
#, fuzzy
msgid "The same keyword should not be repeated in class patterns."
msgstr "類模式中不應重複相同的關鍵字。"

#: ../../reference/compound_stmts.rst:1088
#, fuzzy
msgid ""
"The following is the logical flow for matching a class pattern against a "
"subject value:"
msgstr "以下是將類模式與主題值進行匹配的邏輯流程："

#: ../../reference/compound_stmts.rst:1091
#, fuzzy
msgid ""
"If ``name_or_attr`` is not an instance of the builtin :class:`type` , raise :"
"exc:`TypeError`."
msgstr "如果 ``name_or_attr`` 不是內建 :class:`type` 的實例，則引發 "
":exc:`TypeError`。"

#: ../../reference/compound_stmts.rst:1094
#, fuzzy
msgid ""
"If the subject value is not an instance of ``name_or_attr`` (tested via :"
"func:`isinstance`), the class pattern fails."
msgstr "如果主題值不是 ``name_or_attr`` 的實例（通過 :func:`isinstance` "
"測試），則類模式失敗。"

#: ../../reference/compound_stmts.rst:1097
#, fuzzy
msgid ""
"If no pattern arguments are present, the pattern succeeds.  Otherwise, the "
"subsequent steps depend on whether keyword or positional argument patterns "
"are present."
msgstr "如果不存在模式參數，則模式成功。否則，後續步驟取決於是否存在關鍵字或位置參數"
"模式。"

#: ../../reference/compound_stmts.rst:1101
#, fuzzy
msgid ""
"For a number of built-in types (specified below), a single positional "
"subpattern is accepted which will match the entire subject; for these types "
"keyword patterns also work as for other types."
msgstr "對於許多內建型別（下面指定），接受將匹配整個主題的單個位置子模式；對於這些型"
"別，關鍵字模式也適用於其他型別。"

#: ../../reference/compound_stmts.rst:1105
#, fuzzy
msgid ""
"If only keyword patterns are present, they are processed as follows, one by "
"one:"
msgstr "如果只存在關鍵字模式，則按如下方式逐一處理："

#: ../../reference/compound_stmts.rst:1108
#, fuzzy
msgid "I. The keyword is looked up as an attribute on the subject."
msgstr "I. 關鍵字作為主題的屬性查找。"

#: ../../reference/compound_stmts.rst:1110
#, fuzzy
msgid ""
"If this raises an exception other than :exc:`AttributeError`, the exception "
"bubbles up."
msgstr "如果這引發了 :exc:`AttributeError` 以外的例外，則例外會冒泡。"

#: ../../reference/compound_stmts.rst:1113
#, fuzzy
msgid "If this raises :exc:`AttributeError`, the class pattern has failed."
msgstr "如果這引發 :exc:`AttributeError`，則類模式失敗。"

#: ../../reference/compound_stmts.rst:1115
#, fuzzy
msgid ""
"Else, the subpattern associated with the keyword pattern is matched against "
"the subject's attribute value.  If this fails, the class pattern fails; if "
"this succeeds, the match proceeds to the next keyword."
msgstr "否則，與關鍵字模式關聯的子模式與主題的屬性值匹配。如果失敗，則類模式失敗；如"
"果成功，則匹配繼續到下一個關鍵字。"

#: ../../reference/compound_stmts.rst:1120
#, fuzzy
msgid "II. If all keyword patterns succeed, the class pattern succeeds."
msgstr "二。如果所有關鍵字模式都成功，則類模式成功。"

#: ../../reference/compound_stmts.rst:1122
#, fuzzy
msgid ""
"If any positional patterns are present, they are converted to keyword "
"patterns using the :data:`~object.__match_args__` attribute on the class "
"``name_or_attr`` before matching:"
msgstr ""
"如果存在任何位置模式，則在匹配之前使用類 ``name_or_attr`` 上的 :data:`~object."
"__match_args__` 屬性將它們轉換為關鍵字模式："

#: ../../reference/compound_stmts.rst:1126
#, fuzzy
msgid ""
"I. The equivalent of ``getattr(cls, \"__match_args__\", ())`` is called."
msgstr "I. 等效於 ``getattr(cls, \"__match_args__\", ())`` 被呼叫。"

#: ../../reference/compound_stmts.rst:1128
#, fuzzy
msgid "If this raises an exception, the exception bubbles up."
msgstr "如果這引發例外，則例外會冒泡。"

#: ../../reference/compound_stmts.rst:1130
#, fuzzy
msgid ""
"If the returned value is not a tuple, the conversion fails and :exc:"
"`TypeError` is raised."
msgstr "如果回傳值不是元組，則轉換失敗並引發 :exc:`TypeError`。"

#: ../../reference/compound_stmts.rst:1133
#, fuzzy
msgid ""
"If there are more positional patterns than ``len(cls.__match_args__)``, :exc:"
"`TypeError` is raised."
msgstr "如果位置模式多於 ``len(cls.__match_args__)``，則會引發 :exc:`TypeError`。"

#: ../../reference/compound_stmts.rst:1136
#, fuzzy
msgid ""
"Otherwise, positional pattern ``i`` is converted to a keyword pattern using "
"``__match_args__[i]`` as the keyword.  ``__match_args__[i]`` must be a "
"string; if not :exc:`TypeError` is raised."
msgstr ""
"否則，位置模式 ``i``將轉換為使用“__match_args__[i]”作為關鍵字的關鍵字模式。 "
"``__match_args__[i]`` 必須是字串；如果不是 :exec:`TypeError` 被引發。"

#: ../../reference/compound_stmts.rst:1140
#, fuzzy
msgid "If there are duplicate keywords, :exc:`TypeError` is raised."
msgstr "如果有重複的關鍵字，則會引發 :exc:`TypeError`。"

#: ../../reference/compound_stmts.rst:1142
msgid ":ref:`class-pattern-matching`"
msgstr ":ref:`class-pattern-matching`"

#: ../../reference/compound_stmts.rst:1145
#, fuzzy
msgid ""
"II. Once all positional patterns have been converted to keyword patterns,"
msgstr "二。一旦所有位置模式都轉換為關鍵字模式，"

#: ../../reference/compound_stmts.rst:1145
#, fuzzy
msgid "the match proceeds as if there were only keyword patterns."
msgstr "匹配繼續進行，就好像只有關鍵字模式一樣。"

#: ../../reference/compound_stmts.rst:1147
#, fuzzy
msgid ""
"For the following built-in types the handling of positional subpatterns is "
"different:"
msgstr "對於以下內建型別，位置子模式的處理是不同的："

#: ../../reference/compound_stmts.rst:1150
msgid ":class:`bool`"
msgstr ":class:`bool`"

#: ../../reference/compound_stmts.rst:1151
msgid ":class:`bytearray`"
msgstr ":class:`bytearray`"

#: ../../reference/compound_stmts.rst:1152
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../reference/compound_stmts.rst:1153
msgid ":class:`dict`"
msgstr ":class:`dict`"

#: ../../reference/compound_stmts.rst:1154
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../reference/compound_stmts.rst:1155
msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

#: ../../reference/compound_stmts.rst:1156
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../reference/compound_stmts.rst:1157
#: ../../reference/compound_stmts.rst:1608
msgid ":class:`list`"
msgstr ":class:`list`"

#: ../../reference/compound_stmts.rst:1158
msgid ":class:`set`"
msgstr ":class:`set`"

#: ../../reference/compound_stmts.rst:1159
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../reference/compound_stmts.rst:1160
#: ../../reference/compound_stmts.rst:1611
msgid ":class:`tuple`"
msgstr ":class:`tuple`"

#: ../../reference/compound_stmts.rst:1162
#, fuzzy
msgid ""
"These classes accept a single positional argument, and the pattern there is "
"matched against the whole object rather than an attribute. For example "
"``int(0|1)`` matches the value ``0``, but not the value ``0.0``."
msgstr ""
"這些類接受單個位置參數，並且那裡的模式與整個物件而不是屬性匹配。例如 "
"``int(0|1)`` 匹配值 ``0``，但不匹配值 ``0.0``。"

#: ../../reference/compound_stmts.rst:1166
#, fuzzy
msgid ""
"In simple terms ``CLS(P1, attr=P2)`` matches only if the following happens:"
msgstr "簡單來說，``CLS(P1, attr=P2)`` 只有在發生以下情況時才會匹配："

#: ../../reference/compound_stmts.rst:1168
msgid "``isinstance(<subject>, CLS)``"
msgstr "``isinstance(<subject>, CLS)``"

#: ../../reference/compound_stmts.rst:1169
#, fuzzy
msgid "convert ``P1`` to a keyword pattern using ``CLS.__match_args__``"
msgstr "使用 ``CLS.__match_args__`` 將 ``P1`` 轉換為關鍵字模式"

#: ../../reference/compound_stmts.rst:1171
#, fuzzy
msgid "For each keyword argument ``attr=P2``:"
msgstr "對於每個關鍵字參數 ``attr=P2``："

#: ../../reference/compound_stmts.rst:1171
msgid "``hasattr(<subject>, \"attr\")``"
msgstr "``hasattr(<subject>, \"attr\")``"

#: ../../reference/compound_stmts.rst:1172
#, fuzzy
msgid "``P2`` matches ``<subject>.attr``"
msgstr "``P2`` 匹配``<subject>.attr``"

#: ../../reference/compound_stmts.rst:1173
#, fuzzy
msgid "... and so on for the corresponding keyword argument/pattern pair."
msgstr "...等等對應的關鍵字參數/模式對。"

#: ../../reference/compound_stmts.rst:1188
msgid "Function definitions"
msgstr "函式定義"

#: ../../reference/compound_stmts.rst:1203
#, fuzzy
msgid ""
"A function definition defines a user-defined function object (see section :"
"ref:`types`):"
msgstr "函式定義定義了一個使用者定義的函式物件（參見 types 部分）："

#: ../../reference/compound_stmts.rst:1222
#, fuzzy
msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper "
"around the executable code for the function).  This function object contains "
"a reference to the current global namespace as the global namespace to be "
"used when the function is called."
msgstr ""
"函式定義是一個可執行語句。它的執行將當前本地命名空間中的函式名稱綁定到函式物"
"件（函式可執行程式碼的包裝器）。此函式物件包含對當前全局命名空間的引用，作為"
"呼叫函式時要使用的全局命名空間。"

#: ../../reference/compound_stmts.rst:1228
#, fuzzy
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr "函式定義不執行函式體；只有在呼叫函式時才會執行。 [#]_"

#: ../../reference/compound_stmts.rst:1234
#, fuzzy
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code ::"
msgstr ""
"一個函式定義可以被一個或多個 :term:`decorator` 表達式包裹。裝飾器表達式在定義"
"函式時在包含函式定義的範圍內求值。結果必須是可呼叫的，它是用函式對像作為唯一"
"參數呼叫的。回傳值綁定到函式名而不是函式物件。多個裝飾器以嵌套方式應用。例如"
"，下面的程式碼::"

#: ../../reference/compound_stmts.rst:1245
#: ../../reference/compound_stmts.rst:1422
msgid "is roughly equivalent to ::"
msgstr ""
"大致等價於：\n"
"\n"
"::"

#: ../../reference/compound_stmts.rst:1250
#, fuzzy
msgid ""
"except that the original function is not temporarily bound to the name "
"``func``."
msgstr "除了原始函式沒有暫時綁定到名稱 ``func``之外。"

#: ../../reference/compound_stmts.rst:1252
#, fuzzy
msgid ""
"Functions may be decorated with any valid :token:`~python-grammar:"
"assignment_expression`. Previously, the grammar was much more restrictive; "
"see :pep:`614` for details."
msgstr ""
"函式可以用任何有效的 :token:`~python-grammar:assignment_expression` "
"修飾。以前，語法的限制要多得多；有關詳細資訊，請參閱 :pep:`614`。"

#: ../../reference/compound_stmts.rst:1262
#, fuzzy
msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter* "
"``=`` *expression*, the function is said to have \"default parameter values."
"\"  For a parameter with a default value, the corresponding :term:`argument` "
"may be omitted from a call, in which case the parameter's default value is "
"substituted.  If a parameter has a default value, all following parameters "
"up until the \"``*``\" must also have a default value --- this is a "
"syntactic restriction that is not expressed by the grammar."
msgstr ""
"當一個或多個 :term:`parameters <parameter>` 具有 *parameter* ``=`` "
"*expression* 形式時，該函式被稱為具有“預設參數值”。對於具有預設值的參數，"
"相應的 :term:`argument` 可以從呼叫中省略，在這種情況下，參數的預設值將被替換"
"。如果一個參數有預設值，那麼後面的所有參數直到“``*``”也必須有一個預設值---"
"這是語法沒有表達的句法限制。"

#: ../../reference/compound_stmts.rst:1270
#, fuzzy
msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter value is a mutable object, such as a "
"list or a dictionary: if the function modifies the object (e.g. by appending "
"an item to a list), the default parameter value is in effect modified.  This "
"is generally not what was intended.  A way around this is to use ``None`` as "
"the default, and explicitly test for it in the body of the function, e.g.::"
msgstr ""
"**預設參數值在執行函式定義時從左到右求值。**這意味著在定義函式時對錶達式求值"
"一次，並且每次呼叫都使用相同的“預計算”值.當預設參數值是可變物件（例如列表或字"
"典）時，理解這一點尤為重要：如果函式修改了物件（例如，通過將項目附加到列表）"
"，則預設參數值實際上被修改了。這通常不是預期的。解決這個問題的一種方法是使用“"
"None”作為預設值，並在函式體中顯式測試它，例如："

#: ../../reference/compound_stmts.rst:1291
#, fuzzy
msgid ""
"Function call semantics are described in more detail in section :ref:"
"`calls`. A function call always assigns values to all parameters mentioned "
"in the parameter list, either from positional arguments, from keyword "
"arguments, or from default values.  If the form \"``*identifier``\" is "
"present, it is initialized to a tuple receiving any excess positional "
"parameters, defaulting to the empty tuple. If the form \"``**identifier``\" "
"is present, it is initialized to a new ordered mapping receiving any excess "
"keyword arguments, defaulting to a new empty mapping of the same type.  "
"Parameters after \"``*``\" or \"``*identifier``\" are keyword-only "
"parameters and may only be passed by keyword arguments.  Parameters before "
"\"``/``\" are positional-only parameters and may only be passed by "
"positional arguments."
msgstr ""
"函式呼叫語義在 :ref:`calls` 部分有更詳細的描述。函式呼叫總是為參數列表中提到"
"的所有參數賦值，無論是來自位置參數、關鍵字參數還是預設值。如果存在“``*identif"
"ier``”形式，它被初始化為一個接收任何多餘位置參數的元組，預設為空元組。如果存"
"在“``**identifier``”形式，它會被初始化為一個新的有序映射，接收任何多餘的關鍵"
"字參數，預設為一個新的相同型別的空映射。 “``*``”或“``*identifier``”之後的參數"
"是僅限關鍵字的參數，只能通過關鍵字參數傳遞。 "
"“``/``”之前的參數是僅位置參數，只能通過位置參數傳遞。"

#: ../../reference/compound_stmts.rst:1303
#, fuzzy
msgid ""
"The ``/`` function parameter syntax may be used to indicate positional-only "
"parameters. See :pep:`570` for details."
msgstr "``/`` 函式參數語法可用於指示僅位置參數。有關詳細資訊，請參見 :pep:`570`。"

#: ../../reference/compound_stmts.rst:1312
#, fuzzy
msgid ""
"Parameters may have an :term:`annotation <function annotation>` of the form "
"\"``: expression``\" following the parameter name.  Any parameter may have "
"an annotation, even those of the form ``*identifier`` or ``**identifier``.  "
"Functions may have \"return\" annotation of the form \"``-> expression``\" "
"after the parameter list.  These annotations can be any valid Python "
"expression.  The presence of annotations does not change the semantics of a "
"function.  The annotation values are available as values of a dictionary "
"keyed by the parameters' names in the :attr:`__annotations__` attribute of "
"the function object.  If the ``annotations`` import from :mod:`__future__` "
"is used, annotations are preserved as strings at runtime which enables "
"postponed evaluation.  Otherwise, they are evaluated when the function "
"definition is executed.  In this case annotations may be evaluated in a "
"different order than they appear in the source code."
msgstr ""
"參數可能有一個 :term:`annotation <function annotation>` 形式為 \"``: "
"expression``\" "
"跟在參數名稱之後。任何參數都可以有一個註解，即使是``*identifier`` "
"或``**identifier`` 形式的參數。函式可能在參數列表後有“``-> "
"expression``”形式的 ``return``註解。這些註釋可以是任何有效的 Python "
"表達式。註釋的存在不會改變函式的語義。註釋值可用作字典的值，"
"該字典的值由函式物件的 :attr:`__annotations__` 屬性中的參數名稱鍵入。"
"如果使用從 :mod:`__future__` 導入的``annotations``，註釋將在運行時保留為字串"
"，從而可以推遲評估。否則，將在執行函式定義時評估它們。在這種情況下，註釋的計"
"算順序可能與它們在源程式碼中出現的順序不同。"

#: ../../reference/compound_stmts.rst:1327
#, fuzzy
msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda expressions, "
"described in section :ref:`lambda`.  Note that the lambda expression is "
"merely a shorthand for a simplified function definition; a function defined "
"in a \":keyword:`def`\" statement can be passed around or assigned to "
"another name just like a function defined by a lambda expression.  The \":"
"keyword:`!def`\" form is actually more powerful since it allows the "
"execution of multiple statements and annotations."
msgstr ""
"也可以建立匿名函式（未綁定到名稱的函式），以便在表達式中立即使用。這使用 "
"lambda 表達式，在 :ref:`lambda` 部分中有描述。請注意，lambda "
"表達式只是簡化函式定義的簡寫；在 \":keyword:`def`\" "
"語句中定義的函式可以傳遞或分配給另一個名稱，就像由 lambda "
"表達式定義的函式一樣。 \":keyword:`!def`\" "
"形式實際上更強大，因為它允許執行多個語句和註釋。"

#: ../../reference/compound_stmts.rst:1335
#, fuzzy
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested "
"function can access the local variables of the function containing the def.  "
"See section :ref:`naming` for details."
msgstr ""
"**程式員注意事項：**函式是一流的物件。在函式定義內執行的“``def``”語句定義了一"
"個可以回傳或傳遞的局部函式。嵌套函式中使用的自由變數可以訪問包含 def "
"的函式的局部變數。有關詳細資訊，請參閱 :ref:`naming` 部分。"

#: ../../reference/compound_stmts.rst:1344
#, fuzzy
msgid ":pep:`3107` - Function Annotations"
msgstr ":pep:`3107` - 函式註解"

#: ../../reference/compound_stmts.rst:1344
#, fuzzy
msgid "The original specification for function annotations."
msgstr "函式註釋的原始規範。"

#: ../../reference/compound_stmts.rst:1347
#, fuzzy
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - 型別提示"

#: ../../reference/compound_stmts.rst:1347
#, fuzzy
msgid "Definition of a standard meaning for annotations: type hints."
msgstr "註釋的標準含義定義：型別提示。"

#: ../../reference/compound_stmts.rst:1351
#, fuzzy
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - 變數註釋的語法"

#: ../../reference/compound_stmts.rst:1350
#, fuzzy
msgid ""
"Ability to type hint variable declarations, including class variables and "
"instance variables"
msgstr "能夠鍵入提示變數聲明，包括類變數和實例變數"

#: ../../reference/compound_stmts.rst:1354
#, fuzzy
msgid ":pep:`563` - Postponed Evaluation of Annotations"
msgstr ":pep:`563` - 延遲評估註釋"

#: ../../reference/compound_stmts.rst:1354
#, fuzzy
msgid ""
"Support for forward references within annotations by preserving annotations "
"in a string form at runtime instead of eager evaluation."
msgstr "通過在運行時以字串形式保留註釋而不是急切評估來支援註釋中的前向引用。"

#: ../../reference/compound_stmts.rst:1361
#, fuzzy
msgid "Class definitions"
msgstr "類定義"

#: ../../reference/compound_stmts.rst:1376
#, fuzzy
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr "類定義定義了一個類物件（參見 types 部分）："

#: ../../reference/compound_stmts.rst:1383
#, fuzzy
msgid ""
"A class definition is an executable statement.  The inheritance list usually "
"gives a list of base classes (see :ref:`metaclasses` for more advanced "
"uses), so each item in the list should evaluate to a class object which "
"allows subclassing.  Classes without an inheritance list inherit, by "
"default, from the base class :class:`object`; hence, ::"
msgstr ""
"類定義是一個可執行語句。繼承列表通常給出一個基底類別列表（請參閱 "
":ref:`metaclasses` 了解更高階的用途），因此列表中的每個項目都應評估為允許子類"
"別化的類物件。預設情況下，沒有繼承列表的類繼承自基底類別 "
":class:`object`;因此， ：："

#: ../../reference/compound_stmts.rst:1392
#, fuzzy
msgid "is equivalent to ::"
msgstr "相當於 ::"

#: ../../reference/compound_stmts.rst:1397
#, fuzzy
msgid ""
"The class's suite is then executed in a new execution frame (see :ref:"
"`naming`), using a newly created local namespace and the original global "
"namespace. (Usually, the suite contains mostly function definitions.)  When "
"the class's suite finishes execution, its execution frame is discarded but "
"its local namespace is saved. [#]_ A class object is then created using the "
"inheritance list for the base classes and the saved local namespace for the "
"attribute dictionary.  The class name is bound to this class object in the "
"original local namespace."
msgstr ""
"然後使用新建立的本地名稱空間和原始全局名稱空間在新的執行框架中執行該類的套件"
"（請參閱 :ref:`naming`）。 （通常，套件主要包含函式定義。）當類的套件完成執"
"行時，其執行框架將被丟棄，但其本地命名空間將被保存。 [#]_ 然後使用基底類別的"
"繼承列表和屬性字典保存的本地名稱空間建立一個類物件。類名綁定到原始本地命名空"
"間中的此類物件。"

#: ../../reference/compound_stmts.rst:1406
#, fuzzy
msgid ""
"The order in which attributes are defined in the class body is preserved in "
"the new class's ``__dict__``.  Note that this is reliable only right after "
"the class is created and only for classes that were defined using the "
"definition syntax."
msgstr "在類主體中定義屬性的順序保留在新類的 __dict__ "
"中。請注意，這僅在建立類之後才可靠，並且僅適用於使用定義語法定義的類。"

#: ../../reference/compound_stmts.rst:1411
#, fuzzy
msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr "可以使用 :ref:`metaclasses <metaclasses>` 大量定制類建立。"

#: ../../reference/compound_stmts.rst:1416
#, fuzzy
msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr "類也可以被裝飾：就像裝飾函式一樣，::"

#: ../../reference/compound_stmts.rst:1427
#, fuzzy
msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result is then bound to the class name."
msgstr "裝飾器表達式的求值規則與函式裝飾器相同。然後將結果綁定到類名。"

#: ../../reference/compound_stmts.rst:1430
#, fuzzy
msgid ""
"Classes may be decorated with any valid :token:`~python-grammar:"
"assignment_expression`. Previously, the grammar was much more restrictive; "
"see :pep:`614` for details."
msgstr ""
"類可以用任何有效的 :token:`~python-grammar:assignment_expression` "
"修飾。以前，語法的限制要多得多；有關詳細資訊，請參閱 :pep:`614`。"

#: ../../reference/compound_stmts.rst:1435
#, fuzzy
msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"attributes; they are shared by instances.  Instance attributes can be set in "
"a method with ``self.name = value``.  Both class and instance attributes are "
"accessible through the notation \"``self.name``\", and an instance attribute "
"hides a class attribute with the same name when accessed in this way.  Class "
"attributes can be used as defaults for instance attributes, but using "
"mutable values there can lead to unexpected results.  :ref:`Descriptors "
"<descriptors>` can be used to create instance variables with different "
"implementation details."
msgstr ""
"**程式員注意：**類定義中定義的變數是類屬性；它們由實例共享。實例屬性可以在帶"
"有“self.name = value”的方法中設定。類和實例屬性都可以通過符號“``self.name``”"
"訪問，並且當以這種方式訪問時，實例屬性會隱藏同名的類屬性。類屬性可以用作實例"
"屬性的預設值，但在那裡使用可變值可能會導致意外結果。 :ref:`Descriptors "
"<descriptors>` 可用於建立具有不同實作細節的實例變數。"

#: ../../reference/compound_stmts.rst:1450
#, fuzzy
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Python 3000 中的元類"

#: ../../reference/compound_stmts.rst:1448
#, fuzzy
msgid ""
"The proposal that changed the declaration of metaclasses to the current "
"syntax, and the semantics for how classes with metaclasses are constructed."
msgstr "將元類聲明更改為當前語法的提案，以及如何構造具有元類的類的語義。"

#: ../../reference/compound_stmts.rst:1453
#, fuzzy
msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` - 類裝飾器"

#: ../../reference/compound_stmts.rst:1453
#, fuzzy
msgid ""
"The proposal that added class decorators.  Function and method decorators "
"were introduced in :pep:`318`."
msgstr "新增類裝飾器的提案。 :pep:`318` 中引入了函式和方法裝飾器。"

#: ../../reference/compound_stmts.rst:1460
msgid "Coroutines"
msgstr "協程"

#: ../../reference/compound_stmts.rst:1468
#, fuzzy
msgid "Coroutine function definition"
msgstr "協程函式定義"

#: ../../reference/compound_stmts.rst:1478
#, fuzzy
msgid ""
"Execution of Python coroutines can be suspended and resumed at many points "
"(see :term:`coroutine`). :keyword:`await` expressions, :keyword:`async for` "
"and :keyword:`async with` can only be used in the body of a coroutine "
"function."
msgstr ""
"Python 協同程式的執行可以在許多點暫停和恢復（參見 :term:`coroutine`）。 "
":keyword:`await` 表達式、:keyword:`async for` 和 :keyword:`async with` "
"只能在協程函式體中使用。"

#: ../../reference/compound_stmts.rst:1482
#, fuzzy
msgid ""
"Functions defined with ``async def`` syntax are always coroutine functions, "
"even if they do not contain ``await`` or ``async`` keywords."
msgstr "使用 ``async def`` 語法定義的函式始終是協程函式，即使它們不包含 ``await`` 或 "
"``async`` 關鍵字。"

#: ../../reference/compound_stmts.rst:1485
#, fuzzy
msgid ""
"It is a :exc:`SyntaxError` to use a ``yield from`` expression inside the "
"body of a coroutine function."
msgstr "在協程函式體內使用 ``yield from`` 表達式是一個 :exc:`SyntaxError`。"

#: ../../reference/compound_stmts.rst:1488
msgid "An example of a coroutine function::"
msgstr ""
"一個協程韓式函式範例：\n"
"\n"
"::"

#: ../../reference/compound_stmts.rst:1494
#, fuzzy
msgid ""
"``await`` and ``async`` are now keywords; previously they were only treated "
"as such inside the body of a coroutine function."
msgstr "``await`` 和 ``async`` 現在是關鍵字；以前，它們僅在協程函式體內被視為此類。"

#: ../../reference/compound_stmts.rst:1502
#, fuzzy
msgid "The :keyword:`!async for` statement"
msgstr ":keyword:`!async for` 語句"

#: ../../reference/compound_stmts.rst:1507
#, fuzzy
msgid ""
"An :term:`asynchronous iterable` provides an ``__aiter__`` method that "
"directly returns an :term:`asynchronous iterator`, which can call "
"asynchronous code in its ``__anext__`` method."
msgstr ""
"一個 :term:`asynchronous iterable` 提供了一個 ``__aiter__`` 方法，"
"它直接回傳一個 :term:`asynchronous iterator`，它可以在它的 ``__anext__`` "
"方法中呼叫非同步程式碼。"

#: ../../reference/compound_stmts.rst:1511
#, fuzzy
msgid ""
"The ``async for`` statement allows convenient iteration over asynchronous "
"iterables."
msgstr "``async for`` 語句允許對非同步可疊代物件進行方便的疊代。"

#: ../../reference/compound_stmts.rst:1521
#, fuzzy
msgid "Is semantically equivalent to::"
msgstr "在語義上等同於::"

#: ../../reference/compound_stmts.rst:1537
msgid ""
"See also :meth:`~object.__aiter__` and :meth:`~object.__anext__` for details."
msgstr ""
"更多細節請見 :meth:`~object.__aiter__` 與 :meth:`~object.__anext__`\\ 。"

#: ../../reference/compound_stmts.rst:1539
#, fuzzy
msgid ""
"It is a :exc:`SyntaxError` to use an ``async for`` statement outside the "
"body of a coroutine function."
msgstr "在協程函式體之外使用 ``async for`` 語句是一個 :exc:`SyntaxError`。"

#: ../../reference/compound_stmts.rst:1547
#, fuzzy
msgid "The :keyword:`!async with` statement"
msgstr ":keyword:`!async with` 語句"

#: ../../reference/compound_stmts.rst:1552
#, fuzzy
msgid ""
"An :term:`asynchronous context manager` is a :term:`context manager` that is "
"able to suspend execution in its *enter* and *exit* methods."
msgstr "一個 :term:`非同步上下文管理器` 是一個 :term:`上下文管理器`，它能夠在其 "
"*enter* 和 *exit* 方法中暫停執行。"

#: ../../reference/compound_stmts.rst:1579
msgid ""
"See also :meth:`~object.__aenter__` and :meth:`~object.__aexit__` for "
"details."
msgstr ""
"更多細節請見 :meth:`~object.__aenter__` 與 :meth:`~object.__aexit__`\\ 。"

#: ../../reference/compound_stmts.rst:1581
#, fuzzy
msgid ""
"It is a :exc:`SyntaxError` to use an ``async with`` statement outside the "
"body of a coroutine function."
msgstr "在協程函式體之外使用 ``async with`` 語句是一個 :exc:`SyntaxError`。"

#: ../../reference/compound_stmts.rst:1587
#, fuzzy
msgid ":pep:`492` - Coroutines with async and await syntax"
msgstr ":pep:`492` - 具有非同步和等待語法的協程"

#: ../../reference/compound_stmts.rst:1587
#, fuzzy
msgid ""
"The proposal that made coroutines a proper standalone concept in Python, and "
"added supporting syntax."
msgstr "該提案使協程成為 Python 中的一個適當的獨立概念，並新增了支援語法。"

#: ../../reference/compound_stmts.rst:1592
msgid "Footnotes"
msgstr "註解"

#: ../../reference/compound_stmts.rst:1593
#, fuzzy
msgid ""
"The exception is propagated to the invocation stack unless there is a :"
"keyword:`finally` clause which happens to raise another exception. That new "
"exception causes the old one to be lost."
msgstr "例外會傳播到呼叫堆疊，除非有 :keyword:`finally` "
"子句碰巧引發另一個例外。該新例外導致舊例外丟失。"

#: ../../reference/compound_stmts.rst:1597
#, fuzzy
msgid "In pattern matching, a sequence is defined as one of the following:"
msgstr "在模式匹配中，序列被定義為以下之一："

#: ../../reference/compound_stmts.rst:1599
#, fuzzy
msgid "a class that inherits from :class:`collections.abc.Sequence`"
msgstr "一個繼承自 collections.abc.Sequence 的類"

#: ../../reference/compound_stmts.rst:1600
#, fuzzy
msgid ""
"a Python class that has been registered as :class:`collections.abc.Sequence`"
msgstr "已註冊為 :class:`collections.abc.Sequence` 的 Python 類"

#: ../../reference/compound_stmts.rst:1601
#, fuzzy
msgid ""
"a builtin class that has its (CPython) :data:`Py_TPFLAGS_SEQUENCE` bit set"
msgstr "一個內建類，其 (CPython) :data:`Py_TPFLAGS_SEQUENCE` 位設定"

#: ../../reference/compound_stmts.rst:1602
#: ../../reference/compound_stmts.rst:1621
#, fuzzy
msgid "a class that inherits from any of the above"
msgstr "從上述任何一個繼承的類"

#: ../../reference/compound_stmts.rst:1604
#, fuzzy
msgid "The following standard library classes are sequences:"
msgstr "以下標準庫類是序列："

#: ../../reference/compound_stmts.rst:1606
msgid ":class:`array.array`"
msgstr ":class:`array.array`"

#: ../../reference/compound_stmts.rst:1607
msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

#: ../../reference/compound_stmts.rst:1609
msgid ":class:`memoryview`"
msgstr ":class:`memoryview`"

#: ../../reference/compound_stmts.rst:1610
msgid ":class:`range`"
msgstr ":class:`range`"

#: ../../reference/compound_stmts.rst:1613
#, fuzzy
msgid ""
"Subject values of type ``str``, ``bytes``, and ``bytearray`` do not match "
"sequence patterns."
msgstr "``str``、``bytes`` 和 ``bytearray`` 型別的主題值不匹配序列模式。"

#: ../../reference/compound_stmts.rst:1616
#, fuzzy
msgid "In pattern matching, a mapping is defined as one of the following:"
msgstr "在模式匹配中，映射定義為以下之一："

#: ../../reference/compound_stmts.rst:1618
#, fuzzy
msgid "a class that inherits from :class:`collections.abc.Mapping`"
msgstr "一個繼承自 :class:`collections.abc.Mapping` 的類"

#: ../../reference/compound_stmts.rst:1619
#, fuzzy
msgid ""
"a Python class that has been registered as :class:`collections.abc.Mapping`"
msgstr "已註冊為 :class:`collections.abc.Mapping` 的 Python 類"

#: ../../reference/compound_stmts.rst:1620
#, fuzzy
msgid ""
"a builtin class that has its (CPython) :data:`Py_TPFLAGS_MAPPING` bit set"
msgstr "一個內建類，其 (CPython) :data:`Py_TPFLAGS_MAPPING` 位設定"

#: ../../reference/compound_stmts.rst:1623
#, fuzzy
msgid ""
"The standard library classes :class:`dict` and :class:`types."
"MappingProxyType` are mappings."
msgstr "標準庫類 :class:`dict` 和 :class:`types.MappingProxyType` 是映射。"

#: ../../reference/compound_stmts.rst:1626
#, fuzzy
msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's ``__doc__`` attribute and therefore the "
"function's :term:`docstring`."
msgstr "作為函式主體中第一條語句出現的字串文字被轉換為函式的 ``__doc__`` 屬性，"
"因此轉換為函式的 :term:`docstring`。"

#: ../../reference/compound_stmts.rst:1630
#, fuzzy
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's ``__doc__`` item and therefore the class's :"
"term:`docstring`."
msgstr "作為類主體中第一條語句出現的字串文字被轉換為命名空間的 `__doc__`` 項，"
"因此也就是該類的 :term:`docstring`。"
