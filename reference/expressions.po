# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-03 00:16+0000\n"
"PO-Revision-Date: 2018-05-23 16:17+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/expressions.rst:6
msgid "Expressions"
msgstr "表達式"

#: ../../reference/expressions.rst:10
#, fuzzy
msgid ""
"This chapter explains the meaning of the elements of expressions in Python."
msgstr "本章解釋了 Python 中表達式元素的含義。"

#: ../../reference/expressions.rst:12
#, fuzzy
msgid ""
"**Syntax Notes:** In this and the following chapters, extended BNF notation "
"will be used to describe syntax, not lexical analysis.  When (one "
"alternative of) a syntax rule has the form"
msgstr "**語法註釋：**在本章和後續章節中，將使用擴充 BNF "
"表示法來描述語法，而不是詞法分析。當（一種替代）語法規則具有以下形式時"

#: ../../reference/expressions.rst:19
#, fuzzy
msgid ""
"and no semantics are given, the semantics of this form of ``name`` are the "
"same as for ``othername``."
msgstr "並且沒有給出語義，這種形式的 name 的語義與 othername 的語義相同。"

#: ../../reference/expressions.rst:26
#, fuzzy
msgid "Arithmetic conversions"
msgstr "算術轉換"

#: ../../reference/expressions.rst:30
#, fuzzy
msgid ""
"When a description of an arithmetic operator below uses the phrase \"the "
"numeric arguments are converted to a common type\", this means that the "
"operator implementation for built-in types works as follows:"
msgstr "當下面對算術運算符的描述使用短語“數字參數轉換為通用型別”時，這意味著內建型別"
"的運算符實作如下："

#: ../../reference/expressions.rst:34
#, fuzzy
msgid ""
"If either argument is a complex number, the other is converted to complex;"
msgstr "如果其中一個參數是複數，則另一個被轉換為複數；"

#: ../../reference/expressions.rst:36
#, fuzzy
msgid ""
"otherwise, if either argument is a floating point number, the other is "
"converted to floating point;"
msgstr "否則，如果其中一個參數是浮點數，則另一個被轉換為浮點數；"

#: ../../reference/expressions.rst:39
#, fuzzy
msgid "otherwise, both must be integers and no conversion is necessary."
msgstr "否則，兩者都必須是整數並且不需要轉換。"

#: ../../reference/expressions.rst:41
#, fuzzy
msgid ""
"Some additional rules apply for certain operators (e.g., a string as a left "
"argument to the '%' operator).  Extensions must define their own conversion "
"behavior."
msgstr "一些附加規則適用於某些運算符（例如，字串作為 ``%``運算符的左參數）。擴充必須定義"
"自己的轉換行為。"

#: ../../reference/expressions.rst:49
#, fuzzy
msgid "Atoms"
msgstr "原子"

#: ../../reference/expressions.rst:53
#, fuzzy
msgid ""
"Atoms are the most basic elements of expressions.  The simplest atoms are "
"identifiers or literals.  Forms enclosed in parentheses, brackets or braces "
"are also categorized syntactically as atoms.  The syntax for atoms is:"
msgstr "原子是表達式的最基本元素。最簡單的原子是標識符或文字。括在圓括號、方括號或花"
"括號中的形式在句法上也被歸類為原子。原子的語法是："

#: ../../reference/expressions.rst:66
#, fuzzy
msgid "Identifiers (Names)"
msgstr "標識符（名稱）"

#: ../../reference/expressions.rst:70
#, fuzzy
msgid ""
"An identifier occurring as an atom is a name.  See section :ref:"
"`identifiers` for lexical definition and section :ref:`naming` for "
"documentation of naming and binding."
msgstr ""
"作為原子出現的標識符是名稱。請參閱 :ref:`identifiers` 部分了解詞法定義，參閱 "
":ref:`naming` 部分了解命名和綁定的文檔。"

#: ../../reference/expressions.rst:76
#, fuzzy
msgid ""
"When the name is bound to an object, evaluation of the atom yields that "
"object. When a name is not bound, an attempt to evaluate it raises a :exc:"
"`NameError` exception."
msgstr "當名稱綁定到一個物件時，對原子的評估會產生該物件。當名稱未綁定時，"
"嘗試對其求值會引發 :exc:`NameError` 例外。"

#: ../../reference/expressions.rst:86
#, fuzzy
msgid ""
"**Private name mangling:** When an identifier that textually occurs in a "
"class definition begins with two or more underscore characters and does not "
"end in two or more underscores, it is considered a :dfn:`private name` of "
"that class. Private names are transformed to a longer form before code is "
"generated for them.  The transformation inserts the class name, with leading "
"underscores removed and a single underscore inserted, in front of the name.  "
"For example, the identifier ``__spam`` occurring in a class named ``Ham`` "
"will be transformed to ``_Ham__spam``.  This transformation is independent "
"of the syntactical context in which the identifier is used.  If the "
"transformed name is extremely long (longer than 255 characters), "
"implementation defined truncation may happen. If the class name consists "
"only of underscores, no transformation is done."
msgstr ""
"**私有名稱修改：**當類定義中以文本形式出現的標識符以兩個或多個底線字元開頭"
"且不以兩個或多個底線結尾時，它被視為該類的私有名稱。在為它們生成程式碼之前"
"，私有名稱被轉換為更長的形式。轉換插入類名，刪除前導底線並在名稱前面插入一"
"個底線。例如，出現在名為 ``Ham``的類中的標識符“__spam”將被轉換為“_Ham__spam”。"
"此轉換獨立於使用標識符的語法上下文。如果轉換後的名稱非常長（超過 255 個字元）"
"，則可能會發生實作定義的截斷。如果類名僅由底線組成，則不進行任何轉換。"

#: ../../reference/expressions.rst:102
#, fuzzy
msgid "Literals"
msgstr "文字"

#: ../../reference/expressions.rst:106
#, fuzzy
msgid "Python supports string and bytes literals and various numeric literals:"
msgstr "Python 支援字串和位元組文字以及各種數字文字："

#: ../../reference/expressions.rst:112
#, fuzzy
msgid ""
"Evaluation of a literal yields an object of the given type (string, bytes, "
"integer, floating point number, complex number) with the given value.  The "
"value may be approximated in the case of floating point and imaginary "
"(complex) literals.  See section :ref:`literals` for details."
msgstr ""
"對文字的評估會產生具有給定值的給定型別（字串、位元組、整數、浮點數、複數）的"
"物件。在浮點數和虛數（複數）文字的情況下，該值可能是近似值。有關詳細資訊，"
"請參閱 :ref:`literals` 部分。"

#: ../../reference/expressions.rst:121
#, fuzzy
msgid ""
"All literals correspond to immutable data types, and hence the object's "
"identity is less important than its value.  Multiple evaluations of literals "
"with the same value (either the same occurrence in the program text or a "
"different occurrence) may obtain the same object or a different object with "
"the same value."
msgstr ""
"所有文字都對應於不可變資料型別，因此物件的標識不如其值重要。對具有相同值的文"
"字的多次求值（在程式文本中出現相同或不同的情況）可能會獲得相同的對像或具有相"
"同值的不同物件。"

#: ../../reference/expressions.rst:131
#, fuzzy
msgid "Parenthesized forms"
msgstr "括號形式"

#: ../../reference/expressions.rst:137
#, fuzzy
msgid ""
"A parenthesized form is an optional expression list enclosed in parentheses:"
msgstr "括號形式是用括號括起來的可選表達式列表："

#: ../../reference/expressions.rst:142
#, fuzzy
msgid ""
"A parenthesized expression list yields whatever that expression list yields: "
"if the list contains at least one comma, it yields a tuple; otherwise, it "
"yields the single expression that makes up the expression list."
msgstr "帶括號的表達式列表生成表達式列表生成的任何內容：如果列表包含至少一個逗號，則"
"生成一個元組；否則否則，它會產生構成表達式列表的單個表達式。"

#: ../../reference/expressions.rst:148
#, fuzzy
msgid ""
"An empty pair of parentheses yields an empty tuple object.  Since tuples are "
"immutable, the same rules as for literals apply (i.e., two occurrences of "
"the empty tuple may or may not yield the same object)."
msgstr "一對空括號產生一個空元組物件。由於元組是不可變的，因此適用與文字相同的規則（"
"即，空元組的兩次出現可能會或可能不會產生相同的物件）。"

#: ../../reference/expressions.rst:156
#, fuzzy
msgid ""
"Note that tuples are not formed by the parentheses, but rather by use of the "
"comma.  The exception is the empty tuple, for which parentheses *are* "
"required --- allowing unparenthesized \"nothing\" in expressions would cause "
"ambiguities and allow common typos to pass uncaught."
msgstr ""
"請注意，元組不是由括號構成的，而是由逗號構成的。例外是空元組，它需要括號*是* "
"--- 在表達式中允許未加括號的 ``None`` 會導致歧義並允許常見的拼寫錯誤未被捕獲。"

#: ../../reference/expressions.rst:165
#, fuzzy
msgid "Displays for lists, sets and dictionaries"
msgstr "顯示列表、集合和字典"

#: ../../reference/expressions.rst:169
#, fuzzy
msgid ""
"For constructing a list, a set or a dictionary Python provides special "
"syntax called \"displays\", each of them in two flavors:"
msgstr "為了構造列表、集合或字典，Python "
"提供了稱為“顯示”的特殊語法，每種語法都有兩種形式："

#: ../../reference/expressions.rst:172
#, fuzzy
msgid "either the container contents are listed explicitly, or"
msgstr "明確列出容器內容，或者"

#: ../../reference/expressions.rst:174
#, fuzzy
msgid ""
"they are computed via a set of looping and filtering instructions, called a :"
"dfn:`comprehension`."
msgstr "它們是通過一組循環和過濾指令計算的，稱為 :dfn:`comprehension`。"

#: ../../reference/expressions.rst:182
#, fuzzy
msgid "Common syntax elements for comprehensions are:"
msgstr "comprehensions 的常見語法元素是："

#: ../../reference/expressions.rst:190
#, fuzzy
msgid ""
"The comprehension consists of a single expression followed by at least one :"
"keyword:`!for` clause and zero or more :keyword:`!for` or :keyword:`!if` "
"clauses. In this case, the elements of the new container are those that "
"would be produced by considering each of the :keyword:`!for` or :keyword:`!"
"if` clauses a block, nesting from left to right, and evaluating the "
"expression to produce an element each time the innermost block is reached."
msgstr ""
"理解由一個表達式組成，後跟至少一個 :keyword:`!for` 子句和零個或多個 "
":keyword:`!for` 或 :keyword:`!if` 子句。在這種情況下，"
"新容器的元素是通過將每個 :keyword:`!for` 或 :keyword:`!if` 子句視為一個塊、從"
"左到右嵌套併計算表達式而生成的元素每次到達最裡面的塊時產生一個元素。"

#: ../../reference/expressions.rst:197
#, fuzzy
msgid ""
"However, aside from the iterable expression in the leftmost :keyword:`!for` "
"clause, the comprehension is executed in a separate implicitly nested scope. "
"This ensures that names assigned to in the target list don't \"leak\" into "
"the enclosing scope."
msgstr ""
"然而，除了最左邊的 :keyword:`!for` 子句中的可疊代表達式之外，理解是在一個單獨"
"的隱式嵌套範圍內執行的。這確保了目標列表中分配給的名稱不會“洩漏”到封閉範圍中"
"。"

#: ../../reference/expressions.rst:201
#, fuzzy
msgid ""
"The iterable expression in the leftmost :keyword:`!for` clause is evaluated "
"directly in the enclosing scope and then passed as an argument to the "
"implicitly nested scope. Subsequent :keyword:`!for` clauses and any filter "
"condition in the leftmost :keyword:`!for` clause cannot be evaluated in the "
"enclosing scope as they may depend on the values obtained from the leftmost "
"iterable. For example: ``[x*y for x in range(10) for y in range(x, x+10)]``."
msgstr ""
"最左邊 :keyword:`!for` "
"子句中的可疊代表達式直接在封閉範圍內求值，然後作為參數傳遞給隱式嵌套範圍。"
"後面的 :keyword:`!for` 子句和最左邊的 :keyword:`!for` 子句中的任何過濾條件都"
"不能在封閉範圍內求值，因為它們可能取決於從最左邊的可疊代物件獲得的值。例如：`"
"`[x*y for x in range(10) for y in range(x, x+10)]``。"

#: ../../reference/expressions.rst:208
#, fuzzy
msgid ""
"To ensure the comprehension always results in a container of the appropriate "
"type, ``yield`` and ``yield from`` expressions are prohibited in the "
"implicitly nested scope."
msgstr "為確保理解始終產生適當型別的容器，在隱式嵌套範圍內禁止使用 ``yield`` 和 ``"
"yield from`` 表達式。"

#: ../../reference/expressions.rst:215
#, fuzzy
msgid ""
"Since Python 3.6, in an :keyword:`async def` function, an :keyword:`!async "
"for` clause may be used to iterate over a :term:`asynchronous iterator`. A "
"comprehension in an :keyword:`!async def` function may consist of either a :"
"keyword:`!for` or :keyword:`!async for` clause following the leading "
"expression, may contain additional :keyword:`!for` or :keyword:`!async for` "
"clauses, and may also use :keyword:`await` expressions. If a comprehension "
"contains either :keyword:`!async for` clauses or :keyword:`!await` "
"expressions or other asynchronous comprehensions it is called an :dfn:"
"`asynchronous comprehension`.  An asynchronous comprehension may suspend the "
"execution of the coroutine function in which it appears. See also :pep:`530`."
msgstr ""
"從 Python 3.6 開始，在 async def 函式中，!async for 子句可用於疊代 "
"asynchronous iterator。 :keyword:`!async def` "
"函式中的推導式可能由前導表達式後的 :keyword:`!for` 或 :keyword:`!async for` "
"子句組成，可能包含額外的 :keyword:`!for`或 :keyword:`!async for` 子句，"
"也可以使用 :keyword:`await` 表達式。如果推導包含 :keyword:`!async for` "
"子句或 :keyword:`!await` 表達式或其他非同步推導，則它被稱為 :dfn:`"
"asynchronous "
"comprehension`。非同步理解可能會暫停其出現的協程函式的執行。另見 :pep:`530`。"

#: ../../reference/expressions.rst:227
#, fuzzy
msgid "Asynchronous comprehensions were introduced."
msgstr "引入了非同步理解。"

#: ../../reference/expressions.rst:230 ../../reference/expressions.rst:408
#, fuzzy
msgid "``yield`` and ``yield from`` prohibited in the implicitly nested scope."
msgstr "``yield`` 和 ``yield from`` 在隱式嵌套範圍內被禁止。"

#: ../../reference/expressions.rst:233
#, fuzzy
msgid ""
"Asynchronous comprehensions are now allowed inside comprehensions in "
"asynchronous functions. Outer comprehensions implicitly become asynchronous."
msgstr "現在允許在非同步函式的推導式中使用非同步推導式。外部理解隱含地變成了非同步的"
"。"

#: ../../reference/expressions.rst:242
#, fuzzy
msgid "List displays"
msgstr "列表顯示"

#: ../../reference/expressions.rst:252
#, fuzzy
msgid ""
"A list display is a possibly empty series of expressions enclosed in square "
"brackets:"
msgstr "列表顯示是用方括號括起來的一系列可能為空的表達式："

#: ../../reference/expressions.rst:258
#, fuzzy
msgid ""
"A list display yields a new list object, the contents being specified by "
"either a list of expressions or a comprehension.  When a comma-separated "
"list of expressions is supplied, its elements are evaluated from left to "
"right and placed into the list object in that order.  When a comprehension "
"is supplied, the list is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"列表顯示會產生一個新的列表物件，其內容由表達式列表或推導式指定。當提供以逗號"
"分隔的表達式列表時，其元素將從左到右計算並按該順序放入列表對像中。當提供理解"
"時，列表由理解產生的元素構造。"

#: ../../reference/expressions.rst:268
#, fuzzy
msgid "Set displays"
msgstr "設定顯示"

#: ../../reference/expressions.rst:277
#, fuzzy
msgid ""
"A set display is denoted by curly braces and distinguishable from dictionary "
"displays by the lack of colons separating keys and values:"
msgstr "集合顯示由花括號表示，並且由於缺少分隔鍵和值的冒號而與字典顯示區分開來："

#: ../../reference/expressions.rst:283
#, fuzzy
msgid ""
"A set display yields a new mutable set object, the contents being specified "
"by either a sequence of expressions or a comprehension.  When a comma-"
"separated list of expressions is supplied, its elements are evaluated from "
"left to right and added to the set object.  When a comprehension is "
"supplied, the set is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"集合顯示會產生一個新的可變集合物件，其內容由一系列表達式或推導式指定。當提供"
"以逗號分隔的表達式列表時，其元素將從左到右計算並新增到集合對像中。當提供一個"
"推導式時，該集合由推導式產生的元素構成。"

#: ../../reference/expressions.rst:289
#, fuzzy
msgid ""
"An empty set cannot be constructed with ``{}``; this literal constructs an "
"empty dictionary."
msgstr "空集不能用``{}``構造；這個文字構造了一個空字典。"

#: ../../reference/expressions.rst:296
#, fuzzy
msgid "Dictionary displays"
msgstr "詞典顯示"

#: ../../reference/expressions.rst:307
#, fuzzy
msgid ""
"A dictionary display is a possibly empty series of key/datum pairs enclosed "
"in curly braces:"
msgstr "字典顯示是用花括號括起來的一系列可能為空的鍵/資料對："

#: ../../reference/expressions.rst:316
#, fuzzy
msgid "A dictionary display yields a new dictionary object."
msgstr "字典顯示會產生一個新的字典物件。"

#: ../../reference/expressions.rst:318
#, fuzzy
msgid ""
"If a comma-separated sequence of key/datum pairs is given, they are "
"evaluated from left to right to define the entries of the dictionary: each "
"key object is used as a key into the dictionary to store the corresponding "
"datum.  This means that you can specify the same key multiple times in the "
"key/datum list, and the final dictionary's value for that key will be the "
"last one given."
msgstr ""
"如果給出了以逗號分隔的鍵/資料對序列，它們將從左到右計算以定義字典的條目：每個"
"鍵對像用作字典中的鍵以儲存相應的資料。這意味著您可以在鍵/資料列表中多次指定相"
"同的鍵，並且該鍵的最終字典值將是最後給出的值。"

#: ../../reference/expressions.rst:328
#, fuzzy
msgid ""
"A double asterisk ``**`` denotes :dfn:`dictionary unpacking`. Its operand "
"must be a :term:`mapping`.  Each mapping item is added to the new "
"dictionary.  Later values replace values already set by earlier key/datum "
"pairs and earlier dictionary unpackings."
msgstr ""
"雙星號 ``**`` 表示 :dfn:`dictionary unpacking`。它的操作數必須是一個 :term:`m"
"apping`。每個映射項都新增到新詞典中。較晚的值替換較早的鍵/資料對和較早的字典"
"解包已經設定的值。"

#: ../../reference/expressions.rst:333
#, fuzzy
msgid "Unpacking into dictionary displays, originally proposed by :pep:`448`."
msgstr "解包到字典顯示，最初由 :pep:`448` 提出。"

#: ../../reference/expressions.rst:336
#, fuzzy
msgid ""
"A dict comprehension, in contrast to list and set comprehensions, needs two "
"expressions separated with a colon followed by the usual \"for\" and \"if\" "
"clauses. When the comprehension is run, the resulting key and value elements "
"are inserted in the new dictionary in the order they are produced."
msgstr ""
"與列表和集合理解相反，字典理解需要兩個用冒號分隔的表達式，後跟通常的 ``for``和“i"
"f”子句。運行理解時，生成的鍵和值元素將按照它們生成的順序插入到新字典中。"

#: ../../reference/expressions.rst:344
#, fuzzy
msgid ""
"Restrictions on the types of the key values are listed earlier in section :"
"ref:`types`.  (To summarize, the key type should be :term:`hashable`, which "
"excludes all mutable objects.)  Clashes between duplicate keys are not "
"detected; the last datum (textually rightmost in the display) stored for a "
"given key value prevails."
msgstr ""
"鍵值型別的限制在前面的部分 :ref:`types` 中列出。 （總而言之，鍵型別應該是 :te"
"rm:`hashable`，它排除了所有可變物件。）重複鍵之間的衝突不會被檢測到；為給定鍵"
"值儲存的最後資料（在顯示中最右邊的文本）為準。"

#: ../../reference/expressions.rst:350
#, fuzzy
msgid ""
"Prior to Python 3.8, in dict comprehensions, the evaluation order of key and "
"value was not well-defined.  In CPython, the value was evaluated before the "
"key.  Starting with 3.8, the key is evaluated before the value, as proposed "
"by :pep:`572`."
msgstr ""
"在 Python 3.8 之前，在 dict comprehensions 中，key 和 value "
"的評估順序沒有明確定義。在 CPython 中，值在鍵之前計算。從 3.8 "
"開始，鍵在值之前求值，正如 :pep:`572` 所建議的那樣。"

#: ../../reference/expressions.rst:360
#, fuzzy
msgid "Generator expressions"
msgstr "生成器表達式"

#: ../../reference/expressions.rst:367
#, fuzzy
msgid "A generator expression is a compact generator notation in parentheses:"
msgstr "生成器表達式是括號中的緊湊生成器符號："

#: ../../reference/expressions.rst:372
#, fuzzy
msgid ""
"A generator expression yields a new generator object.  Its syntax is the "
"same as for comprehensions, except that it is enclosed in parentheses "
"instead of brackets or curly braces."
msgstr "生成器表達式產生一個新的生成器物件。它的語法與推導式相同，只是它被括在圓括號"
"中而不是方括號或花括號中。"

#: ../../reference/expressions.rst:376
#, fuzzy
msgid ""
"Variables used in the generator expression are evaluated lazily when the :"
"meth:`~generator.__next__` method is called for the generator object (in the "
"same fashion as normal generators).  However, the iterable expression in the "
"leftmost :keyword:`!for` clause is immediately evaluated, so that an error "
"produced by it will be emitted at the point where the generator expression "
"is defined, rather than at the point where the first value is retrieved. "
"Subsequent :keyword:`!for` clauses and any filter condition in the leftmost :"
"keyword:`!for` clause cannot be evaluated in the enclosing scope as they may "
"depend on the values obtained from the leftmost iterable. For example: "
"``(x*y for x in range(10) for y in range(x, x+10))``."
msgstr ""
"當為生成器物件呼叫 :meth:`~generator.__next__` 方法時（以與普通生成器相同的方"
"式），生成器表達式中使用的變數被惰性求值。但是，最左邊的 :keyword:`!for` 子句"
"中的可疊代表達式會立即求值，因此它產生的錯誤將在定義生成器表達式的位置發出，"
"而不是在第一個值是檢索。後面的 :keyword:`!for` 子句和最左邊的 :keyword:`!for`"
" 子句中的任何過濾條件都不能在封閉範圍內求值，因為它們可能取決於從最左邊的可疊"
"代物件獲得的值。例如：``(x*y for x in range(10) for y in range(x, x+10))``。"

#: ../../reference/expressions.rst:387
#, fuzzy
msgid ""
"The parentheses can be omitted on calls with only one argument.  See "
"section :ref:`calls` for details."
msgstr "在只有一個參數的呼叫中可以省略括號。有關詳細資訊，請參閱 :ref:`calls` 部分。"

#: ../../reference/expressions.rst:390
#, fuzzy
msgid ""
"To avoid interfering with the expected operation of the generator expression "
"itself, ``yield`` and ``yield from`` expressions are prohibited in the "
"implicitly defined generator."
msgstr "為了避免干擾生成器表達式本身的預期操作，在隱式定義的生成器中禁止使用 "
"``yield`` 和 ``yield from`` 表達式。"

#: ../../reference/expressions.rst:394
#, fuzzy
msgid ""
"If a generator expression contains either :keyword:`!async for` clauses or :"
"keyword:`await` expressions it is called an :dfn:`asynchronous generator "
"expression`.  An asynchronous generator expression returns a new "
"asynchronous generator object, which is an asynchronous iterator (see :ref:"
"`async-iterators`)."
msgstr ""
"如果生成器表達式包含 :keyword:`!async for` 子句或 :keyword:`await` 表達式，"
"則它被稱為 :dfn:`非同步生成器表達式`。非同步生成器表達式回傳一個新的非同步生"
"成器物件，它是一個非同步疊代器（參見 :ref:`async-iterators`）。"

#: ../../reference/expressions.rst:400
#, fuzzy
msgid "Asynchronous generator expressions were introduced."
msgstr "引入了非同步生成器表達式。"

#: ../../reference/expressions.rst:403
#, fuzzy
msgid ""
"Prior to Python 3.7, asynchronous generator expressions could only appear "
"in :keyword:`async def` coroutines.  Starting with 3.7, any function can use "
"asynchronous generator expressions."
msgstr ""
"在 Python 3.7 之前，非同步生成器表達式只能出現在 :keyword:`async def` "
"協程中。從 3.7 開始，任何函式都可以使用非同步生成器表達式。"

#: ../../reference/expressions.rst:415
#, fuzzy
msgid "Yield expressions"
msgstr "產量表達式"

#: ../../reference/expressions.rst:427
#, fuzzy
msgid ""
"The yield expression is used when defining a :term:`generator` function or "
"an :term:`asynchronous generator` function and thus can only be used in the "
"body of a function definition.  Using a yield expression in a function's "
"body causes that function to be a generator function, and using it in an :"
"keyword:`async def` function's body causes that coroutine function to be an "
"asynchronous generator function. For example::"
msgstr ""
"yield 表達式在定義 :term:`generator` 函式或 :term:`asynchronous generator` "
"函式時使用，因此只能在函式定義的主體中使用。在函式體中使用 yield "
"表達式會使該函式成為生成器函式，而在 :keyword:`async def` "
"函式體中使用它會使協程函式成為非同步生成器函式。例如：："

#: ../../reference/expressions.rst:440
#, fuzzy
msgid ""
"Due to their side effects on the containing scope, ``yield`` expressions are "
"not permitted as part of the implicitly defined scopes used to implement "
"comprehensions and generator expressions."
msgstr "由於它們對包含範圍的副作用，``yield`` "
"表達式不允許作為用於實作理解和生成器表達式的隱式定義範圍的一部分。"

#: ../../reference/expressions.rst:444
#, fuzzy
msgid ""
"Yield expressions prohibited in the implicitly nested scopes used to "
"implement comprehensions and generator expressions."
msgstr "在用於實作理解和生成器表達式的隱式嵌套範圍中禁止使用 Yield 表達式。"

#: ../../reference/expressions.rst:448
#, fuzzy
msgid ""
"Generator functions are described below, while asynchronous generator "
"functions are described separately in section :ref:`asynchronous-generator-"
"functions`."
msgstr "生成器函式在下面描述，而非同步生成器函式在 :ref:`asynchronous-generator-"
"functions` 部分單獨描述。"

#: ../../reference/expressions.rst:452
#, fuzzy
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator.  That generator then controls the execution of the generator "
"function.  The execution starts when one of the generator's methods is "
"called. At that time, the execution proceeds to the first yield expression, "
"where it is suspended again, returning the value of :token:`~python-grammar:"
"expression_list` to the generator's caller, or ``None`` if :token:`~python-"
"grammar:expression_list` is omitted. By suspended, we mean that all local "
"state is retained, including the current bindings of local variables, the "
"instruction pointer, the internal evaluation stack, and the state of any "
"exception handling. When the execution is resumed by calling one of the "
"generator's methods, the function can proceed exactly as if the yield "
"expression were just another external call.  The value of the yield "
"expression after resuming depends on the method which resumed the "
"execution.  If :meth:`~generator.__next__` is used (typically via either a :"
"keyword:`for` or the :func:`next` builtin) then the result is :const:"
"`None`.  Otherwise, if :meth:`~generator.send` is used, then the result will "
"be the value passed in to that method."
msgstr ""
"呼叫生成器函式時，它會回傳一個稱為生成器的疊代器。然後該生成器控制生成器函式"
"的執行。當呼叫生成器的方法之一時開始執行。那時，執行繼續到第一個 yield "
"表達式，它再次掛起，將 :token:`~python-grammar:expression_list` "
"的值回傳給生成器的呼叫者，或者 ``None`` 如果 :token:` ~python-"
"grammar:expression_list` 被省略。暫停是指保留所有局部狀態，包括局部變數的當前"
"綁定、指令指標、內部計算堆疊和任何例外處理的狀態。當通過呼叫生成器的方法之一"
"恢復執行時，該函式可以像 yield 表達式只是另一個外部呼叫一樣繼續執行。恢復後 "
"yield 表達式的值取決於恢復執行的方法。如果使用 :meth:`~generator.__next__`（"
"通常通過 :keyword:`for` 或 :func:`next` 內建函式），則結果為 "
":const:`None`。否則，如果使用 :meth:`~generator."
"send`，則結果將是傳遞給該方法的值。"

#: ../../reference/expressions.rst:472
#, fuzzy
msgid ""
"All of this makes generator functions quite similar to coroutines; they "
"yield multiple times, they have more than one entry point and their "
"execution can be suspended.  The only difference is that a generator "
"function cannot control where the execution should continue after it yields; "
"the control is always transferred to the generator's caller."
msgstr ""
"所有這些使得生成器功能與協程非常相似；它們產生多次，它們有多個入口點，它們的"
"執行可以被暫停。唯一的區別是生成器函式無法控制在它產生後應該在哪裡繼續執行；"
"控制總是轉移給生成器的呼叫者。"

#: ../../reference/expressions.rst:478
#, fuzzy
msgid ""
"Yield expressions are allowed anywhere in a :keyword:`try` construct.  If "
"the generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), the generator-iterator's :"
"meth:`~generator.close` method will be called, allowing any pending :keyword:"
"`finally` clauses to execute."
msgstr ""
":keyword:`try` 結構中的任何地方都允許使用 Yield "
"表達式。如果生成器在完成之前沒有恢復（通過達到零引用計數或被垃圾收集），"
"生成器疊代器的 :meth:`~generator.close` 方法將被呼叫，允許任何掛起的 "
":keyword:`finally ` 要執行的子句。"

#: ../../reference/expressions.rst:487
#, fuzzy
msgid ""
"When ``yield from <expr>`` is used, the supplied expression must be an "
"iterable. The values produced by iterating that iterable are passed directly "
"to the caller of the current generator's methods. Any values passed in with :"
"meth:`~generator.send` and any exceptions passed in with :meth:`~generator."
"throw` are passed to the underlying iterator if it has the appropriate "
"methods.  If this is not the case, then :meth:`~generator.send` will raise :"
"exc:`AttributeError` or :exc:`TypeError`, while :meth:`~generator.throw` "
"will just raise the passed in exception immediately."
msgstr ""
"當使用 ``yield from <expr>`` 時，提供的表達式必須是可疊代的。通過疊代該可疊代"
"物件產生的值直接傳遞給當前生成器方法的呼叫者。使用 :meth:`~generator.send` "
"傳遞的任何值和使用 :meth:`~generator.throw` 傳遞的任何例外都會傳遞給底層疊代"
"器（如果它具有適當的方法）。如果不是這種情況，那麼 :meth:`~generator.send` "
"將引發 :exc:`AttributeError` 或 :exc:`TypeError`，而 :meth:`~generator.throw`"
" 只會引發傳入的例外立即地。"

#: ../../reference/expressions.rst:496
#, fuzzy
msgid ""
"When the underlying iterator is complete, the :attr:`~StopIteration.value` "
"attribute of the raised :exc:`StopIteration` instance becomes the value of "
"the yield expression. It can be either set explicitly when raising :exc:"
"`StopIteration`, or automatically when the subiterator is a generator (by "
"returning a value from the subgenerator)."
msgstr ""
"當底層疊代器完成時，引發的 :exc:`StopIteration` 實例的 :attr:`~StopIteration."
"value` 屬性成為 yield 表達式的值。它可以在引發 :exc:`StopIteration` "
"時顯式設定，也可以在子疊代器是生成器時自動設定（通過從子生成器回傳一個值）。"

#: ../../reference/expressions.rst:502
#, fuzzy
msgid "Added ``yield from <expr>`` to delegate control flow to a subiterator."
msgstr "新增了 ``yield from <expr>`` 以將控制流委託給子疊代器。"

#: ../../reference/expressions.rst:505
#, fuzzy
msgid ""
"The parentheses may be omitted when the yield expression is the sole "
"expression on the right hand side of an assignment statement."
msgstr "當 yield 表達式是賦值語句右側的唯一表達式時，可以省略括號。"

#: ../../reference/expressions.rst:511
#, fuzzy
msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - 簡單的生成器"

#: ../../reference/expressions.rst:511
#, fuzzy
msgid ""
"The proposal for adding generators and the :keyword:`yield` statement to "
"Python."
msgstr "向 Python 新增生成器和 :keyword:`yield` 語句的提案。"

#: ../../reference/expressions.rst:515
#, fuzzy
msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ":pep:`342` - 通過增強生成器的協程"

#: ../../reference/expressions.rst:514
#, fuzzy
msgid ""
"The proposal to enhance the API and syntax of generators, making them usable "
"as simple coroutines."
msgstr "增強生成器的 API 和語法的提議，使它們可以用作簡單的協程。"

#: ../../reference/expressions.rst:519
#, fuzzy
msgid ":pep:`380` - Syntax for Delegating to a Subgenerator"
msgstr ":pep:`380` - 委託給子生成器的語法"

#: ../../reference/expressions.rst:518
#, fuzzy
msgid ""
"The proposal to introduce the :token:`~python-grammar:yield_from` syntax, "
"making delegation to subgenerators easy."
msgstr "引入 :token:`~python-grammar:yield_from` "
"語法的提議，使子生成器的委派變得容易。"

#: ../../reference/expressions.rst:522
#, fuzzy
msgid ":pep:`525` - Asynchronous Generators"
msgstr ":pep:`525` - 非同步生成器"

#: ../../reference/expressions.rst:522
#, fuzzy
msgid ""
"The proposal that expanded on :pep:`492` by adding generator capabilities to "
"coroutine functions."
msgstr "通過向協程函式新增生成器功能來擴充 :pep:`492` 的提案。"

#: ../../reference/expressions.rst:529
#, fuzzy
msgid "Generator-iterator methods"
msgstr "生成器-疊代器方法"

#: ../../reference/expressions.rst:531
#, fuzzy
msgid ""
"This subsection describes the methods of a generator iterator.  They can be "
"used to control the execution of a generator function."
msgstr "本小節描述生成器疊代器的方法。它們可用於控制生成器函式的執行。"

#: ../../reference/expressions.rst:534
#, fuzzy
msgid ""
"Note that calling any of the generator methods below when the generator is "
"already executing raises a :exc:`ValueError` exception."
msgstr "請注意，當生成器已經在執行時呼叫下面的任何生成器方法都會引發 "
":exc:`ValueError` 例外。"

#: ../../reference/expressions.rst:542
#, fuzzy
msgid ""
"Starts the execution of a generator function or resumes it at the last "
"executed yield expression.  When a generator function is resumed with a :"
"meth:`~generator.__next__` method, the current yield expression always "
"evaluates to :const:`None`.  The execution then continues to the next yield "
"expression, where the generator is suspended again, and the value of the :"
"token:`~python-grammar:expression_list` is returned to :meth:`__next__`'s "
"caller.  If the generator exits without yielding another value, a :exc:"
"`StopIteration` exception is raised."
msgstr ""
"開始執行生成器函式或在最後執行的 yield 表達式處恢復它。當使用 "
":meth:`~generator.__next__` 方法恢復生成器函式時，當前 yield "
"表達式的計算結果始終為 :const:`None`。然後繼續執行下一個 yield "
"表達式，生成器再次掛起，並將 :token:`~python-grammar:expression_list` "
"的值回傳給 :meth:`__next__` "
"的呼叫者。如果生成器在沒有產生另一個值的情況下退出，則會引發 "
":exc:`StopIteration` 例外。"

#: ../../reference/expressions.rst:551
#, fuzzy
msgid ""
"This method is normally called implicitly, e.g. by a :keyword:`for` loop, or "
"by the built-in :func:`next` function."
msgstr "此方法通常被隱式呼叫，例如通過 :keyword:`for` 循環，或通過內建的 :func:`next`"
" 函式。"

#: ../../reference/expressions.rst:557
#, fuzzy
msgid ""
"Resumes the execution and \"sends\" a value into the generator function.  "
"The *value* argument becomes the result of the current yield expression.  "
"The :meth:`send` method returns the next value yielded by the generator, or "
"raises :exc:`StopIteration` if the generator exits without yielding another "
"value.  When :meth:`send` is called to start the generator, it must be "
"called with :const:`None` as the argument, because there is no yield "
"expression that could receive the value."
msgstr ""
"恢復執行並將值“發送”到生成器函式中。 *value* 參數成為當前 yield "
"表達式的結果。 :meth:`send` "
"方法回傳生成器生成的下一個值，或者如果生成器在沒有生成另一個值的情況下退出，"
"則引發 :exc:`StopIteration`。當呼叫 :meth:`send` 啟動生成器時，必須以 "
":const:`None` 作為參數呼叫它，因為沒有可以接收值的 yield 表達式。"

#: ../../reference/expressions.rst:569
#, fuzzy
msgid ""
"Raises an exception at the point where the generator was paused, and returns "
"the next value yielded by the generator function.  If the generator exits "
"without yielding another value, a :exc:`StopIteration` exception is raised.  "
"If the generator function does not catch the passed-in exception, or raises "
"a different exception, then that exception propagates to the caller."
msgstr ""
"在生成器暫停的位置引發例外，並回傳生成器函式產生的下一個值。如果生成器在沒有"
"產生另一個值的情況下退出，則會引發 :exc:`StopIteration` 例外。如果生成器函式"
"沒有捕獲傳入的例外，或者引發了一個不同的例外，那麼該例外就會傳播給呼叫者。"

#: ../../reference/expressions.rst:575
#, fuzzy
msgid ""
"In typical use, this is called with a single exception instance similar to "
"the way the :keyword:`raise` keyword is used."
msgstr "在典型的使用中，這是用一個單一的例外實例來呼叫的，類似於 :keyword:`raise` "
"關鍵字的使用方式。"

#: ../../reference/expressions.rst:578
#, fuzzy
msgid ""
"For backwards compatibility, however, the second signature is supported, "
"following a convention from older versions of Python. The *type* argument "
"should be an exception class, and *value* should be an exception instance. "
"If the *value* is not provided, the *type* constructor is called to get an "
"instance. If *traceback* is provided, it is set on the exception, otherwise "
"any existing :attr:`~BaseException.__traceback__` attribute stored in "
"*value* may be cleared."
msgstr ""
"但是，為了向後相容，支援第二個簽名，遵循舊版本 Python 的約定。 *type* "
"參數應該是一個例外類，*value* 應該是一個例外實例。如果未提供 *value*，則呼叫 "
"*type* 構造函式來獲取實例。如果提供了 *traceback*，它會在例外上設定，"
"否則儲存在 *value* 中的任何現有 :attr:`~BaseException.__traceback__` "
"屬性都可能被清除。"

#: ../../reference/expressions.rst:592
#, fuzzy
msgid ""
"Raises a :exc:`GeneratorExit` at the point where the generator function was "
"paused.  If the generator function then exits gracefully, is already closed, "
"or raises :exc:`GeneratorExit` (by not catching the exception), close "
"returns to its caller.  If the generator yields a value, a :exc:"
"`RuntimeError` is raised.  If the generator raises any other exception, it "
"is propagated to the caller.  :meth:`close` does nothing if the generator "
"has already exited due to an exception or normal exit."
msgstr ""
"在生成器函式暫停的位置引發 :exc:`GeneratorExit`。如果生成器函式隨後正常退出、"
"已經關閉或引發 :exc:`GeneratorExit`（通過不捕獲例外），則關閉回傳到其呼叫者。"
"如果生成器產生一個值，則會引發 :exc:`RuntimeError`。如果生成器引發任何其他例"
"外，它會傳播給呼叫者。如果生成器已經因例外或正常退出而退出，則 :meth:`close` "
"不執行任何操作。"

#: ../../reference/expressions.rst:603
msgid "Examples"
msgstr "模組"

#: ../../reference/expressions.rst:605
#, fuzzy
msgid ""
"Here is a simple example that demonstrates the behavior of generators and "
"generator functions::"
msgstr "這是一個演示生成器和生成器函式行為的簡單示例："

#: ../../reference/expressions.rst:632
#, fuzzy
msgid ""
"For examples using ``yield from``, see :ref:`pep-380` in \"What's New in "
"Python.\""
msgstr "有關使用 ``yield from`` 的示例，請參閱“Python 的新增功能”中的 "
":ref:`pep-380`。"

#: ../../reference/expressions.rst:638
#, fuzzy
msgid "Asynchronous generator functions"
msgstr "非同步生成器函式"

#: ../../reference/expressions.rst:640
#, fuzzy
msgid ""
"The presence of a yield expression in a function or method defined using :"
"keyword:`async def` further defines the function as an :term:`asynchronous "
"generator` function."
msgstr "使用 async def 定義的函式或方法中存在 yield 表達式進一步將該函式定義為 "
"asynchronous generator 函式。"

#: ../../reference/expressions.rst:644
#, fuzzy
msgid ""
"When an asynchronous generator function is called, it returns an "
"asynchronous iterator known as an asynchronous generator object. That object "
"then controls the execution of the generator function. An asynchronous "
"generator object is typically used in an :keyword:`async for` statement in a "
"coroutine function analogously to how a generator object would be used in a :"
"keyword:`for` statement."
msgstr ""
"當呼叫非同步生成器函式時，它會回傳一個稱為非同步生成器物件的非同步疊代器。然"
"後該物件控制生成器函式的執行。非同步生成器物件通常用在協程函式中的 async for "
"語句中，類似於生成器對像在 for 語句中的使用方式。"

#: ../../reference/expressions.rst:651
#, fuzzy
msgid ""
"Calling one of the asynchronous generator's methods returns an :term:"
"`awaitable` object, and the execution starts when this object is awaited on. "
"At that time, the execution proceeds to the first yield expression, where it "
"is suspended again, returning the value of :token:`~python-grammar:"
"expression_list` to the awaiting coroutine. As with a generator, suspension "
"means that all local state is retained, including the current bindings of "
"local variables, the instruction pointer, the internal evaluation stack, and "
"the state of any exception handling. When the execution is resumed by "
"awaiting on the next object returned by the asynchronous generator's "
"methods, the function can proceed exactly as if the yield expression were "
"just another external call. The value of the yield expression after resuming "
"depends on the method which resumed the execution.  If :meth:`~agen."
"__anext__` is used then the result is :const:`None`. Otherwise, if :meth:"
"`~agen.asend` is used, then the result will be the value passed in to that "
"method."
msgstr ""
"呼叫非同步生成器的方法之一會回傳一個 :term:`awaitable` "
"物件，並在等待此物件時開始執行。那時，執行繼續到第一個 yield "
"表達式，它再次暫停，將 :token:`~python-grammar:expression_list` 的值回傳給等"
"待的協程。與生成器一樣，掛起意味著保留所有局部狀態，包括局部變數的當前綁定、"
"指令指標、內部計算堆疊和任何例外處理的狀態。當通過等待非同步生成器的方法回傳"
"的下一個物件來恢復執行時，該函式可以完全繼續執行，就好像 yield "
"表達式只是另一個外部呼叫一樣。恢復後 yield 表達式的值取決於恢復執行的方法。"
"如果使用 :meth:`~agen.__anext__` 則結果為 :const:`None`。否則，如果使用 "
":meth:`~agen.asend`，則結果將是傳遞給該方法的值。"

#: ../../reference/expressions.rst:666
#, fuzzy
msgid ""
"If an asynchronous generator happens to exit early by :keyword:`break`, the "
"caller task being cancelled, or other exceptions, the generator's async "
"cleanup code will run and possibly raise exceptions or access context "
"variables in an unexpected context--perhaps after the lifetime of tasks it "
"depends, or during the event loop shutdown when the async-generator garbage "
"collection hook is called. To prevent this, the caller must explicitly close "
"the async generator by calling :meth:`~agen.aclose` method to finalize the "
"generator and ultimately detach it from the event loop."
msgstr ""
"如果非同步生成器碰巧因 break、呼叫者任務被取消或其他例外提前退出，則生成器的"
"非同步清理程式碼將運行並可能在意外上下文中引發例外或訪問上下文變數——可能在它"
"所依賴的任務的生命週期，或者在呼叫非同步生成器垃圾收集掛鉤時事件循環關閉期間"
"。為防止這種情況，呼叫者必須通過呼叫 :meth:`~agen.aclose` "
"方法顯式關閉非同步生成器以完成生成器並最終將其從事件循環中分離出來。"

#: ../../reference/expressions.rst:676
#, fuzzy
msgid ""
"In an asynchronous generator function, yield expressions are allowed "
"anywhere in a :keyword:`try` construct. However, if an asynchronous "
"generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), then a yield expression "
"within a :keyword:`!try` construct could result in a failure to execute "
"pending :keyword:`finally` clauses.  In this case, it is the responsibility "
"of the event loop or scheduler running the asynchronous generator to call "
"the asynchronous generator-iterator's :meth:`~agen.aclose` method and run "
"the resulting coroutine object, thus allowing any pending :keyword:`!"
"finally` clauses to execute."
msgstr ""
"在非同步生成器函式中，yield 表達式可以出現在 try 構造中的任何位置。但是，如果"
"非同步生成器在完成之前未恢復（通過達到零引用計數或被垃圾收集），則 "
":keyword:`!try` 構造中的 yield 表達式可能導致執行掛起失敗 :keyword:`finally` "
"子句。在這種情況下，運行非同步生成器的事件循環或調度程式負責呼叫非同步生成器-"
"疊代器的 :meth:`~agen.aclose` 方法並運行生成的協程物件，從而允許任何掛起的 "
":keyword:` !finally` 子句執行。"

#: ../../reference/expressions.rst:687
#, fuzzy
msgid ""
"To take care of finalization upon event loop termination, an event loop "
"should define a *finalizer* function which takes an asynchronous generator-"
"iterator and presumably calls :meth:`~agen.aclose` and executes the "
"coroutine. This  *finalizer* may be registered by calling :func:`sys."
"set_asyncgen_hooks`. When first iterated over, an asynchronous generator-"
"iterator will store the registered *finalizer* to be called upon "
"finalization. For a reference example of a *finalizer* method see the "
"implementation of ``asyncio.Loop.shutdown_asyncgens`` in :source:`Lib/"
"asyncio/base_events.py`."
msgstr ""
"為了處理事件循環終止時的終結，事件循環應該定義一個 *finalizer* "
"函式，它採用非同步生成器-疊代器並可能呼叫 :meth:`~agen.aclose` 並執行協程。"
"這個 *finalizer* 可以通過呼叫 :func:`sys.set_asyncgen_hooks` "
"來註冊。第一次疊代時，非同步生成器-疊代器將儲存已註冊的 *finalizer* "
"以在完成時呼叫。有關 *finalizer* 方法的參考示例，請參閱 :source:`Lib/asyncio/"
"base_events.py` 中的 ``asyncio.Loop.shutdown_asyncgens`` 的實作。"

#: ../../reference/expressions.rst:696
#, fuzzy
msgid ""
"The expression ``yield from <expr>`` is a syntax error when used in an "
"asynchronous generator function."
msgstr "表達式“yield from <expr>”在非同步生成器函式中使用時是一個語法錯誤。"

#: ../../reference/expressions.rst:703
#, fuzzy
msgid "Asynchronous generator-iterator methods"
msgstr "非同步生成器-疊代器方法"

#: ../../reference/expressions.rst:705
#, fuzzy
msgid ""
"This subsection describes the methods of an asynchronous generator iterator, "
"which are used to control the execution of a generator function."
msgstr "本小節描述非同步生成器疊代器的方法，這些方法用於控制生成器函式的執行。"

#: ../../reference/expressions.rst:713
#, fuzzy
msgid ""
"Returns an awaitable which when run starts to execute the asynchronous "
"generator or resumes it at the last executed yield expression.  When an "
"asynchronous generator function is resumed with an :meth:`~agen.__anext__` "
"method, the current yield expression always evaluates to :const:`None` in "
"the returned awaitable, which when run will continue to the next yield "
"expression. The value of the :token:`~python-grammar:expression_list` of the "
"yield expression is the value of the :exc:`StopIteration` exception raised "
"by the completing coroutine.  If the asynchronous generator exits without "
"yielding another value, the awaitable instead raises a :exc:"
"`StopAsyncIteration` exception, signalling that the asynchronous iteration "
"has completed."
msgstr ""
"回傳一個 awaitable ，它在運行時開始執行非同步生成器或在最後執行的 yield "
"表達式處恢復它。當使用 :meth:`~agen.__anext__` 方法恢復非同步生成器函式時，"
"當前 yield 表達式在回傳的 awaitable 中始終計算為 :const:`None`，"
"運行時將繼續下一個 yield 表達式。 yield 表達式的 :token:`~python-"
"grammar:expression_list` 的值是完成協程引發的 :exc:`StopIteration` "
"例外的值。如果非同步生成器在沒有產生另一個值的情況下退出，則可等待物件會引發 "
":exc:`StopAsyncIteration` 例外，表明非同步疊代已完成。"

#: ../../reference/expressions.rst:725
#, fuzzy
msgid ""
"This method is normally called implicitly by a :keyword:`async for` loop."
msgstr "此方法通常由 async for 循環隱式呼叫。"

#: ../../reference/expressions.rst:730
#, fuzzy
msgid ""
"Returns an awaitable which when run resumes the execution of the "
"asynchronous generator. As with the :meth:`~generator.send()` method for a "
"generator, this \"sends\" a value into the asynchronous generator function, "
"and the *value* argument becomes the result of the current yield expression. "
"The awaitable returned by the :meth:`asend` method will return the next "
"value yielded by the generator as the value of the raised :exc:"
"`StopIteration`, or raises :exc:`StopAsyncIteration` if the asynchronous "
"generator exits without yielding another value.  When :meth:`asend` is "
"called to start the asynchronous generator, it must be called with :const:"
"`None` as the argument, because there is no yield expression that could "
"receive the value."
msgstr ""
"回傳一個 awaitable ，它在運行時恢復非同步生成器的執行。與生成器的 "
":meth:`~generator.send()` "
"方法一樣，這會將一個值“發送”到非同步生成器函式中，*value* 參數成為當前 yield "
"表達式的結果。 asend "
"方法回傳的可等待物件將回傳生成器生成的下一個值作為引發的 StopIteration "
"的值，或者如果非同步生成器退出而沒有產生另一個，則引發 "
"StopAsyncIteration價值。當呼叫 :meth:`asend` 啟動非同步生成器時，必須以 "
":const:`None` 作為參數呼叫它，因為沒有可以接收值的 yield 表達式。"

#: ../../reference/expressions.rst:745
#, fuzzy
msgid ""
"Returns an awaitable that raises an exception of type ``type`` at the point "
"where the asynchronous generator was paused, and returns the next value "
"yielded by the generator function as the value of the raised :exc:"
"`StopIteration` exception.  If the asynchronous generator exits without "
"yielding another value, a :exc:`StopAsyncIteration` exception is raised by "
"the awaitable. If the generator function does not catch the passed-in "
"exception, or raises a different exception, then when the awaitable is run "
"that exception propagates to the caller of the awaitable."
msgstr ""
"回傳一個在非同步生成器暫停時引發 ``type`` 型別例外的可等待物件，"
"並回傳生成器函式產生的下一個值作為引發的 StopIteration "
"例外的值。如果非同步生成器在沒有產生另一個值的情況下退出，可等待物件會引發 "
"StopAsyncIteration 例外。如果生成器函式沒有捕獲傳入的例外，或者引發了一個不同"
"的例外，那麼當可等待物件運行時，該例外將傳播給可等待物件的呼叫者。"

#: ../../reference/expressions.rst:760
#, fuzzy
msgid ""
"Returns an awaitable that when run will throw a :exc:`GeneratorExit` into "
"the asynchronous generator function at the point where it was paused. If the "
"asynchronous generator function then exits gracefully, is already closed, or "
"raises :exc:`GeneratorExit` (by not catching the exception), then the "
"returned awaitable will raise a :exc:`StopIteration` exception. Any further "
"awaitables returned by subsequent calls to the asynchronous generator will "
"raise a :exc:`StopAsyncIteration` exception.  If the asynchronous generator "
"yields a value, a :exc:`RuntimeError` is raised by the awaitable.  If the "
"asynchronous generator raises any other exception, it is propagated to the "
"caller of the awaitable.  If the asynchronous generator has already exited "
"due to an exception or normal exit, then further calls to :meth:`aclose` "
"will return an awaitable that does nothing."
msgstr ""
"回傳一個可等待物件，當它運行時會在非同步生成器函式暫停的地方拋出一個 "
":exc:`GeneratorExit`。如果非同步生成器函式隨後正常退出、已經關閉或引發 "
":exc:`GeneratorExit`（通過不捕獲例外），則回傳的等待物件將引發 "
":exc:`StopIteration` 例外。"
"對非同步生成器的後續呼叫回傳的任何其他可等待對像都將引發 "
":exc:`StopAsyncIteration` 例外。如果非同步生成器產生一個值，則 "
":exc:`RuntimeError` 由可等待物件引發。如果非同步生成器引發任何其他例外，它會"
"傳播到可等待物件的呼叫者。如果非同步生成器已經由於例外或正常退出而退出，"
"那麼進一步呼叫 aclose 將回傳一個什麼都不做的可等待物件。"

#: ../../reference/expressions.rst:776
#, fuzzy
msgid "Primaries"
msgstr "初選"

#: ../../reference/expressions.rst:780
#, fuzzy
msgid ""
"Primaries represent the most tightly bound operations of the language. Their "
"syntax is:"
msgstr "Primaries 代表語言中綁定最緊密的操作。它們的語法是："

#: ../../reference/expressions.rst:790
#, fuzzy
msgid "Attribute references"
msgstr "屬性引用"

#: ../../reference/expressions.rst:796
#, fuzzy
msgid "An attribute reference is a primary followed by a period and a name:"
msgstr "屬性引用是主要的，後跟句點和名稱："

#: ../../reference/expressions.rst:806
#, fuzzy
msgid ""
"The primary must evaluate to an object of a type that supports attribute "
"references, which most objects do.  This object is then asked to produce the "
"attribute whose name is the identifier.  This production can be customized "
"by overriding the :meth:`__getattr__` method.  If this attribute is not "
"available, the exception :exc:`AttributeError` is raised.  Otherwise, the "
"type and value of the object produced is determined by the object.  Multiple "
"evaluations of the same attribute reference may yield different objects."
msgstr ""
"主要物件必須評估為支援屬性引用的型別的物件，大多數對像都這樣做。然後要求該對"
"像生成名稱為標識符的屬性。可以通過重寫 :meth:`__getattr__` 方法來自定義此產生"
"式。如果此屬性不可用，則會引發例外 :exec:`AttributeError`。否則，產生的物件的"
"型別和值由物件決定。同一屬性引用的多次評估可能會產生不同的物件。"

#: ../../reference/expressions.rst:818
#, fuzzy
msgid "Subscriptions"
msgstr "訂閱"

#: ../../reference/expressions.rst:833
#, fuzzy
msgid ""
"The subscription of an instance of a :ref:`container class <sequence-types>` "
"will generally select an element from the container. The subscription of a :"
"term:`generic class <generic type>` will generally return a :ref:"
"`GenericAlias <types-genericalias>` object."
msgstr ""
"訂閱 :ref:`container class <sequence-types>` "
"的實例通常會從容器中選擇一個元素。 :term:`generic class <generic type>` "
"的訂閱通常會回傳一個 :ref:`GenericAlias <types-genericalias>` 物件。"

#: ../../reference/expressions.rst:841
#, fuzzy
msgid ""
"When an object is subscripted, the interpreter will evaluate the primary and "
"the expression list."
msgstr "當一個對像被下標時，直譯器將計算主列表和表達式列表。"

#: ../../reference/expressions.rst:844
#, fuzzy
msgid ""
"The primary must evaluate to an object that supports subscription. An object "
"may support subscription through defining one or both of :meth:`~object."
"__getitem__` and :meth:`~object.__class_getitem__`. When the primary is "
"subscripted, the evaluated result of the expression list will be passed to "
"one of these methods. For more details on when ``__class_getitem__`` is "
"called instead of ``__getitem__``, see :ref:`classgetitem-versus-getitem`."
msgstr ""
"主要物件必須評估為支援訂閱的物件。物件可以通過定義 :meth:`~object."
"__getitem__` 和 :meth:`~object.__class_getitem__` "
"之一或兩者來支援訂閱。下標時，表達式列表的評估結果將傳遞給這些方法之一。"
"有關何時呼叫 __class_getitem__ 而不是 __getitem__ 的更多詳細資訊，請參閱 :ref"
":`classgetitem-versus-getitem`。"

#: ../../reference/expressions.rst:851
#, fuzzy
msgid ""
"If the expression list contains at least one comma, it will evaluate to a :"
"class:`tuple` containing the items of the expression list. Otherwise, the "
"expression list will evaluate to the value of the list's sole member."
msgstr "如果表達式列表包含至少一個逗號，它將評估為包含表達式列表項的 "
":class:`tuple`。否則，表達式列表將計算為列表唯一成員的值。"

#: ../../reference/expressions.rst:855
#, fuzzy
msgid ""
"For built-in objects, there are two types of objects that support "
"subscription via :meth:`~object.__getitem__`:"
msgstr "對於內建物件，有兩種型別的物件支援通過 :meth:`~object.__getitem__` 進行訂閱："

#: ../../reference/expressions.rst:858
#, fuzzy
msgid ""
"Mappings. If the primary is a :term:`mapping`, the expression list must "
"evaluate to an object whose value is one of the keys of the mapping, and the "
"subscription selects the value in the mapping that corresponds to that key. "
"An example of a builtin mapping class is the :class:`dict` class."
msgstr ""
"映射。如果主要是映射，則表達式列表必須評估其值是映射鍵之一的物件，並且訂閱選"
"擇對應於該鍵的映射中的值。內建映射類的一個示例是 :class:`dict` 類。"

#: ../../reference/expressions.rst:862
#, fuzzy
msgid ""
"Sequences. If the primary is a :term:`sequence`, the expression list must "
"evaluate to an :class:`int` or a :class:`slice` (as discussed in the "
"following section). Examples of builtin sequence classes include the :class:"
"`str`, :class:`list` and :class:`tuple` classes."
msgstr ""
"序列。如果主要是 :term:`sequence`，則表達式列表必須評估為 :class:`int` 或 "
":class:`slice`（如下一節所述）。內建序列類的示例包括 "
":class:`str`、:class:`list` 和 :class:`tuple` 類。"

#: ../../reference/expressions.rst:867
#, fuzzy
msgid ""
"The formal syntax makes no special provision for negative indices in :term:"
"`sequences <sequence>`. However, built-in sequences all provide a :meth:"
"`~object.__getitem__` method that interprets negative indices by adding the "
"length of the sequence to the index so that, for example, ``x[-1]`` selects "
"the last item of ``x``. The resulting value must be a nonnegative integer "
"less than the number of items in the sequence, and the subscription selects "
"the item whose index is that value (counting from zero). Since the support "
"for negative indices and slicing occurs in the object's :meth:`__getitem__` "
"method, subclasses overriding this method will need to explicitly add that "
"support."
msgstr ""
"正式語法對 :term:`sequences <sequence>` 中的負索引沒有特殊規定。但是，"
"內建序列都提供了一個 :meth:`~object.__getitem__` "
"方法，該方法通過將序列的長度新增到索引來解釋負索引，例如，``x[-1]`` 選擇``x``"
" 的最後一項。結果值必須是小於序列中項目數的非負整數，並且訂閱選擇索引為該值（"
"從零開始計數）的項目。由於對負索引和切片的支援發生在物件的 "
":meth:`__getitem__` 方法中，因此覆蓋此方法的子類別將需要顯式新增該支援。"

#: ../../reference/expressions.rst:881
#, fuzzy
msgid ""
"A :class:`string <str>` is a special kind of sequence whose items are "
"*characters*. A character is not a separate data type but a string of "
"exactly one character."
msgstr ":class:`string <str>` 是一種特殊的序列，其項目是*字元*。字元不是單獨的資料型"
"別，而是恰好有一個字元的字串。"

#: ../../reference/expressions.rst:889
#, fuzzy
msgid "Slicings"
msgstr "切片"

#: ../../reference/expressions.rst:903
#, fuzzy
msgid ""
"A slicing selects a range of items in a sequence object (e.g., a string, "
"tuple or list).  Slicings may be used as expressions or as targets in "
"assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr "切片選擇序列對像中的一系列項目（例如，字串、元組或列表）。"
"切片可以用作表達式或賦值或 :keyword:`del` 語句中的目標。切片的語法："

#: ../../reference/expressions.rst:916
#, fuzzy
msgid ""
"There is ambiguity in the formal syntax here: anything that looks like an "
"expression list also looks like a slice list, so any subscription can be "
"interpreted as a slicing.  Rather than further complicating the syntax, this "
"is disambiguated by defining that in this case the interpretation as a "
"subscription takes priority over the interpretation as a slicing (this is "
"the case if the slice list contains no proper slice)."
msgstr ""
"這裡的正式語法存在歧義：任何看起來像表達式列表的東西也看起來像切片列表，因此"
"任何訂閱都可以解釋為切片。這不是進一步複雜化語法，而是通過定義在這種情況下作"
"為訂閱的解釋優先於作為切片的解釋（如果切片列表不包含適當的切片就是這種情況）"
"來消除歧義。"

#: ../../reference/expressions.rst:928
#, fuzzy
msgid ""
"The semantics for a slicing are as follows.  The primary is indexed (using "
"the same :meth:`__getitem__` method as normal subscription) with a key that "
"is constructed from the slice list, as follows.  If the slice list contains "
"at least one comma, the key is a tuple containing the conversion of the "
"slice items; otherwise, the conversion of the lone slice item is the key.  "
"The conversion of a slice item that is an expression is that expression.  "
"The conversion of a proper slice is a slice object (see section :ref:"
"`types`) whose :attr:`~slice.start`, :attr:`~slice.stop` and :attr:`~slice."
"step` attributes are the values of the expressions given as lower bound, "
"upper bound and stride, respectively, substituting ``None`` for missing "
"expressions."
msgstr ""
"切片的語義如下。主要索引（使用與普通訂閱相同的 :meth:`__getitem__` 方法）使用"
"從切片列表構造的鍵，如下所示。如果切片列表至少包含一個逗號，則鍵是一個包含切"
"片項轉換的元組；否則，lone slice item 的轉換是關鍵。作為表達式的切片項的轉換"
"就是該表達式。正確切片的轉換是一個切片物件（參見 :ref:`types` 部分），它的 "
":attr:`~slice.start`、:attr:`~slice.stop` 和 :attr:`~slice."
"step`屬性是分別作為下限、上限和步幅給出的表達式的值，用 ``None`` 代替缺失的表達式。"

#: ../../reference/expressions.rst:952
#, fuzzy
msgid "Calls"
msgstr "來電"

#: ../../reference/expressions.rst:954
#, fuzzy
msgid ""
"A call calls a callable object (e.g., a :term:`function`) with a possibly "
"empty series of :term:`arguments <argument>`:"
msgstr ""
"呼叫呼叫一個可呼叫物件（例如 :term:`function`），其中包含一系列可能為空的 "
":term:`arguments <argument>`："

#: ../../reference/expressions.rst:971
#, fuzzy
msgid ""
"An optional trailing comma may be present after the positional and keyword "
"arguments but does not affect the semantics."
msgstr "可選的尾隨逗號可能出現在位置和關鍵字參數之後，但不影響語義。"

#: ../../reference/expressions.rst:977
#, fuzzy
msgid ""
"The primary must evaluate to a callable object (user-defined functions, "
"built-in functions, methods of built-in objects, class objects, methods of "
"class instances, and all objects having a :meth:`__call__` method are "
"callable).  All argument expressions are evaluated before the call is "
"attempted.  Please refer to section :ref:`function` for the syntax of "
"formal :term:`parameter` lists."
msgstr ""
"primary "
"必須評估為可呼叫物件（使用者定義的函式、內建函式、內建物件的方法、類物件、"
"類實例的方法以及所有具有 :meth:`__call__` "
"方法的對像都是可呼叫的）。在嘗試呼叫之前評估所有參數表達式。請參閱 "
":ref:`function` 部分了解正式 :term:`parameter` 列表的語法。"

#: ../../reference/expressions.rst:985
#, fuzzy
msgid ""
"If keyword arguments are present, they are first converted to positional "
"arguments, as follows.  First, a list of unfilled slots is created for the "
"formal parameters.  If there are N positional arguments, they are placed in "
"the first N slots.  Next, for each keyword argument, the identifier is used "
"to determine the corresponding slot (if the identifier is the same as the "
"first formal parameter name, the first slot is used, and so on).  If the "
"slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, "
"the argument is placed in the slot, filling it (even if the expression is "
"``None``, it fills the slot).  When all arguments have been processed, the "
"slots that are still unfilled are filled with the corresponding default "
"value from the function definition.  (Default values are calculated, once, "
"when the function is defined; thus, a mutable object such as a list or "
"dictionary used as default value will be shared by all calls that don't "
"specify an argument value for the corresponding slot; this should usually be "
"avoided.)  If there are any unfilled slots for which no default value is "
"specified, a :exc:`TypeError` exception is raised.  Otherwise, the list of "
"filled slots is used as the argument list for the call."
msgstr ""
"如果存在關鍵字參數，它們將首先轉換為位置參數，如下所示。首先，為形式參數建立"
"一個未填充槽的列表。如果有 N 個位置參數，則將它們放在前 N 個槽中。接下來，對"
"於每個關鍵字參數，標識符用於確定相應的插槽（如果標識符與第一個形式參數名稱相"
"同，則使用第一個插槽，依此類推）。如果插槽已滿，則會引發 :exc:`TypeError` 例"
"外。否則，參數被放置在插槽中，填充它（即使表達式是 ``None``，它也會填充插槽）。"
"處理完所有參數後，仍未填充的槽將用函式定義中的相應預設值填充。 （預設值在定義"
"函式時計算一次；因此，用作預設值的可變物件（例如列表或字典）將由所有未為相應"
"槽指定參數值的呼叫共享；這應該通常避免。）如果有任何未指定預設值的未填充插槽"
"，則會引發 :exc:`TypeError` 例外。否則，填充槽的列表將用作呼叫的參數列表。"

#: ../../reference/expressions.rst:1005
#, fuzzy
msgid ""
"An implementation may provide built-in functions whose positional parameters "
"do not have names, even if they are 'named' for the purpose of "
"documentation, and which therefore cannot be supplied by keyword.  In "
"CPython, this is the case for functions implemented in C that use :c:func:"
"`PyArg_ParseTuple` to parse their arguments."
msgstr ""
"一個實作可以提供其位置參數沒有名稱的內建函式，即使它們是為了文檔的目的而“命名"
"”的，因此不能通過關鍵字提供。在 CPython 中，這是用 C "
"實作的函式的情況，它們使用:c:func:`PyArg_ParseTuple` 來解析它們的參數。"

#: ../../reference/expressions.rst:1011
#, fuzzy
msgid ""
"If there are more positional arguments than there are formal parameter "
"slots, a :exc:`TypeError` exception is raised, unless a formal parameter "
"using the syntax ``*identifier`` is present; in this case, that formal "
"parameter receives a tuple containing the excess positional arguments (or an "
"empty tuple if there were no excess positional arguments)."
msgstr ""
"如果位置參數多於形式參數槽，則會引發 :exc:`TypeError` 例外，除非存在使用語法 "
"``*identifier`` 的形式參數；在這種情況下，該形式參數接收一個包含多餘位置參數"
"的元組（如果沒有多餘位置參數，則接收一個空元組）。"

#: ../../reference/expressions.rst:1017
#, fuzzy
msgid ""
"If any keyword argument does not correspond to a formal parameter name, a :"
"exc:`TypeError` exception is raised, unless a formal parameter using the "
"syntax ``**identifier`` is present; in this case, that formal parameter "
"receives a dictionary containing the excess keyword arguments (using the "
"keywords as keys and the argument values as corresponding values), or a "
"(new) empty dictionary if there were no excess keyword arguments."
msgstr ""
"如果任何關鍵字參數不對應於形式參數名稱，則會引發 :exc:`TypeError` 例外，"
"除非存在使用語法 ``**identifier`` 的形式參數；在這種情況下，該形式參數接收一"
"個包含多餘關鍵字參數的字典（使用關鍵字作為鍵，使用參數值作為相應的值），或者"
"如果沒有多餘的關鍵字參數，則接收一個（新的）空字典。"

#: ../../reference/expressions.rst:1028
#, fuzzy
msgid ""
"If the syntax ``*expression`` appears in the function call, ``expression`` "
"must evaluate to an :term:`iterable`.  Elements from these iterables are "
"treated as if they were additional positional arguments.  For the call "
"``f(x1, x2, *y, x3, x4)``, if *y* evaluates to a sequence *y1*, ..., *yM*, "
"this is equivalent to a call with M+4 positional arguments *x1*, *x2*, "
"*y1*, ..., *yM*, *x3*, *x4*."
msgstr ""
"如果函式呼叫中出現語法“*expression”，則 ``expression``的計算結果必須是一個可疊代"
"的。這些可疊代對像中的元素被視為附加的位置參數。對於呼叫 ``f(x1, x2, *y, x3, "
"x4)``，如果 *y* 的計算結果為序列 *y1*, ..., *yM*，這等同於使用 M+ 的呼叫4 "
"個位置參數 *x1*、*x2*、*y1*、...、*yM*、*x3*、*x4*。"

#: ../../reference/expressions.rst:1035
#, fuzzy
msgid ""
"A consequence of this is that although the ``*expression`` syntax may appear "
"*after* explicit keyword arguments, it is processed *before* the keyword "
"arguments (and any ``**expression`` arguments -- see below).  So::"
msgstr ""
"這樣做的結果是，雖然“*表達式”語法可能出現在*顯式關鍵字參數之後，但它在*關鍵字"
"參數（以及任何“**表達式”參數——見下文）之前被處理。所以：："

#: ../../reference/expressions.rst:1051
#, fuzzy
msgid ""
"It is unusual for both keyword arguments and the ``*expression`` syntax to "
"be used in the same call, so in practice this confusion does not often arise."
msgstr "在同一個呼叫中同時使用關鍵字參數和 ``*expression`` "
"語法是不常見的，因此在實踐中這種混淆並不經常出現。"

#: ../../reference/expressions.rst:1057
#, fuzzy
msgid ""
"If the syntax ``**expression`` appears in the function call, ``expression`` "
"must evaluate to a :term:`mapping`, the contents of which are treated as "
"additional keyword arguments. If a parameter matching a key has already been "
"given a value (by an explicit keyword argument, or from another unpacking), "
"a :exc:`TypeError` exception is raised."
msgstr ""
"如果函式呼叫中出現語法 `**expression``，則 ``expression`` 的計算結果必須為 :t"
"erm:`mapping`，其內容被視為附加關鍵字參數。如果匹配鍵的參數已經被賦予了值（通"
"過顯式關鍵字參數，或來自另一個解包），則會引發 :exc:`TypeError` 例外。"

#: ../../reference/expressions.rst:1063
#, fuzzy
msgid ""
"When ``**expression`` is used, each key in this mapping must be a string. "
"Each value from the mapping is assigned to the first formal parameter "
"eligible for keyword assignment whose name is equal to the key. A key need "
"not be a Python identifier (e.g. ``\"max-temp °F\"`` is acceptable, although "
"it will not match any formal parameter that could be declared). If there is "
"no match to a formal parameter the key-value pair is collected by the ``**`` "
"parameter, if there is one, or if there is not, a :exc:`TypeError` exception "
"is raised."
msgstr ""
"當使用``**expression`` 時，此映射中的每個鍵都必須是一個字串。映射中的每個值都"
"分配給第一個符合關鍵字分配條件的形式參數，其名稱等於鍵。鍵不必是 Python "
"標識符（例如，``\"max-temp °F\"`` "
"是可以接受的，儘管它不會匹配任何可以聲明的形式參數）。如果與形式參數不匹配，"
"則鍵值對由 ``**`` 參數收集，如果有，或者如果沒有，則會引發 :exc:`TypeError` "
"例外。"

#: ../../reference/expressions.rst:1073
#, fuzzy
msgid ""
"Formal parameters using the syntax ``*identifier`` or ``**identifier`` "
"cannot be used as positional argument slots or as keyword argument names."
msgstr "使用語法“*identifier”或“**identifier”的形式參數不能用作位置參數槽或關鍵字參數"
"名稱。"

#: ../../reference/expressions.rst:1076
#, fuzzy
msgid ""
"Function calls accept any number of ``*`` and ``**`` unpackings, positional "
"arguments may follow iterable unpackings (``*``), and keyword arguments may "
"follow dictionary unpackings (``**``). Originally proposed by :pep:`448`."
msgstr ""
"函式呼叫接受任意數量的``*`` 和``**`` 解包，位置參數可以跟隨可疊代的解包（``*`"
"`），關鍵字參數可以跟隨字典解包（``**``）。最初由 :pep:`448` 提出。"

#: ../../reference/expressions.rst:1082
#, fuzzy
msgid ""
"A call always returns some value, possibly ``None``, unless it raises an "
"exception.  How this value is computed depends on the type of the callable "
"object."
msgstr "呼叫總是回傳一些值，可能是 ``None`` ，除非它引發例外。如何計算此值取決於可呼叫物件"
"的型別。"

#: ../../reference/expressions.rst:1086
#, fuzzy
msgid "If it is---"
msgstr "如果是 - -"

#: ../../reference/expressions.rst:1099
#, fuzzy
msgid "a user-defined function:"
msgstr "使用者定義的函式："

#: ../../reference/expressions.rst:1095
#, fuzzy
msgid ""
"The code block for the function is executed, passing it the argument list.  "
"The first thing the code block will do is bind the formal parameters to the "
"arguments; this is described in section :ref:`function`.  When the code "
"block executes a :keyword:`return` statement, this specifies the return "
"value of the function call."
msgstr ""
"執行函式的程式碼塊，將參數列表傳遞給它。程式碼塊要做的第一件事是將形式參數綁"
"定到實參；這在 :ref:`function` 部分中有描述。當程式碼塊執行 :keyword:`return`"
" 語句時，這指定了函式呼叫的回傳值。"

#: ../../reference/expressions.rst:1113
#, fuzzy
msgid "a built-in function or method:"
msgstr "內建函式或方法："

#: ../../reference/expressions.rst:1112
#, fuzzy
msgid ""
"The result is up to the interpreter; see :ref:`built-in-funcs` for the "
"descriptions of built-in functions and methods."
msgstr "結果取決於口譯員；有關內建函式和方法的說明，請參閱 :red:`built-in-function`。"

#: ../../reference/expressions.rst:1120
#, fuzzy
msgid "a class object:"
msgstr "類物件："

#: ../../reference/expressions.rst:1120
#, fuzzy
msgid "A new instance of that class is returned."
msgstr "回傳該類的一個新實例。"

#: ../../reference/expressions.rst:1130
#, fuzzy
msgid "a class instance method:"
msgstr "類實例方法："

#: ../../reference/expressions.rst:1128
#, fuzzy
msgid ""
"The corresponding user-defined function is called, with an argument list "
"that is one longer than the argument list of the call: the instance becomes "
"the first argument."
msgstr "相應的使用者定義函式被呼叫，參數列表比呼叫的參數列表長一個：實例成為第一個參"
"數。"

#: ../../reference/expressions.rst:1139
#, fuzzy
msgid "a class instance:"
msgstr "一個類實例："

#: ../../reference/expressions.rst:1137
#, fuzzy
msgid ""
"The class must define a :meth:`__call__` method; the effect is then the same "
"as if that method was called."
msgstr "該類必須定義一個 :meth:`__call__` 方法；效果與呼叫該方法一樣。"

#: ../../reference/expressions.rst:1145 ../../reference/expressions.rst:1926
#, fuzzy
msgid "Await expression"
msgstr "等待表達"

#: ../../reference/expressions.rst:1147
#, fuzzy
msgid ""
"Suspend the execution of :term:`coroutine` on an :term:`awaitable` object. "
"Can only be used inside a :term:`coroutine function`."
msgstr ""
"暫停 :term:`coroutine` 在 :term:`awaitable` 對像上的執行。只能在 :term:`"
"coroutine function` 中使用。"

#: ../../reference/expressions.rst:1159
#, fuzzy
msgid "The power operator"
msgstr "電力運營商"

#: ../../reference/expressions.rst:1165
#, fuzzy
msgid ""
"The power operator binds more tightly than unary operators on its left; it "
"binds less tightly than unary operators on its right.  The syntax is:"
msgstr "冪運算符比其左側的一元運算符綁定得更緊密；它的綁定不如右側的一元運算符緊密。"
"語法是："

#: ../../reference/expressions.rst:1171
#, fuzzy
msgid ""
"Thus, in an unparenthesized sequence of power and unary operators, the "
"operators are evaluated from right to left (this does not constrain the "
"evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr "因此，在未加括號的冪和一元運算符序列中，運算符從右到左求值（這不限制操作數的"
"求值順序）：``-1**2`` 結果為 ``-1`` ."

#: ../../reference/expressions.rst:1175
#, fuzzy
msgid ""
"The power operator has the same semantics as the built-in :func:`pow` "
"function, when called with two arguments: it yields its left argument raised "
"to the power of its right argument.  The numeric arguments are first "
"converted to a common type, and the result is of that type."
msgstr ""
"當使用兩個參數呼叫時，冪運算符與內建 :func:`pow` 函式具有相同的語義：它產生其"
"左參數的右參數的冪。數字參數首先轉換為通用型別，結果為該型別。"

#: ../../reference/expressions.rst:1180
#, fuzzy
msgid ""
"For int operands, the result has the same type as the operands unless the "
"second argument is negative; in that case, all arguments are converted to "
"float and a float result is delivered. For example, ``10**2`` returns "
"``100``, but ``10**-2`` returns ``0.01``."
msgstr ""
"對於 int 操作數，結果與操作數具有相同的型別，除非第二個參數為負數；在這種情況"
"下，所有參數都轉換為浮點數，並傳遞一個浮點數結果。例如，``10**2`` "
"回傳``100``，而``10**-2`` 回傳``0.01``。"

#: ../../reference/expressions.rst:1185
#, fuzzy
msgid ""
"Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. "
"Raising a negative number to a fractional power results in a :class:"
"`complex` number. (In earlier versions it raised a :exc:`ValueError`.)"
msgstr ""
"將 ``0.0`` 提高到負冪會導致 :exc:`ZeroDivisionError`。"
"將負數提高到分數次冪會產生一個 :class:`complex` 數。 （在早期版本中，"
"它引發了 :exc:`ValueError`。）"

#: ../../reference/expressions.rst:1189
#, fuzzy
msgid ""
"This operation can be customized using the special :meth:`__pow__` method."
msgstr "可以使用特殊的 :meth:`__pow__` 方法自定義此操作。"

#: ../../reference/expressions.rst:1194
#, fuzzy
msgid "Unary arithmetic and bitwise operations"
msgstr "一元算術和按位運算"

#: ../../reference/expressions.rst:1200
#, fuzzy
msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr "所有一元算術和按位運算都具有相同的優先級："

#: ../../reference/expressions.rst:1211
#, fuzzy
msgid ""
"The unary ``-`` (minus) operator yields the negation of its numeric "
"argument; the operation can be overridden with the :meth:`__neg__` special "
"method."
msgstr "一元 ``-``（減號）運算符產生其數字參數的否定；該操作可以用 :meth:`__neg__` "
"特殊方法覆蓋。"

#: ../../reference/expressions.rst:1219
#, fuzzy
msgid ""
"The unary ``+`` (plus) operator yields its numeric argument unchanged; the "
"operation can be overridden with the :meth:`__pos__` special method."
msgstr "一元 ``+``（加號）運算符產生其數字參數不變；該操作可以用 :meth:`__pos__` "
"特殊方法覆蓋。"

#: ../../reference/expressions.rst:1226
#, fuzzy
msgid ""
"The unary ``~`` (invert) operator yields the bitwise inversion of its "
"integer argument.  The bitwise inversion of ``x`` is defined as ``-(x+1)``.  "
"It only applies to integral numbers or to custom objects that override the :"
"meth:`__invert__` special method."
msgstr ""
"一元 ``~``（反轉）運算符產生其整數參數的按位反轉。 ``x`` 的按位反轉定義為 "
"``-(x+1)``。它僅適用於整數或覆蓋 :meth:`__invert__` 特殊方法的自定義物件。"

#: ../../reference/expressions.rst:1235
#, fuzzy
msgid ""
"In all three cases, if the argument does not have the proper type, a :exc:"
"`TypeError` exception is raised."
msgstr "在這三種情況下，如果參數沒有正確的型別，則會引發 :exc:`TypeError` 例外。"

#: ../../reference/expressions.rst:1242
#, fuzzy
msgid "Binary arithmetic operations"
msgstr "二進位算術運算"

#: ../../reference/expressions.rst:1246
#, fuzzy
msgid ""
"The binary arithmetic operations have the conventional priority levels.  "
"Note that some of these operations also apply to certain non-numeric types.  "
"Apart from the power operator, there are only two levels, one for "
"multiplicative operators and one for additive operators:"
msgstr "二進位算術運算具有常規的優先級。請注意，其中一些操作也適用於某些非數字型別。"
"除了冪運算符，只有兩層，一層是乘法運算符，一層是加法運算符："

#: ../../reference/expressions.rst:1261
#, fuzzy
msgid ""
"The ``*`` (multiplication) operator yields the product of its arguments.  "
"The arguments must either both be numbers, or one argument must be an "
"integer and the other must be a sequence. In the former case, the numbers "
"are converted to a common type and then multiplied together.  In the latter "
"case, sequence repetition is performed; a negative repetition factor yields "
"an empty sequence."
msgstr ""
"``*``（乘法）運算符產生其參數的乘積。參數必須都是數字，或者一個參數必須是整數"
"而另一個必須是序列。在前一種情況下，數字被轉換為通用型別，然後相乘。在後一種"
"情況下，執行序列重複；負重複因子產生空序列。"

#: ../../reference/expressions.rst:1267
#, fuzzy
msgid ""
"This operation can be customized using the special :meth:`__mul__` and :meth:"
"`__rmul__` methods."
msgstr "可以使用特殊的 :meth:`__mul__` 和 :meth:`__rmul__` 方法自定義此操作。"

#: ../../reference/expressions.rst:1274
#, fuzzy
msgid ""
"The ``@`` (at) operator is intended to be used for matrix multiplication.  "
"No builtin Python types implement this operator."
msgstr "``@`` (at) 運算符旨在用於矩陣乘法。沒有內建 Python 型別實作此運算符。"

#: ../../reference/expressions.rst:1285
#, fuzzy
msgid ""
"The ``/`` (division) and ``//`` (floor division) operators yield the "
"quotient of their arguments.  The numeric arguments are first converted to a "
"common type. Division of integers yields a float, while floor division of "
"integers results in an integer; the result is that of mathematical division "
"with the 'floor' function applied to the result.  Division by zero raises "
"the :exc:`ZeroDivisionError` exception."
msgstr ""
"``/``（除法）和`//``（底除法）運算符產生它們參數的商。數字參數首先轉換為通用"
"型別。整數除法產生一個浮點數，而整數除法產生一個整數；結果是對結果應用 ``floor``"
"函式的數學除法。除以零會引發 :exc:`ZeroDivisionError` 例外。"

#: ../../reference/expressions.rst:1292
#, fuzzy
msgid ""
"This operation can be customized using the special :meth:`__truediv__` and :"
"meth:`__floordiv__` methods."
msgstr "可以使用特殊的 :meth:`__truediv__` 和 :meth:`__floordiv__` 方法自定義此操作。"

#: ../../reference/expressions.rst:1299
#, fuzzy
msgid ""
"The ``%`` (modulo) operator yields the remainder from the division of the "
"first argument by the second.  The numeric arguments are first converted to "
"a common type.  A zero right argument raises the :exc:`ZeroDivisionError` "
"exception.  The arguments may be floating point numbers, e.g., ``3.14%0.7`` "
"equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo "
"operator always yields a result with the same sign as its second operand (or "
"zero); the absolute value of the result is strictly smaller than the "
"absolute value of the second operand [#]_."
msgstr ""
"``%``（取模）運算符產生第一個參數除以第二個參數的餘數。數字參數首先轉換為通用"
"型別。右參數為零會引發 :exc:`ZeroDivisionError` "
"例外。參數可以是浮點數，例如，``3.14%0.7`` 等於 ``0.34``（因為 ``3.14`` 等於 "
"``4*0.7 + 0.34``。）模運算符總是產生一個結果與其第二個操作數（或零）相同的符"
"號；結果的絕對值嚴格小於第二個操作數[#]_的絕對值。"

#: ../../reference/expressions.rst:1308
#, fuzzy
msgid ""
"The floor division and modulo operators are connected by the following "
"identity: ``x == (x//y)*y + (x%y)``.  Floor division and modulo are also "
"connected with the built-in function :func:`divmod`: ``divmod(x, y) == (x//"
"y, x%y)``. [#]_."
msgstr ""
"floor 除法運算符和模運算符通過以下標識連接：``x == (x//y)*y + (x%y)``。"
"底除法和取模也與內建函式 :func:`divmod`: ``divmod(x, y) == (x//y, x%y)`` "
"有關。 [#]_。"

#: ../../reference/expressions.rst:1313
#, fuzzy
msgid ""
"In addition to performing the modulo operation on numbers, the ``%`` "
"operator is also overloaded by string objects to perform old-style string "
"formatting (also known as interpolation).  The syntax for string formatting "
"is described in the Python Library Reference, section :ref:`old-string-"
"formatting`."
msgstr ""
"除了對數字執行模運算外，``%`` "
"運算符還被字串物件重載以執行舊式字串格式化（也稱為插值）。字串格式化的語法在 "
"Python 庫參考中的 :ref:`old-string-formatting` 部分進行了描述。"

#: ../../reference/expressions.rst:1318
#, fuzzy
msgid ""
"The *modulo* operation can be customized using the special :meth:`__mod__` "
"method."
msgstr "可以使用特殊的 :meth:`__mod__` 方法自定義 *modulo* 操作。"

#: ../../reference/expressions.rst:1320
#, fuzzy
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are not defined for complex numbers.  Instead, convert to a "
"floating point number using the :func:`abs` function if appropriate."
msgstr "底除法運算符、模運算符和 divmod 函式沒有為複數定義。相反，如果合適，使用 abs "
"函式轉換為浮點數。"

#: ../../reference/expressions.rst:1329
#, fuzzy
msgid ""
"The ``+`` (addition) operator yields the sum of its arguments.  The "
"arguments must either both be numbers or both be sequences of the same "
"type.  In the former case, the numbers are converted to a common type and "
"then added together. In the latter case, the sequences are concatenated."
msgstr ""
"``+``（加法）運算符產生其參數的總和。參數必須都是數字或都是同一型別的序列。在"
"前一種情況下，數字被轉換為通用型別，然後相加。在後一種情況下，序列被連接起來"
"。"

#: ../../reference/expressions.rst:1334
#, fuzzy
msgid ""
"This operation can be customized using the special :meth:`__add__` and :meth:"
"`__radd__` methods."
msgstr "可以使用特殊的 :meth:`__add__` 和 :meth:`__radd__` 方法自定義此操作。"

#: ../../reference/expressions.rst:1342
#, fuzzy
msgid ""
"The ``-`` (subtraction) operator yields the difference of its arguments.  "
"The numeric arguments are first converted to a common type."
msgstr "``-``（減法）運算符產生其參數的差異。數字參數首先轉換為通用型別。"

#: ../../reference/expressions.rst:1345
#, fuzzy
msgid ""
"This operation can be customized using the special :meth:`__sub__` method."
msgstr "可以使用特殊的 :meth:`__sub__` 方法自定義此操作。"

#: ../../reference/expressions.rst:1351
#, fuzzy
msgid "Shifting operations"
msgstr "轉移作業"

#: ../../reference/expressions.rst:1358
#, fuzzy
msgid ""
"The shifting operations have lower priority than the arithmetic operations:"
msgstr "移位操作的優先級低於算術操作："

#: ../../reference/expressions.rst:1363
#, fuzzy
msgid ""
"These operators accept integers as arguments.  They shift the first argument "
"to the left or right by the number of bits given by the second argument."
msgstr "這些運算符接受整數作為參數。它們將第一個參數向左或向右移動第二個參數給定的位"
"數。"

#: ../../reference/expressions.rst:1366
#, fuzzy
msgid ""
"This operation can be customized using the special :meth:`__lshift__` and :"
"meth:`__rshift__` methods."
msgstr "可以使用特殊的 :meth:`__lshift__` 和 :meth:`__rshift__` 方法自定義此操作。"

#: ../../reference/expressions.rst:1371
#, fuzzy
msgid ""
"A right shift by *n* bits is defined as floor division by ``pow(2,n)``.  A "
"left shift by *n* bits is defined as multiplication with ``pow(2,n)``."
msgstr "右移 *n* 位定義為除以“pow(2,n)”。左移 *n* 位定義為與“pow(2,n)”相乘。"

#: ../../reference/expressions.rst:1378
#, fuzzy
msgid "Binary bitwise operations"
msgstr "二進位位運算"

#: ../../reference/expressions.rst:1382
#, fuzzy
msgid "Each of the three bitwise operations has a different priority level:"
msgstr "三個按位運算中的每一個都有不同的優先級："

#: ../../reference/expressions.rst:1393
#, fuzzy
msgid ""
"The ``&`` operator yields the bitwise AND of its arguments, which must be "
"integers or one of them must be a custom object overriding :meth:`__and__` "
"or :meth:`__rand__` special methods."
msgstr ""
"``&`` 運算符產生其參數的按位與，這些參數必須是整數，或者其中之一必須是覆蓋 "
":meth:`__and__` 或 :meth:`__rand__` 特殊方法的自定義物件。"

#: ../../reference/expressions.rst:1402
#, fuzzy
msgid ""
"The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, "
"which must be integers or one of them must be a custom object overriding :"
"meth:`__xor__` or :meth:`__rxor__` special methods."
msgstr ""
"``^`` 運算符產生其參數的按位異或（異或），這些參數必須是整數，"
"或者其中之一必須是覆蓋 :meth:`__xor__` 或 :meth:`__rxor__` "
"特殊方法的自定義物件。"

#: ../../reference/expressions.rst:1411
#, fuzzy
msgid ""
"The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which "
"must be integers or one of them must be a custom object overriding :meth:"
"`__or__` or :meth:`__ror__` special methods."
msgstr ""
"``|`` 運算符產生其參數的按位（包含）或，"
"這些參數必須是整數或其中之一必須是覆蓋 :meth:`__or__` 或 :meth:`__ror__` "
"特殊方法的自定義物件。"

#: ../../reference/expressions.rst:1419
#, fuzzy
msgid "Comparisons"
msgstr "比較"

#: ../../reference/expressions.rst:1431
#, fuzzy
msgid ""
"Unlike C, all comparison operations in Python have the same priority, which "
"is lower than that of any arithmetic, shifting or bitwise operation.  Also "
"unlike C, expressions like ``a < b < c`` have the interpretation that is "
"conventional in mathematics:"
msgstr ""
"與 C 不同，Python "
"中的所有比較操作都具有相同的優先級，低於任何算術、移位或按位運算的優先級。"
"同樣與 C 不同的是，像 ``a < b < c`` 這樣的表達式具有數學中的常規解釋："

#: ../../reference/expressions.rst:1441
#, fuzzy
msgid ""
"Comparisons yield boolean values: ``True`` or ``False``. Custom :dfn:`rich "
"comparison methods` may return non-boolean values. In this case Python will "
"call :func:`bool` on such value in boolean contexts."
msgstr ""
"比較產生布爾值：``True`` 或``False``。自定義 :dfn:`rich comparison methods` "
"可能會回傳非布爾值。在這種情況下，Python 將在布爾上下文中對此類值呼叫 "
":func:`bool`。"

#: ../../reference/expressions.rst:1447
#, fuzzy
msgid ""
"Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is equivalent "
"to ``x < y and y <= z``, except that ``y`` is evaluated only once (but in "
"both cases ``z`` is not evaluated at all when ``x < y`` is found to be "
"false)."
msgstr ""
"比較可以任意鏈接，例如，``x < y <= z`` 等同於 ``x < y and y <= z``，除了 "
"``y`` 只計算一次（但在兩種情況下當發現 ``x < y`` 為假時，``z`` "
"根本不被評估）。"

#: ../../reference/expressions.rst:1451
#, fuzzy
msgid ""
"Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, "
"*op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN "
"z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``, except that "
"each expression is evaluated at most once."
msgstr ""
"形式上，如果 *a*、*b*、*c*、...、*y*、*z* 是表達式並且 "
"*op1*、*op2*、...、*opN* 是比較運算符，則 ` `a op1 b op2 c ... y opN z`` "
"等同於 ``a op1 b and b op2 c and ... y opN z``，除了每個表達式最多計算一次。"

#: ../../reference/expressions.rst:1456
#, fuzzy
msgid ""
"Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a* "
"and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though perhaps not "
"pretty)."
msgstr ""
"請注意，``a op1 b op2 c`` 並不意味著 *a* 和 *c* "
"之間有任何型別的比較，因此，例如，``x < y > z`` "
"是完全合法的（儘管可能不漂亮)."

#: ../../reference/expressions.rst:1463
#, fuzzy
msgid "Value comparisons"
msgstr "價值比較"

#: ../../reference/expressions.rst:1465
#, fuzzy
msgid ""
"The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare the "
"values of two objects.  The objects do not need to have the same type."
msgstr "運算符``<``、``>``、``==``、``>=``、``<=`` 和``!=`` "
"比較兩個物件的值。這些對像不需要具有相同的型別。"

#: ../../reference/expressions.rst:1468
#, fuzzy
msgid ""
"Chapter :ref:`objects` states that objects have a value (in addition to type "
"and identity).  The value of an object is a rather abstract notion in "
"Python: For example, there is no canonical access method for an object's "
"value.  Also, there is no requirement that the value of an object should be "
"constructed in a particular way, e.g. comprised of all its data attributes. "
"Comparison operators implement a particular notion of what the value of an "
"object is.  One can think of them as defining the value of an object "
"indirectly, by means of their comparison implementation."
msgstr ""
"Chapter :ref:`objects` 指出對像有一個值（除了型別和身份）。物件的值在 Python "
"中是一個相當抽象的概念：例如，物件的值沒有規範的訪問方法。此外，不要求物件的"
"值應該以特定方式構造，例如由其所有資料屬性組成。比較運算符實作物件值的特定概"
"念。可以將它們視為通過比較實作間接定義物件的值。"

#: ../../reference/expressions.rst:1477
#, fuzzy
msgid ""
"Because all types are (direct or indirect) subtypes of :class:`object`, they "
"inherit the default comparison behavior from :class:`object`.  Types can "
"customize their comparison behavior by implementing :dfn:`rich comparison "
"methods` like :meth:`__lt__`, described in :ref:`customization`."
msgstr ""
"因為所有型別都是 object 的（直接或間接）子型別，所以它們繼承了 object "
"的預設比較行為。型別可以通過實作 :dfn:`rich comparison methods` "
"來定制它們的比較行為，比如 :meth:`__lt__`，在 :ref:`customization` 中有描述。"

#: ../../reference/expressions.rst:1483
#, fuzzy
msgid ""
"The default behavior for equality comparison (``==`` and ``!=``) is based on "
"the identity of the objects.  Hence, equality comparison of instances with "
"the same identity results in equality, and equality comparison of instances "
"with different identities results in inequality.  A motivation for this "
"default behavior is the desire that all objects should be reflexive (i.e. "
"``x is y`` implies ``x == y``)."
msgstr ""
"相等比較（``==`` 和 ``!=``）的預設行為是基於物件的身份。因此，具有相同身份的"
"實例的相等比較結果是相等的，而具有不同身份的實例的相等比較結果是不平等的。這"
"種預設行為的動機是希望所有對像都應該是自反的（即“x is y”意味著“x == y”）。"

#: ../../reference/expressions.rst:1490
#, fuzzy
msgid ""
"A default order comparison (``<``, ``>``, ``<=``, and ``>=``) is not "
"provided; an attempt raises :exc:`TypeError`.  A motivation for this default "
"behavior is the lack of a similar invariant as for equality."
msgstr ""
"未提供預設順序比較（``<``、``>``、``<=`` 和 ``>=``）；嘗試引發 "
":exc:`TypeError`。這種預設行為的動機是缺乏與平等類似的不變數。"

#: ../../reference/expressions.rst:1494
#, fuzzy
msgid ""
"The behavior of the default equality comparison, that instances with "
"different identities are always unequal, may be in contrast to what types "
"will need that have a sensible definition of object value and value-based "
"equality.  Such types will need to customize their comparison behavior, and "
"in fact, a number of built-in types have done that."
msgstr ""
"預設相等比較的行為，即具有不同身份的實例總是不相等的，可能與需要具有物件值和"
"基於值相等的合理定義的型別形成對比。這些型別需要定制它們的比較行為，事實上，"
"許多內建型別已經做到了這一點。"

#: ../../reference/expressions.rst:1500
#, fuzzy
msgid ""
"The following list describes the comparison behavior of the most important "
"built-in types."
msgstr "以下列表描述了最重要的內建型別的比較行為。"

#: ../../reference/expressions.rst:1503
#, fuzzy
msgid ""
"Numbers of built-in numeric types (:ref:`typesnumeric`) and of the standard "
"library types :class:`fractions.Fraction` and :class:`decimal.Decimal` can "
"be compared within and across their types, with the restriction that complex "
"numbers do not support order comparison.  Within the limits of the types "
"involved, they compare mathematically (algorithmically) correct without loss "
"of precision."
msgstr ""
"內建數字型別 (:ref:`typesnumeric`) 和標準庫型別 :class:`fractions.Fraction` "
"和 :class:`decimal.Decimal` 的數字可以在它們的型別內部和之間進行比較，但有限"
"制複數不支援順序比較。在所涉及型別的限制內，它們在數學上（演算法上）比較正確"
"而不會損失精度。"

#: ../../reference/expressions.rst:1510
#, fuzzy
msgid ""
"The not-a-number values ``float('NaN')`` and ``decimal.Decimal('NaN')`` are "
"special.  Any ordered comparison of a number to a not-a-number value is "
"false. A counter-intuitive implication is that not-a-number values are not "
"equal to themselves.  For example, if ``x = float('NaN')``, ``3 < x``, ``x < "
"3`` and ``x == x`` are all false, while ``x != x`` is true.  This behavior "
"is compliant with IEEE 754."
msgstr ""
"非數字值``float('NaN')`` 和``decimal.Decimal('NaN')`` 是特殊的。數字與非數字"
"值的任何有序比較都是錯誤的。一個違反直覺的暗示是非數字值不等於它們自己。例如"
"，如果 ``x = float('NaN')``、``3 < x``、``x < 3`` 和 ``x == x`` 都是假的，而 "
"``x ! = x`` 為真。此行為符合 IEEE 754。"

#: ../../reference/expressions.rst:1517
#, fuzzy
msgid ""
"``None`` and ``NotImplemented`` are singletons.  :PEP:`8` advises that "
"comparisons for singletons should always be done with ``is`` or ``is not``, "
"never the equality operators."
msgstr ""
"``None`` 和 ``NotImplemented`` 是單例。 :PEP:`8` 建議對單例的比較應該總是用 "
"``is`` 或 ``is not`` 來完成，永遠不要使用相等運算符。"

#: ../../reference/expressions.rst:1521
#, fuzzy
msgid ""
"Binary sequences (instances of :class:`bytes` or :class:`bytearray`) can be "
"compared within and across their types.  They compare lexicographically "
"using the numeric values of their elements."
msgstr "二進位序列（bytes 或 bytearray 的實例）可以在其型別內和跨型別進行比較。他們使"
"用元素的數值按字典順序進行比較。"

#: ../../reference/expressions.rst:1525
#, fuzzy
msgid ""
"Strings (instances of :class:`str`) compare lexicographically using the "
"numerical Unicode code points (the result of the built-in function :func:"
"`ord`) of their characters. [#]_"
msgstr "字串（str 的實例）使用其字元的數字 Unicode 程式碼點（內建函式 ord "
"的結果）按字典順序進行比較。 [#]_"

#: ../../reference/expressions.rst:1529
#, fuzzy
msgid "Strings and binary sequences cannot be directly compared."
msgstr "字串和二進位序列不能直接比較。"

#: ../../reference/expressions.rst:1531
#, fuzzy
msgid ""
"Sequences (instances of :class:`tuple`, :class:`list`, or :class:`range`) "
"can be compared only within each of their types, with the restriction that "
"ranges do not support order comparison.  Equality comparison across these "
"types results in inequality, and ordering comparison across these types "
"raises :exc:`TypeError`."
msgstr ""
"序列（tuple、list 或 range 的實例）只能在它們的每個型別中進行比較，但范圍不支"
"援順序比較的限制。這些型別之間的相等比較會導致不等式，"
"並且這些型別之間的排序比較會引發 :exc:`TypeError`。"

#: ../../reference/expressions.rst:1537
#, fuzzy
msgid ""
"Sequences compare lexicographically using comparison of corresponding "
"elements.  The built-in containers typically assume identical objects are "
"equal to themselves.  That lets them bypass equality tests for identical "
"objects to improve performance and to maintain their internal invariants."
msgstr ""
"序列使用相應元素的比較按字典順序進行比較。內建容器通常假設相同的物件與它們自"
"己相同。這使他們能夠繞過相同物件的相等性測試，以提高性能並保持其內部不變性。"

#: ../../reference/expressions.rst:1542
#, fuzzy
msgid ""
"Lexicographical comparison between built-in collections works as follows:"
msgstr "內建集合之間的詞典順序比較工作如下："

#: ../../reference/expressions.rst:1544
#, fuzzy
msgid ""
"For two collections to compare equal, they must be of the same type, have "
"the same length, and each pair of corresponding elements must compare equal "
"(for example, ``[1,2] == (1,2)`` is false because the type is not the same)."
msgstr ""
"兩個集合要比較相等，它們必須是同一型別，具有相同的長度，並且每對對應的元素必"
"須比較相等（例如，``[1,2] == (1,2)`` 是false 因為型別不一樣）。"

#: ../../reference/expressions.rst:1549
#, fuzzy
msgid ""
"Collections that support order comparison are ordered the same as their "
"first unequal elements (for example, ``[1,2,x] <= [1,2,y]`` has the same "
"value as ``x <= y``).  If a corresponding element does not exist, the "
"shorter collection is ordered first (for example, ``[1,2] < [1,2,3]`` is "
"true)."
msgstr ""
"支援順序比較的集合的順序與其第一個不相等的元素相同（例如，``[1,2,x] <= "
"[1,2,y]`` 與``x <= y` 具有相同的值`）。如果不存在相應的元素，則首先對較短的集"
"合進行排序（例如，``[1,2] < [1,2,3]`` 為真）。"

#: ../../reference/expressions.rst:1555
#, fuzzy
msgid ""
"Mappings (instances of :class:`dict`) compare equal if and only if they have "
"equal ``(key, value)`` pairs. Equality comparison of the keys and values "
"enforces reflexivity."
msgstr "映射（:class:`dict` 的實例）比較相等當且僅當它們具有相等的 ``(key, value)`` "
"對。鍵和值的相等比較強制自反性。"

#: ../../reference/expressions.rst:1559
#, fuzzy
msgid ""
"Order comparisons (``<``, ``>``, ``<=``, and ``>=``) raise :exc:`TypeError`."
msgstr "順序比較（``<``、``>``、``<=`` 和 ``>=``）引發 :exec:`TypeError`。"

#: ../../reference/expressions.rst:1561
#, fuzzy
msgid ""
"Sets (instances of :class:`set` or :class:`frozenset`) can be compared "
"within and across their types."
msgstr "集合（:class:`set` 或 :class:`frozenset` "
"的實例）可以在它們的型別內部和之間進行比較。"

#: ../../reference/expressions.rst:1564
#, fuzzy
msgid ""
"They define order comparison operators to mean subset and superset tests.  "
"Those relations do not define total orderings (for example, the two sets "
"``{1,2}`` and ``{2,3}`` are not equal, nor subsets of one another, nor "
"supersets of one another).  Accordingly, sets are not appropriate arguments "
"for functions which depend on total ordering (for example, :func:`min`, :"
"func:`max`, and :func:`sorted` produce undefined results given a list of "
"sets as inputs)."
msgstr ""
"他們定義順序比較運算符來表示子集和超集測試。這些關係不定義全序（例如，兩個集"
"合“{1,2}”和“{2,3}”不相等，也不是彼此的子集，也不是彼此的超集）。因此，集合不"
"適合依賴於總排序的函式的參數（例如，給定集合列表作為輸入，:func:`min`、:func:"
"`max` 和 :func:`sorted` 產生未定義的結果） ."

#: ../../reference/expressions.rst:1572
#, fuzzy
msgid "Comparison of sets enforces reflexivity of its elements."
msgstr "集合的比較強制其元素的自反性。"

#: ../../reference/expressions.rst:1574
#, fuzzy
msgid ""
"Most other built-in types have no comparison methods implemented, so they "
"inherit the default comparison behavior."
msgstr "大多數其他內建型別都沒有實作比較方法，因此它們繼承了預設的比較行為。"

#: ../../reference/expressions.rst:1577
#, fuzzy
msgid ""
"User-defined classes that customize their comparison behavior should follow "
"some consistency rules, if possible:"
msgstr "如果可能，自定義比較行為的使用者定義類應遵循一些一致性規則："

#: ../../reference/expressions.rst:1580
#, fuzzy
msgid ""
"Equality comparison should be reflexive. In other words, identical objects "
"should compare equal:"
msgstr "相等比較應該是自反的。換句話說，相同的物件應該比較相等："

#: ../../reference/expressions.rst:1583
#, fuzzy
msgid "``x is y`` implies ``x == y``"
msgstr "``x is y`` 表示 ``x == y``"

#: ../../reference/expressions.rst:1585
#, fuzzy
msgid ""
"Comparison should be symmetric. In other words, the following expressions "
"should have the same result:"
msgstr "比較應該是對稱的。換句話說，下面的表達式應該有相同的結果："

#: ../../reference/expressions.rst:1588
msgid "``x == y`` and ``y == x``"
msgstr "``x == y`` 和 ``y == x``"

#: ../../reference/expressions.rst:1590
msgid "``x != y`` and ``y != x``"
msgstr "``x != y`` 和 ``y != x``"

#: ../../reference/expressions.rst:1592
msgid "``x < y`` and ``y > x``"
msgstr "``x < y`` 和 ``y > x``"

#: ../../reference/expressions.rst:1594
msgid "``x <= y`` and ``y >= x``"
msgstr "``x <= y`` 和 ``y >= x``"

#: ../../reference/expressions.rst:1596
#, fuzzy
msgid ""
"Comparison should be transitive. The following (non-exhaustive) examples "
"illustrate that:"
msgstr "比較應該是可傳遞的。以下（非詳盡）示例說明："

#: ../../reference/expressions.rst:1599
msgid "``x > y and y > z`` implies ``x > z``"
msgstr "``x > y and y > z`` 暗示了 ``x > z``"

#: ../../reference/expressions.rst:1601
msgid "``x < y and y <= z`` implies ``x < z``"
msgstr "``x < y and y <= z`` 暗示了 ``x < z``"

#: ../../reference/expressions.rst:1603
#, fuzzy
msgid ""
"Inverse comparison should result in the boolean negation. In other words, "
"the following expressions should have the same result:"
msgstr "反向比較應該導致布爾否定。換句話說，下面的表達式應該有相同的結果："

#: ../../reference/expressions.rst:1606
msgid "``x == y`` and ``not x != y``"
msgstr "``x == y`` 和 ``not x != y``"

#: ../../reference/expressions.rst:1608
#, fuzzy
msgid "``x < y`` and ``not x >= y`` (for total ordering)"
msgstr "``x < y`` 和 ``not x >= y``（用於總排序）"

#: ../../reference/expressions.rst:1610
#, fuzzy
msgid "``x > y`` and ``not x <= y`` (for total ordering)"
msgstr "``x > y`` 和 ``not x <= y``（用於總排序）"

#: ../../reference/expressions.rst:1612
#, fuzzy
msgid ""
"The last two expressions apply to totally ordered collections (e.g. to "
"sequences, but not to sets or mappings). See also the :func:`~functools."
"total_ordering` decorator."
msgstr ""
"最後兩個表達式適用於完全有序的集合（例如序列，但不適用於集合或映射）。另見 "
":func:`~functools.total_ordering` 裝飾器。"

#: ../../reference/expressions.rst:1616
#, fuzzy
msgid ""
"The :func:`hash` result should be consistent with equality. Objects that are "
"equal should either have the same hash value, or be marked as unhashable."
msgstr ":func:`hash` "
"結果應該與相等性一致。相等的物件應該具有相同的散列值，或者被標記為不可散列。"

#: ../../reference/expressions.rst:1620
#, fuzzy
msgid ""
"Python does not enforce these consistency rules. In fact, the not-a-number "
"values are an example for not following these rules."
msgstr "Python 不強制執行這些一致性規則。事實上，非數字值是不遵守這些規則的一個例子。"

#: ../../reference/expressions.rst:1629
#, fuzzy
msgid "Membership test operations"
msgstr "會員測試操作"

#: ../../reference/expressions.rst:1631
#, fuzzy
msgid ""
"The operators :keyword:`in` and :keyword:`not in` test for membership.  ``x "
"in s`` evaluates to ``True`` if *x* is a member of *s*, and ``False`` "
"otherwise. ``x not in s`` returns the negation of ``x in s``.  All built-in "
"sequences and set types support this as well as dictionary, for which :"
"keyword:`!in` tests whether the dictionary has a given key. For container "
"types such as list, tuple, set, frozenset, dict, or collections.deque, the "
"expression ``x in y`` is equivalent to ``any(x is e or x == e for e in y)``."
msgstr ""
"運算符 :keyword:`in` 和 :keyword:`not in` 測試成員資格。如果 *x* 是 *s* "
"的成員，``x in s`` 計算結果為 ``True``，否則為 ``False``。 ``x not in s`` "
"回傳 ``x in s`` 的否定。所有內建序列和集合型別都支援這個以及字典，為此 "
":keyword:`!in` 測試字典是否有給定的鍵。對於 list、tuple、set、frozenset、"
"dict 或 collections.deque 等容器型別，表達式“x in y”等同於“any(x is e or x "
"== e for e in y)” `。"

#: ../../reference/expressions.rst:1639
#, fuzzy
msgid ""
"For the string and bytes types, ``x in y`` is ``True`` if and only if *x* is "
"a substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Empty "
"strings are always considered to be a substring of any other string, so "
"``\"\" in \"abc\"`` will return ``True``."
msgstr ""
"對於字串和位元組型別，當且僅當 *x* 是 *y* 的子字串時，``x in y`` 為 "
"``True``。等效測試是 ``y.find(x) != "
"-1``。空字串總是被認為是任何其他字串的子字串，因此 ``\"\" in \"abc\"`` 將回傳 ``True``。"

#: ../../reference/expressions.rst:1644
#, fuzzy
msgid ""
"For user-defined classes which define the :meth:`__contains__` method, ``x "
"in y`` returns ``True`` if ``y.__contains__(x)`` returns a true value, and "
"``False`` otherwise."
msgstr ""
"對於定義 :meth:`__contains__` 方法的使用者定義類，如果 ``y.__contains__(x)`` "
"回傳真值，則 ``x in y`` 回傳 ``True``，而 ``False` `否則。"

#: ../../reference/expressions.rst:1648
#, fuzzy
msgid ""
"For user-defined classes which do not define :meth:`__contains__` but do "
"define :meth:`__iter__`, ``x in y`` is ``True`` if some value ``z``, for "
"which the expression ``x is z or x == z`` is true, is produced while "
"iterating over ``y``. If an exception is raised during the iteration, it is "
"as if :keyword:`in` raised that exception."
msgstr ""
"對於未定義 :meth:`__contains__` 但定義了 :meth:`__iter__` 的使用者定義類，"
"如果某個值 ``z`` 則 ``x in y`` 為 ``True``，為此表達式 ``x is z or x == z`` "
"為真，是在疊代 ``y`` 時產生的。如果在疊代期間引發例外，就好像 :keyword:`in` "
"引發了該例外。"

#: ../../reference/expressions.rst:1654
#, fuzzy
msgid ""
"Lastly, the old-style iteration protocol is tried: if a class defines :meth:"
"`__getitem__`, ``x in y`` is ``True`` if and only if there is a non-negative "
"integer index *i* such that ``x is y[i] or x == y[i]``, and no lower integer "
"index raises the :exc:`IndexError` exception.  (If any other exception is "
"raised, it is as if :keyword:`in` raised that exception)."
msgstr ""
"最後，嘗試舊式疊代協定：如果類定義 :meth:`__getitem__`，"
"當且僅當存在非負整數索引 *i* 時，``x in y`` 為 ``True``這樣 ``x 是 y[i] 或 x "
"== y[i]``，並且沒有較低的整數索引引發 :exc:`IndexError` 例外。 "
"（如果引發任何其他例外，就好像 :keyword:`in` 引發了那個例外）。"

#: ../../reference/expressions.rst:1666
#, fuzzy
msgid ""
"The operator :keyword:`not in` is defined to have the inverse truth value "
"of :keyword:`in`."
msgstr "運算符 :keyword:`not in` 被定義為具有 :keyword:`in` 的逆真值。"

#: ../../reference/expressions.rst:1679
#, fuzzy
msgid "Identity comparisons"
msgstr "身份比較"

#: ../../reference/expressions.rst:1681
#, fuzzy
msgid ""
"The operators :keyword:`is` and :keyword:`is not` test for an object's "
"identity: ``x is y`` is true if and only if *x* and *y* are the same "
"object.  An Object's identity is determined using the :meth:`id` function.  "
"``x is not y`` yields the inverse truth value. [#]_"
msgstr ""
"運算符 :keyword:`is` 和 :keyword:`is not` 測試物件的身份：當且僅當 *x* 和 *y*"
" 是同一物件時，``x is y`` 為真。使用 :meth:`id` 函式確定物件的身份。 ``x "
"不是 y`` 產生相反的真值。 [#]_"

#: ../../reference/expressions.rst:1693
#, fuzzy
msgid "Boolean operations"
msgstr "布爾運算"

#: ../../reference/expressions.rst:1704
#, fuzzy
msgid ""
"In the context of Boolean operations, and also when expressions are used by "
"control flow statements, the following values are interpreted as false: "
"``False``, ``None``, numeric zero of all types, and empty strings and "
"containers (including strings, tuples, lists, dictionaries, sets and "
"frozensets).  All other values are interpreted as true.  User-defined "
"objects can customize their truth value by providing a :meth:`__bool__` "
"method."
msgstr ""
"在布爾運算的上下文中，以及當控制流語句使用表達式時，以下值被解釋為 false：``F"
"alse``、``None``、所有型別的數字零以及空字串和容器（包括字串、元組、列表、字"
"典、集合和凍結集合）。所有其他值都被解釋為 true。"
"使用者定義的物件可以通過提供 :meth:`__bool__` 方法來自定義它們的真值。"

#: ../../reference/expressions.rst:1713
#, fuzzy
msgid ""
"The operator :keyword:`not` yields ``True`` if its argument is false, "
"``False`` otherwise."
msgstr "operator :keyword:`not` 如果其參數為 false 則產生 ``True`` ，否則產生 "
"``False`` 。"

#: ../../reference/expressions.rst:1718
#, fuzzy
msgid ""
"The expression ``x and y`` first evaluates *x*; if *x* is false, its value "
"is returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr "表達式“x 和 y”首先計算 *x*；如果 *x* 為假，則回傳其值；否則，計算 *y* "
"並回傳結果值。"

#: ../../reference/expressions.rst:1723
#, fuzzy
msgid ""
"The expression ``x or y`` first evaluates *x*; if *x* is true, its value is "
"returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr "表達式“x or y”首先計算 *x*；如果 *x* 為真，則回傳其值；否則，計算 *y* "
"並回傳結果值。"

#: ../../reference/expressions.rst:1726
#, fuzzy
msgid ""
"Note that neither :keyword:`and` nor :keyword:`or` restrict the value and "
"type they return to ``False`` and ``True``, but rather return the last "
"evaluated argument.  This is sometimes useful, e.g., if ``s`` is a string "
"that should be replaced by a default value if it is empty, the expression "
"``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to "
"create a new value, it returns a boolean value regardless of the type of its "
"argument (for example, ``not 'foo'`` produces ``False`` rather than ``''``.)"
msgstr ""
"請注意，:keyword:`and` 和 :keyword:`or` 都不會將它們回傳的值和型別限制為 "
"``False`` 和 ``True``，而是回傳最後計算的參數。這有時很有用，例如，如果 ``s``"
" 是一個字串，如果它為空，則應由預設值替換，表達式 ``s 或 'foo'`` "
"會產生所需的值。因為 :keyword:`not` "
"必須建立一個新值，所以無論參數的型別如何，它都會回傳一個布爾值（例如，``not "
"'foo'`` 產生 ``False`` 而不是 ``'' ``。）"

#: ../../reference/expressions.rst:1742
#, fuzzy
msgid "Assignment expressions"
msgstr "賦值表達式"

#: ../../reference/expressions.rst:1747
#, fuzzy
msgid ""
"An assignment expression (sometimes also called a \"named expression\" or "
"\"walrus\") assigns an :token:`~python-grammar:expression` to an :token:"
"`~python-grammar:identifier`, while also returning the value of the :token:"
"`~python-grammar:expression`."
msgstr ""
"賦值表達式（有時也稱為“命名表達式”或“海象”）將 :token:`~python-"
"grammar:expression` 分配給 :token:`~python-"
"grammar:identifier`，同時回傳值 :token:`~python-grammar:expression`。"

#: ../../reference/expressions.rst:1752
#, fuzzy
msgid "One common use case is when handling matched regular expressions:"
msgstr "一個常見的用例是處理匹配的正則表達式時："

#: ../../reference/expressions.rst:1759
#, fuzzy
msgid "Or, when processing a file stream in chunks:"
msgstr "或者，當以塊的形式處理文件流時："

#: ../../reference/expressions.rst:1766
#, fuzzy
msgid ""
"Assignment expressions must be surrounded by parentheses when used as sub-"
"expressions in slicing, conditional, lambda, keyword-argument, and "
"comprehension-if expressions and in ``assert`` and ``with`` statements. In "
"all other places where they can be used, parentheses are not required, "
"including in ``if`` and ``while`` statements."
msgstr ""
"當在切片、條件、lambda、關鍵字參數和理解-if 表達式以及 ``assert``和 ``with``語句中"
"用作子表達式時，賦值表達式必須用括號括起來。在所有其他可以使用它們的地方，不"
"需要括號，包括在 ``if`` 和 ``while`` 語句中。"

#: ../../reference/expressions.rst:1773
#, fuzzy
msgid "See :pep:`572` for more details about assignment expressions."
msgstr "有關賦值表達式的更多詳細資訊，請參閱 :pep:`572`。"

#: ../../reference/expressions.rst:1780
#, fuzzy
msgid "Conditional expressions"
msgstr "條件表達式"

#: ../../reference/expressions.rst:1792
#, fuzzy
msgid ""
"Conditional expressions (sometimes called a \"ternary operator\") have the "
"lowest priority of all Python operations."
msgstr "條件表達式（有時稱為“三元運算符”）在所有 Python 操作中具有最低的優先級。"

#: ../../reference/expressions.rst:1795
#, fuzzy
msgid ""
"The expression ``x if C else y`` first evaluates the condition, *C* rather "
"than *x*. If *C* is true, *x* is evaluated and its value is returned; "
"otherwise, *y* is evaluated and its value is returned."
msgstr ""
"表達式“x if C else y”首先計算條件，*C* 而不是 *x*。如果 *C* 為真，則計算 *x* "
"並回傳其值；否則，計算 *y* 並回傳其值。"

#: ../../reference/expressions.rst:1799
#, fuzzy
msgid "See :pep:`308` for more details about conditional expressions."
msgstr "有關條件表達式的更多詳細資訊，請參閱 :pep:`308`。"

#: ../../reference/expressions.rst:1806
#, fuzzy
msgid "Lambdas"
msgstr "拉姆達斯"

#: ../../reference/expressions.rst:1817
#, fuzzy
msgid ""
"Lambda expressions (sometimes called lambda forms) are used to create "
"anonymous functions. The expression ``lambda parameters: expression`` yields "
"a function object.  The unnamed object behaves like a function object "
"defined with:"
msgstr ""
"Lambda 表達式（有時稱為 lambda 形式）用於建立匿名函式。表達式“lambda "
"parameters: "
"expression”產生一個函式物件。未命名物件的行為類似於定義的函式物件："

#: ../../reference/expressions.rst:1826
#, fuzzy
msgid ""
"See section :ref:`function` for the syntax of parameter lists.  Note that "
"functions created with lambda expressions cannot contain statements or "
"annotations."
msgstr "有關參數列表的語法，請參閱 :ref:`function` 部分。請注意，使用 lambda "
"表達式建立的函式不能包含語句或註釋。"

#: ../../reference/expressions.rst:1834
#, fuzzy
msgid "Expression lists"
msgstr "表達式列表"

#: ../../reference/expressions.rst:1848
#, fuzzy
msgid ""
"Except when part of a list or set display, an expression list containing at "
"least one comma yields a tuple.  The length of the tuple is the number of "
"expressions in the list.  The expressions are evaluated from left to right."
msgstr "除非列表或集合顯示的一部分，否則包含至少一個逗號的表達式列表會生成一個元組。"
"元組的長度是列表中表達式的數量。表達式從左到右計算。"

#: ../../reference/expressions.rst:1857
#, fuzzy
msgid ""
"An asterisk ``*`` denotes :dfn:`iterable unpacking`.  Its operand must be "
"an :term:`iterable`.  The iterable is expanded into a sequence of items, "
"which are included in the new tuple, list, or set, at the site of the "
"unpacking."
msgstr ""
"星號 ``*``表示：dfn：“可疊代解包”。它的操作數必須是一個 :term:`iterable`。可疊代"
"對像被擴充為一系列項目，這些項目包含在解包位置的新元組、列表或集合中。"

#: ../../reference/expressions.rst:1862
#, fuzzy
msgid ""
"Iterable unpacking in expression lists, originally proposed by :pep:`448`."
msgstr "表達式列表中的可疊代拆包，最初由 :pep:`448` 提出。"

#: ../../reference/expressions.rst:1867
#, fuzzy
msgid ""
"The trailing comma is required only to create a single tuple (a.k.a. a "
"*singleton*); it is optional in all other cases.  A single expression "
"without a trailing comma doesn't create a tuple, but rather yields the value "
"of that expression. (To create an empty tuple, use an empty pair of "
"parentheses: ``()``.)"
msgstr ""
"只需要尾隨逗號來建立單個元組（又名 *singleton*）；在所有其他情況下都是可選的"
"。沒有尾隨逗號的單個表達式不會建立元組，而是生成該表達式的值。 "
"（要建立一個空元組，請使用一對空括號：``()``。）"

#: ../../reference/expressions.rst:1877
#, fuzzy
msgid "Evaluation order"
msgstr "評價順序"

#: ../../reference/expressions.rst:1881
#, fuzzy
msgid ""
"Python evaluates expressions from left to right.  Notice that while "
"evaluating an assignment, the right-hand side is evaluated before the left-"
"hand side."
msgstr "Python 從左到右計算表達式。請注意，在評估賦值時，右側先於左側評估。"

#: ../../reference/expressions.rst:1884
#, fuzzy
msgid ""
"In the following lines, expressions will be evaluated in the arithmetic "
"order of their suffixes::"
msgstr "在以下行中，表達式將按照其後綴的算術順序進行計算："

#: ../../reference/expressions.rst:1898
#, fuzzy
msgid "Operator precedence"
msgstr "運算符優先級"

#: ../../reference/expressions.rst:1903
#, fuzzy
msgid ""
"The following table summarizes the operator precedence in Python, from "
"highest precedence (most binding) to lowest precedence (least binding).  "
"Operators in the same box have the same precedence.  Unless the syntax is "
"explicitly given, operators are binary.  Operators in the same box group "
"left to right (except for exponentiation and conditional expressions, which "
"group from right to left)."
msgstr ""
"下表總結了 Python 中的運算符優先級，從最高優先級（綁定最多）到最低優先級（綁"
"定最少）。同一框中的運算符具有相同的優先級。除非明確給出語法，否則運算符是二"
"進位的。同一框內的運算符從左到右分組（除求冪和條件表達式外，它們從右到左分組"
"）。"

#: ../../reference/expressions.rst:1909
#, fuzzy
msgid ""
"Note that comparisons, membership tests, and identity tests, all have the "
"same precedence and have a left-to-right chaining feature as described in "
"the :ref:`comparisons` section."
msgstr "請注意，比較、成員資格測試和身份測試都具有相同的優先級，並且具有從左到右的鏈"
"接功能，如 :ref:`comparisons` 部分所述。"

#: ../../reference/expressions.rst:1915
#, fuzzy
msgid "Operator"
msgstr "操作員"

#: ../../reference/expressions.rst:1915
msgid "Description"
msgstr "描述"

#: ../../reference/expressions.rst:1917
msgid "``(expressions...)``,"
msgstr "``(expressions...)``,"

#: ../../reference/expressions.rst:1919
msgid "``[expressions...]``, ``{key: value...}``, ``{expressions...}``"
msgstr "``[expressions...]``, ``{key: value...}``, ``{expressions...}``"

#: ../../reference/expressions.rst:1917
#, fuzzy
msgid ""
"Binding or parenthesized expression, list display, dictionary display, set "
"display"
msgstr "綁定或括號表達式、列表顯示、字典顯示、集合顯示"

#: ../../reference/expressions.rst:1923
msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"

#: ../../reference/expressions.rst:1923
#, fuzzy
msgid "Subscription, slicing, call, attribute reference"
msgstr "訂閱、切片、呼叫、屬性引用"

#: ../../reference/expressions.rst:1926
msgid ":keyword:`await x <await>`"
msgstr ":keyword:`await x <await>`"

#: ../../reference/expressions.rst:1928
msgid "``**``"
msgstr "``**``"

#: ../../reference/expressions.rst:1928
#, fuzzy
msgid "Exponentiation [#]_"
msgstr "求冪[#]_"

#: ../../reference/expressions.rst:1930
msgid "``+x``, ``-x``, ``~x``"
msgstr "``+x``, ``-x``, ``~x``"

#: ../../reference/expressions.rst:1930
#, fuzzy
msgid "Positive, negative, bitwise NOT"
msgstr "正數、負數、按位非"

#: ../../reference/expressions.rst:1932
msgid "``*``, ``@``, ``/``, ``//``, ``%``"
msgstr "``*``, ``@``, ``/``, ``//``, ``%``"

#: ../../reference/expressions.rst:1932
#, fuzzy
msgid ""
"Multiplication, matrix multiplication, division, floor division, remainder "
"[#]_"
msgstr "乘法、矩陣乘法、除法、底除法、餘數[#]_"

#: ../../reference/expressions.rst:1936
msgid "``+``, ``-``"
msgstr "``+``, ``-``"

#: ../../reference/expressions.rst:1936
#, fuzzy
msgid "Addition and subtraction"
msgstr "加減"

#: ../../reference/expressions.rst:1938
msgid "``<<``, ``>>``"
msgstr "``<<``, ``>>``"

#: ../../reference/expressions.rst:1938
#, fuzzy
msgid "Shifts"
msgstr "轉移"

#: ../../reference/expressions.rst:1940
msgid "``&``"
msgstr "``&``"

#: ../../reference/expressions.rst:1940
#, fuzzy
msgid "Bitwise AND"
msgstr "按位與"

#: ../../reference/expressions.rst:1942
msgid "``^``"
msgstr "``^``"

#: ../../reference/expressions.rst:1942
#, fuzzy
msgid "Bitwise XOR"
msgstr "按位異或"

#: ../../reference/expressions.rst:1944
msgid "``|``"
msgstr "``|``"

#: ../../reference/expressions.rst:1944
#, fuzzy
msgid "Bitwise OR"
msgstr "按位或"

#: ../../reference/expressions.rst:1946
#, fuzzy
msgid ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"
msgstr ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ` `>=``, ``!=``, ``==``"

#: ../../reference/expressions.rst:1946
#, fuzzy
msgid "Comparisons, including membership tests and identity tests"
msgstr "比較，包括成員資格測試和身份測試"

#: ../../reference/expressions.rst:1950
msgid ":keyword:`not x <not>`"
msgstr ":keyword:`not x <not>`"

#: ../../reference/expressions.rst:1950
#, fuzzy
msgid "Boolean NOT"
msgstr "布爾非"

#: ../../reference/expressions.rst:1952
msgid ":keyword:`and`"
msgstr ":keyword:`and`"

#: ../../reference/expressions.rst:1952
#, fuzzy
msgid "Boolean AND"
msgstr "布爾與"

#: ../../reference/expressions.rst:1954
msgid ":keyword:`or`"
msgstr ":keyword:`or`"

#: ../../reference/expressions.rst:1954
#, fuzzy
msgid "Boolean OR"
msgstr "布爾或"

#: ../../reference/expressions.rst:1956
msgid ":keyword:`if <if_expr>` -- :keyword:`!else`"
msgstr ":keyword:`if <if_expr>` -- :keyword:`!else`"

#: ../../reference/expressions.rst:1956
#, fuzzy
msgid "Conditional expression"
msgstr "條件表達式"

#: ../../reference/expressions.rst:1958
msgid ":keyword:`lambda`"
msgstr ":keyword:`lambda`"

#: ../../reference/expressions.rst:1958
#, fuzzy
msgid "Lambda expression"
msgstr "拉姆達表達式"

#: ../../reference/expressions.rst:1960
msgid "``:=``"
msgstr "``:=``"

#: ../../reference/expressions.rst:1960
#, fuzzy
msgid "Assignment expression"
msgstr "賦值表達式"

#: ../../reference/expressions.rst:1965
msgid "Footnotes"
msgstr "註解"

#: ../../reference/expressions.rst:1966
#, fuzzy
msgid ""
"While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be "
"true numerically due to roundoff.  For example, and assuming a platform on "
"which a Python float is an IEEE 754 double-precision number, in order that "
"``-1e-100 % 1e100`` have the same sign as ``1e100``, the computed result is "
"``-1e-100 + 1e100``, which is numerically exactly equal to ``1e100``.  The "
"function :func:`math.fmod` returns a result whose sign matches the sign of "
"the first argument instead, and so returns ``-1e-100`` in this case. Which "
"approach is more appropriate depends on the application."
msgstr ""
"雖然 ``abs(x%y) < abs(y)`` "
"在數學上是正確的，但對於浮點數，由於四捨五入，它在數值上可能不正確。例如，"
"假設一個 Python 浮點數是 IEEE 754 雙精度數的平台，為了使 ``-1e-100 % 1e100`` "
"與 ``1e100`` 具有相同的符號，計算結果為 ` `-1e-100 + 1e100``，"
"在數值上恰好等於 ``1e100``。函式 :func:`math.fmod` "
"回傳一個結果，其符號與第一個參數的符號相匹配，因此在這種情況下回傳 "
"``-1e-100``。哪種方法更合適取決於應用程式。"

#: ../../reference/expressions.rst:1975
#, fuzzy
msgid ""
"If x is very close to an exact integer multiple of y, it's possible for ``x//"
"y`` to be one larger than ``(x-x%y)//y`` due to rounding.  In such cases, "
"Python returns the latter result, in order to preserve that ``divmod(x,y)[0] "
"* y + x % y`` be very close to ``x``."
msgstr ""
"如果 x 非常接近 y 的整數倍，則由於四捨五入，``x//y`` 可能比 ``(x-x%y)//y`` "
"大 1。在這種情況下，Python 回傳後一個結果，以保持“divmod(x,y)[0] * y + x % "
"y”非常接近 ``x``。"

#: ../../reference/expressions.rst:1980
#, fuzzy
msgid ""
"The Unicode standard distinguishes between :dfn:`code points` (e.g. U+0041) "
"and :dfn:`abstract characters` (e.g. \"LATIN CAPITAL LETTER A\"). While most "
"abstract characters in Unicode are only represented using one code point, "
"there is a number of abstract characters that can in addition be represented "
"using a sequence of more than one code point.  For example, the abstract "
"character \"LATIN CAPITAL LETTER C WITH CEDILLA\" can be represented as a "
"single :dfn:`precomposed character` at code position U+00C7, or as a "
"sequence of a :dfn:`base character` at code position U+0043 (LATIN CAPITAL "
"LETTER C), followed by a :dfn:`combining character` at code position U+0327 "
"(COMBINING CEDILLA)."
msgstr ""
"Unicode 標準區分程式碼點（例如 U+0041）和抽象字元（例如“拉丁大寫字母 A”）。"
"雖然 Unicode 中的大多數抽象字元僅使用一個程式碼點表示，但有許多抽象字元還可以"
"使用多個程式碼點的序列來表示。例如，抽象字元“LATIN CAPITAL LETTER C WITH "
"CEDILLA”可以在程式碼位置 U+00C7 表示為單個 :dfn:`precomposed character`，"
"或者在程式碼位置表示為一系列 :dfn:`base character` U+0043（拉丁文大寫字母 "
"C），後跟程式碼位置 U+0327（COMBINING CEDILLA）處的 :dfn:`combining "
"character`。"

#: ../../reference/expressions.rst:1991
#, fuzzy
msgid ""
"The comparison operators on strings compare at the level of Unicode code "
"points. This may be counter-intuitive to humans.  For example, ``\"\\u00C7\" "
"== \"\\u0043\\u0327\"`` is ``False``, even though both strings represent the "
"same abstract character \"LATIN CAPITAL LETTER C WITH CEDILLA\"."
msgstr ""
"字串的比較運算符在 Unicode "
"程式碼點級別進行比較。這對人類來說可能是違反直覺的。例如，``\"\\u00C7\" == \""
"\\u0043\\u0327\"`` 是 ``False``，即使兩個字串表示相同的抽象字元“帶有 CEDILLA "
"的拉丁大寫字母 C”。"

#: ../../reference/expressions.rst:1996
#, fuzzy
msgid ""
"To compare strings at the level of abstract characters (that is, in a way "
"intuitive to humans), use :func:`unicodedata.normalize`."
msgstr "要在抽象字元級別比較字串（即以人類直觀的方式），請使用 :func:`unicodedata."
"normalize`。"

#: ../../reference/expressions.rst:1999
#, fuzzy
msgid ""
"Due to automatic garbage-collection, free lists, and the dynamic nature of "
"descriptors, you may notice seemingly unusual behaviour in certain uses of "
"the :keyword:`is` operator, like those involving comparisons between "
"instance methods, or constants.  Check their documentation for more info."
msgstr ""
"由於自動垃圾收集、空閒列表和描述器的動態特性，您可能會注意到在 :keyword:`is` "
"運算符的某些使用中看似例外的行為，例如那些涉及實例方法或常數之間的比較的行為"
"。查看他們的文檔以獲取更多資訊。"

#: ../../reference/expressions.rst:2004
#, fuzzy
msgid ""
"The power operator ``**`` binds less tightly than an arithmetic or bitwise "
"unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr "冪運算符 ``**`` 的綁定不如其右側的算術或按位一元運算符緊密，即 ``2**-1`` 是 "
"``0.5``。"

#: ../../reference/expressions.rst:2007
#, fuzzy
msgid ""
"The ``%`` operator is also used for string formatting; the same precedence "
"applies."
msgstr "``%`` 運算符也用於字串格式化；同樣的優先級適用。"
