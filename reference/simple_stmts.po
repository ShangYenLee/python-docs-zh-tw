# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-08 00:19+0000\n"
"PO-Revision-Date: 2018-05-23 16:17+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/simple_stmts.rst:6
#, fuzzy
msgid "Simple statements"
msgstr "簡單語句"

#: ../../reference/simple_stmts.rst:10
#, fuzzy
msgid ""
"A simple statement is comprised within a single logical line. Several simple "
"statements may occur on a single line separated by semicolons.  The syntax "
"for simple statements is:"
msgstr "一個簡單的語句包含在一個邏輯行中。幾個簡單的語句可能出現在一行中，用分號分隔"
"。簡單語句的語法是："

#: ../../reference/simple_stmts.rst:36
#, fuzzy
msgid "Expression statements"
msgstr "表達式語句"

#: ../../reference/simple_stmts.rst:43
#, fuzzy
msgid ""
"Expression statements are used (mostly interactively) to compute and write a "
"value, or (usually) to call a procedure (a function that returns no "
"meaningful result; in Python, procedures return the value ``None``).  Other "
"uses of expression statements are allowed and occasionally useful.  The "
"syntax for an expression statement is:"
msgstr ""
"表達式語句（主要是交互地）用於計算和寫入一個值，或（通常）呼叫一個過程（一個"
"不回傳有意義結果的函式；在 Python 中，過程回傳值 ``None``）。表達式語句的其他用"
"途是允許的，偶爾也有用。表達式語句的語法是："

#: ../../reference/simple_stmts.rst:52
#, fuzzy
msgid ""
"An expression statement evaluates the expression list (which may be a single "
"expression)."
msgstr "表達式語句計算表達式列表（可能是單個表達式）。"

#: ../../reference/simple_stmts.rst:64
#, fuzzy
msgid ""
"In interactive mode, if the value is not ``None``, it is converted to a "
"string using the built-in :func:`repr` function and the resulting string is "
"written to standard output on a line by itself (except if the result is "
"``None``, so that procedure calls do not cause any output.)"
msgstr ""
"在交互模式下，如果值不是 ``None``，則使用內建的 :func:`repr` 函式將其轉換為字串"
"，並將生成的字串單獨一行寫入標準輸出（除非結果是 ``None`` ，因此過程呼叫不會產生任"
"何輸出。）"

#: ../../reference/simple_stmts.rst:72
#, fuzzy
msgid "Assignment statements"
msgstr "賦值語句"

#: ../../reference/simple_stmts.rst:82
#, fuzzy
msgid ""
"Assignment statements are used to (re)bind names to values and to modify "
"attributes or items of mutable objects:"
msgstr "賦值語句用於將名稱（重新）綁定到值並修改可變物件的屬性或項目："

#: ../../reference/simple_stmts.rst:96
#, fuzzy
msgid ""
"(See section :ref:`primaries` for the syntax definitions for *attributeref*, "
"*subscription*, and *slicing*.)"
msgstr ""
"（有關 *attributeref*、*subscription* 和 *slicing* 的語法定義，請參閱 "
":ref:`primaries` 部分。）"

#: ../../reference/simple_stmts.rst:99
#, fuzzy
msgid ""
"An assignment statement evaluates the expression list (remember that this "
"can be a single expression or a comma-separated list, the latter yielding a "
"tuple) and assigns the single resulting object to each of the target lists, "
"from left to right."
msgstr "賦值語句評估表達式列表（請記住，這可以是單個表達式或逗號分隔列表，後者生成元"
"組）並將單個結果對像從左到右分配給每個目標列表。"

#: ../../reference/simple_stmts.rst:108
#, fuzzy
msgid ""
"Assignment is defined recursively depending on the form of the target "
"(list). When a target is part of a mutable object (an attribute reference, "
"subscription or slicing), the mutable object must ultimately perform the "
"assignment and decide about its validity, and may raise an exception if the "
"assignment is unacceptable.  The rules observed by various types and the "
"exceptions raised are given with the definition of the object types (see "
"section :ref:`types`)."
msgstr ""
"分配是根據目標（列表）的形式遞迴定義的。當目標是可變物件（屬性引用、訂閱或切"
"片）的一部分時，可變物件必須最終執行賦值並決定其有效性，並且如果賦值不可接受"
"則可能引發例外。各種型別遵守的規則和引發的例外在對像型別的定義中給出（參見 "
":ref:`types` 部分）。"

#: ../../reference/simple_stmts.rst:121
#, fuzzy
msgid ""
"Assignment of an object to a target list, optionally enclosed in parentheses "
"or square brackets, is recursively defined as follows."
msgstr "將物件分配給目標列表（可選地括在圓括號或方括號中）遞迴定義如下。"

#: ../../reference/simple_stmts.rst:124
#, fuzzy
msgid ""
"If the target list is a single target with no trailing comma, optionally in "
"parentheses, the object is assigned to that target."
msgstr "如果目標列表是沒有尾隨逗號的單個目標（可選擇在括號中），則將物件分配給該目標"
"。"

#: ../../reference/simple_stmts.rst:127
#, fuzzy
msgid "Else:"
msgstr "別的："

#: ../../reference/simple_stmts.rst:129
#, fuzzy
msgid ""
"If the target list contains one target prefixed with an asterisk, called a "
"\"starred\" target: The object must be an iterable with at least as many "
"items as there are targets in the target list, minus one.  The first items "
"of the iterable are assigned, from left to right, to the targets before the "
"starred target.  The final items of the iterable are assigned to the targets "
"after the starred target.  A list of the remaining items in the iterable is "
"then assigned to the starred target (the list can be empty)."
msgstr ""
"如果目標列表包含一個以星號為前綴的目標，稱為“星號”目標：該物件必須是一個可疊"
"代物件，其項目數至少與目標列表中的目標數一樣多，減去一個。可疊代物件的第一項"
"從左到右分配給加星標目標之前的目標。可疊代的最終項目被分配給加星標的目標之後"
"的目標。然後將 iterable "
"中剩餘項目的列表分配給加星標的目標（該列表可以為空）。"

#: ../../reference/simple_stmts.rst:137
#, fuzzy
msgid ""
"Else: The object must be an iterable with the same number of items as there "
"are targets in the target list, and the items are assigned, from left to "
"right, to the corresponding targets."
msgstr "Else：該物件必須是一個可疊代物件，其項目數與目標列表中的目標數相同，並且項目"
"從左到右分配給相應的目標。"

#: ../../reference/simple_stmts.rst:141
#, fuzzy
msgid ""
"Assignment of an object to a single target is recursively defined as follows."
msgstr "將物件分配給單個目標的遞迴定義如下。"

#: ../../reference/simple_stmts.rst:143
#, fuzzy
msgid "If the target is an identifier (name):"
msgstr "如果目標是標識符（名稱）："

#: ../../reference/simple_stmts.rst:145
#, fuzzy
msgid ""
"If the name does not occur in a :keyword:`global` or :keyword:`nonlocal` "
"statement in the current code block: the name is bound to the object in the "
"current local namespace."
msgstr ""
"如果該名稱未出現在當前程式碼塊的 :keyword:`global` 或 :keyword:`nonlocal` "
"語句中：該名稱將綁定到當前本地命名空間中的物件。"

#: ../../reference/simple_stmts.rst:149
#, fuzzy
msgid ""
"Otherwise: the name is bound to the object in the global namespace or the "
"outer namespace determined by :keyword:`nonlocal`, respectively."
msgstr "否則：該名稱分別綁定到全局命名空間或由 nonlocal 確定的外部命名空間中的物件。"

#: ../../reference/simple_stmts.rst:154
#, fuzzy
msgid ""
"The name is rebound if it was already bound.  This may cause the reference "
"count for the object previously bound to the name to reach zero, causing the "
"object to be deallocated and its destructor (if it has one) to be called."
msgstr ""
"如果已經綁定，則名稱為 rebound。這可能會導致先前綁定到名稱的物件的引用計數達"
"到零，從而導致對像被釋放並呼叫其析構函式（如果它有析構函式）。"

#: ../../reference/simple_stmts.rst:160
#, fuzzy
msgid ""
"If the target is an attribute reference: The primary expression in the "
"reference is evaluated.  It should yield an object with assignable "
"attributes; if this is not the case, :exc:`TypeError` is raised.  That "
"object is then asked to assign the assigned object to the given attribute; "
"if it cannot perform the assignment, it raises an exception (usually but not "
"necessarily :exc:`AttributeError`)."
msgstr ""
"如果目標是屬性引用：將計算引用中的主要表達式。它應該產生一個具有可分配屬性的"
"物件；如果不是這種情況，則會引發 :exc:`TypeError`。然後要求該物件將分配的物件"
"分配給給定的屬性；如果它不能執行賦值，它會引發例外（通常但不一定是 "
":exc:`AttributeError`）。"

#: ../../reference/simple_stmts.rst:169
#, fuzzy
msgid ""
"Note: If the object is a class instance and the attribute reference occurs "
"on both sides of the assignment operator, the right-hand side expression, "
"``a.x`` can access either an instance attribute or (if no instance attribute "
"exists) a class attribute.  The left-hand side target ``a.x`` is always set "
"as an instance attribute, creating it if necessary.  Thus, the two "
"occurrences of ``a.x`` do not necessarily refer to the same attribute: if "
"the right-hand side expression refers to a class attribute, the left-hand "
"side creates a new instance attribute as the target of the assignment::"
msgstr ""
"注意：如果對像是一個類實例，並且屬性引用出現在賦值運算符的兩邊，則右側表達式“"
"a.x”可以訪問實例屬性或（如果不存在實例屬性）類屬性。左側目標“a."
"x”始終設定為實例屬性，必要時建立它。因此，兩次出現的 ``a.x`` 不一定指代相同的"
"屬性：如果右側表達式指代一個類屬性，則左側表達式建立一個新的實例屬性作為賦值"
"的目標： :"

#: ../../reference/simple_stmts.rst:183
#, fuzzy
msgid ""
"This description does not necessarily apply to descriptor attributes, such "
"as properties created with :func:`property`."
msgstr "此描述不一定適用於描述器屬性，例如使用 :func:`property` 建立的屬性。"

#: ../../reference/simple_stmts.rst:190
#, fuzzy
msgid ""
"If the target is a subscription: The primary expression in the reference is "
"evaluated.  It should yield either a mutable sequence object (such as a "
"list) or a mapping object (such as a dictionary).  Next, the subscript "
"expression is evaluated."
msgstr "如果目標是訂閱：將評估引用中的主要表達式。它應該產生一個可變序列物件（例如列"
"表）或映射物件（例如字典）。接下來，評估下標表達式。"

#: ../../reference/simple_stmts.rst:199
#, fuzzy
msgid ""
"If the primary is a mutable sequence object (such as a list), the subscript "
"must yield an integer.  If it is negative, the sequence's length is added to "
"it.  The resulting value must be a nonnegative integer less than the "
"sequence's length, and the sequence is asked to assign the assigned object "
"to its item with that index.  If the index is out of range, :exc:"
"`IndexError` is raised (assignment to a subscripted sequence cannot add new "
"items to a list)."
msgstr ""
"如果 primary 是可變序列物件（例如列表），則下標必須產生一個整數。如果它是負數"
"，則將序列的長度新增到它。結果值必須是小於序列長度的非負整數，並且要求序列將"
"分配的物件分配給具有該索引的項目。如果索引超出範圍，則會引發 :exec:`IndexError"
"`（對下標序列的賦值不能將新項目新增到列表中）。"

#: ../../reference/simple_stmts.rst:210
#, fuzzy
msgid ""
"If the primary is a mapping object (such as a dictionary), the subscript "
"must have a type compatible with the mapping's key type, and the mapping is "
"then asked to create a key/datum pair which maps the subscript to the "
"assigned object.  This can either replace an existing key/value pair with "
"the same key value, or insert a new key/value pair (if no key with the same "
"value existed)."
msgstr ""
"如果主對像是映射物件（例如字典），則下標必須具有與映射的鍵型別相容的型別，然"
"後要求映射建立一個鍵/資料對，將下標映射到指定的物件。這可以用相同的鍵值替換現"
"有的鍵/值對，或者插入一個新的鍵/值對（如果不存在具有相同值的鍵）。"

#: ../../reference/simple_stmts.rst:216
#, fuzzy
msgid ""
"For user-defined objects, the :meth:`__setitem__` method is called with "
"appropriate arguments."
msgstr "對於使用者定義的物件，使用適當的參數呼叫 :meth:`__setitem__` 方法。"

#: ../../reference/simple_stmts.rst:221
#, fuzzy
msgid ""
"If the target is a slicing: The primary expression in the reference is "
"evaluated.  It should yield a mutable sequence object (such as a list).  The "
"assigned object should be a sequence object of the same type.  Next, the "
"lower and upper bound expressions are evaluated, insofar they are present; "
"defaults are zero and the sequence's length.  The bounds should evaluate to "
"integers. If either bound is negative, the sequence's length is added to "
"it.  The resulting bounds are clipped to lie between zero and the sequence's "
"length, inclusive.  Finally, the sequence object is asked to replace the "
"slice with the items of the assigned sequence.  The length of the slice may "
"be different from the length of the assigned sequence, thus changing the "
"length of the target sequence, if the target sequence allows it."
msgstr ""
"如果目標是切片：將評估引用中的主要表達式。它應該產生一個可變序列物件（例如列"
"表）。分配的物件應該是相同型別的序列物件。接下來，評估下限和上限表達式，只要"
"它們存在；預設值為零和序列的長度。邊界應評估為整數。如果任一邊界為負，則將序"
"列的長度新增到它。生成的邊界被裁剪為介於零和序列長度之間，包括零和序列長度。"
"最後，序列對像被要求用分配序列的項目替換切片。切片的長度可能不同於指定序列的"
"長度，因此如果目標序列允許的話，會改變目標序列的長度。"

#: ../../reference/simple_stmts.rst:235
#, fuzzy
msgid ""
"In the current implementation, the syntax for targets is taken to be the "
"same as for expressions, and invalid syntax is rejected during the code "
"generation phase, causing less detailed error messages."
msgstr "在當前的實作中，目標的語法與表達式的語法相同，並且在程式碼生成階段拒絕無效語"
"法，導致錯誤消息不那麼詳細。"

#: ../../reference/simple_stmts.rst:239
#, fuzzy
msgid ""
"Although the definition of assignment implies that overlaps between the left-"
"hand side and the right-hand side are 'simultaneous' (for example ``a, b = "
"b, a`` swaps two variables), overlaps *within* the collection of assigned-to "
"variables occur left-to-right, sometimes resulting in confusion.  For "
"instance, the following program prints ``[0, 2]``::"
msgstr ""
"儘管賦值的定義意味著左側和右側之間的重疊是“同時的”（例如，``a, b = b, a`` "
"交換兩個變數），但在 *within* "
"的集合中重疊分配給變數的順序是從左到右，有時會造成混淆。例如，以下程式印出 "
"``[0, 2]``::"

#: ../../reference/simple_stmts.rst:253
#, fuzzy
msgid ":pep:`3132` - Extended Iterable Unpacking"
msgstr ":pep:`3132` - 擴充的可疊代拆包"

#: ../../reference/simple_stmts.rst:254
#, fuzzy
msgid "The specification for the ``*target`` feature."
msgstr "``*target`` 特性的規範。"

#: ../../reference/simple_stmts.rst:260
#, fuzzy
msgid "Augmented assignment statements"
msgstr "擴充賦值語句"

#: ../../reference/simple_stmts.rst:278
#, fuzzy
msgid ""
"Augmented assignment is the combination, in a single statement, of a binary "
"operation and an assignment statement:"
msgstr "擴充賦值是二元運算和賦值語句在單個語句中的組合："

#: ../../reference/simple_stmts.rst:287
#, fuzzy
msgid ""
"(See section :ref:`primaries` for the syntax definitions of the last three "
"symbols.)"
msgstr "（有關最後三個符號的語法定義，請參閱 :ref:`primaries` 部分。）"

#: ../../reference/simple_stmts.rst:290
#, fuzzy
msgid ""
"An augmented assignment evaluates the target (which, unlike normal "
"assignment statements, cannot be an unpacking) and the expression list, "
"performs the binary operation specific to the type of assignment on the two "
"operands, and assigns the result to the original target.  The target is only "
"evaluated once."
msgstr ""
"擴充賦值評估目標（與普通賦值語句不同，它不能是拆包）和表達式列表，對兩個操作"
"數執行特定於賦值型別的二元運算，並將結果賦給原始目標。目標僅被評估一次。"

#: ../../reference/simple_stmts.rst:295
#, fuzzy
msgid ""
"An augmented assignment expression like ``x += 1`` can be rewritten as ``x = "
"x + 1`` to achieve a similar, but not exactly equal effect. In the augmented "
"version, ``x`` is only evaluated once. Also, when possible, the actual "
"operation is performed *in-place*, meaning that rather than creating a new "
"object and assigning that to the target, the old object is modified instead."
msgstr ""
"像 ``x += 1`` 這樣的增強賦值表達式可以重寫為 ``x = x + 1`` "
"以實作類似但不完全相等的效果。在增強版本中，``x`` 僅被評估一次。此外，在可能"
"的情況下，實際操作會*就地*執行，這意味著不是建立新物件並將其分配給目標，而是"
"修改舊物件。"

#: ../../reference/simple_stmts.rst:301
#, fuzzy
msgid ""
"Unlike normal assignments, augmented assignments evaluate the left-hand side "
"*before* evaluating the right-hand side.  For example, ``a[i] += f(x)`` "
"first looks-up ``a[i]``, then it evaluates ``f(x)`` and performs the "
"addition, and lastly, it writes the result back to ``a[i]``."
msgstr ""
"與普通賦值不同，增強賦值先評估左側*再評估右側。例如，``a[i] += f(x)`` "
"首先查找 ``a[i]``，然後計算 ``f(x)`` 並執行加法，最後，它將結果寫回 "
"``a[i]``。"

#: ../../reference/simple_stmts.rst:306
#, fuzzy
msgid ""
"With the exception of assigning to tuples and multiple targets in a single "
"statement, the assignment done by augmented assignment statements is handled "
"the same way as normal assignments. Similarly, with the exception of the "
"possible *in-place* behavior, the binary operation performed by augmented "
"assignment is the same as the normal binary operations."
msgstr ""
"除了在單個語句中對元組和多個目標進行賦值外，擴充賦值語句完成的賦值與普通賦值"
"的處理方式相同。類似地，除了可能的*就地*行為外，增廣賦值執行的二元運算與普通"
"二元運算相同。"

#: ../../reference/simple_stmts.rst:312
#, fuzzy
msgid ""
"For targets which are attribute references, the same :ref:`caveat about "
"class and instance attributes <attr-target-note>` applies as for regular "
"assignments."
msgstr "對於作為屬性引用的目標，關於類和實例屬性 <attr-target-note> "
"的警告同樣適用於常規分配。"

#: ../../reference/simple_stmts.rst:319
#, fuzzy
msgid "Annotated assignment statements"
msgstr "帶註釋的賦值語句"

#: ../../reference/simple_stmts.rst:326
#, fuzzy
msgid ""
":term:`Annotation <variable annotation>` assignment is the combination, in a "
"single statement, of a variable or attribute annotation and an optional "
"assignment statement:"
msgstr ":term:`Annotation <variable "
"annotation>`賦值是在單個語句中，變數或屬性註釋和可選賦值語句的組合："

#: ../../reference/simple_stmts.rst:333
#, fuzzy
msgid ""
"The difference from normal :ref:`assignment` is that only a single target is "
"allowed."
msgstr "與普通 :ref:`assignment` 的區別在於只允許一個目標。"

#: ../../reference/simple_stmts.rst:335
#, fuzzy
msgid ""
"For simple names as assignment targets, if in class or module scope, the "
"annotations are evaluated and stored in a special class or module attribute :"
"attr:`__annotations__` that is a dictionary mapping from variable names "
"(mangled if private) to evaluated annotations. This attribute is writable "
"and is automatically created at the start of class or module body execution, "
"if annotations are found statically."
msgstr ""
"對於作為賦值目標的簡單名稱，如果在類或模組範圍內，註釋將被評估並儲存在特殊的"
"類或模組屬性中 :attr:`__annotations__` 這是一個從變數名（如果私有則被破壞）到"
"評估註釋的字典映射。這個屬性是可寫的，如果註釋是靜態的，它會"
"在類或模組主體執行開始時自動建立。"

#: ../../reference/simple_stmts.rst:343
#, fuzzy
msgid ""
"For expressions as assignment targets, the annotations are evaluated if in "
"class or module scope, but not stored."
msgstr "對於作為賦值目標的表達式，如果在類或模組範圍內，註釋將被評估，但不會被儲存。"

#: ../../reference/simple_stmts.rst:346
#, fuzzy
msgid ""
"If a name is annotated in a function scope, then this name is local for that "
"scope. Annotations are never evaluated and stored in function scopes."
msgstr "如果在函式作用域中註釋了名稱，則該名稱對於該作用域是局部的。註解永遠不會被評"
"估和儲存在函式範圍內。"

#: ../../reference/simple_stmts.rst:349
#, fuzzy
msgid ""
"If the right hand side is present, an annotated assignment performs the "
"actual assignment before evaluating annotations (where applicable). If the "
"right hand side is not present for an expression target, then the "
"interpreter evaluates the target except for the last :meth:`__setitem__` or :"
"meth:`__setattr__` call."
msgstr ""
"如果右側存在，則帶註釋的賦值會在評估註釋（如果適用）之前執行實際賦值。如果表"
"達式目標的右側不存在，則直譯器會計算除最後一個 :meth:`__setitem__` 或 "
":meth:`__setattr__` 呼叫之外的目標。"

#: ../../reference/simple_stmts.rst:360
#, fuzzy
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - 變數註釋的語法"

#: ../../reference/simple_stmts.rst:358
#, fuzzy
msgid ""
"The proposal that added syntax for annotating the types of variables "
"(including class variables and instance variables), instead of expressing "
"them through comments."
msgstr "該提議增加了註釋變數型別（包括類變數和實例變數）的語法，而不是通過註釋來表達"
"它們。"

#: ../../reference/simple_stmts.rst:364
#, fuzzy
msgid ":pep:`484` - Type hints"
msgstr ":pep:`484` - 型別提示"

#: ../../reference/simple_stmts.rst:363
#, fuzzy
msgid ""
"The proposal that added the :mod:`typing` module to provide a standard "
"syntax for type annotations that can be used in static analysis tools and "
"IDEs."
msgstr "新增 :mod:`typing` 模組的提案為可用於靜態分析工具和 IDE "
"的型別註釋提供標準語法。"

#: ../../reference/simple_stmts.rst:367
#, fuzzy
msgid ""
"Now annotated assignments allow the same expressions in the right hand side "
"as regular assignments. Previously, some expressions (like un-parenthesized "
"tuple expressions) caused a syntax error."
msgstr "現在帶註釋的賦值允許在右側使用與常規賦值相同的表達式。以前，某些表達式（如未"
"加括號的元組表達式）會導致語法錯誤。"

#: ../../reference/simple_stmts.rst:376
#, fuzzy
msgid "The :keyword:`!assert` statement"
msgstr ":keyword:`!assert` 語句"

#: ../../reference/simple_stmts.rst:383
#, fuzzy
msgid ""
"Assert statements are a convenient way to insert debugging assertions into a "
"program:"
msgstr "斷言語句是將除錯斷言插入程式的便捷方式："

#: ../../reference/simple_stmts.rst:389
#, fuzzy
msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr "簡單的形式，“斷言表達式”，相當於 ::"

#: ../../reference/simple_stmts.rst:394
#, fuzzy
msgid ""
"The extended form, ``assert expression1, expression2``, is equivalent to ::"
msgstr "擴充形式 ``assert expression1, expression2`` 等價於 ::"

#: ../../reference/simple_stmts.rst:403
#, fuzzy
msgid ""
"These equivalences assume that :const:`__debug__` and :exc:`AssertionError` "
"refer to the built-in variables with those names.  In the current "
"implementation, the built-in variable :const:`__debug__` is ``True`` under "
"normal circumstances, ``False`` when optimization is requested (command line "
"option :option:`-O`).  The current code generator emits no code for an "
"assert statement when optimization is requested at compile time.  Note that "
"it is unnecessary to include the source code for the expression that failed "
"in the error message; it will be displayed as part of the stack trace."
msgstr ""
"這些等價假設 :const:`__debug__` 和 :exc:`AssertionError` "
"引用具有這些名稱的內建變數。在當前的實作中，內建變數 :const:`__debug__` "
"在正常情況下為 ``True``，在請求最佳化時為 ``False``（命令列選項 :option:`-O`"
"）。當在編譯時請求最佳化時，當前程式碼生成器不會為斷言語句發出程式碼。請注意"
"，不必在錯誤消息中包含失敗表達式的源程式碼；它將顯示為堆疊跟踪的一部分。"

#: ../../reference/simple_stmts.rst:412
#, fuzzy
msgid ""
"Assignments to :const:`__debug__` are illegal.  The value for the built-in "
"variable is determined when the interpreter starts."
msgstr "分配給 :const:`__debug__` 是非法的。內建變數的值在直譯器啟動時確定。"

#: ../../reference/simple_stmts.rst:419
#, fuzzy
msgid "The :keyword:`!pass` statement"
msgstr ":keyword:`!pass` 語句"

#: ../../reference/simple_stmts.rst:429
#, fuzzy
msgid ""
":keyword:`pass` is a null operation --- when it is executed, nothing "
"happens. It is useful as a placeholder when a statement is required "
"syntactically, but no code needs to be executed, for example::"
msgstr ":keyword:`pass` 是一個空操作——當它被執行時，沒有任何反應。當語法上需要語句但"
"不需要執行程式碼時，它可用作佔位符，例如："

#: ../../reference/simple_stmts.rst:441
#, fuzzy
msgid "The :keyword:`!del` statement"
msgstr ":keyword:`!del` 語句"

#: ../../reference/simple_stmts.rst:451
#, fuzzy
msgid ""
"Deletion is recursively defined very similar to the way assignment is "
"defined. Rather than spelling it out in full details, here are some hints."
msgstr "刪除是遞迴定義的，與定義賦值的方式非常相似。這裡沒有詳細說明，而是提供了一些"
"提示。"

#: ../../reference/simple_stmts.rst:454
#, fuzzy
msgid ""
"Deletion of a target list recursively deletes each target, from left to "
"right."
msgstr "刪除目標列表會遞迴地從左到右刪除每個目標。"

#: ../../reference/simple_stmts.rst:460
#, fuzzy
msgid ""
"Deletion of a name removes the binding of that name from the local or global "
"namespace, depending on whether the name occurs in a :keyword:`global` "
"statement in the same code block.  If the name is unbound, a :exc:"
"`NameError` exception will be raised."
msgstr ""
"刪除名稱會從本地或全局命名空間中刪除該名稱的綁定，"
"具體取決於該名稱是否出現在同一程式碼塊的 global 語句中。如果名稱未綁定，"
"則會引發 :exc:`NameError` 例外。"

#: ../../reference/simple_stmts.rst:467
#, fuzzy
msgid ""
"Deletion of attribute references, subscriptions and slicings is passed to "
"the primary object involved; deletion of a slicing is in general equivalent "
"to assignment of an empty slice of the right type (but even this is "
"determined by the sliced object)."
msgstr "屬性引用、訂閱和切片的刪除傳遞給涉及的主要物件；刪除切片通常等同於分配一個正"
"確型別的空切片（但即使這是由切片物件決定的）。"

#: ../../reference/simple_stmts.rst:472
#, fuzzy
msgid ""
"Previously it was illegal to delete a name from the local namespace if it "
"occurs as a free variable in a nested block."
msgstr "以前，如果某個名稱作為嵌套塊中的自由變數出現，則從本地命名空間中刪除該名稱是"
"非法的。"

#: ../../reference/simple_stmts.rst:480
#, fuzzy
msgid "The :keyword:`!return` statement"
msgstr ":keyword:`!return` 語句"

#: ../../reference/simple_stmts.rst:490
#, fuzzy
msgid ""
":keyword:`return` may only occur syntactically nested in a function "
"definition, not within a nested class definition."
msgstr ":keyword:`return` 只能在語法上嵌套在函式定義中，而不是在嵌套類定義中。"

#: ../../reference/simple_stmts.rst:493
#, fuzzy
msgid ""
"If an expression list is present, it is evaluated, else ``None`` is "
"substituted."
msgstr "如果存在表達式列表，則對其進行求值，否則替換為 ``None``。"

#: ../../reference/simple_stmts.rst:495
#, fuzzy
msgid ""
":keyword:`return` leaves the current function call with the expression list "
"(or ``None``) as return value."
msgstr ":keyword:`return` 將表達式列表（或 ``None``）作為回傳值保留當前函式呼叫。"

#: ../../reference/simple_stmts.rst:500
#, fuzzy
msgid ""
"When :keyword:`return` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the function."
msgstr ""
"當 :keyword:`return` 將控制從帶有 :keyword:`finally` 子句的 :keyword:`try` "
"語句傳遞出去時，:keyword:`!finally` 子句在真正離開函式之前執行。"

#: ../../reference/simple_stmts.rst:504
#, fuzzy
msgid ""
"In a generator function, the :keyword:`return` statement indicates that the "
"generator is done and will cause :exc:`StopIteration` to be raised. The "
"returned value (if any) is used as an argument to construct :exc:"
"`StopIteration` and becomes the :attr:`StopIteration.value` attribute."
msgstr ""
"在生成器函式中，:keyword:`return` "
"語句表示生成器已完成並將引發 :exc:`StopIteration`。回傳值（如果有）用作構造 "
"StopIteration 的參數，並成為 StopIteration.value 屬性。"

#: ../../reference/simple_stmts.rst:509
#, fuzzy
msgid ""
"In an asynchronous generator function, an empty :keyword:`return` statement "
"indicates that the asynchronous generator is done and will cause :exc:"
"`StopAsyncIteration` to be raised.  A non-empty :keyword:`!return` statement "
"is a syntax error in an asynchronous generator function."
msgstr ""
"在非同步生成器函式中，一個空的 :keyword:`return` "
"語句表示非同步生成器已完成並將引發 :exc:`StopAsyncIteration`。非空 "
":keyword:`!return` 語句是非同步生成器函式中的語法錯誤。"

#: ../../reference/simple_stmts.rst:517
#, fuzzy
msgid "The :keyword:`!yield` statement"
msgstr ":keyword:`!yield` 語句"

#: ../../reference/simple_stmts.rst:529
#, fuzzy
msgid ""
"A :keyword:`yield` statement is semantically equivalent to a :ref:`yield "
"expression <yieldexpr>`. The yield statement can be used to omit the "
"parentheses that would otherwise be required in the equivalent yield "
"expression statement. For example, the yield statements ::"
msgstr ""
":keyword:`yield` 語句在語義上等同於 :ref:`yield 表達式 <yieldexpr>`。 yield "
"語句可用於省略等效的 yield 表達式語句中否則需要的括號。例如，yield 語句 ::"

#: ../../reference/simple_stmts.rst:537
#, fuzzy
msgid "are equivalent to the yield expression statements ::"
msgstr "等同於 yield 表達式語句 ::"

#: ../../reference/simple_stmts.rst:542
#, fuzzy
msgid ""
"Yield expressions and statements are only used when defining a :term:"
"`generator` function, and are only used in the body of the generator "
"function.  Using yield in a function definition is sufficient to cause that "
"definition to create a generator function instead of a normal function."
msgstr ""
"Yield 表達式和語句僅在定義 :term:`generator` "
"函式時使用，並且僅在生成器函式的主體中使用。在函式定義中使用 yield "
"足以使該定義建立生成器函式而不是普通函式。"

#: ../../reference/simple_stmts.rst:547
#, fuzzy
msgid ""
"For full details of :keyword:`yield` semantics, refer to the :ref:"
"`yieldexpr` section."
msgstr "有關 :keyword:`yield` 語義的完整詳細資訊，請參閱 :ref:`yieldexpr` 部分。"

#: ../../reference/simple_stmts.rst:553
#, fuzzy
msgid "The :keyword:`!raise` statement"
msgstr ":keyword:`!raise` 語句"

#: ../../reference/simple_stmts.rst:564
#, fuzzy
msgid ""
"If no expressions are present, :keyword:`raise` re-raises the exception that "
"is currently being handled, which is also known as the *active exception*. "
"If there isn't currently an active exception, a :exc:`RuntimeError` "
"exception is raised indicating that this is an error."
msgstr ""
"如果不存在表達式，:keyword:`raise` "
"重新引發當前正在處理的例外，也稱為*活動例外*。如果當前沒有活動例外，則會引發 "
":exc:`RuntimeError` 例外，指示這是一個錯誤。"

#: ../../reference/simple_stmts.rst:569
#, fuzzy
msgid ""
"Otherwise, :keyword:`raise` evaluates the first expression as the exception "
"object.  It must be either a subclass or an instance of :class:"
"`BaseException`. If it is a class, the exception instance will be obtained "
"when needed by instantiating the class with no arguments."
msgstr ""
"否則，:keyword:`raise` 將第一個表達式計算為例外物件。它必須是 BaseException "
"的子類別或實例。如果是類，則在需要時通過不帶參數實例化該類來獲取例外實例。"

#: ../../reference/simple_stmts.rst:574
#, fuzzy
msgid ""
"The :dfn:`type` of the exception is the exception instance's class, the :dfn:"
"`value` is the instance itself."
msgstr "例外的 :dfn:`type` 是例外實例的類， :dfn:`value` 是實例本身。"

#: ../../reference/simple_stmts.rst:579
#, fuzzy
msgid ""
"A traceback object is normally created automatically when an exception is "
"raised and attached to it as the :attr:`__traceback__` attribute, which is "
"writable. You can create an exception and set your own traceback in one step "
"using the :meth:`~BaseException.with_traceback` exception method (which "
"returns the same exception instance, with its traceback set to its "
"argument), like so::"
msgstr ""
"traceback 物件通常在引發例外時自動建立，並作為 :attr:`__traceback__` "
"屬性附加到它，這是可寫的。您可以使用 :meth:`~BaseException.with_traceback` 例"
"外方法（回傳相同的例外實例，並將其回溯設定為其參數）一步建立一個例外並設定您"
"自己的回溯，如下所示："

#: ../../reference/simple_stmts.rst:591
#, fuzzy
msgid ""
"The ``from`` clause is used for exception chaining: if given, the second "
"*expression* must be another exception class or instance. If the second "
"expression is an exception instance, it will be attached to the raised "
"exception as the :attr:`__cause__` attribute (which is writable). If the "
"expression is an exception class, the class will be instantiated and the "
"resulting exception instance will be attached to the raised exception as "
"the :attr:`__cause__` attribute. If the raised exception is not handled, "
"both exceptions will be printed::"
msgstr ""
"``from`` 子句用於例外鏈接：如果給定，第二個 *expression* "
"必須是另一個例外類或實例。如果第二個表達式是例外實例，它將作為 "
":attr:`__cause__` "
"屬性（可寫）附加到引發的例外。如果表達式是一個例外類，該類將被實例化，"
"生成的例外實例將作為 :attr:`__cause__` "
"屬性附加到引發的例外。如果未處理引發的例外，則將印出兩個例外::"

#: ../../reference/simple_stmts.rst:615
#, fuzzy
msgid ""
"A similar mechanism works implicitly if a new exception is raised when an "
"exception is already being handled.  An exception may be handled when an :"
"keyword:`except` or :keyword:`finally` clause, or a :keyword:`with` "
"statement, is used.  The previous exception is then attached as the new "
"exception's :attr:`__context__` attribute::"
msgstr ""
"如果在已經處理例外時引發新例外，則類似的機制會隱式工作。當使用 "
":keyword:`except` 或 :keyword:`finally` 子句或 :keyword:`with` "
"語句時，可能會處理例外。然後將先前的例外附加為新例外的 :attr:`__context__` "
"屬性::"

#: ../../reference/simple_stmts.rst:636
#, fuzzy
msgid ""
"Exception chaining can be explicitly suppressed by specifying :const:`None` "
"in the ``from`` clause::"
msgstr "可以通過在 ``from`` 子句中指定 :const:`None` 來顯式抑制例外鏈接::"

#: ../../reference/simple_stmts.rst:648
#, fuzzy
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information about handling exceptions is in section :ref:"
"`try`."
msgstr "有關例外的更多資訊可以在 :ref:`exceptions` 部分找到，有關處理例外的資訊在 "
":ref:`try` 部分。"

#: ../../reference/simple_stmts.rst:651
#, fuzzy
msgid ":const:`None` is now permitted as ``Y`` in ``raise X from Y``."
msgstr ":const:`None` 現在允許在 ``raise X from Y`` 中作為 ``Y``。"

#: ../../reference/simple_stmts.rst:654
#, fuzzy
msgid ""
"The ``__suppress_context__`` attribute to suppress automatic display of the "
"exception context."
msgstr "``__suppress_context__`` 屬性用於抑制例外上下文的自動顯示。"

#: ../../reference/simple_stmts.rst:658
#, fuzzy
msgid ""
"If the traceback of the active exception is modified in an :keyword:`except` "
"clause, a subsequent ``raise`` statement re-raises the exception with the "
"modified traceback. Previously, the exception was re-raised with the "
"traceback it had when it was caught."
msgstr ""
"如果在 :keyword:`except` 子句中修改了活動例外的回溯，則後續的 ``raise`` "
"語句會使用修改後的回溯重新引發例外。以前，例外是通過捕獲時的回溯重新引發的。"

#: ../../reference/simple_stmts.rst:667
#, fuzzy
msgid "The :keyword:`!break` statement"
msgstr ":keyword:`!break` 語句"

#: ../../reference/simple_stmts.rst:678
#, fuzzy
msgid ""
":keyword:`break` may only occur syntactically nested in a :keyword:`for` or :"
"keyword:`while` loop, but not nested in a function or class definition "
"within that loop."
msgstr ""
":keyword:`break` 只能在語法上嵌套在 :keyword:`for` 或 :keyword:`while` "
"循環中出現，但不能嵌套在該循環內的函式或類定義中。"

#: ../../reference/simple_stmts.rst:685
#, fuzzy
msgid ""
"It terminates the nearest enclosing loop, skipping the optional :keyword:`!"
"else` clause if the loop has one."
msgstr "它終止最近的封閉循環，跳過可選的 :keyword:`!else` 子句（如果循環有的話）。"

#: ../../reference/simple_stmts.rst:688
#, fuzzy
msgid ""
"If a :keyword:`for` loop is terminated by :keyword:`break`, the loop control "
"target keeps its current value."
msgstr "如果 :keyword:`for` 循環被 :keyword:`break` "
"終止，循環控制目標將保持其當前值。"

#: ../../reference/simple_stmts.rst:693
#, fuzzy
msgid ""
"When :keyword:`break` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the loop."
msgstr ""
"當 :keyword:`break` 將控制從帶有 :keyword:`finally` 子句的 :keyword:`try` "
"語句中移出時，:keyword:`!finally` 子句在真正離開循環之前執行。"

#: ../../reference/simple_stmts.rst:701
#, fuzzy
msgid "The :keyword:`!continue` statement"
msgstr ":keyword:`!continue` 語句"

#: ../../reference/simple_stmts.rst:713
#, fuzzy
msgid ""
":keyword:`continue` may only occur syntactically nested in a :keyword:`for` "
"or :keyword:`while` loop, but not nested in a function or class definition "
"within that loop.  It continues with the next cycle of the nearest enclosing "
"loop."
msgstr ""
":keyword:`continue` 只能在語法上嵌套在 :keyword:`for` 或 :keyword:`while` 循"
"環中，但不能嵌套在該循環內的函式或類定義中。它繼續最近的封閉循環的下一個循環"
"。"

#: ../../reference/simple_stmts.rst:717
#, fuzzy
msgid ""
"When :keyword:`continue` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`!finally` clause is "
"executed before really starting the next loop cycle."
msgstr ""
"當 :keyword:`continue` 將控制從帶有 :keyword:`finally` 子句的 :keyword:`try` "
"語句移出時，該 :keyword:`!finally` 子句在真正開始下一個循環之前執行。"

#: ../../reference/simple_stmts.rst:726
#, fuzzy
msgid "The :keyword:`!import` statement"
msgstr ":keyword:`!import` 語句"

#: ../../reference/simple_stmts.rst:747
#, fuzzy
msgid ""
"The basic import statement (no :keyword:`from` clause) is executed in two "
"steps:"
msgstr "基本的導入語句（沒有 :keyword:`from` 子句）分兩步執行："

#: ../../reference/simple_stmts.rst:750
#, fuzzy
msgid "find a module, loading and initializing it if necessary"
msgstr "找到一個模組，必要時加載並初始化它"

#: ../../reference/simple_stmts.rst:751
#, fuzzy
msgid ""
"define a name or names in the local namespace for the scope where the :"
"keyword:`import` statement occurs."
msgstr "在本地命名空間中為 import 語句出現的範圍定義一個或多個名稱。"

#: ../../reference/simple_stmts.rst:754
#, fuzzy
msgid ""
"When the statement contains multiple clauses (separated by commas) the two "
"steps are carried out separately for each clause, just as though the clauses "
"had been separated out into individual import statements."
msgstr "當語句包含多個子句（以逗號分隔）時，將針對每個子句分別執行這兩個步驟，就好像"
"這些子句已被分成單獨的導入語句一樣。"

#: ../../reference/simple_stmts.rst:759
#, fuzzy
msgid ""
"The details of the first step, finding and loading modules, are described in "
"greater detail in the section on the :ref:`import system <importsystem>`, "
"which also describes the various types of packages and modules that can be "
"imported, as well as all the hooks that can be used to customize the import "
"system. Note that failures in this step may indicate either that the module "
"could not be located, *or* that an error occurred while initializing the "
"module, which includes execution of the module's code."
msgstr ""
"第一步的細節，查找和加載模組，在 :ref:`import system <importsystem>` 部分有更"
"詳細的描述，該部分還描述了可以導入的各種型別的包和模組，以及作為所有可用於自"
"定義導入系統的掛鉤。請注意，此步驟中的失敗可能表示無法找到模組，*或*初始化模"
"組時發生錯誤，其中包括執行模組程式碼。"

#: ../../reference/simple_stmts.rst:767
#, fuzzy
msgid ""
"If the requested module is retrieved successfully, it will be made available "
"in the local namespace in one of three ways:"
msgstr "如果成功檢索到請求的模組，它將通過以下三種方式之一在本地命名空間中可用："

#: ../../reference/simple_stmts.rst:772
#, fuzzy
msgid ""
"If the module name is followed by :keyword:`!as`, then the name following :"
"keyword:`!as` is bound directly to the imported module."
msgstr "如果模組名稱後跟 :keyword:`!as`，則 :keyword:`!as` "
"後的名稱直接綁定到導入的模組。"

#: ../../reference/simple_stmts.rst:774
#, fuzzy
msgid ""
"If no other name is specified, and the module being imported is a top level "
"module, the module's name is bound in the local namespace as a reference to "
"the imported module"
msgstr "如果沒有指定其他名稱，並且被導入的模組是頂級模組，模組的名稱將綁定在本地命名"
"空間中作為對導入模組的引用"

#: ../../reference/simple_stmts.rst:777
#, fuzzy
msgid ""
"If the module being imported is *not* a top level module, then the name of "
"the top level package that contains the module is bound in the local "
"namespace as a reference to the top level package. The imported module must "
"be accessed using its full qualified name rather than directly"
msgstr ""
"如果被導入的模組*不是*頂級模組，那麼包含該模組的頂級包的名稱將綁定在本地名稱"
"空間中作為對頂級包的引用。必須使用其完整限定名而不是直接訪問導入的模組"

#: ../../reference/simple_stmts.rst:787
#, fuzzy
msgid "The :keyword:`from` form uses a slightly more complex process:"
msgstr ":keyword:`from` 形式使用稍微複雜的過程："

#: ../../reference/simple_stmts.rst:789
#, fuzzy
msgid ""
"find the module specified in the :keyword:`from` clause, loading and "
"initializing it if necessary;"
msgstr "找到 :keyword:`from` 子句中指定的模組，必要時加載並初始化它；"

#: ../../reference/simple_stmts.rst:791
#, fuzzy
msgid "for each of the identifiers specified in the :keyword:`import` clauses:"
msgstr "對於 :keyword:`import` 子句中指定的每個標識符："

#: ../../reference/simple_stmts.rst:793
#, fuzzy
msgid "check if the imported module has an attribute by that name"
msgstr "檢查導入的模組是否具有該名稱的屬性"

#: ../../reference/simple_stmts.rst:794
#, fuzzy
msgid ""
"if not, attempt to import a submodule with that name and then check the "
"imported module again for that attribute"
msgstr "如果不是，則嘗試導入具有該名稱的子模組，然後再次檢查導入的模組的該屬性"

#: ../../reference/simple_stmts.rst:796
#, fuzzy
msgid "if the attribute is not found, :exc:`ImportError` is raised."
msgstr "如果未找到該屬性，則會引發 :exc:`ImportError`。"

#: ../../reference/simple_stmts.rst:797
#, fuzzy
msgid ""
"otherwise, a reference to that value is stored in the local namespace, using "
"the name in the :keyword:`!as` clause if it is present, otherwise using the "
"attribute name"
msgstr "否則，對該值的引用儲存在本地命名空間中，使用 :keyword:`!as` "
"子句中的名稱（如果存在），否則使用屬性名稱"

#: ../../reference/simple_stmts.rst:801
msgid "Examples::"
msgstr ""
"範例：\n"
"\n"
"::"

#: ../../reference/simple_stmts.rst:811
#, fuzzy
msgid ""
"If the list of identifiers is replaced by a star (``'*'``), all public names "
"defined in the module are bound in the local namespace for the scope where "
"the :keyword:`import` statement occurs."
msgstr "如果標識符列表被星號 (``'*'``) 替換，則模組中定義的所有公開名稱都綁定在 "
"import 語句出現的範圍的本地名稱空間中。"

#: ../../reference/simple_stmts.rst:817
#, fuzzy
msgid ""
"The *public names* defined by a module are determined by checking the "
"module's namespace for a variable named ``__all__``; if defined, it must be "
"a sequence of strings which are names defined or imported by that module.  "
"The names given in ``__all__`` are all considered public and are required to "
"exist.  If ``__all__`` is not defined, the set of public names includes all "
"names found in the module's namespace which do not begin with an underscore "
"character (``'_'``).  ``__all__`` should contain the entire public API. It "
"is intended to avoid accidentally exporting items that are not part of the "
"API (such as library modules which were imported and used within the module)."
msgstr ""
"模組定義的*公開名稱*是通過檢查模組的名稱空間中名為“__all__”的變數來確定的；如"
"果已定義，它必須是一系列字串，這些字串是該模組定義或導入的名稱。 ``__all__`` "
"中給出的名稱都被認為是公開的，並且必須存在。如果未定義 ``__all__``，"
"則公開名稱集包括在模組命名空間中找到的所有不以底線字元 (``'_'``) "
"開頭的名稱。 ``__all__`` 應該包含整個公開 API。它旨在避免意外導出不屬於 API "
"的項目（例如在模組中導入和使用的庫模組）。"

#: ../../reference/simple_stmts.rst:827
#, fuzzy
msgid ""
"The wild card form of import --- ``from module import *`` --- is only "
"allowed at the module level.  Attempting to use it in class or function "
"definitions will raise a :exc:`SyntaxError`."
msgstr ""
"import 的通配符形式 --- ``from module import *`` --- 只允許在模組級別使用。"
"嘗試在類或函式定義中使用它會引發 :exc:`SyntaxError`。"

#: ../../reference/simple_stmts.rst:834
#, fuzzy
msgid ""
"When specifying what module to import you do not have to specify the "
"absolute name of the module. When a module or package is contained within "
"another package it is possible to make a relative import within the same top "
"package without having to mention the package name. By using leading dots in "
"the specified module or package after :keyword:`from` you can specify how "
"high to traverse up the current package hierarchy without specifying exact "
"names. One leading dot means the current package where the module making the "
"import exists. Two dots means up one package level. Three dots is up two "
"levels, etc. So if you execute ``from . import mod`` from a module in the "
"``pkg`` package then you will end up importing ``pkg.mod``. If you execute "
"``from ..subpkg2 import mod`` from within ``pkg.subpkg1`` you will import "
"``pkg.subpkg2.mod``. The specification for relative imports is contained in "
"the :ref:`relativeimports` section."
msgstr ""
"在指定要導入的模組時，您不必指定模組的絕對名稱。當一個模組或包包含在另一個包"
"中時，可以在同一個頂級包中進行相對導入，而不必提及包名。通過在 "
":keyword:`from` 之後的指定模組或包中使用前導點，您可以指定向上遍歷當前包層次"
"結構的高度，而無需指定確切的名稱。一個前導點表示進行導入的模組所在的當前包。"
"兩個點表示向上一個封裝級別。三個點向上兩級，等等。所以如果你執行``from 。從 "
"``pkg`` 包中的模組導入 mod`` 然後你將最終導入 ``pkg.mod``。如果您從 ``pkg."
"subpkg1`` 中執行 ``from ..subpkg2 import mod``，您將導入 ``pkg.subpkg2."
"mod``。相對導入的規範包含在 :ref:`relativeimports` 部分。"

#: ../../reference/simple_stmts.rst:848
#, fuzzy
msgid ""
":func:`importlib.import_module` is provided to support applications that "
"determine dynamically the modules to be loaded."
msgstr ":func:`importlib.import_module` 用於支援動態確定要加載的模組的應用程式。"

#: ../../reference/simple_stmts.rst:851
msgid ""
"Raises an :ref:`auditing event <auditing>` ``import`` with arguments "
"``module``, ``filename``, ``sys.path``, ``sys.meta_path``, ``sys."
"path_hooks``."
msgstr ""
"引發一個附帶引數 ``module``、``filename``、``sys.path``、``sys.meta_path``、``sys."
"path_hooks`` 的\\ :ref:`稽核事件 <auditing>` ``import``。"

#: ../../reference/simple_stmts.rst:856
#, fuzzy
msgid "Future statements"
msgstr "未來陳述"

#: ../../reference/simple_stmts.rst:862
#, fuzzy
msgid ""
"A :dfn:`future statement` is a directive to the compiler that a particular "
"module should be compiled using syntax or semantics that will be available "
"in a specified future release of Python where the feature becomes standard."
msgstr ""
":dfn:`future statement` "
"是對編譯器的指令，指示特定模組應使用語法或語義進行編譯，這些語法或語義將在 "
"Python 的特定未來版本中可用，屆時該功能將成為標準。"

#: ../../reference/simple_stmts.rst:866
#, fuzzy
msgid ""
"The future statement is intended to ease migration to future versions of "
"Python that introduce incompatible changes to the language.  It allows use "
"of the new features on a per-module basis before the release in which the "
"feature becomes standard."
msgstr ""
"future 語句旨在簡化向 Python 的未來版本的遷移，這些版本引入了對該語言的不相容"
"更改。它允許在功能成為標準的發布之前基於每個模組使用新功能。"

#: ../../reference/simple_stmts.rst:878
#, fuzzy
msgid ""
"A future statement must appear near the top of the module.  The only lines "
"that can appear before a future statement are:"
msgstr "Future 語句必須出現在模組頂部附近。唯一可以出現在 future 語句之前的行是："

#: ../../reference/simple_stmts.rst:881
#, fuzzy
msgid "the module docstring (if any),"
msgstr "模組文檔字串（如果有的話），"

#: ../../reference/simple_stmts.rst:882
#, fuzzy
msgid "comments,"
msgstr "評論，"

#: ../../reference/simple_stmts.rst:883
#, fuzzy
msgid "blank lines, and"
msgstr "空行，和"

#: ../../reference/simple_stmts.rst:884
#, fuzzy
msgid "other future statements."
msgstr "其他未來陳述。"

#: ../../reference/simple_stmts.rst:886
#, fuzzy
msgid ""
"The only feature that requires using the future statement is ``annotations`` "
"(see :pep:`563`)."
msgstr "唯一需要使用 future 語句的特性是 ``annotations``（參見 :pep:`563`）。"

#: ../../reference/simple_stmts.rst:889
#, fuzzy
msgid ""
"All historical features enabled by the future statement are still recognized "
"by Python 3.  The list includes ``absolute_import``, ``division``, "
"``generators``, ``generator_stop``, ``unicode_literals``, "
"``print_function``, ``nested_scopes`` and ``with_statement``.  They are all "
"redundant because they are always enabled, and only kept for backwards "
"compatibility."
msgstr ""
"Python 3 仍然可以識別 future 語句啟用的所有歷史特性。列表包括``absolute_impor"
"t``、``division``、``generators``、``generator_stop``、``unicode_literals``、"
"`` print_function``、``nested_scopes`` 和 ``with_statement``。它們都是冗餘的"
"，因為它們始終處於啟用狀態，並且只是為了向後相容而保留。"

#: ../../reference/simple_stmts.rst:896
#, fuzzy
msgid ""
"A future statement is recognized and treated specially at compile time: "
"Changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in which "
"case the compiler may need to parse the module differently.  Such decisions "
"cannot be pushed off until runtime."
msgstr ""
"Future 語句在編譯時被識別和特殊處理：對核心結構語義的更改通常通過生成不同的程"
"式碼來實作。甚至可能是新功能引入了新的不相容語法（例如新的保留字），在這種情"
"況下，編譯器可能需要以不同方式解析模組。這樣的決定不能推遲到運行時。"

#: ../../reference/simple_stmts.rst:903
#, fuzzy
msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future statement contains a "
"feature not known to it."
msgstr "對於任何給定的版本，編譯器都知道定義了哪些功能名稱，並且如果 future "
"語句包含它不知道的功能，則會引發編譯時錯誤。"

#: ../../reference/simple_stmts.rst:907
#, fuzzy
msgid ""
"The direct runtime semantics are the same as for any import statement: there "
"is a standard module :mod:`__future__`, described later, and it will be "
"imported in the usual way at the time the future statement is executed."
msgstr ""
"直接運行時語義與任何 import 語句相同：有一個標準模組 "
":mod:`__future__`，稍後描述，它將在執行 future 語句時以通常的方式導入。"

#: ../../reference/simple_stmts.rst:911
#, fuzzy
msgid ""
"The interesting runtime semantics depend on the specific feature enabled by "
"the future statement."
msgstr "有趣的運行時語義取決於 future 語句啟用的特定功能。"

#: ../../reference/simple_stmts.rst:914
#, fuzzy
msgid "Note that there is nothing special about the statement::"
msgstr "請注意，聲明沒有什麼特別之處："

#: ../../reference/simple_stmts.rst:918
#, fuzzy
msgid ""
"That is not a future statement; it's an ordinary import statement with no "
"special semantics or syntax restrictions."
msgstr "那不是未來的陳述；這是一個普通的導入語句，沒有特殊的語義或語法限制。"

#: ../../reference/simple_stmts.rst:921
#, fuzzy
msgid ""
"Code compiled by calls to the built-in functions :func:`exec` and :func:"
"`compile` that occur in a module :mod:`M` containing a future statement "
"will, by default, use the new syntax or semantics associated with the future "
"statement.  This can be controlled by optional arguments to :func:`compile` "
"--- see the documentation of that function for details."
msgstr ""
"通過呼叫內建函式 :func:`exec` 和 :func:`compile` 編譯的程式碼出現在包含 "
"future 語句的模組 :mod:`M` "
"中，預設情況下，將使用相關的新語法或語義與未來的聲明。這可以通過 "
":func:`compile` 的可選參數來控制——有關詳細資訊，請參閱該函式的文檔。"

#: ../../reference/simple_stmts.rst:927
#, fuzzy
msgid ""
"A future statement typed at an interactive interpreter prompt will take "
"effect for the rest of the interpreter session.  If an interpreter is "
"started with the :option:`-i` option, is passed a script name to execute, "
"and the script includes a future statement, it will be in effect in the "
"interactive session started after the script is executed."
msgstr ""
"在交互式直譯器提示符下鍵入的未來語句將在直譯器會話的其餘部分生效。"
"如果直譯器以 :option:`-i` 選項啟動，傳遞一個要執行的腳本名稱，"
"並且該腳本包含一個 future 語句，它將在腳本執行後啟動的交互式會話中生效。"

#: ../../reference/simple_stmts.rst:935
#, fuzzy
msgid ":pep:`236` - Back to the __future__"
msgstr ":pep:`236` - 回到 __future__"

#: ../../reference/simple_stmts.rst:936
#, fuzzy
msgid "The original proposal for the __future__ mechanism."
msgstr "__future__ 機制的原始提案。"

#: ../../reference/simple_stmts.rst:942
#, fuzzy
msgid "The :keyword:`!global` statement"
msgstr ":keyword:`!global` 語句"

#: ../../reference/simple_stmts.rst:952
#, fuzzy
msgid ""
"The :keyword:`global` statement is a declaration which holds for the entire "
"current code block.  It means that the listed identifiers are to be "
"interpreted as globals.  It would be impossible to assign to a global "
"variable without :keyword:`!global`, although free variables may refer to "
"globals without being declared global."
msgstr ""
":keyword:`global` "
"語句是適用於整個當前程式碼塊的聲明。這意味著列出的標識符將被解釋為全局變數。"
"如果沒有 :keyword:`!global` "
"就不可能給全局變數賦值，儘管自由變數可以引用全局變數而無需聲明為全局變數。"

#: ../../reference/simple_stmts.rst:958
#, fuzzy
msgid ""
"Names listed in a :keyword:`global` statement must not be used in the same "
"code block textually preceding that :keyword:`!global` statement."
msgstr ":keyword:`global` 語句中列出的名稱不得在該 :keyword:`!global` "
"語句之前的同一程式碼塊中使用。"

#: ../../reference/simple_stmts.rst:961
#, fuzzy
msgid ""
"Names listed in a :keyword:`global` statement must not be defined as formal "
"parameters, or as targets in :keyword:`with` statements or :keyword:`except` "
"clauses, or in a :keyword:`for` target list, :keyword:`class` definition, "
"function definition, :keyword:`import` statement, or variable annotation."
msgstr ""
":keyword:`global` 語句中列出的名稱不得定義為形式參數，或定義為 :keyword:`with`"
" 語句或 :keyword:`except` 子句中的目標，或在 :keyword:`for` 目標列表中, "
":keyword:`class` 定義，函式定義， :keyword:`import` 語句，或者變數註解。"

#: ../../reference/simple_stmts.rst:968
#, fuzzy
msgid ""
"The current implementation does not enforce some of these restrictions, but "
"programs should not abuse this freedom, as future implementations may "
"enforce them or silently change the meaning of the program."
msgstr "當前的實作並沒有強制執行其中的一些限制，但是程式不應該濫用這種自由，因為未來"
"的實作可能會強制執行它們或者悄悄地改變程式的含義。"

#: ../../reference/simple_stmts.rst:977
#, fuzzy
msgid ""
"**Programmer's note:** :keyword:`global` is a directive to the parser.  It "
"applies only to code parsed at the same time as the :keyword:`!global` "
"statement. In particular, a :keyword:`!global` statement contained in a "
"string or code object supplied to the built-in :func:`exec` function does "
"not affect the code block *containing* the function call, and code contained "
"in such a string is unaffected by :keyword:`!global` statements in the code "
"containing the function call.  The same applies to the :func:`eval` and :"
"func:`compile` functions."
msgstr ""
"**程式員注意事項：** :keyword:`global` 是解析器的指令。它僅適用於與 "
":keyword:`!global` 語句同時解析的程式碼。特別是，提供給內建 :func:`exec` "
"函式的字串或程式碼對像中包含的 :keyword:`!global` "
"語句不會影響*包含*函式呼叫的程式碼塊，"
"以及包含在此類中的程式碼字串不受包含函式呼叫的程式碼中的 :keyword:`!global` "
"語句的影響。這同樣適用於 :func:`eval` 和:func:`compile` 函式。"

#: ../../reference/simple_stmts.rst:989
#, fuzzy
msgid "The :keyword:`!nonlocal` statement"
msgstr ":keyword:`!nonlocal` 語句"

#: ../../reference/simple_stmts.rst:997
#, fuzzy
msgid ""
"The :keyword:`nonlocal` statement causes the listed identifiers to refer to "
"previously bound variables in the nearest enclosing scope excluding globals. "
"This is important because the default behavior for binding is to search the "
"local namespace first.  The statement allows encapsulated code to rebind "
"variables outside of the local scope besides the global (module) scope."
msgstr ""
":keyword:`nonlocal` 語句導致列出的標識符引用最近的封閉範圍內的先前綁定變數，"
"不包括全局變數。這很重要，因為綁定的預設行為是首先搜索本地命名空間。該語句允"
"許封裝的程式碼重新綁定除全局（模組）範圍之外的局部範圍之外的變數。"

#: ../../reference/simple_stmts.rst:1003
#, fuzzy
msgid ""
"Names listed in a :keyword:`nonlocal` statement, unlike those listed in a :"
"keyword:`global` statement, must refer to pre-existing bindings in an "
"enclosing scope (the scope in which a new binding should be created cannot "
"be determined unambiguously)."
msgstr ""
":keyword:`nonlocal` 語句中列出的名稱與 :keyword:`global` 語句中列出的名稱不同"
"，必須引用封閉範圍中預先存在的綁定（無法確定應在其中建立新綁定的範圍毫不含糊"
"地）。"

#: ../../reference/simple_stmts.rst:1008
#, fuzzy
msgid ""
"Names listed in a :keyword:`nonlocal` statement must not collide with pre-"
"existing bindings in the local scope."
msgstr ":keyword:`nonlocal` 語句中列出的名稱不得與本地範圍內預先存在的綁定衝突。"

#: ../../reference/simple_stmts.rst:1013
#, fuzzy
msgid ":pep:`3104` - Access to Names in Outer Scopes"
msgstr ":pep:`3104` - 訪問外部作用域中的名稱"

#: ../../reference/simple_stmts.rst:1014
#, fuzzy
msgid "The specification for the :keyword:`nonlocal` statement."
msgstr ":keyword:`nonlocal` 語句的規範。"
