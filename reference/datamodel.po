# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-24 00:16+0000\n"
"PO-Revision-Date: 2018-05-23 16:17+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../reference/datamodel.rst:6
msgid "Data model"
msgstr "資料模型"

#: ../../reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr "物件、值和型別"

#: ../../reference/datamodel.rst:18
#, fuzzy
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer\", code is also represented by objects.)"
msgstr ""
":dfn:`Objects` 是 Python 對資料的抽象。 Python "
"程式中的所有資料都由對像或物件之間的關係表示。 "
"（從某種意義上說，根據馮·諾依曼的“儲存程式計算機”模型，程式碼也由物件表示。）"

#: ../../reference/datamodel.rst:35
#, fuzzy
msgid ""
"Every object has an identity, a type and a value.  An object's *identity* "
"never changes once it has been created; you may think of it as the object's "
"address in memory.  The ':keyword:`is`' operator compares the identity of "
"two objects; the :func:`id` function returns an integer representing its "
"identity."
msgstr ""
"每個對像都有一個標識、一個型別和一個值。物件的*身份*一旦建立就永遠不會改變；"
"你可能會認為它是對像在記憶體中的地址。 ':keyword:`is`' "
"運算符比較兩個物件的身份； :func:`id` 函式回傳一個表示其身份的整數。"

#: ../../reference/datamodel.rst:42
#, fuzzy
msgid "For CPython, ``id(x)`` is the memory address where ``x`` is stored."
msgstr "對於 CPython，``id(x)`` 是儲存 ``x`` 的記憶體地址。"

#: ../../reference/datamodel.rst:44
#, fuzzy
msgid ""
"An object's type determines the operations that the object supports (e.g., "
"\"does it have a length?\") and also defines the possible values for objects "
"of that type.  The :func:`type` function returns an object's type (which is "
"an object itself).  Like its identity, an object's :dfn:`type` is also "
"unchangeable. [#]_"
msgstr ""
"一個物件的型別決定了該物件支援的操作（例如，“它有長度嗎？”）並且還定義了該型"
"別物件的可能值。 :func:`type` "
"函式回傳物件的型別（即物件本身）。與其標識一樣，物件的 :dfn:`type` "
"也是不可更改的。 [#]_"

#: ../../reference/datamodel.rst:50
#, fuzzy
msgid ""
"The *value* of some objects can change.  Objects whose value can change are "
"said to be *mutable*; objects whose value is unchangeable once they are "
"created are called *immutable*. (The value of an immutable container object "
"that contains a reference to a mutable object can change when the latter's "
"value is changed; however the container is still considered immutable, "
"because the collection of objects it contains cannot be changed.  So, "
"immutability is not strictly the same as having an unchangeable value, it is "
"more subtle.) An object's mutability is determined by its type; for "
"instance, numbers, strings and tuples are immutable, while dictionaries and "
"lists are mutable."
msgstr ""
"一些物件的*值*可以改變。值可以改變的對像被稱為*可變*；一旦建立後其值就不可更"
"改的物件稱為*不可變*。 （包含對可變物件的引用的不可變容器物件的值可以在可變物"
"件的值更改時更改；但是容器仍然被認為是不可變的，因為它包含的物件集合不能更改"
"。因此，不可變性不是嚴格意義上的與具有不可更改的值一樣，它更微妙。）物件的可"
"變性由其型別決定；例如，數字、字串和元組是不可變的，而字典和列表是可變的。"

#: ../../reference/datamodel.rst:65
#, fuzzy
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed to "
"postpone garbage collection or omit it altogether --- it is a matter of "
"implementation quality how garbage collection is implemented, as long as no "
"objects are collected that are still reachable."
msgstr ""
"物件永遠不會被顯式銷毀；但是，當它們變得不可訪問時，它們可能會被垃圾收集。允"
"許實作推遲垃圾收集或完全忽略它——垃圾收集的實作方式是實作質量的問題，只要沒有"
"收集到仍然可訪問的物件即可。"

#: ../../reference/datamodel.rst:73
#, fuzzy
msgid ""
"CPython currently uses a reference-counting scheme with (optional) delayed "
"detection of cyclically linked garbage, which collects most objects as soon "
"as they become unreachable, but is not guaranteed to collect garbage "
"containing circular references.  See the documentation of the :mod:`gc` "
"module for information on controlling the collection of cyclic garbage. "
"Other implementations act differently and CPython may change. Do not depend "
"on immediate finalization of objects when they become unreachable (so you "
"should always close files explicitly)."
msgstr ""
"CPython 目前使用引用計數方案（可選）延遲檢測循環鏈接的垃圾，一旦對像變得不可"
"訪問，它就會收集大多數物件，但不能保證收集包含循環引用的垃圾。有關控制循環垃"
"圾收集的資訊，請參閱 :mod:`gc` 模組的文檔。其他實作的行為不同，CPython 可能會"
"改變。當對像變得不可訪問時，不要依賴於物件的立即終結（所以你應該總是明確地關"
"閉文件）。"

#: ../../reference/datamodel.rst:82
#, fuzzy
msgid ""
"Note that the use of the implementation's tracing or debugging facilities "
"may keep objects alive that would normally be collectable. Also note that "
"catching an exception with a ':keyword:`try`...\\ :keyword:`except`' "
"statement may keep objects alive."
msgstr ""
"請注意，使用實作的跟踪或除錯工具可能會使通常可收集的物件保持活動狀態。另請注"
"意，使用 ':keyword:`try`...\\ :keyword:`except`' "
"語句捕獲例外可能會使物件保持活動狀態。"

#: ../../reference/datamodel.rst:87
#, fuzzy
msgid ""
"Some objects contain references to \"external\" resources such as open files "
"or windows.  It is understood that these resources are freed when the object "
"is garbage-collected, but since garbage collection is not guaranteed to "
"happen, such objects also provide an explicit way to release the external "
"resource, usually a :meth:`close` method. Programs are strongly recommended "
"to explicitly close such objects.  The ':keyword:`try`...\\ :keyword:"
"`finally`' statement and the ':keyword:`with`' statement provide convenient "
"ways to do this."
msgstr ""
"一些物件包含對“外部”資源的引用，例如打開的文件或窗口。據了解，當對像被垃圾回"
"收時，這些資源會被釋放，但由於不能保證垃圾回收會發生，因此此類對像還提供了釋"
"放外部資源的顯式方法，通常是 :meth:`close` "
"方法。強烈建議程式顯式關閉此類物件。 ':keyword:`try`...\\ :keyword:`finally`"
"' 語句和 ':keyword:`with`' 語句提供了執行此操作的便捷方法。"

#: ../../reference/datamodel.rst:97
#, fuzzy
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries.  "
"The references are part of a container's value.  In most cases, when we talk "
"about the value of a container, we imply the values, not the identities of "
"the contained objects; however, when we talk about the mutability of a "
"container, only the identities of the immediately contained objects are "
"implied.  So, if an immutable container (like a tuple) contains a reference "
"to a mutable object, its value changes if that mutable object is changed."
msgstr ""
"一些物件包含對其他物件的引用；這些被稱為*容器*。容器的例子有元組、列表和字典"
"。引用是容器值的一部分。在大多數情況下，當我們談論容器的價值時，我們指的是價"
"值，而不是所包含物件的身份；然而，當我們談論容器的可變性時，只暗示了直接包含"
"的物件的身份。因此，如果不可變容器（如元組）包含對可變物件的引用，則它的值會"
"隨著該可變物件的更改而更改。"

#: ../../reference/datamodel.rst:106
#, fuzzy
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance of "
"object identity is affected in some sense: for immutable types, operations "
"that compute new values may actually return a reference to any existing "
"object with the same type and value, while for mutable objects this is not "
"allowed.  E.g., after ``a = 1; b = 1``, ``a`` and ``b`` may or may not refer "
"to the same object with the value one, depending on the implementation, but "
"after ``c = []; d = []``, ``c`` and ``d`` are guaranteed to refer to two "
"different, unique, newly created empty lists. (Note that ``c = d = []`` "
"assigns the same object to both ``c`` and ``d``.)"
msgstr ""
"型別幾乎影響物件行為的所有方面。甚至物件身份的重要性在某種意義上也會受到影響"
"：對於不可變型別，計算新值的操作實際上可能會回傳對具有相同型別和值的任何現有"
"物件的引用，而對於可變物件，這是不允許的。例如，在``a = 1;之後b = 1``、``a`` "
"和 ``b`` 可能指也可能不指同一個值為 1 的物件，這取決於實作，但在 ``c = [] "
"之後； d = []``、``c`` 和 ``d`` 保證引用兩個不同的、唯一的、新建立的空列表。 "
"（請注意，``c = d = []`` 將同一物件分配給 ``c`` 和 ``d``。）"

#: ../../reference/datamodel.rst:120
msgid "The standard type hierarchy"
msgstr "標準型別階層"

#: ../../reference/datamodel.rst:129
#, fuzzy
msgid ""
"Below is a list of the types that are built into Python.  Extension modules "
"(written in C, Java, or other languages, depending on the implementation) "
"can define additional types.  Future versions of Python may add types to the "
"type hierarchy (e.g., rational numbers, efficiently stored arrays of "
"integers, etc.), although such additions will often be provided via the "
"standard library instead."
msgstr ""
"下面是 Python 中內建的型別列表。擴充模組（用 C、Java "
"或其他語言編寫，具體取決於實作）可以定義其他型別。 Python 的未來版本可能會向"
"型別層次結構中新增型別（例如，有理數、有效儲存的整數數組等），儘管這些新增通"
"常會通過標準庫提供。"

#: ../../reference/datamodel.rst:140
#, fuzzy
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the implementation "
"and are not intended for general use.  Their definition may change in the "
"future."
msgstr "下面的一些型別描述包含一段列出“特殊屬性”的段落。這些是提供對實作的訪問的屬性"
"，不適合一般用途。他們的定義將來可能會改變。"

#: ../../reference/datamodel.rst:150
#, fuzzy
msgid "None"
msgstr "沒有任何"

#: ../../reference/datamodel.rst:147
#, fuzzy
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to "
"signify the absence of a value in many situations, e.g., it is returned from "
"functions that don't explicitly return anything. Its truth value is false."
msgstr ""
"此型別具有單個值。有一個具有此值的物件。通過內建名稱 ``None``訪問此物件。它在許"
"多情況下用於表示值的缺失，例如，它是從未顯式回傳任何內容的函式回傳的。它的真"
"值是假的。"

#: ../../reference/datamodel.rst:170
msgid "NotImplemented"
msgstr "NotImplemented"

#: ../../reference/datamodel.rst:155
#, fuzzy
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``NotImplemented``. "
"Numeric methods and rich comparison methods should return this value if they "
"do not implement the operation for the operands provided.  (The interpreter "
"will then try the reflected operation, or some other fallback, depending on "
"the operator.)  It should not be evaluated in a boolean context."
msgstr ""
"此型別具有單個值。有一個具有此值的物件。通過內建名稱 ``NotImplemented`` 訪問此物"
"件。如果數值方法和豐富的比較方法沒有為提供的操作數實作操作，則它們應該回傳此"
"值。 （然後直譯器將嘗試反射操作，或其他一些後備操作，具體取決於運算符。）不應"
"在布爾上下文中對其進行評估。"

#: ../../reference/datamodel.rst:162
msgid "See :ref:`implementing-the-arithmetic-operations` for more details."
msgstr "更多細節請見 :ref:`implementing-the-arithmetic-operations`\\ 。"

#: ../../reference/datamodel.rst:166
#, fuzzy
msgid ""
"Evaluating ``NotImplemented`` in a boolean context is deprecated. While it "
"currently evaluates as true, it will emit a :exc:`DeprecationWarning`. It "
"will raise a :exc:`TypeError` in a future version of Python."
msgstr ""
"在布爾上下文中評估 ``NotImplemented`` 已被棄用。雖然它當前評估為 true，"
"但它會發出一個 DeprecationWarning。它將在未來版本的 Python 中引發 "
":exc:`TypeError`。"

#: ../../reference/datamodel.rst:179
#, fuzzy
msgid "Ellipsis"
msgstr "省略"

#: ../../reference/datamodel.rst:177
#, fuzzy
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the literal ``...`` or the built-in name "
"``Ellipsis``.  Its truth value is true."
msgstr "此型別具有單個值。有一個具有此值的物件。通過文字“...”或內建名稱 ``Ellipsis`` 訪問"
"此物件。它的真值是真的。"

#: ../../reference/datamodel.rst:266
msgid ":class:`numbers.Number`"
msgstr ":class:`numbers.Number`"

#: ../../reference/datamodel.rst:184
#, fuzzy
msgid ""
"These are created by numeric literals and returned as results by arithmetic "
"operators and arithmetic built-in functions.  Numeric objects are immutable; "
"once created their value never changes.  Python numbers are of course "
"strongly related to mathematical numbers, but subject to the limitations of "
"numerical representation in computers."
msgstr ""
"它們由數字文字建立，並作為算術運算符和算術內建函式的結果回傳。數字對像是不可"
"變的；一旦創造，它們的價值就永遠不會改變。 Python "
"數字當然與數學數字密切相關，但受到計算機中數字表示的限制。"

#: ../../reference/datamodel.rst:190
#, fuzzy
msgid ""
"The string representations of the numeric classes, computed by :meth:"
"`~object.__repr__` and :meth:`~object.__str__`, have the following "
"properties:"
msgstr "由 :meth:`~object.__repr__` 和 :meth:`~object.__str__` "
"計算的數字類的字串表示具有以下屬性："

#: ../../reference/datamodel.rst:194
#, fuzzy
msgid ""
"They are valid numeric literals which, when passed to their class "
"constructor, produce an object having the value of the original numeric."
msgstr "它們是有效的數字文字，當傳遞給它們的類構造函式時，會生成一個具有原始數字值的"
"物件。"

#: ../../reference/datamodel.rst:198
#, fuzzy
msgid "The representation is in base 10, when possible."
msgstr "如果可能，表示以 10 為基數。"

#: ../../reference/datamodel.rst:200
#, fuzzy
msgid ""
"Leading zeros, possibly excepting a single zero before a decimal point, are "
"not shown."
msgstr "不顯示前導零，可能除了小數點前的單個零。"

#: ../../reference/datamodel.rst:203
#, fuzzy
msgid ""
"Trailing zeros, possibly excepting a single zero after a decimal point, are "
"not shown."
msgstr "未顯示尾隨零，可能除了小數點後的單個零。"

#: ../../reference/datamodel.rst:206
#, fuzzy
msgid "A sign is shown only when the number is negative."
msgstr "僅當數字為負時才會顯示符號。"

#: ../../reference/datamodel.rst:208
#, fuzzy
msgid ""
"Python distinguishes between integers, floating point numbers, and complex "
"numbers:"
msgstr "Python區分整數、浮點數和復數："

#: ../../reference/datamodel.rst:241
msgid ":class:`numbers.Integral`"
msgstr ":class:`numbers.Integral`"

#: ../../reference/datamodel.rst:214
#, fuzzy
msgid ""
"These represent elements from the mathematical set of integers (positive and "
"negative)."
msgstr "這些代表數學整數集（正數和負數）中的元素。"

#: ../../reference/datamodel.rst:217
#, fuzzy
msgid "There are two types of integers:"
msgstr "有兩種型別的整數："

#: ../../reference/datamodel.rst:224
#, fuzzy
msgid "Integers (:class:`int`)"
msgstr "整數（:class:`int`）"

#: ../../reference/datamodel.rst:220
#, fuzzy
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in a "
"variant of 2's complement which gives the illusion of an infinite string of "
"sign bits extending to the left."
msgstr ""
"這些表示無限範圍內的數字，僅受可用（虛擬）記憶體的限制。出於移位和掩碼操作的"
"目的，假定二進位表示，負數以 2 "
"的補碼的變體表示，這給出了向左延伸的無限符號位串的錯覺。"

#: ../../reference/datamodel.rst:236
#, fuzzy
msgid "Booleans (:class:`bool`)"
msgstr "布爾值 (:class:`bool`)"

#: ../../reference/datamodel.rst:232
#, fuzzy
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean objects. "
"The Boolean type is a subtype of the integer type, and Boolean values behave "
"like the values 0 and 1, respectively, in almost all contexts, the exception "
"being that when converted to a string, the strings ``\"False\"`` or "
"``\"True\"`` are returned, respectively."
msgstr ""
"這些代表真值 False 和 True。表示值 ``False``和 ``True``的兩個對像是唯一的布爾物件。"
"布爾型別是整數型別的子型別，布爾值在幾乎所有上下文中的行為分別類似於值 0 和 "
"1，例外情況是當轉換為字串時，字串 ``False``或“ `\"True\"`` 分別回傳。"

#: ../../reference/datamodel.rst:240
#, fuzzy
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative "
"integers."
msgstr "整數表示規則旨在對涉及負整數的移位和掩碼操作給出最有意義的解釋。"

#: ../../reference/datamodel.rst:256
msgid ":class:`numbers.Real` (:class:`float`)"
msgstr ":class:`numbers.Real` (:class:`float`)"

#: ../../reference/datamodel.rst:250
#, fuzzy
msgid ""
"These represent machine-level double precision floating point numbers. You "
"are at the mercy of the underlying machine architecture (and C or Java "
"implementation) for the accepted range and handling of overflow. Python does "
"not support single-precision floating point numbers; the savings in "
"processor and memory usage that are usually the reason for using these are "
"dwarfed by the overhead of using objects in Python, so there is no reason to "
"complicate the language with two kinds of floating point numbers."
msgstr ""
"這些表示機器級雙精度浮點數。對於可接受的範圍和溢出處理，您受制於底層機器體系"
"結構（以及 C 或 Java 實作）。 Python "
"不支援單精度浮點數；處理器和記憶體使用的節省通常是使用它們的原因，但與在 "
"Python 中使用物件的開銷相比相形見絀，因此沒有理由用兩種浮點數使語言複雜化。"

#: ../../reference/datamodel.rst:266
msgid ":class:`numbers.Complex` (:class:`complex`)"
msgstr ":class:`numbers.Complex` (:class:`complex`)"

#: ../../reference/datamodel.rst:263
#, fuzzy
msgid ""
"These represent complex numbers as a pair of machine-level double precision "
"floating point numbers.  The same caveats apply as for floating point "
"numbers. The real and imaginary parts of a complex number ``z`` can be "
"retrieved through the read-only attributes ``z.real`` and ``z.imag``."
msgstr ""
"這些將復數表示為一對機器級雙精度浮點數。同樣的警告適用於浮點數。複數 ``z`` "
"的實部和虛部可以通過只讀屬性 ``z.real`` 和 ``z.imag`` 檢索。"

#: ../../reference/datamodel.rst:383
#, fuzzy
msgid "Sequences"
msgstr "序列"

#: ../../reference/datamodel.rst:276
#, fuzzy
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers 0, "
"1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``."
msgstr ""
"這些表示由非負數索引的有限有序集。內建函式 :func:`len` "
"回傳序列的項目數。當序列的長度為*n*時，索引集包含數字0、1、...、*n*-1。序列 "
"*a* 的項目 *i* 由 ``a[i]`` 選擇。"

#: ../../reference/datamodel.rst:283
#, fuzzy
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index *k* "
"such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a slice is "
"a sequence of the same type.  This implies that the index set is renumbered "
"so that it starts at 0."
msgstr ""
"序列還支援切片：``a[i:j]`` 選擇所有索引為 *k* 的項目，這樣 *i* ``<=`` *k* "
"``<`` *j*。當用作表達式時，切片是相同型別的序列。這意味著索引集被重新編號，"
"以便它從 0 開始。"

#: ../../reference/datamodel.rst:288
#, fuzzy
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = "
"i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""
"一些序列還支援帶有第三個“步驟”參數的“擴充切片”：``a[i:j:k]`` 選擇 *a* "
"中索引為 *x* 的所有項目，其中 ``x = i + n*k ``, *n* ``>=`` ``0`` 和 *i* "
"``<=`` *x* ``<`` *j*。"

#: ../../reference/datamodel.rst:292
#, fuzzy
msgid "Sequences are distinguished according to their mutability:"
msgstr "序列根據其可變性來區分："

#: ../../reference/datamodel.rst:349
#, fuzzy
msgid "Immutable sequences"
msgstr "不可變序列"

#: ../../reference/datamodel.rst:299
#, fuzzy
msgid ""
"An object of an immutable sequence type cannot change once it is created.  "
"(If the object contains references to other objects, these other objects may "
"be mutable and may be changed; however, the collection of objects directly "
"referenced by an immutable object cannot change.)"
msgstr ""
"不可變序列型別的對像一旦建立就不能更改。 （如果物件包含對其他物件的引用，則這"
"些其他物件可能是可變的並且可能會被更改；但是，不可變物件直接引用的物件集合不"
"能更改。）"

#: ../../reference/datamodel.rst:304
#, fuzzy
msgid "The following types are immutable sequences:"
msgstr "以下型別是不可變序列："

#: ../../reference/datamodel.rst:327
msgid "Strings"
msgstr "字串 (String)"

#: ../../reference/datamodel.rst:317
#, fuzzy
msgid ""
"A string is a sequence of values that represent Unicode code points. All the "
"code points in the range ``U+0000 - U+10FFFF`` can be represented in a "
"string.  Python doesn't have a :c:expr:`char` type; instead, every code "
"point in the string is represented as a string object with length ``1``.  "
"The built-in function :func:`ord` converts a code point from its string form "
"to an integer in the range ``0 - 10FFFF``; :func:`chr` converts an integer "
"in the range ``0 - 10FFFF`` to the corresponding length ``1`` string "
"object. :meth:`str.encode` can be used to convert a :class:`str` to :class:"
"`bytes` using the given text encoding, and :meth:`bytes.decode` can be used "
"to achieve the opposite."
msgstr ""
"字串是表示 Unicode 程式碼點的值序列。 ``U+0000 - U+10FFFF`` "
"範圍內的所有程式碼點都可以用字串表示。 Python 沒有 :c:expr:`char` "
"型別；相反，字串中的每個程式碼點都表示為長度為 ``1``的字串物件。內建函式 "
":func:`ord` 將程式碼點從其字串形式轉換為範圍為 ``0 - 10FFFF`` 的整數； "
":func:`chr` 將 ``0 - 10FFFF`` 範圍內的整數轉換為相應長度的 ``1`` 字串物件。 "
":meth:`str.encode` 可用於使用給定的文本編碼將 :class:`str` 轉換為 "
":class:`bytes`，而 :meth:`bytes.decode` 可用於實作相反的效果。"

#: ../../reference/datamodel.rst:340
#, fuzzy
msgid "Tuples"
msgstr "元組"

#: ../../reference/datamodel.rst:335
#, fuzzy
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one "
"item (a 'singleton') can be formed by affixing a comma to an expression (an "
"expression by itself does not create a tuple, since parentheses must be "
"usable for grouping of expressions).  An empty tuple can be formed by an "
"empty pair of parentheses."
msgstr ""
"元組的項目是任意的 Python 物件。兩個或多個項目的元組由逗號分隔的表達式列表組"
"成。一個項目的元組（“單例”）可以通過將逗號附加到表達式來形成（表達式本身不會"
"建立元組，因為括號必須可用於表達式的分組）。空元組可以由一對空括號組成。"

#: ../../reference/datamodel.rst:349
#, fuzzy
msgid "Bytes"
msgstr "位元組"

#: ../../reference/datamodel.rst:345
#, fuzzy
msgid ""
"A bytes object is an immutable array.  The items are 8-bit bytes, "
"represented by integers in the range 0 <= x < 256.  Bytes literals (like "
"``b'abc'``) and the built-in :func:`bytes()` constructor can be used to "
"create bytes objects.  Also, bytes objects can be decoded to strings via "
"the :meth:`~bytes.decode` method."
msgstr ""
"bytes 對像是一個不可變的數組。這些項目是 8 位位元組，由 0 <= x < 256 "
"範圍內的整數表示。位元組文字（如 ``b'abc'``）和內建的 :func:`bytes()` "
"構造函式可以是用於建立位元組物件。此外，位元組物件可以通過 :meth:`~bytes."
"decode` 方法解碼為字串。"

#: ../../reference/datamodel.rst:383
#, fuzzy
msgid "Mutable sequences"
msgstr "可變序列"

#: ../../reference/datamodel.rst:359
#, fuzzy
msgid ""
"Mutable sequences can be changed after they are created.  The subscription "
"and slicing notations can be used as the target of assignment and :keyword:"
"`del` (delete) statements."
msgstr "可變序列在建立後可以更改。訂閱和切片符號可以用作賦值和 "
":keyword:`del`（刪除）語句的目標。"

#: ../../reference/datamodel.rst:363
#, fuzzy
msgid "There are currently two intrinsic mutable sequence types:"
msgstr "目前有兩種固有的可變序列型別："

#: ../../reference/datamodel.rst:370
msgid "Lists"
msgstr "List（串列）"

#: ../../reference/datamodel.rst:368
#, fuzzy
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note that "
"there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""
"列表的項目是任意的 Python "
"物件。列表是通過將逗號分隔的表達式列表放在方括號中形成的。 （請注意，"
"形成長度為 0 或 1 的列表不需要特殊情況。）"

#: ../../reference/datamodel.rst:378
#, fuzzy
msgid "Byte Arrays"
msgstr "位元組數組"

#: ../../reference/datamodel.rst:375
#, fuzzy
msgid ""
"A bytearray object is a mutable array. They are created by the built-in :"
"func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable :class:`bytes` objects."
msgstr ""
"bytearray 對像是一個可變數組。它們由內建的 :func:`bytearray` "
"構造函式建立。除了可變（因此不可散列）之外，位元組數組還提供與不可變 "
":class:`bytes` 物件相同的介面和功能。"

#: ../../reference/datamodel.rst:382
#, fuzzy
msgid ""
"The extension module :mod:`array` provides an additional example of a "
"mutable sequence type, as does the :mod:`collections` module."
msgstr "擴充模組 :mod:`array` 提供了一個可變序列型別的額外示例， :mod:`collections` "
"模組也是如此。"

#: ../../reference/datamodel.rst:417
#, fuzzy
msgid "Set types"
msgstr "集合型別"

#: ../../reference/datamodel.rst:390
#, fuzzy
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be iterated "
"over, and the built-in function :func:`len` returns the number of items in a "
"set. Common uses for sets are fast membership testing, removing duplicates "
"from a sequence, and computing mathematical operations such as intersection, "
"union, difference, and symmetric difference."
msgstr ""
"它們代表無序的、有限的、唯一的、不可變的物件集。因此，它們不能被任何下標索引"
"。但是，它們可以疊代，內建函式 :func:`len` 回傳集合中的項目數。集合的常見用途"
"是快速成員資格測試、從序列中刪除重複項以及計算交集、並集、差集和對稱差集等數"
"學運算。"

#: ../../reference/datamodel.rst:397
#, fuzzy
msgid ""
"For set elements, the same immutability rules apply as for dictionary keys. "
"Note that numeric types obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be "
"contained in a set."
msgstr ""
"對於集合元素，相同的不變性規則適用於字典鍵。請注意，數字型別遵循數字比較的一"
"般規則：如果兩個數字比較相等（例如， ``1``和“1.0”），則集合中只能包含其中一個。"

#: ../../reference/datamodel.rst:402
#, fuzzy
msgid "There are currently two intrinsic set types:"
msgstr "目前有兩種內在集合型別："

#: ../../reference/datamodel.rst:409
#, fuzzy
msgid "Sets"
msgstr "套"

#: ../../reference/datamodel.rst:407
#, fuzzy
msgid ""
"These represent a mutable set. They are created by the built-in :func:`set` "
"constructor and can be modified afterwards by several methods, such as :meth:"
"`~set.add`."
msgstr "這些代表一個可變集。它們由內建的 :func:`set` "
"構造函式建立，之後可以通過多種方法進行修改，例如 :meth:`~set.add`。"

#: ../../reference/datamodel.rst:417
#, fuzzy
msgid "Frozen sets"
msgstr "冷凍套"

#: ../../reference/datamodel.rst:414
#, fuzzy
msgid ""
"These represent an immutable set.  They are created by the built-in :func:"
"`frozenset` constructor.  As a frozenset is immutable and :term:`hashable`, "
"it can be used again as an element of another set, or as a dictionary key."
msgstr ""
"這些代表一個不可變的集合。它們由內建的 frozenset 構造函式建立。由於 "
"frozenset "
"是不可變的和可散列的，它可以再次用作另一個集合的元素，或用作字典鍵。"

#: ../../reference/datamodel.rst:464
#, fuzzy
msgid "Mappings"
msgstr "映射"

#: ../../reference/datamodel.rst:425
#, fuzzy
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. The "
"subscript notation ``a[k]`` selects the item indexed by ``k`` from the "
"mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function :func:`len` "
"returns the number of items in a mapping."
msgstr ""
"這些表示由任意索引集索引的有限物件集。下標符號“a[k]”從映射 ``a``中選擇由 ``k``索引"
"的項目； this 可以用在表達式中，也可以作為賦值或 :keyword:`del` 語句的目標。"
"內建函式 :func:`len` 回傳映射中的項目數。"

#: ../../reference/datamodel.rst:431
#, fuzzy
msgid "There is currently a single intrinsic mapping type:"
msgstr "目前只有一種內在映射型別："

#: ../../reference/datamodel.rst:464
msgid "Dictionaries"
msgstr "字典"

#: ../../reference/datamodel.rst:436
#, fuzzy
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary values.  "
"The only types of values not acceptable as keys are values containing lists "
"or dictionaries or other mutable types that are compared by value rather "
"than by object identity, the reason being that the efficient implementation "
"of dictionaries requires a key's hash value to remain constant. Numeric "
"types used for keys obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used "
"interchangeably to index the same dictionary entry."
msgstr ""
"這些表示由幾乎任意值索引的有限物件集。唯一不能作為鍵接受的值型別是包含列表或"
"字典或其他按值而不是物件標識進行比較的可變型別的值，原因是字典的有效實作需要"
"鍵的雜湊值保持不變。用於鍵的數字型別遵循數字比較的一般規則：如果兩個數字比較"
"相等（例如， ``1``和“1.0”），那麼它們可以互換使用以索引相同的字典條目。"

#: ../../reference/datamodel.rst:445
#, fuzzy
msgid ""
"Dictionaries preserve insertion order, meaning that keys will be produced in "
"the same order they were added sequentially over the dictionary. Replacing "
"an existing key does not change the order, however removing a key and re-"
"inserting it will add it to the end instead of keeping its old place."
msgstr ""
"字典保留插入順序，這意味著鍵將按照它們在字典中順序新增的相同順序生成。替換現"
"有密鑰不會更改順序，但是移除密鑰並重新插入它會將其新增到末尾，而不是保留其舊"
"位置。"

#: ../../reference/datamodel.rst:450
#, fuzzy
msgid ""
"Dictionaries are mutable; they can be created by the ``{...}`` notation (see "
"section :ref:`dict`)."
msgstr "字典是可變的；它們可以通過 ``{...}`` 符號建立（參見 :ref:`dict` 部分）。"

#: ../../reference/datamodel.rst:457
#, fuzzy
msgid ""
"The extension modules :mod:`dbm.ndbm` and :mod:`dbm.gnu` provide additional "
"examples of mapping types, as does the :mod:`collections` module."
msgstr ""
"擴充模組 :mod:`dbm.ndbm` 和 :mod:`dbm.gnu` "
"提供了映射型別的額外示例，:mod:`collections` 模組也是如此。"

#: ../../reference/datamodel.rst:461
#, fuzzy
msgid ""
"Dictionaries did not preserve insertion order in versions of Python before "
"3.6. In CPython 3.6, insertion order was preserved, but it was considered an "
"implementation detail at that time rather than a language guarantee."
msgstr ""
"字典在 3.6 之前的 Python 版本中不保留插入順序。在 CPython 3.6 "
"中，插入順序被保留，但當時它被認為是一個實作細節，而不是語言保證。"

#: ../../reference/datamodel.rst:726
#, fuzzy
msgid "Callable types"
msgstr "可呼叫型別"

#: ../../reference/datamodel.rst:473
#, fuzzy
msgid ""
"These are the types to which the function call operation (see section :ref:"
"`calls`) can be applied:"
msgstr "這些是可以應用函式呼叫操作（參見 calls 部分）的型別："

#: ../../reference/datamodel.rst:579
#, fuzzy
msgid "User-defined functions"
msgstr "使用者自定義函式"

#: ../../reference/datamodel.rst:482
#, fuzzy
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter list."
msgstr ""
"使用者定義的函式物件由函式定義建立（參見 :ref:`function` "
"部分）。應該使用包含與函式的形式參數列表相同數量的項目的參數列表呼叫它。"

#: ../../reference/datamodel.rst:487 ../../reference/datamodel.rst:841
#, fuzzy
msgid "Special attributes:"
msgstr "特殊屬性："

#: ../../reference/datamodel.rst:505
msgid "Attribute"
msgstr "屬性"

#: ../../reference/datamodel.rst:505
#, fuzzy
msgid "Meaning"
msgstr "意義"

#: ../../reference/datamodel.rst:507 ../../reference/datamodel.rst:762
#: ../../reference/datamodel.rst:857
msgid ":attr:`__doc__`"
msgstr ":attr:`__doc__`"

#: ../../reference/datamodel.rst:507
#, fuzzy
msgid ""
"The function's documentation string, or ``None`` if unavailable; not "
"inherited by subclasses."
msgstr "函式的文檔字串，如果不可用則為 ``None``；不被子類別繼承。"

#: ../../reference/datamodel.rst:507 ../../reference/datamodel.rst:512
#: ../../reference/datamodel.rst:515 ../../reference/datamodel.rst:520
#: ../../reference/datamodel.rst:524 ../../reference/datamodel.rst:530
#: ../../reference/datamodel.rst:540 ../../reference/datamodel.rst:551
#: ../../reference/datamodel.rst:561
#, fuzzy
msgid "Writable"
msgstr "可寫"

#: ../../reference/datamodel.rst:512
msgid ":attr:`~definition.\\ __name__`"
msgstr ":attr:`~definition.\\ __name__`"

#: ../../reference/datamodel.rst:512
#, fuzzy
msgid "The function's name."
msgstr "函式的名稱。"

#: ../../reference/datamodel.rst:515
msgid ":attr:`~definition.\\ __qualname__`"
msgstr ":attr:`~definition.\\ __qualname__`"

#: ../../reference/datamodel.rst:515
#, fuzzy
msgid "The function's :term:`qualified name`."
msgstr "函式的 :term:`限定名稱`。"

#: ../../reference/datamodel.rst:520 ../../reference/datamodel.rst:847
msgid ":attr:`__module__`"
msgstr ":attr:`__module__`"

#: ../../reference/datamodel.rst:520
#, fuzzy
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr "定義函式的模組的名稱，如果不可用，則為 ``None`` 。"

#: ../../reference/datamodel.rst:524
msgid ":attr:`__defaults__`"
msgstr ":attr:`__defaults__`"

#: ../../reference/datamodel.rst:524
#, fuzzy
msgid ""
"A tuple containing default argument values for those arguments that have "
"defaults, or ``None`` if no arguments have a default value."
msgstr "包含那些具有預設值的參數的預設參數值的元組，如果沒有參數具有預設值，則為“None"
"”。"

#: ../../reference/datamodel.rst:530
msgid ":attr:`__code__`"
msgstr ":attr:`__code__`"

#: ../../reference/datamodel.rst:530
#, fuzzy
msgid "The code object representing the compiled function body."
msgstr "表示已編譯函式體的程式碼物件。"

#: ../../reference/datamodel.rst:533
msgid ":attr:`__globals__`"
msgstr ":attr:`__globals__`"

#: ../../reference/datamodel.rst:533
#, fuzzy
msgid ""
"A reference to the dictionary that holds the function's global variables --- "
"the global namespace of the module in which the function was defined."
msgstr "對包含函式全局變數的字典的引用——定義函式的模組的全局命名空間。"

#: ../../reference/datamodel.rst:533 ../../reference/datamodel.rst:544
#, fuzzy
msgid "Read-only"
msgstr "只讀"

#: ../../reference/datamodel.rst:540 ../../reference/datamodel.rst:850
msgid ":attr:`~object.__dict__`"
msgstr ":attr:`~object.__dict__`"

#: ../../reference/datamodel.rst:540
#, fuzzy
msgid "The namespace supporting arbitrary function attributes."
msgstr "支援任意函式屬性的命名空間。"

#: ../../reference/datamodel.rst:544
msgid ":attr:`__closure__`"
msgstr ":attr:`__closure__`"

#: ../../reference/datamodel.rst:544
#, fuzzy
msgid ""
"``None`` or a tuple of cells that contain bindings for the function's free "
"variables. See below for information on the ``cell_contents`` attribute."
msgstr " ``None`` 或包含函式自由變數綁定的單元格元組。有關“cell_contents”屬性的資訊，請參見"
"下文。"

#: ../../reference/datamodel.rst:551 ../../reference/datamodel.rst:777
#: ../../reference/datamodel.rst:864
msgid ":attr:`__annotations__`"
msgstr ":attr:`__annotations__`"

#: ../../reference/datamodel.rst:551
#, fuzzy
msgid ""
"A dict containing annotations of parameters.  The keys of the dict are the "
"parameter names, and ``'return'`` for the return annotation, if provided.  "
"For more information on working with this attribute, see :ref:`annotations-"
"howto`."
msgstr ""
"包含參數註釋的字典。 dict 的鍵是參數名稱，回傳註解的 ``return``（如果提供的話）"
"。有關使用此屬性的更多資訊，請參閱 :ref:`annotations-howto`。"

#: ../../reference/datamodel.rst:561
msgid ":attr:`__kwdefaults__`"
msgstr ":attr:`__kwdefaults__`"

#: ../../reference/datamodel.rst:561
#, fuzzy
msgid "A dict containing defaults for keyword-only parameters."
msgstr "包含僅關鍵字參數的預設值的字典。"

#: ../../reference/datamodel.rst:565
#, fuzzy
msgid ""
"Most of the attributes labelled \"Writable\" check the type of the assigned "
"value."
msgstr "大多數標記為“可寫”的屬性檢查分配值的型別。"

#: ../../reference/datamodel.rst:567
#, fuzzy
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular "
"attribute dot-notation is used to get and set such attributes. *Note that "
"the current implementation only supports function attributes on user-defined "
"functions. Function attributes on built-in functions may be supported in the "
"future.*"
msgstr ""
"函式對像還支援獲取和設定任意屬性，例如，可以使用這些屬性將元資料附加到函式。"
"常規屬性點符號用於獲取和設定此類屬性。 *請注意，當前實作僅支援使用者定義函式"
"的函式屬性。將來可能會支援內建函式的函式屬性。*"

#: ../../reference/datamodel.rst:573
#, fuzzy
msgid ""
"A cell object has the attribute ``cell_contents``. This can be used to get "
"the value of the cell, as well as set the value."
msgstr "單元格物件具有屬性“cell_contents”。這可用於獲取單元格的值，以及設定值。"

#: ../../reference/datamodel.rst:576
#, fuzzy
msgid ""
"Additional information about a function's definition can be retrieved from "
"its code object; see the description of internal types below. The :data:"
"`cell <types.CellType>` type can be accessed in the :mod:`types` module."
msgstr ""
"可以從函式的程式碼對像中檢索有關函式定義的附加資訊；請參閱下面的內部型別的描"
"述。 :data:`cell <types.CellType>` 型別可以在 :mod:`types` 模組中訪問。"

#: ../../reference/datamodel.rst:642
#, fuzzy
msgid "Instance methods"
msgstr "實例方法"

#: ../../reference/datamodel.rst:587
#, fuzzy
msgid ""
"An instance method object combines a class, a class instance and any "
"callable object (normally a user-defined function)."
msgstr "實例方法物件結合了類、類實例和任何可呼叫物件（通常是使用者定義的函式）。"

#: ../../reference/datamodel.rst:597
#, fuzzy
msgid ""
"Special read-only attributes: :attr:`__self__` is the class instance "
"object, :attr:`__func__` is the function object; :attr:`__doc__` is the "
"method's documentation (same as ``__func__.__doc__``); :attr:`~definition."
"__name__` is the method name (same as ``__func__.__name__``); :attr:"
"`__module__` is the name of the module the method was defined in, or "
"``None`` if unavailable."
msgstr ""
"特殊只讀屬性：:attr:`__self__` 為類實例物件，:attr:`__func__` 為函式物件； "
":attr:`__doc__` 是方法的文檔（與 ``__func__.__doc__`` 相同）； "
":attr:`~definition.__name__` 是方法名（與``__func__.__name__`` 相同）； "
":attr:`__module__` 是定義該方法的模組的名稱，如果不可用則為 ``None``。"

#: ../../reference/datamodel.rst:603
#, fuzzy
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying function object."
msgstr "方法還支援訪問（但不設定）底層函式對像上的任意函式屬性。"

#: ../../reference/datamodel.rst:606
#, fuzzy
msgid ""
"User-defined method objects may be created when getting an attribute of a "
"class (perhaps via an instance of that class), if that attribute is a user-"
"defined function object or a class method object."
msgstr "如果該屬性是使用者定義的函式對像或類方法物件，則可以在獲取類的屬性（可能通過"
"該類的實例）時建立使用者定義的方法物件。"

#: ../../reference/datamodel.rst:610
#, fuzzy
msgid ""
"When an instance method object is created by retrieving a user-defined "
"function object from a class via one of its instances, its :attr:`__self__` "
"attribute is the instance, and the method object is said to be bound.  The "
"new method's :attr:`__func__` attribute is the original function object."
msgstr ""
"當通過實例之一從類中檢索使用者定義的函式物件來建立實例方法物件時，其 "
":attr:`__self__` 屬性就是實例，並且方法對像被稱為綁定。新方法的 "
":attr:`__func__` 屬性是原始函式物件。"

#: ../../reference/datamodel.rst:616
#, fuzzy
msgid ""
"When an instance method object is created by retrieving a class method "
"object from a class or instance, its :attr:`__self__` attribute is the class "
"itself, and its :attr:`__func__` attribute is the function object underlying "
"the class method."
msgstr ""
"當通過從類或實例中檢索類方法物件來建立實例方法物件時，其 :attr:`__self__` "
"屬性是類本身，其 :attr:`__func__` 屬性是類方法下的函式物件。"

#: ../../reference/datamodel.rst:621
#, fuzzy
msgid ""
"When an instance method object is called, the underlying function (:attr:"
"`__func__`) is called, inserting the class instance (:attr:`__self__`) in "
"front of the argument list.  For instance, when :class:`C` is a class which "
"contains a definition for a function :meth:`f`, and ``x`` is an instance of :"
"class:`C`, calling ``x.f(1)`` is equivalent to calling ``C.f(x, 1)``."
msgstr ""
"當一個實例方法對像被呼叫時，底層函式 (:attr:`__func__`) 被呼叫，"
"在參數列表前面插入類實例 (:attr:`__self__`)。例如，當 C 是一個包含函式 f "
"定義的類，而 x 是 C 的實例時，呼叫 x.f(1 )`` 相當於呼叫 ``C.f(x, 1)``。"

#: ../../reference/datamodel.rst:628
#, fuzzy
msgid ""
"When an instance method object is derived from a class method object, the "
"\"class instance\" stored in :attr:`__self__` will actually be the class "
"itself, so that calling either ``x.f(1)`` or ``C.f(1)`` is equivalent to "
"calling ``f(C,1)`` where ``f`` is the underlying function."
msgstr ""
"當實例方法物件派生自類方法物件時，儲存在 :attr:`__self__` "
"中的“類實例”實際上將是類本身，因此呼叫 ``x.f(1)`` 或 ``C.f( 1)`` "
"相當於呼叫``f(C,1)`` 其中``f`` 是底層函式。"

#: ../../reference/datamodel.rst:633
#, fuzzy
msgid ""
"Note that the transformation from function object to instance method object "
"happens each time the attribute is retrieved from the instance.  In some "
"cases, a fruitful optimization is to assign the attribute to a local "
"variable and call that local variable. Also notice that this transformation "
"only happens for user-defined functions; other callable objects (and all non-"
"callable objects) are retrieved without transformation.  It is also "
"important to note that user-defined functions which are attributes of a "
"class instance are not converted to bound methods; this *only* happens when "
"the function is an attribute of the class."
msgstr ""
"請注意，每次從實例中檢索屬性時，都會發生從函式對像到實例方法物件的轉換。在某"
"些情況下，富有成效的最佳化是將屬性分配給局部變數並呼叫該局部變數。另請注意，"
"此轉換僅發生在使用者定義的函式中；其他可呼叫物件（以及所有不可呼叫物件）無需"
"轉換即可檢索。同樣重要的是要注意，作為類實例屬性的使用者定義函式不會轉換為綁"
"定方法；這*僅*在函式是類的屬性時發生。"

#: ../../reference/datamodel.rst:657
#, fuzzy
msgid "Generator functions"
msgstr "生成器函式"

#: ../../reference/datamodel.rst:649
#, fuzzy
msgid ""
"A function or method which uses the :keyword:`yield` statement (see section :"
"ref:`yield`) is called a :dfn:`generator function`.  Such a function, when "
"called, always returns an :term:`iterator` object which can be used to "
"execute the body of the function:  calling the iterator's :meth:`iterator."
"__next__` method will cause the function to execute until it provides a "
"value using the :keyword:`!yield` statement.  When the function executes a :"
"keyword:`return` statement or falls off the end, a :exc:`StopIteration` "
"exception is raised and the iterator will have reached the end of the set of "
"values to be returned."
msgstr ""
"使用 :keyword:`yield` 語句（參見 :ref:`yield` 部分）的函式或方法稱為 :dfn:`"
"generator function`。這樣的函式在呼叫時總是回傳一個疊代器物件，該物件可用於執"
"行函式體：呼叫疊代器的疊代器方法將導致函式執行，直到它提供使用 "
":keyword:`!yield` 語句的值。當函式執行 :keyword:`return` "
"語句或從末尾掉落時，將引發 :exc:`StopIteration` "
"例外，並且疊代器將到達要回傳的值集的末尾。"

#: ../../reference/datamodel.rst:667
#, fuzzy
msgid "Coroutine functions"
msgstr "協程函式"

#: ../../reference/datamodel.rst:663
#, fuzzy
msgid ""
"A function or method which is defined using :keyword:`async def` is called "
"a :dfn:`coroutine function`.  Such a function, when called, returns a :term:"
"`coroutine` object.  It may contain :keyword:`await` expressions, as well "
"as :keyword:`async with` and :keyword:`async for` statements. See also the :"
"ref:`coroutine-objects` section."
msgstr ""
"使用 :keyword:`async def` 定義的函式或方法稱為 :dfn:`coroutine function`。"
"這樣的函式在呼叫時回傳一個 :term:`coroutine` 物件。它可能包含 "
":keyword:`await` 表達式，以及 :keyword:`async with` 和 :keyword:`async for` "
"語句。另見 :ref:`coroutine-objects` 部分。"

#: ../../reference/datamodel.rst:687
#, fuzzy
msgid "Asynchronous generator functions"
msgstr "非同步生成器函式"

#: ../../reference/datamodel.rst:674
#, fuzzy
msgid ""
"A function or method which is defined using :keyword:`async def` and which "
"uses the :keyword:`yield` statement is called a :dfn:`asynchronous generator "
"function`.  Such a function, when called, returns an :term:`asynchronous "
"iterator` object which can be used in an :keyword:`async for` statement to "
"execute the body of the function."
msgstr ""
"使用 :keyword:`async def` 定義並使用 :keyword:`yield` 語句的函式或方法稱為 "
":dfn:`非同步生成器函式`。這樣的函式在呼叫時會回傳一個非同步疊代器物件，"
"該物件可在非同步 for 語句中使用以執行函式體。"

#: ../../reference/datamodel.rst:680
#, fuzzy
msgid ""
"Calling the asynchronous iterator's :meth:`aiterator.__anext__ <object."
"__anext__>` method will return an :term:`awaitable` which when awaited will "
"execute until it provides a value using the :keyword:`yield` expression.  "
"When the function executes an empty :keyword:`return` statement or falls off "
"the end, a :exc:`StopAsyncIteration` exception is raised and the "
"asynchronous iterator will have reached the end of the set of values to be "
"yielded."
msgstr ""
"呼叫非同步疊代器的 aiterator.__anext__ <object.__anext__> 方法將回傳一個 "
"awaitable ，它在等待時將執行，直到它使用 yield "
"表達式提供一個值。當函式執行一個空的 :keyword:`return` "
"語句或結束時，將引發一個 :exc:`StopAsyncIteration` "
"例外，並且非同步疊代器將到達要產生的值集的末尾。"

#: ../../reference/datamodel.rst:702
#, fuzzy
msgid "Built-in functions"
msgstr "內建函式"

#: ../../reference/datamodel.rst:695
#, fuzzy
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of "
"built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a "
"standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes: :attr:`__doc__` "
"is the function's documentation string, or ``None`` if unavailable; :attr:"
"`~definition.__name__` is the function's name; :attr:`__self__` is set to "
"``None`` (but see the next item); :attr:`__module__` is the name of the "
"module the function was defined in or ``None`` if unavailable."
msgstr ""
"內建函式對像是 C 函式的包裝器。內建函式的示例是 :func:`len` 和 :func:`math."
"sin`（:mod:`math` 是一個標準的內建模組）。參數的數量和型別由 C "
"函式確定。特殊的只讀屬性：:attr:`__doc__` 是函式的文檔字串，如果不可用則為 "
"``None``； :attr:`~definition.__name__` 是函式的名稱； :attr:`__self__` "
"設定為 ``None``（但請參閱下一項）； :attr:`__module__` "
"是定義函式的模組的名稱，如果不可用則為 ``None``。"

#: ../../reference/datamodel.rst:714
#, fuzzy
msgid "Built-in methods"
msgstr "內建方法"

#: ../../reference/datamodel.rst:710
#, fuzzy
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra "
"argument.  An example of a built-in method is ``alist.append()``, assuming "
"*alist* is a list object. In this case, the special read-only attribute :"
"attr:`__self__` is set to the object denoted by *alist*."
msgstr ""
"這實際上是內建函式的另一種偽裝，這次包含一個作為隱式額外參數傳遞給 C "
"函式的物件。一個內建方法的例子是``alist.append()``，假設*alist* "
"是一個列表物件。在這種情況下，特殊的只讀屬性 :attr:`__self__` 被設定為 "
"*alist* 表示的物件。"

#: ../../reference/datamodel.rst:721
#, fuzzy
msgid "Classes"
msgstr "班級"

#: ../../reference/datamodel.rst:717
#, fuzzy
msgid ""
"Classes are callable.  These objects normally act as factories for new "
"instances of themselves, but variations are possible for class types that "
"override :meth:`~object.__new__`.  The arguments of the call are passed to :"
"meth:`__new__` and, in the typical case, to :meth:`~object.__init__` to "
"initialize the new instance."
msgstr ""
"類是可呼叫的。這些物件通常充當它們自身新實例的工廠，但對於覆蓋 :meth:`~object"
".__new__` 的類型別來說，變化是可能的。呼叫的參數被傳遞給 :meth:`__new__` "
"，在典型情況下，傳遞給 :meth:`~object.__init__` 來初始化新實例。"

#: ../../reference/datamodel.rst:726
#, fuzzy
msgid "Class Instances"
msgstr "類實例"

#: ../../reference/datamodel.rst:724
#, fuzzy
msgid ""
"Instances of arbitrary classes can be made callable by defining a :meth:"
"`~object.__call__` method in their class."
msgstr "通過在類中定義一個 :meth:`~object.__call__` 方法，可以使任意類的實例可呼叫。"

#: ../../reference/datamodel.rst:789
msgid "Modules"
msgstr "模組"

#: ../../reference/datamodel.rst:733
#, fuzzy
msgid ""
"Modules are a basic organizational unit of Python code, and are created by "
"the :ref:`import system <importsystem>` as invoked either by the :keyword:"
"`import` statement, or by calling functions such as :func:`importlib."
"import_module` and built-in :func:`__import__`.  A module object has a "
"namespace implemented by a dictionary object (this is the dictionary "
"referenced by the ``__globals__`` attribute of functions defined in the "
"module).  Attribute references are translated to lookups in this dictionary, "
"e.g., ``m.x`` is equivalent to ``m.__dict__[\"x\"]``. A module object does "
"not contain the code object used to initialize the module (since it isn't "
"needed once the initialization is done)."
msgstr ""
"模組是 Python 程式碼的基本組織單元，由 :ref:`import 系統 <importsystem>` "
"建立，由 :keyword:`import` 語句或呼叫 :func:`importlib 等函式呼叫。 "
"import_module` 和內建的 "
":func:`__import__`。模組對像有一個由字典物件實作的命名空間（"
"這是模組中定義的函式的 ``__globals__`` "
"屬性引用的字典）。屬性引用被翻譯成這個字典中的查找，例如，``m.x`` 等同於``m."
"__dict__[\"x\"]``。模組對像不包含用於初始化模組的程式碼物件（因為一旦初始化完"
"成就不需要它）。"

#: ../../reference/datamodel.rst:745
#, fuzzy
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., ``m.x "
"= 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr "屬性賦值更新模組的命名空間字典，例如，``m.x = 1`` 等同於``m.__dict__[\"x\"] "
"= 1``。"

#: ../../reference/datamodel.rst:755
#, fuzzy
msgid "Predefined (writable) attributes:"
msgstr "預定義（可寫）屬性："

#: ../../reference/datamodel.rst:758
msgid ":attr:`__name__`"
msgstr ":attr:`__name__`"

#: ../../reference/datamodel.rst:758
#, fuzzy
msgid "The module's name."
msgstr "模組的名稱。"

#: ../../reference/datamodel.rst:761
#, fuzzy
msgid "The module's documentation string, or ``None`` if unavailable."
msgstr "模組的文檔字串，如果不可用則為 ``None``。"

#: ../../reference/datamodel.rst:771
msgid ":attr:`__file__`"
msgstr ":attr:`__file__`"

#: ../../reference/datamodel.rst:765
#, fuzzy
msgid ""
"The pathname of the file from which the module was loaded, if it was loaded "
"from a file. The :attr:`__file__` attribute may be missing for certain types "
"of modules, such as C modules that are statically linked into the "
"interpreter.  For extension modules loaded dynamically from a shared "
"library, it's the pathname of the shared library file."
msgstr ""
"如果模組是從文件加載的，則為從中加載模組的文件的路徑名。"
"某些型別的模組可能缺少 :attr:`__file__` 屬性，例如靜態鏈接到直譯器的 C "
"模組。對於從共享庫動態加載的擴充模組，它是共享庫文件的路徑名。"

#: ../../reference/datamodel.rst:774
#, fuzzy
msgid ""
"A dictionary containing :term:`variable annotations <variable annotation>` "
"collected during module body execution.  For best practices on working with :"
"attr:`__annotations__`, please see :ref:`annotations-howto`."
msgstr ""
"包含在模組主體執行期間收集的 :term:`變數註釋 <variable annotation>` 的字典。"
"有關使用 :attr:`__annotations__` 的最佳實踐，請參閱 :ref:`annotations-"
"howto`。"

#: ../../reference/datamodel.rst:781
#, fuzzy
msgid ""
"Special read-only attribute: :attr:`~object.__dict__` is the module's "
"namespace as a dictionary object."
msgstr "特殊的只讀屬性：:attr:`~object.__dict__` 是作為字典物件的模組命名空間。"

#: ../../reference/datamodel.rst:786
#, fuzzy
msgid ""
"Because of the way CPython clears module dictionaries, the module dictionary "
"will be cleared when the module falls out of scope even if the dictionary "
"still has live references.  To avoid this, copy the dictionary or keep the "
"module around while using its dictionary directly."
msgstr ""
"由於 CPython 清除模組字典的方式，當模組超出範圍時，即使字典仍然有活動引用，模"
"組字典也會被清除。為避免這種情況，請複製字典或在直接使用字典時保留模組。"

#: ../../reference/datamodel.rst:864
#, fuzzy
msgid "Custom classes"
msgstr "自定義類"

#: ../../reference/datamodel.rst:792
#, fuzzy
msgid ""
"Custom class types are typically created by class definitions (see section :"
"ref:`class`).  A class has a namespace implemented by a dictionary object. "
"Class attribute references are translated to lookups in this dictionary, e."
"g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` (although there are a "
"number of hooks which allow for other means of locating attributes). When "
"the attribute name is not found there, the attribute search continues in the "
"base classes. This search of the base classes uses the C3 method resolution "
"order which behaves correctly even in the presence of 'diamond' inheritance "
"structures where there are multiple inheritance paths leading back to a "
"common ancestor. Additional details on the C3 MRO used by Python can be "
"found in the documentation accompanying the 2.3 release at https://www."
"python.org/download/releases/2.3/mro/."
msgstr ""
"自定義類型別通常由類定義建立（請參閱 :ref:`class` 部分）。一個類有一個由字典"
"物件實作的命名空間。類屬性引用被翻譯成這個字典中的查找，例如，``C.x`` "
"被翻譯成``C.__dict__[\"x\"]``（儘管有許多掛鉤允許使用其他方法定位屬性） ."
"當在那裡找不到屬性名稱時，將在基底類別中繼續搜索屬性。"
"這種對基底類別的搜索使用 C3 方法解析順序，即使存在“菱形”繼承結構也能正確運行"
"，其中有多個繼承路徑通向一個共同的祖先。有關 Python 使用的 C3 MRO "
"的更多詳細資訊，請參閱 2.3 版本隨附的文檔，網址為 https://www.python.org/"
"download/releases/2.3/mro/。"

#: ../../reference/datamodel.rst:816
#, fuzzy
msgid ""
"When a class attribute reference (for class :class:`C`, say) would yield a "
"class method object, it is transformed into an instance method object whose :"
"attr:`__self__` attribute is :class:`C`.  When it would yield a static "
"method object, it is transformed into the object wrapped by the static "
"method object. See section :ref:`descriptors` for another way in which "
"attributes retrieved from a class may differ from those actually contained "
"in its :attr:`~object.__dict__`."
msgstr ""
"當一個類屬性引用（例如，對於 "
"class :class:`C`）將產生一個類方法物件時，它被轉換成一個實例方法物件，其 "
":attr:`__self__` 屬性是 "
":class:`C`。當它會產生一個靜態方法物件時，它被轉換成靜態方法物件包裝的物件。"
"請參閱 :ref:`descriptors` 部分了解從類中檢索到的屬性可能與實際包含在其 "
":attr:`~object.__dict__` 中的屬性不同的另一種方式。"

#: ../../reference/datamodel.rst:826
#, fuzzy
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr "類屬性賦值更新類的字典，而不是基底類別的字典。"

#: ../../reference/datamodel.rst:831
#, fuzzy
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr "可以呼叫類物件（見上文）以生成類實例（見下文）。"

#: ../../reference/datamodel.rst:844
msgid ":attr:`~definition.__name__`"
msgstr ":attr:`~definition.__name__`"

#: ../../reference/datamodel.rst:844
#, fuzzy
msgid "The class name."
msgstr "類名。"

#: ../../reference/datamodel.rst:847
#, fuzzy
msgid "The name of the module in which the class was defined."
msgstr "在其中定義類的模組的名稱。"

#: ../../reference/datamodel.rst:850
#, fuzzy
msgid "The dictionary containing the class's namespace."
msgstr "包含類的命名空間的字典。"

#: ../../reference/datamodel.rst:854
msgid ":attr:`~class.__bases__`"
msgstr ":attr:`~class.__bases__`"

#: ../../reference/datamodel.rst:853
#, fuzzy
msgid ""
"A tuple containing the base classes, in the order of their occurrence in the "
"base class list."
msgstr "包含基底類別的元組，按照它們在基底類別列表中出現的順序排列。"

#: ../../reference/datamodel.rst:857
#, fuzzy
msgid "The class's documentation string, or ``None`` if undefined."
msgstr "該類的文檔字串，如果未定義則為 ``None`` 。"

#: ../../reference/datamodel.rst:860
#, fuzzy
msgid ""
"A dictionary containing :term:`variable annotations <variable annotation>` "
"collected during class body execution.  For best practices on working with :"
"attr:`__annotations__`, please see :ref:`annotations-howto`."
msgstr ""
"包含 :term:`variable annotations <variable annotation>` "
"在類主體執行期間收集的字典。有關使用 :attr:`__annotations__` 的最佳實踐，"
"請參閱 :ref:`annotations-howto`。"

#: ../../reference/datamodel.rst:907
#, fuzzy
msgid "Class instances"
msgstr "類實例"

#: ../../reference/datamodel.rst:873
#, fuzzy
msgid ""
"A class instance is created by calling a class object (see above).  A class "
"instance has a namespace implemented as a dictionary which is the first "
"place in which attribute references are searched.  When an attribute is not "
"found there, and the instance's class has an attribute by that name, the "
"search continues with the class attributes.  If a class attribute is found "
"that is a user-defined function object, it is transformed into an instance "
"method object whose :attr:`__self__` attribute is the instance.  Static "
"method and class method objects are also transformed; see above under "
"\"Classes\".  See section :ref:`descriptors` for another way in which "
"attributes of a class retrieved via its instances may differ from the "
"objects actually stored in the class's :attr:`~object.__dict__`.  If no "
"class attribute is found, and the object's class has a :meth:`~object."
"__getattr__` method, that is called to satisfy the lookup."
msgstr ""
"類實例是通過呼叫類物件建立的（見上文）。類實例有一個作為字典實作的命名空間，"
"它是搜索屬性引用的第一個地方。如果在那裡找不到屬性，並且實例的類具有該名稱的"
"屬性，則繼續搜索類屬性。如果發現類屬性是使用者定義的函式物件，則將其轉換為實"
"例方法物件，其 :attr:`__self__` "
"屬性為實例。靜態方法和類方法對像也進行了轉換；見上文 ``類``。請參閱 "
":ref:`descriptors` 部分了解另一種方式，"
"其中通過其實例檢索的類的屬性可能與實際儲存在類的 :attr:`~object.__dict__` "
"中的對像不同。如果沒有找到類屬性，並且物件的類有一個 :meth:`~object."
"__getattr__` 方法，呼叫它來滿足查找。"

#: ../../reference/datamodel.rst:889
#, fuzzy
msgid ""
"Attribute assignments and deletions update the instance's dictionary, never "
"a class's dictionary.  If the class has a :meth:`~object.__setattr__` or :"
"meth:`~object.__delattr__` method, this is called instead of updating the "
"instance dictionary directly."
msgstr ""
"屬性賦值和刪除更新實例的字典，而不是類的字典。如果類有 :meth:`~object."
"__setattr__` 或 :meth:`~object.__delattr__` "
"方法，則呼叫它而不是直接更新實例字典。"

#: ../../reference/datamodel.rst:899
#, fuzzy
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they "
"have methods with certain special names.  See section :ref:`specialnames`."
msgstr "如果類實例具有具有特定名稱的方法，則它們可以偽裝成數字、序列或映射。請參閱 "
":ref:`specialnames` 部分。"

#: ../../reference/datamodel.rst:906
#, fuzzy
msgid ""
"Special attributes: :attr:`~object.__dict__` is the attribute dictionary; :"
"attr:`~instance.__class__` is the instance's class."
msgstr "特殊屬性：:attr:`~object.__dict__` 是屬性字典； :attr:`~instance.__class__` "
"是實例的類。"

#: ../../reference/datamodel.rst:933
#, fuzzy
msgid "I/O objects (also known as file objects)"
msgstr "I/O 物件（也稱為文件物件）"

#: ../../reference/datamodel.rst:923
#, fuzzy
msgid ""
"A :term:`file object` represents an open file.  Various shortcuts are "
"available to create file objects: the :func:`open` built-in function, and "
"also :func:`os.popen`, :func:`os.fdopen`, and the :meth:`~socket.socket."
"makefile` method of socket objects (and perhaps by other functions or "
"methods provided by extension modules)."
msgstr ""
":term:`file object` "
"代表一個打開的文件。有多種快捷方式可用於建立文件物件：:func:`open` "
"內建函式，以及 :func:`os.popen`、:func:`os.fdopen` 和 :meth:`~socket。"
" socket 物件的 socket.makefile` "
"方法（以及可能由擴充模組提供的其他函式或方法）。"

#: ../../reference/datamodel.rst:929
#, fuzzy
msgid ""
"The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized "
"to file objects corresponding to the interpreter's standard input, output "
"and error streams; they are all open in text mode and therefore follow the "
"interface defined by the :class:`io.TextIOBase` abstract class."
msgstr ""
"物件“sys.stdin”、“sys.stdout”和“sys.stderr”被初始化為對應於直譯器的標準輸入、"
"輸出和錯誤流的文件物件；它們都以文本模式打開，因此遵循 io.TextIOBase "
"抽像類定義的介面。"

#: ../../reference/datamodel.rst:1220
#, fuzzy
msgid "Internal types"
msgstr "內部型別"

#: ../../reference/datamodel.rst:940
#, fuzzy
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but "
"they are mentioned here for completeness."
msgstr "直譯器內部使用的一些型別暴露給使用者。它們的定義可能會隨著直譯器的未來版本而"
"改變，但為了完整起見，在此提及它們。"

#: ../../reference/datamodel.rst:1050
#, fuzzy
msgid "Code objects"
msgstr "程式碼物件"

#: ../../reference/datamodel.rst:947
#, fuzzy
msgid ""
"Code objects represent *byte-compiled* executable Python code, or :term:"
"`bytecode`. The difference between a code object and a function object is "
"that the function object contains an explicit reference to the function's "
"globals (the module in which it was defined), while a code object contains "
"no context; also the default argument values are stored in the function "
"object, not in the code object (because they represent values calculated at "
"run-time).  Unlike function objects, code objects are immutable and contain "
"no references (directly or indirectly) to mutable objects."
msgstr ""
"程式碼物件表示 *位元組編譯* 可執行 Python 程式碼，或 :term:`位元組碼`。程式"
"碼物件和函式物件之間的區別在於，函式物件包含對函式全局變數（定義它的模組）的"
"顯式引用，而程式碼對像不包含上下文；預設參數值也儲存在函式對像中，而不是程式"
"碼對像中（因為它們表示在運行時計算的值）。與函式對像不同，程式碼對像是不可變"
"的，不包含（直接或間接）對可變物件的引用。"

#: ../../reference/datamodel.rst:975
#, fuzzy
msgid ""
"Special read-only attributes: :attr:`co_name` gives the function name; :attr:"
"`co_qualname` gives the fully qualified function name; :attr:`co_argcount` "
"is the total number of positional arguments (including positional-only "
"arguments and arguments with default values); :attr:`co_posonlyargcount` is "
"the number of positional-only arguments (including arguments with default "
"values); :attr:`co_kwonlyargcount` is the number of keyword-only arguments "
"(including arguments with default values); :attr:`co_nlocals` is the number "
"of local variables used by the function (including arguments); :attr:"
"`co_varnames` is a tuple containing the names of the local variables "
"(starting with the argument names); :attr:`co_cellvars` is a tuple "
"containing the names of local variables that are referenced by nested "
"functions; :attr:`co_freevars` is a tuple containing the names of free "
"variables; :attr:`co_code` is a string representing the sequence of bytecode "
"instructions; :attr:`co_consts` is a tuple containing the literals used by "
"the bytecode; :attr:`co_names` is a tuple containing the names used by the "
"bytecode; :attr:`co_filename` is the filename from which the code was "
"compiled; :attr:`co_firstlineno` is the first line number of the function; :"
"attr:`co_lnotab` is a string encoding the mapping from bytecode offsets to "
"line numbers (for details see the source code of the interpreter); :attr:"
"`co_stacksize` is the required stack size; :attr:`co_flags` is an integer "
"encoding a number of flags for the interpreter."
msgstr ""
"特殊的只讀屬性：:attr:`co_name` 給出函式名； :attr:`co_qualname` "
"給出完全限定的函式名； :attr:`co_argcount` "
"是位置參數的總數（包括僅位置參數和具有預設值的參數）； "
":attr:`co_posonlyargcount` 是僅位置參數的數量（包括具有預設值的參數）； "
":attr:`co_kwonlyargcount` 是僅關鍵字參數的數量（包括具有預設值的參數）； "
":attr:`co_nlocals` 是函式使用的局部變數的數量（包括參數）； "
":attr:`co_varnames` 是一個包含局部變數名稱的元組（以參數名稱開頭）； "
":attr:`co_cellvars` 是一個元組，包含嵌套函式引用的局部變數的名稱； "
":attr:`co_freevars` 是一個包含自由變數名稱的元組； :attr:`co_code` "
"是表示位元組碼指令序列的字串； :attr:`co_consts` "
"是一個包含位元組碼使用的文字的元組； :attr:`co_names` "
"是一個包含位元組碼使用的名稱的元組； :attr:`co_filename` "
"是編譯程式碼的文件名； :attr:`co_firstlineno` 是函式的第一行號； "
":attr:`co_lnotab` "
"是一個字串，編碼從位元組碼偏移量到行號的映射（詳見直譯器的源程式碼）； "
":attr:`co_stacksize` 是所需的堆疊大小； :attr:`co_flags` "
"是一個整數，為直譯器編碼了一些旗標。"

#: ../../reference/datamodel.rst:1000
#, fuzzy
msgid ""
"The following flag bits are defined for :attr:`co_flags`: bit ``0x04`` is "
"set if the function uses the ``*arguments`` syntax to accept an arbitrary "
"number of positional arguments; bit ``0x08`` is set if the function uses the "
"``**keywords`` syntax to accept arbitrary keyword arguments; bit ``0x20`` is "
"set if the function is a generator."
msgstr ""
"為 :attr:`co_flags 定義了以下旗標位：如果函式使用 ``*arguments`` "
"語法接受任意數量的位置參數，則設定位 ``0x04``；如果函式使用“**關鍵字”語法接受"
"任意關鍵字參數，則設定位 ``0x08``；如果函式是生成器，則設定位 ``0x20``。"

#: ../../reference/datamodel.rst:1006
#, fuzzy
msgid ""
"Future feature declarations (``from __future__ import division``) also use "
"bits in :attr:`co_flags` to indicate whether a code object was compiled with "
"a particular feature enabled: bit ``0x2000`` is set if the function was "
"compiled with future division enabled; bits ``0x10`` and ``0x1000`` were "
"used in earlier versions of Python."
msgstr ""
"未來功能聲明（``from __future__ import division``）也使用 co_flags "
"中的位來指示程式碼對像是否在啟用特定功能的情況下編譯：如果函式被編譯，位 "
"``0x2000`` 被設定啟用未來劃分；位 ``0x10``和 ``0x1000``在早期版本的 Python 中使用。"

#: ../../reference/datamodel.rst:1012
#, fuzzy
msgid "Other bits in :attr:`co_flags` are reserved for internal use."
msgstr ":attr:`co_flags` 中的其他位保留供內部使用。"

#: ../../reference/datamodel.rst:1016
#, fuzzy
msgid ""
"If a code object represents a function, the first item in :attr:`co_consts` "
"is the documentation string of the function, or ``None`` if undefined."
msgstr "如果一個程式碼物件表示一個函式，則 :attr:`co_consts` "
"中的第一項是該函式的文檔字串，如果未定義則為 ``None``。"

#: ../../reference/datamodel.rst:1021
#, fuzzy
msgid ""
"Returns an iterable over the source code positions of each bytecode "
"instruction in the code object."
msgstr "回傳程式碼對像中每個位元組碼指令的源程式碼位置的疊代。"

#: ../../reference/datamodel.rst:1024
#, fuzzy
msgid ""
"The iterator returns tuples containing the ``(start_line, end_line, "
"start_column, end_column)``. The *i-th* tuple corresponds to the position of "
"the source code that compiled to the *i-th* instruction. Column information "
"is 0-indexed utf-8 byte offsets on the given source line."
msgstr ""
"疊代器回傳包含 ``(start_line, end_line, start_column, end_column)`` 的元組。 "
"*i-th* 元組對應於編譯為 *i-th* 指令的源程式碼的位置。列資訊是給定源行上的 0 "
"索引 utf-8 位元組偏移量。"

#: ../../reference/datamodel.rst:1030
#, fuzzy
msgid ""
"This positional information can be missing. A non-exhaustive lists of cases "
"where this may happen:"
msgstr "此位置資訊可能會丟失。可能發生這種情況的非詳盡列表："

#: ../../reference/datamodel.rst:1033
#, fuzzy
msgid "Running the interpreter with :option:`-X` ``no_debug_ranges``."
msgstr "使用 :option:`-X` ``no_debug_ranges`` 運行直譯器。"

#: ../../reference/datamodel.rst:1034
#, fuzzy
msgid ""
"Loading a pyc file compiled while using :option:`-X` ``no_debug_ranges``."
msgstr "加載使用 :option:`-X` ``no_debug_ranges`` 編譯的 pyc 文件。"

#: ../../reference/datamodel.rst:1035
#, fuzzy
msgid "Position tuples corresponding to artificial instructions."
msgstr "定位對應於人工指令的元組。"

#: ../../reference/datamodel.rst:1036
#, fuzzy
msgid ""
"Line and column numbers that can't be represented due to implementation "
"specific limitations."
msgstr "由於實施特定限製而無法表示的行號和列號。"

#: ../../reference/datamodel.rst:1039
#, fuzzy
msgid ""
"When this occurs, some or all of the tuple elements can be :const:`None`."
msgstr "發生這種情況時，部分或全部元組元素可以是 :const:`None`。"

#: ../../reference/datamodel.rst:1045
#, fuzzy
msgid ""
"This feature requires storing column positions in code objects which may "
"result in a small increase of disk usage of compiled Python files or "
"interpreter memory usage. To avoid storing the extra information and/or "
"deactivate printing the extra traceback information, the :option:`-X` "
"``no_debug_ranges`` command line flag or the :envvar:`PYTHONNODEBUGRANGES` "
"environment variable can be used."
msgstr ""
"此功能需要在程式碼對像中儲存列位置，這可能會導致編譯 Python 文件的磁盤使用量"
"或直譯器記憶體使用量略有增加。為避免儲存額外資訊和/或停用印出額外回溯資訊，可"
"以使用 :option:`-X` ``no_debug_ranges`` "
"命令列旗標或 :envvar:`PYTHONNODEBUGRANGES` 環境變數。"

#: ../../reference/datamodel.rst:1112
#, fuzzy
msgid "Frame objects"
msgstr "框架物件"

#: ../../reference/datamodel.rst:1057
#, fuzzy
msgid ""
"Frame objects represent execution frames.  They may occur in traceback "
"objects (see below), and are also passed to registered trace functions."
msgstr "框架物件代表執行框架。它們可能出現在回溯對像中（見下文），並且也被傳遞給已註"
"冊的跟踪函式。"

#: ../../reference/datamodel.rst:1068
#, fuzzy
msgid ""
"Special read-only attributes: :attr:`f_back` is to the previous stack frame "
"(towards the caller), or ``None`` if this is the bottom stack frame; :attr:"
"`f_code` is the code object being executed in this frame; :attr:`f_locals` "
"is the dictionary used to look up local variables; :attr:`f_globals` is used "
"for global variables; :attr:`f_builtins` is used for built-in (intrinsic) "
"names; :attr:`f_lasti` gives the precise instruction (this is an index into "
"the bytecode string of the code object)."
msgstr ""
"特殊的只讀屬性：:attr:`f_back` 指向前一個堆疊幀（朝向呼叫者），"
"如果這是底部堆疊幀則為 ``None``； :attr:`f_code` 是該幀正在執行的程式碼物件；"
" :attr:`f_locals` 是用來查找局部變數的字典； :attr:`f_globals` 用於全局變數；"
" :attr:`f_builtins` 用於內建（固有）名稱； :attr:`f_lasti` "
"給出了精確的指令（這是程式碼物件的位元組碼字串的索引）。"

#: ../../reference/datamodel.rst:1076
msgid ""
"Accessing ``f_code`` raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"f_code\"``."
msgstr ""
"存取 ``f_code`` 會引發一個附帶引數 ``obj`` 與 ``\"f_code\"`` 的\\ :ref:`稽核事件 <auditing>` ``object."
"__getattr__``。"

#: ../../reference/datamodel.rst:1085
#, fuzzy
msgid ""
"Special writable attributes: :attr:`f_trace`, if not ``None``, is a function "
"called for various events during code execution (this is used by the "
"debugger). Normally an event is triggered for each new source line - this "
"can be disabled by setting :attr:`f_trace_lines` to :const:`False`."
msgstr ""
"特殊可寫屬性：:attr:`f_trace`，如果不是``None``，是程式碼執行期間為各種事件呼"
"叫的函式（除錯器使用）。通常情況下，每個新的源程式碼行都會觸發一個事件 - "
"這可以通過將 f_trace_lines 設定為 const:False 來禁用。"

#: ../../reference/datamodel.rst:1090
#, fuzzy
msgid ""
"Implementations *may* allow per-opcode events to be requested by setting :"
"attr:`f_trace_opcodes` to :const:`True`. Note that this may lead to "
"undefined interpreter behaviour if exceptions raised by the trace function "
"escape to the function being traced."
msgstr ""
"實作*可能*允許通過將 :attr:`f_trace_opcodes` 設定為 :const:`True` 來請求每個操"
"作碼事件。請注意，如果跟踪函式引發的例外轉義到被跟踪的函式，這可能會導致未定"
"義的直譯器行為。"

#: ../../reference/datamodel.rst:1095
#, fuzzy
msgid ""
":attr:`f_lineno` is the current line number of the frame --- writing to this "
"from within a trace function jumps to the given line (only for the bottom-"
"most frame).  A debugger can implement a Jump command (aka Set Next "
"Statement) by writing to f_lineno."
msgstr ""
":attr:`f_lineno` 是幀的當前行號 --- "
"從跟踪函式中寫入它會跳轉到給定行（僅適用於最底部的幀）。除錯器可以通過寫入 "
"f_lineno 來實作跳轉命令（也稱為設定下一條語句）。"

#: ../../reference/datamodel.rst:1100
#, fuzzy
msgid "Frame objects support one method:"
msgstr "框架物件支援一種方法："

#: ../../reference/datamodel.rst:1104
#, fuzzy
msgid ""
"This method clears all references to local variables held by the frame.  "
"Also, if the frame belonged to a generator, the generator is finalized.  "
"This helps break reference cycles involving frame objects (for example when "
"catching an exception and storing its traceback for later use)."
msgstr ""
"此方法清除所有對框架持有的局部變數的引用。此外，如果幀屬於生成器，則生成器被"
"最終確定。這有助於打破涉及框架物件的引用循環（例如，當捕獲例外並儲存其回溯供"
"以後使用時）。"

#: ../../reference/datamodel.rst:1110
#, fuzzy
msgid ":exc:`RuntimeError` is raised if the frame is currently executing."
msgstr ":exc:`RuntimeError` 如果框架當前正在執行則引發。"

#: ../../reference/datamodel.rst:1176
#, fuzzy
msgid "Traceback objects"
msgstr "回溯物件"

#: ../../reference/datamodel.rst:1128
#, fuzzy
msgid ""
"Traceback objects represent a stack trace of an exception.  A traceback "
"object is implicitly created when an exception occurs, and may also be "
"explicitly created by calling :class:`types.TracebackType`."
msgstr ""
"Traceback 物件表示例外的堆疊跟踪。 traceback 對像在例外發生時隱式建立，"
"也可以通過呼叫 types.TracebackType 顯式建立。"

#: ../../reference/datamodel.rst:1132
#, fuzzy
msgid ""
"For implicitly created tracebacks, when the search for an exception handler "
"unwinds the execution stack, at each unwound level a traceback object is "
"inserted in front of the current traceback.  When an exception handler is "
"entered, the stack trace is made available to the program. (See section :ref:"
"`try`.) It is accessible as the third item of the tuple returned by ``sys."
"exc_info()``, and as the ``__traceback__`` attribute of the caught exception."
msgstr ""
"對於隱式建立的回溯，當搜索例外處理程式展開執行堆疊時，在每個展開的級別上，都"
"會在當前回溯之前插入一個回溯物件。輸入例外處理程式時，堆疊跟踪可供程式使用。 "
"（參見 try 部分。）它可以作為 sys.exc_info() 回傳的元組的第三項訪問，"
"也可以作為捕獲例外的 __traceback__ 屬性訪問。"

#: ../../reference/datamodel.rst:1140
#, fuzzy
msgid ""
"When the program contains no suitable handler, the stack trace is written "
"(nicely formatted) to the standard error stream; if the interpreter is "
"interactive, it is also made available to the user as ``sys.last_traceback``."
msgstr ""
"當程式不包含合適的處理程式時，堆疊跟踪被寫入（格式化）到標準錯誤流；如果直譯"
"器是交互式的，它也可以作為 sys.last_traceback 提供給使用者。"

#: ../../reference/datamodel.rst:1145
#, fuzzy
msgid ""
"For explicitly created tracebacks, it is up to the creator of the traceback "
"to determine how the ``tb_next`` attributes should be linked to form a full "
"stack trace."
msgstr "對於顯式建立的回溯，由回溯的建立者決定應如何鏈接“tb_next”屬性以形成完整的堆疊"
"跟踪。"

#: ../../reference/datamodel.rst:1155
#, fuzzy
msgid ""
"Special read-only attributes: :attr:`tb_frame` points to the execution frame "
"of the current level; :attr:`tb_lineno` gives the line number where the "
"exception occurred; :attr:`tb_lasti` indicates the precise instruction. The "
"line number and last instruction in the traceback may differ from the line "
"number of its frame object if the exception occurred in a :keyword:`try` "
"statement with no matching except clause or with a finally clause."
msgstr ""
"特殊只讀屬性：:attr:`tb_frame` 指向當前關卡的執行幀； :attr:`tb_lineno` "
"給出例外發生的行號； :attr:`tb_lasti` 表示精確指令。如果例外發生在沒有匹配的 "
"except 子句或帶有 finally 子句的 try "
"語句中，則回溯中的行號和最後一條指令可能與其框架物件的行號不同。"

#: ../../reference/datamodel.rst:1164
msgid ""
"Accessing ``tb_frame`` raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"tb_frame\"``."
msgstr ""
"存取 ``tb_frame`` 會引發一個附帶引數 ``obj`` 與 ``\"tb_frame\"`` 的\\ :ref:`稽核事件 <auditing>` ``object."
"__getattr__``。"

#: ../../reference/datamodel.rst:1170
#, fuzzy
msgid ""
"Special writable attribute: :attr:`tb_next` is the next level in the stack "
"trace (towards the frame where the exception occurred), or ``None`` if there "
"is no next level."
msgstr "特殊可寫屬性：:attr:`tb_next` 是堆疊跟踪中的下一層（指向發生例外的幀），"
"如果沒有下一層則為 ``None``。"

#: ../../reference/datamodel.rst:1174
#, fuzzy
msgid ""
"Traceback objects can now be explicitly instantiated from Python code, and "
"the ``tb_next`` attribute of existing instances can be updated."
msgstr "Traceback 物件現在可以從 Python "
"程式碼中顯式實例化，並且可以更新現有實例的“tb_next”屬性。"

#: ../../reference/datamodel.rst:1203
#, fuzzy
msgid "Slice objects"
msgstr "切片物件"

#: ../../reference/datamodel.rst:1181
#, fuzzy
msgid ""
"Slice objects are used to represent slices for :meth:`~object.__getitem__` "
"methods.  They are also created by the built-in :func:`slice` function."
msgstr ""
"切片對像用於表示 :meth:`~object.__getitem__` 方法的切片。它們也是由內建的 "
":func:`slice` 函式建立的。"

#: ../../reference/datamodel.rst:1190
#, fuzzy
msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; :attr:"
"`~slice.stop` is the upper bound; :attr:`~slice.step` is the step value; "
"each is ``None`` if omitted.  These attributes can have any type."
msgstr ""
"特殊的只讀屬性：:attr:`~slice.start` 是下界； :attr:`~slice.stop` 是上限； "
":attr:`~slice.step` "
"為步長值；如果省略，每個都是 ``None`` 。這些屬性可以有任何型別。"

#: ../../reference/datamodel.rst:1194
#, fuzzy
msgid "Slice objects support one method:"
msgstr "切片物件支援一種方法："

#: ../../reference/datamodel.rst:1198
#, fuzzy
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the slice that the slice object would describe if applied "
"to a sequence of *length* items.  It returns a tuple of three integers; "
"respectively these are the *start* and *stop* indices and the *step* or "
"stride length of the slice. Missing or out-of-bounds indices are handled in "
"a manner consistent with regular slices."
msgstr ""
"此方法採用單個整數參數 *length* 併計算有關切片的資訊，如果應用於 *length* "
"項序列，切片物件將描述該切片。它回傳三個整數的元組；這些分別是 *start* 和 "
"*stop* 索引以及切片的 *step* "
"或步幅長度。缺失或越界索引的處理方式與常規切片一致。"

#: ../../reference/datamodel.rst:1212
#, fuzzy
msgid "Static method objects"
msgstr "靜態方法物件"

#: ../../reference/datamodel.rst:1206
#, fuzzy
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method object "
"is a wrapper around any other object, usually a user-defined method object. "
"When a static method object is retrieved from a class or a class instance, "
"the object actually returned is the wrapped object, which is not subject to "
"any further transformation. Static method objects are also callable. Static "
"method objects are created by the built-in :func:`staticmethod` constructor."
msgstr ""
"靜態方法物件提供了一種方法來阻止上述函式對像到方法物件的轉換。靜態方法對像是"
"任何其他物件的包裝器，通常是使用者定義的方法物件。當從類或類實例中檢索靜態方"
"法物件時，實際回傳的對像是包裝物件，不進行任何進一步的轉換。靜態方法對像也是"
"可呼叫的。靜態方法物件由內建的 :func:`staticmethod` 構造函式建立。"

#: ../../reference/datamodel.rst:1220
#, fuzzy
msgid "Class method objects"
msgstr "類方法物件"

#: ../../reference/datamodel.rst:1215
#, fuzzy
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from "
"classes and class instances. The behaviour of class method objects upon such "
"retrieval is described above, under \"User-defined methods\". Class method "
"objects are created by the built-in :func:`classmethod` constructor."
msgstr ""
"類方法物件與靜態方法對像一樣，是另一個物件的包裝器，它改變了從類和類實例中檢"
"索該物件的方式。類方法對像在這種檢索時的行為在上面的“使用者定義的方法”下進行"
"了描述。類方法物件由內建的 :func:`classmethod` 構造函式建立。"

#: ../../reference/datamodel.rst:1225
#, fuzzy
msgid "Special method names"
msgstr "特殊方法名稱"

#: ../../reference/datamodel.rst:1231
#, fuzzy
msgid ""
"A class can implement certain operations that are invoked by special syntax "
"(such as arithmetic operations or subscripting and slicing) by defining "
"methods with special names. This is Python's approach to :dfn:`operator "
"overloading`, allowing classes to define their own behavior with respect to "
"language operators.  For instance, if a class defines a method named :meth:"
"`~object.__getitem__`, and ``x`` is an instance of this class, then ``x[i]`` "
"is roughly equivalent to ``type(x).__getitem__(x, i)``.  Except where "
"mentioned, attempts to execute an operation raise an exception when no "
"appropriate method is defined (typically :exc:`AttributeError` or :exc:"
"`TypeError`)."
msgstr ""
"一個類可以通過定義具有特殊名稱的方法來實作由特殊語法（例如算術運算或下標和切"
"片）呼叫的某些操作。這是 Python 的 :dfn:`operator overloading` "
"方法，允許類定義它們自己關於語言運算符的行為。例如，如果一個類定義了一個名為 "
":meth:`~object.__getitem__` 的方法，並且 ``x`` 是此類的一個實例，那麼 "
"``x[i]`` 大致等同於 ``type( x).__getitem__(x, "
"i)``。除非另有提及，否則在未定義適當方法時嘗試執行操作會引發例外（通常是 "
":exc:`AttributeError` 或 :exc:`TypeError`）。"

#: ../../reference/datamodel.rst:1242
#, fuzzy
msgid ""
"Setting a special method to ``None`` indicates that the corresponding "
"operation is not available.  For example, if a class sets :meth:`~object."
"__iter__` to ``None``, the class is not iterable, so calling :func:`iter` on "
"its instances will raise a :exc:`TypeError` (without falling back to :meth:"
"`~object.__getitem__`). [#]_"
msgstr ""
"將特殊方法設定為 ``None``表示相應的操作不可用。例如，如果一個類將 :meth:`~object"
".__iter__` 設定為 ``None``，則該類不可疊代，因此在其實例上呼叫 :func:`iter` "
"將引發 :exc:`TypeError` (而不會退回到 :meth:`~object.__getitem__`)。 [#]_"

#: ../../reference/datamodel.rst:1248
#, fuzzy
msgid ""
"When implementing a class that emulates any built-in type, it is important "
"that the emulation only be implemented to the degree that it makes sense for "
"the object being modelled.  For example, some sequences may work well with "
"retrieval of individual elements, but extracting a slice may not make "
"sense.  (One example of this is the :class:`~xml.dom.NodeList` interface in "
"the W3C's Document Object Model.)"
msgstr ""
"在實作模擬任何內建型別的類時，重要的是模擬只能實作到它對被建模的對像有意義的"
"程度。例如，某些序列可能適用於檢索單個元素，但提取切片可能沒有意義。 （"
"其中一個例子是 W3C 文檔對像模型中的 :class:`~xml.dom.NodeList` 介面。）"

#: ../../reference/datamodel.rst:1259
#, fuzzy
msgid "Basic customization"
msgstr "基本定制"

#: ../../reference/datamodel.rst:1265
#, fuzzy
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a static "
"method (special-cased so you need not declare it as such) that takes the "
"class of which an instance was requested as its first argument.  The "
"remaining arguments are those passed to the object constructor expression "
"(the call to the class).  The return value of :meth:`__new__` should be the "
"new object instance (usually an instance of *cls*)."
msgstr ""
"呼叫以建立類 *cls* 的新實例。 :meth:`__new__` 是一個靜態方法（特殊情況，因此"
"您無需如此聲明），它將請求實例的類作為其第一個參數。其餘參數是傳遞給物件構造"
"函式表達式（對類的呼叫）的參數。 :meth:`__new__` 的回傳值應該是新的物件實例（"
"通常是 *cls* 的實例）。"

#: ../../reference/datamodel.rst:1272
#, fuzzy
msgid ""
"Typical implementations create a new instance of the class by invoking the "
"superclass's :meth:`__new__` method using ``super().__new__(cls[, ...])`` "
"with appropriate arguments and then modifying the newly created instance as "
"necessary before returning it."
msgstr ""
"典型的實作通過使用帶有適當參數的 ``super().__new__(cls[, ...])`` 呼叫超類的 "
":meth:`__new__` 方法來建立類的新實例，然後將新建立的實例修改為回傳之前需要。"

#: ../../reference/datamodel.rst:1277
#, fuzzy
msgid ""
"If :meth:`__new__` is invoked during object construction and it returns an "
"instance of *cls*, then the new instance’s :meth:`__init__` method will be "
"invoked like ``__init__(self[, ...])``, where *self* is the new instance and "
"the remaining arguments are the same as were passed to the object "
"constructor."
msgstr ""
"如果 :meth:`__new__` 在物件構造期間被呼叫並且它回傳一個 *cls* 的實例，"
"那麼新實例的 :meth:`__init__` 方法將被呼叫為 ``__init__(self[, ...])` `，"
"其中 *self* 是新實例，其餘參數與傳遞給物件構造函式的參數相同。"

#: ../../reference/datamodel.rst:1282
#, fuzzy
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr "如果 :meth:`__new__` 沒有回傳 *cls* 的實例，那麼新實例的 :meth:`__init__` "
"方法將不會被呼叫。"

#: ../../reference/datamodel.rst:1285
#, fuzzy
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types "
"(like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""
":meth:`__new__` 主要用於允許不可變型別（如 int、str "
"或元組）的子類別自定義實例建立。它也通常在自定義元類中被覆蓋以自定義類建立。"

#: ../../reference/datamodel.rst:1294
#, fuzzy
msgid ""
"Called after the instance has been created (by :meth:`__new__`), but before "
"it is returned to the caller.  The arguments are those passed to the class "
"constructor expression.  If a base class has an :meth:`__init__` method, the "
"derived class's :meth:`__init__` method, if any, must explicitly call it to "
"ensure proper initialization of the base class part of the instance; for "
"example: ``super().__init__([args...])``."
msgstr ""
"在建立實例之後呼叫（通過 :meth:`__new__`），但在它回傳給呼叫者之前。參數是傳"
"遞給類構造函式表達式的參數。如果基底類別有 :meth:`__init__` 方法，派生類的 "
":meth:`__init__` 方法（如果有）必須顯式呼叫它以確保正確初始化實例的基底類別部"
"分；例如：``super().__init__([args...])``。"

#: ../../reference/datamodel.rst:1301
#, fuzzy
msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in constructing "
"objects (:meth:`__new__` to create it, and :meth:`__init__` to customize "
"it), no non-``None`` value may be returned by :meth:`__init__`; doing so "
"will cause a :exc:`TypeError` to be raised at runtime."
msgstr ""
"因為 :meth:`__new__` 和 :meth:`__init__` "
"在構造物件時一起工作（:meth:`__new__` 來建立它，而 :meth:`__init__` "
"來定制它），沒有非 ``None``值可以由 :meth:`__init__` 回傳；"
"這樣做會導致在運行時引發 :exc:`TypeError`。"

#: ../../reference/datamodel.rst:1314
#, fuzzy
msgid ""
"Called when the instance is about to be destroyed.  This is also called a "
"finalizer or (improperly) a destructor.  If a base class has a :meth:"
"`__del__` method, the derived class's :meth:`__del__` method, if any, must "
"explicitly call it to ensure proper deletion of the base class part of the "
"instance."
msgstr ""
"在實例即將被銷毀時呼叫。這也稱為終結器或（不恰當地）析構函式。如果基底類別有 "
":meth:`__del__` 方法，則派生類的 :meth:`__del__` "
"方法（如果有）必須顯式呼叫它以確保正確刪除實例的基底類別部分。"

#: ../../reference/datamodel.rst:1320
#, fuzzy
msgid ""
"It is possible (though not recommended!) for the :meth:`__del__` method to "
"postpone destruction of the instance by creating a new reference to it.  "
"This is called object *resurrection*.  It is implementation-dependent "
"whether :meth:`__del__` is called a second time when a resurrected object is "
"about to be destroyed; the current :term:`CPython` implementation only calls "
"it once."
msgstr ""
":meth:`__del__` 方法可以（儘管不推薦！）通過建立對實例的新引用來推遲實例的銷"
"毀。這稱為物件*復活*。 :meth:`__del__` "
"在一個複活的物件即將被銷毀時是否被第二次呼叫是依賴於實作的；當前的 "
":term:`CPython` 實作只呼叫它一次。"

#: ../../reference/datamodel.rst:1327
#, fuzzy
msgid ""
"It is not guaranteed that :meth:`__del__` methods are called for objects "
"that still exist when the interpreter exits."
msgstr "不保證 :meth:`__del__` 方法會在直譯器退出時為仍然存在的物件呼叫。"

#: ../../reference/datamodel.rst:1332
#, fuzzy
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements "
"the reference count for ``x`` by one, and the latter is only called when "
"``x``'s reference count reaches zero."
msgstr ""
"``del x`` 不直接呼叫 ``x.__del__()`` --- 前者將 ``x`` 的引用計數減一，"
"後者僅在 ``x`` 時呼叫的引用計數達到零。"

#: ../../reference/datamodel.rst:1337
#, fuzzy
msgid ""
"It is possible for a reference cycle to prevent the reference count of an "
"object from going to zero.  In this case, the cycle will be later detected "
"and deleted by the :term:`cyclic garbage collector <garbage collection>`.  A "
"common cause of reference cycles is when an exception has been caught in a "
"local variable.  The frame's locals then reference the exception, which "
"references its own traceback, which references the locals of all frames "
"caught in the traceback."
msgstr ""
"引用循環可以防止物件的引用計數變為零。在這種情況下，週期稍後將被 :term:`"
"cyclic garbage collector <garbage collection>` 檢測到並刪除。引用循環的一個常"
"見原因是在局部變數中捕獲到例外。幀的本地然後引用例外，它引用它自己的回溯，它"
"引用回溯中捕獲的所有幀的本地。"

#: ../../reference/datamodel.rst:1347
#, fuzzy
msgid "Documentation for the :mod:`gc` module."
msgstr ":mod:`gc` 模組的文檔。"

#: ../../reference/datamodel.rst:1351
#, fuzzy
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods are "
"invoked, exceptions that occur during their execution are ignored, and a "
"warning is printed to ``sys.stderr`` instead.  In particular:"
msgstr ""
"由於呼叫 :meth:`__del__` 方法的環境不穩定，在執行期間發生的例外將被忽略，"
"而是將警告印出到 ``sys.stderr``。尤其："

#: ../../reference/datamodel.rst:1355
#, fuzzy
msgid ""
":meth:`__del__` can be invoked when arbitrary code is being executed, "
"including from any arbitrary thread.  If :meth:`__del__` needs to take a "
"lock or invoke any other blocking resource, it may deadlock as the resource "
"may already be taken by the code that gets interrupted to execute :meth:"
"`__del__`."
msgstr ""
":meth:`__del__` 可以在執行任意程式碼時呼叫，包括從任意執行緒執行。如果 "
":meth:`__del__` 需要鎖定或呼叫任何其他阻塞資源，它可能會死鎖，"
"因為該資源可能已經被被中斷以執行 :meth:`__del__` 的程式碼佔用。"

#: ../../reference/datamodel.rst:1361
#, fuzzy
msgid ""
":meth:`__del__` can be executed during interpreter shutdown.  As a "
"consequence, the global variables it needs to access (including other "
"modules) may already have been deleted or set to ``None``. Python guarantees "
"that globals whose name begins with a single underscore are deleted from "
"their module before other globals are deleted; if no other references to "
"such globals exist, this may help in assuring that imported modules are "
"still available at the time when the :meth:`__del__` method is called."
msgstr ""
":meth:`__del__` 可以在直譯器關閉期間執行。因此，它需要訪問的全局變數（包括其"
"他模組）可能已經被刪除或設定為 ``None`` 。 Python 保證在刪除其他全局變數之前，先從"
"其模組中刪除名稱以單個底線開頭的全局變數；如果不存在對此類全局變數的其他引"
"用，這可能有助於確保在呼叫 :meth:`__del__` 方法時導入的模組仍然可用。"

#: ../../reference/datamodel.rst:1376
#, fuzzy
msgid ""
"Called by the :func:`repr` built-in function to compute the \"official\" "
"string representation of an object.  If at all possible, this should look "
"like a valid Python expression that could be used to recreate an object with "
"the same value (given an appropriate environment).  If this is not possible, "
"a string of the form ``<...some useful description...>`` should be returned. "
"The return value must be a string object. If a class defines :meth:"
"`__repr__` but not :meth:`__str__`, then :meth:`__repr__` is also used when "
"an \"informal\" string representation of instances of that class is required."
msgstr ""
"由 :func:`repr` 內建函式呼叫以計算物件的“官方”字串表示形式。如果可能的話，"
"這應該看起來像一個有效的 Python 表達式，可用於重新建立具有相同值的物件（給定"
"適當的環境）。如果這不可能，則應回傳格式為“<..."
"一些有用的描述...>”的字串。回傳值必須是字串物件。如果一個類定義了 "
":meth:`__repr__` 而不是 :meth:`__str__` ，那麼 :meth:`__repr__` "
"也會在需要該類實例的“非正式”字串表示時使用。"

#: ../../reference/datamodel.rst:1385
#, fuzzy
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous."
msgstr "這通常用於除錯，因此表示資訊豐富且明確非常重要。"

#: ../../reference/datamodel.rst:1396
#, fuzzy
msgid ""
"Called by :func:`str(object) <str>` and the built-in functions :func:"
"`format` and :func:`print` to compute the \"informal\" or nicely printable "
"string representation of an object.  The return value must be a :ref:`string "
"<textseq>` object."
msgstr ""
"由 :func:`str(object) <str>` 和內建函式 :func:`format` 和 :func:`print` "
"呼叫以計算物件的“非正式”或可印出字串表示形式。回傳值必須是一個 :ref:`string "
"<textseq>` 物件。"

#: ../../reference/datamodel.rst:1401
#, fuzzy
msgid ""
"This method differs from :meth:`object.__repr__` in that there is no "
"expectation that :meth:`__str__` return a valid Python expression: a more "
"convenient or concise representation can be used."
msgstr ""
"此方法與 :meth:`object.__repr__` 的不同之處在於不期望 :meth:`__str__` "
"回傳有效的 Python 表達式：可以使用更方便或簡潔的表示。"

#: ../../reference/datamodel.rst:1405
#, fuzzy
msgid ""
"The default implementation defined by the built-in type :class:`object` "
"calls :meth:`object.__repr__`."
msgstr "內建型別 object 定義的預設實作呼叫 object.__repr__ 。"

#: ../../reference/datamodel.rst:1415
#, fuzzy
msgid ""
"Called by :ref:`bytes <func-bytes>` to compute a byte-string representation "
"of an object. This should return a :class:`bytes` object."
msgstr "由 :ref:`bytes <func-bytes>` "
"呼叫以計算物件的位元組字串表示。這應該回傳一個 :class:`bytes` 物件。"

#: ../../reference/datamodel.rst:1426
#, fuzzy
msgid ""
"Called by the :func:`format` built-in function, and by extension, evaluation "
"of :ref:`formatted string literals <f-strings>` and the :meth:`str.format` "
"method, to produce a \"formatted\" string representation of an object. The "
"*format_spec* argument is a string that contains a description of the "
"formatting options desired. The interpretation of the *format_spec* argument "
"is up to the type implementing :meth:`__format__`, however most classes will "
"either delegate formatting to one of the built-in types, or use a similar "
"formatting option syntax."
msgstr ""
"由 :func:`format` 內建函式呼叫，並通過擴充評估 :ref:`格式化字串文字 "
"<f-strings>` 和 :meth:`str.format` 方法，以生成“格式化\" 物件的字串表示。 "
"*format_spec* 參數是一個字串，其中包含對所需格式化選項的描述。 *format_spec* "
"參數的解釋取決於實作 :meth:`__format__` 的型別，但是大多數類要么將格式化委託"
"給其中一種內建型別，要么使用類似的格式化選項語法。"

#: ../../reference/datamodel.rst:1436
#, fuzzy
msgid ""
"See :ref:`formatspec` for a description of the standard formatting syntax."
msgstr "有關標準格式化語法的說明，請參閱 :ref:`formatspec`。"

#: ../../reference/datamodel.rst:1438
#, fuzzy
msgid "The return value must be a string object."
msgstr "回傳值必須是字串物件。"

#: ../../reference/datamodel.rst:1440
#, fuzzy
msgid ""
"The __format__ method of ``object`` itself raises a :exc:`TypeError` if "
"passed any non-empty string."
msgstr "如果傳遞任何非空字串，``object`` 的 __format__ 方法本身會引發 "
":exc:`TypeError`。"

#: ../../reference/datamodel.rst:1444
#, fuzzy
msgid ""
"``object.__format__(x, '')`` is now equivalent to ``str(x)`` rather than "
"``format(str(x), '')``."
msgstr ""
"``object.__format__(x, '')`` 現在等同於 ``str(x)`` 而不是 ``format(str(x), "
"'')``。"

#: ../../reference/datamodel.rst:1460
#, fuzzy
msgid ""
"These are the so-called \"rich comparison\" methods. The correspondence "
"between operator symbols and method names is as follows: ``x<y`` calls ``x."
"__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` calls ``x.__eq__(y)``, "
"``x!=y`` calls ``x.__ne__(y)``, ``x>y`` calls ``x.__gt__(y)``, and ``x>=y`` "
"calls ``x.__ge__(y)``."
msgstr ""
"這就是所謂的“有錢人比較”的方法。運算符符號和方法名的對應關係如下：``x<y``呼叫"
"``x.__lt__(y)``，``x<=y``呼叫``x.__le__(y)`` , ``x==y`` 呼叫``x.__eq__(y)``, "
"``x!=y`` 呼叫``x.__ne__(y)``, ``x>y`` 呼叫` `x.__gt__(y)`` 和 ``x>=y`` 呼叫 "
"``x.__ge__(y)``。"

#: ../../reference/datamodel.rst:1466
#, fuzzy
msgid ""
"A rich comparison method may return the singleton ``NotImplemented`` if it "
"does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful comparison. "
"However, these methods can return any value, so if the comparison operator "
"is used in a Boolean context (e.g., in the condition of an ``if`` "
"statement), Python will call :func:`bool` on the value to determine if the "
"result is true or false."
msgstr ""
"如果豐富的比較方法沒有為給定的一對參數實作操作，它可能會回傳單例“NotImplement"
"ed”。按照慣例，回傳 ``False``和 ``True``以進行成功比較。但是，這些方法可以回傳任何"
"值，因此如果在布爾上下文中使用比較運算符（例如，在 ``if`` 語句的條件中），"
"Python 將對該值呼叫 :func:`bool` 以確定如果結果是真還是假。"

#: ../../reference/datamodel.rst:1473
#, fuzzy
msgid ""
"By default, ``object`` implements :meth:`__eq__` by using ``is``, returning "
"``NotImplemented`` in the case of a false comparison: ``True if x is y else "
"NotImplemented``. For :meth:`__ne__`, by default it delegates to :meth:"
"`__eq__` and inverts the result unless it is ``NotImplemented``.  There are "
"no other implied relationships among the comparison operators or default "
"implementations; for example, the truth of ``(x<y or x==y)`` does not imply "
"``x<=y``. To automatically generate ordering operations from a single root "
"operation, see :func:`functools.total_ordering`."
msgstr ""
"預設情況下，``object`` 通過使用 ``is`` 實作 :meth:`__eq__`，"
"在錯誤比較的情況下回傳 ``NotImplemented``：``如果 x 是 y 則為真，否則為 "
"NotImplemented``。對於 :meth:`__ne__`，預設情況下它委託給 :meth:`__eq__` "
"並反轉結果，除非它是 "
"``NotImplemented``。比較運算符或預設實作之間沒有其他隱含關係；例如，``(x<y "
"or x==y)`` 的真實性並不意味著 ``x<=y``。要從單個根操作自動生成排序操作，"
"請參閱 func:`functools.total_ordering`。"

#: ../../reference/datamodel.rst:1482
#, fuzzy
msgid ""
"See the paragraph on :meth:`__hash__` for some important notes on creating :"
"term:`hashable` objects which support custom comparison operations and are "
"usable as dictionary keys."
msgstr "有關建立支援自定義比較操作並可用作字典鍵的可雜湊物件的一些重要說明，"
"請參閱有關 :meth:`__hash__` 的段落。"

#: ../../reference/datamodel.rst:1486
#, fuzzy
msgid ""
"There are no swapped-argument versions of these methods (to be used when the "
"left argument does not support the operation but the right argument does); "
"rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection, :meth:"
"`__le__` and :meth:`__ge__` are each other's reflection, and :meth:`__eq__` "
"and :meth:`__ne__` are their own reflection. If the operands are of "
"different types, and right operand's type is a direct or indirect subclass "
"of the left operand's type, the reflected method of the right operand has "
"priority, otherwise the left operand's method has priority.  Virtual "
"subclassing is not considered."
msgstr ""
"這些方法沒有交換參數版本（當左參數不支援該操作但右參數支援時使用）；相反，:me"
"th:`__lt__` 和 :meth:`__gt__` 是彼此的反映，:meth:`__le__` 和 :meth:`__ge__` "
"是彼此的反映，而 :meth:`__eq__` 和 :meth:` __ne__` 是他們自己的倒影。如果操作數"
"是不同的型別，並且右操作數的型別是左操作數型別的直接或間接子類別，則右操作數"
"的反射方法優先，否則左操作數的方法優先。不考慮虛擬子類別化。"

#: ../../reference/datamodel.rst:1503
#, fuzzy
msgid ""
"Called by built-in function :func:`hash` and for operations on members of "
"hashed collections including :class:`set`, :class:`frozenset`, and :class:"
"`dict`.  The ``__hash__()`` method should return an integer. The only "
"required property is that objects which compare equal have the same hash "
"value; it is advised to mix together the hash values of the components of "
"the object that also play a part in comparison of objects by packing them "
"into a tuple and hashing the tuple. Example::"
msgstr ""
"由內建函式 :func:`hash` 呼叫，用於對散列集合的成員進行操作，包括 "
":class:`set`、:class:`frozenset` 和 :class:`dict`。 ``__hash__()`` 方法應該回"
"傳一個整數。唯一需要的屬性是比較相等的物件具有相同的散列值；建議將物件組件的"
"散列值混合在一起，這些散列值也在對像比較中發揮作用，方法是將它們打包到一個元"
"組中並對元組進行散列。例子：："

#: ../../reference/datamodel.rst:1516
#, fuzzy
msgid ""
":func:`hash` truncates the value returned from an object's custom :meth:"
"`__hash__` method to the size of a :c:type:`Py_ssize_t`.  This is typically "
"8 bytes on 64-bit builds and 4 bytes on 32-bit builds.  If an object's   :"
"meth:`__hash__` must interoperate on builds of different bit sizes, be sure "
"to check the width on all supported builds.  An easy way to do this is with "
"``python -c \"import sys; print(sys.hash_info.width)\"``."
msgstr ""
":func:`hash` 將從物件的自定義 :meth:`__hash__` 方法回傳的值截斷為 "
":c:type:`Py_ssize_t` 的大小。這通常在 64 位版本上為 8 個位元組，在 32 "
"位版本上為 4 個位元組。如果物件的 :meth:`__hash__` "
"必須在不同位大小的構建上互操作，請務必檢查所有支援的構建的寬度。"
"一個簡單的方法是使用 ``python -c \"import sys; print(sys.hash_info.width)\""
"``。"

#: ../../reference/datamodel.rst:1524
#, fuzzy
msgid ""
"If a class does not define an :meth:`__eq__` method it should not define a :"
"meth:`__hash__` operation either; if it defines :meth:`__eq__` but not :meth:"
"`__hash__`, its instances will not be usable as items in hashable "
"collections.  If a class defines mutable objects and implements an :meth:"
"`__eq__` method, it should not implement :meth:`__hash__`, since the "
"implementation of :term:`hashable` collections requires that a key's hash "
"value is immutable (if the object's hash value changes, it will be in the "
"wrong hash bucket)."
msgstr ""
"如果一個類沒有定義 :meth:`__eq__` 方法，它也不應該定義 :meth:`__hash__` "
"操作；如果它定義了 :meth:`__eq__` 而不是 :meth:`__hash__` "
"，它的實例將不能用作可雜湊集合中的項目。如果一個類定義了可變物件並實作了 "
":meth:`__eq__` 方法，它不應該實作 :meth:`__hash__`，因為 :term:`hashable` "
"集合的實作要求鍵的雜湊值是不可變的（如果object 的 hash 值發生變化，"
"它會在錯誤的 hash bucket 中）。"

#: ../../reference/datamodel.rst:1533
#, fuzzy
msgid ""
"User-defined classes have :meth:`__eq__` and :meth:`__hash__` methods by "
"default; with them, all objects compare unequal (except with themselves) and "
"``x.__hash__()`` returns an appropriate value such that ``x == y`` implies "
"both that ``x is y`` and ``hash(x) == hash(y)``."
msgstr ""
"使用者定義的類預設有 :meth:`__eq__` 和 :meth:`__hash__` "
"方法；有了它們，所有對像都比較不相等（除了它們自己）並且 ``x.__hash__()`` "
"回傳一個適當的值，這樣 ``x == y`` 意味著 ``x is y`` 和 ``hash (x) == "
"hash(y)``。"

#: ../../reference/datamodel.rst:1538
#, fuzzy
msgid ""
"A class that overrides :meth:`__eq__` and does not define :meth:`__hash__` "
"will have its :meth:`__hash__` implicitly set to ``None``.  When the :meth:"
"`__hash__` method of a class is ``None``, instances of the class will raise "
"an appropriate :exc:`TypeError` when a program attempts to retrieve their "
"hash value, and will also be correctly identified as unhashable when "
"checking ``isinstance(obj, collections.abc.Hashable)``."
msgstr ""
"覆蓋 :meth:`__eq__` 且未定義 :meth:`__hash__` 的類將其 :meth:`__hash__` "
"隱式設定為 ``None``。當類的 :meth:`__hash__` 方法為 ``None`` 時，"
"類的實例將在程式嘗試檢索它們的雜湊值時引發適當的 :exc:`TypeError`，"
"並且也將被正確識別為檢查 ``isinstance(obj, collections.abc.Hashable)`` "
"時不可散列。"

#: ../../reference/datamodel.rst:1545
#, fuzzy
msgid ""
"If a class that overrides :meth:`__eq__` needs to retain the implementation "
"of :meth:`__hash__` from a parent class, the interpreter must be told this "
"explicitly by setting ``__hash__ = <ParentClass>.__hash__``."
msgstr ""
"如果覆蓋 :meth:`__eq__` 的類需要保留父類的 :meth:`__hash__` 的實作，"
"則必須通過設定 ``__hash__ = <ParentClass>.__hash__`` 明確告知直譯器。"

#: ../../reference/datamodel.rst:1549
#, fuzzy
msgid ""
"If a class that does not override :meth:`__eq__` wishes to suppress hash "
"support, it should include ``__hash__ = None`` in the class definition. A "
"class which defines its own :meth:`__hash__` that explicitly raises a :exc:"
"`TypeError` would be incorrectly identified as hashable by an "
"``isinstance(obj, collections.abc.Hashable)`` call."
msgstr ""
"如果一個不覆蓋 :meth:`__eq__` 的類希望抑制散列支援，它應該在類定義中包含 ``"
"__hash__ = None``。定義自己的 :meth:`__hash__` 並顯式引發 :exc:`TypeError` "
"的類將被 ``isinstance(obj, collections.abc.Hashable)`` "
"呼叫錯誤地識別為可雜湊。"

#: ../../reference/datamodel.rst:1558
#, fuzzy
msgid ""
"By default, the :meth:`__hash__` values of str and bytes objects are "
"\"salted\" with an unpredictable random value.  Although they remain "
"constant within an individual Python process, they are not predictable "
"between repeated invocations of Python."
msgstr ""
"預設情況下，str 和 bytes 物件的 :meth:`__hash__` "
"值是用不可預測的隨機值“加鹽”的。儘管它們在單個 Python 行程中保持不變，"
"但它們在 Python 的重複呼叫之間不可預測。"

#: ../../reference/datamodel.rst:1563
#, fuzzy
msgid ""
"This is intended to provide protection against a denial-of-service caused by "
"carefully chosen inputs that exploit the worst case performance of a dict "
"insertion, O(n\\ :sup:`2`) complexity.  See http://www.ocert.org/advisories/"
"ocert-2011-003.html for details."
msgstr ""
"這是為了防止由精心選擇的輸入引起的拒絕服務，這些輸入利用了 dict "
"插入的最壞情況性能，O(n\\ :sup:`2`) 複雜度。有關詳細資訊，請參閱 http://www."
"ocert.org/advisories/ocert-2011-003.html。"

#: ../../reference/datamodel.rst:1568
#, fuzzy
msgid ""
"Changing hash values affects the iteration order of sets. Python has never "
"made guarantees about this ordering (and it typically varies between 32-bit "
"and 64-bit builds)."
msgstr "更改雜湊值會影響集合的疊代順序。 Python 從未對這種順序做出保證（它通常在 32 "
"位和 64 位構建之間有所不同）。"

#: ../../reference/datamodel.rst:1572
msgid "See also :envvar:`PYTHONHASHSEED`."
msgstr "另請參閱 :envvar:`PYTHONHASHSEED`\\ 。"

#: ../../reference/datamodel.rst:1574
#, fuzzy
msgid "Hash randomization is enabled by default."
msgstr "預設情況下啟用雜湊隨機化。"

#: ../../reference/datamodel.rst:1582
#, fuzzy
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``.  When this method is not "
"defined, :meth:`__len__` is called, if it is defined, and the object is "
"considered true if its result is nonzero.  If a class defines neither :meth:"
"`__len__` nor :meth:`__bool__`, all its instances are considered true."
msgstr ""
"呼叫以實作真值測試和內建操作 ``bool()``；應該回傳 ``False`` 或 "
"``True``。如果未定義此方法，則呼叫 "
":meth:`__len__`（如果已定義），並且如果其結果非零，則該對像被視為 true。"
"如果一個類既沒有定義 :meth:`__len__` 也沒有定義"
":meth:`__bool__`，那麼它的所有實例都被認為是真的。"

#: ../../reference/datamodel.rst:1593
#, fuzzy
msgid "Customizing attribute access"
msgstr "自定義屬性訪問"

#: ../../reference/datamodel.rst:1595
#, fuzzy
msgid ""
"The following methods can be defined to customize the meaning of attribute "
"access (use of, assignment to, or deletion of ``x.name``) for class "
"instances."
msgstr "可以定義以下方法來自定義類實例的屬性訪問（使用、分配或刪除 ``x."
"name``）的含義。"

#: ../../reference/datamodel.rst:1603
#, fuzzy
msgid ""
"Called when the default attribute access fails with an :exc:`AttributeError` "
"(either :meth:`__getattribute__` raises an :exc:`AttributeError` because "
"*name* is not an instance attribute or an attribute in the class tree for "
"``self``; or :meth:`__get__` of a *name* property raises :exc:"
"`AttributeError`).  This method should either return the (computed) "
"attribute value or raise an :exc:`AttributeError` exception."
msgstr ""
"當預設屬性訪問因 :exc:`AttributeError` 失敗時呼叫（或者 "
":meth:`__getattribute__` 引發 :exc:`AttributeError` 因為 *name* "
"不是實例屬性或類樹中的屬性`` self``; 或 *name* 屬性的 :meth:`__get__` 會引發 "
":exc:`AttributeError`)。此方法應回傳（計算的）屬性值或引發 "
":exc:`AttributeError` 例外。"

#: ../../reference/datamodel.rst:1610
#, fuzzy
msgid ""
"Note that if the attribute is found through the normal mechanism, :meth:"
"`__getattr__` is not called.  (This is an intentional asymmetry between :"
"meth:`__getattr__` and :meth:`__setattr__`.) This is done both for "
"efficiency reasons and because otherwise :meth:`__getattr__` would have no "
"way to access other attributes of the instance.  Note that at least for "
"instance variables, you can fake total control by not inserting any values "
"in the instance attribute dictionary (but instead inserting them in another "
"object).  See the :meth:`__getattribute__` method below for a way to "
"actually get total control over attribute access."
msgstr ""
"請注意，如果通過正常機制找到該屬性，則不會呼叫 :meth:`__getattr__`。 （這是 "
":meth:`__getattr__` 和 :meth:`__setattr__` "
"之間有意的不對稱。）這樣做既是出於效率原因，也是因為 :meth:`__getattr__` 將無"
"法訪問實例的其他屬性。請注意，至少對於實例變數，您可以通過不在實例屬性字典中"
"插入任何值（而是將它們插入另一個物件）來偽裝完全控制。請參閱下面的 "
":meth:`__getattribute__` 方法，了解一種實際完全控制屬性訪問的方法。"

#: ../../reference/datamodel.rst:1623
#, fuzzy
msgid ""
"Called unconditionally to implement attribute accesses for instances of the "
"class. If the class also defines :meth:`__getattr__`, the latter will not be "
"called unless :meth:`__getattribute__` either calls it explicitly or raises "
"an :exc:`AttributeError`. This method should return the (computed) attribute "
"value or raise an :exc:`AttributeError` exception. In order to avoid "
"infinite recursion in this method, its implementation should always call the "
"base class method with the same name to access any attributes it needs, for "
"example, ``object.__getattribute__(self, name)``."
msgstr ""
"無條件呼叫以實作類實例的屬性訪問。如果該類還定義了 "
":meth:`__getattr__`，後者將不會被呼叫，除非 :meth:`__getattribute__` "
"顯式呼叫它或引發 :exc:`AttributeError`。此方法應回傳（計算的）屬性值或引發 "
":exc:`AttributeError` 例外。為了避免此方法中的無限遞迴，其實作應始終呼叫具有"
"相同名稱的基底類別方法來訪問它需要的任何屬性，例如，``object."
"__getattribute__(self, name)``。"

#: ../../reference/datamodel.rst:1634
#, fuzzy
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or built-in functions. "
"See :ref:`special-lookup`."
msgstr "由於通過語言語法或內建函式進行隱式呼叫，因此在查找特殊方法時仍可能繞過此方法"
"。請參閱 :ref:`特殊查找`。"

#: ../../reference/datamodel.rst:1638
msgid ""
"Raises an :ref:`auditing event <auditing>` ``object.__getattr__`` with "
"arguments ``obj``, ``name``."
msgstr ""
"引發一個附帶引數 ``obj``、``name`` 的\\ :ref:`稽核事件 <auditing>` ``object.__getattr__``。"

#: ../../reference/datamodel.rst:1640
#, fuzzy
msgid ""
"For certain sensitive attribute accesses, raises an :ref:`auditing event "
"<auditing>` ``object.__getattr__`` with arguments ``obj`` and ``name``."
msgstr ""
"對於某些敏感屬性訪問，引發 :ref:`auditing 事件 <auditing>` `object."
"__getattr__`` 帶有參數 ``obj`` 和 ``name``。"

#: ../../reference/datamodel.rst:1647
#, fuzzy
msgid ""
"Called when an attribute assignment is attempted.  This is called instead of "
"the normal mechanism (i.e. store the value in the instance dictionary). "
"*name* is the attribute name, *value* is the value to be assigned to it."
msgstr "嘗試屬性分配時呼叫。這被呼叫而不是正常的機制（即將值儲存在實例字典中）。 "
"*name* 是屬性名稱，*value* 是要分配給它的值。"

#: ../../reference/datamodel.rst:1651
#, fuzzy
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it should "
"call the base class method with the same name, for example, ``object."
"__setattr__(self, name, value)``."
msgstr ""
"如果 :meth:`__setattr__` "
"想要賦值給一個實例屬性，它應該呼叫同名的基底類別方法，例如，``object."
"__setattr__(self, name, value)``。"

#: ../../reference/datamodel.rst:1655
msgid ""
"Raises an :ref:`auditing event <auditing>` ``object.__setattr__`` with "
"arguments ``obj``, ``name``, ``value``."
msgstr ""
"引發一個附帶引數 ``obj``、``name``、``value`` 的\\ :ref:`稽核事件 <auditing>` ``object.__setattr__``。"

#: ../../reference/datamodel.rst:1657
#, fuzzy
msgid ""
"For certain sensitive attribute assignments, raises an :ref:`auditing event "
"<auditing>` ``object.__setattr__`` with arguments ``obj``, ``name``, "
"``value``."
msgstr ""
"對於某些敏感屬性分配，引發一個 :ref:`審計事件 <auditing>``object."
"__setattr__`` 參數為``obj``，``name``，``value``。"

#: ../../reference/datamodel.rst:1664
#, fuzzy
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of assignment.  "
"This should only be implemented if ``del obj.name`` is meaningful for the "
"object."
msgstr "像 :meth:`__setattr__` 但用於屬性刪除而不是賦值。這應該只在 del obj.name "
"對對像有意義的情況下實作。"

#: ../../reference/datamodel.rst:1667
msgid ""
"Raises an :ref:`auditing event <auditing>` ``object.__delattr__`` with "
"arguments ``obj``, ``name``."
msgstr ""
"引發一個附帶引數 ``obj``、``name`` 的\\ :ref:`稽核事件 <auditing>` ``object.__delattr__``。"

#: ../../reference/datamodel.rst:1669
#, fuzzy
msgid ""
"For certain sensitive attribute deletions, raises an :ref:`auditing event "
"<auditing>` ``object.__delattr__`` with arguments ``obj`` and ``name``."
msgstr ""
"對於某些敏感屬性刪除，引發 :ref:`auditing 事件 <auditing>` `object."
"__delattr__`` 帶有參數 ``obj`` 和 ``name``。"

#: ../../reference/datamodel.rst:1676
#, fuzzy
msgid ""
"Called when :func:`dir` is called on the object. A sequence must be "
"returned. :func:`dir` converts the returned sequence to a list and sorts it."
msgstr "當在對像上呼叫 :func:`dir` 時呼叫。必須回傳一個序列。 :func:`dir` "
"將回傳的序列轉換為列表並對其進行排序。"

#: ../../reference/datamodel.rst:1681
#, fuzzy
msgid "Customizing module attribute access"
msgstr "自定義模組屬性訪問"

#: ../../reference/datamodel.rst:1688
#, fuzzy
msgid ""
"Special names ``__getattr__`` and ``__dir__`` can be also used to customize "
"access to module attributes. The ``__getattr__`` function at the module "
"level should accept one argument which is the name of an attribute and "
"return the computed value or raise an :exc:`AttributeError`. If an attribute "
"is not found on a module object through the normal lookup, i.e. :meth:"
"`object.__getattribute__`, then ``__getattr__`` is searched in the module "
"``__dict__`` before raising an :exc:`AttributeError`. If found, it is called "
"with the attribute name and the result is returned."
msgstr ""
"特殊名稱 ``__getattr__`` 和 ``__dir__`` 也可用於自定義對模組屬性的訪問。"
"模組級別的 ``__getattr__`` 函式應該接受一個參數，"
"即屬性名稱並回傳計算值或引發 :exc:`AttributeError`。如果通過正常查找在模組對"
"像上未找到屬性，即 :meth:`object.__getattribute__`，則在引發 "
":exc:`AttributeError` 之前在模組``__dict__`` 中搜索``__getattr__`` ."
"如果找到，則使用屬性名稱呼叫它並回傳結果。"

#: ../../reference/datamodel.rst:1697
#, fuzzy
msgid ""
"The ``__dir__`` function should accept no arguments, and return a sequence "
"of strings that represents the names accessible on module. If present, this "
"function overrides the standard :func:`dir` search on a module."
msgstr ""
"``__dir__`` "
"函式不應接受任何參數，並回傳一個字串序列，表示模組上可訪問的名稱。如果存在，"
"此函式將覆蓋模組上的標準 :func:`dir` 搜索。"

#: ../../reference/datamodel.rst:1701
#, fuzzy
msgid ""
"For a more fine grained customization of the module behavior (setting "
"attributes, properties, etc.), one can set the ``__class__`` attribute of a "
"module object to a subclass of :class:`types.ModuleType`. For example::"
msgstr ""
"為了更細粒度地自定義模組行為（設定屬性、屬性等），可以將模組物件的 __class__ "
"屬性設定為 types.ModuleType 的子類別。例如：："

#: ../../reference/datamodel.rst:1719
#, fuzzy
msgid ""
"Defining module ``__getattr__`` and setting module ``__class__`` only affect "
"lookups made using the attribute access syntax -- directly accessing the "
"module globals (whether by code within the module, or via a reference to the "
"module's globals dictionary) is unaffected."
msgstr ""
"定義模組 ``__getattr__`` 和設定模組 ``__class__`` 只影響使用屬性訪問語法進行"
"的查找——直接訪問模組全局變數（無論是通過模組內的程式碼，還是通過對模組的全局"
"字典的引用）是不受影響。"

#: ../../reference/datamodel.rst:1724
#, fuzzy
msgid "``__class__`` module attribute is now writable."
msgstr "``__class__`` 模組屬性現在是可寫的。"

#: ../../reference/datamodel.rst:1727
#, fuzzy
msgid "``__getattr__`` and ``__dir__`` module attributes."
msgstr "``__getattr__`` 和 ``__dir__`` 模組屬性。"

#: ../../reference/datamodel.rst:1732
msgid ":pep:`562` - Module __getattr__ and __dir__"
msgstr ":pep:`562` - 模組 __getattr__ 和 __dir__"

#: ../../reference/datamodel.rst:1733
#, fuzzy
msgid "Describes the ``__getattr__`` and ``__dir__`` functions on modules."
msgstr "描述模組上的``__getattr__`` 和``__dir__`` 函式。"

#: ../../reference/datamodel.rst:1739
#, fuzzy
msgid "Implementing Descriptors"
msgstr "實施描述器"

#: ../../reference/datamodel.rst:1741
#, fuzzy
msgid ""
"The following methods only apply when an instance of the class containing "
"the method (a so-called *descriptor* class) appears in an *owner* class (the "
"descriptor must be in either the owner's class dictionary or in the class "
"dictionary for one of its parents).  In the examples below, \"the "
"attribute\" refers to the attribute whose name is the key of the property in "
"the owner class' :attr:`~object.__dict__`."
msgstr ""
"以下方法僅適用於包含該方法的類的實例（所謂的*描述器*類）出現在*所有者*類中（"
"描述器必須在所有者的類字典中或在類字典中的一個）它的父母）。在下面的示例中，“"
"屬性”指的是名稱為所有者類中的屬性鍵的屬性':attr:`~object.__dict__`。"

#: ../../reference/datamodel.rst:1751
#, fuzzy
msgid ""
"Called to get the attribute of the owner class (class attribute access) or "
"of an instance of that class (instance attribute access). The optional "
"*owner* argument is the owner class, while *instance* is the instance that "
"the attribute was accessed through, or ``None`` when the attribute is "
"accessed through the *owner*."
msgstr ""
"呼叫以獲取所有者類的屬性（類屬性訪問）或該類的實例的屬性（實例屬性訪問）。"
"可選的 *owner* 參數是所有者類，而 *instance* 是訪問屬性的實例，或者當通過 "
"*owner* 訪問屬性時為 ``None``。"

#: ../../reference/datamodel.rst:1757
#, fuzzy
msgid ""
"This method should return the computed attribute value or raise an :exc:"
"`AttributeError` exception."
msgstr "此方法應回傳計算的屬性值或引發 :exc:`AttributeError` 例外。"

#: ../../reference/datamodel.rst:1760
#, fuzzy
msgid ""
":PEP:`252` specifies that :meth:`__get__` is callable with one or two "
"arguments.  Python's own built-in descriptors support this specification; "
"however, it is likely that some third-party tools have descriptors that "
"require both arguments.  Python's own :meth:`__getattribute__` "
"implementation always passes in both arguments whether they are required or "
"not."
msgstr ""
":PEP:`252` 指定 :meth:`__get__` 可以用一個或兩個參數呼叫。 Python 自帶的內建"
"描述器支援這個規範；但是，某些第三方工具的描述器很可能需要這兩個參數。 "
"Python 自己的 :meth:`__getattribute__` "
"實作總是傳入兩個參數，無論它們是否需要。"

#: ../../reference/datamodel.rst:1769
#, fuzzy
msgid ""
"Called to set the attribute on an instance *instance* of the owner class to "
"a new value, *value*."
msgstr "呼叫以將所有者類的實例 *instance* 上的屬性設定為新值 *value*。"

#: ../../reference/datamodel.rst:1772
#, fuzzy
msgid ""
"Note, adding :meth:`__set__` or :meth:`__delete__` changes the kind of "
"descriptor to a \"data descriptor\".  See :ref:`descriptor-invocation` for "
"more details."
msgstr ""
"請注意，新增 :meth:`__set__` 或 :meth:`__delete__` "
"會將描述器的種類更改為“資料描述器”。有關詳細資訊，請參閱 :ref:`descriptor-"
"invocation`。"

#: ../../reference/datamodel.rst:1778
#, fuzzy
msgid ""
"Called to delete the attribute on an instance *instance* of the owner class."
msgstr "呼叫以刪除所有者類的實例 *instance* 上的屬性。"

#: ../../reference/datamodel.rst:1781
#, fuzzy
msgid ""
"The attribute :attr:`__objclass__` is interpreted by the :mod:`inspect` "
"module as specifying the class where this object was defined (setting this "
"appropriately can assist in runtime introspection of dynamic class "
"attributes). For callables, it may indicate that an instance of the given "
"type (or a subclass) is expected or required as the first positional "
"argument (for example, CPython sets this attribute for unbound methods that "
"are implemented in C)."
msgstr ""
"屬性 :attr:`__objclass__` 被 :mod:`inspect` 模組解釋為指定定義此物件的類（適"
"當地設定它可以幫助動態類屬性的運行時內省）。對於可呼叫物件，它可能表示期望或"
"需要給定型別（或子類別）的實例作為第一個位置參數（例如，CPython 為在 C "
"中實作的未綁定方法設定此屬性）。"

#: ../../reference/datamodel.rst:1792
#, fuzzy
msgid "Invoking Descriptors"
msgstr "呼叫描述器"

#: ../../reference/datamodel.rst:1794
#, fuzzy
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol:  :meth:`~object.__get__`, :meth:`~object.__set__`, and :meth:"
"`~object.__delete__`. If any of those methods are defined for an object, it "
"is said to be a descriptor."
msgstr ""
"通常，描述器是具有“綁定行為”的物件屬性，其屬性訪問已被描述器協定中的方法覆蓋"
"：:meth:`~object.__get__`、:meth:`~object.__set__` 和 :meth:`~object."
"__delete__`。如果為物件定義了這些方法中的任何一個，則稱其為描述器。"

#: ../../reference/datamodel.rst:1800
#, fuzzy
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the base classes of ``type(a)`` excluding metaclasses."
msgstr ""
"屬性訪問的預設行為是從物件的字典中獲取、設定或刪除屬性。例如，``a.x`` "
"有一個以``a.__dict__['x']`` 開頭的查找鏈，然後是``type(a)."
"__dict__['x']``，並繼續遍歷基底類別``type(a)`` 不包括元類。"

#: ../../reference/datamodel.rst:1805
#, fuzzy
msgid ""
"However, if the looked-up value is an object defining one of the descriptor "
"methods, then Python may override the default behavior and invoke the "
"descriptor method instead.  Where this occurs in the precedence chain "
"depends on which descriptor methods were defined and how they were called."
msgstr ""
"但是，如果查找的值是定義描述器方法之一的物件，則 Python 可能會覆蓋預設行為並"
"改為呼叫描述器方法。這在優先鏈中發生的位置取決於定義了哪些描述器方法以及如何"
"呼叫它們。"

#: ../../reference/datamodel.rst:1810
#, fuzzy
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How the "
"arguments are assembled depends on ``a``:"
msgstr "描述器呼叫的起點是一個綁定，``a.x``。如何組裝參數取決於 ``a``："

#: ../../reference/datamodel.rst:1815
#, fuzzy
msgid "Direct Call"
msgstr "直呼"

#: ../../reference/datamodel.rst:1814
#, fuzzy
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr "最簡單和最不常見的呼叫是當使用者程式碼直接呼叫描述器方法時：``x."
"__get__(a)``。"

#: ../../reference/datamodel.rst:1819
#, fuzzy
msgid "Instance Binding"
msgstr "實例綁定"

#: ../../reference/datamodel.rst:1818
#, fuzzy
msgid ""
"If binding to an object instance, ``a.x`` is transformed into the call: "
"``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr "如果綁定到物件實例，``a.x`` 將轉換為呼叫：``type(a).__dict__['x'].__get__(a, "
"type(a))``。"

#: ../../reference/datamodel.rst:1823
#, fuzzy
msgid "Class Binding"
msgstr "類綁定"

#: ../../reference/datamodel.rst:1822
#, fuzzy
msgid ""
"If binding to a class, ``A.x`` is transformed into the call: ``A."
"__dict__['x'].__get__(None, A)``."
msgstr "如果綁定到一個類，``A.x`` 將轉換為呼叫：``A.__dict__['x'].__get__(None, "
"A)``。"

#: ../../reference/datamodel.rst:1829
#, fuzzy
msgid "Super Binding"
msgstr "超級綁定"

#: ../../reference/datamodel.rst:1826
#, fuzzy
msgid ""
"A dotted lookup such as ``super(A, a).x`` searches ``a.__class__.__mro__`` "
"for a base class ``B`` following ``A`` and then returns ``B.__dict__['x']."
"__get__(a, A)``.  If not a descriptor, ``x`` is returned unchanged."
msgstr ""
"諸如 ``super(A, a).x`` 的點查找在 ``A`` 之後搜索 ``a.__class__.__mro__`` "
"以查找基底類別 ``B`` 然後回傳 ``B.__dict__ ['x'].__get__(a, "
"A)``。如果不是描述器，則回傳原樣的 ``x``。"

#: ../../reference/datamodel.rst:1863
#, fuzzy
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on "
"which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`~object.__get__`, :meth:`~object.__set__` and :meth:"
"`~object.__delete__`.  If it does not define :meth:`__get__`, then accessing "
"the attribute will return the descriptor object itself unless there is a "
"value in the object's instance dictionary.  If the descriptor defines :meth:"
"`__set__` and/or :meth:`__delete__`, it is a data descriptor; if it defines "
"neither, it is a non-data descriptor.  Normally, data descriptors define "
"both :meth:`__get__` and :meth:`__set__`, while non-data descriptors have "
"just the :meth:`__get__` method.  Data descriptors with :meth:`__get__` and :"
"meth:`__set__` (and/or :meth:`__delete__`) defined always override a "
"redefinition in an instance dictionary.  In contrast, non-data descriptors "
"can be overridden by instances."
msgstr ""
"對於實例綁定，描述器呼叫的優先級取決於定義了哪些描述器方法。描述器可以定義 "
":meth:`~object.__get__`、:meth:`~object.__set__` 和 :meth:`~object."
"__delete__` 的任意組合。如果它沒有定義 "
":meth:`__get__`，那麼訪問屬性將回傳描述器物件本身，除非物件的實例字典中有值。"
"如果描述器定義了 :meth:`__set__` 和/或 :meth:`__delete__` "
"，它就是一個資料描述器；如果兩者均未定義，則它是非資料描述器。通常，"
"資料描述器同時定義 :meth:`__get__` 和 :meth:`__set__`，而非資料描述器只有 "
":meth:`__get__` 方法。定義了 :meth:`__get__` 和 :meth:`__set__`（和/或 :meth:"
"`__delete__`）的資料描述器總是覆蓋實例字典中的重新定義。相反，非資料描述器可"
"以被實例覆蓋。"

#: ../../reference/datamodel.rst:1877
#, fuzzy
msgid ""
"Python methods (including those decorated with :func:`@staticmethod "
"<staticmethod>` and :func:`@classmethod <classmethod>`) are implemented as "
"non-data descriptors.  Accordingly, instances can redefine and override "
"methods.  This allows individual instances to acquire behaviors that differ "
"from other instances of the same class."
msgstr ""
"Python 方法（包括那些用 :func:`@staticmethod <staticmethod>` 和 :func:`@"
"classmethod <classmethod>` 裝飾的方法）被實作為非資料描述器。因此，實例可以重"
"新定義和覆蓋方法。這允許單個實例獲得與同一類的其他實例不同的行為。"

#: ../../reference/datamodel.rst:1883
#, fuzzy
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ":func:`property` 函式作為資料描述器實作。因此，實例不能覆蓋屬性的行為。"

#: ../../reference/datamodel.rst:1890
msgid "__slots__"
msgstr "__slots__"

#: ../../reference/datamodel.rst:1892
#, fuzzy
msgid ""
"*__slots__* allow us to explicitly declare data members (like properties) "
"and deny the creation of :attr:`~object.__dict__` and *__weakref__* (unless "
"explicitly declared in *__slots__* or available in a parent.)"
msgstr ""
"*__slots__* 允許我們顯式聲明資料成員（如屬性）並拒絕建立 :attr:`~object."
"__dict__` 和 *__weakref__*（除非在 *__slots__* 中顯式聲明或在父級中可用。）"

#: ../../reference/datamodel.rst:1896
#, fuzzy
msgid ""
"The space saved over using :attr:`~object.__dict__` can be significant. "
"Attribute lookup speed can be significantly improved as well."
msgstr "使用 :attr:`~object.__dict__` "
"節省的空間可能很重要。屬性查找速度也可以顯著提高。"

#: ../../reference/datamodel.rst:1901
#, fuzzy
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  *__slots__* reserves space "
"for the declared variables and prevents the automatic creation of :attr:"
"`~object.__dict__` and *__weakref__* for each instance."
msgstr ""
"可以為此類變數分配一個字串、可疊代對像或具有實例使用的變數名稱的字串序列。 "
"*__slots__* 為聲明的變數保留空間並防止為每個實例自動建立 :attr:`~object."
"__dict__` 和 *__weakref__*。"

#: ../../reference/datamodel.rst:1911
#, fuzzy
msgid "Notes on using *__slots__*"
msgstr "使用 *__slots__* 的注意事項"

#: ../../reference/datamodel.rst:1913
#, fuzzy
msgid ""
"When inheriting from a class without *__slots__*, the :attr:`~object."
"__dict__` and *__weakref__* attribute of the instances will always be "
"accessible."
msgstr ""
"從沒有 *__slots__* 的類繼承時，實例的 :attr:`~object.__dict__` 和 "
"*__weakref__* 屬性將始終可訪問。"

#: ../../reference/datamodel.rst:1917
#, fuzzy
msgid ""
"Without a :attr:`~object.__dict__` variable, instances cannot be assigned "
"new variables not listed in the *__slots__* definition.  Attempts to assign "
"to an unlisted variable name raises :exc:`AttributeError`. If dynamic "
"assignment of new variables is desired, then add ``'__dict__'`` to the "
"sequence of strings in the *__slots__* declaration."
msgstr ""
"如果沒有 :attr:`~object.__dict__` 變數，則無法為實例分配未在 *__slots__* 定義"
"中列出的新變數。嘗試分配給未列出的變數名稱引發 :exec:`AttributeError`。如果需"
"要動態分配新變數，則將 ``'__dict__'`` 新增到 *__slots__* 聲明中的字串序列。"

#: ../../reference/datamodel.rst:1924
#, fuzzy
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support :mod:`weak references <weakref>` to its "
"instances. If weak reference support is needed, then add ``'__weakref__'`` "
"to the sequence of strings in the *__slots__* declaration."
msgstr ""
"如果每個實例都沒有 *__weakref__* 變數，定義 *__slots__* "
"的類將不支援對其實例的弱引用 <weakref>。如果需要弱引用支援，則將 "
"``'__weakref__'`` 新增到 *__slots__* 聲明中的字串序列。"

#: ../../reference/datamodel.rst:1930
#, fuzzy
msgid ""
"*__slots__* are implemented at the class level by creating :ref:`descriptors "
"<descriptors>` for each variable name.  As a result, class attributes cannot "
"be used to set default values for instance variables defined by *__slots__*; "
"otherwise, the class attribute would overwrite the descriptor assignment."
msgstr ""
"*__slots__* 通過為每個變數名建立 :ref:`descriptors <descriptors>` "
"在類級別實作。因此，類屬性不能用於為 *__slots__* "
"定義的實例變數設定預設值；否則，類屬性將覆蓋描述器分配。"

#: ../../reference/datamodel.rst:1936
#, fuzzy
msgid ""
"The action of a *__slots__* declaration is not limited to the class where it "
"is defined.  *__slots__* declared in parents are available in child classes. "
"However, child subclasses will get a :attr:`~object.__dict__` and "
"*__weakref__* unless they also define *__slots__* (which should only contain "
"names of any *additional* slots)."
msgstr ""
"*__slots__* 聲明的作用不限於定義它的類。 *__slots__* "
"在父類中聲明的在子類別中可用。但是，子類別將獲得 :attr:`~object.__dict__` 和 "
"*__weakref__* 除非它們還定義了 *__slots__* （它應該只包含任何 *additional* "
"插槽的名稱）。"

#: ../../reference/datamodel.rst:1942
#, fuzzy
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the "
"meaning of the program undefined.  In the future, a check may be added to "
"prevent this."
msgstr ""
"如果一個類定義了一個也在基底類別中定義的槽，則基底類別槽定義的實例變數是不可"
"訪問的（除非直接從基底類別中檢索它的描述器）。這使得程式的含義未定義。將來可"
"能會新增檢查以防止這種情況。"

#: ../../reference/datamodel.rst:1947
#, fuzzy
msgid ""
":exc:`TypeError` will be raised if nonempty *__slots__* are defined for a "
"class derived from a :c:member:`\"variable-length\" built-in type "
"<PyTypeObject.tp_itemsize>` such as :class:`int`, :class:`bytes`, and :class:"
"`tuple`."
msgstr ""
"如果為派生自 :c:member:`\"variable-length\" 內建型別 <PyTypeObject."
"tp_itemsize>` 的類定義了非空 *__slots__* ，例如 :class:`int，則會引發 "
"TypeError `、:class:`bytes` 和 :class:`tuple`。"

#: ../../reference/datamodel.rst:1952
#, fuzzy
msgid "Any non-string :term:`iterable` may be assigned to *__slots__*."
msgstr "任何非字串 :term:`iterable` 都可以分配給 *__slots__*。"

#: ../../reference/datamodel.rst:1954
#, fuzzy
msgid ""
"If a :class:`dictionary <dict>` is used to assign *__slots__*, the "
"dictionary keys will be used as the slot names. The values of the dictionary "
"can be used to provide per-attribute docstrings that will be recognised by :"
"func:`inspect.getdoc` and displayed in the output of :func:`help`."
msgstr ""
"如果 :class:`dictionary <dict>` 用於分配 *__slots__*，則字典鍵將用作插槽名稱"
"。字典的值可用於提供每個屬性的文檔字串，這些文檔字串將被 :func:`inspect."
"getdoc` 識別並顯示在 :func:`help` 的輸出中。"

#: ../../reference/datamodel.rst:1959
#, fuzzy
msgid ""
":attr:`~instance.__class__` assignment works only if both classes have the "
"same *__slots__*."
msgstr ":attr:`~instance.__class__` 賦值僅在兩個類具有相同的 *__slots__* 時才有效。"

#: ../../reference/datamodel.rst:1962
#, fuzzy
msgid ""
":ref:`Multiple inheritance <tut-multiple>` with multiple slotted parent "
"classes can be used, but only one parent is allowed to have attributes "
"created by slots (the other bases must have empty slot layouts) - violations "
"raise :exc:`TypeError`."
msgstr ""
":ref:`多重繼承 <tut-multiple>` 可以使用多個帶插槽的父類，但只允許一個父類具有"
"由插槽建立的屬性（其他基底類別必須具有空插槽佈局）-違規行為引發 :exec:`型別錯"
"誤`。"

#: ../../reference/datamodel.rst:1968
#, fuzzy
msgid ""
"If an :term:`iterator` is used for *__slots__* then a :term:`descriptor` is "
"created for each of the iterator's values. However, the *__slots__* "
"attribute will be an empty iterator."
msgstr ""
"如果 :term:`iterator` 用於 *__slots__* 則為每個疊代器的值建立一個 "
":term:`descriptor`。但是，*__slots__* 屬性將是一個空疊代器。"

#: ../../reference/datamodel.rst:1976
#, fuzzy
msgid "Customizing class creation"
msgstr "自定義類建立"

#: ../../reference/datamodel.rst:1978
#, fuzzy
msgid ""
"Whenever a class inherits from another class, :meth:`~object."
"__init_subclass__` is called on the parent class. This way, it is possible "
"to write classes which change the behavior of subclasses. This is closely "
"related to class decorators, but where class decorators only affect the "
"specific class they're applied to, ``__init_subclass__`` solely applies to "
"future subclasses of the class defining the method."
msgstr ""
"每當一個類從另一個類繼承時， :meth:`~object.__init_subclass__` 在父類上被呼叫"
"。這樣，就可以編寫改變子類別行為的類。這與類裝飾器密切相關，但是類裝飾器只影"
"響它們所應用的特定類，``__init_subclass__`` "
"僅適用於定義該方法的類的未來子類別。"

#: ../../reference/datamodel.rst:1987
#, fuzzy
msgid ""
"This method is called whenever the containing class is subclassed. *cls* is "
"then the new subclass. If defined as a normal instance method, this method "
"is implicitly converted to a class method."
msgstr "只要包含類被子類別化，就會呼叫此方法。 *cls* "
"是新的子類別。如果定義為普通實例方法，則此方法將隱式轉換為類方法。"

#: ../../reference/datamodel.rst:1991
#, fuzzy
msgid ""
"Keyword arguments which are given to a new class are passed to the parent's "
"class ``__init_subclass__``. For compatibility with other classes using "
"``__init_subclass__``, one should take out the needed keyword arguments and "
"pass the others over to the base class, as in::"
msgstr ""
"賦予新類的關鍵字參數被傳遞給父類 ``__init_subclass__``。為了與使用 "
"``__init_subclass__`` "
"的其他類相容，應該取出所需的關鍵字參數並將其他的傳遞給基底類別，如下所示："

#: ../../reference/datamodel.rst:2005
#, fuzzy
msgid ""
"The default implementation ``object.__init_subclass__`` does nothing, but "
"raises an error if it is called with any arguments."
msgstr "預設實作 ``object.__init_subclass__`` "
"什麼都不做，但如果使用任何參數呼叫它會引發錯誤。"

#: ../../reference/datamodel.rst:2010
#, fuzzy
msgid ""
"The metaclass hint ``metaclass`` is consumed by the rest of the type "
"machinery, and is never passed to ``__init_subclass__`` implementations. The "
"actual metaclass (rather than the explicit hint) can be accessed as "
"``type(cls)``."
msgstr ""
"元類提示 ``metaclass`` 由其餘型別機制使用，並且永遠不會傳遞給 "
"``__init_subclass__`` 實作。實際的元類（而不是顯式提示）可以作為 type(cls) "
"訪問。"

#: ../../reference/datamodel.rst:2018
#, fuzzy
msgid ""
"When a class is created, :meth:`type.__new__` scans the class variables and "
"makes callbacks to those with a :meth:`~object.__set_name__` hook."
msgstr ""
"建立類時，:meth:`type.__new__` 掃描類變數並使用 :meth:`~object.__set_name__` "
"鉤子對那些變數進行回呼。"

#: ../../reference/datamodel.rst:2023
#, fuzzy
msgid ""
"Automatically called at the time the owning class *owner* is created. The "
"object has been assigned to *name* in that class::"
msgstr "在建立擁有類 *owner* 時自動呼叫。該對像已分配給該類中的 *name*::"

#: ../../reference/datamodel.rst:2029
#, fuzzy
msgid ""
"If the class variable is assigned after the class is created, :meth:"
"`__set_name__` will not be called automatically. If needed, :meth:"
"`__set_name__` can be called directly::"
msgstr ""
"如果類變數是在類建立之後賦值的，:meth:`__set_name__` "
"不會被自動呼叫。如果需要，可以直接呼叫 :meth:`__set_name__`::"

#: ../../reference/datamodel.rst:2040
msgid "See :ref:`class-object-creation` for more details."
msgstr "更多細節請見 :ref:`class-object-creation`\\ 。"

#: ../../reference/datamodel.rst:2048
#, fuzzy
msgid "Metaclasses"
msgstr "元類"

#: ../../reference/datamodel.rst:2055
#, fuzzy
msgid ""
"By default, classes are constructed using :func:`type`. The class body is "
"executed in a new namespace and the class name is bound locally to the "
"result of ``type(name, bases, namespace)``."
msgstr ""
"預設情況下，類是使用 :func:`type` 構造的。類主體在新的命名空間中執行，"
"類名在本地綁定到 type(name, bases, namespace) 的結果。"

#: ../../reference/datamodel.rst:2059
#, fuzzy
msgid ""
"The class creation process can be customized by passing the ``metaclass`` "
"keyword argument in the class definition line, or by inheriting from an "
"existing class that included such an argument. In the following example, "
"both ``MyClass`` and ``MySubclass`` are instances of ``Meta``::"
msgstr ""
"可以通過在類定義行中傳遞 ``metaclass`` 關鍵字參數，或通過繼承包含此類參數的現"
"有類來自定義類建立過程。在下面的例子中，``MyClass`` 和``MySubclass`` "
"都是``Meta`` 的實例："

#: ../../reference/datamodel.rst:2073
#, fuzzy
msgid ""
"Any other keyword arguments that are specified in the class definition are "
"passed through to all metaclass operations described below."
msgstr "類定義中指定的任何其他關鍵字參數都將傳遞給下面描述的所有元類操作。"

#: ../../reference/datamodel.rst:2076
#, fuzzy
msgid "When a class definition is executed, the following steps occur:"
msgstr "執行類定義時，會發生以下步驟："

#: ../../reference/datamodel.rst:2078
#, fuzzy
msgid "MRO entries are resolved;"
msgstr "MRO條目已解決；"

#: ../../reference/datamodel.rst:2079
#, fuzzy
msgid "the appropriate metaclass is determined;"
msgstr "確定了適當的元類；"

#: ../../reference/datamodel.rst:2080
#, fuzzy
msgid "the class namespace is prepared;"
msgstr "準備好類命名空間；"

#: ../../reference/datamodel.rst:2081
#, fuzzy
msgid "the class body is executed;"
msgstr "類主體被執行；"

#: ../../reference/datamodel.rst:2082
#, fuzzy
msgid "the class object is created."
msgstr "類對像被建立。"

#: ../../reference/datamodel.rst:2086
#, fuzzy
msgid "Resolving MRO entries"
msgstr "解析 MRO 條目"

#: ../../reference/datamodel.rst:2090
#, fuzzy
msgid ""
"If a base that appears in a class definition is not an instance of :class:"
"`type`, then an :meth:`!__mro_entries__` method is searched on the base. If "
"an :meth:`!__mro_entries__` method is found, the base is substituted with "
"the result of a call to :meth:`!__mro_entries__` when creating the class. "
"The method is called with the original bases tuple passed to the *bases* "
"parameter, and must return a tuple of classes that will be used instead of "
"the base. The returned tuple may be empty: in these cases, the original base "
"is ignored."
msgstr ""
"如果出現在類定義中的基不是 :class:`type` 的實例，那麼 "
":meth:`!__mro_entries__` 方法會在該基上搜索。如果找到 "
":meth:`!__mro_entries__` 方法，則在建立類時，基數將替換為呼叫 "
":meth:`!__mro_entries__` 的結果。使用傳遞給 *bases* 參數的原始基數元組呼叫該"
"方法，並且必須回傳將使用的類的元組而不是基數。回傳的元組可能為空：在這些情況"
"下，忽略原始基數。"

#: ../../reference/datamodel.rst:2102
#, fuzzy
msgid ":func:`types.resolve_bases`"
msgstr ":func:`types.resolve_bases`"

#: ../../reference/datamodel.rst:2102
#, fuzzy
msgid "Dynamically resolve bases that are not instances of :class:`type`."
msgstr "動態解析不是 :class:`type` 實例的基底類別。"

#: ../../reference/datamodel.rst:2104
#, fuzzy
msgid ":pep:`560`"
msgstr ":pep:`560`"

#: ../../reference/datamodel.rst:2105
#, fuzzy
msgid "Core support for typing module and generic types."
msgstr "對型別模組和通用型別的核心支援。"

#: ../../reference/datamodel.rst:2109
#, fuzzy
msgid "Determining the appropriate metaclass"
msgstr "確定適當的元類"

#: ../../reference/datamodel.rst:2113
#, fuzzy
msgid ""
"The appropriate metaclass for a class definition is determined as follows:"
msgstr "類定義的適當元類確定如下："

#: ../../reference/datamodel.rst:2115
#, fuzzy
msgid ""
"if no bases and no explicit metaclass are given, then :func:`type` is used;"
msgstr "如果沒有給出基底類別和顯式元類，則使用 :func:`type` ；"

#: ../../reference/datamodel.rst:2116
#, fuzzy
msgid ""
"if an explicit metaclass is given and it is *not* an instance of :func:"
"`type`, then it is used directly as the metaclass;"
msgstr "如果給出了一個明確的元類並且它*不是* :func:`type` "
"的實例，那麼它直接用作元類；"

#: ../../reference/datamodel.rst:2118
#, fuzzy
msgid ""
"if an instance of :func:`type` is given as the explicit metaclass, or bases "
"are defined, then the most derived metaclass is used."
msgstr "如果 :func:`type` "
"的實例作為顯式元類給出，或者定義了基底類別，則使用最派生的元類。"

#: ../../reference/datamodel.rst:2121
#, fuzzy
msgid ""
"The most derived metaclass is selected from the explicitly specified "
"metaclass (if any) and the metaclasses (i.e. ``type(cls)``) of all specified "
"base classes. The most derived metaclass is one which is a subtype of *all* "
"of these candidate metaclasses. If none of the candidate metaclasses meets "
"that criterion, then the class definition will fail with ``TypeError``."
msgstr ""
"最派生的元類是從明確指定的元類（如果有的話）和所有指定基底類別的元類（即 ``ty"
"pe(cls)``）中選擇的。最派生的元類是*所有*這些候選元類的子型別。如果沒有一個候"
"選元類滿足該標準，則類定義將失敗並出現 ``TypeError`` 。"

#: ../../reference/datamodel.rst:2131
#, fuzzy
msgid "Preparing the class namespace"
msgstr "準備類命名空間"

#: ../../reference/datamodel.rst:2136
#, fuzzy
msgid ""
"Once the appropriate metaclass has been identified, then the class namespace "
"is prepared. If the metaclass has a ``__prepare__`` attribute, it is called "
"as ``namespace = metaclass.__prepare__(name, bases, **kwds)`` (where the "
"additional keyword arguments, if any, come from the class definition). The "
"``__prepare__`` method should be implemented as a :func:`classmethod "
"<classmethod>`. The namespace returned by ``__prepare__`` is passed in to "
"``__new__``, but when the final class object is created the namespace is "
"copied into a new ``dict``."
msgstr ""
"一旦確定了適當的元類，就準備好類命名空間。如果元類有一個``__prepare__``屬性，"
"它被稱為``namespace = metaclass.__prepare__(name, bases, "
"**kwds)``（如果有的話，額外的關鍵字參數來自類定義） . ``__prepare__`` "
"方法應該作為一個 :func:`classmethod <classmethod>` 來實作。 ``__prepare__`` "
"回傳的命名空間被傳遞給``__new__``，但是當建立最終類物件時，命名空間被複製到一"
"個新的``dict`` 中。"

#: ../../reference/datamodel.rst:2145
#, fuzzy
msgid ""
"If the metaclass has no ``__prepare__`` attribute, then the class namespace "
"is initialised as an empty ordered mapping."
msgstr "如果元類沒有 __prepare__ 屬性，那麼類命名空間將被初始化為一個空的有序映射。"

#: ../../reference/datamodel.rst:2150
#, fuzzy
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Python 3000 中的元類"

#: ../../reference/datamodel.rst:2151
#, fuzzy
msgid "Introduced the ``__prepare__`` namespace hook"
msgstr "引入了``__prepare__`` 命名空間鉤子"

#: ../../reference/datamodel.rst:2155
#, fuzzy
msgid "Executing the class body"
msgstr "執行類主體"

#: ../../reference/datamodel.rst:2160
#, fuzzy
msgid ""
"The class body is executed (approximately) as ``exec(body, globals(), "
"namespace)``. The key difference from a normal call to :func:`exec` is that "
"lexical scoping allows the class body (including any methods) to reference "
"names from the current and outer scopes when the class definition occurs "
"inside a function."
msgstr ""
"類主體（大約）作為 exec(body, globals(), namespace) 執行。與對 :func:`exec` "
"的正常呼叫的主要區別在於，當類定義出現在函式內部時，詞法範圍允許類主體（包括"
"任何方法）從當前範圍和外部範圍引用名稱。"

#: ../../reference/datamodel.rst:2166
#, fuzzy
msgid ""
"However, even when the class definition occurs inside the function, methods "
"defined inside the class still cannot see names defined at the class scope. "
"Class variables must be accessed through the first parameter of instance or "
"class methods, or through the implicit lexically scoped ``__class__`` "
"reference described in the next section."
msgstr ""
"但是，即使類定義發生在函式內部，類內部定義的方法仍然看不到類範圍內定義的名稱"
"。類變數必須通過實例或類方法的第一個參數訪問，或者通過下一節中描述的隱式詞法"
"範圍的“__class__”引用訪問。"

#: ../../reference/datamodel.rst:2175
#, fuzzy
msgid "Creating the class object"
msgstr "建立類物件"

#: ../../reference/datamodel.rst:2182
#, fuzzy
msgid ""
"Once the class namespace has been populated by executing the class body, the "
"class object is created by calling ``metaclass(name, bases, namespace, "
"**kwds)`` (the additional keywords passed here are the same as those passed "
"to ``__prepare__``)."
msgstr ""
"通過執行類主體填充類命名空間後，將通過呼叫``metaclass(name, bases, "
"namespace, **kwds)`` 建立類物件（此處傳遞的附加關鍵字與傳遞給的關鍵字相同） "
"`__準備__``）。"

#: ../../reference/datamodel.rst:2187
#, fuzzy
msgid ""
"This class object is the one that will be referenced by the zero-argument "
"form of :func:`super`. ``__class__`` is an implicit closure reference "
"created by the compiler if any methods in a class body refer to either "
"``__class__`` or ``super``. This allows the zero argument form of :func:"
"`super` to correctly identify the class being defined based on lexical "
"scoping, while the class or instance that was used to make the current call "
"is identified based on the first argument passed to the method."
msgstr ""
"此類物件將被 :func:`super` 的零參數形式引用。 ``__class__`` "
"是編譯器建立的隱式閉包引用，如果類主體中的任何方法引用 ``__class__`` 或 "
"``super``。這允許 :func:`super` 的零參數形式根據詞法範圍正確識別正在定義的類"
"，同時根據傳遞給方法的第一個參數識別用於進行當前呼叫的類或實例。"

#: ../../reference/datamodel.rst:2197
#, fuzzy
msgid ""
"In CPython 3.6 and later, the ``__class__`` cell is passed to the metaclass "
"as a ``__classcell__`` entry in the class namespace. If present, this must "
"be propagated up to the ``type.__new__`` call in order for the class to be "
"initialised correctly. Failing to do so will result in a :exc:`RuntimeError` "
"in Python 3.8."
msgstr ""
"在 CPython 3.6 及更高版本中，``__class__`` 單元作為類命名空間中的 "
"``__classcell__`` 條目傳遞給元類。如果存在，則必須傳播到 ``type.__new__`` "
"呼叫，以便正確初始化類。如果不這樣做，將導致 Python 3.8 中出現 "
":exc:`RuntimeError`。"

#: ../../reference/datamodel.rst:2203
#, fuzzy
msgid ""
"When using the default metaclass :class:`type`, or any metaclass that "
"ultimately calls ``type.__new__``, the following additional customization "
"steps are invoked after creating the class object:"
msgstr ""
"當使用預設元類 :class:`type` 或任何最終呼叫 ``type.__new__`` "
"的元類時，在建立類對像後呼叫以下額外的自定義步驟："

#: ../../reference/datamodel.rst:2207
#, fuzzy
msgid ""
"The ``type.__new__`` method collects all of the attributes in the class "
"namespace that define a :meth:`~object.__set_name__` method;"
msgstr "``type.__new__`` 方法收集類命名空間中定義 :meth:`~object.__set_name__` "
"方法的所有屬性；"

#: ../../reference/datamodel.rst:2209
#, fuzzy
msgid ""
"Those ``__set_name__`` methods are called with the class being defined and "
"the assigned name of that particular attribute;"
msgstr "那些``__set_name__`` 方法是通過定義的類和該特定屬性的指定名稱來呼叫的；"

#: ../../reference/datamodel.rst:2211
#, fuzzy
msgid ""
"The :meth:`~object.__init_subclass__` hook is called on the immediate parent "
"of the new class in its method resolution order."
msgstr ":meth:`~object.__init_subclass__` "
"掛鉤在新類的直接父級上按其方法解析順序呼叫。"

#: ../../reference/datamodel.rst:2214
#, fuzzy
msgid ""
"After the class object is created, it is passed to the class decorators "
"included in the class definition (if any) and the resulting object is bound "
"in the local namespace as the defined class."
msgstr "建立類對像後，它被傳遞給類定義中包含的類裝飾器（如果有的話），結果對像作為定"
"義的類綁定在本地命名空間中。"

#: ../../reference/datamodel.rst:2218
#, fuzzy
msgid ""
"When a new class is created by ``type.__new__``, the object provided as the "
"namespace parameter is copied to a new ordered mapping and the original "
"object is discarded. The new copy is wrapped in a read-only proxy, which "
"becomes the :attr:`~object.__dict__` attribute of the class object."
msgstr ""
"當通過 type.__new__ 建立新類時，作為命名空間參數提供的對像被複製到新的有序映"
"射中，原始對像被丟棄。新副本包裝在只讀代理中，成為類物件的 :attr:`~object."
"__dict__` 屬性。"

#: ../../reference/datamodel.rst:2225
#, fuzzy
msgid ":pep:`3135` - New super"
msgstr ":pep:`3135` - 新超級"

#: ../../reference/datamodel.rst:2226
#, fuzzy
msgid "Describes the implicit ``__class__`` closure reference"
msgstr "描述隱式的 ``__class__`` 閉包引用"

#: ../../reference/datamodel.rst:2230
#, fuzzy
msgid "Uses for metaclasses"
msgstr "用於元類"

#: ../../reference/datamodel.rst:2232
#, fuzzy
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have been "
"explored include enum, logging, interface checking, automatic delegation, "
"automatic property creation, proxies, frameworks, and automatic resource "
"locking/synchronization."
msgstr "元類的潛在用途是無限的。已經探索的一些想法包括枚舉、日誌記錄、介面檢查、自動"
"委託、自動屬性建立、代理、框架和自動資源鎖定/同步。"

#: ../../reference/datamodel.rst:2239
#, fuzzy
msgid "Customizing instance and subclass checks"
msgstr "自定義實例和子類別檢查"

#: ../../reference/datamodel.rst:2241
#, fuzzy
msgid ""
"The following methods are used to override the default behavior of the :func:"
"`isinstance` and :func:`issubclass` built-in functions."
msgstr "以下方法用於覆蓋 :func:`isinstance` 和 :func:`issubclass` "
"內建函式的預設行為。"

#: ../../reference/datamodel.rst:2244
#, fuzzy
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these methods "
"in order to allow the addition of Abstract Base Classes (ABCs) as \"virtual "
"base classes\" to any class or type (including built-in types), including "
"other ABCs."
msgstr ""
"特別是，元類 abc.ABCMeta 實作了這些方法，以便允許將抽象基底類別 (ABC) "
"作為“虛擬基底類別”新增到任何類或型別（包括內建型別），包括其他基礎知識。"

#: ../../reference/datamodel.rst:2251
#, fuzzy
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement ``isinstance(instance, "
"class)``."
msgstr ""
"如果 *instance* 應被視為 *class* 的（直接或間接）實例，則回傳 "
"true。如果已定義，則呼叫以實作“isinstance(instance, class)”。"

#: ../../reference/datamodel.rst:2258
#, fuzzy
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement ``issubclass(subclass, "
"class)``."
msgstr ""
"如果 *subclass* 應被視為 *class* 的（直接或間接）子類別，則回傳 "
"true。如果已定義，則呼叫以實作 ``issubclass(subclass, class)``。"

#: ../../reference/datamodel.rst:2263
#, fuzzy
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class.  "
"They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on instances, "
"only in this case the instance is itself a class."
msgstr ""
"請注意，這些方法是在類的型別（元類）上查找的。它們不能被定義為實際類中的類方"
"法。這與查找在實例上呼叫的特殊方法是一致的，只是在這種情況下實例本身就是一個"
"類。"

#: ../../reference/datamodel.rst:2274
#, fuzzy
msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ":pep:`3119` - 引入抽象基底類別"

#: ../../reference/datamodel.rst:2271
#, fuzzy
msgid ""
"Includes the specification for customizing :func:`isinstance` and :func:"
"`issubclass` behavior through :meth:`~class.__instancecheck__` and :meth:"
"`~class.__subclasscheck__`, with motivation for this functionality in the "
"context of adding Abstract Base Classes (see the :mod:`abc` module) to the "
"language."
msgstr ""
"包括通過 :meth:`~class.__instancecheck__` 和 :meth:`~class.__subclasscheck__`"
" 自定義 :func:`isinstance` 和 :func:`issubclass` "
"行為的規範，在新增的上下文中具有此功能的動機語言的抽象基底類別（參見 "
":mod:`abc` 模組）。"

#: ../../reference/datamodel.rst:2279
#, fuzzy
msgid "Emulating generic types"
msgstr "模擬泛型"

#: ../../reference/datamodel.rst:2281
#, fuzzy
msgid ""
"When using :term:`type annotations<annotation>`, it is often useful to "
"*parameterize* a :term:`generic type` using Python's square-brackets "
"notation. For example, the annotation ``list[int]`` might be used to signify "
"a :class:`list` in which all the elements are of type :class:`int`."
msgstr ""
"使用 :term:`type annotations<annotation>` 時，使用 Python "
"的方括號表示法*參數化* :term:`generic type` 通常很有用。例如，註解 "
"``list[int]`` 可能用於表示一個 :class:`list`，其中所有元素都是 :class:`int` "
"型別。"

#: ../../reference/datamodel.rst:2289
#, fuzzy
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - 型別提示"

#: ../../reference/datamodel.rst:2289
#, fuzzy
msgid "Introducing Python's framework for type annotations"
msgstr "介紹 Python 的型別註解框架"

#: ../../reference/datamodel.rst:2292
#, fuzzy
msgid ":ref:`Generic Alias Types<types-genericalias>`"
msgstr ":ref:`通用別名型別<types-genericalias>`"

#: ../../reference/datamodel.rst:2292
#, fuzzy
msgid "Documentation for objects representing parameterized generic classes"
msgstr "表示參數化泛型類的物件的文檔"

#: ../../reference/datamodel.rst:2295
#, fuzzy
msgid ""
":ref:`Generics`, :ref:`user-defined generics<user-defined-generics>` and :"
"class:`typing.Generic`"
msgstr ""
":ref:`Generics`, :ref:`user-defined generics<user-defined-generics>` and "
":class:`typing.Generic`"

#: ../../reference/datamodel.rst:2295
#, fuzzy
msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr "有關如何實作可以在運行時參數化並被靜態型別檢查器理解的泛型類的文檔。"

#: ../../reference/datamodel.rst:2298
#, fuzzy
msgid ""
"A class can *generally* only be parameterized if it defines the special "
"class method ``__class_getitem__()``."
msgstr "如果一個類定義了特殊的類方法``__class_getitem__()``，那麼它*通常*只能被參數化"
"。"

#: ../../reference/datamodel.rst:2303
#, fuzzy
msgid ""
"Return an object representing the specialization of a generic class by type "
"arguments found in *key*."
msgstr "通過在 *key* 中找到的型別參數回傳一個代表泛型類特化的物件。"

#: ../../reference/datamodel.rst:2306
#, fuzzy
msgid ""
"When defined on a class, ``__class_getitem__()`` is automatically a class "
"method. As such, there is no need for it to be decorated with :func:"
"`@classmethod<classmethod>` when it is defined."
msgstr ""
"在類上定義時，``__class_getitem__()`` 自動成為類方法。因此，在定義時不需要用 "
":func:`@classmethod<classmethod>` 修飾它。"

#: ../../reference/datamodel.rst:2312
#, fuzzy
msgid "The purpose of *__class_getitem__*"
msgstr "*__class_getitem__* 的目的"

#: ../../reference/datamodel.rst:2314
#, fuzzy
msgid ""
"The purpose of :meth:`~object.__class_getitem__` is to allow runtime "
"parameterization of standard-library generic classes in order to more easily "
"apply :term:`type hints<type hint>` to these classes."
msgstr ""
":meth:`~object.__class_getitem__` 的目的是允許標準庫泛型類的運行時參數化，"
"以便更容易地將 :term:`type hints<type hint>` 應用於這些類。"

#: ../../reference/datamodel.rst:2318
#, fuzzy
msgid ""
"To implement custom generic classes that can be parameterized at runtime and "
"understood by static type-checkers, users should either inherit from a "
"standard library class that already implements :meth:`~object."
"__class_getitem__`, or inherit from :class:`typing.Generic`, which has its "
"own implementation of ``__class_getitem__()``."
msgstr ""
"要實作可以在運行時參數化並被靜態型別檢查器理解的自定義泛型類，"
"使用者應該從已經實作 :meth:`~object.__class_getitem__` 的標準庫類繼承，"
"或者從 :class:`typing 繼承。 Generic`，它有自己的 ``__class_getitem__()`` "
"實作。"

#: ../../reference/datamodel.rst:2324
#, fuzzy
msgid ""
"Custom implementations of :meth:`~object.__class_getitem__` on classes "
"defined outside of the standard library may not be understood by third-party "
"type-checkers such as mypy. Using ``__class_getitem__()`` on any class for "
"purposes other than type hinting is discouraged."
msgstr ""
":meth:`~object.__class_getitem__` "
"在標準庫之外定義的類上的自定義實作可能無法被第三方型別檢查器（例如 "
"mypy）理解。不鼓勵在任何類上出於型別提示以外的目的使用 "
"`__class_getitem__()``。"

#: ../../reference/datamodel.rst:2334
#, fuzzy
msgid "*__class_getitem__* versus *__getitem__*"
msgstr "*__class_getitem__* 與 *__getitem__*"

#: ../../reference/datamodel.rst:2336
#, fuzzy
msgid ""
"Usually, the :ref:`subscription<subscriptions>` of an object using square "
"brackets will call the :meth:`~object.__getitem__` instance method defined "
"on the object's class. However, if the object being subscribed is itself a "
"class, the class method :meth:`~object.__class_getitem__` may be called "
"instead. ``__class_getitem__()`` should return a :ref:`GenericAlias<types-"
"genericalias>` object if it is properly defined."
msgstr ""
"通常，使用方括號的物件的 :ref:`subscription<subscriptions>` "
"將呼叫對像類上定義的 :meth:`~object.__getitem__` "
"實例方法。但是，如果被訂閱的物件本身是一個類，類方法 :meth:`~object."
"__class_getitem__` 可能會被呼叫。 ``__class_getitem__()`` 應該回傳一個 "
":ref:`GenericAlias<types-genericalias>` 物件，如果它被正確定義的話。"

#: ../../reference/datamodel.rst:2343
#, fuzzy
msgid ""
"Presented with the :term:`expression` ``obj[x]``, the Python interpreter "
"follows something like the following process to decide whether :meth:"
"`~object.__getitem__` or :meth:`~object.__class_getitem__` should be called::"
msgstr ""
"與 :term:`expression` ``obj[x]`` 一起出現，Python "
"直譯器遵循類似以下過程來決定 :meth:`~object.__getitem__` 還是 :meth:`~object."
"__class_getitem__` 應該叫做：："

#: ../../reference/datamodel.rst:2371
#, fuzzy
msgid ""
"In Python, all classes are themselves instances of other classes. The class "
"of a class is known as that class's :term:`metaclass`, and most classes have "
"the :class:`type` class as their metaclass. :class:`type` does not define :"
"meth:`~object.__getitem__`, meaning that expressions such as ``list[int]``, "
"``dict[str, float]`` and ``tuple[str, bytes]`` all result in :meth:`~object."
"__class_getitem__` being called::"
msgstr ""
"在 Python 中，所有類本身都是其他類的實例。一個類的類稱為該類的 "
":term:`metaclass`，大多數類都有 :class:`type` 類作為它們的元類。 "
":class:`type` 沒有定義 :meth:`~object.__getitem__`，意思是像 "
"``list[int]``、``dict[str, float]`` 和 ``tuple[str, bytes]`` 都導致 "
":meth:`~object.__class_getitem__` 被呼叫::"

#: ../../reference/datamodel.rst:2390
#, fuzzy
msgid ""
"However, if a class has a custom metaclass that defines :meth:`~object."
"__getitem__`, subscribing the class may result in different behaviour. An "
"example of this can be found in the :mod:`enum` module::"
msgstr ""
"然而，如果一個類有一個自定義的元類，它定義了 :meth:`~object."
"__getitem__`，訂閱這個類可能會導致不同的行為。這方面的一個例子可以在 "
":mod:`enum` 模組中找到："

#: ../../reference/datamodel.rst:2415
#, fuzzy
msgid ":pep:`560` - Core Support for typing module and generic types"
msgstr ":pep:`560` - 對輸入模組和通用型別的核心支援"

#: ../../reference/datamodel.rst:2414
#, fuzzy
msgid ""
"Introducing :meth:`~object.__class_getitem__`, and outlining when a :ref:"
"`subscription<subscriptions>` results in ``__class_getitem__()`` being "
"called instead of :meth:`~object.__getitem__`"
msgstr ""
"介紹 :meth:`~object.__class_getitem__`，並概述何時 "
":ref:`subscription<subscriptions>` 導致呼叫 `__class_getitem__()`` 而不是 "
":meth:`~object.__getitem__`"

#: ../../reference/datamodel.rst:2422
#, fuzzy
msgid "Emulating callable objects"
msgstr "模擬可呼叫物件"

#: ../../reference/datamodel.rst:2429
#, fuzzy
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` roughly translates to ``type(x).__call__(x, "
"arg1, ...)``."
msgstr ""
"當實例作為函式被“呼叫”時被呼叫；如果定義了這個方法，``x(arg1, arg2, ...)`` "
"大致轉換為 ``type(x).__call__(x, arg1, ...)``。"

#: ../../reference/datamodel.rst:2436
#, fuzzy
msgid "Emulating container types"
msgstr "模擬容器型別"

#: ../../reference/datamodel.rst:2438
#, fuzzy
msgid ""
"The following methods can be defined to implement container objects.  "
"Containers usually are :term:`sequences <sequence>` (such as :class:`lists "
"<list>` or :class:`tuples <tuple>`) or :term:`mappings <mapping>` (like :"
"class:`dictionaries <dict>`), but can represent other containers as well.  "
"The first set of methods is used either to emulate a sequence or to emulate "
"a mapping; the difference is that for a sequence, the allowable keys should "
"be the integers *k* for which ``0 <= k < N`` where *N* is the length of the "
"sequence, or :class:`slice` objects, which define a range of items.  It is "
"also recommended that mappings provide the methods :meth:`keys`, :meth:"
"`values`, :meth:`items`, :meth:`get`, :meth:`clear`, :meth:`setdefault`, :"
"meth:`pop`, :meth:`popitem`, :meth:`!copy`, and :meth:`update` behaving "
"similar to those for Python's standard :class:`dictionary <dict>` objects.  "
"The :mod:`collections.abc` module provides a :class:`~collections.abc."
"MutableMapping` :term:`abstract base class` to help create those methods "
"from a base set of :meth:`~object.__getitem__`, :meth:`~object."
"__setitem__`, :meth:`~object.__delitem__`, and :meth:`keys`. Mutable "
"sequences should provide methods :meth:`append`, :meth:`count`, :meth:"
"`index`, :meth:`extend`, :meth:`insert`, :meth:`pop`, :meth:`remove`, :meth:"
"`reverse` and :meth:`sort`, like Python standard :class:`list` objects. "
"Finally, sequence types should implement addition (meaning concatenation) "
"and multiplication (meaning repetition) by defining the methods :meth:"
"`~object.__add__`, :meth:`~object.__radd__`, :meth:`~object.__iadd__`, :meth:"
"`~object.__mul__`, :meth:`~object.__rmul__` and :meth:`~object.__imul__` "
"described below; they should not define other numerical operators.  It is "
"recommended that both mappings and sequences implement the :meth:`~object."
"__contains__` method to allow efficient use of the ``in`` operator; for "
"mappings, ``in`` should search the mapping's keys; for sequences, it should "
"search through the values.  It is further recommended that both mappings and "
"sequences implement the :meth:`~object.__iter__` method to allow efficient "
"iteration through the container; for mappings, :meth:`__iter__` should "
"iterate through the object's keys; for sequences, it should iterate through "
"the values."
msgstr ""
"可以定義以下方法來實作容器物件。容器通常是 :term:`sequences <sequence>`（"
"例如 :class:`lists <list>` 或 :class:`tuples <tuple>`）或 :term:`mappings "
"<mapping>`（例如 :class: `dictionaries <dict>`)，但也可以表示其他容器。第一組"
"方法用於模擬序列或模擬映射；不同之處在於，對於一個序列，允許的鍵應該是整數 "
"*k* ，其中 ``0 <= k < N`` 其中 *N* 是序列的長度，或者 :class:`slice` "
"物件，它定義了一系列項目。還建議映射提供方法 :meth:`keys`, :meth:`values`, "
":meth:`items`, :meth:`get`, :meth:`clear`, :meth:`setdefault` , :meth:`pop`, "
":meth:`popitem`, :meth:`!copy` 和 :meth:`update` 的行為類似於 Python 的標準 "
":class:`dictionary <dict>` 物件。 :mod:`collections.abc` 模組提供了一個 "
":class:`~collections.abc.MutableMapping` :term:`abstract base class` "
"來幫助從一組 :meth:`~object.__getitem__` 建立這些方法、:meth:`~object."
"__setitem__`、:meth:`~object.__delitem__` 和 :meth:`keys`。"
"可變序列應該提供方法 :meth:`append`, :meth:`count`, :meth:`index`, "
":meth:`extend`, :meth:`insert`, :meth:`pop`, :meth: `remove`、:meth:`reverse`"
" 和 :meth:`sort`，就像 Python 標準的 :class:`list` 物件。最後，序列型別應該通"
"過定義方法來實作加法（意思是連接）和乘法（意思是重複） , :meth:`~object."
"__mul__`, :meth:`~object.__rmul__` 和 :meth:`~object.__imul__` "
"如下所述；他們不應該定義其他數字運算符。建議映射和序列都實作 :meth:`~object."
"__contains__` 方法以允許有效使用 ``in`` 運算符；對於映射，``in`` "
"應該搜索映射的鍵；對於序列，它應該搜索值。進一步建議映射和序列都實作 "
":meth:`~object.__iter__` "
"方法以允許通過容器進行高效疊代；對於映射，:meth:`__iter__` "
"應該遍歷物件的鍵；對於序列，它應該遍歷值。"

#: ../../reference/datamodel.rst:2478
#, fuzzy
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the "
"length of the object, an integer ``>=`` 0.  Also, an object that doesn't "
"define a :meth:`__bool__` method and whose :meth:`__len__` method returns "
"zero is considered to be false in a Boolean context."
msgstr ""
"呼叫以實作內建函式 :func:`len`。應回傳物件的長度，一個整數 ``>=`` 0。此外，"
"未定義 :meth:`__bool__` 方法且其 :meth:`__len__` "
"方法回傳零的對像被認為是在布爾上下文中為 false。"

#: ../../reference/datamodel.rst:2485
#, fuzzy
msgid ""
"In CPython, the length is required to be at most :attr:`sys.maxsize`. If the "
"length is larger than :attr:`!sys.maxsize` some features (such as :func:"
"`len`) may raise :exc:`OverflowError`.  To prevent raising :exc:`!"
"OverflowError` by truth value testing, an object must define a :meth:"
"`__bool__` method."
msgstr ""
"在 CPython 中，長度最多為 :attr:`sys.maxsize`。如果長度大於 :attr:`!sys."
"maxsize` 某些功能（例如 :func:`len`）可能會引發 :exc:`OverflowError`。"
"為了防止通過真值測試引發 :exc:`!OverflowError`，物件必須定義一個 "
":meth:`__bool__` 方法。"

#: ../../reference/datamodel.rst:2494
#, fuzzy
msgid ""
"Called to implement :func:`operator.length_hint`. Should return an estimated "
"length for the object (which may be greater or less than the actual length). "
"The length must be an integer ``>=`` 0. The return value may also be :const:"
"`NotImplemented`, which is treated the same as if the ``__length_hint__`` "
"method didn't exist at all. This method is purely an optimization and is "
"never required for correctness."
msgstr ""
"呼叫以實作 :func:`operator."
"length_hint`。應回傳物件的估計長度（可能大於或小於實際長度）。"
"長度必須是一個整數 ``>=`` 0。回傳值也可以是 :const:`NotImplemented`，就像 "
"``__length_hint__`` "
"方法根本不存在一樣。此方法純粹是一種最佳化，永遠不需要正確性。"

#: ../../reference/datamodel.rst:2508
#, fuzzy
msgid ""
"Slicing is done exclusively with the following three methods.  A call like ::"
msgstr "切片僅使用以下三種方法完成。像 :: 這樣的電話"

#: ../../reference/datamodel.rst:2512
#, fuzzy
msgid "is translated to ::"
msgstr "翻譯成::"

#: ../../reference/datamodel.rst:2516
#, fuzzy
msgid "and so forth.  Missing slice items are always filled in with ``None``."
msgstr "等等。缺少的切片項總是用 ``None`` 填充。"

#: ../../reference/datamodel.rst:2521
#, fuzzy
msgid ""
"Called to implement evaluation of ``self[key]``. For :term:`sequence` types, "
"the accepted keys should be integers and slice objects.  Note that the "
"special interpretation of negative indexes (if the class wishes to emulate "
"a :term:`sequence` type) is up to the :meth:`__getitem__` method. If *key* "
"is of an inappropriate type, :exc:`TypeError` may be raised; if of a value "
"outside the set of indexes for the sequence (after any special "
"interpretation of negative values), :exc:`IndexError` should be raised. For :"
"term:`mapping` types, if *key* is missing (not in the container), :exc:"
"`KeyError` should be raised."
msgstr ""
"呼叫以實作“self[key]”的評估。對於 :term:`sequence` "
"型別，接受的鍵應該是整數和切片物件。請注意，負索引的特殊解釋（如果類希望模擬 "
":term:`sequence` 型別）取決於 :meth:`__getitem__` 方法。如果 *key* "
"是不合適的型別，可能會引發 :exc:`TypeError`；如果值超出序列的索引集（在對負值"
"進行任何特殊解釋之後），則應引發 :exec:`IndexError`。對於 :term:`mapping` "
"型別，如果 *key* 缺失（不在容器中），應該引發 :exc:`KeyError`。"

#: ../../reference/datamodel.rst:2533
#, fuzzy
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ":keyword:`for` 循環期望為非法索引引發 :exc:`IndexError` "
"以允許正確檢測序列的結尾。"

#: ../../reference/datamodel.rst:2538
#, fuzzy
msgid ""
"When :ref:`subscripting<subscriptions>` a *class*, the special class method :"
"meth:`~object.__class_getitem__` may be called instead of ``__getitem__()``. "
"See :ref:`classgetitem-versus-getitem` for more details."
msgstr ""
"當 :ref:`subscripting<subscriptions>` 一個 *class* 時，可以呼叫特殊的類方法 "
":meth:`~object.__class_getitem__` 而不是 "
"`__getitem__()``。有關更多詳細資訊，請參閱 :ref:`classgetitem-versus-"
"getitem`。"

#: ../../reference/datamodel.rst:2546
#, fuzzy
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support changes to the values for keys, or if new keys can be added, or for "
"sequences if elements can be replaced.  The same exceptions should be raised "
"for improper *key* values as for the :meth:`__getitem__` method."
msgstr ""
"呼叫以實作對 ``self[key]`` 的賦值。與 :meth:`__getitem__` 相同的註釋。如果物"
"件支援更改鍵的值，或者可以新增新鍵，或者如果可以替換元素，則只應為映射實作此"
"方法。對於 :meth:`__getitem__` 方法不正確的 *key* 值應該引發相同的例外。"

#: ../../reference/datamodel.rst:2555
#, fuzzy
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support removal of keys, or for sequences if elements can be removed from "
"the sequence.  The same exceptions should be raised for improper *key* "
"values as for the :meth:`__getitem__` method."
msgstr ""
"呼叫以實作刪除 ``self[key]``。與 :meth:`__getitem__` 相同的註釋。如果物件支援"
"刪除鍵，或者如果可以從序列中刪除元素，則只應為映射實作此方法。對於 "
":meth:`__getitem__` 方法不正確的 *key* 值應該引發相同的例外。"

#: ../../reference/datamodel.rst:2564
#, fuzzy
msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement ``self[key]`` "
"for dict subclasses when key is not in the dictionary."
msgstr ""
"由 :class:`dict`\\.\\ :meth:`__getitem__` 呼叫，當鍵不在字典中時為 dict "
"子類別實作 ``self[key]``。"

#: ../../reference/datamodel.rst:2570
#, fuzzy
msgid ""
"This method is called when an :term:`iterator` is required for a container. "
"This method should return a new iterator object that can iterate over all "
"the objects in the container.  For mappings, it should iterate over the keys "
"of the container."
msgstr ""
"當容器需要 :term:`iterator` 時呼叫此方法。此方法應回傳一個新的疊代器物件，該"
"物件可以疊代容器中的所有物件。對於映射，它應該遍歷容器的鍵。"

#: ../../reference/datamodel.rst:2578
#, fuzzy
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse "
"iteration.  It should return a new iterator object that iterates over all "
"the objects in the container in reverse order."
msgstr ""
"由內建的 :func:`reversed` 呼叫（如果存在）以實作反向疊代。它應該回傳一個新的"
"疊代器物件，該對像以相反的順序疊代容器中的所有物件。"

#: ../../reference/datamodel.rst:2582
#, fuzzy
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` and :"
"meth:`__getitem__`).  Objects that support the sequence protocol should only "
"provide :meth:`__reversed__` if they can provide an implementation that is "
"more efficient than the one provided by :func:`reversed`."
msgstr ""
"如果未提供 :meth:`__reversed__` 方法，內建的 :func:`reversed` "
"將退回到使用序列協定（:meth:`__len__` 和 :meth:`__getitem__`）。"
"支援序列協定的物件應該只提供 :meth:`__reversed__` 如果它們可以提供比 "
":func:`reversed` 提供的實作更有效的實作。"

#: ../../reference/datamodel.rst:2589
#, fuzzy
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a container. However, container "
"objects can supply the following special method with a more efficient "
"implementation, which also does not require the object be iterable."
msgstr ""
"成員資格測試運算符（:keyword:`in` 和 :keyword:`not in`）通常實作為通過容器的疊"
"代。然而，容器物件可以提供以下具有更有效實作的特殊方法，這也不要求對像是可疊"
"代的。"

#: ../../reference/datamodel.rst:2596
#, fuzzy
msgid ""
"Called to implement membership test operators.  Should return true if *item* "
"is in *self*, false otherwise.  For mapping objects, this should consider "
"the keys of the mapping rather than the values or the key-item pairs."
msgstr ""
"呼叫以實作成員資格測試運算符。如果 *item* 在 *self* 中，應該回傳 true，"
"否則回傳 false。對於映射物件，這應該考慮映射的鍵而不是值或鍵項對。"

#: ../../reference/datamodel.rst:2600
#, fuzzy
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence iteration "
"protocol via :meth:`__getitem__`, see :ref:`this section in the language "
"reference <membership-test-details>`."
msgstr ""
"對於未定義 :meth:`__contains__` 的物件，成員資格測試首先嘗試通過 "
":meth:`__iter__` 進行疊代，然後通過 :meth:`__getitem__` "
"嘗試舊序列疊代協定，請參閱 :ref:`this section in語言參考 <membership-test-"
"details>`。"

#: ../../reference/datamodel.rst:2609
#, fuzzy
msgid "Emulating numeric types"
msgstr "模擬數字型別"

#: ../../reference/datamodel.rst:2611
#, fuzzy
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind of "
"number implemented (e.g., bitwise operations for non-integral numbers) "
"should be left undefined."
msgstr "可以定義以下方法來模擬數字物件。與實作的特定型別的數字不支援的操作對應的方法"
"（例如，非整數的按位操作）應該保持未定義。"

#: ../../reference/datamodel.rst:2637
#, fuzzy
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:"
"`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance, to "
"evaluate the expression ``x + y``, where *x* is an instance of a class that "
"has an :meth:`__add__` method, ``type(x).__add__(x, y)`` is called.  The :"
"meth:`__divmod__` method should be the equivalent to using :meth:"
"`__floordiv__` and :meth:`__mod__`; it should not be related to :meth:"
"`__truediv__`.  Note that :meth:`__pow__` should be defined to accept an "
"optional third argument if the ternary version of the built-in :func:`pow` "
"function is to be supported."
msgstr ""
"呼叫這些方法來實作二進位算術運算（``+``, ``-``, ``*``, ``@``, ``/``, ``//``, "
"`` %``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^`` "
"，``|``）。例如，要計算表達式 ``x + y``，其中 *x* 是具有 :meth:`__add__` "
"方法的類的實例，``type(x).__add__(x, y)` ` 被稱為。 :meth:`__divmod__` "
"方法應該等同於使用 :meth:`__floordiv__` 和 :meth:`__mod__`；它不應該與 "
":meth:`__truediv__` 相關。請注意，如果要支援內建 :func:`pow` 函式的三元版本，"
"則應將 :meth:`__pow__` 定義為接受可選的第三個參數。"

#: ../../reference/datamodel.rst:2648
#, fuzzy
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return ``NotImplemented``."
msgstr "如果其中一個方法不支援使用提供的參數進行操作，它應該回傳 ``NotImplemented`` 。"

#: ../../reference/datamodel.rst:2671
#, fuzzy
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:"
"`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected (swapped) "
"operands.  These functions are only called if the left operand does not "
"support the corresponding operation [#]_ and the operands are of different "
"types. [#]_ For instance, to evaluate the expression ``x - y``, where *y* is "
"an instance of a class that has an :meth:`__rsub__` method, ``type(y)."
"__rsub__(y, x)`` is called if ``type(x).__sub__(x, y)`` returns "
"*NotImplemented*."
msgstr ""
"呼叫這些方法來實作二進位算術運算（``+``, ``-``, ``*``, ``@``, ``/``, ``//``, "
"`` %``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^`` , "
"``|``) 與反射（交換）操作數。這些函式僅在左操作數不支援對應操作[#]_且操作數型"
"別不同時呼叫。 [#]_ 例如，計算表達式 ``x - y``，其中 *y* 是具有 "
":meth:`__rsub__` 方法的類的實例，``type(y).__rsub__(y , x)`` 如果``type(x)."
"__sub__(x, y)`` 回傳 *NotImplemented* 則被呼叫。"

#: ../../reference/datamodel.rst:2683
#, fuzzy
msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr "請注意，三元 :function:`pow` 不會嘗試呼叫 :meth:`__pow__` "
"（強制轉換規則會變得太複雜）。"

#: ../../reference/datamodel.rst:2688
#, fuzzy
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides a different implementation of the reflected method "
"for the operation, this method will be called before the left operand's non-"
"reflected method. This behavior allows subclasses to override their "
"ancestors' operations."
msgstr ""
"如果右操作數的型別是左操作數型別的子類別，並且該子類別為操作提供反射方法的不"
"同實作，則將在左操作數的非反射方法之前呼叫此方法。此行為允許子類別覆蓋其祖先"
"的操作。"

#: ../../reference/datamodel.rst:2709
#, fuzzy
msgid ""
"These methods are called to implement the augmented arithmetic assignments "
"(``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, "
"``>>=``, ``&=``, ``^=``, ``|=``).  These methods should attempt to do the "
"operation in-place (modifying *self*) and return the result (which could be, "
"but does not have to be, *self*).  If a specific method is not defined, the "
"augmented assignment falls back to the normal methods.  For instance, if *x* "
"is an instance of a class with an :meth:`__iadd__` method, ``x += y`` is "
"equivalent to ``x = x.__iadd__(y)`` . Otherwise, ``x.__add__(y)`` and ``y."
"__radd__(x)`` are considered, as with the evaluation of ``x + y``. In "
"certain situations, augmented assignment can result in unexpected errors "
"(see :ref:`faq-augmented-assignment-tuple-error`), but this behavior is in "
"fact part of the data model."
msgstr ""
"呼叫這些方法來實作增廣算術賦值（``+=``、``-=``、``*=``、``@=``、``/=``、``// "
"=``，``%=``，``**=``，``<<=``，``>>=``，``&=``，``^=``，` `|=``）。這些方法應"
"該嘗試就地執行操作（修改*self*）並回傳結果（可以是，但不一定是*self*）。如果"
"未定義特定方法，則擴充賦值會回退到普通方法。例如，如果 *x* 是具有 "
":meth:`__iadd__` 方法的類的實例，則 ``x += y`` 等同於 ``x = x.__iadd__(y)`` "
"。否則，將考慮 ``x.__add__(y)`` 和 ``y.__radd__(x)``，就像對 ``x + y`` "
"的評估一樣。在某些情況下，擴充賦值會導致意外錯誤（參見 faq-augmented-"
"assignment-tuple-error），但這種行為實際上是資料模型的一部分。"

#: ../../reference/datamodel.rst:2730
#, fuzzy
msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, :func:"
"`abs` and ``~``)."
msgstr "呼叫以實作一元算術運算（``-``、``+``、:func:`abs` 和``~``）。"

#: ../../reference/datamodel.rst:2743
#, fuzzy
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int` and :"
"func:`float`.  Should return a value of the appropriate type."
msgstr "呼叫以實作內建函式 :func:`complex`、:func:`int` 和 "
":func:`float`。應回傳適當型別的值。"

#: ../../reference/datamodel.rst:2750
#, fuzzy
msgid ""
"Called to implement :func:`operator.index`, and whenever Python needs to "
"losslessly convert the numeric object to an integer object (such as in "
"slicing, or in the built-in :func:`bin`, :func:`hex` and :func:`oct` "
"functions). Presence of this method indicates that the numeric object is an "
"integer type.  Must return an integer."
msgstr ""
"呼叫以實作 :func:`operator.index`，每當 Python "
"需要無損地將數字物件轉換為整數物件時（例如在切片中，或在內建的 :func:`bin`, "
":func:`hex ` 和 :func:`oct` "
"函式）。此方法的存在表明數字對像是整數型別。必須回傳一個整數。"

#: ../../reference/datamodel.rst:2756
#, fuzzy
msgid ""
"If :meth:`__int__`, :meth:`__float__` and :meth:`__complex__` are not "
"defined then corresponding built-in functions :func:`int`, :func:`float` "
"and :func:`complex` fall back to :meth:`__index__`."
msgstr ""
"如果 :meth:`__int__`, :meth:`__float__` 和 :meth:`__complex__` "
"沒有定義相應的內建函式 :func:`int`, :func:`float` 和 :func:`complex`回到 "
":meth:`__index__`。"

#: ../../reference/datamodel.rst:2768
#, fuzzy
msgid ""
"Called to implement the built-in function :func:`round` and :mod:`math` "
"functions :func:`~math.trunc`, :func:`~math.floor` and :func:`~math.ceil`. "
"Unless *ndigits* is passed to :meth:`!__round__` all these methods should "
"return the value of the object truncated to an :class:`~numbers.Integral` "
"(typically an :class:`int`)."
msgstr ""
"呼叫以實作內建函式 :func:`round` 和 :mod:`math` 函式 :func:`~math.trunc`, "
":func:`~math.floor` 和 :func:`~math.ceil `。除非將 *ndigits* 傳遞給 "
":meth:`!__round__` 所有這些方法都應該回傳截斷為 :class:`~numbers.Integral`（"
"通常是 :class:`int`）的物件的值。"

#: ../../reference/datamodel.rst:2774
#, fuzzy
msgid ""
"The built-in function :func:`int` falls back to :meth:`__trunc__` if "
"neither :meth:`__int__` nor :meth:`__index__` is defined."
msgstr ""
"如果 :meth:`__int__` 和 :meth:`__index__` 均未定義，則內建函式 :func:`int` "
"回落到 :meth:`__trunc__`。"

#: ../../reference/datamodel.rst:2777
#, fuzzy
msgid "The delegation of :func:`int` to :meth:`__trunc__` is deprecated."
msgstr ":func:`int` 到 :meth:`__trunc__` 的委託已棄用。"

#: ../../reference/datamodel.rst:2784
#, fuzzy
msgid "With Statement Context Managers"
msgstr "使用語句上下文管理器"

#: ../../reference/datamodel.rst:2786
#, fuzzy
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to be "
"established when executing a :keyword:`with` statement. The context manager "
"handles the entry into, and the exit from, the desired runtime context for "
"the execution of the block of code.  Context managers are normally invoked "
"using the :keyword:`!with` statement (described in section :ref:`with`), but "
"can also be used by directly invoking their methods."
msgstr ""
":dfn:`context manager` 是一個物件，它定義了在執行 :keyword:`with` 語句時要建"
"立的運行時上下文。上下文管理器處理程式碼塊執行所需的運行時上下文的進入和退出"
"。上下文管理器通常使用 :keyword:`!with` 語句呼叫（在 :ref:`with` "
"部分中描述），但也可以通過直接呼叫它們的方法來使用。"

#: ../../reference/datamodel.rst:2797
#, fuzzy
msgid ""
"Typical uses of context managers include saving and restoring various kinds "
"of global state, locking and unlocking resources, closing opened files, etc."
msgstr "上下文管理器的典型用途包括保存和恢復各種全局狀態、鎖定和解鎖資源、關閉打開的"
"文件等。"

#: ../../reference/datamodel.rst:2800
#, fuzzy
msgid ""
"For more information on context managers, see :ref:`typecontextmanager`."
msgstr "有關上下文管理器的更多資訊，請參閱 :ref:`typecontextmanager`。"

#: ../../reference/datamodel.rst:2805
#, fuzzy
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified in "
"the :keyword:`!as` clause of the statement, if any."
msgstr ""
"輸入與此物件相關的運行時上下文。 :keyword:`with` "
"語句會將此方法的回傳值綁定到語句的 :keyword:`!as` "
"子句中指定的目標（如果有的話）。"

#: ../../reference/datamodel.rst:2812
#, fuzzy
msgid ""
"Exit the runtime context related to this object. The parameters describe the "
"exception that caused the context to be exited. If the context was exited "
"without an exception, all three arguments will be :const:`None`."
msgstr "退出與此物件相關的運行時上下文。這些參數描述了導致上下文退出的例外。如果上下"
"文無例外退出，則所有三個參數都將為 :const:`None`。"

#: ../../reference/datamodel.rst:2816
#, fuzzy
msgid ""
"If an exception is supplied, and the method wishes to suppress the exception "
"(i.e., prevent it from being propagated), it should return a true value. "
"Otherwise, the exception will be processed normally upon exit from this "
"method."
msgstr "如果提供了一個例外，並且該方法希望抑制該例外（即防止它被傳播），它應該回傳一"
"個真值。否則，例外將在退出此方法時正常處理。"

#: ../../reference/datamodel.rst:2820
#, fuzzy
msgid ""
"Note that :meth:`__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr "請注意 :meth:`__exit__` 方法不應重新引發傳入的例外；這是來電者的責任。"

#: ../../reference/datamodel.rst:2827
#, fuzzy
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` -  ``with``語句"

#: ../../reference/datamodel.rst:2827
#, fuzzy
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Python :keyword:`with` 語句的規範、背景和示例。"

#: ../../reference/datamodel.rst:2834
#, fuzzy
msgid "Customizing positional arguments in class pattern matching"
msgstr "在類模式匹配中自定義位置參數"

#: ../../reference/datamodel.rst:2836
#, fuzzy
msgid ""
"When using a class name in a pattern, positional arguments in the pattern "
"are not allowed by default, i.e. ``case MyClass(x, y)`` is typically invalid "
"without special support in ``MyClass``. To be able to use that kind of "
"pattern, the class needs to define a *__match_args__* attribute."
msgstr ""
"在模式中使用類名時，預設情況下不允許模式中的位置參數，即 ``case MyClass(x, "
"y)`` 通常在沒有 ``MyClass`` 特殊支援的情況下無效。為了能夠使用這種模式，"
"該類需要定義一個 *__match_args__* 屬性。"

#: ../../reference/datamodel.rst:2843
#, fuzzy
msgid ""
"This class variable can be assigned a tuple of strings. When this class is "
"used in a class pattern with positional arguments, each positional argument "
"will be converted into a keyword argument, using the corresponding value in "
"*__match_args__* as the keyword. The absence of this attribute is equivalent "
"to setting it to ``()``."
msgstr ""
"可以為此類變數分配一個字串元組。當此類在帶有位置參數的類模式中使用時，每個位"
"置參數將被轉換為關鍵字參數，使用 *__match_args__* 中的相應值作為關鍵字。"
"缺少此屬性等同於將其設定為 ``()``。"

#: ../../reference/datamodel.rst:2849
#, fuzzy
msgid ""
"For example, if ``MyClass.__match_args__`` is ``(\"left\", \"center\", "
"\"right\")`` that means that ``case MyClass(x, y)`` is equivalent to ``case "
"MyClass(left=x, center=y)``. Note that the number of arguments in the "
"pattern must be smaller than or equal to the number of elements in "
"*__match_args__*; if it is larger, the pattern match attempt will raise a :"
"exc:`TypeError`."
msgstr ""
"例如，如果 ``MyClass.__match_args__`` 是 ``(\"left\", \"center\", \"right\""
")`` 這意味著 ``case MyClass(x, y)`` 等同於 ``case MyClass "
"（左=x，中心=y）``。請注意，模式中的參數數量必須小於或等於 *__match_args__* "
"中的元素數量；如果它更大，模式匹配嘗試將引發 :exc:`TypeError`。"

#: ../../reference/datamodel.rst:2859
#, fuzzy
msgid ":pep:`634` - Structural Pattern Matching"
msgstr ":pep:`634` - 結構模式匹配"

#: ../../reference/datamodel.rst:2860
#, fuzzy
msgid "The specification for the Python ``match`` statement."
msgstr "Python ``match`` 語句的規範。"

#: ../../reference/datamodel.rst:2866
#, fuzzy
msgid "Special method lookup"
msgstr "特殊方法查找"

#: ../../reference/datamodel.rst:2868
#, fuzzy
msgid ""
"For custom classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception::"
msgstr "對於自定義類，特殊方法的隱式呼叫只有在對像型別上定義時才能保證正確工作，而不"
"是在物件的實例字典中。該行為是以下程式碼引發例外的原因："

#: ../../reference/datamodel.rst:2883
#, fuzzy
msgid ""
"The rationale behind this behaviour lies with a number of special methods "
"such as :meth:`~object.__hash__` and :meth:`~object.__repr__` that are "
"implemented by all objects, including type objects. If the implicit lookup "
"of these methods used the conventional lookup process, they would fail when "
"invoked on the type object itself::"
msgstr ""
"這種行為背後的基本原理在於許多特殊方法，例如 :meth:`~object.__hash__` 和 "
":meth:`~object.__repr__` 由所有物件實作，包括型別物件。如果這些方法的隱式查找"
"使用常規查找過程，則在型別物件本身上呼叫時它們將失敗::"

#: ../../reference/datamodel.rst:2897
#, fuzzy
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way is "
"sometimes referred to as 'metaclass confusion', and is avoided by bypassing "
"the instance when looking up special methods::"
msgstr "以這種方式錯誤地嘗試呼叫類的未綁定方法有時被稱為“元類混淆”，並且通過在查找特"
"殊方法時繞過實例來避免："

#: ../../reference/datamodel.rst:2906
#, fuzzy
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the :"
"meth:`~object.__getattribute__` method even of the object's metaclass::"
msgstr ""
"除了為了正確性而繞過任何實例屬性之外，隱式特殊方法查找通常還會繞過 "
":meth:`~object.__getattribute__` 方法，甚至是物件的元類::"

#: ../../reference/datamodel.rst:2932
#, fuzzy
msgid ""
"Bypassing the :meth:`~object.__getattribute__` machinery in this fashion "
"provides significant scope for speed optimisations within the interpreter, "
"at the cost of some flexibility in the handling of special methods (the "
"special method *must* be set on the class object itself in order to be "
"consistently invoked by the interpreter)."
msgstr ""
"以這種方式繞過 :meth:`~object.__getattribute__` 機制為直譯器內的速度最佳化提"
"供了很大的空間，代價是在處理特殊方法時有一些靈活性（特殊方法*必須*設定在類對"
"像上本身以便被直譯器一致地呼叫）。"

#: ../../reference/datamodel.rst:2943
msgid "Coroutines"
msgstr "協程"

#: ../../reference/datamodel.rst:2947
#, fuzzy
msgid "Awaitable Objects"
msgstr "等待物件"

#: ../../reference/datamodel.rst:2949
#, fuzzy
msgid ""
"An :term:`awaitable` object generally implements an :meth:`~object."
"__await__` method. :term:`Coroutine objects <coroutine>` returned from :"
"keyword:`async def` functions are awaitable."
msgstr ""
"一個 :term:`awaitable` 物件通常實作一個 :meth:`~object.__await__` "
"方法。從 :keyword:`async def` 函式回傳的協程物件 <coroutine>` 是可等待的。"

#: ../../reference/datamodel.rst:2955
#, fuzzy
msgid ""
"The :term:`generator iterator` objects returned from generators decorated "
"with :func:`types.coroutine` are also awaitable, but they do not implement :"
"meth:`~object.__await__`."
msgstr ""
"從用 types.coroutine 修飾的生成器回傳的 :term:`generator iterator` "
"對像也是可等待的，但它們不實作 :meth:`~object.__await__`。"

#: ../../reference/datamodel.rst:2961
#, fuzzy
msgid ""
"Must return an :term:`iterator`.  Should be used to implement :term:"
"`awaitable` objects.  For instance, :class:`asyncio.Future` implements this "
"method to be compatible with the :keyword:`await` expression."
msgstr ""
"必須回傳一個 :term:`iterator`。應該用於實作 :term:`awaitable` "
"物件。例如，:class:`asyncio.Future` 實作此方法以與 :keyword:`await` "
"表達式相容。"

#: ../../reference/datamodel.rst:2967
#, fuzzy
msgid ""
"The language doesn't place any restriction on the type or value of the "
"objects yielded by the iterator returned by ``__await__``, as this is "
"specific to the implementation of the asynchronous execution framework (e."
"g. :mod:`asyncio`) that will be managing the :term:`awaitable` object."
msgstr ""
"該語言不對由 ``__await__`` "
"回傳的疊代器產生的物件的型別或值施加任何限制，因為這是特定於非同步執行框架（"
"例如 :mod:`asyncio`）的實作將管理 :term:`awaitable` 物件。"

#: ../../reference/datamodel.rst:2975
#, fuzzy
msgid ":pep:`492` for additional information about awaitable objects."
msgstr ":pep:`492` 獲取有關可等待物件的更多資訊。"

#: ../../reference/datamodel.rst:2981
#, fuzzy
msgid "Coroutine Objects"
msgstr "協程物件"

#: ../../reference/datamodel.rst:2983
#, fuzzy
msgid ""
":term:`Coroutine objects <coroutine>` are :term:`awaitable` objects. A "
"coroutine's execution can be controlled by calling :meth:`~object.__await__` "
"and iterating over the result.  When the coroutine has finished executing "
"and returns, the iterator raises :exc:`StopIteration`, and the exception's :"
"attr:`~StopIteration.value` attribute holds the return value.  If the "
"coroutine raises an exception, it is propagated by the iterator.  Coroutines "
"should not directly raise unhandled :exc:`StopIteration` exceptions."
msgstr ""
":term:`Coroutine objects <coroutine>` 是 :term:`awaitable` 物件。"
"協程的執行可以通過呼叫 :meth:`~object.__await__` "
"並疊代結果來控制。當協程完成執行並回傳時，疊代器引發 :exc:`StopIteration`，"
"例外的 :attr:`~StopIteration.value` "
"屬性保存回傳值。如果協程引發例外，它會由疊代器傳播。協程不應直接引發未處理的 "
":exc:`StopIteration` 例外。"

#: ../../reference/datamodel.rst:2991
#, fuzzy
msgid ""
"Coroutines also have the methods listed below, which are analogous to those "
"of generators (see :ref:`generator-methods`).  However, unlike generators, "
"coroutines do not directly support iteration."
msgstr ""
"協程也有下面列出的方法，它們類似於生成器的方法（參見 :ref:`generator-"
"methods`）。但是，與生成器不同，協程不直接支援疊代。"

#: ../../reference/datamodel.rst:2995
#, fuzzy
msgid "It is a :exc:`RuntimeError` to await on a coroutine more than once."
msgstr "在協程上等待不止一次是一個 :exc:`RuntimeError`。"

#: ../../reference/datamodel.rst:3001
#, fuzzy
msgid ""
"Starts or resumes execution of the coroutine.  If *value* is ``None``, this "
"is equivalent to advancing the iterator returned by :meth:`~object."
"__await__`.  If *value* is not ``None``, this method delegates to the :meth:"
"`~generator.send` method of the iterator that caused the coroutine to "
"suspend.  The result (return value, :exc:`StopIteration`, or other "
"exception) is the same as when iterating over the :meth:`__await__` return "
"value, described above."
msgstr ""
"開始或恢復協程的執行。如果 *value* 是 ``None``，這相當於推進 :meth:`~object."
"__await__` 回傳的疊代器。如果 *value* 不是 ``None``，"
"則此方法委託給導致協程掛起的疊代器的 :meth:`~generator.send` "
"方法。結果（回傳值、StopIteration 或其他例外）與疊代 __await__ "
"回傳值時相同，如上所述。"

#: ../../reference/datamodel.rst:3012
#, fuzzy
msgid ""
"Raises the specified exception in the coroutine.  This method delegates to "
"the :meth:`~generator.throw` method of the iterator that caused the "
"coroutine to suspend, if it has such a method.  Otherwise, the exception is "
"raised at the suspension point.  The result (return value, :exc:"
"`StopIteration`, or other exception) is the same as when iterating over the :"
"meth:`~object.__await__` return value, described above.  If the exception is "
"not caught in the coroutine, it propagates back to the caller."
msgstr ""
"在協程中引髮指定的例外。此方法委託給導致協程掛起的疊代器的 :meth:`~generator."
"throw` 方法，如果它有這樣的方法。否則，將在掛起點引發例外。結果（回傳值、"
"StopIteration 或其他例外）與疊代 :meth:`~object.__await__` "
"回傳值時相同，如上所述。如果例外沒有在協程中被捕獲，它會傳播回呼叫者。"

#: ../../reference/datamodel.rst:3023
#, fuzzy
msgid ""
"Causes the coroutine to clean itself up and exit.  If the coroutine is "
"suspended, this method first delegates to the :meth:`~generator.close` "
"method of the iterator that caused the coroutine to suspend, if it has such "
"a method.  Then it raises :exc:`GeneratorExit` at the suspension point, "
"causing the coroutine to immediately clean itself up. Finally, the coroutine "
"is marked as having finished executing, even if it was never started."
msgstr ""
"使協程自行清理並退出。如果協程被掛起，"
"這個方法首先委託給導致協程掛起的疊代器的 :meth:`~generator.close` "
"方法，如果它有這樣的方法。然後它在暫停點引發 :exc:`GeneratorExit`，導致協程立"
"即清理自身。最後，協程被標記為已完成執行，即使它從未啟動過。"

#: ../../reference/datamodel.rst:3031
#, fuzzy
msgid ""
"Coroutine objects are automatically closed using the above process when they "
"are about to be destroyed."
msgstr "協程對像在即將被銷毀時使用上述流程自動關閉。"

#: ../../reference/datamodel.rst:3037
#, fuzzy
msgid "Asynchronous Iterators"
msgstr "非同步疊代器"

#: ../../reference/datamodel.rst:3039
#, fuzzy
msgid ""
"An *asynchronous iterator* can call asynchronous code in its ``__anext__`` "
"method."
msgstr "*非同步疊代器*可以在其“__anext__”方法中呼叫非同步程式碼。"

#: ../../reference/datamodel.rst:3042
#, fuzzy
msgid ""
"Asynchronous iterators can be used in an :keyword:`async for` statement."
msgstr "非同步疊代器可以在 async for 語句中使用。"

#: ../../reference/datamodel.rst:3046
#, fuzzy
msgid "Must return an *asynchronous iterator* object."
msgstr "必須回傳一個 *非同步疊代器* 物件。"

#: ../../reference/datamodel.rst:3050
#, fuzzy
msgid ""
"Must return an *awaitable* resulting in a next value of the iterator.  "
"Should raise a :exc:`StopAsyncIteration` error when the iteration is over."
msgstr "必須回傳一個 *awaitable* 導致疊代器的下一個值。應該在疊代結束時引發 "
":exc:`StopAsyncIteration` 錯誤。"

#: ../../reference/datamodel.rst:3053
#, fuzzy
msgid "An example of an asynchronous iterable object::"
msgstr "非同步可疊代物件的示例::"

#: ../../reference/datamodel.rst:3070
#, fuzzy
msgid ""
"Prior to Python 3.7, :meth:`~object.__aiter__` could return an *awaitable* "
"that would resolve to an :term:`asynchronous iterator <asynchronous "
"iterator>`."
msgstr ""
"在 Python 3.7 之前，:meth:`~object.__aiter__` 可以回傳一個 *awaitable* "
"來解析為一個 :term:`asynchronous iterator <asynchronous iterator>`。"

#: ../../reference/datamodel.rst:3075
#, fuzzy
msgid ""
"Starting with Python 3.7, :meth:`~object.__aiter__` must return an "
"asynchronous iterator object.  Returning anything else will result in a :exc:"
"`TypeError` error."
msgstr ""
"從 Python 3.7 開始，:meth:`~object.__aiter__` 必須回傳一個非同步疊代器物件。"
"回傳任何其他內容將導致 :exc:`TypeError` 錯誤。"

#: ../../reference/datamodel.rst:3083
#, fuzzy
msgid "Asynchronous Context Managers"
msgstr "非同步上下文管理器"

#: ../../reference/datamodel.rst:3085
#, fuzzy
msgid ""
"An *asynchronous context manager* is a *context manager* that is able to "
"suspend execution in its ``__aenter__`` and ``__aexit__`` methods."
msgstr "*非同步上下文管理器*是一個*上下文管理器*，它能夠在其 ``__aenter__`` 和 "
"``__aexit__`` 方法中暫停執行。"

#: ../../reference/datamodel.rst:3088
#, fuzzy
msgid ""
"Asynchronous context managers can be used in an :keyword:`async with` "
"statement."
msgstr "非同步上下文管理器可以在 :keyword:`async with` 語句中使用。"

#: ../../reference/datamodel.rst:3092
#, fuzzy
msgid ""
"Semantically similar to :meth:`__enter__`, the only difference being that it "
"must return an *awaitable*."
msgstr "語義上類似於 :meth:`__enter__`，唯一的區別是它必須回傳一個 *awaitable*。"

#: ../../reference/datamodel.rst:3097
#, fuzzy
msgid ""
"Semantically similar to :meth:`__exit__`, the only difference being that it "
"must return an *awaitable*."
msgstr "語義上類似於 :meth:`__exit__`，唯一的區別是它必須回傳一個 *awaitable*。"

#: ../../reference/datamodel.rst:3100
#, fuzzy
msgid "An example of an asynchronous context manager class::"
msgstr "非同步上下文管理器類的示例::"

#: ../../reference/datamodel.rst:3113
msgid "Footnotes"
msgstr "註解"

#: ../../reference/datamodel.rst:3114
#, fuzzy
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it can "
"lead to some very strange behaviour if it is handled incorrectly."
msgstr "在某些情況下，在某些受控條件下，*可以*更改物件的型別。不過，這通常不是一個好"
"主意，因為如果處理不當，可能會導致一些非常奇怪的行為。"

#: ../../reference/datamodel.rst:3118
#, fuzzy
msgid ""
"The :meth:`~object.__hash__`, :meth:`~object.__iter__`, :meth:`~object."
"__reversed__`, and :meth:`~object.__contains__` methods have special "
"handling for this; others will still raise a :exc:`TypeError`, but may do so "
"by relying on the behavior that ``None`` is not callable."
msgstr ""
":meth:`~object.__hash__`、:meth:`~object.__iter__`、:meth:`~object."
"__reversed__` 和 :meth:`~object.__contains__` 方法對此有特殊處理；"
"其他人仍會引發 :exc:`TypeError`，但可能會依賴於 ``None`` 不可呼叫的行為。"

#: ../../reference/datamodel.rst:3124
#, fuzzy
msgid ""
"\"Does not support\" here means that the class has no such method, or the "
"method returns ``NotImplemented``.  Do not set the method to ``None`` if you "
"want to force fallback to the right operand's reflected method—that will "
"instead have the opposite effect of explicitly *blocking* such fallback."
msgstr ""
"這裡的“不支援”是指該類沒有這個方法，或者該方法回傳``NotImplemented``。如果您"
"想強制回退到正確操作數的反射方法，請不要將方法設定為 ``None`` ——這將產生相反的效果"
"，即顯式*阻止*此類回退。"

#: ../../reference/datamodel.rst:3130
#, fuzzy
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method -- such as :meth:`~object.__add__` -- fails then the overall "
"operation is not supported, which is why the reflected method is not called."
msgstr ""
"對於相同型別的操作數，假設如果非反射方法——例如 :meth:`~object.__add__` "
"失敗則不支援整體操作，這就是不呼叫反射方法的原因."
