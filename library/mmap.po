# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-24 00:16+0000\n"
"PO-Revision-Date: 2018-05-23 16:06+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/mmap.rst:2
#, fuzzy
msgid ":mod:`mmap` --- Memory-mapped file support"
msgstr ":mod:`mmap` --- 記憶體映射文件支援"

#: ../../includes/wasm-notavail.rst:3
#, fuzzy
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ":ref:`Availability <availability>`：不是 Emscripten，不是 WASI。"

#: ../../includes/wasm-notavail.rst:5
#, fuzzy
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"此模組在 WebAssembly 平台 ``wasm32-emscripten`` 和 ``wasm32-wasi`` 上不起作用或不可用"
"。有關更多資訊，請參閱 :ref:`wasm-availability`。"

#: ../../library/mmap.rst:11
#, fuzzy
msgid ""
"Memory-mapped file objects behave like both :class:`bytearray` and like :"
"term:`file objects <file object>`.  You can use mmap objects in most places "
"where :class:`bytearray` are expected; for example, you can use the :mod:"
"`re` module to search through a memory-mapped file.  You can also change a "
"single byte by doing ``obj[index] = 97``, or change a subsequence by "
"assigning to a slice: ``obj[i1:i2] = b'...'``.  You can also read and write "
"data starting at the current file position, and :meth:`seek` through the "
"file to different positions."
msgstr ""
"記憶體映射文件物件的行為類似於 :class:`bytearray` 和 :term:`file objects <file "
"object>`。您可以在大多數需要 :class:`bytearray` 的地方使用 mmap 物件；例如，"
"您可以使用 :mod:`re` 模組來搜索記憶體映射文件。您還可以通過執行 ``obj[index] "
"= 97`` 來更改單個位元組，或者通過分配給切片來更改子序列：``obj[i1:i2] = b'..."
"'``。您還可以從當前文件位置開始讀取和寫入資料，並通過文件搜索到不同位置。"

#: ../../library/mmap.rst:19
#, fuzzy
msgid ""
"A memory-mapped file is created by the :class:`~mmap.mmap` constructor, "
"which is different on Unix and on Windows.  In either case you must provide "
"a file descriptor for a file opened for update. If you wish to map an "
"existing Python file object, use its :meth:`fileno` method to obtain the "
"correct value for the *fileno* parameter.  Otherwise, you can open the file "
"using the :func:`os.open` function, which returns a file descriptor directly "
"(the file still needs to be closed when done)."
msgstr ""
"記憶體映射文件由 :class:`~mmap.mmap` 構造函式建立，這在 Unix 和 Windows "
"上是不同的。在任何一種情況下，您都必須為為更新而打開的文件提供文件描述器。"
"如果您希望映射現有的 Python 文件物件，請使用其 :meth:`fileno` 方法獲取 "
"*fileno* 參數的正確值。否則，您可以使用 :func:`os.open` "
"函式打開文件，該函式直接回傳文件描述器（完成後仍需要關閉文件）。"

#: ../../library/mmap.rst:28
#, fuzzy
msgid ""
"If you want to create a memory-mapping for a writable, buffered file, you "
"should :func:`~io.IOBase.flush` the file first.  This is necessary to ensure "
"that local modifications to the buffers are actually available to the "
"mapping."
msgstr ""
"如果你想為一個可寫的緩衝文件建立一個記憶體映射，你應該先 :func:`~io.IOBase."
"flush` 該文件。這是必要的，以確保對緩衝區的本地修改實際上可用於映射。"

#: ../../library/mmap.rst:33
#, fuzzy
msgid ""
"For both the Unix and Windows versions of the constructor, *access* may be "
"specified as an optional keyword parameter. *access* accepts one of four "
"values: :const:`ACCESS_READ`, :const:`ACCESS_WRITE`, or :const:`ACCESS_COPY` "
"to specify read-only, write-through or copy-on-write memory respectively, "
"or :const:`ACCESS_DEFAULT` to defer to *prot*.  *access* can be used on both "
"Unix and Windows.  If *access* is not specified, Windows mmap returns a "
"write-through mapping.  The initial memory values for all three access types "
"are taken from the specified file.  Assignment to an :const:`ACCESS_READ` "
"memory map raises a :exc:`TypeError` exception.  Assignment to an :const:"
"`ACCESS_WRITE` memory map affects both memory and the underlying file. "
"Assignment to an :const:`ACCESS_COPY` memory map affects memory but does not "
"update the underlying file."
msgstr ""
"對於構造函式的 Unix 和 Windows 版本，*access* 可以指定為可選關鍵字參數。 "
"*access* 接受以下四個值之一：:const:`ACCESS_READ`、:const:`ACCESS_WRITE` 或 "
":const:`ACCESS_COPY` 以分別指定只讀、直寫或寫時復制記憶體，或者： "
"const:`ACCESS_DEFAULT` 推遲到 *prot*。 *access* 可以在 Unix 和 Windows "
"上使用。如果未指定 *access*，Windows mmap "
"將回傳直寫映射。所有三種訪問型別的初始記憶體值都取自指定的文件。分配給 "
":const:`ACCESS_READ` 記憶體映射會引發 :exc:`TypeError` 例外。分配給 "
":const:`ACCESS_WRITE` 記憶體映射會影響記憶體和底層文件。分配給 "
":const:`ACCESS_COPY` 記憶體映射會影響記憶體，但不會更新底層文件。"

#: ../../library/mmap.rst:46
msgid "Added :const:`ACCESS_DEFAULT` constant."
msgstr "新增 :const:`ACCESS_DEFAULT` 常數。"

#: ../../library/mmap.rst:49
#, fuzzy
msgid ""
"To map anonymous memory, -1 should be passed as the fileno along with the "
"length."
msgstr "要映射匿名記憶體，-1 應該作為 fileno 連同長度一起傳遞。"

#: ../../library/mmap.rst:53
#, fuzzy
msgid ""
"**(Windows version)** Maps *length* bytes from the file specified by the "
"file handle *fileno*, and creates a mmap object.  If *length* is larger than "
"the current size of the file, the file is extended to contain *length* "
"bytes.  If *length* is ``0``, the maximum length of the map is the current "
"size of the file, except that if the file is empty Windows raises an "
"exception (you cannot create an empty mapping on Windows)."
msgstr ""
"**（Windows 版本）** 從文件句柄 *fileno* 指定的文件映射 *length* 位元組，"
"並建立一個 mmap 物件。如果 *length* 大於文件的當前大小，則文件將擴充為包含 "
"*length* 個位元組。如果 *length* 為 ``0``，則映射的最大長度為文件的當前大小，"
"除非文件為空 Windows 會引發例外（您不能在 Windows 上建立空映射）。"

#: ../../library/mmap.rst:60
#, fuzzy
msgid ""
"*tagname*, if specified and not ``None``, is a string giving a tag name for "
"the mapping.  Windows allows you to have many different mappings against the "
"same file.  If you specify the name of an existing tag, that tag is opened, "
"otherwise a new tag of this name is created.  If this parameter is omitted "
"or ``None``, the mapping is created without a name.  Avoiding the use of the "
"tag parameter will assist in keeping your code portable between Unix and "
"Windows."
msgstr ""
"*tagname*，如果指定而不是``None``，是一個為映射提供標籤名稱的字串。 Windows "
"允許您對同一個文件有許多不同的映射。如果指定現有標籤的名稱，則會打開該標籤，"
"否則會建立一個具有此名稱的新標籤。如果省略此參數或 ``None`` ，則建立的映射沒有名稱"
"。避免使用 tag 參數將有助於保持程式碼在 Unix 和 Windows 之間的可移植性。"

#: ../../library/mmap.rst:68
#, fuzzy
msgid ""
"*offset* may be specified as a non-negative integer offset. mmap references "
"will be relative to the offset from the beginning of the file. *offset* "
"defaults to 0.  *offset* must be a multiple of the :const:"
"`ALLOCATIONGRANULARITY`."
msgstr ""
"*offset* 可以指定為非負整數偏移量。 mmap 引用將相對於文件開頭的偏移量。 "
"*offset* 預設為 0。*offset* 必須是 ALLOCATIONGRANULARITY 的倍數。"

#: ../../library/mmap.rst:83 ../../library/mmap.rst:174
msgid ""
"Raises an :ref:`auditing event <auditing>` ``mmap.__new__`` with arguments "
"``fileno``, ``length``, ``access``, ``offset``."
msgstr ""
"引發一個附帶引數 ``fileno``、``length``、``access``、``offset`` 的\\ :ref:`稽核事件 <auditing>` ``mmap.__new__``。"

#: ../../library/mmap.rst:77
#, fuzzy
msgid ""
"**(Unix version)** Maps *length* bytes from the file specified by the file "
"descriptor *fileno*, and returns a mmap object.  If *length* is ``0``, the "
"maximum length of the map will be the current size of the file when :class:"
"`~mmap.mmap` is called."
msgstr ""
"**（Unix 版本）** 從文件描述器 *fileno* 指定的文件映射 *length* 位元組，"
"並回傳一個 mmap 物件。如果 *length* 為 ``0``，則地圖的最大長度將是呼叫 "
":class:`~mmap.mmap` 時文件的當前大小。"

#: ../../library/mmap.rst:82
#, fuzzy
msgid ""
"*flags* specifies the nature of the mapping. :const:`MAP_PRIVATE` creates a "
"private copy-on-write mapping, so changes to the contents of the mmap object "
"will be private to this process, and :const:`MAP_SHARED` creates a mapping "
"that's shared with all other processes mapping the same areas of the file.  "
"The default value is :const:`MAP_SHARED`. Some systems have additional "
"possible flags with the full list specified in :ref:`MAP_* constants <map-"
"constants>`."
msgstr ""
"*flags* 指定映射的性質。 :const:`MAP_PRIVATE` 建立一個私有的寫時復制映射，"
"因此對 mmap 物件內容的更改將對該行程私有，而 :const:`MAP_SHARED` 建立一個映射"
"，該映射與映射文件的相同區域。預設值為 :const:`MAP_SHARED`。一些系統有額外的"
"可能旗標，完整列表在 :ref:`MAP_* constants <map-constants>` 中指定。"

#: ../../library/mmap.rst:90
#, fuzzy
msgid ""
"*prot*, if specified, gives the desired memory protection; the two most "
"useful values are :const:`PROT_READ` and :const:`PROT_WRITE`, to specify "
"that the pages may be read or written.  *prot* defaults to :const:`PROT_READ "
"\\| PROT_WRITE`."
msgstr ""
"*prot*，如果指定，提供所需的記憶體保護；兩個最有用的值是 :const:`PROT_READ` "
"和 :const:`PROT_WRITE`，用於指定可以讀取或寫入頁面。 *prot* 預設為 :const:`"
"PROT_READ \\|保護寫入`。"

#: ../../library/mmap.rst:95
#, fuzzy
msgid ""
"*access* may be specified in lieu of *flags* and *prot* as an optional "
"keyword parameter.  It is an error to specify both *flags*, *prot* and "
"*access*.  See the description of *access* above for information on how to "
"use this parameter."
msgstr ""
"*access* 可以代替 *flags* 和 *prot* 作為可選關鍵字參數指定。同時指定 "
"*flags*、*prot* 和 *access* 是錯誤的。有關如何使用此參數的資訊，請參閱上面對 "
"*access* 的描述。"

#: ../../library/mmap.rst:100
#, fuzzy
msgid ""
"*offset* may be specified as a non-negative integer offset. mmap references "
"will be relative to the offset from the beginning of the file. *offset* "
"defaults to 0. *offset* must be a multiple of :const:`ALLOCATIONGRANULARITY` "
"which is equal to :const:`PAGESIZE` on Unix systems."
msgstr ""
"*offset* 可以指定為非負整數偏移量。 mmap 引用將相對於文件開頭的偏移量。 "
"*offset* 預設為 0。*offset* 必須是 :const:`ALLOCATIONGRANULARITY` 的倍數，在 "
"Unix 系統上等於 :const:`PAGESIZE`。"

#: ../../library/mmap.rst:105
#, fuzzy
msgid ""
"To ensure validity of the created memory mapping the file specified by the "
"descriptor *fileno* is internally automatically synchronized with the "
"physical backing store on macOS."
msgstr "為確保建立的記憶體映射的有效性，由描述器 *fileno* 指定的文件在內部自動與 "
"macOS 上的物理後備儲存同步。"

#: ../../library/mmap.rst:109
#, fuzzy
msgid "This example shows a simple way of using :class:`~mmap.mmap`::"
msgstr "這個例子展示了一種使用 :class:`~mmap.mmap`:: 的簡單方法"

#: ../../library/mmap.rst:134
#, fuzzy
msgid ""
":class:`~mmap.mmap` can also be used as a context manager in a :keyword:"
"`with` statement::"
msgstr ":class:`~mmap.mmap` 也可以用作 :keyword:`with` 語句中的上下文管理器::"

#: ../../library/mmap.rst:142
#, fuzzy
msgid "Context manager support."
msgstr "上下文管理器支援。"

#: ../../library/mmap.rst:146
#, fuzzy
msgid ""
"The next example demonstrates how to create an anonymous map and exchange "
"data between the parent and child processes::"
msgstr "下一個示例演示如何建立匿名映射並在父行程和子行程之間交換資料："

#: ../../library/mmap.rst:165
#, fuzzy
msgid "Memory-mapped file objects support the following methods:"
msgstr "記憶體映射文件物件支援以下方法："

#: ../../library/mmap.rst:169
#, fuzzy
msgid ""
"Closes the mmap. Subsequent calls to other methods of the object will result "
"in a ValueError exception being raised. This will not close the open file."
msgstr "關閉 mmap。對該物件的其他方法的後續呼叫將導致引發 ValueError "
"例外。這不會關閉打開的文件。"

#: ../../library/mmap.rst:176
#, fuzzy
msgid "``True`` if the file is closed."
msgstr "如果文件已關閉，則為 True。"

#: ../../library/mmap.rst:183
#, fuzzy
msgid ""
"Returns the lowest index in the object where the subsequence *sub* is found, "
"such that *sub* is contained in the range [*start*, *end*]. Optional "
"arguments *start* and *end* are interpreted as in slice notation. Returns "
"``-1`` on failure."
msgstr ""
"回傳對像中找到子序列 *sub* 的最低索引，這樣 *sub* 包含在範圍 [*start*, *end*]"
" 中。可選參數 *start* 和 *end* 被解釋為切片符號。失敗時回傳 ``-1``。"

#: ../../library/mmap.rst:188 ../../library/mmap.rst:277
#: ../../library/mmap.rst:309
#, fuzzy
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "可寫 :term:`bytes-like object` 現在被接受。"

#: ../../library/mmap.rst:194
#, fuzzy
msgid ""
"Flushes changes made to the in-memory copy of a file back to disk. Without "
"use of this call there is no guarantee that changes are written back before "
"the object is destroyed.  If *offset* and *size* are specified, only changes "
"to the given range of bytes will be flushed to disk; otherwise, the whole "
"extent of the mapping is flushed.  *offset* must be a multiple of the :const:"
"`PAGESIZE` or :const:`ALLOCATIONGRANULARITY`."
msgstr ""
"將對文件的記憶體副本所做的更改刷新回磁盤。如果不使用此呼叫，則無法保證在銷毀"
"物件之前寫回更改。如果指定了 *offset* 和 *size*，只有對給定位元組範圍的更改才"
"會刷新到磁盤；否則，映射的整個範圍都會被刷新。 *offset* 必須是 "
":const:`PAGESIZE` 或 :const:`ALLOCATIONGRANULARITY` 的倍數。"

#: ../../library/mmap.rst:201
#, fuzzy
msgid ""
"``None`` is returned to indicate success.  An exception is raised when the "
"call failed."
msgstr "回傳 ``None`` 表示成功。呼叫失敗時會引發例外。"

#: ../../library/mmap.rst:204
#, fuzzy
msgid ""
"Previously, a nonzero value was returned on success; zero was returned on "
"error under Windows.  A zero value was returned on success; an exception was "
"raised on error under Unix."
msgstr "以前，成功時會回傳一個非零值；在 Windows 下錯誤回傳零。成功回傳零值；在 Unix "
"下錯誤引發例外。"

#: ../../library/mmap.rst:212
#, fuzzy
msgid ""
"Send advice *option* to the kernel about the memory region beginning at "
"*start* and extending *length* bytes.  *option* must be one of the :ref:"
"`MADV_* constants <madvise-constants>` available on the system.  If *start* "
"and *length* are omitted, the entire mapping is spanned.  On some systems "
"(including Linux), *start* must be a multiple of the :const:`PAGESIZE`."
msgstr ""
"向內核發送有關從 *start* 開始並擴充 *length* 位元組的記憶體區域的建議 "
"*option*。 *option* 必須是系統可用的 MADV_* 常數 <madvise-constants> 之一。"
"如果省略 *start* 和 *length*，則跨越整個映射。在某些系統（包括 "
"Linux）上，*start* 必須是 :const:`PAGESIZE` 的倍數。"

#: ../../library/mmap.rst:219
#, fuzzy
msgid "Availability: Systems with the ``madvise()`` system call."
msgstr "可用性：具有 ``madvise()`` 系統呼叫的系統。"

#: ../../library/mmap.rst:226
#, fuzzy
msgid ""
"Copy the *count* bytes starting at offset *src* to the destination index "
"*dest*.  If the mmap was created with :const:`ACCESS_READ`, then calls to "
"move will raise a :exc:`TypeError` exception."
msgstr ""
"將從偏移量 *src* 開始的 *count* 個位元組複製到目標索引 *dest*。如果 mmap "
"是使用 :const:`ACCESS_READ` 建立的，則對 move 的呼叫將引發 :exc:`TypeError` "
"例外。"

#: ../../library/mmap.rst:233
#, fuzzy
msgid ""
"Return a :class:`bytes` containing up to *n* bytes starting from the current "
"file position. If the argument is omitted, ``None`` or negative, return all "
"bytes from the current file position to the end of the mapping. The file "
"position is updated to point after the bytes that were returned."
msgstr ""
"回傳一個 :class:`bytes` 包含從當前文件位置開始最多 *n* 個位元組。如果省略參數"
"， ``None`` 或負數，則回傳從當前文件位置到映射末尾的所有位元組。文件位置更新為指向"
"回傳的位元組之後。"

#: ../../library/mmap.rst:239
#, fuzzy
msgid "Argument can be omitted or ``None``."
msgstr "參數可以省略或 ``None`` 。"

#: ../../library/mmap.rst:244
#, fuzzy
msgid ""
"Returns a byte at the current file position as an integer, and advances the "
"file position by 1."
msgstr "以整數形式回傳當前文件位置的一個位元組，並將文件位置前進 1。"

#: ../../library/mmap.rst:250
#, fuzzy
msgid ""
"Returns a single line, starting at the current file position and up to the "
"next newline. The file position is updated to point after the bytes that "
"were returned."
msgstr "回傳單行，從當前文件位置開始到下一個換行符。文件位置更新為指向回傳的位元組之"
"後。"

#: ../../library/mmap.rst:257
#, fuzzy
msgid ""
"Resizes the map and the underlying file, if any. If the mmap was created "
"with :const:`ACCESS_READ` or :const:`ACCESS_COPY`, resizing the map will "
"raise a :exc:`TypeError` exception."
msgstr ""
"調整地圖和底層文件（如果有）的大小。如果 mmap 是使用 :const:`ACCESS_READ` 或 "
":const:`ACCESS_COPY` 建立的，調整地圖大小將引發 :exc:`TypeError` 例外。"

#: ../../library/mmap.rst:261
#, fuzzy
msgid ""
"**On Windows**: Resizing the map will raise an :exc:`OSError` if there are "
"other maps against the same named file. Resizing an anonymous map (ie "
"against the pagefile) will silently create a new map with the original data "
"copied over up to the length of the new size."
msgstr ""
"**在 Windows 上**：如果有其他地圖針對同一命名文件，調整地圖大小將引發 :exc:`O"
"SError`。調整匿名地圖的大小（即針對頁面文件）將靜默地建立一個新地圖，其原始資"
"料被複製到新大小的長度。"

#: ../../library/mmap.rst:266
#, fuzzy
msgid ""
"Correctly fails if attempting to resize when another map is held Allows "
"resize against an anonymous map on Windows"
msgstr "如果在持有另一張地圖時嘗試調整大小，則正確失敗允許在 Windows "
"上針對匿名地圖調整大小"

#: ../../library/mmap.rst:272
#, fuzzy
msgid ""
"Returns the highest index in the object where the subsequence *sub* is "
"found, such that *sub* is contained in the range [*start*, *end*]. Optional "
"arguments *start* and *end* are interpreted as in slice notation. Returns "
"``-1`` on failure."
msgstr ""
"回傳找到子序列 *sub* 的對像中的最高索引，這樣 *sub* 包含在範圍 [*start*, "
"*end*] 中。可選參數 *start* 和 *end* 被解釋為切片符號。失敗時回傳 ``-1``。"

#: ../../library/mmap.rst:283
#, fuzzy
msgid ""
"Set the file's current position.  *whence* argument is optional and defaults "
"to ``os.SEEK_SET`` or ``0`` (absolute file positioning); other values are "
"``os.SEEK_CUR`` or ``1`` (seek relative to the current position) and ``os."
"SEEK_END`` or ``2`` (seek relative to the file's end)."
msgstr ""
"設定文件的當前位置。 *whence* 參數是可選的，預設為 ``os.SEEK_SET`` 或 "
"``0``（絕對文件定位）；其他值是 ``os.SEEK_CUR`` 或 "
"``1``（相對於當前位置查找）和 ``os.SEEK_END`` 或 "
"``2``（相對於文件末尾查找）。"

#: ../../library/mmap.rst:291
#, fuzzy
msgid ""
"Return the length of the file, which can be larger than the size of the "
"memory-mapped area."
msgstr "回傳文件的長度，可以大於記憶體映射區的大小。"

#: ../../library/mmap.rst:297
#, fuzzy
msgid "Returns the current position of the file pointer."
msgstr "回傳文件指標的當前位置。"

#: ../../library/mmap.rst:302
#, fuzzy
msgid ""
"Write the bytes in *bytes* into memory at the current position of the file "
"pointer and return the number of bytes written (never less than "
"``len(bytes)``, since if the write fails, a :exc:`ValueError` will be "
"raised).  The file position is updated to point after the bytes that were "
"written.  If the mmap was created with :const:`ACCESS_READ`, then writing to "
"it will raise a :exc:`TypeError` exception."
msgstr ""
"將 *bytes* 中的位元組寫入文件指標當前位置的記憶體中，並回傳寫入的位元組數（"
"絕不會小於 ``len(bytes)``，因為如果寫入失敗，則會出現 "
":exc:`ValueError`將被提高）。文件位置更新為指向寫入的位元組之後。如果 mmap "
"是使用 :const:`ACCESS_READ` 建立的，那麼寫入它會引發 :exc:`TypeError` 例外。"

#: ../../library/mmap.rst:312
#, fuzzy
msgid "The number of bytes written is now returned."
msgstr "現在回傳寫入的位元組數。"

#: ../../library/mmap.rst:318
#, fuzzy
msgid ""
"Write the integer *byte* into memory at the current position of the file "
"pointer; the file position is advanced by ``1``. If the mmap was created "
"with :const:`ACCESS_READ`, then writing to it will raise a :exc:`TypeError` "
"exception."
msgstr ""
"將整數 *byte* 寫入記憶體中文件指標的當前位置；文件位置前進了 ``1``。如果 "
"mmap 是使用 :const:`ACCESS_READ` 建立的，那麼寫入它會引發 :exc:`TypeError` "
"例外。"

#: ../../library/mmap.rst:326
#, fuzzy
msgid "MADV_* Constants"
msgstr "MADV_* 常數"

#: ../../library/mmap.rst:353
#, fuzzy
msgid ""
"These options can be passed to :meth:`mmap.madvise`.  Not every option will "
"be present on every system."
msgstr "這些選項可以傳遞給 :meth:`mmap.madvise`。並非每個系統都會出現每個選項。"

#: ../../library/mmap.rst:356
#, fuzzy
msgid "Availability: Systems with the madvise() system call."
msgstr "可用性：具有 madvise() 系統呼叫的系統。"

#: ../../library/mmap.rst:363
#, fuzzy
msgid "MAP_* Constants"
msgstr "MAP_* 常數"

#: ../../library/mmap.rst:374
#, fuzzy
msgid ""
"These are the various flags that can be passed to :meth:`mmap.mmap`. Note "
"that some options might not be present on some systems."
msgstr "這些是可以傳遞給 mmap.mmap "
"的各種旗標。請注意，某些選項在某些系統上可能不存在。"

#: ../../library/mmap.rst:376
msgid "Added MAP_POPULATE constant."
msgstr "新增 MAP_POPULATE 常數。"

#: ../../library/mmap.rst:379
msgid "Added MAP_STACK constant."
msgstr "新增 MAP_STACK 常數。"
