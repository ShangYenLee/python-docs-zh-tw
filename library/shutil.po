# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-24 00:16+0000\n"
"PO-Revision-Date: 2018-05-23 16:10+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../library/shutil.rst:2
msgid ":mod:`shutil` --- High-level file operations"
msgstr ":mod:`shutil` --- 高階檔案操作"

#: ../../library/shutil.rst:10
msgid "**Source code:** :source:`Lib/shutil.py`"
msgstr "**原始碼：**\\ :source:`Lib/shutil.py`"

#: ../../library/shutil.rst:18
#, fuzzy
msgid ""
"The :mod:`shutil` module offers a number of high-level operations on files "
"and collections of files.  In particular, functions are provided  which "
"support file copying and removal. For operations on individual files, see "
"also the :mod:`os` module."
msgstr ""
":mod:`shutil` 模組提供了許多對文件和文件集合的高階操作。特別是，提供了支援文"
"件複製和刪除的功能。有關對單個文件的操作，另請參閱 :mod:`os` 模組。"

#: ../../library/shutil.rst:25
#, fuzzy
msgid ""
"Even the higher-level file copying functions (:func:`shutil.copy`, :func:"
"`shutil.copy2`) cannot copy all file metadata."
msgstr ""
"即使是更高階別的文件複製函式（:func:`shutil.copy`、:func:`shutil.copy2`）也無"
"法複製所有文件元資料。"

#: ../../library/shutil.rst:28
#, fuzzy
msgid ""
"On POSIX platforms, this means that file owner and group are lost as well as "
"ACLs.  On Mac OS, the resource fork and other metadata are not used. This "
"means that resources will be lost and file type and creator codes will not "
"be correct. On Windows, file owners, ACLs and alternate data streams are not "
"copied."
msgstr ""
"在 POSIX 平台上，這意味著文件所有者和組以及 ACL 都將丟失。在 Mac OS 上，不使"
"用資源分支和其他元資料。這意味著資源將丟失，文件型別和建立者程式碼將不正確。"
"在 Windows 上，不會復製文件所有者、ACL 和備用資料流。"

#: ../../library/shutil.rst:38
#, fuzzy
msgid "Directory and files operations"
msgstr "目錄和文件操作"

#: ../../library/shutil.rst:42
#, fuzzy
msgid ""
"Copy the contents of the file-like object *fsrc* to the file-like object "
"*fdst*. The integer *length*, if given, is the buffer size. In particular, a "
"negative *length* value means to copy the data without looping over the "
"source data in chunks; by default the data is read in chunks to avoid "
"uncontrolled memory consumption. Note that if the current file position of "
"the *fsrc* object is not 0, only the contents from the current file position "
"to the end of the file will be copied."
msgstr ""
"將類文件物件 *fsrc* 的內容複製到類文件物件 *fdst*。整數 *length*（如果給定）"
"是緩衝區大小。特別是，負 *length* 值意味著複製資料而不循環遍歷塊中的源資料；"
"預設情況下，資料以塊的形式讀取，以避免不受控制的記憶體消耗。注意，如果*fsrc*"
"物件的當前文件位置不為0，則只會復制從當前文件位置到文件末尾的內容。"

#: ../../library/shutil.rst:53
#, fuzzy
msgid ""
"Copy the contents (no metadata) of the file named *src* to a file named "
"*dst* and return *dst* in the most efficient way possible. *src* and *dst* "
"are path-like objects or path names given as strings."
msgstr ""
"將名為 *src* 的文件的內容（無元資料）複製到名為 *dst* 的文件中，並以最有效的"
"方式回傳 *dst*。 *src* 和 *dst* 是類似路徑的對像或以字串形式給出的路徑名。"

#: ../../library/shutil.rst:57
#, fuzzy
msgid ""
"*dst* must be the complete target file name; look at :func:`~shutil.copy` "
"for a copy that accepts a target directory path.  If *src* and *dst* specify "
"the same file, :exc:`SameFileError` is raised."
msgstr ""
"*dst* 必須是完整的目標文件名；查看 :func:`~shutil.copy` 以獲得接受目標目錄路"
"徑的副本。如果 *src* 和 *dst* 指定相同的文件，則會引發 :exc:`SameFileError`。"

#: ../../library/shutil.rst:61
#, fuzzy
msgid ""
"The destination location must be writable; otherwise, an :exc:`OSError` "
"exception will be raised. If *dst* already exists, it will be replaced. "
"Special files such as character or block devices and pipes cannot be copied "
"with this function."
msgstr ""
"目標位置必須是可寫的；否則，將引發 :exc:`OSError` 例外。如果 *dst* 已經存在，"
"它將被替換。不能使用此功能複制特殊文件，例如字元或塊設備和管道。"

#: ../../library/shutil.rst:66
#, fuzzy
msgid ""
"If *follow_symlinks* is false and *src* is a symbolic link, a new symbolic "
"link will be created instead of copying the file *src* points to."
msgstr ""
"如果 *follow_symlinks* 為 false 並且 *src* 是符號鏈接，將建立一個新的符號鏈接"
"而不是複制 *src* 指向的文件。"

#: ../../library/shutil.rst:70 ../../library/shutil.rst:177
#: ../../library/shutil.rst:208
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copyfile`` with "
"arguments ``src``, ``dst``."
msgstr ""
"引發一個附帶引數 ``src``、``dst`` 的\\ :ref:`稽核事件 <auditing>` ``shutil."
"copyfile``。"

#: ../../library/shutil.rst:72
#, fuzzy
msgid ""
":exc:`IOError` used to be raised instead of :exc:`OSError`. Added "
"*follow_symlinks* argument. Now returns *dst*."
msgstr ""
":exc:`IOError` 曾經被引發而不是 :exc:`OSError`。新增了 *follow_symlinks* 參"
"數。現在回傳 *dst*。"

#: ../../library/shutil.rst:77
#, fuzzy
msgid ""
"Raise :exc:`SameFileError` instead of :exc:`Error`.  Since the former is a "
"subclass of the latter, this change is backward compatible."
msgstr ""
"引發 :exc:`SameFileError` 而不是 :exc:`Error`。由於前者是後者的子類別，因此此"
"更改是向後相容的。"

#: ../../library/shutil.rst:81 ../../library/shutil.rst:185
#: ../../library/shutil.rst:217 ../../library/shutil.rst:287
#: ../../library/shutil.rst:381
#, fuzzy
msgid ""
"Platform-specific fast-copy syscalls may be used internally in order to copy "
"the file more efficiently. See :ref:`shutil-platform-dependent-efficient-"
"copy-operations` section."
msgstr ""
"可以在內部使用特定於平台的快速復制系統呼叫，以便更有效地複製文件。請參閱 :"
"ref:`shutil-platform-dependent-efficient-copy-operations` 部分。"

#: ../../library/shutil.rst:88
#, fuzzy
msgid ""
"This exception is raised if source and destination in :func:`copyfile` are "
"the same file."
msgstr "如果 :func:`copyfile` 中的源和目標是同一個文件，則會引發此例外。"

#: ../../library/shutil.rst:96
#, fuzzy
msgid ""
"Copy the permission bits from *src* to *dst*.  The file contents, owner, and "
"group are unaffected.  *src* and *dst* are path-like objects or path names "
"given as strings. If *follow_symlinks* is false, and both *src* and *dst* "
"are symbolic links, :func:`copymode` will attempt to modify the mode of "
"*dst* itself (rather than the file it points to).  This functionality is not "
"available on every platform; please see :func:`copystat` for more "
"information.  If :func:`copymode` cannot modify symbolic links on the local "
"platform, and it is asked to do so, it will do nothing and return."
msgstr ""
"將權限位從 *src* 複製到 *dst*。文件內容、所有者和組不受影響。 *src* 和 *dst* "
"是類似路徑的對像或以字串形式給出的路徑名。如果 *follow_symlinks* 為 false，並"
"且 *src* 和 *dst* 都是符號鏈接，:func:`copymode` 將嘗試修改 *dst* 本身的模式"
"（而不是它指向的文件）。此功能並非在每個平台上都可用；請參閱 :func:"
"`copystat` 了解更多資訊。如果 :func:`copymode` 無法修改本地平台上的符號鏈接，"
"並且被要求這樣做，它什麼都不做並回傳。"

#: ../../library/shutil.rst:106 ../../library/shutil.rst:179
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copymode`` with "
"arguments ``src``, ``dst``."
msgstr ""
"引發一個附帶引數 ``src``、``dst`` 的\\ :ref:`稽核事件 <auditing>` ``shutil."
"copymode``。"

#: ../../library/shutil.rst:108
msgid "Added *follow_symlinks* argument."
msgstr "新增 *follow_symlinks* 引數。"

#: ../../library/shutil.rst:113
#, fuzzy
msgid ""
"Copy the permission bits, last access time, last modification time, and "
"flags from *src* to *dst*.  On Linux, :func:`copystat` also copies the "
"\"extended attributes\" where possible.  The file contents, owner, and group "
"are unaffected.  *src* and *dst* are path-like objects or path names given "
"as strings."
msgstr ""
"將權限位、上次訪問時間、上次修改時間和旗標從 *src* 複製到 *dst*。在 Linux "
"上，:func:`copystat` 還會盡可能複制“擴充屬性”。文件內容、所有者和組不受影"
"響。 *src* 和 *dst* 是類似路徑的對像或以字串形式給出的路徑名。"

#: ../../library/shutil.rst:119
#, fuzzy
msgid ""
"If *follow_symlinks* is false, and *src* and *dst* both refer to symbolic "
"links, :func:`copystat` will operate on the symbolic links themselves rather "
"than the files the symbolic links refer to—reading the information from the "
"*src* symbolic link, and writing the information to the *dst* symbolic link."
msgstr ""
"如果 *follow_symlinks* 為 false，並且 *src* 和 *dst* 都引用符號鏈接，:func:"
"`copystat` 將對符號鏈接本身而不是符號鏈接引用的文件進行操作——從 * src* 符號鏈"
"接，並將資訊寫入 *dst* 符號鏈接。"

#: ../../library/shutil.rst:128
#, fuzzy
msgid ""
"Not all platforms provide the ability to examine and modify symbolic links.  "
"Python itself can tell you what functionality is locally available."
msgstr ""
"並非所有平台都提供檢查和修改符號鏈接的能力。 Python 本身可以告訴您本地可用的"
"功能。"

#: ../../library/shutil.rst:132
#, fuzzy
msgid ""
"If ``os.chmod in os.supports_follow_symlinks`` is ``True``, :func:`copystat` "
"can modify the permission bits of a symbolic link."
msgstr ""
"如果 os.supports_follow_symlinks 中的 os.chmod 為 True，copystat 可以修改符號"
"鏈接的權限位。"

#: ../../library/shutil.rst:136
#, fuzzy
msgid ""
"If ``os.utime in os.supports_follow_symlinks`` is ``True``, :func:`copystat` "
"can modify the last access and modification times of a symbolic link."
msgstr ""
"如果 os.supports_follow_symlinks 中的 os.utime 為 True，copystat 可以修改符號"
"鏈接的最後訪問和修改時間。"

#: ../../library/shutil.rst:140
#, fuzzy
msgid ""
"If ``os.chflags in os.supports_follow_symlinks`` is ``True``, :func:"
"`copystat` can modify the flags of a symbolic link.  (``os.chflags`` is not "
"available on all platforms.)"
msgstr ""
"如果 os.supports_follow_symlinks 中的 os.chflags 為 True，copystat 可以修改符"
"號鏈接的旗標。 （``os.chflags`` 並非在所有平台上都可用。）"

#: ../../library/shutil.rst:145
#, fuzzy
msgid ""
"On platforms where some or all of this functionality is unavailable, when "
"asked to modify a symbolic link, :func:`copystat` will copy everything it "
"can. :func:`copystat` never returns failure."
msgstr ""
"在部分或全部此功能不可用的平台上，當要求修改符號鏈接時，:func:`copystat` 將復"
"制它可以復制的所有內容。 :func:`copystat` 從不回傳失敗。"

#: ../../library/shutil.rst:150
msgid "Please see :data:`os.supports_follow_symlinks` for more information."
msgstr "更多資訊請見 :data:`os.supports_follow_symlinks`\\ 。"

#: ../../library/shutil.rst:153 ../../library/shutil.rst:210
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copystat`` with "
"arguments ``src``, ``dst``."
msgstr ""
"引發一個附帶引數 ``src``、``dst`` 的\\ :ref:`稽核事件 <auditing>` ``shutil."
"copystat``。"

#: ../../library/shutil.rst:155
#, fuzzy
msgid ""
"Added *follow_symlinks* argument and support for Linux extended attributes."
msgstr "新增了 *follow_symlinks* 參數並支援 Linux 擴充屬性。"

#: ../../library/shutil.rst:160
#, fuzzy
msgid ""
"Copies the file *src* to the file or directory *dst*.  *src* and *dst* "
"should be :term:`path-like objects <path-like object>` or strings.  If *dst* "
"specifies a directory, the file will be copied into *dst* using the base "
"filename from *src*. If *dst* specifies a file that already exists, it will "
"be replaced. Returns the path to the newly created file."
msgstr ""
"將文件 *src* 複製到文件或目錄 *dst*。 *src* 和 *dst* 應該是 :term:`path-like "
"objects <path-like object>` 或字串。如果 *dst* 指定了一個目錄，該文件將使用 "
"*src* 中的基本文件名複製到 *dst* 中。如果 *dst* 指定一個已經存在的文件，它將"
"被替換。回傳新建立文件的路徑。"

#: ../../library/shutil.rst:166
#, fuzzy
msgid ""
"If *follow_symlinks* is false, and *src* is a symbolic link, *dst* will be "
"created as a symbolic link.  If *follow_symlinks* is true and *src* is a "
"symbolic link, *dst* will be a copy of the file *src* refers to."
msgstr ""
"如果 *follow_symlinks* 為 false，並且 *src* 是一個符號鏈接，*dst* 將被建立為"
"一個符號鏈接。如果 *follow_symlinks* 為 true 並且 *src* 是符號鏈接，則 *dst* "
"將是 *src* 引用的文件的副本。"

#: ../../library/shutil.rst:171
#, fuzzy
msgid ""
":func:`~shutil.copy` copies the file data and the file's permission mode "
"(see :func:`os.chmod`).  Other metadata, like the file's creation and "
"modification times, is not preserved. To preserve all file metadata from the "
"original, use :func:`~shutil.copy2` instead."
msgstr ""
":func:`~shutil.copy` 複製文件資料和文件的權限模式（參見 :func:`os.chmod`）。"
"不保留其他元資料，如文件的建立和修改時間。要保留原始文件的所有文件元資料，請"
"改用 :func:`~shutil.copy2`。"

#: ../../library/shutil.rst:181
#, fuzzy
msgid ""
"Added *follow_symlinks* argument. Now returns path to the newly created file."
msgstr "新增了 *follow_symlinks* 參數。現在回傳新建立文件的路徑。"

#: ../../library/shutil.rst:192
#, fuzzy
msgid ""
"Identical to :func:`~shutil.copy` except that :func:`copy2` also attempts to "
"preserve file metadata."
msgstr ""
"與 :func:`~shutil.copy` 相同，除了 :func:`copy2` 還嘗試保留文件元資料。"

#: ../../library/shutil.rst:195
#, fuzzy
msgid ""
"When *follow_symlinks* is false, and *src* is a symbolic link, :func:`copy2` "
"attempts to copy all metadata from the *src* symbolic link to the newly "
"created *dst* symbolic link. However, this functionality is not available on "
"all platforms. On platforms where some or all of this functionality is "
"unavailable, :func:`copy2` will preserve all the metadata it can; :func:"
"`copy2` never raises an exception because it cannot preserve file metadata."
msgstr ""
"當 *follow_symlinks* 為 false，並且 *src* 是符號鏈接時，:func:`copy2` 嘗試將"
"所有元資料從 *src* 符號鏈接複製到新建立的 *dst* 符號鏈接。但是，此功能並非在"
"所有平台上都可用。在部分或全部此功能不可用的平台上，:func:`copy2` 將盡可能保"
"留所有元資料； :func:`copy2` 永遠不會引發例外，因為它無法保留文件元資料。"

#: ../../library/shutil.rst:204
#, fuzzy
msgid ""
":func:`copy2` uses :func:`copystat` to copy the file metadata. Please see :"
"func:`copystat` for more information about platform support for modifying "
"symbolic link metadata."
msgstr ""
":func:`copy2` 使用 :func:`copystat` 複製文件元資料。請參閱 :func:`copystat` "
"以獲取有關修改符號鏈接元資料的平台支援的更多資訊。"

#: ../../library/shutil.rst:212
#, fuzzy
msgid ""
"Added *follow_symlinks* argument, try to copy extended file system "
"attributes too (currently Linux only). Now returns path to the newly created "
"file."
msgstr ""
"新增了 *follow_symlinks* 參數，也嘗試複製擴充文件系統屬性（目前僅限 Linux）。"
"現在回傳新建立文件的路徑。"

#: ../../library/shutil.rst:224
#, fuzzy
msgid ""
"This factory function creates a function that can be used as a callable for :"
"func:`copytree`\\'s *ignore* argument, ignoring files and directories that "
"match one of the glob-style *patterns* provided.  See the example below."
msgstr ""
"此工廠函式建立一個函式，可用作 :func:`copytree`\\'s *ignore* 參數的可呼叫函"
"式，忽略與提供的 glob 樣式 *patterns* 之一匹配的文件和目錄。請參見下面的示"
"例。"

#: ../../library/shutil.rst:233
#, fuzzy
msgid ""
"Recursively copy an entire directory tree rooted at *src* to a directory "
"named *dst* and return the destination directory.  All intermediate "
"directories needed to contain *dst* will also be created by default."
msgstr ""
"遞迴地將以 *src* 為根的整個目錄樹複製到名為 *dst* 的目錄並回傳目標目錄。所有"
"需要包含 *dst* 的中間目錄也將預設建立。"

#: ../../library/shutil.rst:237
#, fuzzy
msgid ""
"Permissions and times of directories are copied with :func:`copystat`, "
"individual files are copied using :func:`~shutil.copy2`."
msgstr ""
"使用 :func:`copystat` 複製目錄的權限和時間，使用 :func:`~shutil.copy2` 複製單"
"個文件。"

#: ../../library/shutil.rst:240
#, fuzzy
msgid ""
"If *symlinks* is true, symbolic links in the source tree are represented as "
"symbolic links in the new tree and the metadata of the original links will "
"be copied as far as the platform allows; if false or omitted, the contents "
"and metadata of the linked files are copied to the new tree."
msgstr ""
"如果 *symlinks* 為真，源樹中的符號鏈接表示為新樹中的符號鏈接，原始鏈接的元資"
"料將在平台允許的範圍內復制；如果為 false 或省略，則鏈接文件的內容和元資料將復"
"製到新樹。"

#: ../../library/shutil.rst:245
#, fuzzy
msgid ""
"When *symlinks* is false, if the file pointed by the symlink doesn't exist, "
"an exception will be added in the list of errors raised in an :exc:`Error` "
"exception at the end of the copy process. You can set the optional "
"*ignore_dangling_symlinks* flag to true if you want to silence this "
"exception. Notice that this option has no effect on platforms that don't "
"support :func:`os.symlink`."
msgstr ""
"當 *symlinks* 為 false 時，如果符號鏈接指向的文件不存在，將在復製過程結束時"
"在 :exc:`Error` 例外引發的錯誤列表中新增例外。如果您想消除此例外，可以將可選"
"的 *ignore_dangling_symlinks* 旗標設定為 true。請注意，此選項對不支援 :func:"
"`os.symlink` 的平台沒有影響。"

#: ../../library/shutil.rst:252
#, fuzzy
msgid ""
"If *ignore* is given, it must be a callable that will receive as its "
"arguments the directory being visited by :func:`copytree`, and a list of its "
"contents, as returned by :func:`os.listdir`.  Since :func:`copytree` is "
"called recursively, the *ignore* callable will be called once for each "
"directory that is copied.  The callable must return a sequence of directory "
"and file names relative to the current directory (i.e. a subset of the items "
"in its second argument); these names will then be ignored in the copy "
"process.  :func:`ignore_patterns` can be used to create such a callable that "
"ignores names based on glob-style patterns."
msgstr ""
"如果給出 *ignore*，它必須是一個可呼叫物件，它將接收 :func:`copytree` 訪問的目"
"錄作為其參數，以及 :func:`os.listdir` 回傳的其內容列表。由於 :func:"
"`copytree` 被遞迴呼叫，*ignore* 可呼叫函式將為每個複制的目錄呼叫一次。可呼叫"
"物件必須回傳相對於當前目錄的一系列目錄和文件名（即第二個參數中項目的子集）；"
"這些名稱將在復製過程中被忽略。 :func:`ignore_patterns` 可用於建立忽略基於 "
"glob 樣式模式的名稱的可呼叫物件。"

#: ../../library/shutil.rst:262
#, fuzzy
msgid ""
"If exception(s) occur, an :exc:`Error` is raised with a list of reasons."
msgstr "如果發生例外，則會引發 :exc:`Error` 並列出原因。"

#: ../../library/shutil.rst:264
#, fuzzy
msgid ""
"If *copy_function* is given, it must be a callable that will be used to copy "
"each file. It will be called with the source path and the destination path "
"as arguments. By default, :func:`~shutil.copy2` is used, but any function "
"that supports the same signature (like :func:`~shutil.copy`) can be used."
msgstr ""
"如果給出了 *copy_function*，它必須是一個可呼叫的，用於復制每個文件。它將以源"
"路徑和目標路徑作為參數呼叫。預設情況下，使用 :func:`~shutil.copy2`，但可以使"
"用任何支援相同簽名的函式（如 :func:`~shutil.copy`）。"

#: ../../library/shutil.rst:269
#, fuzzy
msgid ""
"If *dirs_exist_ok* is false (the default) and *dst* already exists, a :exc:"
"`FileExistsError` is raised. If *dirs_exist_ok* is true, the copying "
"operation will continue if it encounters existing directories, and files "
"within the *dst* tree will be overwritten by corresponding files from the "
"*src* tree."
msgstr ""
"如果 *dirs_exist_ok* 為 false（預設值）並且 *dst* 已經存在，則會引發 :exc:"
"`FileExistsError`。如果 *dirs_exist_ok* 為真，則復制操作將在遇到現有目錄時繼"
"續，並且 *dst* 樹中的文件將被 *src* 樹中的相應文件覆蓋。"

#: ../../library/shutil.rst:275
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copytree`` with "
"arguments ``src``, ``dst``."
msgstr ""
"引發一個附帶引數 ``src``、``dst`` 的\\ :ref:`稽核事件 <auditing>` ``shutil."
"copytree``。"

#: ../../library/shutil.rst:277
#, fuzzy
msgid "Copy metadata when *symlinks* is false. Now returns *dst*."
msgstr "當 *symlinks* 為 false 時復制元資料。現在回傳 *dst*。"

#: ../../library/shutil.rst:281
#, fuzzy
msgid ""
"Added the *copy_function* argument to be able to provide a custom copy "
"function. Added the *ignore_dangling_symlinks* argument to silence dangling "
"symlinks errors when *symlinks* is false."
msgstr ""
"新增了 *copy_function* 參數以提供自定義復制功能。新增了 "
"*ignore_dangling_symlinks* 參數以在 *symlinks* 為 false 時靜音懸掛符號鏈接錯"
"誤。"

#: ../../library/shutil.rst:292
msgid "The *dirs_exist_ok* parameter."
msgstr "*dirs_exist_ok* 參數。"

#: ../../library/shutil.rst:299
#, fuzzy
msgid ""
"Delete an entire directory tree; *path* must point to a directory (but not a "
"symbolic link to a directory).  If *ignore_errors* is true, errors resulting "
"from failed removals will be ignored; if false or omitted, such errors are "
"handled by calling a handler specified by *onerror* or, if that is omitted, "
"they raise an exception."
msgstr ""
"刪除整個目錄樹； *path* 必須指向目錄（但不是指向目錄的符號鏈接）。如果 "
"*ignore_errors* 為真，刪除失敗導致的錯誤將被忽略；如果為 false 或被省略，則此"
"類錯誤將通過呼叫 *onerror* 指定的處理程式來處理，或者，如果被省略，則會引發例"
"外。"

#: ../../library/shutil.rst:305
#, fuzzy
msgid ""
"This function can support :ref:`paths relative to directory descriptors "
"<dir_fd>`."
msgstr ""
"此函式可以支援 :ref:`paths relative to directory descriptors <dir_fd>`。"

#: ../../library/shutil.rst:310
#, fuzzy
msgid ""
"On platforms that support the necessary fd-based functions a symlink attack "
"resistant version of :func:`rmtree` is used by default.  On other platforms, "
"the :func:`rmtree` implementation is susceptible to a symlink attack: given "
"proper timing and circumstances, attackers can manipulate symlinks on the "
"filesystem to delete files they wouldn't be able to access otherwise.  "
"Applications can use the :data:`rmtree.avoids_symlink_attacks` function "
"attribute to determine which case applies."
msgstr ""
"在支援必要的基於 fd 的函式的平台上，預設使用 :func:`rmtree` 的符號鏈接攻擊抵"
"抗版本。在其他平台上，:func:`rmtree` 實作容易受到符號鏈接攻擊：在適當的時間和"
"環境下，攻擊者可以操縱文件系統上的符號鏈接來刪除他們無法訪問的文件。應用程式"
"可以使用 :data:`rmtree.avoids_symlink_attacks` 函式屬性來確定適用哪種情況。"

#: ../../library/shutil.rst:318
#, fuzzy
msgid ""
"If *onerror* is provided, it must be a callable that accepts three "
"parameters: *function*, *path*, and *excinfo*."
msgstr ""
"如果提供了 *onerror*，它必須是一個接受三個參數的可呼叫物件：*function*、"
"*path* 和 *excinfo*。"

#: ../../library/shutil.rst:321
#, fuzzy
msgid ""
"The first parameter, *function*, is the function which raised the exception; "
"it depends on the platform and implementation.  The second parameter, "
"*path*, will be the path name passed to *function*.  The third parameter, "
"*excinfo*, will be the exception information returned by :func:`sys."
"exc_info`.  Exceptions raised by *onerror* will not be caught."
msgstr ""
"第一個參數 *function* 是引發例外的函式；這取決於平台和實作。第二個參數 "
"*path* 將是傳遞給 *function* 的路徑名。第三個參數 *excinfo* 將是 :func:`sys."
"exc_info` 回傳的例外資訊。 *onerror* 引發的例外將不會被捕獲。"

#: ../../library/shutil.rst:327
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.rmtree`` with arguments "
"``path``, ``dir_fd``."
msgstr ""
"引發一個附帶引數 ``path``、``dir_fd`` 的\\ :ref:`稽核事件 <auditing>` "
"``shutil.rmtree``。"

#: ../../library/shutil.rst:329
#, fuzzy
msgid ""
"Added a symlink attack resistant version that is used automatically if "
"platform supports fd-based functions."
msgstr ""
"新增了一個符號鏈接攻擊抵抗版本，如果平台支援基於 fd 的功能，則會自動使用該版"
"本。"

#: ../../library/shutil.rst:333
#, fuzzy
msgid ""
"On Windows, will no longer delete the contents of a directory junction "
"before removing the junction."
msgstr "在 Windows 上，在刪除聯結之前將不再刪除目錄聯結的內容。"

#: ../../library/shutil.rst:337
msgid "The *dir_fd* parameter."
msgstr "*dir_fd* 參數。"

#: ../../library/shutil.rst:342
#, fuzzy
msgid ""
"Indicates whether the current platform and implementation provides a symlink "
"attack resistant version of :func:`rmtree`.  Currently this is only true for "
"platforms supporting fd-based directory access functions."
msgstr ""
"指示當前平台和實作是否提供了 :func:`rmtree` 的符號鏈接攻擊抵抗版本。目前，這"
"僅適用於支援基於 fd 的目錄訪問功能的平台。"

#: ../../library/shutil.rst:351
#, fuzzy
msgid ""
"Recursively move a file or directory (*src*) to another location (*dst*) and "
"return the destination."
msgstr "遞迴地將文件或目錄 (*src*) 移動到另一個位置 (*dst*) 並回傳目的地。"

#: ../../library/shutil.rst:354
#, fuzzy
msgid ""
"If the destination is an existing directory, then *src* is moved inside that "
"directory. If the destination already exists but is not a directory, it may "
"be overwritten depending on :func:`os.rename` semantics."
msgstr ""
"如果目標是現有目錄，則 *src* 將移動到該目錄中。如果目的地已經存在但不是目錄，"
"它可能會被覆蓋，具體取決於 os.rename 語義。"

#: ../../library/shutil.rst:358
#, fuzzy
msgid ""
"If the destination is on the current filesystem, then :func:`os.rename` is "
"used. Otherwise, *src* is copied to *dst* using *copy_function* and then "
"removed.  In case of symlinks, a new symlink pointing to the target of *src* "
"will be created in or as *dst* and *src* will be removed."
msgstr ""
"如果目的地在當前文件系統上，則使用 :func:`os.rename`。否則，使用 "
"*copy_function* 將 *src* 複製到 *dst*，然後刪除。在符號鏈接的情況下，指向 "
"*src* 目標的新符號鏈接將在 *dst* 中或作為 *dst* 建立，*src* 將被刪除。"

#: ../../library/shutil.rst:363
#, fuzzy
msgid ""
"If *copy_function* is given, it must be a callable that takes two arguments "
"*src* and *dst*, and will be used to copy *src* to *dst* if :func:`os."
"rename` cannot be used.  If the source is a directory, :func:`copytree` is "
"called, passing it the :func:`copy_function`. The default *copy_function* "
"is :func:`copy2`.  Using :func:`~shutil.copy` as the *copy_function* allows "
"the move to succeed when it is not possible to also copy the metadata, at "
"the expense of not copying any of the metadata."
msgstr ""
"如果給出了 *copy_function*，它必須是一個帶有兩個參數 *src* 和 *dst* 的可呼叫"
"物件，並且如果不能使用 :func:`os.rename` 將用於將 *src* 複製到 *dst*。如果源"
"是目錄，則呼叫 :func:`copytree`，將 :func:`copy_function` 傳遞給它。預設的 "
"*copy_function* 是 :func:`copy2`。使用 :func:`~shutil.copy` 作為 "
"*copy_function* 允許移動在不可能同時復制元資料時成功，但代價是不復制任何元資"
"料。"

#: ../../library/shutil.rst:371
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.move`` with arguments "
"``src``, ``dst``."
msgstr ""
"引發一個附帶引數 ``src``、``dst`` 的\\ :ref:`稽核事件 <auditing>` ``shutil."
"move``。"

#: ../../library/shutil.rst:373
#, fuzzy
msgid ""
"Added explicit symlink handling for foreign filesystems, thus adapting it to "
"the behavior of GNU's :program:`mv`. Now returns *dst*."
msgstr ""
"為外部文件系統新增了顯式符號鏈接處理，從而使其適應 GNU :program:`mv` 的行為。"
"現在回傳 *dst*。"

#: ../../library/shutil.rst:378
msgid "Added the *copy_function* keyword argument."
msgstr "新增 *copy_function* 關鍵字引數。"

#: ../../library/shutil.rst:386
#, fuzzy
msgid "Accepts a :term:`path-like object` for both *src* and *dst*."
msgstr "接受 *src* 和 *dst* 的 :term:`path-like object`。"

#: ../../library/shutil.rst:391
#, fuzzy
msgid ""
"Return disk usage statistics about the given path as a :term:`named tuple` "
"with the attributes *total*, *used* and *free*, which are the amount of "
"total, used and free space, in bytes. *path* may be a file or a directory."
msgstr ""
"回傳關於給定路徑的磁盤使用統計資訊作為一個命名元組，具有屬性 *total*、*used* "
"和 *free*，它們是總空間量、已用空間量和可用空間量，以位元組為單位。 *path* 可"
"以是文件或目錄。"

#: ../../library/shutil.rst:398
msgid "On Windows, *path* can now be a file or directory."
msgstr "在 Windows 上，*path* 現在可以是檔案或目錄。"

#: ../../library/shutil.rst:401
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`適用 <availability>`：Unix、Windows。"

#: ../../library/shutil.rst:405
#, fuzzy
msgid "Change owner *user* and/or *group* of the given *path*."
msgstr "更改給定 *path* 的所有者 *user* 和/或 *group*。"

#: ../../library/shutil.rst:407
#, fuzzy
msgid ""
"*user* can be a system user name or a uid; the same applies to *group*. At "
"least one argument is required."
msgstr "*user* 可以是系統使用者名或uid；這同樣適用於*組*。至少需要一個參數。"

#: ../../library/shutil.rst:410
#, fuzzy
msgid "See also :func:`os.chown`, the underlying function."
msgstr "另見 :func:`os.chown`，底層函式。"

#: ../../library/shutil.rst:412
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.chown`` with arguments "
"``path``, ``user``, ``group``."
msgstr ""
"引發一個附帶引數 ``path``、``user``、``group`` 的\\ :ref:`稽核事件 "
"<auditing>` ``shutil.chown``。"

#: ../../library/shutil.rst:414
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`適用 <availability>`：Unix。"

#: ../../library/shutil.rst:421
#, fuzzy
msgid ""
"Return the path to an executable which would be run if the given *cmd* was "
"called.  If no *cmd* would be called, return ``None``."
msgstr ""
"回傳可執行文件的路徑，如果給定的 *cmd* 被呼叫，該可執行文件將運行。如果沒有 "
"*cmd* 會被呼叫，回傳``None``。"

#: ../../library/shutil.rst:424
#, fuzzy
msgid ""
"*mode* is a permission mask passed to :func:`os.access`, by default "
"determining if the file exists and executable."
msgstr ""
"*mode* 是傳遞給 :func:`os.access` 的權限掩碼，預設情況下確定文件是否存在且可"
"執行。"

#: ../../library/shutil.rst:427
#, fuzzy
msgid ""
"When no *path* is specified, the results of :func:`os.environ` are used, "
"returning either the \"PATH\" value or a fallback of :attr:`os.defpath`."
msgstr ""
"當未指定 *path* 時，將使用 os.environ 的結果，回傳 ``PATH``值或 os.defpath 的"
"回退。"

#: ../../library/shutil.rst:430
#, fuzzy
msgid ""
"On Windows, the current directory is always prepended to the *path* whether "
"or not you use the default or provide your own, which is the behavior the "
"command shell uses when finding executables.  Additionally, when finding the "
"*cmd* in the *path*, the ``PATHEXT`` environment variable is checked.  For "
"example, if you call ``shutil.which(\"python\")``, :func:`which` will search "
"``PATHEXT`` to know that it should look for ``python.exe`` within the *path* "
"directories.  For example, on Windows::"
msgstr ""
"在 Windows 上，無論您是使用預設目錄還是提供您自己的目錄，當前目錄總是新增到 "
"*path* 之前，這是命令 shell 在查找可執行文件時使用的行為。此外，當在 *path* "
"中找到 *cmd* 時，會檢查 ``PATHEXT`` 環境變數。例如，如果您呼叫 ``shutil."
"which(\"python\")``，:func:`which` 將搜索 ``PATHEXT`` 以了解它應該在 *path 中"
"查找 ``python.exe`` *目錄。例如，在 Windows 上："

#: ../../library/shutil.rst:443
#, fuzzy
msgid ""
"The :class:`bytes` type is now accepted.  If *cmd* type is :class:`bytes`, "
"the result type is also :class:`bytes`."
msgstr ""
":class:`bytes` 型別現在被接受。如果 *cmd* 型別是 :class:`bytes`，則結果型別也"
"是 :class:`bytes`。"

#: ../../library/shutil.rst:449
#, fuzzy
msgid ""
"This exception collects exceptions that are raised during a multi-file "
"operation. For :func:`copytree`, the exception argument is a list of 3-"
"tuples (*srcname*, *dstname*, *exception*)."
msgstr ""
"此例外收集在多文件操作期間引發的例外。對於 :func:`copytree`，例外參數是一個三"
"元組列表（*srcname*、*dstname*、*exception*）。"

#: ../../library/shutil.rst:456
#, fuzzy
msgid "Platform-dependent efficient copy operations"
msgstr "依賴於平台的高效複製操作"

#: ../../library/shutil.rst:458
#, fuzzy
msgid ""
"Starting from Python 3.8, all functions involving a file copy (:func:"
"`copyfile`, :func:`~shutil.copy`, :func:`copy2`, :func:`copytree`, and :func:"
"`move`) may use platform-specific \"fast-copy\" syscalls in order to copy "
"the file more efficiently (see :issue:`33671`). \"fast-copy\" means that the "
"copying operation occurs within the kernel, avoiding the use of userspace "
"buffers in Python as in \"``outfd.write(infd.read())``\"."
msgstr ""
"從 Python 3.8 開始，所有涉及文件複製的函式（:func:`copyfile`、:func:`~shutil."
"copy`、:func:`copy2`、:func:`copytree` 和 :func:`move` ) 可以使用特定於平台"
"的“快速復制”系統呼叫，以便更有效地複製文件（請參閱 :issue:`33671`）。 “快速復"
"制”意味著複製操作發生在內核中，避免在 Python 中使用使用者空間緩衝區，"
"如“``outfd.write(infd.read())``”。"

#: ../../library/shutil.rst:466
#, fuzzy
msgid "On macOS `fcopyfile`_ is used to copy the file content (not metadata)."
msgstr "在 macOS 上，`fcopyfile`_ 用於復製文件內容（不是元資料）。"

#: ../../library/shutil.rst:468
msgid "On Linux :func:`os.sendfile` is used."
msgstr "在 Linux 上是使用 :func:`os.sendfile`。"

#: ../../library/shutil.rst:470
#, fuzzy
msgid ""
"On Windows :func:`shutil.copyfile` uses a bigger default buffer size (1 MiB "
"instead of 64 KiB) and a :func:`memoryview`-based variant of :func:`shutil."
"copyfileobj` is used."
msgstr ""
"在 Windows 上 :func:`shutil.copyfile` 使用更大的預設緩衝區大小（1 MiB 而不是 "
"64 KiB），並使用基於 :func:`memoryview` 的 :func:`shutil.copyfileobj` 變體。"

#: ../../library/shutil.rst:474
#, fuzzy
msgid ""
"If the fast-copy operation fails and no data was written in the destination "
"file then shutil will silently fallback on using less efficient :func:"
"`copyfileobj` function internally."
msgstr ""
"如果快速復制操作失敗並且沒有資料寫入目標文件，則 shutil 將在內部默默地使用效"
"率較低的 :func:`copyfileobj` 函式。"

#: ../../library/shutil.rst:483
#, fuzzy
msgid "copytree example"
msgstr "複製樹示例"

#: ../../library/shutil.rst:485
#, fuzzy
msgid "An example that uses the :func:`ignore_patterns` helper::"
msgstr "使用 :func:`ignore_patterns` 幫助程式的示例::"

#: ../../library/shutil.rst:491
#, fuzzy
msgid ""
"This will copy everything except ``.pyc`` files and files or directories "
"whose name starts with ``tmp``."
msgstr ""
"這將復制除 ``.pyc`` 文件和名稱以 ``tmp`` 開頭的文件或目錄之外的所有內容。"

#: ../../library/shutil.rst:494
#, fuzzy
msgid "Another example that uses the *ignore* argument to add a logging call::"
msgstr "另一個使用 *ignore* 參數新增日誌記錄呼叫的示例："

#: ../../library/shutil.rst:509
msgid "rmtree example"
msgstr "rmtree 範例"

#: ../../library/shutil.rst:511
#, fuzzy
msgid ""
"This example shows how to remove a directory tree on Windows where some of "
"the files have their read-only bit set. It uses the onerror callback to "
"clear the readonly bit and reattempt the remove. Any subsequent failure will "
"propagate. ::"
msgstr ""
"此示例說明如何刪除 Windows 上的目錄樹，其中某些文件設定了只讀位。它使用 "
"onerror 回呼來清除只讀位並重新嘗試刪除。任何後續故障都會傳播。 ::"

#: ../../library/shutil.rst:529
#, fuzzy
msgid "Archiving operations"
msgstr "歸檔操作"

#: ../../library/shutil.rst:533
msgid "Added support for the *xztar* format."
msgstr "新增 *xztar* 格式的支援。"

#: ../../library/shutil.rst:537
#, fuzzy
msgid ""
"High-level utilities to create and read compressed and archived files are "
"also provided.  They rely on the :mod:`zipfile` and :mod:`tarfile` modules."
msgstr ""
"還提供了用於建立和讀取壓縮和存檔文件的高階實用程式。它們依賴於 :mod:"
"`zipfile` 和 :mod:`tarfile` 模組。"

#: ../../library/shutil.rst:542
#, fuzzy
msgid "Create an archive file (such as zip or tar) and return its name."
msgstr "建立一個存檔文件（例如 zip 或 tar）並回傳其名稱。"

#: ../../library/shutil.rst:544
#, fuzzy
msgid ""
"*base_name* is the name of the file to create, including the path, minus any "
"format-specific extension. *format* is the archive format: one of "
"\"zip\" (if the :mod:`zlib` module is available), \"tar\", \"gztar\" (if "
"the :mod:`zlib` module is available), \"bztar\" (if the :mod:`bz2` module is "
"available), or \"xztar\" (if the :mod:`lzma` module is available)."
msgstr ""
"*base_name* 是要建立的文件的名稱，包括路徑，減去任何格式特定的擴充名。 "
"*format* 是存檔格式： ``zip``（如果 :mod:`zlib` 模組可用）、 ``tar``、 "
"``gztar``（如果 :mod:`zlib` 模組可用）、 ``bztar``之一\"（如果 :mod:`bz2` 模"
"組可用），或 \"xztar\"（如果 :mod:`lzma` 模組可用）。"

#: ../../library/shutil.rst:550
#, fuzzy
msgid ""
"*root_dir* is a directory that will be the root directory of the archive, "
"all paths in the archive will be relative to it; for example, we typically "
"chdir into *root_dir* before creating the archive."
msgstr ""
"*root_dir* 是一個目錄，它將成為存檔的根目錄，存檔中的所有路徑都將相對於它；例"
"如，我們通常在建立存檔之前將 chdir 放入 *root_dir*。"

#: ../../library/shutil.rst:554
#, fuzzy
msgid ""
"*base_dir* is the directory where we start archiving from; i.e. *base_dir* "
"will be the common prefix of all files and directories in the archive.  "
"*base_dir* must be given relative to *root_dir*.  See :ref:`shutil-archiving-"
"example-with-basedir` for how to use *base_dir* and *root_dir* together."
msgstr ""
"*base_dir* 是我們開始歸檔的目錄；即 *base_dir* 將是存檔中所有文件和目錄的公開"
"前綴。 *base_dir* 必須相對於 *root_dir* 給出。有關如何一起使用 *base_dir* 和 "
"*root_dir* 的資訊，請參閱 :ref:`shutil-archiving-example-with-basedir`。"

#: ../../library/shutil.rst:560
#, fuzzy
msgid "*root_dir* and *base_dir* both default to the current directory."
msgstr "*root_dir* 和 *base_dir* 都預設為當前目錄。"

#: ../../library/shutil.rst:562
#, fuzzy
msgid ""
"If *dry_run* is true, no archive is created, but the operations that would "
"be executed are logged to *logger*."
msgstr "如果 *dry_run* 為真，則不會建立存檔，但將執行的操作會記錄到 *logger*。"

#: ../../library/shutil.rst:565
#, fuzzy
msgid ""
"*owner* and *group* are used when creating a tar archive. By default, uses "
"the current owner and group."
msgstr ""
"*owner* 和 *group* 在建立 tar 存檔時使用。預設情況下，使用當前所有者和組。"

#: ../../library/shutil.rst:568
#, fuzzy
msgid ""
"*logger* must be an object compatible with :pep:`282`, usually an instance "
"of :class:`logging.Logger`."
msgstr ""
"*logger* 必須是與 :pep:`282` 相容的物件，通常是 :class:`logging.Logger` 的實"
"例。"

#: ../../library/shutil.rst:571
msgid "The *verbose* argument is unused and deprecated."
msgstr "*verbose* 引數未使用且已被棄用。"

#: ../../library/shutil.rst:573
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.make_archive`` with "
"arguments ``base_name``, ``format``, ``root_dir``, ``base_dir``."
msgstr ""
"引發一個附帶引數 ``base_name``、``format``、``root_dir``、``base_dir`` 的\\ :"
"ref:`稽核事件 <auditing>` ``shutil.make_archive``。"

#: ../../library/shutil.rst:577
#, fuzzy
msgid ""
"This function is not thread-safe when custom archivers registered with :func:"
"`register_archive_format` are used.  In this case it temporarily changes the "
"current working directory of the process to perform archiving."
msgstr ""
"當使用通過 :func:`register_archive_format` 註冊的自定義歸檔程式時，此函式不是"
"執行緒安全的。在這種情況下，它會暫時更改行程的當前工作目錄以執行歸檔。"

#: ../../library/shutil.rst:582
#, fuzzy
msgid ""
"The modern pax (POSIX.1-2001) format is now used instead of the legacy GNU "
"format for archives created with ``format=\"tar\"``."
msgstr ""
"現在使用現代 pax (POSIX.1-2001) 格式代替傳統的 GNU 格式，用於使用 "
"``format=\"tar\"`` 建立的檔案。"

#: ../../library/shutil.rst:586
#, fuzzy
msgid ""
"This function is now made thread-safe during creation of standard ``.zip`` "
"and tar archives."
msgstr "在建立標準 .zip 和 tar 存檔期間，此函式現在是執行緒安全的。"

#: ../../library/shutil.rst:592
#, fuzzy
msgid ""
"Return a list of supported formats for archiving. Each element of the "
"returned sequence is a tuple ``(name, description)``."
msgstr ""
"回傳支援的歸檔格式列表。回傳序列的每個元素都是一個元組``（名稱，描述）``。"

#: ../../library/shutil.rst:595 ../../library/shutil.rst:683
msgid "By default :mod:`shutil` provides these formats:"
msgstr "預設情況下 :mod:`shutil` 提供這些格式："

#: ../../library/shutil.rst:597
msgid "*zip*: ZIP file (if the :mod:`zlib` module is available)."
msgstr "*zip*：ZIP 檔案（如果 :mod:`zlib` 模組可用）。"

#: ../../library/shutil.rst:598
#, fuzzy
msgid ""
"*tar*: Uncompressed tar file. Uses POSIX.1-2001 pax format for new archives."
msgstr "*tar*：未壓縮的 tar 文件。對新檔案使用 POSIX.1-2001 pax 格式。"

#: ../../library/shutil.rst:599 ../../library/shutil.rst:688
msgid "*gztar*: gzip'ed tar-file (if the :mod:`zlib` module is available)."
msgstr "*gztar*：gzip 壓縮的 tar 檔案（如果 :mod:`zlib` 模組可用）。"

#: ../../library/shutil.rst:600 ../../library/shutil.rst:689
msgid "*bztar*: bzip2'ed tar-file (if the :mod:`bz2` module is available)."
msgstr "*bztar*：bzip2 壓縮的 tar 檔案（如果 :mod:`bz2` 模組可用）。"

#: ../../library/shutil.rst:601 ../../library/shutil.rst:690
msgid "*xztar*: xz'ed tar-file (if the :mod:`lzma` module is available)."
msgstr "*xztar*：xz 壓縮的 tar 檔案（如果 :mod:`lzma` 模組可用）。"

#: ../../library/shutil.rst:603
#, fuzzy
msgid ""
"You can register new formats or provide your own archiver for any existing "
"formats, by using :func:`register_archive_format`."
msgstr ""
"您可以使用 register_archive_format 註冊新格式或為任何現有格式提供自己的存檔"
"器。"

#: ../../library/shutil.rst:609
#, fuzzy
msgid "Register an archiver for the format *name*."
msgstr "為 *name* 格式註冊一個存檔器。"

#: ../../library/shutil.rst:611
#, fuzzy
msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive the *base_name* of the file to create, followed by the "
"*base_dir* (which defaults to :data:`os.curdir`) to start archiving from. "
"Further arguments are passed as keyword arguments: *owner*, *group*, "
"*dry_run* and *logger* (as passed in :func:`make_archive`)."
msgstr ""
"*function* 是將用於解壓檔案的可呼叫函式。可呼叫物件將收到要建立的文件的 "
"*base_name*，然後是 *base_dir*（預設為 :data:`os.curdir`）以開始歸檔。進一步"
"的參數作為關鍵字參數傳遞：*owner*、*group*、*dry_run* 和 *logger*（在 :func:"
"`make_archive` 中傳遞）。"

#: ../../library/shutil.rst:617
#, fuzzy
msgid ""
"If given, *extra_args* is a sequence of ``(name, value)`` pairs that will be "
"used as extra keywords arguments when the archiver callable is used."
msgstr ""
"如果給定，*extra_args* 是一系列``(name, value)`` 對，當使用 archiver 可呼叫"
"時，它們將用作額外的關鍵字參數。"

#: ../../library/shutil.rst:620
#, fuzzy
msgid ""
"*description* is used by :func:`get_archive_formats` which returns the list "
"of archivers.  Defaults to an empty string."
msgstr ""
"*description* 由 :func:`get_archive_formats` 使用，它回傳歸檔器列表。預設為空"
"字串。"

#: ../../library/shutil.rst:626
#, fuzzy
msgid "Remove the archive format *name* from the list of supported formats."
msgstr "從支援的格式列表中刪除歸檔格式 *name*。"

#: ../../library/shutil.rst:631
#, fuzzy
msgid "Unpack an archive. *filename* is the full path of the archive."
msgstr "解壓縮存檔。 *filename* 是存檔的完整路徑。"

#: ../../library/shutil.rst:633
#, fuzzy
msgid ""
"*extract_dir* is the name of the target directory where the archive is "
"unpacked. If not provided, the current working directory is used."
msgstr ""
"*extract_dir* 是解壓存檔的目標目錄的名稱。如果未提供，則使用當前工作目錄。"

#: ../../library/shutil.rst:636
#, fuzzy
msgid ""
"*format* is the archive format: one of \"zip\", \"tar\", \"gztar\", "
"\"bztar\", or \"xztar\".  Or any other format registered with :func:"
"`register_unpack_format`.  If not provided, :func:`unpack_archive` will use "
"the archive file name extension and see if an unpacker was registered for "
"that extension.  In case none is found, a :exc:`ValueError` is raised."
msgstr ""
"*format* 是存檔格式： ``zip``、 ``tar``、 ``gztar``、 ``bztar``或 ``xztar``之"
"一。或使用 :func:`register_unpack_format` 註冊的任何其他格式。如果未提供，:"
"func:`unpack_archive` 將使用存檔文件擴充名並查看是否為該擴充名註冊了解包程"
"式。如果沒有找到，則會引發 :exc:`ValueError`。"

#: ../../library/shutil.rst:643
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.unpack_archive`` with "
"arguments ``filename``, ``extract_dir``, ``format``."
msgstr ""
"引發一個附帶引數 ``filename``、``extract_dir``、``format`` 的\\ :ref:`稽核事"
"件 <auditing>` ``shutil.unpack_archive``。"

#: ../../library/shutil.rst:647
#, fuzzy
msgid ""
"Never extract archives from untrusted sources without prior inspection. It "
"is possible that files are created outside of the path specified in the "
"*extract_dir* argument, e.g. members that have absolute filenames starting "
"with \"/\" or filenames with two dots \"..\"."
msgstr ""
"未經事先檢查，切勿從不受信任的來源提取檔案。文件可能是在 *extract_dir* 參數中"
"指定的路徑之外建立的，例如絕對文件名以 ``/``開頭或文件名以兩個點“..”開頭的成"
"員。"

#: ../../library/shutil.rst:652
#, fuzzy
msgid "Accepts a :term:`path-like object` for *filename* and *extract_dir*."
msgstr "接受 *filename* 和 *extract_dir* 的 :term:`path-like object`。"

#: ../../library/shutil.rst:657
#, fuzzy
msgid ""
"Registers an unpack format. *name* is the name of the format and "
"*extensions* is a list of extensions corresponding to the format, like ``."
"zip`` for Zip files."
msgstr ""
"註冊一個解包格式。 *name* 是格式的名稱，*extensions* 是與格式對應的擴充名列"
"表，例如 Zip 文件的 ``.zip``。"

#: ../../library/shutil.rst:661
#, fuzzy
msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive the path of the archive, followed by the directory the "
"archive must be extracted to."
msgstr ""
"*function* 是將用於解壓檔案的可呼叫函式。可呼叫文件將接收存檔的路徑，然後是存"
"檔必須提取到的目錄。"

#: ../../library/shutil.rst:665
#, fuzzy
msgid ""
"When provided, *extra_args* is a sequence of ``(name, value)`` tuples that "
"will be passed as keywords arguments to the callable."
msgstr ""
"提供時，*extra_args* 是一系列“(name, value)”元組，將作為關鍵字參數傳遞給可呼"
"叫物件。"

#: ../../library/shutil.rst:668
#, fuzzy
msgid ""
"*description* can be provided to describe the format, and will be returned "
"by the :func:`get_unpack_formats` function."
msgstr ""
"可以提供 *description* 來描述格式，並將由 :func:`get_unpack_formats` 函式回"
"傳。"

#: ../../library/shutil.rst:674
#, fuzzy
msgid "Unregister an unpack format. *name* is the name of the format."
msgstr "註銷解壓格式。 *name* 是格式的名稱。"

#: ../../library/shutil.rst:679
#, fuzzy
msgid ""
"Return a list of all registered formats for unpacking. Each element of the "
"returned sequence is a tuple ``(name, extensions, description)``."
msgstr ""
"回傳所有已註冊格式的列表以進行解包。回傳序列的每個元素都是一個元組 ``(name, "
"extensions, description)``。"

#: ../../library/shutil.rst:685
#, fuzzy
msgid ""
"*zip*: ZIP file (unpacking compressed files works only if the corresponding "
"module is available)."
msgstr "*zip*：ZIP 文件（解壓縮壓縮文件只有在相應的模組可用時才有效）。"

#: ../../library/shutil.rst:687
#, fuzzy
msgid "*tar*: uncompressed tar file."
msgstr "*tar*：未壓縮的 tar 文件。"

#: ../../library/shutil.rst:692
#, fuzzy
msgid ""
"You can register new formats or provide your own unpacker for any existing "
"formats, by using :func:`register_unpack_format`."
msgstr ""
"您可以使用註冊新格式或為任何現有格式提供自己的解包器 :func:"
"`register_unpack_format`。"

#: ../../library/shutil.rst:699
#, fuzzy
msgid "Archiving example"
msgstr "歸檔示例"

#: ../../library/shutil.rst:701
#, fuzzy
msgid ""
"In this example, we create a gzip'ed tar-file archive containing all files "
"found in the :file:`.ssh` directory of the user::"
msgstr ""
"在此示例中，我們建立了一個 gzip 壓縮的 tar 文件存檔，其中包含在使用者的 :"
"file:`.ssh` 目錄中找到的所有文件："

#: ../../library/shutil.rst:711
#, fuzzy
msgid "The resulting archive contains:"
msgstr "生成的存檔包含："

#: ../../library/shutil.rst:729
#, fuzzy
msgid "Archiving example with *base_dir*"
msgstr "使用 *base_dir* 的歸檔示例"

#: ../../library/shutil.rst:731
#, fuzzy
msgid ""
"In this example, similar to the `one above <shutil-archiving-example_>`_, we "
"show how to use :func:`make_archive`, but this time with the usage of "
"*base_dir*.  We now have the following directory structure:"
msgstr ""
"在這個例子中，類似於上面的<shutil-archiving-example_>`_，我們展示瞭如何使用:"
"func:`make_archive`，但這次使用了*base_dir*。我們現在有以下目錄結構："

#: ../../library/shutil.rst:745
#, fuzzy
msgid ""
"In the final archive, :file:`please_add.txt` should be included, but :file:"
"`do_not_add.txt` should not.  Therefore we use the following::"
msgstr ""
"在最終存檔中，應包含 :file:`please_add.txt`，但不應包含 :file:`do_not_add."
"txt`。因此我們使用以下::"

#: ../../library/shutil.rst:759
#, fuzzy
msgid "Listing the files in the resulting archive gives us:"
msgstr "列出結果存檔中的文件給我們："

#: ../../library/shutil.rst:769
#, fuzzy
msgid "Querying the size of the output terminal"
msgstr "查詢輸出端的大小"

#: ../../library/shutil.rst:773
#, fuzzy
msgid "Get the size of the terminal window."
msgstr "獲取終端窗口的大小。"

#: ../../library/shutil.rst:775
#, fuzzy
msgid ""
"For each of the two dimensions, the environment variable, ``COLUMNS`` and "
"``LINES`` respectively, is checked. If the variable is defined and the value "
"is a positive integer, it is used."
msgstr ""
"對於兩個維度中的每一個，分別檢查環境變數 ``COLUMNS`` 和 ``LINES``。如果定義了"
"變數並且值為正整數，則使用它。"

#: ../../library/shutil.rst:779
#, fuzzy
msgid ""
"When ``COLUMNS`` or ``LINES`` is not defined, which is the common case, the "
"terminal connected to :data:`sys.__stdout__` is queried by invoking :func:"
"`os.get_terminal_size`."
msgstr ""
"當 ``COLUMNS`` 或 ``LINES`` 未定義時（這是常見情況），連接到 :data:`sys."
"__stdout__` 的終端通過呼叫 :func:`os.get_terminal_size` 進行查詢。"

#: ../../library/shutil.rst:783
#, fuzzy
msgid ""
"If the terminal size cannot be successfully queried, either because the "
"system doesn't support querying, or because we are not connected to a "
"terminal, the value given in ``fallback`` parameter is used. ``fallback`` "
"defaults to ``(80, 24)`` which is the default size used by many terminal "
"emulators."
msgstr ""
"如果無法成功查詢終端大小，要么是因為系統不支援查詢，要么是因為我們沒有連接到"
"終端，則使用 fallback 參數中給出的值。 ``fallback`` 預設為 ``(80, 24)``，這是"
"許多終端仿真器使用的預設大小。"

#: ../../library/shutil.rst:789
#, fuzzy
msgid "The value returned is a named tuple of type :class:`os.terminal_size`."
msgstr "回傳的值是 os.terminal_size 型別的命名元組。"

#: ../../library/shutil.rst:791
#, fuzzy
msgid ""
"See also: The Single UNIX Specification, Version 2, `Other Environment "
"Variables`_."
msgstr "另請參閱：單一 UNIX 規範，版本 2，`其他環境變數`_。"

#: ../../library/shutil.rst:796
#, fuzzy
msgid ""
"The ``fallback`` values are also used if :func:`os.get_terminal_size` "
"returns zeroes."
msgstr "如果 os.get_terminal_size 回傳零，也會使用 ``fallback`` 值。"
