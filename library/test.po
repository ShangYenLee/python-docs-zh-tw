# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-03 00:16+0000\n"
"PO-Revision-Date: 2018-05-23 16:12+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../library/test.rst:2
msgid ":mod:`test` --- Regression tests package for Python"
msgstr ":mod:`test` --- Python 回歸測試套件"

#: ../../library/test.rst:10
#, fuzzy
msgid ""
"The :mod:`test` package is meant for internal use by Python only. It is "
"documented for the benefit of the core developers of Python. Any use of this "
"package outside of Python's standard library is discouraged as code "
"mentioned here can change or be removed without notice between releases of "
"Python."
msgstr ""
":mod:`test` 包僅供 Python 內部使用。它被記錄下來是為了 Python 的核心開發人員"
"的利益。不鼓勵在 Python 標準庫之外使用此包，因為此處提到的程式碼可能會更改或"
"刪除，恕不另行通知。"

#: ../../library/test.rst:18
#, fuzzy
msgid ""
"The :mod:`test` package contains all regression tests for Python as well as "
"the modules :mod:`test.support` and :mod:`test.regrtest`. :mod:`test."
"support` is used to enhance your tests while :mod:`test.regrtest` drives the "
"testing suite."
msgstr ""
":mod:`test` 包包含 Python 的所有回歸測試以及模組 :mod:`test.support` 和 :mod:"
"`test.regrtest`。 :mod:`test.support` 用於增強您的測試，而 :mod:`test."
"regrtest` 驅動測試套件。"

#: ../../library/test.rst:23
#, fuzzy
msgid ""
"Each module in the :mod:`test` package whose name starts with ``test_`` is a "
"testing suite for a specific module or feature. All new tests should be "
"written using the :mod:`unittest` or :mod:`doctest` module.  Some older "
"tests are written using a \"traditional\" testing style that compares output "
"printed to ``sys.stdout``; this style of test is considered deprecated."
msgstr ""
":mod:`test` 包中名稱以 ``test_`` 開頭的每個模組都是針對特定模組或功能的測試套"
"件。所有新測試都應使用 :mod:`unittest` 或 :mod:`doctest` 模組編寫。一些較舊的"
"測試是使用“傳統”測試風格編寫的，該風格將印出的輸出與“sys.stdout”進行比較；這"
"種測試方式被認為已棄用。"

#: ../../library/test.rst:33
msgid "Module :mod:`unittest`"
msgstr ":mod:`unittest` 模組"

#: ../../library/test.rst:33
msgid "Writing PyUnit regression tests."
msgstr "編寫 PyUnit 回歸測試。"

#: ../../library/test.rst:35
msgid "Module :mod:`doctest`"
msgstr ":mod:`doctest` 模組"

#: ../../library/test.rst:36
#, fuzzy
msgid "Tests embedded in documentation strings."
msgstr "嵌入在文檔字串中的測試。"

#: ../../library/test.rst:42
#, fuzzy
msgid "Writing Unit Tests for the :mod:`test` package"
msgstr "為 :mod:`test` 包編寫單元測試"

#: ../../library/test.rst:44
#, fuzzy
msgid ""
"It is preferred that tests that use the :mod:`unittest` module follow a few "
"guidelines. One is to name the test module by starting it with ``test_`` and "
"end it with the name of the module being tested. The test methods in the "
"test module should start with ``test_`` and end with a description of what "
"the method is testing. This is needed so that the methods are recognized by "
"the test driver as test methods. Also, no documentation string for the "
"method should be included. A comment (such as ``# Tests function returns "
"only True or False``) should be used to provide documentation for test "
"methods. This is done because documentation strings get printed out if they "
"exist and thus what test is being run is not stated."
msgstr ""
"使用 :mod:`unittest` 模組的測試最好遵循一些準則。一種是通過以 ``test_`` 開頭"
"並以被測模組的名稱結尾來命名測試模組。測試模組中的測試方法應該以 ``test_`` 開"
"頭，並以方法測試內容的描述結束。這是必需的，以便測試驅動程式將這些方法識別為"
"測試方法。此外，不應包含該方法的文檔字串。應該使用註釋（例如``# Tests "
"function returns only True or False``）為測試方法提供文檔。這樣做是因為文檔字"
"串如果存在就會被印出出來，因此沒有說明正在運行的測試。"

#: ../../library/test.rst:55
#, fuzzy
msgid "A basic boilerplate is often used::"
msgstr "通常使用基本樣板::"

#: ../../library/test.rst:88
#, fuzzy
msgid ""
"This code pattern allows the testing suite to be run by :mod:`test."
"regrtest`, on its own as a script that supports the :mod:`unittest` CLI, or "
"via the ``python -m unittest`` CLI."
msgstr ""
"此程式碼模式允許測試套件由 :mod:`test.regrtest` 作為支援 :mod:`unittest` CLI "
"的腳本單獨運行，或通過 ``python -m unittest`` CLI 運行。"

#: ../../library/test.rst:92
#, fuzzy
msgid ""
"The goal for regression testing is to try to break code. This leads to a few "
"guidelines to be followed:"
msgstr "回歸測試的目標是嘗試破壞程式碼。這導致了一些需要遵循的指導方針："

#: ../../library/test.rst:95
#, fuzzy
msgid ""
"The testing suite should exercise all classes, functions, and constants. "
"This includes not just the external API that is to be presented to the "
"outside world but also \"private\" code."
msgstr ""
"測試套件應該測試所有的類、函式和常數。這不僅包括要呈現給外界的外部 API，還包"
"括“私有”程式碼。"

#: ../../library/test.rst:99
#, fuzzy
msgid ""
"Whitebox testing (examining the code being tested when the tests are being "
"written) is preferred. Blackbox testing (testing only the published user "
"interface) is not complete enough to make sure all boundary and edge cases "
"are tested."
msgstr ""
"首選白盒測試（在編寫測試時檢查被測試的程式碼）。黑盒測試（僅測試已發布的使用"
"者界面）不夠完整，無法確保測試所有邊界和邊緣情況。"

#: ../../library/test.rst:104
#, fuzzy
msgid ""
"Make sure all possible values are tested including invalid ones. This makes "
"sure that not only all valid values are acceptable but also that improper "
"values are handled correctly."
msgstr ""
"確保測試所有可能的值，包括無效值。這確保不僅所有有效值都是可接受的，而且不正"
"確的值也能得到正確處理。"

#: ../../library/test.rst:108
#, fuzzy
msgid ""
"Exhaust as many code paths as possible. Test where branching occurs and thus "
"tailor input to make sure as many different paths through the code are taken."
msgstr ""
"盡可能多地耗盡程式碼路徑。測試分支發生的位置，從而調整輸入以確保採用盡可能多"
"的程式碼不同路徑。"

#: ../../library/test.rst:111
#, fuzzy
msgid ""
"Add an explicit test for any bugs discovered for the tested code. This will "
"make sure that the error does not crop up again if the code is changed in "
"the future."
msgstr ""
"為為測試程式碼發現的任何錯誤新增顯式測試。如果將來更改程式碼，這將確保錯誤不"
"會再次出現。"

#: ../../library/test.rst:115
#, fuzzy
msgid ""
"Make sure to clean up after your tests (such as close and remove all "
"temporary files)."
msgstr "確保在測試後進行清理（例如關閉並刪除所有臨時文件）。"

#: ../../library/test.rst:118
#, fuzzy
msgid ""
"If a test is dependent on a specific condition of the operating system then "
"verify the condition already exists before attempting the test."
msgstr ""
"如果測試依賴於操作系統的特定條件，則在嘗試測試之前驗證該條件是否已經存在。"

#: ../../library/test.rst:121
#, fuzzy
msgid ""
"Import as few modules as possible and do it as soon as possible. This "
"minimizes external dependencies of tests and also minimizes possible "
"anomalous behavior from side-effects of importing a module."
msgstr ""
"導入盡可能少的模組並儘快完成。這最大限度地減少了測試的外部依賴性，也最大限度"
"地減少了導入模組的副作用可能導致的例外行為。"

#: ../../library/test.rst:125
#, fuzzy
msgid ""
"Try to maximize code reuse. On occasion, tests will vary by something as "
"small as what type of input is used. Minimize code duplication by "
"subclassing a basic test class with a class that specifies the input::"
msgstr ""
"嘗試最大化程式碼重用。有時，測試會因使用的輸入型別而有所不同。通過使用指定輸"
"入的類對基本測試類進行子類別化，最大限度地減少程式碼重複："

#: ../../library/test.rst:145
#, fuzzy
msgid ""
"When using this pattern, remember that all classes that inherit from :class:"
"`unittest.TestCase` are run as tests.  The :class:`Mixin` class in the "
"example above does not have any data and so can't be run by itself, thus it "
"does not inherit from :class:`unittest.TestCase`."
msgstr ""
"使用此模式時，請記住所有繼承自 :class:`unittest.TestCase` 的類都作為測試運"
"行。上例中的 :class:`Mixin` 類沒有任何資料，因此不能單獨運行，因此它沒有繼承"
"自 :class:`unittest.TestCase`。"

#: ../../library/test.rst:153
#, fuzzy
msgid "Test Driven Development"
msgstr "測試驅動開發"

#: ../../library/test.rst:154
#, fuzzy
msgid "A book by Kent Beck on writing tests before code."
msgstr "Kent Beck 寫的一本關於在編寫程式碼之前編寫測試的書。"

#: ../../library/test.rst:160
#, fuzzy
msgid "Running tests using the command-line interface"
msgstr "使用命令列界面運行測試"

#: ../../library/test.rst:162
#, fuzzy
msgid ""
"The :mod:`test` package can be run as a script to drive Python's regression "
"test suite, thanks to the :option:`-m` option: :program:`python -m test`. "
"Under the hood, it uses :mod:`test.regrtest`; the call :program:`python -m "
"test.regrtest` used in previous Python versions still works.  Running the "
"script by itself automatically starts running all regression tests in the :"
"mod:`test` package. It does this by finding all modules in the package whose "
"name starts with ``test_``, importing them, and executing the function :func:"
"`test_main` if present or loading the tests via unittest.TestLoader."
"loadTestsFromModule if ``test_main`` does not exist.  The names of tests to "
"execute may also be passed to the script. Specifying a single regression "
"test (:program:`python -m test test_spam`) will minimize output and only "
"print whether the test passed or failed."
msgstr ""
":mod:`test` 包可以作為腳本運行以驅動 Python 的回歸測試套件，這要歸功於 :"
"option:`-m` 選項：:program:`python -m test`。在引擎蓋下，它使用 :mod:`test."
"regrtest`;以前 Python 版本中使用的呼叫 :program:`python -m test.regrtest` 仍"
"然有效。單獨運行腳本會自動開始運行 :mod:`test` 包中的所有回歸測試。它通過查找"
"包中名稱以 ``test_`` 開頭的所有模組、導入它們並執行函式 :func:`test_main`（如"
"果存在）或通過 unittest.TestLoader.loadTestsFromModule（如果 ``test_main`）加"
"載測試來實作。 ` 不存在。要執行的測試的名稱也可以傳遞給腳本。指定單個回歸測"
"試 (:program:`python -m test test_spam`) 將最小化輸出並且只印出測試是通過還是"
"失敗。"

#: ../../library/test.rst:175
#, fuzzy
msgid ""
"Running :mod:`test` directly allows what resources are available for tests "
"to use to be set. You do this by using the ``-u`` command-line option. "
"Specifying ``all`` as the value for the ``-u`` option enables all possible "
"resources: :program:`python -m test -uall`. If all but one resource is "
"desired (a more common case), a comma-separated list of resources that are "
"not desired may be listed after ``all``. The command :program:`python -m "
"test -uall,-audio,-largefile` will run :mod:`test` with all resources except "
"the ``audio`` and ``largefile`` resources. For a list of all resources and "
"more command-line options, run :program:`python -m test -h`."
msgstr ""
"直接運行 :mod:`test` 允許設定哪些資源可供測試使用。您可以使用 ``-u``命令列選"
"項來執行此操作。指定 ``all`` 作為 ``-u`` 選項的值啟用所有可能的資源：:"
"program:`python -m test -uall`。如果只需要一個資源（一種更常見的情況），則可"
"以在 ``all``之後列出不需要的資源的逗號分隔列表。命令 :program:`python -m "
"test -uall,-audio,-largefile` 將使用除 ``audio`` 和 ``largefile`` 資源之外的"
"所有資源運行 :mod:`test` 。如需所有資源和更多命令列選項的列表，請運行 :"
"program:`python -m test -h`。"

#: ../../library/test.rst:186
#, fuzzy
msgid ""
"Some other ways to execute the regression tests depend on what platform the "
"tests are being executed on. On Unix, you can run :program:`make test` at "
"the top-level directory where Python was built. On Windows, executing :"
"program:`rt.bat` from your :file:`PCbuild` directory will run all regression "
"tests."
msgstr ""
"執行回歸測試的其他一些方法取決於執行測試的平台。在 Unix 上，您可以在構建 "
"Python 的頂級目錄中運行 make test。在 Windows 上，從 :file:`PCbuild` 目錄執"
"行 :program:`rt.bat` 將運行所有回歸測試。"

#: ../../library/test.rst:194
#, fuzzy
msgid ":mod:`test.support` --- Utilities for the Python test suite"
msgstr ":mod:`test.support` --- Python 測試套件的實用程式"

#: ../../library/test.rst:200
#, fuzzy
msgid ""
"The :mod:`test.support` module provides support for Python's regression test "
"suite."
msgstr ":mod:`test.support` 模組提供對 Python 回歸測試套件的支援。"

#: ../../library/test.rst:205
#, fuzzy
msgid ""
":mod:`test.support` is not a public module.  It is documented here to help "
"Python developers write tests.  The API of this module is subject to change "
"without backwards compatibility concerns between releases."
msgstr ""
":mod:`test.support` 不是公開模組。它記錄在此處以幫助 Python 開發人員編寫測"
"試。此模組的 API 可能會發生變化，而不會影響版本之間的向後相容性。"

#: ../../library/test.rst:210
#, fuzzy
msgid "This module defines the following exceptions:"
msgstr "該模組定義了以下例外："

#: ../../library/test.rst:214
#, fuzzy
msgid ""
"Exception to be raised when a test fails. This is deprecated in favor of :"
"mod:`unittest`\\ -based tests and :class:`unittest.TestCase`'s assertion "
"methods."
msgstr ""
"測試失敗時引發例外。這已被棄用，取而代之的是基於 :mod:`unittest`\\ 的測試和 :"
"class:`unittest.TestCase` 的斷言方法。"

#: ../../library/test.rst:221
#, fuzzy
msgid ""
"Subclass of :exc:`unittest.SkipTest`. Raised when a resource (such as a "
"network connection) is not available. Raised by the :func:`requires` "
"function."
msgstr ""
"unittest.SkipTest 的子類別。當資源（例如網絡連接）不可用時引發。由 :func:"
"`requires` 函式引發。"

#: ../../library/test.rst:226
#, fuzzy
msgid "The :mod:`test.support` module defines the following constants:"
msgstr ":mod:`test.support` 模組定義了以下常數："

#: ../../library/test.rst:230
#, fuzzy
msgid ""
"``True`` when verbose output is enabled. Should be checked when more "
"detailed information is desired about a running test. *verbose* is set by :"
"mod:`test.regrtest`."
msgstr ""
"``True`` 啟用詳細輸出時。當需要有關正在運行的測試的更多詳細資訊時，應該檢"
"查。 *verbose* 由 :mod:`test.regrtest` 設定。"

#: ../../library/test.rst:237
#, fuzzy
msgid "``True`` if the running interpreter is Jython."
msgstr "如果正在運行的直譯器是 Jython，則為 True。"

#: ../../library/test.rst:242
#, fuzzy
msgid "``True`` if the system is Android."
msgstr "``True`` 如果系統是 Android。"

#: ../../library/test.rst:247
#, fuzzy
msgid "Path for shell if not on Windows; otherwise ``None``."
msgstr "如果不是在 Windows 上，則為 shell 的路徑；否則``無``。"

#: ../../library/test.rst:252
#, fuzzy
msgid ""
"Timeout in seconds for tests using a network server listening on the network "
"local loopback interface like ``127.0.0.1``."
msgstr ""
"使用網絡伺服器偵聽網絡本地環回介面（如“127.0.0.1”）進行測試的超時秒數。"

#: ../../library/test.rst:255
#, fuzzy
msgid ""
"The timeout is long enough to prevent test failure: it takes into account "
"that the client and the server can run in different threads or even "
"different processes."
msgstr ""
"超時時間足夠長以防止測試失敗：它考慮到客戶端和伺服器可以運行在不同的執行緒甚"
"至不同的行程中。"

#: ../../library/test.rst:259
#, fuzzy
msgid ""
"The timeout should be long enough for :meth:`~socket.socket.connect`, :meth:"
"`~socket.socket.recv` and :meth:`~socket.socket.send` methods of :class:"
"`socket.socket`."
msgstr ""
"超時應該足夠長 :meth:`~socket.socket.connect`, :meth:`~socket.socket.recv` "
"和 :meth:`~socket.socket.send` socket 的方法。 socket `。"

#: ../../library/test.rst:263
msgid "Its default value is 5 seconds."
msgstr "它的預設值為 5 秒。"

#: ../../library/test.rst:265
msgid "See also :data:`INTERNET_TIMEOUT`."
msgstr "另請參閱 :data:`INTERNET_TIMEOUT`\\ 。"

#: ../../library/test.rst:270
#, fuzzy
msgid "Timeout in seconds for network requests going to the internet."
msgstr "網絡請求到 Internet 的超時秒數。"

#: ../../library/test.rst:272
#, fuzzy
msgid ""
"The timeout is short enough to prevent a test to wait for too long if the "
"internet request is blocked for whatever reason."
msgstr "如果網際網路請求因任何原因被阻止，超時時間足夠短，可以防止測試等待太久。"

#: ../../library/test.rst:275
#, fuzzy
msgid ""
"Usually, a timeout using :data:`INTERNET_TIMEOUT` should not mark a test as "
"failed, but skip the test instead: see :func:`~test.support.socket_helper."
"transient_internet`."
msgstr ""
"通常，使用 :data:`INTERNET_TIMEOUT` 的超時不應將測試標記為失敗，而是跳過測"
"試：參見 :func:`~test.support.socket_helper.transient_internet`。"

#: ../../library/test.rst:279
msgid "Its default value is 1 minute."
msgstr "它的預設值為 1 分鐘。"

#: ../../library/test.rst:281
msgid "See also :data:`LOOPBACK_TIMEOUT`."
msgstr "另請參閱 :data:`LOOPBACK_TIMEOUT`\\ 。"

#: ../../library/test.rst:286
#, fuzzy
msgid ""
"Timeout in seconds to mark a test as failed if the test takes \"too long\"."
msgstr "如果測試花費“太長”，超時以秒為單位將測試標記為失敗。"

#: ../../library/test.rst:288
#, fuzzy
msgid ""
"The timeout value depends on the regrtest ``--timeout`` command line option."
msgstr "超時值取決於 regrtest ``--timeout`` 命令列選項。"

#: ../../library/test.rst:290
#, fuzzy
msgid ""
"If a test using :data:`SHORT_TIMEOUT` starts to fail randomly on slow "
"buildbots, use :data:`LONG_TIMEOUT` instead."
msgstr ""
"如果使用 :data:`SHORT_TIMEOUT` 的測試在慢速構建機器人上開始隨機失敗，請改用 :"
"data:`LONG_TIMEOUT`。"

#: ../../library/test.rst:293
#, fuzzy
msgid "Its default value is 30 seconds."
msgstr "它的預設值為 30 秒。"

#: ../../library/test.rst:298
#, fuzzy
msgid "Timeout in seconds to detect when a test hangs."
msgstr "以秒為單位的超時以檢測測試何時掛起。"

#: ../../library/test.rst:300
#, fuzzy
msgid ""
"It is long enough to reduce the risk of test failure on the slowest Python "
"buildbots. It should not be used to mark a test as failed if the test takes "
"\"too long\".  The timeout value depends on the regrtest ``--timeout`` "
"command line option."
msgstr ""
"它足夠長，可以降低在最慢的 Python buildbots 上測試失敗的風險。如果測試花費“太"
"長”，則不應使用它來將測試標記為失敗。超時值取決於 regrtest ``--timeout`` 命令"
"行選項。"

#: ../../library/test.rst:305
msgid "Its default value is 5 minutes."
msgstr "它的預設值為 5 分鐘。"

#: ../../library/test.rst:307
#, fuzzy
msgid ""
"See also :data:`LOOPBACK_TIMEOUT`, :data:`INTERNET_TIMEOUT` and :data:"
"`SHORT_TIMEOUT`."
msgstr ""
"另見 :data:`LOOPBACK_TIMEOUT`、 :data:`INTERNET_TIMEOUT` 和 :data:"
"`SHORT_TIMEOUT`。"

#: ../../library/test.rst:313
#, fuzzy
msgid "Set when tests can be skipped when they are not useful for PGO."
msgstr "設定何時可以跳過對 PGO 無用的測試。"

#: ../../library/test.rst:318
#, fuzzy
msgid ""
"A constant that is likely larger than the underlying OS pipe buffer size, to "
"make writes blocking."
msgstr "一個可能大於底層操作系統管道緩衝區大小的常數，用於阻止寫入。"

#: ../../library/test.rst:324
#, fuzzy
msgid ""
"A constant that is likely larger than the underlying OS socket buffer size, "
"to make writes blocking."
msgstr "一個可能大於底層操作系統 socket 緩衝區大小的常數，用於阻止寫入。"

#: ../../library/test.rst:330
#, fuzzy
msgid "Set to the top level directory that contains :mod:`test.support`."
msgstr "設定為包含 :mod:`test.support` 的頂級目錄。"

#: ../../library/test.rst:335
#, fuzzy
msgid "Set to the top level directory for the test package."
msgstr "設定為測試套件的頂級目錄。"

#: ../../library/test.rst:340
msgid "Set to the ``data`` directory within the test package."
msgstr "設定為測試套件中的 ``data`` 目錄。"

#: ../../library/test.rst:345
#, fuzzy
msgid "Set to :data:`sys.maxsize` for big memory tests."
msgstr "設定為 :data:`sys.maxsize` 用於大記憶體測試。"

#: ../../library/test.rst:350
#, fuzzy
msgid ""
"Set by :func:`set_memlimit` as the memory limit for big memory tests. "
"Limited by :data:`MAX_Py_ssize_t`."
msgstr ""
"由 :func:`set_memlimit` 設定為大記憶體測試的記憶體限制。受 :data:"
"`MAX_Py_ssize_t` 限制。"

#: ../../library/test.rst:356
#, fuzzy
msgid ""
"Set by :func:`set_memlimit` as the memory limit for big memory tests.  Not "
"limited by :data:`MAX_Py_ssize_t`."
msgstr ""
"由 :func:`set_memlimit` 設定為大記憶體測試的記憶體限制。不受 :data:"
"`MAX_Py_ssize_t` 的限制。"

#: ../../library/test.rst:362
#, fuzzy
msgid ""
"Set to ``True`` if Python is built without docstrings (the :c:macro:"
"`WITH_DOC_STRINGS` macro is not defined). See the :option:`configure --"
"without-doc-strings <--without-doc-strings>` option."
msgstr ""
"如果 Python 是在沒有文檔字串的情況下構建的，則設定為 ``True``（未定義 :c:"
"macro:`WITH_DOC_STRINGS` 巨集）。請參閱 :option:`configure --without-doc-"
"strings <--without-doc-strings>` 選項。"

#: ../../library/test.rst:366
#, fuzzy
msgid "See also the :data:`HAVE_DOCSTRINGS` variable."
msgstr "另見 :data:`HAVE_DOCSTRINGS` 變數。"

#: ../../library/test.rst:371
#, fuzzy
msgid ""
"Set to ``True`` if function docstrings are available. See the :option:"
"`python -OO <-O>` option, which strips docstrings of functions implemented "
"in Python."
msgstr ""
"如果函式文檔字串可用，則設定為 ``True``。請參閱 :option:`python -OO <-O>` 選"
"項，它去除了在 Python 中實作的函式的文檔字串。"

#: ../../library/test.rst:374
#, fuzzy
msgid "See also the :data:`MISSING_C_DOCSTRINGS` variable."
msgstr "另見 :data:`MISSING_C_DOCSTRINGS` 變數。"

#: ../../library/test.rst:379
#, fuzzy
msgid "Define the URL of a dedicated HTTP server for the network tests."
msgstr "為網絡測試定義專用 HTTP 伺服器的 URL。"

#: ../../library/test.rst:384
#, fuzzy
msgid "Object that is equal to anything.  Used to test mixed type comparison."
msgstr "等於任何東西的物件。用於測試混合型別比較。"

#: ../../library/test.rst:389
#, fuzzy
msgid ""
"Object that is not equal to anything (even to :data:`ALWAYS_EQ`). Used to "
"test mixed type comparison."
msgstr ""
"不等於任何物件（甚至不等於 :data:`ALWAYS_EQ`）的物件。用於測試混合型別比較。"

#: ../../library/test.rst:395
#, fuzzy
msgid ""
"Object that is greater than anything (except itself). Used to test mixed "
"type comparison."
msgstr "比任何事物都大的物件（除了它本身）。用於測試混合型別比較。"

#: ../../library/test.rst:401
#, fuzzy
msgid ""
"Object that is less than anything (except itself). Used to test mixed type "
"comparison."
msgstr "比任何東西都小的物件（除了它本身）。用於測試混合型別比較。"

#: ../../library/test.rst:405
msgid "The :mod:`test.support` module defines the following functions:"
msgstr ":mod:`test.support` 模組定義了以下函式："

#: ../../library/test.rst:409
#, fuzzy
msgid ""
"Return ``True`` if *resource* is enabled and available. The list of "
"available resources is only set when :mod:`test.regrtest` is executing the "
"tests."
msgstr ""
"如果 *resource* 已啟用且可用，則回傳 ``True``。可用資源列表僅在 :mod:`test."
"regrtest` 執行測試時設定。"

#: ../../library/test.rst:416
msgid "Return ``True`` if Python was not built with ``-O0`` or ``-Og``."
msgstr "如果 Python 不是使用 ``-O0``或 ``-Og`` 建置的則回傳 ``True``。"

#: ../../library/test.rst:421
msgid "Return :data:`_testcapi.WITH_PYMALLOC`."
msgstr "回傳 :data:`_testcapi.WITH_PYMALLOC`。"

#: ../../library/test.rst:426
#, fuzzy
msgid ""
"Raise :exc:`ResourceDenied` if *resource* is not available. *msg* is the "
"argument to :exc:`ResourceDenied` if it is raised. Always returns ``True`` "
"if called by a function whose ``__name__`` is ``'__main__'``. Used when "
"tests are executed by :mod:`test.regrtest`."
msgstr ""
"如果 *resource* 不可用，則引發 :exc:`ResourceDenied`。 *msg* 是 :exc:"
"`ResourceDenied` 的參數（如果它被引發）。如果由 `__name__`` 為 "
"``'__main__'`` 的函式呼叫，則始終回傳 ``True``。當測試由 :mod:`test."
"regrtest` 執行時使用。"

#: ../../library/test.rst:434
#, fuzzy
msgid "Return a repr of *dict* with keys sorted."
msgstr "回傳帶有已排序鍵的 *dict* 的 repr。"

#: ../../library/test.rst:439
#, fuzzy
msgid ""
"Return the path to the file named *filename*. If no match is found "
"*filename* is returned. This does not equal a failure since it could be the "
"path to the file."
msgstr ""
"回傳名為 *filename* 的文件的路徑。如果找不到匹配項，則回傳 *filename*。這不等"
"於失敗，因為它可能是文件的路徑。"

#: ../../library/test.rst:443
#, fuzzy
msgid ""
"Setting *subdir* indicates a relative path to use to find the file rather "
"than looking directly in the path directories."
msgstr "設定 *subdir* 指示用於查找文件的相對路徑，而不是直接在路徑目錄中查找。"

#: ../../library/test.rst:449
#, fuzzy
msgid ""
"Determine whether *test* matches the patterns set in :func:`set_match_tests`."
msgstr "確定 *test* 是否匹配 :func:`set_match_tests` 中設定的模式。"

#: ../../library/test.rst:454
#, fuzzy
msgid ""
"Define match patterns on test filenames and test method names for filtering "
"tests."
msgstr "為過濾測試定義測試文件名和測試方法名稱的匹配模式。"

#: ../../library/test.rst:459
#, fuzzy
msgid ""
"Execute :class:`unittest.TestCase` subclasses passed to the function. The "
"function scans the classes for methods starting with the prefix ``test_`` "
"and executes the tests individually."
msgstr ""
"執行傳遞給函式的 :class:`unittest.TestCase` 子類別。該函式掃描類以查找以前綴 "
"``test_`` 開頭的方法，並單獨執行測試。"

#: ../../library/test.rst:463
#, fuzzy
msgid ""
"It is also legal to pass strings as parameters; these should be keys in "
"``sys.modules``. Each associated module will be scanned by ``unittest."
"TestLoader.loadTestsFromModule()``. This is usually seen in the following :"
"func:`test_main` function::"
msgstr ""
"將字串作為參數傳遞也是合法的；這些應該是 sys.modules 中的鍵。每個關聯模組將"
"由 ``unittest.TestLoader.loadTestsFromModule()`` 掃描。這通常出現在以下 :"
"func:`test_main` 函式中："

#: ../../library/test.rst:471
#, fuzzy
msgid "This will run all tests defined in the named module."
msgstr "這將運行命名模組中定義的所有測試。"

#: ../../library/test.rst:476
#, fuzzy
msgid ""
"Run :func:`doctest.testmod` on the given *module*.  Return ``(failure_count, "
"test_count)``."
msgstr ""
"在給定的 *module* 上運行 :func:`doctest.testmod`。回傳``(failure_count, "
"test_count)``。"

#: ../../library/test.rst:479
#, fuzzy
msgid ""
"If *verbosity* is ``None``, :func:`doctest.testmod` is run with verbosity "
"set to :data:`verbose`.  Otherwise, it is run with verbosity set to "
"``None``.  *optionflags* is passed as ``optionflags`` to :func:`doctest."
"testmod`."
msgstr ""
"如果 *verbosity* 為 ``None``，則運行 doctest.testmod` 時將詳細程度設定為 :"
"data:`verbose`。否則，它將以詳細設定為 ``None`` 的方式運行。 *optionflags* 作"
"為 ``optionflags`` 傳遞給 :func:`doctest.testmod`。"

#: ../../library/test.rst:487
#, fuzzy
msgid ""
"Set the :func:`sys.setswitchinterval` to the given *interval*.  Defines a "
"minimum interval for Android systems to prevent the system from hanging."
msgstr ""
"將 :func:`sys.setswitchinterval` 設定為給定的 *interval*。定義了Android系統防"
"止系統掛起的最小間隔。"

#: ../../library/test.rst:493
#, fuzzy
msgid ""
"Use this check to guard CPython's implementation-specific tests or to run "
"them only on the implementations guarded by the arguments.  This function "
"returns ``True`` or ``False`` depending on the host platform. Example usage::"
msgstr ""
"使用此檢查來保護 CPython 的特定於實作的測試或僅在參數保護的實作上運行它們。此"
"函式根據主機平台回傳 ``True``或 ``False``。用法示例::"

#: ../../library/test.rst:505
#, fuzzy
msgid ""
"Set the values for :data:`max_memuse` and :data:`real_max_memuse` for big "
"memory tests."
msgstr ""
"為大記憶體測試設定 :data:`max_memuse` 和 :data:`real_max_memuse` 的值。"

#: ../../library/test.rst:511
#, fuzzy
msgid ""
"Store the value from *stdout*.  It is meant to hold the stdout at the time "
"the regrtest began."
msgstr "儲存來自 *stdout* 的值。它旨在在 regrtest 開始時保留標準輸出。"

#: ../../library/test.rst:517
#, fuzzy
msgid ""
"Return the original stdout set by :func:`record_original_stdout` or ``sys."
"stdout`` if it's not set."
msgstr ""
"如果未設定，則回傳由 record_original_stdout 或 sys.stdout 設定的原始標準輸"
"出。"

#: ../../library/test.rst:523
#, fuzzy
msgid ""
"Return a list of command line arguments reproducing the current settings in "
"``sys.flags`` and ``sys.warnoptions``."
msgstr ""
"回傳一個命令列參數列表，再現 ``sys.flags`` 和 ``sys.warnoptions`` 中的當前設"
"定。"

#: ../../library/test.rst:529
#, fuzzy
msgid ""
"Return a list of command line arguments reproducing the current optimization "
"settings in ``sys.flags``."
msgstr "回傳一個命令列參數列表，在 ``sys.flags`` 中重現當前的最佳化設定。"

#: ../../library/test.rst:537
#, fuzzy
msgid ""
"A context managers that temporarily replaces the named stream with :class:"
"`io.StringIO` object."
msgstr "臨時用 io.StringIO 物件替換命名流的上下文管理器。"

#: ../../library/test.rst:540
#, fuzzy
msgid "Example use with output streams::"
msgstr "與輸出流一起使用的示例::"

#: ../../library/test.rst:548
#, fuzzy
msgid "Example use with input stream::"
msgstr "與輸入流一起使用的示例::"

#: ../../library/test.rst:560
#, fuzzy
msgid "A context manager that temporary disables :mod:`faulthandler`."
msgstr "臨時禁用 :mod:`faulthandler` 的上下文管理器。"

#: ../../library/test.rst:565
#, fuzzy
msgid ""
"Force as many objects as possible to be collected.  This is needed because "
"timely deallocation is not guaranteed by the garbage collector.  This means "
"that ``__del__`` methods may be called later than expected and weakrefs may "
"remain alive for longer than expected."
msgstr ""
"強制收集盡可能多的物件。這是必需的，因為垃圾收集器不能保證及時釋放。這意味著 "
"``__del__`` 方法的呼叫時間可能比預期的晚，弱引用的存活時間可能比預期的長。"

#: ../../library/test.rst:573
#, fuzzy
msgid ""
"A context manager that disables the garbage collector on entry. On exit, the "
"garbage collector is restored to its prior state."
msgstr ""
"在入口處禁用垃圾收集器的上下文管理器。退出時，垃圾收集器恢復到之前的狀態。"

#: ../../library/test.rst:579
#, fuzzy
msgid "Context manager to swap out an attribute with a new object."
msgstr "上下文管理器用新物件換出一個屬性。"

#: ../../library/test.rst:581 ../../library/test.rst:599
#: ../../library/test.rst:828 ../../library/test.rst:1301
msgid "Usage::"
msgstr ""
"用法：\n"
"\n"
"::"

#: ../../library/test.rst:586
#, fuzzy
msgid ""
"This will set ``obj.attr`` to 5 for the duration of the ``with`` block, "
"restoring the old value at the end of the block.  If ``attr`` doesn't exist "
"on ``obj``, it will be created and then deleted at the end of the block."
msgstr ""
"這將在 ``with`` 塊的持續時間內將 ``obj.attr`` 設定為 5，在塊的末尾恢復舊值。"
"如果 ``obj`` 上不存在 ``attr``，它將被建立，然後在塊的末尾刪除。"

#: ../../library/test.rst:591 ../../library/test.rst:609
#, fuzzy
msgid ""
"The old value (or ``None`` if it doesn't exist) will be assigned to the "
"target of the \"as\" clause, if there is one."
msgstr "舊值（如果不存在則為 ``None``）將分配給 ``as``子句的目標，如果有的話。"

#: ../../library/test.rst:597
#, fuzzy
msgid "Context manager to swap out an item with a new object."
msgstr "上下文管理器用新物件換出一個項目。"

#: ../../library/test.rst:604
#, fuzzy
msgid ""
"This will set ``obj[\"item\"]`` to 5 for the duration of the ``with`` block, "
"restoring the old value at the end of the block. If ``item`` doesn't exist "
"on ``obj``, it will be created and then deleted at the end of the block."
msgstr ""
"這將在 ``with`` 塊的持續時間內將 ``obj[\"item\"]`` 設定為 5，在塊的末尾恢復舊"
"值。如果 ``obj`` 上不存在 ``item``，它將被建立，然後在塊的末尾刪除。"

#: ../../library/test.rst:615
#, fuzzy
msgid ""
"Call the ``flush()`` method on :data:`sys.stdout` and then on :data:`sys."
"stderr`. It can be used to make sure that the logs order is consistent "
"before writing into stderr."
msgstr ""
"在 :data:`sys.stdout` 上呼叫 ``flush()`` 方法，然後在 :data:`sys.stderr` 上呼"
"叫。它可用於確保日誌順序在寫入 stderr 之前是一致的。"

#: ../../library/test.rst:624
#, fuzzy
msgid ""
"Print a warning into :data:`sys.__stderr__`. Format the message as: "
"``f\"Warning -- {msg}\"``. If *msg* is made of multiple lines, add "
"``\"Warning -- \"`` prefix to each line."
msgstr ""
"將警告印出到 :data:`sys.__stderr__`。將消息格式化為：``f\"Warning -- "
"{msg}\"``。如果 *msg* 由多行組成，則在每行前新增 ``\"Warning -- \"`` 前綴。"

#: ../../library/test.rst:633
#, fuzzy
msgid ""
"Wait until process *pid* completes and check that the process exit code is "
"*exitcode*."
msgstr "等到行程 *pid* 完成並檢查行程退出程式碼是否為 *exitcode*。"

#: ../../library/test.rst:636
#, fuzzy
msgid ""
"Raise an :exc:`AssertionError` if the process exit code is not equal to "
"*exitcode*."
msgstr "如果行程退出程式碼不等於 *exitcode*，則引發 :exc:`AssertionError`。"

#: ../../library/test.rst:639
#, fuzzy
msgid ""
"If the process runs longer than *timeout* seconds (:data:`SHORT_TIMEOUT` by "
"default), kill the process and raise an :exc:`AssertionError`. The timeout "
"feature is not available on Windows."
msgstr ""
"如果行程運行時間超過 *timeout* 秒（預設情況下 :data:`SHORT_TIMEOUT`），則終止"
"行程並引發 :exc:`AssertionError`。超時功能在 Windows 上不可用。"

#: ../../library/test.rst:648
#, fuzzy
msgid ""
"Return the size of the :c:type:`PyObject` whose structure members are "
"defined by *fmt*. The returned value includes the size of the Python object "
"header and alignment."
msgstr ""
"回傳結構成員由 *fmt* 定義的 :c:type:`PyObject` 的大小。回傳值包括 Python 對像"
"頭的大小和對齊方式。"

#: ../../library/test.rst:654
#, fuzzy
msgid ""
"Return the size of the :c:type:`PyVarObject` whose structure members are "
"defined by *fmt*. The returned value includes the size of the Python object "
"header and alignment."
msgstr ""
"回傳其結構成員由 *fmt* 定義的 :c:type:`PyVarObject` 的大小。回傳值包括 "
"Python 對像頭的大小和對齊方式。"

#: ../../library/test.rst:660
#, fuzzy
msgid ""
"For testcase *test*, assert that the ``sys.getsizeof`` for *o* plus the GC "
"header size equals *size*."
msgstr ""
"對於測試用例 *test*，斷言 *o* 的 ``sys.getsizeof`` 加上 GC 標頭大小等於 "
"*size*。"

#: ../../library/test.rst:666
#, fuzzy
msgid ""
"A decorator to conditionally mark tests with :func:`unittest."
"expectedFailure`. Any use of this decorator should have an associated "
"comment identifying the relevant tracker issue."
msgstr ""
"有條件地用 unittest.expectedFailure 標記測試的裝飾器。對這個裝飾器的任何使用"
"都應該有一個關聯的註釋來標識相關的跟踪器問題。"

#: ../../library/test.rst:673
#, fuzzy
msgid ""
"A decorator that skips the decorated test on TLS certification validation "
"failures."
msgstr "跳過 TLS 認證驗證失敗的裝飾測試的裝飾器。"

#: ../../library/test.rst:678
#, fuzzy
msgid ""
"A decorator for running a function in a different locale, correctly "
"resetting it after it has finished.  *catstr* is the locale category as a "
"string (for example ``\"LC_ALL\"``).  The *locales* passed will be tried "
"sequentially, and the first valid locale will be used."
msgstr ""
"一個裝飾器，用於在不同的語言環境中運行一個函式，在它完成後正確地重置它。 "
"*catstr* 是字串形式的語言環境類別（例如``\"LC_ALL\"``）。傳遞的 *locales* 將"
"按順序嘗試，並使用第一個有效的語言環境。"

#: ../../library/test.rst:686
#, fuzzy
msgid ""
"A decorator for running a function in a specific timezone, correctly "
"resetting it after it has finished."
msgstr "用於在特定時區運行功能的裝飾器，在完成後正確重置它。"

#: ../../library/test.rst:692
#, fuzzy
msgid ""
"Decorator for the minimum version when running test on FreeBSD.  If the "
"FreeBSD version is less than the minimum, the test is skipped."
msgstr ""
"在 FreeBSD 上運行測試時最低版本的裝飾器。如果 FreeBSD 版本低於最低版本，則跳"
"過測試。"

#: ../../library/test.rst:698
#, fuzzy
msgid ""
"Decorator for the minimum version when running test on Linux.  If the Linux "
"version is less than the minimum, the test is skipped."
msgstr ""
"在 Linux 上運行測試時最低版本的裝飾器。如果 Linux 版本低於最低版本，則跳過測"
"試。"

#: ../../library/test.rst:704
#, fuzzy
msgid ""
"Decorator for the minimum version when running test on macOS.  If the macOS "
"version is less than the minimum, the test is skipped."
msgstr ""
"在 macOS 上運行測試時最低版本的裝飾器。如果 macOS 版本低於最低版本，則跳過測"
"試。"

#: ../../library/test.rst:710
#, fuzzy
msgid "Decorator for skipping tests on non-IEEE 754 platforms."
msgstr "用於在非 IEEE 754 平台上跳過測試的裝飾器。"

#: ../../library/test.rst:715
#, fuzzy
msgid "Decorator for skipping tests if :mod:`zlib` doesn't exist."
msgstr "如果 :mod:`zlib` 不存在則跳過測試的裝飾器。"

#: ../../library/test.rst:720
#, fuzzy
msgid "Decorator for skipping tests if :mod:`gzip` doesn't exist."
msgstr "如果 :mod:`gzip` 不存在則跳過測試的裝飾器。"

#: ../../library/test.rst:725
#, fuzzy
msgid "Decorator for skipping tests if :mod:`bz2` doesn't exist."
msgstr "如果 :mod:`bz2` 不存在則跳過測試的裝飾器。"

#: ../../library/test.rst:730
#, fuzzy
msgid "Decorator for skipping tests if :mod:`lzma` doesn't exist."
msgstr "如果 :mod:`lzma` 不存在則跳過測試的裝飾器。"

#: ../../library/test.rst:735
#, fuzzy
msgid "Decorator for skipping tests if *resource* is not available."
msgstr "如果 *resource* 不可用，用於跳過測試的裝飾器。"

#: ../../library/test.rst:740
#, fuzzy
msgid "Decorator for only running the test if :data:`HAVE_DOCSTRINGS`."
msgstr "僅在 HAVE_DOCSTRINGS 時運行測試的裝飾器。"

#: ../../library/test.rst:745
#, fuzzy
msgid "Decorator for tests only applicable to CPython."
msgstr "僅適用於 CPython 的測試裝飾器。"

#: ../../library/test.rst:750
#, fuzzy
msgid ""
"Decorator for invoking :func:`check_impl_detail` on *guards*.  If that "
"returns ``False``, then uses *msg* as the reason for skipping the test."
msgstr ""
"用於在 *guards* 上呼叫 :func:`check_impl_detail` 的裝飾器。如果回傳 "
"``False``，則使用 *msg* 作為跳過測試的原因。"

#: ../../library/test.rst:756
#, fuzzy
msgid "Decorator to temporarily turn off tracing for the duration of the test."
msgstr "裝飾器在測試期間暫時關閉跟踪。"

#: ../../library/test.rst:761
#, fuzzy
msgid ""
"Decorator for tests which involve reference counting.  The decorator does "
"not run the test if it is not run by CPython.  Any trace function is unset "
"for the duration of the test to prevent unexpected refcounts caused by the "
"trace function."
msgstr ""
"涉及引用計數的測試裝飾器。如果裝飾器不是由 CPython 運行，則裝飾器不會運行測"
"試。在測試期間未設定任何跟踪函式，以防止由跟踪函式引起的意外引用計數。"

#: ../../library/test.rst:769
#, fuzzy
msgid "Decorator for bigmem tests."
msgstr "bigmem 測試的裝飾器。"

#: ../../library/test.rst:771
#, fuzzy
msgid ""
"*size* is a requested size for the test (in arbitrary, test-interpreted "
"units.)  *memuse* is the number of bytes per unit for the test, or a good "
"estimate of it.  For example, a test that needs two byte buffers, of 4 GiB "
"each, could be decorated with ``@bigmemtest(size=_4G, memuse=2)``."
msgstr ""
"*size* 是測試請求的大小（以任意的、測試解釋的單位）。 *memuse* 是測試的每個單"
"元的位元組數，或者是對它的一個很好的估計。例如，需要兩個位元組緩衝區的測試，"
"每個緩衝區 4 GiB，可以用 @bigmemtest(size=_4G, memuse=2) 修飾。"

#: ../../library/test.rst:776
#, fuzzy
msgid ""
"The *size* argument is normally passed to the decorated test method as an "
"extra argument.  If *dry_run* is ``True``, the value passed to the test "
"method may be less than the requested value.  If *dry_run* is ``False``, it "
"means the test doesn't support dummy runs when ``-M`` is not specified."
msgstr ""
"*size* 參數通常作為額外參數傳遞給修飾的測試方法。如果 *dry_run* 為 ``True``，"
"則傳遞給測試方法的值可能小於請求的值。如果 *dry_run* 為 ``False``，則表示在未"
"指定 ``-M`` 時測試不支援虛擬運行。"

#: ../../library/test.rst:784
#, fuzzy
msgid "Decorator for tests that fill the address space."
msgstr "用於填充地址空間的測試的裝飾器。"

#: ../../library/test.rst:789
#, fuzzy
msgid ""
"Test for syntax errors in *statement* by attempting to compile *statement*. "
"*testcase* is the :mod:`unittest` instance for the test.  *errtext* is the "
"regular expression which should match the string representation of the "
"raised :exc:`SyntaxError`.  If *lineno* is not ``None``, compares to the "
"line of the exception.  If *offset* is not ``None``, compares to the offset "
"of the exception."
msgstr ""
"通過嘗試編譯 *statement* 來測試 *statement* 中的語法錯誤。 *testcase* 是用於"
"測試的 :mod:`unittest` 實例。 *errtext* 是正則表達式，它應該匹配引發的字串表"
"示 :exec:`SyntaxError`。如果 *lineno* 不是 ``None`` ，則與例外行進行比較。如"
"果 *offset* 不是 ``None``，則與例外的偏移量進行比較。"

#: ../../library/test.rst:799
#, fuzzy
msgid "Open *url*.  If open fails, raises :exc:`TestFailed`."
msgstr "打開*網址*。如果打開失敗，則引發 :exc:`TestFailed`。"

#: ../../library/test.rst:804
#, fuzzy
msgid ""
"Use this at the end of ``test_main`` whenever sub-processes are started. "
"This will help ensure that no extra children (zombies) stick around to hog "
"resources and create problems when looking for refleaks."
msgstr ""
"每當子行程啟動時，在 ``test_main`` 的末尾使用它。這將有助於確保沒有額外的孩子"
"（殭屍）在尋找反射時留下來佔用資源並造成問題。"

#: ../../library/test.rst:811
#, fuzzy
msgid ""
"Get an attribute, raising :exc:`unittest.SkipTest` if :exc:`AttributeError` "
"is raised."
msgstr ""
"獲取一個屬性，如果引發 :exec:`unittest.SkipTest`，則引發 :exec:"
"`AttributeError`。"

#: ../../library/test.rst:817
#, fuzzy
msgid ""
"Context manager catching unraisable exception using :func:`sys."
"unraisablehook`."
msgstr "上下文管理器使用 :func:`sys.unraisablehook` 捕獲無法引發的例外。"

#: ../../library/test.rst:820
#, fuzzy
msgid ""
"Storing the exception value (``cm.unraisable.exc_value``) creates a "
"reference cycle. The reference cycle is broken explicitly when the context "
"manager exits."
msgstr ""
"儲存例外值（``cm.unraisable.exc_value``）會建立一個引用循環。當上下文管理器退"
"出時，引用循環被明確打破。"

#: ../../library/test.rst:824
#, fuzzy
msgid ""
"Storing the object (``cm.unraisable.object``) can resurrect it if it is set "
"to an object which is being finalized. Exiting the context manager clears "
"the stored object."
msgstr ""
"儲存物件 (``cm.unraisable.object``) 如果它被設定為一個正在被終結的物件，它可"
"以復活它。退出上下文管理器會清除儲存的物件。"

#: ../../library/test.rst:845
#, fuzzy
msgid ""
"Generic implementation of the :mod:`unittest` ``load_tests`` protocol for "
"use in test packages.  *pkg_dir* is the root directory of the package; "
"*loader*, *standard_tests*, and *pattern* are the arguments expected by "
"``load_tests``.  In simple cases, the test package's ``__init__.py`` can be "
"the following::"
msgstr ""
":mod:`unittest` ``load_tests`` 協定的通用實作，用於測試包。 *pkg_dir* 是包的"
"根目錄； *loader*、*standard_tests* 和 *pattern* 是 ``load_tests`` 期望的參"
"數。在簡單的情況下，測試包的 ``__init__.py`` 可以是以下內容："

#: ../../library/test.rst:860
#, fuzzy
msgid ""
"Returns the set of attributes, functions or methods of *ref_api* not found "
"on *other_api*, except for a defined list of items to be ignored in this "
"check specified in *ignore*."
msgstr ""
"回傳在 *other_api* 上找不到的 *ref_api* 的屬性、函式或方法集，但在 *ignore* "
"中指定的此檢查中要忽略的已定義項目列表除外。"

#: ../../library/test.rst:864
#, fuzzy
msgid ""
"By default this skips private attributes beginning with '_' but includes all "
"magic methods, i.e. those starting and ending in '__'."
msgstr ""
"預設情況下，這會跳過以 ``_``開頭的私有屬性，但包括所有魔術方法，即以 ``_``開"
"頭和結尾的那些。"

#: ../../library/test.rst:872
#, fuzzy
msgid ""
"Override *object_to_patch.attr_name* with *new_value*.  Also add cleanup "
"procedure to *test_instance* to restore *object_to_patch* for *attr_name*.  "
"The *attr_name* should be a valid attribute for *object_to_patch*."
msgstr ""
"用 *new_value* 覆蓋 *object_to_patch.attr_name*。還向 *test_instance* 新增清"
"理程式以恢復 *attr_name* 的 *object_to_patch*。 *attr_name* 應該是 "
"*object_to_patch* 的有效屬性。"

#: ../../library/test.rst:880
#, fuzzy
msgid ""
"Run *code* in subinterpreter.  Raise :exc:`unittest.SkipTest` if :mod:"
"`tracemalloc` is enabled."
msgstr ""
"在子直譯器中運行 *code*。如果啟用了 :exec:`unittest.SkipTest`，則提高 :mod:"
"`tracemalloc`。"

#: ../../library/test.rst:886
#, fuzzy
msgid "Assert instances of *cls* are deallocated after iterating."
msgstr "*cls* 的斷言實例在疊代後被釋放。"

#: ../../library/test.rst:891
#, fuzzy
msgid ""
"Check for the existence of the compiler executables whose names are listed "
"in *cmd_names* or all the compiler executables when *cmd_names* is empty and "
"return the first missing executable or ``None`` when none is found missing."
msgstr ""
"檢查是否存在名稱在 *cmd_names* 中列出的編譯器可執行文件或所有編譯器可執行文件"
"（當 *cmd_names* 為空時），並回傳第一個丟失的可執行文件或 ``None`` （如果沒有"
"發現丟失）。"

#: ../../library/test.rst:899
#, fuzzy
msgid ""
"Assert that the ``__all__`` variable of *module* contains all public names."
msgstr "斷言 *module* 的 ``__all__`` 變數包含所有公開名稱。"

#: ../../library/test.rst:901
#, fuzzy
msgid ""
"The module's public names (its API) are detected automatically based on "
"whether they match the public name convention and were defined in *module*."
msgstr ""
"模組的公開名稱（其 API）會根據它們是否匹配公開名稱約定並在 *module* 中定義而"
"自動檢測。"

#: ../../library/test.rst:905
#, fuzzy
msgid ""
"The *name_of_module* argument can specify (as a string or tuple thereof) "
"what module(s) an API could be defined in order to be detected as a public "
"API. One case for this is when *module* imports part of its public API from "
"other modules, possibly a C backend (like ``csv`` and its ``_csv``)."
msgstr ""
"*name_of_module* 參數可以指定（作為字串或元組）API 可以定義哪些模組以便被檢測"
"為公開 API。一種情況是 *module* 從其他模組導入其公開 API 的一部分，可能是 C "
"後端（如 ``csv`` 及其 ``_csv``）。"

#: ../../library/test.rst:910
#, fuzzy
msgid ""
"The *extra* argument can be a set of names that wouldn't otherwise be "
"automatically detected as \"public\", like objects without a proper "
"``__module__`` attribute. If provided, it will be added to the automatically "
"detected ones."
msgstr ""
"*extra* 參數可以是一組不會被自動檢測為 ``public``的名稱，比如沒有適當的 "
"``__module__`` 屬性的物件。如果提供，它將被新增到自動檢測到的。"

#: ../../library/test.rst:914
#, fuzzy
msgid ""
"The *not_exported* argument can be a set of names that must not be treated "
"as part of the public API even though their names indicate otherwise."
msgstr ""
"*not_exported* 參數可以是一組名稱，即使它們的名稱另有說明，也不能將其視為公"
"開 API 的一部分。"

#: ../../library/test.rst:917 ../../library/test.rst:1550
msgid "Example use::"
msgstr ""
"用法範例：\n"
"\n"
"::"

#: ../../library/test.rst:940
#, fuzzy
msgid ""
"Skip tests if the :mod:`multiprocessing.synchronize` module is missing, if "
"there is no available semaphore implementation, or if creating a lock raises "
"an :exc:`OSError`."
msgstr ""
"如果 :mod:`multiprocessing.synchronize` 模組缺失，如果沒有可用的信號量實作，"
"或者如果建立鎖引發 :exc:`OSError`，則跳過測試。"

#: ../../library/test.rst:949
#, fuzzy
msgid "Assert that type *tp* cannot be instantiated using *args* and *kwds*."
msgstr "斷言型別 *tp* 不能使用 *args* 和 *kwds* 實例化。"

#: ../../library/test.rst:956
#, fuzzy
msgid ""
"This function returns a context manager that will change the global :func:"
"`sys.set_int_max_str_digits` setting for the duration of the context to "
"allow execution of test code that needs a different limit on the number of "
"digits when converting between an integer and string."
msgstr ""
"此函式回傳一個上下文管理器，它將在上下文持續時間內更改全局 :func:`sys."
"set_int_max_str_digits` 設定，以允許執行在整數和字串之間轉換時需要不同位數限"
"制的測試程式碼。"

#: ../../library/test.rst:964
#, fuzzy
msgid "The :mod:`test.support` module defines the following classes:"
msgstr ":mod:`test.support` 模組定義了以下類："

#: ../../library/test.rst:969
#, fuzzy
msgid ""
"A context manager used to try to prevent crash dialog popups on tests that "
"are expected to crash a subprocess."
msgstr ""
"一個上下文管理器，用於嘗試防止在預期會導致子行程崩潰的測試中出現崩潰對話框彈"
"出窗口。"

#: ../../library/test.rst:972
#, fuzzy
msgid ""
"On Windows, it disables Windows Error Reporting dialogs using `SetErrorMode "
"<https://msdn.microsoft.com/en-us/library/windows/desktop/ms680621.aspx>`_."
msgstr ""
"在 Windows 上，它使用 `SetErrorMode <https://msdn.microsoft.com/en-us/"
"library/windows/desktop/ms680621.aspx>`_ 禁用 Windows 錯誤報告對話框。"

#: ../../library/test.rst:975
#, fuzzy
msgid ""
"On UNIX, :func:`resource.setrlimit` is used to set :attr:`resource."
"RLIMIT_CORE`'s soft limit to 0 to prevent coredump file creation."
msgstr ""
"在 UNIX 上，:func:`resource.setrlimit` 用於將 :attr:`resource.RLIMIT_CORE` 的"
"軟限制設定為 0，以防止建立 coredump 文件。"

#: ../../library/test.rst:979
#, fuzzy
msgid "On both platforms, the old value is restored by :meth:`__exit__`."
msgstr "在這兩個平台上，舊值都由 :meth:`__exit__` 恢復。"

#: ../../library/test.rst:984
#, fuzzy
msgid ""
"Class to save and restore signal handlers registered by the Python signal "
"handler."
msgstr "用於保存和恢復由 Python 信號處理程式註冊的信號處理程式的類。"

#: ../../library/test.rst:989
#, fuzzy
msgid ""
"Save the signal handlers to a dictionary mapping signal numbers to the "
"current signal handler."
msgstr "將信號處理程式保存到將信號編號映射到當前信號處理程式的字典中。"

#: ../../library/test.rst:994
#, fuzzy
msgid ""
"Set the signal numbers from the :meth:`save` dictionary to the saved handler."
msgstr "將 :meth:`save` 字典中的信號編號設定為保存的處理程式。"

#: ../../library/test.rst:1002
#, fuzzy
msgid "Try to match a single dict with the supplied arguments."
msgstr "嘗試將單個字典與提供的參數匹配。"

#: ../../library/test.rst:1007
#, fuzzy
msgid "Try to match a single stored value (*dv*) with a supplied value (*v*)."
msgstr "嘗試將單個儲存值 (*dv*) 與提供的值 (*v*) 匹配。"

#: ../../library/test.rst:1014
#, fuzzy
msgid "Run *test* and return the result."
msgstr "運行 *test* 並回傳結果。"

#: ../../library/test.rst:1018
#, fuzzy
msgid ":mod:`test.support.socket_helper` --- Utilities for socket tests"
msgstr ":mod:`test.support.socket_helper` ---  socket 測試實用程式"

#: ../../library/test.rst:1024
#, fuzzy
msgid ""
"The :mod:`test.support.socket_helper` module provides support for socket "
"tests."
msgstr ":mod:`test.support.socket_helper` 模組提供對 socket 測試的支援。"

#: ../../library/test.rst:1031
#, fuzzy
msgid "Set to ``True`` if IPv6 is enabled on this host, ``False`` otherwise."
msgstr "如果此主機上啟用了 IPv6，則設定為 ``True``，否則設定為 ``False``。"

#: ../../library/test.rst:1036
#, fuzzy
msgid ""
"Returns an unused port that should be suitable for binding.  This is "
"achieved by creating a temporary socket with the same family and type as the "
"``sock`` parameter (default is :const:`~socket.AF_INET`, :const:`~socket."
"SOCK_STREAM`), and binding it to the specified host address (defaults to "
"``0.0.0.0``) with the port set to 0, eliciting an unused ephemeral port from "
"the OS. The temporary socket is then closed and deleted, and the ephemeral "
"port is returned."
msgstr ""
"回傳應適合綁定的未使用端口。這是通過建立一個與 ``sock`` 參數具有相同系列和型"
"別的臨時 socket （預設為 :const:`~socket.AF_INET`、:const:`~socket."
"SOCK_STREAM`）並將其綁定到端口設定為 0 的指定主機地址（預設為“0.0.0.0”），從"
"操作系統中引出一個未使用的臨時端口。然後關閉並刪除臨時 socket ，並回傳臨時端"
"口。"

#: ../../library/test.rst:1045
#, fuzzy
msgid ""
"Either this method or :func:`bind_port` should be used for any tests where a "
"server socket needs to be bound to a particular port for the duration of the "
"test. Which one to use depends on whether the calling code is creating a "
"Python socket, or if an unused port needs to be provided in a constructor or "
"passed to an external program (i.e. the ``-accept`` argument to openssl's "
"s_server mode).  Always prefer :func:`bind_port` over :func:"
"`find_unused_port` where possible.  Using a hard coded port is discouraged "
"since it can make multiple instances of the test impossible to run "
"simultaneously, which is a problem for buildbots."
msgstr ""
"此方法或 :func:`bind_port` 應用於在測試期間需要將伺服器 socket 綁定到特定端口"
"的任何測試。使用哪一個取決於呼叫程式碼是否正在建立 Python  socket ，或者是否"
"需要在構造函式中提供未使用的端口或傳遞給外部程式（即 openssl s_server 模式的 "
"``-accept`` 參數）。盡可能使用 :func:`bind_port` 而不是 :func:"
"`find_unused_port`。不鼓勵使用硬編碼端口，因為它會使多個測試實例無法同時運"
"行，這對構建機器人來說是個問題。"

#: ../../library/test.rst:1059
#, fuzzy
msgid ""
"Bind the socket to a free port and return the port number.  Relies on "
"ephemeral ports in order to ensure we are using an unbound port.  This is "
"important as many tests may be running simultaneously, especially in a "
"buildbot environment.  This method raises an exception if the ``sock."
"family`` is :const:`~socket.AF_INET` and ``sock.type`` is :const:`~socket."
"SOCK_STREAM`, and the socket has :const:`~socket.SO_REUSEADDR` or :const:"
"`~socket.SO_REUSEPORT` set on it. Tests should never set these socket "
"options for TCP/IP sockets. The only case for setting these options is "
"testing multicasting via multiple UDP sockets."
msgstr ""
"將 socket 綁定到空閒端口並回傳端口號。依賴臨時端口以確保我們使用的是未綁定端"
"口。這很重要，因為許多測試可能同時運行，尤其是在 buildbot 環境中。如果 "
"``sock.family`` 是 :const:`~socket.AF_INET` 並且 ``sock.type`` 是 :const:"
"`~socket.SOCK_STREAM` 並且 socket 具有 :const: `~socket.SO_REUSEADDR` 或 :"
"const:`~socket.SO_REUSEPORT` 在其上設定。測試不應該為 TCP/IP  socket 設定這"
"些 socket 選項。設定這些選項的唯一情況是通過多個 UDP  socket 測試多播。"

#: ../../library/test.rst:1070
#, fuzzy
msgid ""
"Additionally, if the :const:`~socket.SO_EXCLUSIVEADDRUSE` socket option is "
"available (i.e. on Windows), it will be set on the socket.  This will "
"prevent anyone else from binding to our host/port for the duration of the "
"test."
msgstr ""
"此外，如果 :const:`~socket.SO_EXCLUSIVEADDRUSE`  socket 選項可用（即在 "
"Windows 上），它將在 socket 上設定。這將防止任何其他人在測試期間綁定到我們的"
"主機/端口。"

#: ../../library/test.rst:1078
#, fuzzy
msgid ""
"Bind a Unix socket, raising :exc:`unittest.SkipTest` if :exc:"
"`PermissionError` is raised."
msgstr ""
"綁定 Unix  socket ，如果引發 PermissionError 則引發 :exc:`unittest."
"SkipTest`。"

#: ../../library/test.rst:1084
#, fuzzy
msgid ""
"A decorator for running tests that require a functional ``bind()`` for Unix "
"sockets."
msgstr "一個裝飾器，用於運行需要 Unix  socket 功能性“bind()”的測試。"

#: ../../library/test.rst:1090
#, fuzzy
msgid ""
"A context manager that raises :exc:`~test.support.ResourceDenied` when "
"various issues with the internet connection manifest themselves as "
"exceptions."
msgstr ""
"當 Internet 連接的各種問題表現為例外時，引發 :exc:`~test.support."
"ResourceDenied` 的上下文管理器。"

#: ../../library/test.rst:1096
#, fuzzy
msgid ""
":mod:`test.support.script_helper` --- Utilities for the Python execution "
"tests"
msgstr ":mod:`test.support.script_helper` --- Python 執行測試的實用程式"

#: ../../library/test.rst:1102
#, fuzzy
msgid ""
"The :mod:`test.support.script_helper` module provides support for Python's "
"script execution tests."
msgstr ""
":mod:`test.support.script_helper` 模組為 Python 的腳本執行測試提供支援。"

#: ../../library/test.rst:1107
#, fuzzy
msgid ""
"Return ``True`` if ``sys.executable interpreter`` requires environment "
"variables in order to be able to run at all."
msgstr ""
"如果“sys.executable interpreter”需要環境變數才能運行，則回傳 ``True``。"

#: ../../library/test.rst:1110
#, fuzzy
msgid ""
"This is designed to be used with ``@unittest.skipIf()`` to annotate tests "
"that need to use an ``assert_python*()`` function to launch an isolated mode "
"(``-I``) or no environment mode (``-E``) sub-interpreter process."
msgstr ""
"這旨在與“@unittest.skipIf()”一起使用，以註釋需要使用“assert_python*()”函式啟"
"動隔離模式（ ``-I``）或無環境的測試mode (``-E``) 子直譯器行程。"

#: ../../library/test.rst:1114
#, fuzzy
msgid ""
"A normal build & test does not run into this situation but it can happen "
"when trying to run the standard library test suite from an interpreter that "
"doesn't have an obvious home with Python's current home finding logic."
msgstr ""
"正常的構建和測試不會遇到這種情況，但是當嘗試從直譯器運行標準庫測試套件時可能"
"會發生這種情況，而直譯器沒有明顯的歸屬地與 Python 當前的歸屬地查找邏輯。"

#: ../../library/test.rst:1118
#, fuzzy
msgid ""
"Setting :envvar:`PYTHONHOME` is one way to get most of the testsuite to run "
"in that situation.  :envvar:`PYTHONPATH` or :envvar:`PYTHONUSERSITE` are "
"other common environment variables that might impact whether or not the "
"interpreter can start."
msgstr ""
"設定 :envvar:`PYTHONHOME` 是讓大部分測試套件在這種情況下運行的一種方法。 :"
"envvar:`PYTHONPATH` 或 :envvar:`PYTHONUSERSITE` 是可能影響直譯器是否可以啟動"
"的其他常見環境變數。"

#: ../../library/test.rst:1126
#, fuzzy
msgid ""
"Set up the environment based on *env_vars* for running the interpreter in a "
"subprocess.  The values can include ``__isolated``, ``__cleanenv``, "
"``__cwd``, and ``TERM``."
msgstr ""
"基於 *env_vars* 設定環境以在子行程中運行直譯器。這些值可以包括"
"``__isolated``、``__cleanenv``、``__cwd`` 和``TERM``。"

#: ../../library/test.rst:1130 ../../library/test.rst:1146
#: ../../library/test.rst:1158
#, fuzzy
msgid "The function no longer strips whitespaces from *stderr*."
msgstr "該函式不再從 *stderr* 中去除空格。"

#: ../../library/test.rst:1136
#, fuzzy
msgid ""
"Assert that running the interpreter with *args* and optional environment "
"variables *env_vars* succeeds (``rc == 0``) and return a ``(return code, "
"stdout, stderr)`` tuple."
msgstr ""
"斷言使用 *args* 和可選環境變數 *env_vars* 運行直譯器成功 (``rc == 0``) 並回傳"
"一個``(return code, stdout, stderr)`` 元組。"

#: ../../library/test.rst:1140
#, fuzzy
msgid ""
"If the *__cleanenv* keyword-only parameter is set, *env_vars* is used as a "
"fresh environment."
msgstr "如果設定了 *__cleanenv* 僅關鍵字參數，*env_vars* 將用作全新環境。"

#: ../../library/test.rst:1143
#, fuzzy
msgid ""
"Python is started in isolated mode (command line option ``-I``), except if "
"the *__isolated* keyword-only parameter is set to ``False``."
msgstr ""
"Python 以隔離模式啟動（命令列選項 ``-I``），除非 *__isolated* 關鍵字參數設定"
"為 ``False``。"

#: ../../library/test.rst:1152
#, fuzzy
msgid ""
"Assert that running the interpreter with *args* and optional environment "
"variables *env_vars* fails (``rc != 0``) and return a ``(return code, "
"stdout, stderr)`` tuple."
msgstr ""
"斷言使用 *args* 和可選環境變數 *env_vars* 運行直譯器失敗 (``rc != 0``) 並回傳"
"一個 ``(return code, stdout, stderr)`` 元組。"

#: ../../library/test.rst:1156
msgid "See :func:`assert_python_ok` for more options."
msgstr "更多選項請見 :func:`assert_python_ok`\\ 。"

#: ../../library/test.rst:1164
#, fuzzy
msgid "Run a Python subprocess with the given arguments."
msgstr "使用給定的參數運行 Python 子行程。"

#: ../../library/test.rst:1166
#, fuzzy
msgid ""
"*kw* is extra keyword args to pass to :func:`subprocess.Popen`. Returns a :"
"class:`subprocess.Popen` object."
msgstr ""
"*kw* 是要傳遞給 :func:`subprocess.Popen` 的額外關鍵字參數。回傳一個 :class:"
"`subprocess.Popen` 物件。"

#: ../../library/test.rst:1172
#, fuzzy
msgid ""
"Run the given :class:`subprocess.Popen` process until completion and return "
"stdout."
msgstr "運行給定的 :class:`subprocess.Popen` 過程直到完成並回傳標準輸出。"

#: ../../library/test.rst:1178
#, fuzzy
msgid ""
"Create script containing *source* in path *script_dir* and "
"*script_basename*. If *omit_suffix* is ``False``, append ``.py`` to the "
"name.  Return the full script path."
msgstr ""
"在路徑 *script_dir* 和 *script_basename* 中建立包含 *source* 的腳本。如果 "
"*omit_suffix* 為 ``False``，請將 ``.py`` 附加到名稱中。回傳完整的腳本路徑。"

#: ../../library/test.rst:1185
#, fuzzy
msgid ""
"Create zip file at *zip_dir* and *zip_basename* with extension ``zip`` which "
"contains the files in *script_name*. *name_in_zip* is the archive name. "
"Return a tuple containing ``(full path, full path of archive name)``."
msgstr ""
"在 *zip_dir* 和 *zip_basename* 建立 zip 文件，擴充名為 ``zip``，其中包含 "
"*script_name* 中的文件。 *name_in_zip* 是存檔名稱。回傳一個包含“（完整路徑，"
"存檔名稱的完整路徑）”的元組。"

#: ../../library/test.rst:1192
#, fuzzy
msgid ""
"Create a directory named *pkg_dir* containing an ``__init__`` file with "
"*init_source* as its contents."
msgstr ""
"建立一個名為 *pkg_dir* 的目錄，其中包含一個以 *init_source* 為內容的 "
"``__init__`` 文件。"

#: ../../library/test.rst:1199
#, fuzzy
msgid ""
"Create a zip package directory with a path of *zip_dir* and *zip_basename* "
"containing an empty ``__init__`` file and a file *script_basename* "
"containing the *source*.  If *compiled* is ``True``, both source files will "
"be compiled and added to the zip package.  Return a tuple of the full zip "
"path and the archive name for the zip file."
msgstr ""
"建立一個 zip 包目錄，路徑為 *zip_dir* 和 *zip_basename*，其中包含一個空的 "
"``__init__`` 文件和一個包含 *source* 的文件 *script_basename*。如果"
"*compiled* 為 ``True``，則兩個源文件都將被編譯並新增到 zip 包中。回傳完整 "
"zip 路徑的元組和 zip 文件的存檔名稱。"

#: ../../library/test.rst:1207
#, fuzzy
msgid ""
":mod:`test.support.bytecode_helper` --- Support tools for testing correct "
"bytecode generation"
msgstr ":mod:`test.support.bytecode_helper` --- 測試正確位元組碼生成的支援工具"

#: ../../library/test.rst:1212
#, fuzzy
msgid ""
"The :mod:`test.support.bytecode_helper` module provides support for testing "
"and inspecting bytecode generation."
msgstr ""
":mod:`test.support.bytecode_helper` 模組為測試和檢查位元組碼生成提供支援。"

#: ../../library/test.rst:1217
#, fuzzy
msgid "The module defines the following class:"
msgstr "該模組定義了以下類："

#: ../../library/test.rst:1221
#, fuzzy
msgid "This class has custom assertion methods for inspecting bytecode."
msgstr "此類具有用於檢查位元組碼的自定義斷言方法。"

#: ../../library/test.rst:1225
#, fuzzy
msgid "Return the disassembly of *co* as string."
msgstr "將 *co* 的反彙編回傳為字串。"

#: ../../library/test.rst:1230
#, fuzzy
msgid ""
"Return instr if *opname* is found, otherwise throws :exc:`AssertionError`."
msgstr "如果找到 *opname* 則回傳 instr，否則拋出 :exc:`AssertionError`。"

#: ../../library/test.rst:1235
#, fuzzy
msgid "Throws :exc:`AssertionError` if *opname* is found."
msgstr "如果找到 *opname*，則拋出 :exc:`AssertionError`。"

#: ../../library/test.rst:1239
#, fuzzy
msgid ":mod:`test.support.threading_helper` --- Utilities for threading tests"
msgstr ":mod:`test.support.threading_helper` --- 用於執行緒測試的實用程式"

#: ../../library/test.rst:1244
#, fuzzy
msgid ""
"The :mod:`test.support.threading_helper` module provides support for "
"threading tests."
msgstr ":mod:`test.support.threading_helper` 模組提供對執行緒測試的支援。"

#: ../../library/test.rst:1251
#, fuzzy
msgid ""
"Join a *thread* within *timeout*.  Raise an :exc:`AssertionError` if thread "
"is still alive after *timeout* seconds."
msgstr ""
"在*超時*內加入*執行緒*。如果執行緒在 *timeout* 秒後仍然存在，則引發 :exc:"
"`AssertionError`。"

#: ../../library/test.rst:1257
#, fuzzy
msgid "Decorator to ensure the threads are cleaned up even if the test fails."
msgstr "裝飾器確保即使測試失敗也能清理執行緒。"

#: ../../library/test.rst:1262
#, fuzzy
msgid ""
"Context manager to start *threads*, which is a sequence of threads. *unlock* "
"is a function called after the threads are started, even if an exception was "
"raised; an example would be :meth:`threading.Event.set`. ``start_threads`` "
"will attempt to join the started threads upon exit."
msgstr ""
"啟動 *threads* 的上下文管理器，這是一個執行緒序列。 *unlock* 是在執行緒啟動後"
"呼叫的函式，即使引發例外也是如此；一個例子是 :meth:`threading.Event.set`。 "
"``start_threads`` 將嘗試在退出時加入已啟動的執行緒。"

#: ../../library/test.rst:1270
#, fuzzy
msgid ""
"Cleanup up threads not specified in *original_values*.  Designed to emit a "
"warning if a test leaves running threads in the background."
msgstr ""
"清理未在 *original_values* 中指定的執行緒。設計用於在測試在後台留下正在運行的"
"執行緒時發出警告。"

#: ../../library/test.rst:1276
#, fuzzy
msgid "Return current thread count and copy of dangling threads."
msgstr "回傳當前執行緒數和懸掛執行緒的副本。"

#: ../../library/test.rst:1281
#, fuzzy
msgid ""
"Context manager to wait until all threads created in the ``with`` statement "
"exit."
msgstr "上下文管理器等待，直到在 ``with`` 語句中建立的所有執行緒退出。"

#: ../../library/test.rst:1287
#, fuzzy
msgid ""
"Context manager catching :class:`threading.Thread` exception using :func:"
"`threading.excepthook`."
msgstr "上下文管理器使用 threading.excepthook 捕獲 threading.Thread 例外。"

#: ../../library/test.rst:1290
#, fuzzy
msgid "Attributes set when an exception is caught:"
msgstr "捕獲例外時設定的屬性："

#: ../../library/test.rst:1292
msgid "``exc_type``"
msgstr "``exc_type``"

#: ../../library/test.rst:1293
msgid "``exc_value``"
msgstr "``exc_value``"

#: ../../library/test.rst:1294
msgid "``exc_traceback``"
msgstr "``exc_traceback``"

#: ../../library/test.rst:1295
msgid "``thread``"
msgstr "``thread``"

#: ../../library/test.rst:1297
msgid "See :func:`threading.excepthook` documentation."
msgstr "參閱 :func:`threading.excepthook` 文件。"

#: ../../library/test.rst:1299
#, fuzzy
msgid "These attributes are deleted at the context manager exit."
msgstr "這些屬性在上下文管理器出口處被刪除。"

#: ../../library/test.rst:1319
#, fuzzy
msgid ":mod:`test.support.os_helper` --- Utilities for os tests"
msgstr ":mod:`test.support.os_helper` --- 操作系統測試的實用程式"

#: ../../library/test.rst:1324
#, fuzzy
msgid "The :mod:`test.support.os_helper` module provides support for os tests."
msgstr ":mod:`test.support.os_helper` 模組提供對操作系統測試的支援。"

#: ../../library/test.rst:1331
#, fuzzy
msgid "A non-ASCII character encodable by :func:`os.fsencode`."
msgstr "可由 os.fsencode 編碼的非 ASCII 字元。"

#: ../../library/test.rst:1336
#, fuzzy
msgid "Set to :func:`os.getcwd`."
msgstr "設定為 :func:`os.getcwd`。"

#: ../../library/test.rst:1341
#, fuzzy
msgid ""
"Set to a name that is safe to use as the name of a temporary file.  Any "
"temporary file that is created should be closed and unlinked (removed)."
msgstr ""
"設定為可以安全用作臨時文件名稱的名稱。應關閉並取消鏈接（刪除）建立的任何臨時"
"文件。"

#: ../../library/test.rst:1347
#, fuzzy
msgid ""
"Set to a filename containing the :data:`FS_NONASCII` character, if it "
"exists. This guarantees that if the filename exists, it can be encoded and "
"decoded with the default filesystem encoding. This allows tests that require "
"a non-ASCII filename to be easily skipped on platforms where they can't work."
msgstr ""
"設定為包含 :data:`FS_NONASCII` 字元的文件名（如果存在）。這保證瞭如果文件名存"
"在，它可以使用預設的文件系統編碼進行編碼和解碼。這使得需要非 ASCII 文件名的測"
"試可以在無法運行的平台上輕鬆跳過。"

#: ../../library/test.rst:1355
#, fuzzy
msgid ""
"Set to a filename (str type) that should not be able to be encoded by file "
"system encoding in strict mode.  It may be ``None`` if it's not possible to "
"generate such a filename."
msgstr ""
"設定為一個文件名（str 型別），該文件名在嚴格模式下不應被文件系統編碼編碼。如"
"果不可能生成這樣的文件名，它可能是 ``None`` 。"

#: ../../library/test.rst:1362
#, fuzzy
msgid ""
"Set to a filename (bytes type) that should not be able to be decoded by file "
"system encoding in strict mode.  It may be ``None`` if it's not possible to "
"generate such a filename."
msgstr ""
"設定為在嚴格模式下不應被文件系統編碼解碼的文件名（位元組型別）。如果不可能生"
"成這樣的文件名，它可能是 ``None`` 。"

#: ../../library/test.rst:1369
#, fuzzy
msgid "Set to a non-ASCII name for a temporary file."
msgstr "設定為臨時文件的非 ASCII 名稱。"

#: ../../library/test.rst:1374
#, fuzzy
msgid ""
"Class used to temporarily set or unset environment variables.  Instances can "
"be used as a context manager and have a complete dictionary interface for "
"querying/modifying the underlying ``os.environ``. After exit from the "
"context manager all changes to environment variables done through this "
"instance will be rolled back."
msgstr ""
"用於臨時設定或取消設定環境變數的類。實例可以用作上下文管理器，並具有用於查詢/"
"修改底層“os.environ”的完整字典介面。退出上下文管理器後，通過此實例對環境變數"
"所做的所有更改都將回滾。"

#: ../../library/test.rst:1380
#, fuzzy
msgid "Added dictionary interface."
msgstr "新增詞典界面。"

#: ../../library/test.rst:1386
#, fuzzy
msgid ""
"Simple :term:`path-like object`.  It implements the :meth:`__fspath__` "
"method which just returns the *path* argument.  If *path* is an exception, "
"it will be raised in :meth:`!__fspath__`."
msgstr ""
"簡單 :term:`類似路徑的物件`。它實作了 :meth:`__fspath__` 方法，該方法只回傳 "
"*path* 參數。如果 *path* 是一個例外，它將在 :meth:`!__fspath__` 中被引發。"

#: ../../library/test.rst:1393
#, fuzzy
msgid ""
"Temporarily set the environment variable ``envvar`` to the value of "
"``value``."
msgstr "暫時將環境變數 ``envvar`` 設定為 ``value`` 的值。"

#: ../../library/test.rst:1399
#, fuzzy
msgid "Temporarily unset the environment variable ``envvar``."
msgstr "暫時取消設定環境變數 ``envvar``。"

#: ../../library/test.rst:1404
#, fuzzy
msgid "Return ``True`` if the OS supports symbolic links, ``False`` otherwise."
msgstr "如果操作系統支援符號鏈接，則回傳 ``True``，否則回傳 ``False``。"

#: ../../library/test.rst:1410
#, fuzzy
msgid "Return ``True`` if the OS supports xattr, ``False`` otherwise."
msgstr "如果操作系統支援 xattr，則回傳 ``True``，否則回傳 ``False``。"

#: ../../library/test.rst:1416
#, fuzzy
msgid ""
"A context manager that temporarily changes the current working directory to "
"*path* and yields the directory."
msgstr "臨時將當前工作目錄更改為 *path* 並生成目錄的上下文管理器。"

#: ../../library/test.rst:1419
#, fuzzy
msgid ""
"If *quiet* is ``False``, the context manager raises an exception on error.  "
"Otherwise, it issues only a warning and keeps the current working directory "
"the same."
msgstr ""
"如果 *quiet* 為 ``False``，則上下文管理器會在出錯時引發例外。否則，它只會發出"
"警告並保持當前工作目錄不變。"

#: ../../library/test.rst:1426
#, fuzzy
msgid ""
"Create an empty file with *filename*.  If it already exists, truncate it."
msgstr "使用 *filename* 建立一個空文件。如果它已經存在，則將其截斷。"

#: ../../library/test.rst:1431
#, fuzzy
msgid "Count the number of open file descriptors."
msgstr "計算打開的文件描述器的數量。"

#: ../../library/test.rst:1436
#, fuzzy
msgid "Return ``True`` if the file system for *directory* is case-insensitive."
msgstr "如果 *directory* 的文件系統不區分大小寫，則回傳 ``True``。"

#: ../../library/test.rst:1441
#, fuzzy
msgid ""
"Create an invalid file descriptor by opening and closing a temporary file, "
"and returning its descriptor."
msgstr "通過打開和關閉臨時文件並回傳其描述器來建立無效的文件描述器。"

#: ../../library/test.rst:1447
#, fuzzy
msgid ""
"Call :func:`os.rmdir` on *filename*.  On Windows platforms, this is wrapped "
"with a wait loop that checks for the existence of the file, which is needed "
"due to antivirus programs that can hold files open and prevent deletion."
msgstr ""
"在 *filename* 上呼叫 :func:`os.rmdir`。在 Windows 平台上，這包含一個等待循"
"環，用於檢查文件是否存在，這是必需的，因為防病毒程式可以保持文件打開並防止刪"
"除。"

#: ../../library/test.rst:1455
#, fuzzy
msgid ""
"Call :func:`shutil.rmtree` on *path* or call :func:`os.lstat` and :func:`os."
"rmdir` to remove a path and its contents.  As with :func:`rmdir`, on Windows "
"platforms this is wrapped with a wait loop that checks for the existence of "
"the files."
msgstr ""
"在 *path* 上呼叫 :func:`shutil.rmtree` 或呼叫 :func:`os.lstat` 和 :func:`os."
"rmdir` 來刪除路徑及其內容。與 :func:`rmdir` 一樣，在 Windows 平台上，它包含一"
"個等待循環，用於檢查文件是否存在。"

#: ../../library/test.rst:1463
#, fuzzy
msgid "A decorator for running tests that require support for symbolic links."
msgstr "用於運行需要支援符號鏈接的測試的裝飾器。"

#: ../../library/test.rst:1468
#, fuzzy
msgid "A decorator for running tests that require support for xattr."
msgstr "用於運行需要 xattr 支援的測試的裝飾器。"

#: ../../library/test.rst:1473
#, fuzzy
msgid ""
"A context manager that temporarily creates a new directory and changes the "
"current working directory (CWD)."
msgstr "臨時建立新目錄並更改當前工作目錄 (CWD) 的上下文管理器。"

#: ../../library/test.rst:1476
#, fuzzy
msgid ""
"The context manager creates a temporary directory in the current directory "
"with name *name* before temporarily changing the current working directory.  "
"If *name* is ``None``, the temporary directory is created using :func:"
"`tempfile.mkdtemp`."
msgstr ""
"在臨時更改當前工作目錄之前，上下文管理器在當前目錄中建立一個名為 *name* 的臨"
"時目錄。如果 *name* 是 ``None``，則使用 :func:`tempfile.mkdtemp` 建立臨時目"
"錄。"

#: ../../library/test.rst:1481
#, fuzzy
msgid ""
"If *quiet* is ``False`` and it is not possible to create or change the CWD, "
"an error is raised.  Otherwise, only a warning is raised and the original "
"CWD is used."
msgstr ""
"如果 *quiet* 為 ``False``並且無法建立或更改 CWD，則會引發錯誤。否則，只會發出"
"警告並使用原始 CWD。"

#: ../../library/test.rst:1488
#, fuzzy
msgid ""
"A context manager that creates a temporary directory at *path* and yields "
"the directory."
msgstr "在 *path* 處建立臨時目錄並生成目錄的上下文管理器。"

#: ../../library/test.rst:1491
#, fuzzy
msgid ""
"If *path* is ``None``, the temporary directory is created using :func:"
"`tempfile.mkdtemp`.  If *quiet* is ``False``, the context manager raises an "
"exception on error.  Otherwise, if *path* is specified and cannot be "
"created, only a warning is issued."
msgstr ""
"如果 *path* 為 ``None``，則使用 :func:`tempfile.mkdtemp` 建立臨時目錄。如果 "
"*quiet* 為 ``False``，則上下文管理器會在出錯時引發例外。否則，如果指定了 "
"*path* 但無法建立，則只會發出警告。"

#: ../../library/test.rst:1499
#, fuzzy
msgid "A context manager that temporarily sets the process umask."
msgstr "臨時設定行程 umask 的上下文管理器。"

#: ../../library/test.rst:1504
#, fuzzy
msgid ""
"Call :func:`os.unlink` on *filename*.  As with :func:`rmdir`, on Windows "
"platforms, this is wrapped with a wait loop that checks for the existence of "
"the file."
msgstr ""
"在 *filename* 上呼叫 :func:`os.unlink`。與 :func:`rmdir` 一樣，在 Windows 平"
"台上，它包含一個檢查文件是否存在的等待循環。"

#: ../../library/test.rst:1510
#, fuzzy
msgid ":mod:`test.support.import_helper` --- Utilities for import tests"
msgstr ":mod:`test.support.import_helper` --- 用於導入測試的實用程式"

#: ../../library/test.rst:1515
#, fuzzy
msgid ""
"The :mod:`test.support.import_helper` module provides support for import "
"tests."
msgstr ":mod:`test.support.import_helper` 模組提供對導入測試的支援。"

#: ../../library/test.rst:1522
#, fuzzy
msgid ""
"Remove the module named *module_name* from ``sys.modules`` and delete any "
"byte-compiled files of the module."
msgstr ""
"從 sys.modules 中刪除名為 *module_name* 的模組，並刪除該模組的任何位元組編譯"
"文件。"

#: ../../library/test.rst:1528
#, fuzzy
msgid ""
"This function imports and returns a fresh copy of the named Python module by "
"removing the named module from ``sys.modules`` before doing the import. Note "
"that unlike :func:`reload`, the original module is not affected by this "
"operation."
msgstr ""
"此函式通過在導入之前從“sys.modules”中刪除命名模組來導入並回傳命名 Python 模組"
"的新副本。請注意，與 :func:`reload` 不同，原始模組不受此操作的影響。"

#: ../../library/test.rst:1533
#, fuzzy
msgid ""
"*fresh* is an iterable of additional module names that are also removed from "
"the ``sys.modules`` cache before doing the import."
msgstr ""
"*fresh* 是附加模組名稱的可疊代，這些名稱在執行導入之前也從 ``sys.modules`` 快"
"取中刪除。"

#: ../../library/test.rst:1536
#, fuzzy
msgid ""
"*blocked* is an iterable of module names that are replaced with ``None`` in "
"the module cache during the import to ensure that attempts to import them "
"raise :exc:`ImportError`."
msgstr ""
"*blocked* 是一個可疊代的模組名稱，在導入期間在模組快取中被替換為 ``None``，以"
"確保嘗試導入它們會引發 :exc:`ImportError`。"

#: ../../library/test.rst:1540
#, fuzzy
msgid ""
"The named module and any modules named in the *fresh* and *blocked* "
"parameters are saved before starting the import and then reinserted into "
"``sys.modules`` when the fresh import is complete."
msgstr ""
"命名模組和在 *fresh* 和 *blocked* 參數中命名的任何模組在開始導入之前保存，然"
"後在新導入完成時重新插入到 ``sys.modules`` 中。"

#: ../../library/test.rst:1544
#, fuzzy
msgid ""
"Module and package deprecation messages are suppressed during this import if "
"*deprecated* is ``True``."
msgstr ""
"如果 *deprecated* 為 ``True``，模組和包的棄用消息將在此導入期間被抑制。"

#: ../../library/test.rst:1547
#, fuzzy
msgid ""
"This function will raise :exc:`ImportError` if the named module cannot be "
"imported."
msgstr "如果無法導入命名模組，此函式將引發 :exc:`ImportError`。"

#: ../../library/test.rst:1564
#, fuzzy
msgid ""
"This function imports and returns the named module. Unlike a normal import, "
"this function raises :exc:`unittest.SkipTest` if the module cannot be "
"imported."
msgstr ""
"此函式導入並回傳命名模組。與普通導入不同，如果無法導入模組，此函式會引發："
"exc:`unittest.SkipTest`。"

#: ../../library/test.rst:1568
#, fuzzy
msgid ""
"Module and package deprecation messages are suppressed during this import if "
"*deprecated* is ``True``.  If a module is required on a platform but "
"optional for others, set *required_on* to an iterable of platform prefixes "
"which will be compared against :data:`sys.platform`."
msgstr ""
"如果 *deprecated* 為 ``True``，模組和包的棄用消息將在此導入期間被抑制。如果一"
"個模組在平台上是必需的，但對其他平台是可選的，請將 *required_on* 設定為平台前"
"綴的可疊代物件，它將與 :data:`sys.platform` 進行比較。"

#: ../../library/test.rst:1578
#, fuzzy
msgid "Return a copy of :data:`sys.modules`."
msgstr "回傳 :data:`sys.modules` 的副本。"

#: ../../library/test.rst:1583
#, fuzzy
msgid ""
"Remove modules except for *oldmodules* and ``encodings`` in order to "
"preserve internal cache."
msgstr "刪除除 *oldmodules* 和 ``encodings`` 之外的模組以保留內部快取。"

#: ../../library/test.rst:1589
#, fuzzy
msgid "Delete *name* from ``sys.modules``."
msgstr "從 ``sys.modules`` 中刪除 *name*。"

#: ../../library/test.rst:1594
#, fuzzy
msgid ""
"Move a :pep:`3147`/:pep:`488` pyc file to its legacy pyc location and return "
"the file system path to the legacy pyc file.  The *source* value is the file "
"system path to the source file.  It does not need to exist, however the PEP "
"3147/488 pyc file must exist."
msgstr ""
"將 :pep:`3147`/:pep:`488` pyc 文件移動到其舊版 pyc 位置，並將文件系統路徑回傳"
"到舊版 pyc 文件。 *source* 值是源文件的文件系統路徑。它不需要存在，但是 PEP "
"3147/488 pyc 文件必須存在。"

#: ../../library/test.rst:1602
#, fuzzy
msgid ""
"A context manager to force import to return a new module reference.  This is "
"useful for testing module-level behaviors, such as the emission of a :exc:"
"`DeprecationWarning` on import.  Example usage::"
msgstr ""
"強制導入以回傳新模組引用的上下文管理器。這對於測試模組級行為很有用，例如在導"
"入時發出 DeprecationWarning。用法示例::"

#: ../../library/test.rst:1612
#, fuzzy
msgid "A context manager to temporarily add directories to :data:`sys.path`."
msgstr "臨時將目錄新增到 :data:`sys.path` 的上下文管理器。"

#: ../../library/test.rst:1614
#, fuzzy
msgid ""
"This makes a copy of :data:`sys.path`, appends any directories given as "
"positional arguments, then reverts :data:`sys.path` to the copied settings "
"when the context ends."
msgstr ""
"這會製作 :data:`sys.path` 的副本，附加任何作為位置參數給出的目錄，然後在上下"
"文結束時將 :data:`sys.path` 恢復為複制的設定。"

#: ../../library/test.rst:1618
#, fuzzy
msgid ""
"Note that *all* :data:`sys.path` modifications in the body of the context "
"manager, including replacement of the object, will be reverted at the end of "
"the block."
msgstr ""
"請注意，上下文管理器主體中的 *所有* :data:`sys.path` 修改，包括物件的替換，將"
"在塊的末尾恢復。"

#: ../../library/test.rst:1624
#, fuzzy
msgid ":mod:`test.support.warnings_helper` --- Utilities for warnings tests"
msgstr ":mod:`test.support.warnings_helper` --- 警告測試實用程式"

#: ../../library/test.rst:1629
#, fuzzy
msgid ""
"The :mod:`test.support.warnings_helper` module provides support for warnings "
"tests."
msgstr ":mod:`test.support.warnings_helper` 模組提供對警告測試的支援。"

#: ../../library/test.rst:1636
#, fuzzy
msgid ""
"Suppress warnings that are instances of *category*, which must be :exc:"
"`Warning` or a subclass. Roughly equivalent to :func:`warnings."
"catch_warnings` with :meth:`warnings.simplefilter('ignore', "
"category=category) <warnings.simplefilter>`. For example::"
msgstr ""
"禁止作為 *category* 實例的警告，它必須是 :exc:`Warning` 或子類別。大致相當"
"於 :func:`warnings.catch_warnings` 和 :meth:`warnings.simplefilter('ignore', "
"category=category) <warnings.simplefilter>`。例如：："

#: ../../library/test.rst:1651
#, fuzzy
msgid ""
"Context manager to check that no :exc:`ResourceWarning` was raised.  You "
"must remove the object which may emit :exc:`ResourceWarning` before the end "
"of the context manager."
msgstr ""
"上下文管理器檢查是否沒有引發 ResourceWarning。您必須在上下文管理器結束之前刪"
"除可能發出 ResourceWarning 的物件。"

#: ../../library/test.rst:1658
#, fuzzy
msgid ""
"Test for syntax warning in *statement* by attempting to compile *statement*. "
"Test also that the :exc:`SyntaxWarning` is emitted only once, and that it "
"will be converted to a :exc:`SyntaxError` when turned into error. *testcase* "
"is the :mod:`unittest` instance for the test.  *errtext* is the regular "
"expression which should match the string representation of the emitted :exc:"
"`SyntaxWarning` and raised :exc:`SyntaxError`.  If *lineno* is not ``None``, "
"compares to the line of the warning and exception. If *offset* is not "
"``None``, compares to the offset of the exception."
msgstr ""
"通過嘗試編譯 *statement* 來測試 *statement* 中的語法警告。還要測試 :exc:"
"`SyntaxWarning` 僅發出一次，並且在變為錯誤時將轉換為 :exc:`SyntaxError`。 "
"*testcase* 是用於測試的 :mod:`unittest` 實例。 *errtext* 是正則表達式，它應該"
"匹配發出的字串表示 :exec:`SyntaxWarning` 和引發的 :exec:`SyntaxError`。如果 "
"*lineno* 不是 ``None`` ，則與警告和例外行進行比較。如果 *offset* 不是 "
"``None``，則與例外的偏移量進行比較。"

#: ../../library/test.rst:1672
#, fuzzy
msgid ""
"A convenience wrapper for :func:`warnings.catch_warnings()` that makes it "
"easier to test that a warning was correctly raised.  It is approximately "
"equivalent to calling ``warnings.catch_warnings(record=True)`` with :meth:"
"`warnings.simplefilter` set to ``always`` and with the option to "
"automatically validate the results that are recorded."
msgstr ""
":func:`warnings.catch_warnings()` 的便利包裝器，可以更輕鬆地測試警告是否已正"
"確發出。它大致相當於呼叫 ``warnings.catch_warnings(record=True)`` 並將 :meth:"
"`warnings.simplefilter` 設定為 ``always`` 並帶有自動驗證記錄結果的選項。"

#: ../../library/test.rst:1678
#, fuzzy
msgid ""
"``check_warnings`` accepts 2-tuples of the form ``(\"message regexp\", "
"WarningCategory)`` as positional arguments. If one or more *filters* are "
"provided, or if the optional keyword argument *quiet* is ``False``, it "
"checks to make sure the warnings are as expected:  each specified filter "
"must match at least one of the warnings raised by the enclosed code or the "
"test fails, and if any warnings are raised that do not match any of the "
"specified filters the test fails.  To disable the first of these checks, set "
"*quiet* to ``True``."
msgstr ""
"``check_warnings`` 接受形式為 ``(\"message regexp\", WarningCategory)`` 的二"
"元組作為位置參數。如果提供了一個或多個 *filters*，或者如果可選關鍵字參數 "
"*quiet* 為 ``False``，它會檢查以確保警告符合預期：每個指定的過濾器必須至少匹"
"配由隨附的程式碼或測試失敗，如果發出任何與任何指定過濾器不匹配的警告，則測試"
"失敗。要禁用這些檢查中的第一項，請將 *quiet* 設定為 ``True``。"

#: ../../library/test.rst:1687
#, fuzzy
msgid "If no arguments are specified, it defaults to::"
msgstr "如果未指定參數，則預設為 ::"

#: ../../library/test.rst:1691
#, fuzzy
msgid "In this case all warnings are caught and no errors are raised."
msgstr "在這種情況下，所有警告都會被捕獲並且不會引發任何錯誤。"

#: ../../library/test.rst:1693
#, fuzzy
msgid ""
"On entry to the context manager, a :class:`WarningRecorder` instance is "
"returned. The underlying warnings list from :func:`~warnings.catch_warnings` "
"is available via the recorder object's :attr:`warnings` attribute.  As a "
"convenience, the attributes of the object representing the most recent "
"warning can also be accessed directly through the recorder object (see "
"example below).  If no warning has been raised, then any of the attributes "
"that would otherwise be expected on an object representing a warning will "
"return ``None``."
msgstr ""
"在進入上下文管理器時，回傳一個 :class:`WarningRecorder` 實例。來自 :func:"
"`~warnings.catch_warnings` 的底層警告列表可通過記錄器物件的 :attr:`warnings` "
"屬性獲得。為方便起見，表示最近警告的物件的屬性也可以通過記錄器物件直接訪問"
"（參見下面的示例）。如果沒有發出警告，那麼表示警告的對像上預期的任何屬性都將"
"回傳 ``None`` 。"

#: ../../library/test.rst:1702
#, fuzzy
msgid ""
"The recorder object also has a :meth:`reset` method, which clears the "
"warnings list."
msgstr "記錄器對像還有一個 :meth:`reset` 方法，用於清除警告列表。"

#: ../../library/test.rst:1705
#, fuzzy
msgid "The context manager is designed to be used like this::"
msgstr "上下文管理器旨在像這樣使用::"

#: ../../library/test.rst:1712
#, fuzzy
msgid ""
"In this case if either warning was not raised, or some other warning was "
"raised, :func:`check_warnings` would raise an error."
msgstr ""
"在這種情況下，如果沒有發出警告，或者發出了其他警告，:func:`check_warnings` 將"
"引發錯誤。"

#: ../../library/test.rst:1715
#, fuzzy
msgid ""
"When a test needs to look more deeply into the warnings, rather than just "
"checking whether or not they occurred, code like this can be used::"
msgstr ""
"當測試需要更深入地查看警告，而不是僅僅檢查警告是否發生時，可以使用如下程式"
"碼："

#: ../../library/test.rst:1729
#, fuzzy
msgid ""
"Here all warnings will be caught, and the test code tests the captured "
"warnings directly."
msgstr "這裡會捕獲所有的警告，測試程式碼直接對捕獲的警告進行測試。"

#: ../../library/test.rst:1732
#, fuzzy
msgid "New optional arguments *filters* and *quiet*."
msgstr "新的可選參數 *filters* 和 *quiet*。"

#: ../../library/test.rst:1738
#, fuzzy
msgid ""
"Class used to record warnings for unit tests. See documentation of :func:"
"`check_warnings` above for more details."
msgstr ""
"用於記錄單元測試警告的類。有關詳細資訊，請參閱上面的 :func:`check_warnings` "
"文檔。"
