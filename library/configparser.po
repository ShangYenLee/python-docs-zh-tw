# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-17 00:18+0000\n"
"PO-Revision-Date: 2018-05-23 14:41+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/configparser.rst:2
msgid ":mod:`configparser` --- Configuration file parser"
msgstr ":mod:`configparser` --- 配置檔案剖析器"

#: ../../library/configparser.rst:14
msgid "**Source code:** :source:`Lib/configparser.py`"
msgstr "**原始碼：**\\ :source:`Lib/configparser.py`"

#: ../../library/configparser.rst:24
#, fuzzy
msgid ""
"This module provides the :class:`ConfigParser` class which implements a "
"basic configuration language which provides a structure similar to what's "
"found in Microsoft Windows INI files.  You can use this to write Python "
"programs which can be customized by end users easily."
msgstr ""
"該模組提供了 ConfigParser 類，該類實作了一種基本配置語言，該語言提供了類似於 "
"Microsoft Windows INI 文件中的結構。"
"您可以使用它來編寫最終使用者可以輕鬆自定義的 Python 程式。"

#: ../../library/configparser.rst:31
#, fuzzy
msgid ""
"This library does *not* interpret or write the value-type prefixes used in "
"the Windows Registry extended version of INI syntax."
msgstr "此庫 *不* 解釋或寫入 INI 語法的 Windows 註冊表擴充版本中使用的值型別前綴。"

#: ../../library/configparser.rst:38
msgid "Module :mod:`tomllib`"
msgstr ":mod:`tomllib` 模組"

#: ../../library/configparser.rst:37
#, fuzzy
msgid ""
"TOML is a well-specified format for application configuration files. It is "
"specifically designed to be an improved version of INI."
msgstr "TOML 是應用程式配置文件的一種明確指定的格式。它專門設計為 INI 的改進版本。"

#: ../../library/configparser.rst:42
msgid "Module :mod:`shlex`"
msgstr ":mod:`shlex` 模組"

#: ../../library/configparser.rst:41
#, fuzzy
msgid ""
"Support for creating Unix shell-like mini-languages which can also be used "
"for application configuration files."
msgstr "支援建立類似 Unix shell 的迷你語言，這些語言也可用於應用程式配置文件。"

#: ../../library/configparser.rst:45
msgid "Module :mod:`json`"
msgstr ":mod:`json` 模組"

#: ../../library/configparser.rst:45
#, fuzzy
msgid ""
"The ``json`` module implements a subset of JavaScript syntax which is "
"sometimes used for configuration, but does not support comments."
msgstr "``json`` 模組實作了 JavaScript 語法的一個子集，有時用於配置，但不支援註釋。"

#: ../../library/configparser.rst:60
msgid "Quick Start"
msgstr "快速開始"

#: ../../library/configparser.rst:62
#, fuzzy
msgid "Let's take a very basic configuration file that looks like this:"
msgstr "讓我們來看一個非常基本的配置文件，如下所示："

#: ../../library/configparser.rst:79
#, fuzzy
msgid ""
"The structure of INI files is described `in the following section "
"<#supported-ini-file-structure>`_.  Essentially, the file consists of "
"sections, each of which contains keys with values. :mod:`configparser` "
"classes can read and write such files.  Let's start by creating the above "
"configuration file programmatically."
msgstr ""
"INI 文件的結構在以下部分 <#supported-ini-file-structure> "
"中描述。本質上，該文件由部分組成，每個部分都包含帶有值的鍵。 "
":mod:`configparser` "
"類可以讀取和寫入此類文件。讓我們從以編程方式建立上述配置文件開始。"

#: ../../library/configparser.rst:103
#, fuzzy
msgid ""
"As you can see, we can treat a config parser much like a dictionary. There "
"are differences, `outlined later <#mapping-protocol-access>`_, but the "
"behavior is very close to what you would expect from a dictionary."
msgstr ""
"如您所見，我們可以像對待字典一樣對待配置剖析器。存在差異，`稍後概述<#mapping-"
"protocol-access>`_，但行為非常接近您對字典的期望。"

#: ../../library/configparser.rst:107
#, fuzzy
msgid ""
"Now that we have created and saved a configuration file, let's read it back "
"and explore the data it holds."
msgstr "現在我們已經建立並保存了一個配置文件，讓我們回讀它並探索它包含的資料。"

#: ../../library/configparser.rst:142
#, fuzzy
msgid ""
"As we can see above, the API is pretty straightforward.  The only bit of "
"magic involves the ``DEFAULT`` section which provides default values for all "
"other sections [1]_.  Note also that keys in sections are case-insensitive "
"and stored in lowercase [1]_."
msgstr ""
"正如我們在上面看到的，API 非常簡單。唯一的魔力涉及 ``DEFAULT`` 部分，"
"它為所有其他部分 [1]_ 提供預設值。另請注意，部分中的鍵不區分大小寫，"
"並以小寫字母 [1]_ 儲存。"

#: ../../library/configparser.rst:147
#, fuzzy
msgid ""
"It is possible to read several configurations into a single :class:"
"`ConfigParser`, where the most recently added configuration has the highest "
"priority. Any conflicting keys are taken from the more recent configuration "
"while the previously existing keys are retained."
msgstr ""
"可以將多個配置讀取到一個 ConfigParser 中，其中最近新增的配置具有最高優先級。"
"任何衝突的密鑰都取自更新的配置，同時保留以前存在的密鑰。"

#: ../../library/configparser.rst:168
#, fuzzy
msgid ""
"This behaviour is equivalent to a :meth:`ConfigParser.read` call with "
"several files passed to the *filenames* parameter."
msgstr "此行為等效於將多個文件傳遞給 *filenames* 參數的 ConfigParser.read 呼叫。"

#: ../../library/configparser.rst:173
#, fuzzy
msgid "Supported Datatypes"
msgstr "支援的資料型別"

#: ../../library/configparser.rst:175
#, fuzzy
msgid ""
"Config parsers do not guess datatypes of values in configuration files, "
"always storing them internally as strings.  This means that if you need "
"other datatypes, you should convert on your own:"
msgstr "配置剖析器不會猜測配置文件中值的資料型別，總是在內部將它們儲存為字串。這意味"
"著如果你需要其他資料型別，你應該自己轉換："

#: ../../library/configparser.rst:186
#, fuzzy
msgid ""
"Since this task is so common, config parsers provide a range of handy getter "
"methods to handle integers, floats and booleans.  The last one is the most "
"interesting because simply passing the value to ``bool()`` would do no good "
"since ``bool('False')`` is still ``True``.  This is why config parsers also "
"provide :meth:`~ConfigParser.getboolean`.  This method is case-insensitive "
"and recognizes Boolean values from ``'yes'``/``'no'``, ``'on'``/``'off'``, "
"``'true'``/``'false'`` and ``'1'``/``'0'`` [1]_.  For example:"
msgstr ""
"由於這個任務很常見，配置剖析器提供了一系列方便的 getter "
"方法來處理整數、浮點數和布爾值。最後一個是最有趣的，因為簡單地將值傳遞給 "
"``bool()`` 不會有任何好處，因為 ``bool('False')`` 仍然是 ``True``。"
"這就是配置剖析器還提供 :meth:`~ConfigParser.getboolean` 的原因。此方法不區分"
"大小寫，並從 ``是``/ ``否``、 ``開``/ ``關``、 ``True``中識別布爾值/``'false'`` 和 "
"``'1'``/``'0'`` [1]_。例如："

#: ../../library/configparser.rst:203
#, fuzzy
msgid ""
"Apart from :meth:`~ConfigParser.getboolean`, config parsers also provide "
"equivalent :meth:`~ConfigParser.getint` and :meth:`~ConfigParser.getfloat` "
"methods.  You can register your own converters and customize the provided "
"ones. [1]_"
msgstr ""
"除了 :meth:`~ConfigParser.getboolean` 之外，配置剖析器還提供等效的 "
":meth:`~ConfigParser.getint` 和 :meth:`~ConfigParser.getfloat` "
"方法。您可以註冊自己的轉換器並自定義提供的轉換器。 [1]_"

#: ../../library/configparser.rst:209
#, fuzzy
msgid "Fallback Values"
msgstr "回退值"

#: ../../library/configparser.rst:211
#, fuzzy
msgid ""
"As with a dictionary, you can use a section's :meth:`get` method to provide "
"fallback values:"
msgstr "與字典一樣，您可以使用部分的 :meth:`get` 方法來提供備用值："

#: ../../library/configparser.rst:224
#, fuzzy
msgid ""
"Please note that default values have precedence over fallback values. For "
"instance, in our example the ``'CompressionLevel'`` key was specified only "
"in the ``'DEFAULT'`` section.  If we try to get it from the section "
"``'topsecret.server.example'``, we will always get the default, even if we "
"specify a fallback:"
msgstr ""
"請注意，預設值優先於後備值。例如，在我們的示例中， ``CompressionLevel`` 鍵僅在“DE"
"FAULT”部分中指定。如果我們嘗試從“topsecret.server."
"example”部分獲取它，我們將始終獲得預設值，即使我們指定了回退："

#: ../../library/configparser.rst:235
#, fuzzy
msgid ""
"One more thing to be aware of is that the parser-level :meth:`get` method "
"provides a custom, more complex interface, maintained for backwards "
"compatibility.  When using this method, a fallback value can be provided via "
"the ``fallback`` keyword-only argument:"
msgstr ""
"需要注意的另一件事是剖析器級別的 get 方法提供了一個自定義的、更複雜的介面，為"
"向後相容而維護。使用此方法時，可以通過 ``fallback`` 關鍵字參數提供回退值："

#: ../../library/configparser.rst:246
#, fuzzy
msgid ""
"The same ``fallback`` argument can be used with the :meth:`~ConfigParser."
"getint`, :meth:`~ConfigParser.getfloat` and :meth:`~ConfigParser.getboolean` "
"methods, for example:"
msgstr ""
"相同的 ``fallback`` 參數可以與 :meth:`~ConfigParser."
"getint`、:meth:`~ConfigParser.getfloat` 和 :meth:`~ConfigParser.getboolean` "
"方法一起使用，例如："

#: ../../library/configparser.rst:262
#, fuzzy
msgid "Supported INI File Structure"
msgstr "支援的 INI 文件結構"

#: ../../library/configparser.rst:264
#, fuzzy
msgid ""
"A configuration file consists of sections, each led by a ``[section]`` "
"header, followed by key/value entries separated by a specific string (``=`` "
"or ``:`` by default [1]_).  By default, section names are case sensitive but "
"keys are not [1]_.  Leading and trailing whitespace is removed from keys and "
"values. Values can be omitted if the parser is configured to allow it [1]_, "
"in which case the key/value delimiter may also be left out.  Values can also "
"span multiple lines, as long as they are indented deeper than the first line "
"of the value.  Depending on the parser's mode, blank lines may be treated as "
"parts of multiline values or ignored."
msgstr ""
"配置文件由部分組成，每個部分由一個“[section]”標題引導，後跟由特定字串分隔的鍵"
"/值條目（預設情況下為 ``=``或 ``:``[1]_） .預設情況下，部分名稱區分大小寫，"
"但鍵不是 [1]_。從鍵和值中刪除前導和尾隨空格。如果剖析器配置為允許 [1]_，則可"
"以省略值，在這種情況下，也可以省略鍵/值定界符。值也可以跨越多行，只要它們比值"
"的第一行縮進得更深。根據剖析器的模式，空白行可能被視為多行值的一部分或被忽略"
"。"

#: ../../library/configparser.rst:274
#, fuzzy
msgid ""
"By default,  a valid section name can be any string that does not contain '\\"
"\\n' or ']'. To change this, see :attr:`ConfigParser.SECTCRE`."
msgstr ""
"預設情況下，有效的節名可以是任何不包含“\\\\n"
"”或 ``]``的字串。要更改此設定，請參閱 :attr:`ConfigParser.SECTCRE`。"

#: ../../library/configparser.rst:277
#, fuzzy
msgid ""
"Configuration files may include comments, prefixed by specific characters "
"(``#`` and ``;`` by default [1]_).  Comments may appear on their own on an "
"otherwise empty line, possibly indented. [1]_"
msgstr "配置文件可能包含註釋，以特定字元為前綴（預設情況下為 ``#``和 ``;``[1]_）。註釋可能"
"會單獨出現在空行中，可能會縮進。 [1]_"

#: ../../library/configparser.rst:281 ../../library/configparser.rst:344
msgid "For example:"
msgstr "例如："

#: ../../library/configparser.rst:329
#, fuzzy
msgid "Interpolation of values"
msgstr "值的插值"

#: ../../library/configparser.rst:331
#, fuzzy
msgid ""
"On top of the core functionality, :class:`ConfigParser` supports "
"interpolation.  This means values can be preprocessed before returning them "
"from ``get()`` calls."
msgstr "在核心功能之上，ConfigParser 支援插值。這意味著可以在從 get() "
"呼叫回傳值之前對其進行預處理。"

#: ../../library/configparser.rst:339
#, fuzzy
msgid ""
"The default implementation used by :class:`ConfigParser`.  It enables values "
"to contain format strings which refer to other values in the same section, "
"or values in the special default section [1]_.  Additional default values "
"can be provided on initialization."
msgstr ""
"ConfigParser "
"使用的預設實作。它使值能夠包含格式字串，這些格式字串引用同一部分中的其他值，"
"或特殊預設部分 [1]_ 中的值。可以在初始化時提供額外的預設值。"

#: ../../library/configparser.rst:357
#, fuzzy
msgid ""
"In the example above, :class:`ConfigParser` with *interpolation* set to "
"``BasicInterpolation()`` would resolve ``%(home_dir)s`` to the value of "
"``home_dir`` (``/Users`` in this case).  ``%(my_dir)s`` in effect would "
"resolve to ``/Users/lumberjack``.  All interpolations are done on demand so "
"keys used in the chain of references do not have to be specified in any "
"specific order in the configuration file."
msgstr ""
"在上面的示例中，*interpolation* 設定為 ``BasicInterpolation()`` 的 "
"ConfigParser 會將 ``%(home_dir)s`` 剖析為 ``home_dir`` 的值（``/Users` ` "
"在這種情況下）。 ``%(my_dir)s`` 實際上會剖析為 ``/Users/lumberjack``。所有插"
"值都是按需完成的，因此不必在配置文件中以任何特定順序指定引用鏈中使用的鍵。"

#: ../../library/configparser.rst:364
#, fuzzy
msgid ""
"With ``interpolation`` set to ``None``, the parser would simply return "
"``%(my_dir)s/Pictures`` as the value of ``my_pictures`` and ``%(home_dir)s/"
"lumberjack`` as the value of ``my_dir``."
msgstr ""
"將 ``interpolation`` 設定為 ``None``時，剖析器將簡單地回傳“%(my_dir)s/"
"Pictures”作為“my_pictures”和“%(home_dir)s/lumberjack”的值` 作為 ``my_dir`` "
"的值。"

#: ../../library/configparser.rst:372
#, fuzzy
msgid ""
"An alternative handler for interpolation which implements a more advanced "
"syntax, used for instance in ``zc.buildout``.  Extended interpolation is "
"using ``${section:option}`` to denote a value from a foreign section. "
"Interpolation can span multiple levels.  For convenience, if the ``section:"
"`` part is omitted, interpolation defaults to the current section (and "
"possibly the default values from the special section)."
msgstr ""
"用於實作更高階語法的插值的替代處理程式，例如在 ``zc.buildout`` 中使用。擴充插"
"值使用“${section:option}”來表示來自外部部分的值。插值可以跨越多個級別。為方便"
"起見，如果省略 ``section:`` "
"部分，則插值預設為當前部分（也可能是特殊部分的預設值）。"

#: ../../library/configparser.rst:379
#, fuzzy
msgid ""
"For example, the configuration specified above with basic interpolation, "
"would look like this with extended interpolation:"
msgstr "例如，上面使用基本插值指定的配置在使用擴充插值時看起來像這樣："

#: ../../library/configparser.rst:393
#, fuzzy
msgid "Values from other sections can be fetched as well:"
msgstr "也可以從其他部分獲取值："

#: ../../library/configparser.rst:415
#, fuzzy
msgid "Mapping Protocol Access"
msgstr "映射協定訪問"

#: ../../library/configparser.rst:419
#, fuzzy
msgid ""
"Mapping protocol access is a generic name for functionality that enables "
"using custom objects as if they were dictionaries.  In case of :mod:"
"`configparser`, the mapping interface implementation is using the "
"``parser['section']['option']`` notation."
msgstr ""
"映射協定訪問是功能的通用名稱，可以像使用字典一樣使用自定義物件。在 "
":mod:`configparser` 的情況下，映射介面實作使用 "
"``parser['section']['option']`` 表示法。"

#: ../../library/configparser.rst:424
#, fuzzy
msgid ""
"``parser['section']`` in particular returns a proxy for the section's data "
"in the parser.  This means that the values are not copied but they are taken "
"from the original parser on demand.  What's even more important is that when "
"values are changed on a section proxy, they are actually mutated in the "
"original parser."
msgstr ""
"``parser['section']`` 特別回傳剖析器中該部分資料的代理。這意味著這些值不會被"
"複製，而是根據需要從原始剖析器中獲取。更重要的是，當部分代理上的值發生變化時"
"，它們實際上在原始剖析器中發生了變化。"

#: ../../library/configparser.rst:430
#, fuzzy
msgid ""
":mod:`configparser` objects behave as close to actual dictionaries as "
"possible. The mapping interface is complete and adheres to the :class:"
"`~collections.abc.MutableMapping` ABC. However, there are a few differences "
"that should be taken into account:"
msgstr ""
":mod:`configparser` "
"物件的行為盡可能接近實際字典。映射介面是完整的，並遵守 :class:`~collections."
"abc.MutableMapping` ABC。但是，應考慮一些差異："

#: ../../library/configparser.rst:435
#, fuzzy
msgid ""
"By default, all keys in sections are accessible in a case-insensitive manner "
"[1]_.  E.g. ``for option in parser[\"section\"]`` yields only "
"``optionxform``'ed option key names.  This means lowercased keys by "
"default.  At the same time, for a section that holds the key ``'a'``, both "
"expressions return ``True``::"
msgstr ""
"預設情況下，部分中的所有鍵都可以以不區分大小寫的方式訪問 [1]_。例如。 ``for "
"option in parser[\"section\"]`` 僅產生 ``optionxform``\\'ed 選項鍵名稱。這意"
"味著預設情況下小寫的鍵。同時，對於包含鍵 ``a``的部分，兩個表達式都回傳 ``True``::"

#: ../../library/configparser.rst:443
#, fuzzy
msgid ""
"All sections include ``DEFAULTSECT`` values as well which means that ``."
"clear()`` on a section may not leave the section visibly empty.  This is "
"because default values cannot be deleted from the section (because "
"technically they are not there).  If they are overridden in the section, "
"deleting causes the default value to be visible again.  Trying to delete a "
"default value causes a :exc:`KeyError`."
msgstr ""
"所有部分都包含 ``DEFAULTSECT`` 值，這意味著部分上的 ``.clear()`` 可能不會使該"
"部分明顯為空。這是因為無法從該部分中刪除預設值（因為從技術上講它們不存在）。"
"如果它們在部分中被覆蓋，則刪除會導致預設值再次可見。嘗試刪除預設值會導致 "
":exc:`KeyError`。"

#: ../../library/configparser.rst:450
#, fuzzy
msgid "``DEFAULTSECT`` cannot be removed from the parser:"
msgstr "``DEFAULTSECT`` 無法從剖析器中刪除："

#: ../../library/configparser.rst:452
#, fuzzy
msgid "trying to delete it raises :exc:`ValueError`,"
msgstr "試圖刪除它會引發 :exec:`ValueError`，"

#: ../../library/configparser.rst:454
#, fuzzy
msgid "``parser.clear()`` leaves it intact,"
msgstr "``parser.clear()`` 保持原樣，"

#: ../../library/configparser.rst:456
#, fuzzy
msgid "``parser.popitem()`` never returns it."
msgstr "``parser.popitem()`` 永遠不會回傳它。"

#: ../../library/configparser.rst:458
#, fuzzy
msgid ""
"``parser.get(section, option, **kwargs)`` - the second argument is **not** a "
"fallback value.  Note however that the section-level ``get()`` methods are "
"compatible both with the mapping protocol and the classic configparser API."
msgstr ""
"``parser.get(section, option, **kwargs)`` - "
"第二個參數**不是**後備值。但是請注意，節級 ``get()`` 方法與映射協定和經典的 "
"configparser API 相容。"

#: ../../library/configparser.rst:462
#, fuzzy
msgid ""
"``parser.items()`` is compatible with the mapping protocol (returns a list "
"of *section_name*, *section_proxy* pairs including the DEFAULTSECT).  "
"However, this method can also be invoked with arguments: ``parser."
"items(section, raw, vars)``.  The latter call returns a list of *option*, "
"*value* pairs for a specified ``section``, with all interpolations expanded "
"(unless ``raw=True`` is provided)."
msgstr ""
"``parser.items()`` 與映射協定相容（回傳 *section_name*、*section_proxy* "
"對的列表，包括 DEFAULTSECT）。但是，也可以使用參數呼叫此方法：``parser.items("
"section, raw, vars)``。後一個呼叫回傳指定“部分”的*選項*、*值*對列表，所有插值"
"都已展開（除非提供了“raw=True”）。"

#: ../../library/configparser.rst:469
#, fuzzy
msgid ""
"The mapping protocol is implemented on top of the existing legacy API so "
"that subclasses overriding the original interface still should have mappings "
"working as expected."
msgstr "映射協定是在現有遺留 API "
"之上實作的，因此覆蓋原始介面的子類別仍應具有按預期工作的映射。"

#: ../../library/configparser.rst:475
#, fuzzy
msgid "Customizing Parser Behaviour"
msgstr "自定義剖析器行為"

#: ../../library/configparser.rst:477
#, fuzzy
msgid ""
"There are nearly as many INI format variants as there are applications using "
"it. :mod:`configparser` goes a long way to provide support for the largest "
"sensible set of INI styles available.  The default functionality is mainly "
"dictated by historical background and it's very likely that you will want to "
"customize some of the features."
msgstr ""
"INI 格式變體的數量幾乎與使用它的應用程式一樣多。 :mod:`configparser` "
"為提供對最大的可用 INI 樣式集的支援大有幫助。預設功能主要由歷史背景決定，您很"
"可能希望自定義某些功能。"

#: ../../library/configparser.rst:483
#, fuzzy
msgid ""
"The most common way to change the way a specific config parser works is to "
"use the :meth:`__init__` options:"
msgstr "更改特定配置剖析器工作方式的最常見方法是使用 :meth:`__init__` 選項："

#: ../../library/configparser.rst:486
#, fuzzy
msgid "*defaults*, default value: ``None``"
msgstr "*預設值*，預設值：``無``"

#: ../../library/configparser.rst:488
#, fuzzy
msgid ""
"This option accepts a dictionary of key-value pairs which will be initially "
"put in the ``DEFAULT`` section.  This makes for an elegant way to support "
"concise configuration files that don't specify values which are the same as "
"the documented default."
msgstr ""
"此選項接受鍵值對的字典，這些鍵值對最初將放在 ``DEFAULT`` 部分中。這提供了一種"
"優雅的方式來支援不指定與記錄的預設值相同的值的簡潔配置文件。"

#: ../../library/configparser.rst:493
#, fuzzy
msgid ""
"Hint: if you want to specify default values for a specific section, use :"
"meth:`read_dict` before you read the actual file."
msgstr "提示：如果要為特定部分指定預設值，請在讀取實際文件之前使用 "
":meth:`read_dict`。"

#: ../../library/configparser.rst:496
#, fuzzy
msgid "*dict_type*, default value: :class:`dict`"
msgstr "*dict_type*，預設值：:class:`dict`"

#: ../../library/configparser.rst:498
#, fuzzy
msgid ""
"This option has a major impact on how the mapping protocol will behave and "
"how the written configuration files look.  With the standard dictionary, "
"every section is stored in the order they were added to the parser.  Same "
"goes for options within sections."
msgstr "此選項對映射協定的行為方式以及寫入的配置文件的外觀有重大影響。使用標準字典，"
"每個部分都按照它們新增到剖析器的順序儲存。部分中的選項也是如此。"

#: ../../library/configparser.rst:503
#, fuzzy
msgid ""
"An alternative dictionary type can be used for example to sort sections and "
"options on write-back."
msgstr "例如，可以使用另一種字典型別對寫回時的部分和選項進行排序。"

#: ../../library/configparser.rst:506
#, fuzzy
msgid ""
"Please note: there are ways to add a set of key-value pairs in a single "
"operation.  When you use a regular dictionary in those operations, the order "
"of the keys will be ordered.  For example:"
msgstr "請注意：有多種方法可以在單個操作中新增一組鍵值對。當您在這些操作中使用常規字"
"典時，鍵的順序將被排序。例如："

#: ../../library/configparser.rst:528
#, fuzzy
msgid "*allow_no_value*, default value: ``False``"
msgstr "*allow_no_value*，預設值：``False``"

#: ../../library/configparser.rst:530
#, fuzzy
msgid ""
"Some configuration files are known to include settings without values, but "
"which otherwise conform to the syntax supported by :mod:`configparser`.  The "
"*allow_no_value* parameter to the constructor can be used to indicate that "
"such values should be accepted:"
msgstr ""
"已知一些配置文件包含沒有值的設定，但在其他方面符合 :mod:`configparser` "
"支援的語法。構造函式的 *allow_no_value* 參數可用於指示應接受此類值："

#: ../../library/configparser.rst:565
#, fuzzy
msgid "*delimiters*, default value: ``('=', ':')``"
msgstr "*分隔符*，預設值：``('=', ':')``"

#: ../../library/configparser.rst:567
#, fuzzy
msgid ""
"Delimiters are substrings that delimit keys from values within a section. "
"The first occurrence of a delimiting substring on a line is considered a "
"delimiter.  This means values (but not keys) can contain the delimiters."
msgstr "定界符是將部分中的鍵與值分隔開的子字串。行中第一次出現的定界子字串被視為定界"
"符。這意味著值（但不是鍵）可以包含分隔符。"

#: ../../library/configparser.rst:571
#, fuzzy
msgid ""
"See also the *space_around_delimiters* argument to :meth:`ConfigParser."
"write`."
msgstr "另請參閱 ConfigParser.write 的 *space_around_delimiters* 參數。"

#: ../../library/configparser.rst:574
#, fuzzy
msgid "*comment_prefixes*, default value: ``('#', ';')``"
msgstr "*comment_prefixes*，預設值：``('#', ';')``"

#: ../../library/configparser.rst:576
#, fuzzy
msgid "*inline_comment_prefixes*, default value: ``None``"
msgstr "*inline_comment_prefixes*，預設值：``None``"

#: ../../library/configparser.rst:578
#, fuzzy
msgid ""
"Comment prefixes are strings that indicate the start of a valid comment "
"within a config file. *comment_prefixes* are used only on otherwise empty "
"lines (optionally indented) whereas *inline_comment_prefixes* can be used "
"after every valid value (e.g. section names, options and empty lines as "
"well).  By default inline comments are disabled and ``'#'`` and ``';'`` are "
"used as prefixes for whole line comments."
msgstr ""
"註釋前綴是指示配置文件中有效註釋開始的字串。 *comment_prefixes* "
"僅用於空行（可選縮進），而 *inline_comment_prefixes* 可用於每個有效值（例如部"
"分名稱、選項和空行）之後。預設情況下，內聯註釋被禁用，``'#'`` 和 ``';'`` "
"被用作整行註釋的前綴。"

#: ../../library/configparser.rst:585
#, fuzzy
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``comment_prefixes=('#',';')`` and ``inline_comment_prefixes=(';',)``."
msgstr ""
"在之前版本的 :mod:`configparser` 中，行為匹配 ``comment_prefixes=('#',';')`` "
"和 ``inline_comment_prefixes=(';',)``。"

#: ../../library/configparser.rst:589
#, fuzzy
msgid ""
"Please note that config parsers don't support escaping of comment prefixes "
"so using *inline_comment_prefixes* may prevent users from specifying option "
"values with characters used as comment prefixes.  When in doubt, avoid "
"setting *inline_comment_prefixes*.  In any circumstances, the only way of "
"storing comment prefix characters at the beginning of a line in multiline "
"values is to interpolate the prefix, for example::"
msgstr ""
"請注意，配置剖析器不支援註釋前綴的轉義，因此使用 *inline_comment_prefixes* "
"可能會阻止使用者使用用作註釋前綴的字元來指定選項值。如有疑問，請避免設定 *inl"
"ine_comment_prefixes*。在任何情況下，在多行值的行首儲存註釋前綴字元的唯一方法"
"是插入前綴，例如："

#: ../../library/configparser.rst:635
#, fuzzy
msgid "*strict*, default value: ``True``"
msgstr "*嚴格*，預設值：``True``"

#: ../../library/configparser.rst:637
#, fuzzy
msgid ""
"When set to ``True``, the parser will not allow for any section or option "
"duplicates while reading from a single source (using :meth:`read_file`, :"
"meth:`read_string` or :meth:`read_dict`).  It is recommended to use strict "
"parsers in new applications."
msgstr ""
"當設定為 ``True`` 時，剖析器在從單個源讀取時將不允許任何部分或選項重複（使用 "
":meth:`read_file`、:meth:`read_string` 或 "
":meth:`read_dict`）。建議在新應用程式中使用嚴格的剖析器。"

#: ../../library/configparser.rst:642
#, fuzzy
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``strict=False``."
msgstr "在之前的 :mod:`configparser` 版本中，行為匹配 ``strict=False``。"

#: ../../library/configparser.rst:646
#, fuzzy
msgid "*empty_lines_in_values*, default value: ``True``"
msgstr "*empty_lines_in_values*，預設值：``True``"

#: ../../library/configparser.rst:648
#, fuzzy
msgid ""
"In config parsers, values can span multiple lines as long as they are "
"indented more than the key that holds them.  By default parsers also let "
"empty lines to be parts of values.  At the same time, keys can be "
"arbitrarily indented themselves to improve readability.  In consequence, "
"when configuration files get big and complex, it is easy for the user to "
"lose track of the file structure.  Take for instance:"
msgstr ""
"在配置剖析器中，值可以跨越多行，只要它們比保存它們的鍵縮進更多。預設情況下，"
"剖析器還讓空行成為值的一部分。同時，鍵可以自行任意縮進以提高可讀性。因此，當"
"配置文件變得又大又復雜時，使用者很容易忘記文件結構。舉個例子："

#: ../../library/configparser.rst:663
#, fuzzy
msgid ""
"This can be especially problematic for the user to see if she's using a "
"proportional font to edit the file.  That is why when your application does "
"not need values with empty lines, you should consider disallowing them.  "
"This will make empty lines split keys every time.  In the example above, it "
"would produce two keys, ``key`` and ``this``."
msgstr ""
"這對於使用者查看她是否使用比例字體來編輯文件來說尤其成問題。這就是為什麼當您"
"的應用程式不需要帶有空行的值時，您應該考慮禁止它們。這將使空行每次都拆分鍵。"
"在上面的例子中，它會產生兩個鍵，``key`` 和``this``。"

#: ../../library/configparser.rst:669
#, fuzzy
msgid ""
"*default_section*, default value: ``configparser.DEFAULTSECT`` (that is: "
"``\"DEFAULT\"``)"
msgstr "*default_section*，預設值：``configparser.DEFAULTSECT``（即：``\"DEFAULT\""
"``）"

#: ../../library/configparser.rst:672
#, fuzzy
msgid ""
"The convention of allowing a special section of default values for other "
"sections or interpolation purposes is a powerful concept of this library, "
"letting users create complex declarative configurations.  This section is "
"normally called ``\"DEFAULT\"`` but this can be customized to point to any "
"other valid section name.  Some typical values include: ``\"general\"`` or "
"``\"common\"``.  The name provided is used for recognizing default sections "
"when reading from any source and is used when writing configuration back to "
"a file.  Its current value can be retrieved using the ``parser_instance."
"default_section`` attribute and may be modified at runtime (i.e. to convert "
"files from one format to another)."
msgstr ""
"允許其他部分或插值目的的特殊部分預設值的約定是該庫的一個強大概念，允許使用者"
"建立複雜的聲明性配置。此部分通常稱為 ``DEFAULT`` ，但可以自定義它以指向任何其他有"
"效的部分名稱。一些典型的值包括：``\"general\"`` 或 ``\"common\"``。提供的名稱"
"用於在從任何源讀取時識別預設部分，並在將配置寫回文件時使用。它的當前值可以使"
"用“parser_instance.default_section”屬性檢索，並且可以在運行時修改（即將文件從"
"一種格式轉換為另一種格式）。"

#: ../../library/configparser.rst:683
#, fuzzy
msgid "*interpolation*, default value: ``configparser.BasicInterpolation``"
msgstr "*插值*，預設值：``configparser.BasicInterpolation``"

#: ../../library/configparser.rst:685
#, fuzzy
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_. :class:"
"`RawConfigParser` has a default value of ``None``."
msgstr ""
"可以通過 *interpolation* 參數提供自定義處理程式來自定義插值行為。 ``None`` "
"可用於完全關閉插值，``ExtendedInterpolation()`` 提供了一個受 ``zc.buildout`` "
"啟發的更高階的變體。在`專用文檔部分 <#interpolation-of-values>`_ "
"中有更多關於該主題的資訊。 :class:`RawConfigParser` 的預設值為 ``None``。"

#: ../../library/configparser.rst:692
#, fuzzy
msgid "*converters*, default value: not set"
msgstr "*轉換器*，預設值：未設定"

#: ../../library/configparser.rst:694
#, fuzzy
msgid ""
"Config parsers provide option value getters that perform type conversion.  "
"By default :meth:`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat`, "
"and :meth:`~ConfigParser.getboolean` are implemented.  Should other getters "
"be desirable, users may define them in a subclass or pass a dictionary where "
"each key is a name of the converter and each value is a callable "
"implementing said conversion.  For instance, passing ``{'decimal': decimal."
"Decimal}`` would add :meth:`getdecimal` on both the parser object and all "
"section proxies.  In other words, it will be possible to write both "
"``parser_instance.getdecimal('section', 'key', fallback=0)`` and "
"``parser_instance['section'].getdecimal('key', 0)``."
msgstr ""
"配置剖析器提供執行型別轉換的選項值獲取器。預設情況下 :meth:`~ConfigParser."
"getint`、:meth:`~ConfigParser.getfloat` 和 :meth:`~ConfigParser.getboolean` "
"被實作。如果需要其他 getter，使用者可以在子類別中定義它們或傳遞一個字典，其中"
"每個鍵都是轉換器的名稱，每個值都是實作所述轉換的可呼叫物件。例如，傳遞 "
"``{'decimal': decimal.Decimal}`` 會在剖析器物件和所有部分代理上新增 "
":meth:`getdecimal`。換句話說，可以同時編寫 ``parser_instance.getdecimal("
"'section', 'key', fallback=0)`` 和 ``parser_instance['section'].getdecimal("
"'key', 0)` `。"

#: ../../library/configparser.rst:705
#, fuzzy
msgid ""
"If the converter needs to access the state of the parser, it can be "
"implemented as a method on a config parser subclass.  If the name of this "
"method starts with ``get``, it will be available on all section proxies, in "
"the dict-compatible form (see the ``getdecimal()`` example above)."
msgstr ""
"如果轉換器需要訪問剖析器的狀態，它可以作為配置剖析器子類別上的方法實作。"
"如果此方法的名稱以 ``get`` 開頭，它將在所有部分代理上可用，以 dict "
"相容的形式（參見上面的 ``getdecimal()`` 示例）。"

#: ../../library/configparser.rst:710
#, fuzzy
msgid ""
"More advanced customization may be achieved by overriding default values of "
"these parser attributes.  The defaults are defined on the classes, so they "
"may be overridden by subclasses or by attribute assignment."
msgstr "可以通過覆蓋這些剖析器屬性的預設值來實作更高階的定制。預設值是在類上定義的，"
"因此它們可以被子類別或屬性分配覆蓋。"

#: ../../library/configparser.rst:716
#, fuzzy
msgid ""
"By default when using :meth:`~ConfigParser.getboolean`, config parsers "
"consider the following values ``True``: ``'1'``, ``'yes'``, ``'true'``, "
"``'on'`` and the following values ``False``: ``'0'``, ``'no'``, ``'false'``, "
"``'off'``.  You can override this by specifying a custom dictionary of "
"strings and their Boolean outcomes. For example:"
msgstr ""
"預設情況下，使用 :meth:`~ConfigParser.getboolean` 時，配置剖析器會考慮以下值 "
"``True``：``'1'``、``'yes'``、``'true'``、  ``開``和以下值 ``False``： ``0``、 ``否``、 ``False``"
"、 ``關``。您可以通過指定字串及其布爾結果的自定義字典來覆蓋它。例如："

#: ../../library/configparser.rst:734
#, fuzzy
msgid ""
"Other typical Boolean pairs include ``accept``/``reject`` or ``enabled``/"
"``disabled``."
msgstr "其他典型的布爾對包括``accept``/``reject`` 或``enabled``/``disabled``。"

#: ../../library/configparser.rst:740
#, fuzzy
msgid ""
"This method transforms option names on every read, get, or set operation.  "
"The default converts the name to lowercase.  This also means that when a "
"configuration file gets written, all keys will be lowercase.  Override this "
"method if that's unsuitable. For example:"
msgstr ""
"此方法在每次讀取、獲取或設定操作時轉換選項名稱。預設將名稱轉換為小寫。這也意"
"味著當寫入配置文件時，所有鍵都將是小寫的。如果不合適，請覆蓋此方法。例如："

#: ../../library/configparser.rst:770
#, fuzzy
msgid ""
"The optionxform function transforms option names to a canonical form. This "
"should be an idempotent function: if the name is already in canonical form, "
"it should be returned unchanged."
msgstr "optionxform 函式將選項名稱轉換為規範形式。這應該是一個冪等函式：如果名稱已經"
"是規範形式，則應原封不動地回傳。"

#: ../../library/configparser.rst:777
#, fuzzy
msgid ""
"A compiled regular expression used to parse section headers.  The default "
"matches ``[section]`` to the name ``\"section\"``.  Whitespace is considered "
"part of the section name, thus ``[  larch  ]`` will be read as a section of "
"name ``\"  larch  \"``.  Override this attribute if that's unsuitable.  For "
"example:"
msgstr ""
"用於剖析節標題的已編譯正則表達式。預設匹配 ``[section]`` 到名稱 ``\"section\""
"``。空格被認為是部分名稱的一部分，因此 ``[ larch ]`` 將被讀取為名稱為 ``\" "
"larch \"`` 的部分。如果不合適，請覆蓋此屬性。例如："

#: ../../library/configparser.rst:805
#, fuzzy
msgid ""
"While ConfigParser objects also use an ``OPTCRE`` attribute for recognizing "
"option lines, it's not recommended to override it because that would "
"interfere with constructor options *allow_no_value* and *delimiters*."
msgstr ""
"雖然 ConfigParser 對像也使用 ``OPTCRE`` 屬性來識別選項行，但不建議覆蓋它，"
"因為這會干擾構造函式選項 *allow_no_value* 和 *delimiters*。"

#: ../../library/configparser.rst:811
#, fuzzy
msgid "Legacy API Examples"
msgstr "遺留 API 示例"

#: ../../library/configparser.rst:813
#, fuzzy
msgid ""
"Mainly because of backwards compatibility concerns, :mod:`configparser` "
"provides also a legacy API with explicit ``get``/``set`` methods.  While "
"there are valid use cases for the methods outlined below, mapping protocol "
"access is preferred for new projects.  The legacy API is at times more "
"advanced, low-level and downright counterintuitive."
msgstr ""
"主要是出於向後相容性的考慮，:mod:`configparser` 還提供了一個帶有顯式 "
"``get``/``set`` 方法的遺留 "
"API。雖然下面概述的方法有有效的用例，但映射協定訪問是新項目的首選。遺留 API "
"有時更高階、更底層且完全違反直覺。"

#: ../../library/configparser.rst:819
#, fuzzy
msgid "An example of writing to a configuration file::"
msgstr "寫入配置文件的示例::"

#: ../../library/configparser.rst:842
#, fuzzy
msgid "An example of reading the configuration file again::"
msgstr "再次讀取配置文件的例子::"

#: ../../library/configparser.rst:860
#, fuzzy
msgid "To get interpolation, use :class:`ConfigParser`::"
msgstr "要獲得插值，請使用 ConfigParser::"

#: ../../library/configparser.rst:893
#, fuzzy
msgid ""
"Default values are available in both types of ConfigParsers.  They are used "
"in interpolation if an option used is not defined elsewhere. ::"
msgstr "預設值在兩種型別的 ConfigParsers "
"中都可用。如果使用的選項未在別處定義，則它們用於插值。 ::"

#: ../../library/configparser.rst:911
msgid "ConfigParser Objects"
msgstr "ConfigParser 物件"

#: ../../library/configparser.rst:915
#, fuzzy
msgid ""
"The main configuration parser.  When *defaults* is given, it is initialized "
"into the dictionary of intrinsic defaults.  When *dict_type* is given, it "
"will be used to create the dictionary objects for the list of sections, for "
"the options within a section, and for the default values."
msgstr ""
"主要配置剖析器。當給出 *defaults* 時，它被初始化為內在預設值的字典。當給出 "
"*dict_type* 時，它將用於為部分列表、部分中的選項和預設值建立字典物件。"

#: ../../library/configparser.rst:920
#, fuzzy
msgid ""
"When *delimiters* is given, it is used as the set of substrings that divide "
"keys from values.  When *comment_prefixes* is given, it will be used as the "
"set of substrings that prefix comments in otherwise empty lines. Comments "
"can be indented.  When *inline_comment_prefixes* is given, it will be used "
"as the set of substrings that prefix comments in non-empty lines."
msgstr ""
"當給出 *delimiters* 時，它用作將鍵與值分開的子字串集。當給出 "
"*comment_prefixes* "
"時，它將用作一組子字串，在其他空行中為註釋新增前綴。註釋可以縮進。當給出 "
"*inline_comment_prefixes* 時，它將用作非空行中前綴註釋的子字串集。"

#: ../../library/configparser.rst:926
#, fuzzy
msgid ""
"When *strict* is ``True`` (the default), the parser won't allow for any "
"section or option duplicates while reading from a single source (file, "
"string or dictionary), raising :exc:`DuplicateSectionError` or :exc:"
"`DuplicateOptionError`.  When *empty_lines_in_values* is ``False`` (default: "
"``True``), each empty line marks the end of an option.  Otherwise, internal "
"empty lines of a multiline option are kept as part of the value. When "
"*allow_no_value* is ``True`` (default: ``False``), options without values "
"are accepted; the value held for these is ``None`` and they are serialized "
"without the trailing delimiter."
msgstr ""
"當 *strict* 為 ``True``（預設值）時，剖析器在從單個源（文件、字串或字典）讀取"
"時不允許任何部分或選項重複，引發 :exc:`DuplicateSectionError` 或： "
"exc:`DuplicateOptionError`。當 *empty_lines_in_values* 為 ``False``（預設值："
"``True``）時，每個空行都標記一個選項的結尾。否則，多行選項的內部空行將保留為"
"值的一部分。當 *allow_no_value* 為 ``True``（預設值：``False``）時，接受沒有"
"值的選項；為這些保留的值為 ``None`` ，並且它們在沒有尾隨定界符的情況下進行序列化。"

#: ../../library/configparser.rst:936
#, fuzzy
msgid ""
"When *default_section* is given, it specifies the name for the special "
"section holding default values for other sections and interpolation purposes "
"(normally named ``\"DEFAULT\"``).  This value can be retrieved and changed "
"on runtime using the ``default_section`` instance attribute."
msgstr ""
"當給出 *default_section* 時，它指定特殊部分的名稱，其中包含其他部分和插值目的"
"的預設值（通常命名為 ``DEFAULT`` ``）。可以使用“default_section”實例屬性在運行時"
"檢索和更改此值。"

#: ../../library/configparser.rst:941
#, fuzzy
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_."
msgstr ""
"可以通過 *interpolation* 參數提供自定義處理程式來自定義插值行為。 ``None`` "
"可用於完全關閉插值，``ExtendedInterpolation()`` 提供了一個受 ``zc.buildout`` "
"啟發的更高階的變體。在`專用文檔部分 <#interpolation-of-values>`_ "
"中有更多關於該主題的資訊。"

#: ../../library/configparser.rst:947
#, fuzzy
msgid ""
"All option names used in interpolation will be passed through the :meth:"
"`optionxform` method just like any other option name reference.  For "
"example, using the default implementation of :meth:`optionxform` (which "
"converts option names to lower case), the values ``foo %(bar)s`` and ``foo "
"%(BAR)s`` are equivalent."
msgstr ""
"插值中使用的所有選項名稱都將通過 :meth:`optionxform` "
"方法傳遞，就像任何其他選項名稱引用一樣。例如，使用 :meth:`optionxform` "
"的預設實作（將選項名稱轉換為小寫），值 ``foo %(bar)s`` 和 ``foo %(BAR)s`` "
"是等價的。"

#: ../../library/configparser.rst:953
#, fuzzy
msgid ""
"When *converters* is given, it should be a dictionary where each key "
"represents the name of a type converter and each value is a callable "
"implementing the conversion from string to the desired datatype.  Every "
"converter gets its own corresponding :meth:`get*()` method on the parser "
"object and section proxies."
msgstr ""
"當 *converters* 給出時，它應該是一個字典，其中每個鍵代表一個型別轉換器的名稱"
"，每個值都是一個可呼叫的實作從字串到所需資料型別的轉換。"
"每個轉換器在剖析器物件和部分代理上都有自己對應的 :meth:`get*()` 方法。"

#: ../../library/configparser.rst:959
#, fuzzy
msgid "The default *dict_type* is :class:`collections.OrderedDict`."
msgstr "預設的 *dict_type* 是 :class:`collections.OrderedDict`。"

#: ../../library/configparser.rst:962
#, fuzzy
msgid ""
"*allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* and *interpolation* were added."
msgstr ""
"新增了 *allow_no_value*、*delimiters*、*comment_prefixes*、*strict*、*empty_l"
"ines_in_values*、*default_section* 和 *interpolation*。"

#: ../../library/configparser.rst:967
msgid "The *converters* argument was added."
msgstr "新增 *converters* 引數。"

#: ../../library/configparser.rst:970
#, fuzzy
msgid ""
"The *defaults* argument is read with :meth:`read_dict()`, providing "
"consistent behavior across the parser: non-string keys and values are "
"implicitly converted to strings."
msgstr "*defaults* 參數使用 :meth:`read_dict()` "
"讀取，在整個剖析器中提供一致的行為：非字串鍵和值被隱式轉換為字串。"

#: ../../library/configparser.rst:975 ../../library/configparser.rst:1260
#, fuzzy
msgid ""
"The default *dict_type* is :class:`dict`, since it now preserves insertion "
"order."
msgstr "預設的 *dict_type* 是 :class:`dict`，因為它現在保留了插入順序。"

#: ../../library/configparser.rst:981
#, fuzzy
msgid "Return a dictionary containing the instance-wide defaults."
msgstr "回傳包含實例範圍預設值的字典。"

#: ../../library/configparser.rst:986
#, fuzzy
msgid ""
"Return a list of the sections available; the *default section* is not "
"included in the list."
msgstr "回傳可用部分的列表； *預設部分*不包含在列表中。"

#: ../../library/configparser.rst:992
#, fuzzy
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised.  The name of "
"the section must be a string; if not, :exc:`TypeError` is raised."
msgstr ""
"將名為 *section* 的部分新增到實例中。如果給定名稱的部分已經存在，則會引發：ex"
"c:`DuplicateSectionError`。如果傳遞了 *default section* 名稱，則會引發 "
":exc:`ValueError`。該部分的名稱必須是一個字串；如果不是，則引發 "
":exc:`TypeError`。"

#: ../../library/configparser.rst:997
#, fuzzy
msgid "Non-string section names raise :exc:`TypeError`."
msgstr "非字串部分名稱引發 :exc:`TypeError`。"

#: ../../library/configparser.rst:1003
#, fuzzy
msgid ""
"Indicates whether the named *section* is present in the configuration. The "
"*default section* is not acknowledged."
msgstr "指示指定的 *section* 是否存在於配置中。 *預設部分*未被確認。"

#: ../../library/configparser.rst:1009
#, fuzzy
msgid "Return a list of options available in the specified *section*."
msgstr "回傳指定 *section* 中可用的選項列表。"

#: ../../library/configparser.rst:1014
#, fuzzy
msgid ""
"If the given *section* exists, and contains the given *option*, return :"
"const:`True`; otherwise return :const:`False`.  If the specified *section* "
"is :const:`None` or an empty string, DEFAULT is assumed."
msgstr ""
"如果給定的 *section* 存在，並且包含給定的 *option*，則回傳 :const:`True`;"
"否則回傳 :const:`False`。如果指定的 *section* 是 :const:`None` 或空字串，"
"則假定為 DEFAULT。"

#: ../../library/configparser.rst:1021
#, fuzzy
msgid ""
"Attempt to read and parse an iterable of filenames, returning a list of "
"filenames which were successfully parsed."
msgstr "嘗試讀取和剖析可疊代的文件名，回傳已成功剖析的文件名列表。"

#: ../../library/configparser.rst:1024
#, fuzzy
msgid ""
"If *filenames* is a string, a :class:`bytes` object or a :term:`path-like "
"object`, it is treated as a single filename.  If a file named in *filenames* "
"cannot be opened, that file will be ignored.  This is designed so that you "
"can specify an iterable of potential configuration file locations (for "
"example, the current directory, the user's home directory, and some system-"
"wide directory), and all existing configuration files in the iterable will "
"be read."
msgstr ""
"如果 *filenames* 是字串、:class:`bytes` 對像或 :term:`path-like "
"object`，它被視為單個文件名。如果無法打開以 *filenames* 命名的文件，則該文件"
"將被忽略。這是為了讓您可以指定一個可疊代的潛在配置文件位置（例如，當前目錄、"
"使用者的主目錄和一些系統範圍的目錄），並且將讀取可疊代中的所有現有配置文件。"

#: ../../library/configparser.rst:1033
#, fuzzy
msgid ""
"If none of the named files exist, the :class:`ConfigParser` instance will "
"contain an empty dataset.  An application which requires initial values to "
"be loaded from a file should load the required file or files using :meth:"
"`read_file` before calling :meth:`read` for any optional files::"
msgstr ""
"如果命名文件都不存在，則 ConfigParser 實例將包含一個空資料集。"
"需要從文件加載初始值的應用程式應在呼叫任何可選文件的 read_file 之前使用 "
"read_file 加載所需的一個或多個文件::"

#: ../../library/configparser.rst:1046
#, fuzzy
msgid ""
"The *encoding* parameter.  Previously, all files were read using the default "
"encoding for :func:`open`."
msgstr "*編碼*參數。以前，所有文件都是使用 :func:`open` 的預設編碼讀取的。"

#: ../../library/configparser.rst:1050
#, fuzzy
msgid "The *filenames* parameter accepts a :term:`path-like object`."
msgstr "*filenames* 參數接受一個 :term:`path-like object`。"

#: ../../library/configparser.rst:1053
#, fuzzy
msgid "The *filenames* parameter accepts a :class:`bytes` object."
msgstr "*filenames* 參數接受一個 :class:`bytes` 物件。"

#: ../../library/configparser.rst:1059
#, fuzzy
msgid ""
"Read and parse configuration data from *f* which must be an iterable "
"yielding Unicode strings (for example files opened in text mode)."
msgstr "從 *f* 讀取和剖析配置資料，它必須是可疊代的生成 Unicode "
"字串（例如以文本模式打開的文件）。"

#: ../../library/configparser.rst:1062
#, fuzzy
msgid ""
"Optional argument *source* specifies the name of the file being read.  If "
"not given and *f* has a :attr:`name` attribute, that is used for *source*; "
"the default is ``'<???>'``."
msgstr ""
"可選參數 *source* 指定正在讀取的文件的名稱。如果未給出且 *f* 具有 "
":attr:`name` 屬性，則用於 *source*；預設是``'<???>'``。"

#: ../../library/configparser.rst:1066
#, fuzzy
msgid "Replaces :meth:`readfp`."
msgstr "替換 :meth:`readfp`。"

#: ../../library/configparser.rst:1071
#, fuzzy
msgid "Parse configuration data from a string."
msgstr "從字串中剖析配置資料。"

#: ../../library/configparser.rst:1073
#, fuzzy
msgid ""
"Optional argument *source* specifies a context-specific name of the string "
"passed.  If not given, ``'<string>'`` is used.  This should commonly be a "
"filesystem path or a URL."
msgstr ""
"可選參數 *source* 指定傳遞的字串的上下文特定名稱。如果未給出，則使用 "
"``'<string>'``。這通常應該是文件系統路徑或 URL。"

#: ../../library/configparser.rst:1082
#, fuzzy
msgid ""
"Load configuration from any object that provides a dict-like ``items()`` "
"method.  Keys are section names, values are dictionaries with keys and "
"values that should be present in the section.  If the used dictionary type "
"preserves order, sections and their keys will be added in order. Values are "
"automatically converted to strings."
msgstr ""
"從任何提供類似 dict 的 items() 方法的物件加載配置。鍵是部分名稱，值是包含應出"
"現在該部分中的鍵和值的字典。如果使用的字典型別保留順序，則部分及其鍵將按順序"
"新增。值會自動轉換為字串。"

#: ../../library/configparser.rst:1088
#, fuzzy
msgid ""
"Optional argument *source* specifies a context-specific name of the "
"dictionary passed.  If not given, ``<dict>`` is used."
msgstr "可選參數 *source* 指定傳遞的字典的上下文特定名稱。如果未給出，則使用 "
"``<dict>``。"

#: ../../library/configparser.rst:1091
#, fuzzy
msgid "This method can be used to copy state between parsers."
msgstr "此方法可用於在剖析器之間複製狀態。"

#: ../../library/configparser.rst:1098
#, fuzzy
msgid ""
"Get an *option* value for the named *section*.  If *vars* is provided, it "
"must be a dictionary.  The *option* is looked up in *vars* (if provided), "
"*section*, and in *DEFAULTSECT* in that order.  If the key is not found and "
"*fallback* is provided, it is used as a fallback value.  ``None`` can be "
"provided as a *fallback* value."
msgstr ""
"為指定的 *section* 獲取一個 *option* 值。如果提供了 "
"*vars*，它必須是一個字典。 *option* 在 *vars*（如果提供）、*section* 和 "
"*DEFAULTSECT* 中按此順序查找。如果未找到密鑰並提供 "
"*fallback*，則將其用作回退值。 ``None`` 可以作為 *fallback* 值提供。"

#: ../../library/configparser.rst:1104
#, fuzzy
msgid ""
"All the ``'%'`` interpolations are expanded in the return values, unless the "
"*raw* argument is true.  Values for interpolation keys are looked up in the "
"same manner as the option."
msgstr "除非 *raw* 參數為真，否則所有 ``%``插值都會在回傳值中展開。以與選項相同的方式查"
"找插值鍵的值。"

#: ../../library/configparser.rst:1108
#, fuzzy
msgid ""
"Arguments *raw*, *vars* and *fallback* are keyword only to protect users "
"from trying to use the third argument as the *fallback* fallback (especially "
"when using the mapping protocol)."
msgstr ""
"參數 *raw*、*vars* 和 *fallback* 只是關鍵字，"
"以防止使用者嘗試使用第三個參數作為 *fallback* "
"回退（尤其是在使用映射協定時）。"

#: ../../library/configparser.rst:1116
#, fuzzy
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to an integer.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"將指定 *section* 中的 *option* 強制轉換為整數的便捷方法。有關 *raw*、*vars* "
"和 *fallback* 的解釋，請參閱 :meth:`get`。"

#: ../../library/configparser.rst:1123
#, fuzzy
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a floating point number.  See :meth:`get` for explanation of *raw*, "
"*vars* and *fallback*."
msgstr ""
"將指定 *section* 中的 *option* 強制轉換為浮點數的便捷方法。有關 *raw*、*vars*"
" 和 *fallback* 的解釋，請參閱 :meth:`get`。"

#: ../../library/configparser.rst:1130
#, fuzzy
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a Boolean value.  Note that the accepted values for the option are "
"``'1'``, ``'yes'``, ``'true'``, and ``'on'``, which cause this method to "
"return ``True``, and ``'0'``, ``'no'``, ``'false'``, and ``'off'``, which "
"cause it to return ``False``.  These string values are checked in a case-"
"insensitive manner.  Any other value will cause it to raise :exc:"
"`ValueError`.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"將指定 *section* 中的 *option* 強制轉換為布爾值的便捷方法。請注意，該選項的接"
"受值是 ``'1'``, ``'yes'``, ``'true'`` 和 ``'on'``，這會導致此方法回傳 ``True`` 和 "
"``'0'``、``'no'``、``'false'`` 和 ``'off'``，這導致它回傳 "
"``False``。這些字串值以不區分大小寫的方式進行檢查。任何其他值都會導致它引發 "
":exc:`ValueError`。有關 *raw*、*vars* 和 *fallback* 的解釋，請參閱 "
":meth:`get`。"

#: ../../library/configparser.rst:1143
#, fuzzy
msgid ""
"When *section* is not given, return a list of *section_name*, "
"*section_proxy* pairs, including DEFAULTSECT."
msgstr ""
"當未給出 *section* 時，回傳 *section_name*, *section_proxy* 對的列表，包括 "
"DEFAULTSECT。"

#: ../../library/configparser.rst:1146
#, fuzzy
msgid ""
"Otherwise, return a list of *name*, *value* pairs for the options in the "
"given *section*.  Optional arguments have the same meaning as for the :meth:"
"`get` method."
msgstr "否則，回傳給定*部分*中選項的*名稱*、*值*對列表。可選參數與 :meth:`get` "
"方法具有相同的含義。"

#: ../../library/configparser.rst:1150
#, fuzzy
msgid ""
"Items present in *vars* no longer appear in the result.  The previous "
"behaviour mixed actual parser options with variables provided for "
"interpolation."
msgstr "*vars* 中的項目不再出現在結果中。以前的行為將實際的剖析器選項與為插值提供的變"
"數混合在一起。"

#: ../../library/configparser.rst:1158
#, fuzzy
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  *option* and *value* must be "
"strings; if not, :exc:`TypeError` is raised."
msgstr ""
"如果給定的部分存在，則將給定的選項設定為指定的值；否則引發 :exec:`NoSectionErr"
"or`。 *option* 和 *value* 必須是字串；如果不是，則引發 :exc:`TypeError`。"

#: ../../library/configparser.rst:1165
#, fuzzy
msgid ""
"Write a representation of the configuration to the specified :term:`file "
"object`, which must be opened in text mode (accepting strings).  This "
"representation can be parsed by a future :meth:`read` call.  If "
"*space_around_delimiters* is true, delimiters between keys and values are "
"surrounded by spaces."
msgstr ""
"將配置的表示寫入指定的文件物件，該文件物件必須以文本模式打開（接受字串）。"
"這種表示可以通過未來的 read 呼叫來剖析。如果 *space_around_delimiters* "
"為真，則鍵和值之間的分隔符由空格包圍。"

#: ../../library/configparser.rst:1173
#, fuzzy
msgid ""
"Comments in the original configuration file are not preserved when writing "
"the configuration back. What is considered a comment, depends on the given "
"values for *comment_prefix* and *inline_comment_prefix*."
msgstr ""
"寫回配置時，不會保留原始配置文件中的註釋。什麼被認為是評論，取決於 "
"*comment_prefix* 和 *inline_comment_prefix* 的給定值。"

#: ../../library/configparser.rst:1181
#, fuzzy
msgid ""
"Remove the specified *option* from the specified *section*.  If the section "
"does not exist, raise :exc:`NoSectionError`.  If the option existed to be "
"removed, return :const:`True`; otherwise return :const:`False`."
msgstr ""
"從指定的*部分* 中刪除指定的*選項*。如果該部分不存在，則引發 :exec:`NoSectionEr"
"ror`。如果存在要刪除的選項，則回傳 :const:`True`;否則回傳 :const:`False`。"

#: ../../library/configparser.rst:1189
#, fuzzy
msgid ""
"Remove the specified *section* from the configuration.  If the section in "
"fact existed, return ``True``.  Otherwise return ``False``."
msgstr "從配置中刪除指定的*部分*。如果該部分確實存在，則回傳 ``True``。否則回傳 ``False``。"

#: ../../library/configparser.rst:1195
#, fuzzy
msgid ""
"Transforms the option name *option* as found in an input file or as passed "
"in by client code to the form that should be used in the internal "
"structures.  The default implementation returns a lower-case version of "
"*option*; subclasses may override this or client code can set an attribute "
"of this name on instances to affect this behavior."
msgstr ""
"將在輸入文件中找到的或由客戶端程式碼傳入的選項名稱 *option* "
"轉換為應該在內部結構中使用的形式。預設實作回傳 *option* 的小寫版本；子類別可"
"以覆蓋這個或者客戶端程式碼可以在實例上設定這個名稱的屬性來影響這個行為。"

#: ../../library/configparser.rst:1201
#, fuzzy
msgid ""
"You don't need to subclass the parser to use this method, you can also set "
"it on an instance, to a function that takes a string argument and returns a "
"string.  Setting it to ``str``, for example, would make option names case "
"sensitive::"
msgstr ""
"您不需要將剖析器子類別化來使用此方法，您也可以將它設定在一個實例上，設定為一"
"個接受字串參數並回傳字串的函式。例如，將其設定為 ``str`` "
"會使選項名稱區分大小寫::"

#: ../../library/configparser.rst:1209
#, fuzzy
msgid ""
"Note that when reading configuration files, whitespace around the option "
"names is stripped before :meth:`optionxform` is called."
msgstr "請注意，在讀取配置文件時，選項名稱周圍的空格會在呼叫 :meth:`optionxform` "
"之前被去除。"

#: ../../library/configparser.rst:1215
#, fuzzy
msgid "Use :meth:`read_file` instead."
msgstr "使用 :meth:`read_file` 代替。"

#: ../../library/configparser.rst:1218
#, fuzzy
msgid ""
":meth:`readfp` now iterates on *fp* instead of calling ``fp.readline()``."
msgstr ":meth:`readfp` 現在疊代 *fp* 而不是呼叫 ``fp.readline()``。"

#: ../../library/configparser.rst:1221
#, fuzzy
msgid ""
"For existing code calling :meth:`readfp` with arguments which don't support "
"iteration, the following generator may be used as a wrapper around the file-"
"like object::"
msgstr "對於使用不支援疊代的參數呼叫 :meth:`readfp` "
"的現有程式碼，可以使用以下生成器作為類文件物件的包裝器::"

#: ../../library/configparser.rst:1231
#, fuzzy
msgid ""
"Instead of ``parser.readfp(fp)`` use ``parser."
"read_file(readline_generator(fp))``."
msgstr ""
"而不是 ``parser.readfp(fp)`` 使用 ``parser."
"read_file(readline_generator(fp))``。"

#: ../../library/configparser.rst:1237
#, fuzzy
msgid ""
"The maximum depth for recursive interpolation for :meth:`get` when the *raw* "
"parameter is false.  This is relevant only when the default *interpolation* "
"is used."
msgstr "當 *raw* 參數為 false 時，get 的遞迴插值的最大深度。這僅在使用預設 "
"*interpolation* 時相關。"

#: ../../library/configparser.rst:1245
msgid "RawConfigParser Objects"
msgstr "RawConfigParser 物件"

#: ../../library/configparser.rst:1255
#, fuzzy
msgid ""
"Legacy variant of the :class:`ConfigParser`.  It has interpolation disabled "
"by default and allows for non-string section names, option names, and values "
"via its unsafe ``add_section`` and ``set`` methods, as well as the legacy "
"``defaults=`` keyword argument handling."
msgstr ""
"ConfigParser 的遺留變體。它預設禁用插值，並允許通過其不安全的 ``add_section``"
" 和 ``set`` 方法以及遺留的 ``defaults=`` "
"關鍵字參數處理非字串部分名稱、選項名稱和值."

#: ../../library/configparser.rst:1265
#, fuzzy
msgid ""
"Consider using :class:`ConfigParser` instead which checks types of the "
"values to be stored internally.  If you don't want interpolation, you can "
"use ``ConfigParser(interpolation=None)``."
msgstr ""
"考慮使用 ConfigParser 而不是檢查要在內部儲存的值的型別。如果你不想插值，你可"
"以使用``ConfigParser(interpolation=None)``。"

#: ../../library/configparser.rst:1272
#, fuzzy
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised."
msgstr ""
"將名為 *section* 的部分新增到實例中。如果給定名稱的部分已經存在，則會引發：ex"
"c:`DuplicateSectionError`。如果傳遞了 *default section* 名稱，則會引發 "
":exc:`ValueError`。"

#: ../../library/configparser.rst:1276
#, fuzzy
msgid ""
"Type of *section* is not checked which lets users create non-string named "
"sections.  This behaviour is unsupported and may cause internal errors."
msgstr "不檢查 *section* 的型別，這允許使用者建立非字串命名的部分。此行為不受支援，可"
"能會導致內部錯誤。"

#: ../../library/configparser.rst:1282
#, fuzzy
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  While it is possible to use :class:"
"`RawConfigParser` (or :class:`ConfigParser` with *raw* parameters set to "
"true) for *internal* storage of non-string values, full functionality "
"(including interpolation and output to files) can only be achieved using "
"string values."
msgstr ""
"如果給定的部分存在，則將給定的選項設定為指定的值；否則引發 :exec:`NoSectionErr"
"or`。雖然可以使用 :class:`RawConfigParser`（或 :class:`ConfigParser` 並將 "
"*raw* 參數設定為 true）用於非字串值的*內部*儲存、完整功能（包括插值和輸出到文"
"件）只能使用字串值來實作。"

#: ../../library/configparser.rst:1289
#, fuzzy
msgid ""
"This method lets users assign non-string values to keys internally.  This "
"behaviour is unsupported and will cause errors when attempting to write to a "
"file or get it in non-raw mode.  **Use the mapping protocol API** which does "
"not allow such assignments to take place."
msgstr ""
"此方法允許使用者在內部將非字串值分配給鍵。此行為不受支援，並且在嘗試寫入文件"
"或以非原始模式獲取文件時會導致錯誤。 **使用不允許進行此類分配的映射協定 "
"API**。"

#: ../../library/configparser.rst:1296
msgid "Exceptions"
msgstr "例外"

#: ../../library/configparser.rst:1300
#, fuzzy
msgid "Base class for all other :mod:`configparser` exceptions."
msgstr "所有其他 :mod:`configparser` 例外的基底類別。"

#: ../../library/configparser.rst:1305
#, fuzzy
msgid "Exception raised when a specified section is not found."
msgstr "找不到指定部分時引發例外。"

#: ../../library/configparser.rst:1310
#, fuzzy
msgid ""
"Exception raised if :meth:`add_section` is called with the name of a section "
"that is already present or in strict parsers when a section if found more "
"than once in a single input file, string or dictionary."
msgstr "如果在單個輸入文件、字串或字典中多次發現一個節時，"
"如果使用已經存在的節的名稱或在嚴格剖析器中呼叫 add_section 時引發例外。"

#: ../../library/configparser.rst:1314
#, fuzzy
msgid ""
"Optional ``source`` and ``lineno`` attributes and arguments to :meth:"
"`__init__` were added."
msgstr "新增了可選的 ``source`` 和 ``lineno`` 屬性以及 :meth:`__init__` 的參數。"

#: ../../library/configparser.rst:1321
#, fuzzy
msgid ""
"Exception raised by strict parsers if a single option appears twice during "
"reading from a single file, string or dictionary. This catches misspellings "
"and case sensitivity-related errors, e.g. a dictionary may have two keys "
"representing the same case-insensitive configuration key."
msgstr ""
"如果在從單個文件、字串或字典讀取期間單個選項出現兩次，則由嚴格的剖析器引發例"
"外。這會捕獲拼寫錯誤和與大小寫敏感相關的錯誤，例如字典可能有兩個鍵代表相同的"
"不區分大小寫的配置鍵。"

#: ../../library/configparser.rst:1329
#, fuzzy
msgid ""
"Exception raised when a specified option is not found in the specified "
"section."
msgstr "在指定部分找不到指定選項時引發例外。"

#: ../../library/configparser.rst:1335
#, fuzzy
msgid ""
"Base class for exceptions raised when problems occur performing string "
"interpolation."
msgstr "執行字串插值時出現問題時引發例外的基底類別。"

#: ../../library/configparser.rst:1341
#, fuzzy
msgid ""
"Exception raised when string interpolation cannot be completed because the "
"number of iterations exceeds :const:`MAX_INTERPOLATION_DEPTH`.  Subclass of :"
"exc:`InterpolationError`."
msgstr ""
"由於疊代次數超過 :const:`MAX_INTERPOLATION_DEPTH` "
"而無法完成字串插值時引發的例外。 InterpolationError 的子類別。"

#: ../../library/configparser.rst:1348
#, fuzzy
msgid ""
"Exception raised when an option referenced from a value does not exist. "
"Subclass of :exc:`InterpolationError`."
msgstr "當從值引用的選項不存在時引發例外。 InterpolationError 的子類別。"

#: ../../library/configparser.rst:1354
#, fuzzy
msgid ""
"Exception raised when the source text into which substitutions are made does "
"not conform to the required syntax.  Subclass of :exc:`InterpolationError`."
msgstr "當進行替換的源文本不符合要求的語法時引發例外。 InterpolationError 的子類別。"

#: ../../library/configparser.rst:1360
#, fuzzy
msgid ""
"Exception raised when attempting to parse a file which has no section "
"headers."
msgstr "嘗試剖析沒有節標題的文件時引發例外。"

#: ../../library/configparser.rst:1366
#, fuzzy
msgid "Exception raised when errors occur attempting to parse a file."
msgstr "嘗試剖析文件時發生錯誤時引發例外。"

#: ../../library/configparser.rst:1368
#, fuzzy
msgid ""
"The ``filename`` attribute and :meth:`__init__` argument were renamed to "
"``source`` for consistency."
msgstr "``filename`` 屬性和 :meth:`__init__` 參數被重命名為 ``source`` 以保持一致性。"

#: ../../library/configparser.rst:1374
msgid "Footnotes"
msgstr "註解"

#: ../../library/configparser.rst:1375
#, fuzzy
msgid ""
"Config parsers allow for heavy customization.  If you are interested in "
"changing the behaviour outlined by the footnote reference, consult the "
"`Customizing Parser Behaviour`_ section."
msgstr "配置剖析器允許大量定制。如果您有興趣更改腳註參考概述的行為，請參閱“自定義剖析"
"器行為”部分。"
