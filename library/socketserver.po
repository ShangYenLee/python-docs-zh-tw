# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-13 00:17+0000\n"
"PO-Revision-Date: 2018-05-23 16:10+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/socketserver.rst:2
#, fuzzy
msgid ":mod:`socketserver` --- A framework for network servers"
msgstr ":mod:`socketserver` --- 網絡伺服器框架"

#: ../../library/socketserver.rst:7
msgid "**Source code:** :source:`Lib/socketserver.py`"
msgstr "**原始碼：**\\ :source:`Lib/socketserver.py`"

#: ../../library/socketserver.rst:11
#, fuzzy
msgid ""
"The :mod:`socketserver` module simplifies the task of writing network "
"servers."
msgstr ":mod:`socketserver` 模組簡化了編寫網絡伺服器的任務。"

#: ../../includes/wasm-notavail.rst:3
#, fuzzy
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ":ref:`Availability <availability>`：不是 Emscripten，不是 WASI。"

#: ../../includes/wasm-notavail.rst:5
#, fuzzy
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"此模組在 WebAssembly 平台 ``wasm32-emscripten`` 和 ``wasm32-wasi`` 上不起作用或不可用"
"。有關更多資訊，請參閱 :ref:`wasm-availability`。"

#: ../../library/socketserver.rst:15
#, fuzzy
msgid "There are four basic concrete server classes:"
msgstr "有四個基本的具體伺服器類："

#: ../../library/socketserver.rst:20
#, fuzzy
msgid ""
"This uses the internet TCP protocol, which provides for continuous streams "
"of data between the client and server. If *bind_and_activate* is true, the "
"constructor automatically attempts to invoke :meth:`~BaseServer.server_bind` "
"and :meth:`~BaseServer.server_activate`.  The other parameters are passed to "
"the :class:`BaseServer` base class."
msgstr ""
"這使用 Internet TCP 協定，該協定在客戶端和伺服器之間提供連續的資料流。如果 "
"*bind_and_activate* 為真，構造函式會自動嘗試呼叫 :meth:`~BaseServer."
"server_bind` 和 :meth:`~BaseServer.server_activate`。其他參數傳遞給 "
":class:`BaseServer` 基底類別。"

#: ../../library/socketserver.rst:30
#, fuzzy
msgid ""
"This uses datagrams, which are discrete packets of information that may "
"arrive out of order or be lost while in transit.  The parameters are the "
"same as for :class:`TCPServer`."
msgstr "這使用資料報，它們是離散的資訊包，可能會亂序到達或在傳輸過程中丟失。參數與 "
":class:`TCPServer` 相同。"

#: ../../library/socketserver.rst:38
#, fuzzy
msgid ""
"These more infrequently used classes are similar to the TCP and UDP classes, "
"but use Unix domain sockets; they're not available on non-Unix platforms.  "
"The parameters are the same as for :class:`TCPServer`."
msgstr ""
"這些比較不常用的類類似於TCP和UDP類，但是使用的是Unix域 socket ；它們在非 Unix "
"平台上不可用。參數與 :class:`TCPServer` 相同。"

#: ../../library/socketserver.rst:44
#, fuzzy
msgid ""
"These four classes process requests :dfn:`synchronously`; each request must "
"be completed before the next request can be started.  This isn't suitable if "
"each request takes a long time to complete, because it requires a lot of "
"computation, or because it returns a lot of data which the client is slow to "
"process.  The solution is to create a separate process or thread to handle "
"each request; the :class:`ForkingMixIn` and :class:`ThreadingMixIn` mix-in "
"classes can be used to support asynchronous behaviour."
msgstr ""
"這四個類處理請求 :dfn:`synchronously`;每個請求必須在下一個請求開始之前完成。"
"如果每個請求都需要很長時間才能完成，這是不合適的，因為它需要大量計算，或者因"
"為它回傳大量客戶端處理速度很慢的資料。解決方案是建立一個單獨的行程或執行緒來"
"處理每個請求； ForkingMixIn 和 ThreadingMixIn 混合類可用於支援非同步行為。"

#: ../../library/socketserver.rst:52
#, fuzzy
msgid ""
"Creating a server requires several steps.  First, you must create a request "
"handler class by subclassing the :class:`BaseRequestHandler` class and "
"overriding its :meth:`~BaseRequestHandler.handle` method; this method will "
"process incoming requests.  Second, you must instantiate one of the server "
"classes, passing it the server's address and the request handler class. It "
"is recommended to use the server in a :keyword:`with` statement. Then call "
"the :meth:`~BaseServer.handle_request` or :meth:`~BaseServer.serve_forever` "
"method of the server object to process one or many requests.  Finally, call :"
"meth:`~BaseServer.server_close` to close the socket (unless you used a :"
"keyword:`!with` statement)."
msgstr ""
"建立伺服器需要幾個步驟。首先，您必須通過子類別化 BaseRequestHandler "
"類並覆蓋其 :meth:`~BaseRequestHandler.handle` 方法來建立請求處理程式類；此方"
"法將處理傳入的請求。其次，您必須實例化其中一個伺服器類，將伺服器地址和請求處"
"理程式類傳遞給它。建議在 :keyword:`with` "
"語句中使用伺服器。然後呼叫伺服器物件的 :meth:`~BaseServer.handle_request` "
"或 :meth:`~BaseServer.serve_forever` 方法來處理一個或多個請求。最後，呼叫 "
":meth:`~BaseServer.server_close` 關閉 socket （除非您使用了 :keyword:`!with` "
"語句）。"

#: ../../library/socketserver.rst:64
#, fuzzy
msgid ""
"When inheriting from :class:`ThreadingMixIn` for threaded connection "
"behavior, you should explicitly declare how you want your threads to behave "
"on an abrupt shutdown.  The :class:`ThreadingMixIn` class defines an "
"attribute *daemon_threads*, which indicates whether or not the server should "
"wait for thread termination.  You should set the flag explicitly if you "
"would like threads to behave autonomously; the default is :const:`False`, "
"meaning that Python will not exit until all threads created by :class:"
"`ThreadingMixIn` have exited."
msgstr ""
"從 :class:`ThreadingMixIn` "
"繼承執行緒連接行為時，您應該明確聲明您希望執行緒在突然關閉時的行為方式。 "
":class:`ThreadingMixIn` 類定義了一個屬性 *daemon_threads*，它指示伺服器是否應"
"該等待執行緒終止。如果您希望執行緒自主運行，您應該顯式地設定旗標；預設值為 "
":const:`False`，這意味著 Python 不會退出，直到由 :class:`ThreadingMixIn` "
"建立的所有執行緒都退出。"

#: ../../library/socketserver.rst:73
#, fuzzy
msgid ""
"Server classes have the same external methods and attributes, no matter what "
"network protocol they use."
msgstr "伺服器類具有相同的外部方法和屬性，無論它們使用什麼網絡協定。"

#: ../../library/socketserver.rst:78
#, fuzzy
msgid "Server Creation Notes"
msgstr "伺服器建立說明"

#: ../../library/socketserver.rst:80
#, fuzzy
msgid ""
"There are five classes in an inheritance diagram, four of which represent "
"synchronous servers of four types::"
msgstr "一個繼承圖中有五個類，其中四個代表四種型別的同步伺服器::"

#: ../../library/socketserver.rst:97
#, fuzzy
msgid ""
"Note that :class:`UnixDatagramServer` derives from :class:`UDPServer`, not "
"from :class:`UnixStreamServer` --- the only difference between an IP and a "
"Unix server is the address family."
msgstr ""
"請注意 :class:`UnixDatagramServer` "
"派生自 :class:`UDPServer`，而不是 :class:`UnixStreamServer` --- IP 和 Unix "
"伺服器之間的唯一區別是地址族。"

#: ../../library/socketserver.rst:105
#, fuzzy
msgid ""
"Forking and threading versions of each type of server can be created using "
"these mix-in classes.  For instance, :class:`ThreadingUDPServer` is created "
"as follows::"
msgstr "可以使用這些混合類建立每種型別伺服器的分叉和執行緒版本。例如，:class:`Threadi"
"ngUDPServer` 建立如下："

#: ../../library/socketserver.rst:112
#, fuzzy
msgid ""
"The mix-in class comes first, since it overrides a method defined in :class:"
"`UDPServer`.  Setting the various attributes also changes the behavior of "
"the underlying server mechanism."
msgstr "混合類首先出現，因為它覆蓋了 UDPServer "
"中定義的方法。設定各種屬性也會改變底層伺服器機制的行為。"

#: ../../library/socketserver.rst:116
#, fuzzy
msgid ""
":class:`ForkingMixIn` and the Forking classes mentioned below are only "
"available on POSIX platforms that support :func:`~os.fork`."
msgstr ""
":class:`ForkingMixIn` 和下面提到的 Forking 類僅在支援 :func:`~os.fork` 的 "
"POSIX 平台上可用。"

#: ../../library/socketserver.rst:119
#, fuzzy
msgid ""
":meth:`socketserver.ForkingMixIn.server_close` waits until all child "
"processes complete, except if :attr:`socketserver.ForkingMixIn."
"block_on_close` attribute is false."
msgstr ""
":meth:`socketserver.ForkingMixIn.server_close` 等待所有子行程完成，除非 "
":attr:`socketserver.ForkingMixIn.block_on_close` 屬性為 false。"

#: ../../library/socketserver.rst:123
#, fuzzy
msgid ""
":meth:`socketserver.ThreadingMixIn.server_close` waits until all non-daemon "
"threads complete, except if :attr:`socketserver.ThreadingMixIn."
"block_on_close` attribute is false. Use daemonic threads by setting :data:"
"`ThreadingMixIn.daemon_threads` to ``True`` to not wait until threads "
"complete."
msgstr ""
":meth:`socketserver.ThreadingMixIn.server_close` 等待所有非守護執行緒完成，"
"除非 :attr:`socketserver.ThreadingMixIn.block_on_close` 屬性為 false。通過將 "
":data:`ThreadingMixIn.daemon_threads` 設定為 ``True`` "
"來使用守護執行緒，不要等到執行緒完成。"

#: ../../library/socketserver.rst:132
#, fuzzy
msgid ""
":meth:`socketserver.ForkingMixIn.server_close` and :meth:`socketserver."
"ThreadingMixIn.server_close` now waits until all child processes and non-"
"daemonic threads complete. Add a new :attr:`socketserver.ForkingMixIn."
"block_on_close` class attribute to opt-in for the pre-3.7 behaviour."
msgstr ""
":meth:`socketserver.ForkingMixIn.server_close` 和 :meth:`socketserver."
"ThreadingMixIn.server_close` 現在等待所有子行程和非守護執行緒完成。"
"新增一個新的 :attr:`socketserver.ForkingMixIn.block_on_close` "
"類屬性以選擇加入 3.7 之前的行為。"

#: ../../library/socketserver.rst:144
#, fuzzy
msgid "These classes are pre-defined using the mix-in classes."
msgstr "這些類是使用混合類預定義的。"

#: ../../library/socketserver.rst:147
#, fuzzy
msgid ""
"To implement a service, you must derive a class from :class:"
"`BaseRequestHandler` and redefine its :meth:`~BaseRequestHandler.handle` "
"method. You can then run various versions of the service by combining one of "
"the server classes with your request handler class.  The request handler "
"class must be different for datagram or stream services.  This can be hidden "
"by using the handler subclasses :class:`StreamRequestHandler` or :class:"
"`DatagramRequestHandler`."
msgstr ""
"要實作服務，您必須從 :class:`BaseRequestHandler` 派生一個類並重新定義其 "
":meth:`~BaseRequestHandler.handle` 方法。然後，您可以通過將其中一個伺服器類與"
"您的請求處理程式類組合來運行該服務的各種版本。資料報或流服務的請求處理程式類"
"必須不同。這可以通過使用處理程式子類別隱藏 :class:`StreamRequestHandler` "
"或 :class:`DatagramRequestHandler`。"

#: ../../library/socketserver.rst:155
#, fuzzy
msgid ""
"Of course, you still have to use your head!  For instance, it makes no sense "
"to use a forking server if the service contains state in memory that can be "
"modified by different requests, since the modifications in the child process "
"would never reach the initial state kept in the parent process and passed to "
"each child.  In this case, you can use a threading server, but you will "
"probably have to use locks to protect the integrity of the shared data."
msgstr ""
"當然，還是要用腦子！例如，如果服務在記憶體中包含可以被不同請求修改的狀態，則"
"使用分叉伺服器是沒有意義的，因為子行程中的修改永遠不會達到保留在父行程中並傳"
"遞給每個子行程的初始狀態.在這種情況下，您可以使用執行緒伺服器，但您可能必須使"
"用鎖來保護共享資料的完整性。"

#: ../../library/socketserver.rst:162
#, fuzzy
msgid ""
"On the other hand, if you are building an HTTP server where all data is "
"stored externally (for instance, in the file system), a synchronous class "
"will essentially render the service \"deaf\" while one request is being "
"handled -- which may be for a very long time if a client is slow to receive "
"all the data it has requested.  Here a threading or forking server is "
"appropriate."
msgstr ""
"另一方面，如果您正在構建一個 HTTP 伺服器，其中所有資料都儲存在外部（例如，在"
"文件系統中），那麼同步類實際上將在處理一個請求時使服務“失聰”——這可能是如果客"
"戶端接收它請求的所有資料的速度很慢，則會持續很長時間。這裡執行緒或分叉伺服器"
"是合適的。"

#: ../../library/socketserver.rst:168
#, fuzzy
msgid ""
"In some cases, it may be appropriate to process part of a request "
"synchronously, but to finish processing in a forked child depending on the "
"request data.  This can be implemented by using a synchronous server and "
"doing an explicit fork in the request handler class :meth:"
"`~BaseRequestHandler.handle` method."
msgstr ""
"在某些情況下，同步處理部分請求可能是合適的，但根據請求資料在分叉子中完成處理"
"。這可以通過使用同步伺服器並在請求處理程式類 :meth:`~BaseRequestHandler."
"handle` 方法中進行顯式分叉來實作。"

#: ../../library/socketserver.rst:173
#, fuzzy
msgid ""
"Another approach to handling multiple simultaneous requests in an "
"environment that supports neither threads nor :func:`~os.fork` (or where "
"these are too expensive or inappropriate for the service) is to maintain an "
"explicit table of partially finished requests and to use :mod:`selectors` to "
"decide which request to work on next (or whether to handle a new incoming "
"request).  This is particularly important for stream services where each "
"client can potentially be connected for a long time (if threads or "
"subprocesses cannot be used).  See :mod:`asyncore` for another way to manage "
"this."
msgstr ""
"在既不支援執行緒也不支援 :func:`~os.fork` 的環境中處理多個同時請求的另一種方"
"法是維護一個顯式的部分完成請求表並使用 :mod:`selectors` 來決定接下來處理哪個請"
"求（或是否處理新的傳入請求）。這對於每個客戶端都可能連接很長時間的流服務尤其"
"重要（如果不能使用執行緒或子行程）。請參閱 :mod:`asyncore` "
"以了解另一種管理方式。"

#: ../../library/socketserver.rst:187
#, fuzzy
msgid "Server Objects"
msgstr "伺服器物件"

#: ../../library/socketserver.rst:191
#, fuzzy
msgid ""
"This is the superclass of all Server objects in the module.  It defines the "
"interface, given below, but does not implement most of the methods, which is "
"done in subclasses.  The two parameters are stored in the respective :attr:"
"`server_address` and :attr:`RequestHandlerClass` attributes."
msgstr ""
"這是模組中所有伺服器物件的超類。它定義了下面給出的介面，但沒有實作大部分方法"
"，這些方法是在子類別中完成的。這兩個參數儲存在各自的 :attr:`server_address` "
"和 :attr:`RequestHandlerClass` 屬性中。"

#: ../../library/socketserver.rst:199
#, fuzzy
msgid ""
"Return an integer file descriptor for the socket on which the server is "
"listening.  This function is most commonly passed to :mod:`selectors`, to "
"allow monitoring multiple servers in the same process."
msgstr "回傳伺服器正在偵聽的 socket 的整數文件描述器。此函式最常傳遞給 "
":mod:`selectors`，以允許在同一行程中監視多個伺服器。"

#: ../../library/socketserver.rst:206
#, fuzzy
msgid ""
"Process a single request.  This function calls the following methods in "
"order: :meth:`get_request`, :meth:`verify_request`, and :meth:"
"`process_request`.  If the user-provided :meth:`~BaseRequestHandler.handle` "
"method of the handler class raises an exception, the server's :meth:"
"`handle_error` method will be called.  If no request is received within :"
"attr:`timeout` seconds, :meth:`handle_timeout` will be called and :meth:"
"`handle_request` will return."
msgstr ""
"處理單個請求。此函式按順序呼叫以下方法：:meth:`get_request`、:meth:`verify_re"
"quest` 和 :meth:`process_request`。如果處理程式類的使用者提供的 "
":meth:`~BaseRequestHandler.handle` 方法引發例外，將呼叫伺服器的 "
":meth:`handle_error` 方法。如果在 :attr:`timeout` "
"秒內沒有收到請求，:meth:`handle_timeout` 將被呼叫並且 :meth:`handle_request` "
"將回傳。"

#: ../../library/socketserver.rst:218
#, fuzzy
msgid ""
"Handle requests until an explicit :meth:`shutdown` request.  Poll for "
"shutdown every *poll_interval* seconds. Ignores the :attr:`timeout` "
"attribute.  It also calls :meth:`service_actions`, which may be used by a "
"subclass or mixin to provide actions specific to a given service.  For "
"example, the :class:`ForkingMixIn` class uses :meth:`service_actions` to "
"clean up zombie child processes."
msgstr ""
"處理請求直到明確的 :meth:`shutdown` 請求。每 *poll_interval* 秒輪詢關閉。"
"忽略 :attr:`timeout` 屬性。它還呼叫 :meth:`service_actions`，子類別或 mixin "
"可以使用它來提供特定於給定服務的操作。例如，:class:`ForkingMixIn` 類使用 "
":meth:`service_actions` 來清理殭屍子行程。"

#: ../../library/socketserver.rst:226
#, fuzzy
msgid "Added ``service_actions`` call to the ``serve_forever`` method."
msgstr "新增了對 serve_forever 方法的 service_actions 呼叫。"

#: ../../library/socketserver.rst:232
#, fuzzy
msgid ""
"This is called in the :meth:`serve_forever` loop. This method can be "
"overridden by subclasses or mixin classes to perform actions specific to a "
"given service, such as cleanup actions."
msgstr "這在 serve_forever 循環中呼叫。此方法可以被子類別或混合類覆蓋，以執行特定於給"
"定服務的操作，例如清理操作。"

#: ../../library/socketserver.rst:240
#, fuzzy
msgid ""
"Tell the :meth:`serve_forever` loop to stop and wait until it does. :meth:"
"`shutdown` must be called while :meth:`serve_forever` is running in a "
"different thread otherwise it will deadlock."
msgstr ""
"告訴 :meth:`serve_forever` 循環停止並等待它停止。 :meth:`shutdown` 必須在 "
":meth:`serve_forever` 在不同執行緒中運行時呼叫，否則會死鎖。"

#: ../../library/socketserver.rst:247
#, fuzzy
msgid "Clean up the server. May be overridden."
msgstr "清理伺服器。可能被覆蓋。"

#: ../../library/socketserver.rst:252
#, fuzzy
msgid ""
"The family of protocols to which the server's socket belongs. Common "
"examples are :const:`socket.AF_INET` and :const:`socket.AF_UNIX`."
msgstr "伺服器 socket 所屬的協定系列。常見的例子是 :const:`socket.AF_INET` 和 "
":const:`socket.AF_UNIX`。"

#: ../../library/socketserver.rst:258
#, fuzzy
msgid ""
"The user-provided request handler class; an instance of this class is "
"created for each request."
msgstr "使用者提供的請求處理程式類；為每個請求建立此類的一個實例。"

#: ../../library/socketserver.rst:264
#, fuzzy
msgid ""
"The address on which the server is listening.  The format of addresses "
"varies depending on the protocol family; see the documentation for the :mod:"
"`socket` module for details.  For internet protocols, this is a tuple "
"containing a string giving the address, and an integer port number: "
"``('127.0.0.1', 80)``, for example."
msgstr ""
"伺服器正在偵聽的地址。地址的格式因協定族而異；有關詳細資訊，請參閱 "
":mod:`socket` 模組的文檔。對於 Internet "
"協定，這是一個包含給出地址的字串和一個整數端口號的元組：例如，``("
"'127.0.0.1', 80)``。"

#: ../../library/socketserver.rst:273
#, fuzzy
msgid ""
"The socket object on which the server will listen for incoming requests."
msgstr "伺服器將在其上偵聽傳入請求的 socket 物件。"

#: ../../library/socketserver.rst:276
#, fuzzy
msgid "The server classes support the following class variables:"
msgstr "伺服器類支援以下類變數："

#: ../../library/socketserver.rst:282
#, fuzzy
msgid ""
"Whether the server will allow the reuse of an address.  This defaults to :"
"const:`False`, and can be set in subclasses to change the policy."
msgstr "伺服器是否允許重複使用地址。這預設為 "
":const:`False`，並且可以在子類別中設定以更改策略。"

#: ../../library/socketserver.rst:288
#, fuzzy
msgid ""
"The size of the request queue.  If it takes a long time to process a single "
"request, any requests that arrive while the server is busy are placed into a "
"queue, up to :attr:`request_queue_size` requests.  Once the queue is full, "
"further requests from clients will get a \"Connection denied\" error.  The "
"default value is usually 5, but this can be overridden by subclasses."
msgstr ""
"請求隊列的大小。如果處理單個請求需要很長時間，則在伺服器繁忙時到達的任何請求"
"都會被放入隊列中，最多為 :attr:`request_queue_size` "
"個請求。一旦隊列已滿，來自客戶端的進一步請求將收到“連接被拒絕”錯誤。"
"預設值通常是 5，但可以被子類別覆蓋。"

#: ../../library/socketserver.rst:297
#, fuzzy
msgid ""
"The type of socket used by the server; :const:`socket.SOCK_STREAM` and :"
"const:`socket.SOCK_DGRAM` are two common values."
msgstr ""
"伺服器使用的 socket 型別； :const:`socket.SOCK_STREAM` 和 :const:`socket."
"SOCK_DGRAM` 是兩個常用值。"

#: ../../library/socketserver.rst:303
#, fuzzy
msgid ""
"Timeout duration, measured in seconds, or :const:`None` if no timeout is "
"desired.  If :meth:`handle_request` receives no incoming requests within the "
"timeout period, the :meth:`handle_timeout` method is called."
msgstr ""
"超時持續時間，以秒為單位，如果不需要超時，則為 :const:`None`。如果 "
":meth:`handle_request` 在超時期限內沒有收到傳入請求，則呼叫 "
":meth:`handle_timeout` 方法。"

#: ../../library/socketserver.rst:308
#, fuzzy
msgid ""
"There are various server methods that can be overridden by subclasses of "
"base server classes like :class:`TCPServer`; these methods aren't useful to "
"external users of the server object."
msgstr "有多種伺服器方法可以被基本伺服器類的子類別覆蓋，例如 "
":class:`TCPServer`;這些方法對伺服器物件的外部使用者沒有用。"

#: ../../library/socketserver.rst:317
#, fuzzy
msgid ""
"Actually processes the request by instantiating :attr:`RequestHandlerClass` "
"and calling its :meth:`~BaseRequestHandler.handle` method."
msgstr ""
"實際上通過實例化 RequestHandlerClass 並呼叫它的 :meth:`~BaseRequestHandler."
"handle` 方法來處理請求。"

#: ../../library/socketserver.rst:323
#, fuzzy
msgid ""
"Must accept a request from the socket, and return a 2-tuple containing the "
"*new* socket object to be used to communicate with the client, and the "
"client's address."
msgstr "必須接受來自 socket 的請求，並回傳一個二元組，其中包含用於與客戶端通信的*新*套"
"接字物件，以及客戶端的地址。"

#: ../../library/socketserver.rst:330
#, fuzzy
msgid ""
"This function is called if the :meth:`~BaseRequestHandler.handle` method of "
"a :attr:`RequestHandlerClass` instance raises an exception.  The default "
"action is to print the traceback to standard error and continue handling "
"further requests."
msgstr ""
"如果 :attr:`RequestHandlerClass` 實例的 :meth:`~BaseRequestHandler.handle` 方"
"法引發例外，則呼叫此函式。預設操作是將回溯印出到標準錯誤並繼續處理進一步的請"
"求。"

#: ../../library/socketserver.rst:335
#, fuzzy
msgid "Now only called for exceptions derived from the :exc:`Exception` class."
msgstr "現在只呼叫派生自 :exc:`Exception` 類的例外。"

#: ../../library/socketserver.rst:342
#, fuzzy
msgid ""
"This function is called when the :attr:`timeout` attribute has been set to a "
"value other than :const:`None` and the timeout period has passed with no "
"requests being received.  The default action for forking servers is to "
"collect the status of any child processes that have exited, while in "
"threading servers this method does nothing."
msgstr ""
"當 :attr:`timeout` 屬性已設定為 :const:`None` 以外的值並且超時期限已過且未收"
"到任何請求時，將呼叫此函式。分叉伺服器的預設操作是收集任何已退出的子行程的狀"
"態，而在執行緒伺服器中，此方法不執行任何操作。"

#: ../../library/socketserver.rst:351
#, fuzzy
msgid ""
"Calls :meth:`finish_request` to create an instance of the :attr:"
"`RequestHandlerClass`.  If desired, this function can create a new process "
"or thread to handle the request; the :class:`ForkingMixIn` and :class:"
"`ThreadingMixIn` classes do this."
msgstr ""
"呼叫 :meth:`finish_request` 來建立一個 RequestHandlerClass "
"的實例。如果需要，這個函式可以建立一個新的行程或執行緒來處理請求； "
":class:`ForkingMixIn` 和 :class:`ThreadingMixIn` 類執行此操作。"

#: ../../library/socketserver.rst:363
#, fuzzy
msgid ""
"Called by the server's constructor to activate the server.  The default "
"behavior for a TCP server just invokes :meth:`~socket.socket.listen` on the "
"server's socket.  May be overridden."
msgstr ""
"由伺服器的構造函式呼叫以激活伺服器。 TCP "
"伺服器的預設行為只是在伺服器的 socket 上呼叫 :meth:`~socket.socket."
"listen`。可能被覆蓋。"

#: ../../library/socketserver.rst:370
#, fuzzy
msgid ""
"Called by the server's constructor to bind the socket to the desired "
"address. May be overridden."
msgstr "由伺服器的構造函式呼叫以將 socket 綁定到所需的地址。可能被覆蓋。"

#: ../../library/socketserver.rst:376
#, fuzzy
msgid ""
"Must return a Boolean value; if the value is :const:`True`, the request will "
"be processed, and if it's :const:`False`, the request will be denied.  This "
"function can be overridden to implement access controls for a server. The "
"default implementation always returns :const:`True`."
msgstr ""
"必須回傳一個布爾值；如果值為 :const:`True`，請求將被處理，如果值為 "
":const:`False`，請求將被拒絕。可以重寫此函式以實作對伺服器的訪問控制。"
"預設實作總是回傳 :const:`True`。"

#: ../../library/socketserver.rst:382
#, fuzzy
msgid ""
"Support for the :term:`context manager` protocol was added.  Exiting the "
"context manager is equivalent to calling :meth:`server_close`."
msgstr "新增了對 :term:`context manager` 協定的支援。退出上下文管理器等同於呼叫 "
":meth:`server_close`。"

#: ../../library/socketserver.rst:388
#, fuzzy
msgid "Request Handler Objects"
msgstr "請求處理程式物件"

#: ../../library/socketserver.rst:392
#, fuzzy
msgid ""
"This is the superclass of all request handler objects.  It defines the "
"interface, given below.  A concrete request handler subclass must define a "
"new :meth:`handle` method, and can override any of the other methods.  A new "
"instance of the subclass is created for each request."
msgstr ""
"這是所有請求處理程式物件的超類。它定義了介面，如下所示。"
"具體的請求處理程式子類別必須定義一個新的 handle "
"方法，並且可以覆蓋任何其他方法。為每個請求建立子類別的新實例。"

#: ../../library/socketserver.rst:401
#, fuzzy
msgid ""
"Called before the :meth:`handle` method to perform any initialization "
"actions required.  The default implementation does nothing."
msgstr "在 :meth:`handle` "
"方法之前呼叫以執行所需的任何初始化操作。預設實作什麼也不做。"

#: ../../library/socketserver.rst:407
#, fuzzy
msgid ""
"This function must do all the work required to service a request.  The "
"default implementation does nothing.  Several instance attributes are "
"available to it; the request is available as :attr:`self.request`; the "
"client address as :attr:`self.client_address`; and the server instance as :"
"attr:`self.server`, in case it needs access to per-server information."
msgstr ""
"此功能必須完成為請求提供服務所需的所有工作。預設實作什麼也不做。它有幾個實例"
"屬性；該請求可作為 :attr:`self.request` 獲得；客戶端地址為 :attr:`self."
"client_address`；和伺服器實例作為 :attr:`self."
"server`，以防它需要訪問每個伺服器的資訊。"

#: ../../library/socketserver.rst:413
#, fuzzy
msgid ""
"The type of :attr:`self.request` is different for datagram or stream "
"services.  For stream services, :attr:`self.request` is a socket object; for "
"datagram services, :attr:`self.request` is a pair of string and socket."
msgstr ""
"self.request 的型別對於資料報或流服務是不同的。對於流服務，:attr:`self."
"request` 是一個 socket 物件；對於資料報服務，:attr:`self.request` "
"是一對字串和 socket 。"

#: ../../library/socketserver.rst:420
#, fuzzy
msgid ""
"Called after the :meth:`handle` method to perform any clean-up actions "
"required.  The default implementation does nothing.  If :meth:`setup` raises "
"an exception, this function will not be called."
msgstr ""
"在 :meth:`handle` 方法之後呼叫以執行所需的任何清理操作。預設實作什麼也不做。"
"如果 :meth:`setup` 引發例外，則不會呼叫此函式。"

#: ../../library/socketserver.rst:428
#, fuzzy
msgid ""
"These :class:`BaseRequestHandler` subclasses override the :meth:"
"`~BaseRequestHandler.setup` and :meth:`~BaseRequestHandler.finish` methods, "
"and provide :attr:`self.rfile` and :attr:`self.wfile` attributes. The :attr:"
"`self.rfile` and :attr:`self.wfile` attributes can be read or written, "
"respectively, to get the request data or return data to the client. The :"
"attr:`!rfile` attributes support the :class:`io.BufferedIOBase` readable "
"interface, and :attr:`!wfile` attributes support the :class:`!io."
"BufferedIOBase` writable interface."
msgstr ""
"這些 :class:`BaseRequestHandler` 子類別覆蓋 :meth:`~BaseRequestHandler.setup`"
" 和 :meth:`~BaseRequestHandler.finish` 方法，並提供 :attr:`self.rfile` 和 "
":attr:`self.wfile`屬性。 :attr:`self.rfile` 和 :attr:`self.wfile` "
"屬性可以分別被讀取或寫入，以獲取請求資料或回傳資料給客戶端。 :attr:`!rfile` "
"屬性支援 :class:`io.BufferedIOBase` 可讀介面，:attr:`!wfile` "
"屬性支援 :class:`!io.BufferedIOBase` 可寫介面。"

#: ../../library/socketserver.rst:437
#, fuzzy
msgid ""
":attr:`StreamRequestHandler.wfile` also supports the :class:`io."
"BufferedIOBase` writable interface."
msgstr ":attr:`StreamRequestHandler.wfile` 還支援 :class:`io.BufferedIOBase` "
"可寫介面。"

#: ../../library/socketserver.rst:443
msgid "Examples"
msgstr "範例"

#: ../../library/socketserver.rst:446
msgid ":class:`socketserver.TCPServer` Example"
msgstr ":class:`socketserver.TCPServer` 範例"

#: ../../library/socketserver.rst:448 ../../library/socketserver.rst:547
#, fuzzy
msgid "This is the server side::"
msgstr "這是伺服器端::"

#: ../../library/socketserver.rst:478
#, fuzzy
msgid ""
"An alternative request handler class that makes use of streams (file-like "
"objects that simplify communication by providing the standard file "
"interface)::"
msgstr "使用流的替代請求處理程式類（通過提供標准文件介面簡化通信的類似文件的物件）："

#: ../../library/socketserver.rst:493
#, fuzzy
msgid ""
"The difference is that the ``readline()`` call in the second handler will "
"call ``recv()`` multiple times until it encounters a newline character, "
"while the single ``recv()`` call in the first handler will just return what "
"has been sent from the client in one ``sendall()`` call."
msgstr ""
"不同之處在於，第二個處理程式中的 ``readline()`` 呼叫將多次呼叫 ``recv()`` "
"直到遇到換行符，而第一個處理程式中的單個 ``recv()`` 呼叫只會回傳客戶端在一次 "
"sendall() 呼叫中發送的內容。"

#: ../../library/socketserver.rst:499 ../../library/socketserver.rst:571
#, fuzzy
msgid "This is the client side::"
msgstr "這是客戶端::"

#: ../../library/socketserver.rst:520 ../../library/socketserver.rst:646
#, fuzzy
msgid "The output of the example should look something like this:"
msgstr "該示例的輸出應如下所示："

#: ../../library/socketserver.rst:522
#, fuzzy
msgid "Server:"
msgstr "伺服器："

#: ../../library/socketserver.rst:532
#, fuzzy
msgid "Client:"
msgstr "客戶："

#: ../../library/socketserver.rst:545
msgid ":class:`socketserver.UDPServer` Example"
msgstr ":class:`socketserver.UDPServer` 範例"

#: ../../library/socketserver.rst:590
#, fuzzy
msgid ""
"The output of the example should look exactly like for the TCP server "
"example."
msgstr "該示例的輸出應該與 TCP 伺服器示例完全一樣。"

#: ../../library/socketserver.rst:594
#, fuzzy
msgid "Asynchronous Mixins"
msgstr "非同步混合"

#: ../../library/socketserver.rst:596
#, fuzzy
msgid ""
"To build asynchronous handlers, use the :class:`ThreadingMixIn` and :class:"
"`ForkingMixIn` classes."
msgstr "要構建非同步處理程式，請使用 ThreadingMixIn 和 ForkingMixIn 類。"

#: ../../library/socketserver.rst:599
#, fuzzy
msgid "An example for the :class:`ThreadingMixIn` class::"
msgstr "ThreadingMixIn 類的示例："

#: ../../library/socketserver.rst:657
#, fuzzy
msgid ""
"The :class:`ForkingMixIn` class is used in the same way, except that the "
"server will spawn a new process for each request. Available only on POSIX "
"platforms that support :func:`~os.fork`."
msgstr ""
":class:`ForkingMixIn` "
"類以相同的方式使用，除了伺服器將為每個請求生成一個新行程。僅在支援 :func:`~os"
".fork` 的 POSIX 平台上可用。"
