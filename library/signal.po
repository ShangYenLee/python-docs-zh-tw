# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-24 00:16+0000\n"
"PO-Revision-Date: 2018-05-23 16:10+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../library/signal.rst:2
msgid ":mod:`signal` --- Set handlers for asynchronous events"
msgstr ":mod:`signal` --- 設定非同步事件的處理程式"

#: ../../library/signal.rst:7
msgid "**Source code:** :source:`Lib/signal.py`"
msgstr "**原始碼：**\\ :source:`Lib/signal.py`"

#: ../../library/signal.rst:11
#, fuzzy
msgid "This module provides mechanisms to use signal handlers in Python."
msgstr "該模組提供了在 Python 中使用信號處理程式的機制。"

#: ../../library/signal.rst:15
msgid "General rules"
msgstr "一般規則"

#: ../../library/signal.rst:17
#, fuzzy
msgid ""
"The :func:`signal.signal` function allows defining custom handlers to be "
"executed when a signal is received.  A small number of default handlers are "
"installed: :const:`SIGPIPE` is ignored (so write errors on pipes and sockets "
"can be reported as ordinary Python exceptions) and :const:`SIGINT` is "
"translated into a :exc:`KeyboardInterrupt` exception if the parent process "
"has not changed it."
msgstr ""
":func:`signal.signal` 函式允許定義在接收到信號時執行的自定義處理程式。安裝了"
"少量預設處理程式：:const:`SIGPIPE` 被忽略（因此可以將管道和 socket 上的寫入錯誤"
"報告為普通的 Python 例外）並且 :const:`SIGINT` 被翻譯成:exc:"
"`KeyboardInterrupt`如果父行程沒有更改它，則例外。"

#: ../../library/signal.rst:24
#, fuzzy
msgid ""
"A handler for a particular signal, once set, remains installed until it is "
"explicitly reset (Python emulates the BSD style interface regardless of the "
"underlying implementation), with the exception of the handler for :const:"
"`SIGCHLD`, which follows the underlying implementation."
msgstr ""
"特定信號的處理程式，一旦設定，將保持安裝狀態，直到它被顯式重置（Python 模擬 "
"BSD 樣式介面，而不管底層實作如何），但 :const:`SIGCHLD` 的處理程式除外，它遵"
"循底層實作."

#: ../../library/signal.rst:29
#, fuzzy
msgid ""
"On WebAssembly platforms ``wasm32-emscripten`` and ``wasm32-wasi``, signals "
"are emulated and therefore behave differently. Several functions and signals "
"are not available on these platforms."
msgstr ""
"在 WebAssembly 平台 ``wasm32-emscripten`` 和 ``wasm32-wasi`` 上，信號被模擬，因此表現"
"不同。一些功能和信號在這些平台上不可用。"

#: ../../library/signal.rst:34
msgid "Execution of Python signal handlers"
msgstr "執行 Python 信號處理程式"

#: ../../library/signal.rst:36
#, fuzzy
msgid ""
"A Python signal handler does not get executed inside the low-level (C) "
"signal handler.  Instead, the low-level signal handler sets a flag which "
"tells the :term:`virtual machine` to execute the corresponding Python signal "
"handler at a later point(for example at the next :term:`bytecode` "
"instruction). This has consequences:"
msgstr ""
"Python 信號處理程式不會在低階 (C) 信號處理程式中執行。相反，低階信號處理程式"
"設定一個旗標，告訴虛擬機稍後執行相應的 Python 信號處理程式（例如在下一個位元"
"組碼指令）。這會產生以下後果："

#: ../../library/signal.rst:42
#, fuzzy
msgid ""
"It makes little sense to catch synchronous errors like :const:`SIGFPE` or :"
"const:`SIGSEGV` that are caused by an invalid operation in C code.  Python "
"will return from the signal handler to the C code, which is likely to raise "
"the same signal again, causing Python to apparently hang.  From Python 3.3 "
"onwards, you can use the :mod:`faulthandler` module to report on synchronous "
"errors."
msgstr ""
"捕獲由 C 程式碼中的無效操作引起的 SIGFPE 或 SIGSEGV 等同步錯誤毫無意義。 "
"Python 將從信號處理程式回傳到 C 程式碼，這可能會再次引發相同的信號，導致 "
"Python 明顯掛起。從 Python 3.3 開始，您可以使用 :mod:`faulthandler` 模組來報"
"告同步錯誤。"

#: ../../library/signal.rst:49
#, fuzzy
msgid ""
"A long-running calculation implemented purely in C (such as regular "
"expression matching on a large body of text) may run uninterrupted for an "
"arbitrary amount of time, regardless of any signals received.  The Python "
"signal handlers will be called when the calculation finishes."
msgstr ""
"完全用 C 實作的長時間運行的計算（例如對大量文本進行正則表達式匹配）可能會在任"
"意時間內不間斷地運行，而不管收到的任何信號。計算完成後將呼叫 Python 信號處理"
"程式。"

#: ../../library/signal.rst:54
#, fuzzy
msgid ""
"If the handler raises an exception, it will be raised \"out of thin air\" in "
"the main thread. See the :ref:`note below <handlers-and-exceptions>` for a "
"discussion."
msgstr ""
"如果處理程式引發例外，它將在主執行緒中“憑空”引發。請參閱下面的 :ref:`note "
"<handlers-and-exceptions>` 進行討論。"

#: ../../library/signal.rst:62
#, fuzzy
msgid "Signals and threads"
msgstr "信號和執行緒"

#: ../../library/signal.rst:64
#, fuzzy
msgid ""
"Python signal handlers are always executed in the main Python thread of the "
"main interpreter, even if the signal was received in another thread.  This "
"means that signals can't be used as a means of inter-thread communication.  "
"You can use the synchronization primitives from the :mod:`threading` module "
"instead."
msgstr ""
"Python 信號處理程式始終在主直譯器的主 Python 執行緒中執行，即使信號是在另一個"
"執行緒中接收到的。這意味著信號不能用作執行緒間通信的手段。您可以改用 :mod:"
"`threading` 模組中的同步原語。"

#: ../../library/signal.rst:69
#, fuzzy
msgid ""
"Besides, only the main thread of the main interpreter is allowed to set a "
"new signal handler."
msgstr "此外，只允許主直譯器的主執行緒設定新的信號處理程式。"

#: ../../library/signal.rst:73
msgid "Module contents"
msgstr "模組內容"

#: ../../library/signal.rst:75
#, fuzzy
msgid ""
"signal (SIG*), handler (:const:`SIG_DFL`, :const:`SIG_IGN`) and sigmask (:"
"const:`SIG_BLOCK`, :const:`SIG_UNBLOCK`, :const:`SIG_SETMASK`) related "
"constants listed below were turned into :class:`enums <enum.IntEnum>` (:"
"class:`Signals`, :class:`Handlers` and :class:`Sigmasks` respectively). :"
"func:`getsignal`, :func:`pthread_sigmask`, :func:`sigpending` and :func:"
"`sigwait` functions return human-readable :class:`enums <enum.IntEnum>` as :"
"class:`Signals` objects."
msgstr ""
"signal (SIG*), handler (:const:`SIG_DFL`, :const:`SIG_IGN`) 和 sigmask (:"
"const:`SIG_BLOCK`, :const:`SIG_UNBLOCK`, :const:`SIG_SETMASK`) 相關常數如下所"
"列被轉化為 enums <enum.IntEnum>（分別為 :class:`Signals`、:class:`Handlers` "
"和 :class:`Sigmasks`）。 :func:`getsignal`、:func:`pthread_sigmask`、:func:"
"`sigpending` 和 :func:`sigwait` 函式回傳人類可讀的 :class:`enums <enum."
"IntEnum>` 作為 :class:`Signals`物件。"

#: ../../library/signal.rst:85
#, fuzzy
msgid "The signal module defines three enums:"
msgstr "信號模組定義了三個枚舉："

#: ../../library/signal.rst:89
#, fuzzy
msgid ""
":class:`enum.IntEnum` collection of SIG* constants and the CTRL_* constants."
msgstr ":class:`enum.IntEnum` SIG* 常數和 CTRL_* 常數的集合。"

#: ../../library/signal.rst:95
#, fuzzy
msgid ""
":class:`enum.IntEnum` collection the constants :const:`SIG_DFL` and :const:"
"`SIG_IGN`."
msgstr ":class:`enum.IntEnum` 收集常數 :const:`SIG_DFL` 和 :const:`SIG_IGN`。"

#: ../../library/signal.rst:101
#, fuzzy
msgid ""
":class:`enum.IntEnum` collection the constants :const:`SIG_BLOCK`, :const:"
"`SIG_UNBLOCK` and :const:`SIG_SETMASK`."
msgstr ""
":class:`enum.IntEnum` 集合常數 :const:`SIG_BLOCK`, :const:`SIG_UNBLOCK` 和 :"
"const:`SIG_SETMASK`。"

#: ../../library/signal.rst:103 ../../library/signal.rst:136
#: ../../library/signal.rst:148 ../../library/signal.rst:154
#: ../../library/signal.rst:164 ../../library/signal.rst:178
#: ../../library/signal.rst:196 ../../library/signal.rst:204
#: ../../library/signal.rst:230 ../../library/signal.rst:236
#: ../../library/signal.rst:242 ../../library/signal.rst:349
#: ../../library/signal.rst:388 ../../library/signal.rst:435
#: ../../library/signal.rst:469 ../../library/signal.rst:499
#: ../../library/signal.rst:506 ../../library/signal.rst:559
#: ../../library/signal.rst:601 ../../library/signal.rst:616
#: ../../library/signal.rst:642 ../../library/signal.rst:662
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`適用 <availability>`：Unix。"

#: ../../library/signal.rst:105 ../../library/signal.rst:471
msgid ""
"See the man page :manpage:`sigprocmask(2)` and :manpage:`pthread_sigmask(3)` "
"for further information."
msgstr ""
"更多資訊請見 :manpage:`sigprocmask(2)` 與 :manpage:`pthread_sigmask(3)` 手冊"
"頁。"

#: ../../library/signal.rst:111
#, fuzzy
msgid "The variables defined in the :mod:`signal` module are:"
msgstr ":mod:`signal` 模組中定義的變數是："

#: ../../library/signal.rst:116
#, fuzzy
msgid ""
"This is one of two standard signal handling options; it will simply perform "
"the default function for the signal.  For example, on most systems the "
"default action for :const:`SIGQUIT` is to dump core and exit, while the "
"default action for :const:`SIGCHLD` is to simply ignore it."
msgstr ""
"這是兩個標准信號處理選項之一；它將簡單地執行信號的預設功能。例如，在大多數係"
"統上 :const:`SIGQUIT` 的預設操作是轉儲核心並退出，而 :const:`SIGCHLD` 的預設"
"操作是簡單地忽略它。"

#: ../../library/signal.rst:124
#, fuzzy
msgid ""
"This is another standard signal handler, which will simply ignore the given "
"signal."
msgstr "這是另一個標准信號處理程式，它將簡單地忽略給定信號。"

#: ../../library/signal.rst:130
msgid "Abort signal from :manpage:`abort(3)`."
msgstr "來自 :manpage:`abort(3)` 的中止信號。"

#: ../../library/signal.rst:134
msgid "Timer signal from :manpage:`alarm(2)`."
msgstr "來自 :manpage:`alarm(2)` 的定時器信號。"

#: ../../library/signal.rst:140
#, fuzzy
msgid "Interrupt from keyboard (CTRL + BREAK)."
msgstr "從鍵盤中斷 (CTRL + BREAK)。"

#: ../../library/signal.rst:142 ../../library/signal.rst:260
#: ../../library/signal.rst:270
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`適用 <availability>`：Windows。"

#: ../../library/signal.rst:146
#, fuzzy
msgid "Bus error (bad memory access)."
msgstr "總線錯誤（記憶體訪問錯誤）。"

#: ../../library/signal.rst:152
#, fuzzy
msgid "Child process stopped or terminated."
msgstr "子行程停止或終止。"

#: ../../library/signal.rst:158
msgid "Alias to :data:`SIGCHLD`."
msgstr ":data:`SIGCHLD` 的別名。"

#: ../../library/signal.rst:162
msgid "Continue the process if it is currently stopped"
msgstr "如果當前已停止，則繼續該行程"

#: ../../library/signal.rst:168
#, fuzzy
msgid "Floating-point exception. For example, division by zero."
msgstr "浮點例外。例如，除以零。"

#: ../../library/signal.rst:171
#, fuzzy
msgid ""
":exc:`ZeroDivisionError` is raised when the second argument of a division or "
"modulo operation is zero."
msgstr ":exc:`ZeroDivisionError` 當除法或模運算的第二個參數為零時引發。"

#: ../../library/signal.rst:176
#, fuzzy
msgid ""
"Hangup detected on controlling terminal or death of controlling process."
msgstr "在控制終端上檢測到掛斷或控制行程死亡。"

#: ../../library/signal.rst:182
#, fuzzy
msgid "Illegal instruction."
msgstr "非法指令。"

#: ../../library/signal.rst:186
msgid "Interrupt from keyboard (CTRL + C)."
msgstr "從鍵盤中斷 (CTRL + C)。"

#: ../../library/signal.rst:188
#, fuzzy
msgid "Default action is to raise :exc:`KeyboardInterrupt`."
msgstr "預設操作是引發 :exc:`KeyboardInterrupt`。"

#: ../../library/signal.rst:192
#, fuzzy
msgid "Kill signal."
msgstr "殺信號。"

#: ../../library/signal.rst:194
#, fuzzy
msgid "It cannot be caught, blocked, or ignored."
msgstr "它不能被捕獲、阻止或忽略。"

#: ../../library/signal.rst:200
#, fuzzy
msgid "Broken pipe: write to pipe with no readers."
msgstr "損壞的管道：寫入沒有讀者的管道。"

#: ../../library/signal.rst:202
#, fuzzy
msgid "Default action is to ignore the signal."
msgstr "預設操作是忽略信號。"

#: ../../library/signal.rst:208
#, fuzzy
msgid "Segmentation fault: invalid memory reference."
msgstr "分段錯誤：無效的記憶體引用。"

#: ../../library/signal.rst:212
#, fuzzy
msgid ""
"Stack fault on coprocessor. The Linux kernel does not raise this signal: it "
"can only be raised in user space."
msgstr "協處理器堆疊錯誤。 Linux 內核不會引發此信號：它只能在使用者空間引發。"

#: ../../library/signal.rst:215
msgid ":ref:`Availability <availability>`: Linux."
msgstr ":ref:`適用 <availability>`：Linux。"

#: ../../library/signal.rst:217
#, fuzzy
msgid ""
"On architectures where the signal is available. See the man page :manpage:"
"`signal(7)` for further information."
msgstr ""
"在信號可用的架構上。有關詳細資訊，請參閱手冊頁 :manpage:`signal(7)`。"

#: ../../library/signal.rst:224
msgid "Termination signal."
msgstr "終止信號。"

#: ../../library/signal.rst:228
msgid "User-defined signal 1."
msgstr "使用者自訂信號 1。"

#: ../../library/signal.rst:234
msgid "User-defined signal 2."
msgstr "使用者自訂信號 2."

#: ../../library/signal.rst:240
#, fuzzy
msgid "Window resize signal."
msgstr "窗口調整大小信號。"

#: ../../library/signal.rst:246
#, fuzzy
msgid ""
"All the signal numbers are defined symbolically.  For example, the hangup "
"signal is defined as :const:`signal.SIGHUP`; the variable names are "
"identical to the names used in C programs, as found in ``<signal.h>``.  The "
"Unix man page for ':c:func:`signal`' lists the existing signals (on some "
"systems this is :manpage:`signal(2)`, on others the list is in :manpage:"
"`signal(7)`). Note that not all systems define the same set of signal names; "
"only those names defined by the system are defined by this module."
msgstr ""
"所有信號編號均以符號方式定義。例如，掛斷信號定義為 :const:`signal.SIGHUP`；變"
"數名稱與 C 程式中使用的名稱相同，如 ``<signal.h>`` 中所見。 ':c:func:"
"`signal`' 的 Unix 手冊頁列出了現有的信號（在某些系統上，這是 :manpage:"
"`signal(2)`，在其他系統上，列表在 :manpage:`signal(7)` ).請注意，並非所有系統"
"都定義了同一組信號名稱；只有系統定義的名稱才由該模組定義。"

#: ../../library/signal.rst:257
#, fuzzy
msgid ""
"The signal corresponding to the :kbd:`Ctrl+C` keystroke event. This signal "
"can only be used with :func:`os.kill`."
msgstr ""
"對應於 :kbd:`Ctrl+C` 擊鍵事件的信號。此信號只能與 :func:`os.kill` 一起使用。"

#: ../../library/signal.rst:267
#, fuzzy
msgid ""
"The signal corresponding to the :kbd:`Ctrl+Break` keystroke event. This "
"signal can only be used with :func:`os.kill`."
msgstr ""
"對應於 :kbd:`Ctrl+Break` 擊鍵事件的信號。此信號只能與 :func:`os.kill` 一起使"
"用。"

#: ../../library/signal.rst:277
#, fuzzy
msgid ""
"One more than the number of the highest signal number. Use :func:"
"`valid_signals` to get valid signal numbers."
msgstr "比最高信號數多一。使用 :func:`valid_signals` 獲取有效信號編號。"

#: ../../library/signal.rst:283
#, fuzzy
msgid ""
"Decrements interval timer in real time, and delivers :const:`SIGALRM` upon "
"expiration."
msgstr "實時遞減間隔計時器，並在到期時傳遞 :const:`SIGALRM`。"

#: ../../library/signal.rst:289
#, fuzzy
msgid ""
"Decrements interval timer only when the process is executing, and delivers "
"SIGVTALRM upon expiration."
msgstr "僅當行程正在執行時遞減間隔計時器，並在到期時傳遞 SIGVTALRM。"

#: ../../library/signal.rst:295
#, fuzzy
msgid ""
"Decrements interval timer both when the process executes and when the system "
"is executing on behalf of the process. Coupled with ITIMER_VIRTUAL, this "
"timer is usually used to profile the time spent by the application in user "
"and kernel space. SIGPROF is delivered upon expiration."
msgstr ""
"在行程執行時和系統代表行程執行時遞減間隔計時器。與 ITIMER_VIRTUAL 結合使用，"
"此計時器通常用於分析應用程式在使用者和內核空間中花費的時間。 SIGPROF 在到期時"
"交付。"

#: ../../library/signal.rst:303
#, fuzzy
msgid ""
"A possible value for the *how* parameter to :func:`pthread_sigmask` "
"indicating that signals are to be blocked."
msgstr ":func:`pthread_sigmask` 的 *how* 參數的一個可能值，表示要阻止信號。"

#: ../../library/signal.rst:310
#, fuzzy
msgid ""
"A possible value for the *how* parameter to :func:`pthread_sigmask` "
"indicating that signals are to be unblocked."
msgstr ""
":func:`pthread_sigmask` 的 *how* 參數的一個可能值，表示要解除阻塞的信號。"

#: ../../library/signal.rst:317
#, fuzzy
msgid ""
"A possible value for the *how* parameter to :func:`pthread_sigmask` "
"indicating that the signal mask is to be replaced."
msgstr ":func:`pthread_sigmask` 的 *how* 參數的可能值，表示要替換信號掩碼。"

#: ../../library/signal.rst:323
#, fuzzy
msgid "The :mod:`signal` module defines one exception:"
msgstr ":mod:`signal` 模組定義了一個例外："

#: ../../library/signal.rst:327
#, fuzzy
msgid ""
"Raised to signal an error from the underlying :func:`setitimer` or :func:"
"`getitimer` implementation. Expect this error if an invalid interval timer "
"or a negative time is passed to :func:`setitimer`. This error is a subtype "
"of :exc:`OSError`."
msgstr ""
"引發以發出來自底層 setitimer 或 getitimer 實作的錯誤信號。如果將無效的間隔計"
"時器或負時間傳遞給 :func:`setitimer`，則預計會出現此錯誤。此錯誤是 :exc:"
"`OSError` 的子型別。"

#: ../../library/signal.rst:332
#, fuzzy
msgid ""
"This error used to be a subtype of :exc:`IOError`, which is now an alias of :"
"exc:`OSError`."
msgstr "此錯誤曾經是 :exc:`IOError` 的子型別，現在是 :exc:`OSError` 的別名。"

#: ../../library/signal.rst:337
msgid "The :mod:`signal` module defines the following functions:"
msgstr ":mod:`signal` 模組定義了以下函式："

#: ../../library/signal.rst:342
#, fuzzy
msgid ""
"If *time* is non-zero, this function requests that a :const:`SIGALRM` signal "
"be sent to the process in *time* seconds. Any previously scheduled alarm is "
"canceled (only one alarm can be scheduled at any time).  The returned value "
"is then the number of seconds before any previously set alarm was to have "
"been delivered. If *time* is zero, no alarm is scheduled, and any scheduled "
"alarm is canceled.  If the return value is zero, no alarm is currently "
"scheduled."
msgstr ""
"如果 *time* 不為零，此函式請求在 *time* 秒後向行程發送一個 "
"SIGALRM 信號。取消任何先前安排的鬧鐘（任何時候只能安排一個鬧鐘）。回傳值是之"
"前設定的任何警報被發送之前的秒數。如果 *time* 為零，則不安排鬧鐘，並且取消任"
"何安排的鬧鐘。如果回傳值為零，則當前沒有安排警報。"

#: ../../library/signal.rst:351
msgid "See the man page :manpage:`alarm(2)` for further information."
msgstr "更多資訊請見 :manpage:`alarm(2)` 手冊頁。"

#: ../../library/signal.rst:356
#, fuzzy
msgid ""
"Return the current signal handler for the signal *signalnum*. The returned "
"value may be a callable Python object, or one of the special values :const:"
"`signal.SIG_IGN`, :const:`signal.SIG_DFL` or :const:`None`.  Here, :const:"
"`signal.SIG_IGN` means that the signal was previously ignored, :const:"
"`signal.SIG_DFL` means that the default way of handling the signal was "
"previously in use, and ``None`` means that the previous signal handler was "
"not installed from Python."
msgstr ""
"回傳信號 *signalnum* 的當前信號處理程式。回傳值可能是一個可呼叫的 Python 物"
"件，或者是以下特殊值之一 :const:`signal.SIG_IGN`、:const:`signal.SIG_DFL` "
"或 :const:`None`。這裡，:const:`signal.SIG_IGN` 表示信號之前被忽略，:const:"
"`signal.SIG_DFL` 表示處理信號的預設方式以前被使用過，``None`` 表示之前的信號"
"信號處理程式不是從 Python 安裝的。"

#: ../../library/signal.rst:367
#, fuzzy
msgid ""
"Returns the description of signal *signalnum*, such as \"Interrupt\" for :"
"const:`SIGINT`. Returns :const:`None` if *signalnum* has no description. "
"Raises :exc:`ValueError` if *signalnum* is invalid."
msgstr ""
"回傳信號 *signalnum* 的描述，例如 :const:`SIGINT` 的“中斷”。如果 *signalnum* "
"沒有描述，則回傳 :const:`None`。如果 *signalnum* 無效，則引發 :exc:"
"`ValueError`。"

#: ../../library/signal.rst:376
#, fuzzy
msgid ""
"Return the set of valid signal numbers on this platform.  This can be less "
"than ``range(1, NSIG)`` if some signals are reserved by the system for "
"internal use."
msgstr ""
"回傳此平台上的有效信號編號集。如果系統保留某些信號供內部使用，則這可以小於 ``range(1, NSIG)``。"

#: ../../library/signal.rst:385
#, fuzzy
msgid ""
"Cause the process to sleep until a signal is received; the appropriate "
"handler will then be called.  Returns nothing."
msgstr "使行程休眠，直到收到信號；然後將呼叫適當的處理程式。什麼都不回傳。"

#: ../../library/signal.rst:390
msgid "See the man page :manpage:`signal(2)` for further information."
msgstr "更多資訊請見 :manpage:`signal(2)` 手冊頁。"

#: ../../library/signal.rst:392
#, fuzzy
msgid ""
"See also :func:`sigwait`, :func:`sigwaitinfo`, :func:`sigtimedwait` and :"
"func:`sigpending`."
msgstr ""
"另見 :func:`sigwait`、:func:`sigwaitinfo`、:func:`sigtimedwait` 和 :func:"
"`sigpending`。"

#: ../../library/signal.rst:398
#, fuzzy
msgid "Sends a signal to the calling process. Returns nothing."
msgstr "向呼叫行程發送信號。什麼都不回傳。"

#: ../../library/signal.rst:405
#, fuzzy
msgid ""
"Send signal *sig* to the process referred to by file descriptor *pidfd*. "
"Python does not currently support the *siginfo* parameter; it must be "
"``None``.  The *flags* argument is provided for future extensions; no flag "
"values are currently defined."
msgstr ""
"向文件描述器 *pidfd* 引用的行程發送信號 *sig*。 Python 目前不支援 *siginfo* "
"參數；它必須是 ``None`` 。 *flags* 參數是為將來的擴充提供的；當前沒有定義旗標值。"

#: ../../library/signal.rst:410
msgid "See the :manpage:`pidfd_send_signal(2)` man page for more information."
msgstr "更多資訊請見 :manpage:`pidfd_send_signal(2)` 手冊頁。"

#: ../../library/signal.rst:412
msgid ":ref:`Availability <availability>`: Linux >= 5.1"
msgstr ":ref:`適用 <availability>`：Linux 5.1 以上"

#: ../../library/signal.rst:418
#, fuzzy
msgid ""
"Send the signal *signalnum* to the thread *thread_id*, another thread in the "
"same process as the caller.  The target thread can be executing any code "
"(Python or not).  However, if the target thread is executing the Python "
"interpreter, the Python signal handlers will be :ref:`executed by the main "
"thread of the main interpreter <signals-and-threads>`.  Therefore, the only "
"point of sending a signal to a particular Python thread would be to force a "
"running system call to fail with :exc:`InterruptedError`."
msgstr ""
"將信號 *signalnum* 發送到執行緒 *thread_id*，這是與呼叫者在同一行程中的另一個"
"執行緒。目標執行緒可以執行任何程式碼（Python 或非 Python）。但是，如果目標執"
"行緒正在執行 Python 直譯器，則 Python 信號處理程式將 :ref:`由主直譯器 "
"<signals-and-threads>` 的主執行緒執行。因此，向特定 Python 執行緒發送信號的唯"
"一目的是強制正在運行的系統呼叫失敗並回傳 :exc:`InterruptedError`。"

#: ../../library/signal.rst:426
#, fuzzy
msgid ""
"Use :func:`threading.get_ident()` or the :attr:`~threading.Thread.ident` "
"attribute of :class:`threading.Thread` objects to get a suitable value for "
"*thread_id*."
msgstr ""
"使用 :func:`threading.get_ident()` 或 :class:`threading.Thread` 物件的 :attr:"
"`~threading.Thread.ident` 屬性為 *thread_id* 獲取合適的值。"

#: ../../library/signal.rst:430
#, fuzzy
msgid ""
"If *signalnum* is 0, then no signal is sent, but error checking is still "
"performed; this can be used to check if the target thread is still running."
msgstr ""
"如果*signalnum*為0，則不發送信號，但仍進行錯誤檢查；這可用於檢查目標執行緒是"
"否仍在運行。"

#: ../../library/signal.rst:433
msgid ""
"Raises an :ref:`auditing event <auditing>` ``signal.pthread_kill`` with "
"arguments ``thread_id``, ``signalnum``."
msgstr ""
"引發一個附帶引數 ``thread_id``、``signalnum`` 的\\ :ref:`稽核事件 "
"<auditing>` ``signal.pthread_kill``。"

#: ../../library/signal.rst:437
msgid "See the man page :manpage:`pthread_kill(3)` for further  information."
msgstr "更多資訊請見 :manpage:`pthread_kill(3)` 手冊頁。"

#: ../../library/signal.rst:439
msgid "See also :func:`os.kill`."
msgstr "另請參閱 :func:`os.kill`。"

#: ../../library/signal.rst:446
#, fuzzy
msgid ""
"Fetch and/or change the signal mask of the calling thread.  The signal mask "
"is the set of signals whose delivery is currently blocked for the caller. "
"Return the old signal mask as a set of signals."
msgstr ""
"獲取和/或更改呼叫執行緒的信號掩碼。信號掩碼是一組信號，其傳遞當前被阻止給呼叫"
"者。將舊信號掩碼作為一組信號回傳。"

#: ../../library/signal.rst:450
#, fuzzy
msgid ""
"The behavior of the call is dependent on the value of *how*, as follows."
msgstr "呼叫的行為取決於 *how* 的值，如下所示。"

#: ../../library/signal.rst:452
#, fuzzy
msgid ""
":data:`SIG_BLOCK`: The set of blocked signals is the union of the current "
"set and the *mask* argument."
msgstr ":data:`SIG_BLOCK`：阻塞信號集是當前集和 *mask* 參數的並集。"

#: ../../library/signal.rst:454
#, fuzzy
msgid ""
":data:`SIG_UNBLOCK`: The signals in *mask* are removed from the current set "
"of blocked signals.  It is permissible to attempt to unblock a signal which "
"is not blocked."
msgstr ""
":data:`SIG_UNBLOCK`：*mask* 中的信號從當前的阻塞信號集中移除。允許嘗試解鎖未"
"阻塞的信號。"

#: ../../library/signal.rst:457
#, fuzzy
msgid ""
":data:`SIG_SETMASK`: The set of blocked signals is set to the *mask* "
"argument."
msgstr ":data:`SIG_SETMASK`：阻塞信號集設定為 *mask* 參數。"

#: ../../library/signal.rst:460
#, fuzzy
msgid ""
"*mask* is a set of signal numbers (e.g. { :const:`signal.SIGINT`, :const:"
"`signal.SIGTERM`}). Use :func:`~signal.valid_signals` for a full mask "
"including all signals."
msgstr ""
"*mask* 是一組信號編號（例如 { :const:`signal.SIGINT`, :const:`signal."
"SIGTERM`}）。使用 :func:`~signal.valid_signals` 獲取包含所有信號的完整掩碼。"

#: ../../library/signal.rst:464
#, fuzzy
msgid ""
"For example, ``signal.pthread_sigmask(signal.SIG_BLOCK, [])`` reads the "
"signal mask of the calling thread."
msgstr ""
"例如，``signal.pthread_sigmask(signal.SIG_BLOCK, [])`` 讀取呼叫執行緒的信號掩"
"碼。"

#: ../../library/signal.rst:467
#, fuzzy
msgid ":data:`SIGKILL` and :data:`SIGSTOP` cannot be blocked."
msgstr ":data:`SIGKILL` 和 :data:`SIGSTOP` 不能被阻止。"

#: ../../library/signal.rst:474
msgid "See also :func:`pause`, :func:`sigpending` and :func:`sigwait`."
msgstr "另請參閱 :func:`pause`\\ 、\\ :func:`sigpending` 與 :func:`sigwait`。"

#: ../../library/signal.rst:481
#, fuzzy
msgid ""
"Sets given interval timer (one of :const:`signal.ITIMER_REAL`, :const:"
"`signal.ITIMER_VIRTUAL` or :const:`signal.ITIMER_PROF`) specified by *which* "
"to fire after *seconds* (float is accepted, different from :func:`alarm`) "
"and after that every *interval* seconds (if *interval* is non-zero). The "
"interval timer specified by *which* can be cleared by setting *seconds* to "
"zero."
msgstr ""
"設定由 *which* 指定的給定間隔計時器（:const:`signal.ITIMER_REAL`、:const:"
"`signal.ITIMER_VIRTUAL` 或 :const:`signal.ITIMER_PROF` 之一）在 *seconds* 後"
"觸發（接受浮點數，不同於 :func:`alarm`) 之後每隔 *interval* 秒（如果 "
"*interval* 非零）。由 *which* 指定的間隔計時器可以通過將 *seconds* 設定為零來"
"清除。"

#: ../../library/signal.rst:488
#, fuzzy
msgid ""
"When an interval timer fires, a signal is sent to the process. The signal "
"sent is dependent on the timer being used; :const:`signal.ITIMER_REAL` will "
"deliver :const:`SIGALRM`, :const:`signal.ITIMER_VIRTUAL` sends :const:"
"`SIGVTALRM`, and :const:`signal.ITIMER_PROF` will deliver :const:`SIGPROF`."
msgstr ""
"當一個間隔計時器觸發時，一個信號被發送到行程。發送的信號取決於所使用的定時"
"器； :const:`signal.ITIMER_REAL` 將傳遞 :const:`SIGALRM`，:const:`signal."
"ITIMER_VIRTUAL` 發送 :const:`SIGVTALRM`，而 :const:`signal.ITIMER_PROF` 將傳"
"遞 :const:`SIGPROF` ."

#: ../../library/signal.rst:494
#, fuzzy
msgid "The old values are returned as a tuple: (delay, interval)."
msgstr "舊值作為元組回傳：（延遲，間隔）。"

#: ../../library/signal.rst:496
#, fuzzy
msgid ""
"Attempting to pass an invalid interval timer will cause an :exc:"
"`ItimerError`."
msgstr "嘗試傳遞無效的間隔計時器將導致 :exc:`ItimerError`。"

#: ../../library/signal.rst:504
#, fuzzy
msgid "Returns current value of a given interval timer specified by *which*."
msgstr "回傳由 *which* 指定的給定間隔計時器的當前值。"

#: ../../library/signal.rst:511
#, fuzzy
msgid ""
"Set the wakeup file descriptor to *fd*.  When a signal is received, the "
"signal number is written as a single byte into the fd.  This can be used by "
"a library to wakeup a poll or select call, allowing the signal to be fully "
"processed."
msgstr ""
"將喚醒文件描述器設定為 *fd*。當接收到信號時，信號編號將作為單個位元組寫入 "
"fd。庫可以使用它來喚醒輪詢或選擇呼叫，從而使信號得到完全處理。"

#: ../../library/signal.rst:516
#, fuzzy
msgid ""
"The old wakeup fd is returned (or -1 if file descriptor wakeup was not "
"enabled).  If *fd* is -1, file descriptor wakeup is disabled. If not -1, "
"*fd* must be non-blocking.  It is up to the library to remove any bytes from "
"*fd* before calling poll or select again."
msgstr ""
"回傳舊的喚醒 fd（如果未啟用文件描述器喚醒，則回傳 -1）。如果 *fd* 為 -1，文件"
"描述器喚醒被禁用。如果不是 -1，*fd* 必須是非阻塞的。在再次呼叫 poll 或 "
"select 之前，由庫從 *fd* 中刪除任何位元組。"

#: ../../library/signal.rst:521 ../../library/signal.rst:576
#, fuzzy
msgid ""
"When threads are enabled, this function can only be called from :ref:`the "
"main thread of the main interpreter <signals-and-threads>`; attempting to "
"call it from other threads will cause a :exc:`ValueError` exception to be "
"raised."
msgstr ""
"啟用執行緒時，此函式只能從 :ref:`主直譯器的主執行緒 <signals-and-threads>` 呼"
"叫；嘗試從其他執行緒呼叫它會導致引發 :exc:`ValueError` 例外。"

#: ../../library/signal.rst:526
#, fuzzy
msgid ""
"There are two common ways to use this function. In both approaches, you use "
"the fd to wake up when a signal arrives, but then they differ in how they "
"determine *which* signal or signals have arrived."
msgstr ""
"有兩種常用的方法來使用此功能。在這兩種方法中，您都使用 fd 在信號到達時喚醒，"
"但是它們在確定*哪個*信號或信號到達的方式上有所不同。"

#: ../../library/signal.rst:531
#, fuzzy
msgid ""
"In the first approach, we read the data out of the fd's buffer, and the byte "
"values give you the signal numbers. This is simple, but in rare cases it can "
"run into a problem: generally the fd will have a limited amount of buffer "
"space, and if too many signals arrive too quickly, then the buffer may "
"become full, and some signals may be lost. If you use this approach, then "
"you should set ``warn_on_full_buffer=True``, which will at least cause a "
"warning to be printed to stderr when signals are lost."
msgstr ""
"在第一種方法中，我們從 fd 的緩衝區中讀取資料，位元組值為您提供信號編號。這很"
"簡單，但在極少數情況下會遇到問題：通常 fd 的緩衝區空間有限，如果太多信號到達"
"得太快，緩衝區可能會變滿，一些信號可能會丟失。如果您使用這種方法，那麼您應該"
"設定 ``warn_on_full_buffer=True``，這至少會導致在信號丟失時將警告印出到 "
"stderr。"

#: ../../library/signal.rst:540
#, fuzzy
msgid ""
"In the second approach, we use the wakeup fd *only* for wakeups, and ignore "
"the actual byte values. In this case, all we care about is whether the fd's "
"buffer is empty or non-empty; a full buffer doesn't indicate a problem at "
"all. If you use this approach, then you should set "
"``warn_on_full_buffer=False``, so that your users are not confused by "
"spurious warning messages."
msgstr ""
"在第二種方法中，我們*僅*使用喚醒 fd 進行喚醒，並忽略實際位元組值。在這種情況"
"下，我們只關心 fd 的緩衝區是空的還是非空的；一個完整的緩衝區根本不表示有問"
"題。如果您使用這種方法，那麼您應該設定 ``warn_on_full_buffer=False``，這樣您"
"的使用者就不會被虛假的警告消息所迷惑。"

#: ../../library/signal.rst:547
#, fuzzy
msgid "On Windows, the function now also supports socket handles."
msgstr "在 Windows 上，該函式現在還支援 socket 句柄。"

#: ../../library/signal.rst:550
msgid "Added ``warn_on_full_buffer`` parameter."
msgstr "新增 ``warn_on_full_buffer`` 參數。"

#: ../../library/signal.rst:555
#, fuzzy
msgid ""
"Change system call restart behaviour: if *flag* is :const:`False`, system "
"calls will be restarted when interrupted by signal *signalnum*, otherwise "
"system calls will be interrupted.  Returns nothing."
msgstr ""
"更改系統呼叫重啟行為：如果 *flag* 為 :const:`False`，系統呼叫將在被信號 "
"*signalnum* 中斷時重啟，否則係統呼叫將被中斷。什麼都不回傳。"

#: ../../library/signal.rst:561
msgid "See the man page :manpage:`siginterrupt(3)` for further information."
msgstr "更多資訊請見 :manpage:`siginterrupt(3)` 手冊頁。"

#: ../../library/signal.rst:563
#, fuzzy
msgid ""
"Note that installing a signal handler with :func:`signal` will reset the "
"restart behaviour to interruptible by implicitly calling :c:func:"
"`siginterrupt` with a true *flag* value for the given signal."
msgstr ""
"請注意，使用 :func:`signal` 安裝信號處理程式會將重啟行為重置為可中斷，方法是"
"通過使用給定信號的真實 *flag* 值隱式呼叫 :c:func:`siginterrupt` 。"

#: ../../library/signal.rst:570
#, fuzzy
msgid ""
"Set the handler for signal *signalnum* to the function *handler*.  *handler* "
"can be a callable Python object taking two arguments (see below), or one of "
"the special values :const:`signal.SIG_IGN` or :const:`signal.SIG_DFL`.  The "
"previous signal handler will be returned (see the description of :func:"
"`getsignal` above).  (See the Unix man page :manpage:`signal(2)` for further "
"information.)"
msgstr ""
"將信號 *signalnum* 的處理程式設定為函式 *handler*。 *handler* 可以是一個可呼"
"叫的 Python 物件，它有兩個參數（見下文），或者是特殊值之一 :const:`signal."
"SIG_IGN` 或 :const:`signal.SIG_DFL`。將回傳先前的信號處理程式（請參閱上面對 :"
"func:`getsignal` 的描述）。 （有關更多資訊，請參閱 Unix 手冊頁：聯機幫助頁："
"`signal(2)`。）"

#: ../../library/signal.rst:581
#, fuzzy
msgid ""
"The *handler* is called with two arguments: the signal number and the "
"current stack frame (``None`` or a frame object; for a description of frame "
"objects, see the :ref:`description in the type hierarchy <frame-objects>` or "
"see the attribute descriptions in the :mod:`inspect` module)."
msgstr ""
"*handler* 用兩個參數呼叫：信號編號和當前堆疊幀（``None`` 或幀物件；有關幀物件"
"的描述，請參閱型別層次結構 <frame- 中的 :ref:` 描述objects>` 或查看 :mod:"
"`inspect` 模組中的屬性描述）。"

#: ../../library/signal.rst:586
#, fuzzy
msgid ""
"On Windows, :func:`signal` can only be called with :const:`SIGABRT`, :const:"
"`SIGFPE`, :const:`SIGILL`, :const:`SIGINT`, :const:`SIGSEGV`, :const:"
"`SIGTERM`, or :const:`SIGBREAK`. A :exc:`ValueError` will be raised in any "
"other case. Note that not all systems define the same set of signal names; "
"an :exc:`AttributeError` will be raised if a signal name is not defined as "
"``SIG*`` module level constant."
msgstr ""
"在 Windows 上，:func:`signal` 只能通過以下方式呼叫 :const:`SIGABRT`、:const:"
"`SIGFPE`、:const:`SIGILL`、:const:`SIGINT`、:const:`SIGSEGV`、: const:"
"`SIGTERM` 或 :const:`SIGBREAK`。在任何其他情況下都會引發 :exc:`ValueError`。"
"請注意，並非所有系統都定義了同一組信號名稱；如果信號名稱未定義為 ``SIG*`` 模"
"組級常數，則會引發 :exc:`AttributeError`。"

#: ../../library/signal.rst:597
#, fuzzy
msgid ""
"Examine the set of signals that are pending for delivery to the calling "
"thread (i.e., the signals which have been raised while blocked).  Return the "
"set of the pending signals."
msgstr ""
"檢查等待傳遞給呼叫執行緒的信號集（即，在阻塞時發出的信號）。回傳掛起信號的集"
"合。"

#: ../../library/signal.rst:603
msgid "See the man page :manpage:`sigpending(2)` for further information."
msgstr "更多資訊請見 :manpage:`sigpending(2)` 手冊頁。"

#: ../../library/signal.rst:605
msgid "See also :func:`pause`, :func:`pthread_sigmask` and :func:`sigwait`."
msgstr ""
"另請參閱 :func:`pause`\\ 、\\ :func:`pthread_sigmask` 與 :func:`sigwait`。"

#: ../../library/signal.rst:612
#, fuzzy
msgid ""
"Suspend execution of the calling thread until the delivery of one of the "
"signals specified in the signal set *sigset*.  The function accepts the "
"signal (removes it from the pending list of signals), and returns the signal "
"number."
msgstr ""
"暫停呼叫執行緒的執行，直到傳遞信號集 *sigset* 中指定的信號之一。該函式接受信"
"號（將其從未決信號列表中刪除），並回傳信號編號。"

#: ../../library/signal.rst:618
msgid "See the man page :manpage:`sigwait(3)` for further information."
msgstr "更多資訊請見 :manpage:`sigwait(3)` 手冊頁。"

#: ../../library/signal.rst:620
#, fuzzy
msgid ""
"See also :func:`pause`, :func:`pthread_sigmask`, :func:`sigpending`, :func:"
"`sigwaitinfo` and :func:`sigtimedwait`."
msgstr ""
"另見 :func:`pause`、:func:`pthread_sigmask`、:func:`sigpending`、:func:"
"`sigwaitinfo` 和 :func:`sigtimedwait`。"

#: ../../library/signal.rst:628
#, fuzzy
msgid ""
"Suspend execution of the calling thread until the delivery of one of the "
"signals specified in the signal set *sigset*.  The function accepts the "
"signal and removes it from the pending list of signals. If one of the "
"signals in *sigset* is already pending for the calling thread, the function "
"will return immediately with information about that signal. The signal "
"handler is not called for the delivered signal. The function raises an :exc:"
"`InterruptedError` if it is interrupted by a signal that is not in *sigset*."
msgstr ""
"暫停呼叫執行緒的執行，直到傳遞信號集 *sigset* 中指定的信號之一。該函式接受信"
"號並將其從未決信號列表中刪除。如果 *sigset* 中的信號之一已經等待呼叫執行緒，"
"該函式將立即回傳有關該信號的資訊。不為傳遞的信號呼叫信號處理程式。如果函式被"
"不在 *sigset* 中的信號中斷，該函式將引發 :exc:`InterruptedError`。"

#: ../../library/signal.rst:637
#, fuzzy
msgid ""
"The return value is an object representing the data contained in the :c:type:"
"`siginfo_t` structure, namely: :attr:`si_signo`, :attr:`si_code`, :attr:"
"`si_errno`, :attr:`si_pid`, :attr:`si_uid`, :attr:`si_status`, :attr:"
"`si_band`."
msgstr ""
"回傳值是一個物件，表示 :c:type:`siginfo_t` 結構中包含的資料，即：:attr:"
"`si_signo`、:attr:`si_code`、:attr:`si_errno`、:attr:`si_pid `、:attr:"
"`si_uid`、:attr:`si_status`、:attr:`si_band`。"

#: ../../library/signal.rst:644
msgid "See the man page :manpage:`sigwaitinfo(2)` for further information."
msgstr "更多資訊請見 :manpage:`sigwaitinfo(2)` 手冊頁。"

#: ../../library/signal.rst:646
msgid "See also :func:`pause`, :func:`sigwait` and :func:`sigtimedwait`."
msgstr ""
"另請參閱 :func:`pause`\\ 、\\ :func:`sigwait` 與 :func:`sigtimedwait`。"

#: ../../library/signal.rst:650
#, fuzzy
msgid ""
"The function is now retried if interrupted by a signal not in *sigset* and "
"the signal handler does not raise an exception (see :pep:`475` for the "
"rationale)."
msgstr ""
"如果被不在 *sigset* 中的信號中斷並且信號處理程式不會引發例外（請參閱 :pep:"
"`475` 了解基本原理），該函式現在會重試。"

#: ../../library/signal.rst:658
#, fuzzy
msgid ""
"Like :func:`sigwaitinfo`, but takes an additional *timeout* argument "
"specifying a timeout. If *timeout* is specified as :const:`0`, a poll is "
"performed. Returns :const:`None` if a timeout occurs."
msgstr ""
"類似於 :func:`sigwaitinfo`，但需要一個額外的 *timeout* 參數來指定超時。如果 "
"*timeout* 指定為 :const:`0`，則執行輪詢。如果發生超時，則回傳 :const:`None`。"

#: ../../library/signal.rst:664
msgid "See the man page :manpage:`sigtimedwait(2)` for further information."
msgstr "更多資訊請見 :manpage:`sigtimedwait(2)` 手冊頁。"

#: ../../library/signal.rst:666
msgid "See also :func:`pause`, :func:`sigwait` and :func:`sigwaitinfo`."
msgstr "另請參閱 :func:`pause`\\ 、\\ :func:`sigwait` 與 :func:`sigwaitinfo`。"

#: ../../library/signal.rst:670
#, fuzzy
msgid ""
"The function is now retried with the recomputed *timeout* if interrupted by "
"a signal not in *sigset* and the signal handler does not raise an exception "
"(see :pep:`475` for the rationale)."
msgstr ""
"如果被不在 *sigset* 中的信號中斷，並且信號處理程式不會引發例外（請參閱 :pep:"
"`475` 了解基本原理），該函式現在會使用重新計算的 *timeout* 重試。"

#: ../../library/signal.rst:679
msgid "Examples"
msgstr "範例"

#: ../../library/signal.rst:681
#, fuzzy
msgid ""
"Here is a minimal example program. It uses the :func:`alarm` function to "
"limit the time spent waiting to open a file; this is useful if the file is "
"for a serial device that may not be turned on, which would normally cause "
"the :func:`os.open` to hang indefinitely.  The solution is to set a 5-second "
"alarm before opening the file; if the operation takes too long, the alarm "
"signal will be sent, and the handler raises an exception. ::"
msgstr ""
"這是一個最小的示例程式。它使用 :func:`alarm` 函式來限制等待打開文件所花費的時"
"間；如果文件是用於可能未打開的串行設備的，這將很有用，這通常會導致 :func:`os."
"open` 無限期掛起。解決辦法是在打開文件前設定5秒的鬧鐘；如果操作時間過長，將發"
"送警報信號，並且處理程式會引發例外。 ::"

#: ../../library/signal.rst:705
#, fuzzy
msgid "Note on SIGPIPE"
msgstr "關於 SIGPIPE 的註釋"

#: ../../library/signal.rst:707
#, fuzzy
msgid ""
"Piping output of your program to tools like :manpage:`head(1)` will cause a :"
"const:`SIGPIPE` signal to be sent to your process when the receiver of its "
"standard output closes early.  This results in an exception like :code:"
"`BrokenPipeError: [Errno 32] Broken pipe`.  To handle this case, wrap your "
"entry point to catch this exception as follows::"
msgstr ""
"將程式的輸出通過管道傳輸到 :manpage:`head(1)` 等工具將導致 :const:`SIGPIPE` "
"信號在其標準輸出的接收器提前關閉時發送到您的行程。這會導致類似 :code:"
"`BrokenPipeError: [Errno 32] Broken pipe` 的例外。要處理這種情況，請包裝您的"
"入口點以捕獲此例外，如下所示："

#: ../../library/signal.rst:734
#, fuzzy
msgid ""
"Do not set :const:`SIGPIPE`'s disposition to :const:`SIG_DFL` in order to "
"avoid :exc:`BrokenPipeError`.  Doing that would cause your program to exit "
"unexpectedly whenever any socket connection is interrupted while your "
"program is still writing to it."
msgstr ""
"不要將 :const:`SIGPIPE` 的處置設定為 :const:`SIG_DFL` 以避免 :exc:"
"`BrokenPipeError`。這樣做會導致您的程式在您的程式仍在寫入時任何 socket 連接中斷"
"時意外退出。"

#: ../../library/signal.rst:743
msgid "Note on Signal Handlers and Exceptions"
msgstr "關於信號處理程式和例外的註釋"

#: ../../library/signal.rst:745
#, fuzzy
msgid ""
"If a signal handler raises an exception, the exception will be propagated to "
"the main thread and may be raised after any :term:`bytecode` instruction. "
"Most notably, a :exc:`KeyboardInterrupt` may appear at any point during "
"execution. Most Python code, including the standard library, cannot be made "
"robust against this, and so a :exc:`KeyboardInterrupt` (or any other "
"exception resulting from a signal handler) may on rare occasions put the "
"program in an unexpected state."
msgstr ""
"如果信號處理程式引發例外，例外將傳播到主執行緒，並且可能在任何 :term:"
"`bytecode` 指令之後引發。最值得注意的是，:exc:`KeyboardInterrupt` 可能會在執"
"行期間的任何時候出現。大多數 Python 程式碼，包括標準庫，都不能針對此變得健"
"壯，因此 :exc:`KeyboardInterrupt`（或信號處理程式產生的任何其他例外）在極少數"
"情況下可能會使程式處於意外狀態。"

#: ../../library/signal.rst:752
msgid "To illustrate this issue, consider the following code::"
msgstr "為了說明這個問題，請先參考以下程式碼："

#: ../../library/signal.rst:769
#, fuzzy
msgid ""
"For many programs, especially those that merely want to exit on :exc:"
"`KeyboardInterrupt`, this is not a problem, but applications that are "
"complex or require high reliability should avoid raising exceptions from "
"signal handlers. They should also avoid catching :exc:`KeyboardInterrupt` as "
"a means of gracefully shutting down.  Instead, they should install their "
"own :const:`SIGINT` handler. Below is an example of an HTTP server that "
"avoids :exc:`KeyboardInterrupt`::"
msgstr ""
"對於許多程式，尤其是那些只想在 :exc:`KeyboardInterrupt` 退出的程式，這不是問"
"題，但複雜或需要高可靠性的應用程式應避免從信號處理程式引發例外。他們還應該避"
"免捕捉 :exc:`KeyboardInterrupt` 作為正常關閉的方式。相反，他們應該安裝自己"
"的 :const:`SIGINT` 處理程式。下面是一個避免 :exc:`KeyboardInterrupt`:: 的 "
"HTTP 伺服器的例子："
