# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-03-20 00:13+0000\n"
"PO-Revision-Date: 2015-12-09 17:51+0000\n"
"Last-Translator: Liang-Bo Wang <me@liang2.tw>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/textwrap.rst:2
#, fuzzy
msgid ":mod:`textwrap` --- Text wrapping and filling"
msgstr ":mod:`textwrap` --- 文本環繞和填充"

#: ../../library/textwrap.rst:10
msgid "**Source code:** :source:`Lib/textwrap.py`"
msgstr "**原始碼：**\\ :source:`Lib/textwrap.py`"

#: ../../library/textwrap.rst:14
#, fuzzy
msgid ""
"The :mod:`textwrap` module provides some convenience functions, as well as :"
"class:`TextWrapper`, the class that does all the work. If you're just "
"wrapping or filling one or two text strings, the convenience functions "
"should be good enough; otherwise, you should use an instance of :class:"
"`TextWrapper` for efficiency."
msgstr ""
":mod:`textwrap` 模組提供了一些方便的功能，以及 :class:`TextWrapper`，這個類完"
"成所有的工作。如果您只是包裝或填充一兩個文本字串，那麼便利功能應該足夠了；否"
"則，您應該使用 :class:`TextWrapper` 的實例以提高效率。"

#: ../../library/textwrap.rst:27
#, fuzzy
msgid ""
"Wraps the single paragraph in *text* (a string) so every line is at most "
"*width* characters long.  Returns a list of output lines, without final "
"newlines."
msgstr "將單個段落包裝在 *text*（字串）中，因此每一行的長度最多為 *width* "
"個字元。回傳輸出行列表，沒有最終換行符。"

#: ../../library/textwrap.rst:31
#, fuzzy
msgid ""
"Optional keyword arguments correspond to the instance attributes of :class:"
"`TextWrapper`, documented below."
msgstr "可選關鍵字參數對應於 TextWrapper 的實例屬性，如下所述。"

#: ../../library/textwrap.rst:34
#, fuzzy
msgid ""
"See the :meth:`TextWrapper.wrap` method for additional details on how :func:"
"`wrap` behaves."
msgstr "有關 :func:`wrap` 行為方式的更多詳細資訊，請參閱 :meth:`TextWrapper.wrap` "
"方法。"

#: ../../library/textwrap.rst:45
#, fuzzy
msgid ""
"Wraps the single paragraph in *text*, and returns a single string containing "
"the wrapped paragraph.  :func:`fill` is shorthand for  ::"
msgstr "將單個段落包裝在 *text* 中，並回傳包含包裝段落的單個字串。 :func:`fill` 是 ::"
" 的簡寫"

#: ../../library/textwrap.rst:50
#, fuzzy
msgid ""
"In particular, :func:`fill` accepts exactly the same keyword arguments as :"
"func:`wrap`."
msgstr "特別是，:func:`fill` 接受與 :func:`wrap` 完全相同的關鍵字參數。"

#: ../../library/textwrap.rst:58
#, fuzzy
msgid "Collapse and truncate the given *text* to fit in the given *width*."
msgstr "折疊並截斷給定的 *text* 以適應給定的 *width*。"

#: ../../library/textwrap.rst:60
#, fuzzy
msgid ""
"First the whitespace in *text* is collapsed (all whitespace is replaced by "
"single spaces).  If the result fits in the *width*, it is returned. "
"Otherwise, enough words are dropped from the end so that the remaining words "
"plus the :attr:`placeholder` fit within :attr:`width`::"
msgstr ""
"首先折疊 *text* 中的空格（所有空格都被單個空格替換）。如果結果適合 "
"*width*，則回傳。否則，從末尾刪除足夠多的單詞，以便剩餘的單詞加上 "
":attr:`placeholder` 適合 :attr:`width`::"

#: ../../library/textwrap.rst:72
#, fuzzy
msgid ""
"Optional keyword arguments correspond to the instance attributes of :class:"
"`TextWrapper`, documented below.  Note that the whitespace is collapsed "
"before the text is passed to the :class:`TextWrapper` :meth:`fill` function, "
"so changing the value of :attr:`.tabsize`, :attr:`.expand_tabs`, :attr:`."
"drop_whitespace`, and :attr:`.replace_whitespace` will have no effect."
msgstr ""
"可選關鍵字參數對應於 TextWrapper 的實例屬性，如下所述。請注意，"
"在將文本傳遞給 :class:`TextWrapper` :meth:`fill` 函式之前，空格會折疊，"
"因此更改 :attr:`.tabsize`、:attr:`.expand_tabs`、:attr 的值:`."
"drop_whitespace` 和 :attr:`.replace_whitespace` 將無效。"

#: ../../library/textwrap.rst:82
#, fuzzy
msgid "Remove any common leading whitespace from every line in *text*."
msgstr "從 *text* 中的每一行中刪除所有常見的前導空格。"

#: ../../library/textwrap.rst:84
#, fuzzy
msgid ""
"This can be used to make triple-quoted strings line up with the left edge of "
"the display, while still presenting them in the source code in indented form."
msgstr "這可用於使三引號字串與顯示的左邊緣對齊，同時仍以縮進形式在源程式碼中顯示它們"
"。"

#: ../../library/textwrap.rst:87
#, fuzzy
msgid ""
"Note that tabs and spaces are both treated as whitespace, but they are not "
"equal: the lines ``\"  hello\"`` and ``\"\\thello\"`` are considered to have "
"no common leading whitespace."
msgstr "請注意，製表符和空格都被視為空白，但它們並不相等：行 ``hello``和“\\thello"
"”被認為沒有共同的前導空白。"

#: ../../library/textwrap.rst:91
#, fuzzy
msgid ""
"Lines containing only whitespace are ignored in the input and normalized to "
"a single newline character in the output."
msgstr "僅包含空格的行在輸入中將被忽略，並在輸出中標準化為單個換行符。"

#: ../../library/textwrap.rst:94 ../../library/textwrap.rst:115
msgid "For example::"
msgstr ""
"舉例來說：\n"
"\n"
"::"

#: ../../library/textwrap.rst:108
#, fuzzy
msgid "Add *prefix* to the beginning of selected lines in *text*."
msgstr "將 *prefix* 新增到 *text* 中選定行的開頭。"

#: ../../library/textwrap.rst:110
#, fuzzy
msgid "Lines are separated by calling ``text.splitlines(True)``."
msgstr "通過呼叫 text.splitlines(True) 來分隔行。"

#: ../../library/textwrap.rst:112
#, fuzzy
msgid ""
"By default, *prefix* is added to all lines that do not consist solely of "
"whitespace (including any line endings)."
msgstr "預設情況下，*prefix* 被新增到所有不僅僅由空格組成的行（包括任何行結尾）。"

#: ../../library/textwrap.rst:121
#, fuzzy
msgid ""
"The optional *predicate* argument can be used to control which lines are "
"indented. For example, it is easy to add *prefix* to even empty and "
"whitespace-only lines::"
msgstr "可選的 *predicate* 參數可用於控制縮進的行。例如，很容易將 *prefix* "
"新增到空行和純空格行::"

#: ../../library/textwrap.rst:134
#, fuzzy
msgid ""
":func:`wrap`, :func:`fill` and :func:`shorten` work by creating a :class:"
"`TextWrapper` instance and calling a single method on it.  That instance is "
"not reused, so for applications that process many text strings using :func:"
"`wrap` and/or :func:`fill`, it may be more efficient to create your own :"
"class:`TextWrapper` object."
msgstr ""
":func:`wrap`、:func:`fill` 和 :func:`shorten` 通過建立一個 "
":class:`TextWrapper` 實例並在其上呼叫單個方法來工作。該實例不會被重用，"
"因此對於使用 wrap 和/或 fill 處理許多文本字串的應用程式，建立自己的 "
"TextWrapper 物件可能更有效。"

#: ../../library/textwrap.rst:140
#, fuzzy
msgid ""
"Text is preferably wrapped on whitespaces and right after the hyphens in "
"hyphenated words; only then will long words be broken if necessary, unless :"
"attr:`TextWrapper.break_long_words` is set to false."
msgstr ""
"文本最好用空格包裹起來，並緊跟在帶連字元的單詞中的連字元之後；只有這樣，長單"
"詞才會在必要時被打斷，除非 :attr:`TextWrapper.break_long_words` 設定為 "
"false。"

#: ../../library/textwrap.rst:146
#, fuzzy
msgid ""
"The :class:`TextWrapper` constructor accepts a number of optional keyword "
"arguments.  Each keyword argument corresponds to an instance attribute, so "
"for example ::"
msgstr ":class:`TextWrapper` "
"構造函式接受許多可選的關鍵字參數。每個關鍵字參數對應一個實例屬性，例如 ::"

#: ../../library/textwrap.rst:152
#, fuzzy
msgid "is the same as  ::"
msgstr "是相同的  ：："

#: ../../library/textwrap.rst:157
#, fuzzy
msgid ""
"You can re-use the same :class:`TextWrapper` object many times, and you can "
"change any of its options through direct assignment to instance attributes "
"between uses."
msgstr "您可以多次重複使用同一個 TextWrapper "
"物件，並且可以通過在使用之間直接分配給實例屬性來更改其任何選項。"

#: ../../library/textwrap.rst:161
#, fuzzy
msgid ""
"The :class:`TextWrapper` instance attributes (and keyword arguments to the "
"constructor) are as follows:"
msgstr ":class:`TextWrapper` 實例屬性（和構造函式的關鍵字參數）如下所示："

#: ../../library/textwrap.rst:167
#, fuzzy
msgid ""
"(default: ``70``) The maximum length of wrapped lines.  As long as there are "
"no individual words in the input text longer than :attr:`width`, :class:"
"`TextWrapper` guarantees that no output line will be longer than :attr:"
"`width` characters."
msgstr ""
"（預設值：``70``）換行的最大長度。只要輸入文本中沒有單個單詞長於 "
":attr:`width`，TextWrapper 保證沒有輸出行長於 :attr:`width` 個字元。"

#: ../../library/textwrap.rst:175
#, fuzzy
msgid ""
"(default: ``True``) If true, then all tab characters in *text* will be "
"expanded to spaces using the :meth:`expandtabs` method of *text*."
msgstr ""
"（預設值：``True``）如果為 true，則 *text* 中的所有製表符都將使用 *text* 的 "
":meth:`expandtabs` 方法擴充為空格。"

#: ../../library/textwrap.rst:181
#, fuzzy
msgid ""
"(default: ``8``) If :attr:`expand_tabs` is true, then all tab characters in "
"*text* will be expanded to zero or more spaces, depending on the current "
"column and the given tab size."
msgstr ""
"（預設值：``8``）如果 :attr:`expand_tabs` 為真，則 *text* "
"中的所有製表符將擴充為零個或多個空格，具體取決於當前列和給定的製表符大小。"

#: ../../library/textwrap.rst:190
#, fuzzy
msgid ""
"(default: ``True``) If true, after tab expansion but before wrapping, the :"
"meth:`wrap` method will replace each whitespace character with a single "
"space.  The whitespace characters replaced are as follows: tab, newline, "
"vertical tab, formfeed, and carriage return (``'\\t\\n\\v\\f\\r'``)."
msgstr ""
"（預設值：``True``）如果為 true，則在製表符擴充之後但在換行之前，:meth:`wrap`"
" 方法將用一個空格替換每個空白字元。替換的空白字元如下：製表符、換行符、垂直製"
"表符、換頁符和回車符（``'\\t\\n\\v\\f\\r'``）。"

#: ../../library/textwrap.rst:198
#, fuzzy
msgid ""
"If :attr:`expand_tabs` is false and :attr:`replace_whitespace` is true, each "
"tab character will be replaced by a single space, which is *not* the same as "
"tab expansion."
msgstr ""
"如果 :attr:`expand_tabs` 為 false 且 :attr:`replace_whitespace` 為 "
"true，則每個製表符將被單個空格替換，這與製表符擴充*不*相同。"

#: ../../library/textwrap.rst:204
#, fuzzy
msgid ""
"If :attr:`replace_whitespace` is false, newlines may appear in the middle of "
"a line and cause strange output. For this reason, text should be split into "
"paragraphs (using :meth:`str.splitlines` or similar) which are wrapped "
"separately."
msgstr ""
"如果 :attr:`replace_whitespace` 為 false，換行符可能出現在行的中間並導致奇怪"
"的輸出。出於這個原因，文本應該被分成段落（使用 :meth:`str.splitlines` "
"或類似的），單獨包裝。"

#: ../../library/textwrap.rst:212
#, fuzzy
msgid ""
"(default: ``True``) If true, whitespace at the beginning and ending of every "
"line (after wrapping but before indenting) is dropped. Whitespace at the "
"beginning of the paragraph, however, is not dropped if non-whitespace "
"follows it.  If whitespace being dropped takes up an entire line, the whole "
"line is dropped."
msgstr ""
"（預設值：``True``）如果為 true，則每行開頭和結尾的空格（在換行之後但在縮進之"
"前）將被刪除。然而，如果段落開頭的空格後面沒有空格，則它不會被刪除。如果刪除"
"的空格佔據了整行，則整行都將被刪除。"

#: ../../library/textwrap.rst:221
#, fuzzy
msgid ""
"(default: ``''``) String that will be prepended to the first line of wrapped "
"output.  Counts towards the length of the first line.  The empty string is "
"not indented."
msgstr "（預設值：``''``）將新增到包裝輸出的第一行之前的字串。計入第一行的長度。空字"
"串不縮進。"

#: ../../library/textwrap.rst:228
#, fuzzy
msgid ""
"(default: ``''``) String that will be prepended to all lines of wrapped "
"output except the first.  Counts towards the length of each line except the "
"first."
msgstr "（預設值：``''``）將新增到除第一行之外的所有包裝輸出行之前的字串。計入除第一"
"行以外的每行的長度。"

#: ../../library/textwrap.rst:235
#, fuzzy
msgid ""
"(default: ``False``) If true, :class:`TextWrapper` attempts to detect "
"sentence endings and ensure that sentences are always separated by exactly "
"two spaces.  This is generally desired for text in a monospaced font. "
"However, the sentence detection algorithm is imperfect: it assumes that a "
"sentence ending consists of a lowercase letter followed by one of ``'.'``, "
"``'!'``, or ``'?'``, possibly followed by one of ``'\"'`` or ``\"'\"``, "
"followed by a space.  One problem with this is algorithm is that it is "
"unable to detect the difference between \"Dr.\" in ::"
msgstr ""
"（預設值：``False``）如果為 true，TextWrapper 會嘗試檢測句子結尾並確保句子始"
"終由正好兩個空格分隔。這通常適用於等寬字體的文本。然而，句子檢測演算法並不完"
"美：它假定句子結尾由一個小寫字母后跟 ``.``、 ``!``或 ``?``之一組成，可能後跟 ``\\'\"\\"
"'`` 或 ``\"\\'\"`` 之一，後跟一個空格。演算法的一個問題是它無法檢測 :: "
"中的“Dr.”之間的區別"

#: ../../library/textwrap.rst:246
#, fuzzy
msgid "and \"Spot.\" in ::"
msgstr "和“現場”。在 ：："

#: ../../library/textwrap.rst:250
#, fuzzy
msgid ":attr:`fix_sentence_endings` is false by default."
msgstr ":attr:`fix_sentence_endings` 預設為 false。"

#: ../../library/textwrap.rst:252
#, fuzzy
msgid ""
"Since the sentence detection algorithm relies on ``string.lowercase`` for "
"the definition of \"lowercase letter\", and a convention of using two spaces "
"after a period to separate sentences on the same line, it is specific to "
"English-language texts."
msgstr ""
"由於句子檢測演算法依賴於 ``string.lowercase`` 來定義“小寫字母”，以及在句點後"
"使用兩個空格來分隔同一行句子的約定，因此它特定於英語文本。"

#: ../../library/textwrap.rst:260
#, fuzzy
msgid ""
"(default: ``True``) If true, then words longer than :attr:`width` will be "
"broken in order to ensure that no lines are longer than :attr:`width`.  If "
"it is false, long words will not be broken, and some lines may be longer "
"than :attr:`width`.  (Long words will be put on a line by themselves, in "
"order to minimize the amount by which :attr:`width` is exceeded.)"
msgstr ""
"（預設值：``True``）如果為 true，那麼長於 :attr:`width` 的單詞將被打斷，"
"以確保沒有行長於 "
":attr:`width`。如果為false，長單詞不會被打斷，有些行可能比 :attr:`width`長。 "
"（長單詞將自己放在一行上，以盡量減少超出 :attr:`width` 的量。）"

#: ../../library/textwrap.rst:269
#, fuzzy
msgid ""
"(default: ``True``) If true, wrapping will occur preferably on whitespaces "
"and right after hyphens in compound words, as it is customary in English. If "
"false, only whitespaces will be considered as potentially good places for "
"line breaks, but you need to set :attr:`break_long_words` to false if you "
"want truly insecable words.  Default behaviour in previous versions was to "
"always allow breaking hyphenated words."
msgstr ""
"（預設值：``True``）如果為 "
"true，則換行將優先出現在復合詞中的空格和連字元之後，這在英語中是習慣的。"
"如果為 "
"false，則只有空格將被視為換行的潛在好地方，但如果您想要真正不可分割的單詞，"
"則需要將 break_long_words 設定為 "
"false。以前版本中的預設行為是始終允許斷開帶連字元的單詞。"

#: ../../library/textwrap.rst:279
#, fuzzy
msgid ""
"(default: ``None``) If not ``None``, then the output will contain at most "
"*max_lines* lines, with *placeholder* appearing at the end of the output."
msgstr ""
"（預設值：``None``）如果不是``None``，那麼輸出將包含最多 *max_lines* "
"行，*placeholder* 出現在輸出的末尾。"

#: ../../library/textwrap.rst:289
#, fuzzy
msgid ""
"(default: ``' [...]'``) String that will appear at the end of the output "
"text if it has been truncated."
msgstr "（預設值：``' [...]'``）如果已被截斷，將出現在輸出文本末尾的字串。"

#: ../../library/textwrap.rst:295
#, fuzzy
msgid ""
":class:`TextWrapper` also provides some public methods, analogous to the "
"module-level convenience functions:"
msgstr ":class:`TextWrapper` 還提供了一些公開方法，類似於模組級便利函式："

#: ../../library/textwrap.rst:300
#, fuzzy
msgid ""
"Wraps the single paragraph in *text* (a string) so every line is at most :"
"attr:`width` characters long.  All wrapping options are taken from instance "
"attributes of the :class:`TextWrapper` instance.  Returns a list of output "
"lines, without final newlines.  If the wrapped output has no content, the "
"returned list is empty."
msgstr ""
"將單個段落包裝在 *text*（字串）中，因此每一行的長度最多為 :attr:`width` "
"個字元。所有包裝選項均取自 TextWrapper 實例的實例屬性。回傳輸出行列表，沒有最"
"終換行符。如果包裝的輸出沒有內容，則回傳的列表為空。"

#: ../../library/textwrap.rst:309
#, fuzzy
msgid ""
"Wraps the single paragraph in *text*, and returns a single string containing "
"the wrapped paragraph."
msgstr "將單個段落包裝在 *text* 中，並回傳包含包裝段落的單個字串。"
