# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-13 00:17+0000\n"
"PO-Revision-Date: 2022-10-16 04:51+0800\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.1.1\n"

#: ../../library/asynchat.rst:2
msgid ":mod:`asynchat` --- Asynchronous socket command/response handler"
msgstr ":mod:`asynchat` --- 非同步 socket 指令/回應處理函式"

#: ../../library/asynchat.rst:11
msgid "**Source code:** :source:`Lib/asynchat.py`"
msgstr "**原始碼：**\\ :source:`Lib/asynchat.py`"

#: ../../library/asynchat.rst:17
msgid ""
"The :mod:`asynchat` module is deprecated (see :pep:`PEP 594 <594#asynchat>` "
"for details). Please use :mod:`asyncio` instead."
msgstr ""
":mod:`asynchat` 已被棄用（詳情請見 :pep:`PEP 594 <594#asynchat>`\\ ）。請改"
"用 :mod:`asyncio`\\ 。"

#: ../../library/asynchat.rst:22
#, fuzzy
msgid ""
"This module exists for backwards compatibility only.  For new code we "
"recommend using :mod:`asyncio`."
msgstr "該模組的存在只是為了向後相容。對於新程式碼，我們建議使用 :mod:`asyncio`。"

#: ../../library/asynchat.rst:25
#, fuzzy
msgid ""
"This module builds on the :mod:`asyncore` infrastructure, simplifying "
"asynchronous clients and servers and making it easier to handle protocols "
"whose elements are terminated by arbitrary strings, or are of variable "
"length. :mod:`asynchat` defines the abstract class :class:`async_chat` that "
"you subclass, providing implementations of the :meth:`collect_incoming_data` "
"and :meth:`found_terminator` methods. It uses the same asynchronous loop as :"
"mod:`asyncore`, and the two types of channel, :class:`asyncore.dispatcher` "
"and :class:`asynchat.async_chat`, can freely be mixed in the channel map. "
"Typically an :class:`asyncore.dispatcher` server channel generates new :"
"class:`asynchat.async_chat` channel objects as it receives incoming "
"connection requests."
msgstr ""
"該模組建立在 :mod:`asyncore` 基礎設施之上，簡化了非同步客戶端和伺服器，並使其"
"更容易處理其元素由任意字串終止或長度可變的協定。 :mod:`asynchat` "
"定義了您子類別化的抽像類 :class:`async_chat`，提供了 "
":meth:`collect_incoming_data` 和 :meth:`found_terminator` 方法的實作。"
"它使用與 :mod:`asyncore` 相同的非同步循環，兩種型別的通道 :class:`asyncore."
"dispatcher` 和 :class:`asynchat.async_chat` 可以在通道映射中自由混合。通常 "
":class:`asyncore.dispatcher` 伺服器通道會在接收傳入的連接請求時生成新的 "
":class:`asynchat.async_chat` 通道物件。"

#: ../../includes/wasm-notavail.rst:3
#, fuzzy
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ":ref:`Availability <availability>`：不是 Emscripten，不是 WASI。"

#: ../../includes/wasm-notavail.rst:5
#, fuzzy
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"此模組在 WebAssembly 平台 ``wasm32-emscripten`` 和 ``wasm32-wasi`` 上不起作用或不可用"
"。有關更多資訊，請參閱 :ref:`wasm-availability`。"

#: ../../library/asynchat.rst:41
#, fuzzy
msgid ""
"This class is an abstract subclass of :class:`asyncore.dispatcher`. To make "
"practical use of the code you must subclass :class:`async_chat`, providing "
"meaningful :meth:`collect_incoming_data` and :meth:`found_terminator` "
"methods. The :class:`asyncore.dispatcher` methods can be used, although not "
"all make sense in a message/response context."
msgstr ""
"此類是 asyncore.dispatcher 的抽象子類別。要實際使用程式碼，您必須繼承 "
":meth:`async_chat`，提供有意義的 :meth:`collect_incoming_data` 和 "
":meth:`found_terminator` 方法。可以使用 :class:`asyncore.dispatcher` "
"方法，儘管在消息/響應上下文中並非所有方法都有意義。"

#: ../../library/asynchat.rst:48
#, fuzzy
msgid ""
"Like :class:`asyncore.dispatcher`, :class:`async_chat` defines a set of "
"events that are generated by an analysis of socket conditions after a :c:"
"func:`select` call. Once the polling loop has been started the :class:"
"`async_chat` object's methods are called by the event-processing framework "
"with no action on the part of the programmer."
msgstr ""
"與 :class:`asyncore.dispatcher` 一樣，:class:`async_chat` 定義了一組事件，"
"這些事件是在 :c:func:`select` "
"呼叫後通過分析 socket 條件生成的。一旦啟動輪詢循環，事件處理框架就會呼叫 "
"async_chat 物件的方法，程式員無需採取任何操作。"

#: ../../library/asynchat.rst:54
#, fuzzy
msgid ""
"Two class attributes can be modified, to improve performance, or possibly "
"even to conserve memory."
msgstr "可以修改兩個類屬性，以提高性能，甚至可能節省記憶體。"

#: ../../library/asynchat.rst:60
#, fuzzy
msgid "The asynchronous input buffer size (default ``4096``)."
msgstr "非同步輸入緩衝區大小（預設 ``4096``）。"

#: ../../library/asynchat.rst:65
#, fuzzy
msgid "The asynchronous output buffer size (default ``4096``)."
msgstr "非同步輸出緩衝區大小（預設 ``4096``）。"

#: ../../library/asynchat.rst:67
#, fuzzy
msgid ""
"Unlike :class:`asyncore.dispatcher`, :class:`async_chat` allows you to "
"define a :abbr:`FIFO (first-in, first-out)` queue of *producers*. A producer "
"need have only one method, :meth:`more`, which should return data to be "
"transmitted on the channel. The producer indicates exhaustion (*i.e.* that "
"it contains no more data) by having its :meth:`more` method return the empty "
"bytes object. At this point the :class:`async_chat` object removes the "
"producer from the queue and starts using the next producer, if any. When the "
"producer queue is empty the :meth:`handle_write` method does nothing. You "
"use the channel object's :meth:`set_terminator` method to describe how to "
"recognize the end of, or an important breakpoint in, an incoming "
"transmission from the remote endpoint."
msgstr ""
"與 asyncore.dispatcher 不同，async_chat 允許您定義 *producer* 的 FIFO（先進先"
"出）隊列。生產者只需要一個方法 :meth:`more`，它應該回傳要在通道上傳輸的資料。"
"生產者通過其 more 方法回傳空位元組物件來指示耗盡（*即*它不包含更多資料）。"
"此時 :class:`async_chat` 對像從隊列中刪除生產者並開始使用下一個生產者，如果有"
"的話。當生產者隊列為空時，:meth:`handle_write` 方法什麼都不做。"
"您使用通道物件的 set_terminator "
"方法來描述如何識別來自遠程端點的傳入傳輸的結束或重要斷點。"

#: ../../library/asynchat.rst:80
#, fuzzy
msgid ""
"To build a functioning :class:`async_chat` subclass your  input methods :"
"meth:`collect_incoming_data` and :meth:`found_terminator` must handle the "
"data that the channel receives asynchronously. The methods are described "
"below."
msgstr ""
"要構建一個功能性的 async_chat 子類別，您的輸入方法 collect_incoming_data 和 "
"found_terminator 必須處理通道非同步接收的資料。這些方法描述如下。"

#: ../../library/asynchat.rst:88
#, fuzzy
msgid ""
"Pushes a ``None`` on to the producer queue. When this producer is popped off "
"the queue it causes the channel to be closed."
msgstr "將 ``None`` 推送到生產者隊列。當這個生產者從隊列中彈出時，它會導致通道關閉。"

#: ../../library/asynchat.rst:94
#, fuzzy
msgid ""
"Called with *data* holding an arbitrary amount of received data.  The "
"default method, which must be overridden, raises a :exc:"
"`NotImplementedError` exception."
msgstr "使用 *data* 呼叫，其中包含任意數量的接收資料。必須重寫的預設方法會引發 "
":exc:`NotImplementedError` 例外。"

#: ../../library/asynchat.rst:101
#, fuzzy
msgid ""
"In emergencies this method will discard any data held in the input and/or "
"output buffers and the producer queue."
msgstr "在緊急情況下，此方法將丟棄輸入和/或輸出緩衝區以及生產者隊列中保存的所有資料。"

#: ../../library/asynchat.rst:107
#, fuzzy
msgid ""
"Called when the incoming data stream  matches the termination condition set "
"by :meth:`set_terminator`. The default method, which must be overridden, "
"raises a :exc:`NotImplementedError` exception. The buffered input data "
"should be available via an instance attribute."
msgstr ""
"當傳入資料流與 set_terminator 設定的終止條件匹配時呼叫。"
"必須重寫的預設方法會引發 :exc:`NotImplementedError` "
"例外。緩衝的輸入資料應該通過實例屬性可用。"

#: ../../library/asynchat.rst:115
#, fuzzy
msgid "Returns the current terminator for the channel."
msgstr "回傳通道的當前終止符。"

#: ../../library/asynchat.rst:120
#, fuzzy
msgid ""
"Pushes data on to the channel's queue to ensure its transmission. This is "
"all you need to do to have the channel write the data out to the network, "
"although it is possible to use your own producers in more complex schemes to "
"implement encryption and chunking, for example."
msgstr ""
"將資料推送到通道的隊列以確保其傳輸。這就是讓通道將資料寫入網絡所需要做的全部"
"工作，儘管可以在更複雜的方案中使用您自己的生產者來實作加密和分塊等。"

#: ../../library/asynchat.rst:128
#, fuzzy
msgid ""
"Takes a producer object and adds it to the producer queue associated with "
"the channel.  When all currently pushed producers have been exhausted the "
"channel will consume this producer's data by calling its :meth:`more` method "
"and send the data to the remote endpoint."
msgstr ""
"獲取生產者物件並將其新增到與通道關聯的生產者隊列。當所有當前推送的生產者都用"
"完時，通道將通過呼叫其 more "
"方法來使用該生產者的資料，並將資料發送到遠程端點。"

#: ../../library/asynchat.rst:136
#, fuzzy
msgid ""
"Sets the terminating condition to be recognized on the channel.  ``term`` "
"may be any of three types of value, corresponding to three different ways to "
"handle incoming protocol data."
msgstr "設定要在通道上識別的終止條件。 ``term`` "
"可以是三種型別值中的任何一種，對應於處理傳入協定資料的三種不同方式。"

#: ../../library/asynchat.rst:141
#, fuzzy
msgid "term"
msgstr "學期"

#: ../../library/asynchat.rst:141
msgid "Description"
msgstr "描述"

#: ../../library/asynchat.rst:143
#, fuzzy
msgid "*string*"
msgstr "*string*"

#: ../../library/asynchat.rst:143
#, fuzzy
msgid ""
"Will call :meth:`found_terminator` when the string is found in the input "
"stream"
msgstr "當在輸入流中找到字串時，將呼叫 :meth:`found_terminator`"

#: ../../library/asynchat.rst:146
#, fuzzy
msgid "*integer*"
msgstr "*integer*"

#: ../../library/asynchat.rst:146
#, fuzzy
msgid ""
"Will call :meth:`found_terminator` when the indicated number of characters "
"have been received"
msgstr "收到指定數量的字元後將呼叫 :meth:`found_terminator`"

#: ../../library/asynchat.rst:150
msgid "``None``"
msgstr "``None``"

#: ../../library/asynchat.rst:150
#, fuzzy
msgid "The channel continues to collect data forever"
msgstr "該通道將永遠持續收集資料"

#: ../../library/asynchat.rst:154
#, fuzzy
msgid ""
"Note that any data following the terminator will be available for reading by "
"the channel after :meth:`found_terminator` is called."
msgstr "請注意，在呼叫 :meth:`found_terminator` "
"之後，終止符後面的任何資料都可供通道讀取。"

#: ../../library/asynchat.rst:161
#, fuzzy
msgid "asynchat Example"
msgstr "非同步聊天示例"

#: ../../library/asynchat.rst:163
#, fuzzy
msgid ""
"The following partial example shows how HTTP requests can be read with :"
"class:`async_chat`.  A web server might create an :class:"
"`http_request_handler` object for each incoming client connection. Notice "
"that initially the channel terminator is set to match the blank line at the "
"end of the HTTP headers, and a flag indicates that the headers are being "
"read."
msgstr ""
"以下部分示例顯示瞭如何使用 async_chat 讀取 HTTP 請求。 Web "
"伺服器可能會為每個傳入的客戶端連接建立一個 http_request_handler "
"物件。請注意，最初通道終止符設定為與 HTTP "
"標頭末尾的空行相匹配，並且旗標指示正在讀取標頭。"

#: ../../library/asynchat.rst:170
#, fuzzy
msgid ""
"Once the headers have been read, if the request is of type POST (indicating "
"that further data are present in the input stream) then the ``Content-Length:"
"`` header is used to set a numeric terminator to read the right amount of "
"data from the channel."
msgstr ""
"讀取標頭後，如果請求的型別為 POST（表示輸入流中存在更多資料），則“Content-"
"Length:”標頭用於設定數字終止符以讀取正確數量的資料來自通道的資料。"

#: ../../library/asynchat.rst:175
#, fuzzy
msgid ""
"The :meth:`handle_request` method is called once all relevant input has been "
"marshalled, after setting the channel terminator to ``None`` to ensure that "
"any extraneous data sent by the web client are ignored. ::"
msgstr ""
":meth:`handle_request` 方法在所有相關輸入被編組後呼叫，在將通道終止符設定為 "
"``None`` 以確保忽略 Web 客戶端發送的任何無關資料之後。 ::"
