# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-14 00:15+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../library/asyncio-policy.rst:8
#, fuzzy
msgid "Policies"
msgstr "政策"

#: ../../library/asyncio-policy.rst:10
#, fuzzy
msgid ""
"An event loop policy is a global object used to get and set the current :ref:"
"`event loop <asyncio-event-loop>`, as well as create new event loops. The "
"default policy can be :ref:`replaced <asyncio-policy-get-set>` with :ref:"
"`built-in alternatives <asyncio-policy-builtin>` to use different event loop "
"implementations, or substituted by a :ref:`custom policy <asyncio-custom-"
"policies>` that can override these behaviors."
msgstr ""
"事件循環策略是一個全局物件，用於獲取和設定當前的 :ref:`事件循環 <asyncio-"
"event-loop>`，以及建立新的事件循環。預設策略可以是 :ref:`replaced <asyncio-"
"policy-get-set>` 和 :ref:`built-in alternatives <asyncio-policy-builtin>` "
"以使用不同的事件循環實作，或替換為：ref :`custom policy <asyncio-custom-"
"policies>` 可以覆蓋這些行為。"

#: ../../library/asyncio-policy.rst:19
#, fuzzy
msgid ""
"The :ref:`policy object <asyncio-policy-objects>` gets and sets a separate "
"event loop per *context*. This is per-thread by default, though custom "
"policies could define *context* differently."
msgstr ""
":ref:`policy object <asyncio-policy-objects>` 為每個 *context* "
"獲取和設定一個單獨的事件循環。預設情況下這是每個執行緒，"
"儘管自定義策略可以不同地定義 *context*。"

#: ../../library/asyncio-policy.rst:24
#, fuzzy
msgid ""
"Custom event loop policies can control the behavior of :func:"
"`get_event_loop`, :func:`set_event_loop`, and :func:`new_event_loop`."
msgstr ""
"自定義事件循環策略可以控制 :func:`get_event_loop`、:func:`set_event_loop` 和 "
":func:`new_event_loop` 的行為。"

#: ../../library/asyncio-policy.rst:27
#, fuzzy
msgid ""
"Policy objects should implement the APIs defined in the :class:"
"`AbstractEventLoopPolicy` abstract base class."
msgstr "策略物件應該實作在 AbstractEventLoopPolicy 抽象基底類別中定義的 API。"

#: ../../library/asyncio-policy.rst:34
#, fuzzy
msgid "Getting and Setting the Policy"
msgstr "獲取和設定策略"

#: ../../library/asyncio-policy.rst:36
#, fuzzy
msgid ""
"The following functions can be used to get and set the policy for the "
"current process:"
msgstr "以下函式可用於獲取和設定當前行程的策略："

#: ../../library/asyncio-policy.rst:41
#, fuzzy
msgid "Return the current process-wide policy."
msgstr "回傳當前行程範圍的策略。"

#: ../../library/asyncio-policy.rst:45
#, fuzzy
msgid "Set the current process-wide policy to *policy*."
msgstr "將當前行程範圍的策略設定為 *policy*。"

#: ../../library/asyncio-policy.rst:47
#, fuzzy
msgid "If *policy* is set to ``None``, the default policy is restored."
msgstr "如果 *policy* 設定為 ``None``，則恢復預設策略。"

#: ../../library/asyncio-policy.rst:53
#, fuzzy
msgid "Policy Objects"
msgstr "策略物件"

#: ../../library/asyncio-policy.rst:55
#, fuzzy
msgid "The abstract event loop policy base class is defined as follows:"
msgstr "抽象事件循環策略基底類別定義如下："

#: ../../library/asyncio-policy.rst:59
#, fuzzy
msgid "An abstract base class for asyncio policies."
msgstr "非同步策略的抽象基底類別。"

#: ../../library/asyncio-policy.rst:63
#, fuzzy
msgid "Get the event loop for the current context."
msgstr "獲取當前上下文的事件循環。"

#: ../../library/asyncio-policy.rst:65
#, fuzzy
msgid ""
"Return an event loop object implementing the :class:`AbstractEventLoop` "
"interface."
msgstr "回傳一個實作 AbstractEventLoop 介面的事件循環物件。"

#: ../../library/asyncio-policy.rst:68 ../../library/asyncio-policy.rst:80
#, fuzzy
msgid "This method should never return ``None``."
msgstr "此方法永遠不應回傳 ``None`` 。"

#: ../../library/asyncio-policy.rst:74
#, fuzzy
msgid "Set the event loop for the current context to *loop*."
msgstr "將當前上下文的事件循環設定為 *loop*。"

#: ../../library/asyncio-policy.rst:78
#, fuzzy
msgid "Create and return a new event loop object."
msgstr "建立並回傳一個新的事件循環物件。"

#: ../../library/asyncio-policy.rst:84
#, fuzzy
msgid "Get a child process watcher object."
msgstr "獲取子行程觀察器物件。"

#: ../../library/asyncio-policy.rst:86
#, fuzzy
msgid ""
"Return a watcher object implementing the :class:`AbstractChildWatcher` "
"interface."
msgstr "回傳一個實作 AbstractChildWatcher 介面的觀察者物件。"

#: ../../library/asyncio-policy.rst:89 ../../library/asyncio-policy.rst:95
#, fuzzy
msgid "This function is Unix specific."
msgstr "這個函式是 Unix 特有的。"

#: ../../library/asyncio-policy.rst:93
#, fuzzy
msgid "Set the current child process watcher to *watcher*."
msgstr "將當前子行程觀察器設定為 *watcher*。"

#: ../../library/asyncio-policy.rst:100
#, fuzzy
msgid "asyncio ships with the following built-in policies:"
msgstr "asyncio 附帶以下內建策略："

#: ../../library/asyncio-policy.rst:105
#, fuzzy
msgid ""
"The default asyncio policy.  Uses :class:`SelectorEventLoop` on Unix and :"
"class:`ProactorEventLoop` on Windows."
msgstr ""
"預設的非同步策略。在 Unix 上使用 :class:`SelectorEventLoop`，在 Windows "
"上使用 :class:`ProactorEventLoop`。"

#: ../../library/asyncio-policy.rst:108
#, fuzzy
msgid ""
"There is no need to install the default policy manually. asyncio is "
"configured to use the default policy automatically."
msgstr "無需手動安裝預設策略。 asyncio 被配置為自動使用預設策略。"

#: ../../library/asyncio-policy.rst:113
#, fuzzy
msgid "On Windows, :class:`ProactorEventLoop` is now used by default."
msgstr "在 Windows 上，ProactorEventLoop 現在預設使用。"

#: ../../library/asyncio-policy.rst:116
#, fuzzy
msgid ""
"In Python versions 3.10.9, 3.11.1 and 3.12 the :meth:`get_event_loop` method "
"of the default asyncio policy emits a :exc:`DeprecationWarning` if there is "
"no running event loop and no current loop is set. In some future Python "
"release this will become an error."
msgstr ""
"在 Python 版本 3.10.9、3.11.1 和 3.12 "
"中，如果沒有正在運行的事件循環並且沒有設定當前循環，則預設非同步策略的 "
"get_event_loop 方法會發出 DeprecationWarning。在未來的某些 Python "
"版本中，這將成為一個錯誤。"

#: ../../library/asyncio-policy.rst:124
#, fuzzy
msgid ""
"An alternative event loop policy that uses the :class:`SelectorEventLoop` "
"event loop implementation."
msgstr "使用 SelectorEventLoop 事件循環實作的替代事件循環策略。"

#: ../../library/asyncio-policy.rst:127 ../../library/asyncio-policy.rst:135
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`適用 <availability>`：Windows。"

#: ../../library/asyncio-policy.rst:132
#, fuzzy
msgid ""
"An alternative event loop policy that uses the :class:`ProactorEventLoop` "
"event loop implementation."
msgstr "使用 ProactorEventLoop 事件循環實作的替代事件循環策略。"

#: ../../library/asyncio-policy.rst:141
#, fuzzy
msgid "Process Watchers"
msgstr "行程觀察者"

#: ../../library/asyncio-policy.rst:143
#, fuzzy
msgid ""
"A process watcher allows customization of how an event loop monitors child "
"processes on Unix. Specifically, the event loop needs to know when a child "
"process has exited."
msgstr "行程觀察器允許自定義事件循環如何監視 Unix "
"上的子行程。具體來說，事件循環需要知道子行程何時退出。"

#: ../../library/asyncio-policy.rst:147
#, fuzzy
msgid ""
"In asyncio, child processes are created with :func:`create_subprocess_exec` "
"and :meth:`loop.subprocess_exec` functions."
msgstr "在 asyncio 中，子行程是使用 create_subprocess_exec 和 loop.subprocess_exec "
"函式建立的。"

#: ../../library/asyncio-policy.rst:151
#, fuzzy
msgid ""
"asyncio defines the :class:`AbstractChildWatcher` abstract base class, which "
"child watchers should implement, and has four different implementations: :"
"class:`ThreadedChildWatcher` (configured to be used by default), :class:"
"`MultiLoopChildWatcher`, :class:`SafeChildWatcher`, and :class:"
"`FastChildWatcher`."
msgstr ""
"asyncio 定義了子觀察者應該實作的 AbstractChildWatcher 抽象基底類別，它有四種"
"不同的實作：ThreadedChildWatcher（預設配置使用）、MultiLoopChildWatcher、clas"
"s： `SafeChildWatcher` 和 :class:`FastChildWatcher`。"

#: ../../library/asyncio-policy.rst:157
#, fuzzy
msgid ""
"See also the :ref:`Subprocess and Threads <asyncio-subprocess-threads>` "
"section."
msgstr "另請參閱 :ref:`Subprocess and Threads <asyncio-subprocess-threads>` 部分。"

#: ../../library/asyncio-policy.rst:160
#, fuzzy
msgid ""
"The following two functions can be used to customize the child process "
"watcher implementation used by the asyncio event loop:"
msgstr "以下兩個函式可用於自定義 asyncio 事件循環使用的子行程觀察器實作："

#: ../../library/asyncio-policy.rst:165
#, fuzzy
msgid "Return the current child watcher for the current policy."
msgstr "回傳當前策略的當前子觀察者。"

#: ../../library/asyncio-policy.rst:169
#, fuzzy
msgid ""
"Set the current child watcher to *watcher* for the current policy.  "
"*watcher* must implement methods defined in the :class:"
"`AbstractChildWatcher` base class."
msgstr ""
"將當前的子觀察者設定為當前策略的 *watcher* 。 *watcher* 必須實作在 "
"AbstractChildWatcher 基底類別中定義的方法。"

#: ../../library/asyncio-policy.rst:174
#, fuzzy
msgid ""
"Third-party event loops implementations might not support custom child "
"watchers.  For such event loops, using :func:`set_child_watcher` might be "
"prohibited or have no effect."
msgstr "第三方事件循環實作可能不支援自定義子觀察者。對於此類事件循環，使用 "
":func:`set_child_watcher` 可能會被禁止或無效。"

#: ../../library/asyncio-policy.rst:182
#, fuzzy
msgid "Register a new child handler."
msgstr "註冊一個新的子處理程式。"

#: ../../library/asyncio-policy.rst:184
#, fuzzy
msgid ""
"Arrange for ``callback(pid, returncode, *args)`` to be called when a process "
"with PID equal to *pid* terminates.  Specifying another callback for the "
"same process replaces the previous handler."
msgstr ""
"當 PID 等於 *pid* 的行程終止時，安排呼叫``callback(pid, returncode, "
"*args)``。為同一行程指定另一個回呼將替換以前的處理程式。"

#: ../../library/asyncio-policy.rst:189
#, fuzzy
msgid "The *callback* callable must be thread-safe."
msgstr "*callback* 可呼叫物件必須是執行緒安全的。"

#: ../../library/asyncio-policy.rst:193
#, fuzzy
msgid "Removes the handler for process with PID equal to *pid*."
msgstr "刪除 PID 等於 *pid* 的行程的處理程式。"

#: ../../library/asyncio-policy.rst:195
#, fuzzy
msgid ""
"The function returns ``True`` if the handler was successfully removed, "
"``False`` if there was nothing to remove."
msgstr "如果處理程式已成功刪除，該函式回傳 ``True``，如果沒有要刪除的內容，則回傳 ``False``"
"。"

#: ../../library/asyncio-policy.rst:200
#, fuzzy
msgid "Attach the watcher to an event loop."
msgstr "將觀察者附加到事件循環。"

#: ../../library/asyncio-policy.rst:202
#, fuzzy
msgid ""
"If the watcher was previously attached to an event loop, then it is first "
"detached before attaching to the new loop."
msgstr "如果 watcher 之前附加到事件循環，則在附加到新循環之前首先將其分離。"

#: ../../library/asyncio-policy.rst:205
#, fuzzy
msgid "Note: loop may be ``None``."
msgstr "注意：循環可能是 ``None`` 。"

#: ../../library/asyncio-policy.rst:209
#, fuzzy
msgid "Return ``True`` if the watcher is ready to use."
msgstr "如果觀察者準備好使用，則回傳 ``True``。"

#: ../../library/asyncio-policy.rst:211
#, fuzzy
msgid ""
"Spawning a subprocess with *inactive* current child watcher raises :exc:"
"`RuntimeError`."
msgstr "使用 *inactive* 當前子觀察者生成子行程會引發 :exc:`RuntimeError`。"

#: ../../library/asyncio-policy.rst:218
#, fuzzy
msgid "Close the watcher."
msgstr "關閉觀察者。"

#: ../../library/asyncio-policy.rst:220
#, fuzzy
msgid ""
"This method has to be called to ensure that underlying resources are cleaned-"
"up."
msgstr "必須呼叫此方法以確保清理底層資源。"

#: ../../library/asyncio-policy.rst:225
#, fuzzy
msgid ""
"This implementation starts a new waiting thread for every subprocess spawn."
msgstr "此實作為每個子行程生成啟動一個新的等待執行緒。"

#: ../../library/asyncio-policy.rst:227
#, fuzzy
msgid ""
"It works reliably even when the asyncio event loop is run in a non-main OS "
"thread."
msgstr "即使 asyncio 事件循環在非主操作系統執行緒中運行，它也能可靠地工作。"

#: ../../library/asyncio-policy.rst:229
#, fuzzy
msgid ""
"There is no noticeable overhead when handling a big number of children "
"(*O(1)* each time a child terminates), but starting a thread per process "
"requires extra memory."
msgstr "處理大量子行程時沒有明顯的開銷（*O(1)* "
"每次子行程終止），但每個行程啟動一個執行緒需要額外的記憶體。"

#: ../../library/asyncio-policy.rst:232
#, fuzzy
msgid "This watcher is used by default."
msgstr "預設情況下使用此觀察器。"

#: ../../library/asyncio-policy.rst:238
#, fuzzy
msgid ""
"This implementation registers a :py:data:`SIGCHLD` signal handler on "
"instantiation. That can break third-party code that installs a custom "
"handler for :py:data:`SIGCHLD` signal."
msgstr ""
"此實作在實例化時註冊了一個 :py:data:`SIGCHLD` 信號處理程式。這可能會破壞為 "
":py:data:`SIGCHLD` 信號安裝自定義處理程式的第三方程式碼。"

#: ../../library/asyncio-policy.rst:242 ../../library/asyncio-policy.rst:260
#, fuzzy
msgid ""
"The watcher avoids disrupting other code spawning processes by polling every "
"process explicitly on a :py:data:`SIGCHLD` signal."
msgstr "觀察者通過在 :py:data:`SIGCHLD` "
"信號上顯式輪詢每個行程來避免中斷其他程式碼生成行程。"

#: ../../library/asyncio-policy.rst:245
#, fuzzy
msgid ""
"There is no limitation for running subprocesses from different threads once "
"the watcher is installed."
msgstr "安裝觀察程式後，從不同執行緒運行子行程沒有限制。"

#: ../../library/asyncio-policy.rst:248
#, fuzzy
msgid ""
"The solution is safe but it has a significant overhead when handling a big "
"number of processes (*O(n)* each time a :py:data:`SIGCHLD` is received)."
msgstr "該解決方案是安全的，但在處理大量行程時會產生很大的開銷（*O(n)* "
"每次收到:py:data:`SIGCHLD`）。"

#: ../../library/asyncio-policy.rst:256
#, fuzzy
msgid ""
"This implementation uses active event loop from the main thread to handle :"
"py:data:`SIGCHLD` signal. If the main thread has no running event loop "
"another thread cannot spawn a subprocess (:exc:`RuntimeError` is raised)."
msgstr ""
"此實作使用來自主執行緒的活動事件循環來處理 :py:data:`SIGCHLD` 信號。如果主執"
"行緒沒有正在運行的事件循環，則另一個執行緒無法生成子行程（引發 :exec:`RuntimeE"
"rror`）。"

#: ../../library/asyncio-policy.rst:263
#, fuzzy
msgid ""
"This solution is as safe as :class:`MultiLoopChildWatcher` and has the same "
"*O(N)* complexity but requires a running event loop in the main thread to "
"work."
msgstr ""
"此解決方案與 MultiLoopChildWatcher 一樣安全，並且具有相同的 *O(N)* "
"複雜性，但需要在主執行緒中運行事件循環才能工作。"

#: ../../library/asyncio-policy.rst:268
#, fuzzy
msgid ""
"This implementation reaps every terminated processes by calling ``os."
"waitpid(-1)`` directly, possibly breaking other code spawning processes and "
"waiting for their termination."
msgstr "此實作通過直接呼叫 os.waitpid(-1) "
"來獲取每個終止的行程，可能會破壞其他程式碼生成行程並等待它們的終止。"

#: ../../library/asyncio-policy.rst:272
#, fuzzy
msgid ""
"There is no noticeable overhead when handling a big number of children "
"(*O(1)* each time a child terminates)."
msgstr "處理大量孩子時沒有明顯的開銷（*O(1)* 每次孩子終止）。"

#: ../../library/asyncio-policy.rst:275
#, fuzzy
msgid ""
"This solution requires a running event loop in the main thread to work, as :"
"class:`SafeChildWatcher`."
msgstr "此解決方案需要在主執行緒中運行一個事件循環才能工作，如 :class:`SafeChildWatcher"
"`。"

#: ../../library/asyncio-policy.rst:280
#, fuzzy
msgid ""
"This implementation polls process file descriptors (pidfds) to await child "
"process termination. In some respects, :class:`PidfdChildWatcher` is a "
"\"Goldilocks\" child watcher implementation. It doesn't require signals or "
"threads, doesn't interfere with any processes launched outside the event "
"loop, and scales linearly with the number of subprocesses launched by the "
"event loop. The main disadvantage is that pidfds are specific to Linux, and "
"only work on recent (5.3+) kernels."
msgstr ""
"此實作輪詢行程文件描述器 (pidfds) "
"以等待子行程終止。在某些方面，:class:`PidfdChildWatcher` 是一個 ``Goldilocks``子"
"觀察器實作。它不需要信號或執行緒，不干擾在事件循環外啟動的任何行程，並隨事件"
"循環啟動的子行程數量線性擴充。主要缺點是 pidfds 是特定於 Linux 的，"
"並且只能在最近的 (5.3+) 內核上工作。"

#: ../../library/asyncio-policy.rst:294
#, fuzzy
msgid "Custom Policies"
msgstr "自定義策略"

#: ../../library/asyncio-policy.rst:296
#, fuzzy
msgid ""
"To implement a new event loop policy, it is recommended to subclass :class:"
"`DefaultEventLoopPolicy` and override the methods for which custom behavior "
"is wanted, e.g.::"
msgstr "要實作新的事件循環策略，建議繼承 DefaultEventLoopPolicy "
"並覆蓋需要自定義行為的方法，例如："
