# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-24 00:16+0000\n"
"PO-Revision-Date: 2018-05-23 16:10+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../library/socket.rst:2
msgid ":mod:`socket` --- Low-level networking interface"
msgstr ":mod:`socket` --- 低階網路介面"

#: ../../library/socket.rst:7
msgid "**Source code:** :source:`Lib/socket.py`"
msgstr "**原始碼：**\\ :source:`Lib/socket.py`"

#: ../../library/socket.rst:11
#, fuzzy
msgid ""
"This module provides access to the BSD *socket* interface. It is available "
"on all modern Unix systems, Windows, MacOS, and probably additional "
"platforms."
msgstr ""
"該模組提供對 BSD *socket* 介面的訪問。它適用於所有現代 Unix 系統、Windows、"
"MacOS 以及可能的其他平台。"

#: ../../library/socket.rst:16
#, fuzzy
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs."
msgstr "某些行為可能取決於平台，因為呼叫是對操作系統 socket  API 進行的。"

#: ../../includes/wasm-notavail.rst:3
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ":ref:`適用 <availability>`：非 Emscripten、非 WASI。"

#: ../../includes/wasm-notavail.rst:5
#, fuzzy
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"此模組在 WebAssembly 平台 ``wasm32-emscripten`` 和 ``wasm32-wasi`` 上不起作用"
"或不可用。有關更多資訊，請參閱 :ref:`wasm-availability`。"

#: ../../library/socket.rst:24
#, fuzzy
msgid ""
"The Python interface is a straightforward transliteration of the Unix system "
"call and library interface for sockets to Python's object-oriented style: "
"the :func:`.socket` function returns a :dfn:`socket object` whose methods "
"implement the various socket system calls.  Parameter types are somewhat "
"higher-level than in the C interface: as with :meth:`read` and :meth:`write` "
"operations on Python files, buffer allocation on receive operations is "
"automatic, and buffer length is implicit on send operations."
msgstr ""
"Python 介面是 Unix 系統呼叫和 socket 庫介面到 Python 面向對像風格的直接音"
"譯：:func:`.socket` 函式回傳一個 :dfn:`socket 物件`，其方法實作了各種 socket "
"系統呼叫.參數型別比 C 介面中的參數型別更高階：與 Python 文件上的 read 和 "
"write 操作一樣，接收操作的緩衝區分配是自動的，發送操作的緩衝區長度是隱式的。"

#: ../../library/socket.rst:36
msgid "Module :mod:`socketserver`"
msgstr ":mod:`socketserver` 模組"

#: ../../library/socket.rst:36
#, fuzzy
msgid "Classes that simplify writing network servers."
msgstr "簡化編寫網絡伺服器的類別。"

#: ../../library/socket.rst:38
msgid "Module :mod:`ssl`"
msgstr ":mod:`ssl` 模組"

#: ../../library/socket.rst:39
#, fuzzy
msgid "A TLS/SSL wrapper for socket objects."
msgstr " socket 物件的 TLS/SSL 包裝器。"

#: ../../library/socket.rst:43
msgid "Socket families"
msgstr "Socket 系列家族"

#: ../../library/socket.rst:45
#, fuzzy
msgid ""
"Depending on the system and the build options, various socket families are "
"supported by this module."
msgstr "根據系統和構建選項，此模組支援各種 socket 系列。"

#: ../../library/socket.rst:48
#, fuzzy
msgid ""
"The address format required by a particular socket object is automatically "
"selected based on the address family specified when the socket object was "
"created.  Socket addresses are represented as follows:"
msgstr ""
"特定 socket 物件所需的地址格式是根據建立 socket 物件時指定的地址族自動選擇"
"的。套接字地址表示如下："

#: ../../library/socket.rst:52
#, fuzzy
msgid ""
"The address of an :const:`AF_UNIX` socket bound to a file system node is "
"represented as a string, using the file system encoding and the "
"``'surrogateescape'`` error handler (see :pep:`383`).  An address in Linux's "
"abstract namespace is returned as a :term:`bytes-like object` with an "
"initial null byte; note that sockets in this namespace can communicate with "
"normal file system sockets, so programs intended to run on Linux may need to "
"deal with both types of address.  A string or bytes-like object can be used "
"for either type of address when passing it as an argument."
msgstr ""
"綁定到文件系統節點的 :const:`AF_UNIX`  socket 的地址表示為一個字串，使用文件"
"系統編碼和 ``'surrogateescape'`` 錯誤處理程式（參見 :pep:`383`）。 Linux 抽象"
"命名空間中的地址作為帶有初始空位元組的類似位元組的物件回傳；請注意，此命名空"
"間中的 socket 可以與普通文件系統 socket 通信，因此打算在 Linux 上運行的程式可"
"能需要處理這兩種型別的地址。當將其作為參數傳遞時，字串或類似位元組的物件可用"
"於任何一種型別的地址。"

#: ../../library/socket.rst:62
#, fuzzy
msgid ""
"Previously, :const:`AF_UNIX` socket paths were assumed to use UTF-8 encoding."
msgstr "以前，:const:`AF_UNIX`  socket 路徑被假定為使用 UTF-8 編碼。"

#: ../../library/socket.rst:66 ../../library/socket.rst:1043
#: ../../library/socket.rst:1085 ../../library/socket.rst:1844
#, fuzzy
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "可寫 :term:`bytes-like object` 現在被接受。"

#: ../../library/socket.rst:71
#, fuzzy
msgid ""
"A pair ``(host, port)`` is used for the :const:`AF_INET` address family, "
"where *host* is a string representing either a hostname in internet domain "
"notation like ``'daring.cwi.nl'`` or an IPv4 address like "
"``'100.50.200.5'``, and *port* is an integer."
msgstr ""
"一對 ``(host, port)`` 用於 :const:`AF_INET` 地址族，其中 *host* 是一個字串，"
"代表網際網路域表示法中的主機名，如 ``'daring.cwi.nl'` ` 或類似 "
"``'100.50.200.5'`` 的 IPv4 地址，*port* 是一個整數。"

#: ../../library/socket.rst:76
#, fuzzy
msgid ""
"For IPv4 addresses, two special forms are accepted instead of a host "
"address: ``''`` represents :const:`INADDR_ANY`, which is used to bind to all "
"interfaces, and the string ``'<broadcast>'`` represents :const:"
"`INADDR_BROADCAST`.  This behavior is not compatible with IPv6, therefore, "
"you may want to avoid these if you intend to support IPv6 with your Python "
"programs."
msgstr ""
"對於 IPv4 地址，接受兩種特殊形式而不是主機地址：``''`` 表示 :const:"
"`INADDR_ANY`，用於綁定到所有介面，字串 ``'<broadcast>'``代表 :const:"
"`INADDR_BROADCAST`。此行為與 IPv6 不相容，因此，如果您打算使用 Python 程式支"
"援 IPv6，您可能希望避免這些行為。"

#: ../../library/socket.rst:83
#, fuzzy
msgid ""
"For :const:`AF_INET6` address family, a four-tuple ``(host, port, flowinfo, "
"scope_id)`` is used, where *flowinfo* and *scope_id* represent the "
"``sin6_flowinfo`` and ``sin6_scope_id`` members in :const:`struct "
"sockaddr_in6` in C.  For :mod:`socket` module methods, *flowinfo* and "
"*scope_id* can be omitted just for backward compatibility.  Note, however, "
"omission of *scope_id* can cause problems in manipulating scoped IPv6 "
"addresses."
msgstr ""
"對於 :const:`AF_INET6` 地址族，使用四元組``(host, port, flowinfo, "
"scope_id)``，其中*flowinfo* 和*scope_id* 代表``sin6_flowinfo`` 和"
"``sin6_scope_id` C 中 :const:`struct sockaddr_in6` 中的` 成員。對於 :mod:"
"`socket` 模組方法，*flowinfo* 和*scope_id* 可以省略只是為了向後相容。但是請注"
"意，省略 *scope_id* 可能會導致在處理範圍內的 IPv6 地址時出現問題。"

#: ../../library/socket.rst:90
#, fuzzy
msgid ""
"For multicast addresses (with *scope_id* meaningful) *address* may not "
"contain ``%scope_id`` (or ``zone id``) part. This information is superfluous "
"and may be safely omitted (recommended)."
msgstr ""
"對於多播地址（*scope_id* 有意義）*address* 可能不包含 ``%scope_id``（或 "
"``zone id``）部分。此資訊是多餘的，可以安全地省略（推薦）。"

#: ../../library/socket.rst:95
#, fuzzy
msgid ":const:`AF_NETLINK` sockets are represented as pairs ``(pid, groups)``."
msgstr ":const:`AF_NETLINK` socket 表示為成對的 ``(pid, groups)``。"

#: ../../library/socket.rst:97
#, fuzzy
msgid ""
"Linux-only support for TIPC is available using the :const:`AF_TIPC` address "
"family.  TIPC is an open, non-IP based networked protocol designed for use "
"in clustered computer environments.  Addresses are represented by a tuple, "
"and the fields depend on the address type. The general tuple form is "
"``(addr_type, v1, v2, v3 [, scope])``, where:"
msgstr ""
"使用 :const:`AF_TIPC` 地址族可獲得對 TIPC 的僅 Linux 支援。 TIPC 是一種開放"
"的、非基於 IP 的網絡協定，設計用於集群計算機環境。地址由元組表示，欄位取決於"
"地址型別。一般的元組形式是``(addr_type, v1, v2, v3 [, scope])``，其中："

#: ../../library/socket.rst:103
#, fuzzy
msgid ""
"*addr_type* is one of :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME`, "
"or :const:`TIPC_ADDR_ID`."
msgstr ""
"*addr_type* 是 :const:`TIPC_ADDR_NAMESEQ`、:const:`TIPC_ADDR_NAME` 或 :const:"
"`TIPC_ADDR_ID` 之一。"

#: ../../library/socket.rst:105
#, fuzzy
msgid ""
"*scope* is one of :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE`, "
"and :const:`TIPC_NODE_SCOPE`."
msgstr ""
"*scope* 是 :const:`TIPC_ZONE_SCOPE`、:const:`TIPC_CLUSTER_SCOPE` 和 :const:"
"`TIPC_NODE_SCOPE` 之一。"

#: ../../library/socket.rst:107
#, fuzzy
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAME`, then *v1* is the server type, "
"*v2* is the port identifier, and *v3* should be 0."
msgstr ""
"如果 *addr_type* 是 :const:`TIPC_ADDR_NAME`，那麼 *v1* 是伺服器型別，*v2* 是"
"端口標識符，*v3* 應該是 0。"

#: ../../library/socket.rst:110
#, fuzzy
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAMESEQ`, then *v1* is the server type, "
"*v2* is the lower port number, and *v3* is the upper port number."
msgstr ""
"如果 *addr_type* 是 :const:`TIPC_ADDR_NAMESEQ`，那麼 *v1* 是伺服器型別，*v2* "
"是下端口號，*v3* 是上端口號。"

#: ../../library/socket.rst:113
#, fuzzy
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_ID`, then *v1* is the node, *v2* is the "
"reference, and *v3* should be set to 0."
msgstr ""
"如果 *addr_type* 是 :const:`TIPC_ADDR_ID`，那麼 *v1* 是節點，*v2* 是引用，"
"*v3* 應該設定為 0。"

#: ../../library/socket.rst:116
#, fuzzy
msgid ""
"A tuple ``(interface, )`` is used for the :const:`AF_CAN` address family, "
"where *interface* is a string representing a network interface name like "
"``'can0'``. The network interface name ``''`` can be used to receive packets "
"from all network interfaces of this family."
msgstr ""
"元組 ``(interface, )`` 用於 :const:`AF_CAN` 地址族，其中 *interface* 是表示網"
"絡介面名稱的字串，如 ``'can0'``。網絡介面名稱 ``''`` 可用於接收來自該系列所有"
"網絡介面的封包。"

#: ../../library/socket.rst:121
#, fuzzy
msgid ""
":const:`CAN_ISOTP` protocol require a tuple ``(interface, rx_addr, "
"tx_addr)`` where both additional parameters are unsigned long integer that "
"represent a CAN identifier (standard or extended)."
msgstr ""
":const:`CAN_ISOTP` 協定需要一個元組``(interface, rx_addr, tx_addr)`` 其中兩個"
"附加參數都是代表 CAN 標識符（標准或擴充）的無符號長整數。"

#: ../../library/socket.rst:124
#, fuzzy
msgid ""
":const:`CAN_J1939` protocol require a tuple ``(interface, name, pgn, addr)`` "
"where additional parameters are 64-bit unsigned integer representing the ECU "
"name, a 32-bit unsigned integer representing the Parameter Group Number "
"(PGN), and an 8-bit integer representing the address."
msgstr ""
":const:`CAN_J1939` 協定需要一個元組``(interface, name, pgn, addr)`` 其中附加"
"參數是表示 ECU 名稱的 64 位無符號整數，表示參數組編號 (PGN) 的 32 位無符號整"
"數), 和一個表示地址的 8 位整數。"

#: ../../library/socket.rst:129
#, fuzzy
msgid ""
"A string or a tuple ``(id, unit)`` is used for the :const:`SYSPROTO_CONTROL` "
"protocol of the :const:`PF_SYSTEM` family. The string is the name of a "
"kernel control using a dynamically assigned ID. The tuple can be used if ID "
"and unit number of the kernel control are known or if a registered ID is "
"used."
msgstr ""
"字串或元組``(id, unit)`` 用於 :const:`PF_SYSTEM` 家族的 :const:"
"`SYSPROTO_CONTROL` 協定。該字串是使用動態分配的 ID 的內核控件的名稱。如果內核"
"控件的 ID 和單元號已知，或者如果使用已註冊的 ID，則可以使用元組。"

#: ../../library/socket.rst:137
#, fuzzy
msgid ""
":const:`AF_BLUETOOTH` supports the following protocols and address formats:"
msgstr ":const:`AF_BLUETOOTH` 支援以下協定和地址格式："

#: ../../library/socket.rst:140
#, fuzzy
msgid ""
":const:`BTPROTO_L2CAP` accepts ``(bdaddr, psm)`` where ``bdaddr`` is the "
"Bluetooth address as a string and ``psm`` is an integer."
msgstr ""
":const:`BTPROTO_L2CAP` 接受``(bdaddr, psm)`` 其中``bdaddr`` 是字串形式的藍牙"
"地址，``psm`` 是一個整數。"

#: ../../library/socket.rst:143
#, fuzzy
msgid ""
":const:`BTPROTO_RFCOMM` accepts ``(bdaddr, channel)`` where ``bdaddr`` is "
"the Bluetooth address as a string and ``channel`` is an integer."
msgstr ""
":const:`BTPROTO_RFCOMM` 接受``(bdaddr, channel)`` 其中``bdaddr`` 是字串形式的"
"藍牙地址，``channel`` 是一個整數。"

#: ../../library/socket.rst:146
#, fuzzy
msgid ""
":const:`BTPROTO_HCI` accepts ``(device_id,)`` where ``device_id`` is either "
"an integer or a string with the Bluetooth address of the interface. (This "
"depends on your OS; NetBSD and DragonFlyBSD expect a Bluetooth address while "
"everything else expects an integer.)"
msgstr ""
":const:`BTPROTO_HCI` 接受 ``(device_id,)`` 其中 ``device_id`` 是整數或帶有介"
"面藍牙地址的字串。 （這取決於您的操作系統；NetBSD 和 DragonFlyBSD 需要一個藍"
"牙地址，而其他一切都需要一個整數。）"

#: ../../library/socket.rst:151
msgid "NetBSD and DragonFlyBSD support added."
msgstr "加入對 NetBSD 和 DragonFlyBSD 的支援。"

#: ../../library/socket.rst:154
#, fuzzy
msgid ""
":const:`BTPROTO_SCO` accepts ``bdaddr`` where ``bdaddr`` is a :class:`bytes` "
"object containing the Bluetooth address in a string format. (ex. "
"``b'12:23:34:45:56:67'``) This protocol is not supported under FreeBSD."
msgstr ""
":const:`BTPROTO_SCO` 接受 ``bdaddr``，其中 ``bdaddr`` 是一個包含字串格式的藍"
"牙地址的 :class:`bytes` 物件。 （例如 ``b'12:23:34:45:56:67'``）FreeBSD 不支"
"援此協定。"

#: ../../library/socket.rst:159
#, fuzzy
msgid ""
":const:`AF_ALG` is a Linux-only socket based interface to Kernel "
"cryptography. An algorithm socket is configured with a tuple of two to four "
"elements ``(type, name [, feat [, mask]])``, where:"
msgstr ""
":const:`AF_ALG` 是一個基於 Linux  socket 的內核加密介面。一個演算法 socket 配"
"置了一個由兩到四個元素組成的元組``(type, name [, feat [, mask]])``，其中："

#: ../../library/socket.rst:163
#, fuzzy
msgid ""
"*type* is the algorithm type as string, e.g. ``aead``, ``hash``, "
"``skcipher`` or ``rng``."
msgstr ""
"*type* 是字串形式的演算法型別，例如``aead``、``hash``、``skcipher`` 或 "
"``rng``。"

#: ../../library/socket.rst:166
#, fuzzy
msgid ""
"*name* is the algorithm name and operation mode as string, e.g. ``sha256``, "
"``hmac(sha256)``, ``cbc(aes)`` or ``drbg_nopr_ctr_aes256``."
msgstr ""
"*name* 是演算法名稱和操作模式，字串形式，例如``sha256``、``hmac(sha256)``、"
"``cbc(aes)`` 或 ``drbg_nopr_ctr_aes256``。"

#: ../../library/socket.rst:169
#, fuzzy
msgid "*feat* and *mask* are unsigned 32bit integers."
msgstr "*fear* 和 *mask* 是無符號的 32 位整數。"

#: ../../library/socket.rst:171 ../../library/socket.rst:519
#: ../../library/socket.rst:1766
msgid ":ref:`Availability <availability>`: Linux >= 2.6.38."
msgstr ":ref:`適用 <availability>`：Linux >= 2.6.38。"

#: ../../library/socket.rst:173
#, fuzzy
msgid "Some algorithm types require more recent Kernels."
msgstr "某些演算法型別需要更新的內核。"

#: ../../library/socket.rst:177
#, fuzzy
msgid ""
":const:`AF_VSOCK` allows communication between virtual machines and their "
"hosts. The sockets are represented as a ``(CID, port)`` tuple where the "
"context ID or CID and port are integers."
msgstr ""
":const:`AF_VSOCK` 允許虛擬機與其主機之間的通信。 socket 表示為“(CID, port)”元"
"組，其中上下文 ID 或 CID 和端口是整數。"

#: ../../library/socket.rst:181 ../../library/socket.rst:592
msgid ":ref:`Availability <availability>`: Linux >= 3.9"
msgstr ":ref:`適用 <availability>`：Linux 3.9 以上。"

#: ../../library/socket.rst:183
msgid "See :manpage:`vsock(7)`"
msgstr "請見 :manpage:`vsock(7)`"

#: ../../library/socket.rst:187
#, fuzzy
msgid ""
":const:`AF_PACKET` is a low-level interface directly to network devices. The "
"packets are represented by the tuple ``(ifname, proto[, pkttype[, hatype[, "
"addr]]])`` where:"
msgstr ""
":const:`AF_PACKET` 是直接連接到網絡設備的低階介面。封包由元組“(ifname, "
"proto[, pkttype[, hatype[, addr]]])”表示，其中："

#: ../../library/socket.rst:191
#, fuzzy
msgid "*ifname* - String specifying the device name."
msgstr "*ifname* - 指定設備名稱的字串。"

#: ../../library/socket.rst:192
#, fuzzy
msgid ""
"*proto* - An in network-byte-order integer specifying the Ethernet protocol "
"number."
msgstr "*proto* - 指定以太網協定編號的網絡位元組順序整數。"

#: ../../library/socket.rst:194
#, fuzzy
msgid "*pkttype* - Optional integer specifying the packet type:"
msgstr "*pkttype* - 指定封包型別的可選整數："

#: ../../library/socket.rst:196
#, fuzzy
msgid "``PACKET_HOST`` (the default) - Packet addressed to the local host."
msgstr "``PACKET_HOST``（預設值）- 發送到本地主機的封包。"

#: ../../library/socket.rst:197
#, fuzzy
msgid "``PACKET_BROADCAST`` - Physical-layer broadcast packet."
msgstr "``PACKET_BROADCAST`` - 物理層廣播封包。"

#: ../../library/socket.rst:198
#, fuzzy
msgid ""
"``PACKET_MULTICAST`` - Packet sent to a physical-layer multicast address."
msgstr "``PACKET_MULTICAST`` - 發送到物理層多播地址的封包。"

#: ../../library/socket.rst:199
#, fuzzy
msgid ""
"``PACKET_OTHERHOST`` - Packet to some other host that has been caught by a "
"device driver in promiscuous mode."
msgstr ""
"``PACKET_OTHERHOST`` - 發送到其他主機的封包已被設備驅動程式以混雜模式捕獲。"

#: ../../library/socket.rst:201
#, fuzzy
msgid ""
"``PACKET_OUTGOING`` - Packet originating from the local host that is looped "
"back to a packet socket."
msgstr "``PACKET_OUTGOING`` - 來自本地主機的封包被環回到封包 socket 。"

#: ../../library/socket.rst:203
#, fuzzy
msgid "*hatype* - Optional integer specifying the ARP hardware address type."
msgstr "*hatype* - 指定 ARP 硬件地址型別的可選整數。"

#: ../../library/socket.rst:204
#, fuzzy
msgid ""
"*addr* - Optional bytes-like object specifying the hardware physical "
"address, whose interpretation depends on the device."
msgstr "*addr* - 可選的類似位元組的物件，指定硬件物理地址，其解釋取決於設備。"

#: ../../library/socket.rst:207 ../../library/socket.rst:480
msgid ":ref:`Availability <availability>`: Linux >= 2.2."
msgstr ":ref:`適用 <availability>`：Linux >= 2.2。"

#: ../../library/socket.rst:209
#, fuzzy
msgid ""
":const:`AF_QIPCRTR` is a Linux-only socket based interface for communicating "
"with services running on co-processors in Qualcomm platforms. The address "
"family is represented as a ``(node, port)`` tuple where the *node* and "
"*port* are non-negative integers."
msgstr ""
":const:`AF_QIPCRTR` 是一個基於 Linux  socket 的介面，用於與在高通平台的協處理"
"器上運行的服務進行通信。地址族表示為``(node, port)`` 元組，其中*node* 和"
"*port* 是非負整數。"

#: ../../library/socket.rst:214 ../../library/socket.rst:568
msgid ":ref:`Availability <availability>`: Linux >= 4.7."
msgstr ":ref:`適用 <availability>`：Linux >= 4.7。"

#: ../../library/socket.rst:218
#, fuzzy
msgid ""
":const:`IPPROTO_UDPLITE` is a variant of UDP which allows you to specify "
"what portion of a packet is covered with the checksum. It adds two socket "
"options that you can change. ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_SEND_CSCOV, length)`` will change what portion of outgoing packets "
"are covered by the checksum and ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_RECV_CSCOV, length)`` will filter out packets which cover too little "
"of their data. In both cases ``length`` should be in ``range(8, 2**16, 8)``."
msgstr ""
":const:`IPPROTO_UDPLITE` 是 UDP 的變體，它允許您指定封包的哪一部分被校驗和覆"
"蓋。它新增了兩個可以更改的 socket 選項。 ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_SEND_CSCOV, length)`` 將改變傳出封包的哪一部分被校驗和覆蓋，``self."
"setsockopt(IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV, length)`` 將過濾掉覆蓋太少的"
"封包他們的資料。在這兩種情況下，``length`` 應該在 ``range(8, 2**16, 8)`` 內。"

#: ../../library/socket.rst:227
#, fuzzy
msgid ""
"Such a socket should be constructed with ``socket(AF_INET, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv4 or ``socket(AF_INET6, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv6."
msgstr ""
"這樣的 socket 應該用 IPv4 的 socket(AF_INET, SOCK_DGRAM, IPPROTO_UDPLITE) 或 "
"IPv6 的 socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDPLITE) 構造。"

#: ../../library/socket.rst:231
msgid ":ref:`Availability <availability>`: Linux >= 2.6.20, FreeBSD >= 10.1"
msgstr ":ref:`適用 <availability>`：Linux 2.6.20 以上、FreeBSD 10.1 以上。"

#: ../../library/socket.rst:235
#, fuzzy
msgid ""
"If you use a hostname in the *host* portion of IPv4/v6 socket address, the "
"program may show a nondeterministic behavior, as Python uses the first "
"address returned from the DNS resolution.  The socket address will be "
"resolved differently into an actual IPv4/v6 address, depending on the "
"results from DNS resolution and/or the host configuration.  For "
"deterministic behavior use a numeric address in *host* portion."
msgstr ""
"如果您在 IPv4/v6  socket 地址的 *host* 部分使用主機名，程式可能會顯示不確定的"
"行為，因為 Python 使用從 DNS 解析回傳的第一個地址。 socket 地址將以不同方式解"
"析為實際 IPv4/v6 地址，具體取決於 DNS 解析和/或主機配置的結果。對於確定性行"
"為，請在 *host* 部分使用數字地址。"

#: ../../library/socket.rst:242
#, fuzzy
msgid ""
"All errors raise exceptions.  The normal exceptions for invalid argument "
"types and out-of-memory conditions can be raised. Errors related to socket "
"or address semantics raise :exc:`OSError` or one of its subclasses."
msgstr ""
"所有錯誤都會引發例外。可以引發無效參數型別和記憶體不足情況的正常例外。與 "
"socket 或地址語義相關的錯誤會引發 :exc:`OSError` 或其子類別之一。"

#: ../../library/socket.rst:247
#, fuzzy
msgid ""
"Non-blocking mode is supported through :meth:`~socket.setblocking`.  A "
"generalization of this based on timeouts is supported through :meth:`~socket."
"settimeout`."
msgstr ""
"通過 :meth:`~socket.setblocking` 支援非阻塞模式。通過 :meth:`~socket."
"settimeout` 支援基於超時的泛化。"

#: ../../library/socket.rst:253
msgid "Module contents"
msgstr "模組內容"

#: ../../library/socket.rst:255
#, fuzzy
msgid "The module :mod:`socket` exports the following elements."
msgstr "模組 :mod:`socket` 導出以下元素。"

#: ../../library/socket.rst:259
msgid "Exceptions"
msgstr "例外"

#: ../../library/socket.rst:263
msgid "A deprecated alias of :exc:`OSError`."
msgstr "一個已棄用的 :exc:`OSError` 的別名。"

#: ../../library/socket.rst:265
#, fuzzy
msgid "Following :pep:`3151`, this class was made an alias of :exc:`OSError`."
msgstr "在 :pep:`3151` 之後，這個類成為 :exc:`OSError` 的別名。"

#: ../../library/socket.rst:271
#, fuzzy
msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors, i.e. for functions that use *h_errno* in the POSIX C API, including :"
"func:`gethostbyname_ex` and :func:`gethostbyaddr`. The accompanying value is "
"a pair ``(h_errno, string)`` representing an error returned by a library "
"call.  *h_errno* is a numeric value, while *string* represents the "
"description of *h_errno*, as returned by the :c:func:`hstrerror` C function."
msgstr ""
":exc:`OSError` 的子類別，此例外是針對與地址相關的錯誤引發的，即對於在 POSIX "
"C API 中使用 *h_errno* 的函式，包括 :func:`gethostbyname_ex` 和 :func:"
"`gethostbyaddr`。附帶的值是一對“(h_errno, string)”，表示庫呼叫回傳的錯誤。 "
"*h_errno* 是一個數值，而 *string* 表示 *h_errno* 的描述，由:c:func:"
"`hstrerror` C 函式回傳。"

#: ../../library/socket.rst:279 ../../library/socket.rst:292
#: ../../library/socket.rst:305
#, fuzzy
msgid "This class was made a subclass of :exc:`OSError`."
msgstr "這個類是 :exc:`OSError` 的子類別。"

#: ../../library/socket.rst:284
#, fuzzy
msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors by :func:`getaddrinfo` and :func:`getnameinfo`. The accompanying "
"value is a pair ``(error, string)`` representing an error returned by a "
"library call.  *string* represents the description of *error*, as returned "
"by the :c:func:`gai_strerror` C function.  The numeric *error* value will "
"match one of the :const:`EAI_\\*` constants defined in this module."
msgstr ""
":exc:`OSError` 的子類別，此例外由 :func:`getaddrinfo` 和 :func:`getnameinfo` "
"針對與地址相關的錯誤引發。附帶的值是一對“(error, string)”，表示庫呼叫回傳的錯"
"誤。 *string* 表示 *error* 的描述，由:c:func:`gai_strerror` C 函式回傳。數字 "
"*error* 值將匹配此模組中定義的 EAI_\\* 常數之一。"

#: ../../library/socket.rst:297
#, fuzzy
msgid "A deprecated alias of :exc:`TimeoutError`."
msgstr ":exc:`TimeoutError` 的棄用別名。"

#: ../../library/socket.rst:299
#, fuzzy
msgid ""
"A subclass of :exc:`OSError`, this exception is raised when a timeout occurs "
"on a socket which has had timeouts enabled via a prior call to :meth:"
"`~socket.settimeout` (or implicitly through :func:`~socket."
"setdefaulttimeout`).  The accompanying value is a string whose value is "
"currently always \"timed out\"."
msgstr ""
":exc:`OSError` 的子類別，當 socket 發生超時時引發此例外，該 socket 已通過先前"
"呼叫 :meth:`~socket.settimeout`（或隱式地通過 :func:`~socket ."
"setdefaulttimeout`）。伴隨值是一個字串，其值當前始終為“超時”。"

#: ../../library/socket.rst:308
#, fuzzy
msgid "This class was made an alias of :exc:`TimeoutError`."
msgstr "這個類是 :exc:`TimeoutError` 的別名。"

#: ../../library/socket.rst:313
msgid "Constants"
msgstr "常數"

#: ../../library/socket.rst:315
#, fuzzy
msgid ""
"The AF_* and SOCK_* constants are now :class:`AddressFamily` and :class:"
"`SocketKind` :class:`.IntEnum` collections."
msgstr ""
"AF_* 和 SOCK_* 常數現在是 :class:`AddressFamily` 和 :class:`SocketKind` :"
"class:`.IntEnum` 集合。"

#: ../../library/socket.rst:324
#, fuzzy
msgid ""
"These constants represent the address (and protocol) families, used for the "
"first argument to :func:`.socket`.  If the :const:`AF_UNIX` constant is not "
"defined then this protocol is unsupported.  More constants may be available "
"depending on the system."
msgstr ""
"這些常數代表地址（和協定）系列，用於 :func:`.socket` 的第一個參數。如果未定"
"義 :const:`AF_UNIX` 常數，則不支援此協定。根據系統的不同，可能會有更多常數可"
"用。"

#: ../../library/socket.rst:336
#, fuzzy
msgid ""
"These constants represent the socket types, used for the second argument to :"
"func:`.socket`.  More constants may be available depending on the system. "
"(Only :const:`SOCK_STREAM` and :const:`SOCK_DGRAM` appear to be generally "
"useful.)"
msgstr ""
"這些常數表示 socket 型別，用於 :func:`.socket` 的第二個參數。根據系統的不同，"
"可能會有更多常數可用。 （只有 :const:`SOCK_STREAM` 和 :const:`SOCK_DGRAM` 似"
"乎通常有用。）"

#: ../../library/socket.rst:344
#, fuzzy
msgid ""
"These two constants, if defined, can be combined with the socket types and "
"allow you to set some flags atomically (thus avoiding possible race "
"conditions and the need for separate calls)."
msgstr ""
"這兩個常數，如果定義的話，可以與 socket 型別組合，並允許您自動設定一些旗標"
"（從而避免可能的競爭條件和單獨呼叫的需要）。"

#: ../../library/socket.rst:350
#, fuzzy
msgid ""
"`Secure File Descriptor Handling <https://udrepper.livejournal.com/20407."
"html>`_ for a more thorough explanation."
msgstr ""
"`安全文件描述器處理 <https://udrepper.livejournal.com/20407.html>`_ 以獲得更"
"詳盡的解釋。"

#: ../../library/socket.rst:353
msgid ":ref:`Availability <availability>`: Linux >= 2.6.27."
msgstr ":ref:`適用 <availability>`：Linux >= 2.6.27。"

#: ../../library/socket.rst:372
#, fuzzy
msgid ""
"Many constants of these forms, documented in the Unix documentation on "
"sockets and/or the IP protocol, are also defined in the socket module. They "
"are generally used in arguments to the :meth:`setsockopt` and :meth:"
"`getsockopt` methods of socket objects.  In most cases, only those symbols "
"that are defined in the Unix header files are defined; for a few symbols, "
"default values are provided."
msgstr ""
"這些形式的許多常數，記錄在 Unix 文檔中關於 socket 和/或 IP 協定，也在 socket "
"模組中定義。它們通常用於 socket 物件的 setsockopt 和 getsockopt 方法的參數"
"中。在大多數情況下，只定義那些在 Unix 標頭檔中定義的符號；對於一些符號，提供"
"了預設值。"

#: ../../library/socket.rst:379
#, fuzzy
msgid ""
"``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION`` were added."
msgstr ""
"新增了``SO_DOMAIN``、``SO_PROTOCOL``、``SO_PEERSEC``、``SO_PASSSEC``、"
"``TCP_USER_TIMEOUT``、``TCP_CONGESTION``。"

#: ../../library/socket.rst:383
#, fuzzy
msgid ""
"On Windows, ``TCP_FASTOPEN``, ``TCP_KEEPCNT`` appear if run-time Windows "
"supports."
msgstr ""
"在 Windows 上，如果運行時 Windows 支援，則會出現 ``TCP_FASTOPEN``、"
"``TCP_KEEPCNT``。"

#: ../../library/socket.rst:387
msgid "``TCP_NOTSENT_LOWAT`` was added."
msgstr "新增 ``TCP_NOTSENT_LOWAT``。"

#: ../../library/socket.rst:390
#, fuzzy
msgid ""
"On Windows, ``TCP_KEEPIDLE``, ``TCP_KEEPINTVL`` appear if run-time Windows "
"supports."
msgstr ""
"在 Windows 上，如果運行時 Windows 支援，則會出現 ``TCP_KEEPIDLE``、"
"``TCP_KEEPINTVL``。"

#: ../../library/socket.rst:393
#, fuzzy
msgid ""
"``IP_RECVTOS`` was added.  Added ``TCP_KEEPALIVE``. On MacOS this constant "
"can be used in the same  way that ``TCP_KEEPIDLE`` is used on Linux."
msgstr ""
"新增了``IP_RECVTOS``。新增了``TCP_KEEPALIVE``。在 MacOS 上，這個常數的使用方"
"式與在 Linux 上使用 ``TCP_KEEPIDLE`` 的方式相同。"

#: ../../library/socket.rst:398
#, fuzzy
msgid ""
"Added ``TCP_CONNECTION_INFO``. On MacOS this constant can be used in the "
"same way that ``TCP_INFO`` is used on Linux and BSD."
msgstr ""
"新增了``TCP_CONNECTION_INFO``。在 MacOS 上，這個常數的使用方式與在 Linux 和 "
"BSD 上使用 ``TCP_INFO`` 的方式相同。"

#: ../../library/socket.rst:407 ../../library/socket.rst:477
#: ../../library/socket.rst:488
#, fuzzy
msgid ""
"Many constants of these forms, documented in the Linux documentation, are "
"also defined in the socket module."
msgstr "Linux 文檔中記錄的這些形式的許多常數也在 socket 模組中定義。"

#: ../../library/socket.rst:410
msgid ":ref:`Availability <availability>`: Linux >= 2.6.25, NetBSD >= 8."
msgstr ":ref:`適用 <availability>`：Linux 2.6.25 以上、NetBSD 8 以上。"

#: ../../library/socket.rst:414
#, fuzzy
msgid "NetBSD support was added."
msgstr "新增了 NetBSD 支援。"

#: ../../library/socket.rst:420
#, fuzzy
msgid ""
"CAN_BCM, in the CAN protocol family, is the broadcast manager (BCM) "
"protocol. Broadcast manager constants, documented in the Linux "
"documentation, are also defined in the socket module."
msgstr ""
"CAN_BCM，在CAN協定族中，是廣播管理器（BCM）協定。 Linux 文檔中記錄的廣播管理"
"器常數也在 socket 模組中定義。"

#: ../../library/socket.rst:424 ../../library/socket.rst:459
msgid ":ref:`Availability <availability>`: Linux >= 2.6.25."
msgstr ":ref:`適用 <availability>`：Linux >= 2.6.25。"

#: ../../library/socket.rst:427
#, fuzzy
msgid ""
"The :data:`CAN_BCM_CAN_FD_FRAME` flag is only available on Linux >= 4.8."
msgstr ":data:`CAN_BCM_CAN_FD_FRAME` 旗標僅在 Linux >= 4.8 上可用。"

#: ../../library/socket.rst:433
#, fuzzy
msgid ""
"Enables CAN FD support in a CAN_RAW socket. This is disabled by default. "
"This allows your application to send both CAN and CAN FD frames; however, "
"you must accept both CAN and CAN FD frames when reading from the socket."
msgstr ""
"在 CAN_RAW  socket 中啟用 CAN FD 支援。預設情況下禁用。這允許您的應用程式發"
"送 CAN 和 CAN FD 幀；但是，從 socket 讀取時，您必須同時接受 CAN 和 CAN FD "
"幀。"

#: ../../library/socket.rst:437 ../../library/socket.rst:448
#, fuzzy
msgid "This constant is documented in the Linux documentation."
msgstr "此常數記錄在 Linux 文檔中。"

#: ../../library/socket.rst:439
msgid ":ref:`Availability <availability>`: Linux >= 3.6."
msgstr ":ref:`適用 <availability>`：Linux >= 3.6。"

#: ../../library/socket.rst:445
#, fuzzy
msgid ""
"Joins the applied CAN filters such that only CAN frames that match all given "
"CAN filters are passed to user space."
msgstr ""
"加入應用的 CAN 過濾器，以便只有匹配所有給定 CAN 過濾器的 CAN 幀才會傳遞到使用"
"者空間。"

#: ../../library/socket.rst:450
msgid ":ref:`Availability <availability>`: Linux >= 4.1."
msgstr ":ref:`適用 <availability>`：Linux >= 4.1。"

#: ../../library/socket.rst:456
#, fuzzy
msgid ""
"CAN_ISOTP, in the CAN protocol family, is the ISO-TP (ISO 15765-2) protocol. "
"ISO-TP constants, documented in the Linux documentation."
msgstr ""
"CAN_ISOTP，在CAN協定族中，是ISO-TP（ISO 15765-2）協定。 ISO-TP 常數，記錄在 "
"Linux 文檔中。"

#: ../../library/socket.rst:465
#, fuzzy
msgid ""
"CAN_J1939, in the CAN protocol family, is the SAE J1939 protocol. J1939 "
"constants, documented in the Linux documentation."
msgstr ""
"CAN_J1939，在CAN協定族中，是SAE J1939協定。 J1939 常數，記錄在 Linux 文檔中。"

#: ../../library/socket.rst:468
msgid ":ref:`Availability <availability>`: Linux >= 5.4."
msgstr ":ref:`適用 <availability>`：Linux >= 5.4。"

#: ../../library/socket.rst:491
msgid ":ref:`Availability <availability>`: Linux >= 2.6.30."
msgstr ":ref:`適用 <availability>`：Linux >= 2.6.30。"

#: ../../library/socket.rst:501
#, fuzzy
msgid ""
"Constants for Windows' WSAIoctl(). The constants are used as arguments to "
"the :meth:`~socket.socket.ioctl` method of socket objects."
msgstr ""
"Windows 的 WSAIoctl() 的常數。這些常數用作 socket 物件的 :meth:`~socket."
"socket.ioctl` 方法的參數。"

#: ../../library/socket.rst:504 ../../library/socket.rst:1458
msgid "``SIO_LOOPBACK_FAST_PATH`` was added."
msgstr "加入 ``SIO_LOOPBACK_FAST_PATH``。"

#: ../../library/socket.rst:510
#, fuzzy
msgid ""
"TIPC related constants, matching the ones exported by the C socket API. See "
"the TIPC documentation for more information."
msgstr ""
"TIPC 相關常數，匹配 C  socket  API 導出的常數。有關詳細資訊，請參閱 TIPC 文"
"檔。"

#: ../../library/socket.rst:517
#, fuzzy
msgid "Constants for Linux Kernel cryptography."
msgstr "Linux 內核密碼學的常數。"

#: ../../library/socket.rst:529
#, fuzzy
msgid "Constants for Linux host/guest communication."
msgstr "Linux 主機/來賓通信的常數。"

#: ../../library/socket.rst:531
msgid ":ref:`Availability <availability>`: Linux >= 4.8."
msgstr ":ref:`適用 <availability>`：Linux >= 4.8。"

#: ../../library/socket.rst:537
msgid ":ref:`Availability <availability>`: BSD, macOS."
msgstr ":ref:`適用 <availability>`：BSD、macOS。"

#: ../../library/socket.rst:543
#, fuzzy
msgid ""
"This constant contains a boolean value which indicates if IPv6 is supported "
"on this platform."
msgstr "此常數包含一個布爾值，指示此平台是否支援 IPv6。"

#: ../../library/socket.rst:549
#, fuzzy
msgid ""
"These are string constants containing Bluetooth addresses with special "
"meanings. For example, :const:`BDADDR_ANY` can be used to indicate any "
"address when specifying the binding socket with :const:`BTPROTO_RFCOMM`."
msgstr ""
"這些是包含具有特殊含義的藍牙地址的字串常數。例如 :const:`BDADDR_ANY` 可用於在"
"使用 :const:`BTPROTO_RFCOMM` 指定綁定 socket 時指示任何地址。"

#: ../../library/socket.rst:558
#, fuzzy
msgid ""
"For use with :const:`BTPROTO_HCI`. :const:`HCI_FILTER` is not available for "
"NetBSD or DragonFlyBSD. :const:`HCI_TIME_STAMP` and :const:`HCI_DATA_DIR` "
"are not available for FreeBSD, NetBSD, or DragonFlyBSD."
msgstr ""
"與 :const:`BTPROTO_HCI` 一起使用。 :const:`HCI_FILTER` 不適用於 NetBSD 或 "
"DragonFlyBSD。 :const:`HCI_TIME_STAMP` 和 :const:`HCI_DATA_DIR` 不適用於 "
"FreeBSD、NetBSD 或 DragonFlyBSD。"

#: ../../library/socket.rst:565
#, fuzzy
msgid ""
"Constant for Qualcomm's IPC router protocol, used to communicate with "
"service providing remote processors."
msgstr "Qualcomm 的 IPC 路由器協定常數，用於與提供遠程處理器的服務進行通信。"

#: ../../library/socket.rst:574
#, fuzzy
msgid ""
"LOCAL_CREDS and LOCAL_CREDS_PERSISTENT can be used with SOCK_DGRAM, "
"SOCK_STREAM sockets, equivalent to Linux/DragonFlyBSD SO_PASSCRED, while "
"LOCAL_CREDS sends the credentials at first read, LOCAL_CREDS_PERSISTENT "
"sends for each read, SCM_CREDS2 must be then used for the latter for the "
"message type."
msgstr ""
"LOCAL_CREDS 和 LOCAL_CREDS_PERSISTENT 可以與 SOCK_DGRAM、SOCK_STREAM  socket "
"一起使用，相當於 Linux/DragonFlyBSD SO_PASSCRED，而 LOCAL_CREDS 在第一次讀取"
"時發送憑據，LOCAL_CREDS_PERSISTENT 在每次讀取時發送，SCM_CREDS2 必須用於後者"
"的消息型別。"

#: ../../library/socket.rst:583
msgid ":ref:`Availability <availability>`: FreeBSD."
msgstr ":ref:`適用 <availability>`：FreeBSD。"

#: ../../library/socket.rst:587
#, fuzzy
msgid ""
"Constant to optimize CPU locality, to be used in conjunction with :data:"
"`SO_REUSEPORT`."
msgstr "最佳化 CPU 局部性的常數，與 :data:`SO_REUSEPORT` 結合使用。"

#: ../../library/socket.rst:595
msgid "Functions"
msgstr "函式"

#: ../../library/socket.rst:598
msgid "Creating sockets"
msgstr "建立 sockets"

#: ../../library/socket.rst:600
#, fuzzy
msgid ""
"The following functions all create :ref:`socket objects <socket-objects>`."
msgstr "以下函式都建立 :ref:`socket objects <socket-objects>`。"

#: ../../library/socket.rst:605
#, fuzzy
msgid ""
"Create a new socket using the given address family, socket type and protocol "
"number.  The address family should be :const:`AF_INET` (the default), :const:"
"`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN`, :const:`AF_PACKET`, or :const:"
"`AF_RDS`. The socket type should be :const:`SOCK_STREAM` (the default), :"
"const:`SOCK_DGRAM`, :const:`SOCK_RAW` or perhaps one of the other ``SOCK_`` "
"constants. The protocol number is usually zero and may be omitted or in the "
"case where the address family is :const:`AF_CAN` the protocol should be one "
"of :const:`CAN_RAW`, :const:`CAN_BCM`, :const:`CAN_ISOTP` or :const:"
"`CAN_J1939`."
msgstr ""
"使用給定的地址族、 socket 型別和協定號建立一個新 socket 。地址系列應該是 :"
"const:`AF_INET`（預設值）、:const:`AF_INET6`、:const:`AF_UNIX`、:const:"
"`AF_CAN`、:const:`AF_PACKET` 或 :const:`AF_RDS `。 socket 型別應該是 :const:"
"`SOCK_STREAM`（預設值）、:const:`SOCK_DGRAM`、:const:`SOCK_RAW` 或者可能是其"
"他 ``SOCK_`` 常數之一。協定編號通常為零，可以省略，或者在地址族為 AF_CAN 的情"
"況下，協定應為 CAN_RAW、CAN_BCM、CAN_ISOTP 之一` 或 :const:`CAN_J1939`。"

#: ../../library/socket.rst:615
#, fuzzy
msgid ""
"If *fileno* is specified, the values for *family*, *type*, and *proto* are "
"auto-detected from the specified file descriptor.  Auto-detection can be "
"overruled by calling the function with explicit *family*, *type*, or *proto* "
"arguments.  This only affects how Python represents e.g. the return value "
"of :meth:`socket.getpeername` but not the actual OS resource.  Unlike :func:"
"`socket.fromfd`, *fileno* will return the same socket and not a duplicate. "
"This may help close a detached socket using :meth:`socket.close()`."
msgstr ""
"如果指定了 *fileno*，則從指定的文件描述器中自動檢測 *family*、*type* 和 "
"*proto* 的值。可以通過使用顯式 *family*、*type* 或 *proto* 參數呼叫函式來否決"
"自動檢測。這只會影響 Python 的表示方式，例如 :meth:`socket.getpeername` 的回"
"傳值，但不是實際的操作系統資源。與 :func:`socket.fromfd` 不同，*fileno* 將回"
"傳相同的 socket 而不是重複的 socket 。這可能有助於使用 socket.close() 關閉分"
"離的 socket 。"

#: ../../library/socket.rst:624 ../../library/socket.rst:770
#: ../../library/socket.rst:1277 ../../library/socket.rst:1371
#, fuzzy
msgid "The newly created socket is :ref:`non-inheritable <fd_inheritance>`."
msgstr "新建立的 socket 是 :ref:`non-inheritable <fd_inheritance>`。"

#: ../../library/socket.rst:637
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.__new__`` with arguments "
"``self``, ``family``, ``type``, ``protocol``."
msgstr ""
"引發一個附帶引數 ``self``、``family``、``type``、``protocol`` 的\\ :ref:`稽核"
"事件 <auditing>` ``socket.__new__``。"

#: ../../library/socket.rst:628
#, fuzzy
msgid "The AF_CAN family was added. The AF_RDS family was added."
msgstr "新增了 AF_CAN 系列。新增了 AF_RDS 系列。"

#: ../../library/socket.rst:632
msgid "The CAN_BCM protocol was added."
msgstr "新增 CAN_BCM 協定。"

#: ../../library/socket.rst:635 ../../library/socket.rst:772
#, fuzzy
msgid "The returned socket is now non-inheritable."
msgstr "回傳的 socket 現在不可繼承。"

#: ../../library/socket.rst:638
msgid "The CAN_ISOTP protocol was added."
msgstr "新增 CAN_ISOTP 協定。"

#: ../../library/socket.rst:641
#, fuzzy
msgid ""
"When :const:`SOCK_NONBLOCK` or :const:`SOCK_CLOEXEC` bit flags are applied "
"to *type* they are cleared, and :attr:`socket.type` will not reflect them.  "
"They are still passed to the underlying system ``socket()`` call.  Therefore,"
msgstr ""
"當 :const:`SOCK_NONBLOCK` 或 :const:`SOCK_CLOEXEC` 位旗標應用於 *type* 它們會"
"被清除，並且 :attr:`socket.type` 不會反映它們。它們仍然傳遞給底層系統 "
"``socket()`` 呼叫。所以，"

#: ../../library/socket.rst:653
#, fuzzy
msgid ""
"will still create a non-blocking socket on OSes that support "
"``SOCK_NONBLOCK``, but ``sock.type`` will be set to ``socket.SOCK_STREAM``."
msgstr ""
"仍然會在支援 ``SOCK_NONBLOCK`` 的操作系統上建立一個非阻塞 socket ，但是 "
"``sock.type`` 將被設定為 ``socket.SOCK_STREAM``。"

#: ../../library/socket.rst:657
msgid "The CAN_J1939 protocol was added."
msgstr "新增 CAN_J1939 協定。"

#: ../../library/socket.rst:660
msgid "The IPPROTO_MPTCP protocol was added."
msgstr "新增 IPPROTO_MPTCP 協定。"

#: ../../library/socket.rst:665
#, fuzzy
msgid ""
"Build a pair of connected socket objects using the given address family, "
"socket type, and protocol number.  Address family, socket type, and protocol "
"number are as for the :func:`.socket` function above. The default family is :"
"const:`AF_UNIX` if defined on the platform; otherwise, the default is :const:"
"`AF_INET`."
msgstr ""
"使用給定的地址族、 socket 型別和協定號構建一對連接的 socket 物件。地址族、 "
"socket 型別和協定號與上面的 :func:`.socket` 函式相同。如果在平台上定義，則預"
"設系列為 :const:`AF_UNIX`；否則，預設值為 :const:`AF_INET`。"

#: ../../library/socket.rst:670
#, fuzzy
msgid "The newly created sockets are :ref:`non-inheritable <fd_inheritance>`."
msgstr "新建立的 socket 是 :ref:`non-inheritable <fd_inheritance>`。"

#: ../../library/socket.rst:672
#, fuzzy
msgid ""
"The returned socket objects now support the whole socket API, rather than a "
"subset."
msgstr "回傳的 socket 物件現在支援整個 socket  API，而不是一個子集。"

#: ../../library/socket.rst:676
#, fuzzy
msgid "The returned sockets are now non-inheritable."
msgstr "回傳的 socket 現在不可繼承。"

#: ../../library/socket.rst:679
msgid "Windows support added."
msgstr "新增對 Windows 的支援。"

#: ../../library/socket.rst:685
#, fuzzy
msgid ""
"Connect to a TCP service listening on the internet *address* (a 2-tuple "
"``(host, port)``), and return the socket object.  This is a higher-level "
"function than :meth:`socket.connect`: if *host* is a non-numeric hostname, "
"it will try to resolve it for both :data:`AF_INET` and :data:`AF_INET6`, and "
"then try to connect to all possible addresses in turn until a connection "
"succeeds.  This makes it easy to write clients that are compatible to both "
"IPv4 and IPv6."
msgstr ""
"連接到 TCP 服務監聽網際網路*地址*（二元組``（主機，端口）``），並回傳 socket 物"
"件。這是一個比 :meth:`socket.connect` 更高階的函式：如果 *host* 是一個非數字"
"主機名，它將嘗試為 :data:`AF_INET` 和 :data:`AF_INET6` 解析它，然後依次嘗試連"
"接所有可能的地址，直到連接成功。這使得編寫同時相容 IPv4 和 IPv6 的客戶端變得"
"容易。"

#: ../../library/socket.rst:693
#, fuzzy
msgid ""
"Passing the optional *timeout* parameter will set the timeout on the socket "
"instance before attempting to connect.  If no *timeout* is supplied, the "
"global default timeout setting returned by :func:`getdefaulttimeout` is used."
msgstr ""
"傳遞可選的 *timeout* 參數將在嘗試連接之前在 socket 實例上設定超時。如果未提"
"供 *timeout*，則使用 :func:`getdefaulttimeout` 回傳的全局預設超時設定。"

#: ../../library/socket.rst:698
#, fuzzy
msgid ""
"If supplied, *source_address* must be a 2-tuple ``(host, port)`` for the "
"socket to bind to as its source address before connecting.  If host or port "
"are '' or 0 respectively the OS default behavior will be used."
msgstr ""
"如果提供，*source_address* 必須是一個二元組``（主機，端口）``，以便 socket 在"
"連接之前綁定到它的源地址。如果主機或端口分別為 '' 或 0，則將使用操作系統預設"
"行為。"

#: ../../library/socket.rst:702
#, fuzzy
msgid ""
"When a connection cannot be created, an exception is raised. By default, it "
"is the exception from the last address in the list. If *all_errors* is "
"``True``, it is an :exc:`ExceptionGroup` containing the errors of all "
"attempts."
msgstr ""
"當無法建立連接時，會引發例外。預設情況下，它是列表中最後一個地址的例外。如果 "
"*all_errors* 為 ``True``，則它是一個包含所有嘗試錯誤的 ExceptionGroup。"

#: ../../library/socket.rst:707
msgid "*source_address* was added."
msgstr "新增 *source_address*\\ 。"

#: ../../library/socket.rst:710
msgid "*all_errors* was added."
msgstr "新增 *all_errors*\\ 。"

#: ../../library/socket.rst:716
#, fuzzy
msgid ""
"Convenience function which creates a TCP socket bound to *address* (a 2-"
"tuple ``(host, port)``) and return the socket object."
msgstr ""
"建立綁定到 *address*（二元組``（主機，端口）``）並回傳 socket 物件的 TCP  "
"socket 的便捷函式。"

#: ../../library/socket.rst:719
#, fuzzy
msgid ""
"*family* should be either :data:`AF_INET` or :data:`AF_INET6`. *backlog* is "
"the queue size passed to :meth:`socket.listen`; if not specified , a default "
"reasonable value is chosen. *reuse_port* dictates whether to set the :data:"
"`SO_REUSEPORT` socket option."
msgstr ""
"*family* 應該是 :data:`AF_INET` 或 :data:`AF_INET6`。 *backlog* 是傳遞給 "
"socket.listen 的隊列大小；如果未指定，則選擇預設的合理值。 *reuse_port* 指示"
"是否設定 :data:`SO_REUSEPORT`  socket 選項。"

#: ../../library/socket.rst:724
#, fuzzy
msgid ""
"If *dualstack_ipv6* is true and the platform supports it the socket will be "
"able to accept both IPv4 and IPv6 connections, else it will raise :exc:"
"`ValueError`. Most POSIX platforms and Windows are supposed to support this "
"functionality. When this functionality is enabled the address returned by :"
"meth:`socket.getpeername` when an IPv4 connection occurs will be an IPv6 "
"address represented as an IPv4-mapped IPv6 address. If *dualstack_ipv6* is "
"false it will explicitly disable this functionality on platforms that enable "
"it by default (e.g. Linux). This parameter can be used in conjunction with :"
"func:`has_dualstack_ipv6`:"
msgstr ""
"如果 *dualstack_ipv6* 為 true 並且平台支援它， socket 將能夠接受 IPv4 和 "
"IPv6 連接，否則它會引發 :exc:`ValueError`。大多數 POSIX 平台和 Windows 都應該"
"支援此功能。啟用此功能後，發生 IPv4 連接時 socket.getpeername 回傳的地址將是"
"一個 IPv6 地址，表示為 IPv4 映射的 IPv6 地址。如果 *dualstack_ipv6* 為 "
"false，它將在預設啟用它的平台（例如 Linux）上明確禁用此功能。此參數可以與 :"
"func:`has_dualstack_ipv6` 結合使用："

#: ../../library/socket.rst:746
#, fuzzy
msgid ""
"On POSIX platforms the :data:`SO_REUSEADDR` socket option is set in order to "
"immediately reuse previous sockets which were bound on the same *address* "
"and remained in TIME_WAIT state."
msgstr ""
"在 POSIX 平台上，設定 :data:`SO_REUSEADDR`  socket 選項是為了立即重用以前綁定"
"在相同 *address* 並保持 TIME_WAIT 狀態的 socket 。"

#: ../../library/socket.rst:754
#, fuzzy
msgid ""
"Return ``True`` if the platform supports creating a TCP socket which can "
"handle both IPv4 and IPv6 connections."
msgstr ""
"如果平台支援建立可以處理 IPv4 和 IPv6 連接的 TCP  socket ，則回傳 ``True``。"

#: ../../library/socket.rst:761
#, fuzzy
msgid ""
"Duplicate the file descriptor *fd* (an integer as returned by a file "
"object's :meth:`fileno` method) and build a socket object from the result.  "
"Address family, socket type and protocol number are as for the :func:`."
"socket` function above. The file descriptor should refer to a socket, but "
"this is not checked --- subsequent operations on the object may fail if the "
"file descriptor is invalid. This function is rarely needed, but can be used "
"to get or set socket options on a socket passed to a program as standard "
"input or output (such as a server started by the Unix inet daemon).  The "
"socket is assumed to be in blocking mode."
msgstr ""
"複製文件描述器 *fd*（一個由文件物件的 :meth:`fileno` 方法回傳的整數）並根據結"
"果構建一個 socket 物件。地址族、 socket 型別和協定號與上面的 :func:`.socket` "
"函式相同。文件描述器應該引用一個套接字，但是沒有檢查這一點——如果文件描述器無"
"效，對該物件的後續操作可能會失敗。很少需要此函式，但可用於獲取或設定作為標準"
"輸入或輸出傳遞給程式（例如由 Unix inet 守護程式啟動的伺服器）的 socket 上的 "
"socket 選項。假定 socket 處於阻塞模式。"

#: ../../library/socket.rst:778
#, fuzzy
msgid ""
"Instantiate a socket from data obtained from the :meth:`socket.share` "
"method.  The socket is assumed to be in blocking mode."
msgstr ""
"從 :meth:`socket.share` 方法獲得的資料實例化一個 socket 。假定 socket 處於阻"
"塞模式。"

#: ../../library/socket.rst:781 ../../library/socket.rst:1872
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`適用 <availability>`：Windows。"

#: ../../library/socket.rst:788
#, fuzzy
msgid ""
"This is a Python type object that represents the socket object type. It is "
"the same as ``type(socket(...))``."
msgstr ""
"這是一個表示 socket 對像型別的 Python 型別物件。它與 ``type(socket(...))`` 相"
"同。"

#: ../../library/socket.rst:793
msgid "Other functions"
msgstr "其他函式"

#: ../../library/socket.rst:795
#, fuzzy
msgid "The :mod:`socket` module also offers various network-related services:"
msgstr ":mod:`socket` 模組還提供各種與網絡相關的服務："

#: ../../library/socket.rst:800
#, fuzzy
msgid ""
"Close a socket file descriptor. This is like :func:`os.close`, but for "
"sockets. On some platforms (most noticeable Windows) :func:`os.close` does "
"not work for socket file descriptors."
msgstr ""
"關閉 socket 文件描述器。這類似於 :func:`os.close`，但用於 socket 。在某些平台"
"上（最引人注目的 Windows） :func:`os.close` 不適用於 socket 文件描述器。"

#: ../../library/socket.rst:808
#, fuzzy
msgid ""
"Translate the *host*/*port* argument into a sequence of 5-tuples that "
"contain all the necessary arguments for creating a socket connected to that "
"service. *host* is a domain name, a string representation of an IPv4/v6 "
"address or ``None``. *port* is a string service name such as ``'http'``, a "
"numeric port number or ``None``.  By passing ``None`` as the value of *host* "
"and *port*, you can pass ``NULL`` to the underlying C API."
msgstr ""
"將 *host*/*port* 參數轉換為 5 元組序列，其中包含建立連接到該服務的 socket 所"
"需的所有參數。 *host* 是一個域名，一個 IPv4/v6 地址的字串表示或 ``None`` 。 "
"*port* 是一個字串服務名稱，例如 ``'http'``、數字端口號或 ``None``。通過將 "
"``None``作為 *host* 和 *port* 的值傳遞，您可以將 ``NULL`` 傳遞給底層 C API。"

#: ../../library/socket.rst:815
#, fuzzy
msgid ""
"The *family*, *type* and *proto* arguments can be optionally specified in "
"order to narrow the list of addresses returned.  Passing zero as a value for "
"each of these arguments selects the full range of results. The *flags* "
"argument can be one or several of the ``AI_*`` constants, and will influence "
"how results are computed and returned. For example, :const:`AI_NUMERICHOST` "
"will disable domain name resolution and will raise an error if *host* is a "
"domain name."
msgstr ""
"可以選擇性地指定 *family*、*type* 和 *proto* 參數以縮小回傳的地址列表。將零作"
"為每個參數的值來選擇全部結果範圍。 *flags* 參數可以是一個或多個“AI_*”常數，並"
"將影響結果的計算和回傳方式。例如，:const:`AI_NUMERICHOST` 將禁用域名解析並在 "
"*host* 是域名時引發錯誤。"

#: ../../library/socket.rst:823
#, fuzzy
msgid "The function returns a list of 5-tuples with the following structure:"
msgstr "該函式回傳具有以下結構的 5 元組列表："

#: ../../library/socket.rst:825
msgid "``(family, type, proto, canonname, sockaddr)``"
msgstr "``(family, type, proto, canonname, sockaddr)``"

#: ../../library/socket.rst:827
#, fuzzy
msgid ""
"In these tuples, *family*, *type*, *proto* are all integers and are meant to "
"be passed to the :func:`.socket` function.  *canonname* will be a string "
"representing the canonical name of the *host* if :const:`AI_CANONNAME` is "
"part of the *flags* argument; else *canonname* will be empty.  *sockaddr* is "
"a tuple describing a socket address, whose format depends on the returned "
"*family* (a ``(address, port)`` 2-tuple for :const:`AF_INET`, a ``(address, "
"port, flowinfo, scope_id)`` 4-tuple for :const:`AF_INET6`), and is meant to "
"be passed to the :meth:`socket.connect` method."
msgstr ""
"在這些元組中，*family*、*type*、*proto* 都是整數，旨在傳遞給 :func:`.socket` "
"函式。如果 :const:`AI_CANONNAME` 是 *flags* 參數的一部分，*canonname* 將是表"
"示 *host* 規範名稱的字串；否則 *canonname* 將為空。 *sockaddr* 是一個描述 "
"socket 地址的元組，其格式取決於回傳的 *family*（一個 ``(address, port)`` 二元"
"組用於 :const:`AF_INET`，一個 ``(address, port, flowinfo, scope_id)`` "
"AF_INET6` 的 4 元組), 旨在傳遞給 :meth:`socket.connect` 方法。"

#: ../../library/socket.rst:848
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getaddrinfo`` with "
"arguments ``host``, ``port``, ``family``, ``type``, ``protocol``."
msgstr ""
"引發一個附帶引數 ``host``、``port``、``family``、``type``、``protocol`` 的"
"\\ :ref:`稽核事件 <auditing>` ``socket.getaddrinfo``。"

#: ../../library/socket.rst:839
#, fuzzy
msgid ""
"The following example fetches address information for a hypothetical TCP "
"connection to ``example.org`` on port 80 (results may differ on your system "
"if IPv6 isn't enabled)::"
msgstr ""
"以下示例獲取地址資訊，用於在端口 80 上連接到“example.org”的假設 TCP 連接（如"
"果未啟用 IPv6，您的系統上的結果可能會有所不同）："

#: ../../library/socket.rst:849
#, fuzzy
msgid "parameters can now be passed using keyword arguments."
msgstr "現在可以使用關鍵字參數傳遞參數。"

#: ../../library/socket.rst:852
#, fuzzy
msgid ""
"for IPv6 multicast addresses, string representing an address will not "
"contain ``%scope_id`` part."
msgstr "對於 IPv6 多播地址，表示地址的字串將不包含“%scope_id”部分。"

#: ../../library/socket.rst:858
#, fuzzy
msgid ""
"Return a fully qualified domain name for *name*. If *name* is omitted or "
"empty, it is interpreted as the local host.  To find the fully qualified "
"name, the hostname returned by :func:`gethostbyaddr` is checked, followed by "
"aliases for the host, if available.  The first name which includes a period "
"is selected.  In case no fully qualified domain name is available and *name* "
"was provided, it is returned unchanged.  If *name* was empty or equal to "
"``'0.0.0.0'``, the hostname from :func:`gethostname` is returned."
msgstr ""
"回傳 *name* 的完全限定域名。如果 *name* 被省略或為空，它被解釋為本地主機。要"
"找到完全限定的名稱，檢查 :func:`gethostbyaddr` 回傳的主機名，然後檢查主機的別"
"名（如果可用）。選擇包含句點的名字。如果沒有可用的完全限定域名並且提供了 "
"*name*，則回傳原樣。如果 *name* 為空或等於 ``'0.0.0.0'``，則回傳來自 :func:"
"`gethostname` 的主機名。"

#: ../../library/socket.rst:869
#, fuzzy
msgid ""
"Translate a host name to IPv4 address format.  The IPv4 address is returned "
"as a string, such as  ``'100.50.200.5'``.  If the host name is an IPv4 "
"address itself it is returned unchanged.  See :func:`gethostbyname_ex` for a "
"more complete interface. :func:`gethostbyname` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""
"將主機名轉換為 IPv4 地址格式。 IPv4 地址以字串形式回傳，例如“100.50.200.5”。"
"如果主機名本身是一個 IPv4 地址，則回傳不變。請參閱 :func:`gethostbyname_ex` "
"以獲得更完整的界面。 :func:`gethostbyname` 不支援 IPv6 名稱解析，應該使用 :"
"func:`getaddrinfo` 來支援 IPv4/v6 雙棧。"

#: ../../library/socket.rst:886 ../../library/socket.rst:902
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyname`` with "
"argument ``hostname``."
msgstr ""
"引發一個附帶引數 ``hostname`` 的\\ :ref:`稽核事件 <auditing>` ``socket."
"gethostbyname``。"

#: ../../library/socket.rst:877 ../../library/socket.rst:893
#: ../../library/socket.rst:906 ../../library/socket.rst:921
#: ../../library/socket.rst:938 ../../library/socket.rst:949
#: ../../library/socket.rst:960 ../../library/socket.rst:971
#: ../../library/socket.rst:1295 ../../library/socket.rst:1342
#: ../../library/socket.rst:1356 ../../library/socket.rst:1376
#: ../../library/socket.rst:1423 ../../library/socket.rst:1468
#: ../../library/socket.rst:1850 ../../library/socket.rst:1860
msgid ":ref:`Availability <availability>`: not WASI."
msgstr ":ref:`適用 <availability>`：非 WASI。"

#: ../../library/socket.rst:882
#, fuzzy
msgid ""
"Translate a host name to IPv4 address format, extended interface. Return a "
"triple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is the host's "
"primary host name, *aliaslist* is a (possibly empty) list of alternative "
"host names for the same address, and *ipaddrlist* is a list of IPv4 "
"addresses for the same interface on the same host (often but not always a "
"single address). :func:`gethostbyname_ex` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""
"將主機名轉換為 IPv4 地址格式，擴充介面。回傳一個三元組``(hostname, "
"aliaslist, ipaddrlist)`` 其中 *hostname* 是主機的主要主機名，*aliaslist* 是同"
"一地址的備選主機名列表（可能為空），*ipaddrlist* 是一個同一主機上同一介面的 "
"IPv4 地址列表（通常但不總是一個地址）。 :func:`gethostbyname_ex` 不支援 IPv6 "
"名稱解析，應該使用 :func:`getaddrinfo` 代替 IPv4/v6 雙棧支援。"

#: ../../library/socket.rst:898
#, fuzzy
msgid ""
"Return a string containing the hostname of the machine where  the Python "
"interpreter is currently executing."
msgstr "回傳一個字串，其中包含 Python 直譯器當前正在執行的機器的主機名。"

#: ../../library/socket.rst:912
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostname`` with no "
"arguments."
msgstr ""
"引發一個不附帶引數的\\ :ref:`稽核事件 <auditing>` ``socket.gethostname``。"

#: ../../library/socket.rst:903
#, fuzzy
msgid ""
"Note: :func:`gethostname` doesn't always return the fully qualified domain "
"name; use :func:`getfqdn` for that."
msgstr ""
"注意：:func:`gethostname` 並不總是回傳完全限定的域名；為此使用 :func:"
"`getfqdn`。"

#: ../../library/socket.rst:911
#, fuzzy
msgid ""
"Return a triple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is "
"the primary host name responding to the given *ip_address*, *aliaslist* is a "
"(possibly empty) list of alternative host names for the same address, and "
"*ipaddrlist* is a list of IPv4/v6 addresses for the same interface on the "
"same host (most likely containing only a single address). To find the fully "
"qualified domain name, use the function :func:`getfqdn`. :func:"
"`gethostbyaddr` supports both IPv4 and IPv6."
msgstr ""
"回傳一個三元組``(hostname, aliaslist, ipaddrlist)`` 其中 *hostname* 是響應給"
"定 *ip_address* 的主要主機名，*aliaslist* 是同一地址的備選主機名列表（可能為"
"空）， *ipaddrlist* 是同一主機上同一介面的 IPv4/v6 地址列表（很可能只包含一個"
"地址）。要查找完全限定的域名，請使用函式 :func:`getfqdn`。 :func:"
"`gethostbyaddr` 同時支援 IPv4 和 IPv6。"

#: ../../library/socket.rst:930
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyaddr`` with "
"argument ``ip_address``."
msgstr ""
"引發一個附帶引數 ``ip_address`` 的\\ :ref:`稽核事件 <auditing>` ``socket."
"gethostbyaddr``。"

#: ../../library/socket.rst:926
#, fuzzy
msgid ""
"Translate a socket address *sockaddr* into a 2-tuple ``(host, port)``. "
"Depending on the settings of *flags*, the result can contain a fully "
"qualified domain name or numeric address representation in *host*.  "
"Similarly, *port* can contain a string port name or a numeric port number."
msgstr ""
"將 socket 地址 *sockaddr* 轉換為二元組 ``(host, port)``。根據 *flags* 的設"
"定，結果可以包含 *host* 中的完全限定域名或數字地址表示。同樣，*port* 可以包含"
"字串端口名稱或數字端口號。"

#: ../../library/socket.rst:931
#, fuzzy
msgid ""
"For IPv6 addresses, ``%scope_id`` is appended to the host part if *sockaddr* "
"contains meaningful *scope_id*. Usually this happens for multicast addresses."
msgstr ""
"對於 IPv6 地址，如果 *sockaddr* 包含有意義的 *scope_id*，則將 ``%scope_id`` "
"附加到主機部分。通常這發生在多播地址上。"

#: ../../library/socket.rst:934
#, fuzzy
msgid ""
"For more information about *flags* you can consult :manpage:`getnameinfo(3)`."
msgstr "有關 *flags* 的更多資訊，您可以參考 :manpage:`getnameinfo(3)`。"

#: ../../library/socket.rst:947
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getnameinfo`` with "
"argument ``sockaddr``."
msgstr ""
"引發一個附帶引數 ``sockaddr`` 的\\ :ref:`稽核事件 <auditing>` ``socket."
"getnameinfo``。"

#: ../../library/socket.rst:943
#, fuzzy
msgid ""
"Translate an internet protocol name (for example, ``'icmp'``) to a constant "
"suitable for passing as the (optional) third argument to the :func:`.socket` "
"function.  This is usually only needed for sockets opened in \"raw\" mode (:"
"const:`SOCK_RAW`); for the normal socket modes, the correct protocol is "
"chosen automatically if the protocol is omitted or zero."
msgstr ""
"將網際網路協定名稱（例如，``'icmp'``）轉換為適合作為（可選）第三個參數傳遞給 :"
"func:`.socket` 函式的常數。這通常只需要在“原始”模式下打開的 socket  (:const:"
"`SOCK_RAW`)；對於普通 socket 模式，如果協定被省略或為零，則會自動選擇正確的協"
"定。"

#: ../../library/socket.rst:954
#, fuzzy
msgid ""
"Translate an internet service name and protocol name to a port number for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""
"將 Internet 服務名稱和協定名稱轉換為該服務的端口號。可選的協定名稱，如果給定"
"的話，應該是 ``'tcp'`` 或 ``'udp'``，否則任何協定都會匹配。"

#: ../../library/socket.rst:969
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyname`` with "
"arguments ``servicename``, ``protocolname``."
msgstr ""
"引發一個附帶引數 ``sockaddr``、``protocolname`` 的\\ :ref:`稽核事件 "
"<auditing>` ``socket.getservbyname``。"

#: ../../library/socket.rst:965
#, fuzzy
msgid ""
"Translate an internet port number and protocol name to a service name for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""
"將 Internet 端口號和協定名稱轉換為該服務的服務名稱。可選的協定名稱，如果給定"
"的話，應該是 ``'tcp'`` 或 ``'udp'``，否則任何協定都會匹配。"

#: ../../library/socket.rst:980
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyport`` with "
"arguments ``port``, ``protocolname``."
msgstr ""
"引發一個附帶引數 ``port``、``protocolname`` 的\\ :ref:`稽核事件 <auditing>` "
"``socket.getservbyport``。"

#: ../../library/socket.rst:976
#, fuzzy
msgid ""
"Convert 32-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"將 32 位正整數從網絡位元組順序轉換為主機位元組順序。在主機位元組順序與網絡位"
"元組順序相同的機器上，這是一個空操作；否則，它執行 4 位元組交換操作。"

#: ../../library/socket.rst:983
#, fuzzy
msgid ""
"Convert 16-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"將 16 位正整數從網絡位元組順序轉換為主機位元組順序。在主機位元組順序與網絡位"
"元組順序相同的機器上，這是一個空操作；否則，它執行 2 位元組交換操作。"

#: ../../library/socket.rst:987 ../../library/socket.rst:1005
#, fuzzy
msgid ""
"Raises :exc:`OverflowError` if *x* does not fit in a 16-bit unsigned integer."
msgstr "如果 *x* 不適合 16 位無符號整數，則引發 :exc:`OverflowError`。"

#: ../../library/socket.rst:994
#, fuzzy
msgid ""
"Convert 32-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"將 32 位正整數從主機位元組順序轉換為網絡位元組順序。在主機位元組順序與網絡位"
"元組順序相同的機器上，這是一個空操作；否則，它執行 4 位元組交換操作。"

#: ../../library/socket.rst:1001
#, fuzzy
msgid ""
"Convert 16-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"將 16 位正整數從主機位元組順序轉換為網絡位元組順序。在主機位元組順序與網絡位"
"元組順序相同的機器上，這是一個空操作；否則，它執行 2 位元組交換操作。"

#: ../../library/socket.rst:1012
#, fuzzy
msgid ""
"Convert an IPv4 address from dotted-quad string format (for example, "
"'123.45.67.89') to 32-bit packed binary format, as a bytes object four "
"characters in length.  This is useful when conversing with a program that "
"uses the standard C library and needs objects of type :c:struct:`in_addr`, "
"which is the C type for the 32-bit packed binary this function returns."
msgstr ""
"將 IPv4 地址從點分四組字串格式（例如，'123.45.67.89'）轉換為 32 位壓縮二進位"
"格式，作為長度為四個字元的位元組物件。這在與使用標準 C 庫並需要 :c:struct:"
"`in_addr` 型別物件的程式對話時很有用，這是此函式回傳的 32 位壓縮二進位文件的 "
"C 型別。"

#: ../../library/socket.rst:1018
#, fuzzy
msgid ""
":func:`inet_aton` also accepts strings with less than three dots; see the "
"Unix manual page :manpage:`inet(3)` for details."
msgstr ""
":func:`inet_aton` 也接受少於三個點的字串；有關詳細資訊，請參閱 Unix 手冊頁 :"
"manpage:`inet(3)`。"

#: ../../library/socket.rst:1021
#, fuzzy
msgid ""
"If the IPv4 address string passed to this function is invalid, :exc:"
"`OSError` will be raised. Note that exactly what is valid depends on the "
"underlying C implementation of :c:func:`inet_aton`."
msgstr ""
"如果傳遞給此函式的 IPv4 地址字串無效，將引發 :exc:`OSError`。請注意，究竟什麼"
"是有效的取決於 :c:func:`inet_aton` 的底層 C 實作。"

#: ../../library/socket.rst:1025
#, fuzzy
msgid ""
":func:`inet_aton` does not support IPv6, and :func:`inet_pton` should be "
"used instead for IPv4/v6 dual stack support."
msgstr ""
":func:`inet_aton` 不支援 IPv6，應該使用 :func:`inet_pton` 代替 IPv4/v6 雙棧支"
"援。"

#: ../../library/socket.rst:1031
#, fuzzy
msgid ""
"Convert a 32-bit packed IPv4 address (a :term:`bytes-like object` four bytes "
"in length) to its standard dotted-quad string representation (for example, "
"'123.45.67.89').  This is useful when conversing with a program that uses "
"the standard C library and needs objects of type :c:struct:`in_addr`, which "
"is the C type for the 32-bit packed binary data this function takes as an "
"argument."
msgstr ""
"將 32 位打包的 IPv4 地址（長度為四個位元組的類似位元組的物件）轉換為其標準的"
"點分四組字串表示形式（例如，'123.45.67.89'）。這在與使用標準 C 庫並需要 :c:"
"struct:`in_addr` 型別物件的程式對話時很有用，這是此函式作為參數的 32 位壓縮二"
"進位資料的 C 型別。"

#: ../../library/socket.rst:1038
#, fuzzy
msgid ""
"If the byte sequence passed to this function is not exactly 4 bytes in "
"length, :exc:`OSError` will be raised. :func:`inet_ntoa` does not support "
"IPv6, and :func:`inet_ntop` should be used instead for IPv4/v6 dual stack "
"support."
msgstr ""
"如果傳遞給此函式的位元組序列長度不正好是 4 個位元組，則會引發 :exc:"
"`OSError`。 :func:`inet_ntoa` 不支援 IPv6，應該使用 :func:`inet_ntop` 來支援 "
"IPv4/v6 雙棧。"

#: ../../library/socket.rst:1049
#, fuzzy
msgid ""
"Convert an IP address from its family-specific string format to a packed, "
"binary format. :func:`inet_pton` is useful when a library or network "
"protocol calls for an object of type :c:struct:`in_addr` (similar to :func:"
"`inet_aton`) or :c:struct:`in6_addr`."
msgstr ""
"將 IP 地址從其特定於家族的字串格式轉換為打包的二進位格式。 :func:`inet_pton` "
"在庫或網絡協定呼叫 :c:struct:`in_addr`（類似於 :func:`inet_aton`）或 :c:"
"struct:`in6_addr` 型別的物件時很有用。"

#: ../../library/socket.rst:1054
#, fuzzy
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and :"
"const:`AF_INET6`. If the IP address string *ip_string* is invalid, :exc:"
"`OSError` will be raised. Note that exactly what is valid depends on both "
"the value of *address_family* and the underlying implementation of :c:func:"
"`inet_pton`."
msgstr ""
"*address_family* 支援的值目前是 :const:`AF_INET` 和 :const:`AF_INET6`。如果 "
"IP 地址字串 *ip_string* 無效，將引發 :exc:`OSError`。請注意，究竟什麼是有效的"
"取決於 *address_family* 的值和 :c:func:`inet_pton` 的底層實作。"

#: ../../library/socket.rst:1060 ../../library/socket.rst:1080
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`適用 <availability>`：Unix、Windows。"

#: ../../library/socket.rst:1062 ../../library/socket.rst:1082
#, fuzzy
msgid "Windows support added"
msgstr "新增 Windows 支援"

#: ../../library/socket.rst:1068
#, fuzzy
msgid ""
"Convert a packed IP address (a :term:`bytes-like object` of some number of "
"bytes) to its standard, family-specific string representation (for example, "
"``'7.10.0.5'`` or ``'5aef:2b::8'``). :func:`inet_ntop` is useful when a "
"library or network protocol returns an object of type :c:struct:`in_addr` "
"(similar to :func:`inet_ntoa`) or :c:struct:`in6_addr`."
msgstr ""
"將打包的 IP 地址（一些位元組數的 :term:`bytes-like object`）轉換為其標準的、"
"特定於系列的字串表示形式（例如，``'7.10.0.5'`` 或 ``'5aef： 2b::8'``）。 :"
"func:`inet_ntop` 在庫或網絡協定回傳 :c:struct:`in_addr`（類似於 :func:"
"`inet_ntoa`）或 :c:struct:`in6_addr` 型別的物件時很有用。"

#: ../../library/socket.rst:1075
#, fuzzy
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and :"
"const:`AF_INET6`. If the bytes object *packed_ip* is not the correct length "
"for the specified address family, :exc:`ValueError` will be raised. :exc:"
"`OSError` is raised for errors from the call to :func:`inet_ntop`."
msgstr ""
"*address_family* 支援的值目前是 :const:`AF_INET` 和 :const:`AF_INET6`。如果位"
"元組物件 *packed_ip* 不是指定地址系列的正確長度，則會引發 :exc:"
"`ValueError`。 :exc:`OSError` 是針對呼叫 :func:`inet_ntop` 的錯誤而引發的。"

#: ../../library/socket.rst:1097
#, fuzzy
msgid ""
"Return the total length, without trailing padding, of an ancillary data item "
"with associated data of the given *length*.  This value can often be used as "
"the buffer size for :meth:`~socket.recvmsg` to receive a single item of "
"ancillary data, but :rfc:`3542` requires portable applications to use :func:"
"`CMSG_SPACE` and thus include space for padding, even when the item will be "
"the last in the buffer.  Raises :exc:`OverflowError` if *length* is outside "
"the permissible range of values."
msgstr ""
"回傳具有給定 *length* 關聯資料的輔助資料項的總長度，不帶尾隨填充。此值通常可"
"用作 :meth:`~socket.recvmsg` 的緩衝區大小以接收單個輔助資料項，但 :rfc:"
"`3542` 要求便攜式應用程式使用 :func:`CMSG_SPACE` 並因此包括填充空間，即使該項"
"目將是緩衝區中的最後一個。如果 *length* 超出允許的值範圍，則引發 :exc:"
"`OverflowError`。"

#: ../../library/socket.rst:1106 ../../library/socket.rst:1129
msgid ":ref:`Availability <availability>`: Unix, not Emscripten, not WASI."
msgstr ":ref:`適用 <availability>`：Unix、非 Emscripten、非 WASI。"

#: ../../library/socket.rst:1108 ../../library/socket.rst:1598
#: ../../library/socket.rst:1642 ../../library/socket.rst:1750
#, fuzzy
msgid "Most Unix platforms."
msgstr "大多數 Unix 平台。"

#: ../../library/socket.rst:1115
#, fuzzy
msgid ""
"Return the buffer size needed for :meth:`~socket.recvmsg` to receive an "
"ancillary data item with associated data of the given *length*, along with "
"any trailing padding.  The buffer space needed to receive multiple items is "
"the sum of the :func:`CMSG_SPACE` values for their associated data lengths.  "
"Raises :exc:`OverflowError` if *length* is outside the permissible range of "
"values."
msgstr ""
"回傳 :meth:`~socket.recvmsg` 接收具有給定 *length* 關聯資料的輔助資料項以及任"
"何尾隨填充所需的緩衝區大小。接收多個項目所需的緩衝區空間是其關聯資料長度的 "
"CMSG_SPACE 值的總和。如果 *length* 超出允許的值範圍，則引發 :exc:"
"`OverflowError`。"

#: ../../library/socket.rst:1123
#, fuzzy
msgid ""
"Note that some systems might support ancillary data without providing this "
"function.  Also note that setting the buffer size using the results of this "
"function may not precisely limit the amount of ancillary data that can be "
"received, since additional data may be able to fit into the padding area."
msgstr ""
"請注意，某些系統可能在不提供此功能的情況下支援輔助資料。另請注意，使用此函式"
"的結果設定緩衝區大小可能不會精確地限制可以接收的輔助資料量，因為額外的資料可"
"能能夠放入填充區域。"

#: ../../library/socket.rst:1131
#, fuzzy
msgid "most Unix platforms."
msgstr "大多數 Unix 平台。"

#: ../../library/socket.rst:1138
#, fuzzy
msgid ""
"Return the default timeout in seconds (float) for new socket objects. A "
"value of ``None`` indicates that new socket objects have no timeout. When "
"the socket module is first imported, the default is ``None``."
msgstr ""
"回傳新 socket 物件的預設超時（以秒為單位）（浮點數）。  ``None`` 值表示新 "
"socket 對像沒有超時。首次導入 socket 模組時，預設為 ``None`` 。"

#: ../../library/socket.rst:1145
#, fuzzy
msgid ""
"Set the default timeout in seconds (float) for new socket objects.  When the "
"socket module is first imported, the default is ``None``.  See :meth:"
"`~socket.settimeout` for possible values and their respective meanings."
msgstr ""
"為新 socket 物件設定預設超時（以秒為單位）。首次導入 socket 模組時，預設為 "
"``None`` 。請參閱 :meth:`~socket.settimeout` 了解可能的值及其各自的含義。"

#: ../../library/socket.rst:1153
#, fuzzy
msgid ""
"Set the machine's hostname to *name*.  This will raise an :exc:`OSError` if "
"you don't have enough rights."
msgstr ""
"將機器的主機名設定為 *name*。如果您沒有足夠的權限，這將引發 :exc:`OSError`。"

#: ../../library/socket.rst:1167
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sethostname`` with "
"argument ``name``."
msgstr ""
"引發一個附帶引數 ``name`` 的\\ :ref:`稽核事件 <auditing>` ``socket."
"sethostname``。"

#: ../../library/socket.rst:1158 ../../library/socket.rst:1596
#: ../../library/socket.rst:1640
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`適用 <availability>`：Unix。"

#: ../../library/socket.rst:1165
#, fuzzy
msgid ""
"Return a list of network interface information (index int, name string) "
"tuples. :exc:`OSError` if the system call fails."
msgstr ""
"回傳網絡介面資訊（索引 int，名稱字串）元組列表。 :exc:`OSError` 如果系統呼叫"
"失敗。"

#: ../../library/socket.rst:1169 ../../library/socket.rst:1196
#: ../../library/socket.rst:1213 ../../library/socket.rst:1230
#: ../../library/socket.rst:1244
msgid ""
":ref:`Availability <availability>`: Unix, Windows, not Emscripten, not WASI."
msgstr ":ref:`適用 <availability>`：Unix、Windows、非 Emscripten、非 WASI。"

#: ../../library/socket.rst:1173 ../../library/socket.rst:1200
#: ../../library/socket.rst:1217
msgid "Windows support was added."
msgstr "增加對 Windows 的支援。"

#: ../../library/socket.rst:1178
#, fuzzy
msgid ""
"On Windows network interfaces have different names in different contexts "
"(all names are examples):"
msgstr ""
"在 Windows 上，網絡介面在不同的上下文中有不同的名稱（所有名稱都是示例）："

#: ../../library/socket.rst:1181
msgid "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"
msgstr "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"

#: ../../library/socket.rst:1182
#, fuzzy
msgid "name: ``ethernet_32770``"
msgstr "名稱：``ethernet_32770``"

#: ../../library/socket.rst:1183
#, fuzzy
msgid "friendly name: ``vEthernet (nat)``"
msgstr "友好名稱：``vEthernet（nat）``"

#: ../../library/socket.rst:1184
#, fuzzy
msgid "description: ``Hyper-V Virtual Ethernet Adapter``"
msgstr "描述：``Hyper-V 虛擬以太網適配器``"

#: ../../library/socket.rst:1186
#, fuzzy
msgid ""
"This function returns names of the second form from the list, "
"``ethernet_32770`` in this example case."
msgstr "此函式回傳列表中第二種形式的名稱，在本示例中為“ethernet_32770”。"

#: ../../library/socket.rst:1192
#, fuzzy
msgid ""
"Return a network interface index number corresponding to an interface name. :"
"exc:`OSError` if no interface with the given name exists."
msgstr ""
"回傳與介面名稱對應的網絡介面索引號。 :exc:`OSError` 如果不存在具有給定名稱的"
"介面。"

#: ../../library/socket.rst:1204 ../../library/socket.rst:1221
#, fuzzy
msgid "\"Interface name\" is a name as documented in :func:`if_nameindex`."
msgstr "“介面名稱”是 :func:`if_nameindex` 中記錄的名稱。"

#: ../../library/socket.rst:1209
#, fuzzy
msgid ""
"Return a network interface name corresponding to an interface index number. :"
"exc:`OSError` if no interface with the given index exists."
msgstr ""
"回傳與介面索引號對應的網絡介面名稱。 :exc:`OSError` 如果不存在具有給定索引的"
"介面。"

#: ../../library/socket.rst:1226
#, fuzzy
msgid ""
"Send the list of file descriptors *fds* over an :const:`AF_UNIX` socket "
"*sock*. The *fds* parameter is a sequence of file descriptors. Consult :meth:"
"`sendmsg` for the documentation of these parameters."
msgstr ""
"通過 :const:`AF_UNIX`  socket  *sock* 發送文件描述器列表 *fds*。 *fds* 參數是"
"一系列文件描述器。有關這些參數的文檔，請參閱 :meth:`sendmsg`。"

#: ../../library/socket.rst:1232 ../../library/socket.rst:1246
#, fuzzy
msgid ""
"Unix platforms supporting :meth:`~socket.sendmsg` and :const:`SCM_RIGHTS` "
"mechanism."
msgstr "支援 :meth:`~socket.sendmsg` 和 :const:`SCM_RIGHTS` 機制的 Unix 平台。"

#: ../../library/socket.rst:1240
#, fuzzy
msgid ""
"Receive up to *maxfds* file descriptors from an :const:`AF_UNIX` socket "
"*sock*. Return ``(msg, list(fds), flags, addr)``. Consult :meth:`recvmsg` "
"for the documentation of these parameters."
msgstr ""
"從 :const:`AF_UNIX`  socket  *sock* 接收最多 *maxfds* 文件描述器。回傳"
"``(msg, list(fds), flags, addr)``。有關這些參數的文檔，請參閱 :meth:"
"`recvmsg`。"

#: ../../library/socket.rst:1253
#, fuzzy
msgid "Any truncated integers at the end of the list of file descriptors."
msgstr "文件描述器列表末尾的任何截斷整數。"

#: ../../library/socket.rst:1259
msgid "Socket Objects"
msgstr "Socket 物件"

#: ../../library/socket.rst:1261
#, fuzzy
msgid ""
"Socket objects have the following methods.  Except for :meth:`~socket."
"makefile`, these correspond to Unix system calls applicable to sockets."
msgstr ""
" socket 物件具有以下方法。除了 :meth:`~socket.makefile`，這些對應於適用於 "
"socket 的 Unix 系統呼叫。"

#: ../../library/socket.rst:1265
#, fuzzy
msgid ""
"Support for the :term:`context manager` protocol was added.  Exiting the "
"context manager is equivalent to calling :meth:`~socket.close`."
msgstr ""
"新增了對 :term:`context manager` 協定的支援。退出上下文管理器相當於呼叫 :"
"meth:`~socket.close`。"

#: ../../library/socket.rst:1272
#, fuzzy
msgid ""
"Accept a connection. The socket must be bound to an address and listening "
"for connections. The return value is a pair ``(conn, address)`` where *conn* "
"is a *new* socket object usable to send and receive data on the connection, "
"and *address* is the address bound to the socket on the other end of the "
"connection."
msgstr ""
"接受連接。 socket 必須綁定到一個地址並偵聽連接。回傳值是一對“(conn, "
"address)”，其中 *conn* 是一個 *new*  socket 物件，可用於在連接上發送和接收資"
"料，而 *address* 是綁定到另一個 socket 的地址連接結束。"

#: ../../library/socket.rst:1279 ../../library/socket.rst:1373
#, fuzzy
msgid "The socket is now non-inheritable."
msgstr " socket 現在不可繼承。"

#: ../../library/socket.rst:1282 ../../library/socket.rst:1511
#: ../../library/socket.rst:1525 ../../library/socket.rst:1602
#: ../../library/socket.rst:1675 ../../library/socket.rst:1694
#: ../../library/socket.rst:1711 ../../library/socket.rst:1756
#, fuzzy
msgid ""
"If the system call is interrupted and the signal handler does not raise an "
"exception, the method now retries the system call instead of raising an :exc:"
"`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"如果系統呼叫被中斷並且信號處理程式沒有引發例外，該方法現在會重試系統呼叫，而"
"不是引發 :exc:`InterruptedError` 例外（請參閱 :pep:`475` 了解基本原理）。"

#: ../../library/socket.rst:1290
#, fuzzy
msgid ""
"Bind the socket to *address*.  The socket must not already be bound. (The "
"format of *address* depends on the address family --- see above.)"
msgstr ""
"將 socket 綁定到 *address*。 socket 必須尚未綁定。 （*address* 的格式取決於地"
"址系列---見上文。）"

#: ../../library/socket.rst:1304
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.bind`` with arguments "
"``self``, ``address``."
msgstr ""
"引發一個附帶引數 ``self``、``address`` 的\\ :ref:`稽核事件 <auditing>` "
"``socket.bind``。"

#: ../../library/socket.rst:1300
#, fuzzy
msgid ""
"Mark the socket closed.  The underlying system resource (e.g. a file "
"descriptor) is also closed when all file objects from :meth:`makefile()` are "
"closed.  Once that happens, all future operations on the socket object will "
"fail. The remote end will receive no more data (after queued data is "
"flushed)."
msgstr ""
"將 socket 標記為關閉。當 makefile() 中的所有文件物件關閉時，底層系統資源（例"
"如文件描述器）也將關閉。一旦發生這種情況，以後對 socket 物件的所有操作都將失"
"敗。遠程端將不再接收資料（刷新排隊的資料後）。"

#: ../../library/socket.rst:1306
#, fuzzy
msgid ""
"Sockets are automatically closed when they are garbage-collected, but it is "
"recommended to :meth:`close` them explicitly, or to use a :keyword:`with` "
"statement around them."
msgstr ""
" socket 在垃圾回收時會自動關閉，但建議顯式關閉它們，或在它們周圍使用 :"
"keyword:`with` 語句。"

#: ../../library/socket.rst:1310
#, fuzzy
msgid ""
":exc:`OSError` is now raised if an error occurs when the underlying :c:func:"
"`close` call is made."
msgstr ""
":exc:`OSError` 如果在進行底層 :c:func:`close` 呼叫時發生錯誤，現在會引發。"

#: ../../library/socket.rst:1316
#, fuzzy
msgid ""
":meth:`close()` releases the resource associated with a connection but does "
"not necessarily close the connection immediately.  If you want to close the "
"connection in a timely fashion, call :meth:`shutdown()` before :meth:"
"`close()`."
msgstr ""
":meth:`close()` 釋放與連接關聯的資源，但不一定立即關閉連接。如果您想及時關閉"
"連接，請在 :meth:`close()` 之前呼叫 :meth:`shutdown()`。"

#: ../../library/socket.rst:1324
#, fuzzy
msgid ""
"Connect to a remote socket at *address*. (The format of *address* depends on "
"the address family --- see above.)"
msgstr ""
"連接到位於 *address* 的遠程 socket 。 （*address* 的格式取決於地址系列---見上"
"文。）"

#: ../../library/socket.rst:1327
#, fuzzy
msgid ""
"If the connection is interrupted by a signal, the method waits until the "
"connection completes, or raise a :exc:`TimeoutError` on timeout, if the "
"signal handler doesn't raise an exception and the socket is blocking or has "
"a timeout. For non-blocking sockets, the method raises an :exc:"
"`InterruptedError` exception if the connection is interrupted by a signal "
"(or the exception raised by the signal handler)."
msgstr ""
"如果連接被信號中斷，該方法會等待連接完成，或者在超時時引發 :exc:"
"`TimeoutError`，如果信號處理程式沒有引發例外並且 socket 正在阻塞或超時。對於"
"非阻塞 socket ，如果連接被信號中斷（或信號處理程式引發的例外），該方法會引"
"發 :exc:`InterruptedError` 例外。"

#: ../../library/socket.rst:1345 ../../library/socket.rst:1365
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.connect`` with arguments "
"``self``, ``address``."
msgstr ""
"引發一個附帶引數 ``self``、``address`` 的\\ :ref:`稽核事件 <auditing>` "
"``socket.connect``。"

#: ../../library/socket.rst:1336
#, fuzzy
msgid ""
"The method now waits until the connection completes instead of raising an :"
"exc:`InterruptedError` exception if the connection is interrupted by a "
"signal, the signal handler doesn't raise an exception and the socket is "
"blocking or has a timeout (see the :pep:`475` for the rationale)."
msgstr ""
"如果連接被信號中斷，該方法現在會等待連接完成而不是引發 :exc:"
"`InterruptedError` 例外，信號處理程式不會引發例外並且 socket 正在阻塞或超時"
"（請參閱： pep:`475` 的基本原理）。"

#: ../../library/socket.rst:1347
#, fuzzy
msgid ""
"Like ``connect(address)``, but return an error indicator instead of raising "
"an exception for errors returned by the C-level :c:func:`connect` call "
"(other problems, such as \"host not found,\" can still raise exceptions).  "
"The error indicator is ``0`` if the operation succeeded, otherwise the value "
"of the :c:data:`errno` variable.  This is useful to support, for example, "
"asynchronous connects."
msgstr ""
"類似於 ``connect(address)``，但回傳一個錯誤指示器而不是為 C 級 :c:func:"
"`connect` 呼叫回傳的錯誤引發例外（其他問題，例如“找不到主機”，可以仍然引發例"
"外）。如果操作成功，錯誤指示符為 ``0``，否則為 :c:data:`errno` 變數的值。這對"
"於支援例如非同步連接很有用。"

#: ../../library/socket.rst:1360
#, fuzzy
msgid ""
"Put the socket object into closed state without actually closing the "
"underlying file descriptor.  The file descriptor is returned, and can be "
"reused for other purposes."
msgstr ""
"將 socket 物件置於關閉狀態，而不實際關閉底層文件描述器。文件描述器被回傳，並"
"且可以重新用於其他目的。"

#: ../../library/socket.rst:1369
#, fuzzy
msgid "Duplicate the socket."
msgstr "複製 socket 。"

#: ../../library/socket.rst:1381
#, fuzzy
msgid ""
"Return the socket's file descriptor (a small integer), or -1 on failure. "
"This is useful with :func:`select.select`."
msgstr ""
"回傳 socket 的文件描述器（一個小整數），如果失敗則回傳 -1。這對於 :func:"
"`select.select` 很有用。"

#: ../../library/socket.rst:1384
#, fuzzy
msgid ""
"Under Windows the small integer returned by this method cannot be used where "
"a file descriptor can be used (such as :func:`os.fdopen`).  Unix does not "
"have this limitation."
msgstr ""
"在 Windows 下，此方法回傳的小整數不能用於可以使用文件描述器的地方（例如 :"
"func:`os.fdopen`）。 Unix 沒有這個限制。"

#: ../../library/socket.rst:1390
#, fuzzy
msgid ""
"Get the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle: ``True`` if the socket can be inherited in "
"child processes, ``False`` if it cannot."
msgstr ""
"獲取 socket 文件描述器或 socket 句柄的可繼承旗標 <fd inheritance>：如果 "
"socket 可以在子行程中繼承，則為 True，否則為 False。"

#: ../../library/socket.rst:1399
#, fuzzy
msgid ""
"Return the remote address to which the socket is connected.  This is useful "
"to find out the port number of a remote IPv4/v6 socket, for instance. (The "
"format of the address returned depends on the address family --- see "
"above.)  On some systems this function is not supported."
msgstr ""
"回傳 socket 連接到的遠程地址。例如，這對於找出遠程 IPv4/v6  socket 的端口號很"
"有用。 （回傳的地址格式取決於地址系列---見上文。）在某些系統上不支援此功能。"

#: ../../library/socket.rst:1407
#, fuzzy
msgid ""
"Return the socket's own address.  This is useful to find out the port number "
"of an IPv4/v6 socket, for instance. (The format of the address returned "
"depends on the address family --- see above.)"
msgstr ""
"回傳 socket 自己的地址。例如，這對於找出 IPv4/v6  socket 的端口號很有用。 "
"（回傳的地址格式取決於地址系列---見上文。）"

#: ../../library/socket.rst:1414
#, fuzzy
msgid ""
"Return the value of the given socket option (see the Unix man page :manpage:"
"`getsockopt(2)`).  The needed symbolic constants (:const:`SO_\\*` etc.) are "
"defined in this module.  If *buflen* is absent, an integer option is assumed "
"and its integer value is returned by the function.  If *buflen* is present, "
"it specifies the maximum length of the buffer used to receive the option in, "
"and this buffer is returned as a bytes object.  It is up to the caller to "
"decode the contents of the buffer (see the optional built-in module :mod:"
"`struct` for a way to decode C structures encoded as byte strings)."
msgstr ""
"回傳給定 socket 選項的值（參見 Unix 手冊頁 :manpage:`getsockopt(2)`）。所需的"
"符號常數（:const:`SO_\\*` 等）在此模組中定義。如果 *buflen* 不存在，則假定一"
"個整數選項，並且函式回傳其整數值。如果存在 *buflen*，它指定用於接收選項的緩衝"
"區的最大長度，並且此緩衝區作為位元組物件回傳。由呼叫者解碼緩衝區的內容（請參"
"閱可選的內建模組 :mod:`struct` 以了解解碼編碼為位元組字串的 C 結構的方法）。"

#: ../../library/socket.rst:1428
#, fuzzy
msgid ""
"Return ``True`` if socket is in blocking mode, ``False`` if in non-blocking."
msgstr ""
"如果 socket 處於阻塞模式，則回傳 ``True``，如果處於非阻塞模式，則回傳 "
"``False``。"

#: ../../library/socket.rst:1431
#, fuzzy
msgid "This is equivalent to checking ``socket.gettimeout() == 0``."
msgstr "這相當於檢查 ``socket.gettimeout() == 0``。"

#: ../../library/socket.rst:1438
#, fuzzy
msgid ""
"Return the timeout in seconds (float) associated with socket operations, or "
"``None`` if no timeout is set.  This reflects the last call to :meth:"
"`setblocking` or :meth:`settimeout`."
msgstr ""
"回傳與 socket 操作關聯的超時秒數（浮點數），如果未設定超時則回傳 ``None``。這"
"反映了對 :meth:`setblocking` 或 :meth:`settimeout` 的最後一次呼叫。"

#: ../../library/socket.rst:0
msgid "platform"
msgstr "平台"

#: ../../library/socket.rst:1445
msgid "Windows"
msgstr "Windows"

#: ../../library/socket.rst:1447
#, fuzzy
msgid ""
"The :meth:`ioctl` method is a limited interface to the WSAIoctl system "
"interface.  Please refer to the `Win32 documentation <https://msdn.microsoft."
"com/en-us/library/ms741621%28VS.85%29.aspx>`_ for more information."
msgstr ""
":meth:`ioctl` 方法是 WSAIoctl 系統介面的有限介面。請參閱 `Win32 文檔 "
"<https://msdn.microsoft.com/en-us/library/ms741621%28VS.85%29.aspx>`_ 了解更"
"多資訊。"

#: ../../library/socket.rst:1452
#, fuzzy
msgid ""
"On other platforms, the generic :func:`fcntl.fcntl` and :func:`fcntl.ioctl` "
"functions may be used; they accept a socket object as their first argument."
msgstr ""
"在其他平台上，可以使用通用的 fcntl.fcntl 和 fcntl.ioctl 函式；他們接受一個 "
"socket 對像作為他們的第一個參數。"

#: ../../library/socket.rst:1455
#, fuzzy
msgid ""
"Currently only the following control codes are supported: ``SIO_RCVALL``, "
"``SIO_KEEPALIVE_VALS``, and ``SIO_LOOPBACK_FAST_PATH``."
msgstr ""
"目前僅支援以下控制程式碼：``SIO_RCVALL``、``SIO_KEEPALIVE_VALS`` 和 "
"``SIO_LOOPBACK_FAST_PATH``。"

#: ../../library/socket.rst:1463
#, fuzzy
msgid ""
"Enable a server to accept connections.  If *backlog* is specified, it must "
"be at least 0 (if it is lower, it is set to 0); it specifies the number of "
"unaccepted connections that the system will allow before refusing new "
"connections. If not specified, a default reasonable value is chosen."
msgstr ""
"啟用伺服器以接受連接。如果指定了*backlog*，則它必須至少為 0（如果較低，則設定"
"為 0）；它指定係統在拒絕新連接之前允許的未接受連接數。如果未指定，則選擇預設"
"的合理值。"

#: ../../library/socket.rst:1470
#, fuzzy
msgid "The *backlog* parameter is now optional."
msgstr "*backlog* 參數現在是可選的。"

#: ../../library/socket.rst:1479
#, fuzzy
msgid ""
"Return a :term:`file object` associated with the socket.  The exact returned "
"type depends on the arguments given to :meth:`makefile`.  These arguments "
"are interpreted the same way as by the built-in :func:`open` function, "
"except the only supported *mode* values are ``'r'`` (default), ``'w'`` and "
"``'b'``."
msgstr ""
"回傳一個與 socket 關聯的文件物件。確切的回傳型別取決於給 makefile 的參數。這"
"些參數的解釋方式與內建 :func:`open` 函式的解釋方式相同，除了唯一支援的 "
"*mode* 值是 ``'r'``（預設值）、``'w'`` 和 ` `'b'``。"

#: ../../library/socket.rst:1484
#, fuzzy
msgid ""
"The socket must be in blocking mode; it can have a timeout, but the file "
"object's internal buffer may end up in an inconsistent state if a timeout "
"occurs."
msgstr ""
" socket 必須處於阻塞模式；它可以有超時，但如果發生超時，文件物件的內部緩衝區"
"可能會以不一致的狀態結束。"

#: ../../library/socket.rst:1488
#, fuzzy
msgid ""
"Closing the file object returned by :meth:`makefile` won't close the "
"original socket unless all other file objects have been closed and :meth:"
"`socket.close` has been called on the socket object."
msgstr ""
"關閉 :meth:`makefile` 回傳的文件對像不會關閉原始 socket ，除非所有其他文件對"
"像都已關閉並且 :meth:`socket.close` 已在 socket 對像上呼叫。"

#: ../../library/socket.rst:1494
#, fuzzy
msgid ""
"On Windows, the file-like object created by :meth:`makefile` cannot be used "
"where a file object with a file descriptor is expected, such as the stream "
"arguments of :meth:`subprocess.Popen`."
msgstr ""
"在 Windows 上，由 :meth:`makefile` 建立的類文件對像不能用於需要具有文件描述器"
"的文件物件的地方，例如 :meth:`subprocess.Popen` 的流參數。"

#: ../../library/socket.rst:1501
#, fuzzy
msgid ""
"Receive data from the socket.  The return value is a bytes object "
"representing the data received.  The maximum amount of data to be received "
"at once is specified by *bufsize*.  See the Unix manual page :manpage:"
"`recv(2)` for the meaning of the optional argument *flags*; it defaults to "
"zero."
msgstr ""
"從 socket 接收資料。回傳值是一個位元組物件，表示接收到的資料。一次接收的最大"
"資料量由 *bufsize* 指定。請參閱 Unix 手冊頁 :manpage:`recv(2)` 了解可選參數 "
"*flags* 的含義；它預設為零。"

#: ../../library/socket.rst:1508
#, fuzzy
msgid ""
"For best match with hardware and network realities, the value of  *bufsize* "
"should be a relatively small power of 2, for example, 4096."
msgstr ""
"為了最好地匹配硬件和網絡實際情況，*bufsize* 的值應該是 2 的一個相對較小的冪，"
"例如 4096。"

#: ../../library/socket.rst:1519
#, fuzzy
msgid ""
"Receive data from the socket.  The return value is a pair ``(bytes, "
"address)`` where *bytes* is a bytes object representing the data received "
"and *address* is the address of the socket sending the data.  See the Unix "
"manual page :manpage:`recv(2)` for the meaning of the optional argument "
"*flags*; it defaults to zero. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"從 socket 接收資料。回傳值是一對 ``(bytes, address)`` 其中 *bytes* 是表示接收"
"到的資料的位元組物件，*address* 是發送資料的 socket 地址。請參閱 Unix 手冊"
"頁 :manpage:`recv(2)` 了解可選參數 *flags* 的含義；它預設為零。 （*address* "
"的格式取決於地址系列---見上文。）"

#: ../../library/socket.rst:1530
#, fuzzy
msgid ""
"For multicast IPv6 address, first item of *address* does not contain "
"``%scope_id`` part anymore. In order to get full IPv6 address use :func:"
"`getnameinfo`."
msgstr ""
"對於多播 IPv6 地址，*address* 的第一項不再包含“%scope_id”部分。為了獲得完整"
"的 IPv6 地址，請使用 :func:`getnameinfo`。"

#: ../../library/socket.rst:1537
#, fuzzy
msgid ""
"Receive normal data (up to *bufsize* bytes) and ancillary data from the "
"socket.  The *ancbufsize* argument sets the size in bytes of the internal "
"buffer used to receive the ancillary data; it defaults to 0, meaning that no "
"ancillary data will be received.  Appropriate buffer sizes for ancillary "
"data can be calculated using :func:`CMSG_SPACE` or :func:`CMSG_LEN`, and "
"items which do not fit into the buffer might be truncated or discarded.  The "
"*flags* argument defaults to 0 and has the same meaning as for :meth:`recv`."
msgstr ""
"從 socket 接收正常資料（最多 *bufsize* 位元組）和輔助資料。 *ancbufsize* 參數"
"設定用於接收輔助資料的內部緩衝區的大小（以位元組為單位）；它預設為 0，表示不"
"會接收任何輔助資料。可以使用 CMSG_SPACE 或 CMSG_LEN 計算輔助資料的適當緩衝區"
"大小，不適合緩衝區的項目可能會被截斷或丟棄。 *flags* 參數預設為 0，與 :meth:"
"`recv` 具有相同的含義。"

#: ../../library/socket.rst:1547
#, fuzzy
msgid ""
"The return value is a 4-tuple: ``(data, ancdata, msg_flags, address)``.  The "
"*data* item is a :class:`bytes` object holding the non-ancillary data "
"received.  The *ancdata* item is a list of zero or more tuples "
"``(cmsg_level, cmsg_type, cmsg_data)`` representing the ancillary data "
"(control messages) received: *cmsg_level* and *cmsg_type* are integers "
"specifying the protocol level and protocol-specific type respectively, and "
"*cmsg_data* is a :class:`bytes` object holding the associated data.  The "
"*msg_flags* item is the bitwise OR of various flags indicating conditions on "
"the received message; see your system documentation for details. If the "
"receiving socket is unconnected, *address* is the address of the sending "
"socket, if available; otherwise, its value is unspecified."
msgstr ""
"回傳值是一個 4 元組：``(data, ancdata, msg_flags, address)``。 *data* 項是一"
"個 :class:`bytes` 物件，保存接收到的非輔助資料。 *ancdata* 項是零個或多個元組"
"的列表 ``(cmsg_level, cmsg_type, cmsg_data)`` 表示接收到的輔助資料（控制消"
"息）：*cmsg_level* 和 *cmsg_type* 是指定協定級別和協定級別的整數特定型別，"
"*cmsg_data* 是一個保存關聯資料的 :class:`bytes` 物件。 *msg_flags* 項目是各種"
"旗標的按位或，指示接收消息的條件；有關詳細資訊，請參閱您的系統文檔。如果接收 "
"socket 未連接，*address* 是發送 socket 的地址（如果可用）；否則，其值未指定。"

#: ../../library/socket.rst:1561
#, fuzzy
msgid ""
"On some systems, :meth:`sendmsg` and :meth:`recvmsg` can be used to pass "
"file descriptors between processes over an :const:`AF_UNIX` socket.  When "
"this facility is used (it is often restricted to :const:`SOCK_STREAM` "
"sockets), :meth:`recvmsg` will return, in its ancillary data, items of the "
"form ``(socket.SOL_SOCKET, socket.SCM_RIGHTS, fds)``, where *fds* is a :"
"class:`bytes` object representing the new file descriptors as a binary array "
"of the native C :c:expr:`int` type.  If :meth:`recvmsg` raises an exception "
"after the system call returns, it will first attempt to close any file "
"descriptors received via this mechanism."
msgstr ""
"在某些系統上，:meth:`sendmsg` 和 :meth:`recvmsg` 可用於通過 :const:"
"`AF_UNIX`  socket 在行程之間傳遞文件描述器。當使用此工具時（通常僅限於 "
"SOCK_STREAM  socket ），recvmsg 將在其輔助資料中回傳形式為（socket."
"SOL_SOCKET，socket.SCM_RIGHTS，fds）的項目)``，其中 *fds* 是一個 :class:"
"`bytes` 物件，將新文件描述器表示為原生 C :c:expr:`int` 型別的二進位數組。如"
"果 :meth:`recvmsg` 在系統呼叫回傳後引發例外，它將首先嘗試關閉通過此機制接收到"
"的任何文件描述器。"

#: ../../library/socket.rst:1572
#, fuzzy
msgid ""
"Some systems do not indicate the truncated length of ancillary data items "
"which have been only partially received.  If an item appears to extend "
"beyond the end of the buffer, :meth:`recvmsg` will issue a :exc:"
"`RuntimeWarning`, and will return the part of it which is inside the buffer "
"provided it has not been truncated before the start of its associated data."
msgstr ""
"一些系統不指示僅部分接收的輔助資料項的截斷長度。如果一個項目似乎超出了緩衝區"
"的末尾，recvmsg 將發出一個 RuntimeWarning 並回傳它在緩衝區內的部分，前提是它"
"在開始之前沒有被截斷其相關資料。"

#: ../../library/socket.rst:1579
#, fuzzy
msgid ""
"On systems which support the :const:`SCM_RIGHTS` mechanism, the following "
"function will receive up to *maxfds* file descriptors, returning the message "
"data and a list containing the descriptors (while ignoring unexpected "
"conditions such as unrelated control messages being received).  See also :"
"meth:`sendmsg`. ::"
msgstr ""
"在支援 SCM_RIGHTS 機制的系統上，以下函式將接收最多 *maxfds* 個文件描述器，回"
"傳消息資料和包含描述器的列表（同時忽略意外情況，例如接收到不相關的控制消"
"息）。另見 :meth:`sendmsg`。 ::"

#: ../../library/socket.rst:1610
#, fuzzy
msgid ""
"Receive normal data and ancillary data from the socket, behaving as :meth:"
"`recvmsg` would, but scatter the non-ancillary data into a series of buffers "
"instead of returning a new bytes object.  The *buffers* argument must be an "
"iterable of objects that export writable buffers (e.g. :class:`bytearray` "
"objects); these will be filled with successive chunks of the non-ancillary "
"data until it has all been written or there are no more buffers.  The "
"operating system may set a limit (:func:`~os.sysconf` value ``SC_IOV_MAX``) "
"on the number of buffers that can be used.  The *ancbufsize* and *flags* "
"arguments have the same meaning as for :meth:`recvmsg`."
msgstr ""
"從 socket 接收普通資料和輔助資料，行為與 recvmsg 一樣，但將非輔助資料分散到一"
"系列緩衝區中，而不是回傳新的位元組物件。 *buffers* 參數必須是導出可寫緩衝區的"
"物件的可疊代物件（例如 :class:`bytearray` 物件）；這些將被連續的非輔助資料塊"
"填充，直到它全部被寫入或沒有更多的緩衝區。操作系統可以對可以使用的緩衝區數量"
"設定限制（:func:`~os.sysconf` 值``SC_IOV_MAX``）。 *ancbufsize* 和 *flags* 參"
"數與 recvmsg 的含義相同。"

#: ../../library/socket.rst:1621
#, fuzzy
msgid ""
"The return value is a 4-tuple: ``(nbytes, ancdata, msg_flags, address)``, "
"where *nbytes* is the total number of bytes of non-ancillary data written "
"into the buffers, and *ancdata*, *msg_flags* and *address* are the same as "
"for :meth:`recvmsg`."
msgstr ""
"回傳值是一個 4 元組：``(nbytes, ancdata, msg_flags, address)``，其中 "
"*nbytes* 是寫入緩衝區的非輔助資料的總位元組數，*ancdata*, *msg_flags * 和 "
"*address* 與 :meth:`recvmsg` 相同。"

#: ../../library/socket.rst:1626
msgid "Example::"
msgstr ""
"範例：\n"
"\n"
"::"

#: ../../library/socket.rst:1649
#, fuzzy
msgid ""
"Receive data from the socket, writing it into *buffer* instead of creating a "
"new bytestring.  The return value is a pair ``(nbytes, address)`` where "
"*nbytes* is the number of bytes received and *address* is the address of the "
"socket sending the data.  See the Unix manual page :manpage:`recv(2)` for "
"the meaning of the optional argument *flags*; it defaults to zero.  (The "
"format of *address* depends on the address family --- see above.)"
msgstr ""
"從 socket 接收資料，將其寫入 *buffer* 而不是建立新的位元組串。回傳值是一"
"對“(nbytes, address)”，其中 *nbytes* 是接收到的位元組數，*address* 是發送資料"
"的 socket 地址。請參閱 Unix 手冊頁 :manpage:`recv(2)` 了解可選參數 *flags* 的"
"含義；它預設為零。 （*address* 的格式取決於地址系列---見上文。）"

#: ../../library/socket.rst:1659
#, fuzzy
msgid ""
"Receive up to *nbytes* bytes from the socket, storing the data into a buffer "
"rather than creating a new bytestring.  If *nbytes* is not specified (or 0), "
"receive up to the size available in the given buffer.  Returns the number of "
"bytes received.  See the Unix manual page :manpage:`recv(2)` for the meaning "
"of the optional argument *flags*; it defaults to zero."
msgstr ""
"從 socket 接收最多 *nbytes* 位元組，將資料儲存到緩衝區而不是建立新的位元組"
"串。如果未指定 *nbytes*（或 0），則接收最大為給定緩衝區中可用的大小。回傳接收"
"到的位元組數。請參閱 Unix 手冊頁 :manpage:`recv(2)` 了解可選參數 *flags* 的含"
"義；它預設為零。"

#: ../../library/socket.rst:1668
#, fuzzy
msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Returns the number of bytes sent. Applications are responsible for "
"checking that all data has been sent; if only some of the data was "
"transmitted, the application needs to attempt delivery of the remaining "
"data. For further information on this topic, consult the :ref:`socket-howto`."
msgstr ""
"向 socket 發送資料。 socket 必須連接到遠程 socket 。可選的 *flags* 參數與上面"
"的 recv 具有相同的含義。回傳發送的位元組數。應用程式負責檢查所有資料是否已發"
"送；如果只傳輸了部分資料，則應用程式需要嘗試傳輸其餘資料。有關此主題的更多資"
"訊，請參閱 :ref:`socket-howto`。"

#: ../../library/socket.rst:1683
#, fuzzy
msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Unlike :meth:`send`, this method continues to send data from *bytes* "
"until either all data has been sent or an error occurs.  ``None`` is "
"returned on success.  On error, an exception is raised, and there is no way "
"to determine how much data, if any, was successfully sent."
msgstr ""
"向 socket 發送資料。 socket 必須連接到遠程 socket 。可選的 *flags* 參數與上面"
"的 recv 具有相同的含義。與 :meth:`send` 不同，此方法繼續從 *bytes* 發送資料，"
"直到發送完所有資料或發生錯誤。成功時回傳 ``None`` 。出錯時會引發例外，並且無"
"法確定成功發送了多少資料（如果有的話）。"

#: ../../library/socket.rst:1690
#, fuzzy
msgid ""
"The socket timeout is no longer reset each time data is sent successfully. "
"The socket timeout is now the maximum total duration to send all data."
msgstr ""
"每次成功發送資料時， socket 超時不再重置。 socket 超時現在是發送所有資料的最"
"大總持續時間。"

#: ../../library/socket.rst:1703
#, fuzzy
msgid ""
"Send data to the socket.  The socket should not be connected to a remote "
"socket, since the destination socket is specified by *address*.  The "
"optional *flags* argument has the same meaning as for :meth:`recv` above.  "
"Return the number of bytes sent. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"向 socket 發送資料。 socket 不應連接到遠程 socket ，因為目標 socket 由 "
"*address* 指定。可選的 *flags* 參數與上面的 recv 具有相同的含義。回傳發送的位"
"元組數。 （*address* 的格式取決於地址系列---見上文。）"

#: ../../library/socket.rst:1720
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendto`` with arguments "
"``self``, ``address``."
msgstr ""
"引發一個附帶引數 ``self``、``address`` 的\\ :ref:`稽核事件 <auditing>` "
"``socket.sendto``。"

#: ../../library/socket.rst:1719
#, fuzzy
msgid ""
"Send normal and ancillary data to the socket, gathering the non-ancillary "
"data from a series of buffers and concatenating it into a single message.  "
"The *buffers* argument specifies the non-ancillary data as an iterable of :"
"term:`bytes-like objects <bytes-like object>` (e.g. :class:`bytes` objects); "
"the operating system may set a limit (:func:`~os.sysconf` value "
"``SC_IOV_MAX``) on the number of buffers that can be used.  The *ancdata* "
"argument specifies the ancillary data (control messages) as an iterable of "
"zero or more tuples ``(cmsg_level, cmsg_type, cmsg_data)``, where "
"*cmsg_level* and *cmsg_type* are integers specifying the protocol level and "
"protocol-specific type respectively, and *cmsg_data* is a bytes-like object "
"holding the associated data.  Note that some systems (in particular, systems "
"without :func:`CMSG_SPACE`) might support sending only one control message "
"per call.  The *flags* argument defaults to 0 and has the same meaning as "
"for :meth:`send`.  If *address* is supplied and not ``None``, it sets a "
"destination address for the message.  The return value is the number of "
"bytes of non-ancillary data sent."
msgstr ""
"將正常資料和輔助資料發送到 socket ，從一系列緩衝區收集非輔助資料並將其連接成"
"一條消息。 *buffers* 參數將非輔助資料指定為 :term:`bytes-like objects <bytes-"
"like object>` 的可疊代物件（例如 :class:`bytes` objects）；操作系統可以對可以"
"使用的緩衝區數量設定限制（:func:`~os.sysconf` 值``SC_IOV_MAX``）。 *ancdata* "
"參數將輔助資料（控制消息）指定為零個或多個元組的可疊代``(cmsg_level, "
"cmsg_type, cmsg_data)``，其中 *cmsg_level* 和 *cmsg_type* 是指定協定級別和協"
"定級別的整數分別指定特定型別，*cmsg_data* 是一個保存相關資料的類位元組物件。"
"請注意，某些系統（特別是沒有 CMSG_SPACE 的系統）可能支援每次呼叫僅發送一條控"
"制消息。 *flags* 參數預設為 0，與 :meth:`send` 具有相同的含義。如果提供了 "
"*address* 而不是 ``None``，它會為消息設定一個目標地址。回傳值是發送的非輔助資"
"料的位元組數。"

#: ../../library/socket.rst:1739
#, fuzzy
msgid ""
"The following function sends the list of file descriptors *fds* over an :"
"const:`AF_UNIX` socket, on systems which support the :const:`SCM_RIGHTS` "
"mechanism.  See also :meth:`recvmsg`. ::"
msgstr ""
"在支援 SCM_RIGHTS 機制的系統上，以下函式通過 AF_UNIX  socket 發送文件描述器 "
"*fds* 列表。另見 :meth:`recvmsg`。 ::"

#: ../../library/socket.rst:1748
msgid ":ref:`Availability <availability>`: Unix, not WASI."
msgstr ":ref:`適用 <availability>`：Unix、非 WASI。"

#: ../../library/socket.rst:1763
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendmsg`` with arguments "
"``self``, ``address``."
msgstr ""
"引發一個附帶引數 ``self``、``address`` 的\\ :ref:`稽核事件 <auditing>` "
"``socket.sendmsg``。"

#: ../../library/socket.rst:1763
#, fuzzy
msgid ""
"Specialized version of :meth:`~socket.sendmsg` for :const:`AF_ALG` socket. "
"Set mode, IV, AEAD associated data length and flags for :const:`AF_ALG` "
"socket."
msgstr ""
":const:`AF_ALG`  socket 的 :meth:`~socket.sendmsg` 專用版本。為 AF_ALG  "
"socket 設定模式、IV、AEAD 相關資料長度和旗標。"

#: ../../library/socket.rst:1772
#, fuzzy
msgid ""
"Send a file until EOF is reached by using high-performance :mod:`os."
"sendfile` and return the total number of bytes which were sent. *file* must "
"be a regular file object opened in binary mode. If :mod:`os.sendfile` is not "
"available (e.g. Windows) or *file* is not a regular file :meth:`send` will "
"be used instead. *offset* tells from where to start reading the file. If "
"specified, *count* is the total number of bytes to transmit as opposed to "
"sending the file until EOF is reached. File position is updated on return or "
"also in case of error in which case :meth:`file.tell() <io.IOBase.tell>` can "
"be used to figure out the number of bytes which were sent. The socket must "
"be of :const:`SOCK_STREAM` type. Non-blocking sockets are not supported."
msgstr ""
"使用高性能 :mod:`os.sendfile` 發送文件直到到達 EOF 並回傳已發送的位元組總"
"數。 *file* 必須是以二進位模式打開的常規文件物件。如果 :mod:`os.sendfile` 不"
"可用（例如 Windows）或 *file* 不是常規文件，則將使用 :meth:`send` 代替。 "
"*offset* 告訴從哪裡開始讀取文件。如果指定，*count* 是要傳輸的位元組總數，而不"
"是在到達 EOF 之前發送文件。文件位置在回傳時或在發生錯誤的情況下更新，在這種情"
"況下 :meth:`file.tell() <io.IOBase.tell>` 可用於計算發送的位元組數。 socket "
"必須是 :const:`SOCK_STREAM` 型別。不支援非阻塞 socket 。"

#: ../../library/socket.rst:1788
#, fuzzy
msgid ""
"Set the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle."
msgstr ""
"設定 socket 文件描述器或 socket 句柄的 :ref:`inheritable 旗標 "
"<fd_inheritance>`。"

#: ../../library/socket.rst:1796
#, fuzzy
msgid ""
"Set blocking or non-blocking mode of the socket: if *flag* is false, the "
"socket is set to non-blocking, else to blocking mode."
msgstr ""
"設定 socket 的阻塞或非阻塞模式：如果*flag* 為false，則 socket 設定為非阻塞，"
"否則為阻塞模式。"

#: ../../library/socket.rst:1799
#, fuzzy
msgid ""
"This method is a shorthand for certain :meth:`~socket.settimeout` calls:"
msgstr "此方法是某些 :meth:`~socket.settimeout` 呼叫的簡寫："

#: ../../library/socket.rst:1801
msgid "``sock.setblocking(True)`` is equivalent to ``sock.settimeout(None)``"
msgstr "``sock.setblocking(True)`` 等價於 ``sock.settimeout(None)``"

#: ../../library/socket.rst:1803
msgid "``sock.setblocking(False)`` is equivalent to ``sock.settimeout(0.0)``"
msgstr "``sock.setblocking(False)`` 等價於 ``sock.settimeout(0.0)``"

#: ../../library/socket.rst:1805
#, fuzzy
msgid ""
"The method no longer applies :const:`SOCK_NONBLOCK` flag on :attr:`socket."
"type`."
msgstr "該方法不再在 :attr:`socket.type` 上應用 :const:`SOCK_NONBLOCK` 旗標。"

#: ../../library/socket.rst:1812
#, fuzzy
msgid ""
"Set a timeout on blocking socket operations.  The *value* argument can be a "
"nonnegative floating point number expressing seconds, or ``None``. If a non-"
"zero value is given, subsequent socket operations will raise a :exc:"
"`timeout` exception if the timeout period *value* has elapsed before the "
"operation has completed.  If zero is given, the socket is put in non-"
"blocking mode. If ``None`` is given, the socket is put in blocking mode."
msgstr ""
"設定阻塞 socket 操作的超時時間。 *value* 參數可以是表示秒的非負浮點數，或 "
"``None`` 。如果給出一個非零值，如果在操作完成之前超時時間 *value* 已經過去，"
"則後續 socket 操作將引發 :exc:`timeout` 例外。如果給出零， socket 將置於非阻"
"塞模式。如果給出 ``None``，套接字將處於阻塞模式。"

#: ../../library/socket.rst:1819
#, fuzzy
msgid ""
"For further information, please consult the :ref:`notes on socket timeouts "
"<socket-timeouts>`."
msgstr "有關更多資訊，請參閱 :ref:`關於 socket 超時的說明 <socket-timeouts>`。"

#: ../../library/socket.rst:1821
#, fuzzy
msgid ""
"The method no longer toggles :const:`SOCK_NONBLOCK` flag on :attr:`socket."
"type`."
msgstr "該方法不再切換 :const:`socket.type` 上的 :const:`SOCK_NONBLOCK` 旗標。"

#: ../../library/socket.rst:1834
#, fuzzy
msgid ""
"Set the value of the given socket option (see the Unix manual page :manpage:"
"`setsockopt(2)`).  The needed symbolic constants are defined in the :mod:"
"`socket` module (:const:`SO_\\*` etc.).  The value can be an integer, "
"``None`` or a :term:`bytes-like object` representing a buffer. In the later "
"case it is up to the caller to ensure that the bytestring contains the "
"proper bits (see the optional built-in module :mod:`struct` for a way to "
"encode C structures as bytestrings). When *value* is set to ``None``, "
"*optlen* argument is required. It's equivalent to call :c:func:`setsockopt` "
"C function with ``optval=NULL`` and ``optlen=optlen``."
msgstr ""
"設定給定 socket 選項的值（參見 Unix 手冊頁 :manpage:`setsockopt(2)`）。所需的"
"符號常數在 :mod:`socket` 模組中定義（:const:`SO_\\*` 等）。該值可以是整數、 "
"``None`` 或表示緩衝區的類似位元組的物件。在後一種情況下，由呼叫者確保位元組串"
"包含正確的位（請參閱可選的內建模組 :mod:`struct` 以了解將 C 結構編碼為位元組"
"串的方法）。當 *value* 設定為 ``None`` 時，*optlen* 參數是必需的。它等效於使"
"用 `optval=NULL`` 和 ``optlen=optlen`` 呼叫 :c:func:`setsockopt` C 函式。"

#: ../../library/socket.rst:1847
#, fuzzy
msgid "setsockopt(level, optname, None, optlen: int) form added."
msgstr "新增了 setsockopt(level, optname, None, optlen: int) 形式。"

#: ../../library/socket.rst:1855
#, fuzzy
msgid ""
"Shut down one or both halves of the connection.  If *how* is :const:"
"`SHUT_RD`, further receives are disallowed.  If *how* is :const:`SHUT_WR`, "
"further sends are disallowed.  If *how* is :const:`SHUT_RDWR`, further sends "
"and receives are disallowed."
msgstr ""
"關閉連接的一半或兩半。如果 *how* 是 :const:`SHUT_RD`，則不允許進一步接收。如"
"果 *how* 是 :const:`SHUT_WR`，則不允許進一步發送。如果 *how* 是 :const:"
"`SHUT_RDWR`，則不允許進一步發送和接收。"

#: ../../library/socket.rst:1865
#, fuzzy
msgid ""
"Duplicate a socket and prepare it for sharing with a target process.  The "
"target process must be provided with *process_id*.  The resulting bytes "
"object can then be passed to the target process using some form of "
"interprocess communication and the socket can be recreated there using :func:"
"`fromshare`. Once this method has been called, it is safe to close the "
"socket since the operating system has already duplicated it for the target "
"process."
msgstr ""
"複製 socket 並準備與目標行程共享。目標行程必須與 *process_id* 一起提供。然後"
"可以使用某種形式的行程間通信將生成的位元組對像傳遞給目標行程，並且可以使用 :"
"func:`fromshare` 在那裡重新建立 socket 。一旦呼叫此方法，就可以安全地關閉 "
"socket ，因為操作系統已經為目標行程複製了它。"

#: ../../library/socket.rst:1877
#, fuzzy
msgid ""
"Note that there are no methods :meth:`read` or :meth:`write`; use :meth:"
"`~socket.recv` and :meth:`~socket.send` without *flags* argument instead."
msgstr ""
"請注意，沒有方法 :meth:`read` 或 :meth:`write`;使用不帶 *flags* 參數的 :meth:"
"`~socket.recv` 和 :meth:`~socket.send` 代替。"

#: ../../library/socket.rst:1880
#, fuzzy
msgid ""
"Socket objects also have these (read-only) attributes that correspond to the "
"values given to the :class:`~socket.socket` constructor."
msgstr ""
" socket 對像也有這些（只讀）屬性，它們對應於給 :class:`~socket.socket` 構造函"
"式的值。"

#: ../../library/socket.rst:1886
#, fuzzy
msgid "The socket family."
msgstr " socket 家族。"

#: ../../library/socket.rst:1891
#, fuzzy
msgid "The socket type."
msgstr " socket 型別。"

#: ../../library/socket.rst:1896
#, fuzzy
msgid "The socket protocol."
msgstr " socket 協定。"

#: ../../library/socket.rst:1903
#, fuzzy
msgid "Notes on socket timeouts"
msgstr "關於 socket 超時的注意事項"

#: ../../library/socket.rst:1905
#, fuzzy
msgid ""
"A socket object can be in one of three modes: blocking, non-blocking, or "
"timeout.  Sockets are by default always created in blocking mode, but this "
"can be changed by calling :func:`setdefaulttimeout`."
msgstr ""
" socket 物件可以處於三種模式之一：阻塞、非阻塞或超時。預設情況下， socket 始"
"終以阻塞模式建立，但這可以通過呼叫 :func:`setdefaulttimeout` 來更改。"

#: ../../library/socket.rst:1909
#, fuzzy
msgid ""
"In *blocking mode*, operations block until complete or the system returns an "
"error (such as connection timed out)."
msgstr "在*阻塞模式*中，操作阻塞直到完成或系統回傳錯誤（例如連接超時）。"

#: ../../library/socket.rst:1912
#, fuzzy
msgid ""
"In *non-blocking mode*, operations fail (with an error that is unfortunately "
"system-dependent) if they cannot be completed immediately: functions from "
"the :mod:`select` module can be used to know when and whether a socket is "
"available for reading or writing."
msgstr ""
"在*非阻塞模式*下，如果操作不能立即完成，操作將失敗（不幸的是系統相關的錯"
"誤）：來自 :mod:`select` 模組的函式可用於了解 socket 何時以及是否可用用於閱讀"
"或寫作。"

#: ../../library/socket.rst:1917
#, fuzzy
msgid ""
"In *timeout mode*, operations fail if they cannot be completed within the "
"timeout specified for the socket (they raise a :exc:`timeout` exception) or "
"if the system returns an error."
msgstr ""
"在 *超時模式* 下，如果操作無法在為 socket 指定的超時內完成（它們引發 :exc:"
"`timeout` 例外）或系統回傳錯誤，則操作失敗。"

#: ../../library/socket.rst:1922
#, fuzzy
msgid ""
"At the operating system level, sockets in *timeout mode* are internally set "
"in non-blocking mode.  Also, the blocking and timeout modes are shared "
"between file descriptors and socket objects that refer to the same network "
"endpoint. This implementation detail can have visible consequences if e.g. "
"you decide to use the :meth:`~socket.fileno()` of a socket."
msgstr ""
"在操作系統級別，*超時模式* 的 socket 在內部設定為非阻塞模式。此外，阻塞和超時"
"模式在引用同一網絡端點的文件描述器和 socket 物件之間共享。如果例如，此實作細"
"節可能會產生明顯的後果。您決定使用 socket 的 :meth:`~socket.fileno()`。"

#: ../../library/socket.rst:1929
#, fuzzy
msgid "Timeouts and the ``connect`` method"
msgstr "超時和 ``connect`` 方法"

#: ../../library/socket.rst:1931
#, fuzzy
msgid ""
"The :meth:`~socket.connect` operation is also subject to the timeout "
"setting, and in general it is recommended to call :meth:`~socket.settimeout` "
"before calling :meth:`~socket.connect` or pass a timeout parameter to :meth:"
"`create_connection`.  However, the system network stack may also return a "
"connection timeout error of its own regardless of any Python socket timeout "
"setting."
msgstr ""
":meth:`~socket.connect` 操作也受制於超時設定，一般情況下建議在呼叫 :meth:"
"`~socket.connect` 之前先呼叫 :meth:`~socket.settimeout` 或傳遞一個"
"create_connection 的超時參數。但是，無論任何 Python  socket 超時設定如何，系"
"統網絡堆疊也可能回傳自己的連接超時錯誤。"

#: ../../library/socket.rst:1939
#, fuzzy
msgid "Timeouts and the ``accept`` method"
msgstr "超時和 ``accept`` 方法"

#: ../../library/socket.rst:1941
#, fuzzy
msgid ""
"If :func:`getdefaulttimeout` is not :const:`None`, sockets returned by the :"
"meth:`~socket.accept` method inherit that timeout.  Otherwise, the behaviour "
"depends on settings of the listening socket:"
msgstr ""
"如果 :func:`getdefaulttimeout` 不是 :const:`None`，則 :meth:`~socket.accept` "
"方法回傳的 socket 會繼承該超時。否則，行為取決於偵聽 socket 的設定："

#: ../../library/socket.rst:1945
#, fuzzy
msgid ""
"if the listening socket is in *blocking mode* or in *timeout mode*, the "
"socket returned by :meth:`~socket.accept` is in *blocking mode*;"
msgstr ""
"如果偵聽 socket 處於*阻塞模式*或*超時模式*，則 :meth:`~socket.accept` 回傳的 "
"socket 處於*阻塞模式*；"

#: ../../library/socket.rst:1948
#, fuzzy
msgid ""
"if the listening socket is in *non-blocking mode*, whether the socket "
"returned by :meth:`~socket.accept` is in blocking or non-blocking mode is "
"operating system-dependent.  If you want to ensure cross-platform behaviour, "
"it is recommended you manually override this setting."
msgstr ""
"如果偵聽 socket 處於*非阻塞模式*，則 :meth:`~socket.accept` 回傳的 socket 是"
"處於阻塞模式還是非阻塞模式取決於操作系統。如果您想確保跨平台行為，建議您手動"
"覆蓋此設定。"

#: ../../library/socket.rst:1957
msgid "Example"
msgstr "範例"

#: ../../library/socket.rst:1959
#, fuzzy
msgid ""
"Here are four minimal example programs using the TCP/IP protocol: a server "
"that echoes all data that it receives back (servicing only one client), and "
"a client using it.  Note that a server must perform the sequence :func:`."
"socket`, :meth:`~socket.bind`, :meth:`~socket.listen`, :meth:`~socket."
"accept` (possibly repeating the :meth:`~socket.accept` to service more than "
"one client), while a client only needs the sequence :func:`.socket`, :meth:"
"`~socket.connect`.  Also note that the server does not :meth:`~socket."
"sendall`/:meth:`~socket.recv` on the socket it is listening on but on the "
"new socket returned by :meth:`~socket.accept`."
msgstr ""
"這裡有四個使用 TCP/IP 協定的最小示例程式：一個回顯它接收到的所有資料的伺服器"
"（只為一個客戶端提供服務），以及一個使用它的客戶端。請注意，伺服器必須執行以"
"下序列 :func:`.socket`、:meth:`~socket.bind`、:meth:`~socket.listen`、:meth:"
"`~socket.accept`（可能重複： meth:`~socket.accept` 服務多個客戶端），而客戶端"
"只需要序列 :func:`.socket`, :meth:`~socket.connect`。另請注意，伺服器不會在它"
"正在偵聽的 socket 上執行 :meth:`~socket.sendall`/:meth:`~socket.recv`，而是在"
"由 :meth:`~socket.accept` 回傳的新 socket 上執行。"

#: ../../library/socket.rst:1969
msgid "The first two examples support IPv4 only. ::"
msgstr ""
"前兩個範例只支援 IPv4：\n"
"\n"
"::"

#: ../../library/socket.rst:2000
#, fuzzy
msgid ""
"The next two examples are identical to the above two, but support both IPv4 "
"and IPv6. The server side will listen to the first address family available "
"(it should listen to both instead). On most of IPv6-ready systems, IPv6 will "
"take precedence and the server may not accept IPv4 traffic. The client side "
"will try to connect to the all addresses returned as a result of the name "
"resolution, and sends traffic to the first one connected successfully. ::"
msgstr ""
"接下來的兩個示例與上面兩個相同，但同時支援 IPv4 和 IPv6。伺服器端將監聽第一個"
"可用的地址族（它應該同時監聽兩者）。在大多數支援 IPv6 的系統上，IPv6 優先，伺"
"服器可能不接受 IPv4 流量。客戶端將嘗試連接到作為名稱解析結果回傳的所有地址，"
"並將流量發送到第一個連接成功的地址。 ::"

#: ../../library/socket.rst:2072
#, fuzzy
msgid ""
"The next example shows how to write a very simple network sniffer with raw "
"sockets on Windows. The example requires administrator privileges to modify "
"the interface::"
msgstr ""
"下一個示例展示瞭如何在 Windows 上使用原始 socket 編寫一個非常簡單的網絡嗅探"
"器。該示例需要管理員權限才能修改介面::"

#: ../../library/socket.rst:2097
#, fuzzy
msgid ""
"The next example shows how to use the socket interface to communicate to a "
"CAN network using the raw socket protocol. To use CAN with the broadcast "
"manager protocol instead, open a socket with::"
msgstr ""
"下一個示例顯示如何使用 socket 介面通過原始 socket 協定與 CAN 網絡通信。要將 "
"CAN 與廣播管理器協定一起使用，請使用以下內容打開一個 socket ："

#: ../../library/socket.rst:2103
#, fuzzy
msgid ""
"After binding (:const:`CAN_RAW`) or connecting (:const:`CAN_BCM`) the "
"socket, you can use the :meth:`socket.send` and :meth:`socket.recv` "
"operations (and their counterparts) on the socket object as usual."
msgstr ""
"綁定（ :const:`CAN_RAW`）或連接（ :const:`CAN_BCM`） socket 後，您可以使用："
"meth：`socket.send`和 :meth:`socket.recv`操作（及其對應物）像往常一樣在 "
"socket 對像上。"

#: ../../library/socket.rst:2107
#, fuzzy
msgid "This last example might require special privileges::"
msgstr "最後一個示例可能需要特殊權限::"

#: ../../library/socket.rst:2147
#, fuzzy
msgid ""
"Running an example several times with too small delay between executions, "
"could lead to this error::"
msgstr "多次運行一個示例，兩次執行之間的延遲太小，可能會導致此錯誤::"

#: ../../library/socket.rst:2152
#, fuzzy
msgid ""
"This is because the previous execution has left the socket in a "
"``TIME_WAIT`` state, and can't be immediately reused."
msgstr "這是因為之前的執行使 socket 處於 ``TIME_WAIT`` 狀態，不能立即重用。"

#: ../../library/socket.rst:2155
#, fuzzy
msgid ""
"There is a :mod:`socket` flag to set, in order to prevent this, :data:"
"`socket.SO_REUSEADDR`::"
msgstr ""
"有一個 :mod:`socket` 旗標要設定，為了防止這種情況，:data:`socket."
"SO_REUSEADDR`::"

#: ../../library/socket.rst:2162
#, fuzzy
msgid ""
"the :data:`SO_REUSEADDR` flag tells the kernel to reuse a local socket in "
"``TIME_WAIT`` state, without waiting for its natural timeout to expire."
msgstr ""
":data:`SO_REUSEADDR` 旗標告訴內核重用處於 ``TIME_WAIT`` 狀態的本地 socket ，"
"而無需等待其自然超時到期。"

#: ../../library/socket.rst:2168
#, fuzzy
msgid ""
"For an introduction to socket programming (in C), see the following papers:"
msgstr "有關 socket 編程（C 語言）的介紹，請參閱以下論文："

#: ../../library/socket.rst:2170
#, fuzzy
msgid ""
"*An Introductory 4.3BSD Interprocess Communication Tutorial*, by Stuart "
"Sechrest"
msgstr "*介紹性 4.3BSD 行程間通信教程*，作者 Stuart Sechrest"

#: ../../library/socket.rst:2172
#, fuzzy
msgid ""
"*An Advanced 4.3BSD Interprocess Communication Tutorial*, by Samuel J.  "
"Leffler et al,"
msgstr "*高階 4.3BSD 行程間通信教程*，作者 Samuel J. Leffler 等人，"

#: ../../library/socket.rst:2175
#, fuzzy
msgid ""
"both in the UNIX Programmer's Manual, Supplementary Documents 1 (sections "
"PS1:7 and PS1:8).  The platform-specific reference material for the various "
"socket-related system calls are also a valuable source of information on the "
"details of socket semantics.  For Unix, refer to the manual pages; for "
"Windows, see the WinSock (or Winsock 2) specification.  For IPv6-ready APIs, "
"readers may want to refer to :rfc:`3493` titled Basic Socket Interface "
"Extensions for IPv6."
msgstr ""
"兩者都在 UNIX 程式員手冊，補充文檔 1（PS1:7 和 PS1:8 節）中。各種與 socket 相"
"關的系統呼叫的特定於平台的參考資料也是有關 socket 語義細節的寶貴資訊來源。對"
"於 Unix，請參閱手冊頁；對於 Windows，請參閱 WinSock（或 Winsock 2）規範。對於"
"支援 IPv6 的 API，讀者可能需要參考標題為 IPv6 的基本 socket 介面擴充的 :rfc:"
"`3493`。"
