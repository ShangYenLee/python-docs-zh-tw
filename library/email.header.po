# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-26 18:54+0800\n"
"PO-Revision-Date: 2018-05-23 14:44+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/email.header.rst:2
#, fuzzy
msgid ":mod:`email.header`: Internationalized headers"
msgstr ":mod:`email.header`: 國際化標題"

#: ../../library/email.header.rst:7
msgid "**Source code:** :source:`Lib/email/header.py`"
msgstr "**原始碼：**\\ :source:`Lib/email/header.py`"

#: ../../library/email.header.rst:11
#, fuzzy
msgid ""
"This module is part of the legacy (``Compat32``) email API.  In the current "
"API encoding and decoding of headers is handled transparently by the "
"dictionary-like API of the :class:`~email.message.EmailMessage` class.  In "
"addition to uses in legacy code, this module can be useful in applications "
"that need to completely control the character sets used when encoding "
"headers."
msgstr ""
"此模組是舊版 (``Compat32``) 電子郵件 API 的一部分。在當前的 API 中，"
"標頭的編碼和解碼由 :class:`~email.message.EmailMessage` 類的類似字典的 API 透"
"明地處理。除了在遺留程式碼中使用外，此模組在需要完全控制編碼標頭時使用的字元"
"集的應用程式中也很有用。"

#: ../../library/email.header.rst:17
#, fuzzy
msgid ""
"The remaining text in this section is the original documentation of the "
"module."
msgstr "本節中的其余文本是模組的原始文檔。"

#: ../../library/email.header.rst:19
#, fuzzy
msgid ""
":rfc:`2822` is the base standard that describes the format of email "
"messages. It derives from the older :rfc:`822` standard which came into "
"widespread use at a time when most email was composed of ASCII characters "
"only.  :rfc:`2822` is a specification written assuming email contains only 7-"
"bit ASCII characters."
msgstr ""
":rfc:`2822` 是描述電子郵件格式的基本標準。它源自舊的 :rfc:`822` 標準，"
"該標准在大多數電子郵件僅由 ASCII 字元組成的時候得到廣泛使用。 :rfc:`2822` "
"是假設電子郵件僅包含 7 位 ASCII 字元的規範。"

#: ../../library/email.header.rst:24
#, fuzzy
msgid ""
"Of course, as email has been deployed worldwide, it has become "
"internationalized, such that language specific character sets can now be "
"used in email messages.  The base standard still requires email messages to "
"be transferred using only 7-bit ASCII characters, so a slew of RFCs have "
"been written describing how to encode email containing non-ASCII characters "
"into :rfc:`2822`\\ -compliant format. These RFCs include :rfc:`2045`, :rfc:"
"`2046`, :rfc:`2047`, and :rfc:`2231`. The :mod:`email` package supports "
"these standards in its :mod:`email.header` and :mod:`email.charset` modules."
msgstr ""
"當然，由於電子郵件已在全球部署，它已經國際化，因此現在可以在電子郵件消息中使"
"用特定於語言的字元集。基本標準仍然要求僅使用 7 位 ASCII "
"字元傳輸電子郵件消息，因此已編寫了大量 RFC，描述如何將包含非 ASCII "
"字元的電子郵件編碼為 :rfc:`2822`\\ 相容格式。這些 RFC "
"包括 :rfc:`2045`、:rfc:`2046`、:rfc:`2047` 和 :rfc:`2231`。 :mod:`email` "
"包在其 :mod:`email.header` 和 :mod:`email.charset` 模組中支援這些標準。"

#: ../../library/email.header.rst:33
#, fuzzy
msgid ""
"If you want to include non-ASCII characters in your email headers, say in "
"the :mailheader:`Subject` or :mailheader:`To` fields, you should use the :"
"class:`Header` class and assign the field in the :class:`~email.message."
"Message` object to an instance of :class:`Header` instead of using a string "
"for the header value.  Import the :class:`Header` class from the :mod:`email."
"header` module. For example::"
msgstr ""
"如果你想在你的電子郵件標題中包含非 ASCII 字元，比如在 :mailheader:`Subject` "
"或 :mailheader:`To` 欄位中，你應該使用 :class:`Header` 類並將欄位分配到： "
"class:`~email.message.Message` 對像到 :class:`Header` "
"的實例，而不是使用字串作為標頭值。從 :mod:`email.header` "
"模組導入 :class:`Header` 類。例如：："

#: ../../library/email.header.rst:50
#, fuzzy
msgid ""
"Notice here how we wanted the :mailheader:`Subject` field to contain a non-"
"ASCII character?  We did this by creating a :class:`Header` instance and "
"passing in the character set that the byte string was encoded in.  When the "
"subsequent :class:`~email.message.Message` instance was flattened, the :"
"mailheader:`Subject` field was properly :rfc:`2047` encoded.  MIME-aware "
"mail readers would show this header using the embedded ISO-8859-1 character."
msgstr ""
"請注意，我們是如何希望 :mailheader:`Subject` 欄位包含非 ASCII 字元的？"
"我們通過建立一個 Header 實例並傳入編碼位元組字串的字元集來做到這一點。 "
"Subject` 欄位已正確編碼為 :rfc:`2047`。支援 MIME 的郵件閱讀器將使用嵌入的 "
"ISO-8859-1 字元顯示此標頭。"

#: ../../library/email.header.rst:57
#, fuzzy
msgid "Here is the :class:`Header` class description:"
msgstr "這是 :class:`Header` 類描述："

#: ../../library/email.header.rst:62
#, fuzzy
msgid ""
"Create a MIME-compliant header that can contain strings in different "
"character sets."
msgstr "建立一個符合 MIME 標準的標頭，它可以包含不同字元集中的字串。"

#: ../../library/email.header.rst:65
#, fuzzy
msgid ""
"Optional *s* is the initial header value.  If ``None`` (the default), the "
"initial header value is not set.  You can later append to the header with :"
"meth:`append` method calls.  *s* may be an instance of :class:`bytes` or :"
"class:`str`, but see the :meth:`append` documentation for semantics."
msgstr ""
"可選 *s* 是初始標頭值。如果 ``None`` （預設值），則未設定初始標頭值。"
"您可以稍後使用 :meth:`append` 方法呼叫附加到標頭。 *s* 可能是 :class:`bytes` "
"或 :class:`str` 的實例，但請參閱 :meth:`append` 文檔了解語義。"

#: ../../library/email.header.rst:70
#, fuzzy
msgid ""
"Optional *charset* serves two purposes: it has the same meaning as the "
"*charset* argument to the :meth:`append` method.  It also sets the default "
"character set for all subsequent :meth:`append` calls that omit the "
"*charset* argument.  If *charset* is not provided in the constructor (the "
"default), the ``us-ascii`` character set is used both as *s*'s initial "
"charset and as the default for subsequent :meth:`append` calls."
msgstr ""
"可選的 *charset* 有兩個用途：它與 :meth:`append` 方法的 *charset* "
"參數具有相同的含義。它還為省略 *charset* 參數的所有後續 :meth:`append` "
"呼叫設定預設字元集。如果 *charset* 未在構造函式中提供（預設），則 us-ascii "
"字元集將用作 *s* 的初始字元集和後續 :meth:`append` 呼叫的預設字元集。"

#: ../../library/email.header.rst:77
#, fuzzy
msgid ""
"The maximum line length can be specified explicitly via *maxlinelen*.  For "
"splitting the first line to a shorter value (to account for the field header "
"which isn't included in *s*, e.g. :mailheader:`Subject`) pass in the name of "
"the field in *header_name*.  The default *maxlinelen* is 76, and the default "
"value for *header_name* is ``None``, meaning it is not taken into account "
"for the first line of a long, split header."
msgstr ""
"最大行長度可以通過 *maxlinelen* 明確指定。為了將第一行拆分為較短的值（以考慮 "
"*s* 中未包含的欄位標題，例如 :mailheader:`Subject`）在 *header_name* "
"中傳遞欄位名稱。預設的 *maxlinelen* 是 76，*header_name* 的預設值是 "
"``None``，這意味著它不會被考慮到一個長的、分割的標題的第一行。"

#: ../../library/email.header.rst:84
#, fuzzy
msgid ""
"Optional *continuation_ws* must be :rfc:`2822`\\ -compliant folding "
"whitespace, and is usually either a space or a hard tab character.  This "
"character will be prepended to continuation lines.  *continuation_ws* "
"defaults to a single space character."
msgstr ""
"可選的 *continuation_ws* 必須是 :rfc:`2822`\\ "
"-相容的折疊空格，通常是空格或硬製表符。該字元將被新增到續行中。 "
"*continuation_ws* 預設為單個空格字元。"

#: ../../library/email.header.rst:89
#, fuzzy
msgid ""
"Optional *errors* is passed straight through to the :meth:`append` method."
msgstr "可選的 *errors* 直接傳遞給 :meth:`append` 方法。"

#: ../../library/email.header.rst:94
#, fuzzy
msgid "Append the string *s* to the MIME header."
msgstr "將字串 *s* 附加到 MIME 標頭。"

#: ../../library/email.header.rst:96
#, fuzzy
msgid ""
"Optional *charset*, if given, should be a :class:`~email.charset.Charset` "
"instance (see :mod:`email.charset`) or the name of a character set, which "
"will be converted to a :class:`~email.charset.Charset` instance.  A value of "
"``None`` (the default) means that the *charset* given in the constructor is "
"used."
msgstr ""
"可選的 *charset*，如果給定，應該是一個 :class:`~email.charset.Charset` 實例（"
"見 :mod:`email.charset`）或字元集的名稱，它將被轉換為 :class :`~email.charset"
".Charset` 實例。 ``None`` 的值（預設值）意味著使用構造函式中給出的 "
"*charset*。"

#: ../../library/email.header.rst:102
#, fuzzy
msgid ""
"*s* may be an instance of :class:`bytes` or :class:`str`.  If it is an "
"instance of :class:`bytes`, then *charset* is the encoding of that byte "
"string, and a :exc:`UnicodeError` will be raised if the string cannot be "
"decoded with that character set."
msgstr ""
"*s* 可能是 :class:`bytes` 或 :class:`str` 的實例。如果它是 :class:`bytes` "
"的實例，則 *charset* 是該位元組字串的編碼，如果無法使用該字元集解碼字串，"
"則會引發 :exc:`UnicodeError`。"

#: ../../library/email.header.rst:107
#, fuzzy
msgid ""
"If *s* is an instance of :class:`str`, then *charset* is a hint specifying "
"the character set of the characters in the string."
msgstr "如果 *s* 是 :class:`str` 的一個實例，那麼 *charset* "
"是一個提示，指定字串中字元的字元集。"

#: ../../library/email.header.rst:110
#, fuzzy
msgid ""
"In either case, when producing an :rfc:`2822`\\ -compliant header using :rfc:"
"`2047` rules, the string will be encoded using the output codec of the "
"charset.  If the string cannot be encoded using the output codec, a "
"UnicodeError will be raised."
msgstr ""
"在任何一種情況下，當使用 :rfc:`2047` 規則生成符合 :rfc:`2822`\\ 的標頭時，字"
"串將使用字元集的輸出編解碼器進行編碼。如果無法使用輸出編解碼器對字串進行編碼"
"，則會引發 UnicodeError。"

#: ../../library/email.header.rst:115
#, fuzzy
msgid ""
"Optional *errors* is passed as the errors argument to the decode call if *s* "
"is a byte string."
msgstr "如果 *s* 是位元組字串，則可選 *errors* 作為錯誤參數傳遞給解碼呼叫。"

#: ../../library/email.header.rst:121
#, fuzzy
msgid ""
"Encode a message header into an RFC-compliant format, possibly wrapping long "
"lines and encapsulating non-ASCII parts in base64 or quoted-printable "
"encodings."
msgstr "將消息標頭編碼為符合 RFC 的格式，可能會將長行換行並將非 ASCII 部分封裝在 "
"base64 或引用印出編碼中。"

#: ../../library/email.header.rst:125
#, fuzzy
msgid ""
"Optional *splitchars* is a string containing characters which should be "
"given extra weight by the splitting algorithm during normal header "
"wrapping.  This is in very rough support of :RFC:`2822`\\'s 'higher level "
"syntactic breaks':  split points preceded by a splitchar are preferred "
"during line splitting, with the characters preferred in the order in which "
"they appear in the string.  Space and tab may be included in the string to "
"indicate whether preference should be given to one over the other as a split "
"point when other split chars do not appear in the line being split.  "
"Splitchars does not affect :RFC:`2047` encoded lines."
msgstr ""
"可選的 *splitchars* 是一個包含字元的字串，在正常的標頭包裝期間，拆分演算法應"
"該給予這些字元額外的權重。這是對 :RFC:`2822`\\'s 'higher level syntactic "
"breaks' 的非常粗略的支援：在行拆分期間首選以 splitchar 開頭的拆分點，字元按照"
"它們在字串中出現的順序首選。字串中可以包含空格和製表符，以指示當其他拆分字元"
"未出現在要拆分的行中時，是否應優先考慮一個作為拆分點。 Splitchars 不影響 "
":RFC:`2047` 編碼行。"

#: ../../library/email.header.rst:135
#, fuzzy
msgid ""
"*maxlinelen*, if given, overrides the instance's value for the maximum line "
"length."
msgstr "*maxlinelen*，如果給定，將覆蓋實例的最大行長度值。"

#: ../../library/email.header.rst:138
#, fuzzy
msgid ""
"*linesep* specifies the characters used to separate the lines of the folded "
"header.  It defaults to the most useful value for Python application code (``"
"\\n``), but ``\\r\\n`` can be specified in order to produce headers with RFC-"
"compliant line separators."
msgstr ""
"*linesep* 指定用於分隔折疊標題行的字元。它預設為 Python "
"應用程式程式碼最有用的值 (``\\n"
"``)，但可以指定 ``\\r\\n"
"`` 以生成具有符合 RFC 標準的行分隔符的標頭。"

#: ../../library/email.header.rst:143
msgid "Added the *linesep* argument."
msgstr "新增引數 *linesep*\\ 。"

#: ../../library/email.header.rst:147
#, fuzzy
msgid ""
"The :class:`Header` class also provides a number of methods to support "
"standard operators and built-in functions."
msgstr ":class:`Header` 類還提供了許多方法來支援標準運算符和內建函式。"

#: ../../library/email.header.rst:152
#, fuzzy
msgid ""
"Returns an approximation of the :class:`Header` as a string, using an "
"unlimited line length.  All pieces are converted to unicode using the "
"specified encoding and joined together appropriately.  Any pieces with a "
"charset of ``'unknown-8bit'`` are decoded as ASCII using the ``'replace'`` "
"error handler."
msgstr ""
"使用無限行長度回傳 :class:`Header` 作為字串的近似值。"
"所有片段都使用指定的編碼轉換為 "
"unicode，並適當地連接在一起。使用“替換”錯誤處理程式將任何帶有“未知 8 位”"
"字元集的片段解碼為 ASCII。"

#: ../../library/email.header.rst:158
#, fuzzy
msgid "Added handling for the ``'unknown-8bit'`` charset."
msgstr "新增了對 ``'unknown-8bit'`` 字元集的處理。"

#: ../../library/email.header.rst:164
#, fuzzy
msgid ""
"This method allows you to compare two :class:`Header` instances for equality."
msgstr "此方法允許您比較兩個 :class:`Header` 實例是否相等。"

#: ../../library/email.header.rst:170
#, fuzzy
msgid ""
"This method allows you to compare two :class:`Header` instances for "
"inequality."
msgstr "此方法允許您比較兩個 :class:`Header` 實例是否不相等。"

#: ../../library/email.header.rst:173
#, fuzzy
msgid ""
"The :mod:`email.header` module also provides the following convenient "
"functions."
msgstr ":mod:`email.header` 模組還提供了以下方便的功能。"

#: ../../library/email.header.rst:178
#, fuzzy
msgid ""
"Decode a message header value without converting the character set. The "
"header value is in *header*."
msgstr "在不轉換字元集的情況下解碼郵件標頭值。標頭值在 *header* 中。"

#: ../../library/email.header.rst:181
#, fuzzy
msgid ""
"This function returns a list of ``(decoded_string, charset)`` pairs "
"containing each of the decoded parts of the header.  *charset* is ``None`` "
"for non-encoded parts of the header, otherwise a lower case string "
"containing the name of the character set specified in the encoded string."
msgstr ""
"此函式回傳包含標頭每個解碼部分的“(decoded_string, charset)”對列表。 *charset*"
" 對於標頭的非編碼部分為 ``None``，否則為包含編碼字串中指定的字元集名稱的小寫字串"
"。"

#: ../../library/email.header.rst:186
msgid "Here's an example::"
msgstr ""
"以下是個範例：\n"
"\n"
"::"

#: ../../library/email.header.rst:195
#, fuzzy
msgid ""
"Create a :class:`Header` instance from a sequence of pairs as returned by :"
"func:`decode_header`."
msgstr "根據 decode_header 回傳的一系列對建立一個 Header 實例。"

#: ../../library/email.header.rst:198
#, fuzzy
msgid ""
":func:`decode_header` takes a header value string and returns a sequence of "
"pairs of the format ``(decoded_string, charset)`` where *charset* is the "
"name of the character set."
msgstr ""
":func:`decode_header` 獲取標頭值字串並回傳格式為 ``(decoded_string, "
"charset)`` 的序列對，其中 *charset* 是字元集的名稱。"

#: ../../library/email.header.rst:202
#, fuzzy
msgid ""
"This function takes one of those sequence of pairs and returns a :class:"
"`Header` instance.  Optional *maxlinelen*, *header_name*, and "
"*continuation_ws* are as in the :class:`Header` constructor."
msgstr ""
"此函式採用這些對序列中的一個並回傳一個 Header 實例。可選的 "
"*maxlinelen*、*header_name* 和 *continuation_ws* 與 Header 構造函式中的一樣。"
