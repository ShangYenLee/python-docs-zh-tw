# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-15 00:18+0000\n"
"PO-Revision-Date: 2018-05-23 16:00+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/email.mime.rst:2
msgid ":mod:`email.mime`: Creating email and MIME objects from scratch"
msgstr ":mod:`email.mime`：從頭開始建立電子郵件和 MIME 物件"

#: ../../library/email.mime.rst:7
msgid "**Source code:** :source:`Lib/email/mime/`"
msgstr "**原始碼：**\\ :source:`Lib/email/mime/`"

#: ../../library/email.mime.rst:11
#, fuzzy
msgid ""
"This module is part of the legacy (``Compat32``) email API.  Its "
"functionality is partially replaced by the :mod:`~email.contentmanager` in "
"the new API, but in certain applications these classes may still be useful, "
"even in non-legacy code."
msgstr ""
"此模組是舊版 (``Compat32``) 電子郵件 API 的一部分。它的功能部分被新 API 中的 "
":mod:`~email.contentmanager` "
"取代，但在某些應用程式中，這些類可能仍然有用，即使在非遺留程式碼中也是如此。"

#: ../../library/email.mime.rst:16
#, fuzzy
msgid ""
"Ordinarily, you get a message object structure by passing a file or some "
"text to a parser, which parses the text and returns the root message "
"object.  However you can also build a complete message structure from "
"scratch, or even individual :class:`~email.message.Message` objects by "
"hand.  In fact, you can also take an existing structure and add new :class:"
"`~email.message.Message` objects, move them around, etc.  This makes a very "
"convenient interface for slicing-and-dicing MIME messages."
msgstr ""
"通常，您通過將文件或一些文本傳遞給解析器來獲得消息物件結構，解析器解析文本並"
"回傳根消息物件。然而，您也可以從頭開始構建完整的消息結構，"
"甚至可以手動構建單個 :class:`~email.message.Message` 物件。事實上，"
"您還可以採用現有結構並新增新的 :class:`~email.message.Message` "
"物件，移動它們等。這為切片和切割 MIME 消息提供了一個非常方便的界面。"

#: ../../library/email.mime.rst:24
#, fuzzy
msgid ""
"You can create a new object structure by creating :class:`~email.message."
"Message` instances, adding attachments and all the appropriate headers "
"manually.  For MIME messages though, the :mod:`email` package provides some "
"convenient subclasses to make things easier."
msgstr ""
"您可以通過建立 :class:`~email.message.Message` "
"實例、手動新增附件和所有適當的標題來建立新的物件結構。不過，對於 MIME "
"消息，:mod:`email` 包提供了一些方便的子類別，使事情變得更容易。"

#: ../../library/email.mime.rst:29
#, fuzzy
msgid "Here are the classes:"
msgstr "以下是課程："

#: ../../library/email.mime.rst:35
msgid "Module: :mod:`email.mime.base`"
msgstr "模組：\\ :mod:`email.mime.base`"

#: ../../library/email.mime.rst:37
#, fuzzy
msgid ""
"This is the base class for all the MIME-specific subclasses of :class:"
"`~email.message.Message`.  Ordinarily you won't create instances "
"specifically of :class:`MIMEBase`, although you could.  :class:`MIMEBase` is "
"provided primarily as a convenient base class for more specific MIME-aware "
"subclasses."
msgstr ""
"這是 :class:`~email.message.Message` 的所有特定於 MIME 的子類別的基底類別。"
"通常您不會專門建立 :class:`MIMEBase` 的實例，儘管您可以。 :class:`MIMEBase` "
"主要作為更具體的 MIME 感知子類別的方便基底類別提供。"

#: ../../library/email.mime.rst:43
#, fuzzy
msgid ""
"*_maintype* is the :mailheader:`Content-Type` major type (e.g. :mimetype:"
"`text` or :mimetype:`image`), and *_subtype* is the :mailheader:`Content-"
"Type` minor type  (e.g. :mimetype:`plain` or :mimetype:`gif`).  *_params* is "
"a parameter key/value dictionary and is passed directly to :meth:`Message."
"add_header <email.message.Message.add_header>`."
msgstr ""
"*_maintype* 是 :mailheader:`Content-Type` 主要型別（例如 :mimetype:`text` 或 "
":mimetype:`image`），*_subtype* 是 :mailheader:`Content-Type` "
"次要型別（例如:mimetype:`plain` 或 :mimetype:`gif`)。 *_params* "
"是參數鍵/值字典，直接傳遞給 :meth:`Message.add_header <email.message.Message."
"add_header>`。"

#: ../../library/email.mime.rst:49
#, fuzzy
msgid ""
"If *policy* is specified, (defaults to the :class:`compat32 <email.policy."
"Compat32>` policy) it will be passed to :class:`~email.message.Message`."
msgstr ""
"如果指定了 *policy*，（預設為 :class:`compat32 <email.policy.Compat32>` "
"策略）它將被傳遞給 :class:`~email.message.Message`。"

#: ../../library/email.mime.rst:53
#, fuzzy
msgid ""
"The :class:`MIMEBase` class always adds a :mailheader:`Content-Type` header "
"(based on *_maintype*, *_subtype*, and *_params*), and a :mailheader:`MIME-"
"Version` header (always set to ``1.0``)."
msgstr ""
":class:`MIMEBase` 類總是新增一個 :mailheader:`Content-Type` 標頭（基於 "
"*_maintype*、*_subtype* 和 *_params*）和一個 :mailheader:`MIME-Version` "
"標頭（總是設定為 ``1.0``)。"

#: ../../library/email.mime.rst:57 ../../library/email.mime.rst:104
#: ../../library/email.mime.rst:135 ../../library/email.mime.rst:169
#: ../../library/email.mime.rst:205 ../../library/email.mime.rst:225
#: ../../library/email.mime.rst:259
msgid "Added *policy* keyword-only parameter."
msgstr "新增僅限關鍵字參數 *policy*\\ 。"

#: ../../library/email.mime.rst:65
msgid "Module: :mod:`email.mime.nonmultipart`"
msgstr "模組：\\ :mod:`email.mime.nonmultipart`"

#: ../../library/email.mime.rst:67
#, fuzzy
msgid ""
"A subclass of :class:`~email.mime.base.MIMEBase`, this is an intermediate "
"base class for MIME messages that are not :mimetype:`multipart`.  The "
"primary purpose of this class is to prevent the use of the :meth:`~email."
"message.Message.attach` method, which only makes sense for :mimetype:"
"`multipart` messages.  If :meth:`~email.message.Message.attach` is called, "
"a :exc:`~email.errors.MultipartConversionError` exception is raised."
msgstr ""
":class:`~email.mime.base.MIMEBase` 的子類別，這是非 :mimetype:`multipart` 的 "
"MIME 消息的中間基底類別。此類的主要目的是防止使用 :meth:`~email.message."
"Message.attach` 方法，該方法僅對 :mimetype:`multipart` 消息有意義。如果 "
":meth:`~email.message.Message.attach` 被呼叫，則會引發 :exc:`~email.errors."
"MultipartConversionError` 例外。"

#: ../../library/email.mime.rst:80
msgid "Module: :mod:`email.mime.multipart`"
msgstr "模組：\\ :mod:`email.mime.multipart`"

#: ../../library/email.mime.rst:82
#, fuzzy
msgid ""
"A subclass of :class:`~email.mime.base.MIMEBase`, this is an intermediate "
"base class for MIME messages that are :mimetype:`multipart`.  Optional "
"*_subtype* defaults to :mimetype:`mixed`, but can be used to specify the "
"subtype of the message.  A :mailheader:`Content-Type` header of :mimetype:"
"`multipart/_subtype` will be added to the message object.  A :mailheader:"
"`MIME-Version` header will also be added."
msgstr ""
":class:`~email.mime.base.MIMEBase` 的子類別，這是 MIME "
"消息的中間基底類別 :mimetype:`multipart`。可選 *_subtype* 預設為 "
":mimetype:`mixed`，但可用於指定消息的子型別。 :mimetype:`multipart/_subtype` "
"的:mailheader:`Content-Type` 標頭將新增到郵件物件。 :mailheader:`MIME-"
"Version` 標頭也將被新增。"

#: ../../library/email.mime.rst:89
#, fuzzy
msgid ""
"Optional *boundary* is the multipart boundary string.  When ``None`` (the "
"default), the boundary is calculated when needed (for example, when the "
"message is serialized)."
msgstr "可選的 *boundary* 是多部分邊界字串。當 ``None`` （預設值）時，邊界在需要時計算（例"
"如，當消息被序列化時）。"

#: ../../library/email.mime.rst:93
#, fuzzy
msgid ""
"*_subparts* is a sequence of initial subparts for the payload.  It must be "
"possible to convert this sequence to a list.  You can always attach new "
"subparts to the message by using the :meth:`Message.attach <email.message."
"Message.attach>` method."
msgstr ""
"*_subparts* 是有效負載的一系列初始子部分。必須可以將此序列轉換為列表。"
"您始終可以使用 Message.attach <email.message.Message.attach> "
"方法將新的子部分附加到消息中。"

#: ../../library/email.mime.rst:98 ../../library/email.mime.rst:131
#: ../../library/email.mime.rst:165 ../../library/email.mime.rst:200
#: ../../library/email.mime.rst:223 ../../library/email.mime.rst:254
#, fuzzy
msgid ""
"Optional *policy* argument defaults to :class:`compat32 <email.policy."
"Compat32>`."
msgstr "可選的 *policy* 參數預設為 :class:`compat32 <email.policy.Compat32>`。"

#: ../../library/email.mime.rst:100
#, fuzzy
msgid ""
"Additional parameters for the :mailheader:`Content-Type` header are taken "
"from the keyword arguments, or passed into the *_params* argument, which is "
"a keyword dictionary."
msgstr ":mailheader:`Content-Type` 標頭的其他參數取自關鍵字參數，或傳遞到 *_params* "
"參數，這是一個關鍵字字典。"

#: ../../library/email.mime.rst:113
msgid "Module: :mod:`email.mime.application`"
msgstr "模組：\\ :mod:`email.mime.application`"

#: ../../library/email.mime.rst:115
#, fuzzy
msgid ""
"A subclass of :class:`~email.mime.nonmultipart.MIMENonMultipart`, the :class:"
"`MIMEApplication` class is used to represent MIME message objects of major "
"type :mimetype:`application`.  *_data* contains the bytes for the raw "
"application data.  Optional *_subtype* specifies the MIME subtype and "
"defaults to :mimetype:`octet-stream`."
msgstr ""
":class:`~email.mime.nonmultipart.MIMENonMultipart` "
"的子類別，:class:`MIMEApplication` 類用於表示主要型別 :mimetype:`application`"
" 的 MIME 消息物件。 *_data* 包含原始應用程式資料的位元組。可選 *_subtype* "
"指定 MIME 子型別，預設為 :mimetype:`octet-stream`。"

#: ../../library/email.mime.rst:121
#, fuzzy
msgid ""
"Optional *_encoder* is a callable (i.e. function) which will perform the "
"actual encoding of the data for transport.  This callable takes one "
"argument, which is the :class:`MIMEApplication` instance. It should use :"
"meth:`~email.message.Message.get_payload` and :meth:`~email.message.Message."
"set_payload` to change the payload to encoded form.  It should also add any :"
"mailheader:`Content-Transfer-Encoding` or other headers to the message "
"object as necessary.  The default encoding is base64.  See the :mod:`email."
"encoders` module for a list of the built-in encoders."
msgstr ""
"可選的 *_encoder* 是一個可呼叫的（即函式），它將執行資料的實際編碼以進行傳輸"
"。這個可呼叫函式接受一個參數，即 :class:`MIMEApplication` 實例。它應該使用 "
":meth:`~email.message.Message.get_payload` 和 :meth:`~email.message.Message."
"set_payload` "
"將有效負載更改為編碼形式。它還應根據需要向消息物件新增任何:mailheader"
":`Content-Transfer-Encoding` 或其他標頭。預設編碼是 "
"base64。有關內建編碼器的列表，請參閱 :mod:`email.encoders` 模組。"

#: ../../library/email.mime.rst:133 ../../library/email.mime.rst:167
#, fuzzy
msgid "*_params* are passed straight through to the base class constructor."
msgstr "*_params* 直接傳遞給基底類別構造函式。"

#: ../../library/email.mime.rst:144
msgid "Module: :mod:`email.mime.audio`"
msgstr "模組：\\ :mod:`email.mime.audio`"

#: ../../library/email.mime.rst:146
#, fuzzy
msgid ""
"A subclass of :class:`~email.mime.nonmultipart.MIMENonMultipart`, the :class:"
"`MIMEAudio` class is used to create MIME message objects of major type :"
"mimetype:`audio`. *_audiodata* contains the bytes for the raw audio data.  "
"If this data can be decoded as au, wav, aiff, or aifc, then the subtype will "
"be automatically included in the :mailheader:`Content-Type` header. "
"Otherwise you can explicitly specify the audio subtype via the *_subtype* "
"argument.  If the minor type could not be guessed and *_subtype* was not "
"given, then :exc:`TypeError` is raised."
msgstr ""
":class:`~email.mime.nonmultipart.MIMENonMultipart` "
"的子類別，:class:`MIMEAudio` 類用於建立主要型別為 :mimetype:`audio` 的 MIME "
"消息物件。 *_audiodata* 包含原始音頻資料的位元組。如果此資料可以解碼為 "
"au、wav、aiff 或 aifc，則子型別將自動包含在 Content-Type 標頭中。否則，"
"您可以通過 *_subtype* 參數明確指定音頻子型別。如果無法猜測次要型別且未給出 "
"*_subtype*，則會引發 :exc:`TypeError`。"

#: ../../library/email.mime.rst:155
#, fuzzy
msgid ""
"Optional *_encoder* is a callable (i.e. function) which will perform the "
"actual encoding of the audio data for transport.  This callable takes one "
"argument, which is the :class:`MIMEAudio` instance. It should use :meth:"
"`~email.message.Message.get_payload` and :meth:`~email.message.Message."
"set_payload` to change the payload to encoded form.  It should also add any :"
"mailheader:`Content-Transfer-Encoding` or other headers to the message "
"object as necessary.  The default encoding is base64.  See the :mod:`email."
"encoders` module for a list of the built-in encoders."
msgstr ""
"可選的 *_encoder* 是一個可呼叫的（即函式），它將執行音頻資料的實際編碼以進行"
"傳輸。這個可呼叫函式接受一個參數，即 :class:`MIMEAudio` 實例。它應該使用 "
":meth:`~email.message.Message.get_payload` 和 :meth:`~email.message.Message."
"set_payload` "
"將有效負載更改為編碼形式。它還應根據需要向消息物件新增任何:mailheader"
":`Content-Transfer-Encoding` 或其他標頭。預設編碼是 "
"base64。有關內建編碼器的列表，請參閱 :mod:`email.encoders` 模組。"

#: ../../library/email.mime.rst:178
msgid "Module: :mod:`email.mime.image`"
msgstr "模組：\\ :mod:`email.mime.image`"

#: ../../library/email.mime.rst:180
#, fuzzy
msgid ""
"A subclass of :class:`~email.mime.nonmultipart.MIMENonMultipart`, the :class:"
"`MIMEImage` class is used to create MIME message objects of major type :"
"mimetype:`image`. *_imagedata* contains the bytes for the raw image data.  "
"If this data type can be detected (jpeg, png, gif, tiff, rgb, pbm, pgm, ppm, "
"rast, xbm, bmp, webp, and exr attempted), then the subtype will be "
"automatically included in the :mailheader:`Content-Type` header. Otherwise "
"you can explicitly specify the image subtype via the *_subtype* argument. If "
"the minor type could not be guessed and *_subtype* was not given, then :exc:"
"`TypeError` is raised."
msgstr ""
":class:`~email.mime.nonmultipart.MIMENonMultipart` "
"的子類別，:class:`MIMEImage` 類用於建立主要型別 :mimetype:`image` 的 MIME "
"消息物件。 *_imagedata* 包含原始圖像資料的位元組。如果可以檢測到此資料型別（"
"嘗試了 jpeg、png、gif、tiff、rgb、pbm、pgm、ppm、rast、xbm、bmp、webp 和 "
"exr），則子型別將自動包含在 :mailheader:` Content-Type 標頭。否則，"
"您可以通過 *_subtype* 參數明確指定圖像子型別。如果無法猜測次要型別且未給出 "
"*_subtype*，則會引發 :exc:`TypeError`。"

#: ../../library/email.mime.rst:190
#, fuzzy
msgid ""
"Optional *_encoder* is a callable (i.e. function) which will perform the "
"actual encoding of the image data for transport.  This callable takes one "
"argument, which is the :class:`MIMEImage` instance. It should use :meth:"
"`~email.message.Message.get_payload` and :meth:`~email.message.Message."
"set_payload` to change the payload to encoded form.  It should also add any :"
"mailheader:`Content-Transfer-Encoding` or other headers to the message "
"object as necessary.  The default encoding is base64.  See the :mod:`email."
"encoders` module for a list of the built-in encoders."
msgstr ""
"可選的 *_encoder* 是一個可呼叫的（即函式），它將執行圖像資料的實際編碼以進行"
"傳輸。這個可呼叫物件接受一個參數，即 :class:`MIMEImage` 實例。它應該使用 "
":meth:`~email.message.Message.get_payload` 和 :meth:`~email.message.Message."
"set_payload` "
"將有效負載更改為編碼形式。它還應根據需要向消息物件新增任何:mailheader"
":`Content-Transfer-Encoding` 或其他標頭。預設編碼是 "
"base64。有關內建編碼器的列表，請參閱 :mod:`email.encoders` 模組。"

#: ../../library/email.mime.rst:202
#, fuzzy
msgid ""
"*_params* are passed straight through to the :class:`~email.mime.base."
"MIMEBase` constructor."
msgstr "*_params* 直接傳遞給 :class:`~email.mime.base.MIMEBase` 構造函式。"

#: ../../library/email.mime.rst:212
msgid "Module: :mod:`email.mime.message`"
msgstr "模組：\\ :mod:`email.mime.message`"

#: ../../library/email.mime.rst:214
#, fuzzy
msgid ""
"A subclass of :class:`~email.mime.nonmultipart.MIMENonMultipart`, the :class:"
"`MIMEMessage` class is used to create MIME objects of main type :mimetype:"
"`message`. *_msg* is used as the payload, and must be an instance of class :"
"class:`~email.message.Message` (or a subclass thereof), otherwise a :exc:"
"`TypeError` is raised."
msgstr ""
":class:`~email.mime.nonmultipart.MIMENonMultipart` "
"的子類別，:class:`MIMEMessage` 類用於建立主要型別 :mimetype:`message` 的 "
"MIME 物件。 *_msg* 用作有效負載，並且必須是類 :class:`~email.message."
"Message`（或其子類別）的實例，否則會引發 :exc:`TypeError`。"

#: ../../library/email.mime.rst:220
#, fuzzy
msgid ""
"Optional *_subtype* sets the subtype of the message; it defaults to :"
"mimetype:`rfc822`."
msgstr "可選 *_subtype* 設定消息的子型別；它預設為 :mimetype:`rfc822`。"

#: ../../library/email.mime.rst:232
msgid "Module: :mod:`email.mime.text`"
msgstr "模組：\\ :mod:`email.mime.text`"

#: ../../library/email.mime.rst:234
#, fuzzy
msgid ""
"A subclass of :class:`~email.mime.nonmultipart.MIMENonMultipart`, the :class:"
"`MIMEText` class is used to create MIME objects of major type :mimetype:"
"`text`. *_text* is the string for the payload.  *_subtype* is the minor type "
"and defaults to :mimetype:`plain`.  *_charset* is the character set of the "
"text and is passed as an argument to the :class:`~email.mime.nonmultipart."
"MIMENonMultipart` constructor; it defaults to ``us-ascii`` if the string "
"contains only ``ascii`` code points, and ``utf-8`` otherwise.  The "
"*_charset* parameter accepts either a string or a :class:`~email.charset."
"Charset` instance."
msgstr ""
":class:`~email.mime.nonmultipart.MIMENonMultipart` "
"的子類別，:class:`MIMEText` 類用於建立主要型別 :mimetype:`text` 的 MIME "
"物件。 *_text* 是負載的字串。 *_subtype* 是次要型別，預設為 "
":mimetype:`plain`。 *_charset* 是文本的字元集，作為參數傳遞給 :class:`~email."
"mime.nonmultipart.MIMENonMultipart` 構造函式；如果字串僅包含 ``ascii`` "
"程式碼點，則預設為 ``us-ascii``，否則預設為 ``utf-8``。 *_charset* "
"參數接受字串或 :class:`~email.charset.Charset` 實例。"

#: ../../library/email.mime.rst:244
#, fuzzy
msgid ""
"Unless the *_charset* argument is explicitly set to ``None``, the MIMEText "
"object created will have both a :mailheader:`Content-Type` header with a "
"``charset`` parameter, and a :mailheader:`Content-Transfer-Encoding` "
"header.  This means that a subsequent ``set_payload`` call will not result "
"in an encoded payload, even if a charset is passed in the ``set_payload`` "
"command.  You can \"reset\" this behavior by deleting the ``Content-Transfer-"
"Encoding`` header, after which a ``set_payload`` call will automatically "
"encode the new payload (and add a new :mailheader:`Content-Transfer-"
"Encoding` header)."
msgstr ""
"除非 *_charset* 參數被顯式設定為 ``None``，否則建立的 MIMEText "
"物件將同時具有帶有 ``charset`` 參數的 Content-Type 標頭和 :mailheader:`Content- "
"Transfer-Encoding` 標頭。這意味著即使在 set_payload 命令中傳遞了字元集，"
"後續的 set_payload 呼叫也不會產生編碼的有效載荷。您可以通過刪除``Content-"
"Transfer-Encoding`` 標頭來“重置”此行為，之後呼叫``set_payload`` "
"將自動編碼新的有效負載（並新增新的 :mailheader:`Content-Transfer-Encoding ` "
"標題）。"

#: ../../library/email.mime.rst:256
#, fuzzy
msgid "*_charset* also accepts :class:`~email.charset.Charset` instances."
msgstr "*_charset* 也接受 :class:`~email.charset.Charset` 實例。"
