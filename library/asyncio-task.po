# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-25 00:20+0000\n"
"PO-Revision-Date: 2018-05-23 14:39+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-task.rst:6
#, fuzzy
msgid "Coroutines and Tasks"
msgstr "協程和任務"

#: ../../library/asyncio-task.rst:8
#, fuzzy
msgid ""
"This section outlines high-level asyncio APIs to work with coroutines and "
"Tasks."
msgstr "本節概述了用於協同程式和任務的高階非同步 API。"

#: ../../library/asyncio-task.rst:19 ../../library/asyncio-task.rst:148
msgid "Coroutines"
msgstr "協程"

#: ../../library/asyncio-task.rst:21
msgid "**Source code:** :source:`Lib/asyncio/coroutines.py`"
msgstr "**原始碼：**\\ :source:`Lib/asyncio/coroutines.py`"

#: ../../library/asyncio-task.rst:25
#, fuzzy
msgid ""
":term:`Coroutines <coroutine>` declared with the async/await syntax is the "
"preferred way of writing asyncio applications.  For example, the following "
"snippet of code prints \"hello\", waits 1 second, and then prints \"world\"::"
msgstr ""
":term:`Coroutines <coroutine>` 使用 async/await 語法聲明是編寫 asyncio "
"應用程式的首選方式。例如，以下程式碼片段印出 ``hello``，等待 1 "
"秒，然後印出 ``world``::"

#: ../../library/asyncio-task.rst:41
#, fuzzy
msgid ""
"Note that simply calling a coroutine will not schedule it to be executed::"
msgstr "請注意，簡單地呼叫協程不會安排它執行::"

#: ../../library/asyncio-task.rst:47
#, fuzzy
msgid "To actually run a coroutine, asyncio provides the following mechanisms:"
msgstr "為了實際運行協程，asyncio 提供了以下機制："

#: ../../library/asyncio-task.rst:49
#, fuzzy
msgid ""
"The :func:`asyncio.run` function to run the top-level entry point \"main()\" "
"function (see the above example.)"
msgstr ":func:`asyncio.run` 函式運行頂級入口點“main()”函式（參見上面的示例。）"

#: ../../library/asyncio-task.rst:52
#, fuzzy
msgid ""
"Awaiting on a coroutine.  The following snippet of code will print \"hello\" "
"after waiting for 1 second, and then print \"world\" after waiting for "
"*another* 2 seconds::"
msgstr "等待協程。以下程式碼片段將在等待 1 秒後印出 ``hello``，然後在等待 *another* 2 "
"秒後印出 ``world``::"

#: ../../library/asyncio-task.rst:73
#, fuzzy
msgid "Expected output::"
msgstr "預期輸出::"

#: ../../library/asyncio-task.rst:80
#, fuzzy
msgid ""
"The :func:`asyncio.create_task` function to run coroutines concurrently as "
"asyncio :class:`Tasks <Task>`."
msgstr ":func:`asyncio.create_task` 函式將協程作為 asyncio :class:`Tasks <Task>` "
"同時運行。"

#: ../../library/asyncio-task.rst:83
#, fuzzy
msgid ""
"Let's modify the above example and run two ``say_after`` coroutines "
"*concurrently*::"
msgstr "讓我們修改上面的示例並運行兩個 ``say_after`` 協程*並發*::"

#: ../../library/asyncio-task.rst:102
#, fuzzy
msgid ""
"Note that expected output now shows that the snippet runs 1 second faster "
"than before::"
msgstr "請注意，預期輸出現在顯示程式碼片段運行速度比以前快 1 秒::"

#: ../../library/asyncio-task.rst:110
#, fuzzy
msgid ""
"The :class:`asyncio.TaskGroup` class provides a more modern alternative to :"
"func:`create_task`. Using this API, the last example becomes::"
msgstr ""
":class:`asyncio.TaskGroup` 類為 :func:`create_task` "
"提供了一個更現代的替代方案。使用此 API，最後一個示例變為：："

#: ../../library/asyncio-task.rst:128
#, fuzzy
msgid "The timing and output should be the same as for the previous version."
msgstr "時間和輸出應該與以前的版本相同。"

#: ../../library/asyncio-task.rst:130
#, fuzzy
msgid ":class:`asyncio.TaskGroup`."
msgstr ":class:`asyncio.TaskGroup`。"

#: ../../library/asyncio-task.rst:137
#, fuzzy
msgid "Awaitables"
msgstr "等待物件"

#: ../../library/asyncio-task.rst:139
#, fuzzy
msgid ""
"We say that an object is an **awaitable** object if it can be used in an :"
"keyword:`await` expression.  Many asyncio APIs are designed to accept "
"awaitables."
msgstr ""
"如果一個物件可以在 :keyword:`await` 表達式中使用，我們就說它是一個 "
"**awaitable** 物件。許多 asyncio API 旨在接受可等待物件。"

#: ../../library/asyncio-task.rst:143
#, fuzzy
msgid ""
"There are three main types of *awaitable* objects: **coroutines**, "
"**Tasks**, and **Futures**."
msgstr "*awaitable* 物件主要分為三種型別：**coroutines**、**Tasks** 和**Futures**。"

#: ../../library/asyncio-task.rst:149
#, fuzzy
msgid ""
"Python coroutines are *awaitables* and therefore can be awaited from other "
"coroutines::"
msgstr "Python 協程是 *awaitables*，因此可以等待其他協程::"

#: ../../library/asyncio-task.rst:170
#, fuzzy
msgid ""
"In this documentation the term \"coroutine\" can be used for two closely "
"related concepts:"
msgstr "在本文檔中，術語“協程”可用於兩個密切相關的概念："

#: ../../library/asyncio-task.rst:173
#, fuzzy
msgid "a *coroutine function*: an :keyword:`async def` function;"
msgstr "*協程函式*：一個 :keyword:`async def` 函式；"

#: ../../library/asyncio-task.rst:175
#, fuzzy
msgid ""
"a *coroutine object*: an object returned by calling a *coroutine function*."
msgstr "*協程物件*：通過呼叫*協程函式*回傳的物件。"

#: ../../library/asyncio-task.rst:180
#, fuzzy
msgid "Tasks"
msgstr "任務"

#: ../../library/asyncio-task.rst:181
#, fuzzy
msgid "*Tasks* are used to schedule coroutines *concurrently*."
msgstr "*任務*用於*並發*安排協程。"

#: ../../library/asyncio-task.rst:183
#, fuzzy
msgid ""
"When a coroutine is wrapped into a *Task* with functions like :func:`asyncio."
"create_task` the coroutine is automatically scheduled to run soon::"
msgstr "當協程被包裝到一個*任務*中時，協程會自動安排運行，如 :func:`asyncio."
"create_task`"

#: ../../library/asyncio-task.rst:205
#, fuzzy
msgid "Futures"
msgstr "期貨"

#: ../../library/asyncio-task.rst:206
#, fuzzy
msgid ""
"A :class:`Future` is a special **low-level** awaitable object that "
"represents an **eventual result** of an asynchronous operation."
msgstr ":class:`Future` "
"是一個特殊的**低階**可等待物件，表示非同步操作的**最終結果**。"

#: ../../library/asyncio-task.rst:209
#, fuzzy
msgid ""
"When a Future object is *awaited* it means that the coroutine will wait "
"until the Future is resolved in some other place."
msgstr "當一個 Future 對像被 *awaited* 時，這意味著協程將等待直到 Future "
"在其他地方被解析。"

#: ../../library/asyncio-task.rst:212
#, fuzzy
msgid ""
"Future objects in asyncio are needed to allow callback-based code to be used "
"with async/await."
msgstr "asyncio 中的 Future 物件需要允許基於回呼的程式碼與 async/await 一起使用。"

#: ../../library/asyncio-task.rst:215
#, fuzzy
msgid ""
"Normally **there is no need** to create Future objects at the application "
"level code."
msgstr "通常**不需要**在應用程式級程式碼中建立 Future 物件。"

#: ../../library/asyncio-task.rst:218
#, fuzzy
msgid ""
"Future objects, sometimes exposed by libraries and some asyncio APIs, can be "
"awaited::"
msgstr "可以等待未來物件，有時由庫和一些非同步 API 公開："

#: ../../library/asyncio-task.rst:230
#, fuzzy
msgid ""
"A good example of a low-level function that returns a Future object is :meth:"
"`loop.run_in_executor`."
msgstr "回傳 Future 物件的低階函式的一個很好的例子是 :meth:`loop.run_in_executor`。"

#: ../../library/asyncio-task.rst:235
#, fuzzy
msgid "Creating Tasks"
msgstr "建立任務"

#: ../../library/asyncio-task.rst:237
msgid "**Source code:** :source:`Lib/asyncio/tasks.py`"
msgstr "**原始碼：**\\ :source:`Lib/asyncio/tasks.py`"

#: ../../library/asyncio-task.rst:243
#, fuzzy
msgid ""
"Wrap the *coro* :ref:`coroutine <coroutine>` into a :class:`Task` and "
"schedule its execution.  Return the Task object."
msgstr "將 *coro* :ref:`coroutine <coroutine>` 包裝到 :class:`Task` "
"中並安排其執行。回傳任務物件。"

#: ../../library/asyncio-task.rst:246
#, fuzzy
msgid ""
"If *name* is not ``None``, it is set as the name of the task using :meth:"
"`Task.set_name`."
msgstr "如果 *name* 不是 ``None``，則使用 Task.set_name 將其設定為任務的名稱。"

#: ../../library/asyncio-task.rst:249
#, fuzzy
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. The current context "
"copy is created when no *context* is provided."
msgstr ""
"一個可選的僅限關鍵字的 *context* 參數允許為 *coro* "
"指定一個自定義的 :class:`contextvars.Context` 在其中運行。"
"當前上下文副本在沒有提供 *context* 時建立。"

#: ../../library/asyncio-task.rst:253
#, fuzzy
msgid ""
"The task is executed in the loop returned by :func:`get_running_loop`, :exc:"
"`RuntimeError` is raised if there is no running loop in current thread."
msgstr ""
"該任務在 :func:`get_running_loop` "
"回傳的循環中執行，如果當前執行緒中沒有正在運行的循環，則會引發 "
":exc:`RuntimeError`。"

#: ../../library/asyncio-task.rst:259
#, fuzzy
msgid ""
":meth:`asyncio.TaskGroup.create_task` is a newer alternative that allows for "
"convenient waiting for a group of related tasks."
msgstr ":meth:`asyncio.TaskGroup.create_task` "
"是一種較新的替代方法，可以方便地等待一組相關任務。"

#: ../../library/asyncio-task.rst:264
#, fuzzy
msgid ""
"Save a reference to the result of this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done. For reliable \"fire-and-forget\" background "
"tasks, gather them in a collection::"
msgstr ""
"保存對此函式結果的引用，以避免任務在執行過程中消失。事件循環只保留對任務的弱"
"引用。未在其他地方引用的任務可能會在任何時候被垃圾收集，甚至在它完成之前。對"
"於可靠的“即發即棄”後台任務，將它們收集在一個集合中::"

#: ../../library/asyncio-task.rst:286 ../../library/asyncio-task.rst:1012
msgid "Added the *name* parameter."
msgstr "新增 *name* 參數。"

#: ../../library/asyncio-task.rst:289
msgid "Added the *context* parameter."
msgstr "新增 *context* 參數。"

#: ../../library/asyncio-task.rst:294
#, fuzzy
msgid "Task Cancellation"
msgstr "任務取消"

#: ../../library/asyncio-task.rst:296
#, fuzzy
msgid ""
"Tasks can easily and safely be cancelled. When a task is cancelled, :exc:"
"`asyncio.CancelledError` will be raised in the task at the next opportunity."
msgstr "可以輕鬆安全地取消任務。當任務被取消時， asyncio.CancelledError "
"將在下一次機會中在任務中引發。"

#: ../../library/asyncio-task.rst:300
#, fuzzy
msgid ""
"It is recommended that coroutines use ``try/finally`` blocks to robustly "
"perform clean-up logic. In case :exc:`asyncio.CancelledError` is explicitly "
"caught, it should generally be propagated when clean-up is complete. :exc:"
"`asyncio.CancelledError` directly subclasses :exc:`BaseException` so most "
"code will not need to be aware of it."
msgstr ""
"建議協程使用 ``try/finally`` 塊來穩健地執行清理邏輯。如果 :exc:`asyncio."
"CancelledError` 被顯式捕獲，通常應該在清理完成時傳播它。 :exc:`asyncio."
"CancelledError` 是 :exc:`BaseException` "
"的直接子類別，所以大多數程式碼不需要知道它。"

#: ../../library/asyncio-task.rst:306
#, fuzzy
msgid ""
"The asyncio components that enable structured concurrency, like :class:"
"`asyncio.TaskGroup` and :func:`asyncio.timeout`, are implemented using "
"cancellation internally and might misbehave if a coroutine swallows :exc:"
"`asyncio.CancelledError`. Similarly, user code should not generally call :"
"meth:`uncancel <asyncio.Task.uncancel>`. However, in cases when suppressing :"
"exc:`asyncio.CancelledError` is truly desired, it is necessary to also call "
"``uncancel()`` to completely remove the cancellation state."
msgstr ""
"啟用結構化並發的 asyncio 組件，如 :class:`asyncio.TaskGroup` 和 "
":func:`asyncio.timeout`，是在內部使用取消實作的，如果協程吞噬 :exc:`asyncio."
"CancelledError` 可能會出現例外。同樣，使用者程式碼通常不應呼叫 :meth:`"
"uncancel <asyncio.Task.uncancel>`。但是，在確實需要抑制 :exc:`asyncio."
"CancelledError` 的情況下，還需要呼叫 ``uncancel()`` 以完全刪除取消狀態。"

#: ../../library/asyncio-task.rst:318
#, fuzzy
msgid "Task Groups"
msgstr "任務組"

#: ../../library/asyncio-task.rst:320
#, fuzzy
msgid ""
"Task groups combine a task creation API with a convenient and reliable way "
"to wait for all tasks in the group to finish."
msgstr "任務組將任務建立 API 與方便可靠的方式相結合，以等待組中的所有任務完成。"

#: ../../library/asyncio-task.rst:325
#, fuzzy
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` holding a "
"group of tasks. Tasks can be added to the group using :meth:`create_task`. "
"All tasks are awaited when the context manager exits."
msgstr ""
"一個 :ref:`非同步上下文管理器 <async-context-managers>` 持有一組任務。"
"可以使用 create_task 將任務新增到組中。當上下文管理器退出時，等待所有任務。"

#: ../../library/asyncio-task.rst:334
#, fuzzy
msgid ""
"Create a task in this task group. The signature matches that of :func:"
"`asyncio.create_task`."
msgstr "在此任務組中建立任務。簽名與 :func:`asyncio.create_task` 的簽名匹配。"

#: ../../library/asyncio-task.rst:337 ../../library/asyncio-task.rst:467
#: ../../library/asyncio-task.rst:595 ../../library/asyncio-task.rst:653
#: ../../library/asyncio-task.rst:679 ../../library/asyncio-task.rst:722
#: ../../library/asyncio-task.rst:816
msgid "Example::"
msgstr ""
"範例：\n"
"\n"
"::"

#: ../../library/asyncio-task.rst:345
#, fuzzy
msgid ""
"The ``async with`` statement will wait for all tasks in the group to finish. "
"While waiting, new tasks may still be added to the group (for example, by "
"passing ``tg`` into one of the coroutines and calling ``tg.create_task()`` "
"in that coroutine). Once the last task has finished and the ``async with`` "
"block is exited, no new tasks may be added to the group."
msgstr ""
"``async with`` "
"語句將等待組中的所有任務完成。在等待期間，新任務可能仍會新增到組中（例如，"
"通過將 ``tg`` 傳遞到其中一個協程並在該協程中呼叫 ``tg.create_task()``）。"
"一旦最後一個任務完成並退出 ``async with`` 塊，就不能向組中新增新任務。"

#: ../../library/asyncio-task.rst:352
#, fuzzy
msgid ""
"The first time any of the tasks belonging to the group fails with an "
"exception other than :exc:`asyncio.CancelledError`, the remaining tasks in "
"the group are cancelled. No further tasks can then be added to the group. At "
"this point, if the body of the ``async with`` statement is still active (i."
"e., :meth:`~object.__aexit__` hasn't been called yet), the task directly "
"containing the ``async with`` statement is also cancelled. The resulting :"
"exc:`asyncio.CancelledError` will interrupt an ``await``, but it will not "
"bubble out of the containing ``async with`` statement."
msgstr ""
"屬於該組的任何任務第一次失敗並出現除 :exc:`asyncio.CancelledError` "
"以外的例外時，該組中的其餘任務將被取消。然後不能向該組新增更多任務。此時，"
"如果 ``async with`` 語句的主體仍然處於活動狀態（即 :meth:`~object.__aexit__` "
"尚未被呼叫），則直接包含 ``async with`` "
"的任務聲明也被取消。結果 :exec:`asyncio.CancelledError` 將中斷 ``await``，"
"但它不會從包含的 ``async with`` 語句中冒出。"

#: ../../library/asyncio-task.rst:362
#, fuzzy
msgid ""
"Once all tasks have finished, if any tasks have failed with an exception "
"other than :exc:`asyncio.CancelledError`, those exceptions are combined in "
"an :exc:`ExceptionGroup` or :exc:`BaseExceptionGroup` (as appropriate; see "
"their documentation) which is then raised."
msgstr ""
"所有任務完成後，如果任何任務因 :exc:`asyncio.CancelledError` "
"以外的例外而失敗，則這些例外將合併到 :exc:`ExceptionGroup` 或 "
":exc:`BaseExceptionGroup`（視情況而定；請參閱它們的文件），然後提出。"

#: ../../library/asyncio-task.rst:369
#, fuzzy
msgid ""
"Two base exceptions are treated specially: If any task fails with :exc:"
"`KeyboardInterrupt` or :exc:`SystemExit`, the task group still cancels the "
"remaining tasks and waits for them, but then the initial :exc:"
"`KeyboardInterrupt` or :exc:`SystemExit` is re-raised instead of :exc:"
"`ExceptionGroup` or :exc:`BaseExceptionGroup`."
msgstr ""
"兩個基本例外被特殊處理：如果任何任務因 :exc:`KeyboardInterrupt` 或 "
":exc:`SystemExit` 失敗，任務組仍會取消剩餘的任務並等待它們，但隨後初始的 "
":exc:`KeyboardInterrupt` 或 :exc:`SystemExit` 被重新引發，而不是 "
":exc:`ExceptionGroup` 或 :exc:`BaseExceptionGroup`。"

#: ../../library/asyncio-task.rst:375
#, fuzzy
msgid ""
"If the body of the ``async with`` statement exits with an exception (so :"
"meth:`~object.__aexit__` is called with an exception set), this is treated "
"the same as if one of the tasks failed: the remaining tasks are cancelled "
"and then waited for, and non-cancellation exceptions are grouped into an "
"exception group and raised. The exception passed into :meth:`~object."
"__aexit__`, unless it is :exc:`asyncio.CancelledError`, is also included in "
"the exception group. The same special case is made for :exc:"
"`KeyboardInterrupt` and :exc:`SystemExit` as in the previous paragraph."
msgstr ""
"如果 ``async with`` 語句的主體例外退出（因此呼叫 :meth:`~object.__aexit__` 時"
"設定了例外），這將被視為與其中一項任務失敗相同：剩餘的任務被取消然後等待，非"
"取消例外被分組到一個例外組中並被引發。傳入 :meth:`~object.__aexit__` 的例外，"
"除非是 :exc:`asyncio.CancelledError`，也包含在例外組中。與上一段中的 "
":exc:`KeyboardInterrupt` 和 :exc:`SystemExit` 相同的特殊情況。"

#: ../../library/asyncio-task.rst:389
#, fuzzy
msgid "Sleeping"
msgstr "睡眠"

#: ../../library/asyncio-task.rst:393
#, fuzzy
msgid "Block for *delay* seconds."
msgstr "阻塞 *delay* 秒。"

#: ../../library/asyncio-task.rst:395
#, fuzzy
msgid ""
"If *result* is provided, it is returned to the caller when the coroutine "
"completes."
msgstr "如果提供了 *result* ，它會在協程完成時回傳給呼叫者。"

#: ../../library/asyncio-task.rst:398
#, fuzzy
msgid ""
"``sleep()`` always suspends the current task, allowing other tasks to run."
msgstr "``sleep()`` 總是暫停當前任務，允許其他任務運行。"

#: ../../library/asyncio-task.rst:401
#, fuzzy
msgid ""
"Setting the delay to 0 provides an optimized path to allow other tasks to "
"run. This can be used by long-running functions to avoid blocking the event "
"loop for the full duration of the function call."
msgstr "將延遲設定為 0 可提供最佳化路徑以允許其他任務運行。長時間運行的函式可以使用它"
"來避免在函式呼叫的整個過程中阻塞事件循環。"

#: ../../library/asyncio-task.rst:407
#, fuzzy
msgid ""
"Example of coroutine displaying the current date every second for 5 seconds::"
msgstr "協程示例，每秒顯示當前日期，持續 5 秒："

#: ../../library/asyncio-task.rst:425 ../../library/asyncio-task.rst:516
#: ../../library/asyncio-task.rst:570 ../../library/asyncio-task.rst:717
#: ../../library/asyncio-task.rst:747 ../../library/asyncio-task.rst:799
#: ../../library/asyncio-task.rst:822
msgid "Removed the *loop* parameter."
msgstr "移除 *loop* 參數。"

#: ../../library/asyncio-task.rst:430
#, fuzzy
msgid "Running Tasks Concurrently"
msgstr "同時運行任務"

#: ../../library/asyncio-task.rst:434
#, fuzzy
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* sequence "
"*concurrently*."
msgstr ""
"在 *aws* 序列 *concurrently* 中運行 :ref:`awaitable objects <asyncio-"
"awaitables>`。"

#: ../../library/asyncio-task.rst:437
#, fuzzy
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task."
msgstr "如果 *aws* 中的任何 awaitable 是協程，它會自動安排為任務。"

#: ../../library/asyncio-task.rst:440
#, fuzzy
msgid ""
"If all awaitables are completed successfully, the result is an aggregate "
"list of returned values.  The order of result values corresponds to the "
"order of awaitables in *aws*."
msgstr "如果所有可等待對像都成功完成，則結果是回傳值的聚合列表。結果值的順序對應於 "
"*aws* 中可等待物件的順序。"

#: ../../library/asyncio-task.rst:444
#, fuzzy
msgid ""
"If *return_exceptions* is ``False`` (default), the first raised exception is "
"immediately propagated to the task that awaits on ``gather()``.  Other "
"awaitables in the *aws* sequence **won't be cancelled** and will continue to "
"run."
msgstr ""
"如果 *return_exceptions* 為 ``False``（預設），"
"第一個引發的例外會立即傳播到等待 ``gather()`` 的任務。 *aws* "
"序列中的其他可等待物件**不會被取消**並將繼續運行。"

#: ../../library/asyncio-task.rst:449
#, fuzzy
msgid ""
"If *return_exceptions* is ``True``, exceptions are treated the same as "
"successful results, and aggregated in the result list."
msgstr "如果 *return_exceptions* 為 "
"``True``，則將例外視為成功結果，並彙總到結果列表中。"

#: ../../library/asyncio-task.rst:452
#, fuzzy
msgid ""
"If ``gather()`` is *cancelled*, all submitted awaitables (that have not "
"completed yet) are also *cancelled*."
msgstr "如果``gather()``被*取消*，所有提交的可等待物件（尚未完成）也將被*取消*。"

#: ../../library/asyncio-task.rst:455
#, fuzzy
msgid ""
"If any Task or Future from the *aws* sequence is *cancelled*, it is treated "
"as if it raised :exc:`CancelledError` -- the ``gather()`` call is **not** "
"cancelled in this case.  This is to prevent the cancellation of one "
"submitted Task/Future to cause other Tasks/Futures to be cancelled."
msgstr ""
"如果 *aws* 序列中的任何 Task 或 Future 被*取消*，它被視為引發了 "
":exc:`CancelledError` —— 在這種情況下，``gather()`` 呼叫**未**被取消."
"這是為了防止取消一個已提交的任務/未來導致其他任務/未來被取消。"

#: ../../library/asyncio-task.rst:462
#, fuzzy
msgid ""
"A more modern way to create and run tasks concurrently and wait for their "
"completion is :class:`asyncio.TaskGroup`."
msgstr "一種更現代的並發建立和運行任務並等待它們完成的方法是 :class:`asyncio."
"TaskGroup`。"

#: ../../library/asyncio-task.rst:505
#, fuzzy
msgid ""
"If *return_exceptions* is False, cancelling gather() after it has been "
"marked done won't cancel any submitted awaitables. For instance, gather can "
"be marked done after propagating an exception to the caller, therefore, "
"calling ``gather.cancel()`` after catching an exception (raised by one of "
"the awaitables) from gather won't cancel any other awaitables."
msgstr ""
"如果 *return_exceptions* 為 False，則在標記完成後取消 gather() "
"不會取消任何已提交的可等待物件。例如，可以在向呼叫者傳播例外後將 gather "
"標記為完成，因此，在從 gather "
"捕獲例外（由其中一個可等待物件引發）後呼叫“gather."
"cancel()”不會取消任何其他可等待物件。"

#: ../../library/asyncio-task.rst:512
#, fuzzy
msgid ""
"If the *gather* itself is cancelled, the cancellation is propagated "
"regardless of *return_exceptions*."
msgstr "如果 *gather* 本身被取消，則不管 *return_exceptions* 都會傳播取消。"

#: ../../library/asyncio-task.rst:519
#, fuzzy
msgid ""
"Deprecation warning is emitted if no positional arguments are provided or "
"not all positional arguments are Future-like objects and there is no running "
"event loop."
msgstr "如果沒有提供位置參數或併非所有位置參數都是類似 Future "
"的物件並且沒有運行的事件循環，則會發出棄用警告。"

#: ../../library/asyncio-task.rst:526
#, fuzzy
msgid "Shielding From Cancellation"
msgstr "避免取消"

#: ../../library/asyncio-task.rst:530
#, fuzzy
msgid ""
"Protect an :ref:`awaitable object <asyncio-awaitables>` from being :meth:"
"`cancelled <Task.cancel>`."
msgstr "保護 :ref:`awaitable 物件 <asyncio-awaitables>` 免於被取消 <Task.cancel>`。"

#: ../../library/asyncio-task.rst:533 ../../library/asyncio-task.rst:699
#, fuzzy
msgid "If *aw* is a coroutine it is automatically scheduled as a Task."
msgstr "如果 *aw* 是協程，它會自動安排為任務。"

#: ../../library/asyncio-task.rst:535
#, fuzzy
msgid "The statement::"
msgstr "該聲明：："

#: ../../library/asyncio-task.rst:540
#, fuzzy
msgid "is equivalent to::"
msgstr "相當於：："

#: ../../library/asyncio-task.rst:544
#, fuzzy
msgid ""
"*except* that if the coroutine containing it is cancelled, the Task running "
"in ``something()`` is not cancelled.  From the point of view of "
"``something()``, the cancellation did not happen. Although its caller is "
"still cancelled, so the \"await\" expression still raises a :exc:"
"`CancelledError`."
msgstr ""
"*除了*如果包含它的協程被取消，則在 ``something()`` 中運行的任務不會被取消。"
"從 ``something()`` 的角度來看，取消並沒有發生。儘管它的呼叫者仍然被取消，所以"
" ``await``表達式仍然引發一個 :exc:`CancelledError`。"

#: ../../library/asyncio-task.rst:550
#, fuzzy
msgid ""
"If ``something()`` is cancelled by other means (i.e. from within itself) "
"that would also cancel ``shield()``."
msgstr "如果 ``something()`` 被其他方式（即從其自身內部）取消，那也會取消 "
"``shield()``。"

#: ../../library/asyncio-task.rst:553
#, fuzzy
msgid ""
"If it is desired to completely ignore cancellation (not recommended) the "
"``shield()`` function should be combined with a try/except clause, as "
"follows::"
msgstr "如果希望完全忽略取消（不推薦），``shield()`` 函式應該與 try/except "
"子句結合使用，如下所示："

#: ../../library/asyncio-task.rst:565
#, fuzzy
msgid ""
"Save a reference to tasks passed to this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done."
msgstr ""
"保存對傳遞給此函式的任務的引用，以避免任務在執行過程中消失。事件循環只保留對"
"任務的弱引用。未在其他地方引用的任務可能會在任何時候被垃圾收集，甚至在它完成"
"之前。"

#: ../../library/asyncio-task.rst:573
#, fuzzy
msgid ""
"Deprecation warning is emitted if *aw* is not Future-like object and there "
"is no running event loop."
msgstr "如果 *aw* 不是 Future-like 物件並且沒有正在運行的事件循環，則會發出棄用警告。"

#: ../../library/asyncio-task.rst:579
#, fuzzy
msgid "Timeouts"
msgstr "超時"

#: ../../library/asyncio-task.rst:583
#, fuzzy
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` that can be "
"used to limit the amount of time spent waiting on something."
msgstr "一個 :ref:`非同步上下文管理器 <async-context-"
"managers>`，可用於限制等待某事所花費的時間。"

#: ../../library/asyncio-task.rst:587
#, fuzzy
msgid ""
"*delay* can either be ``None``, or a float/int number of seconds to wait. If "
"*delay* is ``None``, no time limit will be applied; this can be useful if "
"the delay is unknown when the context manager is created."
msgstr ""
"*delay* 可以是 ``None`` ，也可以是等待的浮點數/整數秒數。如果 *delay* 為``None``，"
"則不會應用時間限制；如果在建立上下文管理器時延遲未知，這將很有用。"

#: ../../library/asyncio-task.rst:592
#, fuzzy
msgid ""
"In either case, the context manager can be rescheduled after creation using :"
"meth:`Timeout.reschedule`."
msgstr "在任何一種情況下，上下文管理器都可以在建立後使用 Timeout.reschedule "
"重新安排。"

#: ../../library/asyncio-task.rst:601
#, fuzzy
msgid ""
"If ``long_running_task`` takes more than 10 seconds to complete, the context "
"manager will cancel the current task and handle the resulting :exc:`asyncio."
"CancelledError` internally, transforming it into an :exc:`asyncio."
"TimeoutError` which can be caught and handled."
msgstr ""
"如果 ``long_running_task`` 需要超過 10 "
"秒才能完成，上下文管理器將取消當前任務並在內部處理結果 :exec:`asyncio."
"CancelledError`，將其轉換為 :exc:`asyncio.TimeoutError` 可以被抓住和處理。"

#: ../../library/asyncio-task.rst:608
#, fuzzy
msgid ""
"The :func:`asyncio.timeout` context manager is what transforms the :exc:"
"`asyncio.CancelledError` into an :exc:`asyncio.TimeoutError`, which means "
"the :exc:`asyncio.TimeoutError` can only be caught *outside* of the context "
"manager."
msgstr ""
":func:`asyncio.timeout` 上下文管理器將 :exc:`asyncio.CancelledError` 轉換為 "
":exc:`asyncio.TimeoutError`，這意味著 :exc:`asyncio.TimeoutError` 只能被捕獲 "
"*在上下文管理器之外*。"

#: ../../library/asyncio-task.rst:613
#, fuzzy
msgid "Example of catching :exc:`asyncio.TimeoutError`::"
msgstr "捕獲 :exc:`asyncio.TimeoutError`:: 的例子"

#: ../../library/asyncio-task.rst:624
#, fuzzy
msgid ""
"The context manager produced by :func:`asyncio.timeout` can be rescheduled "
"to a different deadline and inspected."
msgstr "asyncio.timeout 生成的上下文管理器可以重新安排到不同的截止日期並進行檢查。"

#: ../../library/asyncio-task.rst:629
#, fuzzy
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` for "
"cancelling overdue coroutines."
msgstr "用於取消過期協程的 :ref:`非同步上下文管理器 <async-context-managers>`。"

#: ../../library/asyncio-task.rst:632
#, fuzzy
msgid ""
"``when`` should be an absolute time at which the context should time out, as "
"measured by the event loop's clock:"
msgstr "``when`` 應該是上下文應該超時的絕對時間，由事件循環的時鐘測量："

#: ../../library/asyncio-task.rst:635
#, fuzzy
msgid "If ``when`` is ``None``, the timeout will never trigger."
msgstr "如果``when`` 為``None``，則永遠不會觸發超時。"

#: ../../library/asyncio-task.rst:636
#, fuzzy
msgid ""
"If ``when < loop.time()``, the timeout will trigger on the next iteration of "
"the event loop."
msgstr "如果``when < loop.time()``，超時將在事件循環的下一次疊代中觸發。"

#: ../../library/asyncio-task.rst:641
#, fuzzy
msgid ""
"Return the current deadline, or ``None`` if the current deadline is not set."
msgstr "回傳當前截止日期，如果未設定當前截止日期，則回傳 ``None``。"

#: ../../library/asyncio-task.rst:646
#, fuzzy
msgid "Reschedule the timeout."
msgstr "重新安排超時。"

#: ../../library/asyncio-task.rst:650
#, fuzzy
msgid "Return whether the context manager has exceeded its deadline (expired)."
msgstr "回傳上下文管理器是否已超過其截止日期（已過期）。"

#: ../../library/asyncio-task.rst:670
#, fuzzy
msgid "Timeout context managers can be safely nested."
msgstr "超時上下文管理器可以安全地嵌套。"

#: ../../library/asyncio-task.rst:676
#, fuzzy
msgid ""
"Similar to :func:`asyncio.timeout`, except *when* is the absolute time to "
"stop waiting, or ``None``."
msgstr "與 :func:`asyncio.timeout` 類似，除了 *when* 是停止等待的絕對時間，或 "
"``None``。"

#: ../../library/asyncio-task.rst:696
#, fuzzy
msgid ""
"Wait for the *aw* :ref:`awaitable <asyncio-awaitables>` to complete with a "
"timeout."
msgstr "等待 *aw* :ref:`awaitable <asyncio-awaitables>` 超時完成。"

#: ../../library/asyncio-task.rst:701
#, fuzzy
msgid ""
"*timeout* can either be ``None`` or a float or int number of seconds to wait "
"for.  If *timeout* is ``None``, block until the future completes."
msgstr "*timeout* 可以是 ``None`` 或浮點數或等待的秒數。如果 *timeout* "
"是``None``，阻塞直到未來完成。"

#: ../../library/asyncio-task.rst:705
#, fuzzy
msgid ""
"If a timeout occurs, it cancels the task and raises :exc:`TimeoutError`."
msgstr "如果發生超時，它會取消任務並引發 :exc:`TimeoutError`。"

#: ../../library/asyncio-task.rst:708
#, fuzzy
msgid ""
"To avoid the task :meth:`cancellation <Task.cancel>`, wrap it in :func:"
"`shield`."
msgstr "要避免任務取消 <Task.cancel>，請將其包裝在屏蔽中。"

#: ../../library/asyncio-task.rst:711
#, fuzzy
msgid ""
"The function will wait until the future is actually cancelled, so the total "
"wait time may exceed the *timeout*. If an exception happens during "
"cancellation, it is propagated."
msgstr "該函式將等到 future 被實際取消，因此總等待時間可能會超過 "
"*timeout*。如果在取消期間發生例外，則會傳播該例外。"

#: ../../library/asyncio-task.rst:715
#, fuzzy
msgid "If the wait is cancelled, the future *aw* is also cancelled."
msgstr "如果等待被取消，未來的 *aw* 也會被取消。"

#: ../../library/asyncio-task.rst:742
#, fuzzy
msgid ""
"When *aw* is cancelled due to a timeout, ``wait_for`` waits for *aw* to be "
"cancelled.  Previously, it raised :exc:`TimeoutError` immediately."
msgstr ""
"當 *aw* 由於超時而被取消時，``wait_for`` 等待 *aw* 被取消。以前，"
"它會立即引發 :exc:`TimeoutError`。"

#: ../../library/asyncio-task.rst:752
#, fuzzy
msgid "Waiting Primitives"
msgstr "等待原語"

#: ../../library/asyncio-task.rst:756
#, fuzzy
msgid ""
"Run :class:`~asyncio.Future` and :class:`~asyncio.Task` instances in the "
"*aws* iterable concurrently and block until the condition specified by "
"*return_when*."
msgstr ""
"在 *aws* 可疊代對像中同時運行 :class:`~asyncio.Future` 和 :class:`~asyncio."
"Task` 實例，並阻塞直到達到 *return_when* 指定的條件。"

#: ../../library/asyncio-task.rst:760
#, fuzzy
msgid ""
"The *aws* iterable must not be empty and generators yielding tasks are not "
"accepted."
msgstr "*aws* 可疊代對像不能為空，生成任務的生成器不被接受。"

#: ../../library/asyncio-task.rst:762
#, fuzzy
msgid "Returns two sets of Tasks/Futures: ``(done, pending)``."
msgstr "回傳兩組任務/未來：``（完成，待定）``。"

#: ../../library/asyncio-task.rst:764
msgid "Usage::"
msgstr ""
"用法：\n"
"\n"
"::"

#: ../../library/asyncio-task.rst:768
#, fuzzy
msgid ""
"*timeout* (a float or int), if specified, can be used to control the maximum "
"number of seconds to wait before returning."
msgstr "*timeout*（浮點數或整數），如果指定，可用於控制回傳前等待的最大秒數。"

#: ../../library/asyncio-task.rst:771
#, fuzzy
msgid ""
"Note that this function does not raise :exc:`TimeoutError`. Futures or Tasks "
"that aren't done when the timeout occurs are simply returned in the second "
"set."
msgstr "請注意，此函式不會引發 :exc:`TimeoutError`。超時發生時未完成的 Futures 或 "
"Tasks 僅在第二組中回傳。"

#: ../../library/asyncio-task.rst:775
#, fuzzy
msgid ""
"*return_when* indicates when this function should return.  It must be one of "
"the following constants:"
msgstr "*return_when* 指示此函式應回傳的時間。它必須是以下常數之一："

#: ../../library/asyncio-task.rst:781
msgid "Constant"
msgstr "常數"

#: ../../library/asyncio-task.rst:781
msgid "Description"
msgstr "描述"

#: ../../library/asyncio-task.rst:783
msgid ":const:`FIRST_COMPLETED`"
msgstr ":const:`FIRST_COMPLETED`"

#: ../../library/asyncio-task.rst:783
#, fuzzy
msgid "The function will return when any future finishes or is cancelled."
msgstr "當任何 future 完成或被取消時，該函式將回傳。"

#: ../../library/asyncio-task.rst:786
msgid ":const:`FIRST_EXCEPTION`"
msgstr ":const:`FIRST_EXCEPTION`"

#: ../../library/asyncio-task.rst:786
#, fuzzy
msgid ""
"The function will return when any future finishes by raising an exception.  "
"If no future raises an exception then it is equivalent to :const:"
"`ALL_COMPLETED`."
msgstr "當任何未來通過引發例外完成時，該函式將回傳。如果未來沒有引發例外，"
"那麼它等同於 :const:`ALL_COMPLETED`。"

#: ../../library/asyncio-task.rst:792
msgid ":const:`ALL_COMPLETED`"
msgstr ":const:`ALL_COMPLETED`"

#: ../../library/asyncio-task.rst:792
#, fuzzy
msgid "The function will return when all futures finish or are cancelled."
msgstr "當所有期貨完成或被取消時，該函式將回傳。"

#: ../../library/asyncio-task.rst:796
#, fuzzy
msgid ""
"Unlike :func:`~asyncio.wait_for`, ``wait()`` does not cancel the futures "
"when a timeout occurs."
msgstr "與 :func:`~asyncio.wait_for` 不同，``wait()`` 不會在超時發生時取消期貨。"

#: ../../library/asyncio-task.rst:802
#, fuzzy
msgid "Passing coroutine objects to ``wait()`` directly is forbidden."
msgstr "禁止將協程物件直接傳遞給 ``wait()``。"

#: ../../library/asyncio-task.rst:807
#, fuzzy
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* iterable "
"concurrently. Generators yielding tasks are not accepted as *aws* iterable. "
"Return an iterator of coroutines. Each coroutine returned can be awaited to "
"get the earliest next result from the iterable of the remaining awaitables."
msgstr ""
"在 *aws* 可疊代對像中同時運行 :ref:`awaitable objects <asyncio-awaitables>`。"
"產生任務的生成器不被接受為 *aws* 可疊代。回傳協同程式的疊代器。可以等待回傳的"
"每個協程，以從剩餘可等待物件的可疊代對像中獲得最早的下一個結果。"

#: ../../library/asyncio-task.rst:813
#, fuzzy
msgid ""
"Raises :exc:`TimeoutError` if the timeout occurs before all Futures are done."
msgstr "如果在所有 Futures 完成之前發生超時，則引發 :exc:`TimeoutError`。"

#: ../../library/asyncio-task.rst:825
#, fuzzy
msgid ""
"Deprecation warning is emitted if not all awaitable objects in the *aws* "
"iterable are Future-like objects and there is no running event loop."
msgstr "如果並非 *aws* 可疊代對像中的所有可等待對像都是 Future-like "
"物件並且沒有正在運行的事件循環，則會發出棄用警告。"

#: ../../library/asyncio-task.rst:831
#, fuzzy
msgid "Running in Threads"
msgstr "在執行緒中運行"

#: ../../library/asyncio-task.rst:835
#, fuzzy
msgid "Asynchronously run function *func* in a separate thread."
msgstr "在單獨的執行緒中非同步運行函式 *func*。"

#: ../../library/asyncio-task.rst:837
#, fuzzy
msgid ""
"Any \\*args and \\*\\*kwargs supplied for this function are directly passed "
"to *func*. Also, the current :class:`contextvars.Context` is propagated, "
"allowing context variables from the event loop thread to be accessed in the "
"separate thread."
msgstr ""
"為此函式提供的任何 \\*args 和 \\*\\*kwargs 都直接傳遞給 *func*。此外，當前的 "
":class:`contextvars.Context` "
"被傳播，允許在單獨的執行緒中訪問來自事件循環執行緒的上下文變數。"

#: ../../library/asyncio-task.rst:842
#, fuzzy
msgid ""
"Return a coroutine that can be awaited to get the eventual result of *func*."
msgstr "回傳一個協程，可以等待它獲得 *func* 的最終結果。"

#: ../../library/asyncio-task.rst:844
#, fuzzy
msgid ""
"This coroutine function is primarily intended to be used for executing IO-"
"bound functions/methods that would otherwise block the event loop if they "
"were run in the main thread. For example::"
msgstr "此協程函式主要用於執行 IO "
"綁定函式/方法，如果它們在主執行緒中運行，否則會阻塞事件循環。例如：："

#: ../../library/asyncio-task.rst:874
#, fuzzy
msgid ""
"Directly calling ``blocking_io()`` in any coroutine would block the event "
"loop for its duration, resulting in an additional 1 second of run time. "
"Instead, by using ``asyncio.to_thread()``, we can run it in a separate "
"thread without blocking the event loop."
msgstr ""
"在任何協程中直接呼叫 ``blocking_io()`` 都會在其持續時間內阻塞事件循環，"
"從而導致額外的 1 秒運行時間。相反，通過使用 ``asyncio."
"to_thread()``，我們可以在一個單獨的執行緒中運行它而不會阻塞事件循環。"

#: ../../library/asyncio-task.rst:881
#, fuzzy
msgid ""
"Due to the :term:`GIL`, ``asyncio.to_thread()`` can typically only be used "
"to make IO-bound functions non-blocking. However, for extension modules that "
"release the GIL or alternative Python implementations that don't have one, "
"``asyncio.to_thread()`` can also be used for CPU-bound functions."
msgstr ""
"由於 :term:`GIL`，``asyncio.to_thread()`` 通常只能用於使 IO "
"綁定函式成為非阻塞的。但是，對於發布 GIL 的擴充模組或沒有 GIL 的替代 Python "
"實作，``asyncio.to_thread()`` 也可用於 CPU 綁定函式。"

#: ../../library/asyncio-task.rst:890
#, fuzzy
msgid "Scheduling From Other Threads"
msgstr "從其他執行緒調度"

#: ../../library/asyncio-task.rst:894
#, fuzzy
msgid "Submit a coroutine to the given event loop.  Thread-safe."
msgstr "將協程提交給給定的事件循環。執行緒安全的。"

#: ../../library/asyncio-task.rst:896
#, fuzzy
msgid ""
"Return a :class:`concurrent.futures.Future` to wait for the result from "
"another OS thread."
msgstr "回傳 :class:`concurrent.futures.Future` "
"以等待來自另一個操作系統執行緒的結果。"

#: ../../library/asyncio-task.rst:899
#, fuzzy
msgid ""
"This function is meant to be called from a different OS thread than the one "
"where the event loop is running.  Example::"
msgstr "此函式旨在從與運行事件循環的執行緒不同的操作系統執行緒中呼叫。例子：："

#: ../../library/asyncio-task.rst:911
#, fuzzy
msgid ""
"If an exception is raised in the coroutine, the returned Future will be "
"notified.  It can also be used to cancel the task in the event loop::"
msgstr "如果在協程中引發例外，將通知回傳的 Future。它還可以用於取消事件循環中的任務::"

#: ../../library/asyncio-task.rst:925
#, fuzzy
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr "請參閱文檔的 :ref:`並發和多執行緒 <asyncio-multithreading>` 部分。"

#: ../../library/asyncio-task.rst:928
#, fuzzy
msgid ""
"Unlike other asyncio functions this function requires the *loop* argument to "
"be passed explicitly."
msgstr "與其他非同步函式不同，此函式需要顯式傳遞 *loop* 參數。"

#: ../../library/asyncio-task.rst:935
#, fuzzy
msgid "Introspection"
msgstr "內省"

#: ../../library/asyncio-task.rst:940
#, fuzzy
msgid ""
"Return the currently running :class:`Task` instance, or ``None`` if no task "
"is running."
msgstr "回傳當前運行的 :class:`Task` 實例，如果沒有任務正在運行，則回傳 ``None``。"

#: ../../library/asyncio-task.rst:943
#, fuzzy
msgid ""
"If *loop* is ``None`` :func:`get_running_loop` is used to get the current "
"loop."
msgstr "如果 *loop* 為 ``None`` :func:`get_running_loop` 用於獲取當前循環。"

#: ../../library/asyncio-task.rst:951
#, fuzzy
msgid "Return a set of not yet finished :class:`Task` objects run by the loop."
msgstr "回傳循環運行的一組尚未完成的 :class:`Task` 物件。"

#: ../../library/asyncio-task.rst:954
#, fuzzy
msgid ""
"If *loop* is ``None``, :func:`get_running_loop` is used for getting current "
"loop."
msgstr "如果 *loop* 為 ``None``，則 :func:`get_running_loop` 用於獲取當前循環。"

#: ../../library/asyncio-task.rst:962
#, fuzzy
msgid "Return ``True`` if *obj* is a coroutine object."
msgstr "如果 *obj* 是協程物件，則回傳 ``True``。"

#: ../../library/asyncio-task.rst:968
#, fuzzy
msgid "Task Object"
msgstr "任務物件"

#: ../../library/asyncio-task.rst:972
#, fuzzy
msgid ""
"A :class:`Future-like <Future>` object that runs a Python :ref:`coroutine "
"<coroutine>`.  Not thread-safe."
msgstr "運行 Python :ref:`coroutine <coroutine>` 的類未來 <Future>` "
"物件。不是執行緒安全的。"

#: ../../library/asyncio-task.rst:975
#, fuzzy
msgid ""
"Tasks are used to run coroutines in event loops. If a coroutine awaits on a "
"Future, the Task suspends the execution of the coroutine and waits for the "
"completion of the Future.  When the Future is *done*, the execution of the "
"wrapped coroutine resumes."
msgstr ""
"任務用於在事件循環中運行協程。如果協程等待 Future，Task "
"會暫停協程的執行並等待 Future 的完成。當 Future "
"*完成*時，包裝協程的執行將恢復。"

#: ../../library/asyncio-task.rst:981
#, fuzzy
msgid ""
"Event loops use cooperative scheduling: an event loop runs one Task at a "
"time.  While a Task awaits for the completion of a Future, the event loop "
"runs other Tasks, callbacks, or performs IO operations."
msgstr "事件循環使用協作調度：事件循環一次運行一個任務。當任務等待 Future "
"完成時，事件循環運行其他任務、回呼或執行 IO 操作。"

#: ../../library/asyncio-task.rst:986
#, fuzzy
msgid ""
"Use the high-level :func:`asyncio.create_task` function to create Tasks, or "
"the low-level :meth:`loop.create_task` or :func:`ensure_future` functions.  "
"Manual instantiation of Tasks is discouraged."
msgstr ""
"使用高階 :func:`asyncio.create_task` 函式建立任務，或使用低階 :meth:`loop."
"create_task` 或 :func:`ensure_future` 函式。不鼓勵手動實例化任務。"

#: ../../library/asyncio-task.rst:991
#, fuzzy
msgid ""
"To cancel a running Task use the :meth:`cancel` method.  Calling it will "
"cause the Task to throw a :exc:`CancelledError` exception into the wrapped "
"coroutine.  If a coroutine is awaiting on a Future object during "
"cancellation, the Future object will be cancelled."
msgstr ""
"要取消正在運行的任務，請使用 cancel 方法。呼叫它將導致 Task 將 "
"CancelledError 例外拋出到包裝的協程中。如果協程在取消期間正在等待 Future "
"物件，則 Future 物件將被取消。"

#: ../../library/asyncio-task.rst:996
#, fuzzy
msgid ""
":meth:`cancelled` can be used to check if the Task was cancelled. The method "
"returns ``True`` if the wrapped coroutine did not suppress the :exc:"
"`CancelledError` exception and was actually cancelled."
msgstr ""
":meth:`cancelled` 可用於檢查任務是否已取消。如果包裝的協程沒有抑制 "
"CancelledError 例外並且實際上被取消，則該方法回傳 True。"

#: ../../library/asyncio-task.rst:1001
#, fuzzy
msgid ""
":class:`asyncio.Task` inherits from :class:`Future` all of its APIs except :"
"meth:`Future.set_result` and :meth:`Future.set_exception`."
msgstr ""
":class:`asyncio.Task` 繼承自 :class:`Future` 除了 :meth:`Future.set_result` "
"和 :meth:`Future.set_exception` 之外的所有 API。"

#: ../../library/asyncio-task.rst:1005
#, fuzzy
msgid ""
"Tasks support the :mod:`contextvars` module.  When a Task is created it "
"copies the current context and later runs its coroutine in the copied "
"context."
msgstr "任務支援 :mod:`contextvars` "
"模組。建立任務時，它會復制當前上下文，然後在復制的上下文中運行其協程。"

#: ../../library/asyncio-task.rst:1009
#, fuzzy
msgid "Added support for the :mod:`contextvars` module."
msgstr "新增了對 :mod:`contextvars` 模組的支援。"

#: ../../library/asyncio-task.rst:1015
#, fuzzy
msgid ""
"Deprecation warning is emitted if *loop* is not specified and there is no "
"running event loop."
msgstr "如果未指定 *loop* 並且沒有正在運行的事件循環，則會發出棄用警告。"

#: ../../library/asyncio-task.rst:1021
#, fuzzy
msgid "Return ``True`` if the Task is *done*."
msgstr "如果任務*完成*，則回傳 ``True``。"

#: ../../library/asyncio-task.rst:1023
#, fuzzy
msgid ""
"A Task is *done* when the wrapped coroutine either returned a value, raised "
"an exception, or the Task was cancelled."
msgstr "當包裝協程回傳值、引發例外或任務被取消時，任務*完成*。"

#: ../../library/asyncio-task.rst:1028
#, fuzzy
msgid "Return the result of the Task."
msgstr "回傳任務的結果。"

#: ../../library/asyncio-task.rst:1030
#, fuzzy
msgid ""
"If the Task is *done*, the result of the wrapped coroutine is returned (or "
"if the coroutine raised an exception, that exception is re-raised.)"
msgstr "如果任務*完成*，則回傳包裝協程的結果（或者如果協程引發例外，則重新引發該例外"
"。）"

#: ../../library/asyncio-task.rst:1034 ../../library/asyncio-task.rst:1048
#, fuzzy
msgid ""
"If the Task has been *cancelled*, this method raises a :exc:`CancelledError` "
"exception."
msgstr "如果任務已被*取消*，此方法會引發一個 :exc:`CancelledError` 例外。"

#: ../../library/asyncio-task.rst:1037
#, fuzzy
msgid ""
"If the Task's result isn't yet available, this method raises a :exc:"
"`InvalidStateError` exception."
msgstr "如果任務的結果尚不可用，此方法會引發 InvalidStateError 例外。"

#: ../../library/asyncio-task.rst:1042
#, fuzzy
msgid "Return the exception of the Task."
msgstr "回傳任務的例外。"

#: ../../library/asyncio-task.rst:1044
#, fuzzy
msgid ""
"If the wrapped coroutine raised an exception that exception is returned.  If "
"the wrapped coroutine returned normally this method returns ``None``."
msgstr "如果包裝協程引發例外，則回傳該例外。如果包裝的協程正常回傳，則此方法回傳 ``None`` "
"。"

#: ../../library/asyncio-task.rst:1051
#, fuzzy
msgid ""
"If the Task isn't *done* yet, this method raises an :exc:`InvalidStateError` "
"exception."
msgstr "如果任務尚未*完成*，此方法會引發一個 InvalidStateError 例外。"

#: ../../library/asyncio-task.rst:1056
#, fuzzy
msgid "Add a callback to be run when the Task is *done*."
msgstr "新增要在任務*完成*時運行的回呼。"

#: ../../library/asyncio-task.rst:1058 ../../library/asyncio-task.rst:1067
#, fuzzy
msgid "This method should only be used in low-level callback-based code."
msgstr "此方法只能用於基於回呼的低階程式碼。"

#: ../../library/asyncio-task.rst:1060
#, fuzzy
msgid ""
"See the documentation of :meth:`Future.add_done_callback` for more details."
msgstr "有關詳細資訊，請參閱 Future.add_done_callback 的文檔。"

#: ../../library/asyncio-task.rst:1065
#, fuzzy
msgid "Remove *callback* from the callbacks list."
msgstr "從回呼列表中刪除 *callback*。"

#: ../../library/asyncio-task.rst:1069
#, fuzzy
msgid ""
"See the documentation of :meth:`Future.remove_done_callback` for more "
"details."
msgstr "有關詳細資訊，請參閱 Future.remove_done_callback 的文檔。"

#: ../../library/asyncio-task.rst:1074
#, fuzzy
msgid "Return the list of stack frames for this Task."
msgstr "回傳此任務的堆疊幀列表。"

#: ../../library/asyncio-task.rst:1076
#, fuzzy
msgid ""
"If the wrapped coroutine is not done, this returns the stack where it is "
"suspended.  If the coroutine has completed successfully or was cancelled, "
"this returns an empty list. If the coroutine was terminated by an exception, "
"this returns the list of traceback frames."
msgstr "如果包裝協程沒有完成，這將回傳它暫停的堆疊。如果協程已成功完成或被取消，則回"
"傳一個空列表。如果協程因例外而終止，則回傳回溯幀列表。"

#: ../../library/asyncio-task.rst:1082
#, fuzzy
msgid "The frames are always ordered from oldest to newest."
msgstr "幀始終按從舊到新的順序排列。"

#: ../../library/asyncio-task.rst:1084
#, fuzzy
msgid "Only one stack frame is returned for a suspended coroutine."
msgstr "掛起的協程只回傳一個堆疊幀。"

#: ../../library/asyncio-task.rst:1086
#, fuzzy
msgid ""
"The optional *limit* argument sets the maximum number of frames to return; "
"by default all available frames are returned. The ordering of the returned "
"list differs depending on whether a stack or a traceback is returned: the "
"newest frames of a stack are returned, but the oldest frames of a traceback "
"are returned.  (This matches the behavior of the traceback module.)"
msgstr ""
"可選的 *limit* 參數設定要回傳的最大幀數；預設情況下回傳所有可用的幀。回傳列表"
"的順序根據回傳的是堆疊還是回溯而不同：回傳堆疊的最新幀，但回傳回溯的最舊幀。 "
"（這與回溯模組的行為相匹配。）"

#: ../../library/asyncio-task.rst:1095
#, fuzzy
msgid "Print the stack or traceback for this Task."
msgstr "印出此任務的堆疊或回溯。"

#: ../../library/asyncio-task.rst:1097
#, fuzzy
msgid ""
"This produces output similar to that of the traceback module for the frames "
"retrieved by :meth:`get_stack`."
msgstr "這會產生類似於 get_stack 檢索到的幀的回溯模組的輸出。"

#: ../../library/asyncio-task.rst:1100
#, fuzzy
msgid "The *limit* argument is passed to :meth:`get_stack` directly."
msgstr "*limit* 參數直接傳遞給 :meth:`get_stack`。"

#: ../../library/asyncio-task.rst:1102
#, fuzzy
msgid ""
"The *file* argument is an I/O stream to which the output is written; by "
"default output is written to :data:`sys.stdout`."
msgstr "*file* 參數是寫入輸出的 I/O 流；預設情況下，輸出寫入 :data:`sys.stdout`。"

#: ../../library/asyncio-task.rst:1107
#, fuzzy
msgid "Return the coroutine object wrapped by the :class:`Task`."
msgstr "回傳由 Task 包裝的協程物件。"

#: ../../library/asyncio-task.rst:1113
#, fuzzy
msgid "Return the name of the Task."
msgstr "回傳任務的名稱。"

#: ../../library/asyncio-task.rst:1115
#, fuzzy
msgid ""
"If no name has been explicitly assigned to the Task, the default asyncio "
"Task implementation generates a default name during instantiation."
msgstr "如果沒有為任務顯式分配名稱，則預設的 asyncio "
"任務實作會在實例化期間生成一個預設名稱。"

#: ../../library/asyncio-task.rst:1123
#, fuzzy
msgid "Set the name of the Task."
msgstr "設定任務的名稱。"

#: ../../library/asyncio-task.rst:1125
#, fuzzy
msgid ""
"The *value* argument can be any object, which is then converted to a string."
msgstr "*value* 參數可以是任何物件，然後將其轉換為字串。"

#: ../../library/asyncio-task.rst:1128
#, fuzzy
msgid ""
"In the default Task implementation, the name will be visible in the :func:"
"`repr` output of a task object."
msgstr "在預設的 Task 實作中，名稱將在任務物件的 :func:`repr` 輸出中可見。"

#: ../../library/asyncio-task.rst:1135
#, fuzzy
msgid "Request the Task to be cancelled."
msgstr "請求取消任務。"

#: ../../library/asyncio-task.rst:1137
#, fuzzy
msgid ""
"This arranges for a :exc:`CancelledError` exception to be thrown into the "
"wrapped coroutine on the next cycle of the event loop."
msgstr "這安排在事件循環的下一個週期將 :exc:`CancelledError` 例外拋入包裝協程。"

#: ../../library/asyncio-task.rst:1140
#, fuzzy
msgid ""
"The coroutine then has a chance to clean up or even deny the request by "
"suppressing the exception with a :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Therefore, unlike :meth:"
"`Future.cancel`, :meth:`Task.cancel` does not guarantee that the Task will "
"be cancelled, although suppressing cancellation completely is not common and "
"is actively discouraged.  Should the coroutine nevertheless decide to "
"suppress the cancellation, it needs to call :meth:`Task.uncancel` in "
"addition to catching the exception."
msgstr ""
"然後協程有機會通過使用 try ...... except CancelledError ...... finally "
"塊抑制例外來清理甚至拒絕請求。因此，與 :meth:`Future.cancel` "
"不同，:meth:`Task.cancel` 不保證任務將被取消，儘管完全抑制取消並不常見並且被"
"積極勸阻。如果協程仍然決定抑制取消，除了捕獲例外外，它還需要呼叫 :meth:`Task."
"uncancel`。"

#: ../../library/asyncio-task.rst:1150
msgid "Added the *msg* parameter."
msgstr "新增 *msg* 參數。"

#: ../../library/asyncio-task.rst:1153
#, fuzzy
msgid "The ``msg`` parameter is propagated from cancelled task to its awaiter."
msgstr "``msg`` 參數從取消的任務傳播到它的等待者。"

#: ../../library/asyncio-task.rst:1158
#, fuzzy
msgid ""
"The following example illustrates how coroutines can intercept the "
"cancellation request::"
msgstr "以下示例說明協程如何攔截取消請求："

#: ../../library/asyncio-task.rst:1197
#, fuzzy
msgid "Return ``True`` if the Task is *cancelled*."
msgstr "如果任務被*取消*，則回傳 ``True``。"

#: ../../library/asyncio-task.rst:1199
#, fuzzy
msgid ""
"The Task is *cancelled* when the cancellation was requested with :meth:"
"`cancel` and the wrapped coroutine propagated the :exc:`CancelledError` "
"exception thrown into it."
msgstr ""
"當使用 :meth:`cancel` 請求取消並且包裝的協程傳播了拋入其中的 "
":exc:`CancelledError` 例外時，任務被*取消*。"

#: ../../library/asyncio-task.rst:1205
#, fuzzy
msgid "Decrement the count of cancellation requests to this Task."
msgstr "減少對此任務的取消請求計數。"

#: ../../library/asyncio-task.rst:1207
#, fuzzy
msgid "Returns the remaining number of cancellation requests."
msgstr "回傳剩餘的取消請求數。"

#: ../../library/asyncio-task.rst:1209
#, fuzzy
msgid ""
"Note that once execution of a cancelled task completed, further calls to :"
"meth:`uncancel` are ineffective."
msgstr "請注意，一旦取消的任務執行完成，進一步呼叫 :meth:`uncancel` 將無效。"

#: ../../library/asyncio-task.rst:1214
#, fuzzy
msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  In particular, if a Task gets successfully uncancelled, this "
"allows for elements of structured concurrency like :ref:`taskgroups` and :"
"func:`asyncio.timeout` to continue running, isolating cancellation to the "
"respective structured block. For example::"
msgstr ""
"此方法由 asyncio 的內部使用，預計不會由最終使用者程式碼使用。特別是，如果任務"
"成功取消，這允許結構化並發的元素，如 :ref:`taskgroups` 和 :func:`asyncio."
"timeout` 繼續運行，將取消隔離到相應的結構化塊。例如：："

#: ../../library/asyncio-task.rst:1232
#, fuzzy
msgid ""
"While the block with ``make_request()`` and ``make_another_request()`` might "
"get cancelled due to the timeout, ``unrelated_code()`` should continue "
"running even in case of the timeout.  This is implemented with :meth:"
"`uncancel`.  :class:`TaskGroup` context managers use :func:`uncancel` in a "
"similar fashion."
msgstr ""
"雖然帶有 ``make_request()`` 和 ``make_another_request()`` "
"的塊可能由於超時而被取消，但 ``unrelated_code()`` "
"即使在超時的情況下也應該繼續運行。這是用 :meth:`uncancel` 實作的。 "
":class:`TaskGroup` 上下文管理器以類似的方式使用 :func:`uncancel`。"

#: ../../library/asyncio-task.rst:1238
#, fuzzy
msgid ""
"If end-user code is, for some reason, suppresing cancellation by catching :"
"exc:`CancelledError`, it needs to call this method to remove the "
"cancellation state."
msgstr "如果最終使用者程式碼出於某種原因通過捕獲 :exc:`CancelledError` "
"來抑制取消，則需要呼叫此方法來刪除取消狀態。"

#: ../../library/asyncio-task.rst:1244
#, fuzzy
msgid ""
"Return the number of pending cancellation requests to this Task, i.e., the "
"number of calls to :meth:`cancel` less the number of :meth:`uncancel` calls."
msgstr "回傳此任務的未決取消請求數，即呼叫 :meth:`cancel` 的次數減去 :meth:`uncancel`"
" 呼叫的次數。"

#: ../../library/asyncio-task.rst:1248
#, fuzzy
msgid ""
"Note that if this number is greater than zero but the Task is still "
"executing, :meth:`cancelled` will still return ``False``. This is because "
"this number can be lowered by calling :meth:`uncancel`, which can lead to "
"the task not being cancelled after all if the cancellation requests go down "
"to zero."
msgstr ""
"請注意，如果此數字大於零但任務仍在執行，:meth:`cancelled` 仍將回傳 "
"``False``。這是因為可以通過呼叫 :meth:`uncancel` "
"來降低這個數字，如果取消請求降為零，這可能導致任務最終不會被取消。"

#: ../../library/asyncio-task.rst:1254
#, fuzzy
msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  See :meth:`uncancel` for more details."
msgstr "此方法由 asyncio 的內部使用，預計不會由最終使用者程式碼使用。有關更多詳細資訊"
"，請參見 :meth:`uncancel`。"
