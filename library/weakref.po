# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-22 00:15+0000\n"
"PO-Revision-Date: 2018-05-23 16:15+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/weakref.rst:4
msgid ":mod:`weakref` --- Weak references"
msgstr ":mod:`weakref` --- 弱參照"

#: ../../library/weakref.rst:14
msgid "**Source code:** :source:`Lib/weakref.py`"
msgstr "**原始碼：**\\ :source:`Lib/weakref.py`"

#: ../../library/weakref.rst:18
#, fuzzy
msgid ""
"The :mod:`weakref` module allows the Python programmer to create :dfn:`weak "
"references` to objects."
msgstr ":mod:`weakref` 模組允許 Python 程式員建立物件的 :dfn:`weak references`。"

#: ../../library/weakref.rst:24
#, fuzzy
msgid ""
"In the following, the term :dfn:`referent` means the object which is "
"referred to by a weak reference."
msgstr "在下文中，術語 :dfn:`referent` 表示被弱引用引用的物件。"

#: ../../library/weakref.rst:27
#, fuzzy
msgid ""
"A weak reference to an object is not enough to keep the object alive: when "
"the only remaining references to a referent are weak references, :term:"
"`garbage collection` is free to destroy the referent and reuse its memory "
"for something else.  However, until the object is actually destroyed the "
"weak reference may return the object even if there are no strong references "
"to it."
msgstr ""
"對物件的弱引用不足以使物件保持活動狀態：當對引用物件的唯一剩餘引用是弱引用時"
"，垃圾收集可以自由地銷毀引用物件並將其記憶體重新用於其他用途。但是，在物件實"
"際被銷毀之前，弱引用可能會回傳該物件，即使沒有對它的強引用也是如此。"

#: ../../library/weakref.rst:33
#, fuzzy
msgid ""
"A primary use for weak references is to implement caches or mappings holding "
"large objects, where it's desired that a large object not be kept alive "
"solely because it appears in a cache or mapping."
msgstr "弱引用的主要用途是實作包含大物件的快取或映射，其中不希望大物件僅僅因為出現在"
"快取或映射中而保持活動狀態。"

#: ../../library/weakref.rst:37
#, fuzzy
msgid ""
"For example, if you have a number of large binary image objects, you may "
"wish to associate a name with each.  If you used a Python dictionary to map "
"names to images, or images to names, the image objects would remain alive "
"just because they appeared as values or keys in the dictionaries.  The :"
"class:`WeakKeyDictionary` and :class:`WeakValueDictionary` classes supplied "
"by the :mod:`weakref` module are an alternative, using weak references to "
"construct mappings that don't keep objects alive solely because they appear "
"in the mapping objects.  If, for example, an image object is a value in a :"
"class:`WeakValueDictionary`, then when the last remaining references to that "
"image object are the weak references held by weak mappings, garbage "
"collection can reclaim the object, and its corresponding entries in weak "
"mappings are simply deleted."
msgstr ""
"例如，如果您有許多大型二進位圖像物件，您可能希望為每個物件關聯一個名稱。"
"如果您使用 Python 字典將名稱映射到圖像，或將圖像映射到名稱，則圖像物件將保持"
"活動狀態，因為它們在字典中顯示為值或鍵。 :mod:`weakref` "
"模組提供的 :class:`WeakKeyDictionary` 和 :class:`WeakValueDictionary` 類是另一"
"種選擇，它們使用弱引用來構造映射，這些映射不會僅僅因為它們出現在映射對像中而"
"使物件保持活動狀態.例如，如果一個圖像對像是 WeakValueDictionary 中的一個值，"
"那麼當對該圖像物件的最後剩餘引用是弱映射持有的弱引用時，垃圾回收可以回收該物"
"件及其對應的條目在弱映射中被簡單地刪除。"

#: ../../library/weakref.rst:50
#, fuzzy
msgid ""
":class:`WeakKeyDictionary` and :class:`WeakValueDictionary` use weak "
"references in their implementation, setting up callback functions on the "
"weak references that notify the weak dictionaries when a key or value has "
"been reclaimed by garbage collection.  :class:`WeakSet` implements the :"
"class:`set` interface, but keeps weak references to its elements, just like "
"a :class:`WeakKeyDictionary` does."
msgstr ""
":class:`WeakKeyDictionary` 和 :class:`WeakValueDictionary` 在它們的實作中使用"
"弱引用，在弱引用上設定回呼函式，當鍵或值被垃圾收集回收時通知弱字典。 "
":class:`WeakSet` 實作 :class:`set` 介面，但保留對其元素的弱引用，就像 "
":class:`WeakKeyDictionary` 所做的那樣。"

#: ../../library/weakref.rst:57
#, fuzzy
msgid ""
":class:`finalize` provides a straight forward way to register a cleanup "
"function to be called when an object is garbage collected. This is simpler "
"to use than setting up a callback function on a raw weak reference, since "
"the module automatically ensures that the finalizer remains alive until the "
"object is collected."
msgstr ""
":class:`finalize` 提供了一種直接的方法來註冊一個清理函式，以便在對像被垃圾回"
"收時呼叫。這比在原始弱引用上設定回呼函式更容易使用，因為模組會自動確保終結器"
"保持活動狀態，直到對像被收集。"

#: ../../library/weakref.rst:63
#, fuzzy
msgid ""
"Most programs should find that using one of these weak container types or :"
"class:`finalize` is all they need -- it's not usually necessary to create "
"your own weak references directly.  The low-level machinery is exposed by "
"the :mod:`weakref` module for the benefit of advanced uses."
msgstr ""
"大多數程式應該發現使用其中一種弱容器型別或 :class:`finalize` "
"是它們所需要的——通常不需要直接建立您自己的弱引用。低階機制由 :mod:`weakref` "
"模組公開，以利於高階用途。"

#: ../../library/weakref.rst:68
#, fuzzy
msgid ""
"Not all objects can be weakly referenced. Objects which support weak "
"references include class instances, functions written in Python (but not in "
"C), instance methods, sets, frozensets, some :term:`file objects <file "
"object>`, :term:`generators <generator>`, type objects, sockets, arrays, "
"deques, regular expression pattern objects, and code objects."
msgstr ""
"並非所有對像都可以被弱引用。支援弱引用的物件包括類實例、用 Python "
"編寫的函式（但不是用 C 編寫的）、實例方法、集合、frozensets、一些文件物件<文"
"件物件>、生成器<生成器>、型別物件、 socket 、數組、雙端隊列、正則表達式模式物件"
"和程式碼物件。"

#: ../../library/weakref.rst:74
#, fuzzy
msgid "Added support for thread.lock, threading.Lock, and code objects."
msgstr "新增了對 thread.lock、threading.Lock 和程式碼物件的支援。"

#: ../../library/weakref.rst:77
#, fuzzy
msgid ""
"Several built-in types such as :class:`list` and :class:`dict` do not "
"directly support weak references but can add support through subclassing::"
msgstr "幾個內建型別，如 :class:`list` 和 :class:`dict` "
"不直接支援弱引用，但可以通過子類別化來新增支援::"

#: ../../library/weakref.rst:87
#, fuzzy
msgid ""
"Other built-in types such as :class:`tuple` and :class:`int` do not support "
"weak references even when subclassed."
msgstr "其他內建型別，如 :class:`tuple` 和 :class:`int` "
"即使在子類別化時也不支援弱引用。"

#: ../../library/weakref.rst:90
#, fuzzy
msgid ""
"Extension types can easily be made to support weak references; see :ref:"
"`weakref-support`."
msgstr "可以很容易地使擴充型別支援弱引用；請參閱 :ref:`weakref-support`。"

#: ../../library/weakref.rst:93
#, fuzzy
msgid ""
"When ``__slots__`` are defined for a given type, weak reference support is "
"disabled unless a ``'__weakref__'`` string is also present in the sequence "
"of strings in the ``__slots__`` declaration. See :ref:`__slots__ "
"documentation <slots>` for details."
msgstr ""
"當為給定型別定義 ``__slots__`` 時，弱引用支援將被禁用，除非 ``'__weakref__'`` "
"字串也存在於 ``__slots__`` 聲明中的字串序列中。有關詳細資訊，請參閱 :ref:`__slots__` "
"文檔 <slots>`。"

#: ../../library/weakref.rst:100
#, fuzzy
msgid ""
"Return a weak reference to *object*.  The original object can be retrieved "
"by calling the reference object if the referent is still alive; if the "
"referent is no longer alive, calling the reference object will cause :const:"
"`None` to be returned.  If *callback* is provided and not :const:`None`, and "
"the returned weakref object is still alive, the callback will be called when "
"the object is about to be finalized; the weak reference object will be "
"passed as the only parameter to the callback; the referent will no longer be "
"available."
msgstr ""
"回傳對 *object* 的弱引用。如果引用物件仍然存在，則可以通過呼叫引用物件來檢索"
"原始物件；如果引用對像不再存在，呼叫引用物件將導致回傳 :const:`None`。"
"如果提供了 *callback* 而不是 :const:`None`，並且回傳的 weakref 物件仍然存在，"
"則在物件即將完成時呼叫回呼；弱引用物件將作為唯一參數傳遞給回呼；引用物件將不"
"再可用。"

#: ../../library/weakref.rst:108
#, fuzzy
msgid ""
"It is allowable for many weak references to be constructed for the same "
"object. Callbacks registered for each weak reference will be called from the "
"most recently registered callback to the oldest registered callback."
msgstr "允許為同一個物件構造多個弱引用。為每個弱引用註冊的回呼將從最近註冊的回呼呼叫"
"到最早註冊的回呼。"

#: ../../library/weakref.rst:112
#, fuzzy
msgid ""
"Exceptions raised by the callback will be noted on the standard error "
"output, but cannot be propagated; they are handled in exactly the same way "
"as exceptions raised from an object's :meth:`__del__` method."
msgstr "回呼引發的例外將在標準錯誤輸出中註明，但不能傳播；它們的處理方式與物件的 "
":meth:`__del__` 方法引發的例外的處理方式完全相同。"

#: ../../library/weakref.rst:116
#, fuzzy
msgid ""
"Weak references are :term:`hashable` if the *object* is hashable.  They will "
"maintain their hash value even after the *object* was deleted.  If :func:"
"`hash` is called the first time only after the *object* was deleted, the "
"call will raise :exc:`TypeError`."
msgstr ""
"如果 *object* 是可散列的，則弱引用是 :term:`hashable`。即使在 *object* "
"被刪除後，它們仍將保留其雜湊值。如果 :func:`hash` 僅在 *object* "
"被刪除後第一次被呼叫，呼叫將引發 :exc:`TypeError`。"

#: ../../library/weakref.rst:121
#, fuzzy
msgid ""
"Weak references support tests for equality, but not ordering.  If the "
"referents are still alive, two references have the same equality "
"relationship as their referents (regardless of the *callback*).  If either "
"referent has been deleted, the references are equal only if the reference "
"objects are the same object."
msgstr ""
"弱引用支援相等性測試，但不支援排序。如果引用物件仍然存在，則兩個引用與其引用"
"物件具有相同的相等關係（無論*回呼*如何）。如果任一引用對像已被刪除，則僅當引"
"用對像是同一物件時，引用才相等。"

#: ../../library/weakref.rst:126
#, fuzzy
msgid "This is a subclassable type rather than a factory function."
msgstr "這是一個可子類別化的型別，而不是一個工廠函式。"

#: ../../library/weakref.rst:130
#, fuzzy
msgid ""
"This read-only attribute returns the callback currently associated to the "
"weakref.  If there is no callback or if the referent of the weakref is no "
"longer alive then this attribute will have value ``None``."
msgstr "此只讀屬性回傳當前關聯到 weakref 的回呼。如果沒有回呼或者如果 weakref "
"的引用不再存在，那麼這個屬性將具有值 ``None``。"

#: ../../library/weakref.rst:134
msgid "Added the :attr:`__callback__` attribute."
msgstr "新增 :attr:`__callback__` 屬性。"

#: ../../library/weakref.rst:140
#, fuzzy
msgid ""
"Return a proxy to *object* which uses a weak reference.  This supports use "
"of the proxy in most contexts instead of requiring the explicit "
"dereferencing used with weak reference objects.  The returned object will "
"have a type of either ``ProxyType`` or ``CallableProxyType``, depending on "
"whether *object* is callable.  Proxy objects are not :term:`hashable` "
"regardless of the referent; this avoids a number of problems related to "
"their fundamentally mutable nature, and prevents their use as dictionary "
"keys.  *callback* is the same as the parameter of the same name to the :func:"
"`ref` function."
msgstr ""
"回傳一個使用弱引用的 *object* 的代理。這支援在大多數情況下使用代理，而不是要"
"求對弱引用物件使用顯式取消引用。回傳的物件將具有 ``ProxyType`` 或 "
"``CallableProxyType`` 型別，具體取決於 *object* 是否可呼叫。代理對像不是 "
":term:`hashable` 而不管所指物件；這避免了一些與其基本可變性質相關的問題，並防"
"止將它們用作字典鍵。 *callback* 與 :func:`ref` 函式的同名參數相同。"

#: ../../library/weakref.rst:149
#, fuzzy
msgid ""
"Accessing an attribute of the proxy object after the referent is garbage "
"collected raises :exc:`ReferenceError`."
msgstr "在引用對像被垃圾收集後訪問代理物件的屬性會引發 :exc:`ReferenceError`。"

#: ../../library/weakref.rst:152
#, fuzzy
msgid ""
"Extended the operator support on proxy objects to include the matrix "
"multiplication operators ``@`` and ``@=``."
msgstr "擴充了對代理物件的運算符支援，以包括矩陣乘法運算符 ``@``和“@=”。"

#: ../../library/weakref.rst:159
#, fuzzy
msgid ""
"Return the number of weak references and proxies which refer to *object*."
msgstr "回傳引用 *object* 的弱引用和代理的數量。"

#: ../../library/weakref.rst:164
#, fuzzy
msgid ""
"Return a list of all weak reference and proxy objects which refer to "
"*object*."
msgstr "回傳引用 *object* 的所有弱引用和代理物件的列表。"

#: ../../library/weakref.rst:169
#, fuzzy
msgid ""
"Mapping class that references keys weakly.  Entries in the dictionary will "
"be discarded when there is no longer a strong reference to the key.  This "
"can be used to associate additional data with an object owned by other parts "
"of an application without adding attributes to those objects.  This can be "
"especially useful with objects that override attribute accesses."
msgstr ""
"弱引用鍵的映射類。當不再有對鍵的強引用時，字典中的條目將被丟棄。這可用於將附"
"加資料與應用程式其他部分擁有的物件相關聯，而無需向這些物件新增屬性。這對於覆"
"蓋屬性訪問的物件特別有用。"

#: ../../library/weakref.rst:175
#, fuzzy
msgid ""
"Note that when a key with equal value to an existing key (but not equal "
"identity) is inserted into the dictionary, it replaces the value but does "
"not replace the existing key. Due to this, when the reference to the "
"original key is deleted, it also deletes the entry in the dictionary::"
msgstr ""
"請注意，當將與現有鍵具有相同值（但不相同）的鍵插入字典時，它會替換該值但不會"
"替換現有鍵。因此，當刪除對原始鍵的引用時，它也會刪除字典中的條目::"

#: ../../library/weakref.rst:188
#, fuzzy
msgid "A workaround would be to remove the key prior to reassignment::"
msgstr "解決方法是在重新分配之前刪除密鑰::"

#: ../../library/weakref.rst:199
msgid "Added support for ``|`` and ``|=`` operators, specified in :pep:`584`."
msgstr "新增 :pep:`584` 所述對於 ``|`` 與 ``|=`` 運算子的支援。"

#: ../../library/weakref.rst:202
#, fuzzy
msgid ""
":class:`WeakKeyDictionary` objects have an additional method that exposes "
"the internal references directly.  The references are not guaranteed to be "
"\"live\" at the time they are used, so the result of calling the references "
"needs to be checked before being used.  This can be used to avoid creating "
"references that will cause the garbage collector to keep the keys around "
"longer than needed."
msgstr ""
":class:`WeakKeyDictionary` 對像有一個直接公開內部引用的附加方法。不保證引用在"
"使用時是“活的”，因此呼叫引用的結果需要在使用前進行檢查。這可用於避免建立引用"
"，這將導致垃圾收集器將密鑰保留的時間超過需要的時間。"

#: ../../library/weakref.rst:212
#, fuzzy
msgid "Return an iterable of the weak references to the keys."
msgstr "回傳對鍵的弱引用的可疊代。"

#: ../../library/weakref.rst:217
#, fuzzy
msgid ""
"Mapping class that references values weakly.  Entries in the dictionary will "
"be discarded when no strong reference to the value exists any more."
msgstr "弱引用值的映射類。當不再存在對該值的強引用時，字典中的條目將被丟棄。"

#: ../../library/weakref.rst:220
#, fuzzy
msgid ""
"Added support for ``|`` and ``|=`` operators, as specified in :pep:`584`."
msgstr "新增了對 ``|`` 和 ``|=`` 運算符的支援，如 :pep:`584` 中所指定。"

#: ../../library/weakref.rst:223
#, fuzzy
msgid ""
":class:`WeakValueDictionary` objects have an additional method that has the "
"same issues as the :meth:`keyrefs` method of :class:`WeakKeyDictionary` "
"objects."
msgstr ""
":class:`WeakValueDictionary` 對像有一個額外的方法，它與 "
":class:`WeakKeyDictionary` 物件的 :meth:`keyrefs` 方法有相同的問題。"

#: ../../library/weakref.rst:230
#, fuzzy
msgid "Return an iterable of the weak references to the values."
msgstr "回傳對值的弱引用的可疊代。"

#: ../../library/weakref.rst:235
#, fuzzy
msgid ""
"Set class that keeps weak references to its elements.  An element will be "
"discarded when no strong reference to it exists any more."
msgstr "設定對其元素保持弱引用的類。當不再存在對其的強引用時，該元素將被丟棄。"

#: ../../library/weakref.rst:241
#, fuzzy
msgid ""
"A custom :class:`ref` subclass which simulates a weak reference to a bound "
"method (i.e., a method defined on a class and looked up on an instance). "
"Since a bound method is ephemeral, a standard weak reference cannot keep "
"hold of it.  :class:`WeakMethod` has special code to recreate the bound "
"method until either the object or the original function dies::"
msgstr ""
"自定義 :class:`ref` 子類別，它模擬對綁定方法的弱引用（即，在類上定義並在實例"
"上查找的方法）。由於綁定方法是短暫的，標準的弱引用無法保留它。 "
":class:`WeakMethod` "
"有特殊的程式碼來重新建立綁定方法，直到對像或原始函式死亡::"

#: ../../library/weakref.rst:265
#, fuzzy
msgid ""
"*callback* is the same as the parameter of the same name to the :func:`ref` "
"function."
msgstr "*callback* 與 :func:`ref` 函式的同名參數相同。"

#: ../../library/weakref.rst:271
#, fuzzy
msgid ""
"Return a callable finalizer object which will be called when *obj* is "
"garbage collected. Unlike an ordinary weak reference, a finalizer will "
"always survive until the reference object is collected, greatly simplifying "
"lifecycle management."
msgstr ""
"回傳一個可呼叫的終結器物件，當 *obj* 被垃圾回收時將被呼叫。與普通的弱引用不同"
"，終結器將一直存活到引用對像被收集為止，從而大大簡化了生命週期管理。"

#: ../../library/weakref.rst:276
#, fuzzy
msgid ""
"A finalizer is considered *alive* until it is called (either explicitly or "
"at garbage collection), and after that it is *dead*.  Calling a live "
"finalizer returns the result of evaluating ``func(*arg, **kwargs)``, whereas "
"calling a dead finalizer returns :const:`None`."
msgstr ""
"終結器被認為是“活著”的，直到它被呼叫（顯式地或在垃圾收集時），然後它就“死了”"
"。呼叫實時終結器回傳評估``func(*arg, **kwargs)`` "
"的結果，而呼叫死終結器回傳 :const:`None`。"

#: ../../library/weakref.rst:281
#, fuzzy
msgid ""
"Exceptions raised by finalizer callbacks during garbage collection will be "
"shown on the standard error output, but cannot be propagated.  They are "
"handled in the same way as exceptions raised from an object's :meth:"
"`__del__` method or a weak reference's callback."
msgstr ""
"垃圾收集期間終結器回呼引發的例外將顯示在標準錯誤輸出中，但無法傳播。"
"它們的處理方式與物件的 :meth:`__del__` "
"方法或弱引用的回呼引發的例外的處理方式相同。"

#: ../../library/weakref.rst:287
#, fuzzy
msgid ""
"When the program exits, each remaining live finalizer is called unless its :"
"attr:`atexit` attribute has been set to false.  They are called in reverse "
"order of creation."
msgstr "當程式退出時，每個剩餘的活動終結器都會被呼叫，除非它的 :attr:`atexit` "
"屬性已設定為 false。它們以相反的建立順序被呼叫。"

#: ../../library/weakref.rst:291
#, fuzzy
msgid ""
"A finalizer will never invoke its callback during the later part of the :"
"term:`interpreter shutdown` when module globals are liable to have been "
"replaced by :const:`None`."
msgstr "當模組全局變數可能被替換為 None 時，終結器將永遠不會在 interpreter shutdown "
"的後期呼叫其回呼。"

#: ../../library/weakref.rst:297
#, fuzzy
msgid ""
"If *self* is alive then mark it as dead and return the result of calling "
"``func(*args, **kwargs)``.  If *self* is dead then return :const:`None`."
msgstr ""
"如果 *self* 還活著，則將其標記為已死亡並回傳呼叫 ``func(*args, **kwargs)`` "
"的結果。如果 *self* 已死則回傳 :const:`None`。"

#: ../../library/weakref.rst:303
#, fuzzy
msgid ""
"If *self* is alive then mark it as dead and return the tuple ``(obj, func, "
"args, kwargs)``.  If *self* is dead then return :const:`None`."
msgstr ""
"如果 *self* 還活著，則將其標記為已死亡並回傳元組 ``(obj, func, args, "
"kwargs)``。如果 *self* 已死則回傳 :const:`None`。"

#: ../../library/weakref.rst:309
#, fuzzy
msgid ""
"If *self* is alive then return the tuple ``(obj, func, args, kwargs)``.  If "
"*self* is dead then return :const:`None`."
msgstr ""
"如果 *self* 還活著，則回傳元組 ``(obj, func, args, kwargs)``。如果 *self* "
"已死則回傳 :const:`None`。"

#: ../../library/weakref.rst:314
#, fuzzy
msgid "Property which is true if the finalizer is alive, false otherwise."
msgstr "如果終結器處於活動狀態則為 true 的屬性，否則為 false。"

#: ../../library/weakref.rst:318
#, fuzzy
msgid ""
"A writable boolean property which by default is true.  When the program "
"exits, it calls all remaining live finalizers for which :attr:`.atexit` is "
"true.  They are called in reverse order of creation."
msgstr ""
"一個可寫的布爾屬性，預設情況下為 "
"true。當程式退出時，它會呼叫所有剩餘的活動終結器，其中 :attr:`.atexit` "
"為真。它們以相反的建立順序被呼叫。"

#: ../../library/weakref.rst:325
#, fuzzy
msgid ""
"It is important to ensure that *func*, *args* and *kwargs* do not own any "
"references to *obj*, either directly or indirectly, since otherwise *obj* "
"will never be garbage collected.  In particular, *func* should not be a "
"bound method of *obj*."
msgstr ""
"重要的是要確保 *func*、*args* 和 *kwargs* 不直接或間接擁有對 *obj* "
"的任何引用，否則 *obj* 永遠不會被垃圾收集。特別是，*func* 不應該是 *obj* "
"的綁定方法。"

#: ../../library/weakref.rst:335
#, fuzzy
msgid "The type object for weak references objects."
msgstr "弱引用物件的型別物件。"

#: ../../library/weakref.rst:340
#, fuzzy
msgid "The type object for proxies of objects which are not callable."
msgstr "不可呼叫物件代理的型別物件。"

#: ../../library/weakref.rst:345
#, fuzzy
msgid "The type object for proxies of callable objects."
msgstr "可呼叫物件代理的型別物件。"

#: ../../library/weakref.rst:350
#, fuzzy
msgid ""
"Sequence containing all the type objects for proxies.  This can make it "
"simpler to test if an object is a proxy without being dependent on naming "
"both proxy types."
msgstr "包含代理的所有型別物件的序列。這可以更簡單地測試對像是否是代理，而不依賴於命"
"名兩種代理型別。"

#: ../../library/weakref.rst:358
#, fuzzy
msgid ":pep:`205` - Weak References"
msgstr ":pep:`205` - 弱引用"

#: ../../library/weakref.rst:358
#, fuzzy
msgid ""
"The proposal and rationale for this feature, including links to earlier "
"implementations and information about similar features in other languages."
msgstr "此功能的建議和理由，包括指向早期實作的鏈接以及有關其他語言的類似功能的資訊。"

#: ../../library/weakref.rst:365
#, fuzzy
msgid "Weak Reference Objects"
msgstr "弱引用物件"

#: ../../library/weakref.rst:367
#, fuzzy
msgid ""
"Weak reference objects have no methods and no attributes besides :attr:`ref."
"__callback__`. A weak reference object allows the referent to be obtained, "
"if it still exists, by calling it:"
msgstr ""
"除了 :attr:`ref.__callback__` 之外，弱引用對像沒有方法也沒有屬性。弱引用物件"
"允許通過呼叫它來獲取引用物件（如果它仍然存在）："

#: ../../library/weakref.rst:381
#, fuzzy
msgid ""
"If the referent no longer exists, calling the reference object returns :"
"const:`None`:"
msgstr "如果引用對像不再存在，則呼叫引用物件回傳 :const:`None`："

#: ../../library/weakref.rst:388
#, fuzzy
msgid ""
"Testing that a weak reference object is still live should be done using the "
"expression ``ref() is not None``.  Normally, application code that needs to "
"use a reference object should follow this pattern::"
msgstr ""
"測試弱引用對像是否仍然存在應該使用表達式 ``ref() is not None`` "
"來完成。通常，需要使用引用物件的應用程式程式碼應遵循以下模式："

#: ../../library/weakref.rst:401
#, fuzzy
msgid ""
"Using a separate test for \"liveness\" creates race conditions in threaded "
"applications; another thread can cause a weak reference to become "
"invalidated before the weak reference is called; the idiom shown above is "
"safe in threaded applications as well as single-threaded applications."
msgstr ""
"使用單獨的“活性”測試會在執行緒應用程式中建立競爭條件；另一個執行緒可能導致弱"
"引用在呼叫之前失效；上面顯示的習慣用法在執行緒應用程式和單執行緒應用程式中都"
"是安全的。"

#: ../../library/weakref.rst:406
#, fuzzy
msgid ""
"Specialized versions of :class:`ref` objects can be created through "
"subclassing. This is used in the implementation of the :class:"
"`WeakValueDictionary` to reduce the memory overhead for each entry in the "
"mapping.  This may be most useful to associate additional information with a "
"reference, but could also be used to insert additional processing on calls "
"to retrieve the referent."
msgstr ""
":class:`ref` 物件的特殊版本可以通過子類別化來建立。這用於 "
"WeakValueDictionary 的實作，以減少映射中每個條目的記憶體開銷。這對於將附加資"
"訊與引用相關聯可能最有用，但也可用於在呼叫中插入附加處理以檢索引用。"

#: ../../library/weakref.rst:412
#, fuzzy
msgid ""
"This example shows how a subclass of :class:`ref` can be used to store "
"additional information about an object and affect the value that's returned "
"when the referent is accessed::"
msgstr "此示例展示瞭如何使用 :class:`ref` "
"的子類別來儲存有關物件的附加資訊並影響訪問引用物件時回傳的值::"

#: ../../library/weakref.rst:439
msgid "Example"
msgstr "範例"

#: ../../library/weakref.rst:441
#, fuzzy
msgid ""
"This simple example shows how an application can use object IDs to retrieve "
"objects that it has seen before.  The IDs of the objects can then be used in "
"other data structures without forcing the objects to remain alive, but the "
"objects can still be retrieved by ID if they do."
msgstr ""
"這個簡單的例子展示了應用程式如何使用物件 ID 來檢索它以前見過"
"的物件。然後可以在其他資料結構中使用物件的 "
"ID，而無需強制物件保持活動狀態，但如果存在，仍然可以通過 ID 檢索物件。"

#: ../../library/weakref.rst:466
#, fuzzy
msgid "Finalizer Objects"
msgstr "終結器物件"

#: ../../library/weakref.rst:468
#, fuzzy
msgid ""
"The main benefit of using :class:`finalize` is that it makes it simple to "
"register a callback without needing to preserve the returned finalizer "
"object.  For instance"
msgstr "使用 :class:`finalize` "
"的主要好處是它使註冊回呼變得簡單，而無需保留回傳的終結器物件。例如"

#: ../../library/weakref.rst:482
#, fuzzy
msgid ""
"The finalizer can be called directly as well.  However the finalizer will "
"invoke the callback at most once."
msgstr "終結器也可以直接呼叫。但是終結器最多會呼叫一次回呼。"

#: ../../library/weakref.rst:498
#, fuzzy
msgid ""
"You can unregister a finalizer using its :meth:`~finalize.detach` method.  "
"This kills the finalizer and returns the arguments passed to the constructor "
"when it was created."
msgstr "您可以使用其 :meth:`~finalize.detach` "
"方法註銷終結器。這會終止終結器並回傳建立時傳遞給構造函式的參數。"

#: ../../library/weakref.rst:512
#, fuzzy
msgid ""
"Unless you set the :attr:`~finalize.atexit` attribute to :const:`False`, a "
"finalizer will be called when the program exits if it is still alive.  For "
"instance"
msgstr ""
"除非您將 :attr:`~finalize.atexit` 屬性設定為 "
":const:`False`，否則如果程式仍然存在，則在程式退出時將呼叫終結器。例如"

#: ../../library/weakref.rst:527
#, fuzzy
msgid "Comparing finalizers with :meth:`__del__` methods"
msgstr "將終結器與 :meth:`__del__` 方法進行比較"

#: ../../library/weakref.rst:529
#, fuzzy
msgid ""
"Suppose we want to create a class whose instances represent temporary "
"directories.  The directories should be deleted with their contents when the "
"first of the following events occurs:"
msgstr "假設我們要建立一個類，其實例代表臨時目錄。當以下事件中的第一個發生時，應刪除"
"目錄及其內容："

#: ../../library/weakref.rst:533
#, fuzzy
msgid "the object is garbage collected,"
msgstr "該對像被垃圾收集，"

#: ../../library/weakref.rst:534
#, fuzzy
msgid "the object's :meth:`remove` method is called, or"
msgstr "物件的 :meth:`remove` 方法被呼叫，或者"

#: ../../library/weakref.rst:535
#, fuzzy
msgid "the program exits."
msgstr "程式退出。"

#: ../../library/weakref.rst:537
#, fuzzy
msgid ""
"We might try to implement the class using a :meth:`__del__` method as "
"follows::"
msgstr "我們可能會嘗試使用 :meth:`__del__` 方法來實作該類，如下所示："

#: ../../library/weakref.rst:556
#, fuzzy
msgid ""
"Starting with Python 3.4, :meth:`__del__` methods no longer prevent "
"reference cycles from being garbage collected, and module globals are no "
"longer forced to :const:`None` during :term:`interpreter shutdown`. So this "
"code should work without any issues on CPython."
msgstr ""
"從 Python 3.4 開始，:meth:`__del__` 方法不再阻止引用循環被垃圾收集，"
"模組全局變數在 :term:`interpreter shutdown` 期間不再強制為 :const:`None`。"
"所以這段程式碼在 CPython 上應該沒有任何問題。"

#: ../../library/weakref.rst:561
#, fuzzy
msgid ""
"However, handling of :meth:`__del__` methods is notoriously implementation "
"specific, since it depends on internal details of the interpreter's garbage "
"collector implementation."
msgstr "然而，眾所周知，__del__ "
"方法的處理是特定於實作的，因為它取決於直譯器的垃圾收集器實作的內部細節。"

#: ../../library/weakref.rst:565
#, fuzzy
msgid ""
"A more robust alternative can be to define a finalizer which only references "
"the specific functions and objects that it needs, rather than having access "
"to the full state of the object::"
msgstr "一個更健壯的替代方法是定義一個終結器，它只引用它需要的特定函式和物件，而不是"
"訪問物件的完整狀態::"

#: ../../library/weakref.rst:581
#, fuzzy
msgid ""
"Defined like this, our finalizer only receives a reference to the details it "
"needs to clean up the directory appropriately. If the object never gets "
"garbage collected the finalizer will still be called at exit."
msgstr "像這樣定義，我們的終結器只接收對適當清理目錄所需的詳細資訊的引用。如果物件永"
"遠不會被垃圾收集，終結器仍將在退出時被呼叫。"

#: ../../library/weakref.rst:585
#, fuzzy
msgid ""
"The other advantage of weakref based finalizers is that they can be used to "
"register finalizers for classes where the definition is controlled by a "
"third party, such as running code when a module is unloaded::"
msgstr "基於 weakref 的終結器的另一個優點是它們可用於為定義由第三方控制的類註冊終結器"
"，例如在卸載模組時運行程式碼::"

#: ../../library/weakref.rst:597
#, fuzzy
msgid ""
"If you create a finalizer object in a daemonic thread just as the program "
"exits then there is the possibility that the finalizer does not get called "
"at exit.  However, in a daemonic thread :func:`atexit.register`, ``try: ... "
"finally: ...`` and ``with: ...`` do not guarantee that cleanup occurs either."
msgstr ""
"如果您在程式退出時在守護執行緒中建立終結器物件，則終結器可能不會在退出時被呼"
"叫。然而，在守護執行緒中 :func:`atexit.register`、``try: ... finally: ...`` "
"和 ``with: ...`` 也不能保證清理髮生。"
