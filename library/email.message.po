# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-06-20 18:08+0800\n"
"PO-Revision-Date: 2018-05-23 14:44+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/email.message.rst:2
msgid ":mod:`email.message`: Representing an email message"
msgstr ":mod:`email.message`: 表示一封電子郵件"

#: ../../library/email.message.rst:10
msgid "**Source code:** :source:`Lib/email/message.py`"
msgstr "**原始碼：**\\ :source:`Lib/email/message.py`"

#: ../../library/email.message.rst:14
msgid "[1]_"
msgstr "[1]_"

#: ../../library/email.message.rst:16
#, fuzzy
msgid ""
"The central class in the :mod:`email` package is the :class:`EmailMessage` "
"class, imported from the :mod:`email.message` module.  It is the base class "
"for the :mod:`email` object model.  :class:`EmailMessage` provides the core "
"functionality for setting and querying header fields, for accessing message "
"bodies, and for creating or modifying structured messages."
msgstr ""
":mod:`email` 包中的中心類是 :class:`EmailMessage` 類，從 :mod:`email.message`"
" 模組導入。它是 :mod:`email` 對像模型的基底類別。 :class:`EmailMessage` "
"提供設定和查詢標頭欄位、訪問郵件正文以及建立或修改結構化郵件的核心功能。"

#: ../../library/email.message.rst:22
#, fuzzy
msgid ""
"An email message consists of *headers* and a *payload* (which is also "
"referred to as the *content*).  Headers are :rfc:`5322` or :rfc:`6532` style "
"field names and values, where the field name and value are separated by a "
"colon.  The colon is not part of either the field name or the field value.  "
"The payload may be a simple text message, or a binary object, or a "
"structured sequence of sub-messages each with their own set of headers and "
"their own payload.  The latter type of payload is indicated by the message "
"having a MIME type such as :mimetype:`multipart/\\*` or :mimetype:`message/"
"rfc822`."
msgstr ""
"一封電子郵件由 *headers* 和 *payload*（也稱為 *content*）組成。標頭是 "
":rfc:`5322` 或 :rfc:`6532` 樣式的欄位名稱和值，其中欄位名稱和值由冒號分隔。冒"
"號不是欄位名稱或欄位值的一部分。有效負載可以是簡單的文本消息，或二進位物件，"
"或結構化的子消息序列，每個子消息都有自己的一組標頭和自己的有效負載。"
"後一種型別的有效負載由具有 MIME 型別的消息指示，例如 :mimetype:`multipart/\\"
"*` 或 :mimetype:`message/rfc822`。"

#: ../../library/email.message.rst:31
#, fuzzy
msgid ""
"The conceptual model provided by an :class:`EmailMessage` object is that of "
"an ordered dictionary of headers coupled with a *payload* that represents "
"the :rfc:`5322` body of the message, which might be a list of sub-"
"``EmailMessage`` objects.  In addition to the normal dictionary methods for "
"accessing the header names and values, there are methods for accessing "
"specialized information from the headers (for example the MIME content "
"type), for operating on the payload, for generating a serialized version of "
"the message, and for recursively walking over the object tree."
msgstr ""
":class:`EmailMessage` 物件提供的概念模型是一個有序的標頭字典加上表示消息的 "
":rfc:`5322` 正文的 *payload*，它可能是一個子列表`EmailMessage`` 物件。除了用"
"於訪問標頭名稱和值的普通字典方法之外，還有一些方法可以從標頭訪問專用資訊（"
"例如 MIME 內容型別）、對有效負載進行操作、生成消息的序列化版本，以及用於遞迴"
"遍歷物件樹。"

#: ../../library/email.message.rst:40
#, fuzzy
msgid ""
"The :class:`EmailMessage` dictionary-like interface is indexed by the header "
"names, which must be ASCII values.  The values of the dictionary are strings "
"with some extra methods.  Headers are stored and returned in case-preserving "
"form, but field names are matched case-insensitively.  Unlike a real dict, "
"there is an ordering to the keys, and there can be duplicate keys.  "
"Additional methods are provided for working with headers that have duplicate "
"keys."
msgstr ""
":class:`EmailMessage` 類似字典的介面由標頭名稱索引，標頭名稱必須是 ASCII 值。"
"字典的值是帶有一些額外方法的字串。標題以保留大小寫的形式儲存和回傳，但欄位名"
"稱匹配時不區分大小寫。與真正的字典不同，鍵是有順序的，並且可以有重複的鍵。提"
"供了其他方法來處理具有重複鍵的標頭。"

#: ../../library/email.message.rst:47
#, fuzzy
msgid ""
"The *payload* is either a string or bytes object, in the case of simple "
"message objects, or a list of :class:`EmailMessage` objects, for MIME "
"container documents such as :mimetype:`multipart/\\*` and :mimetype:`message/"
"rfc822` message objects."
msgstr ""
"*payload* 是字串或位元組物件，在簡單消息物件的情況下，或者是一個 "
"EmailMessage 物件列表，用於 MIME 容器文檔，例如 :mimetype:`multipart/\\*` 和 "
":mimetype :`message/rfc822` 消息物件。"

#: ../../library/email.message.rst:55
#, fuzzy
msgid ""
"If *policy* is specified use the rules it specifies to update and serialize "
"the representation of the message.  If *policy* is not set, use the :class:"
"`~email.policy.default` policy, which follows the rules of the email RFCs "
"except for line endings (instead of the RFC mandated ``\\r\\n``, it uses the "
"Python standard ``\\n`` line endings).  For more information see the :mod:"
"`~email.policy` documentation."
msgstr ""
"如果指定了 *policy*，則使用它指定的規則來更新和序列化消息的表示。如果未設定 "
"*policy*，請使用 :class:`~email.policy.default` 策略，該策略遵循電子郵件 RFC "
"的規則，行尾除外（而不是 RFC 強制的 ``\\r\\n"
"``，它使用 Python 標準的 ``\\n"
"`` 行結尾）。有關詳細資訊，請參閱 :mod:`~email.policy` 文檔。"

#: ../../library/email.message.rst:64
#, fuzzy
msgid ""
"Return the entire message flattened as a string.  When optional *unixfrom* "
"is true, the envelope header is included in the returned string.  *unixfrom* "
"defaults to ``False``.  For backward compatibility with the base :class:"
"`~email.message.Message` class *maxheaderlen* is accepted, but defaults to "
"``None``, which means that by default the line length is controlled by the :"
"attr:`~email.policy.EmailPolicy.max_line_length` of the policy.  The "
"*policy* argument may be used to override the default policy obtained from "
"the message instance.  This can be used to control some of the formatting "
"produced by the method, since the specified *policy* will be passed to the :"
"class:`~email.generator.Generator`."
msgstr ""
"回傳扁平化為字串的整個消息。當可選的 *unixfrom* "
"為真時，信封標頭包含在回傳的字串中。 *unixfrom* 預設為 "
"``False``。為了向後相容基底類別 :class:`~email.message.Message` "
"類*maxheaderlen* 被接受，但預設為``None``，這意味著預設情況下行長度由 :attr:`~"
" 控制策略的 email.policy.EmailPolicy.max_line_length`。 *policy* 參數可用於覆"
"蓋從消息實例獲得的預設策略。這可用於控制該方法生成的一些格式，因為指定的*策略"
"*將傳遞給 :class:`~email.generator.Generator`。"

#: ../../library/email.message.rst:76 ../../library/email.message.rst:114
#, fuzzy
msgid ""
"Flattening the message may trigger changes to the :class:`EmailMessage` if "
"defaults need to be filled in to complete the transformation to a string "
"(for example, MIME boundaries may be generated or modified)."
msgstr "如果需要填充預設值以完成到字串的轉換（例如，可能會生成或修改 MIME 邊界），"
"則扁平化消息可能會觸發對 EmailMessage 的更改。"

#: ../../library/email.message.rst:80
#, fuzzy
msgid ""
"Note that this method is provided as a convenience and may not be the most "
"useful way to serialize messages in your application, especially if you are "
"dealing with multiple messages.  See :class:`email.generator.Generator` for "
"a more flexible API for serializing messages.  Note also that this method is "
"restricted to producing messages serialized as \"7 bit clean\" when :attr:"
"`~email.policy.EmailPolicy.utf8` is ``False``, which is the default."
msgstr ""
"請注意，此方法是為了方便而提供的，可能不是在應用程式中序列化消息的最有用方法"
"，尤其是在處理多條消息時。請參閱 :class:`email.generator.Generator` "
"以獲取用於序列化消息的更靈活的 API。另請注意，當 :attr:`~email.policy."
"EmailPolicy.utf8` 為 ``False`` 時，此方法僅限於生成序列化為“7 "
"位乾淨”的消息，這是預設值。"

#: ../../library/email.message.rst:88
#, fuzzy
msgid ""
"the default behavior when *maxheaderlen* is not specified was changed from "
"defaulting to 0 to defaulting to the value of *max_line_length* from the "
"policy."
msgstr "未指定 *maxheaderlen* 時的預設行為已從預設為 0 更改為預設為策略中的 "
"*max_line_length* 值。"

#: ../../library/email.message.rst:95
#, fuzzy
msgid ""
"Equivalent to ``as_string(policy=self.policy.clone(utf8=True))``.  Allows "
"``str(msg)`` to produce a string containing the serialized message in a "
"readable format."
msgstr ""
"相當於 ``as_string(policy=self.policy.clone(utf8=True))``。允許 ``str(msg)`` "
"以可讀格式生成包含序列化消息的字串。"

#: ../../library/email.message.rst:99
#, fuzzy
msgid ""
"the method was changed to use ``utf8=True``, thus producing an :rfc:`6531`-"
"like message representation, instead of being a direct alias for :meth:"
"`as_string`."
msgstr ""
"該方法已更改為使用 ``utf8=True``，從而生成類似 :rfc:`6531` 的消息表示，"
"而不是 :meth:`as_string` 的直接別名。"

#: ../../library/email.message.rst:106
#, fuzzy
msgid ""
"Return the entire message flattened as a bytes object.  When optional "
"*unixfrom* is true, the envelope header is included in the returned string.  "
"*unixfrom* defaults to ``False``.  The *policy* argument may be used to "
"override the default policy obtained from the message instance. This can be "
"used to control some of the formatting produced by the method, since the "
"specified *policy* will be passed to the :class:`~email.generator."
"BytesGenerator`."
msgstr ""
"回傳扁平化為位元組物件的整個消息。當可選的 *unixfrom* "
"為真時，信封標頭包含在回傳的字串中。 *unixfrom* 預設為 ``False``。 *policy* "
"參數可用於覆蓋從消息實例獲得的預設策略。這可用於控制該方法生成的一些格式，"
"因為指定的 *policy* 將傳遞給 :class:`~email.generator.BytesGenerator`。"

#: ../../library/email.message.rst:118
#, fuzzy
msgid ""
"Note that this method is provided as a convenience and may not be the most "
"useful way to serialize messages in your application, especially if you are "
"dealing with multiple messages.  See :class:`email.generator.BytesGenerator` "
"for a more flexible API for serializing messages."
msgstr ""
"請注意，此方法是為了方便而提供的，可能不是在應用程式中序列化消息的最有用方法"
"，尤其是在處理多條消息時。請參閱 :class:`email.generator.BytesGenerator` "
"以獲取用於序列化消息的更靈活的 API。"

#: ../../library/email.message.rst:127
#, fuzzy
msgid ""
"Equivalent to :meth:`.as_bytes()`.  Allows ``bytes(msg)`` to produce a bytes "
"object containing the serialized message."
msgstr "相當於 :meth:`.as_bytes()`。允許 ``bytes(msg)`` "
"生成包含序列化消息的位元組物件。"

#: ../../library/email.message.rst:133
#, fuzzy
msgid ""
"Return ``True`` if the message's payload is a list of sub-\\ :class:"
"`EmailMessage` objects, otherwise return ``False``.  When :meth:"
"`is_multipart` returns ``False``, the payload should be a string object "
"(which might be a CTE encoded binary payload).  Note that :meth:"
"`is_multipart` returning ``True`` does not necessarily mean that \"msg."
"get_content_maintype() == 'multipart'\" will return the ``True``. For "
"example, ``is_multipart`` will return ``True`` when the :class:"
"`EmailMessage` is of type ``message/rfc822``."
msgstr ""
"如果消息的有效負載是子\\ :class:`EmailMessage` "
"物件的列表，則回傳 ``True``，否則回傳 ``False``。當 :meth:`is_multipart` 回傳 "
"``False`` 時，負載應該是一個字串物件（它可能是一個 CTE "
"編碼的二進位負載）。請注意 :meth:`is_multipart` 回傳 ``True`` "
"並不一定意味著“msg.get_content_maintype() == 'multipart'”將回傳 "
"``True``。例如，當 EmailMessage 的型別為“message/"
"rfc822”時，“is_multipart”將回傳 ``True``。"

#: ../../library/email.message.rst:145
#, fuzzy
msgid ""
"Set the message's envelope header to *unixfrom*, which should be a string.  "
"(See :class:`~mailbox.mboxMessage` for a brief description of this header.)"
msgstr ""
"將消息的信封標頭設定為 *unixfrom*，這應該是一個字串。 "
"（有關此標頭的簡要說明，請參閱 :class:`~mailbox.mboxMessage`。）"

#: ../../library/email.message.rst:152
#, fuzzy
msgid ""
"Return the message's envelope header.  Defaults to ``None`` if the envelope "
"header was never set."
msgstr "回傳消息的信封頭。如果從未設定信封標頭，則預設為 ``None`` 。"

#: ../../library/email.message.rst:156
#, fuzzy
msgid ""
"The following methods implement the mapping-like interface for accessing the "
"message's headers.  Note that there are some semantic differences between "
"these methods and a normal mapping (i.e. dictionary) interface.  For "
"example, in a dictionary there are no duplicate keys, but here there may be "
"duplicate message headers.  Also, in dictionaries there is no guaranteed "
"order to the keys returned by :meth:`keys`, but in an :class:`EmailMessage` "
"object, headers are always returned in the order they appeared in the "
"original message, or in which they were added to the message later.  Any "
"header deleted and then re-added is always appended to the end of the header "
"list."
msgstr ""
"以下方法實作了用於訪問消息標頭的類似映射的介面。請注意，這些方法與法線映射（"
"即字典）介面之間存在一些語義差異。例如，字典中沒有重複的鍵，但這裡可能有重複"
"的消息頭。此外，在字典中，keys 回傳的鍵沒有保證的順序，但在 EmailMessage 對像"
"中，標題總是按照它們在原始消息中出現的順序回傳，或者它們在其中出現的順序稍後"
"新增到消息中。刪除並重新新增的任何標頭始終附加到標頭列表的末尾。"

#: ../../library/email.message.rst:167
#, fuzzy
msgid ""
"These semantic differences are intentional and are biased toward convenience "
"in the most common use cases."
msgstr "這些語義差異是有意為之的，並且在最常見的用例中偏向於方便。"

#: ../../library/email.message.rst:170
#, fuzzy
msgid ""
"Note that in all cases, any envelope header present in the message is not "
"included in the mapping interface."
msgstr "請注意，在所有情況下，消息中出現的任何信封標頭都不包含在映射介面中。"

#: ../../library/email.message.rst:176
#, fuzzy
msgid "Return the total number of headers, including duplicates."
msgstr "回傳標頭總數，包括重複項。"

#: ../../library/email.message.rst:181
#, fuzzy
msgid ""
"Return ``True`` if the message object has a field named *name*. Matching is "
"done without regard to case and *name* does not include the trailing colon.  "
"Used for the ``in`` operator.  For example::"
msgstr ""
"如果消息對像有一個名為 *name* 的欄位，則回傳 "
"``True``。匹配不區分大小寫，*name* 不包括結尾的冒號。用於 ``in`` "
"運算符。例如：："

#: ../../library/email.message.rst:191
#, fuzzy
msgid ""
"Return the value of the named header field.  *name* does not include the "
"colon field separator.  If the header is missing, ``None`` is returned; a :"
"exc:`KeyError` is never raised."
msgstr "回傳命名頭欄位的值。 *name* 不包括冒號欄位分隔符。如果缺少標頭，則回傳 ``None`` ；"
"永遠不會引發 :exc:`KeyError`。"

#: ../../library/email.message.rst:195
#, fuzzy
msgid ""
"Note that if the named field appears more than once in the message's "
"headers, exactly which of those field values will be returned is undefined.  "
"Use the :meth:`get_all` method to get the values of all the extant headers "
"named *name*."
msgstr ""
"請注意，如果命名欄位在消息的標頭中出現多次，則將回傳哪些欄位值是未定義的。"
"使用 :meth:`get_all` 方法獲取名為 *name* 的所有現存標頭的值。"

#: ../../library/email.message.rst:200
#, fuzzy
msgid ""
"Using the standard (non-``compat32``) policies, the returned value is an "
"instance of a subclass of :class:`email.headerregistry.BaseHeader`."
msgstr "使用標準（非``compat32``）策略，回傳值是 email.headerregistry.BaseHeader` "
"子類別的一個實例。"

#: ../../library/email.message.rst:206
#, fuzzy
msgid ""
"Add a header to the message with field name *name* and value *val*.  The "
"field is appended to the end of the message's existing headers."
msgstr "使用欄位名稱 *name* 和值 *val* "
"向消息新增標頭。該欄位附加到郵件現有標頭的末尾。"

#: ../../library/email.message.rst:209
#, fuzzy
msgid ""
"Note that this does *not* overwrite or delete any existing header with the "
"same name.  If you want to ensure that the new header is the only one "
"present in the message with field name *name*, delete the field first, e.g.::"
msgstr ""
"請注意，這 *不會* 覆蓋或刪除任何具有相同名稱的現有標頭。"
"如果要確保新標頭是消息中唯一具有欄位名稱 *name* "
"的標頭，請先刪除該欄位，例如：::"

#: ../../library/email.message.rst:216
#, fuzzy
msgid ""
"If the :mod:`policy` defines certain headers to be unique (as the standard "
"policies do), this method may raise a :exc:`ValueError` when an attempt is "
"made to assign a value to such a header when one already exists.  This "
"behavior is intentional for consistency's sake, but do not depend on it as "
"we may choose to make such assignments do an automatic deletion of the "
"existing header in the future."
msgstr ""
"如果 :mod:`policy` "
"將某些標頭定義為唯一（如標準策略所做的那樣），則當嘗試為此類標頭分配值時，"
"此方法可能會引發 :exc:`ValueError`，而此類標頭已經存在.此行為是為了保持一致性"
"而有意為之，但不要依賴它，因為我們可能會選擇讓此類分配在將來自動刪除現有標頭"
"。"

#: ../../library/email.message.rst:226
#, fuzzy
msgid ""
"Delete all occurrences of the field with name *name* from the message's "
"headers.  No exception is raised if the named field isn't present in the "
"headers."
msgstr "從消息的標題中刪除名稱為 *name* "
"的所有欄位。如果標頭中不存在命名欄位，則不會引發例外。"

#: ../../library/email.message.rst:233
#, fuzzy
msgid "Return a list of all the message's header field names."
msgstr "回傳所有消息的標題欄位名稱的列表。"

#: ../../library/email.message.rst:238
#, fuzzy
msgid "Return a list of all the message's field values."
msgstr "回傳所有消息欄位值的列表。"

#: ../../library/email.message.rst:243
#, fuzzy
msgid ""
"Return a list of 2-tuples containing all the message's field headers and "
"values."
msgstr "回傳包含所有消息欄位標題和值的二元組列表。"

#: ../../library/email.message.rst:249
#, fuzzy
msgid ""
"Return the value of the named header field.  This is identical to :meth:"
"`__getitem__` except that optional *failobj* is returned if the named header "
"is missing (*failobj* defaults to ``None``)."
msgstr ""
"回傳命名頭欄位的值。這與 :meth:`__getitem__` 相同，"
"只是如果缺少命名標頭則回傳可選的 *failobj*（*failobj* 預設為 ``None`` ）。"

#: ../../library/email.message.rst:254
#, fuzzy
msgid "Here are some additional useful header related methods:"
msgstr "以下是一些其他有用的標頭相關方法："

#: ../../library/email.message.rst:259
#, fuzzy
msgid ""
"Return a list of all the values for the field named *name*. If there are no "
"such named headers in the message, *failobj* is returned (defaults to "
"``None``)."
msgstr "回傳名為 *name* 的欄位的所有值的列表。如果消息中沒有這樣的命名標頭，則回傳 "
"*failobj*（預設為 ``None`` ）。"

#: ../../library/email.message.rst:266
#, fuzzy
msgid ""
"Extended header setting.  This method is similar to :meth:`__setitem__` "
"except that additional header parameters can be provided as keyword "
"arguments.  *_name* is the header field to add and *_value* is the *primary* "
"value for the header."
msgstr ""
"擴充標題設定。此方法與 :meth:`__setitem__` "
"類似，不同之處在於附加的標頭參數可以作為關鍵字參數提供。 *_name* "
"是要新增的標頭欄位，*_value* 是標頭的 *primary* 值。"

#: ../../library/email.message.rst:271
#, fuzzy
msgid ""
"For each item in the keyword argument dictionary *_params*, the key is taken "
"as the parameter name, with underscores converted to dashes (since dashes "
"are illegal in Python identifiers).  Normally, the parameter will be added "
"as ``key=\"value\"`` unless the value is ``None``, in which case only the "
"key will be added."
msgstr ""
"對於關鍵字參數字典 *_params* 中的每一項，鍵作為參數名稱，底線轉換為破折號（"
"因為破折號在 Python 標識符中是非法的）。通常情況下，參數將被新增為 ``key="
"\"value\"`` 除非值為 ``None``，在這種情況下只會新增鍵。"

#: ../../library/email.message.rst:277
#, fuzzy
msgid ""
"If the value contains non-ASCII characters, the charset and language may be "
"explicitly controlled by specifying the value as a three tuple in the format "
"``(CHARSET, LANGUAGE, VALUE)``, where ``CHARSET`` is a string naming the "
"charset to be used to encode the value, ``LANGUAGE`` can usually be set to "
"``None`` or the empty string (see :rfc:`2231` for other possibilities), and "
"``VALUE`` is the string value containing non-ASCII code points.  If a three "
"tuple is not passed and the value contains non-ASCII characters, it is "
"automatically encoded in :rfc:`2231` format using a ``CHARSET`` of ``utf-8`` "
"and a ``LANGUAGE`` of ``None``."
msgstr ""
"如果該值包含非 ASCII 字元，則可以通過將值指定為格式為“(CHARSET, LANGUAGE, VAL"
"UE)”的三元組來顯式控制字元集和語言，其中 ``CHARSET`` 是字串命名用於對值進行編碼的"
"字元集，``LANGUAGE`` 通常可以設定為``None`` "
"或空字串（其他可能性參見 :rfc:`2231`），``VALUE`` 是包含非 ASCII "
"程式碼點的字串值。如果未傳遞三元組且值包含非 ASCII 字元，則使用 ``utf-8`` 的 "
"``CHARSET`` 和 ``LANGUAGE`` 自動編碼為 :rfc:`2231` 格式的``無``。"

#: ../../library/email.message.rst:287
msgid "Here is an example::"
msgstr ""
"以下是個範例：\n"
"\n"
"::"

#: ../../library/email.message.rst:291
#, fuzzy
msgid "This will add a header that looks like ::"
msgstr "這將新增一個標題，看起來像 ::"

#: ../../library/email.message.rst:295
#, fuzzy
msgid "An example of the extended interface with non-ASCII characters::"
msgstr "具有非 ASCII 字元的擴充介面示例："

#: ../../library/email.message.rst:303
#, fuzzy
msgid ""
"Replace a header.  Replace the first header found in the message that "
"matches *_name*, retaining header order and field name case of the original "
"header.  If no matching header is found, raise a :exc:`KeyError`."
msgstr ""
"替換標題。替換在消息中找到的與 *_name* 匹配的第一個標頭，保留原始標頭的標頭順"
"序和欄位名稱大小寫。如果未找到匹配的標頭，則引發 :exc:`KeyError`。"

#: ../../library/email.message.rst:311
#, fuzzy
msgid ""
"Return the message's content type, coerced to lower case of the form :"
"mimetype:`maintype/subtype`.  If there is no :mailheader:`Content-Type` "
"header in the message return the value returned by :meth:"
"`get_default_type`.  If the :mailheader:`Content-Type` header is invalid, "
"return ``text/plain``."
msgstr ""
"回傳消息的內容型別，強制為 :mimetype:`maintype/subtype` 形式的小寫。"
"如果郵件中沒有 :mailheader:`Content-Type` 標頭，則回傳 "
":meth:`get_default_type` 回傳的值。如果 :mailheader:`Content-Type` 標頭無效，"
"則回傳 ``text/plain``。"

#: ../../library/email.message.rst:317
#, fuzzy
msgid ""
"(According to :rfc:`2045`, messages always have a default type, :meth:"
"`get_content_type` will always return a value.  :rfc:`2045` defines a "
"message's default type to be :mimetype:`text/plain` unless it appears inside "
"a :mimetype:`multipart/digest` container, in which case it would be :"
"mimetype:`message/rfc822`.  If the :mailheader:`Content-Type` header has an "
"invalid type specification, :rfc:`2045` mandates that the default type be :"
"mimetype:`text/plain`.)"
msgstr ""
"（根據 :rfc:`2045`，消息始終具有預設型別，:meth:`get_content_type` "
"將始終回傳一個值。:rfc:`2045` 將消息的預設型別定義為 :mimetype:`text/plain`"
"除非它出現在 :mimetype:`multipart/digest` 容器中，在這種情況下它將是 "
":mimetype:`message/rfc822`。如果 :mailheader:`Content-Type` "
"標頭具有無效的型別規範，:rfc: `2045` 要求預設型別為 :mimetype:`text/"
"plain`。）"

#: ../../library/email.message.rst:328
#, fuzzy
msgid ""
"Return the message's main content type.  This is the :mimetype:`maintype` "
"part of the string returned by :meth:`get_content_type`."
msgstr "回傳消息的主要內容型別。這是 :meth:`get_content_type` 回傳的字串的 "
":mimetype:`maintype` 部分。"

#: ../../library/email.message.rst:334
#, fuzzy
msgid ""
"Return the message's sub-content type.  This is the :mimetype:`subtype` part "
"of the string returned by :meth:`get_content_type`."
msgstr "回傳消息的子內容型別。這是 :meth:`get_content_type` 回傳的字串的 "
":mimetype:`subtype` 部分。"

#: ../../library/email.message.rst:340
#, fuzzy
msgid ""
"Return the default content type.  Most messages have a default content type "
"of :mimetype:`text/plain`, except for messages that are subparts of :"
"mimetype:`multipart/digest` containers.  Such subparts have a default "
"content type of :mimetype:`message/rfc822`."
msgstr ""
"回傳預設內容型別。大多數消息的預設內容型別為 :mimetype:`text/plain`，但屬於 "
":mimetype:`multipart/digest` 容器子部分的消息除外。"
"此類子部分的預設內容型別為 :mimetype:`message/rfc822`。"

#: ../../library/email.message.rst:348
#, fuzzy
msgid ""
"Set the default content type.  *ctype* should either be :mimetype:`text/"
"plain` or :mimetype:`message/rfc822`, although this is not enforced.  The "
"default content type is not stored in the :mailheader:`Content-Type` header, "
"so it only affects the return value of the ``get_content_type`` methods when "
"no :mailheader:`Content-Type` header is present in the message."
msgstr ""
"設定預設內容型別。 *ctype* 應該是 :mimetype:`text/plain` 或 :mimetype:`"
"message/rfc822`，雖然這不是強制的。預設內容型別不儲存在:mailheader:`Content-"
"Type` 標頭中，因此它僅在消息中不存在:mailheader:`Content-Type` "
"標頭時影響``get_content_type`` 方法的回傳值."

#: ../../library/email.message.rst:359
#, fuzzy
msgid ""
"Set a parameter in the :mailheader:`Content-Type` header.  If the parameter "
"already exists in the header, replace its value with *value*. When *header* "
"is ``Content-Type`` (the default) and the header does not yet exist in the "
"message, add it, set its value to :mimetype:`text/plain`, and append the new "
"parameter value.  Optional *header* specifies an alternative header to :"
"mailheader:`Content-Type`."
msgstr ""
"在 :mailheader:`Content-Type` 標頭中設定一個參數。如果該參數已存在於標頭中，"
"請將其值替換為 *value*。當 *header* 是 ``Content-"
"Type``（預設值）並且消息中尚不存在標頭時，新增它，將其值設定為 :mimetype:`"
"text/plain`，並附加新的參數值。可選的 *header* 指定 :mailheader:`Content-"
"Type` 的替代標頭。"

#: ../../library/email.message.rst:366
#, fuzzy
msgid ""
"If the value contains non-ASCII characters, the charset and language may be "
"explicitly specified using the optional *charset* and *language* "
"parameters.  Optional *language* specifies the :rfc:`2231` language, "
"defaulting to the empty string.  Both *charset* and *language* should be "
"strings.  The default is to use the ``utf8`` *charset* and ``None`` for the "
"*language*."
msgstr ""
"如果該值包含非 ASCII 字元，則可以使用可選的 *charset* 和 *language* "
"參數顯式指定字元集和語言。可選的 *language* 指定 :rfc:`2231` "
"語言，預設為空字串。 *charset* 和 *language* 都應該是字串。預設是使用 "
"``utf8`` *charset* 和 ``None`` 作為 *language*。"

#: ../../library/email.message.rst:373
#, fuzzy
msgid ""
"If *replace* is ``False`` (the default) the header is moved to the end of "
"the list of headers.  If *replace* is ``True``, the header will be updated "
"in place."
msgstr ""
"如果 *replace* 是 ``False``（預設值），標題將移動到標題列表的末尾。如果 "
"*replace* 是 ``True``，標題將被更新到位。"

#: ../../library/email.message.rst:377 ../../library/email.message.rst:394
#, fuzzy
msgid ""
"Use of the *requote* parameter with :class:`EmailMessage` objects is "
"deprecated."
msgstr "不推薦使用帶有 EmailMessage 物件的 *requote* 參數。"

#: ../../library/email.message.rst:380
#, fuzzy
msgid ""
"Note that existing parameter values of headers may be accessed through the :"
"attr:`~email.headerregistry.BaseHeader.params` attribute of the header value "
"(for example, ``msg['Content-Type'].params['charset']``)."
msgstr ""
"請注意，可以通過標頭值的 :attr:`~email.headerregistry.BaseHeader.params` "
"屬性訪問標頭的現有參數值（例如，``msg['Content-Type'].params['charset' "
"]``）。"

#: ../../library/email.message.rst:384
#, fuzzy
msgid "``replace`` keyword was added."
msgstr "新增了``replace``關鍵字。"

#: ../../library/email.message.rst:389
#, fuzzy
msgid ""
"Remove the given parameter completely from the :mailheader:`Content-Type` "
"header.  The header will be re-written in place without the parameter or its "
"value.  Optional *header* specifies an alternative to :mailheader:`Content-"
"Type`."
msgstr ""
"從 :mailheader:`Content-Type` "
"標頭中完全刪除給定參數。標頭將在沒有參數或其值的情況下重新寫入。可選的 "
"*header* 指定 :mailheader:`Content-Type` 的替代方法。"

#: ../../library/email.message.rst:400
#, fuzzy
msgid ""
"Return the value of the ``filename`` parameter of the :mailheader:`Content-"
"Disposition` header of the message.  If the header does not have a "
"``filename`` parameter, this method falls back to looking for the ``name`` "
"parameter on the :mailheader:`Content-Type` header.  If neither is found, or "
"the header is missing, then *failobj* is returned. The returned string will "
"always be unquoted as per :func:`email.utils.unquote`."
msgstr ""
"回傳消息的 :mailheader:`Content-Disposition` 標頭的 ``filename`` 參數的值。"
"如果標頭沒有 ``filename`` 參數，則此方法回退到在 :mailheader:`Content-Type` "
"標頭上尋找 ``name`` 參數。如果兩者均未找到，或者標頭丟失，則回傳 *failobj*。"
"根據 :func:`email.utils.unquote` 回傳的字串將始終不帶引號。"

#: ../../library/email.message.rst:411
#, fuzzy
msgid ""
"Return the value of the ``boundary`` parameter of the :mailheader:`Content-"
"Type` header of the message, or *failobj* if either the header is missing, "
"or has no ``boundary`` parameter.  The returned string will always be "
"unquoted as per :func:`email.utils.unquote`."
msgstr ""
"回傳消息的 :mailheader:`Content-Type` 標頭的 ``boundary`` 參數的值，"
"如果標頭丟失或沒有 ``boundary`` 參數，則回傳 *failobj*。根據 :func:`email."
"utils.unquote` 回傳的字串將始終不帶引號。"

#: ../../library/email.message.rst:419
#, fuzzy
msgid ""
"Set the ``boundary`` parameter of the :mailheader:`Content-Type` header to "
"*boundary*.  :meth:`set_boundary` will always quote *boundary* if "
"necessary.  A :exc:`~email.errors.HeaderParseError` is raised if the message "
"object has no :mailheader:`Content-Type` header."
msgstr ""
"將 :mailheader:`Content-Type` 標頭的 ``boundary`` 參數設定為 *boundary*。 "
":meth:`set_boundary` 將始終在必要時引用 *boundary*。如果消息對像沒有 Content-"
"Type 標頭，則會引發 :exc:`~email.errors.HeaderParseError`。"

#: ../../library/email.message.rst:424
#, fuzzy
msgid ""
"Note that using this method is subtly different from deleting the old :"
"mailheader:`Content-Type` header and adding a new one with the new boundary "
"via :meth:`add_header`, because :meth:`set_boundary` preserves the order of "
"the :mailheader:`Content-Type` header in the list of headers."
msgstr ""
"請注意，使用此方法與刪除舊的 :mailheader:`Content-Type` "
"標頭並通過 :meth:`add_header` "
"新增具有新邊界的新標頭略有不同，因為 :meth:`set_boundary` 保留了:mailheader"
":`Content-Type` 標題列表中的標題。"

#: ../../library/email.message.rst:433
#, fuzzy
msgid ""
"Return the ``charset`` parameter of the :mailheader:`Content-Type` header, "
"coerced to lower case.  If there is no :mailheader:`Content-Type` header, or "
"if that header has no ``charset`` parameter, *failobj* is returned."
msgstr ""
"回傳 :mailheader:`Content-Type` 標頭的 ``charset`` 參數，強制為小寫。"
"如果沒有 :mailheader:`Content-Type` 標頭，或者如果該標頭沒有 ``charset`` "
"參數，則回傳 *failobj*。"

#: ../../library/email.message.rst:440
#, fuzzy
msgid ""
"Return a list containing the character set names in the message.  If the "
"message is a :mimetype:`multipart`, then the list will contain one element "
"for each subpart in the payload, otherwise, it will be a list of length 1."
msgstr ""
"回傳包含消息中字元集名稱的列表。如果消息是 "
":mimetype:`multipart`，則列表將包含有效載荷中每個子部分的一個元素，否則，"
"它將是一個長度為 1 的列表。"

#: ../../library/email.message.rst:444
#, fuzzy
msgid ""
"Each item in the list will be a string which is the value of the ``charset`` "
"parameter in the :mailheader:`Content-Type` header for the represented "
"subpart.  If the subpart has no :mailheader:`Content-Type` header, no "
"``charset`` parameter, or is not of the :mimetype:`text` main MIME type, "
"then that item in the returned list will be *failobj*."
msgstr ""
"列表中的每個項目都是一個字串，它是代表子部分的 Content-Type 標頭中的 charset "
"參數的值。如果子部分沒有:mailheader:`Content-Type` 標頭，沒有 ``charset`` "
"參數，或者不是 :mimetype:`text` 主要 MIME 型別，則回傳列表中的該項目將為 "
"*failobj* ."

#: ../../library/email.message.rst:453
#, fuzzy
msgid ""
"Return ``True`` if there is a :mailheader:`Content-Disposition` header and "
"its (case insensitive) value is ``attachment``, ``False`` otherwise."
msgstr "如果存在 Content-Disposition "
"標頭且其（不區分大小寫）值為“附件”，則回傳 ``True``，否則回傳 ``False``。"

#: ../../library/email.message.rst:456
#, fuzzy
msgid ""
"is_attachment is now a method instead of a property, for consistency with :"
"meth:`~email.message.Message.is_multipart`."
msgstr ""
"is_attachment 現在是一種方法而不是屬性，以與 :meth:`~email.message.Message."
"is_multipart` 保持一致。"

#: ../../library/email.message.rst:463
#, fuzzy
msgid ""
"Return the lowercased value (without parameters) of the message's :"
"mailheader:`Content-Disposition` header if it has one, or ``None``.  The "
"possible values for this method are *inline*, *attachment* or ``None`` if "
"the message follows :rfc:`2183`."
msgstr ""
"回傳郵件的 :mailheader:`Content-Disposition` "
"標頭的小寫值（不帶參數），如果有的話，或者 ``None``。如果消息跟在 :rfc:`2183`"
" 之後，此方法的可能值是 *inline*、*attachment* 或 ``None``。"

#: ../../library/email.message.rst:471
#, fuzzy
msgid ""
"The following methods relate to interrogating and manipulating the content "
"(payload) of the message."
msgstr "以下方法與詢問和處理消息的內容（有效負載）有關。"

#: ../../library/email.message.rst:477
#, fuzzy
msgid ""
"The :meth:`walk` method is an all-purpose generator which can be used to "
"iterate over all the parts and subparts of a message object tree, in depth-"
"first traversal order.  You will typically use :meth:`walk` as the iterator "
"in a ``for`` loop; each iteration returns the next subpart."
msgstr ""
":meth:`walk` 方法是一種通用生成器，可用於以深度優先遍歷順序疊代消息物件樹的所"
"有部分和子部分。您通常會使用 :meth:`walk` 作為 ``for`` "
"循環中的疊代器；每次疊代回傳下一個子部分。"

#: ../../library/email.message.rst:482
#, fuzzy
msgid ""
"Here's an example that prints the MIME type of every part of a multipart "
"message structure:"
msgstr "下面是一個印出多部分消息結構每個部分的 MIME 型別的示例："

#: ../../library/email.message.rst:503
#, fuzzy
msgid ""
"``walk`` iterates over the subparts of any part where :meth:`is_multipart` "
"returns ``True``, even though ``msg.get_content_maintype() == 'multipart'`` "
"may return ``False``.  We can see this in our example by making use of the "
"``_structure`` debug helper function:"
msgstr ""
"``walk`` 遍歷任何部分的子部分，其中 :meth:`is_multipart` 回傳 ``True``，即使 "
"``msg.get_content_maintype() == 'multipart'`` 可能回傳 ``False``。"
"我們可以在我們的示例中通過使用 ``_structure`` 除錯輔助函式看到這一點："

#: ../../library/email.message.rst:531
#, fuzzy
msgid ""
"Here the ``message`` parts are not ``multiparts``, but they do contain "
"subparts. ``is_multipart()`` returns ``True`` and ``walk`` descends into the "
"subparts."
msgstr ""
"這裡的“消息”部分不是“多部分”，但它們確實包含子部分。 ``is_multipart()`` 回傳 "
"``True`` 和 ``walk`` 下降到子部分。"

#: ../../library/email.message.rst:538
#, fuzzy
msgid ""
"Return the MIME part that is the best candidate to be the \"body\" of the "
"message."
msgstr "回傳最適合作為郵件“正文”的 MIME 部分。"

#: ../../library/email.message.rst:541
#, fuzzy
msgid ""
"*preferencelist* must be a sequence of strings from the set ``related``, "
"``html``, and ``plain``, and indicates the order of preference for the "
"content type of the part returned."
msgstr ""
"*preferencelist* 必須是集合``related``、``html`` 和``plain`` "
"中的字串序列，指示回傳部分內容型別的優先順序。"

#: ../../library/email.message.rst:545
#, fuzzy
msgid ""
"Start looking for candidate matches with the object on which the "
"``get_body`` method is called."
msgstr "開始尋找與呼叫 ``get_body`` 方法的物件的候選匹配項。"

#: ../../library/email.message.rst:548
#, fuzzy
msgid ""
"If ``related`` is not included in *preferencelist*, consider the root part "
"(or subpart of the root part) of any related encountered as a candidate if "
"the (sub-)part matches a preference."
msgstr "如果“相關”未包含在*偏好列表*中，如果（子）部分與偏好匹配，則將遇到的任何相關"
"的根部分（或根部分的子部分）視為候選者。"

#: ../../library/email.message.rst:552
#, fuzzy
msgid ""
"When encountering a ``multipart/related``, check the ``start`` parameter and "
"if a part with a matching :mailheader:`Content-ID` is found, consider only "
"it when looking for candidate matches.  Otherwise consider only the first "
"(default root) part of the ``multipart/related``."
msgstr ""
"當遇到 ``multipart/related`` 時，檢查 ``start`` "
"參數，如果找到匹配的部分 :mailheader:`Content-"
"ID`，在尋找候選匹配項時只考慮它。否則只考慮 ``multipart/related`` "
"的第一個（預設根）部分。"

#: ../../library/email.message.rst:557
#, fuzzy
msgid ""
"If a part has a :mailheader:`Content-Disposition` header, only consider the "
"part a candidate match if the value of the header is ``inline``."
msgstr ""
"如果一個部分有一個 :mailheader:`Content-Disposition` 標題，只有當標題的值為 "
"``inline`` 時才認為該部分是候選匹配項。"

#: ../../library/email.message.rst:560
#, fuzzy
msgid ""
"If none of the candidates matches any of the preferences in "
"*preferencelist*, return ``None``."
msgstr "如果沒有候選人與 *preferencelist* 中的任何偏好匹配，則回傳 ``None``。"

#: ../../library/email.message.rst:563
#, fuzzy
msgid ""
"Notes: (1) For most applications the only *preferencelist* combinations that "
"really make sense are ``('plain',)``, ``('html', 'plain')``, and the default "
"``('related', 'html', 'plain')``.  (2) Because matching starts with the "
"object on which ``get_body`` is called, calling ``get_body`` on a "
"``multipart/related`` will return the object itself unless *preferencelist* "
"has a non-default value. (3) Messages (or message parts) that do not specify "
"a :mailheader:`Content-Type` or whose :mailheader:`Content-Type` header is "
"invalid will be treated as if they are of type ``text/plain``, which may "
"occasionally cause ``get_body`` to return unexpected results."
msgstr ""
"注意：(1) 對於大多數應用程式，唯一真正有意義的 *preferencelist* "
"組合是``('plain',)``、``('html', 'plain')`` 和預設的``( "
"'相關'，'html'，'普通'）``。 (2) 因為匹配從呼叫 ``get_body`` 的對像開始，"
"所以在 ``multipart/related`` 上呼叫 ``get_body`` 將回傳物件本身，除非 "
"*preferencelist* 具有非預設值。 (3) 未指定 :mailheader:`Content-Type` 或 "
":mailheader:`Content-Type` 標頭無效的消息（或消息部分）將被視為 ``text/plain`"
" 型別`，這可能偶爾會導致 ``get_body`` 回傳意外結果。"

#: ../../library/email.message.rst:577
#, fuzzy
msgid ""
"Return an iterator over all of the immediate sub-parts of the message that "
"are not candidate \"body\" parts.  That is, skip the first occurrence of "
"each of ``text/plain``, ``text/html``, ``multipart/related``, or ``multipart/"
"alternative`` (unless they are explicitly marked as attachments via :"
"mailheader:`Content-Disposition: attachment`), and return all remaining "
"parts.  When applied directly to a ``multipart/related``, return an iterator "
"over the all the related parts except the root part (ie: the part pointed to "
"by the ``start`` parameter, or the first part if there is no ``start`` "
"parameter or the ``start`` parameter doesn't match the :mailheader:`Content-"
"ID` of any of the parts).  When applied directly to a ``multipart/"
"alternative`` or a non-``multipart``, return an empty iterator."
msgstr ""
"回傳消息的所有非候選“正文”部分的直接子部分的疊代器。也就是說，跳過第一次出現"
"的“text/plain”、“text/html”、“multipart/related”或“multipart/alternative”（"
"除非它們被明確標記為附件通過 :mailheader:`Content-Disposition: "
"attachment`)，並回傳所有剩餘部分。當直接應用於 ``multipart/related`` "
"時，回傳除根部分之外的所有相關部分的疊代器（即：``start`` "
"參數指向的部分，如果沒有，則回傳第一部分``start`` 參數或 ``start`` "
"參數與任何部分的 :mailheader:`Content-ID` 都不匹配）。當直接應用於“"
"multipart/alternative”或非 ``multipart`` 時，回傳一個空疊代器。"

#: ../../library/email.message.rst:593
#, fuzzy
msgid ""
"Return an iterator over all of the immediate sub-parts of the message, which "
"will be empty for a non-``multipart``.  (See also :meth:`~email.message."
"EmailMessage.walk`.)"
msgstr ""
"在消息的所有直接子部分上回傳一個疊代器，對於非“多部分”，它將為空。 （另見 "
":meth:`~email.message.EmailMessage.walk`。）"

#: ../../library/email.message.rst:600
#, fuzzy
msgid ""
"Call the :meth:`~email.contentmanager.ContentManager.get_content` method of "
"the *content_manager*, passing self as the message object, and passing along "
"any other arguments or keywords as additional arguments.  If "
"*content_manager* is not specified, use the ``content_manager`` specified by "
"the current :mod:`~email.policy`."
msgstr ""
"呼叫 *content_manager* 的 :meth:`~email.contentmanager.ContentManager."
"get_content` 方法，將 self "
"作為消息對像傳遞，並將任何其他參數或關鍵字作為附加參數傳遞。如果未指定 "
"*content_manager*，則使用當前 :mod:`~email.policy` "
"指定的``content_manager``。"

#: ../../library/email.message.rst:609
#, fuzzy
msgid ""
"Call the :meth:`~email.contentmanager.ContentManager.set_content` method of "
"the *content_manager*, passing self as the message object, and passing along "
"any other arguments or keywords as additional arguments.  If "
"*content_manager* is not specified, use the ``content_manager`` specified by "
"the current :mod:`~email.policy`."
msgstr ""
"呼叫 *content_manager* 的 :meth:`~email.contentmanager.ContentManager."
"set_content` 方法，將 self "
"作為消息對像傳遞，並將任何其他參數或關鍵字作為附加參數傳遞。如果未指定 "
"*content_manager*，則使用當前 :mod:`~email.policy` "
"指定的``content_manager``。"

#: ../../library/email.message.rst:618
#, fuzzy
msgid ""
"Convert a non-``multipart`` message into a ``multipart/related`` message, "
"moving any existing :mailheader:`Content-` headers and payload into a (new) "
"first part of the ``multipart``.  If *boundary* is specified, use it as the "
"boundary string in the multipart, otherwise leave the boundary to be "
"automatically created when it is needed (for example, when the message is "
"serialized)."
msgstr ""
"將非``multipart`` 消息轉換為``multipart/related`` "
"消息，將任何現有的:mailheader:`Content-` 標頭和有效負載移動到``multipart`` "
"的（新）第一部分。如果指定了 *boundary* ，則將其用作多部分中的邊界字串，否則"
"讓邊界在需要時自動建立（例如，當消息被序列化時）。"

#: ../../library/email.message.rst:628
#, fuzzy
msgid ""
"Convert a non-``multipart`` or a ``multipart/related`` into a ``multipart/"
"alternative``, moving any existing :mailheader:`Content-` headers and "
"payload into a (new) first part of the ``multipart``.  If *boundary* is "
"specified, use it as the boundary string in the multipart, otherwise leave "
"the boundary to be automatically created when it is needed (for example, "
"when the message is serialized)."
msgstr ""
"將非``multipart`` 或``multipart/related`` 轉換為``multipart/"
"alternative``，將任何現有的 :mailheader:`Content-` "
"標頭和有效負載移動到（新的）第一部分``多部分``。如果指定了 *boundary* ，則將"
"其用作多部分中的邊界字串，否則讓邊界在需要時自動建立（例如，當消息被序列化時"
"）。"

#: ../../library/email.message.rst:638
#, fuzzy
msgid ""
"Convert a non-``multipart``, a ``multipart/related``, or a ``multipart-"
"alternative`` into a ``multipart/mixed``, moving any existing :mailheader:"
"`Content-` headers and payload into a (new) first part of the "
"``multipart``.  If *boundary* is specified, use it as the boundary string in "
"the multipart, otherwise leave the boundary to be automatically created when "
"it is needed (for example, when the message is serialized)."
msgstr ""
"將非``multipart``、``multipart/related`` 或``multipart-alternative`` 轉換為``"
"multipart/mixed``，移動任何現有的 :mailheader:`Content-` 標題和payload 到 "
"``multipart`` 的（新的）第一部分。如果指定了 *boundary* ，則將其用作多部分中"
"的邊界字串，否則讓邊界在需要時自動建立（例如，當消息被序列化時）。"

#: ../../library/email.message.rst:648
#, fuzzy
msgid ""
"If the message is a ``multipart/related``, create a new message object, pass "
"all of the arguments to its :meth:`set_content` method, and :meth:`~email."
"message.Message.attach` it to the ``multipart``.  If the message is a non-"
"``multipart``, call :meth:`make_related` and then proceed as above.  If the "
"message is any other type of ``multipart``, raise a :exc:`TypeError`. If "
"*content_manager* is not specified, use the ``content_manager`` specified by "
"the current :mod:`~email.policy`. If the added part has no :mailheader:"
"`Content-Disposition` header, add one with the value ``inline``."
msgstr ""
"如果消息是 ``multipart/"
"related``，建立一個新的消息物件，將所有參數傳遞給它的 :meth:`set_content` "
"方法，並將它 :meth:`~email.message.Message.attach` "
"到``多部分``。如果消息是非“多部分”，請呼叫 make_related "
"然後按上面的步驟進行。如果消息是任何其他型別的 ``multipart``，引發 "
":exc:`TypeError`。如果未指定 *content_manager*，則使用當前 :mod:`~email."
"policy` 指定的``content_manager``。如果新增的部分沒有 :mailheader:`Content-"
"Disposition` 標頭，請新增一個值為 ``inline`` 的標頭。"

#: ../../library/email.message.rst:661
#, fuzzy
msgid ""
"If the message is a ``multipart/alternative``, create a new message object, "
"pass all of the arguments to its :meth:`set_content` method, and :meth:"
"`~email.message.Message.attach` it to the ``multipart``.  If the message is "
"a non-``multipart`` or ``multipart/related``, call :meth:`make_alternative` "
"and then proceed as above.  If the message is any other type of "
"``multipart``, raise a :exc:`TypeError`. If *content_manager* is not "
"specified, use the ``content_manager`` specified by the current :mod:`~email."
"policy`."
msgstr ""
"如果消息是 ``multipart/alternative``，建立一個新的消息物件，將所有參數傳遞給"
"它的 :meth:`set_content` 方法，並將它 :meth:`~email.message.Message.attach`"
" 到``多部分``。如果消息是非``multipart`` 或``multipart/related``，請呼叫 "
"make_alternative 然後按上面的步驟進行。如果消息是任何其他型別的 "
"``multipart``，引發 :exc:`TypeError`。如果未指定 *content_manager*，"
"則使用當前 :mod:`~email.policy` 指定的``content_manager``。"

#: ../../library/email.message.rst:673
#, fuzzy
msgid ""
"If the message is a ``multipart/mixed``, create a new message object, pass "
"all of the arguments to its :meth:`set_content` method, and :meth:`~email."
"message.Message.attach` it to the ``multipart``.  If the message is a non-"
"``multipart``, ``multipart/related``, or ``multipart/alternative``, call :"
"meth:`make_mixed` and then proceed as above. If *content_manager* is not "
"specified, use the ``content_manager`` specified by the current :mod:`~email."
"policy`.  If the added part has no :mailheader:`Content-Disposition` header, "
"add one with the value ``attachment``.  This method can be used both for "
"explicit attachments (:mailheader:`Content-Disposition: attachment`) and "
"``inline`` attachments (:mailheader:`Content-Disposition: inline`), by "
"passing appropriate options to the ``content_manager``."
msgstr ""
"如果消息是 ``multipart/"
"mixed``，建立一個新的消息物件，將所有參數傳遞給它的 :meth:`set_content` "
"方法，並將它 :meth:`~email.message.Message.attach` "
"到``多部分``。如果消息是非 ``multipart`` 、“multipart/related”或“multipart/"
"alternative”，請呼叫 make_mixed 然後按上述方式進行。如果未指定 "
"*content_manager*，則使用當前 :mod:`~email.policy` "
"指定的 ``content_manager``。如果新增的部分沒有 :mailheader:`Content-"
"Disposition` 標頭，請新增一個值為 ``attachment`` 的標頭。"
"通過將適當的選項傳遞給 ``content_manager，此方法可用於顯式附件（"
":mailheader:`Content-Disposition: attachment`）和``inline`` 附件（ "
":mailheader:`Content-Disposition: inline` ） ``。"

#: ../../library/email.message.rst:689
#, fuzzy
msgid "Remove the payload and all of the headers."
msgstr "刪除有效負載和所有標頭。"

#: ../../library/email.message.rst:694
#, fuzzy
msgid ""
"Remove the payload and all of the :exc:`Content-` headers, leaving all other "
"headers intact and in their original order."
msgstr "刪除有效負載和所有 :exc:`Content-` "
"標頭，使所有其他標頭保持原樣並保持其原始順序。"

#: ../../library/email.message.rst:698
#, fuzzy
msgid ":class:`EmailMessage` objects have the following instance attributes:"
msgstr ":class:`EmailMessage` 物件具有以下實例屬性："

#: ../../library/email.message.rst:703
#, fuzzy
msgid ""
"The format of a MIME document allows for some text between the blank line "
"following the headers, and the first multipart boundary string. Normally, "
"this text is never visible in a MIME-aware mail reader because it falls "
"outside the standard MIME armor.  However, when viewing the raw text of the "
"message, or when viewing the message in a non-MIME aware reader, this text "
"can become visible."
msgstr ""
"MIME "
"文檔的格式允許在標題後面的空行和第一個多部分邊界字串之間有一些文本。通常，"
"此文本在支援 MIME 的郵件閱讀器中永遠不可見，因為它不在標準 MIME "
"防護範圍之內。但是，在查看消息的原始文本時，或者在非 MIME "
"感知閱讀器中查看消息時，此文本可能會變得可見。"

#: ../../library/email.message.rst:710
#, fuzzy
msgid ""
"The *preamble* attribute contains this leading extra-armor text for MIME "
"documents.  When the :class:`~email.parser.Parser` discovers some text after "
"the headers but before the first boundary string, it assigns this text to "
"the message's *preamble* attribute.  When the :class:`~email.generator."
"Generator` is writing out the plain text representation of a MIME message, "
"and it finds the message has a *preamble* attribute, it will write this text "
"in the area between the headers and the first boundary.  See :mod:`email."
"parser` and :mod:`email.generator` for details."
msgstr ""
"*preamble* 屬性包含用於 MIME 文檔的這個領先的額外裝甲文本。當 :class:`~email."
"parser.Parser` 在標頭之後但在第一個邊界字串之前發現一些文本時，"
"它會將此文本分配給消息的 *preamble* 屬性。當 :class:`~email.generator."
"Generator` 正在寫出 MIME 消息的純文本表示時，它發現該消息具有 *preamble* "
"屬性，它會將此文本寫入標題和第一個邊界。有關詳細資訊，請參閱 :mod:`email."
"parser` 和 :mod:`email.generator`。"

#: ../../library/email.message.rst:720
#, fuzzy
msgid ""
"Note that if the message object has no preamble, the *preamble* attribute "
"will be ``None``."
msgstr "請注意，如果消息對像沒有前導碼，*preamble* 屬性將為 ``None``。"

#: ../../library/email.message.rst:726
#, fuzzy
msgid ""
"The *epilogue* attribute acts the same way as the *preamble* attribute, "
"except that it contains text that appears between the last boundary and the "
"end of the message.  As with the :attr:`~EmailMessage.preamble`, if there is "
"no epilog text this attribute will be ``None``."
msgstr ""
"*epilogue* 屬性與 *preamble* "
"屬性的作用相同，只是它包含出現在最後一個邊界和消息結尾之間的文本。與 "
":attr:`~EmailMessage.preamble` 一樣，如果沒有結尾文本，則此屬性將為 "
"``None``。"

#: ../../library/email.message.rst:734
#, fuzzy
msgid ""
"The *defects* attribute contains a list of all the problems found when "
"parsing this message.  See :mod:`email.errors` for a detailed description of "
"the possible parsing defects."
msgstr "*defects* 屬性包含解析此消息時發現的所有問題的列表。有關可能的解析缺陷的詳細"
"描述，請參見 :mod:`email.errors`。"

#: ../../library/email.message.rst:741
#, fuzzy
msgid ""
"This class represents a subpart of a MIME message.  It is identical to :"
"class:`EmailMessage`, except that no :mailheader:`MIME-Version` headers are "
"added when :meth:`~EmailMessage.set_content` is called, since sub-parts do "
"not need their own :mailheader:`MIME-Version` headers."
msgstr ""
"此類表示 MIME 消息的子部分。它與 :class:`EmailMessage` 相同，只是在呼叫 "
":meth:`~EmailMessage.set_content` 時不新增 :mailheader:`MIME-Version` 標頭，"
"因為子部分不需要它們自己的 :mailheader: `MIME-Version` 標頭。"

#: ../../library/email.message.rst:748
msgid "Footnotes"
msgstr "註解"

#: ../../library/email.message.rst:749
#, fuzzy
msgid ""
"Originally added in 3.4 as a :term:`provisional module <provisional "
"package>`.  Docs for legacy message class moved to :ref:`compat32_message`."
msgstr "最初在 3.4 中新增為 :term:`臨時模組 <臨時包>`。遺留消息類的文檔已移至 "
":ref:`compat32_message`。"
