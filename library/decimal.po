# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-26 00:19+0000\n"
"PO-Revision-Date: 2018-05-23 14:43+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/decimal.rst:2
msgid ":mod:`decimal` --- Decimal fixed point and floating point arithmetic"
msgstr ":mod:`decimal` --- 十進位數固定點和浮點運算"

#: ../../library/decimal.rst:15
msgid "**Source code:** :source:`Lib/decimal.py`"
msgstr "**原始碼：**\\ :source:`Lib/decimal.py`"

#: ../../library/decimal.rst:33
#, fuzzy
msgid ""
"The :mod:`decimal` module provides support for fast correctly rounded "
"decimal floating point arithmetic. It offers several advantages over the :"
"class:`float` datatype:"
msgstr ":mod:`decimal` 模組提供對快速正確四捨五入的十進位浮點運算的支援。與 "
":class:`float` 資料型別相比，它有幾個優點："

#: ../../library/decimal.rst:37
#, fuzzy
msgid ""
"Decimal \"is based on a floating-point model which was designed with people "
"in mind, and necessarily has a paramount guiding principle -- computers must "
"provide an arithmetic that works in the same way as the arithmetic that "
"people learn at school.\" -- excerpt from the decimal arithmetic "
"specification."
msgstr ""
"Decimal“基於一個以人為本的浮點模型，並且必然有一個至高無上的指導原則——計算機"
"必須提供一種與人們在學校學習的演算法相同的演算法。” -- 摘自十進位算術規範。"

#: ../../library/decimal.rst:42
#, fuzzy
msgid ""
"Decimal numbers can be represented exactly.  In contrast, numbers like "
"``1.1`` and ``2.2`` do not have exact representations in binary floating "
"point. End users typically would not expect ``1.1 + 2.2`` to display as "
"``3.3000000000000003`` as it does with binary floating point."
msgstr ""
"十進位數可以精確表示。相比之下，像“1.1”和“2."
"2”這樣的數字在二進位浮點數中沒有精確的表示。最終使用者通常不希望 ``1.1 + 2."
"2`` 像二進位浮點數那樣顯示為 ``3.3000000000000003``。"

#: ../../library/decimal.rst:47
#, fuzzy
msgid ""
"The exactness carries over into arithmetic.  In decimal floating point, "
"``0.1 + 0.1 + 0.1 - 0.3`` is exactly equal to zero.  In binary floating "
"point, the result is ``5.5511151231257827e-017``.  While near to zero, the "
"differences prevent reliable equality testing and differences can "
"accumulate. For this reason, decimal is preferred in accounting applications "
"which have strict equality invariants."
msgstr ""
"精確性延續到算術中。在十進位浮點數中，“0.1 + 0.1 + 0.1 - 0."
"3”正好等於零。在二進位浮點數中，結果是 ``5.5511151231257827e-017``。雖然接近"
"於零，但差異會阻止可靠的相等性測試，並且差異會累積。因此，在具有嚴格相等不變"
"數的會計應用程式中，十進位是首選。"

#: ../../library/decimal.rst:54
#, fuzzy
msgid ""
"The decimal module incorporates a notion of significant places so that "
"``1.30 + 1.20`` is ``2.50``.  The trailing zero is kept to indicate "
"significance. This is the customary presentation for monetary applications. "
"For multiplication, the \"schoolbook\" approach uses all the figures in the "
"multiplicands.  For instance, ``1.3 * 1.2`` gives ``1.56`` while ``1.30 * "
"1.20`` gives ``1.5600``."
msgstr ""
"decimal 模組包含一個重要位置的概念，因此 ``1.30 + 1.20`` 是 ``2.50``。保留尾"
"隨零以指示重要性。這是貨幣應用程式的習慣表示。對於乘法，“教科書”方法使用被乘"
"數中的所有數字。例如，``1.3 * 1.2`` 給出``1.56`` 而``1.30 * 1.20`` 給出``1."
"5600``。"

#: ../../library/decimal.rst:61
#, fuzzy
msgid ""
"Unlike hardware based binary floating point, the decimal module has a user "
"alterable precision (defaulting to 28 places) which can be as large as "
"needed for a given problem:"
msgstr "與基於硬件的二進位浮點數不同，decimal 模組具有使用者可更改的精度（預設為 28 "
"位），對於給定問題，它可以根據需要設定為最大："

#: ../../library/decimal.rst:73
#, fuzzy
msgid ""
"Both binary and decimal floating point are implemented in terms of published "
"standards.  While the built-in float type exposes only a modest portion of "
"its capabilities, the decimal module exposes all required parts of the "
"standard. When needed, the programmer has full control over rounding and "
"signal handling. This includes an option to enforce exact arithmetic by "
"using exceptions to block any inexact operations."
msgstr ""
"二進位和十進位浮點數都是根據已發布的標準實作的。雖然內建 float "
"型別隻公開了其功能的一小部分，但 decimal 模組公開了標準的所有必需部分。需要時"
"，程式員可以完全控制舍入和信號處理。這包括通過使用例外來阻止任何不精確的操作"
"來強制執行精確算術的選項。"

#: ../../library/decimal.rst:80
#, fuzzy
msgid ""
"The decimal module was designed to support \"without prejudice, both exact "
"unrounded decimal arithmetic (sometimes called fixed-point arithmetic) and "
"rounded floating-point arithmetic.\"  -- excerpt from the decimal arithmetic "
"specification."
msgstr "decimal 模組旨在支援“不帶偏見地支援精確的非四捨五入十進位算術（有時稱為定點算"
"術）和四捨五入浮點算術。” -- 摘自十進位算術規範。"

#: ../../library/decimal.rst:85
#, fuzzy
msgid ""
"The module design is centered around three concepts:  the decimal number, "
"the context for arithmetic, and signals."
msgstr "模組設計以三個概念為中心：十進位數、算術上下文和信號。"

#: ../../library/decimal.rst:88
#, fuzzy
msgid ""
"A decimal number is immutable.  It has a sign, coefficient digits, and an "
"exponent.  To preserve significance, the coefficient digits do not truncate "
"trailing zeros.  Decimals also include special values such as ``Infinity``, "
"``-Infinity``, and ``NaN``.  The standard also differentiates ``-0`` from "
"``+0``."
msgstr ""
"十進位數是不可變的。它有一個符號、係數數字和一個指數。為了保持顯著性，係數數"
"字不會截斷尾隨零。小數還包括特殊值，例如 ``Infinity`` 、 ``-Infinity`` 和 ``NaN``。該標"
"準還將 ``-0``與 ``+0``區分開來。"

#: ../../library/decimal.rst:94
#, fuzzy
msgid ""
"The context for arithmetic is an environment specifying precision, rounding "
"rules, limits on exponents, flags indicating the results of operations, and "
"trap enablers which determine whether signals are treated as exceptions.  "
"Rounding options include :const:`ROUND_CEILING`, :const:`ROUND_DOWN`, :const:"
"`ROUND_FLOOR`, :const:`ROUND_HALF_DOWN`, :const:`ROUND_HALF_EVEN`, :const:"
"`ROUND_HALF_UP`, :const:`ROUND_UP`, and :const:`ROUND_05UP`."
msgstr ""
"算術的上下文是指定精度、舍入規則、指數限制、指示操作結果的旗標以及確定信號是"
"否被視為例外的陷阱啟動器的環境。舍入選項包括 :const:`ROUND_CEILING`、:const:`"
"ROUND_DOWN`、:const:`ROUND_FLOOR`、:const:`ROUND_HALF_DOWN`、:const:`ROUND_HA"
"LF_EVEN`、:const:`ROUND_HALF_UP`、:const:`ROUND_UP `, 和 "
":const:`ROUND_05UP`。"

#: ../../library/decimal.rst:101
#, fuzzy
msgid ""
"Signals are groups of exceptional conditions arising during the course of "
"computation.  Depending on the needs of the application, signals may be "
"ignored, considered as informational, or treated as exceptions. The signals "
"in the decimal module are: :const:`Clamped`, :const:`InvalidOperation`, :"
"const:`DivisionByZero`, :const:`Inexact`, :const:`Rounded`, :const:"
"`Subnormal`, :const:`Overflow`, :const:`Underflow` and :const:"
"`FloatOperation`."
msgstr ""
"信號是在計算過程中出現的一組例外情況。根據應用程式的需要，信號可能會被忽略、"
"被視為資訊或被視為例外。十進位模組中的信號是 :const:`Clamped`, "
":const:`InvalidOperation`, :const:`DivisionByZero`, :const:`Inexact`, "
":const:`Rounded`, :const:`Subnormal`, :const:`Overflow`、:const:`Underflow` "
"和 :const:`FloatOperation`。"

#: ../../library/decimal.rst:108
#, fuzzy
msgid ""
"For each signal there is a flag and a trap enabler.  When a signal is "
"encountered, its flag is set to one, then, if the trap enabler is set to "
"one, an exception is raised.  Flags are sticky, so the user needs to reset "
"them before monitoring a calculation."
msgstr ""
"對於每個信號，都有一個旗標和一個陷阱啟動器。當遇到信號時，其旗標設定為 "
"1，然後，如果陷阱啟動器設定為 "
"1，則會引發例外。旗標是粘性的，因此使用者需要在監控計算之前重置它們。"

#: ../../library/decimal.rst:116
#, fuzzy
msgid ""
"IBM's General Decimal Arithmetic Specification, `The General Decimal "
"Arithmetic Specification <https://speleotrove.com/decimal/decarith.html>`_."
msgstr ""
"IBM 的通用十進位算術規範，`通用十進位算術規範 <https://speleotrove.com/"
"decimal/decarith.html>`_。"

#: ../../library/decimal.rst:125
#, fuzzy
msgid "Quick-start Tutorial"
msgstr "快速入門教程"

#: ../../library/decimal.rst:127
#, fuzzy
msgid ""
"The usual start to using decimals is importing the module, viewing the "
"current context with :func:`getcontext` and, if necessary, setting new "
"values for precision, rounding, or enabled traps::"
msgstr "使用小數的通常開始是導入模組，使用 :func:`getcontext` "
"查看當前上下文，並在必要時為精度、舍入或啟用的陷阱設定新值::"

#: ../../library/decimal.rst:139
#, fuzzy
msgid ""
"Decimal instances can be constructed from integers, strings, floats, or "
"tuples. Construction from an integer or a float performs an exact conversion "
"of the value of that integer or float.  Decimal numbers include special "
"values such as ``NaN`` which stands for \"Not a number\", positive and "
"negative ``Infinity``, and ``-0``::"
msgstr ""
"Decimal 實例可以從整數、字串、浮點數或元組構造。從整數或浮點數構造執行該整數"
"或浮點數的值的精確轉換。十進位數包括特殊值，例如代表“不是數字”的 ``NaN``、正負“I"
"nfinity”和 ``-0``::"

#: ../../library/decimal.rst:163
#, fuzzy
msgid ""
"If the :exc:`FloatOperation` signal is trapped, accidental mixing of "
"decimals and floats in constructors or ordering comparisons raises an "
"exception::"
msgstr "如果 :exc:`FloatOperation` "
"信號被捕獲，構造函式中小數和浮點數的意外混合或排序比較會引發例外::"

#: ../../library/decimal.rst:182
#, fuzzy
msgid ""
"The significance of a new Decimal is determined solely by the number of "
"digits input.  Context precision and rounding only come into play during "
"arithmetic operations."
msgstr "新 Decimal "
"的重要性僅由輸入的位數決定。上下文精度和舍入僅在算術運算期間起作用。"

#: ../../library/decimal.rst:199
#, fuzzy
msgid ""
"If the internal limits of the C version are exceeded, constructing a decimal "
"raises :class:`InvalidOperation`::"
msgstr "如果超過了 C 版本的內部限制，則構造小數會引發 :class:`InvalidOperation`::"

#: ../../library/decimal.rst:209
#, fuzzy
msgid ""
"Decimals interact well with much of the rest of Python.  Here is a small "
"decimal floating point flying circus:"
msgstr "小數與 Python 的大部分其他部分交互良好。這是一個小十進位浮點飛行馬戲團："

#: ../../library/decimal.rst:241
#, fuzzy
msgid "And some mathematical functions are also available to Decimal:"
msgstr "並且一些數學函式也可用於 Decimal："

#: ../../library/decimal.rst:253
#, fuzzy
msgid ""
"The :meth:`~Decimal.quantize` method rounds a number to a fixed exponent.  "
"This method is useful for monetary applications that often round results to "
"a fixed number of places:"
msgstr ":meth:`~Decimal.quantize` 方法將數字四捨五入為固定指數。此方法對於經常將結果"
"四捨五入到固定位數的貨幣應用程式很有用："

#: ../../library/decimal.rst:262
#, fuzzy
msgid ""
"As shown above, the :func:`getcontext` function accesses the current context "
"and allows the settings to be changed.  This approach meets the needs of "
"most applications."
msgstr "如上所示，:func:`getcontext` "
"函式訪問當前上下文並允許更改設定。這種方法可以滿足大多數應用程式的需要。"

#: ../../library/decimal.rst:266
#, fuzzy
msgid ""
"For more advanced work, it may be useful to create alternate contexts using "
"the Context() constructor.  To make an alternate active, use the :func:"
"`setcontext` function."
msgstr "對於更高階的工作，使用 Context() "
"構造函式建立備用上下文可能很有用。要激活備用，請使用 :func:`setcontext` "
"函式。"

#: ../../library/decimal.rst:270
#, fuzzy
msgid ""
"In accordance with the standard, the :mod:`decimal` module provides two "
"ready to use standard contexts, :const:`BasicContext` and :const:"
"`ExtendedContext`. The former is especially useful for debugging because "
"many of the traps are enabled:"
msgstr ""
"根據標準，:mod:`decimal` "
"模組提供了兩個隨時可用的標准上下文，:const:`BasicContext` 和 "
":const:`ExtendedContext`。前者對於除錯特別有用，因為啟用了許多陷阱："

#: ../../library/decimal.rst:299
#, fuzzy
msgid ""
"Contexts also have signal flags for monitoring exceptional conditions "
"encountered during computations.  The flags remain set until explicitly "
"cleared, so it is best to clear the flags before each set of monitored "
"computations by using the :meth:`~Context.clear_flags` method. ::"
msgstr ""
"上下文也有信號旗標，用於監視計算過程中遇到的例外情況。旗標在明確清除之前一直"
"保持設定狀態，因此最好在每組受監控的計算之前使用 :meth:`~Context.clear_flags`"
" 方法清除旗標。 ::"

#: ../../library/decimal.rst:312
#, fuzzy
msgid ""
"The *flags* entry shows that the rational approximation to pi was rounded "
"(digits beyond the context precision were thrown away) and that the result "
"is inexact (some of the discarded digits were non-zero)."
msgstr "*flags* 條目顯示 pi 的有理近似值已四捨五入（超出上下文精度的數字被丟棄）並且"
"結果不准確（一些丟棄的數字是非零的）。"

#: ../../library/decimal.rst:316
#, fuzzy
msgid ""
"Individual traps are set using the dictionary in the :attr:`~Context.traps` "
"attribute of a context:"
msgstr "使用上下文的 :attr:`~Context.traps` 屬性中的字典設定各個陷阱："

#: ../../library/decimal.rst:331
#, fuzzy
msgid ""
"Most programs adjust the current context only once, at the beginning of the "
"program.  And, in many applications, data is converted to :class:`Decimal` "
"with a single cast inside a loop.  With context set and decimals created, "
"the bulk of the program manipulates the data no differently than with other "
"Python numeric types."
msgstr ""
"大多數程式只在程式開始時調整一次當前上下文。而且，在許多應用程式中，"
"資料通過循環內的單個轉換轉換為 Decimal。通過設定上下文和建立小數，"
"程式的大部分操作資料與使用其他 Python 數字型別沒有什麼不同。"

#: ../../library/decimal.rst:343
#, fuzzy
msgid "Decimal objects"
msgstr "小數物件"

#: ../../library/decimal.rst:348
#, fuzzy
msgid "Construct a new :class:`Decimal` object based from *value*."
msgstr "根據 *value* 構造一個新的 Decimal 物件。"

#: ../../library/decimal.rst:350
#, fuzzy
msgid ""
"*value* can be an integer, string, tuple, :class:`float`, or another :class:"
"`Decimal` object. If no *value* is given, returns ``Decimal('0')``.  If "
"*value* is a string, it should conform to the decimal numeric string syntax "
"after leading and trailing whitespace characters, as well as underscores "
"throughout, are removed::"
msgstr ""
"*value* 可以是整數、字串、元組、:class:`float` 或另一個 :class:`Decimal` "
"物件。如果沒有給出 *value*，則回傳 ``Decimal('0')``。如果 *value* 是一個字串"
"，在刪除前導和尾隨空白字元以及整個底線後，它應該符合十進位數字字串語法："

#: ../../library/decimal.rst:366
#, fuzzy
msgid ""
"Other Unicode decimal digits are also permitted where ``digit`` appears "
"above.  These include decimal digits from various other alphabets (for "
"example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits "
"``'\\uff10'`` through ``'\\uff19'``."
msgstr ""
"上面出現“數字”的地方也允許使用其他 Unicode "
"十進位數字。這些包括來自各種其他字母表的十進位數字（例如，Arabic-Indic 和 "
"Devanāgarī 數字）以及全角數字 ``'\\uff10'`` 到 ``'\\uff19'``。"

#: ../../library/decimal.rst:371
#, fuzzy
msgid ""
"If *value* is a :class:`tuple`, it should have three components, a sign "
"(``0`` for positive or ``1`` for negative), a :class:`tuple` of digits, and "
"an integer exponent. For example, ``Decimal((0, (1, 4, 1, 4), -3))`` returns "
"``Decimal('1.414')``."
msgstr ""
"如果 *value* 是一個 tuple，它應該有三個組成部分，一個符號（ ``0``表示正數， ``1``表"
"示負數），一個由數字組成的元組，以及整數指數。例如，``Decimal((0, (1, 4, 1, "
"4), -3))`` 回傳 ``Decimal('1.414')``。"

#: ../../library/decimal.rst:376
#, fuzzy
msgid ""
"If *value* is a :class:`float`, the binary floating point value is "
"losslessly converted to its exact decimal equivalent.  This conversion can "
"often require 53 or more digits of precision.  For example, "
"``Decimal(float('1.1'))`` converts to "
"``Decimal('1.100000000000000088817841970012523233890533447265625')``."
msgstr ""
"如果 *value* 是 "
":class:`float`，則二進位浮點值無損地轉換為其精確的十進位等效值。"
"這種轉換通常需要 53 位或更多位的精度。例如，``Decimal(float('1.1'))`` 轉換為 "
"``Decimal('1.100000000000000088817841970012523233890533447265625')``。"

#: ../../library/decimal.rst:382
#, fuzzy
msgid ""
"The *context* precision does not affect how many digits are stored. That is "
"determined exclusively by the number of digits in *value*. For example, "
"``Decimal('3.00000')`` records all five zeros even if the context precision "
"is only three."
msgstr ""
"*context* 精度不影響儲存的位數。這完全由 *value* "
"中的位數決定。例如，``Decimal('3.00000')`` "
"記錄所有五個零，即使上下文精度只有三個。"

#: ../../library/decimal.rst:387
#, fuzzy
msgid ""
"The purpose of the *context* argument is determining what to do if *value* "
"is a malformed string.  If the context traps :const:`InvalidOperation`, an "
"exception is raised; otherwise, the constructor returns a new Decimal with "
"the value of ``NaN``."
msgstr ""
"*context* 參數的目的是確定如果 *value* 是格式錯誤的字串時要做什麼。如果上下文"
"陷阱 :const:`InvalidOperation`，則會引發例外；否則，構造函式回傳一個值為 ``NaN``"
"的新 Decimal。"

#: ../../library/decimal.rst:392
#, fuzzy
msgid "Once constructed, :class:`Decimal` objects are immutable."
msgstr "一旦構建，Decimal 對像是不可變的。"

#: ../../library/decimal.rst:394
#, fuzzy
msgid ""
"The argument to the constructor is now permitted to be a :class:`float` "
"instance."
msgstr "現在允許構造函式的參數是一個 :class:`float` 實例。"

#: ../../library/decimal.rst:398
#, fuzzy
msgid ""
":class:`float` arguments raise an exception if the :exc:`FloatOperation` "
"trap is set. By default the trap is off."
msgstr "如果設定了 :exc:`FloatOperation` 陷阱，則 :class:`float` "
"參數會引發例外。預設情況下，陷阱處於關閉狀態。"

#: ../../library/decimal.rst:402
#, fuzzy
msgid ""
"Underscores are allowed for grouping, as with integral and floating-point "
"literals in code."
msgstr "允許使用底線進行分組，就像程式碼中的整數和浮點文字一樣。"

#: ../../library/decimal.rst:406
#, fuzzy
msgid ""
"Decimal floating point objects share many properties with the other built-in "
"numeric types such as :class:`float` and :class:`int`.  All of the usual "
"math operations and special methods apply.  Likewise, decimal objects can be "
"copied, pickled, printed, used as dictionary keys, used as set elements, "
"compared, sorted, and coerced to another type (such as :class:`float` or :"
"class:`int`)."
msgstr ""
"十進位浮點物件與其他內建數字型別共享許多屬性，例如 float 和 int。所有常用的數"
"學運算和特殊方法都適用。同樣，十進位物件可以被複製、醃製、印出、用作字典鍵、"
"用作集合元素、比較、排序和強制轉換為另一種型別（例如 float 或 int）。"

#: ../../library/decimal.rst:413
#, fuzzy
msgid ""
"There are some small differences between arithmetic on Decimal objects and "
"arithmetic on integers and floats.  When the remainder operator ``%`` is "
"applied to Decimal objects, the sign of the result is the sign of the "
"*dividend* rather than the sign of the divisor::"
msgstr ""
"Decimal 物件的算術與整數和浮點數的算術之間存在一些細微差別。當餘數運算符 "
"``%`` 應用於 Decimal 物件時，結果的符號是 *dividend* 的符號而不是除數的符號::"

#: ../../library/decimal.rst:423
#, fuzzy
msgid ""
"The integer division operator ``//`` behaves analogously, returning the "
"integer part of the true quotient (truncating towards zero) rather than its "
"floor, so as to preserve the usual identity ``x == (x // y) * y + x % y``::"
msgstr ""
"整數除法運算符 `//`` "
"的行為類似，回傳真商的整數部分（截斷為零）而不是它的底數，以保持通常的身份 ``"
"x == (x // y) * y + x % y``::"

#: ../../library/decimal.rst:432
#, fuzzy
msgid ""
"The ``%`` and ``//`` operators implement the ``remainder`` and ``divide-"
"integer`` operations (respectively) as described in the specification."
msgstr "``%`` 和``//`` 運算符實作了``remainder`` 和``divide-integer`` "
"操作（分別），如規範中所述。"

#: ../../library/decimal.rst:436
#, fuzzy
msgid ""
"Decimal objects cannot generally be combined with floats or instances of :"
"class:`fractions.Fraction` in arithmetic operations: an attempt to add a :"
"class:`Decimal` to a :class:`float`, for example, will raise a :exc:"
"`TypeError`.  However, it is possible to use Python's comparison operators "
"to compare a :class:`Decimal` instance ``x`` with another number ``y``.  "
"This avoids confusing results when doing equality comparisons between "
"numbers of different types."
msgstr ""
"Decimal 物件通常不能在算術運算中與浮點數或 fractions.Fraction "
"的實例組合：例如，嘗試將 Decimal 新增到 float "
"將引發 :exc:`TypeError`。但是，可以使用 Python 的比較運算符將 Decimal 實例 "
"``x`` 與另一個數字 ``y`` "
"進行比較。這避免了在不同型別的數字之間進行相等比較時混淆結果。"

#: ../../library/decimal.rst:444
#, fuzzy
msgid ""
"Mixed-type comparisons between :class:`Decimal` instances and other numeric "
"types are now fully supported."
msgstr "現在完全支援 Decimal 實例和其他數字型別之間的混合型別比較。"

#: ../../library/decimal.rst:448
#, fuzzy
msgid ""
"In addition to the standard numeric properties, decimal floating point "
"objects also have a number of specialized methods:"
msgstr "除了標準的數字屬性，十進位浮點對像還有一些專門的方法："

#: ../../library/decimal.rst:454
#, fuzzy
msgid ""
"Return the adjusted exponent after shifting out the coefficient's rightmost "
"digits until only the lead digit remains: ``Decimal('321e+5').adjusted()`` "
"returns seven.  Used for determining the position of the most significant "
"digit with respect to the decimal point."
msgstr ""
"在移出係數最右邊的數字直到只剩下前導數字後回傳調整後的指數：``Decimal('321e+5"
"').adjusted()`` 回傳 7。用於確定最高有效位相對於小數點的位置。"

#: ../../library/decimal.rst:461
#, fuzzy
msgid ""
"Return a pair ``(n, d)`` of integers that represent the given :class:"
"`Decimal` instance as a fraction, in lowest terms and with a positive "
"denominator::"
msgstr "回傳一對 ``(n, d)`` 整數，表示給定的 Decimal "
"實例作為分數，以最小項表示並具有正分母::"

#: ../../library/decimal.rst:468
#, fuzzy
msgid ""
"The conversion is exact.  Raise OverflowError on infinities and ValueError "
"on NaNs."
msgstr "轉換是準確的。引發無窮大的 OverflowError 和 NaN 的 ValueError。"

#: ../../library/decimal.rst:475
#, fuzzy
msgid ""
"Return a :term:`named tuple` representation of the number: "
"``DecimalTuple(sign, digits, exponent)``."
msgstr "回傳數字的命名元組表示：``DecimalTuple(sign, digits, exponent)``。"

#: ../../library/decimal.rst:481
#, fuzzy
msgid ""
"Return the canonical encoding of the argument.  Currently, the encoding of "
"a :class:`Decimal` instance is always canonical, so this operation returns "
"its argument unchanged."
msgstr "回傳參數的規範編碼。目前，Decimal "
"實例的編碼始終是規範的，因此此操作回傳其參數不變。"

#: ../../library/decimal.rst:487
#, fuzzy
msgid ""
"Compare the values of two Decimal instances.  :meth:`compare` returns a "
"Decimal instance, and if either operand is a NaN then the result is a NaN::"
msgstr ""
"比較兩個 Decimal 實例的值。 :meth:`compare` 回傳一個 Decimal 實例，"
"如果任一操作數是 NaN，則結果是 NaN::"

#: ../../library/decimal.rst:498
#, fuzzy
msgid ""
"This operation is identical to the :meth:`compare` method, except that all "
"NaNs signal.  That is, if neither operand is a signaling NaN then any quiet "
"NaN operand is treated as though it were a signaling NaN."
msgstr ""
"此操作與 :meth:`compare` 方法相同，除了所有 NaN 信號。也就是說，"
"如果兩個操作數都不是信號 NaN，則任何安靜的 NaN 操作數都被視為信號 NaN。"

#: ../../library/decimal.rst:504
#, fuzzy
msgid ""
"Compare two operands using their abstract representation rather than their "
"numerical value.  Similar to the :meth:`compare` method, but the result "
"gives a total ordering on :class:`Decimal` instances.  Two :class:`Decimal` "
"instances with the same numeric value but different representations compare "
"unequal in this ordering:"
msgstr ""
"使用它們的抽象表示而不是它們的數值來比較兩個操作數。類似於 :meth:`compare` "
"方法，但結果給出了 :class:`Decimal` 實例的總排序。"
"具有相同數值但不同表示的兩個 Decimal 實例在此排序中比較不相等："

#: ../../library/decimal.rst:513
#, fuzzy
msgid ""
"Quiet and signaling NaNs are also included in the total ordering.  The "
"result of this function is ``Decimal('0')`` if both operands have the same "
"representation, ``Decimal('-1')`` if the first operand is lower in the total "
"order than the second, and ``Decimal('1')`` if the first operand is higher "
"in the total order than the second operand.  See the specification for "
"details of the total order."
msgstr ""
"安靜和信號 NaN 也包含在總排序中。如果兩個操作數具有相同的表示，則此函式的結果"
"為“Decimal('0')”，如果第一個操作數的總順序低於第二個，則為“Decimal('-1')”，並"
"且``Decimal('1')`` 如果第一個操作數在總順序上高於第二個操作數。有關總訂單的詳"
"細資訊，請參閱規範。"

#: ../../library/decimal.rst:520 ../../library/decimal.rst:531
#: ../../library/decimal.rst:559 ../../library/decimal.rst:835
#, fuzzy
msgid ""
"This operation is unaffected by context and is quiet: no flags are changed "
"and no rounding is performed.  As an exception, the C version may raise "
"InvalidOperation if the second operand cannot be converted exactly."
msgstr ""
"此操作不受上下文影響並且是安靜的：沒有更改旗標，也沒有執行舍入。作為例外，如"
"果無法準確轉換第二個操作數，C 版本可能會引發 InvalidOperation。"

#: ../../library/decimal.rst:526
#, fuzzy
msgid ""
"Compare two operands using their abstract representation rather than their "
"value as in :meth:`compare_total`, but ignoring the sign of each operand. "
"``x.compare_total_mag(y)`` is equivalent to ``x.copy_abs().compare_total(y."
"copy_abs())``."
msgstr ""
"使用它們的抽象表示而不是它們的值來比較兩個操作數，如 :meth:`compare_total` "
"中那樣，但忽略每個操作數的符號。 ``x.compare_total_mag(y)`` 等價於 ``x."
"copy_abs().compare_total(y.copy_abs())``。"

#: ../../library/decimal.rst:537
#, fuzzy
msgid ""
"Just returns self, this method is only to comply with the Decimal "
"Specification."
msgstr "Just returns self，此方法僅符合Decimal Specification。"

#: ../../library/decimal.rst:542
#, fuzzy
msgid ""
"Return the absolute value of the argument.  This operation is unaffected by "
"the context and is quiet: no flags are changed and no rounding is performed."
msgstr "回傳參數的絕對值。此操作不受上下文影響並且是安靜的：沒有更改旗標，也沒有執行"
"舍入。"

#: ../../library/decimal.rst:548
#, fuzzy
msgid ""
"Return the negation of the argument.  This operation is unaffected by the "
"context and is quiet: no flags are changed and no rounding is performed."
msgstr "回傳參數的否定。此操作不受上下文影響並且是安靜的：沒有更改旗標，也沒有執行舍"
"入。"

#: ../../library/decimal.rst:553
#, fuzzy
msgid ""
"Return a copy of the first operand with the sign set to be the same as the "
"sign of the second operand.  For example:"
msgstr "回傳第一個操作數的副本，其符號設定為與第二個操作數的符號相同。例如："

#: ../../library/decimal.rst:565
#, fuzzy
msgid ""
"Return the value of the (natural) exponential function ``e**x`` at the given "
"number.  The result is correctly rounded using the :const:`ROUND_HALF_EVEN` "
"rounding mode."
msgstr "回傳給定數字處的（自然）指數函式“e**x”的值。結果使用 :const:`ROUND_HALF_EVEN`"
" 舍入模式正確舍入。"

#: ../../library/decimal.rst:576
#, fuzzy
msgid ""
"Alternative constructor that only accepts instances of :class:`float` or :"
"class:`int`."
msgstr "僅接受 :class:`float` 或 :class:`int` 實例的替代構造函式。"

#: ../../library/decimal.rst:579
#, fuzzy
msgid ""
"Note ``Decimal.from_float(0.1)`` is not the same as ``Decimal('0.1')``. "
"Since 0.1 is not exactly representable in binary floating point, the value "
"is stored as the nearest representable value which is "
"``0x1.999999999999ap-4``.  That equivalent value in decimal is "
"``0.1000000000000000055511151231257827021181583404541015625``."
msgstr ""
"注意``Decimal.from_float(0.1)`` 與``Decimal('0.1')`` 不同。由於 0.1 "
"不能用二進位浮點數精確表示，因此該值儲存為最接近的可表示值，即“0x1."
"999999999999ap-4”。十進位的等效值是“0."
"1000000000000000055511151231257827021181583404541015625”。"

#: ../../library/decimal.rst:585
#, fuzzy
msgid ""
"From Python 3.2 onwards, a :class:`Decimal` instance can also be constructed "
"directly from a :class:`float`."
msgstr "從 Python 3.2 開始，Decimal 實例也可以直接從 float 構造。"

#: ../../library/decimal.rst:603
#, fuzzy
msgid ""
"Fused multiply-add.  Return self*other+third with no rounding of the "
"intermediate product self*other."
msgstr "融合乘加。回傳 self*other+third 中間產品 self*other 沒有四捨五入。"

#: ../../library/decimal.rst:611
#, fuzzy
msgid ""
"Return :const:`True` if the argument is canonical and :const:`False` "
"otherwise.  Currently, a :class:`Decimal` instance is always canonical, so "
"this operation always returns :const:`True`."
msgstr ""
"如果參數是規範的，則回傳 :const:`True`，否則回傳 :const:`False`。目前，"
"Decimal 實例始終是規範的，因此此操作始終回傳 True。"

#: ../../library/decimal.rst:617
#, fuzzy
msgid ""
"Return :const:`True` if the argument is a finite number, and :const:`False` "
"if the argument is an infinity or a NaN."
msgstr ""
"如果參數是有限數，則回傳 :const:`True`；如果參數是無窮大或 "
"NaN，則回傳 :const:`False`。"

#: ../../library/decimal.rst:622
#, fuzzy
msgid ""
"Return :const:`True` if the argument is either positive or negative infinity "
"and :const:`False` otherwise."
msgstr "如果參數是正無窮大或負無窮大，則回傳 :const:`True`，否則回傳 :const:`False`。"

#: ../../library/decimal.rst:627
#, fuzzy
msgid ""
"Return :const:`True` if the argument is a (quiet or signaling) NaN and :"
"const:`False` otherwise."
msgstr "如果參數是（安靜的或發信號的）NaN，則回傳 :const:`True`，否則回傳 :const:`F"
"alse`。"

#: ../../library/decimal.rst:632
#, fuzzy
msgid ""
"Return :const:`True` if the argument is a *normal* finite number.  Return :"
"const:`False` if the argument is zero, subnormal, infinite or a NaN."
msgstr "如果參數是*普通*有限數，則回傳 :const:`True`。如果參數為零、次正規、無限或 "
"NaN，則回傳 :const:`False`。"

#: ../../library/decimal.rst:637
#, fuzzy
msgid ""
"Return :const:`True` if the argument is a quiet NaN, and :const:`False` "
"otherwise."
msgstr "如果參數是一個安靜的 NaN，則回傳 :const:`True`，否則回傳 :const:`False`。"

#: ../../library/decimal.rst:642
#, fuzzy
msgid ""
"Return :const:`True` if the argument has a negative sign and :const:`False` "
"otherwise.  Note that zeros and NaNs can both carry signs."
msgstr "如果參數具有負號，則回傳 :const:`True`，否則回傳 :const:`False`。請注意，"
"零和 NaN 都可以帶符號。"

#: ../../library/decimal.rst:647
#, fuzzy
msgid ""
"Return :const:`True` if the argument is a signaling NaN and :const:`False` "
"otherwise."
msgstr "如果參數是信號 NaN，則回傳 :const:`True`，否則回傳 :const:`False`。"

#: ../../library/decimal.rst:652
#, fuzzy
msgid ""
"Return :const:`True` if the argument is subnormal, and :const:`False` "
"otherwise."
msgstr "如果參數次正規，則回傳 :const:`True`，否則回傳 :const:`False`。"

#: ../../library/decimal.rst:657
#, fuzzy
msgid ""
"Return :const:`True` if the argument is a (positive or negative) zero and :"
"const:`False` otherwise."
msgstr "如果參數為（正或負）零，則回傳 :const:`True`，否則回傳 :const:`False`。"

#: ../../library/decimal.rst:662
#, fuzzy
msgid ""
"Return the natural (base e) logarithm of the operand.  The result is "
"correctly rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr "回傳操作數的自然（以 e 為底）對數。結果使用 :const:`ROUND_HALF_EVEN` "
"舍入模式正確舍入。"

#: ../../library/decimal.rst:667
#, fuzzy
msgid ""
"Return the base ten logarithm of the operand.  The result is correctly "
"rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr "回傳操作數的以十為底的對數。結果使用 :const:`ROUND_HALF_EVEN` "
"舍入模式正確舍入。"

#: ../../library/decimal.rst:672
#, fuzzy
msgid ""
"For a nonzero number, return the adjusted exponent of its operand as a :"
"class:`Decimal` instance.  If the operand is a zero then ``Decimal('-"
"Infinity')`` is returned and the :const:`DivisionByZero` flag is raised.  If "
"the operand is an infinity then ``Decimal('Infinity')`` is returned."
msgstr ""
"對於非零數，將其操作數的調整指數作為 Decimal "
"實例回傳。如果操作數為零，則回傳“Decimal('-Infinity')”並引發 DivisionByZero "
"旗標。如果操作數是無窮大，則回傳 Decimal('Infinity')。"

#: ../../library/decimal.rst:680
#, fuzzy
msgid ""
":meth:`logical_and` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise "
"``and`` of the two operands."
msgstr ""
":meth:`logical_and` 是一個邏輯運算，需要兩個*邏輯操作數*（參見 :ref:`logical_"
"operands_label`）。結果是兩個操作數的數字 ``和``。"

#: ../../library/decimal.rst:686
#, fuzzy
msgid ""
":meth:`logical_invert` is a logical operation.  The result is the digit-wise "
"inversion of the operand."
msgstr ":meth:`logical_invert` 是一個邏輯操作。結果是操作數的數字反轉。"

#: ../../library/decimal.rst:691
#, fuzzy
msgid ""
":meth:`logical_or` is a logical operation which takes two *logical operands* "
"(see :ref:`logical_operands_label`).  The result is the digit-wise ``or`` of "
"the two operands."
msgstr ""
":meth:`logical_or` 是一個邏輯運算，需要兩個*邏輯操作數*（參見 :ref:`logical_o"
"perands_label`）。結果是兩個操作數的數字 ``或``。"

#: ../../library/decimal.rst:697
#, fuzzy
msgid ""
":meth:`logical_xor` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise "
"exclusive or of the two operands."
msgstr ""
":meth:`logical_xor` 是一個邏輯運算，需要兩個*邏輯操作數*（參見 :ref:`logical_"
"operands_label`）。結果是兩個操作數的數字異或。"

#: ../../library/decimal.rst:703
#, fuzzy
msgid ""
"Like ``max(self, other)`` except that the context rounding rule is applied "
"before returning and that ``NaN`` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""
"類似於 ``max(self, other)`` 除了在回傳之前應用上下文舍入規則並且 ``NaN`` "
"值被發出信號或被忽略（取決於上下文以及它們是發出信號還是安靜）。"

#: ../../library/decimal.rst:710
#, fuzzy
msgid ""
"Similar to the :meth:`.max` method, but the comparison is done using the "
"absolute values of the operands."
msgstr "類似於 :meth:`.max` 方法，但比較是使用操作數的絕對值完成的。"

#: ../../library/decimal.rst:715
#, fuzzy
msgid ""
"Like ``min(self, other)`` except that the context rounding rule is applied "
"before returning and that ``NaN`` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""
"類似於 min(self, other) 除了在回傳之前應用上下文舍入規則並且 NaN "
"值要么發出信號要么忽略（取決於上下文以及它們是發出信號還是安靜）。"

#: ../../library/decimal.rst:722
#, fuzzy
msgid ""
"Similar to the :meth:`.min` method, but the comparison is done using the "
"absolute values of the operands."
msgstr "類似於 :meth:`.min` 方法，但比較是使用操作數的絕對值完成的。"

#: ../../library/decimal.rst:727
#, fuzzy
msgid ""
"Return the largest number representable in the given context (or in the "
"current thread's context if no context is given) that is smaller than the "
"given operand."
msgstr "回傳在給定上下文中（如果沒有給出上下文，則在當前執行緒的上下文中）可表示的小"
"於給定操作數的最大數字。"

#: ../../library/decimal.rst:733
#, fuzzy
msgid ""
"Return the smallest number representable in the given context (or in the "
"current thread's context if no context is given) that is larger than the "
"given operand."
msgstr "回傳在給定上下文中（如果沒有給出上下文，則在當前執行緒的上下文中）可表示的大"
"於給定操作數的最小數字。"

#: ../../library/decimal.rst:739
#, fuzzy
msgid ""
"If the two operands are unequal, return the number closest to the first "
"operand in the direction of the second operand.  If both operands are "
"numerically equal, return a copy of the first operand with the sign set to "
"be the same as the sign of the second operand."
msgstr ""
"如果兩個操作數不相等，則回傳在第二個操作數的方向上最接近第一個操作數的數。如"
"果兩個操作數在數值上相等，則回傳第一個操作數的副本，其符號設定為與第二個操作"
"數的符號相同。"

#: ../../library/decimal.rst:746
#, fuzzy
msgid ""
"Normalize the number by stripping the rightmost trailing zeros and "
"converting any result equal to ``Decimal('0')`` to ``Decimal('0e0')``. Used "
"for producing canonical values for attributes of an equivalence class. For "
"example, ``Decimal('32.100')`` and ``Decimal('0.321000e+2')`` both normalize "
"to the equivalent value ``Decimal('32.1')``."
msgstr ""
"通過去除最右邊的尾隨零並將任何等於“Decimal('0')”的結果轉換為“Decimal('0e0')”"
"來規範化數字。用於為等價類的屬性生成規範值。例如，``Decimal('32.100')`` 和 "
"``Decimal('0.321000e+2')`` 都歸一化為等效值 ``Decimal('32.1')"
"``。"

#: ../../library/decimal.rst:755
#, fuzzy
msgid ""
"Return a string describing the *class* of the operand.  The returned value "
"is one of the following ten strings."
msgstr "回傳描述操作數的 *class* 的字串。回傳值為以下十個字串之一。"

#: ../../library/decimal.rst:758
#, fuzzy
msgid "``\"-Infinity\"``, indicating that the operand is negative infinity."
msgstr "``\"-Infinity\"``，表示操作數為負無窮大。"

#: ../../library/decimal.rst:759
#, fuzzy
msgid ""
"``\"-Normal\"``, indicating that the operand is a negative normal number."
msgstr "``\"-Normal\"``，表示操作數是負正規數。"

#: ../../library/decimal.rst:760
#, fuzzy
msgid ""
"``\"-Subnormal\"``, indicating that the operand is negative and subnormal."
msgstr "``\"-Subnormal\"``，表示操作數為負且次正規。"

#: ../../library/decimal.rst:761
#, fuzzy
msgid "``\"-Zero\"``, indicating that the operand is a negative zero."
msgstr "``\"-Zero\"``，表示操作數為負零。"

#: ../../library/decimal.rst:762
#, fuzzy
msgid "``\"+Zero\"``, indicating that the operand is a positive zero."
msgstr "``\"+Zero\"``，表示操作數為正零。"

#: ../../library/decimal.rst:763
#, fuzzy
msgid ""
"``\"+Subnormal\"``, indicating that the operand is positive and subnormal."
msgstr "``\"+Subnormal\"``，表示操作數為正且次正規。"

#: ../../library/decimal.rst:764
#, fuzzy
msgid ""
"``\"+Normal\"``, indicating that the operand is a positive normal number."
msgstr "``\"+Normal\"``，表示操作數是一個正常的正數。"

#: ../../library/decimal.rst:765
#, fuzzy
msgid "``\"+Infinity\"``, indicating that the operand is positive infinity."
msgstr "``\"+Infinity\"``，表示操作數為正無窮大。"

#: ../../library/decimal.rst:766
#, fuzzy
msgid "``\"NaN\"``, indicating that the operand is a quiet NaN (Not a Number)."
msgstr "``\"NaN\"``，表示操作數是一個安靜的 NaN（不是數字）。"

#: ../../library/decimal.rst:767
#, fuzzy
msgid "``\"sNaN\"``, indicating that the operand is a signaling NaN."
msgstr "``\"sNaN\"``，表示操作數是一個信號 NaN。"

#: ../../library/decimal.rst:771
#, fuzzy
msgid ""
"Return a value equal to the first operand after rounding and having the "
"exponent of the second operand."
msgstr "在四捨五入後回傳一個等於第一個操作數並具有第二個操作數的指數的值。"

#: ../../library/decimal.rst:777
#, fuzzy
msgid ""
"Unlike other operations, if the length of the coefficient after the quantize "
"operation would be greater than precision, then an :const:`InvalidOperation` "
"is signaled. This guarantees that, unless there is an error condition, the "
"quantized exponent is always equal to that of the right-hand operand."
msgstr ""
"與其他操作不同，如果量化操作後係數的長度大於精度，則會發出 InvalidOperation "
"信號。這保證了除非出現錯誤情況，否則量化指數始終等於右側操作數的指數。"

#: ../../library/decimal.rst:783
#, fuzzy
msgid ""
"Also unlike other operations, quantize never signals Underflow, even if the "
"result is subnormal and inexact."
msgstr "與其他操作不同的是，量化從不發出下溢信號，即使結果不正常且不准確。"

#: ../../library/decimal.rst:786
#, fuzzy
msgid ""
"If the exponent of the second operand is larger than that of the first then "
"rounding may be necessary.  In this case, the rounding mode is determined by "
"the ``rounding`` argument if given, else by the given ``context`` argument; "
"if neither argument is given the rounding mode of the current thread's "
"context is used."
msgstr ""
"如果第二個操作數的指數大於第一個操作數的指數，則可能需要進行舍入。在這種情況"
"下，舍入模式由給定的 ``rounding`` 參數決定，否則由給定的 ``context`` "
"參數決定；如果兩個參數都沒有給出，則使用當前執行緒上下文的捨入模式。"

#: ../../library/decimal.rst:792
#, fuzzy
msgid ""
"An error is returned whenever the resulting exponent is greater than :attr:"
"`~Context.Emax` or less than :meth:`~Context.Etiny`."
msgstr "只要結果指數大於 :attr:`~Context.Emax` 或小於 :meth:`~Context."
"Etiny`，就會回傳錯誤。"

#: ../../library/decimal.rst:797
#, fuzzy
msgid ""
"Return ``Decimal(10)``, the radix (base) in which the :class:`Decimal` class "
"does all its arithmetic.  Included for compatibility with the specification."
msgstr "回傳 ``Decimal(10)``，Decimal "
"類在其中執行所有算術運算的基數（基數）。包括在內是為了與規範相容。"

#: ../../library/decimal.rst:803
#, fuzzy
msgid ""
"Return the remainder from dividing *self* by *other*.  This differs from "
"``self % other`` in that the sign of the remainder is chosen so as to "
"minimize its absolute value.  More precisely, the return value is ``self - n "
"* other`` where ``n`` is the integer nearest to the exact value of ``self / "
"other``, and if two integers are equally near then the even one is chosen."
msgstr ""
"回傳 *self* 除以 *other* 的餘數。這與“self % "
"other”的不同之處在於，選擇餘數的符號是為了最小化其絕對值。更準確地說，"
"回傳值是 ``self - n * other`` 其中 ``n`` 是最接近 ``self / other`` "
"精確值的整數，如果兩個整數同樣接近則偶數被選中。"

#: ../../library/decimal.rst:810
#, fuzzy
msgid "If the result is zero then its sign will be the sign of *self*."
msgstr "如果結果為零，則其符號將為 *self* 的符號。"

#: ../../library/decimal.rst:821
#, fuzzy
msgid ""
"Return the result of rotating the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to rotate.  If the second operand is "
"positive then rotation is to the left; otherwise rotation is to the right. "
"The coefficient of the first operand is padded on the left with zeros to "
"length precision if necessary.  The sign and exponent of the first operand "
"are unchanged."
msgstr ""
"回傳將第一個操作數的數字按第二個操作數指定的數量旋轉的結果。"
"第二個操作數必須是 -precision 到 precision 範圍內的整數。第二個操作數的絕對值"
"給出了要旋轉的位數。如果第二個操作數是正數，則向左旋轉；否則旋轉是向右的。如"
"有必要，第一個操作數的係數在左側用零填充以達到長度精度。第一個操作數的符號和"
"指數不變。"

#: ../../library/decimal.rst:832
#, fuzzy
msgid ""
"Test whether self and other have the same exponent or whether both are "
"``NaN``."
msgstr "測試 self 和 other 是否具有相同的指數，或者兩者是否都是 ``NaN``。"

#: ../../library/decimal.rst:841
#, fuzzy
msgid ""
"Return the first operand with exponent adjusted by the second. Equivalently, "
"return the first operand multiplied by ``10**other``.  The second operand "
"must be an integer."
msgstr "回傳第一個操作數，指數由第二個調整。等價地，回傳第一個操作數乘以 "
"``10**other``。第二個操作數必須是整數。"

#: ../../library/decimal.rst:847
#, fuzzy
msgid ""
"Return the result of shifting the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to shift.  If the second operand is "
"positive then the shift is to the left; otherwise the shift is to the "
"right.  Digits shifted into the coefficient are zeros.  The sign and "
"exponent of the first operand are unchanged."
msgstr ""
"回傳將第一個操作數的數字移位第二個操作數指定的量的結果。第二個操作數必須是 -"
"precision 到 precision 範圍內的整數。第二個操作數的絕對值給出了要移動的位數。"
"如果第二個操作數是正數，則向左移動；否則向右移動。移入係數的數字為零。第一個"
"操作數的符號和指數不變。"

#: ../../library/decimal.rst:857
#, fuzzy
msgid "Return the square root of the argument to full precision."
msgstr "將參數的平方根回傳到全精度。"

#: ../../library/decimal.rst:862 ../../library/decimal.rst:1457
#, fuzzy
msgid ""
"Convert to a string, using engineering notation if an exponent is needed."
msgstr "如果需要指數，則使用工程符號轉換為字串。"

#: ../../library/decimal.rst:864 ../../library/decimal.rst:1459
#, fuzzy
msgid ""
"Engineering notation has an exponent which is a multiple of 3.  This can "
"leave up to 3 digits to the left of the decimal place and may require the "
"addition of either one or two trailing zeros."
msgstr "工程符號的指數是 3 的倍數。這可以在小數點左側保留最多 3 "
"位數字，並且可能需要新增一個或兩個尾隨零。"

#: ../../library/decimal.rst:868
#, fuzzy
msgid ""
"For example, this converts ``Decimal('123E+1')`` to ``Decimal('1.23E+3')``."
msgstr "例如，這會將“Decimal('123E+1')”轉換為“Decimal('1.23E+3')”。"

#: ../../library/decimal.rst:872
#, fuzzy
msgid ""
"Identical to the :meth:`to_integral_value` method.  The ``to_integral`` name "
"has been kept for compatibility with older versions."
msgstr "與 :meth:`to_integral_value` 方法相同。為了與舊版本相容，保留了 "
"``to_integral`` 名稱。"

#: ../../library/decimal.rst:877
#, fuzzy
msgid ""
"Round to the nearest integer, signaling :const:`Inexact` or :const:`Rounded` "
"as appropriate if rounding occurs.  The rounding mode is determined by the "
"``rounding`` parameter if given, else by the given ``context``.  If neither "
"parameter is given then the rounding mode of the current context is used."
msgstr ""
"四捨五入到最接近的整數，如果發生四捨五入，則根據需要發出信號 :const:`Inexact`"
" 或 :const:`Rounded`。舍入模式由 ``rounding`` 參數決定，否則由給定的 "
"``context`` 決定。如果沒有給出任何參數，則使用當前上下文的捨入模式。"

#: ../../library/decimal.rst:885
#, fuzzy
msgid ""
"Round to the nearest integer without signaling :const:`Inexact` or :const:"
"`Rounded`.  If given, applies *rounding*; otherwise, uses the rounding "
"method in either the supplied *context* or the current context."
msgstr ""
"舍入到最接近的整數而不發出信號 :const:`Inexact` 或 "
":const:`Rounded`。如果給定，應用*舍入*；否則，在提供的 *context* "
"或當前上下文中使用舍入方法。"

#: ../../library/decimal.rst:893
#, fuzzy
msgid "Logical operands"
msgstr "邏輯操作數"

#: ../../library/decimal.rst:895
#, fuzzy
msgid ""
"The :meth:`~Decimal.logical_and`, :meth:`~Decimal.logical_invert`, :meth:"
"`~Decimal.logical_or`, and :meth:`~Decimal.logical_xor` methods expect their "
"arguments to be *logical operands*.  A *logical operand* is a :class:"
"`Decimal` instance whose exponent and sign are both zero, and whose digits "
"are all either ``0`` or ``1``."
msgstr ""
":meth:`~Decimal.logical_and`、:meth:`~Decimal."
"logical_invert`、:meth:`~Decimal.logical_or` 和 :meth:`~Decimal.logical_xor` "
"方法期望它們的參數是*邏輯操作數*。 *邏輯操作數*是一個 Decimal "
"實例，其指數和符號均為零，並且其數字全部為 ``0``或 ``1``。"

#: ../../library/decimal.rst:907
#, fuzzy
msgid "Context objects"
msgstr "上下文物件"

#: ../../library/decimal.rst:909
#, fuzzy
msgid ""
"Contexts are environments for arithmetic operations.  They govern precision, "
"set rules for rounding, determine which signals are treated as exceptions, "
"and limit the range for exponents."
msgstr "上下文是算術運算的環境。它們控制精度，設定舍入規則，確定哪些信號被視為例外，"
"並限制指數的範圍。"

#: ../../library/decimal.rst:913
#, fuzzy
msgid ""
"Each thread has its own current context which is accessed or changed using "
"the :func:`getcontext` and :func:`setcontext` functions:"
msgstr "每個執行緒都有自己的當前上下文，可以使用 :func:`getcontext` 和 "
":func:`setcontext` 函式訪問或更改："

#: ../../library/decimal.rst:919
#, fuzzy
msgid "Return the current context for the active thread."
msgstr "回傳活動執行緒的當前上下文。"

#: ../../library/decimal.rst:924
#, fuzzy
msgid "Set the current context for the active thread to *c*."
msgstr "將活動執行緒的當前上下文設定為 *c*。"

#: ../../library/decimal.rst:926
#, fuzzy
msgid ""
"You can also use the :keyword:`with` statement and the :func:`localcontext` "
"function to temporarily change the active context."
msgstr "您還可以使用 :keyword:`with` 語句和 :func:`localcontext` "
"函式臨時更改活動上下文。"

#: ../../library/decimal.rst:931
#, fuzzy
msgid ""
"Return a context manager that will set the current context for the active "
"thread to a copy of *ctx* on entry to the with-statement and restore the "
"previous context when exiting the with-statement. If no context is "
"specified, a copy of the current context is used.  The *kwargs* argument is "
"used to set the attributes of the new context."
msgstr ""
"回傳一個上下文管理器，它將在進入 with 語句時將活動執行緒的當前上下文設定為 "
"*ctx* 的副本，並在退出 with "
"語句時恢復先前的上下文。如果未指定上下文，則使用當前上下文的副本。 *kwargs* "
"參數用於設定新上下文的屬性。"

#: ../../library/decimal.rst:937
#, fuzzy
msgid ""
"For example, the following code sets the current decimal precision to 42 "
"places, performs a calculation, and then automatically restores the previous "
"context::"
msgstr "例如，下面的程式碼將當前的小數精度設定為42位，進行一次計算，然後自動恢復之前"
"的上下文："

#: ../../library/decimal.rst:947
#, fuzzy
msgid "Using keyword arguments, the code would be the following::"
msgstr "使用關鍵字參數，程式碼如下："

#: ../../library/decimal.rst:955
#, fuzzy
msgid ""
"Raises :exc:`TypeError` if *kwargs* supplies an attribute that :class:"
"`Context` doesn't support.  Raises either :exc:`TypeError` or :exc:"
"`ValueError` if *kwargs* supplies an invalid value for an attribute."
msgstr ""
"如果 *kwargs* 提供了 :class:`Context` 不支援的屬性，則引發 :exc:`TypeError`。"
"如果 *kwargs* 為屬性提供無效值，則引發 :exc:`TypeError` 或 "
":exc:`ValueError`。"

#: ../../library/decimal.rst:959
#, fuzzy
msgid ""
":meth:`localcontext` now supports setting context attributes through the use "
"of keyword arguments."
msgstr ":meth:`localcontext` 現在支援通過使用關鍵字參數設定上下文屬性。"

#: ../../library/decimal.rst:962
#, fuzzy
msgid ""
"New contexts can also be created using the :class:`Context` constructor "
"described below. In addition, the module provides three pre-made contexts:"
msgstr "也可以使用下面描述的 :class:`Context` "
"構造函式建立新的上下文。此外，該模組還提供了三個預製上下文："

#: ../../library/decimal.rst:968
#, fuzzy
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to :const:"
"`ROUND_HALF_UP`.  All flags are cleared.  All traps are enabled (treated as "
"exceptions) except :const:`Inexact`, :const:`Rounded`, and :const:"
"`Subnormal`."
msgstr ""
"這是通用十進位算術規範定義的標准上下文。精度設定為九。舍入設定為 "
":const:`ROUND_HALF_UP`。所有旗標都被清除。除 "
":const:`Inexact`、:const:`Rounded` 和 :const:`Subnormal` "
"外，所有陷阱均已啟用（視為例外）。"

#: ../../library/decimal.rst:974
#, fuzzy
msgid ""
"Because many of the traps are enabled, this context is useful for debugging."
msgstr "因為啟用了許多陷阱，所以此上下文對於除錯很有用。"

#: ../../library/decimal.rst:979
#, fuzzy
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to :const:"
"`ROUND_HALF_EVEN`.  All flags are cleared.  No traps are enabled (so that "
"exceptions are not raised during computations)."
msgstr ""
"這是通用十進位算術規範定義的標准上下文。精度設定為九。舍入設定為 :const:`ROUN"
"D_HALF_EVEN`。所有旗標都被清除。沒有啟用陷阱（以便在計算期間不會引發例外）。"

#: ../../library/decimal.rst:984
#, fuzzy
msgid ""
"Because the traps are disabled, this context is useful for applications that "
"prefer to have result value of ``NaN`` or ``Infinity`` instead of raising "
"exceptions.  This allows an application to complete a run in the presence of "
"conditions that would otherwise halt the program."
msgstr ""
"由於陷阱被禁用，此上下文對於更喜歡將結果值為 ``NaN``或 ``Infinity`` 而不是引發例外的"
"應用程式很有用。這允許應用程式在可能會停止程式的情況下完成運行。"

#: ../../library/decimal.rst:992
#, fuzzy
msgid ""
"This context is used by the :class:`Context` constructor as a prototype for "
"new contexts.  Changing a field (such a precision) has the effect of "
"changing the default for new contexts created by the :class:`Context` "
"constructor."
msgstr ""
"這個上下文被 :class:`Context` "
"構造函式用作新上下文的原型。更改欄位（例如精度）會更改由 :class:`Context` "
"構造函式建立的新上下文的預設值。"

#: ../../library/decimal.rst:996
#, fuzzy
msgid ""
"This context is most useful in multi-threaded environments.  Changing one of "
"the fields before threads are started has the effect of setting system-wide "
"defaults.  Changing the fields after threads have started is not recommended "
"as it would require thread synchronization to prevent race conditions."
msgstr ""
"此上下文在多執行緒環境中最有用。在執行緒啟動之前更改其中一個欄位具有設定系統"
"範圍預設值的效果。不建議在執行緒啟動後更改欄位，因為這需要執行緒同步以防止競"
"爭條件。"

#: ../../library/decimal.rst:1001
#, fuzzy
msgid ""
"In single threaded environments, it is preferable to not use this context at "
"all.  Instead, simply create contexts explicitly as described below."
msgstr "在單執行緒環境中，最好根本不使用此上下文。相反，只需如下所述顯式建立上下文。"

#: ../../library/decimal.rst:1004
#, fuzzy
msgid ""
"The default values are :attr:`Context.prec`\\ =\\ ``28``, :attr:`Context."
"rounding`\\ =\\ :const:`ROUND_HALF_EVEN`, and enabled traps for :class:"
"`Overflow`, :class:`InvalidOperation`, and :class:`DivisionByZero`."
msgstr ""
"預設值為 :attr:`Context.prec`\\ =\\ ``28``, :attr:`Context.rounding`\\ =\\ "
":const:`ROUND_HALF_EVEN`, 並為 :class:`Overflow` 啟用陷阱, "
":class:`InvalidOperation` 和 :class:`DivisionByZero`。"

#: ../../library/decimal.rst:1009
#, fuzzy
msgid ""
"In addition to the three supplied contexts, new contexts can be created with "
"the :class:`Context` constructor."
msgstr "除了提供的三個上下文之外，還可以使用 Context 構造函式建立新的上下文。"

#: ../../library/decimal.rst:1015
#, fuzzy
msgid ""
"Creates a new context.  If a field is not specified or is :const:`None`, the "
"default values are copied from the :const:`DefaultContext`.  If the *flags* "
"field is not specified or is :const:`None`, all flags are cleared."
msgstr ""
"建立一個新的上下文。如果欄位未指定或為 None，則預設值將從 DefaultContext "
"複製。如果未指定 *flags* 欄位或為 :const:`None`，則清除所有旗標。"

#: ../../library/decimal.rst:1019
#, fuzzy
msgid ""
"*prec* is an integer in the range [``1``, :const:`MAX_PREC`] that sets the "
"precision for arithmetic operations in the context."
msgstr ""
"*prec* 是 [``1``, :const:`MAX_PREC`] "
"範圍內的整數，用於設定上下文中算術運算的精度。"

#: ../../library/decimal.rst:1022
#, fuzzy
msgid ""
"The *rounding* option is one of the constants listed in the section "
"`Rounding Modes`_."
msgstr "*rounding* 選項是“舍入模式”部分中列出的常數之一。"

#: ../../library/decimal.rst:1025
#, fuzzy
msgid ""
"The *traps* and *flags* fields list any signals to be set. Generally, new "
"contexts should only set traps and leave the flags clear."
msgstr "*traps* 和 *flags* "
"欄位列出了要設定的任何信號。通常，新上下文應該只設定陷阱並清除旗標。"

#: ../../library/decimal.rst:1028
#, fuzzy
msgid ""
"The *Emin* and *Emax* fields are integers specifying the outer limits "
"allowable for exponents. *Emin* must be in the range [ :const:`MIN_EMIN`, "
"``0``], *Emax* in the range [``0``, :const:`MAX_EMAX`]."
msgstr ""
"*Emin* 和 *Emax* 欄位是指定指數允許的外部限制的整數。 *Emin* 必須在 "
"[ :const:`MIN_EMIN`, ``0``] 範圍內，*Emax* 在 [``0``, :const:`MAX_EMAX`] "
"範圍內。"

#: ../../library/decimal.rst:1032
#, fuzzy
msgid ""
"The *capitals* field is either ``0`` or ``1`` (the default). If set to "
"``1``, exponents are printed with a capital ``E``; otherwise, a lowercase "
"``e`` is used: ``Decimal('6.02e+23')``."
msgstr ""
"*capitals* 欄位是 ``0`` 或 ``1``（預設值）。如果設定為 ``1``，則指數以大寫字母“E"
"”印出；否則，使用小寫的 ``e``：“Decimal('6.02e+23')”。"

#: ../../library/decimal.rst:1036
#, fuzzy
msgid ""
"The *clamp* field is either ``0`` (the default) or ``1``. If set to ``1``, "
"the exponent ``e`` of a :class:`Decimal` instance representable in this "
"context is strictly limited to the range ``Emin - prec + 1 <= e <= Emax - "
"prec + 1``.  If *clamp* is ``0`` then a weaker condition holds: the adjusted "
"exponent of the :class:`Decimal` instance is at most :attr:`~Context.Emax`.  "
"When *clamp* is ``1``, a large normal number will, where possible, have its "
"exponent reduced and a corresponding number of zeros added to its "
"coefficient, in order to fit the exponent constraints; this preserves the "
"value of the number but loses information about significant trailing zeros.  "
"For example::"
msgstr ""
"*clamp* 欄位是 ``0``（預設值）或 ``1``。如果設定為 ``1``，"
"則在此上下文中可表示的 Decimal 實例的指數 ``e``嚴格限制在“Emin - prec + 1 <= e "
"<= Emax - prec”範圍內+ 1``。如果 *clamp* 是 ``0`` 則一個較弱的條件成立："
"Decimal 實例的調整指數最多為 :attr:`~Context.Emax`。當 *clamp* 為 ``1`` 時，"
"一個大的正態數將在可能的情況下減少其指數，並在其係數中新增相應數量的零，以適"
"應指數約束；這會保留數字的值，但會丟失有關重要尾隨零的資訊。例如：："

#: ../../library/decimal.rst:1051
#, fuzzy
msgid ""
"A *clamp* value of ``1`` allows compatibility with the fixed-width decimal "
"interchange formats specified in IEEE 754."
msgstr "``1`` 的 *clamp* 值允許與 IEEE 754 中指定的固定寬度十進位交換格式相容。"

#: ../../library/decimal.rst:1054
#, fuzzy
msgid ""
"The :class:`Context` class defines several general purpose methods as well "
"as a large number of methods for doing arithmetic directly in a given "
"context. In addition, for each of the :class:`Decimal` methods described "
"above (with the exception of the :meth:`~Decimal.adjusted` and :meth:"
"`~Decimal.as_tuple` methods) there is a corresponding :class:`Context` "
"method.  For example, for a :class:`Context` instance ``C`` and :class:"
"`Decimal` instance ``x``, ``C.exp(x)`` is equivalent to ``x."
"exp(context=C)``.  Each :class:`Context` method accepts a Python integer (an "
"instance of :class:`int`) anywhere that a Decimal instance is accepted."
msgstr ""
":class:`Context` "
"類定義了幾個通用方法以及大量在給定上下文中直接進行算術運算的方法。此外，"
"對於上述每個 Decimal 方法（除了 :meth:`~Decimal.adjusted` 和 :meth:`~Decimal."
"as_tuple` 方法）都有一個對應的 :class: `上下文`方法。例如，對於 "
":class:`Context` 實例 ``C`` 和 :class:`Decimal` 實例 ``x``，``C.exp(x)`` "
"等同於 ``x.exp(上下文=C）``。每個 :class:`Context` 方法在接受 Decimal "
"實例的任何地方都接受一個 Python 整數（一個 :class:`int` 的實例）。"

#: ../../library/decimal.rst:1067
#, fuzzy
msgid "Resets all of the flags to ``0``."
msgstr "將所有旗標重置為 ``0``。"

#: ../../library/decimal.rst:1071
#, fuzzy
msgid "Resets all of the traps to ``0``."
msgstr "將所有陷阱重置為 ``0``。"

#: ../../library/decimal.rst:1077
#, fuzzy
msgid "Return a duplicate of the context."
msgstr "回傳上下文的副本。"

#: ../../library/decimal.rst:1081
#, fuzzy
msgid "Return a copy of the Decimal instance num."
msgstr "回傳 Decimal 實例 num 的副本。"

#: ../../library/decimal.rst:1085
#, fuzzy
msgid ""
"Creates a new Decimal instance from *num* but using *self* as context. "
"Unlike the :class:`Decimal` constructor, the context precision, rounding "
"method, flags, and traps are applied to the conversion."
msgstr ""
"從 *num* 建立一個新的 Decimal 實例，但使用 *self* 作為上下文。與 Decimal "
"構造函式不同，上下文精度、舍入方法、旗標和陷阱應用於轉換。"

#: ../../library/decimal.rst:1089
#, fuzzy
msgid ""
"This is useful because constants are often given to a greater precision than "
"is needed by the application.  Another benefit is that rounding immediately "
"eliminates unintended effects from digits beyond the current precision. In "
"the following example, using unrounded inputs means that adding zero to a "
"sum can change the result:"
msgstr ""
"這很有用，因為常數的精度通常高於應用程式所需的精度。另一個好處是捨入會立即消"
"除超出當前精度的數字的意外影響。在以下示例中，使用未舍入的輸入意味著將零加到"
"總和中可以改變結果："

#: ../../library/decimal.rst:1103
#, fuzzy
msgid ""
"This method implements the to-number operation of the IBM specification. If "
"the argument is a string, no leading or trailing whitespace or underscores "
"are permitted."
msgstr "該方法實作了IBM規範的to-"
"number操作。如果參數是字串，則不允許有前導或尾隨空格或底線。"

#: ../../library/decimal.rst:1109
#, fuzzy
msgid ""
"Creates a new Decimal instance from a float *f* but rounding using *self* as "
"the context.  Unlike the :meth:`Decimal.from_float` class method, the "
"context precision, rounding method, flags, and traps are applied to the "
"conversion."
msgstr ""
"從浮點數 *f* 建立一個新的 Decimal 實例，但使用 *self* 作為上下文進行舍入。與 "
"Decimal.from_float 類方法不同，上下文精度、舍入方法、旗標和陷阱應用於轉換。"

#: ../../library/decimal.rst:1129
#, fuzzy
msgid ""
"Returns a value equal to ``Emin - prec + 1`` which is the minimum exponent "
"value for subnormal results.  When underflow occurs, the exponent is set to :"
"const:`Etiny`."
msgstr "回傳等於“Emin - prec + 1”的值，這是次正規結果的最小指數值。發生下溢時，"
"指數設定為 Etiny。"

#: ../../library/decimal.rst:1135
#, fuzzy
msgid "Returns a value equal to ``Emax - prec + 1``."
msgstr "回傳等於“Emax - prec + 1”的值。"

#: ../../library/decimal.rst:1137
#, fuzzy
msgid ""
"The usual approach to working with decimals is to create :class:`Decimal` "
"instances and then apply arithmetic operations which take place within the "
"current context for the active thread.  An alternative approach is to use "
"context methods for calculating within a specific context.  The methods are "
"similar to those for the :class:`Decimal` class and are only briefly "
"recounted here."
msgstr ""
"使用小數的常用方法是建立 Decimal 實例，然後應用在活動執行緒的當前上下文中發生"
"的算術運算。另一種方法是使用上下文方法在特定上下文中進行計算。這些方法類似於 "
"Decimal 類的方法，此處僅作簡要說明。"

#: ../../library/decimal.rst:1147
#, fuzzy
msgid "Returns the absolute value of *x*."
msgstr "回傳 *x* 的絕對值。"

#: ../../library/decimal.rst:1152
#, fuzzy
msgid "Return the sum of *x* and *y*."
msgstr "回傳 *x* 和 *y* 的總和。"

#: ../../library/decimal.rst:1157
#, fuzzy
msgid "Returns the same Decimal object *x*."
msgstr "回傳相同的 Decimal 物件 *x*。"

#: ../../library/decimal.rst:1162
#, fuzzy
msgid "Compares *x* and *y* numerically."
msgstr "比較 *x* 和 *y* 的數值。"

#: ../../library/decimal.rst:1167
#, fuzzy
msgid "Compares the values of the two operands numerically."
msgstr "比較兩個操作數的數值。"

#: ../../library/decimal.rst:1172
#, fuzzy
msgid "Compares two operands using their abstract representation."
msgstr "使用它們的抽象表示比較兩個操作數。"

#: ../../library/decimal.rst:1177
#, fuzzy
msgid ""
"Compares two operands using their abstract representation, ignoring sign."
msgstr "使用抽象表示比較兩個操作數，忽略符號。"

#: ../../library/decimal.rst:1182
#, fuzzy
msgid "Returns a copy of *x* with the sign set to 0."
msgstr "回傳符號設定為 0 的 *x* 副本。"

#: ../../library/decimal.rst:1187
#, fuzzy
msgid "Returns a copy of *x* with the sign inverted."
msgstr "回傳符號反轉的 *x* 副本。"

#: ../../library/decimal.rst:1192
#, fuzzy
msgid "Copies the sign from *y* to *x*."
msgstr "將符號從 *y* 複製到 *x*。"

#: ../../library/decimal.rst:1197
#, fuzzy
msgid "Return *x* divided by *y*."
msgstr "回傳 *x* 除以 *y*。"

#: ../../library/decimal.rst:1202
#, fuzzy
msgid "Return *x* divided by *y*, truncated to an integer."
msgstr "回傳 *x* 除以 *y*，截斷為整數。"

#: ../../library/decimal.rst:1207
#, fuzzy
msgid "Divides two numbers and returns the integer part of the result."
msgstr "將兩個數字相除並回傳結果的整數部分。"

#: ../../library/decimal.rst:1212
#, fuzzy
msgid "Returns ``e ** x``."
msgstr "回傳``e ** x``。"

#: ../../library/decimal.rst:1217
#, fuzzy
msgid "Returns *x* multiplied by *y*, plus *z*."
msgstr "回傳 *x* 乘以 *y*，再加上 *z*。"

#: ../../library/decimal.rst:1222
#, fuzzy
msgid "Returns ``True`` if *x* is canonical; otherwise returns ``False``."
msgstr "如果 *x* 是規範的，則回傳 ``True``；否則回傳 ``False``。"

#: ../../library/decimal.rst:1227
#, fuzzy
msgid "Returns ``True`` if *x* is finite; otherwise returns ``False``."
msgstr "如果 *x* 是有限的，則回傳 ``True``；否則回傳 ``False``。"

#: ../../library/decimal.rst:1232
#, fuzzy
msgid "Returns ``True`` if *x* is infinite; otherwise returns ``False``."
msgstr "如果 *x* 是無限的，則回傳 ``True``；否則回傳 ``False``。"

#: ../../library/decimal.rst:1237
#, fuzzy
msgid "Returns ``True`` if *x* is a qNaN or sNaN; otherwise returns ``False``."
msgstr "如果 *x* 是 qNaN 或 sNaN，則回傳 ``True``；否則回傳 ``False``。"

#: ../../library/decimal.rst:1242
#, fuzzy
msgid ""
"Returns ``True`` if *x* is a normal number; otherwise returns ``False``."
msgstr "如果 *x* 是一個普通數字，則回傳 ``True``；否則回傳 ``False``。"

#: ../../library/decimal.rst:1247
#, fuzzy
msgid "Returns ``True`` if *x* is a quiet NaN; otherwise returns ``False``."
msgstr "如果 *x* 是一個安靜的 NaN，則回傳 ``True``；否則回傳 ``False``。"

#: ../../library/decimal.rst:1252
#, fuzzy
msgid "Returns ``True`` if *x* is negative; otherwise returns ``False``."
msgstr "如果 *x* 為負，則回傳 ``True``；否則回傳 ``False``。"

#: ../../library/decimal.rst:1257
#, fuzzy
msgid ""
"Returns ``True`` if *x* is a signaling NaN; otherwise returns ``False``."
msgstr "如果 *x* 是一個信號 NaN，則回傳 ``True``；否則回傳 ``False``。"

#: ../../library/decimal.rst:1262
#, fuzzy
msgid "Returns ``True`` if *x* is subnormal; otherwise returns ``False``."
msgstr "如果 *x* 是次正規的，則回傳 ``True``；否則回傳 ``False``。"

#: ../../library/decimal.rst:1267
#, fuzzy
msgid "Returns ``True`` if *x* is a zero; otherwise returns ``False``."
msgstr "如果 *x* 為零，則回傳 ``True``；否則回傳 ``False``。"

#: ../../library/decimal.rst:1272
#, fuzzy
msgid "Returns the natural (base e) logarithm of *x*."
msgstr "回傳 *x* 的自然（以 e 為底）對數。"

#: ../../library/decimal.rst:1277
#, fuzzy
msgid "Returns the base 10 logarithm of *x*."
msgstr "回傳 *x* 的以 10 為底的對數。"

#: ../../library/decimal.rst:1282
#, fuzzy
msgid "Returns the exponent of the magnitude of the operand's MSD."
msgstr "回傳操作數的 MSD 大小的指數。"

#: ../../library/decimal.rst:1287
#, fuzzy
msgid "Applies the logical operation *and* between each operand's digits."
msgstr "在每個操作數的數字之間應用邏輯運算 *and*。"

#: ../../library/decimal.rst:1292
#, fuzzy
msgid "Invert all the digits in *x*."
msgstr "反轉 *x* 中的所有數字。"

#: ../../library/decimal.rst:1297
#, fuzzy
msgid "Applies the logical operation *or* between each operand's digits."
msgstr "在每個操作數的數字之間應用邏輯運算 *or*。"

#: ../../library/decimal.rst:1302
#, fuzzy
msgid "Applies the logical operation *xor* between each operand's digits."
msgstr "在每個操作數的數字之間應用邏輯運算 *xor*。"

#: ../../library/decimal.rst:1307
#, fuzzy
msgid "Compares two values numerically and returns the maximum."
msgstr "比較兩個值的數值並回傳最大值。"

#: ../../library/decimal.rst:1312 ../../library/decimal.rst:1322
#, fuzzy
msgid "Compares the values numerically with their sign ignored."
msgstr "比較數值並忽略其符號。"

#: ../../library/decimal.rst:1317
#, fuzzy
msgid "Compares two values numerically and returns the minimum."
msgstr "比較兩個值的數值並回傳最小值。"

#: ../../library/decimal.rst:1327
#, fuzzy
msgid "Minus corresponds to the unary prefix minus operator in Python."
msgstr "減號對應於 Python 中的一元前綴減號運算符。"

#: ../../library/decimal.rst:1332
#, fuzzy
msgid "Return the product of *x* and *y*."
msgstr "回傳 *x* 和 *y* 的乘積。"

#: ../../library/decimal.rst:1337
#, fuzzy
msgid "Returns the largest representable number smaller than *x*."
msgstr "回傳小於 *x* 的最大可表示數。"

#: ../../library/decimal.rst:1342
#, fuzzy
msgid "Returns the smallest representable number larger than *x*."
msgstr "回傳大於 *x* 的最小可表示數。"

#: ../../library/decimal.rst:1347
#, fuzzy
msgid "Returns the number closest to *x*, in direction towards *y*."
msgstr "回傳最接近 *x* 的數字，朝向 *y*。"

#: ../../library/decimal.rst:1352
#, fuzzy
msgid "Reduces *x* to its simplest form."
msgstr "將 *x* 簡化為最簡單的形式。"

#: ../../library/decimal.rst:1357
#, fuzzy
msgid "Returns an indication of the class of *x*."
msgstr "回傳 *x* 類的指示。"

#: ../../library/decimal.rst:1362
#, fuzzy
msgid ""
"Plus corresponds to the unary prefix plus operator in Python.  This "
"operation applies the context precision and rounding, so it is *not* an "
"identity operation."
msgstr "Plus 對應於 Python 中的一元前綴加運算符。此操作應用上下文精度和舍入，因此它 "
"*不是* 身份操作。"

#: ../../library/decimal.rst:1369
#, fuzzy
msgid "Return ``x`` to the power of ``y``, reduced modulo ``modulo`` if given."
msgstr "回傳 ``x`` 的 ``y`` 次方，如果給定則減少模 ``modulo``。"

#: ../../library/decimal.rst:1371
#, fuzzy
msgid ""
"With two arguments, compute ``x**y``.  If ``x`` is negative then ``y`` must "
"be integral.  The result will be inexact unless ``y`` is integral and the "
"result is finite and can be expressed exactly in 'precision' digits. The "
"rounding mode of the context is used. Results are always correctly rounded "
"in the Python version."
msgstr ""
"使用兩個參數，計算“x**y”。如果 ``x`` 為負數，則 ``y`` "
"必須是整數。結果將是不精確的，除非 ``y`` "
"是整數並且結果是有限的並且可以精確地用“精度”數字表示。使用上下文的捨入模式。"
"結果在 Python 版本中始終正確四捨五入。"

#: ../../library/decimal.rst:1377
#, fuzzy
msgid ""
"``Decimal(0) ** Decimal(0)`` results in ``InvalidOperation``, and if "
"``InvalidOperation`` is not trapped, then results in ``Decimal('NaN')``."
msgstr ""
"``Decimal(0) ** Decimal(0)`` 導致 ``InvalidOperation``，如果 "
"``InvalidOperation`` 未被捕獲，則導致 ``Decimal('NaN')``。"

#: ../../library/decimal.rst:1380
#, fuzzy
msgid ""
"The C module computes :meth:`power` in terms of the correctly rounded :meth:"
"`exp` and :meth:`ln` functions. The result is well-defined but only \"almost "
"always correctly rounded\"."
msgstr ""
"C 模組根據正確舍入的 :meth:`exp` 和 :meth:`ln` 函式計算 "
":meth:`power`。結果是明確定義的，但只是“幾乎總是正確舍入”。"

#: ../../library/decimal.rst:1385
#, fuzzy
msgid ""
"With three arguments, compute ``(x**y) % modulo``.  For the three argument "
"form, the following restrictions on the arguments hold:"
msgstr "使用三個參數，計算 ``(x**y) % modulo``。對於三參數形式，對參數有以下限制："

#: ../../library/decimal.rst:1388
#, fuzzy
msgid "all three arguments must be integral"
msgstr "所有三個參數都必須是整數"

#: ../../library/decimal.rst:1389
#, fuzzy
msgid "``y`` must be nonnegative"
msgstr "``y`` 必須是非負數"

#: ../../library/decimal.rst:1390
#, fuzzy
msgid "at least one of ``x`` or ``y`` must be nonzero"
msgstr "``x`` 或 ``y`` 中至少有一個必須是非零的"

#: ../../library/decimal.rst:1391
#, fuzzy
msgid "``modulo`` must be nonzero and have at most 'precision' digits"
msgstr "``modulo`` 必須為非零且最多具有“精度”數字"

#: ../../library/decimal.rst:1393
#, fuzzy
msgid ""
"The value resulting from ``Context.power(x, y, modulo)`` is equal to the "
"value that would be obtained by computing ``(x**y) % modulo`` with unbounded "
"precision, but is computed more efficiently.  The exponent of the result is "
"zero, regardless of the exponents of ``x``, ``y`` and ``modulo``.  The "
"result is always exact."
msgstr ""
"``Context.power(x, y, modulo)`` 產生的值等於通過無限精度計算 `(x**y) % "
"modulo`` 獲得的值，但計算效率更高."
"結果的指數為零，無論 ``x``、 ``y``和 ``modulo``的指數如何。結果總是準確的。"

#: ../../library/decimal.rst:1403
#, fuzzy
msgid "Returns a value equal to *x* (rounded), having the exponent of *y*."
msgstr "回傳等於 *x*（四捨五入）的值，指數為 *y*。"

#: ../../library/decimal.rst:1408
#, fuzzy
msgid "Just returns 10, as this is Decimal, :)"
msgstr "只回傳 10，因為這是十進位，:)"

#: ../../library/decimal.rst:1413
#, fuzzy
msgid "Returns the remainder from integer division."
msgstr "回傳整數除法的餘數。"

#: ../../library/decimal.rst:1415
#, fuzzy
msgid ""
"The sign of the result, if non-zero, is the same as that of the original "
"dividend."
msgstr "如果結果的符號非零，則與原始股息的符號相同。"

#: ../../library/decimal.rst:1421
#, fuzzy
msgid ""
"Returns ``x - y * n``, where *n* is the integer nearest the exact value of "
"``x / y`` (if the result is 0 then its sign will be the sign of *x*)."
msgstr "回傳 ``x - y * n``，其中 *n* 是最接近 ``x / y`` 精確值的整數（如果結果為 0，"
"則其符號將是 *x* 的符號）。"

#: ../../library/decimal.rst:1427
#, fuzzy
msgid "Returns a rotated copy of *x*, *y* times."
msgstr "回傳 *x*, *y* 次的旋轉副本。"

#: ../../library/decimal.rst:1432
#, fuzzy
msgid "Returns ``True`` if the two operands have the same exponent."
msgstr "如果兩個操作數具有相同的指數，則回傳 ``True``。"

#: ../../library/decimal.rst:1437
#, fuzzy
msgid "Returns the first operand after adding the second value its exp."
msgstr "將第二個值與其 exp 相加後回傳第一個操作數。"

#: ../../library/decimal.rst:1442
#, fuzzy
msgid "Returns a shifted copy of *x*, *y* times."
msgstr "回傳 *x*, *y* 次的移位副本。"

#: ../../library/decimal.rst:1447
#, fuzzy
msgid "Square root of a non-negative number to context precision."
msgstr "非負數的平方根到上下文精度。"

#: ../../library/decimal.rst:1452
#, fuzzy
msgid "Return the difference between *x* and *y*."
msgstr "回傳 *x* 和 *y* 之間的差異。"

#: ../../library/decimal.rst:1466
#, fuzzy
msgid "Rounds to an integer."
msgstr "四捨五入為整數。"

#: ../../library/decimal.rst:1471
#, fuzzy
msgid "Converts a number to a string using scientific notation."
msgstr "使用科學記數法將數字轉換為字串。"

#: ../../library/decimal.rst:1478
msgid "Constants"
msgstr "常數"

#: ../../library/decimal.rst:1480
#, fuzzy
msgid ""
"The constants in this section are only relevant for the C module. They are "
"also included in the pure Python version for compatibility."
msgstr "本節中的常數僅與 C 模組相關。它們也包含在純 Python 版本中以實作相容性。"

#: ../../library/decimal.rst:1484
#, fuzzy
msgid "32-bit"
msgstr "32位"

#: ../../library/decimal.rst:1484
#, fuzzy
msgid "64-bit"
msgstr "64位"

#: ../../library/decimal.rst:1486 ../../library/decimal.rst:1488
msgid "``425000000``"
msgstr "``425000000``"

#: ../../library/decimal.rst:1486 ../../library/decimal.rst:1488
msgid "``999999999999999999``"
msgstr "``999999999999999999``"

#: ../../library/decimal.rst:1490
msgid "``-425000000``"
msgstr "``-425000000``"

#: ../../library/decimal.rst:1490
msgid "``-999999999999999999``"
msgstr "``-999999999999999999``"

#: ../../library/decimal.rst:1492
msgid "``-849999999``"
msgstr "``-849999999``"

#: ../../library/decimal.rst:1492
msgid "``-1999999999999999997``"
msgstr "``-1999999999999999997``"

#: ../../library/decimal.rst:1498
#, fuzzy
msgid ""
"The value is ``True``.  Deprecated, because Python now always has threads."
msgstr "該值為 ``True``。已棄用，因為 Python 現在總是有執行緒。"

#: ../../library/decimal.rst:1504
#, fuzzy
msgid ""
"The default value is ``True``. If Python is :option:`configured using the --"
"without-decimal-contextvar option <--without-decimal-contextvar>`, the C "
"version uses a thread-local rather than a coroutine-local context and the "
"value is ``False``.  This is slightly faster in some nested context "
"scenarios."
msgstr ""
"預設值為 ``True``。如果使用 --without-decimal-contextvar 選項 <--without-decimal-"
"contextvar>` 配置 Python :option:`，則 C 版本使用執行緒局部上下文而不是協程局"
"部上下文，並且值為``假的``。這在某些嵌套上下文場景中稍微快一些。"

#: ../../library/decimal.rst:1509
#, fuzzy
msgid "backported to 3.7 and 3.8."
msgstr "向後移植到 3.7 和 3.8。"

#: ../../library/decimal.rst:1513
#, fuzzy
msgid "Rounding modes"
msgstr "舍入模式"

#: ../../library/decimal.rst:1517
#, fuzzy
msgid "Round towards ``Infinity``."
msgstr "向“無限”舍入。"

#: ../../library/decimal.rst:1521
#, fuzzy
msgid "Round towards zero."
msgstr "向零舍入。"

#: ../../library/decimal.rst:1525
#, fuzzy
msgid "Round towards ``-Infinity``."
msgstr "向 ``-Infinity`` 舍入。"

#: ../../library/decimal.rst:1529
#, fuzzy
msgid "Round to nearest with ties going towards zero."
msgstr "四捨五入到最接近的關係趨向於零。"

#: ../../library/decimal.rst:1533
#, fuzzy
msgid "Round to nearest with ties going to nearest even integer."
msgstr "四捨五入到最接近的關係到最接近的偶數。"

#: ../../library/decimal.rst:1537
#, fuzzy
msgid "Round to nearest with ties going away from zero."
msgstr "四捨五入到最接近的關係從零開始。"

#: ../../library/decimal.rst:1541
#, fuzzy
msgid "Round away from zero."
msgstr "從零舍入。"

#: ../../library/decimal.rst:1545
#, fuzzy
msgid ""
"Round away from zero if last digit after rounding towards zero would have "
"been 0 or 5; otherwise round towards zero."
msgstr "如果向零四捨五入後的最後一位數字是 0 或 5，則從零四捨五入；否則向零舍入。"

#: ../../library/decimal.rst:1552
#, fuzzy
msgid "Signals"
msgstr "信號"

#: ../../library/decimal.rst:1554
#, fuzzy
msgid ""
"Signals represent conditions that arise during computation. Each corresponds "
"to one context flag and one context trap enabler."
msgstr "信號表示計算過程中出現的條件。每個對應一個上下文旗標和一個上下文陷阱啟動器。"

#: ../../library/decimal.rst:1557
#, fuzzy
msgid ""
"The context flag is set whenever the condition is encountered. After the "
"computation, flags may be checked for informational purposes (for instance, "
"to determine whether a computation was exact). After checking the flags, be "
"sure to clear all flags before starting the next computation."
msgstr ""
"只要遇到條件，就會設定上下文旗標。計算之後，可以檢查旗標以供參考（例如，確定"
"計算是否準確）。檢查旗標後，請務必在開始下一次計算之前清除所有旗標。"

#: ../../library/decimal.rst:1562
#, fuzzy
msgid ""
"If the context's trap enabler is set for the signal, then the condition "
"causes a Python exception to be raised.  For example, if the :class:"
"`DivisionByZero` trap is set, then a :exc:`DivisionByZero` exception is "
"raised upon encountering the condition."
msgstr ""
"如果為信號設定了上下文的陷阱啟動器，則該條件會導致引發 Python 例外。例如，"
"如果設定了 DivisionByZero 陷阱，則在遇到該條件時會引發 DivisionByZero 例外。"

#: ../../library/decimal.rst:1570
#, fuzzy
msgid "Altered an exponent to fit representation constraints."
msgstr "更改指數以適應表示約束。"

#: ../../library/decimal.rst:1572
#, fuzzy
msgid ""
"Typically, clamping occurs when an exponent falls outside the context's :"
"attr:`~Context.Emin` and :attr:`~Context.Emax` limits.  If possible, the "
"exponent is reduced to fit by adding zeros to the coefficient."
msgstr ""
"通常，當指數超出上下文的 :attr:`~Context.Emin` 和 :attr:`~Context.Emax` "
"限制時，就會發生箝位。如果可能，通過向係數新增零來減少指數以適合。"

#: ../../library/decimal.rst:1579
#, fuzzy
msgid "Base class for other signals and a subclass of :exc:`ArithmeticError`."
msgstr "其他信號的基底類別和 ArithmeticError 的子類別。"

#: ../../library/decimal.rst:1584
#, fuzzy
msgid "Signals the division of a non-infinite number by zero."
msgstr "表示非無限數除以零。"

#: ../../library/decimal.rst:1586
#, fuzzy
msgid ""
"Can occur with division, modulo division, or when raising a number to a "
"negative power.  If this signal is not trapped, returns ``Infinity`` or ``-"
"Infinity`` with the sign determined by the inputs to the calculation."
msgstr "可以與除法、模除法或將數字增加到負冪時發生。如果此信號未被捕獲，則回傳“Infini"
"ty”或 ``-Infinity`` ，其符號由計算的輸入確定。"

#: ../../library/decimal.rst:1593
#, fuzzy
msgid "Indicates that rounding occurred and the result is not exact."
msgstr "表示發生了舍入，結果不准確。"

#: ../../library/decimal.rst:1595
#, fuzzy
msgid ""
"Signals when non-zero digits were discarded during rounding. The rounded "
"result is returned.  The signal flag or trap is used to detect when results "
"are inexact."
msgstr "在舍入期間丟棄非零數字時發出信號。回傳四捨五入的結果。信號旗標或陷阱用於檢測"
"結果何時不准確。"

#: ../../library/decimal.rst:1602
#, fuzzy
msgid "An invalid operation was performed."
msgstr "執行了無效操作。"

#: ../../library/decimal.rst:1604
#, fuzzy
msgid ""
"Indicates that an operation was requested that does not make sense. If not "
"trapped, returns ``NaN``.  Possible causes include::"
msgstr "表示請求了一個沒有意義的操作。如果沒有被困，則回傳 ``NaN``。可能的原因包括："

#: ../../library/decimal.rst:1620
#, fuzzy
msgid "Numerical overflow."
msgstr "數值溢出。"

#: ../../library/decimal.rst:1622
#, fuzzy
msgid ""
"Indicates the exponent is larger than :attr:`Context.Emax` after rounding "
"has occurred.  If not trapped, the result depends on the rounding mode, "
"either pulling inward to the largest representable finite number or rounding "
"outward to ``Infinity``.  In either case, :class:`Inexact` and :class:"
"`Rounded` are also signaled."
msgstr ""
"表示指數在舍入後大於 :attr:`Context.Emax`。如果沒有被困住，結果取決於舍入模式"
"，要么向內拉到最大的可表示有限數，要么向外舍入到“無窮大”。在任何一種情況下，:"
"class:`Inexact` 和 :class:`Rounded` 也會發出信號。"

#: ../../library/decimal.rst:1631
#, fuzzy
msgid "Rounding occurred though possibly no information was lost."
msgstr "儘管可能沒有資訊丟失，但發生了舍入。"

#: ../../library/decimal.rst:1633
#, fuzzy
msgid ""
"Signaled whenever rounding discards digits; even if those digits are zero "
"(such as rounding ``5.00`` to ``5.0``).  If not trapped, returns the result "
"unchanged.  This signal is used to detect loss of significant digits."
msgstr ""
"每當四捨五入丟棄數字時發出信號；即使這些數字為零（例如將 ``5.00`` 舍入為 ``5."
"0``）。如果沒有陷入，則回傳結果不變。該信號用於檢測有效數字的丟失。"

#: ../../library/decimal.rst:1641
#, fuzzy
msgid "Exponent was lower than :attr:`~Context.Emin` prior to rounding."
msgstr "在四捨五入之前，指數低於 :attr:`~Context.Emin`。"

#: ../../library/decimal.rst:1643
#, fuzzy
msgid ""
"Occurs when an operation result is subnormal (the exponent is too small). If "
"not trapped, returns the result unchanged."
msgstr "當運算結果不正常（指數太小）時發生。如果沒有陷入，則回傳結果不變。"

#: ../../library/decimal.rst:1649
#, fuzzy
msgid "Numerical underflow with result rounded to zero."
msgstr "結果四捨五入為零的數字下溢。"

#: ../../library/decimal.rst:1651
#, fuzzy
msgid ""
"Occurs when a subnormal result is pushed to zero by rounding. :class:"
"`Inexact` and :class:`Subnormal` are also signaled."
msgstr "當通過舍入將次正規結果推為零時發生。 :class:`Inexact` 和 :class:`Subnormal` "
"也發出信號。"

#: ../../library/decimal.rst:1657
#, fuzzy
msgid "Enable stricter semantics for mixing floats and Decimals."
msgstr "為混合浮點數和小數啟用更嚴格的語義。"

#: ../../library/decimal.rst:1659
#, fuzzy
msgid ""
"If the signal is not trapped (default), mixing floats and Decimals is "
"permitted in the :class:`~decimal.Decimal` constructor, :meth:`~decimal."
"Context.create_decimal` and all comparison operators. Both conversion and "
"comparisons are exact. Any occurrence of a mixed operation is silently "
"recorded by setting :exc:`FloatOperation` in the context flags. Explicit "
"conversions with :meth:`~decimal.Decimal.from_float` or :meth:`~decimal."
"Context.create_decimal_from_float` do not set the flag."
msgstr ""
"如果信號未被捕獲（預設），則在 :class:`~decimal.Decimal` "
"構造函式、:meth:`~decimal.Context.create_decimal` "
"和所有比較運算符中允許混合浮點數和 Decimals。轉換和比較都是準確的。"
"通過在上下文旗標中設定 FloatOperation 來靜默記錄混合操作的任何發生。使用 "
":meth:`~decimal.Decimal.from_float` 或 :meth:`~decimal.Context."
"create_decimal_from_float` 的顯式轉換不會設定旗標。"

#: ../../library/decimal.rst:1667
#, fuzzy
msgid ""
"Otherwise (the signal is trapped), only equality comparisons and explicit "
"conversions are silent. All other mixed operations raise :exc:"
"`FloatOperation`."
msgstr "否則（信號被捕獲），只有相等比較和顯式轉換是靜默的。所有其他混合操作都會引發 "
":exc:`FloatOperation`。"

#: ../../library/decimal.rst:1671
#, fuzzy
msgid "The following table summarizes the hierarchy of signals::"
msgstr "下表總結了信號的層次結構："

#: ../../library/decimal.rst:1692
#, fuzzy
msgid "Floating Point Notes"
msgstr "浮點數註釋"

#: ../../library/decimal.rst:1696
#, fuzzy
msgid "Mitigating round-off error with increased precision"
msgstr "通過提高精度來減少舍入誤差"

#: ../../library/decimal.rst:1698
#, fuzzy
msgid ""
"The use of decimal floating point eliminates decimal representation error "
"(making it possible to represent ``0.1`` exactly); however, some operations "
"can still incur round-off error when non-zero digits exceed the fixed "
"precision."
msgstr "使用十進位浮點數消除了十進位表示錯誤（使得可以精確表示 ``0."
"1``）；但是，當非零數字超過固定精度時，某些操作仍會產生舍入錯誤。"

#: ../../library/decimal.rst:1702
#, fuzzy
msgid ""
"The effects of round-off error can be amplified by the addition or "
"subtraction of nearly offsetting quantities resulting in loss of "
"significance.  Knuth provides two instructive examples where rounded "
"floating point arithmetic with insufficient precision causes the breakdown "
"of the associative and distributive properties of addition:"
msgstr ""
"舍入誤差的影響可以通過新增或減去幾乎抵消的量來放大，從而導致重要性損失。 "
"Knuth 提供了兩個有啟發性的示例，其中精度不足的捨入浮點運算導致加法的關聯和分"
"配屬性崩潰："

#: ../../library/decimal.rst:1726
#, fuzzy
msgid ""
"The :mod:`decimal` module makes it possible to restore the identities by "
"expanding the precision sufficiently to avoid loss of significance:"
msgstr ":mod:`decimal` 模組可以通過充分擴充精度來恢復身份，以避免失去重要性："

#: ../../library/decimal.rst:1746
#, fuzzy
msgid "Special values"
msgstr "特殊值"

#: ../../library/decimal.rst:1748
#, fuzzy
msgid ""
"The number system for the :mod:`decimal` module provides special values "
"including ``NaN``, ``sNaN``, ``-Infinity``, ``Infinity``, and two zeros, "
"``+0`` and ``-0``."
msgstr ""
":mod:`decimal` 模組的數字系統提供特殊值，包括 "
"``NaN``、``sNaN``、``-Infinity``、``Infinity`` 和兩個零、``+0` `和``-0``。"

#: ../../library/decimal.rst:1752
#, fuzzy
msgid ""
"Infinities can be constructed directly with:  ``Decimal('Infinity')``. Also, "
"they can arise from dividing by zero when the :exc:`DivisionByZero` signal "
"is not trapped.  Likewise, when the :exc:`Overflow` signal is not trapped, "
"infinity can result from rounding beyond the limits of the largest "
"representable number."
msgstr ""
"無窮大可以直接構造為：``Decimal('Infinity')``。此外，當 DivisionByZero "
"信號未被捕獲時，它們可能會因除以零而產生。同樣，當 :exc:`Overflow` "
"信號未被捕獲時，無窮大可能是由於四捨五入超出最大可表示數的限製而產生的。"

#: ../../library/decimal.rst:1757
#, fuzzy
msgid ""
"The infinities are signed (affine) and can be used in arithmetic operations "
"where they get treated as very large, indeterminate numbers.  For instance, "
"adding a constant to infinity gives another infinite result."
msgstr "無窮大是有符號的（仿射的），可用於算術運算，在這些運算中它們被視為非常大的不"
"確定數。例如，將一個常數加到無窮大會得到另一個無窮大的結果。"

#: ../../library/decimal.rst:1761
#, fuzzy
msgid ""
"Some operations are indeterminate and return ``NaN``, or if the :exc:"
"`InvalidOperation` signal is trapped, raise an exception.  For example, "
"``0/0`` returns ``NaN`` which means \"not a number\".  This variety of "
"``NaN`` is quiet and, once created, will flow through other computations "
"always resulting in another ``NaN``.  This behavior can be useful for a "
"series of computations that occasionally have missing inputs --- it allows "
"the calculation to proceed while flagging specific results as invalid."
msgstr ""
"一些操作是不確定的並回傳 ``NaN``，或者如果 InvalidOperation "
"信號被捕獲，則引發例外。例如，“0/0”回傳 ``NaN``，意思是“不是數字”。這種 ``NaN``的變"
"體是安靜的，一旦建立，將流經其他計算，始終導致另一個 ``NaN``。此行為對於偶爾缺少"
"輸入的一系列計算很有用——它允許計算繼續進行，同時將特定結果標"
"記為無效。"

#: ../../library/decimal.rst:1769
#, fuzzy
msgid ""
"A variant is ``sNaN`` which signals rather than remaining quiet after every "
"operation.  This is a useful return value when an invalid result needs to "
"interrupt a calculation for special handling."
msgstr "一個變體是 ``sNaN``，它發出信號而不是在每次操作後保持安靜。當無效結果需要中斷計"
"算以進行特殊處理時，這是一個有用的回傳值。"

#: ../../library/decimal.rst:1773
#, fuzzy
msgid ""
"The behavior of Python's comparison operators can be a little surprising "
"where a ``NaN`` is involved.  A test for equality where one of the operands "
"is a quiet or signaling ``NaN`` always returns :const:`False` (even when "
"doing ``Decimal('NaN')==Decimal('NaN')``), while a test for inequality "
"always returns :const:`True`.  An attempt to compare two Decimals using any "
"of the ``<``, ``<=``, ``>`` or ``>=`` operators will raise the :exc:"
"`InvalidOperation` signal if either operand is a ``NaN``, and return :const:"
"`False` if this signal is not trapped.  Note that the General Decimal "
"Arithmetic specification does not specify the behavior of direct "
"comparisons; these rules for comparisons involving a ``NaN`` were taken from "
"the IEEE 854 standard (see Table 3 in section 5.7).  To ensure strict "
"standards-compliance, use the :meth:`~Decimal.compare` and :meth:`~Decimal."
"compare_signal` methods instead."
msgstr ""
"在涉及 ``NaN`` 的情況下，Python 的比較運算符的行為可能有點令人驚訝。"
"如果其中一個操作數是安靜的或發出信號的 NaN 總是回傳 :const:`False "
"的相等性測試（即使在執行 Decimal('NaN')==Decimal('NaN')`` 時也是如此） ，"
"而對不等式的測試總是回傳 :const:`True`。如果任一操作數是一個 "
"``NaN``，如果這個信號沒有被捕獲，則回傳 :const:`False`。請注意，通用十進位算"
"術規範並未指定直接比較的行為；這些涉及 ``NaN``的比較規則取自 IEEE 854 標準（"
"請參閱第 5.7 節中的表 3）。為確保嚴格符合標準，請改用 :meth:`~Decimal."
"compare` 和 :meth:`~Decimal.compare_signal` 方法。"

#: ../../library/decimal.rst:1786
#, fuzzy
msgid ""
"The signed zeros can result from calculations that underflow. They keep the "
"sign that would have resulted if the calculation had been carried out to "
"greater precision.  Since their magnitude is zero, both positive and "
"negative zeros are treated as equal and their sign is informational."
msgstr ""
"帶符號的零可能來自下溢的計算。如果以更高的精度進行計算，它們會保留可能產生的"
"符號。由於它們的大小為零，因此正零和負零都被視為相等，並且它們的符號是資訊性"
"的。"

#: ../../library/decimal.rst:1791
#, fuzzy
msgid ""
"In addition to the two signed zeros which are distinct yet equal, there are "
"various representations of zero with differing precisions yet equivalent in "
"value.  This takes a bit of getting used to.  For an eye accustomed to "
"normalized floating point representations, it is not immediately obvious "
"that the following calculation returns a value equal to zero:"
msgstr ""
"除了兩個不同但相等的有符號零之外，還有各種精度不同但值相等的零表示形式。這需"
"要一點時間來適應。對於習慣於歸一化浮點表示的人來說，以下計算回傳的值是否為零"
"並不是顯而易見的："

#: ../../library/decimal.rst:1806
#, fuzzy
msgid "Working with threads"
msgstr "使用執行緒"

#: ../../library/decimal.rst:1808
#, fuzzy
msgid ""
"The :func:`getcontext` function accesses a different :class:`Context` object "
"for each thread.  Having separate thread contexts means that threads may "
"make changes (such as ``getcontext().prec=10``) without interfering with "
"other threads."
msgstr ""
":func:`getcontext` 函式為每個執行緒訪問不同的 :class:`Context` 物件。擁有獨立"
"的執行緒上下文意味著執行緒可以在不干擾其他執行緒的情況下進行更改（例如 "
"``getcontext().prec=10``）。"

#: ../../library/decimal.rst:1812
#, fuzzy
msgid ""
"Likewise, the :func:`setcontext` function automatically assigns its target "
"to the current thread."
msgstr "同樣，:func:`setcontext` 函式自動將其目標分配給當前執行緒。"

#: ../../library/decimal.rst:1815
#, fuzzy
msgid ""
"If :func:`setcontext` has not been called before :func:`getcontext`, then :"
"func:`getcontext` will automatically create a new context for use in the "
"current thread."
msgstr ""
"如果 :func:`setcontext` 在 :func:`getcontext` 之前沒有被呼叫，那麼 "
":func:`getcontext` 將自動建立一個新的上下文以供當前執行緒使用。"

#: ../../library/decimal.rst:1819
#, fuzzy
msgid ""
"The new context is copied from a prototype context called *DefaultContext*. "
"To control the defaults so that each thread will use the same values "
"throughout the application, directly modify the *DefaultContext* object. "
"This should be done *before* any threads are started so that there won't be "
"a race condition between threads calling :func:`getcontext`. For example::"
msgstr ""
"新上下文是從名為 *DefaultContext* 的原型上下文中復制的。要控制預設值以便每個"
"執行緒在整個應用程式中使用相同的值，請直接修改 *DefaultContext* "
"物件。這應該在*任何執行緒啟動之前*完成，這樣呼叫 :func:`getcontext` "
"的執行緒之間就不會出現競爭條件。例如：："

#: ../../library/decimal.rst:1844
#, fuzzy
msgid "Recipes"
msgstr "食譜"

#: ../../library/decimal.rst:1846
#, fuzzy
msgid ""
"Here are a few recipes that serve as utility functions and that demonstrate "
"ways to work with the :class:`Decimal` class::"
msgstr "以下是一些用作實用函式的方法，它們演示了使用 Decimal 類的方法："

#: ../../library/decimal.rst:2001
#, fuzzy
msgid "Decimal FAQ"
msgstr "十進位常見問題解答"

#: ../../library/decimal.rst:2003
#, fuzzy
msgid ""
"Q. It is cumbersome to type ``decimal.Decimal('1234.5')``.  Is there a way "
"to minimize typing when using the interactive interpreter?"
msgstr "問：輸入 ``decimal.Decimal('1234.5')`` "
"很麻煩。使用交互式直譯器時有沒有辦法盡量減少打字？"

#: ../../library/decimal.rst:2006
#, fuzzy
msgid "A. Some users abbreviate the constructor to just a single letter:"
msgstr "A. 一些使用者將構造函式縮寫為一個字母："

#: ../../library/decimal.rst:2012
#, fuzzy
msgid ""
"Q. In a fixed-point application with two decimal places, some inputs have "
"many places and need to be rounded.  Others are not supposed to have excess "
"digits and need to be validated.  What methods should be used?"
msgstr "Q. 在有兩位小數的定點應用中，有些輸入有很多位，需要四捨五入。其他人不應該有多"
"餘的數字，需要進行驗證。應該使用什麼方法？"

#: ../../library/decimal.rst:2016
#, fuzzy
msgid ""
"A. The :meth:`~Decimal.quantize` method rounds to a fixed number of decimal "
"places. If the :const:`Inexact` trap is set, it is also useful for "
"validation:"
msgstr ""
"A. :meth:`~Decimal.quantize` 方法四捨五入到固定的小數位數。如果設定了 "
":const:`Inexact` 陷阱，它對驗證也很有用："

#: ../../library/decimal.rst:2034
#, fuzzy
msgid ""
"Q. Once I have valid two place inputs, how do I maintain that invariant "
"throughout an application?"
msgstr "問：一旦我有了有效的兩個位置輸入，我如何在整個應用程式中保持不變？"

#: ../../library/decimal.rst:2037
#, fuzzy
msgid ""
"A. Some operations like addition, subtraction, and multiplication by an "
"integer will automatically preserve fixed point.  Others operations, like "
"division and non-integer multiplication, will change the number of decimal "
"places and need to be followed-up with a :meth:`~Decimal.quantize` step:"
msgstr ""
"A. 某些運算如整數的加、減和乘將自動保留不動點。其他操作，如除法和非整數乘法，"
"將改變小數位數，需要跟進一個 :meth:`~Decimal.quantize` 步驟："

#: ../../library/decimal.rst:2055
#, fuzzy
msgid ""
"In developing fixed-point applications, it is convenient to define functions "
"to handle the :meth:`~Decimal.quantize` step:"
msgstr "在開發定點應用程式時，定義函式來處理 :meth:`~Decimal.quantize` 步驟很方便："

#: ../../library/decimal.rst:2068
#, fuzzy
msgid ""
"Q. There are many ways to express the same value.  The numbers ``200``, "
"``200.000``, ``2E2``, and ``.02E+4`` all have the same value at various "
"precisions. Is there a way to transform them to a single recognizable "
"canonical value?"
msgstr ""
"Q. 表達相同價值的方式有很多種。數字 ``200``、“200.000”、 ``2E2``和“.02E+4”在不同的"
"精度下都具有相同的值。有沒有辦法將它們轉換為單一可識別的規範值？"

#: ../../library/decimal.rst:2073
#, fuzzy
msgid ""
"A. The :meth:`~Decimal.normalize` method maps all equivalent values to a "
"single representative:"
msgstr "A. :meth:`~Decimal.normalize` 方法將所有等效值映射到一個代表："

#: ../../library/decimal.rst:2080
#, fuzzy
msgid ""
"Q. Some decimal values always print with exponential notation.  Is there a "
"way to get a non-exponential representation?"
msgstr "問：一些十進位值總是以指數表示法印出。有沒有辦法獲得非指數表示？"

#: ../../library/decimal.rst:2083
#, fuzzy
msgid ""
"A. For some values, exponential notation is the only way to express the "
"number of significant places in the coefficient.  For example, expressing "
"``5.0E+3`` as ``5000`` keeps the value constant but cannot show the "
"original's two-place significance."
msgstr ""
"A. 對於某些值，指數表示法是表示係數中有效位數的唯一方法。例如，將 ``5.0E+3`` "
"表示為 ``5000`` 保持值不變，但不能顯示原始的兩位顯著性。"

#: ../../library/decimal.rst:2088
#, fuzzy
msgid ""
"If an application does not care about tracking significance, it is easy to "
"remove the exponent and trailing zeroes, losing significance, but keeping "
"the value unchanged:"
msgstr "如果應用程式不關心跟踪重要性，則很容易刪除指數和尾隨零，失去重要性，但保持值"
"不變："

#: ../../library/decimal.rst:2098
#, fuzzy
msgid "Q. Is there a way to convert a regular float to a :class:`Decimal`?"
msgstr "問：有沒有辦法將常規浮點數轉換為 Decimal？"

#: ../../library/decimal.rst:2100
#, fuzzy
msgid ""
"A. Yes, any binary floating point number can be exactly expressed as a "
"Decimal though an exact conversion may take more precision than intuition "
"would suggest:"
msgstr "A. 是的，任何二進位浮點數都可以精確地表示為 "
"Decimal，儘管精確轉換可能需要比直覺所建議的更精確："

#: ../../library/decimal.rst:2109
#, fuzzy
msgid ""
"Q. Within a complex calculation, how can I make sure that I haven't gotten a "
"spurious result because of insufficient precision or rounding anomalies."
msgstr "問：在復雜的計算中，我如何才能確保我沒有因為精度不足或舍入例外而得到虛假結果"
"。"

#: ../../library/decimal.rst:2112
#, fuzzy
msgid ""
"A. The decimal module makes it easy to test results.  A best practice is to "
"re-run calculations using greater precision and with various rounding modes. "
"Widely differing results indicate insufficient precision, rounding mode "
"issues, ill-conditioned inputs, or a numerically unstable algorithm."
msgstr ""
"A. decimal 模組使測試結果變得容易。最佳做法是使用更高的精度和各種舍入模式重新"
"運行計算。差異很大的結果表明精度不足、舍入模式問題、輸入條件不佳或演算法數值"
"不穩定。"

#: ../../library/decimal.rst:2117
#, fuzzy
msgid ""
"Q. I noticed that context precision is applied to the results of operations "
"but not to the inputs.  Is there anything to watch out for when mixing "
"values of different precisions?"
msgstr "問：我注意到上下文精度適用於操作結果，但不適用於輸入。混合不同精度的值有什麼"
"需要注意的嗎？"

#: ../../library/decimal.rst:2121
#, fuzzy
msgid ""
"A. Yes.  The principle is that all values are considered to be exact and so "
"is the arithmetic on those values.  Only the results are rounded.  The "
"advantage for inputs is that \"what you type is what you get\".  A "
"disadvantage is that the results can look odd if you forget that the inputs "
"haven't been rounded:"
msgstr ""
"答：是的。原則是所有值都被認為是精確的，這些值的算術也是如此。只有結果是四捨"
"五入的。輸入的優點是“你輸入的就是你得到的”。一個缺點是，如果您忘記輸入沒有被"
"四捨五入，結果可能看起來很奇怪："

#: ../../library/decimal.rst:2134
#, fuzzy
msgid ""
"The solution is either to increase precision or to force rounding of inputs "
"using the unary plus operation:"
msgstr "解決方案是提高精度或使用一元加運算強制舍入輸入："

#: ../../library/decimal.rst:2143
#, fuzzy
msgid ""
"Alternatively, inputs can be rounded upon creation using the :meth:`Context."
"create_decimal` method:"
msgstr "或者，可以使用 Context.create_decimal 方法在建立時舍入輸入："

#: ../../library/decimal.rst:2149
#, fuzzy
msgid "Q. Is the CPython implementation fast for large numbers?"
msgstr "問：CPython 實作對於大數來說速度快嗎？"

#: ../../library/decimal.rst:2151
#, fuzzy
msgid ""
"A. Yes.  In the CPython and PyPy3 implementations, the C/CFFI versions of "
"the decimal module integrate the high speed `libmpdec <https://www.bytereef."
"org/mpdecimal/doc/libmpdec/index.html>`_ library for arbitrary precision "
"correctly rounded decimal floating point arithmetic [#]_. ``libmpdec`` uses "
"`Karatsuba multiplication <https://en.wikipedia.org/wiki/"
"Karatsuba_algorithm>`_ for medium-sized numbers and the `Number Theoretic "
"Transform <https://en.wikipedia.org/wiki/"
"Discrete_Fourier_transform_(general)#Number-theoretic_transform>`_ for very "
"large numbers."
msgstr ""
"答：是的。在 CPython 和 PyPy3 實作中，十進位模組的 C/CFFI 版本正確集成了高速 "
"`libmpdec <https://www.bytereef.org/mpdecimal/doc/libmpdec/index.html>`_ "
"任意精度庫四捨五入的十進位浮點運算 [#]_。 ``libmpdec`` 使用`Karatsuba 乘法 "
"<https://en.wikipedia.org/wiki/Karatsuba_algorithm>`_ 用於中等大小的數字和`"
"Number Theoretic Transform <https://en.wikipedia.org/wiki/ "
"Discrete_Fourier_transform_(general)#Number-theoretic_transform>`_ "
"用於非常大的數。"

#: ../../library/decimal.rst:2161
#, fuzzy
msgid ""
"The context must be adapted for exact arbitrary precision arithmetic. :attr:"
"`~Context.Emin` and :attr:`~Context.Emax` should always be set to the "
"maximum values, :attr:`~Context.clamp` should always be 0 (the default).  "
"Setting :attr:`~Context.prec` requires some care."
msgstr ""
"上下文必須適應精確的任意精度算術。 :attr:`~Context.Emin` 和 :attr:`~Context."
"Emax` 應始終設定為最大值，:attr:`~Context.clamp` 應始終為 0（預設值）。設定 "
":attr:`~Context.prec` 需要小心。"

#: ../../library/decimal.rst:2165
#, fuzzy
msgid ""
"The easiest approach for trying out bignum arithmetic is to use the maximum "
"value for :attr:`~Context.prec` as well [#]_::"
msgstr "嘗試 bignum 演算法的最簡單方法是使用 :attr:`~Context.prec` 的最大值以及 "
"[#]_::"

#: ../../library/decimal.rst:2174
#, fuzzy
msgid ""
"For inexact results, :attr:`MAX_PREC` is far too large on 64-bit platforms "
"and the available memory will be insufficient::"
msgstr "對於不精確的結果，:attr:`MAX_PREC` 在 64 位平台上太大，可用記憶體不足::"

#: ../../library/decimal.rst:2182
#, fuzzy
msgid ""
"On systems with overallocation (e.g. Linux), a more sophisticated approach "
"is to adjust :attr:`~Context.prec` to the amount of available RAM.  Suppose "
"that you have 8GB of RAM and expect 10 simultaneous operands using a maximum "
"of 500MB each::"
msgstr ""
"在過度分配的系統上（例如 Linux），一種更複雜的方法是將 :attr:`~Context.prec` "
"調整為可用 RAM 的數量。假設您有 8GB 的 RAM 並且期望同時使用 10 "
"個操作數，每個操作數最多使用 500MB::"

#: ../../library/decimal.rst:2206
#, fuzzy
msgid ""
"In general (and especially on systems without overallocation), it is "
"recommended to estimate even tighter bounds and set the :attr:`Inexact` trap "
"if all calculations are expected to be exact."
msgstr "一般而言（尤其是在沒有過度分配的系統上），建議估計更嚴格的邊界並設定 Inexact "
"陷阱，如果所有計算都預期是準確的。"

#: ../../library/decimal.rst:2215
#, fuzzy
msgid ""
"This approach now works for all exact results except for non-integer powers."
msgstr "這種方法現在適用於除非整數冪之外的所有精確結果。"
