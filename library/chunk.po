# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-15 20:43+0000\n"
"PO-Revision-Date: 2022-05-22 02:03+0800\n"
"Last-Translator: Liang-Bo Wang <me@liang2.tw>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../library/chunk.rst:2
msgid ":mod:`chunk` --- Read IFF chunked data"
msgstr ":mod:`chunk` --- 讀取 IFF 分塊資料"

#: ../../library/chunk.rst:11
msgid "**Source code:** :source:`Lib/chunk.py`"
msgstr "**原始碼：**\\ :source:`Lib/chunk.py`"

#: ../../library/chunk.rst:23
msgid ""
"The :mod:`chunk` module is deprecated (see :pep:`PEP 594 <594#chunk>` for "
"details)."
msgstr ""
":mod:`chunk` 模組 (module) 即將被棄用（詳見 :pep:`PEP 594 <594#chunk>`\\ ）。"

#: ../../library/chunk.rst:26
#, fuzzy
msgid ""
"This module provides an interface for reading files that use EA IFF 85 "
"chunks. [#]_  This format is used in at least the Audio Interchange File "
"Format (AIFF/AIFF-C) and the Real Media File Format (RMFF).  The WAVE audio "
"file format is closely related and can also be read using this module."
msgstr ""
"該模組提供了一個介面，用於讀取使用 EA IFF 85 塊的文件。 [#]_ "
"這種格式至少用於音頻交換文件格式 (AIFF/AIFF-C) 和真實媒體文件格式 (RMFF)。 "
"WAVE 音頻文件格式密切相關，也可以使用此模組讀取。"

#: ../../library/chunk.rst:31
#, fuzzy
msgid "A chunk has the following structure:"
msgstr "塊具有以下結構："

#: ../../library/chunk.rst:34
#, fuzzy
msgid "Offset"
msgstr "抵消"

#: ../../library/chunk.rst:34
msgid "Length"
msgstr "長度"

#: ../../library/chunk.rst:34
msgid "Contents"
msgstr "內容"

#: ../../library/chunk.rst:36
msgid "0"
msgstr "0"

#: ../../library/chunk.rst:36 ../../library/chunk.rst:38
msgid "4"
msgstr "4"

#: ../../library/chunk.rst:36
#, fuzzy
msgid "Chunk ID"
msgstr "塊 ID"

#: ../../library/chunk.rst:38
#, fuzzy
msgid "Size of chunk in big-endian byte order, not including the header"
msgstr "big-endian 位元組順序的塊大小，不包括標頭"

#: ../../library/chunk.rst:42
msgid "8"
msgstr "8"

#: ../../library/chunk.rst:42
msgid "*n*"
msgstr "*n*"

#: ../../library/chunk.rst:42
#, fuzzy
msgid "Data bytes, where *n* is the size given in the preceding field"
msgstr "資料位元組，其中 *n* 是前面欄位中給出的大小"

#: ../../library/chunk.rst:46
msgid "8 + *n*"
msgstr "8 + *n*"

#: ../../library/chunk.rst:46
msgid "0 or 1"
msgstr "0 或 1"

#: ../../library/chunk.rst:46
#, fuzzy
msgid "Pad byte needed if *n* is odd and chunk alignment is used"
msgstr "如果 *n* 為奇數且使用塊對齊，則需要填充位元組"

#: ../../library/chunk.rst:50
#, fuzzy
msgid "The ID is a 4-byte string which identifies the type of chunk."
msgstr "ID 是一個 4 位元組的字串，用於標識塊的型別。"

#: ../../library/chunk.rst:52
#, fuzzy
msgid ""
"The size field (a 32-bit value, encoded using big-endian byte order) gives "
"the size of the chunk data, not including the 8-byte header."
msgstr "大小欄位（一個 32 位值，使用 big-endian 位元組順序編碼）給出塊資料的大小，"
"不包括 8 位元組的標頭。"

#: ../../library/chunk.rst:55
#, fuzzy
msgid ""
"Usually an IFF-type file consists of one or more chunks.  The proposed usage "
"of the :class:`Chunk` class defined here is to instantiate an instance at "
"the start of each chunk and read from the instance until it reaches the end, "
"after which a new instance can be instantiated. At the end of the file, "
"creating a new instance will fail with an :exc:`EOFError` exception."
msgstr ""
"通常一個 IFF 型別的文件由一個或多個塊組成。此處定義的 :class:`Chunk` 類的建議"
"用法是在每個塊的開頭實例化一個實例，並從該實例讀取直到它到達末尾，之後可以實"
"例化一個新實例。在文件末尾，建立新實例將失敗並出現 :exc:`EOFError` 例外。"

#: ../../library/chunk.rst:64
#, fuzzy
msgid ""
"Class which represents a chunk.  The *file* argument is expected to be a "
"file-like object.  An instance of this class is specifically allowed.  The "
"only method that is needed is :meth:`~io.IOBase.read`.  If the methods :meth:"
"`~io.IOBase.seek` and :meth:`~io.IOBase.tell` are present and don't raise an "
"exception, they are also used. If these methods are present and raise an "
"exception, they are expected to not have altered the object.  If the "
"optional argument *align* is true, chunks are assumed to be aligned on 2-"
"byte boundaries.  If *align* is false, no alignment is assumed.  The default "
"value is true.  If the optional argument *bigendian* is false, the chunk "
"size is assumed to be in little-endian order. This is needed for WAVE audio "
"files. The default value is true.  If the optional argument *inclheader* is "
"true, the size given in the chunk header includes the size of the header.  "
"The default value is false."
msgstr ""
"代表塊的類。 *file* 參數應該是一個類似文件的物件。特別允許此類的實例。"
"唯一需要的方法是 :meth:`~io.IOBase.read`。如果方法 :meth:`~io.IOBase.seek` "
"和 :meth:`~io.IOBase.tell` 存在並且沒有引發例外，它們也會被使用。如果這些方法"
"存在並引發例外，則它們應該不會更改物件。如果可選參數 *align* 為真，"
"則假定塊在 2 位元組邊界上對齊。如果 *align* 為 "
"false，則假定不對齊。預設值是true。如果可選參數 *bigendian* 為 "
"false，則塊大小假定為小端順序。這是 WAVE 音頻文件所需要的。預設值是true。"
"如果可選參數 *inclheader* "
"為真，則塊標頭中給出的大小包括標頭的大小。預設值為假。"

#: ../../library/chunk.rst:78
#, fuzzy
msgid "A :class:`Chunk` object supports the following methods:"
msgstr ":class:`Chunk` 物件支援以下方法："

#: ../../library/chunk.rst:83
#, fuzzy
msgid ""
"Returns the name (ID) of the chunk.  This is the first 4 bytes of the chunk."
msgstr "回傳塊的名稱 (ID)。這是塊的前 4 個位元組。"

#: ../../library/chunk.rst:89
#, fuzzy
msgid "Returns the size of the chunk."
msgstr "回傳塊的大小。"

#: ../../library/chunk.rst:94
#, fuzzy
msgid ""
"Close and skip to the end of the chunk.  This does not close the underlying "
"file."
msgstr "關閉並跳到塊的末尾。這不會關閉基礎文件。"

#: ../../library/chunk.rst:97
#, fuzzy
msgid ""
"The remaining methods will raise :exc:`OSError` if called after the :meth:"
"`close` method has been called.  Before Python 3.3, they used to raise :exc:"
"`IOError`, now an alias of :exc:`OSError`."
msgstr ""
"如果在呼叫 :meth:`close` 方法之後呼叫，其餘方法將引發 :exc:`OSError`。在 "
"Python 3.3 之前，他們曾經提出 :exc:`IOError`，現在是 :exc:`OSError` 的別名。"

#: ../../library/chunk.rst:104
#, fuzzy
msgid "Returns ``False``."
msgstr "回傳 ``False``。"

#: ../../library/chunk.rst:109
#, fuzzy
msgid ""
"Set the chunk's current position.  The *whence* argument is optional and "
"defaults to ``0`` (absolute file positioning); other values are ``1`` (seek "
"relative to the current position) and ``2`` (seek relative to the file's "
"end).  There is no return value. If the underlying file does not allow seek, "
"only forward seeks are allowed."
msgstr ""
"設定塊的當前位置。 *whence* 參數是可選的，預設為 ``0``（絕對文件定位）；其他值是"
" ``1``（相對於當前位置查找）和 ``2``（相對於文件末尾查找）。沒有回傳值。如果基礎文"
"件不允許查找，則只允許向前查找。"

#: ../../library/chunk.rst:118
#, fuzzy
msgid "Return the current position into the chunk."
msgstr "將當前位置回傳到塊中。"

#: ../../library/chunk.rst:123
#, fuzzy
msgid ""
"Read at most *size* bytes from the chunk (less if the read hits the end of "
"the chunk before obtaining *size* bytes).  If the *size* argument is "
"negative or omitted, read all data until the end of the chunk.  An empty "
"bytes object is returned when the end of the chunk is encountered "
"immediately."
msgstr ""
"從塊中讀取最多 *size* 位元組（如果讀取在獲取 *size* "
"位元組之前到達塊末尾則更少）。如果 *size* 參數為負數或省略，"
"則讀取所有數據直到塊結束"
"。當立即遇到塊的末尾時，將回傳一個空位元組物件。"

#: ../../library/chunk.rst:132
#, fuzzy
msgid ""
"Skip to the end of the chunk.  All further calls to :meth:`read` for the "
"chunk will return ``b''``.  If you are not interested in the contents of the "
"chunk, this method should be called so that the file points to the start of "
"the next chunk."
msgstr ""
"跳到塊的末尾。對該塊的所有進一步呼叫 :meth:`read` 將回傳 "
"``b''``。如果您對塊的內容不感興趣，則應呼叫此方法以使文件指向下一個塊的開始。"

#: ../../library/chunk.rst:139
msgid "Footnotes"
msgstr "註解"

#: ../../library/chunk.rst:140
#, fuzzy
msgid ""
"\"EA IFF 85\" Standard for Interchange Format Files, Jerry Morrison, "
"Electronic Arts, January 1985."
msgstr "“EA IFF 85”交換格式文件標準，Jerry Morrison，Electronic Arts，1985 年 1 月。"
