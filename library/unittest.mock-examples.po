# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-31 08:13+0000\n"
"PO-Revision-Date: 2016-11-19 00:35+0000\n"
"Last-Translator: Liang-Bo Wang <me@liang2.tw>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/unittest.mock-examples.rst:2
#, fuzzy
msgid ":mod:`unittest.mock` --- getting started"
msgstr ":mod:`unittest.mock` --- 開始"

#: ../../library/unittest.mock-examples.rst:27
#, fuzzy
msgid "Using Mock"
msgstr "使用 Mock"

#: ../../library/unittest.mock-examples.rst:30
#, fuzzy
msgid "Mock Patching Methods"
msgstr "模擬修補方法"

#: ../../library/unittest.mock-examples.rst:32
#, fuzzy
msgid "Common uses for :class:`Mock` objects include:"
msgstr ":class:`Mock` 物件的常見用途包括："

#: ../../library/unittest.mock-examples.rst:34
#, fuzzy
msgid "Patching methods"
msgstr "修補方法"

#: ../../library/unittest.mock-examples.rst:35
#, fuzzy
msgid "Recording method calls on objects"
msgstr "記錄對物件的方法呼叫"

#: ../../library/unittest.mock-examples.rst:37
#, fuzzy
msgid ""
"You might want to replace a method on an object to check that it is called "
"with the correct arguments by another part of the system:"
msgstr "您可能想要替換物件上的方法以檢查系統的另一部分是否使用正確的參數呼叫它："

#: ../../library/unittest.mock-examples.rst:45
#, fuzzy
msgid ""
"Once our mock has been used (``real.method`` in this example) it has methods "
"and attributes that allow you to make assertions about how it has been used."
msgstr "一旦使用了我們的 mock（本例中為“real."
"method”），它就會有方法和屬性，讓您可以斷言它是如何被使用的。"

#: ../../library/unittest.mock-examples.rst:50
#, fuzzy
msgid ""
"In most of these examples the :class:`Mock` and :class:`MagicMock` classes "
"are interchangeable. As the ``MagicMock`` is the more capable class it makes "
"a sensible one to use by default."
msgstr ""
"在大多數這些示例中，:class:`Mock` 和 :class:`MagicMock` 類是可以互換的。由於 "
"``MagicMock`` 是功能更強大的類，因此預設情況下它是一個明智的類。"

#: ../../library/unittest.mock-examples.rst:54
#, fuzzy
msgid ""
"Once the mock has been called its :attr:`~Mock.called` attribute is set to "
"``True``. More importantly we can use the :meth:`~Mock.assert_called_with` "
"or :meth:`~Mock.assert_called_once_with` method to check that it was called "
"with the correct arguments."
msgstr ""
"一旦 mock 被呼叫，它的 :attr:`~Mock.called` 屬性被設定為 "
"``True``。更重要的是，我們可以使用 :meth:`~Mock.assert_called_with` 或 "
":meth:`~Mock.assert_called_once_with` 方法來檢查它是否使用了正確的參數呼叫。"

#: ../../library/unittest.mock-examples.rst:59
#, fuzzy
msgid ""
"This example tests that calling ``ProductionClass().method`` results in a "
"call to the ``something`` method:"
msgstr "此示例測試呼叫 ``ProductionClass().method`` 會導致呼叫 ``something`` 方法："

#: ../../library/unittest.mock-examples.rst:76
#, fuzzy
msgid "Mock for Method Calls on an Object"
msgstr "模擬物件上的方法呼叫"

#: ../../library/unittest.mock-examples.rst:78
#, fuzzy
msgid ""
"In the last example we patched a method directly on an object to check that "
"it was called correctly. Another common use case is to pass an object into a "
"method (or some part of the system under test) and then check that it is "
"used in the correct way."
msgstr ""
"在上一個示例中，我們直接在物件上修補了一個方法，以檢查它是否被正確呼叫。另一"
"個常見的用例是將一個物件傳遞給一個方法（或被測系統的某個部分），然後檢查它是"
"否以正確的方式使用。"

#: ../../library/unittest.mock-examples.rst:83
#, fuzzy
msgid ""
"The simple ``ProductionClass`` below has a ``closer`` method. If it is "
"called with an object then it calls ``close`` on it."
msgstr "下面的簡單 ``ProductionClass`` 有一個 ``closer``方法。如果它是用一個物件呼叫的，"
"那麼它會呼叫它的 ``close``。"

#: ../../library/unittest.mock-examples.rst:91
#, fuzzy
msgid ""
"So to test it we need to pass in an object with a ``close`` method and check "
"that it was called correctly."
msgstr "所以為了測試它，我們需要傳入一個帶有 ``close`` "
"方法的物件並檢查它是否被正確呼叫。"

#: ../../library/unittest.mock-examples.rst:99
#, fuzzy
msgid ""
"We don't have to do any work to provide the 'close' method on our mock. "
"Accessing close creates it. So, if 'close' hasn't already been called then "
"accessing it in the test will create it, but :meth:`~Mock."
"assert_called_with` will raise a failure exception."
msgstr ""
"我們不需要做任何工作來為我們的模擬提供“關閉”方法。訪問關閉建立它。因此，如果"
"尚未呼叫 ``close``，則在測試中訪問它會建立它，但是 :meth:`~Mock."
"assert_called_with` 將引發失敗例外。"

#: ../../library/unittest.mock-examples.rst:106
#, fuzzy
msgid "Mocking Classes"
msgstr "模擬類"

#: ../../library/unittest.mock-examples.rst:108
#, fuzzy
msgid ""
"A common use case is to mock out classes instantiated by your code under "
"test. When you patch a class, then that class is replaced with a mock. "
"Instances are created by *calling the class*. This means you access the "
"\"mock instance\" by looking at the return value of the mocked class."
msgstr ""
"一個常見的用例是模擬由被測程式碼實例化的類。當您修補一個類時，該類將被模擬替"
"換。實例是通過*呼叫類*建立的。這意味著您可以通過查看模擬類的回傳值來訪問“模擬"
"實例”。"

#: ../../library/unittest.mock-examples.rst:113
#, fuzzy
msgid ""
"In the example below we have a function ``some_function`` that instantiates "
"``Foo`` and calls a method on it. The call to :func:`patch` replaces the "
"class ``Foo`` with a mock. The ``Foo`` instance is the result of calling the "
"mock, so it is configured by modifying the mock :attr:`~Mock."
"return_value`. ::"
msgstr ""
"在下面的示例中，我們有一個函式 ``some_function`` 實例化 ``Foo`` "
"並呼叫它的方法。呼叫 :func:`patch` 將類 ``Foo`` 替換為模擬。 ``Foo`` "
"實例是呼叫 mock 的結果，因此通過修改 mock :attr:`~Mock.return_value` "
"來配置它。 ::"

#: ../../library/unittest.mock-examples.rst:130
#, fuzzy
msgid "Naming your mocks"
msgstr "命名你的模擬"

#: ../../library/unittest.mock-examples.rst:132
#, fuzzy
msgid ""
"It can be useful to give your mocks a name. The name is shown in the repr of "
"the mock and can be helpful when the mock appears in test failure messages. "
"The name is also propagated to attributes or methods of the mock:"
msgstr ""
"給你的模擬一個名字可能很有用。該名稱顯示在 mock 的 repr 中，當 mock "
"出現在測試失敗消息中時會很有幫助。該名稱還會傳播到模擬的屬性或方法："

#: ../../library/unittest.mock-examples.rst:144
#, fuzzy
msgid "Tracking all Calls"
msgstr "跟踪所有呼叫"

#: ../../library/unittest.mock-examples.rst:146
#, fuzzy
msgid ""
"Often you want to track more than a single call to a method. The :attr:"
"`~Mock.mock_calls` attribute records all calls to child attributes of the "
"mock - and also to their children."
msgstr "通常您想要跟踪多個方法呼叫。 :attr:`~Mock.mock_calls` "
"屬性記錄了對模擬的子屬性及其子屬性的所有呼叫。"

#: ../../library/unittest.mock-examples.rst:158
#, fuzzy
msgid ""
"If you make an assertion about ``mock_calls`` and any unexpected methods "
"have been called, then the assertion will fail. This is useful because as "
"well as asserting that the calls you expected have been made, you are also "
"checking that they were made in the right order and with no additional calls:"
msgstr ""
"如果您對 ``mock_calls`` 做出斷言並且呼叫了任何意外的方法，則斷言將失敗。這很"
"有用，因為除了斷言您預期的呼叫已經進行之外，您還檢查它們是否以正確的順序進行"
"並且沒有額外的呼叫："

#: ../../library/unittest.mock-examples.rst:163
#, fuzzy
msgid ""
"You use the :data:`call` object to construct lists for comparing with "
"``mock_calls``:"
msgstr "您使用 :data:`call` 物件來構造用於與 ``mock_calls`` 進行比較的列表："

#: ../../library/unittest.mock-examples.rst:170
#, fuzzy
msgid ""
"However, parameters to calls that return mocks are not recorded, which means "
"it is not possible to track nested calls where the parameters used to create "
"ancestors are important:"
msgstr "但是，不記錄回傳模擬的呼叫的參數，這意味著無法跟踪用於建立祖先的參數很重要的"
"嵌套呼叫："

#: ../../library/unittest.mock-examples.rst:181
#, fuzzy
msgid "Setting Return Values and Attributes"
msgstr "設定回傳值和屬性"

#: ../../library/unittest.mock-examples.rst:183
#, fuzzy
msgid "Setting the return values on a mock object is trivially easy:"
msgstr "在模擬物件上設定回傳值非常簡單："

#: ../../library/unittest.mock-examples.rst:190
#, fuzzy
msgid "Of course you can do the same for methods on the mock:"
msgstr "當然，您可以對 mock 上的方法執行相同的操作："

#: ../../library/unittest.mock-examples.rst:197
#, fuzzy
msgid "The return value can also be set in the constructor:"
msgstr "回傳值也可以在構造函式中設定："

#: ../../library/unittest.mock-examples.rst:203
#, fuzzy
msgid "If you need an attribute setting on your mock, just do it:"
msgstr "如果你需要在你的 mock 上進行屬性設定，只需執行以下操作："

#: ../../library/unittest.mock-examples.rst:210
#, fuzzy
msgid ""
"Sometimes you want to mock up a more complex situation, like for example "
"``mock.connection.cursor().execute(\"SELECT 1\")``. If we wanted this call "
"to return a list, then we have to configure the result of the nested call."
msgstr ""
"有時您想模擬更複雜的情況，例如``mock.connection.cursor().execute(\"SELECT 1\""
")``。如果我們希望此呼叫回傳一個列表，那麼我們必須配置嵌套呼叫的結果。"

#: ../../library/unittest.mock-examples.rst:214
#, fuzzy
msgid ""
"We can use :data:`call` to construct the set of calls in a \"chained call\" "
"like this for easy assertion afterwards:"
msgstr "我們可以使用 :data:`call` 在這樣的“鍊式呼叫”中構造呼叫集，以便之後輕鬆斷言："

#: ../../library/unittest.mock-examples.rst:228
#, fuzzy
msgid ""
"It is the call to ``.call_list()`` that turns our call object into a list of "
"calls representing the chained calls."
msgstr "正是對 .call_list() 的呼叫將我們的呼叫物件變成了代錶鍊式呼叫的呼叫列表。"

#: ../../library/unittest.mock-examples.rst:233
#, fuzzy
msgid "Raising exceptions with mocks"
msgstr "用模擬引發例外"

#: ../../library/unittest.mock-examples.rst:235
#, fuzzy
msgid ""
"A useful attribute is :attr:`~Mock.side_effect`. If you set this to an "
"exception class or instance then the exception will be raised when the mock "
"is called."
msgstr "一個有用的屬性是 :attr:`~Mock."
"side_effect`。如果將其設定為例外類或實例，則在呼叫模擬時將引發例外。"

#: ../../library/unittest.mock-examples.rst:247
#, fuzzy
msgid "Side effect functions and iterables"
msgstr "副作用函式和可疊代物件"

#: ../../library/unittest.mock-examples.rst:249
#, fuzzy
msgid ""
"``side_effect`` can also be set to a function or an iterable. The use case "
"for ``side_effect`` as an iterable is where your mock is going to be called "
"several times, and you want each call to return a different value. When you "
"set ``side_effect`` to an iterable every call to the mock returns the next "
"value from the iterable:"
msgstr ""
"``side_effect`` 也可以設定為函式或可疊代物件。 ``side_effect`` 作為可疊代物件"
"的用例是您的模擬將被多次呼叫，並且您希望每次呼叫都回傳不同的值。當您將 "
"``side_effect`` "
"設定為可疊代物件時，每次呼叫模擬都會回傳可疊代物件的下一個值："

#: ../../library/unittest.mock-examples.rst:264
#, fuzzy
msgid ""
"For more advanced use cases, like dynamically varying the return values "
"depending on what the mock is called with, ``side_effect`` can be a "
"function. The function will be called with the same arguments as the mock. "
"Whatever the function returns is what the call returns:"
msgstr ""
"對於更高階的用例，比如根據呼叫 mock 的內容動態改變回傳值，``side_effect`` 可"
"以是一個函式。該函式將使用與模擬相同的參數呼叫。無論函式回傳什麼，呼叫都會回"
"傳什麼："

#: ../../library/unittest.mock-examples.rst:281
#, fuzzy
msgid "Mocking asynchronous iterators"
msgstr "模擬非同步疊代器"

#: ../../library/unittest.mock-examples.rst:283
#, fuzzy
msgid ""
"Since Python 3.8, ``AsyncMock`` and ``MagicMock`` have support to mock :ref:"
"`async-iterators` through ``__aiter__``. The :attr:`~Mock.return_value` "
"attribute of ``__aiter__`` can be used to set the return values to be used "
"for iteration."
msgstr ""
"從 Python 3.8 開始，``AsyncMock`` 和 ``MagicMock`` 通過 ``__aiter__`` "
"支援模擬 :ref:`async-iterators`。 ``__aiter__`` 的 :attr:`~Mock.return_value`"
" 屬性可用於設定用於疊代的回傳值。"

#: ../../library/unittest.mock-examples.rst:298
#, fuzzy
msgid "Mocking asynchronous context manager"
msgstr "模擬非同步情境管理器"

#: ../../library/unittest.mock-examples.rst:300
#, fuzzy
msgid ""
"Since Python 3.8, ``AsyncMock`` and ``MagicMock`` have support to mock :ref:"
"`async-context-managers` through ``__aenter__`` and ``__aexit__``. By "
"default, ``__aenter__`` and ``__aexit__`` are ``AsyncMock`` instances that "
"return an async function."
msgstr ""
"從 Python 3.8 開始，``AsyncMock`` 和``MagicMock`` 通過``__aenter__`` "
"和``__aexit__`` 支援模擬 :ref:`async-context-"
"managers`。預設情況下，``__aenter__`` 和``__aexit__`` "
"是回傳非同步函式的``AsyncMock`` 實例。"

#: ../../library/unittest.mock-examples.rst:322
#, fuzzy
msgid "Creating a Mock from an Existing Object"
msgstr "從現有物件建立模擬"

#: ../../library/unittest.mock-examples.rst:324
#, fuzzy
msgid ""
"One problem with over use of mocking is that it couples your tests to the "
"implementation of your mocks rather than your real code. Suppose you have a "
"class that implements ``some_method``. In a test for another class, you "
"provide a mock of this object that *also* provides ``some_method``. If later "
"you refactor the first class, so that it no longer has ``some_method`` - "
"then your tests will continue to pass even though your code is now broken!"
msgstr ""
"過度使用模擬的一個問題是它會將您的測試與模擬的實作相結合，而不是與您的真實程"
"式碼相結合。假設你有一個實作 ``some_method`` 的類。在另一個類的測試中，您提供"
"了此物件的模擬，*還*提供了“some_method”。如果稍後您重構第一個類，"
"使其不再具有 ``some_method`` - "
"那麼即使您的程式碼現在已損壞，您的測試仍將繼續通過！"

#: ../../library/unittest.mock-examples.rst:331
#, fuzzy
msgid ""
":class:`Mock` allows you to provide an object as a specification for the "
"mock, using the *spec* keyword argument. Accessing methods / attributes on "
"the mock that don't exist on your specification object will immediately "
"raise an attribute error. If you change the implementation of your "
"specification, then tests that use that class will start failing immediately "
"without you having to instantiate the class in those tests."
msgstr ""
":class:`Mock` 允許您使用 *spec* 關鍵字參數提供一個物件作為模擬的規範。"
"訪問規範物件中不存在的 mock 方法/屬性將立即引發屬性錯誤。如果您更改規範的實作"
"，那麼使用該類的測試將立即開始失敗，而您不必在這些測試中實例化該類。"

#: ../../library/unittest.mock-examples.rst:344
#, fuzzy
msgid ""
"Using a specification also enables a smarter matching of calls made to the "
"mock, regardless of whether some parameters were passed as positional or "
"named arguments::"
msgstr "使用規範還可以更智能地匹配對模擬的呼叫，而不管某些參數是作為位置參數還是命名"
"參數傳遞的::"

#: ../../library/unittest.mock-examples.rst:355
#, fuzzy
msgid ""
"If you want this smarter matching to also work with method calls on the "
"mock, you can use :ref:`auto-speccing <auto-speccing>`."
msgstr ""
"如果您希望這種更智能的匹配也適用於 mock 上的方法呼叫，您可以使用 :ref:`auto-"
"speccing <auto-speccing>`。"

#: ../../library/unittest.mock-examples.rst:358
#, fuzzy
msgid ""
"If you want a stronger form of specification that prevents the setting of "
"arbitrary attributes as well as the getting of them then you can use "
"*spec_set* instead of *spec*."
msgstr "如果你想要一種更強大的規範形式來防止任意屬性的設定以及它們的獲取，"
"那麼你可以使用 *spec_set* 而不是 *spec*。"

#: ../../library/unittest.mock-examples.rst:365
#, fuzzy
msgid "Patch Decorators"
msgstr "補丁裝飾器"

#: ../../library/unittest.mock-examples.rst:369
#, fuzzy
msgid ""
"With :func:`patch` it matters that you patch objects in the namespace where "
"they are looked up. This is normally straightforward, but for a quick guide "
"read :ref:`where to patch <where-to-patch>`."
msgstr ""
"使用 :func:`patch` "
"重要的是在查找它們的名稱空間中修補物件。這通常很簡單，但要獲得快速指南，"
"請閱讀 :ref:`where to patch <where-to-patch>`。"

#: ../../library/unittest.mock-examples.rst:374
#, fuzzy
msgid ""
"A common need in tests is to patch a class attribute or a module attribute, "
"for example patching a builtin or patching a class in a module to test that "
"it is instantiated. Modules and classes are effectively global, so patching "
"on them has to be undone after the test or the patch will persist into other "
"tests and cause hard to diagnose problems."
msgstr ""
"測試中的一個常見需求是修補類屬性或模組屬性，例如修補內建函式或修補模組中的類"
"以測試它是否已實例化。模組和類實際上是全局的，因此必須在測試後撤消對它們的修"
"補，否則修補將持續到其他測試中並導致難以診斷的問題。"

#: ../../library/unittest.mock-examples.rst:380
#, fuzzy
msgid ""
"mock provides three convenient decorators for this: :func:`patch`, :func:"
"`patch.object` and :func:`patch.dict`. ``patch`` takes a single string, of "
"the form ``package.module.Class.attribute`` to specify the attribute you are "
"patching. It also optionally takes a value that you want the attribute (or "
"class or whatever) to be replaced with. 'patch.object' takes an object and "
"the name of the attribute you would like patched, plus optionally the value "
"to patch it with."
msgstr ""
"mock 為此提供了三個方便的裝飾器：:func:`patch`、:func:`patch.object` "
"和 :func:`patch.dict`。 ``patch`` 採用單個字串，形式為 ``package.module.Class."
"attribute`` 來指定您正在修補的屬性。它還可以選擇採用一個值，您希望用該值替換"
"屬性（或類或其他）。 'patch.object' "
"採用一個物件和您想要修補的屬性的名稱，加上可選的修補它的值。"

#: ../../library/unittest.mock-examples.rst:388
#, fuzzy
msgid "``patch.object``::"
msgstr "``patch.object``::"

#: ../../library/unittest.mock-examples.rst:405
#, fuzzy
msgid ""
"If you are patching a module (including :mod:`builtins`) then use :func:"
"`patch` instead of :func:`patch.object`:"
msgstr ""
"如果你正在修補一個模組（包括 :mod:`builtins`）然後使用 :func:`patch` 而不是 "
":func:`patch.object`："

#: ../../library/unittest.mock-examples.rst:415
#, fuzzy
msgid ""
"The module name can be 'dotted', in the form ``package.module`` if needed::"
msgstr "如果需要，模組名稱可以是 ``點``形式，形式為“package.module”："

#: ../../library/unittest.mock-examples.rst:424
#, fuzzy
msgid "A nice pattern is to actually decorate test methods themselves:"
msgstr "一個很好的模式是實際裝飾測試方法本身："

#: ../../library/unittest.mock-examples.rst:435
#, fuzzy
msgid ""
"If you want to patch with a Mock, you can use :func:`patch` with only one "
"argument (or :func:`patch.object` with two arguments). The mock will be "
"created for you and passed into the test function / method:"
msgstr ""
"如果你想用 Mock 打補丁，你可以使用 :func:`patch` 只帶一個參數（或者 "
":func:`patch.object` "
"帶兩個參數）。將為您建立模擬並將其傳遞到測試函式/方法中："

#: ../../library/unittest.mock-examples.rst:447
#, fuzzy
msgid "You can stack up multiple patch decorators using this pattern::"
msgstr "您可以使用此模式堆疊多個補丁裝飾器::"

#: ../../library/unittest.mock-examples.rst:458
#, fuzzy
msgid ""
"When you nest patch decorators the mocks are passed in to the decorated "
"function in the same order they applied (the normal *Python* order that "
"decorators are applied). This means from the bottom up, so in the example "
"above the mock for ``test_module.ClassName2`` is passed in first."
msgstr ""
"當您嵌套補丁裝飾器時，模擬將按照它們應用的相同順序傳遞給裝飾函式（"
"裝飾器應用的正常 *Python* 順序）。這意味著自下而上，因此在上面的示例中，"
"首先傳入 ``test_module.ClassName2`` 的模擬。"

#: ../../library/unittest.mock-examples.rst:463
#, fuzzy
msgid ""
"There is also :func:`patch.dict` for setting values in a dictionary just "
"during a scope and restoring the dictionary to its original state when the "
"test ends:"
msgstr "還有 :func:`patch.dict` "
"用於在範圍內設定字典中的值並在測試結束時將字典恢復到其原始狀態："

#: ../../library/unittest.mock-examples.rst:474
#, fuzzy
msgid ""
"``patch``, ``patch.object`` and ``patch.dict`` can all be used as context "
"managers."
msgstr "``patch``、``patch.object`` 和 ``patch.dict`` 都可以用作情境管理器。"

#: ../../library/unittest.mock-examples.rst:476
#, fuzzy
msgid ""
"Where you use :func:`patch` to create a mock for you, you can get a "
"reference to the mock using the \"as\" form of the with statement:"
msgstr "在使用 :func:`patch` 為您建立模擬的地方，您可以使用 with "
"語句的 ``as``形式獲取對模擬的引用："

#: ../../library/unittest.mock-examples.rst:491
#, fuzzy
msgid ""
"As an alternative ``patch``, ``patch.object`` and ``patch.dict`` can be used "
"as class decorators. When used in this way it is the same as applying the "
"decorator individually to every method whose name starts with \"test\"."
msgstr ""
"作為替代方案，``patch``、``patch.object`` 和 ``patch.dict`` 可以用作類裝飾器"
"。當以這種方式使用時，它與將裝飾器單獨應用於名稱以 ``test``開頭的每個方法相同。"

#: ../../library/unittest.mock-examples.rst:499
#, fuzzy
msgid "Further Examples"
msgstr "更多例子"

#: ../../library/unittest.mock-examples.rst:502
#, fuzzy
msgid "Here are some more examples for some slightly more advanced scenarios."
msgstr "下面是一些稍微更高階的場景的更多示例。"

#: ../../library/unittest.mock-examples.rst:506
#, fuzzy
msgid "Mocking chained calls"
msgstr "模擬鍊式呼叫"

#: ../../library/unittest.mock-examples.rst:508
#, fuzzy
msgid ""
"Mocking chained calls is actually straightforward with mock once you "
"understand the :attr:`~Mock.return_value` attribute. When a mock is called "
"for the first time, or you fetch its ``return_value`` before it has been "
"called, a new :class:`Mock` is created."
msgstr ""
"一旦你理解了 :attr:`~Mock.return_value` 屬性，模擬鍊式呼叫實際上很簡單。"
"當第一次呼叫 mock 時，或者在呼叫它之前獲取它的 ``return_value`` 時，"
"將建立一個新的 :class:`Mock`。"

#: ../../library/unittest.mock-examples.rst:513
#, fuzzy
msgid ""
"This means that you can see how the object returned from a call to a mocked "
"object has been used by interrogating the ``return_value`` mock:"
msgstr "這意味著您可以通過詢問 ``return_value`` "
"模擬來查看從呼叫模擬物件回傳的物件是如何被使用的："

#: ../../library/unittest.mock-examples.rst:521
#, fuzzy
msgid ""
"From here it is a simple step to configure and then make assertions about "
"chained calls. Of course another alternative is writing your code in a more "
"testable way in the first place..."
msgstr "從這裡開始，只需一個簡單的步驟即可配置然後對鍊式呼叫進行斷言。當然，另一種選"
"擇是首先以更可測試的方式編寫程式碼......"

#: ../../library/unittest.mock-examples.rst:525
#, fuzzy
msgid "So, suppose we have some code that looks a little bit like this:"
msgstr "所以，假設我們有一些程式碼看起來有點像這樣："

#: ../../library/unittest.mock-examples.rst:534
#, fuzzy
msgid ""
"Assuming that ``BackendProvider`` is already well tested, how do we test "
"``method()``? Specifically, we want to test that the code section ``# more "
"code`` uses the response object in the correct way."
msgstr ""
"假設 ``BackendProvider`` 已經測試好了，我們如何測試 "
"``method()``？具體來說，我們要測試程式碼部分“#more "
"code”是否以正確的方式使用響應物件。"

#: ../../library/unittest.mock-examples.rst:538
#, fuzzy
msgid ""
"As this chain of calls is made from an instance attribute we can monkey "
"patch the ``backend`` attribute on a ``Something`` instance. In this "
"particular case we are only interested in the return value from the final "
"call to ``start_call`` so we don't have much configuration to do. Let's "
"assume the object it returns is 'file-like', so we'll ensure that our "
"response object uses the builtin :func:`open` as its ``spec``."
msgstr ""
"由於這個呼叫鍊是從一個實例屬性進行的，我們可以猴子修補一個 ``Something`` "
"實例上的 ``backend`` 屬性。在這種特殊情況下，我們只對最終呼叫 start_call 的回"
"傳值感興趣，因此我們不需要做太多配置。讓我們假設它回傳的物件是“類似文件”的，"
"所以我們將確保我們的響應物件使用內建的 :func:`open` 作為它的 ``spec``。"

#: ../../library/unittest.mock-examples.rst:545
#, fuzzy
msgid ""
"To do this we create a mock instance as our mock backend and create a mock "
"response object for it. To set the response as the return value for that "
"final ``start_call`` we could do this::"
msgstr ""
"為此，我們建立一個模擬實例作為我們的模擬後端，並為其建立一個模擬響應物件。"
"要將響應設定為最終 ``start_call`` 的回傳值，我們可以這樣做："

#: ../../library/unittest.mock-examples.rst:551
#, fuzzy
msgid ""
"We can do that in a slightly nicer way using the :meth:`~Mock."
"configure_mock` method to directly set the return value for us::"
msgstr "我們可以使用 :meth:`~Mock.configure_mock` "
"方法以更好的方式來直接為我們設定回傳值::"

#: ../../library/unittest.mock-examples.rst:560
#, fuzzy
msgid ""
"With these we monkey patch the \"mock backend\" in place and can make the "
"real call::"
msgstr "有了這些，我們猴子修補了“模擬後端”，就可以進行真正的呼叫::"

#: ../../library/unittest.mock-examples.rst:566
#, fuzzy
msgid ""
"Using :attr:`~Mock.mock_calls` we can check the chained call with a single "
"assert. A chained call is several calls in one line of code, so there will "
"be several entries in ``mock_calls``. We can use :meth:`call.call_list` to "
"create this list of calls for us::"
msgstr ""
"使用 :attr:`~Mock.mock_calls` "
"我們可以使用單個斷言檢查鍊式呼叫。鍊式呼叫是一行程式碼中的多個呼叫，因此 "
"mock_calls 中將有多個條目。我們可以使用 :meth:`call.call_list` "
"為我們建立這個呼叫列表::"

#: ../../library/unittest.mock-examples.rst:577
#, fuzzy
msgid "Partial mocking"
msgstr "部分嘲諷"

#: ../../library/unittest.mock-examples.rst:579
#, fuzzy
msgid ""
"In some tests I wanted to mock out a call to :meth:`datetime.date.today` to "
"return a known date, but I didn't want to prevent the code under test from "
"creating new date objects. Unfortunately :class:`datetime.date` is written "
"in C, and so I couldn't just monkey-patch out the static :meth:`date.today` "
"method."
msgstr ""
"在某些測試中，我想模擬呼叫 :meth:`datetime.date.today` 以回傳已知日期，但我不"
"想阻止被測程式碼建立新的日期物件。不幸的是 :class:`datetime.date` 是用 C "
"語言編寫的，所以我不能簡單地猴子修補靜態的 :meth:`date.today` 方法。"

#: ../../library/unittest.mock-examples.rst:584
#, fuzzy
msgid ""
"I found a simple way of doing this that involved effectively wrapping the "
"date class with a mock, but passing through calls to the constructor to the "
"real class (and returning real instances)."
msgstr "我找到了一種簡單的方法來執行此操作，該方法涉及使用模擬有效地包裝日期類，但將"
"對構造函式的呼叫傳遞給真實類（並回傳真實實例）。"

#: ../../library/unittest.mock-examples.rst:588
#, fuzzy
msgid ""
"The :func:`patch decorator <patch>` is used here to mock out the ``date`` "
"class in the module under test. The :attr:`side_effect` attribute on the "
"mock date class is then set to a lambda function that returns a real date. "
"When the mock date class is called a real date will be constructed and "
"returned by ``side_effect``. ::"
msgstr ""
":func:`patch 裝飾器 <patch>` 在這裡用於模擬被測模組中的 ``date`` 類。"
"然後將模擬日期類的 :attr:`side_effect` 屬性設定為回傳真實日期的 lambda "
"函式。當呼叫模擬日期類時，將構造一個真實日期並由 side_effect 回傳。 ::"

#: ../../library/unittest.mock-examples.rst:602
#, fuzzy
msgid ""
"Note that we don't patch :class:`datetime.date` globally, we patch ``date`` "
"in the module that *uses* it. See :ref:`where to patch <where-to-patch>`."
msgstr ""
"請注意，我們不會在全局範圍內修補 datetime.date，我們會在*使用*它的模組中修補 "
"``date``。請參閱 :ref:`在哪裡修補 <where-to-patch>`。"

#: ../../library/unittest.mock-examples.rst:605
#, fuzzy
msgid ""
"When ``date.today()`` is called a known date is returned, but calls to the "
"``date(...)`` constructor still return normal dates. Without this you can "
"find yourself having to calculate an expected result using exactly the same "
"algorithm as the code under test, which is a classic testing anti-pattern."
msgstr ""
"當呼叫 ``date.today()`` 時回傳已知日期，但呼叫 ``date(...)`` 構造函式仍會回傳"
"正常日期。如果沒有這個，您會發現自己必須使用與被測程式碼完全相同的演算法來計"
"算預期結果，這是一種經典的測試反模式。"

#: ../../library/unittest.mock-examples.rst:610
#, fuzzy
msgid ""
"Calls to the date constructor are recorded in the ``mock_date`` attributes "
"(``call_count`` and friends) which may also be useful for your tests."
msgstr "對日期構造函式的呼叫記錄在 ``mock_date`` 屬性（``call_count`` "
"和朋友）中，這也可能對您的測試有用。"

#: ../../library/unittest.mock-examples.rst:613
#, fuzzy
msgid ""
"An alternative way of dealing with mocking dates, or other builtin classes, "
"is discussed in `this blog entry <https://williambert.online/2011/07/how-to-"
"unit-testing-in-django-with-mocking-and-patching/>`_."
msgstr ""
"`this blog entry <https://williambert.online/2011/07/how-to-unit-testing-in-"
"django-with-mocking- 中討論了處理模擬日期或其他內建類的另一種方法和修補/>`_。"

#: ../../library/unittest.mock-examples.rst:619
#, fuzzy
msgid "Mocking a Generator Method"
msgstr "模擬生成器方法"

#: ../../library/unittest.mock-examples.rst:621
#, fuzzy
msgid ""
"A Python generator is a function or method that uses the :keyword:`yield` "
"statement to return a series of values when iterated over [#]_."
msgstr "Python 生成器是一種函式或方法，它使用 :keyword:`yield` 語句在疊代 [#]_ "
"時回傳一系列值。"

#: ../../library/unittest.mock-examples.rst:624
#, fuzzy
msgid ""
"A generator method / function is called to return the generator object. It "
"is the generator object that is then iterated over. The protocol method for "
"iteration is :meth:`~container.__iter__`, so we can mock this using a :class:"
"`MagicMock`."
msgstr ""
"呼叫生成器方法/函式以回傳生成器物件。然後疊代的是生成器物件。"
"疊代的協定方法是 :meth:`~container.__iter__`，因此我們可以使用 "
":class:`MagicMock` 模擬它。"

#: ../../library/unittest.mock-examples.rst:629
#, fuzzy
msgid ""
"Here's an example class with an \"iter\" method implemented as a generator:"
msgstr "這是一個示例類，其中包含作為生成器實作的 ``iter``方法："

#: ../../library/unittest.mock-examples.rst:641
#, fuzzy
msgid "How would we mock this class, and in particular its \"iter\" method?"
msgstr "我們如何模擬這個類，尤其是它的 ``iter``方法？"

#: ../../library/unittest.mock-examples.rst:643
#, fuzzy
msgid ""
"To configure the values returned from the iteration (implicit in the call "
"to :class:`list`), we need to configure the object returned by the call to "
"``foo.iter()``."
msgstr "要配置從疊代回傳的值（隱含在呼叫 list 中），我們需要配置呼叫 foo.iter() "
"回傳的物件。"

#: ../../library/unittest.mock-examples.rst:651
#, fuzzy
msgid ""
"There are also generator expressions and more `advanced uses <http://www."
"dabeaz.com/coroutines/index.html>`_ of generators, but we aren't concerned "
"about them here. A very good introduction to generators and how powerful "
"they are is: `Generator Tricks for Systems Programmers <http://www.dabeaz."
"com/generators/>`_."
msgstr ""
"還有生成器表達式和生成器的更多`高階用法 <http://www.dabeaz.com/coroutines/"
"index."
"html>`_，但我們在這裡不關心它們。對生成器及其強大功能的一個很好的介紹是：`"
"系統程式員的生成器技巧 <http://www.dabeaz.com/generators/>`_。"

#: ../../library/unittest.mock-examples.rst:659
#, fuzzy
msgid "Applying the same patch to every test method"
msgstr "對每個測試方法應用相同的補丁"

#: ../../library/unittest.mock-examples.rst:661
#, fuzzy
msgid ""
"If you want several patches in place for multiple test methods the obvious "
"way is to apply the patch decorators to every method. This can feel like "
"unnecessary repetition. Instead, you can use :func:`patch` (in all its "
"various forms) as a class decorator. This applies the patches to all test "
"methods on the class. A test method is identified by methods whose names "
"start with ``test``::"
msgstr ""
"如果你想為多個測試方法準備好幾個補丁，顯而易見的方法是將補丁裝飾器應用於每個"
"方法。這感覺像是不必要的重複。相反，您可以使用 "
":func:`patch`（以各種形式）作為類裝飾器。這會將補丁應用於該類的所有測試方法。"
"測試方法由名稱以 ``test`` 開頭的方法標識："

#: ../../library/unittest.mock-examples.rst:685
#, fuzzy
msgid ""
"An alternative way of managing patches is to use the :ref:`start-and-stop`. "
"These allow you to move the patching into your ``setUp`` and ``tearDown`` "
"methods. ::"
msgstr ""
"另一種管理補丁的方法是使用 :ref:`start-and-"
"stop`。這些允許您將補丁移動到您的``setUp``和``tearDown``方法中。 ::"

#: ../../library/unittest.mock-examples.rst:702
#, fuzzy
msgid ""
"If you use this technique you must ensure that the patching is \"undone\" by "
"calling ``stop``. This can be fiddlier than you might think, because if an "
"exception is raised in the setUp then tearDown is not called. :meth:"
"`unittest.TestCase.addCleanup` makes this easier::"
msgstr ""
"如果你使用這種技術，你必須通過呼叫 ``stop`` "
"來確保補丁被“撤銷”。這可能比您想像的更複雜，因為如果在 setUp 中引發例外，"
"則不會呼叫 tearDown。 :meth:`unittest.TestCase.addCleanup` 使這更容易::"

#: ../../library/unittest.mock-examples.rst:720
#, fuzzy
msgid "Mocking Unbound Methods"
msgstr "模擬未綁定方法"

#: ../../library/unittest.mock-examples.rst:722
#, fuzzy
msgid ""
"Whilst writing tests today I needed to patch an *unbound method* (patching "
"the method on the class rather than on the instance). I needed self to be "
"passed in as the first argument because I want to make asserts about which "
"objects were calling this particular method. The issue is that you can't "
"patch with a mock for this, because if you replace an unbound method with a "
"mock it doesn't become a bound method when fetched from the instance, and so "
"it doesn't get self passed in. The workaround is to patch the unbound method "
"with a real function instead. The :func:`patch` decorator makes it so simple "
"to patch out methods with a mock that having to create a real function "
"becomes a nuisance."
msgstr ""
"今天在編寫測試時，我需要修補一個*未綁定的方法*（修補類上的方法而不是實例上的"
"方法）。我需要將 self 作為第一個參數傳入，因為我想斷言哪些物件正在呼叫這個特"
"定方法。問題是你不能為此使用模擬進行修補，因為如果你用模擬替換未綁定的方法，"
"它在從實例中獲取時不會成為綁定方法，因此它不會自我傳遞。解決方法是用一個真正"
"的函式來修補未綁定的方法。 :func:`patch` 裝飾器使得用 mock "
"修補方法變得如此簡單，以至於不得不建立一個真正的函式變得很麻煩。"

#: ../../library/unittest.mock-examples.rst:733
#, fuzzy
msgid ""
"If you pass ``autospec=True`` to patch then it does the patching with a "
"*real* function object. This function object has the same signature as the "
"one it is replacing, but delegates to a mock under the hood. You still get "
"your mock auto-created in exactly the same way as before. What it means "
"though, is that if you use it to patch out an unbound method on a class the "
"mocked function will be turned into a bound method if it is fetched from an "
"instance. It will have ``self`` passed in as the first argument, which is "
"exactly what I wanted:"
msgstr ""
"如果您將 ``autospec=True`` 傳遞給補丁，那麼它會使用 *real* 函式物件進行補丁。"
"這個函式物件與它正在替換的物件具有相同的簽名，但在幕後委託給了一個模擬。您仍"
"然會以與以前完全相同的方式自動建立模擬。但它的意思是，如果您使用它來修補類上"
"的未綁定方法，則如果從實例中獲取模擬函式，則模擬函式將變成綁定方法。它會將 "
"``self`` 作為第一個參數傳入，這正是我想要的："

#: ../../library/unittest.mock-examples.rst:754
#, fuzzy
msgid ""
"If we don't use ``autospec=True`` then the unbound method is patched out "
"with a Mock instance instead, and isn't called with ``self``."
msgstr "如果我們不使用 ``autospec=True``，那麼未綁定的方法將用 Mock 實例修補，"
"而不是使用 ``self`` 呼叫。"

#: ../../library/unittest.mock-examples.rst:759
#, fuzzy
msgid "Checking multiple calls with mock"
msgstr "用模擬檢查多個呼叫"

#: ../../library/unittest.mock-examples.rst:761
#, fuzzy
msgid ""
"mock has a nice API for making assertions about how your mock objects are "
"used."
msgstr "mock 有一個很好的 API，可以斷言你的 mock 物件是如何使用的。"

#: ../../library/unittest.mock-examples.rst:768
#, fuzzy
msgid ""
"If your mock is only being called once you can use the :meth:"
"`assert_called_once_with` method that also asserts that the :attr:"
"`call_count` is one."
msgstr ""
"如果你的 mock 只被呼叫一次，你可以使用 :meth:`assert_called_once_with` 方法，"
"該方法也斷言 :attr:`call_count` 是一個。"

#: ../../library/unittest.mock-examples.rst:779
#, fuzzy
msgid ""
"Both ``assert_called_with`` and ``assert_called_once_with`` make assertions "
"about the *most recent* call. If your mock is going to be called several "
"times, and you want to make assertions about *all* those calls you can use :"
"attr:`~Mock.call_args_list`:"
msgstr ""
"``assert_called_with`` 和 ``assert_called_once_with`` 都對 *最近* "
"呼叫進行斷言。如果你的 mock "
"將被多次呼叫，並且你想對*所有*這些呼叫進行斷言，你可以使用 :attr:`~Mock."
"call_args_list`:"

#: ../../library/unittest.mock-examples.rst:791
#, fuzzy
msgid ""
"The :data:`call` helper makes it easy to make assertions about these calls. "
"You can build up a list of expected calls and compare it to "
"``call_args_list``. This looks remarkably similar to the repr of the "
"``call_args_list``:"
msgstr ""
":data:`call` 幫助程式可以輕鬆地對這些呼叫進行斷言。您可以建立一個預期呼叫列表"
"，並將其與“call_args_list”進行比較。這看起來與 ``call_args_list`` 的 repr "
"非常相似："

#: ../../library/unittest.mock-examples.rst:801
#, fuzzy
msgid "Coping with mutable arguments"
msgstr "處理可變參數"

#: ../../library/unittest.mock-examples.rst:803
#, fuzzy
msgid ""
"Another situation is rare, but can bite you, is when your mock is called "
"with mutable arguments. ``call_args`` and ``call_args_list`` store "
"*references* to the arguments. If the arguments are mutated by the code "
"under test then you can no longer make assertions about what the values were "
"when the mock was called."
msgstr ""
"另一種情況很少見，但可以咬你，當你的模擬被呼叫時帶有可變參數。 ``call_args`` "
"和 ``call_args_list`` 儲存參數的 *references*。如果參數被被測程式碼改變了，那"
"麼你就不能再斷言呼叫模擬時的值是什麼。"

#: ../../library/unittest.mock-examples.rst:808
#, fuzzy
msgid ""
"Here's some example code that shows the problem. Imagine the following "
"functions defined in 'mymodule'::"
msgstr "下面是一些顯示問題的示例程式碼。想像一下在 ``mymodule`` 中定義的以下函式："

#: ../../library/unittest.mock-examples.rst:819
#, fuzzy
msgid ""
"When we try to test that ``grob`` calls ``frob`` with the correct argument "
"look what happens::"
msgstr "當我們嘗試測試 ``grob`` 使用正確的參數呼叫 ``frob`` 時，看看會發生什麼："

#: ../../library/unittest.mock-examples.rst:834
#, fuzzy
msgid ""
"One possibility would be for mock to copy the arguments you pass in. This "
"could then cause problems if you do assertions that rely on object identity "
"for equality."
msgstr "一種可能性是讓 mock 複製您傳入的參數。如果您執行依賴於物件標識來實作相等性的"
"斷言，這可能會導致問題。"

#: ../../library/unittest.mock-examples.rst:838
#, fuzzy
msgid ""
"Here's one solution that uses the :attr:`side_effect` functionality. If you "
"provide a ``side_effect`` function for a mock then ``side_effect`` will be "
"called with the same args as the mock. This gives us an opportunity to copy "
"the arguments and store them for later assertions. In this example I'm using "
"*another* mock to store the arguments so that I can use the mock methods for "
"doing the assertion. Again a helper function sets this up for me. ::"
msgstr ""
"這是一個使用 :attr:`side_effect` 功能的解決方案。如果您為 mock 提供一個 "
"``side_effect`` 函式，那麼將使用與 mock 相同的參數呼叫 "
"``side_effect``。這使我們有機會復制參數並儲存它們以供以後斷言。在此示例中，"
"我使用 *another* mock 來儲存參數，以便我可以使用 mock "
"方法來執行斷言。輔助函式再次為我設定了這個。 ::"

#: ../../library/unittest.mock-examples.rst:867
#, fuzzy
msgid ""
"``copy_call_args`` is called with the mock that will be called. It returns a "
"new mock that we do the assertion on. The ``side_effect`` function makes a "
"copy of the args and calls our ``new_mock`` with the copy."
msgstr ""
"``copy_call_args`` "
"與將要呼叫的模擬一起呼叫。它回傳一個我們對其進行斷言的新模擬。 "
"``side_effect`` 函式複製了 args 並使用副本呼叫我們的 ``new_mock``。"

#: ../../library/unittest.mock-examples.rst:873
#, fuzzy
msgid ""
"If your mock is only going to be used once there is an easier way of "
"checking arguments at the point they are called. You can simply do the "
"checking inside a ``side_effect`` function."
msgstr ""
"如果你的 mock "
"只會被使用一次，那麼有一種更簡單的方法可以在呼叫參數時檢查參數。"
"您可以簡單地在 ``side_effect`` 函式中進行檢查。"

#: ../../library/unittest.mock-examples.rst:887
#, fuzzy
msgid ""
"An alternative approach is to create a subclass of :class:`Mock` or :class:"
"`MagicMock` that copies (using :func:`copy.deepcopy`) the arguments. Here's "
"an example implementation:"
msgstr "另一種方法是建立 Mock 或 MagicMock 的子類別來複製（使用 copy."
"deepcopy）參數。這是一個示例實作："

#: ../../library/unittest.mock-examples.rst:911
#, fuzzy
msgid ""
"When you subclass ``Mock`` or ``MagicMock`` all dynamically created "
"attributes, and the ``return_value`` will use your subclass automatically. "
"That means all children of a ``CopyingMock`` will also have the type "
"``CopyingMock``."
msgstr ""
"當您子類別化``Mock`` 或``MagicMock`` 所有動態建立的屬性時，``return_value`` "
"將自動使用您的子類別。這意味著 ``CopyingMock`` 的所有孩子也將具有 "
"``CopyingMock`` 型別。"

#: ../../library/unittest.mock-examples.rst:917
#, fuzzy
msgid "Nesting Patches"
msgstr "嵌套補丁"

#: ../../library/unittest.mock-examples.rst:919
#, fuzzy
msgid ""
"Using patch as a context manager is nice, but if you do multiple patches you "
"can end up with nested with statements indenting further and further to the "
"right::"
msgstr "使用 patch 作為情境管理器很好，但是如果你做多個補丁，你最終可能會嵌套 with "
"statements 越來越向右縮進::"

#: ../../library/unittest.mock-examples.rst:937
#, fuzzy
msgid ""
"With unittest ``cleanup`` functions and the :ref:`start-and-stop` we can "
"achieve the same effect without the nested indentation. A simple helper "
"method, ``create_patch``, puts the patch in place and returns the created "
"mock for us::"
msgstr ""
"使用 unittest ``cleanup`` 函式和 :ref:`start-and-stop` 我們可以在沒有嵌套縮進"
"的情況下實作相同的效果。一個簡單的輔助方法，``create_patch``，將補丁放置到位"
"並為我們回傳建立的模擬::"

#: ../../library/unittest.mock-examples.rst:965
#, fuzzy
msgid "Mocking a dictionary with MagicMock"
msgstr "用 MagicMock 模擬字典"

#: ../../library/unittest.mock-examples.rst:967
#, fuzzy
msgid ""
"You may want to mock a dictionary, or other container object, recording all "
"access to it whilst having it still behave like a dictionary."
msgstr "您可能想要模擬字典或其他容器物件，記錄對它的所有訪問，同時讓它仍然像字典一樣"
"運行。"

#: ../../library/unittest.mock-examples.rst:970
#, fuzzy
msgid ""
"We can do this with :class:`MagicMock`, which will behave like a dictionary, "
"and using :data:`~Mock.side_effect` to delegate dictionary access to a real "
"underlying dictionary that is under our control."
msgstr ""
"我們可以使用 :class:`MagicMock` 來做到這一點，它的行為類似於字典，並使用 "
":data:`~Mock.side_effect` 將字典訪問委託給我們控制下的真實底層字典。"

#: ../../library/unittest.mock-examples.rst:974
#, fuzzy
msgid ""
"When the :meth:`__getitem__` and :meth:`__setitem__` methods of our "
"``MagicMock`` are called (normal dictionary access) then ``side_effect`` is "
"called with the key (and in the case of ``__setitem__`` the value too). We "
"can also control what is returned."
msgstr ""
"當我們的 ``MagicMock`` 的 :meth:`__getitem__` 和 :meth:`__setitem__` "
"方法被呼叫時（正常的字典訪問）然後 ``side_effect`` 使用鍵被呼叫（在 ``"
"__setitem__ 的情況下） `` 也是價值）。我們還可以控制回傳的內容。"

#: ../../library/unittest.mock-examples.rst:978
#, fuzzy
msgid ""
"After the ``MagicMock`` has been used we can use attributes like :data:"
"`~Mock.call_args_list` to assert about how the dictionary was used:"
msgstr "使用 ``MagicMock`` 後，我們可以使用 :data:`~Mock.call_args_list` "
"等屬性來斷言字典的使用方式："

#: ../../library/unittest.mock-examples.rst:994
#, fuzzy
msgid ""
"An alternative to using ``MagicMock`` is to use ``Mock`` and *only* provide "
"the magic methods you specifically want:"
msgstr "使用 ``MagicMock`` 的另一種方法是使用 ``Mock`` 並且 *僅* "
"提供您特別需要的魔術方法："

#: ../../library/unittest.mock-examples.rst:1001
#, fuzzy
msgid ""
"A *third* option is to use ``MagicMock`` but passing in ``dict`` as the "
"*spec* (or *spec_set*) argument so that the ``MagicMock`` created only has "
"dictionary magic methods available:"
msgstr ""
"*第三個*選項是使用 ``MagicMock`` 但將 ``dict`` 作為 *spec*（或 "
"*spec_set*）參數傳遞，以便建立的 ``MagicMock`` 只有可用的字典魔術方法："

#: ../../library/unittest.mock-examples.rst:1009
#, fuzzy
msgid ""
"With these side effect functions in place, the ``mock`` will behave like a "
"normal dictionary but recording the access. It even raises a :exc:`KeyError` "
"if you try to access a key that doesn't exist."
msgstr ""
"有了這些副作用函式，``mock`` "
"將像普通字典一樣運行，但會記錄訪問。如果您嘗試訪問不存在的密鑰，它甚至會引發 "
":exc:`KeyError`。"

#: ../../library/unittest.mock-examples.rst:1028
#, fuzzy
msgid ""
"After it has been used you can make assertions about the access using the "
"normal mock methods and attributes:"
msgstr "使用後，您可以使用正常的模擬方法和屬性對訪問進行斷言："

#: ../../library/unittest.mock-examples.rst:1040
#, fuzzy
msgid "Mock subclasses and their attributes"
msgstr "模擬子類別及其屬性"

#: ../../library/unittest.mock-examples.rst:1042
#, fuzzy
msgid ""
"There are various reasons why you might want to subclass :class:`Mock`. One "
"reason might be to add helper methods. Here's a silly example:"
msgstr "您可能想要子類別化 Mock "
"的原因有多種。原因之一可能是新增輔助方法。這是一個愚蠢的例子："

#: ../../library/unittest.mock-examples.rst:1058
#, fuzzy
msgid ""
"The standard behaviour for ``Mock`` instances is that attributes and the "
"return value mocks are of the same type as the mock they are accessed on. "
"This ensures that ``Mock`` attributes are ``Mocks`` and ``MagicMock`` "
"attributes are ``MagicMocks`` [#]_. So if you're subclassing to add helper "
"methods then they'll also be available on the attributes and return value "
"mock of instances of your subclass."
msgstr ""
"``Mock`` 實例的標準行為是屬性和回傳值模擬與訪問它們的模擬具有相同的型別。這確"
"保了``Mock`` 屬性是``Mocks`` 和``MagicMock`` 屬性是``MagicMocks`` [#]_。因此"
"，如果您正在子類別化以新增輔助方法，那麼它們也可以在子類別實例的屬性和回傳值"
"模擬上使用。"

#: ../../library/unittest.mock-examples.rst:1074
#, fuzzy
msgid ""
"Sometimes this is inconvenient. For example, `one user <https://code.google."
"com/archive/p/mock/issues/105>`_ is subclassing mock to created a `Twisted "
"adaptor <https://twistedmatrix.com/documents/11.0.0/api/twisted.python."
"components.html>`_. Having this applied to attributes too actually causes "
"errors."
msgstr ""
"有時這很不方便。例如，`一個使用者 <https://code.google.com/archive/p/mock/"
"issues/105>`_ 正在繼承 mock 以建立一個`Twisted 適配器 <https://twistedmatrix."
"com/documents/11.0 .0/api/twisted.python.components."
"html>`_。將此應用於屬性實際上也會導致錯誤。"

#: ../../library/unittest.mock-examples.rst:1080
#, fuzzy
msgid ""
"``Mock`` (in all its flavours) uses a method called ``_get_child_mock`` to "
"create these \"sub-mocks\" for attributes and return values. You can prevent "
"your subclass being used for attributes by overriding this method. The "
"signature is that it takes arbitrary keyword arguments (``**kwargs``) which "
"are then passed onto the mock constructor:"
msgstr ""
"``Mock``（在其所有風格中）使用一種名為 ``_get_child_mock`` 的方法為屬性和回傳"
"值建立這些“子模擬”。您可以通過覆蓋此方法來防止您的子類別被用於屬性。簽名是它"
"採用任意關鍵字參數（``**kwargs``），然後將其傳遞給模擬構造函式："

#: ../../library/unittest.mock-examples.rst:1097
#, fuzzy
msgid ""
"An exception to this rule are the non-callable mocks. Attributes use the "
"callable variant because otherwise non-callable mocks couldn't have callable "
"methods."
msgstr "這條規則的一個例外是不可呼叫的模擬。屬性使用可呼叫變體，因為否則不可呼叫的模"
"擬不可能有可呼叫的方法。"

#: ../../library/unittest.mock-examples.rst:1103
#, fuzzy
msgid "Mocking imports with patch.dict"
msgstr "使用 patch.dict 模擬導入"

#: ../../library/unittest.mock-examples.rst:1105
#, fuzzy
msgid ""
"One situation where mocking can be hard is where you have a local import "
"inside a function. These are harder to mock because they aren't using an "
"object from the module namespace that we can patch out."
msgstr "模擬可能很困難的一種情況是您在函式內部有一個本地導入。這些更難模擬，因為它們"
"沒有使用我們可以修補的模組名稱空間中的物件。"

#: ../../library/unittest.mock-examples.rst:1109
#, fuzzy
msgid ""
"Generally local imports are to be avoided. They are sometimes done to "
"prevent circular dependencies, for which there is *usually* a much better "
"way to solve the problem (refactor the code) or to prevent \"up front costs"
"\" by delaying the import. This can also be solved in better ways than an "
"unconditional local import (store the module as a class or module attribute "
"and only do the import on first use)."
msgstr ""
"通常應避免本地進口。有時這樣做是為了防止循環依賴，*通常*有更好的方法來解決問"
"題（重構程式碼）或通過延遲導入來防止“前期成本”。這也可以通過比無條件本地導入"
"更好的方法來解決（將模組儲存為類或模組屬性，並且僅在首次使用時進行導入）。"

#: ../../library/unittest.mock-examples.rst:1116
#, fuzzy
msgid ""
"That aside there is a way to use ``mock`` to affect the results of an "
"import. Importing fetches an *object* from the :data:`sys.modules` "
"dictionary. Note that it fetches an *object*, which need not be a module. "
"Importing a module for the first time results in a module object being put "
"in ``sys.modules``, so usually when you import something you get a module "
"back. This need not be the case however."
msgstr ""
"除此之外，還有一種方法可以使用 ``mock`` 來影響導入的結果。導入從 :data:`sys."
"modules` 字典中獲取一個 *object*。請注意，它獲取一個 "
"*object*，它不一定是一個模組。第一次導入模組會導致模組物件被放入 ``sys."
"modules`` "
"中，因此通常當您導入某些東西時，您會得到一個模組。然而，情況並非如此。"

#: ../../library/unittest.mock-examples.rst:1123
#, fuzzy
msgid ""
"This means you can use :func:`patch.dict` to *temporarily* put a mock in "
"place in :data:`sys.modules`. Any imports whilst this patch is active will "
"fetch the mock. When the patch is complete (the decorated function exits, "
"the with statement body is complete or ``patcher.stop()`` is called) then "
"whatever was there previously will be restored safely."
msgstr ""
"這意味著您可以使用 :func:`patch.dict` 來*暫時*在 :data:`sys.modules` 中放置一"
"個模擬。此補丁處於活動狀態時的任何導入都將獲取模擬。當補丁完成時（修飾函式退"
"出，with 語句主體完成或呼叫 patcher.stop() ）然後之前的任何內容都將安全恢復。"

#: ../../library/unittest.mock-examples.rst:1129
#, fuzzy
msgid "Here's an example that mocks out the 'fooble' module."
msgstr "這是模擬 ``fooble``模組的示例。"

#: ../../library/unittest.mock-examples.rst:1141
#, fuzzy
msgid ""
"As you can see the ``import fooble`` succeeds, but on exit there is no "
"'fooble' left in :data:`sys.modules`."
msgstr "正如您所看到的，``import fooble`` 成功了，但是在退出時，sys.modules "
"中沒有留下任何 'fooble'。"

#: ../../library/unittest.mock-examples.rst:1144
#, fuzzy
msgid "This also works for the ``from module import name`` form:"
msgstr "這也適用於 ``from module import name`` 形式："

#: ../../library/unittest.mock-examples.rst:1154
#, fuzzy
msgid "With slightly more work you can also mock package imports:"
msgstr "通過稍微多一些工作，您還可以模擬包導入："

#: ../../library/unittest.mock-examples.rst:1167
#, fuzzy
msgid "Tracking order of calls and less verbose call assertions"
msgstr "跟踪呼叫順序和更簡潔的呼叫斷言"

#: ../../library/unittest.mock-examples.rst:1169
#, fuzzy
msgid ""
"The :class:`Mock` class allows you to track the *order* of method calls on "
"your mock objects through the :attr:`~Mock.method_calls` attribute. This "
"doesn't allow you to track the order of calls between separate mock objects, "
"however we can use :attr:`~Mock.mock_calls` to achieve the same effect."
msgstr ""
":class:`Mock` 類允許您通過 :attr:`~Mock.method_calls` 屬性跟踪模擬物件上方法"
"呼叫的*順序*。這不允許您跟踪單獨模擬物件之間的呼叫順序，但是我們可以使用 "
":attr:`~Mock.mock_calls` 來實作相同的效果。"

#: ../../library/unittest.mock-examples.rst:1174
#, fuzzy
msgid ""
"Because mocks track calls to child mocks in ``mock_calls``, and accessing an "
"arbitrary attribute of a mock creates a child mock, we can create our "
"separate mocks from a parent one. Calls to those child mock will then all be "
"recorded, in order, in the ``mock_calls`` of the parent:"
msgstr ""
"因為 mocks 在 mock_calls 中跟踪對子 mocks 的呼叫，並且訪問 mock "
"的任意屬性會建立子 mock，所以我們可以從父 mock 建立單獨的 "
"mock。然後，對這些子模擬的呼叫將按順序全部記錄在父物件的“mock_calls”中："

#: ../../library/unittest.mock-examples.rst:1191
#, fuzzy
msgid ""
"We can then assert about the calls, including the order, by comparing with "
"the ``mock_calls`` attribute on the manager mock:"
msgstr "然後我們可以通過與管理器模擬上的“mock_calls”屬性進行比較來斷言呼叫，包括順序"
"："

#: ../../library/unittest.mock-examples.rst:1198
#, fuzzy
msgid ""
"If ``patch`` is creating, and putting in place, your mocks then you can "
"attach them to a manager mock using the :meth:`~Mock.attach_mock` method. "
"After attaching calls will be recorded in ``mock_calls`` of the manager. ::"
msgstr ""
"如果 ``patch`` 正在建立並放置您的模擬，那麼您可以使用 :meth:`~Mock."
"attach_mock` "
"方法將它們附加到管理器模擬。附加呼叫後將記錄在經理的``mock_calls``中。 ::"

#: ../../library/unittest.mock-examples.rst:1217
#, fuzzy
msgid ""
"If many calls have been made, but you're only interested in a particular "
"sequence of them then an alternative is to use the :meth:`~Mock."
"assert_has_calls` method. This takes a list of calls (constructed with the :"
"data:`call` object). If that sequence of calls are in :attr:`~Mock."
"mock_calls` then the assert succeeds."
msgstr ""
"如果進行了很多呼叫，但您只對它們的特定序列感興趣，那麼另一種方法是使用 "
":meth:`~Mock.assert_has_calls` 方法。這需要一個呼叫列表（使用 :data:`call` "
"物件構造）。如果該呼叫序列在 :attr:`~Mock.mock_calls` 中，則斷言成功。"

#: ../../library/unittest.mock-examples.rst:1231
#, fuzzy
msgid ""
"Even though the chained call ``m.one().two().three()`` aren't the only calls "
"that have been made to the mock, the assert still succeeds."
msgstr "即使鍊式呼叫``m.one().two().three()`` "
"不是對模擬進行的唯一呼叫，斷言仍然成功。"

#: ../../library/unittest.mock-examples.rst:1234
#, fuzzy
msgid ""
"Sometimes a mock may have several calls made to it, and you are only "
"interested in asserting about *some* of those calls. You may not even care "
"about the order. In this case you can pass ``any_order=True`` to "
"``assert_has_calls``:"
msgstr ""
"有時一個 mock 可能有多個呼叫，而您只對斷言這些呼叫中的*一些*感興趣。您甚至可"
"能不關心順序。在這種情況下，您可以將 ``any_order=True`` 傳遞給 "
"``assert_has_calls``："

#: ../../library/unittest.mock-examples.rst:1246
#, fuzzy
msgid "More complex argument matching"
msgstr "更複雜的參數匹配"

#: ../../library/unittest.mock-examples.rst:1248
#, fuzzy
msgid ""
"Using the same basic concept as :data:`ANY` we can implement matchers to do "
"more complex assertions on objects used as arguments to mocks."
msgstr "使用與 ANY "
"相同的基本概念，我們可以實作匹配器以對用作模擬參數的物件執行更複雜的斷言。"

#: ../../library/unittest.mock-examples.rst:1251
#, fuzzy
msgid ""
"Suppose we expect some object to be passed to a mock that by default "
"compares equal based on object identity (which is the Python default for "
"user defined classes). To use :meth:`~Mock.assert_called_with` we would need "
"to pass in the exact same object. If we are only interested in some of the "
"attributes of this object then we can create a matcher that will check these "
"attributes for us."
msgstr ""
"假設我們希望將某個物件傳遞給預設情況下根據物件標識比較相等的模擬（"
"這是使用者定義類的 Python 預設值）。要使用 :meth:`~Mock.assert_called_with` "
"我們需要傳入完全相同的物件。如果我們只對該物件的某些屬性感興趣，那麼我們可以"
"建立一個匹配器來為我們檢查這些屬性。"

#: ../../library/unittest.mock-examples.rst:1258
#, fuzzy
msgid ""
"You can see in this example how a 'standard' call to ``assert_called_with`` "
"isn't sufficient:"
msgstr "您可以在此示例中看到對“assert_called_with”的“標準”呼叫是如何不夠的："

#: ../../library/unittest.mock-examples.rst:1273
#, fuzzy
msgid ""
"A comparison function for our ``Foo`` class might look something like this:"
msgstr "我們的 ``Foo`` 類的比較函式可能看起來像這樣："

#: ../../library/unittest.mock-examples.rst:1285
#, fuzzy
msgid ""
"And a matcher object that can use comparison functions like this for its "
"equality operation would look something like this:"
msgstr "一個可以使用這樣的比較函式來進行相等操作的匹配器物件看起來像這樣："

#: ../../library/unittest.mock-examples.rst:1296
#, fuzzy
msgid "Putting all this together:"
msgstr "把所有這些放在一起："

#: ../../library/unittest.mock-examples.rst:1301
#, fuzzy
msgid ""
"The ``Matcher`` is instantiated with our compare function and the ``Foo`` "
"object we want to compare against. In ``assert_called_with`` the ``Matcher`` "
"equality method will be called, which compares the object the mock was "
"called with against the one we created our matcher with. If they match then "
"``assert_called_with`` passes, and if they don't an :exc:`AssertionError` is "
"raised:"
msgstr ""
"``Matcher`` 是用我們的比較函式和我們想要比較的 ``Foo`` 物件實例化的。在 "
"``assert_called_with`` 中將呼叫 ``Matcher`` "
"相等方法，它將呼叫模擬的物件與我們建立匹配器的物件進行比較。如果它們匹配，則 "
"``assert_called_with`` 通過，如果它們不匹配，則引發 :exc:`AssertionError`："

#: ../../library/unittest.mock-examples.rst:1314
#, fuzzy
msgid ""
"With a bit of tweaking you could have the comparison function raise the :exc:"
"`AssertionError` directly and provide a more useful failure message."
msgstr "通過一些調整，您可以讓比較函式直接引發 :exc:`AssertionError` "
"並提供更有用的失敗消息。"

#: ../../library/unittest.mock-examples.rst:1317
#, fuzzy
msgid ""
"As of version 1.5, the Python testing library `PyHamcrest <https://"
"pyhamcrest.readthedocs.io/>`_ provides similar functionality, that may be "
"useful here, in the form of its equality matcher (`hamcrest.library."
"integration.match_equality <https://pyhamcrest.readthedocs.io/en/release-1.8/"
"integration/#module-hamcrest.library.integration.match_equality>`_)."
msgstr ""
"從 1.5 版開始，Python 測試庫 `PyHamcrest <https://pyhamcrest.readthedocs.io/"
">`_ 以其等式匹配器 (`hamcrest.library.integration. match_equality "
"<https://pyhamcrest.readthedocs.io/en/release-1.8/integration/#module-"
"hamcrest.library.integration.match_equality>`_)。"
