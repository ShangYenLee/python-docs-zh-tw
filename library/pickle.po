# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-24 00:16+0000\n"
"PO-Revision-Date: 2018-05-23 16:07+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/pickle.rst:2
msgid ":mod:`pickle` --- Python object serialization"
msgstr ":mod:`pickle` --- Python 物件序列化"

#: ../../library/pickle.rst:10
msgid "**Source code:** :source:`Lib/pickle.py`"
msgstr "**原始碼：**\\ :source:`Lib/pickle.py`"

#: ../../library/pickle.rst:22
#, fuzzy
msgid ""
"The :mod:`pickle` module implements binary protocols for serializing and de-"
"serializing a Python object structure.  *\"Pickling\"* is the process "
"whereby a Python object hierarchy is converted into a byte stream, and "
"*\"unpickling\"* is the inverse operation, whereby a byte stream (from a :"
"term:`binary file` or :term:`bytes-like object`) is converted back into an "
"object hierarchy.  Pickling (and unpickling) is alternatively known as "
"\"serialization\", \"marshalling,\" [#]_ or \"flattening\"; however, to "
"avoid confusion, the terms used here are \"pickling\" and \"unpickling\"."
msgstr ""
"pickle 模組實作了用於序列化和反序列化 Python 物件結構的二進位協定。 "
"* ``Pickling`` * 是將 Python 物件層次結構轉換為位元組流的過程，* ``unpickling``* "
"是逆向操作，位元組流（來自 :term:`binary file` 或 :term:` bytes-like object`)"
" 被轉換回物件層次結構。 Pickling（和 unpickling）也稱為“序列化”、“編組”、[#]"
"_ 或“扁平化”；但是，為避免混淆，此處使用的術語是 ``pickling`` 和 ``unpickling``。"

#: ../../library/pickle.rst:33
#, fuzzy
msgid "The ``pickle`` module **is not secure**. Only unpickle data you trust."
msgstr "``pickle`` 模組**不安全**。只解開您信任的資料。"

#: ../../library/pickle.rst:35
#, fuzzy
msgid ""
"It is possible to construct malicious pickle data which will **execute "
"arbitrary code during unpickling**. Never unpickle data that could have come "
"from an untrusted source, or that could have been tampered with."
msgstr ""
"構建惡意 pickle 資料是可能的，它將**在 unpickling "
"期間執行任意程式碼**。切勿取消可能來自不受信任來源或可能已被篡改的資料。"

#: ../../library/pickle.rst:39
#, fuzzy
msgid ""
"Consider signing data with :mod:`hmac` if you need to ensure that it has not "
"been tampered with."
msgstr "如果您需要確保資料未被篡改，請考慮使用 :mod:`hmac` 對資料進行簽名。"

#: ../../library/pickle.rst:42
#, fuzzy
msgid ""
"Safer serialization formats such as :mod:`json` may be more appropriate if "
"you are processing untrusted data. See :ref:`comparison-with-json`."
msgstr ""
"如果您正在處理不受信任的資料，則更安全的序列化格式（如 :mod:`json` "
"可能更合適。請參閱 :ref:`comparison-with-json`。"

#: ../../library/pickle.rst:47
#, fuzzy
msgid "Relationship to other Python modules"
msgstr "與其他 Python 模組的關係"

#: ../../library/pickle.rst:50
#, fuzzy
msgid "Comparison with ``marshal``"
msgstr "與 ``marshal`` 的比較"

#: ../../library/pickle.rst:52
#, fuzzy
msgid ""
"Python has a more primitive serialization module called :mod:`marshal`, but "
"in general :mod:`pickle` should always be the preferred way to serialize "
"Python objects.  :mod:`marshal` exists primarily to support Python's :file:`."
"pyc` files."
msgstr ""
"Python 有一個更原始的序列化模組，稱為 "
":mod:`marshal`，但一般來說，:mod:`pickle` 應該始終是序列化 Python "
"物件的首選方式。 :mod:`marshal` 的存在主要是為了支援 Python 的 :file:`.pyc` "
"文件。"

#: ../../library/pickle.rst:57
#, fuzzy
msgid ""
"The :mod:`pickle` module differs from :mod:`marshal` in several significant "
"ways:"
msgstr ":mod:`pickle` 模組在幾個重要方面與 :mod:`marshal` 不同："

#: ../../library/pickle.rst:59
#, fuzzy
msgid ""
"The :mod:`pickle` module keeps track of the objects it has already "
"serialized, so that later references to the same object won't be serialized "
"again. :mod:`marshal` doesn't do this."
msgstr ":mod:`pickle` "
"模組跟踪它已經序列化的物件，以便以後對同一物件的引用不會再次序列化。 "
":mod:`marshal` 不會這樣做。"

#: ../../library/pickle.rst:63
#, fuzzy
msgid ""
"This has implications both for recursive objects and object sharing.  "
"Recursive objects are objects that contain references to themselves.  These "
"are not handled by marshal, and in fact, attempting to marshal recursive "
"objects will crash your Python interpreter.  Object sharing happens when "
"there are multiple references to the same object in different places in the "
"object hierarchy being serialized.  :mod:`pickle` stores such objects only "
"once, and ensures that all other references point to the master copy.  "
"Shared objects remain shared, which can be very important for mutable "
"objects."
msgstr ""
"這對遞迴物件和物件共享都有影響。遞迴對像是包含對自身的引用的物件。這些不是由"
"編組處理的，事實上，嘗試編組遞迴物件會使您的 Python 直譯器崩潰。當在被序列化"
"的物件層次結構中的不同位置存在對同一物件的多個引用時，就會發生物件共享。 "
":mod:`pickle` 僅儲存此類對像一次，並確保所有其他引用都指向主副本。共享物件保"
"持共享狀態，這對於可變物件非常重要。"

#: ../../library/pickle.rst:72
#, fuzzy
msgid ""
":mod:`marshal` cannot be used to serialize user-defined classes and their "
"instances.  :mod:`pickle` can save and restore class instances "
"transparently, however the class definition must be importable and live in "
"the same module as when the object was stored."
msgstr ""
":mod:`marshal` 不能用於序列化使用者定義的類及其實例。 :mod:`pickle` 可以透明"
"地保存和恢復類實例，但是類定義必須是可導入的，並且與儲存物件時位於同一模組中"
"。"

#: ../../library/pickle.rst:77
#, fuzzy
msgid ""
"The :mod:`marshal` serialization format is not guaranteed to be portable "
"across Python versions.  Because its primary job in life is to support :file:"
"`.pyc` files, the Python implementers reserve the right to change the "
"serialization format in non-backwards compatible ways should the need arise. "
"The :mod:`pickle` serialization format is guaranteed to be backwards "
"compatible across Python releases provided a compatible pickle protocol is "
"chosen and pickling and unpickling code deals with Python 2 to Python 3 type "
"differences if your data is crossing that unique breaking change language "
"boundary."
msgstr ""
":mod:`marshal` 序列化格式不保證可以跨 Python 版本移植。"
"因為它的主要工作是支援 :file:`.pyc` 文件，Python "
"實作者保留在需要時以非向後相容的方式更改序列化格式的權利。 :mod:`pickle` "
"序列化格式保證在 Python 版本之間向後相容，前提是選擇了相容的 pickle "
"協定，並且如果您的資料跨越了獨特的突破性更改語言邊界，pickling 和 unpickling "
"程式碼會處理 Python 2 到 Python 3 的型別差異."

#: ../../library/pickle.rst:90
#, fuzzy
msgid "Comparison with ``json``"
msgstr "與 ``json`` 的比較"

#: ../../library/pickle.rst:92
#, fuzzy
msgid ""
"There are fundamental differences between the pickle protocols and `JSON "
"(JavaScript Object Notation) <https://json.org>`_:"
msgstr "pickle 協定和 `JSON（JavaScript 物件表示法）<https://json.org>`_ "
"之間存在根本區別："

#: ../../library/pickle.rst:95
#, fuzzy
msgid ""
"JSON is a text serialization format (it outputs unicode text, although most "
"of the time it is then encoded to ``utf-8``), while pickle is a binary "
"serialization format;"
msgstr ""
"JSON 是一種文本序列化格式（它輸出 unicode 文本，儘管大多數時候它會被編碼為 "
"``utf-8``），而 pickle 是一種二進位序列化格式；"

#: ../../library/pickle.rst:99
#, fuzzy
msgid "JSON is human-readable, while pickle is not;"
msgstr "JSON 是人類可讀的，而 pickle 不是；"

#: ../../library/pickle.rst:101
#, fuzzy
msgid ""
"JSON is interoperable and widely used outside of the Python ecosystem, while "
"pickle is Python-specific;"
msgstr "JSON 在 Python 生態系統之外具有互操作性和廣泛使用，而 pickle 是特定於 Python "
"的；"

#: ../../library/pickle.rst:104
#, fuzzy
msgid ""
"JSON, by default, can only represent a subset of the Python built-in types, "
"and no custom classes; pickle can represent an extremely large number of "
"Python types (many of them automatically, by clever usage of Python's "
"introspection facilities; complex cases can be tackled by implementing :ref:"
"`specific object APIs <pickle-inst>`);"
msgstr ""
"預設情況下，JSON 只能表示 Python 內建型別的一個子集，不能表示自定義類； "
"pickle 可以表示大量的 Python 型別（其中許多是自動的，通過巧妙地使用 Python "
"的內省工具；複雜的情況可以通過實作 :ref:`特定物件 API <pickle-inst>` "
"來解決）；"

#: ../../library/pickle.rst:110
#, fuzzy
msgid ""
"Unlike pickle, deserializing untrusted JSON does not in itself create an "
"arbitrary code execution vulnerability."
msgstr "與 pickle 不同，反序列化不受信任的 JSON 本身不會產生任意程式碼執行漏洞。"

#: ../../library/pickle.rst:114
#, fuzzy
msgid ""
"The :mod:`json` module: a standard library module allowing JSON "
"serialization and deserialization."
msgstr ":mod:`json` 模組：一個允許 JSON 序列化和反序列化的標準庫模組。"

#: ../../library/pickle.rst:121
#, fuzzy
msgid "Data stream format"
msgstr "資料流格式"

#: ../../library/pickle.rst:126
#, fuzzy
msgid ""
"The data format used by :mod:`pickle` is Python-specific.  This has the "
"advantage that there are no restrictions imposed by external standards such "
"as JSON or XDR (which can't represent pointer sharing); however it means "
"that non-Python programs may not be able to reconstruct pickled Python "
"objects."
msgstr ""
":mod:`pickle` 使用的資料格式是特定於 Python "
"的。這樣做的好處是沒有JSON或XDR等外部標準的限制（不能代表指標共享）；然而，"
"這意味著非 Python 程式可能無法重建醃製的 Python 物件。"

#: ../../library/pickle.rst:131
#, fuzzy
msgid ""
"By default, the :mod:`pickle` data format uses a relatively compact binary "
"representation.  If you need optimal size characteristics, you can "
"efficiently :doc:`compress <archiving>` pickled data."
msgstr ""
"預設情況下，:mod:`pickle` "
"資料格式使用相對緊湊的二進位表示。如果您需要最佳大小特性，您可以有效地壓縮 "
"<archiving>` 醃製資料。"

#: ../../library/pickle.rst:135
#, fuzzy
msgid ""
"The module :mod:`pickletools` contains tools for analyzing data streams "
"generated by :mod:`pickle`.  :mod:`pickletools` source code has extensive "
"comments about opcodes used by pickle protocols."
msgstr ""
"模組 :mod:`pickletools` 包含用於分析由 :mod:`pickle` 生成的資料流的工具。 "
":mod:`pickletools` 源程式碼對 pickle 協定使用的操作碼有廣泛的評論。"

#: ../../library/pickle.rst:139
#, fuzzy
msgid ""
"There are currently 6 different protocols which can be used for pickling. "
"The higher the protocol used, the more recent the version of Python needed "
"to read the pickle produced."
msgstr "目前有 6 種不同的協定可用於酸洗。使用的協定越高，讀取生成的 pickle 所需的 "
"Python 版本越新。"

#: ../../library/pickle.rst:143
#, fuzzy
msgid ""
"Protocol version 0 is the original \"human-readable\" protocol and is "
"backwards compatible with earlier versions of Python."
msgstr "協定版本 0 是原始的“人類可讀”協定，並且向後相容早期版本的 Python。"

#: ../../library/pickle.rst:146
#, fuzzy
msgid ""
"Protocol version 1 is an old binary format which is also compatible with "
"earlier versions of Python."
msgstr "協定版本 1 是一種舊的二進位格式，它也與早期版本的 Python 相容。"

#: ../../library/pickle.rst:149
#, fuzzy
msgid ""
"Protocol version 2 was introduced in Python 2.3.  It provides much more "
"efficient pickling of :term:`new-style classes <new-style class>`.  Refer "
"to :pep:`307` for information about improvements brought by protocol 2."
msgstr ""
"協定版本 2 是在 Python 2.3 中引入的。它提供了更有效的 :term:`new-style "
"classes <new-style class>` 酸洗。有關協定 2 帶來的改進的資訊，請參閱 "
":pep:`307`。"

#: ../../library/pickle.rst:153
#, fuzzy
msgid ""
"Protocol version 3 was added in Python 3.0.  It has explicit support for :"
"class:`bytes` objects and cannot be unpickled by Python 2.x.  This was the "
"default protocol in Python 3.0--3.7."
msgstr ""
"Python 3.0 中新增了協定版本 3。它明確支援 :class:`bytes` 物件並且不能被 "
"Python 2.x 解封。這是 Python 3.0--3.7 中的預設協定。"

#: ../../library/pickle.rst:157
#, fuzzy
msgid ""
"Protocol version 4 was added in Python 3.4.  It adds support for very large "
"objects, pickling more kinds of objects, and some data format "
"optimizations.  It is the default protocol starting with Python 3.8. Refer "
"to :pep:`3154` for information about improvements brought by protocol 4."
msgstr ""
"Python 3.4 中新增了協定版本 4。它增加了對非常大的物件的支援，對更多種類的物件"
"進行酸洗，以及一些資料格式最佳化。它是從 Python 3.8 開始的預設協定。有關協定 "
"4 帶來的改進的資訊，請參閱 :pep:`3154`。"

#: ../../library/pickle.rst:163
#, fuzzy
msgid ""
"Protocol version 5 was added in Python 3.8.  It adds support for out-of-band "
"data and speedup for in-band data.  Refer to :pep:`574` for information "
"about improvements brought by protocol 5."
msgstr ""
"Python 3.8 中新增了協定版本 5。它增加了對帶外資料的支援和對帶內資料的加速。"
"有關協定 5 帶來的改進的資訊，請參閱 :pep:`574`。"

#: ../../library/pickle.rst:168
#, fuzzy
msgid ""
"Serialization is a more primitive notion than persistence; although :mod:"
"`pickle` reads and writes file objects, it does not handle the issue of "
"naming persistent objects, nor the (even more complicated) issue of "
"concurrent access to persistent objects.  The :mod:`pickle` module can "
"transform a complex object into a byte stream and it can transform the byte "
"stream into an object with the same internal structure.  Perhaps the most "
"obvious thing to do with these byte streams is to write them onto a file, "
"but it is also conceivable to send them across a network or store them in a "
"database.  The :mod:`shelve` module provides a simple interface to pickle "
"and unpickle objects on DBM-style database files."
msgstr ""
"序列化是比持久化更原始的概念；雖然 :mod:`pickle` 讀取和寫入文件物件，但它不處"
"理命名持久物件的問題，也不處理（甚至更複雜的）並發訪問持久物件的問題。 "
":mod:`pickle` 模組可以將復雜物件轉換為位元組流，並且可以將位元組流轉換為具有"
"相同內部結構的物件。也許對這些位元組流最明顯的處理是將它們寫入文件，但也可以"
"想像通過網絡發送它們或將它們儲存在資料庫中。 :mod:`shelve` "
"模組提供了一個簡單的介面來 pickle 和 unpickle DBM 風格的資料庫文件上的物件。"

#: ../../library/pickle.rst:181
msgid "Module Interface"
msgstr "模組介面"

#: ../../library/pickle.rst:183
#, fuzzy
msgid ""
"To serialize an object hierarchy, you simply call the :func:`dumps` "
"function. Similarly, to de-serialize a data stream, you call the :func:"
"`loads` function. However, if you want more control over serialization and "
"de-serialization, you can create a :class:`Pickler` or an :class:`Unpickler` "
"object, respectively."
msgstr ""
"要序列化物件層次結構，只需呼叫 dumps 函式即可。同樣，要反序列化資料流，"
"您可以呼叫 :func:`loads` 函式。然而，如果你想更好地控制序列化和反序列化，你可"
"以分別建立一個 :class:`Pickler` 或一個 :class:`Unpickler` 物件。"

#: ../../library/pickle.rst:188
#, fuzzy
msgid "The :mod:`pickle` module provides the following constants:"
msgstr ":mod:`pickle` 模組提供以下常數："

#: ../../library/pickle.rst:193
#, fuzzy
msgid ""
"An integer, the highest :ref:`protocol version <pickle-protocols>` "
"available.  This value can be passed as a *protocol* value to functions :"
"func:`dump` and :func:`dumps` as well as the :class:`Pickler` constructor."
msgstr ""
"一個整數，最高 :ref:`協定版本 <pickle-protocols>` 可用。該值可以作為 "
"*protocol* 值傳遞給函式 :func:`dump` 和 :func:`dumps` 以及 :class:`Pickler` "
"構造函式。"

#: ../../library/pickle.rst:200
#, fuzzy
msgid ""
"An integer, the default :ref:`protocol version <pickle-protocols>` used for "
"pickling.  May be less than :data:`HIGHEST_PROTOCOL`.  Currently the default "
"protocol is 4, first introduced in Python 3.4 and incompatible with previous "
"versions."
msgstr ""
"一個整數，用於 pickling 的預設 :ref:`協定版本 <pickle-protocols>`。可能小於 "
":data:`HIGHEST_PROTOCOL`。目前預設協定為 4，最早在 Python 3.4 "
"中引入，與之前的版本不相容。"

#: ../../library/pickle.rst:207
#, fuzzy
msgid "The default protocol is 3."
msgstr "預設協定為 3。"

#: ../../library/pickle.rst:211
#, fuzzy
msgid "The default protocol is 4."
msgstr "預設協定為 4。"

#: ../../library/pickle.rst:213
#, fuzzy
msgid ""
"The :mod:`pickle` module provides the following functions to make the "
"pickling process more convenient:"
msgstr ":mod:`pickle` 模組提供了以下功能，使酸洗過程更加方便："

#: ../../library/pickle.rst:218
#, fuzzy
msgid ""
"Write the pickled representation of the object *obj* to the open :term:`file "
"object` *file*.  This is equivalent to ``Pickler(file, protocol).dump(obj)``."
msgstr ""
"將物件 *obj* 的 pickled 表示寫入打開的 :term:`file object` "
"*file*。這相當於``Pickler(file, protocol).dump(obj)``。"

#: ../../library/pickle.rst:222
#, fuzzy
msgid ""
"Arguments *file*, *protocol*, *fix_imports* and *buffer_callback* have the "
"same meaning as in the :class:`Pickler` constructor."
msgstr ""
"參數 *file*、*protocol*、*fix_imports* 和 *buffer_callback* 與 Pickler "
"構造函式中的含義相同。"

#: ../../library/pickle.rst:225 ../../library/pickle.rst:236
#: ../../library/pickle.rst:328
msgid "The *buffer_callback* argument was added."
msgstr "新增 *buffer_callback* 引數。"

#: ../../library/pickle.rst:230
#, fuzzy
msgid ""
"Return the pickled representation of the object *obj* as a :class:`bytes` "
"object, instead of writing it to a file."
msgstr "將物件 *obj* 的 pickled 表示作為 :class:`bytes` "
"物件回傳，而不是將其寫入文件。"

#: ../../library/pickle.rst:233
#, fuzzy
msgid ""
"Arguments *protocol*, *fix_imports* and *buffer_callback* have the same "
"meaning as in the :class:`Pickler` constructor."
msgstr "參數 *protocol*、*fix_imports* 和 *buffer_callback* 與 Pickler "
"構造函式中的含義相同。"

#: ../../library/pickle.rst:241
#, fuzzy
msgid ""
"Read the pickled representation of an object from the open :term:`file "
"object` *file* and return the reconstituted object hierarchy specified "
"therein. This is equivalent to ``Unpickler(file).load()``."
msgstr ""
"從打開的 :term:`file object` *file* 中讀取物件的 pickled "
"表示，並回傳其中指定的重構物件層次結構。這相當於 ``Unpickler(file).load()``。"

#: ../../library/pickle.rst:245 ../../library/pickle.rst:260
#, fuzzy
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed.  Bytes past the pickled representation of the object are "
"ignored."
msgstr "pickle 的協定版本是自動檢測的，因此不需要協定參數。超過物件的 pickled "
"表示的位元組將被忽略。"

#: ../../library/pickle.rst:249
#, fuzzy
msgid ""
"Arguments *file*, *fix_imports*, *encoding*, *errors*, *strict* and "
"*buffers* have the same meaning as in the :class:`Unpickler` constructor."
msgstr ""
"參數 *file*、*fix_imports*、*encoding*、*errors*、*strict* 和 *buffers* 與 "
"Unpickler 構造函式中的含義相同。"

#: ../../library/pickle.rst:252 ../../library/pickle.rst:267
#: ../../library/pickle.rst:429
msgid "The *buffers* argument was added."
msgstr "新增 *buffer* 引數。"

#: ../../library/pickle.rst:257
#, fuzzy
msgid ""
"Return the reconstituted object hierarchy of the pickled representation "
"*data* of an object. *data* must be a :term:`bytes-like object`."
msgstr "回傳物件的醃製表示*資料*的重構物件層次結構。 *data* 必須是一個 :term:`bytes-"
"like object`。"

#: ../../library/pickle.rst:264
#, fuzzy
msgid ""
"Arguments *fix_imports*, *encoding*, *errors*, *strict* and *buffers* have "
"the same meaning as in the :class:`Unpickler` constructor."
msgstr ""
"參數 *fix_imports*、*encoding*、*errors*、*strict* 和 *buffers* 與 Unpickler "
"構造函式中的含義相同。"

#: ../../library/pickle.rst:271
#, fuzzy
msgid "The :mod:`pickle` module defines three exceptions:"
msgstr ":mod:`pickle` 模組定義了三個例外："

#: ../../library/pickle.rst:275
#, fuzzy
msgid ""
"Common base class for the other pickling exceptions.  It inherits :exc:"
"`Exception`."
msgstr "其他酸洗例外的公開基底類別。它繼承了 :exc:`Exception`。"

#: ../../library/pickle.rst:280
#, fuzzy
msgid ""
"Error raised when an unpicklable object is encountered by :class:`Pickler`. "
"It inherits :exc:`PickleError`."
msgstr ":class:`Pickler` 遇到 unpicklable "
"物件時引發錯誤。它繼承了 :exc:`PickleError`。"

#: ../../library/pickle.rst:283
#, fuzzy
msgid ""
"Refer to :ref:`pickle-picklable` to learn what kinds of objects can be "
"pickled."
msgstr "請參閱 :ref:`pickle-picklable` 以了解可以 pickle 的對像型別。"

#: ../../library/pickle.rst:288
#, fuzzy
msgid ""
"Error raised when there is a problem unpickling an object, such as a data "
"corruption or a security violation.  It inherits :exc:`PickleError`."
msgstr "當對像出現問題時引發錯誤，例如資料損壞或安全違規。它繼承了 :exc:`PickleError`"
"。"

#: ../../library/pickle.rst:291
#, fuzzy
msgid ""
"Note that other exceptions may also be raised during unpickling, including "
"(but not necessarily limited to) AttributeError, EOFError, ImportError, and "
"IndexError."
msgstr ""
"請注意，在 unpickling "
"期間也可能引發其他例外，包括（但不一定限於）AttributeError、EOFError、"
"ImportError 和 IndexError。"

#: ../../library/pickle.rst:296
#, fuzzy
msgid ""
"The :mod:`pickle` module exports three classes, :class:`Pickler`, :class:"
"`Unpickler` and :class:`PickleBuffer`:"
msgstr ""
":mod:`pickle` 模組導出三個類：:class:`Pickler`、:class:`Unpickler` 和 "
":class:`PickleBuffer`："

#: ../../library/pickle.rst:301
#, fuzzy
msgid "This takes a binary file for writing a pickle data stream."
msgstr "這需要一個二進位文件來寫入 pickle 資料流。"

#: ../../library/pickle.rst:303
#, fuzzy
msgid ""
"The optional *protocol* argument, an integer, tells the pickler to use the "
"given protocol; supported protocols are 0 to :data:`HIGHEST_PROTOCOL`. If "
"not specified, the default is :data:`DEFAULT_PROTOCOL`.  If a negative "
"number is specified, :data:`HIGHEST_PROTOCOL` is selected."
msgstr ""
"可選的 *protocol* 參數，一個整數，告訴 pickler 使用給定的協定；支援的協定是 "
"0 到 :data:`HIGHEST_PROTOCOL`。如果未指定，則預設為 :data:`DEFAULT_PROTOCOL`"
"。如果指定負數，則選擇 :data:`HIGHEST_PROTOCOL`。"

#: ../../library/pickle.rst:308
#, fuzzy
msgid ""
"The *file* argument must have a write() method that accepts a single bytes "
"argument.  It can thus be an on-disk file opened for binary writing, an :"
"class:`io.BytesIO` instance, or any other custom object that meets this "
"interface."
msgstr ""
"*file* 參數必須有一個接受單個位元組參數的 write() "
"方法。因此，它可以是為二進位寫入而打開的磁盤文件、io.BytesIO "
"實例或滿足此介面的任何其他自定義物件。"

#: ../../library/pickle.rst:313
#, fuzzy
msgid ""
"If *fix_imports* is true and *protocol* is less than 3, pickle will try to "
"map the new Python 3 names to the old module names used in Python 2, so that "
"the pickle data stream is readable with Python 2."
msgstr ""
"如果 *fix_imports* 為真且 *protocol* 小於 3，pickle 將嘗試將新的 Python 3 "
"名稱映射到 Python 2 中使用的舊模組名稱，以便 pickle 資料流可以用 Python 2 "
"讀取。"

#: ../../library/pickle.rst:317
#, fuzzy
msgid ""
"If *buffer_callback* is None (the default), buffer views are serialized into "
"*file* as part of the pickle stream."
msgstr "如果 *buffer_callback* 為 None（預設值），緩衝區視圖將作為 pickle "
"流的一部分序列化到 *file* 中。"

#: ../../library/pickle.rst:320
#, fuzzy
msgid ""
"If *buffer_callback* is not None, then it can be called any number of times "
"with a buffer view.  If the callback returns a false value (such as None), "
"the given buffer is :ref:`out-of-band <pickle-oob>`; otherwise the buffer is "
"serialized in-band, i.e. inside the pickle stream."
msgstr ""
"如果 *buffer_callback* 不是 "
"None，則可以使用緩衝區視圖呼叫任意次數。如果回呼回傳一個假值（例如 None），"
"則給定的緩衝區是 :ref:`out-of-band <pickle-oob>`；否則緩衝區在帶內序列化，"
"即在 pickle 流中。"

#: ../../library/pickle.rst:325
#, fuzzy
msgid ""
"It is an error if *buffer_callback* is not None and *protocol* is None or "
"smaller than 5."
msgstr "如果 *buffer_callback* 不為 None 且 *protocol* 為 None 或小於 5，則為錯誤。"

#: ../../library/pickle.rst:333
#, fuzzy
msgid ""
"Write the pickled representation of *obj* to the open file object given in "
"the constructor."
msgstr "將 *obj* 的醃製表示寫入構造函式中給定的打開文件物件。"

#: ../../library/pickle.rst:338
#, fuzzy
msgid "Do nothing by default.  This exists so a subclass can override it."
msgstr "預設什麼也不做。這是存在的，因此子類別可以覆蓋它。"

#: ../../library/pickle.rst:340
#, fuzzy
msgid ""
"If :meth:`persistent_id` returns ``None``, *obj* is pickled as usual.  Any "
"other value causes :class:`Pickler` to emit the returned value as a "
"persistent ID for *obj*.  The meaning of this persistent ID should be "
"defined by :meth:`Unpickler.persistent_load`.  Note that the value returned "
"by :meth:`persistent_id` cannot itself have a persistent ID."
msgstr ""
"如果 :meth:`persistent_id` 回傳 ``None``，*obj* 將照常醃製。"
"任何其他值都會導致 Pickler 發出回傳值作為 *obj* 的持久 ID。這個持久化 ID "
"的含義應該由 Unpickler.persistent_load 定義。請注意 :meth:`persistent_id` "
"回傳的值本身不能具有持久 ID。"

#: ../../library/pickle.rst:346 ../../library/pickle.rst:447
msgid "See :ref:`pickle-persistent` for details and examples of uses."
msgstr "關於細節與用法範例請見 :ref:`pickle-persistent`\\ 。"

#: ../../library/pickle.rst:350
#, fuzzy
msgid ""
"A pickler object's dispatch table is a registry of *reduction functions* of "
"the kind which can be declared using :func:`copyreg.pickle`.  It is a "
"mapping whose keys are classes and whose values are reduction functions.  A "
"reduction function takes a single argument of the associated class and "
"should conform to the same interface as a :meth:`__reduce__` method."
msgstr ""
"一個 pickler 物件的調度表是一個可以使用 :func:`copyreg.pickle` 聲明的型別的 *"
"reduction functions* 的註冊表。它是一個映射，其鍵是類，其值是縮減函式。縮減函"
"式採用關聯類的單個參數，並且應符合與 :meth:`__reduce__` 方法相同的介面。"

#: ../../library/pickle.rst:358
#, fuzzy
msgid ""
"By default, a pickler object will not have a :attr:`dispatch_table` "
"attribute, and it will instead use the global dispatch table managed by the :"
"mod:`copyreg` module. However, to customize the pickling for a specific "
"pickler object one can set the :attr:`dispatch_table` attribute to a dict-"
"like object.  Alternatively, if a subclass of :class:`Pickler` has a :attr:"
"`dispatch_table` attribute then this will be used as the default dispatch "
"table for instances of that class."
msgstr ""
"預設情況下，pickler 對像不會有 :attr:`dispatch_table` 屬性，而是使用 "
":mod:`copyreg` 模組管理的全局調度表。但是，要為特定的 pickler 物件自定義 "
"pickling，可以將 :attr:`dispatch_table` 屬性設定為類似 dict 的物件。或者，"
"如果 Pickler 的子類別具有 dispatch_table "
"屬性，那麼它將用作該類實例的預設調度表。"

#: ../../library/pickle.rst:367
msgid "See :ref:`pickle-dispatch` for usage examples."
msgstr "關於用法範例請見 :ref:`pickle-dispatch`\\ 。"

#: ../../library/pickle.rst:373
#, fuzzy
msgid ""
"Special reducer that can be defined in :class:`Pickler` subclasses. This "
"method has priority over any reducer in the :attr:`dispatch_table`.  It "
"should conform to the same interface as a :meth:`__reduce__` method, and can "
"optionally return ``NotImplemented`` to fallback on :attr:`dispatch_table`-"
"registered reducers to pickle ``obj``."
msgstr ""
"可以在 Pickler 子類別中定義的特殊減速器。此方法優先於 dispatch_table "
"中的任何 reducer。它應該符合與 :meth:`__reduce__` 方法相同的介面，"
"並且可以選擇回傳 ``NotImplemented`` 以回退到 :attr:`dispatch_table` "
"註冊的縮減器來 pickle ``obj``。"

#: ../../library/pickle.rst:379
#, fuzzy
msgid "For a detailed example, see :ref:`reducer_override`."
msgstr "有關詳細示例，請參閱 :ref:`reducer_override`。"

#: ../../library/pickle.rst:385
#, fuzzy
msgid ""
"Deprecated. Enable fast mode if set to a true value.  The fast mode disables "
"the usage of memo, therefore speeding the pickling process by not generating "
"superfluous PUT opcodes.  It should not be used with self-referential "
"objects, doing otherwise will cause :class:`Pickler` to recurse infinitely."
msgstr ""
"已棄用。如果設定為真值，則啟用快速模式。快速模式禁用備忘錄的使用，"
"因此通過不生成多餘的 PUT 操作碼來加速酸洗過程。它不應該與自引用對像一起使用，"
"否則會導致 :class:`Pickler` 無限遞迴。"

#: ../../library/pickle.rst:391
#, fuzzy
msgid "Use :func:`pickletools.optimize` if you need more compact pickles."
msgstr "如果您需要更緊湊的泡菜，請使用 pickletools.optimize。"

#: ../../library/pickle.rst:396
#, fuzzy
msgid "This takes a binary file for reading a pickle data stream."
msgstr "這需要一個二進位文件來讀取 pickle 資料流。"

#: ../../library/pickle.rst:398
#, fuzzy
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed."
msgstr "pickle 的協定版本是自動檢測的，因此不需要協定參數。"

#: ../../library/pickle.rst:401
#, fuzzy
msgid ""
"The argument *file* must have three methods, a read() method that takes an "
"integer argument, a readinto() method that takes a buffer argument and a "
"readline() method that requires no arguments, as in the :class:`io."
"BufferedIOBase` interface.  Thus *file* can be an on-disk file opened for "
"binary reading, an :class:`io.BytesIO` object, or any other custom object "
"that meets this interface."
msgstr ""
"參數 *file* 必須具有三個方法，一個採用整數參數的 read() 方法，"
"一個採用緩衝區參數的 readinto() 方法和一個不需要參數的 readline() 方法，如 "
":class:`io .BufferedIOBase` 介面。因此 *file* "
"可以是為二進位讀取而打開的磁盤文件、:class:`io.BytesIO` "
"對像或滿足此介面的任何其他自定義物件。"

#: ../../library/pickle.rst:408
#, fuzzy
msgid ""
"The optional arguments *fix_imports*, *encoding* and *errors* are used to "
"control compatibility support for pickle stream generated by Python 2. If "
"*fix_imports* is true, pickle will try to map the old Python 2 names to the "
"new names used in Python 3.  The *encoding* and *errors* tell pickle how to "
"decode 8-bit string instances pickled by Python 2; these default to 'ASCII' "
"and 'strict', respectively.  The *encoding* can be 'bytes' to read these 8-"
"bit string instances as bytes objects. Using ``encoding='latin1'`` is "
"required for unpickling NumPy arrays and instances of :class:`~datetime."
"datetime`, :class:`~datetime.date` and :class:`~datetime.time` pickled by "
"Python 2."
msgstr ""
"可選參數 *fix_imports*、*encoding* 和 *errors* 用於控制對 Python 2 生成的 "
"pickle 流的相容性支援。如果 *fix_imports* 為真，pickle 將嘗試將舊的 Python 2 "
"名稱映射到使用的新名稱在 Python 3 中。 *encoding* 和 *errors* 告訴 pickle "
"如何解碼由 Python 2 醃製的 8 位字串實例；它們分別預設為 ``ASCII``和“嚴格”。 "
"*encoding* 可以是 'bytes' 以將這些 8 位字串實例讀取為位元組物件。使用 "
"``encoding='latin1'`` 需要使用 unpickling NumPy 數組和 :class:`~datetime."
"datetime`, :class:`~datetime.date` 和 :class:`~datetime.time` 的實例蟒蛇2。"

#: ../../library/pickle.rst:419
#, fuzzy
msgid ""
"If *buffers* is None (the default), then all data necessary for "
"deserialization must be contained in the pickle stream.  This means that the "
"*buffer_callback* argument was None when a :class:`Pickler` was instantiated "
"(or when :func:`dump` or :func:`dumps` was called)."
msgstr ""
"如果 *buffers* 為 None（預設值），則反序列化所需的所有資料都必須包含在 "
"pickle 流中。這意味著 *buffer_callback* 參數在實例化 Pickler 時為 None（"
"或呼叫 dump 或 dumps 時）。"

#: ../../library/pickle.rst:424
#, fuzzy
msgid ""
"If *buffers* is not None, it should be an iterable of buffer-enabled objects "
"that is consumed each time the pickle stream references an :ref:`out-of-band "
"<pickle-oob>` buffer view.  Such buffers have been given in order to the "
"*buffer_callback* of a Pickler object."
msgstr ""
"如果 *buffers* 不是 None，它應該是啟用緩衝區的物件的可疊代物件，每次 pickle "
"流引用 :ref:`out-of-band <pickle-oob>` 緩衝區視圖時都會被消耗。"
"這樣的緩衝區是為了 Pickler 物件的 *buffer_callback* 而提供的。"

#: ../../library/pickle.rst:434
#, fuzzy
msgid ""
"Read the pickled representation of an object from the open file object given "
"in the constructor, and return the reconstituted object hierarchy specified "
"therein.  Bytes past the pickled representation of the object are ignored."
msgstr ""
"從構造函式中給定的打開文件對像中讀取物件的 pickled "
"表示，並回傳其中指定的重構物件層次結構。超過物件的 pickled "
"表示的位元組將被忽略。"

#: ../../library/pickle.rst:441
#, fuzzy
msgid "Raise an :exc:`UnpicklingError` by default."
msgstr "預設情況下引發 :exc:`UnpicklingError`。"

#: ../../library/pickle.rst:443
#, fuzzy
msgid ""
"If defined, :meth:`persistent_load` should return the object specified by "
"the persistent ID *pid*.  If an invalid persistent ID is encountered, an :"
"exc:`UnpicklingError` should be raised."
msgstr ""
"如果已定義，:meth:`persistent_load` 應該回傳由持久 ID *pid* 指定的物件。"
"如果遇到無效的持久 ID，則應引發 :exc:`UnpicklingError`。"

#: ../../library/pickle.rst:451
#, fuzzy
msgid ""
"Import *module* if necessary and return the object called *name* from it, "
"where the *module* and *name* arguments are :class:`str` objects.  Note, "
"unlike its name suggests, :meth:`find_class` is also used for finding "
"functions."
msgstr ""
"如有必要，導入 *module* 並從中回傳名為 *name* 的物件，其中 *module* 和 *name*"
" 參數是 :class:`str` 物件。請注意，與其名稱所暗示的不同，:meth:`find_class` "
"也用於查找函式。"

#: ../../library/pickle.rst:456
#, fuzzy
msgid ""
"Subclasses may override this to gain control over what type of objects and "
"how they can be loaded, potentially reducing security risks. Refer to :ref:"
"`pickle-restrict` for details."
msgstr "子類別可以重寫它以控制物件的型別以及加載它們的方式，從而潛在地降低安全風險。"
"有關詳細資訊，請參閱 :ref:`pickle-restrict`。"

#: ../../library/pickle.rst:460
msgid ""
"Raises an :ref:`auditing event <auditing>` ``pickle.find_class`` with "
"arguments ``module``, ``name``."
msgstr ""
"引發一個附帶引數 ``module``、``name`` 的\\ :ref:`稽核事件 <auditing>` ``pickle.find_class``。"

#: ../../library/pickle.rst:464
#, fuzzy
msgid ""
"A wrapper for a buffer representing picklable data.  *buffer* must be a :ref:"
"`buffer-providing <bufferobjects>` object, such as a :term:`bytes-like "
"object` or a N-dimensional array."
msgstr ""
"表示可醃製資料的緩衝區的包裝器。 *buffer* 必須是 :ref:`提供緩衝區的 "
"<bufferobjects>` 物件，例如 :term:`bytes-like object` 或 N 維數組。"

#: ../../library/pickle.rst:468
#, fuzzy
msgid ""
":class:`PickleBuffer` is itself a buffer provider, therefore it is possible "
"to pass it to other APIs expecting a buffer-providing object, such as :class:"
"`memoryview`."
msgstr ""
":class:`PickleBuffer` 本身就是一個緩衝區提供者，"
"因此可以將它傳遞給其他需要緩衝區提供物件的 API，例如 :class:`memoryview`。"

#: ../../library/pickle.rst:472
#, fuzzy
msgid ""
":class:`PickleBuffer` objects can only be serialized using pickle protocol 5 "
"or higher.  They are eligible for :ref:`out-of-band serialization <pickle-"
"oob>`."
msgstr ""
":class:`PickleBuffer` 對像只能使用 pickle 協定 5 或更高版本進行序列化。"
"它們有資格進行 :ref:`帶外序列化 <pickle-oob>`。"

#: ../../library/pickle.rst:480
#, fuzzy
msgid ""
"Return a :class:`memoryview` of the memory area underlying this buffer. The "
"returned object is a one-dimensional, C-contiguous memoryview with format "
"``B`` (unsigned bytes).  :exc:`BufferError` is raised if the buffer is "
"neither C- nor Fortran-contiguous."
msgstr ""
"回傳此緩衝區下面的記憶體區域的 :class:`memoryview`。回傳的對像是一個一維的 C "
"連續記憶體視圖，格式為 ``B``（無符號位元組）。 :exc:`BufferError` "
"如果緩衝區既不是 C- 也不是 Fortran-連續的，則會引發。"

#: ../../library/pickle.rst:487
#, fuzzy
msgid "Release the underlying buffer exposed by the PickleBuffer object."
msgstr "釋放 PickleBuffer 物件公開的底層緩衝區。"

#: ../../library/pickle.rst:493
#, fuzzy
msgid "What can be pickled and unpickled?"
msgstr "什麼可以醃製和不醃製？"

#: ../../library/pickle.rst:495
#, fuzzy
msgid "The following types can be pickled:"
msgstr "可以醃製以下型別："

#: ../../library/pickle.rst:497
msgid "``None``, ``True``, and ``False``;"
msgstr "``None``\\ 、\\ ``True`` 和 ``False``\\ ；"

#: ../../library/pickle.rst:499
#, fuzzy
msgid "integers, floating-point numbers, complex numbers;"
msgstr "整數、浮點數、複數；"

#: ../../library/pickle.rst:501
#, fuzzy
msgid "strings, bytes, bytearrays;"
msgstr "字串、位元組、位元組數組；"

#: ../../library/pickle.rst:503
#, fuzzy
msgid ""
"tuples, lists, sets, and dictionaries containing only picklable objects;"
msgstr "僅包含可醃製物件的元組、列表、集合和字典；"

#: ../../library/pickle.rst:505
#, fuzzy
msgid ""
"functions (built-in and user-defined) accessible from the top level of a "
"module (using :keyword:`def`, not :keyword:`lambda`);"
msgstr "可從模組頂層訪問的函式（內建和使用者定義）（使用 :keyword:`def`，而不是：keyw"
"ord:`lambda`）；"

#: ../../library/pickle.rst:508
#, fuzzy
msgid "classes accessible from the top level of a module;"
msgstr "可從模組頂層訪問的類；"

#: ../../library/pickle.rst:510
#, fuzzy
msgid ""
"instances of such classes whose the result of calling :meth:`__getstate__` "
"is picklable  (see section :ref:`pickle-inst` for details)."
msgstr ""
"這些類的實例，其呼叫 :meth:`__getstate__` 的結果是可醃製的（有關詳細資訊，"
"請參閱 :ref:`pickle-inst` 部分）。"

#: ../../library/pickle.rst:513
#, fuzzy
msgid ""
"Attempts to pickle unpicklable objects will raise the :exc:`PicklingError` "
"exception; when this happens, an unspecified number of bytes may have "
"already been written to the underlying file.  Trying to pickle a highly "
"recursive data structure may exceed the maximum recursion depth, a :exc:"
"`RecursionError` will be raised in this case.  You can carefully raise this "
"limit with :func:`sys.setrecursionlimit`."
msgstr ""
"嘗試醃製不可醃製的物件將引發 :exc:`PicklingError` "
"例外；發生這種情況時，可能已經將未指定數量的位元組寫入基礎文件。嘗試 pickle "
"高度遞迴的資料結構可能會超過最大遞迴深度，在這種情況下將引發 RecursionError。"
"您可以使用 :func:`sys.setrecursionlimit` 小心地提高這個限制。"

#: ../../library/pickle.rst:520
#, fuzzy
msgid ""
"Note that functions (built-in and user-defined) are pickled by fully :term:"
"`qualified name`, not by value. [#]_  This means that only the function name "
"is pickled, along with the name of the containing module and classes.  "
"Neither the function's code, nor any of its function attributes are "
"pickled.  Thus the defining module must be importable in the unpickling "
"environment, and the module must contain the named object, otherwise an "
"exception will be raised. [#]_"
msgstr ""
"請注意，函式（內建和使用者定義的）是通過完全限定名稱而不是值來醃製的。 [#]_ "
"這意味著只有函式名以及包含的模組和類的名稱被 pickle。"
"函式的程式碼及其任何函式屬性都不會被 pickle。因此，定義模組在 unpickling "
"環境中必須是可導入的，並且模組必須包含命名物件，否則將引發例外。 [#]_"

#: ../../library/pickle.rst:527
#, fuzzy
msgid ""
"Similarly, classes are pickled by fully qualified name, so the same "
"restrictions in the unpickling environment apply.  Note that none of the "
"class's code or data is pickled, so in the following example the class "
"attribute ``attr`` is not restored in the unpickling environment::"
msgstr ""
"類似地，類通過完全限定名稱進行 pickle，因此 unpickling "
"環境中的相同限制適用。請注意，類的程式碼或資料都沒有被 "
"pickle，因此在下面的示例中，類屬性 ``attr`` 不會在 unpickling 環境中恢復："

#: ../../library/pickle.rst:537
#, fuzzy
msgid ""
"These restrictions are why picklable functions and classes must be defined "
"at the top level of a module."
msgstr "這些限制是為什麼 picklable 函式和類必須在模組的頂層定義的原因。"

#: ../../library/pickle.rst:540
#, fuzzy
msgid ""
"Similarly, when class instances are pickled, their class's code and data are "
"not pickled along with them.  Only the instance data are pickled.  This is "
"done on purpose, so you can fix bugs in a class or add methods to the class "
"and still load objects that were created with an earlier version of the "
"class.  If you plan to have long-lived objects that will see many versions "
"of a class, it may be worthwhile to put a version number in the objects so "
"that suitable conversions can be made by the class's :meth:`__setstate__` "
"method."
msgstr ""
"類似地，當類實例被 pickle 時，它們的類的程式碼和資料不會與它們一起被 pickle。"
"只有實例資料被醃製。這是有意為之的，因此您可以修復類中的錯誤或向類中新增方法"
"，並且仍然加載使用該類的早期版本建立的物件。如果您計劃擁有長期存在的物件，這"
"些物件將看到一個類的多個版本，那麼在對像中放置一個版本號可能是值得的，"
"以便可以通過該類的 :meth:`__setstate__` 方法進行適當的轉換。"

#: ../../library/pickle.rst:552
#, fuzzy
msgid "Pickling Class Instances"
msgstr "酸洗類實例"

#: ../../library/pickle.rst:556
#, fuzzy
msgid ""
"In this section, we describe the general mechanisms available to you to "
"define, customize, and control how class instances are pickled and unpickled."
msgstr "在本節中，我們將描述可用於定義、自定義和控制類實例如何 pickle 和 unpickle "
"的一般機制。"

#: ../../library/pickle.rst:559
#, fuzzy
msgid ""
"In most cases, no additional code is needed to make instances picklable.  By "
"default, pickle will retrieve the class and the attributes of an instance "
"via introspection. When a class instance is unpickled, its :meth:`__init__` "
"method is usually *not* invoked.  The default behaviour first creates an "
"uninitialized instance and then restores the saved attributes.  The "
"following code shows an implementation of this behaviour::"
msgstr ""
"在大多數情況下，不需要額外的程式碼來使實例可挑選。預設情況下，pickle "
"將通過內省檢索實例的類和屬性。當一個類實例被 unpickled 時，它的 "
":meth:`__init__` 方法通常*不會*被呼叫。預設行為首先建立一個未初始化的實例，然"
"後恢復保存的屬性。以下程式碼顯示了此行為的實作："

#: ../../library/pickle.rst:574
#, fuzzy
msgid ""
"Classes can alter the default behaviour by providing one or several special "
"methods:"
msgstr "類可以通過提供一種或多種特殊方法來改變預設行為："

#: ../../library/pickle.rst:579
#, fuzzy
msgid ""
"In protocols 2 and newer, classes that implements the :meth:"
"`__getnewargs_ex__` method can dictate the values passed to the :meth:"
"`__new__` method upon unpickling.  The method must return a pair ``(args, "
"kwargs)`` where *args* is a tuple of positional arguments and *kwargs* a "
"dictionary of named arguments for constructing the object.  Those will be "
"passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"在協定 2 和更新版本中，實作 :meth:`__getnewargs_ex__` 方法的類可以指定在 "
"unpickling 時傳遞給 :meth:`__new__` 方法的值。該方法必須回傳一對“(args, "
"kwargs)”，其中 *args* 是位置參數的元組，*kwargs* "
"是用於構造物件的命名參數的字典。這些將在 unpickling 時傳遞給 :meth:`__new__` "
"方法。"

#: ../../library/pickle.rst:587
#, fuzzy
msgid ""
"You should implement this method if the :meth:`__new__` method of your class "
"requires keyword-only arguments.  Otherwise, it is recommended for "
"compatibility to implement :meth:`__getnewargs__`."
msgstr ""
"如果你的類的 :meth:`__new__` 方法只需要關鍵字參數，你應該實作這個方法。否則，"
"建議實作相容性 :meth:`__getnewargs__`。"

#: ../../library/pickle.rst:591
#, fuzzy
msgid ":meth:`__getnewargs_ex__` is now used in protocols 2 and 3."
msgstr ":meth:`__getnewargs_ex__` 現在用於協定 2 和 3。"

#: ../../library/pickle.rst:597
#, fuzzy
msgid ""
"This method serves a similar purpose as :meth:`__getnewargs_ex__`, but "
"supports only positional arguments.  It must return a tuple of arguments "
"``args`` which will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"此方法的用途與 :meth:`__getnewargs_ex__` 類似，但僅支援位置參數。"
"它必須回傳一個參數元組 ``args``，它將在 unpickling 時傳遞給 :meth:`__new__` "
"方法。"

#: ../../library/pickle.rst:601
#, fuzzy
msgid ""
":meth:`__getnewargs__` will not be called if :meth:`__getnewargs_ex__` is "
"defined."
msgstr ":meth:`__getnewargs__` 如果定義了 :method:`__getnewargs__` 將不會被呼叫。"

#: ../../library/pickle.rst:604
#, fuzzy
msgid ""
"Before Python 3.6, :meth:`__getnewargs__` was called instead of :meth:"
"`__getnewargs_ex__` in protocols 2 and 3."
msgstr ""
"在 Python 3.6 之前，在協定 2 和 3 中呼叫 :meth:`__getnewargs__` 而不是 "
":meth:`__getnewargs_ex__` 。"

#: ../../library/pickle.rst:611
#, fuzzy
msgid ""
"Classes can further influence how their instances are pickled by overriding "
"the method :meth:`__getstate__`.  It is called and the returned object is "
"pickled as the contents for the instance, instead of a default state. There "
"are several cases:"
msgstr ""
"類可以通過覆蓋方法 :meth:`__getstate__` 進一步影響它們的實例如何被醃製。它被"
"呼叫並且回傳的對像被醃製為實例的內容，而不是預設狀態。有幾種情況："

#: ../../library/pickle.rst:616
#, fuzzy
msgid ""
"For a class that has no instance :attr:`~object.__dict__` and no :attr:"
"`~object.__slots__`, the default state is ``None``."
msgstr ""
"對於沒有實例 :attr:`~object.__dict__` 和 :attr:`~object.__slots__` 的類，"
"預設狀態為 ``None``。"

#: ../../library/pickle.rst:619
#, fuzzy
msgid ""
"For a class that has an instance :attr:`~object.__dict__` and no :attr:"
"`~object.__slots__`, the default state is ``self.__dict__``."
msgstr ""
"對於具有實例 :attr:`~object.__dict__` 而沒有 :attr:`~object.__slots__` 的類，"
"預設狀態為 ``self.__dict__``。"

#: ../../library/pickle.rst:622
#, fuzzy
msgid ""
"For a class that has an instance :attr:`~object.__dict__` and :attr:`~object."
"__slots__`, the default state is a tuple consisting of two dictionaries:  "
"``self.__dict__``, and a dictionary mapping slot names to slot values.  Only "
"slots that have a value are included in the latter."
msgstr ""
"對於具有實例 :attr:`~object.__dict__` 和 :attr:`~object.__slots__` "
"的類，預設狀態是由兩個字典組成的元組：``self.__dict__`` "
"和一個字典映射插槽名稱到插槽值。後者僅包含具有值的插槽。"

#: ../../library/pickle.rst:628
#, fuzzy
msgid ""
"For a class that has :attr:`~object.__slots__` and no instance :attr:"
"`~object.__dict__`, the default state is a tuple whose first item is "
"``None`` and whose second item is a dictionary mapping slot names to slot "
"values described in the previous bullet."
msgstr ""
"對於具有 :attr:`~object.__slots__` 且沒有實例 :attr:`~object.__dict__` "
"的類，預設狀態是一個元組，其第一項為 "
"``None``，第二項為字典映射插槽名稱到上一個項目符號中描述的插槽值。"

#: ../../library/pickle.rst:633
#, fuzzy
msgid ""
"Added the default implementation of the ``__getstate__()`` method in the :"
"class:`object` class."
msgstr "在 :class:`object` 類中新增了 ``__getstate__()`` 方法的預設實作。"

#: ../../library/pickle.rst:640
#, fuzzy
msgid ""
"Upon unpickling, if the class defines :meth:`__setstate__`, it is called "
"with the unpickled state.  In that case, there is no requirement for the "
"state object to be a dictionary.  Otherwise, the pickled state must be a "
"dictionary and its items are assigned to the new instance's dictionary."
msgstr ""
"在 unpickling 時，如果該類定義了 :meth:`__setstate__` ，它會在 unpickled 狀態"
"下被呼叫。在那種情況下，狀態對像不需要是字典。否則，醃製狀態必須是一個字典，"
"並且它的項目被分配給新實例的字典。"

#: ../../library/pickle.rst:647
#, fuzzy
msgid ""
"If :meth:`__getstate__` returns a false value, the :meth:`__setstate__` "
"method will not be called upon unpickling."
msgstr ""
"如果 :meth:`__getstate__` 回傳 false 值，則 :meth:`__setstate__` 方法不會在 "
"unpickling 時被呼叫。"

#: ../../library/pickle.rst:651
#, fuzzy
msgid ""
"Refer to the section :ref:`pickle-state` for more information about how to "
"use the methods :meth:`__getstate__` and :meth:`__setstate__`."
msgstr ""
"有關如何使用方法 :meth:`__getstate__` 和 :meth:`__setstate__` 的更多資訊，"
"請參閱 :ref:`pickle-state` 部分。"

#: ../../library/pickle.rst:656
#, fuzzy
msgid ""
"At unpickling time, some methods like :meth:`__getattr__`, :meth:"
"`__getattribute__`, or :meth:`__setattr__` may be called upon the instance.  "
"In case those methods rely on some internal invariant being true, the type "
"should implement :meth:`__new__` to establish such an invariant, as :meth:"
"`__init__` is not called when unpickling an instance."
msgstr ""
"在 unpickling 時，可能會在實例上呼叫一些方法，如 "
":meth:`__getattr__`、:meth:`__getattribute__` 或 "
":meth:`__setattr__`。如果這些方法依賴於某些內部不變數為真，則該型別應實作 "
":meth:`__new__` 以建立這樣的不變數，因為 :meth:`__init__` "
"在取消實例時不會被呼叫。"

#: ../../library/pickle.rst:665
#, fuzzy
msgid ""
"As we shall see, pickle does not use directly the methods described above.  "
"In fact, these methods are part of the copy protocol which implements the :"
"meth:`__reduce__` special method.  The copy protocol provides a unified "
"interface for retrieving the data necessary for pickling and copying "
"objects. [#]_"
msgstr ""
"正如我們將看到的，pickle 不直接使用上述方法。事實上，這些方法是實作 "
":meth:`__reduce__` 特殊方法的複制協定的一部分。複製協定提供了一個統一的介面，"
"用於檢索 pickle 和復制物件所需的資料。 [#]_"

#: ../../library/pickle.rst:671
#, fuzzy
msgid ""
"Although powerful, implementing :meth:`__reduce__` directly in your classes "
"is error prone.  For this reason, class designers should use the high-level "
"interface (i.e., :meth:`__getnewargs_ex__`, :meth:`__getstate__` and :meth:"
"`__setstate__`) whenever possible.  We will show, however, cases where "
"using :meth:`__reduce__` is the only option or leads to more efficient "
"pickling or both."
msgstr ""
"儘管功能強大，但直接在您的類中實施 :meth:`__reduce__` 很容易出錯。出於這個原"
"因，類設計者應該盡可能使用高階介面（即 :meth:`__getnewargs_ex__`、:meth:`__ge"
"tstate__` 和 :meth:`__setstate__`）。然而，我們將展示使用 :meth:`__reduce__` "
"是唯一選擇或導致更有效酸洗或兩者兼而有之的情況。"

#: ../../library/pickle.rst:680
#, fuzzy
msgid ""
"The interface is currently defined as follows.  The :meth:`__reduce__` "
"method takes no argument and shall return either a string or preferably a "
"tuple (the returned object is often referred to as the \"reduce value\")."
msgstr "該介面目前定義如下。 :meth:`__reduce__` 方法不帶任何參數，應回傳一個字串或最"
"好是一個元組（回傳的物件通常稱為“減少值”）。"

#: ../../library/pickle.rst:684
#, fuzzy
msgid ""
"If a string is returned, the string should be interpreted as the name of a "
"global variable.  It should be the object's local name relative to its "
"module; the pickle module searches the module namespace to determine the "
"object's module.  This behaviour is typically useful for singletons."
msgstr ""
"如果回傳字串，則該字串應被解釋為全局變數的名稱。它應該是物件相對於其模組的本"
"地名稱； pickle 模組搜索模組名稱空間以確定物件的模組。此行為通常對單例有用。"

#: ../../library/pickle.rst:689
#, fuzzy
msgid ""
"When a tuple is returned, it must be between two and six items long. "
"Optional items can either be omitted, or ``None`` can be provided as their "
"value.  The semantics of each item are in order:"
msgstr "回傳元組時，它的長度必須在兩到六個項目之間。可以省略可選項目，或者可以提供“無"
"”作為它們的值。每個項目的語義是有序的："

#: ../../library/pickle.rst:695
#, fuzzy
msgid ""
"A callable object that will be called to create the initial version of the "
"object."
msgstr "將呼叫以建立物件的初始版本的可呼叫物件。"

#: ../../library/pickle.rst:698
#, fuzzy
msgid ""
"A tuple of arguments for the callable object.  An empty tuple must be given "
"if the callable does not accept any argument."
msgstr "可呼叫物件的參數元組。如果可呼叫對像不接受任何參數，則必須給出一個空元組。"

#: ../../library/pickle.rst:701
#, fuzzy
msgid ""
"Optionally, the object's state, which will be passed to the object's :meth:"
"`__setstate__` method as previously described.  If the object has no such "
"method then, the value must be a dictionary and it will be added to the "
"object's :attr:`~object.__dict__` attribute."
msgstr ""
"可選地，物件的狀態，它將被傳遞給物件的 __setstate__ "
"方法，如前所述。如果對像沒有這樣的方法，則該值必須是一個字典，"
"它將被新增到物件的 :attr:`~object.__dict__` 屬性中。"

#: ../../library/pickle.rst:706
#, fuzzy
msgid ""
"Optionally, an iterator (and not a sequence) yielding successive items. "
"These items will be appended to the object either using ``obj.append(item)`` "
"or, in batch, using ``obj.extend(list_of_items)``. This is primarily used "
"for list subclasses, but may be used by other classes as long as they have :"
"meth:`append` and :meth:`extend` methods with the appropriate signature.  "
"(Whether :meth:`append` or :meth:`extend` is used depends on which pickle "
"protocol version is used as well as the number of items to append, so both "
"must be supported.)"
msgstr ""
"可選地，疊代器（而不是序列）產生連續的項目。這些項目將使用 ``obj."
"append(item)`` 或批量使用 ``obj.extend(list_of_items)`` "
"附加到物件。這主要用於列表子類別，但也可以被其他類使用，"
"只要它們具有帶有適當簽名的 :meth:`append` 和 :meth:`extend` 方法。 （"
"是否使用 :meth:`append` 或 :meth:`extend` 取決於使用的 pickle "
"協定版本以及要追加的項目數，因此兩者都必須被支援。）"

#: ../../library/pickle.rst:715
#, fuzzy
msgid ""
"Optionally, an iterator (not a sequence) yielding successive key-value "
"pairs.  These items will be stored to the object using ``obj[key] = "
"value``.  This is primarily used for dictionary subclasses, but may be used "
"by other classes as long as they implement :meth:`__setitem__`."
msgstr ""
"可選地，疊代器（不是序列）產生連續的鍵值對。這些項目將使用 ``obj[key] = "
"value`` 儲存到對像中。這主要用於字典子類別，但也可以被其他類使用，"
"只要它們實作 :meth:`__setitem__`。"

#: ../../library/pickle.rst:720
#, fuzzy
msgid ""
"Optionally, a callable with a ``(obj, state)`` signature. This callable "
"allows the user to programmatically control the state-updating behavior of a "
"specific object, instead of using ``obj``'s static :meth:`__setstate__` "
"method. If not ``None``, this callable will have priority over ``obj``'s :"
"meth:`__setstate__`."
msgstr ""
"可選地，一個帶有 ``(obj, state)`` "
"簽名的可呼叫物件。此可呼叫允許使用者以編程方式控制特定物件的狀態更新行為，"
"而不是使用 ``obj`` 的靜態 :meth:`__setstate__` 方法。如果不是 ``None``，"
"這個可呼叫物件將優先於 ``obj`` 的 :meth:`__setstate__`。"

#: ../../library/pickle.rst:726
#, fuzzy
msgid "The optional sixth tuple item, ``(obj, state)``, was added."
msgstr "新增了可選的第六元組項``(obj, state)``。"

#: ../../library/pickle.rst:732
#, fuzzy
msgid ""
"Alternatively, a :meth:`__reduce_ex__` method may be defined.  The only "
"difference is this method should take a single integer argument, the "
"protocol version.  When defined, pickle will prefer it over the :meth:"
"`__reduce__` method.  In addition, :meth:`__reduce__` automatically becomes "
"a synonym for the extended version.  The main use for this method is to "
"provide backwards-compatible reduce values for older Python releases."
msgstr ""
"或者，可以定義 :meth:`__reduce_ex__` "
"方法。唯一的區別是此方法應採用單個整數參數，即協定版本。定義後，pickle "
"將優先於 :meth:`__reduce__` 方法。此外，:meth:`__reduce__` "
"自動成為擴充版本的同義詞。此方法的主要用途是為較舊的 Python "
"版本提供向後相容的減少值。"

#: ../../library/pickle.rst:744
#, fuzzy
msgid "Persistence of External Objects"
msgstr "外部物件的持久化"

#: ../../library/pickle.rst:750
#, fuzzy
msgid ""
"For the benefit of object persistence, the :mod:`pickle` module supports the "
"notion of a reference to an object outside the pickled data stream.  Such "
"objects are referenced by a persistent ID, which should be either a string "
"of alphanumeric characters (for protocol 0) [#]_ or just an arbitrary object "
"(for any newer protocol)."
msgstr ""
"為了物件持久化的好處，:mod:`pickle` 模組支援引用 pickle "
"資料流之外的物件的概念。此類物件由持久 ID 引用，該 ID "
"應該是一串字母數字字元（對於協定 0）[#]_ "
"或只是一個任意物件（對於任何較新的協定）。"

#: ../../library/pickle.rst:756
#, fuzzy
msgid ""
"The resolution of such persistent IDs is not defined by the :mod:`pickle` "
"module; it will delegate this resolution to the user-defined methods on the "
"pickler and unpickler, :meth:`~Pickler.persistent_id` and :meth:`~Unpickler."
"persistent_load` respectively."
msgstr ""
":mod:`pickle` 模組未定義此類持久 ID 的解析；它將此解決方案委託給 pickler 和 "
"unpickler 上的使用者定義方法，分別為 :meth:`~Pickler.persistent_id` 和 "
":meth:`~Unpickler.persistent_load`。"

#: ../../library/pickle.rst:761
#, fuzzy
msgid ""
"To pickle objects that have an external persistent ID, the pickler must have "
"a custom :meth:`~Pickler.persistent_id` method that takes an object as an "
"argument and returns either ``None`` or the persistent ID for that object. "
"When ``None`` is returned, the pickler simply pickles the object as normal. "
"When a persistent ID string is returned, the pickler will pickle that "
"object, along with a marker so that the unpickler will recognize it as a "
"persistent ID."
msgstr ""
"要 pickle 具有外部持久 ID 的物件，pickler 必須有一個自定義的 :meth:`~Pickler."
"persistent_id` 方法，該方法將對像作為參數並回傳 ``None``或該物件的持久 "
"ID。當回傳 ``None``時，pickler 只是像往常一樣簡單地 pickle 物件。當回傳持久 ID "
"字串時，pickler 將 pickle 該對像以及一個標記，以便 unpickler 將其識別為持久 "
"ID。"

#: ../../library/pickle.rst:768
#, fuzzy
msgid ""
"To unpickle external objects, the unpickler must have a custom :meth:"
"`~Unpickler.persistent_load` method that takes a persistent ID object and "
"returns the referenced object."
msgstr ""
"要 unpickle 外部物件，unpickler 必須有一個自定義的 :meth:`~Unpickler."
"persistent_load` 方法，該方法採用持久 ID 物件並回傳引用的物件。"

#: ../../library/pickle.rst:772
#, fuzzy
msgid ""
"Here is a comprehensive example presenting how persistent ID can be used to "
"pickle external objects by reference."
msgstr "這是一個綜合示例，展示瞭如何使用持久 ID 通過引用來醃製外部物件。"

#: ../../library/pickle.rst:780
#, fuzzy
msgid "Dispatch Tables"
msgstr "調度表"

#: ../../library/pickle.rst:782
#, fuzzy
msgid ""
"If one wants to customize pickling of some classes without disturbing any "
"other code which depends on pickling, then one can create a pickler with a "
"private dispatch table."
msgstr "如果想自定義某些類的酸洗而不干擾任何其他依賴酸洗的程式碼，那麼可以建立一個帶"
"有私有調度表的酸洗器。"

#: ../../library/pickle.rst:786
#, fuzzy
msgid ""
"The global dispatch table managed by the :mod:`copyreg` module is available "
"as :data:`copyreg.dispatch_table`.  Therefore, one may choose to use a "
"modified copy of :data:`copyreg.dispatch_table` as a private dispatch table."
msgstr ""
"由 :mod:`copyreg` 模組管理的全局調度表可用作 :data:`copyreg."
"dispatch_table`。因此，可以選擇使用 :data:`copyreg.dispatch_table` "
"的修改副本作為私有調度表。"

#: ../../library/pickle.rst:791
msgid "For example ::"
msgstr ""
"舉例來說：\n"
"\n"
"::"

#: ../../library/pickle.rst:798
#, fuzzy
msgid ""
"creates an instance of :class:`pickle.Pickler` with a private dispatch table "
"which handles the ``SomeClass`` class specially.  Alternatively, the code ::"
msgstr ""
"建立一個 :class:`pickle.Pickler` 的實例，帶有一個專門處理 ``SomeClass`` "
"類的私有調度表。或者，程式碼 ::"

#: ../../library/pickle.rst:808
#, fuzzy
msgid ""
"does the same but all instances of ``MyPickler`` will by default share the "
"private dispatch table.  On the other hand, the code ::"
msgstr "做同樣的事情，但 ``MyPickler`` 的所有實例將預設共享私有調度表。另一方面，"
"程式碼 ::"

#: ../../library/pickle.rst:815
#, fuzzy
msgid ""
"modifies the global dispatch table shared by all users of the :mod:`copyreg` "
"module."
msgstr "修改 :mod:`copyreg` 模組的所有使用者共享的全局調度表。"

#: ../../library/pickle.rst:820
#, fuzzy
msgid "Handling Stateful Objects"
msgstr "處理有狀態物件"

#: ../../library/pickle.rst:826
#, fuzzy
msgid ""
"Here's an example that shows how to modify pickling behavior for a class. "
"The :class:`TextReader` class opens a text file, and returns the line number "
"and line contents each time its :meth:`!readline` method is called. If a :"
"class:`TextReader` instance is pickled, all attributes *except* the file "
"object member are saved. When the instance is unpickled, the file is "
"reopened, and reading resumes from the last location. The :meth:"
"`__setstate__` and :meth:`__getstate__` methods are used to implement this "
"behavior. ::"
msgstr ""
"下面是一個示例，說明如何修改類的 pickling 行為。 :class:`TextReader` "
"類打開一個文本文件，並在每次呼叫其 :meth:`!readline` 方法時回傳行號和行內容。"
"如果 :class:`TextReader` 實例被醃製，所有屬性*除了*文件物件成員都會被保存。"
"當實例被 unpickled 時，文件被重新打開，並從最後一個位置恢復讀取。 "
":meth:`__setstate__` 和 :meth:`__getstate__` 方法用於實作此行為。 ::"

#: ../../library/pickle.rst:872
#, fuzzy
msgid "A sample usage might be something like this::"
msgstr "示例用法可能是這樣的::"

#: ../../library/pickle.rst:886
#, fuzzy
msgid "Custom Reduction for Types, Functions, and Other Objects"
msgstr "型別、函式和其他物件的自定義縮減"

#: ../../library/pickle.rst:890
#, fuzzy
msgid ""
"Sometimes, :attr:`~Pickler.dispatch_table` may not be flexible enough. In "
"particular we may want to customize pickling based on another criterion than "
"the object's type, or we may want to customize the pickling of functions and "
"classes."
msgstr ""
"有時，:attr:`~Pickler.dispatch_table` 可能不夠靈活。特別是，我們可能希望根據"
"對像型別以外的其他標準自定義酸洗，或者我們可能希望自定義函式和類的酸洗。"

#: ../../library/pickle.rst:895
#, fuzzy
msgid ""
"For those cases, it is possible to subclass from the :class:`Pickler` class "
"and implement a :meth:`~Pickler.reducer_override` method. This method can "
"return an arbitrary reduction tuple (see :meth:`__reduce__`). It can "
"alternatively return ``NotImplemented`` to fallback to the traditional "
"behavior."
msgstr ""
"對於這些情況，可以從 :class:`Pickler` 類繼承並實作 :meth:`~Pickler."
"reducer_override` 方法。此方法可以回傳任意歸約元組（請參閱 :meth:`__reduce__"
"`）。它也可以回傳 ``NotImplemented`` 以回退到傳統行為。"

#: ../../library/pickle.rst:900
#, fuzzy
msgid ""
"If both the :attr:`~Pickler.dispatch_table` and :meth:`~Pickler."
"reducer_override` are defined, then :meth:`~Pickler.reducer_override` method "
"takes priority."
msgstr ""
"如果 :attr:`~Pickler.dispatch_table` 和 :meth:`~Pickler.reducer_override` "
"都定義了，那麼 :meth:`~Pickler.reducer_override` 方法優先。"

#: ../../library/pickle.rst:905
#, fuzzy
msgid ""
"For performance reasons, :meth:`~Pickler.reducer_override` may not be called "
"for the following objects: ``None``, ``True``, ``False``, and exact "
"instances of :class:`int`, :class:`float`, :class:`bytes`, :class:`str`, :"
"class:`dict`, :class:`set`, :class:`frozenset`, :class:`list` and :class:"
"`tuple`."
msgstr ""
"出於性能原因，可能不會為以下物件呼叫 :meth:`~Pickler."
"reducer_override`：``None``、``True``、``False`` 以及 :class:`int` "
"的確切實例, :class:`float`, :class:`bytes`, :class:`str`, :class:`dict`, "
":class:`set`, :class:`frozenset`, :class:`list` 和 :class:`元組`。"

#: ../../library/pickle.rst:911
#, fuzzy
msgid ""
"Here is a simple example where we allow pickling and reconstructing a given "
"class::"
msgstr "這是一個簡單的例子，我們允許 pickling 和重構一個給定的類："

#: ../../library/pickle.rst:946
#, fuzzy
msgid "Out-of-band Buffers"
msgstr "帶外緩衝器"

#: ../../library/pickle.rst:950
#, fuzzy
msgid ""
"In some contexts, the :mod:`pickle` module is used to transfer massive "
"amounts of data.  Therefore, it can be important to minimize the number of "
"memory copies, to preserve performance and resource consumption.  However, "
"normal operation of the :mod:`pickle` module, as it transforms a graph-like "
"structure of objects into a sequential stream of bytes, intrinsically "
"involves copying data to and from the pickle stream."
msgstr ""
"在某些情況下，:mod:`pickle` 模組用於傳輸大量資料。因此，盡量減少記憶體副本的"
"數量以保持性能和資源消耗可能很重要。然而，:mod:`pickle` "
"模組的正常操作，因為它將物件的圖形結構轉換為順序位元組流，"
"本質上涉及將資料複製到 pickle 流和從 pickle 流複製資料。"

#: ../../library/pickle.rst:957
#, fuzzy
msgid ""
"This constraint can be eschewed if both the *provider* (the implementation "
"of the object types to be transferred) and the *consumer* (the "
"implementation of the communications system) support the out-of-band "
"transfer facilities provided by pickle protocol 5 and higher."
msgstr ""
"如果*provider*（要傳輸的對像型別的實作）和*consumer*（通信系統的實作）都支援 "
"pickle 協定 5 和提供的帶外傳輸設施，則可以避開此約束更高。"

#: ../../library/pickle.rst:963
#, fuzzy
msgid "Provider API"
msgstr "供應商介面"

#: ../../library/pickle.rst:965
#, fuzzy
msgid ""
"The large data objects to be pickled must implement a :meth:`__reduce_ex__` "
"method specialized for protocol 5 and higher, which returns a :class:"
"`PickleBuffer` instance (instead of e.g. a :class:`bytes` object) for any "
"large data."
msgstr ""
"要 pickle 的大資料物件必須實作專用於協定 5 及更高版本的 :meth:`__reduce_ex__`"
" 方法，該方法為任何大資料回傳一個 :class:`PickleBuffer` 實例（而不是例如 "
":class:`bytes` 物件）資料。"

#: ../../library/pickle.rst:970
#, fuzzy
msgid ""
"A :class:`PickleBuffer` object *signals* that the underlying buffer is "
"eligible for out-of-band data transfer.  Those objects remain compatible "
"with normal usage of the :mod:`pickle` module.  However, consumers can also "
"opt-in to tell :mod:`pickle` that they will handle those buffers by "
"themselves."
msgstr ""
":class:`PickleBuffer` 物件*發出信號*表示底層緩衝區符合帶外資料傳輸條件。"
"這些物件與 :mod:`pickle` 模組的正常使用保持相容。然而，消費者也可以選擇告訴 "
"pickle 他們將自己處理這些緩衝區。"

#: ../../library/pickle.rst:977
#, fuzzy
msgid "Consumer API"
msgstr "消費者API"

#: ../../library/pickle.rst:979
#, fuzzy
msgid ""
"A communications system can enable custom handling of the :class:"
"`PickleBuffer` objects generated when serializing an object graph."
msgstr "通信系統可以啟用對序列化對像圖時生成的 PickleBuffer 物件的自定義處理。"

#: ../../library/pickle.rst:982
#, fuzzy
msgid ""
"On the sending side, it needs to pass a *buffer_callback* argument to :class:"
"`Pickler` (or to the :func:`dump` or :func:`dumps` function), which will be "
"called with each :class:`PickleBuffer` generated while pickling the object "
"graph.  Buffers accumulated by the *buffer_callback* will not see their data "
"copied into the pickle stream, only a cheap marker will be inserted."
msgstr ""
"在發送方，它需要將 *buffer_callback* "
"參數傳遞給 :class:`Pickler`（或傳遞給 :func:`dump` 或 :func:`dumps` "
"函式），每個:class:醃製對像圖時生成 ``PickleBuffer`` 。 *buffer_callback* "
"累積的緩衝區不會看到它們的資料被複製到 pickle 流中，只會插入一個便宜的標記。"

#: ../../library/pickle.rst:989
#, fuzzy
msgid ""
"On the receiving side, it needs to pass a *buffers* argument to :class:"
"`Unpickler` (or to the :func:`load` or :func:`loads` function), which is an "
"iterable of the buffers which were passed to *buffer_callback*. That "
"iterable should produce buffers in the same order as they were passed to "
"*buffer_callback*.  Those buffers will provide the data expected by the "
"reconstructors of the objects whose pickling produced the original :class:"
"`PickleBuffer` objects."
msgstr ""
"在接收方，它需要將 *buffers* 參數傳遞給 :class:`Unpickler`（或傳遞給 "
":func:`load` 或 :func:`loads` 函式），這是一個可疊代的緩衝區傳遞給 "
"*buffer_callback*。該可疊代物件應按照傳遞給 *buffer_callback* 的相同順序生成"
"緩衝區。這些緩衝區將提供物件的重構器所期望的資料，這些物件的酸洗產生了原始的:"
"class:`PickleBuffer` 物件。"

#: ../../library/pickle.rst:997
#, fuzzy
msgid ""
"Between the sending side and the receiving side, the communications system "
"is free to implement its own transfer mechanism for out-of-band buffers. "
"Potential optimizations include the use of shared memory or datatype-"
"dependent compression."
msgstr "在發送方和接收方之間，通信系統可以自由實作自己的帶外緩衝區傳輸機制。潛在的最"
"佳化包括使用共享記憶體或依賴於資料型別的壓縮。"

#: ../../library/pickle.rst:1003
msgid "Example"
msgstr "範例"

#: ../../library/pickle.rst:1005
#, fuzzy
msgid ""
"Here is a trivial example where we implement a :class:`bytearray` subclass "
"able to participate in out-of-band buffer pickling::"
msgstr "這是一個簡單的例子，我們實作了一個能夠參與帶外緩衝區酸洗的 :class:`bytearray` "
"子類別::"

#: ../../library/pickle.rst:1029
#, fuzzy
msgid ""
"The reconstructor (the ``_reconstruct`` class method) returns the buffer's "
"providing object if it has the right type.  This is an easy way to simulate "
"zero-copy behaviour on this toy example."
msgstr "重構器（``_reconstruct`` 類方法）回傳緩衝區的提供物件（如果它具有正確的型別）"
"。這是在此玩具示例中模擬零拷貝行為的簡單方法。"

#: ../../library/pickle.rst:1033
#, fuzzy
msgid ""
"On the consumer side, we can pickle those objects the usual way, which when "
"unserialized will give us a copy of the original object::"
msgstr "在消費者方面，我們可以用通常的方式 pickle "
"那些物件，當反序列化時，我們會得到一個原始物件的副本："

#: ../../library/pickle.rst:1042
#, fuzzy
msgid ""
"But if we pass a *buffer_callback* and then give back the accumulated "
"buffers when unserializing, we are able to get back the original object::"
msgstr "但是如果我們傳遞一個 *buffer_callback* "
"然後在反序列化時回傳累積的緩衝區，我們就能夠取回原始物件::"

#: ../../library/pickle.rst:1052
#, fuzzy
msgid ""
"This example is limited by the fact that :class:`bytearray` allocates its "
"own memory: you cannot create a :class:`bytearray` instance that is backed "
"by another object's memory.  However, third-party datatypes such as NumPy "
"arrays do not have this limitation, and allow use of zero-copy pickling (or "
"making as few copies as possible) when transferring between distinct "
"processes or systems."
msgstr ""
"此示例受限於 :class:`bytearray` 分配自己的記憶體這一事實："
"您不能建立由另一個物件的記憶體支援的 :class:`bytearray` 實例。但是，NumPy "
"數組等第三方資料型別沒有此限制，並且在不同行程或系統之間傳輸時允許使用零拷貝 "
"pickling（或製作盡可能少的副本）。"

#: ../../library/pickle.rst:1059
#, fuzzy
msgid ":pep:`574` -- Pickle protocol 5 with out-of-band data"
msgstr ":pep:`574` -- 帶有帶外資料的 Pickle 協定 5"

#: ../../library/pickle.rst:1065
#, fuzzy
msgid "Restricting Globals"
msgstr "限制全局變數"

#: ../../library/pickle.rst:1070
#, fuzzy
msgid ""
"By default, unpickling will import any class or function that it finds in "
"the pickle data.  For many applications, this behaviour is unacceptable as "
"it permits the unpickler to import and invoke arbitrary code.  Just consider "
"what this hand-crafted pickle data stream does when loaded::"
msgstr ""
"預設情況下，unpickling 將導入它在 pickle "
"資料中找到的任何類或函式。對於許多應用程式來說，這種行為是不可接受的，"
"因為它允許 unpickler "
"導入和呼叫任意程式碼。想想這個手工製作的泡菜資料流在加載時做了什麼::"

#: ../../library/pickle.rst:1080
#, fuzzy
msgid ""
"In this example, the unpickler imports the :func:`os.system` function and "
"then apply the string argument \"echo hello world\".  Although this example "
"is inoffensive, it is not difficult to imagine one that could damage your "
"system."
msgstr ""
"在此示例中，unpickler 導入 os.system 函式，然後應用字串參數“echo hello "
"world”。儘管這個例子沒有什麼冒犯性，但不難想像一個可能會損壞您的系統的例子。"

#: ../../library/pickle.rst:1084
#, fuzzy
msgid ""
"For this reason, you may want to control what gets unpickled by customizing :"
"meth:`Unpickler.find_class`.  Unlike its name suggests, :meth:`Unpickler."
"find_class` is called whenever a global (i.e., a class or a function) is "
"requested.  Thus it is possible to either completely forbid globals or "
"restrict them to a safe subset."
msgstr ""
"出於這個原因，您可能希望通過自定義 Unpickler.find_class "
"來控制取消醃製的內容。與其名稱所暗示的不同，只要請求全局（即類或函式），"
"就會呼叫 :meth:`Unpickler."
"find_class`。因此，可以完全禁止全局變數或將它們限制在一個安全的子集中。"

#: ../../library/pickle.rst:1090
#, fuzzy
msgid ""
"Here is an example of an unpickler allowing only few safe classes from the :"
"mod:`builtins` module to be loaded::"
msgstr "下面是一個 unpickler 的例子，它只允許加載 builtins 模組中的幾個安全類："

#: ../../library/pickle.rst:1119
#, fuzzy
msgid "A sample usage of our unpickler working as intended::"
msgstr "我們的 unpickler 按預期工作的示例用法："

#: ../../library/pickle.rst:1138
#, fuzzy
msgid ""
"As our examples shows, you have to be careful with what you allow to be "
"unpickled.  Therefore if security is a concern, you may want to consider "
"alternatives such as the marshalling API in :mod:`xmlrpc.client` or third-"
"party solutions."
msgstr ""
"正如我們的示例所示，您必須小心處理允許取消醃製的內容。因此，如果安全是一個問"
"題，您可能需要考慮替代方案，例如 :mod:`xmlrpc.client` 中的編組 API "
"或第三方解決方案。"

#: ../../library/pickle.rst:1145
#, fuzzy
msgid "Performance"
msgstr "表現"

#: ../../library/pickle.rst:1147
#, fuzzy
msgid ""
"Recent versions of the pickle protocol (from protocol 2 and upwards) feature "
"efficient binary encodings for several common features and built-in types. "
"Also, the :mod:`pickle` module has a transparent optimizer written in C."
msgstr ""
"pickle 協定的最新版本（從協定 2 "
"開始）為幾個常見功能和內建型別提供了高效的二進位編碼。此外，:mod:`pickle` "
"模組有一個用 C 語言編寫的透明最佳化器。"

#: ../../library/pickle.rst:1155
msgid "Examples"
msgstr "範例"

#: ../../library/pickle.rst:1157
#, fuzzy
msgid ""
"For the simplest code, use the :func:`dump` and :func:`load` functions. ::"
msgstr "對於最簡單的程式碼，使用 :func:`dump` 和 :func:`load` 函式。 ::"

#: ../../library/pickle.rst:1173
#, fuzzy
msgid "The following example reads the resulting pickled data. ::"
msgstr "以下示例讀取生成的醃製資料。 ::"

#: ../../library/pickle.rst:1190
msgid "Module :mod:`copyreg`"
msgstr ":mod:`copyreg` 模組"

#: ../../library/pickle.rst:1190
#, fuzzy
msgid "Pickle interface constructor registration for extension types."
msgstr "擴充型別的 Pickle 介面構造函式註冊。"

#: ../../library/pickle.rst:1193
msgid "Module :mod:`pickletools`"
msgstr ":mod:`pickletools` 模組"

#: ../../library/pickle.rst:1193
#, fuzzy
msgid "Tools for working with and analyzing pickled data."
msgstr "用於處理和分析醃製資料的工具。"

#: ../../library/pickle.rst:1196
msgid "Module :mod:`shelve`"
msgstr ":mod:`shelve` 模組"

#: ../../library/pickle.rst:1196
#, fuzzy
msgid "Indexed databases of objects; uses :mod:`pickle`."
msgstr "物件的索引資料庫；使用 :mod:`pickle`。"

#: ../../library/pickle.rst:1199
msgid "Module :mod:`copy`"
msgstr ":mod:`copy` 模組"

#: ../../library/pickle.rst:1199
#, fuzzy
msgid "Shallow and deep object copying."
msgstr "淺層和深層物件複製。"

#: ../../library/pickle.rst:1201
msgid "Module :mod:`marshal`"
msgstr ":mod:`marshal` 模組"

#: ../../library/pickle.rst:1202
#, fuzzy
msgid "High-performance serialization of built-in types."
msgstr "內建型別的高性能序列化。"

#: ../../library/pickle.rst:1206
msgid "Footnotes"
msgstr "註解"

#: ../../library/pickle.rst:1207
#, fuzzy
msgid "Don't confuse this with the :mod:`marshal` module"
msgstr "不要將它與 :mod:`marshal` 模組混淆"

#: ../../library/pickle.rst:1209
#, fuzzy
msgid ""
"This is why :keyword:`lambda` functions cannot be pickled:  all :keyword:`!"
"lambda` functions share the same name:  ``<lambda>``."
msgstr ""
"這就是為什麼 :keyword:`lambda` 函式不能被 pickle 的原因：所有 "
":keyword:`!lambda` 函式共享相同的名稱：``<lambda>``。"

#: ../../library/pickle.rst:1212
#, fuzzy
msgid ""
"The exception raised will likely be an :exc:`ImportError` or an :exc:"
"`AttributeError` but it could be something else."
msgstr "引發的例外可能是 :exc:`ImportError` 或 :exc:`AttributeError` "
"但它也可能是其他東西。"

#: ../../library/pickle.rst:1215
#, fuzzy
msgid ""
"The :mod:`copy` module uses this protocol for shallow and deep copying "
"operations."
msgstr ":mod:`copy` 模組使用此協定進行淺層和深層複製操作。"

#: ../../library/pickle.rst:1218
#, fuzzy
msgid ""
"The limitation on alphanumeric characters is due to the fact that persistent "
"IDs in protocol 0 are delimited by the newline character.  Therefore if any "
"kind of newline characters occurs in persistent IDs, the resulting pickled "
"data will become unreadable."
msgstr ""
"對字母數字字元的限制是由於協定 0 中的持久 ID 由換行符分隔。因此，如果持久化 "
"ID 中出現任何型別的換行符，生成的 pickled 資料將變得不可讀。"
