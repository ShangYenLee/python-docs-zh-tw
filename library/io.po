# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-24 00:16+0000\n"
"PO-Revision-Date: 2018-05-23 16:04+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/io.rst:2
msgid ":mod:`io` --- Core tools for working with streams"
msgstr ":mod:`io` --- 處理串流的核心工具"

#: ../../library/io.rst:15
msgid "**Source code:** :source:`Lib/io.py`"
msgstr "**原始碼：**\\ :source:`Lib/io.py`"

#: ../../library/io.rst:22
msgid "Overview"
msgstr "總覽"

#: ../../library/io.rst:27
#, fuzzy
msgid ""
"The :mod:`io` module provides Python's main facilities for dealing with "
"various types of I/O.  There are three main types of I/O: *text I/O*, "
"*binary I/O* and *raw I/O*.  These are generic categories, and various "
"backing stores can be used for each of them.  A concrete object belonging to "
"any of these categories is called a :term:`file object`.  Other common terms "
"are *stream* and *file-like object*."
msgstr ""
":mod:`io` 模組提供了 Python 處理各種型別 I/O 的主要工具。 I/O "
"主要分為三種型別：*文本 I/O*、*二進位 I/O* 和*原始 I/O*。這些是通用類別，每個"
"類別都可以使用各種後備儲存。屬於任何這些類別的具體物件稱為文件物件。"
"其他常見術語是 *stream* 和 *file-like object*。"

#: ../../library/io.rst:34
#, fuzzy
msgid ""
"Independent of its category, each concrete stream object will also have "
"various capabilities: it can be read-only, write-only, or read-write. It can "
"also allow arbitrary random access (seeking forwards or backwards to any "
"location), or only sequential access (for example in the case of a socket or "
"pipe)."
msgstr ""
"獨立於其類別，每個具體的流對像也將具有不同的能力：它可以是只讀的、只寫的或讀"
"寫的。它還可以允許任意隨機訪問（向前或向後尋找任何位置），或僅順序訪問（例如"
"在 socket 或管道的情況下）。"

#: ../../library/io.rst:40
#, fuzzy
msgid ""
"All streams are careful about the type of data you give to them.  For "
"example giving a :class:`str` object to the ``write()`` method of a binary "
"stream will raise a :exc:`TypeError`.  So will giving a :class:`bytes` "
"object to the ``write()`` method of a text stream."
msgstr ""
"所有流都會注意您提供給它們的資料型別。例如，將一個 :class:`str` "
"物件賦給二進位流的 ``write()`` 方法將引發一個 "
":exc:`TypeError`。因此將一個 :class:`bytes` 物件提供給文本流的``write()`` "
"方法。"

#: ../../library/io.rst:45
#, fuzzy
msgid ""
"Operations that used to raise :exc:`IOError` now raise :exc:`OSError`, "
"since :exc:`IOError` is now an alias of :exc:`OSError`."
msgstr ""
"過去引發 :exc:`IOError` 的操作現在引發 :exc:`OSError`，因為 :exc:`IOError` "
"現在是 :exc:`OSError` 的別名。"

#: ../../library/io.rst:51 ../../library/io.rst:855 ../../library/io.rst:1122
#, fuzzy
msgid "Text I/O"
msgstr "文字 I/O"

#: ../../library/io.rst:53
#, fuzzy
msgid ""
"Text I/O expects and produces :class:`str` objects.  This means that "
"whenever the backing store is natively made of bytes (such as in the case of "
"a file), encoding and decoding of data is made transparently as well as "
"optional translation of platform-specific newline characters."
msgstr ""
"文本 I/O 期望並生成 :class:`str` 物件。這意味著只要後備儲存本身由位元組組成（"
"例如在文件的情況下），資料的編碼和解碼以及平台特定換行符的可選轉換都是透明的"
"。"

#: ../../library/io.rst:58
#, fuzzy
msgid ""
"The easiest way to create a text stream is with :meth:`open()`, optionally "
"specifying an encoding::"
msgstr "建立文本流的最簡單方法是使用 :meth:`open()`，可選擇指定編碼::"

#: ../../library/io.rst:63
#, fuzzy
msgid ""
"In-memory text streams are also available as :class:`StringIO` objects::"
msgstr "記憶體中的文本流也可以作為 StringIO 物件使用："

#: ../../library/io.rst:67
#, fuzzy
msgid ""
"The text stream API is described in detail in the documentation of :class:"
"`TextIOBase`."
msgstr "文本流 API 在 TextIOBase 的文檔中有詳細描述。"

#: ../../library/io.rst:72 ../../library/io.rst:1110
#, fuzzy
msgid "Binary I/O"
msgstr "二進位輸入輸出"

#: ../../library/io.rst:74
#, fuzzy
msgid ""
"Binary I/O (also called *buffered I/O*) expects :term:`bytes-like objects "
"<bytes-like object>` and produces :class:`bytes` objects.  No encoding, "
"decoding, or newline translation is performed.  This category of streams can "
"be used for all kinds of non-text data, and also when manual control over "
"the handling of text data is desired."
msgstr ""
"二進位 I/O（也稱為 *緩衝 I/O*）期望 :term:`bytes-like objects <bytes-like "
"object>` 並生成 :class:`bytes` 物件。不執行編碼、解碼或換行轉換。此類流可用於"
"所有型別的非文本資料，也可用於需要手動控制文本資料處理的情況。"

#: ../../library/io.rst:80
#, fuzzy
msgid ""
"The easiest way to create a binary stream is with :meth:`open()` with "
"``'b'`` in the mode string::"
msgstr "建立二進位流的最簡單方法是在模式字串中使用 :meth:`open()` 和 ``'b'``::"

#: ../../library/io.rst:85
#, fuzzy
msgid ""
"In-memory binary streams are also available as :class:`BytesIO` objects::"
msgstr "記憶體中的二進位流也可用作 :class:`BytesIO` 物件::"

#: ../../library/io.rst:89
#, fuzzy
msgid ""
"The binary stream API is described in detail in the docs of :class:"
"`BufferedIOBase`."
msgstr "BufferedIOBase 的文檔中詳細描述了二進位流 API。"

#: ../../library/io.rst:92
#, fuzzy
msgid ""
"Other library modules may provide additional ways to create text or binary "
"streams.  See :meth:`socket.socket.makefile` for example."
msgstr "其他庫模組可能會提供額外的方法來建立文本或二進位流。例如，參見 :meth:`socket."
"socket.makefile`。"

#: ../../library/io.rst:97
#, fuzzy
msgid "Raw I/O"
msgstr "原始 I/O"

#: ../../library/io.rst:99
#, fuzzy
msgid ""
"Raw I/O (also called *unbuffered I/O*) is generally used as a low-level "
"building-block for binary and text streams; it is rarely useful to directly "
"manipulate a raw stream from user code.  Nevertheless, you can create a raw "
"stream by opening a file in binary mode with buffering disabled::"
msgstr ""
"原始 I/O（也稱為*無緩衝 I/O*）通常用作二進位和文本流的低階構建塊；從使用者程"
"式碼直接操作原始流很少有用。不過，您可以通過在禁用緩衝的情況下以二進位模式打"
"開文件來建立原始流："

#: ../../library/io.rst:106
#, fuzzy
msgid ""
"The raw stream API is described in detail in the docs of :class:`RawIOBase`."
msgstr "原始流 API 在 :class:`RawIOBase` 的文檔中有詳細描述。"

#: ../../library/io.rst:112
#, fuzzy
msgid "Text Encoding"
msgstr "文本編碼"

#: ../../library/io.rst:114
#, fuzzy
msgid ""
"The default encoding of :class:`TextIOWrapper` and :func:`open` is locale-"
"specific (:func:`locale.getencoding`)."
msgstr ""
":class:`TextIOWrapper` 和 :func:`open` 的預設編碼是特定於語言環境的 "
"(:func:`locale.getencoding`)。"

#: ../../library/io.rst:117
#, fuzzy
msgid ""
"However, many developers forget to specify the encoding when opening text "
"files encoded in UTF-8 (e.g. JSON, TOML, Markdown, etc...) since most Unix "
"platforms use UTF-8 locale by default. This causes bugs because the locale "
"encoding is not UTF-8 for most Windows users. For example::"
msgstr ""
"但是，許多開發人員在打開以 UTF-8 編碼的文本文件（例如 JSON、TOML、Markdown "
"等）時忘記指定編碼，因為大多數 Unix 平台預設使用 UTF-8 "
"語言環境。這會導致錯誤，因為對於大多數 Windows 使用者而言，語言環境編碼不是 "
"UTF-8。例如：："

#: ../../library/io.rst:126
#, fuzzy
msgid ""
"Accordingly, it is highly recommended that you specify the encoding "
"explicitly when opening text files. If you want to use UTF-8, pass "
"``encoding=\"utf-8\"``. To use the current locale encoding, "
"``encoding=\"locale\"`` is supported since Python 3.10."
msgstr ""
"因此，強烈建議您在打開文本文件時明確指定編碼。如果你想使用 UTF-8，傳遞 "
"``encoding=\"utf-8\"``。要使用當前的語言環境編碼，自 Python 3.10 起支援 "
"``encoding=\"locale\"``。"

#: ../../library/io.rst:135
msgid ":ref:`utf8-mode`"
msgstr ":ref:`utf8-mode`"

#: ../../library/io.rst:134
#, fuzzy
msgid ""
"Python UTF-8 Mode can be used to change the default encoding to UTF-8 from "
"locale-specific encoding."
msgstr "Python UTF-8 模式可用於將預設編碼從特定於語言環境的編碼更改為 UTF-8。"

#: ../../library/io.rst:137
msgid ":pep:`686`"
msgstr ":pep:`686`"

#: ../../library/io.rst:138
msgid "Python 3.15 will make :ref:`utf8-mode` default."
msgstr "Python 3.15 將使 :ref:`utf8-mode` 成為預設。"

#: ../../library/io.rst:143
#, fuzzy
msgid "Opt-in EncodingWarning"
msgstr "選擇加入編碼警告"

#: ../../library/io.rst:145
msgid "See :pep:`597` for more details."
msgstr "更多資訊請見 :pep:`597`\\ 。"

#: ../../library/io.rst:148
#, fuzzy
msgid ""
"To find where the default locale encoding is used, you can enable the ``-X "
"warn_default_encoding`` command line option or set the :envvar:"
"`PYTHONWARNDEFAULTENCODING` environment variable, which will emit an :exc:"
"`EncodingWarning` when the default encoding is used."
msgstr ""
"要查找使用預設語言環境編碼的位置，您可以啟用 ``-X warn_default_encoding`` "
"命令列選項或設定 :envvar:`PYTHONWARNDEFAULTENCODING` 環境變數，"
"這將在預設編碼時發出 :exc:`EncodingWarning`用來。"

#: ../../library/io.rst:153
#, fuzzy
msgid ""
"If you are providing an API that uses :func:`open` or :class:`TextIOWrapper` "
"and passes ``encoding=None`` as a parameter, you can use :func:"
"`text_encoding` so that callers of the API will emit an :exc:"
"`EncodingWarning` if they don't pass an ``encoding``. However, please "
"consider using UTF-8 by default (i.e. ``encoding=\"utf-8\"``) for new APIs."
msgstr ""
"如果您提供的 API 使用 :func:`open` 或 :class:`TextIOWrapper` 並將 "
"``encoding=None`` 作為參數傳遞，則可以使用 :func:`text_encoding` 這樣 API "
"的呼叫者將如果他們沒有通過 ``encoding`` 則發出 :exc:`EncodingWarning`。但是，"
"請考慮為新 API 預設使用 UTF-8（即 ``encoding=\"utf-8\"``）。"

#: ../../library/io.rst:162
#, fuzzy
msgid "High-level Module Interface"
msgstr "高階模組介面"

#: ../../library/io.rst:166
#, fuzzy
msgid ""
"An int containing the default buffer size used by the module's buffered I/O "
"classes.  :func:`open` uses the file's blksize (as obtained by :func:`os."
"stat`) if possible."
msgstr ""
"一個 int，包含模組的緩衝 I/O 類使用的預設緩衝區大小。 :func:`open` 如果可能，"
"使用文件的 blksize（由 :func:`os.stat` 獲得）。"

#: ../../library/io.rst:173
#, fuzzy
msgid "This is an alias for the builtin :func:`open` function."
msgstr "這是內建 :func:`open` 函式的別名。"

#: ../../library/io.rst:175
msgid ""
"Raises an :ref:`auditing event <auditing>` ``open`` with arguments ``path``, "
"``mode``, ``flags``."
msgstr ""
"引發一個附帶引數 ``path``、``mode``、``flags`` 的\\ :ref:`稽核事件 <auditing>` ``open``。"

#: ../../library/io.rst:177
#, fuzzy
msgid ""
"This function raises an :ref:`auditing event <auditing>` ``open`` with "
"arguments ``path``, ``mode`` and ``flags``. The ``mode`` and ``flags`` "
"arguments may have been modified or inferred from the original call."
msgstr ""
"此函式引發一個 :ref:`auditing 事件 <auditing>` ``open`` 帶有參數 "
"``path``、``mode`` 和 ``flags``。 ``mode`` 和 ``flags`` "
"參數可能已被修改或從原始呼叫中推斷出來。"

#: ../../library/io.rst:184
#, fuzzy
msgid ""
"Opens the provided file with mode ``'rb'``. This function should be used "
"when the intent is to treat the contents as executable code."
msgstr "使用模式 ``rb``打開提供的文件。當意圖將內容視為可執行程式碼時，應使用此函式。"

#: ../../library/io.rst:187
#, fuzzy
msgid "``path`` should be a :class:`str` and an absolute path."
msgstr "``path`` 應該是一個 :class:`str` 和一個絕對路徑。"

#: ../../library/io.rst:189
#, fuzzy
msgid ""
"The behavior of this function may be overridden by an earlier call to the :c:"
"func:`PyFile_SetOpenCodeHook`. However, assuming that ``path`` is a :class:"
"`str` and an absolute path, ``open_code(path)`` should always behave the "
"same as ``open(path, 'rb')``. Overriding the behavior is intended for "
"additional validation or preprocessing of the file."
msgstr ""
"此函式的行為可能會被之前對 PyFile_SetOpenCodeHook 的呼叫覆蓋。但是，假設 "
"``path`` 是一個 :class:`str` 和一個絕對路徑，``open_code(path)`` "
"的行為應該始終與 ``open(path, 'rb')`` "
"相同。覆蓋行為旨在對文件進行額外的驗證或預處理。"

#: ../../library/io.rst:200
#, fuzzy
msgid ""
"This is a helper function for callables that use :func:`open` or :class:"
"`TextIOWrapper` and have an ``encoding=None`` parameter."
msgstr ""
"這是使用 :func:`open` 或 :class:`TextIOWrapper` 並具有 ``encoding=None`` "
"參數的可呼叫物件的輔助函式。"

#: ../../library/io.rst:203
#, fuzzy
msgid ""
"This function returns *encoding* if it is not ``None``. Otherwise, it "
"returns ``\"locale\"`` or ``\"utf-8\"`` depending on :ref:`UTF-8 Mode <utf8-"
"mode>`."
msgstr ""
"這個函式回傳 *encoding* 如果它不是``None``。否則，它回傳 ``\"locale\"`` 或 ``"
"\"utf-8\"`` 取決於 :ref:`UTF-8 Mode <utf8-mode>`。"

#: ../../library/io.rst:207
#, fuzzy
msgid ""
"This function emits an :class:`EncodingWarning` if :data:`sys.flags."
"warn_default_encoding <sys.flags>` is true and *encoding* is ``None``. "
"*stacklevel* specifies where the warning is emitted. For example::"
msgstr ""
"如果 :data:`sys.flags.warn_default_encoding <sys.flags>` 為真且 *encoding* "
"為 ``None``，此函式將發出 EncodingWarning。 *stacklevel* "
"指定發出警告的位置。例如：："

#: ../../library/io.rst:217
#, fuzzy
msgid ""
"In this example, an :class:`EncodingWarning` is emitted for the caller of "
"``read_text()``."
msgstr "在此示例中，為 read_text() 的呼叫者發出了一個 EncodingWarning。"

#: ../../library/io.rst:220
msgid "See :ref:`io-text-encoding` for more information."
msgstr "更多資訊請見 :ref:`io-text-encoding`\\ 。"

#: ../../library/io.rst:224
#, fuzzy
msgid ""
":func:`text_encoding` returns \"utf-8\" when UTF-8 mode is enabled and "
"*encoding* is ``None``."
msgstr ":func:`text_encoding` 在啟用 UTF-8 模式且 *encoding* 為 ``None`` "
"時回傳 ``utf-8``。"

#: ../../library/io.rst:231
#, fuzzy
msgid ""
"This is a compatibility alias for the builtin :exc:`BlockingIOError` "
"exception."
msgstr "這是內建 BlockingIOError 例外的相容性別名。"

#: ../../library/io.rst:237
#, fuzzy
msgid ""
"An exception inheriting :exc:`OSError` and :exc:`ValueError` that is raised "
"when an unsupported operation is called on a stream."
msgstr "繼承 :exc:`OSError` 和 :exc:`ValueError` "
"的例外在流上呼叫不受支援的操作時引發。"

#: ../../library/io.rst:244
msgid ":mod:`sys`"
msgstr ":mod:`sys`"

#: ../../library/io.rst:244
#, fuzzy
msgid ""
"contains the standard IO streams: :data:`sys.stdin`, :data:`sys.stdout`, "
"and :data:`sys.stderr`."
msgstr "包含標準 IO 流：:data:`sys.stdin`、:data:`sys.stdout` 和 :data:`sys.stderr`。"

#: ../../library/io.rst:249
#, fuzzy
msgid "Class hierarchy"
msgstr "類層次結構"

#: ../../library/io.rst:251
#, fuzzy
msgid ""
"The implementation of I/O streams is organized as a hierarchy of classes.  "
"First :term:`abstract base classes <abstract base class>` (ABCs), which are "
"used to specify the various categories of streams, then concrete classes "
"providing the standard stream implementations."
msgstr ""
"I/O 流的實作被組織為類的層次結構。首先 :term:`抽象基底類別 <abstract base "
"class>` (ABCs)，用於指定流的各種類別，然後是提供標準流實作的具體類。"

#: ../../library/io.rst:258
#, fuzzy
msgid ""
"The abstract base classes also provide default implementations of some "
"methods in order to help implementation of concrete stream classes.  For "
"example, :class:`BufferedIOBase` provides unoptimized implementations of :"
"meth:`~IOBase.readinto` and :meth:`~IOBase.readline`."
msgstr ""
"抽象基底類別還提供了一些方法的預設實作，以幫助實作具體的流類。例如，:class:`B"
"ufferedIOBase` 提供了 :meth:`~IOBase.readinto` 和 :meth:`~IOBase.readline` "
"的未最佳化實作。"

#: ../../library/io.rst:263
#, fuzzy
msgid ""
"At the top of the I/O hierarchy is the abstract base class :class:`IOBase`.  "
"It defines the basic interface to a stream.  Note, however, that there is no "
"separation between reading and writing to streams; implementations are "
"allowed to raise :exc:`UnsupportedOperation` if they do not support a given "
"operation."
msgstr ""
"在 I/O 層次結構的頂部是抽象基底類別 :class:`IOBase`。它定義了流的基本介面。但"
"是請注意，讀取和寫入流之間沒有分離；如果實作不支援給定的操作，則允許它們引發 "
":exc:`UnsupportedOperation`。"

#: ../../library/io.rst:268
#, fuzzy
msgid ""
"The :class:`RawIOBase` ABC extends :class:`IOBase`.  It deals with the "
"reading and writing of bytes to a stream.  :class:`FileIO` subclasses :class:"
"`RawIOBase` to provide an interface to files in the machine's file system."
msgstr ""
":class:`RawIOBase` ABC 擴充了 :class:`IOBase`。它處理位元組到流的讀寫。 "
":class:`FileIO` 是 :class:`RawIOBase` "
"的子類別，為機器文件系統中的文件提供介面。"

#: ../../library/io.rst:272
#, fuzzy
msgid ""
"The :class:`BufferedIOBase` ABC extends :class:`IOBase`.  It deals with "
"buffering on a raw binary stream (:class:`RawIOBase`).  Its subclasses, :"
"class:`BufferedWriter`, :class:`BufferedReader`, and :class:`BufferedRWPair` "
"buffer raw binary streams that are writable, readable, and both readable and "
"writable, respectively. :class:`BufferedRandom` provides a buffered "
"interface to seekable streams. Another :class:`BufferedIOBase` subclass, :"
"class:`BytesIO`, is a stream of in-memory bytes."
msgstr ""
"BufferedIOBase ABC 擴充了 IOBase。它處理原始二進位流 (:class:`RawIOBase`) "
"上的緩衝。它的子類別 BufferedWriter、BufferedReader 和 BufferedRWPair "
"分別緩衝可寫、可讀和可讀可寫的原始二進位流。 :class:`BufferedRandom` "
"為可搜索流提供緩衝介面。另一個 :class:`BufferedIOBase` 子類別 "
":class:`BytesIO` 是記憶體位元組流。"

#: ../../library/io.rst:280
#, fuzzy
msgid ""
"The :class:`TextIOBase` ABC extends :class:`IOBase`.  It deals with streams "
"whose bytes represent text, and handles encoding and decoding to and from "
"strings.  :class:`TextIOWrapper`, which extends :class:`TextIOBase`, is a "
"buffered text interface to a buffered raw stream (:class:`BufferedIOBase`).  "
"Finally, :class:`StringIO` is an in-memory stream for text."
msgstr ""
":class:`TextIOBase` ABC 擴充了 :class:`IOBase`。它處理位元組表示文本的流，並處"
"理與字串之間的編碼和解碼。擴充了 TextIOBase 的 TextIOWrapper 是緩衝原始流 "
"(BufferedIOBase) 的緩衝文本介面。最後，:class:`StringIO` "
"是一個記憶體中的文本流。"

#: ../../library/io.rst:286
#, fuzzy
msgid ""
"Argument names are not part of the specification, and only the arguments of :"
"func:`open` are intended to be used as keyword arguments."
msgstr "參數名稱不是規範的一部分，只有 :func:`open` 的參數可以用作關鍵字參數。"

#: ../../library/io.rst:289
#, fuzzy
msgid ""
"The following table summarizes the ABCs provided by the :mod:`io` module:"
msgstr "下表總結了 :mod:`io` 模組提供的 ABC："

#: ../../library/io.rst:294
msgid "ABC"
msgstr "ABC"

#: ../../library/io.rst:294
#, fuzzy
msgid "Inherits"
msgstr "繼承"

#: ../../library/io.rst:294
#, fuzzy
msgid "Stub Methods"
msgstr "存根方法"

#: ../../library/io.rst:294
#, fuzzy
msgid "Mixin Methods and Properties"
msgstr "混合方法和屬性"

#: ../../library/io.rst:296 ../../library/io.rst:301 ../../library/io.rst:303
#: ../../library/io.rst:305
msgid ":class:`IOBase`"
msgstr ":class:`IOBase`"

#: ../../library/io.rst:296
msgid "``fileno``, ``seek``, and ``truncate``"
msgstr "``fileno``\\ 、\\ ``seek`` 和 ``truncate``"

#: ../../library/io.rst:296
#, fuzzy
msgid ""
"``close``, ``closed``, ``__enter__``, ``__exit__``, ``flush``, ``isatty``, "
"``__iter__``, ``__next__``, ``readable``, ``readline``, ``readlines``, "
"``seekable``, ``tell``, ``writable``, and ``writelines``"
msgstr ""
"``close``，``closed``，``__enter__``，``__exit__``，``flush``，``isatty``，``"
"__iter__``，``__next__``，``可讀``、``readline``、``readlines``、``seekable``"
"、``tell``、``writable`` 和``writelines``"

#: ../../library/io.rst:301
msgid ":class:`RawIOBase`"
msgstr ":class:`RawIOBase`"

#: ../../library/io.rst:301
msgid "``readinto`` and ``write``"
msgstr "``readinto`` 和 ``write``"

#: ../../library/io.rst:301
#, fuzzy
msgid "Inherited :class:`IOBase` methods, ``read``, and ``readall``"
msgstr "繼承 :class:`IOBase` 方法，``read`` 和 ``readall``"

#: ../../library/io.rst:303
msgid ":class:`BufferedIOBase`"
msgstr ":class:`BufferedIOBase`"

#: ../../library/io.rst:303
msgid "``detach``, ``read``, ``read1``, and ``write``"
msgstr "``detach``\\ 、\\ ``read``\\ 、\\ ``read1`` 和 ``write``"

#: ../../library/io.rst:303
#, fuzzy
msgid "Inherited :class:`IOBase` methods, ``readinto``, and ``readinto1``"
msgstr "繼承 :class:`IOBase` 方法，``readinto`` 和``readinto1``"

#: ../../library/io.rst:305
msgid ":class:`TextIOBase`"
msgstr ":class:`TextIOBase`"

#: ../../library/io.rst:305
msgid "``detach``, ``read``, ``readline``, and ``write``"
msgstr "``detach``\\ 、\\ ``read``\\ 、\\ ``readline`` 和 ``write``"

#: ../../library/io.rst:305
#, fuzzy
msgid ""
"Inherited :class:`IOBase` methods, ``encoding``, ``errors``, and ``newlines``"
msgstr "繼承 :class:`IOBase` 方法、``encoding``、``errors`` 和 ``newlines``"

#: ../../library/io.rst:312
#, fuzzy
msgid "I/O Base Classes"
msgstr "I/O 基底類別"

#: ../../library/io.rst:316
#, fuzzy
msgid "The abstract base class for all I/O classes."
msgstr "所有 I/O 類的抽象基底類別。"

#: ../../library/io.rst:318
#, fuzzy
msgid ""
"This class provides empty abstract implementations for many methods that "
"derived classes can override selectively; the default implementations "
"represent a file that cannot be read, written or seeked."
msgstr "此類為派生類可以有選擇地覆蓋的許多方法提供了空的抽象實作；預設實作表示無法讀"
"取、寫入或查找的文件。"

#: ../../library/io.rst:323
#, fuzzy
msgid ""
"Even though :class:`IOBase` does not declare :meth:`read` or :meth:`write` "
"because their signatures will vary, implementations and clients should "
"consider those methods part of the interface.  Also, implementations may "
"raise a :exc:`ValueError` (or :exc:`UnsupportedOperation`) when operations "
"they do not support are called."
msgstr ""
"儘管 :class:`IOBase` 沒有聲明 :meth:`read` 或 :meth:`write` 因為它們的簽名會"
"有所不同，實作和客戶端應該將這些方法視為介面的一部分。此外，當呼叫不支援的操"
"作時，實作可能會引發 :exc:`ValueError`（或 :exc:`UnsupportedOperation`）。"

#: ../../library/io.rst:329
#, fuzzy
msgid ""
"The basic type used for binary data read from or written to a file is :class:"
"`bytes`.  Other :term:`bytes-like objects <bytes-like object>` are accepted "
"as method arguments too.  Text I/O classes work with :class:`str` data."
msgstr ""
"用於從文件讀取或寫入文件的二進位資料的基本型別是 :class:`bytes`。其他 :term"
":`bytes-like objects <bytes-like object>` 也被接受為方法參數。文本 I/O "
"類使用 :class:`str` 資料。"

#: ../../library/io.rst:333
#, fuzzy
msgid ""
"Note that calling any method (even inquiries) on a closed stream is "
"undefined.  Implementations may raise :exc:`ValueError` in this case."
msgstr "請注意，在關閉的流上呼叫任何方法（甚至查詢）都是未定義的。在這種情況下，"
"實作可能會引發 :exc:`ValueError`。"

#: ../../library/io.rst:336
#, fuzzy
msgid ""
":class:`IOBase` (and its subclasses) supports the iterator protocol, meaning "
"that an :class:`IOBase` object can be iterated over yielding the lines in a "
"stream.  Lines are defined slightly differently depending on whether the "
"stream is a binary stream (yielding bytes), or a text stream (yielding "
"character strings).  See :meth:`~IOBase.readline` below."
msgstr ""
":class:`IOBase`（及其子類別）支援疊代器協定，這意味著 :class:`IOBase` 物件可"
"以疊代生成流中的行。根據流是二進位流（產生位元組）還是文本流（產生字串），行"
"的定義略有不同。請參閱下面的 :meth:`~IOBase.readline`。"

#: ../../library/io.rst:342
#, fuzzy
msgid ""
":class:`IOBase` is also a context manager and therefore supports the :"
"keyword:`with` statement.  In this example, *file* is closed after the :"
"keyword:`!with` statement's suite is finished---even if an exception occurs::"
msgstr ""
":class:`IOBase` 也是一個上下文管理器，因此支援 :keyword:`with` "
"語句。在此示例中，*file* 在 :keyword:`!with` 語句組完成後關閉---"
"即使發生例外::"

#: ../../library/io.rst:349
#, fuzzy
msgid ":class:`IOBase` provides these data attributes and methods:"
msgstr ":class:`IOBase` 提供了這些資料屬性和方法："

#: ../../library/io.rst:353
#, fuzzy
msgid ""
"Flush and close this stream. This method has no effect if the file is "
"already closed. Once the file is closed, any operation on the file (e.g. "
"reading or writing) will raise a :exc:`ValueError`."
msgstr "刷新並關閉此流。如果文件已經關閉，則此方法無效。文件關閉後，對文件的任何操作"
"（例如讀取或寫入）都會引發 :exc:`ValueError`。"

#: ../../library/io.rst:357
#, fuzzy
msgid ""
"As a convenience, it is allowed to call this method more than once; only the "
"first call, however, will have an effect."
msgstr "為方便起見，允許多次呼叫此方法；但是，只有第一個呼叫會產生影響。"

#: ../../library/io.rst:362
#, fuzzy
msgid "``True`` if the stream is closed."
msgstr "``True`` 如果流被關閉。"

#: ../../library/io.rst:366
#, fuzzy
msgid ""
"Return the underlying file descriptor (an integer) of the stream if it "
"exists.  An :exc:`OSError` is raised if the IO object does not use a file "
"descriptor."
msgstr "如果存在，則回傳流的基礎文件描述器（整數）。如果 IO 對像不使用文件描述器，"
"則會引發 :exc:`OSError`。"

#: ../../library/io.rst:372
#, fuzzy
msgid ""
"Flush the write buffers of the stream if applicable.  This does nothing for "
"read-only and non-blocking streams."
msgstr "如果適用，刷新流的寫入緩衝區。這對只讀和非阻塞流沒有任何作用。"

#: ../../library/io.rst:377
#, fuzzy
msgid ""
"Return ``True`` if the stream is interactive (i.e., connected to a terminal/"
"tty device)."
msgstr "如果流是交互式的（即連接到終端/tty 設備），則回傳 ``True``。"

#: ../../library/io.rst:382
#, fuzzy
msgid ""
"Return ``True`` if the stream can be read from.  If ``False``, :meth:`read` "
"will raise :exc:`OSError`."
msgstr "如果可以讀取流，則回傳 True。如果 ``False``，:meth:`read` 將引發 "
":exc:`OSError`。"

#: ../../library/io.rst:387
#, fuzzy
msgid ""
"Read and return one line from the stream.  If *size* is specified, at most "
"*size* bytes will be read."
msgstr "從流中讀取並回傳一行。如果指定了 *size*，則最多讀取 *size* 個位元組。"

#: ../../library/io.rst:390
#, fuzzy
msgid ""
"The line terminator is always ``b'\\n'`` for binary files; for text files, "
"the *newline* argument to :func:`open` can be used to select the line "
"terminator(s) recognized."
msgstr ""
"對於二進位文件，行終止符始終為 ``b'\\n"
"'``；對於文本文件，:func:`open` 的 *newline* 參數可用於選擇識別的行終止符。"

#: ../../library/io.rst:396
#, fuzzy
msgid ""
"Read and return a list of lines from the stream.  *hint* can be specified to "
"control the number of lines read: no more lines will be read if the total "
"size (in bytes/characters) of all lines so far exceeds *hint*."
msgstr ""
"從流中讀取並回傳行列表。可以指定 *hint* "
"來控制讀取的行數：如果到目前為止所有行的總大小（以位元組/字元為單位）超過 "
"*hint*，則不會再讀取任何行。"

#: ../../library/io.rst:400
#, fuzzy
msgid ""
"*hint* values of ``0`` or less, as well as ``None``, are treated as no hint."
msgstr "``0`` 或更小的 *hint* 值以及 ``None`` 被視為無提示。"

#: ../../library/io.rst:403
#, fuzzy
msgid ""
"Note that it's already possible to iterate on file objects using ``for line "
"in file: ...`` without calling ``file.readlines()``."
msgstr ""
"請注意，已經可以使用 ``for line in file: ...`` 在文件對像上進行疊代，"
"而無需呼叫 ``file.readlines()``。"

#: ../../library/io.rst:408
#, fuzzy
msgid ""
"Change the stream position to the given byte *offset*.  *offset* is "
"interpreted relative to the position indicated by *whence*.  The default "
"value for *whence* is :data:`SEEK_SET`.  Values for *whence* are:"
msgstr ""
"將流位置更改為給定位元組 *offset*。 *offset* 相對於 *whence* "
"指示的位置進行解釋。 *whence* 的預設值是 :data:`SEEK_SET`。 *whence* 的值是："

#: ../../library/io.rst:412
#, fuzzy
msgid ""
":data:`SEEK_SET` or ``0`` -- start of the stream (the default); *offset* "
"should be zero or positive"
msgstr ":data:`SEEK_SET` 或 ``0`` -- 流的開始（預設）； *offset* 應為零或正數"

#: ../../library/io.rst:414
#, fuzzy
msgid ""
":data:`SEEK_CUR` or ``1`` -- current stream position; *offset* may be "
"negative"
msgstr ":data:`SEEK_CUR` 或 ``1`` -- 當前流位置； *offset* 可能為負"

#: ../../library/io.rst:416
#, fuzzy
msgid ""
":data:`SEEK_END` or ``2`` -- end of the stream; *offset* is usually negative"
msgstr ":data:`SEEK_END` 或 ``2`` -- 流的結尾； *offset* 通常為負"

#: ../../library/io.rst:419
#, fuzzy
msgid "Return the new absolute position."
msgstr "回傳新的絕對位置。"

#: ../../library/io.rst:421 ../../library/io.rst:930
#, fuzzy
msgid "The ``SEEK_*`` constants."
msgstr "``SEEK_*`` 常數。"

#: ../../library/io.rst:424
#, fuzzy
msgid ""
"Some operating systems could support additional values, like :data:`os."
"SEEK_HOLE` or :data:`os.SEEK_DATA`. The valid values for a file could depend "
"on it being open in text or binary mode."
msgstr ""
"一些操作系統可以支援額外的值，比如 :data:`os.SEEK_HOLE` 或 :data:`os."
"SEEK_DATA`。文件的有效值可能取決於它是以文本或二進位模式打開的。"

#: ../../library/io.rst:431
#, fuzzy
msgid ""
"Return ``True`` if the stream supports random access.  If ``False``, :meth:"
"`seek`, :meth:`tell` and :meth:`truncate` will raise :exc:`OSError`."
msgstr ""
"如果流支援隨機訪問，則回傳 ``True``。如果 ``False``、:meth:`seek`、:meth:`tell` "
"和 :meth:`truncate` 將引發 :exc:`OSError`。"

#: ../../library/io.rst:436
#, fuzzy
msgid "Return the current stream position."
msgstr "回傳當前流位置。"

#: ../../library/io.rst:440
#, fuzzy
msgid ""
"Resize the stream to the given *size* in bytes (or the current position if "
"*size* is not specified).  The current stream position isn't changed. This "
"resizing can extend or reduce the current file size.  In case of extension, "
"the contents of the new file area depend on the platform (on most systems, "
"additional bytes are zero-filled).  The new file size is returned."
msgstr ""
"將流的大小調整為給定的 *size*（以位元組為單位）（如果未指定 *size*，則調整為"
"當前位置）。當前流位置沒有改變。此調整大小可以擴充或減小當前文件的大小。在擴"
"充的情況下，新文件區域的內容取決於平台（在大多數係統上，額外的位元組是零填充"
"的）。回傳新的文件大小。"

#: ../../library/io.rst:447
#, fuzzy
msgid "Windows will now zero-fill files when extending."
msgstr "Windows 現在將在擴充時對文件進行零填充。"

#: ../../library/io.rst:452
#, fuzzy
msgid ""
"Return ``True`` if the stream supports writing.  If ``False``, :meth:`write` "
"and :meth:`truncate` will raise :exc:`OSError`."
msgstr ""
"如果流支援寫入，則回傳 ``True``。如果 ``False``，:meth:`write` 和 "
":meth:`truncate` 將引發 :exc:`OSError`。"

#: ../../library/io.rst:457
#, fuzzy
msgid ""
"Write a list of lines to the stream.  Line separators are not added, so it "
"is usual for each of the lines provided to have a line separator at the end."
msgstr "將行列表寫入流。未新增行分隔符，因此通常提供的每一行末尾都有一個行分隔符。"

#: ../../library/io.rst:463
#, fuzzy
msgid ""
"Prepare for object destruction. :class:`IOBase` provides a default "
"implementation of this method that calls the instance's :meth:`~IOBase."
"close` method."
msgstr "準備物件銷毀。 :class:`IOBase` 提供此方法的預設實作，呼叫實例的 "
":meth:`~IOBase.close` 方法。"

#: ../../library/io.rst:470
#, fuzzy
msgid "Base class for raw binary streams.  It inherits :class:`IOBase`."
msgstr "原始二進位流的基底類別。它繼承了 :class:`IOBase`。"

#: ../../library/io.rst:472
#, fuzzy
msgid ""
"Raw binary streams typically provide low-level access to an underlying OS "
"device or API, and do not try to encapsulate it in high-level primitives "
"(this functionality is done at a higher-level in buffered binary streams and "
"text streams, described later in this page)."
msgstr ""
"原始二進位流通常提供對底層 OS 設備或 API 的低階訪問，並且不會嘗試將其封裝在高"
"級原語中（此功能在更高階別的緩衝二進位流和文本流中完成，稍後在這一頁）。"

#: ../../library/io.rst:477
#, fuzzy
msgid ""
":class:`RawIOBase` provides these methods in addition to those from :class:"
"`IOBase`:"
msgstr ":class:`RawIOBase` 除了來自 :class:`IOBase` 的方法外，還提供了這些方法："

#: ../../library/io.rst:482
#, fuzzy
msgid ""
"Read up to *size* bytes from the object and return them.  As a convenience, "
"if *size* is unspecified or -1, all bytes until EOF are returned. Otherwise, "
"only one system call is ever made.  Fewer than *size* bytes may be returned "
"if the operating system call returns fewer than *size* bytes."
msgstr ""
"從對像中讀取最多 *size* 個位元組並回傳它們。為方便起見，如果 *size* "
"未指定或為 -1，則回傳 EOF 之前的所有位元組。否則，只會進行一次系統呼叫。"
"如果操作系統呼叫回傳少於 *size* 位元組，則可能回傳少於 *size* 位元組。"

#: ../../library/io.rst:487
#, fuzzy
msgid ""
"If 0 bytes are returned, and *size* was not 0, this indicates end of file. "
"If the object is in non-blocking mode and no bytes are available, ``None`` "
"is returned."
msgstr ""
"如果回傳 0 個位元組，並且 *size* 不為 "
"0，則表示文件結束。如果物件處於非阻塞模式並且沒有位元組可用，則回傳 ``None``。"

#: ../../library/io.rst:491
#, fuzzy
msgid ""
"The default implementation defers to :meth:`readall` and :meth:`readinto`."
msgstr "預設實作遵循 :meth:`readall` 和 :meth:`readinto`。"

#: ../../library/io.rst:496
#, fuzzy
msgid ""
"Read and return all the bytes from the stream until EOF, using multiple "
"calls to the stream if necessary."
msgstr "從流中讀取並回傳所有位元組，直到 EOF，必要時使用對流的多次呼叫。"

#: ../../library/io.rst:501
#, fuzzy
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b*, and "
"return the number of bytes read.  For example, *b* might be a :class:"
"`bytearray`. If the object is in non-blocking mode and no bytes are "
"available, ``None`` is returned."
msgstr ""
"將位元組讀入一個預先分配的、可寫的 :term:`bytes-like object` "
"*b*，並回傳讀取的位元組數。例如，*b* 可能是一個 "
":class:`bytearray`。如果物件處於非阻塞模式並且沒有位元組可用，則回傳 ``None``。"

#: ../../library/io.rst:509
#, fuzzy
msgid ""
"Write the given :term:`bytes-like object`, *b*, to the underlying raw "
"stream, and return the number of bytes written.  This can be less than the "
"length of *b* in bytes, depending on specifics of the underlying raw stream, "
"and especially if it is in non-blocking mode.  ``None`` is returned if the "
"raw stream is set not to block and no single byte could be readily written "
"to it.  The caller may release or mutate *b* after this method returns, so "
"the implementation should only access *b* during the method call."
msgstr ""
"將給定的 :term:`bytes-like object` *b* 寫入底層原始流，並回傳寫入的位元組數。"
"這可能小於 *b* 的位元組長度，具體取決於底層原始流的具體情況，尤其是在非阻塞模"
"式下。如果原始流設定為不阻塞並且沒有單個位元組可以輕易寫入，則回傳 ``None`` 。"
"呼叫者可以在此方法回傳後釋放或改變 *b*，因此實作應僅在方法呼叫期間訪問 *b*。"

#: ../../library/io.rst:522
#, fuzzy
msgid ""
"Base class for binary streams that support some kind of buffering. It "
"inherits :class:`IOBase`."
msgstr "支援某種緩衝的二進位流的基底類別。它繼承了 :class:`IOBase`。"

#: ../../library/io.rst:525
#, fuzzy
msgid ""
"The main difference with :class:`RawIOBase` is that methods :meth:`read`, :"
"meth:`readinto` and :meth:`write` will try (respectively) to read as much "
"input as requested or to consume all given output, at the expense of making "
"perhaps more than one system call."
msgstr ""
"與 :class:`RawIOBase` 的主要區別在於方法 :meth:`read`、:meth:`readinto` "
"和 :meth:`write` 將嘗試（分別）讀取請求的輸入或消耗所有給定的輸入輸出，代價是"
"可能進行不止一次系統呼叫。"

#: ../../library/io.rst:530
#, fuzzy
msgid ""
"In addition, those methods can raise :exc:`BlockingIOError` if the "
"underlying raw stream is in non-blocking mode and cannot take or give enough "
"data; unlike their :class:`RawIOBase` counterparts, they will never return "
"``None``."
msgstr ""
"此外，如果底層原始流處於非阻塞模式並且無法獲取或提供足夠的資料，"
"這些方法可能會引發 BlockingIOError；不像他們的 :class:`RawIOBase` 對應物，"
"他們永遠不會回傳 ``None``。"

#: ../../library/io.rst:535
#, fuzzy
msgid ""
"Besides, the :meth:`read` method does not have a default implementation that "
"defers to :meth:`readinto`."
msgstr "此外，:meth:`read` 方法沒有遵循 :meth:`readinto` 的預設實作。"

#: ../../library/io.rst:538
#, fuzzy
msgid ""
"A typical :class:`BufferedIOBase` implementation should not inherit from a :"
"class:`RawIOBase` implementation, but wrap one, like :class:`BufferedWriter` "
"and :class:`BufferedReader` do."
msgstr ""
"典型的 BufferedIOBase 實作不應繼承自 RawIOBase 實作，而是包裝一個，如 "
"BufferedWriter 和 BufferedReader 那樣。"

#: ../../library/io.rst:542
#, fuzzy
msgid ""
":class:`BufferedIOBase` provides or overrides these data attributes and "
"methods in addition to those from :class:`IOBase`:"
msgstr ":class:`BufferedIOBase` 提供或覆蓋這些資料屬性和方法，以及來自 "
":class:`IOBase` 的資料屬性和方法："

#: ../../library/io.rst:547
#, fuzzy
msgid ""
"The underlying raw stream (a :class:`RawIOBase` instance) that :class:"
"`BufferedIOBase` deals with.  This is not part of the :class:"
"`BufferedIOBase` API and may not exist on some implementations."
msgstr ""
"BufferedIOBase 處理的底層原始流（一個 RawIOBase 實例）。這不是 "
"BufferedIOBase API 的一部分，在某些實作中可能不存在。"

#: ../../library/io.rst:553
#, fuzzy
msgid "Separate the underlying raw stream from the buffer and return it."
msgstr "將底層原始流與緩衝區分離並回傳。"

#: ../../library/io.rst:555
#, fuzzy
msgid ""
"After the raw stream has been detached, the buffer is in an unusable state."
msgstr "分離原始流後，緩衝區處於不可用狀態。"

#: ../../library/io.rst:558
#, fuzzy
msgid ""
"Some buffers, like :class:`BytesIO`, do not have the concept of a single raw "
"stream to return from this method.  They raise :exc:`UnsupportedOperation`."
msgstr ""
"一些緩衝區，如 :class:`BytesIO`，沒有從該方法回傳的單個原始流的概念。他們提出"
" :exec:`UnsupportedOperation`。"

#: ../../library/io.rst:566
#, fuzzy
msgid ""
"Read and return up to *size* bytes.  If the argument is omitted, ``None``, "
"or negative, data is read and returned until EOF is reached.  An empty :"
"class:`bytes` object is returned if the stream is already at EOF."
msgstr ""
"讀取並回傳最多 *size* 個位元組。如果省略參數、 ``None`` 或負數，則讀取並回傳資料，"
"直到到達 EOF。如果流已經在 EOF，則回傳一個空的 bytes 物件。"

#: ../../library/io.rst:570
#, fuzzy
msgid ""
"If the argument is positive, and the underlying raw stream is not "
"interactive, multiple raw reads may be issued to satisfy the byte count "
"(unless EOF is reached first).  But for interactive raw streams, at most one "
"raw read will be issued, and a short result does not imply that EOF is "
"imminent."
msgstr ""
"如果參數為正，並且底層原始流不是交互式的，則可能會發出多個原始讀取以滿足位元"
"組數（除非首先達到 EOF）。但對於交互式原始流，最多會發出一次原始讀取，"
"一個簡短的結果並不意味著 EOF 即將到來。"

#: ../../library/io.rst:576 ../../library/io.rst:599 ../../library/io.rst:609
#, fuzzy
msgid ""
"A :exc:`BlockingIOError` is raised if the underlying raw stream is in non "
"blocking-mode, and has no data available at the moment."
msgstr "如果底層原始流處於非阻塞模式並且目前沒有可用資料，則會引發 BlockingIOError。"

#: ../../library/io.rst:581
#, fuzzy
msgid ""
"Read and return up to *size* bytes, with at most one call to the underlying "
"raw stream's :meth:`~RawIOBase.read` (or :meth:`~RawIOBase.readinto`) "
"method.  This can be useful if you are implementing your own buffering on "
"top of a :class:`BufferedIOBase` object."
msgstr ""
"讀取並回傳最多 *size* 個位元組，最多呼叫一次底層原始流的 :meth:`~RawIOBase."
"read`（或 :meth:`~RawIOBase.readinto`）方法。如果您在 BufferedIOBase "
"物件之上實作自己的緩衝，這將很有用。"

#: ../../library/io.rst:587
#, fuzzy
msgid ""
"If *size* is ``-1`` (the default), an arbitrary number of bytes are returned "
"(more than zero unless EOF is reached)."
msgstr "如果 *size* 為 ``-1``（預設值），則回傳任意數量的位元組（除非達到 "
"EOF，否則大於零）。"

#: ../../library/io.rst:592
#, fuzzy
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b* and "
"return the number of bytes read. For example, *b* might be a :class:"
"`bytearray`."
msgstr ""
"將位元組讀入一個預先分配的、可寫的 :term:`bytes-like object` *b* "
"並回傳讀取的位元組數。例如，*b* 可能是一個 :class:`bytearray`。"

#: ../../library/io.rst:596
#, fuzzy
msgid ""
"Like :meth:`read`, multiple reads may be issued to the underlying raw "
"stream, unless the latter is interactive."
msgstr "像 :meth:`read` 一樣，可能會向底層原始流發出多次讀取，除非後者是交互式的。"

#: ../../library/io.rst:604
#, fuzzy
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b*, "
"using at most one call to the underlying raw stream's :meth:`~RawIOBase."
"read` (or :meth:`~RawIOBase.readinto`) method. Return the number of bytes "
"read."
msgstr ""
"將位元組讀入一個預先分配的、可寫的類似位元組的物件*b*，最多使用一次呼叫底層原"
"始流的 :meth:`~RawIOBase.read`（或 :meth:`~RawIOBase.read）。讀入`) "
"方法。回傳讀取的位元組數。"

#: ../../library/io.rst:616
#, fuzzy
msgid ""
"Write the given :term:`bytes-like object`, *b*, and return the number of "
"bytes written (always equal to the length of *b* in bytes, since if the "
"write fails an :exc:`OSError` will be raised).  Depending on the actual "
"implementation, these bytes may be readily written to the underlying stream, "
"or held in a buffer for performance and latency reasons."
msgstr ""
"寫入給定的 :term:`bytes-like object` *b*，並回傳寫入的位元組數（始終等於 *b* "
"的長度，以位元組為單位，因為如果寫入失敗，則會出現 OSError被提高）。根據實際"
"實作，這些位元組可能很容易寫入底層流，或出於性能和延遲原因保存在緩衝區中。"

#: ../../library/io.rst:623
#, fuzzy
msgid ""
"When in non-blocking mode, a :exc:`BlockingIOError` is raised if the data "
"needed to be written to the raw stream but it couldn't accept all the data "
"without blocking."
msgstr "在非阻塞模式下，如果需要將資料寫入原始流但無法在不阻塞的情況下接受所有資料，"
"則會引發 BlockingIOError。"

#: ../../library/io.rst:627
#, fuzzy
msgid ""
"The caller may release or mutate *b* after this method returns, so the "
"implementation should only access *b* during the method call."
msgstr "呼叫者可以在此方法回傳後釋放或改變 *b*，因此實作應僅在方法呼叫期間訪問 *b*。"

#: ../../library/io.rst:632
#, fuzzy
msgid "Raw File I/O"
msgstr "原始文件 I/O"

#: ../../library/io.rst:636
#, fuzzy
msgid ""
"A raw binary stream representing an OS-level file containing bytes data.  It "
"inherits :class:`RawIOBase`."
msgstr "表示包含位元組資料的操作系統級文件的原始二進位流。它繼承了 :class:`RawIOBase`"
"。"

#: ../../library/io.rst:639
#, fuzzy
msgid "The *name* can be one of two things:"
msgstr "*名稱* 可以是以下兩種情況之一："

#: ../../library/io.rst:641
#, fuzzy
msgid ""
"a character string or :class:`bytes` object representing the path to the "
"file which will be opened. In this case closefd must be ``True`` (the "
"default) otherwise an error will be raised."
msgstr "一個字串或 bytes 物件，代表將要打開的文件的路徑。在這種情況下，closefd "
"必須為 ``True``（預設值），否則將引發錯誤。"

#: ../../library/io.rst:644
#, fuzzy
msgid ""
"an integer representing the number of an existing OS-level file descriptor "
"to which the resulting :class:`FileIO` object will give access. When the "
"FileIO object is closed this fd will be closed as well, unless *closefd* is "
"set to ``False``."
msgstr ""
"一個整數，表示生成的 FileIO "
"物件將授予訪問權限的現有操作系統級文件描述器的數量。當 FileIO 物件關閉時，此 "
"fd 也將關閉，除非 *closefd* 設定為 ``False``。"

#: ../../library/io.rst:649
#, fuzzy
msgid ""
"The *mode* can be ``'r'``, ``'w'``, ``'x'`` or ``'a'`` for reading "
"(default), writing, exclusive creation or appending. The file will be "
"created if it doesn't exist when opened for writing or appending; it will be "
"truncated when opened for writing. :exc:`FileExistsError` will be raised if "
"it already exists when opened for creating. Opening a file for creating "
"implies writing, so this mode behaves in a similar way to ``'w'``. Add a "
"``'+'`` to the mode to allow simultaneous reading and writing."
msgstr ""
"*mode* 可以是 ``'r'``、``'w'``、``'x'`` 或 ``'a'`` 用於讀取（預設）、寫入、獨"
"占建立或追加。如果文件不存在，則在打開進行寫入或追加時建立該文件；打開寫入時"
"它將被截斷。 :exc:`FileExistsError` 如果在打開建立時已經存在，將被引發。打開"
"文件進行建立意味著寫入，因此此模式的行為方式與 ``'w'`` 類似。在模式中新增一個``'+"
"'`` 以允許同時讀取和寫入。"

#: ../../library/io.rst:657
#, fuzzy
msgid ""
"The :meth:`read` (when called with a positive argument), :meth:`readinto` "
"and :meth:`write` methods on this class will only make one system call."
msgstr ""
"此類的 :meth:`read`（當使用正參數呼叫時）、:meth:`readinto` 和 :meth:`write` "
"方法只會進行一次系統呼叫。"

#: ../../library/io.rst:660
#, fuzzy
msgid ""
"A custom opener can be used by passing a callable as *opener*. The "
"underlying file descriptor for the file object is then obtained by calling "
"*opener* with (*name*, *flags*). *opener* must return an open file "
"descriptor (passing :mod:`os.open` as *opener* results in functionality "
"similar to passing ``None``)."
msgstr ""
"可以通過將可呼叫對像作為 *opener* 傳遞來使用自定義開啟器。然後通過使用 "
"(*name*, *flags*) 呼叫 *opener* 來獲取文件物件的底層文件描述器。 *opener* "
"必須回傳一個打開的文件描述器（傳遞 :mod:`os.open` 作為 *opener* "
"結果類似於傳遞 ``None`` 的功能）。"

#: ../../library/io.rst:666
#, fuzzy
msgid "The newly created file is :ref:`non-inheritable <fd_inheritance>`."
msgstr "新建立的文件是 :ref:`non-inheritable <fd_inheritance>`。"

#: ../../library/io.rst:668
#, fuzzy
msgid ""
"See the :func:`open` built-in function for examples on using the *opener* "
"parameter."
msgstr "有關使用 *opener* 參數的示例，請參閱 :func:`open` 內建函式。"

#: ../../library/io.rst:671
#, fuzzy
msgid "The *opener* parameter was added. The ``'x'`` mode was added."
msgstr "新增了 *opener* 參數。新增了``'x'`` 模式。"

#: ../../library/io.rst:675
#, fuzzy
msgid "The file is now non-inheritable."
msgstr "該文件現在不可繼承。"

#: ../../library/io.rst:678
#, fuzzy
msgid ""
":class:`FileIO` provides these data attributes in addition to those from :"
"class:`RawIOBase` and :class:`IOBase`:"
msgstr ""
":class:`FileIO` 除了來自 :class:`RawIOBase` 和 :class:`IOBase` "
"的資料屬性外，還提供了這些資料屬性："

#: ../../library/io.rst:683
#, fuzzy
msgid "The mode as given in the constructor."
msgstr "構造函式中給定的模式。"

#: ../../library/io.rst:687
#, fuzzy
msgid ""
"The file name.  This is the file descriptor of the file when no name is "
"given in the constructor."
msgstr "文件名。當構造函式中沒有給出名稱時，這是文件的文件描述器。"

#: ../../library/io.rst:692
#, fuzzy
msgid "Buffered Streams"
msgstr "緩衝流"

#: ../../library/io.rst:694
#, fuzzy
msgid ""
"Buffered I/O streams provide a higher-level interface to an I/O device than "
"raw I/O does."
msgstr "緩衝 I/O 流為 I/O 設備提供比原始 I/O 更高階別的介面。"

#: ../../library/io.rst:699
#, fuzzy
msgid ""
"A binary stream using an in-memory bytes buffer.  It inherits :class:"
"`BufferedIOBase`.  The buffer is discarded when the :meth:`~IOBase.close` "
"method is called."
msgstr ""
"使用記憶體中位元組緩衝區的二進位流。它繼承了 :class:`BufferedIOBase`。當呼叫 "
":meth:`~IOBase.close` 方法時，緩衝區被丟棄。"

#: ../../library/io.rst:703
#, fuzzy
msgid ""
"The optional argument *initial_bytes* is a :term:`bytes-like object` that "
"contains initial data."
msgstr "可選參數 *initial_bytes* 是一個包含初始資料的類似位元組的物件。"

#: ../../library/io.rst:706
#, fuzzy
msgid ""
":class:`BytesIO` provides or overrides these methods in addition to those "
"from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ":class:`BufferedIOBase` 和 :class:`IOBase` 中的方法之外，BytesIO "
"還提供或覆蓋這些方法："

#: ../../library/io.rst:711
#, fuzzy
msgid ""
"Return a readable and writable view over the contents of the buffer without "
"copying them.  Also, mutating the view will transparently update the "
"contents of the buffer::"
msgstr "回傳緩衝區內容的可讀和可寫視圖，而不復制它們。此外，改變視圖將透明地更新緩衝"
"區的內容::"

#: ../../library/io.rst:722
#, fuzzy
msgid ""
"As long as the view exists, the :class:`BytesIO` object cannot be resized or "
"closed."
msgstr "只要視圖存在，BytesIO 物件就不能調整大小或關閉。"

#: ../../library/io.rst:729
#, fuzzy
msgid "Return :class:`bytes` containing the entire contents of the buffer."
msgstr "回傳包含緩衝區全部內容的 :class:`bytes`。"

#: ../../library/io.rst:734
#, fuzzy
msgid "In :class:`BytesIO`, this is the same as :meth:`~BufferedIOBase.read`."
msgstr "在 :class:`BytesIO` 中，這與 :meth:`~BufferedIOBase.read` 相同。"

#: ../../library/io.rst:736 ../../library/io.rst:779
#, fuzzy
msgid "The *size* argument is now optional."
msgstr "*size* 參數現在是可選的。"

#: ../../library/io.rst:741
#, fuzzy
msgid ""
"In :class:`BytesIO`, this is the same as :meth:`~BufferedIOBase.readinto`."
msgstr "在 :class:`BytesIO` 中，這與 :meth:`~BufferedIOBase.readinto` 相同。"

#: ../../library/io.rst:747
#, fuzzy
msgid ""
"A buffered binary stream providing higher-level access to a readable, non "
"seekable :class:`RawIOBase` raw binary stream.  It inherits :class:"
"`BufferedIOBase`."
msgstr ""
"一種緩衝二進位流，提供對可讀、不可搜索的 RawIOBase "
"原始二進位流的更高階別訪問。它繼承了 :class:`BufferedIOBase`。"

#: ../../library/io.rst:751
#, fuzzy
msgid ""
"When reading data from this object, a larger amount of data may be requested "
"from the underlying raw stream, and kept in an internal buffer. The buffered "
"data can then be returned directly on subsequent reads."
msgstr "從該物件讀取資料時，可能會從底層原始流中請求大量資料，並將其保存在內部緩衝區"
"中。然後可以在後續讀取時直接回傳緩衝的資料。"

#: ../../library/io.rst:755
#, fuzzy
msgid ""
"The constructor creates a :class:`BufferedReader` for the given readable "
"*raw* stream and *buffer_size*.  If *buffer_size* is omitted, :data:"
"`DEFAULT_BUFFER_SIZE` is used."
msgstr ""
"構造函式為給定的可讀 *raw* 流和 *buffer_size* 建立一個 BufferedReader。"
"如果省略 *buffer_size*，則使用 :data:`DEFAULT_BUFFER_SIZE`。"

#: ../../library/io.rst:759
#, fuzzy
msgid ""
":class:`BufferedReader` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr "除了 BufferedIOBase 和 IOBase 中的方法之外，BufferedReader "
"還提供或覆蓋了這些方法："

#: ../../library/io.rst:764
#, fuzzy
msgid ""
"Return bytes from the stream without advancing the position.  At most one "
"single read on the raw stream is done to satisfy the call. The number of "
"bytes returned may be less or more than requested."
msgstr "從流中回傳位元組而不推進位置。最多完成一次對原始流的讀取以滿足呼叫。回傳的位"
"元組數可能比請求的少或多。"

#: ../../library/io.rst:770
#, fuzzy
msgid ""
"Read and return *size* bytes, or if *size* is not given or negative, until "
"EOF or if the read call would block in non-blocking mode."
msgstr "讀取並回傳 *size* 位元組，或者如果 *size* 未給出或為負數，直到 EOF "
"或讀取呼叫將在非阻塞模式下阻塞。"

#: ../../library/io.rst:775
#, fuzzy
msgid ""
"Read and return up to *size* bytes with only one call on the raw stream. If "
"at least one byte is buffered, only buffered bytes are returned. Otherwise, "
"one raw stream read call is made."
msgstr ""
"只需對原始流呼叫一次，即可讀取並回傳最多 *size* 個位元組。如果至少緩衝了一個"
"位元組，則只回傳緩衝的位元組。否則，進行一次原始流讀取呼叫。"

#: ../../library/io.rst:785
#, fuzzy
msgid ""
"A buffered binary stream providing higher-level access to a writeable, non "
"seekable :class:`RawIOBase` raw binary stream.  It inherits :class:"
"`BufferedIOBase`."
msgstr ""
"一種緩衝的二進位流，提供對可寫的、不可搜索的 :class:`RawIOBase` "
"原始二進位流的更高階別訪問。它繼承了 :class:`BufferedIOBase`。"

#: ../../library/io.rst:789
#, fuzzy
msgid ""
"When writing to this object, data is normally placed into an internal "
"buffer.  The buffer will be written out to the underlying :class:`RawIOBase` "
"object under various conditions, including:"
msgstr "寫入此物件時，資料通常會放入內部緩衝區。緩衝區將在各種條件下寫出到底層 "
":class:`RawIOBase` 物件，包括："

#: ../../library/io.rst:793
#, fuzzy
msgid "when the buffer gets too small for all pending data;"
msgstr "當緩衝區對於所有未決資料來說太小時；"

#: ../../library/io.rst:794
#, fuzzy
msgid "when :meth:`flush()` is called;"
msgstr "當 :meth:`flush()` 被呼叫時；"

#: ../../library/io.rst:795
#, fuzzy
msgid ""
"when a :meth:`seek()` is requested (for :class:`BufferedRandom` objects);"
msgstr "當請求 seek() 時（對於 BufferedRandom 物件）；"

#: ../../library/io.rst:796
#, fuzzy
msgid "when the :class:`BufferedWriter` object is closed or destroyed."
msgstr "當 BufferedWriter 物件關閉或銷毀時。"

#: ../../library/io.rst:798
#, fuzzy
msgid ""
"The constructor creates a :class:`BufferedWriter` for the given writeable "
"*raw* stream.  If the *buffer_size* is not given, it defaults to :data:"
"`DEFAULT_BUFFER_SIZE`."
msgstr ""
"構造函式為給定的可寫 *raw* 流建立一個 BufferedWriter。如果未給出 "
"*buffer_size*，則預設為 :data:`DEFAULT_BUFFER_SIZE`。"

#: ../../library/io.rst:802
#, fuzzy
msgid ""
":class:`BufferedWriter` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr "除了 BufferedIOBase 和 IOBase 中的方法之外，BufferedWriter "
"還提供或覆蓋了這些方法："

#: ../../library/io.rst:807
#, fuzzy
msgid ""
"Force bytes held in the buffer into the raw stream.  A :exc:"
"`BlockingIOError` should be raised if the raw stream blocks."
msgstr "將緩衝區中保存的位元組強制放入原始流中。如果原始流阻塞，則應引發 "
":exc:`BlockingIOError`。"

#: ../../library/io.rst:812
#, fuzzy
msgid ""
"Write the :term:`bytes-like object`, *b*, and return the number of bytes "
"written.  When in non-blocking mode, a :exc:`BlockingIOError` is raised if "
"the buffer needs to be written out but the raw stream blocks."
msgstr ""
"寫入 :term:`bytes-like object`，*b*，並回傳寫入的位元組數。在非阻塞模式下，如"
"果需要寫出緩衝區但原始流阻塞，則會引發 BlockingIOError。"

#: ../../library/io.rst:820
#, fuzzy
msgid ""
"A buffered binary stream providing higher-level access to a seekable :class:"
"`RawIOBase` raw binary stream.  It inherits :class:`BufferedReader` and :"
"class:`BufferedWriter`."
msgstr ""
"一種緩衝二進位流，提供對可搜索 RawIOBase 原始二進位流的更高階別訪問。"
"它繼承了 BufferedReader 和 BufferedWriter。"

#: ../../library/io.rst:824
#, fuzzy
msgid ""
"The constructor creates a reader and writer for a seekable raw stream, given "
"in the first argument.  If the *buffer_size* is omitted it defaults to :data:"
"`DEFAULT_BUFFER_SIZE`."
msgstr ""
"構造函式為第一個參數中給出的可搜索原始流建立讀取器和寫入器。如果 "
"*buffer_size* 被省略，它預設為 :data:`DEFAULT_BUFFER_SIZE`。"

#: ../../library/io.rst:828
#, fuzzy
msgid ""
":class:`BufferedRandom` is capable of anything :class:`BufferedReader` or :"
"class:`BufferedWriter` can do.  In addition, :meth:`seek` and :meth:`tell` "
"are guaranteed to be implemented."
msgstr ""
":class:`BufferedRandom` 可以做任何 :class:`BufferedReader` 或 "
":class:`BufferedWriter` 可以做的事情。此外，:meth:`seek` 和 :meth:`tell` "
"保證被實作。"

#: ../../library/io.rst:835
#, fuzzy
msgid ""
"A buffered binary stream providing higher-level access to two non seekable :"
"class:`RawIOBase` raw binary streams---one readable, the other writeable. It "
"inherits :class:`BufferedIOBase`."
msgstr ""
"一種緩衝二進位流，提供對兩個不可搜索的 :class:`RawIOBase` 原始二進位流的更高"
"級別訪問——一個可讀，另一個可寫。它繼承了 :class:`BufferedIOBase`。"

#: ../../library/io.rst:839
#, fuzzy
msgid ""
"*reader* and *writer* are :class:`RawIOBase` objects that are readable and "
"writeable respectively.  If the *buffer_size* is omitted it defaults to :"
"data:`DEFAULT_BUFFER_SIZE`."
msgstr ""
"*reader* 和 *writer* 是 :class:`RawIOBase` 物件，分別是可讀和可寫的。如果 "
"*buffer_size* 被省略，它預設為 :data:`DEFAULT_BUFFER_SIZE`。"

#: ../../library/io.rst:843
#, fuzzy
msgid ""
":class:`BufferedRWPair` implements all of :class:`BufferedIOBase`\\'s "
"methods except for :meth:`~BufferedIOBase.detach`, which raises :exc:"
"`UnsupportedOperation`."
msgstr ""
":class:`BufferedRWPair` 實作了所有 :class:`BufferedIOBase`\\ 的方法，但 "
":meth:`~BufferedIOBase.detach` 除外，後者會引發 :exc:`UnsupportedOperation`。"

#: ../../library/io.rst:849
#, fuzzy
msgid ""
":class:`BufferedRWPair` does not attempt to synchronize accesses to its "
"underlying raw streams.  You should not pass it the same object as reader "
"and writer; use :class:`BufferedRandom` instead."
msgstr ""
"BufferedRWPair 不會嘗試同步對其底層原始流的訪問。你不應該傳遞給它與讀者和作家"
"相同的物件；使用 :class:`BufferedRandom` 代替。"

#: ../../library/io.rst:859
#, fuzzy
msgid ""
"Base class for text streams.  This class provides a character and line based "
"interface to stream I/O.  It inherits :class:`IOBase`."
msgstr "文本流的基底類別。此類為流式 I/O 提供基於字元和行的介面。它繼承了 "
":class:`IOBase`。"

#: ../../library/io.rst:862
#, fuzzy
msgid ""
":class:`TextIOBase` provides or overrides these data attributes and methods "
"in addition to those from :class:`IOBase`:"
msgstr ":class:`TextIOBase` 除了來自 :class:`IOBase` "
"的資料屬性和方法外，還提供或覆蓋這些資料屬性和方法："

#: ../../library/io.rst:867
#, fuzzy
msgid ""
"The name of the encoding used to decode the stream's bytes into strings, and "
"to encode strings into bytes."
msgstr "用於將流的位元組解碼為字串以及將字串編碼為位元組的編碼名稱。"

#: ../../library/io.rst:872
#, fuzzy
msgid "The error setting of the decoder or encoder."
msgstr "解碼器或編碼器的錯誤設定。"

#: ../../library/io.rst:876
#, fuzzy
msgid ""
"A string, a tuple of strings, or ``None``, indicating the newlines "
"translated so far.  Depending on the implementation and the initial "
"constructor flags, this may not be available."
msgstr "一個字串，一個字串元組，或者 ``None`` ，表示到目前為止翻譯的換行符。根據實作和初始"
"構造函式旗標，這可能不可用。"

#: ../../library/io.rst:882
#, fuzzy
msgid ""
"The underlying binary buffer (a :class:`BufferedIOBase` instance) that :"
"class:`TextIOBase` deals with.  This is not part of the :class:`TextIOBase` "
"API and may not exist in some implementations."
msgstr ""
"TextIOBase 處理的底層二進位緩衝區（一個 BufferedIOBase 實例）。這不是 "
"TextIOBase API 的一部分，在某些實作中可能不存在。"

#: ../../library/io.rst:888
#, fuzzy
msgid ""
"Separate the underlying binary buffer from the :class:`TextIOBase` and "
"return it."
msgstr "將底層二進位緩衝區與 TextIOBase 分開並回傳它。"

#: ../../library/io.rst:891
#, fuzzy
msgid ""
"After the underlying buffer has been detached, the :class:`TextIOBase` is in "
"an unusable state."
msgstr "底層緩衝區分離後，TextIOBase 處於不可用狀態。"

#: ../../library/io.rst:894
#, fuzzy
msgid ""
"Some :class:`TextIOBase` implementations, like :class:`StringIO`, may not "
"have the concept of an underlying buffer and calling this method will raise :"
"exc:`UnsupportedOperation`."
msgstr "一些 TextIOBase 實作，如 StringIO，可能沒有底層緩衝區的概念，"
"呼叫此方法將引發 UnsupportedOperation。"

#: ../../library/io.rst:902
#, fuzzy
msgid ""
"Read and return at most *size* characters from the stream as a single :class:"
"`str`.  If *size* is negative or ``None``, reads until EOF."
msgstr "從流中讀取並回傳最多 *size* 個字元作為單個 :class:`str`。如果 *size* "
"為負數或 ``None`` ，則讀取直到 EOF。"

#: ../../library/io.rst:907
#, fuzzy
msgid ""
"Read until newline or EOF and return a single ``str``.  If the stream is "
"already at EOF, an empty string is returned."
msgstr "閱讀直到換行符或 EOF 並回傳單個 ``str``。如果流已經在 EOF，則回傳一個空字串。"

#: ../../library/io.rst:910
#, fuzzy
msgid "If *size* is specified, at most *size* characters will be read."
msgstr "如果指定了 *size*，則最多讀取 *size* 個字元。"

#: ../../library/io.rst:914
#, fuzzy
msgid ""
"Change the stream position to the given *offset*.  Behaviour depends on the "
"*whence* parameter.  The default value for *whence* is :data:`SEEK_SET`."
msgstr "將流位置更改為給定的 *offset*。行為取決於 *whence* 參數。 *whence* "
"的預設值是 :data:`SEEK_SET`。"

#: ../../library/io.rst:918
#, fuzzy
msgid ""
":data:`SEEK_SET` or ``0``: seek from the start of the stream (the default); "
"*offset* must either be a number returned by :meth:`TextIOBase.tell`, or "
"zero.  Any other *offset* value produces undefined behaviour."
msgstr ""
":data:`SEEK_SET` 或 ``0``：從流的開頭查找（預設）； *offset* 必須是 "
"TextIOBase.tell 回傳的數字，或者是零。任何其他 *offset* "
"值都會產生未定義的行為。"

#: ../../library/io.rst:922
#, fuzzy
msgid ""
":data:`SEEK_CUR` or ``1``: \"seek\" to the current position; *offset* must "
"be zero, which is a no-operation (all other values are unsupported)."
msgstr ":data:`SEEK_CUR` 或 ``1``：“搜索”到當前位置； *offset* "
"必須為零，這是一個空操作（不支援所有其他值）。"

#: ../../library/io.rst:925
#, fuzzy
msgid ""
":data:`SEEK_END` or ``2``: seek to the end of the stream; *offset* must be "
"zero (all other values are unsupported)."
msgstr ":data:`SEEK_END` 或 ``2``：尋找到流的末尾； *offset* "
"必須為零（不支援所有其他值）。"

#: ../../library/io.rst:928
#, fuzzy
msgid "Return the new absolute position as an opaque number."
msgstr "將新的絕對位置作為不透明數字回傳。"

#: ../../library/io.rst:935
#, fuzzy
msgid ""
"Return the current stream position as an opaque number.  The number does not "
"usually represent a number of bytes in the underlying binary storage."
msgstr "將當前流位置作為不透明數字回傳。該數字通常不代表底層二進位儲存中的位元組數。"

#: ../../library/io.rst:941
#, fuzzy
msgid ""
"Write the string *s* to the stream and return the number of characters "
"written."
msgstr "將字串 *s* 寫入流並回傳寫入的字元數。"

#: ../../library/io.rst:948
#, fuzzy
msgid ""
"A buffered text stream providing higher-level access to a :class:"
"`BufferedIOBase` buffered binary stream.  It inherits :class:`TextIOBase`."
msgstr "緩衝文本流提供對 BufferedIOBase 緩衝二進位流的更高階別訪問。它繼承了 "
":class:`TextIOBase`。"

#: ../../library/io.rst:952
#, fuzzy
msgid ""
"*encoding* gives the name of the encoding that the stream will be decoded or "
"encoded with.  It defaults to :func:`locale.getencoding()`. "
"``encoding=\"locale\"`` can be used to specify the current locale's encoding "
"explicitly. See :ref:`io-text-encoding` for more information."
msgstr ""
"*encoding* 給出流將被解碼或編碼的編碼名稱。它預設為 :func:`locale."
"getencoding()`。 ``encoding=\"locale\"`` "
"可用於明確指定當前語言環境的編碼。有關詳細資訊，請參閱 :ref:`io-text-"
"encoding`。"

#: ../../library/io.rst:957
#, fuzzy
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled.  Pass ``'strict'`` to raise a :exc:`ValueError` "
"exception if there is an encoding error (the default of ``None`` has the "
"same effect), or pass ``'ignore'`` to ignore errors.  (Note that ignoring "
"encoding errors can lead to data loss.)  ``'replace'`` causes a replacement "
"marker (such as ``'?'``) to be inserted where there is malformed data. "
"``'backslashreplace'`` causes malformed data to be replaced by a backslashed "
"escape sequence.  When writing, ``'xmlcharrefreplace'`` (replace with the "
"appropriate XML character reference)  or ``'namereplace'`` (replace with "
"``\\N{...}`` escape sequences) can be used.  Any other error handling name "
"that has been registered with :func:`codecs.register_error` is also valid."
msgstr ""
"*errors* 是一個可選字串，指定如何處理編碼和解碼錯誤。如果存在編碼錯誤，"
"則傳遞 ``'strict'`` 以引發 :exc:`ValueError` 例外（預設的 ``None`` "
"具有相同的效果），或傳遞 ``'ignore'`` 以忽略錯誤。 "
"（請注意，忽略編碼錯誤會導致資料丟失。）``'replace'`` "
"會導致在存在格式錯誤的資料處插入替換標記（例如 ``'?'``）。 "
"``'backslashreplace'`` 導致格式錯誤的資料被反斜杠轉義序列替換。寫入時，可以使"
"用``'xmlcharrefreplace'``（替換為適當的XML字元引用）或``'namereplace'``（替換"
"為``\\N{...}``轉義序列）。已在 :func:`codecs.register_error` "
"註冊的任何其他錯誤處理名稱也是有效的。"

#: ../../library/io.rst:973
#, fuzzy
msgid ""
"*newline* controls how line endings are handled.  It can be ``None``, "
"``''``, ``'\\n'``, ``'\\r'``, and ``'\\r\\n'``.  It works as follows:"
msgstr ""
"*newline* 控制如何處理行尾。它可以是``無``、``''``、``'\\n"
"'``、``'\\r'`` 和``'\\r\\n"
"'``。它的工作原理如下："

#: ../../library/io.rst:976
#, fuzzy
msgid ""
"When reading input from the stream, if *newline* is ``None``, :term:"
"`universal newlines` mode is enabled.  Lines in the input can end in "
"``'\\n'``, ``'\\r'``, or ``'\\r\\n'``, and these are translated into "
"``'\\n'`` before being returned to the caller.  If *newline* is ``''``, "
"universal newlines mode is enabled, but line endings are returned to the "
"caller untranslated.  If *newline* has any of the other legal values, input "
"lines are only terminated by the given string, and the line ending is "
"returned to the caller untranslated."
msgstr ""
"從流中讀取輸入時，如果 *newline* 為 ``None``，則啟用 :term:`universal "
"newlines` 模式。輸入中的行可以以 ``'\\n"
"'``、``'\\r'`` 或 ``'\\r\\n"
"'`` 結尾，這些被翻譯成 ``'\\n"
"'``在回傳給呼叫者之前。如果 *newline* 是 "
"``''``，則啟用通用換行模式，但行尾未翻譯回傳給呼叫者。如果 *newline* 具有任何"
"其他合法值，則輸入行僅由給定字串終止，並且行結尾未翻譯地回傳給呼叫者。"

#: ../../library/io.rst:985
#, fuzzy
msgid ""
"When writing output to the stream, if *newline* is ``None``, any ``'\\n'`` "
"characters written are translated to the system default line separator, :"
"data:`os.linesep`.  If *newline* is ``''`` or ``'\\n'``, no translation "
"takes place.  If *newline* is any of the other legal values, any ``'\\n'`` "
"characters written are translated to the given string."
msgstr ""
"將輸出寫入流時，如果 *newline* 為 ``None``，則寫入的任何 ``'\\n"
"'`` 字元都將轉換為系統預設行分隔符 :data:`os.linesep`。如果 *newline* 是 "
"``''`` 或 ``'\\n"
"'``，則不會進行任何轉換。如果 *newline* 是任何其他合法值，則寫入的任何 ``'\\n"
"'`` 字元都將轉換為給定的字串。"

#: ../../library/io.rst:991
#, fuzzy
msgid ""
"If *line_buffering* is ``True``, :meth:`flush` is implied when a call to "
"write contains a newline character or a carriage return."
msgstr ""
"如果 *line_buffering* 為 ``True``，則當對 write 的呼叫包含換行符或回車符時，"
"隱含 :meth:`flush`。"

#: ../../library/io.rst:994
#, fuzzy
msgid ""
"If *write_through* is ``True``, calls to :meth:`write` are guaranteed not to "
"be buffered: any data written on the :class:`TextIOWrapper` object is "
"immediately handled to its underlying binary *buffer*."
msgstr ""
"如果 *write_through* 為 ``True``，則保證不會緩衝對 :meth:`write` 的呼叫："
"寫入 TextIOWrapper 物件的任何資料都會立即處理到其底層二進位 *buffer*。"

#: ../../library/io.rst:998
#, fuzzy
msgid "The *write_through* argument has been added."
msgstr "新增了 *write_through* 參數。"

#: ../../library/io.rst:1001
#, fuzzy
msgid ""
"The default *encoding* is now ``locale.getpreferredencoding(False)`` instead "
"of ``locale.getpreferredencoding()``. Don't change temporary the locale "
"encoding using :func:`locale.setlocale`, use the current locale encoding "
"instead of the user preferred encoding."
msgstr ""
"預設*編碼*現在是``locale.getpreferredencoding(False)`` 而不是``locale."
"getpreferredencoding()``。不要使用 :func:`locale.setlocale` "
"臨時更改語言環境編碼，使用當前語言環境編碼而不是使用者首選編碼。"

#: ../../library/io.rst:1007
#, fuzzy
msgid ""
"The *encoding* argument now supports the ``\"locale\"`` dummy encoding name."
msgstr "*encoding* 參數現在支援 ``\"locale\"`` 虛擬編碼名稱。"

#: ../../library/io.rst:1010
#, fuzzy
msgid ""
":class:`TextIOWrapper` provides these data attributes and methods in "
"addition to those from :class:`TextIOBase` and :class:`IOBase`:"
msgstr "TextIOWrapper 除了 TextIOBase 和 IOBase "
"中的資料屬性和方法外，還提供了這些資料屬性和方法："

#: ../../library/io.rst:1015
#, fuzzy
msgid "Whether line buffering is enabled."
msgstr "是否啟用行緩衝。"

#: ../../library/io.rst:1019
#, fuzzy
msgid "Whether writes are passed immediately to the underlying binary buffer."
msgstr "寫入是否立即傳遞到底層二進位緩衝區。"

#: ../../library/io.rst:1027
#, fuzzy
msgid ""
"Reconfigure this text stream using new settings for *encoding*, *errors*, "
"*newline*, *line_buffering* and *write_through*."
msgstr ""
"使用 *encoding*、*errors*、*newline*、*line_buffering* 和 *write_through* "
"的新設定重新配置此文本流。"

#: ../../library/io.rst:1030
#, fuzzy
msgid ""
"Parameters not specified keep current settings, except ``errors='strict'`` "
"is used when *encoding* is specified but *errors* is not specified."
msgstr "未指定的參數保留當前設定，除了在指定 *encoding* 但未指定 *errors* 時使用 "
"``errors='strict'``。"

#: ../../library/io.rst:1034
#, fuzzy
msgid ""
"It is not possible to change the encoding or newline if some data has "
"already been read from the stream. On the other hand, changing encoding "
"after write is possible."
msgstr "如果已經從流中讀取了一些資料，則無法更改編碼或換行符。另一方面，可以在寫入後"
"更改編碼。"

#: ../../library/io.rst:1038
#, fuzzy
msgid ""
"This method does an implicit stream flush before setting the new parameters."
msgstr "此方法在設定新參數之前執行隱式流刷新。"

#: ../../library/io.rst:1043
#, fuzzy
msgid "The method supports ``encoding=\"locale\"`` option."
msgstr "該方法支援 ``encoding=\"locale\"`` 選項。"

#: ../../library/io.rst:1049
#, fuzzy
msgid ""
"A text stream using an in-memory text buffer.  It inherits :class:"
"`TextIOBase`."
msgstr "使用記憶體中文本緩衝區的文本流。它繼承了 :class:`TextIOBase`。"

#: ../../library/io.rst:1052
#, fuzzy
msgid ""
"The text buffer is discarded when the :meth:`~IOBase.close` method is called."
msgstr "當呼叫 :meth:`~IOBase.close` 方法時，文本緩衝區被丟棄。"

#: ../../library/io.rst:1055
#, fuzzy
msgid ""
"The initial value of the buffer can be set by providing *initial_value*. If "
"newline translation is enabled, newlines will be encoded as if by :meth:"
"`~TextIOBase.write`.  The stream is positioned at the start of the buffer "
"which emulates opening an existing file in a ``w+`` mode, making it ready "
"for an immediate write from the beginning or for a write that would "
"overwrite the initial value.  To emulate opening a file in an ``a+`` mode "
"ready for appending, use ``f.seek(0, io.SEEK_END)`` to reposition the stream "
"at the end of the buffer."
msgstr ""
"緩衝區的初始值可以通過提供 *initial_value* 來設定。如果啟用換行符轉換，"
"換行符將被編碼為 :meth:`~TextIOBase.write`。流位於緩衝區的開頭，緩衝區模擬以“"
"w+”模式打開現有文件，使其準備好從開頭立即寫入或覆蓋初始值的寫入。要模擬以準備"
"好追加的 ``a+``模式打開文件，請使用“f.seek(0, io."
"SEEK_END)”將流重新定位在緩衝區的末尾。"

#: ../../library/io.rst:1064
#, fuzzy
msgid ""
"The *newline* argument works like that of :class:`TextIOWrapper`, except "
"that when writing output to the stream, if *newline* is ``None``, newlines "
"are written as ``\\n`` on all platforms."
msgstr ""
"*newline* 參數的工作方式與 TextIOWrapper 的參數類似，只是在將輸出寫入流時，"
"如果 *newline* 為 ``None``，則換行符在所有平台上都寫為 ``\\n"
"``。"

#: ../../library/io.rst:1068
#, fuzzy
msgid ""
":class:`StringIO` provides this method in addition to those from :class:"
"`TextIOBase` and :class:`IOBase`:"
msgstr "除了 TextIOBase 和 IOBase 中的方法之外，StringIO 還提供了此方法："

#: ../../library/io.rst:1073
#, fuzzy
msgid ""
"Return a ``str`` containing the entire contents of the buffer. Newlines are "
"decoded as if by :meth:`~TextIOBase.read`, although the stream position is "
"not changed."
msgstr "回傳包含緩衝區全部內容的 ``str``。換行符就像被 :meth:`~TextIOBase.read` "
"解碼一樣，儘管流位置沒有改變。"

#: ../../library/io.rst:1077
msgid "Example usage::"
msgstr ""
"使用範例：\n"
"\n"
"::"

#: ../../library/io.rst:1099
#, fuzzy
msgid ""
"A helper codec that decodes newlines for :term:`universal newlines` mode. It "
"inherits :class:`codecs.IncrementalDecoder`."
msgstr ""
"一個輔助編解碼器，可以為 :term:`universal newlines` "
"模式解碼換行符。它繼承 :class:`codecs.IncrementalDecoder`。"

#: ../../library/io.rst:1104
#, fuzzy
msgid "Performance"
msgstr "表現"

#: ../../library/io.rst:1106
#, fuzzy
msgid ""
"This section discusses the performance of the provided concrete I/O "
"implementations."
msgstr "本節討論所提供的具體 I/O 實作的性能。"

#: ../../library/io.rst:1112
#, fuzzy
msgid ""
"By reading and writing only large chunks of data even when the user asks for "
"a single byte, buffered I/O hides any inefficiency in calling and executing "
"the operating system's unbuffered I/O routines.  The gain depends on the OS "
"and the kind of I/O which is performed.  For example, on some modern OSes "
"such as Linux, unbuffered disk I/O can be as fast as buffered I/O.  The "
"bottom line, however, is that buffered I/O offers predictable performance "
"regardless of the platform and the backing device.  Therefore, it is almost "
"always preferable to use buffered I/O rather than unbuffered I/O for binary "
"data."
msgstr ""
"通過只讀取和寫入大塊資料，即使當使用者請求單個位元組時，緩衝 I/O "
"隱藏了呼叫和執行操作系統的非緩衝 I/O 例程的任何低效率。"
"增益取決於操作系統和執行的 I/O 型別。例如，在某些現代操作系統（如 Linux）上，"
"無緩衝磁盤 I/O 可以與緩衝 I/O 一樣快。然而，底線是緩衝 I/O "
"提供可預測的性能，而不管平台和支援設備如何。因此，對於二進位資料，"
"幾乎總是使用緩衝 I/O 而不是非緩衝 I/O 更可取。"

#: ../../library/io.rst:1124
#, fuzzy
msgid ""
"Text I/O over a binary storage (such as a file) is significantly slower than "
"binary I/O over the same storage, because it requires conversions between "
"unicode and binary data using a character codec.  This can become noticeable "
"handling huge amounts of text data like large log files.  Also, :meth:"
"`TextIOWrapper.tell` and :meth:`TextIOWrapper.seek` are both quite slow due "
"to the reconstruction algorithm used."
msgstr ""
"二進位儲存（例如文件）上的文本 I/O 比同一儲存上的二進位 I/O 慢得多，"
"因為它需要使用字元編解碼器在 unicode 和二進位資料之間進行轉換。這在處理大量文"
"本資料（如大型日誌文件）時會變得很明顯。此外，由於使用了重建演算法，"
"TextIOWrapper.tell 和 TextIOWrapper.seek 都非常慢。"

#: ../../library/io.rst:1131
#, fuzzy
msgid ""
":class:`StringIO`, however, is a native in-memory unicode container and will "
"exhibit similar speed to :class:`BytesIO`."
msgstr "然而，StringIO 是一個原生的記憶體中 unicode 容器，其速度與 BytesIO 相似。"

#: ../../library/io.rst:1135
#, fuzzy
msgid "Multi-threading"
msgstr "多執行緒"

#: ../../library/io.rst:1137
#, fuzzy
msgid ""
":class:`FileIO` objects are thread-safe to the extent that the operating "
"system calls (such as ``read(2)`` under Unix) they wrap are thread-safe too."
msgstr ""
":class:`FileIO` 對像是執行緒安全的，因為它們包裝的操作系統呼叫（例如 Unix "
"下的 ``read(2)``）也是執行緒安全的。"

#: ../../library/io.rst:1140
#, fuzzy
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, :class:"
"`BufferedWriter`, :class:`BufferedRandom` and :class:`BufferedRWPair`) "
"protect their internal structures using a lock; it is therefore safe to call "
"them from multiple threads at once."
msgstr ""
"二進位緩衝物件（BufferedReader、BufferedWriter、BufferedRandom 和 "
"BufferedRWPair "
"的實例）使用鎖保護其內部結構；因此一次從多個執行緒呼叫它們是安全的。"

#: ../../library/io.rst:1145
#, fuzzy
msgid ":class:`TextIOWrapper` objects are not thread-safe."
msgstr ":class:`TextIOWrapper` 對像不是執行緒安全的。"

#: ../../library/io.rst:1148
#, fuzzy
msgid "Reentrancy"
msgstr "重入"

#: ../../library/io.rst:1150
#, fuzzy
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, :class:"
"`BufferedWriter`, :class:`BufferedRandom` and :class:`BufferedRWPair`) are "
"not reentrant.  While reentrant calls will not happen in normal situations, "
"they can arise from doing I/O in a :mod:`signal` handler.  If a thread tries "
"to re-enter a buffered object which it is already accessing, a :exc:"
"`RuntimeError` is raised.  Note this doesn't prohibit a different thread "
"from entering the buffered object."
msgstr ""
"二進位緩衝物件（BufferedReader、BufferedWriter、BufferedRandom 和 "
"BufferedRWPair 的實例）不可重入。雖然在正常情況下不會發生重入呼叫，"
"但它們可能會在 :mod:`signal` 處理程式中執行 I/O "
"時出現。如果執行緒試圖重新進入它已經在訪問的緩衝物件，則會引發 "
":exc:`RuntimeError`。請注意，這並不禁止其他執行緒進入緩衝物件。"

#: ../../library/io.rst:1158
#, fuzzy
msgid ""
"The above implicitly extends to text files, since the :func:`open()` "
"function will wrap a buffered object inside a :class:`TextIOWrapper`.  This "
"includes standard streams and therefore affects the built-in :func:`print()` "
"function as well."
msgstr ""
"以上內容隱式擴充到文本文件，因為 open() 函式會將緩衝物件包裝在 TextIOWrapper "
"中。這包括標準流，因此也會影響內建的 :func:`print()` 函式。"
