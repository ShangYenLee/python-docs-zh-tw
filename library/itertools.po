# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-25 00:17+0000\n"
"PO-Revision-Date: 2018-05-23 16:04+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/itertools.rst:2
msgid ":mod:`itertools` --- Functions creating iterators for efficient looping"
msgstr ":mod:`itertools` --- 為高效循環而建立疊代器的函式"

#: ../../library/itertools.rst:20
#, fuzzy
msgid ""
"This module implements a number of :term:`iterator` building blocks inspired "
"by constructs from APL, Haskell, and SML.  Each has been recast in a form "
"suitable for Python."
msgstr ""
"該模組實作了一些受 APL、Haskell 和 SML 構造啟發的 :term:`iterator` 構建塊。"
"每一個都以適合 Python 的形式重鑄。"

#: ../../library/itertools.rst:24
#, fuzzy
msgid ""
"The module standardizes a core set of fast, memory efficient tools that are "
"useful by themselves or in combination.  Together, they form an \"iterator "
"algebra\" making it possible to construct specialized tools succinctly and "
"efficiently in pure Python."
msgstr ""
"該模組標準化了一組核心的快速、記憶體高效的工具，這些工具可以單獨使用或組合使"
"用。它們一起形成了一個“疊代器代數”，使得在純 Python "
"中簡潔高效地構建專用工具成為可能。"

#: ../../library/itertools.rst:29
#, fuzzy
msgid ""
"For instance, SML provides a tabulation tool: ``tabulate(f)`` which produces "
"a sequence ``f(0), f(1), ...``.  The same effect can be achieved in Python "
"by combining :func:`map` and :func:`count` to form ``map(f, count())``."
msgstr ""
"例如，SML 提供了一個製表工具：``tabulate(f)``，它產生一個序列``f(0), f(1), "
"...``。通過組合 :func:`map` 和 :func:`count` 形成 ``map(f, count())``，"
"可以在 Python 中實作相同的效果。"

#: ../../library/itertools.rst:33
#, fuzzy
msgid ""
"These tools and their built-in counterparts also work well with the high-"
"speed functions in the :mod:`operator` module.  For example, the "
"multiplication operator can be mapped across two vectors to form an "
"efficient dot-product: ``sum(starmap(operator.mul, zip(vec1, vec2, "
"strict=True)))``."
msgstr ""
"這些工具及其內建的對應工具也可以很好地與 :mod:`operator` 模組中的高速函式配合"
"使用。例如，乘法運算符可以映射到兩個向量之間以形成有效的點積：``sum(starmap("
"operator.mul, zip(vec1, vec2, strict=True)))``。"

#: ../../library/itertools.rst:39
#, fuzzy
msgid "**Infinite iterators:**"
msgstr "**無限疊代器：**"

#: ../../library/itertools.rst:42 ../../library/itertools.rst:52
#: ../../library/itertools.rst:72
#, fuzzy
msgid "Iterator"
msgstr "疊代器"

#: ../../library/itertools.rst:42 ../../library/itertools.rst:52
#: ../../library/itertools.rst:72
msgid "Arguments"
msgstr "引數"

#: ../../library/itertools.rst:42 ../../library/itertools.rst:52
#: ../../library/itertools.rst:72 ../../library/itertools.rst:81
msgid "Results"
msgstr "結果"

#: ../../library/itertools.rst:42 ../../library/itertools.rst:52
msgid "Example"
msgstr "範例"

#: ../../library/itertools.rst:44
msgid ":func:`count`"
msgstr ":func:`count`"

#: ../../library/itertools.rst:44
#, fuzzy
msgid "start, [step]"
msgstr "開始，[步驟]"

#: ../../library/itertools.rst:44
#, fuzzy
msgid "start, start+step, start+2*step, ..."
msgstr "開始，開始+步，開始+2*步，..."

#: ../../library/itertools.rst:44
msgid "``count(10) --> 10 11 12 13 14 ...``"
msgstr "``count(10) --> 10 11 12 13 14 ...``"

#: ../../library/itertools.rst:45
msgid ":func:`cycle`"
msgstr ":func:`cycle`"

#: ../../library/itertools.rst:45
msgid "p"
msgstr "p"

#: ../../library/itertools.rst:45
msgid "p0, p1, ... plast, p0, p1, ..."
msgstr "p0, p1, ... plast, p0, p1, ..."

#: ../../library/itertools.rst:45
msgid "``cycle('ABCD') --> A B C D A B C D ...``"
msgstr "``cycle('ABCD') --> A B C D A B C D ...``"

#: ../../library/itertools.rst:46
msgid ":func:`repeat`"
msgstr ":func:`repeat`"

#: ../../library/itertools.rst:46
msgid "elem [,n]"
msgstr "elem [,n]"

#: ../../library/itertools.rst:46
#, fuzzy
msgid "elem, elem, elem, ... endlessly or up to n times"
msgstr "elem, elem, elem, ... 無窮無盡或最多 n 次"

#: ../../library/itertools.rst:46
msgid "``repeat(10, 3) --> 10 10 10``"
msgstr "``repeat(10, 3) --> 10 10 10``"

#: ../../library/itertools.rst:49
#, fuzzy
msgid "**Iterators terminating on the shortest input sequence:**"
msgstr "**終止於最短輸入序列的疊代器：**"

#: ../../library/itertools.rst:54
msgid ":func:`accumulate`"
msgstr ":func:`accumulate`"

#: ../../library/itertools.rst:54
msgid "p [,func]"
msgstr "p [,func]"

#: ../../library/itertools.rst:54
msgid "p0, p0+p1, p0+p1+p2, ..."
msgstr "p0, p0+p1, p0+p1+p2, ..."

#: ../../library/itertools.rst:54
msgid "``accumulate([1,2,3,4,5]) --> 1 3 6 10 15``"
msgstr "``accumulate([1,2,3,4,5]) --> 1 3 6 10 15``"

#: ../../library/itertools.rst:55
msgid ":func:`chain`"
msgstr ":func:`chain`"

#: ../../library/itertools.rst:55 ../../library/itertools.rst:66
msgid "p, q, ..."
msgstr "p, q, ..."

#: ../../library/itertools.rst:55 ../../library/itertools.rst:56
msgid "p0, p1, ... plast, q0, q1, ..."
msgstr "p0, p1, ... plast, q0, q1, ..."

#: ../../library/itertools.rst:55
msgid "``chain('ABC', 'DEF') --> A B C D E F``"
msgstr "``chain('ABC', 'DEF') --> A B C D E F``"

#: ../../library/itertools.rst:56
msgid ":func:`chain.from_iterable`"
msgstr ":func:`chain.from_iterable`"

#: ../../library/itertools.rst:56 ../../library/itertools.rst:62
#, fuzzy
msgid "iterable"
msgstr "可疊代的"

#: ../../library/itertools.rst:56
msgid "``chain.from_iterable(['ABC', 'DEF']) --> A B C D E F``"
msgstr "``chain.from_iterable(['ABC', 'DEF']) --> A B C D E F``"

#: ../../library/itertools.rst:57
msgid ":func:`compress`"
msgstr ":func:`compress`"

#: ../../library/itertools.rst:57
#, fuzzy
msgid "data, selectors"
msgstr "資料，選擇器"

#: ../../library/itertools.rst:57
msgid "(d[0] if s[0]), (d[1] if s[1]), ..."
msgstr "(d[0] if s[0]), (d[1] if s[1]), ..."

#: ../../library/itertools.rst:57
msgid "``compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F``"
msgstr "``compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F``"

#: ../../library/itertools.rst:58
msgid ":func:`dropwhile`"
msgstr ":func:`dropwhile`"

#: ../../library/itertools.rst:58 ../../library/itertools.rst:59
#: ../../library/itertools.rst:64
msgid "pred, seq"
msgstr "pred, seq"

#: ../../library/itertools.rst:58
#, fuzzy
msgid "seq[n], seq[n+1], starting when pred fails"
msgstr "seq[n], seq[n+1], pred失敗時開始"

#: ../../library/itertools.rst:58
msgid "``dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1``"
msgstr "``dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1``"

#: ../../library/itertools.rst:59
msgid ":func:`filterfalse`"
msgstr ":func:`filterfalse`"

#: ../../library/itertools.rst:59
#, fuzzy
msgid "elements of seq where pred(elem) is false"
msgstr "pred(elem) 為假的 seq 元素"

#: ../../library/itertools.rst:59
msgid "``filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8``"
msgstr "``filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8``"

#: ../../library/itertools.rst:60
msgid ":func:`groupby`"
msgstr ":func:`groupby`"

#: ../../library/itertools.rst:60
msgid "iterable[, key]"
msgstr "iterable[, key]"

#: ../../library/itertools.rst:60
#, fuzzy
msgid "sub-iterators grouped by value of key(v)"
msgstr "按 key(v) 的值分組的子疊代器"

#: ../../library/itertools.rst:61
msgid ":func:`islice`"
msgstr ":func:`islice`"

#: ../../library/itertools.rst:61
msgid "seq, [start,] stop [, step]"
msgstr "seq, [start,] stop [, step]"

#: ../../library/itertools.rst:61
#, fuzzy
msgid "elements from seq[start:stop:step]"
msgstr "來自 seq[start:stop:step] 的元素"

#: ../../library/itertools.rst:61
msgid "``islice('ABCDEFG', 2, None) --> C D E F G``"
msgstr "``islice('ABCDEFG', 2, None) --> C D E F G``"

#: ../../library/itertools.rst:62
msgid ":func:`pairwise`"
msgstr ":func:`pairwise`"

#: ../../library/itertools.rst:62
msgid "(p[0], p[1]), (p[1], p[2])"
msgstr "(p[0], p[1]), (p[1], p[2])"

#: ../../library/itertools.rst:62
msgid "``pairwise('ABCDEFG') --> AB BC CD DE EF FG``"
msgstr "``pairwise('ABCDEFG') --> AB BC CD DE EF FG``"

#: ../../library/itertools.rst:63
msgid ":func:`starmap`"
msgstr ":func:`starmap`"

#: ../../library/itertools.rst:63
msgid "func, seq"
msgstr "func, seq"

#: ../../library/itertools.rst:63
msgid "func(\\*seq[0]), func(\\*seq[1]), ..."
msgstr "func(\\*seq[0]), func(\\*seq[1]), ..."

#: ../../library/itertools.rst:63
msgid "``starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000``"
msgstr "``starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000``"

#: ../../library/itertools.rst:64
msgid ":func:`takewhile`"
msgstr ":func:`takewhile`"

#: ../../library/itertools.rst:64
msgid "seq[0], seq[1], until pred fails"
msgstr "seq[0], seq[1], until pred fails"

#: ../../library/itertools.rst:64
msgid "``takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4``"
msgstr "``takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4``"

#: ../../library/itertools.rst:65
msgid ":func:`tee`"
msgstr ":func:`tee`"

#: ../../library/itertools.rst:65
msgid "it, n"
msgstr "it, n"

#: ../../library/itertools.rst:65
#, fuzzy
msgid "it1, it2, ... itn  splits one iterator into n"
msgstr "it1, it2, ... itn 將一個疊代器拆分為 n 個"

#: ../../library/itertools.rst:66
msgid ":func:`zip_longest`"
msgstr ":func:`zip_longest`"

#: ../../library/itertools.rst:66
msgid "(p[0], q[0]), (p[1], q[1]), ..."
msgstr "(p[0], q[0]), (p[1], q[1]), ..."

#: ../../library/itertools.rst:66
msgid "``zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-``"
msgstr "``zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-``"

#: ../../library/itertools.rst:69
#, fuzzy
msgid "**Combinatoric iterators:**"
msgstr "**組合疊代器：**"

#: ../../library/itertools.rst:74
msgid ":func:`product`"
msgstr ":func:`product`"

#: ../../library/itertools.rst:74
msgid "p, q, ... [repeat=1]"
msgstr "p, q, ... [repeat=1]"

#: ../../library/itertools.rst:74
#, fuzzy
msgid "cartesian product, equivalent to a nested for-loop"
msgstr "笛卡爾積，相當於嵌套的 for 循環"

#: ../../library/itertools.rst:75
msgid ":func:`permutations`"
msgstr ":func:`permutations`"

#: ../../library/itertools.rst:75
msgid "p[, r]"
msgstr "p[, r]"

#: ../../library/itertools.rst:75
#, fuzzy
msgid "r-length tuples, all possible orderings, no repeated elements"
msgstr "r 長度的元組，所有可能的順序，沒有重複的元素"

#: ../../library/itertools.rst:76
msgid ":func:`combinations`"
msgstr ":func:`combinations`"

#: ../../library/itertools.rst:76 ../../library/itertools.rst:77
msgid "p, r"
msgstr "p, r"

#: ../../library/itertools.rst:76
#, fuzzy
msgid "r-length tuples, in sorted order, no repeated elements"
msgstr "r-length 元組，按排序順序，無重複元素"

#: ../../library/itertools.rst:77
msgid ":func:`combinations_with_replacement`"
msgstr ":func:`combinations_with_replacement`"

#: ../../library/itertools.rst:77
#, fuzzy
msgid "r-length tuples, in sorted order, with repeated elements"
msgstr "r 長度元組，按排序順序，具有重複元素"

#: ../../library/itertools.rst:81
#, fuzzy
msgid "Examples"
msgstr "例子"

#: ../../library/itertools.rst:83
msgid "``product('ABCD', repeat=2)``"
msgstr "``product('ABCD', repeat=2)``"

#: ../../library/itertools.rst:83
msgid "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"
msgstr "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"

#: ../../library/itertools.rst:84
msgid "``permutations('ABCD', 2)``"
msgstr "``permutations('ABCD', 2)``"

#: ../../library/itertools.rst:84
msgid "``AB AC AD BA BC BD CA CB CD DA DB DC``"
msgstr "``AB AC AD BA BC BD CA CB CD DA DB DC``"

#: ../../library/itertools.rst:85
msgid "``combinations('ABCD', 2)``"
msgstr "``combinations('ABCD', 2)``"

#: ../../library/itertools.rst:85
msgid "``AB AC AD BC BD CD``"
msgstr "``AB AC AD BC BD CD``"

#: ../../library/itertools.rst:86
msgid "``combinations_with_replacement('ABCD', 2)``"
msgstr "``combinations_with_replacement('ABCD', 2)``"

#: ../../library/itertools.rst:86
msgid "``AA AB AC AD BB BC BD CC CD DD``"
msgstr "``AA AB AC AD BB BC BD CC CD DD``"

#: ../../library/itertools.rst:93
#, fuzzy
msgid "Itertool functions"
msgstr "Itertool 函式"

#: ../../library/itertools.rst:95
#, fuzzy
msgid ""
"The following module functions all construct and return iterators. Some "
"provide streams of infinite length, so they should only be accessed by "
"functions or loops that truncate the stream."
msgstr "以下模組函式所有構造和回傳疊代器。有些提供無限長度的流，因此它們只能由截斷流"
"的函式或循環訪問。"

#: ../../library/itertools.rst:101
#, fuzzy
msgid ""
"Make an iterator that returns accumulated sums, or accumulated results of "
"other binary functions (specified via the optional *func* argument)."
msgstr "建立一個回傳累加和或其他二元函式的累加結果的疊代器（通過可選的 *func* "
"參數指定）。"

#: ../../library/itertools.rst:105
#, fuzzy
msgid ""
"If *func* is supplied, it should be a function of two arguments. Elements of "
"the input *iterable* may be any type that can be accepted as arguments to "
"*func*. (For example, with the default operation of addition, elements may "
"be any addable type including :class:`~decimal.Decimal` or :class:"
"`~fractions.Fraction`.)"
msgstr ""
"如果提供 *func*，它應該是兩個參數的函式。輸入 *iterable* "
"的元素可以是任何可以接受為 *func* 參數的型別。 "
"（例如，對於預設的加法運算，元素可以是任何可加型別，包括 :class:`~decimal."
"Decimal` 或 :class:`~fractions.Fraction`。）"

#: ../../library/itertools.rst:112
#, fuzzy
msgid ""
"Usually, the number of elements output matches the input iterable. However, "
"if the keyword argument *initial* is provided, the accumulation leads off "
"with the *initial* value so that the output has one more element than the "
"input iterable."
msgstr ""
"通常，輸出的元素數量與輸入的可疊代物件相匹配。但是，如果提供了關鍵字參數 "
"*initial*，則累加會以 *initial* 值開始，以便輸出比輸入可疊代多一個元素。"

#: ../../library/itertools.rst:117 ../../library/itertools.rst:203
#: ../../library/itertools.rst:252 ../../library/itertools.rst:452
#: ../../library/itertools.rst:488 ../../library/itertools.rst:515
#: ../../library/itertools.rst:595
msgid "Roughly equivalent to::"
msgstr ""
"大致等價於：\n"
"\n"
"::"

#: ../../library/itertools.rst:136
#, fuzzy
msgid ""
"There are a number of uses for the *func* argument.  It can be set to :func:"
"`min` for a running minimum, :func:`max` for a running maximum, or :func:"
"`operator.mul` for a running product.  Amortization tables can be built by "
"accumulating interest and applying payments:"
msgstr ""
"*func* 參數有多種用途。它可以設定為 :func:`min` 表示運行最小值，:func:`max` "
"表示運行最大值，或 :func:`operator.mul` "
"表示運行產品。攤銷表可以通過累積利息和應用付款來建立："

#: ../../library/itertools.rst:154
#, fuzzy
msgid ""
"See :func:`functools.reduce` for a similar function that returns only the "
"final accumulated value."
msgstr "請參閱 func:`functools.reduce` 了解僅回傳最終累加值的類似函式。"

#: ../../library/itertools.rst:159
msgid "Added the optional *func* parameter."
msgstr "新增選用的 *func* 參數。"

#: ../../library/itertools.rst:162
msgid "Added the optional *initial* parameter."
msgstr "新增選用的 *initial* 參數。"

#: ../../library/itertools.rst:167
#, fuzzy
msgid ""
"Make an iterator that returns elements from the first iterable until it is "
"exhausted, then proceeds to the next iterable, until all of the iterables "
"are exhausted.  Used for treating consecutive sequences as a single "
"sequence. Roughly equivalent to::"
msgstr ""
"建立一個疊代器，回傳第一個可疊代物件的元素，直到用盡，然後繼續下一個可疊代物"
"件，直到所有可疊代對像都用完。用於將連續序列視為單個序列。大致相當於::"

#: ../../library/itertools.rst:181
#, fuzzy
msgid ""
"Alternate constructor for :func:`chain`.  Gets chained inputs from a single "
"iterable argument that is evaluated lazily.  Roughly equivalent to::"
msgstr ":func:`chain` "
"的備用構造函式。從延遲評估的單個可疊代參數獲取鏈接輸入。大致相當於::"

#: ../../library/itertools.rst:193
#, fuzzy
msgid "Return *r* length subsequences of elements from the input *iterable*."
msgstr "從輸入 *iterable* 中回傳元素的 *r* 長度子序列。"

#: ../../library/itertools.rst:195 ../../library/itertools.rst:244
#, fuzzy
msgid ""
"The combination tuples are emitted in lexicographic ordering according to "
"the order of the input *iterable*. So, if the input *iterable* is sorted, "
"the output tuples will be produced in sorted order."
msgstr "組合元組根據輸入 *iterable* 的順序按字典順序發出。因此，如果輸入 *iterable* "
"已排序，則輸出元組將按排序順序生成。"

#: ../../library/itertools.rst:199
#, fuzzy
msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"So if the input elements are unique, there will be no repeated values in "
"each combination."
msgstr "元素根據它們的位置而不是它們的值被視為唯一的。所以如果輸入元素是唯一的，那麼"
"每個組合中就不會出現重複值。"

#: ../../library/itertools.rst:225
#, fuzzy
msgid ""
"The code for :func:`combinations` can be also expressed as a subsequence of :"
"func:`permutations` after filtering entries where the elements are not in "
"sorted order (according to their position in the input pool)::"
msgstr ""
":func:`combinations` 的程式碼也可以表示為 :func:`permutations` "
"在過濾元素未按排序順序（根據它們在輸入池中的位置）的條目後的子序列："

#: ../../library/itertools.rst:236
#, fuzzy
msgid ""
"The number of items returned is ``n! / r! / (n-r)!`` when ``0 <= r <= n`` or "
"zero when ``r > n``."
msgstr "回傳的項目數是``n！ /r！ / (n-r)!`` 當 ``0 <= r <= n`` 或當 ``r > n`` "
"時為零。"

#: ../../library/itertools.rst:241
#, fuzzy
msgid ""
"Return *r* length subsequences of elements from the input *iterable* "
"allowing individual elements to be repeated more than once."
msgstr "從輸入 *iterable* 中回傳元素的 *r* 長度子序列，允許單個元素重複多次。"

#: ../../library/itertools.rst:248
#, fuzzy
msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"So if the input elements are unique, the generated combinations will also be "
"unique."
msgstr "元素根據它們的位置而不是它們的值被視為唯一的。因此，如果輸入元素是唯一的，則"
"生成的組合也將是唯一的。"

#: ../../library/itertools.rst:271
#, fuzzy
msgid ""
"The code for :func:`combinations_with_replacement` can be also expressed as "
"a subsequence of :func:`product` after filtering entries where the elements "
"are not in sorted order (according to their position in the input pool)::"
msgstr ""
":func:`combinations_with_replacement` 的程式碼也可以表示為 :func:`product` "
"在過濾元素未按排序順序（根據它們在輸入池中的位置）的條目後的子序列："

#: ../../library/itertools.rst:282
#, fuzzy
msgid ""
"The number of items returned is ``(n+r-1)! / r! / (n-1)!`` when ``n > 0``."
msgstr "回傳的項目數是``(n+r-1)! /r！ / (n-1)!`` 當 ``n > 0`` 時。"

#: ../../library/itertools.rst:289
#, fuzzy
msgid ""
"Make an iterator that filters elements from *data* returning only those that "
"have a corresponding element in *selectors* that evaluates to ``True``. "
"Stops when either the *data* or *selectors* iterables has been exhausted. "
"Roughly equivalent to::"
msgstr ""
"建立一個疊代器，過濾來自 *data* 的元素，僅回傳那些在 *selectors* "
"中具有對應元素且計算結果為 ``True`` 的元素。當 *data* 或 *selectors* "
"疊代器耗盡時停止。大致相當於::"

#: ../../library/itertools.rst:303
#, fuzzy
msgid ""
"Make an iterator that returns evenly spaced values starting with number "
"*start*. Often used as an argument to :func:`map` to generate consecutive "
"data points. Also, used with :func:`zip` to add sequence numbers.  Roughly "
"equivalent to::"
msgstr ""
"建立一個疊代器，回傳以數字 *start* 開頭的均勻間隔的值。通常用作 :func:`map` "
"的參數以生成連續的資料點。此外，與 :func:`zip` "
"一起使用以新增序列號。大致相當於::"

#: ../../library/itertools.rst:315
#, fuzzy
msgid ""
"When counting with floating point numbers, better accuracy can sometimes be "
"achieved by substituting multiplicative code such as: ``(start + step * i "
"for i in count())``."
msgstr ""
"當用浮點數計數時，有時可以通過替換乘法程式碼來獲得更好的準確性，例如：``("
"start + step * i for i in count())``。"

#: ../../library/itertools.rst:319
msgid "Added *step* argument and allowed non-integer arguments."
msgstr "新增 *step* 引數並允許非整數引數。"

#: ../../library/itertools.rst:324
#, fuzzy
msgid ""
"Make an iterator returning elements from the iterable and saving a copy of "
"each. When the iterable is exhausted, return elements from the saved copy.  "
"Repeats indefinitely.  Roughly equivalent to::"
msgstr "製作一個疊代器，從可疊代對像中回傳元素並保存每個元素的副本。當 iterable "
"耗盡時，從保存的副本中回傳元素。無限期地重複。大致相當於::"

#: ../../library/itertools.rst:338
#, fuzzy
msgid ""
"Note, this member of the toolkit may require significant auxiliary storage "
"(depending on the length of the iterable)."
msgstr "請注意，工具包的這個成員可能需要大量輔助儲存（取決於可疊代物件的長度）。"

#: ../../library/itertools.rst:344
#, fuzzy
msgid ""
"Make an iterator that drops elements from the iterable as long as the "
"predicate is true; afterwards, returns every element.  Note, the iterator "
"does not produce *any* output until the predicate first becomes false, so it "
"may have a lengthy start-up time.  Roughly equivalent to::"
msgstr ""
"製作一個疊代器，只要謂詞為真，它就會從可疊代對像中刪除元素；之後，回傳每個元"
"素。注意，在謂詞第一次變為假之前，疊代器不會產生*任何*輸出，因此它可能有很長"
"的啟動時間。大致相當於::"

#: ../../library/itertools.rst:361
#, fuzzy
msgid ""
"Make an iterator that filters elements from iterable returning only those "
"for which the predicate is false. If *predicate* is ``None``, return the "
"items that are false. Roughly equivalent to::"
msgstr ""
"建立一個疊代器，從 iterable 中過濾元素，只回傳那些謂詞為假的元素。如果 "
"*predicate* 是 ``None``，回傳錯誤的項目。大致相當於::"

#: ../../library/itertools.rst:376
#, fuzzy
msgid ""
"Make an iterator that returns consecutive keys and groups from the "
"*iterable*. The *key* is a function computing a key value for each element.  "
"If not specified or is ``None``, *key* defaults to an identity function and "
"returns the element unchanged.  Generally, the iterable needs to already be "
"sorted on the same key function."
msgstr ""
"建立一個從 *iterable* 回傳連續鍵和組的疊代器。 *key* "
"是一個計算每個元素的鍵值的函式。如果未指定或為 ``None``，*key* 預設為身份函式並"
"回傳未更改的元素。通常，可疊代物件需要已經根據相同的鍵函式進行排序。"

#: ../../library/itertools.rst:382
#, fuzzy
msgid ""
"The operation of :func:`groupby` is similar to the ``uniq`` filter in Unix.  "
"It generates a break or new group every time the value of the key function "
"changes (which is why it is usually necessary to have sorted the data using "
"the same key function).  That behavior differs from SQL's GROUP BY which "
"aggregates common elements regardless of their input order."
msgstr ""
":func:`groupby` 的操作類似於 Unix 中的 ``uniq`` 過濾器。每次鍵函式的值發生變"
"化時，它都會生成一個中斷或新組（這就是為什麼通常需要使用相同的鍵函式對資料進"
"行排序的原因）。該行為與 SQL 的 GROUP BY "
"不同，後者聚合公開元素而不考慮其輸入順序。"

#: ../../library/itertools.rst:388
#, fuzzy
msgid ""
"The returned group is itself an iterator that shares the underlying iterable "
"with :func:`groupby`.  Because the source is shared, when the :func:"
"`groupby` object is advanced, the previous group is no longer visible.  So, "
"if that data is needed later, it should be stored as a list::"
msgstr ""
"回傳的組本身是一個疊代器，它與 :func:`groupby` "
"共享底層可疊代物件。因為源是共享的，當 :func:`groupby` 對像被推進時，之前的組"
"不再可見。因此，如果以後需要該資料，則應將其儲存為列表::"

#: ../../library/itertools.rst:400
msgid ":func:`groupby` is roughly equivalent to::"
msgstr ""
":func:`groupby` 大致等價於：\n"
"\n"
"::"

#: ../../library/itertools.rst:437
#, fuzzy
msgid ""
"Make an iterator that returns selected elements from the iterable. If "
"*start* is non-zero, then elements from the iterable are skipped until start "
"is reached. Afterward, elements are returned consecutively unless *step* is "
"set higher than one which results in items being skipped.  If *stop* is "
"``None``, then iteration continues until the iterator is exhausted, if at "
"all; otherwise, it stops at the specified position."
msgstr ""
"建立一個疊代器，回傳從可疊代對像中選擇的元素。如果 *start* 非零，則跳過 "
"iterable 中的元素，直到到達 start。之後，元素將連續回傳，除非 *step* "
"設定為高於 1 導致項目被跳過。如果 *stop* 為 ``None``，則疊代將繼續，直到疊代器耗"
"盡（如果耗盡）；否則，它會停在指定的位置。"

#: ../../library/itertools.rst:444
#, fuzzy
msgid ""
"If *start* is ``None``, then iteration starts at zero. If *step* is "
"``None``, then the step defaults to one."
msgstr "如果 *start* 為 ``None``，則疊代從零開始。如果 *step* "
"為 ``None``，則該步驟預設為一個。"

#: ../../library/itertools.rst:447
#, fuzzy
msgid ""
"Unlike regular slicing, :func:`islice` does not support negative values for "
"*start*, *stop*, or *step*.  Can be used to extract related fields from data "
"where the internal structure has been flattened (for example, a multi-line "
"report may list a name field on every third line)."
msgstr ""
"與常規切片不同，:func:`islice` 不支援 *start*、*stop* 或 *step* 的負值。可用"
"於從內部結構已展平的資料中提取相關欄位（例如，多行報告可能每三行列出一個名稱"
"欄位）。"

#: ../../library/itertools.rst:482
#, fuzzy
msgid "Return successive overlapping pairs taken from the input *iterable*."
msgstr "回傳從輸入 *iterable* 中獲取的連續重疊對。"

#: ../../library/itertools.rst:484
#, fuzzy
msgid ""
"The number of 2-tuples in the output iterator will be one fewer than the "
"number of inputs.  It will be empty if the input iterable has fewer than two "
"values."
msgstr "輸出疊代器中二元組的數量將比輸入的數量少一個。如果輸入的可疊代物件少於兩個值"
"，它將為空。"

#: ../../library/itertools.rst:501
#, fuzzy
msgid ""
"Return successive *r* length permutations of elements in the *iterable*."
msgstr "回傳 *iterable* 中元素的連續 *r* 長度排列。"

#: ../../library/itertools.rst:503
#, fuzzy
msgid ""
"If *r* is not specified or is ``None``, then *r* defaults to the length of "
"the *iterable* and all possible full-length permutations are generated."
msgstr "如果 *r* 未指定或為 ``None`` ，則 *r* 預設為 *iterable* "
"的長度，並生成所有可能的全長排列。"

#: ../../library/itertools.rst:507
#, fuzzy
msgid ""
"The permutation tuples are emitted in lexicographic order according to the "
"order of the input *iterable*. So, if the input *iterable* is sorted, the "
"output tuples will be produced in sorted order."
msgstr "置換元組根據輸入 *iterable* 的順序按字典順序發出。因此，如果輸入 *iterable* "
"已排序，則輸出元組將按排序順序生成。"

#: ../../library/itertools.rst:511
#, fuzzy
msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"So if the input elements are unique, there will be no repeated values within "
"a permutation."
msgstr "元素根據它們的位置而不是它們的值被視為唯一的。因此，如果輸入元素是唯一的，則"
"排列中不會有重複值。"

#: ../../library/itertools.rst:542
#, fuzzy
msgid ""
"The code for :func:`permutations` can be also expressed as a subsequence of :"
"func:`product`, filtered to exclude entries with repeated elements (those "
"from the same position in the input pool)::"
msgstr ""
":func:`permutations` 的程式碼也可以表示為 :func:`product` "
"的子序列，過濾以排除具有重複元素的條目（來自輸入池中相同位置的條目）::"

#: ../../library/itertools.rst:554
#, fuzzy
msgid ""
"The number of items returned is ``n! / (n-r)!`` when ``0 <= r <= n`` or zero "
"when ``r > n``."
msgstr "回傳的項目數是``n！ / (n-r)!`` 當 ``0 <= r <= n`` 或當 ``r > n`` 時為零。"

#: ../../library/itertools.rst:559
#, fuzzy
msgid "Cartesian product of input iterables."
msgstr "輸入疊代的笛卡爾積。"

#: ../../library/itertools.rst:561
#, fuzzy
msgid ""
"Roughly equivalent to nested for-loops in a generator expression. For "
"example, ``product(A, B)`` returns the same as ``((x,y) for x in A for y in "
"B)``."
msgstr ""
"大致相當於生成器表達式中的嵌套 for 循環。例如，``product(A, B)`` "
"回傳與``((x,y) for x in A for y in B)`` 相同的結果。"

#: ../../library/itertools.rst:564
#, fuzzy
msgid ""
"The nested loops cycle like an odometer with the rightmost element advancing "
"on every iteration.  This pattern creates a lexicographic ordering so that "
"if the input's iterables are sorted, the product tuples are emitted in "
"sorted order."
msgstr "嵌套循環像里程表一樣循環，每次疊代時最右邊的元素都會前進。此模式建立字典順序"
"，以便如果輸入的可疊代對像已排序，則產品元組將按排序順序發出。"

#: ../../library/itertools.rst:569
#, fuzzy
msgid ""
"To compute the product of an iterable with itself, specify the number of "
"repetitions with the optional *repeat* keyword argument.  For example, "
"``product(A, repeat=4)`` means the same as ``product(A, A, A, A)``."
msgstr ""
"要計算可疊代物件與其自身的乘積，請使用可選的 *repeat* "
"關鍵字參數指定重複次數。例如，``product(A, repeat=4)`` 與``product(A, A, A, "
"A)`` 的含義相同。"

#: ../../library/itertools.rst:573
#, fuzzy
msgid ""
"This function is roughly equivalent to the following code, except that the "
"actual implementation does not build up intermediate results in memory::"
msgstr "這個函式大致等同於下面的程式碼，除了實際的實作不會在記憶體中建立中間結果："

#: ../../library/itertools.rst:586
#, fuzzy
msgid ""
"Before :func:`product` runs, it completely consumes the input iterables, "
"keeping pools of values in memory to generate the products.  Accordingly, it "
"is only useful with finite inputs."
msgstr "在 :func:`product` 運行之前，它會完全消耗輸入的可疊代物件，將值池保存在記憶體"
"中以生成產品。因此，它僅對有限輸入有用。"

#: ../../library/itertools.rst:592
#, fuzzy
msgid ""
"Make an iterator that returns *object* over and over again. Runs "
"indefinitely unless the *times* argument is specified."
msgstr "建立一個反復回傳 *object* 的疊代器。除非指定 *times* 參數，否則無限期運行。"

#: ../../library/itertools.rst:606
#, fuzzy
msgid ""
"A common use for *repeat* is to supply a stream of constant values to *map* "
"or *zip*:"
msgstr "*repeat* 的一個常見用途是向 *map* 或 *zip* 提供一個常數值流："

#: ../../library/itertools.rst:616
#, fuzzy
msgid ""
"Make an iterator that computes the function using arguments obtained from "
"the iterable.  Used instead of :func:`map` when argument parameters are "
"already grouped in tuples from a single iterable (when the data has been "
"\"pre-zipped\")."
msgstr ""
"建立一個疊代器，該疊代器使用從可疊代對像中獲得的參數來計算函式。當參數參數已"
"經從單個可疊代的元組中分組時（當資料已“預壓縮”時），用於代替 :func:`map`。"

#: ../../library/itertools.rst:621
#, fuzzy
msgid ""
"The difference between :func:`map` and :func:`starmap` parallels the "
"distinction between ``function(a,b)`` and ``function(*c)``. Roughly "
"equivalent to::"
msgstr ""
":func:`map` 和 :func:`starmap` 之間的區別類似於 ``function(a,b)`` 和 "
"``function(*c)`` 之間的區別。大致相當於::"

#: ../../library/itertools.rst:633
#, fuzzy
msgid ""
"Make an iterator that returns elements from the iterable as long as the "
"predicate is true.  Roughly equivalent to::"
msgstr "建立一個疊代器，只要謂詞為真，它就會從可疊代對像中回傳元素。大致相當於::"

#: ../../library/itertools.rst:647
#, fuzzy
msgid "Return *n* independent iterators from a single iterable."
msgstr "從單個可疊代物件回傳 *n* 個獨立的疊代器。"

#: ../../library/itertools.rst:649
#, fuzzy
msgid ""
"The following Python code helps explain what *tee* does (although the actual "
"implementation is more complex and uses only a single underlying :abbr:`FIFO "
"(first-in, first-out)` queue)::"
msgstr "以下 Python 程式碼有助於解釋 *tee* 的作用（"
"儘管實際實作更複雜並且僅使用單個底層 :abbr:`FIFO（先進先出）` 隊列）："

#: ../../library/itertools.rst:668
#, fuzzy
msgid ""
"Once a :func:`tee` has been created, the original *iterable* should not be "
"used anywhere else; otherwise, the *iterable* could get advanced without the "
"tee objects being informed."
msgstr ""
"一旦一個 :func:`tee` 被建立，原來的 *iterable* "
"不應該在其他任何地方使用；否則，*iterable* 可能會在沒有通知 tee "
"物件的情況下得到提升。"

#: ../../library/itertools.rst:672
#, fuzzy
msgid ""
"``tee`` iterators are not threadsafe. A :exc:`RuntimeError` may be raised "
"when using simultaneously iterators returned by the same :func:`tee` call, "
"even if the original *iterable* is threadsafe."
msgstr ""
"``tee`` 疊代器不是執行緒安全的。當同時使用由同一 :func:`tee` "
"呼叫回傳的疊代器時，可能會引發 :exc:`RuntimeError`，即使原始的 *iterable* "
"是執行緒安全的。"

#: ../../library/itertools.rst:676
#, fuzzy
msgid ""
"This itertool may require significant auxiliary storage (depending on how "
"much temporary data needs to be stored). In general, if one iterator uses "
"most or all of the data before another iterator starts, it is faster to use :"
"func:`list` instead of :func:`tee`."
msgstr ""
"這個 itertool 可能需要大量的輔助儲存（取決於需要儲存多少臨時資料）。通常，如"
"果一個疊代器在另一個疊代器開始之前使用了大部分或全部資料，則使用 :func:`list`"
" 而不是 :func:`tee` 會更快。"

#: ../../library/itertools.rst:684
#, fuzzy
msgid ""
"Make an iterator that aggregates elements from each of the iterables. If the "
"iterables are of uneven length, missing values are filled-in with "
"*fillvalue*. Iteration continues until the longest iterable is exhausted.  "
"Roughly equivalent to::"
msgstr ""
"建立一個疊代器，聚合來自每個可疊代物件的元素。如果 iterables 的長度不均勻，"
"缺失值將用 *fillvalue* 填充。疊代一直持續到最長的疊代耗盡。大致相當於::"

#: ../../library/itertools.rst:708
#, fuzzy
msgid ""
"If one of the iterables is potentially infinite, then the :func:"
"`zip_longest` function should be wrapped with something that limits the "
"number of calls (for example :func:`islice` or :func:`takewhile`).  If not "
"specified, *fillvalue* defaults to ``None``."
msgstr ""
"如果其中一個可疊代物件可能是無限的，那麼 :func:`zip_longest` "
"函式應該用限制呼叫次數的東西包裝（例如 :func:`islice` 或 "
":func:`takewhile`）。如果未指定，*fillvalue* 預設為 ``None`` 。"

#: ../../library/itertools.rst:717
#, fuzzy
msgid "Itertools Recipes"
msgstr "Itertools 食譜"

#: ../../library/itertools.rst:719
#, fuzzy
msgid ""
"This section shows recipes for creating an extended toolset using the "
"existing itertools as building blocks."
msgstr "本節顯示使用現有 itertools 作為構建塊建立擴充工具集的方法。"

#: ../../library/itertools.rst:722
#, fuzzy
msgid ""
"The primary purpose of the itertools recipes is educational.  The recipes "
"show various ways of thinking about individual tools — for example, that "
"``chain.from_iterable`` is related to the concept of flattening.  The "
"recipes also give ideas about ways that the tools can be combined — for "
"example, how ``compress()`` and ``range()`` can work together.  The recipes "
"also show patterns for using itertools with the :mod:`operator` and :mod:"
"`collections` modules as well as with the built-in itertools such as "
"``map()``, ``filter()``, ``reversed()``, and ``enumerate()``."
msgstr ""
"itertools "
"食譜的主要目的是教育。這些秘訣展示了對單個工具的各種思考方式——例如，``chain."
"from_iterable`` 與扁平化的概念有關。這些秘訣還提供了有關工具組合方式的想法——"
"例如，``compress()`` 和 ``range()`` 如何協同工作。食譜還展示了將 itertools "
"與 :mod:`operator` 和 :mod:`collections` 模組以及內建 itertools "
"一起使用的模式，例如 ``map()``、``filter()`` 、``reversed()`` 和 "
"``enumerate()``。"

#: ../../library/itertools.rst:731
#, fuzzy
msgid ""
"A secondary purpose of the recipes is to serve as an incubator.  The "
"``accumulate()``, ``compress()``, and ``pairwise()`` itertools started out "
"as recipes.  Currently, the ``iter_index()`` recipe is being tested to see "
"whether it proves its worth."
msgstr ""
"食譜的第二個目的是作為孵化器。 ``accumulate()``、``compress()`` 和 "
"``pairwise()`` itertools 最初是作為食譜。目前，``iter_index()`` "
"配方正在測試中，看它是否證明了它的價值。"

#: ../../library/itertools.rst:736
#, fuzzy
msgid ""
"Substantially all of these recipes and many, many others can be installed "
"from the `more-itertools project <https://pypi.org/project/more-itertools/"
">`_ found on the Python Package Index::"
msgstr ""
"基本上所有這些方法和許多其他方法都可以從 `more-itertools 項目 <https://pypi."
"org/project/more-itertools/>`_ 安裝，可在 Python 包索引中找到："

#: ../../library/itertools.rst:742
#, fuzzy
msgid ""
"Many of the recipes offer the same high performance as the underlying "
"toolset. Superior memory performance is kept by processing elements one at a "
"time rather than bringing the whole iterable into memory all at once. Code "
"volume is kept small by linking the tools together in a functional style "
"which helps eliminate temporary variables.  High speed is retained by "
"preferring \"vectorized\" building blocks over the use of for-loops and :"
"term:`generator`\\s which incur interpreter overhead."
msgstr ""
"許多配方提供與底層工具集相同的高性能。通過一次處理一個元素而不是一次將整個可"
"疊代物件全部放入記憶體來保持卓越的記憶體性能。通過以有助於消除臨時變數的功能"
"樣式將工具鏈接在一起，程式碼量保持較小。通過優先使用“矢量化”構建塊而不是使用 "
"for 循環和產生直譯器開銷的 :term:`generator`\\s 來保持高速。"
