# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-15 20:43+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../library/asyncio-runner.rst:6
#, fuzzy
msgid "Runners"
msgstr "跑步者"

#: ../../library/asyncio-runner.rst:8
msgid "**Source code:** :source:`Lib/asyncio/runners.py`"
msgstr "**原始碼：**\\ :source:`Lib/asyncio/runners.py`"

#: ../../library/asyncio-runner.rst:11
#, fuzzy
msgid ""
"This section outlines high-level asyncio primitives to run asyncio code."
msgstr "本節概述了運行非同步程式碼的高階非同步原語。"

#: ../../library/asyncio-runner.rst:13
#, fuzzy
msgid ""
"They are built on top of an :ref:`event loop <asyncio-event-loop>` with the "
"aim to simplify async code usage for common wide-spread scenarios."
msgstr "它們建立在 :ref:`event loop <asyncio-event-loop>` "
"之上，旨在簡化常見廣泛場景的非同步程式碼使用。"

#: ../../library/asyncio-runner.rst:23
#, fuzzy
msgid "Running an asyncio Program"
msgstr "運行非同步程式"

#: ../../library/asyncio-runner.rst:27
#, fuzzy
msgid "Execute the :term:`coroutine` *coro* and return the result."
msgstr "執行 :term:`coroutine` *coro* 並回傳結果。"

#: ../../library/asyncio-runner.rst:29
#, fuzzy
msgid ""
"This function runs the passed coroutine, taking care of managing the asyncio "
"event loop, *finalizing asynchronous generators*, and closing the threadpool."
msgstr "此函式運行傳遞的協程，負責管理 asyncio "
"事件循環，*完成非同步生成器*，並關閉執行緒池。"

#: ../../library/asyncio-runner.rst:33 ../../library/asyncio-runner.rst:103
#, fuzzy
msgid ""
"This function cannot be called when another asyncio event loop is running in "
"the same thread."
msgstr "當另一個非同步事件循環在同一執行緒中運行時，無法呼叫此函式。"

#: ../../library/asyncio-runner.rst:36 ../../library/asyncio-runner.rst:73
#, fuzzy
msgid ""
"If *debug* is ``True``, the event loop will be run in debug mode. ``False`` "
"disables debug mode explicitly. ``None`` is used to respect the global :ref:"
"`asyncio-debug-mode` settings."
msgstr ""
"如果 *debug* 為 ``True``，事件循環將在除錯模式下運行。 ``False`` "
"顯式禁用除錯模式。 ``None`` 用於尊重全局 :ref:`asyncio-debug-mode` 設定。"

#: ../../library/asyncio-runner.rst:40
#, fuzzy
msgid ""
"This function always creates a new event loop and closes it at the end.  It "
"should be used as a main entry point for asyncio programs, and should "
"ideally only be called once."
msgstr "這個函式總是建立一個新的事件循環並在最後關閉它。它應該用作 asyncio "
"程式的主要入口點，理想情況下應該只呼叫一次。"

#: ../../library/asyncio-runner.rst:44
msgid "Example::"
msgstr ""
"範例：\n"
"\n"
"::"

#: ../../library/asyncio-runner.rst:54
#, fuzzy
msgid "Updated to use :meth:`loop.shutdown_default_executor`."
msgstr "更新為使用 :meth:`loop.shutdown_default_executor`。"

#: ../../library/asyncio-runner.rst:59
#, fuzzy
msgid ""
"*debug* is ``None`` by default to respect the global debug mode settings."
msgstr "*debug* 預設為 ``None`` 以遵守全局除錯模式設定。"

#: ../../library/asyncio-runner.rst:63
#, fuzzy
msgid "Runner context manager"
msgstr "跑步者上下文管理器"

#: ../../library/asyncio-runner.rst:67
#, fuzzy
msgid ""
"A context manager that simplifies *multiple* async function calls in the "
"same context."
msgstr "一個上下文管理器，可簡化同一上下文中的 *多個* 非同步函式呼叫。"

#: ../../library/asyncio-runner.rst:70
#, fuzzy
msgid ""
"Sometimes several top-level async functions should be called in the same :"
"ref:`event loop <asyncio-event-loop>` and :class:`contextvars.Context`."
msgstr "有時，應該在同一個事件循環 <asyncio-event-loop> 和 contextvars.Context "
"中呼叫多個頂級非同步函式。"

#: ../../library/asyncio-runner.rst:77
#, fuzzy
msgid ""
"*loop_factory* could be used for overriding the loop creation. It is the "
"responsibility of the *loop_factory* to set the created loop as the current "
"one. By default :func:`asyncio.new_event_loop` is used and set as current "
"event loop with :func:`asyncio.set_event_loop` if *loop_factory* is ``None``."
msgstr ""
"*loop_factory* 可用於覆蓋循環建立。 *loop_factory* "
"負責將建立的循環設定為當前循環。預設情況下使用 :func:`asyncio.new_event_loop`"
" 並設定為當前事件循環 :func:`asyncio.set_event_loop` 如果 *loop_factory* 為 "
"``None``。"

#: ../../library/asyncio-runner.rst:82
#, fuzzy
msgid ""
"Basically, :func:`asyncio.run()` example can be rewritten with the runner "
"usage::"
msgstr "基本上，:func:`asyncio.run()` 示例可以用運行器用法重寫::"

#: ../../library/asyncio-runner.rst:95
#, fuzzy
msgid "Run a :term:`coroutine <coroutine>` *coro* in the embedded loop."
msgstr "在嵌入式循環中運行 :term:`coroutine <coroutine>` *coro*。"

#: ../../library/asyncio-runner.rst:97
#, fuzzy
msgid "Return the coroutine's result or raise its exception."
msgstr "回傳協程的結果或引發其例外。"

#: ../../library/asyncio-runner.rst:99
#, fuzzy
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. The runner's default "
"context is used if ``None``."
msgstr ""
"一個可選的僅限關鍵字的 *context* 參數允許為要運行的 *coro* "
"指定一個自定義的 :class:`contextvars."
"Context`。如果``None``，則使用運行器的預設上下文。"

#: ../../library/asyncio-runner.rst:108
#, fuzzy
msgid "Close the runner."
msgstr "關閉亞軍。"

#: ../../library/asyncio-runner.rst:110
#, fuzzy
msgid ""
"Finalize asynchronous generators, shutdown default executor, close the event "
"loop and release embedded :class:`contextvars.Context`."
msgstr "完成非同步生成器，關閉預設執行器，關閉事件循環並釋放嵌入的 "
":class:`contextvars.Context`。"

#: ../../library/asyncio-runner.rst:115
#, fuzzy
msgid "Return the event loop associated with the runner instance."
msgstr "回傳與運行器實例關聯的事件循環。"

#: ../../library/asyncio-runner.rst:119
#, fuzzy
msgid ""
":class:`Runner` uses the lazy initialization strategy, its constructor "
"doesn't initialize underlying low-level structures."
msgstr ":class:`Runner` 使用惰性初始化策略，其構造函式不初始化底層低階結構。"

#: ../../library/asyncio-runner.rst:122
#, fuzzy
msgid ""
"Embedded *loop* and *context* are created at the :keyword:`with` body "
"entering or the first call of :meth:`run` or :meth:`get_loop`."
msgstr ""
"嵌入式 *loop* 和 *context* 是在 :keyword:`with` 主體進入或第一次呼叫 "
":meth:`run` 或 :meth:`get_loop` 時建立的。"

#: ../../library/asyncio-runner.rst:127
#, fuzzy
msgid "Handling Keyboard Interruption"
msgstr "處理鍵盤中斷"

#: ../../library/asyncio-runner.rst:131
#, fuzzy
msgid ""
"When :const:`signal.SIGINT` is raised by :kbd:`Ctrl-C`, :exc:"
"`KeyboardInterrupt` exception is raised in the main thread by default. "
"However this doesn't work with :mod:`asyncio` because it can interrupt "
"asyncio internals and can hang the program from exiting."
msgstr ""
"當 :const:`signal.SIGINT` 被 :kbd:`Ctrl-C` 引發時，"
"預設情況下在主執行緒中引發 :exc:`KeyboardInterrupt` 例外。然而，這不適用於 "
":mod:`asyncio`，因為它會中斷 asyncio 內部並可能掛起程式退出。"

#: ../../library/asyncio-runner.rst:136
#, fuzzy
msgid ""
"To mitigate this issue, :mod:`asyncio` handles :const:`signal.SIGINT` as "
"follows:"
msgstr "為了緩解這個問題，:mod:`asyncio` 處理 :const:`signal.SIGINT` 如下："

#: ../../library/asyncio-runner.rst:138
#, fuzzy
msgid ""
":meth:`asyncio.Runner.run` installs a custom :const:`signal.SIGINT` handler "
"before any user code is executed and removes it when exiting from the "
"function."
msgstr ""
":meth:`asyncio.Runner.run` 在執行任何使用者程式碼之前安裝自定義 "
":const:`signal.SIGINT` 處理程式，並在退出函式時將其刪除。"

#: ../../library/asyncio-runner.rst:140
#, fuzzy
msgid ""
"The :class:`~asyncio.Runner` creates the main task for the passed coroutine "
"for its execution."
msgstr ":class:`~asyncio.Runner` 為傳遞的協程建立主要任務以供其執行。"

#: ../../library/asyncio-runner.rst:142
#, fuzzy
msgid ""
"When :const:`signal.SIGINT` is raised by :kbd:`Ctrl-C`, the custom signal "
"handler cancels the main task by calling :meth:`asyncio.Task.cancel` which "
"raises :exc:`asyncio.CancelledError` inside the main task.  This causes the "
"Python stack to unwind, ``try/except`` and ``try/finally`` blocks can be "
"used for resource cleanup.  After the main task is cancelled, :meth:`asyncio."
"Runner.run` raises :exc:`KeyboardInterrupt`."
msgstr ""
"當 :const:`signal.SIGINT` 被 :kbd:`Ctrl-C` 引發時，"
"自定義信號處理程式通過呼叫 :meth:`asyncio.Task.cancel` 取消主任務，這引發了 "
":exc:`asyncio.CancelledError ` 在主要任務中。這會導致 Python 堆疊展開，``try/"
"except`` 和 ``try/finally`` 塊可用於資源清理。主任務取消後，"
"asyncio.Runner.run 引發 KeyboardInterrupt。"

#: ../../library/asyncio-runner.rst:148
#, fuzzy
msgid ""
"A user could write a tight loop which cannot be interrupted by :meth:"
"`asyncio.Task.cancel`, in which case the second following :kbd:`Ctrl-C` "
"immediately raises the :exc:`KeyboardInterrupt` without cancelling the main "
"task."
msgstr ""
"使用者可以編寫一個不能被 :meth:`asyncio.Task.cancel` "
"中斷的緊密循環，在這種情況下，第二個跟隨 :kbd:`Ctrl-C` 會立即引發 "
":exc:`KeyboardInterrupt` 而不會取消主循環任務。"
