# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-31 08:13+0000\n"
"PO-Revision-Date: 2018-05-23 14:39+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-protocol.rst:9
msgid "Transports and Protocols"
msgstr "傳輸和協定"

#: ../../library/asyncio-protocol.rst:12
#, fuzzy
msgid "Preface"
msgstr "前言"

#: ../../library/asyncio-protocol.rst:13
#, fuzzy
msgid ""
"Transports and Protocols are used by the **low-level** event loop APIs such "
"as :meth:`loop.create_connection`.  They use callback-based programming "
"style and enable high-performance implementations of network or IPC "
"protocols (e.g. HTTP)."
msgstr ""
"傳輸和協定由**低階**事件循環 API 使用，例如 :meth:`loop."
"create_connection`。他們使用基於回呼的編程風格，並支援網絡或 IPC 協定（例如 "
"HTTP）的高性能實作。"

#: ../../library/asyncio-protocol.rst:18
#, fuzzy
msgid ""
"Essentially, transports and protocols should only be used in libraries and "
"frameworks and never in high-level asyncio applications."
msgstr "本質上，傳輸和協定應該只在庫和框架中使用，永遠不要在高階非同步應用程式中使用"
"。"

#: ../../library/asyncio-protocol.rst:22
#, fuzzy
msgid "This documentation page covers both `Transports`_ and `Protocols`_."
msgstr "此文檔頁面涵蓋了“傳輸”和“協定”。"

#: ../../library/asyncio-protocol.rst:25
#, fuzzy
msgid "Introduction"
msgstr "介紹"

#: ../../library/asyncio-protocol.rst:26
#, fuzzy
msgid ""
"At the highest level, the transport is concerned with *how* bytes are "
"transmitted, while the protocol determines *which* bytes to transmit (and to "
"some extent when)."
msgstr "在最高階別，傳輸關注*如何*位元組傳輸，而協定決定*哪些*位元組傳輸（以及在某種"
"程度上何時傳輸）。"

#: ../../library/asyncio-protocol.rst:30
#, fuzzy
msgid ""
"A different way of saying the same thing: a transport is an abstraction for "
"a socket (or similar I/O endpoint) while a protocol is an abstraction for an "
"application, from the transport's point of view."
msgstr "換種說法：從傳輸的角度來看，傳輸是對 socket （或類似的 I/O "
"端點）的抽象，而協定是對應用程式的抽象。"

#: ../../library/asyncio-protocol.rst:35
#, fuzzy
msgid ""
"Yet another view is the transport and protocol interfaces together define an "
"abstract interface for using network I/O and interprocess I/O."
msgstr "另一種觀點是傳輸和協定介面共同定義了一個抽象介面，用於使用網絡 I/O 和行程間 "
"I/O。"

#: ../../library/asyncio-protocol.rst:39
#, fuzzy
msgid ""
"There is always a 1:1 relationship between transport and protocol objects: "
"the protocol calls transport methods to send data, while the transport calls "
"protocol methods to pass it data that has been received."
msgstr "傳輸和協定物件之間始終存在 1:1 "
"的關係：協定呼叫傳輸方法發送資料，而傳輸呼叫協定方法將已接收的資料傳遞給它。"

#: ../../library/asyncio-protocol.rst:44
#, fuzzy
msgid ""
"Most of connection oriented event loop methods (such as :meth:`loop."
"create_connection`) usually accept a *protocol_factory* argument used to "
"create a *Protocol* object for an accepted connection, represented by a "
"*Transport* object. Such methods usually return a tuple of ``(transport, "
"protocol)``."
msgstr ""
"大多數面向連接的事件循環方法（例如 :meth:`loop.create_connection`）"
"通常接受一個 *protocol_factory* 參數，用於為接受的連接建立一個 *Protocol* "
"物件，由 *Transport* 物件表示。這樣的方法通常回傳一個元組``(transport, "
"protocol)``。"

#: ../../library/asyncio-protocol.rst:51
msgid "Contents"
msgstr "目錄"

#: ../../library/asyncio-protocol.rst:52
#, fuzzy
msgid "This documentation page contains the following sections:"
msgstr "本文檔頁麵包含以下部分："

#: ../../library/asyncio-protocol.rst:54
#, fuzzy
msgid ""
"The `Transports`_ section documents asyncio :class:`BaseTransport`, :class:"
"`ReadTransport`, :class:`WriteTransport`, :class:`Transport`, :class:"
"`DatagramTransport`, and :class:`SubprocessTransport` classes."
msgstr ""
"`Transports`_ 部分記錄了 asyncio :class:`BaseTransport`、:class:`ReadTranspor"
"t`、:class:`WriteTransport`、:class:`Transport`、:class:`DatagramTransport` "
"和 :class:`SubprocessTransport`類。"

#: ../../library/asyncio-protocol.rst:59
#, fuzzy
msgid ""
"The `Protocols`_ section documents asyncio :class:`BaseProtocol`, :class:"
"`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol`, and :class:"
"`SubprocessProtocol` classes."
msgstr ""
"`Protocols`_ 部分記錄了 asyncio :class:`BaseProtocol`、:class:`Protocol`、:cl"
"ass:`BufferedProtocol`、:class:`DatagramProtocol` 和 "
":class:`SubprocessProtocol` 類。"

#: ../../library/asyncio-protocol.rst:63
#, fuzzy
msgid ""
"The `Examples`_ section showcases how to work with transports, protocols, "
"and low-level event loop APIs."
msgstr "“示例”部分展示瞭如何使用傳輸、協定和低階事件循環 API。"

#: ../../library/asyncio-protocol.rst:70
#, fuzzy
msgid "Transports"
msgstr "交通工具"

#: ../../library/asyncio-protocol.rst:72
msgid "**Source code:** :source:`Lib/asyncio/transports.py`"
msgstr "**原始碼：**\\ :source:`Lib/asyncio/transports.py`"

#: ../../library/asyncio-protocol.rst:76
#, fuzzy
msgid ""
"Transports are classes provided by :mod:`asyncio` in order to abstract "
"various kinds of communication channels."
msgstr "傳輸是由 :mod:`asyncio` 提供的類，用於抽象各種通信通道。"

#: ../../library/asyncio-protocol.rst:79
#, fuzzy
msgid ""
"Transport objects are always instantiated by an :ref:`asyncio event loop "
"<asyncio-event-loop>`."
msgstr "傳輸物件總是由 :ref:`asyncio 事件循環 <asyncio-event-loop>` 實例化。"

#: ../../library/asyncio-protocol.rst:82
#, fuzzy
msgid ""
"asyncio implements transports for TCP, UDP, SSL, and subprocess pipes. The "
"methods available on a transport depend on the transport's kind."
msgstr "asyncio 為 TCP、UDP、SSL "
"和子行程管道實作傳輸。傳輸上可用的方法取決於傳輸的型別。"

#: ../../library/asyncio-protocol.rst:85
#, fuzzy
msgid ""
"The transport classes are :ref:`not thread safe <asyncio-multithreading>`."
msgstr "傳輸類是 :ref:`不是執行緒安全的 <asyncio-multithreading>`。"

#: ../../library/asyncio-protocol.rst:89
#, fuzzy
msgid "Transports Hierarchy"
msgstr "傳輸層級"

#: ../../library/asyncio-protocol.rst:93
#, fuzzy
msgid ""
"Base class for all transports.  Contains methods that all asyncio transports "
"share."
msgstr "所有傳輸的基底類別。包含所有非同步傳輸共享的方法。"

#: ../../library/asyncio-protocol.rst:98
#, fuzzy
msgid "A base transport for write-only connections."
msgstr "用於只寫連接的基本傳輸。"

#: ../../library/asyncio-protocol.rst:100
#, fuzzy
msgid ""
"Instances of the *WriteTransport* class are returned from the :meth:`loop."
"connect_write_pipe` event loop method and are also used by subprocess-"
"related methods like :meth:`loop.subprocess_exec`."
msgstr ""
"*WriteTransport* 類的實例從 :meth:`loop.connect_write_pipe` "
"事件循環方法回傳，也被子行程相關的方法使用，如 :meth:`loop.subprocess_exec`。"

#: ../../library/asyncio-protocol.rst:107
#, fuzzy
msgid "A base transport for read-only connections."
msgstr "只讀連接的基本傳輸。"

#: ../../library/asyncio-protocol.rst:109
#, fuzzy
msgid ""
"Instances of the *ReadTransport* class are returned from the :meth:`loop."
"connect_read_pipe` event loop method and are also used by subprocess-related "
"methods like :meth:`loop.subprocess_exec`."
msgstr ""
"*ReadTransport* 類的實例從 :meth:`loop.connect_read_pipe` 事件循環方法回傳，"
"也被 :meth:`loop.subprocess_exec` 等子流程相關方法使用。"

#: ../../library/asyncio-protocol.rst:116
#, fuzzy
msgid ""
"Interface representing a bidirectional transport, such as a TCP connection."
msgstr "表示雙向傳輸的介面，例如 TCP 連接。"

#: ../../library/asyncio-protocol.rst:119
#, fuzzy
msgid ""
"The user does not instantiate a transport directly; they call a utility "
"function, passing it a protocol factory and other information necessary to "
"create the transport and protocol."
msgstr "使用者不直接實例化傳輸；他們呼叫實用程式函式，將協定工廠和建立傳輸和協定所需"
"的其他資訊傳遞給它。"

#: ../../library/asyncio-protocol.rst:123
#, fuzzy
msgid ""
"Instances of the *Transport* class are returned from or used by event loop "
"methods like :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.create_server`, :meth:`loop.sendfile`, "
"etc."
msgstr ""
"*Transport* 類的實例由事件循環方法回傳或使用，例如 :meth:`loop."
"create_connection`、:meth:`loop.create_unix_connection`、:meth:`loop."
"create_server`、:meth:`loop。發送文件`等"

#: ../../library/asyncio-protocol.rst:131
#, fuzzy
msgid "A transport for datagram (UDP) connections."
msgstr "資料報 (UDP) 連接的傳輸。"

#: ../../library/asyncio-protocol.rst:133
#, fuzzy
msgid ""
"Instances of the *DatagramTransport* class are returned from the :meth:`loop."
"create_datagram_endpoint` event loop method."
msgstr ""
"*DatagramTransport* 類的實例從 :meth:`loop.create_datagram_endpoint` "
"事件循環方法回傳。"

#: ../../library/asyncio-protocol.rst:139
#, fuzzy
msgid ""
"An abstraction to represent a connection between a parent and its child OS "
"process."
msgstr "表示父行程與其子操作系統行程之間的連接的抽象。"

#: ../../library/asyncio-protocol.rst:142
#, fuzzy
msgid ""
"Instances of the *SubprocessTransport* class are returned from event loop "
"methods :meth:`loop.subprocess_shell` and :meth:`loop.subprocess_exec`."
msgstr ""
"*SubprocessTransport* 類的實例從事件循環方法 :meth:`loop.subprocess_shell` "
"和 :meth:`loop.subprocess_exec` 回傳。"

#: ../../library/asyncio-protocol.rst:148
#, fuzzy
msgid "Base Transport"
msgstr "基地運輸"

#: ../../library/asyncio-protocol.rst:152
#, fuzzy
msgid "Close the transport."
msgstr "關閉傳輸。"

#: ../../library/asyncio-protocol.rst:154
#, fuzzy
msgid ""
"If the transport has a buffer for outgoing data, buffered data will be "
"flushed asynchronously.  No more data will be received.  After all buffered "
"data is flushed, the protocol's :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` method will be called with :const:`None` as "
"its argument. The transport should not be used once it is closed."
msgstr ""
"如果傳輸有用於傳出資料的緩衝區，則緩衝資料將被非同步刷新。將不再接收資料。刷"
"新所有緩衝資料後，協定的 :meth:`protocol.connection_lost() <BaseProtocol."
"connection_lost>` 方法將以 :const:`None` "
"作為參數呼叫。一旦關閉，不應使用交通工具。"

#: ../../library/asyncio-protocol.rst:164
#, fuzzy
msgid "Return ``True`` if the transport is closing or is closed."
msgstr "如果傳輸正在關閉或已關閉，則回傳 ``True``。"

#: ../../library/asyncio-protocol.rst:168
#, fuzzy
msgid "Return information about the transport or underlying resources it uses."
msgstr "回傳有關它使用的傳輸或基礎資源的資訊。"

#: ../../library/asyncio-protocol.rst:171
#, fuzzy
msgid ""
"*name* is a string representing the piece of transport-specific information "
"to get."
msgstr "*name* 是一個字串，表示要獲取的特定於傳輸的資訊。"

#: ../../library/asyncio-protocol.rst:174
#, fuzzy
msgid ""
"*default* is the value to return if the information is not available, or if "
"the transport does not support querying it with the given third-party event "
"loop implementation or on the current platform."
msgstr "*default* 是在資訊不可用時回傳的值，或者如果傳輸不支援使用給定的第三方事件循"
"環實作或在當前平台上查詢它。"

#: ../../library/asyncio-protocol.rst:179
#, fuzzy
msgid ""
"For example, the following code attempts to get the underlying socket object "
"of the transport::"
msgstr "例如，以下程式碼嘗試獲取傳輸的底層 socket 物件："

#: ../../library/asyncio-protocol.rst:186
#, fuzzy
msgid "Categories of information that can be queried on some transports:"
msgstr "可以在某些傳輸上查詢的資訊類別："

#: ../../library/asyncio-protocol.rst:188
#, fuzzy
msgid "socket:"
msgstr "插座："

#: ../../library/asyncio-protocol.rst:190
#, fuzzy
msgid ""
"``'peername'``: the remote address to which the socket is connected, result "
"of :meth:`socket.socket.getpeername` (``None`` on error)"
msgstr ""
"``'peername'``： socket 連接到的遠程地址，結果 :meth:`socket.socket."
"getpeername`（``None`` 錯誤）"

#: ../../library/asyncio-protocol.rst:194
#, fuzzy
msgid "``'socket'``: :class:`socket.socket` instance"
msgstr "``'socket'``: :class:`socket.socket` 實例"

#: ../../library/asyncio-protocol.rst:196
#, fuzzy
msgid ""
"``'sockname'``: the socket's own address, result of :meth:`socket.socket."
"getsockname`"
msgstr "``'sockname'``: socket 自己的地址，:meth:`socket.socket.getsockname` 的結果"

#: ../../library/asyncio-protocol.rst:199
#, fuzzy
msgid "SSL socket:"
msgstr "SSL socket ："

#: ../../library/asyncio-protocol.rst:201
#, fuzzy
msgid ""
"``'compression'``: the compression algorithm being used as a string, or "
"``None`` if the connection isn't compressed; result of :meth:`ssl.SSLSocket."
"compression`"
msgstr ""
"``'compression'``：用作字串的壓縮演算法，如果連接未壓縮則為``None``； "
":meth:`ssl.SSLSocket.compression` 的結果"

#: ../../library/asyncio-protocol.rst:205
#, fuzzy
msgid ""
"``'cipher'``: a three-value tuple containing the name of the cipher being "
"used, the version of the SSL protocol that defines its use, and the number "
"of secret bits being used; result of :meth:`ssl.SSLSocket.cipher`"
msgstr ""
"``'cipher'``：一個三值元組，包含正在使用的密碼的名稱、定義其使用的 SSL "
"協定的版本以及正在使用的秘密位數； :meth:`ssl.SSLSocket.cipher` 的結果"

#: ../../library/asyncio-protocol.rst:210
#, fuzzy
msgid ""
"``'peercert'``: peer certificate; result of :meth:`ssl.SSLSocket.getpeercert`"
msgstr "``'peercert'``：對等證書；結果 :meth:`ssl.SSLSocket.getpeercert`"

#: ../../library/asyncio-protocol.rst:213
#, fuzzy
msgid "``'sslcontext'``: :class:`ssl.SSLContext` instance"
msgstr "``'sslcontext'``: :class:`ssl.SSLContext` 實例"

#: ../../library/asyncio-protocol.rst:215
#, fuzzy
msgid ""
"``'ssl_object'``: :class:`ssl.SSLObject` or :class:`ssl.SSLSocket` instance"
msgstr "``'ssl_object'``: :class:`ssl.SSLObject` 或 :class:`ssl.SSLSocket` 實例"

#: ../../library/asyncio-protocol.rst:218
#, fuzzy
msgid "pipe:"
msgstr "管道："

#: ../../library/asyncio-protocol.rst:220
#, fuzzy
msgid "``'pipe'``: pipe object"
msgstr "``'管道'``：管道物件"

#: ../../library/asyncio-protocol.rst:222
#, fuzzy
msgid "subprocess:"
msgstr "子過程："

#: ../../library/asyncio-protocol.rst:224
#, fuzzy
msgid "``'subprocess'``: :class:`subprocess.Popen` instance"
msgstr "``'subprocess'``: :class:`subprocess.Popen` 實例"

#: ../../library/asyncio-protocol.rst:228
#, fuzzy
msgid "Set a new protocol."
msgstr "設定新協定。"

#: ../../library/asyncio-protocol.rst:230
#, fuzzy
msgid ""
"Switching protocol should only be done when both protocols are documented to "
"support the switch."
msgstr "只有當兩種協定都被記錄為支援切換時，才應進行切換協定。"

#: ../../library/asyncio-protocol.rst:235
#, fuzzy
msgid "Return the current protocol."
msgstr "回傳當前協定。"

#: ../../library/asyncio-protocol.rst:239
#, fuzzy
msgid "Read-only Transports"
msgstr "只讀傳輸"

#: ../../library/asyncio-protocol.rst:243
#, fuzzy
msgid "Return ``True`` if the transport is receiving new data."
msgstr "如果傳輸正在接收新資料，則回傳 ``True``。"

#: ../../library/asyncio-protocol.rst:249
#, fuzzy
msgid ""
"Pause the receiving end of the transport.  No data will be passed to the "
"protocol's :meth:`protocol.data_received() <Protocol.data_received>` method "
"until :meth:`resume_reading` is called."
msgstr ""
"暫停傳輸的接收端。在呼叫 resume_reading 之前，不會將任何資料傳遞給協定的 "
"protocol.data_received() <Protocol.data_received> 方法。"

#: ../../library/asyncio-protocol.rst:253
#, fuzzy
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already paused or closed."
msgstr "該方法是冪等的，即它可以在傳輸已經暫停或關閉時呼叫。"

#: ../../library/asyncio-protocol.rst:259
#, fuzzy
msgid ""
"Resume the receiving end.  The protocol's :meth:`protocol.data_received() "
"<Protocol.data_received>` method will be called once again if some data is "
"available for reading."
msgstr ""
"恢復接收端。如果某些資料可供讀取，協定的 :meth:`protocol.data_received() "
"<Protocol.data_received>` 方法將被再次呼叫。"

#: ../../library/asyncio-protocol.rst:263
#, fuzzy
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already reading."
msgstr "該方法是冪等的，即它可以在傳輸已經讀取時呼叫。"

#: ../../library/asyncio-protocol.rst:269
#, fuzzy
msgid "Write-only Transports"
msgstr "只寫傳輸"

#: ../../library/asyncio-protocol.rst:273
#, fuzzy
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost.  No more data will be received. The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"立即關閉傳輸，無需等待掛起的操作完成。緩衝資料將丟失。將不再接收資料。協定的 "
":meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"方法最終將以 :const:`None` 作為參數呼叫。"

#: ../../library/asyncio-protocol.rst:281
#, fuzzy
msgid ""
"Return :const:`True` if the transport supports :meth:`~WriteTransport."
"write_eof`, :const:`False` if not."
msgstr ""
"如果傳輸支援 :meth:`~WriteTransport.write_eof`，則回傳 :const:`True`，"
"否則回傳 :const:`False`。"

#: ../../library/asyncio-protocol.rst:286
#, fuzzy
msgid "Return the current size of the output buffer used by the transport."
msgstr "回傳傳輸使用的輸出緩衝區的當前大小。"

#: ../../library/asyncio-protocol.rst:290
#, fuzzy
msgid ""
"Get the *high* and *low* watermarks for write flow control. Return a tuple "
"``(low, high)`` where *low* and *high* are positive number of bytes."
msgstr ""
"獲取用於寫入流控制的 *high* 和 *low* 水印。回傳一個元組 ``(low, high)`` 其中 "
"*low* 和 *high* 是正位元組數。"

#: ../../library/asyncio-protocol.rst:294
#, fuzzy
msgid "Use :meth:`set_write_buffer_limits` to set the limits."
msgstr "使用 :meth:`set_write_buffer_limits` 設定限制。"

#: ../../library/asyncio-protocol.rst:300
#, fuzzy
msgid "Set the *high* and *low* watermarks for write flow control."
msgstr "為寫入流量控制設定*高*和*低*水印。"

#: ../../library/asyncio-protocol.rst:302
#, fuzzy
msgid ""
"These two values (measured in number of bytes) control when the protocol's :"
"meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` and :meth:"
"`protocol.resume_writing() <BaseProtocol.resume_writing>` methods are "
"called. If specified, the low watermark must be less than or equal to the "
"high watermark.  Neither *high* nor *low* can be negative."
msgstr ""
"這兩個值（以位元組數衡量）控制協定的 :meth:`protocol.pause_writing() "
"<BaseProtocol.pause_writing>` 和 :meth:`protocol.resume_writing() "
"<BaseProtocol.resume_writing>` "
"方法何時被呼叫。如果指定，低水位線必須小於或等於高水位線。 *high* 和 *low* "
"都不能為負數。"

#: ../../library/asyncio-protocol.rst:310
#, fuzzy
msgid ""
":meth:`~BaseProtocol.pause_writing` is called when the buffer size becomes "
"greater than or equal to the *high* value. If writing has been paused, :meth:"
"`~BaseProtocol.resume_writing` is called when the buffer size becomes less "
"than or equal to the *low* value."
msgstr ""
":meth:`~BaseProtocol.pause_writing` 當緩衝區大小大於或等於 *high* "
"值時呼叫。如果寫入已暫停，則當緩衝區大小小於或等於 *low* 值時呼叫 "
":meth:`~BaseProtocol.resume_writing`。"

#: ../../library/asyncio-protocol.rst:315
#, fuzzy
msgid ""
"The defaults are implementation-specific.  If only the high watermark is "
"given, the low watermark defaults to an implementation-specific value less "
"than or equal to the high watermark.  Setting *high* to zero forces *low* to "
"zero as well, and causes :meth:`~BaseProtocol.pause_writing` to be called "
"whenever the buffer becomes non-empty.  Setting *low* to zero causes :meth:"
"`~BaseProtocol.resume_writing` to be called only once the buffer is empty. "
"Use of zero for either limit is generally sub-optimal as it reduces "
"opportunities for doing I/O and computation concurrently."
msgstr ""
"預設值是特定於實作的。如果僅給出高水印，則低水印預設為小於或等於高水印的特定"
"於實作的值。將 *high* 設定為零會強制 *low* "
"也為零，並導致 :meth:`~BaseProtocol.pause_writing` 在緩衝區變為非空時被呼叫。"
"將 *low* 設定為零會導致 :meth:`~BaseProtocol.resume_writing` "
"僅在緩衝區為空時才被呼叫。對任何一個限制使用零通常都不是最佳選擇，"
"因為它減少了同時進行 I/O 和計算的機會。"

#: ../../library/asyncio-protocol.rst:326
#, fuzzy
msgid "Use :meth:`~WriteTransport.get_write_buffer_limits` to get the limits."
msgstr "使用 :meth:`~WriteTransport.get_write_buffer_limits` 獲取限制。"

#: ../../library/asyncio-protocol.rst:331
#, fuzzy
msgid "Write some *data* bytes to the transport."
msgstr "將一些 *data* 位元組寫入傳輸。"

#: ../../library/asyncio-protocol.rst:333
#: ../../library/asyncio-protocol.rst:362
#, fuzzy
msgid ""
"This method does not block; it buffers the data and arranges for it to be "
"sent out asynchronously."
msgstr "此方法不會阻塞；它緩衝資料並安排將其非同步發送出去。"

#: ../../library/asyncio-protocol.rst:338
#, fuzzy
msgid ""
"Write a list (or any iterable) of data bytes to the transport. This is "
"functionally equivalent to calling :meth:`write` on each element yielded by "
"the iterable, but may be implemented more efficiently."
msgstr "將資料位元組列表（或任何可疊代的）寫入傳輸。"
"這在功能上等同於在疊代產生的每個元素上呼叫 "
":meth:`write`，但可以更有效地實作。"

#: ../../library/asyncio-protocol.rst:345
#, fuzzy
msgid ""
"Close the write end of the transport after flushing all buffered data. Data "
"may still be received."
msgstr "刷新所有緩衝資料後關閉傳輸的寫入端。可能仍會收到資料。"

#: ../../library/asyncio-protocol.rst:348
#, fuzzy
msgid ""
"This method can raise :exc:`NotImplementedError` if the transport (e.g. SSL) "
"doesn't support half-closed connections."
msgstr "如果傳輸（例如 "
"SSL）不支援半關閉連接，則此方法可以引發 :exec:`NotImplementedError`。"

#: ../../library/asyncio-protocol.rst:353
#, fuzzy
msgid "Datagram Transports"
msgstr "資料報傳輸"

#: ../../library/asyncio-protocol.rst:357
#, fuzzy
msgid ""
"Send the *data* bytes to the remote peer given by *addr* (a transport-"
"dependent target address).  If *addr* is :const:`None`, the data is sent to "
"the target address given on transport creation."
msgstr ""
"將 *data* 位元組發送到 *addr*（依賴於傳輸的目標地址）給定的遠程對等方。如果 "
"*addr* 是 :const:`None`，資料將發送到建立傳輸時給出的目標地址。"

#: ../../library/asyncio-protocol.rst:367
#, fuzzy
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost. No more data will be received.  The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"立即關閉傳輸，無需等待掛起的操作完成。緩衝資料將丟失。將不再接收資料。協定的 "
":meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"方法最終將以 :const:`None` 作為參數呼叫。"

#: ../../library/asyncio-protocol.rst:377
#, fuzzy
msgid "Subprocess Transports"
msgstr "子行程傳輸"

#: ../../library/asyncio-protocol.rst:381
#, fuzzy
msgid "Return the subprocess process id as an integer."
msgstr "將子行程行程 ID 作為整數回傳。"

#: ../../library/asyncio-protocol.rst:385
#, fuzzy
msgid ""
"Return the transport for the communication pipe corresponding to the integer "
"file descriptor *fd*:"
msgstr "回傳對應於整數文件描述器 *fd* 的通信管道的傳輸："

#: ../../library/asyncio-protocol.rst:388
#, fuzzy
msgid ""
"``0``: readable streaming transport of the standard input (*stdin*), or :"
"const:`None` if the subprocess was not created with ``stdin=PIPE``"
msgstr ""
"``0``：標準輸入 (*stdin*) 的可讀流式傳輸，如果子行程不是使用 ``stdin=PIPE`` "
"建立的，則為 :const:`None`"

#: ../../library/asyncio-protocol.rst:390
#, fuzzy
msgid ""
"``1``: writable streaming transport of the standard output (*stdout*), or :"
"const:`None` if the subprocess was not created with ``stdout=PIPE``"
msgstr ""
"``1``：標準輸出（*stdout*）的可寫流式傳輸，或者 :const:`None` "
"如果子行程不是使用 ``stdout=PIPE`` 建立的"

#: ../../library/asyncio-protocol.rst:392
#, fuzzy
msgid ""
"``2``: writable streaming transport of the standard error (*stderr*), or :"
"const:`None` if the subprocess was not created with ``stderr=PIPE``"
msgstr ""
"``2``：標準錯誤 (*stderr*) 的可寫流式傳輸，如果子行程不是使用 ``stderr=PIPE``"
" 建立的，則為 :const:`None`"

#: ../../library/asyncio-protocol.rst:394
#, fuzzy
msgid "other *fd*: :const:`None`"
msgstr "其他 *fd*: :const:`None`"

#: ../../library/asyncio-protocol.rst:398
#, fuzzy
msgid ""
"Return the subprocess return code as an integer or :const:`None` if it "
"hasn't returned, which is similar to the :attr:`subprocess.Popen.returncode` "
"attribute."
msgstr "將子行程回傳碼作為整數回傳，如果未回傳，則回傳 None，這類似於 "
"subprocess.Popen.returncode 屬性。"

#: ../../library/asyncio-protocol.rst:404
#, fuzzy
msgid "Kill the subprocess."
msgstr "殺死子行程。"

#: ../../library/asyncio-protocol.rst:406
#, fuzzy
msgid ""
"On POSIX systems, the function sends SIGKILL to the subprocess. On Windows, "
"this method is an alias for :meth:`terminate`."
msgstr "在 POSIX 系統上，該函式將 SIGKILL 發送到子行程。在 Windows 上，此方法是 "
":meth:`terminate` 的別名。"

#: ../../library/asyncio-protocol.rst:409
msgid "See also :meth:`subprocess.Popen.kill`."
msgstr "另請參閱 :meth:`subprocess.Popen.kill`\\ 。"

#: ../../library/asyncio-protocol.rst:413
#, fuzzy
msgid ""
"Send the *signal* number to the subprocess, as in :meth:`subprocess.Popen."
"send_signal`."
msgstr "將 *signal* 號發送到子行程，如 :meth:`subprocess.Popen.send_signal`。"

#: ../../library/asyncio-protocol.rst:418
#, fuzzy
msgid "Stop the subprocess."
msgstr "停止子行程。"

#: ../../library/asyncio-protocol.rst:420
#, fuzzy
msgid ""
"On POSIX systems, this method sends SIGTERM to the subprocess. On Windows, "
"the Windows API function TerminateProcess() is called to stop the subprocess."
msgstr ""
"在 POSIX 系統上，此方法將 SIGTERM 發送到子行程。在 Windows 上，呼叫 Windows "
"API 函式 TerminateProcess() 來停止子行程。"

#: ../../library/asyncio-protocol.rst:424
msgid "See also :meth:`subprocess.Popen.terminate`."
msgstr "另請參閱 :meth:`subprocess.Popen.terminate`\\ 。"

#: ../../library/asyncio-protocol.rst:428
#, fuzzy
msgid "Kill the subprocess by calling the :meth:`kill` method."
msgstr "通過呼叫 :meth:`kill` 方法終止子行程。"

#: ../../library/asyncio-protocol.rst:430
#, fuzzy
msgid ""
"If the subprocess hasn't returned yet, and close transports of *stdin*, "
"*stdout*, and *stderr* pipes."
msgstr "如果子行程尚未回傳，則關閉 *stdin*、*stdout* 和 *stderr* 管道的傳輸。"

#: ../../library/asyncio-protocol.rst:437
#, fuzzy
msgid "Protocols"
msgstr "協定"

#: ../../library/asyncio-protocol.rst:439
msgid "**Source code:** :source:`Lib/asyncio/protocols.py`"
msgstr "**原始碼：**\\ :source:`Lib/asyncio/protocols.py`"

#: ../../library/asyncio-protocol.rst:443
#, fuzzy
msgid ""
"asyncio provides a set of abstract base classes that should be used to "
"implement network protocols.  Those classes are meant to be used together "
"with :ref:`transports <asyncio-transport>`."
msgstr ""
"asyncio 提供了一組應該用於實作網絡協定的抽象基底類別。這些類旨在與 :ref:`"
"transports <asyncio-transport>` 一起使用。"

#: ../../library/asyncio-protocol.rst:447
#, fuzzy
msgid ""
"Subclasses of abstract base protocol classes may implement some or all "
"methods.  All these methods are callbacks: they are called by transports on "
"certain events, for example when some data is received. A base protocol "
"method should be called by the corresponding transport."
msgstr ""
"抽象基協定類的子類別可以實作部分或全部方法。所有這些方法都是回呼：它們在特定"
"事件上由傳輸呼叫，例如當接收到某些資料時。基本協定方法應由相應的傳輸呼叫。"

#: ../../library/asyncio-protocol.rst:454
#, fuzzy
msgid "Base Protocols"
msgstr "基本協定"

#: ../../library/asyncio-protocol.rst:458
#, fuzzy
msgid "Base protocol with methods that all protocols share."
msgstr "具有所有協定共享方法的基本協定。"

#: ../../library/asyncio-protocol.rst:462
#, fuzzy
msgid ""
"The base class for implementing streaming protocols (TCP, Unix sockets, etc)."
msgstr "用於實作流協定（TCP、Unix  socket 等）的基底類別。"

#: ../../library/asyncio-protocol.rst:467
#, fuzzy
msgid ""
"A base class for implementing streaming protocols with manual control of the "
"receive buffer."
msgstr "用於通過手動控制接收緩衝區實作流協定的基底類別。"

#: ../../library/asyncio-protocol.rst:472
#, fuzzy
msgid "The base class for implementing datagram (UDP) protocols."
msgstr "用於實作資料報 (UDP) 協定的基底類別。"

#: ../../library/asyncio-protocol.rst:476
#, fuzzy
msgid ""
"The base class for implementing protocols communicating with child processes "
"(unidirectional pipes)."
msgstr "用於實作與子行程（單向管道）通信的協定的基底類別。"

#: ../../library/asyncio-protocol.rst:481
#, fuzzy
msgid "Base Protocol"
msgstr "基本協定"

#: ../../library/asyncio-protocol.rst:483
#, fuzzy
msgid "All asyncio protocols can implement Base Protocol callbacks."
msgstr "所有 asyncio 協定都可以實作 Base Protocol 回呼。"

#: ../../library/asyncio-protocol.rst:486
#, fuzzy
msgid "Connection Callbacks"
msgstr "連接回呼"

#: ../../library/asyncio-protocol.rst:487
#, fuzzy
msgid ""
"Connection callbacks are called on all protocols, exactly once per a "
"successful connection.  All other protocol callbacks can only be called "
"between those two methods."
msgstr "連接回呼在所有協定上呼叫，每次成功連接一次。所有其他協定回呼只能在這兩個方法"
"之間呼叫。"

#: ../../library/asyncio-protocol.rst:493
#, fuzzy
msgid "Called when a connection is made."
msgstr "建立連接時呼叫。"

#: ../../library/asyncio-protocol.rst:495
#, fuzzy
msgid ""
"The *transport* argument is the transport representing the connection.  The "
"protocol is responsible for storing the reference to its transport."
msgstr "*transport* 參數是代表連接的傳輸。該協定負責儲存對其傳輸的引用。"

#: ../../library/asyncio-protocol.rst:501
#, fuzzy
msgid "Called when the connection is lost or closed."
msgstr "當連接丟失或關閉時呼叫。"

#: ../../library/asyncio-protocol.rst:503
#, fuzzy
msgid ""
"The argument is either an exception object or :const:`None`. The latter "
"means a regular EOF is received, or the connection was aborted or closed by "
"this side of the connection."
msgstr "參數是例外對像或 :const:`None`。後者意味著收到常規 "
"EOF，或者連接被連接的這一端中止或關閉。"

#: ../../library/asyncio-protocol.rst:509
#, fuzzy
msgid "Flow Control Callbacks"
msgstr "流量控制回呼"

#: ../../library/asyncio-protocol.rst:510
#, fuzzy
msgid ""
"Flow control callbacks can be called by transports to pause or resume "
"writing performed by the protocol."
msgstr "傳輸可以呼叫流量控制回呼來暫停或恢復協定執行的寫入。"

#: ../../library/asyncio-protocol.rst:513
#, fuzzy
msgid ""
"See the documentation of the :meth:`~WriteTransport.set_write_buffer_limits` "
"method for more details."
msgstr "有關詳細資訊，請參閱 :meth:`~WriteTransport.set_write_buffer_limits` "
"方法的文檔。"

#: ../../library/asyncio-protocol.rst:518
#, fuzzy
msgid "Called when the transport's buffer goes over the high watermark."
msgstr "當傳輸緩衝區超過高水位線時呼叫。"

#: ../../library/asyncio-protocol.rst:522
#, fuzzy
msgid "Called when the transport's buffer drains below the low watermark."
msgstr "當傳輸緩衝區耗盡到低水位線以下時呼叫。"

#: ../../library/asyncio-protocol.rst:524
#, fuzzy
msgid ""
"If the buffer size equals the high watermark, :meth:`~BaseProtocol."
"pause_writing` is not called: the buffer size must go strictly over."
msgstr "如果緩衝區大小等於高水位線，則不會呼叫 :meth:`~BaseProtocol."
"pause_writing`：緩衝區大小必須嚴格超過。"

#: ../../library/asyncio-protocol.rst:528
#, fuzzy
msgid ""
"Conversely, :meth:`~BaseProtocol.resume_writing` is called when the buffer "
"size is equal or lower than the low watermark.  These end conditions are "
"important to ensure that things go as expected when either mark is zero."
msgstr ""
"相反，:meth:`~BaseProtocol.resume_writing` 在緩衝區大小等於或小於低水位線時被"
"呼叫。這些結束條件對於確保當任一標記為零時事情按預期進行很重要。"

#: ../../library/asyncio-protocol.rst:535
#, fuzzy
msgid "Streaming Protocols"
msgstr "流媒體協定"

#: ../../library/asyncio-protocol.rst:537
#, fuzzy
msgid ""
"Event methods, such as :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe`, and :meth:`loop.connect_write_pipe` accept factories "
"that return streaming protocols."
msgstr ""
"事件方法，例如 :meth:`loop.create_server`、:meth:`loop."
"create_unix_server`、:meth:`loop.create_connection`、:meth:`loop."
"create_unix_connection`、:meth:`loop.connect_accepted_socket`、 "
"loop.connect_read_pipe 和 loop.connect_write_pipe 接受回傳流協定的工廠。"

#: ../../library/asyncio-protocol.rst:545
#, fuzzy
msgid ""
"Called when some data is received.  *data* is a non-empty bytes object "
"containing the incoming data."
msgstr "收到一些資料時呼叫。 *data* 是包含傳入資料的非空位元組物件。"

#: ../../library/asyncio-protocol.rst:548
#, fuzzy
msgid ""
"Whether the data is buffered, chunked or reassembled depends on the "
"transport.  In general, you shouldn't rely on specific semantics and instead "
"make your parsing generic and flexible. However, data is always received in "
"the correct order."
msgstr "資料是緩衝、分塊還是重組取決於傳輸。一般來說，您不應該依賴特定的語義，而是讓"
"您的解析通用且靈活。但是，資料總是以正確的順序接收。"

#: ../../library/asyncio-protocol.rst:553
#, fuzzy
msgid ""
"The method can be called an arbitrary number of times while a connection is "
"open."
msgstr "當連接打開時，可以呼叫任意次數的方法。"

#: ../../library/asyncio-protocol.rst:556
#, fuzzy
msgid ""
"However, :meth:`protocol.eof_received() <Protocol.eof_received>` is called "
"at most once.  Once ``eof_received()`` is called, ``data_received()`` is not "
"called anymore."
msgstr ""
"但是，:meth:`protocol.eof_received() <Protocol.eof_received>` "
"最多被呼叫一次。一旦呼叫了``eof_received()``，就不再呼叫``data_received()``。"

#: ../../library/asyncio-protocol.rst:562
#, fuzzy
msgid ""
"Called when the other end signals it won't send any more data (for example "
"by calling :meth:`transport.write_eof() <WriteTransport.write_eof>`, if the "
"other end also uses asyncio)."
msgstr ""
"當另一端發出不再發送任何資料的信號時呼叫（例如，如果另一端也使用 asyncio，"
"則呼叫 transport.write_eof() <WriteTransport.write_eof>`）。"

#: ../../library/asyncio-protocol.rst:567
#, fuzzy
msgid ""
"This method may return a false value (including ``None``), in which case the "
"transport will close itself.  Conversely, if this method returns a true "
"value, the protocol used determines whether to close the transport. Since "
"the default implementation returns ``None``, it implicitly closes the "
"connection."
msgstr ""
"此方法可能會回傳一個錯誤值（包括 ``None`` ），在這種情況下，傳輸將自行關閉。相反，"
"如果此方法回傳真值，則使用的協定決定是否關閉傳輸。由於預設實作回傳 ``None`` ，因此"
"它隱式關閉了連接。"

#: ../../library/asyncio-protocol.rst:573
#, fuzzy
msgid ""
"Some transports, including SSL, don't support half-closed connections, in "
"which case returning true from this method will result in the connection "
"being closed."
msgstr "某些傳輸（包括 SSL）不支援半關閉連接，在這種情況下，從此方法回傳 true "
"將導致連接關閉。"

#: ../../library/asyncio-protocol.rst:578
#: ../../library/asyncio-protocol.rst:636
#, fuzzy
msgid "State machine:"
msgstr "狀態機："

#: ../../library/asyncio-protocol.rst:589
#, fuzzy
msgid "Buffered Streaming Protocols"
msgstr "緩衝流協定"

#: ../../library/asyncio-protocol.rst:593
#, fuzzy
msgid ""
"Buffered Protocols can be used with any event loop method that supports "
"`Streaming Protocols`_."
msgstr "Buffered Protocols 可以與任何支援“Streaming "
"Protocols”的事件循環方法一起使用。"

#: ../../library/asyncio-protocol.rst:596
#, fuzzy
msgid ""
"``BufferedProtocol`` implementations allow explicit manual allocation and "
"control of the receive buffer.  Event loops can then use the buffer provided "
"by the protocol to avoid unnecessary data copies.  This can result in "
"noticeable performance improvement for protocols that receive big amounts of "
"data.  Sophisticated protocol implementations can significantly reduce the "
"number of buffer allocations."
msgstr ""
"``BufferedProtocol`` 實作允許顯式手動分配和控制接收緩衝區。然後，事件循環可以"
"使用協定提供的緩衝區來避免不必要的資料複製。這可以顯著提高接收大量資料的協定"
"的性能。複雜的協定實作可以顯著減少緩衝區分配的數量。"

#: ../../library/asyncio-protocol.rst:603
#, fuzzy
msgid ""
"The following callbacks are called on :class:`BufferedProtocol` instances:"
msgstr "在 BufferedProtocol 實例上呼叫以下回呼："

#: ../../library/asyncio-protocol.rst:608
#, fuzzy
msgid "Called to allocate a new receive buffer."
msgstr "呼叫以分配新的接收緩衝區。"

#: ../../library/asyncio-protocol.rst:610
#, fuzzy
msgid ""
"*sizehint* is the recommended minimum size for the returned buffer.  It is "
"acceptable to return smaller or larger buffers than what *sizehint* "
"suggests.  When set to -1, the buffer size can be arbitrary. It is an error "
"to return a buffer with a zero size."
msgstr ""
"*sizehint* 是回傳緩衝區的推薦最小大小。回傳比 *sizehint* "
"建議的更小或更大的緩衝區是可以接受的。當設定為 -1 "
"時，緩衝區大小可以是任意的。回傳大小為零的緩衝區是錯誤的。"

#: ../../library/asyncio-protocol.rst:615
#, fuzzy
msgid ""
"``get_buffer()`` must return an object implementing the :ref:`buffer "
"protocol <bufferobjects>`."
msgstr "``get_buffer()`` 必須回傳一個實作緩衝協定 <bufferobjects> 的物件。"

#: ../../library/asyncio-protocol.rst:620
#, fuzzy
msgid "Called when the buffer was updated with the received data."
msgstr "當緩衝區用接收到的資料更新時呼叫。"

#: ../../library/asyncio-protocol.rst:622
#, fuzzy
msgid "*nbytes* is the total number of bytes that were written to the buffer."
msgstr "*nbytes* 是寫入緩衝區的位元組總數。"

#: ../../library/asyncio-protocol.rst:626
#, fuzzy
msgid ""
"See the documentation of the :meth:`protocol.eof_received() <Protocol."
"eof_received>` method."
msgstr "請參閱 :meth:`protocol.eof_received() <Protocol.eof_received>` 方法的文檔。"

#: ../../library/asyncio-protocol.rst:630
#, fuzzy
msgid ""
":meth:`~BufferedProtocol.get_buffer` can be called an arbitrary number of "
"times during a connection.  However, :meth:`protocol.eof_received() "
"<Protocol.eof_received>` is called at most once and, if called, :meth:"
"`~BufferedProtocol.get_buffer` and :meth:`~BufferedProtocol.buffer_updated` "
"won't be called after it."
msgstr ""
":meth:`~BufferedProtocol.get_buffer` "
"可以在連接期間被呼叫任意次數。但是，:meth:`protocol.eof_received() <Protocol."
"eof_received>` 最多被呼叫一次，如果被呼叫，:meth:`~BufferedProtocol."
"get_buffer` 和 :meth:`~BufferedProtocol.buffer_updated` 將不會被呼叫叫了它。"

#: ../../library/asyncio-protocol.rst:649
#, fuzzy
msgid "Datagram Protocols"
msgstr "資料報協定"

#: ../../library/asyncio-protocol.rst:651
#, fuzzy
msgid ""
"Datagram Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.create_datagram_endpoint` method."
msgstr "資料報協定實例應該由傳遞給 :meth:`loop.create_datagram_endpoint` "
"方法的協定工廠構造。"

#: ../../library/asyncio-protocol.rst:656
#, fuzzy
msgid ""
"Called when a datagram is received.  *data* is a bytes object containing the "
"incoming data.  *addr* is the address of the peer sending the data; the "
"exact format depends on the transport."
msgstr "收到資料報時呼叫。 *data* 是包含傳入資料的位元組物件。 *addr* "
"是發送資料的對端地址；確切的格式取決於傳輸。"

#: ../../library/asyncio-protocol.rst:662
#, fuzzy
msgid ""
"Called when a previous send or receive operation raises an :class:"
"`OSError`.  *exc* is the :class:`OSError` instance."
msgstr "當先前的發送或接收操作引發 OSError 時呼叫。 *exc* 是 :class:`OSError` 實例。"

#: ../../library/asyncio-protocol.rst:665
#, fuzzy
msgid ""
"This method is called in rare conditions, when the transport (e.g. UDP) "
"detects that a datagram could not be delivered to its recipient. In many "
"conditions though, undeliverable datagrams will be silently dropped."
msgstr "在極少數情況下呼叫此方法，當傳輸（例如 UDP）檢測到資料報無法傳遞給其接收者時"
"。但在許多情況下，無法傳遞的資料報將被靜默丟棄。"

#: ../../library/asyncio-protocol.rst:672
#, fuzzy
msgid ""
"On BSD systems (macOS, FreeBSD, etc.) flow control is not supported for "
"datagram protocols, because there is no reliable way to detect send failures "
"caused by writing too many packets."
msgstr "在 BSD 系統（macOS、FreeBSD 等）上，資料報協定不支援流量控制，因為沒有可靠的"
"方法來檢測寫入過多資料包導致的發送失敗。"

#: ../../library/asyncio-protocol.rst:676
#, fuzzy
msgid ""
"The socket always appears 'ready' and excess packets are dropped. An :class:"
"`OSError` with ``errno`` set to :const:`errno.ENOBUFS` may or may not be "
"raised; if it is raised, it will be reported to :meth:`DatagramProtocol."
"error_received` but otherwise ignored."
msgstr ""
" socket 始終顯示為“就緒”，多餘的資料包將被丟棄。將 errno 設定為 errno.ENOBUFS "
"的 OSError 可能會也可能不會被引發；如果它被引發，它將被報告給 "
":meth:`DatagramProtocol.error_received` 但否則被忽略。"

#: ../../library/asyncio-protocol.rst:685
#, fuzzy
msgid "Subprocess Protocols"
msgstr "子行程協定"

#: ../../library/asyncio-protocol.rst:687
#, fuzzy
msgid ""
"Subprocess Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` "
"methods."
msgstr ""
"子行程協定實例應該由傳遞給 :meth:`loop.subprocess_exec` 和 :meth:`loop."
"subprocess_shell` 方法的協定工廠構造。"

#: ../../library/asyncio-protocol.rst:693
#, fuzzy
msgid ""
"Called when the child process writes data into its stdout or stderr pipe."
msgstr "當子行程將資料寫入其 stdout 或 stderr 管道時呼叫。"

#: ../../library/asyncio-protocol.rst:696
#, fuzzy
msgid "*fd* is the integer file descriptor of the pipe."
msgstr "*fd* 是管道的整數文件描述器。"

#: ../../library/asyncio-protocol.rst:698
#, fuzzy
msgid "*data* is a non-empty bytes object containing the received data."
msgstr "*data* 是包含接收到的資料的非空位元組物件。"

#: ../../library/asyncio-protocol.rst:702
#, fuzzy
msgid ""
"Called when one of the pipes communicating with the child process is closed."
msgstr "當與子行程通信的管道之一關閉時呼叫。"

#: ../../library/asyncio-protocol.rst:705
#, fuzzy
msgid "*fd* is the integer file descriptor that was closed."
msgstr "*fd* 是關閉的整數文件描述器。"

#: ../../library/asyncio-protocol.rst:709
#, fuzzy
msgid "Called when the child process has exited."
msgstr "當子行程退出時呼叫。"

#: ../../library/asyncio-protocol.rst:713
msgid "Examples"
msgstr "範例"

#: ../../library/asyncio-protocol.rst:718
#, fuzzy
msgid "TCP Echo Server"
msgstr "TCP 回顯伺服器"

#: ../../library/asyncio-protocol.rst:720
#, fuzzy
msgid ""
"Create a TCP echo server using the :meth:`loop.create_server` method, send "
"back received data, and close the connection::"
msgstr "使用 :meth:`loop.create_server` 方法建立一個 TCP "
"回顯伺服器，發送回接收到的資料，並關閉連接::"

#: ../../library/asyncio-protocol.rst:761
#, fuzzy
msgid ""
"The :ref:`TCP echo server using streams <asyncio-tcp-echo-server-streams>` "
"example uses the high-level :func:`asyncio.start_server` function."
msgstr ""
":ref:`TCP echo server using streams <asyncio-tcp-echo-server-streams>` "
"示例使用高階 :func:`asyncio.start_server` 函式。"

#: ../../library/asyncio-protocol.rst:767
#, fuzzy
msgid "TCP Echo Client"
msgstr "TCP 回顯客戶端"

#: ../../library/asyncio-protocol.rst:769
#, fuzzy
msgid ""
"A TCP echo client using the :meth:`loop.create_connection` method, sends "
"data, and waits until the connection is closed::"
msgstr "使用 :meth:`loop.create_connection` 方法的 TCP echo "
"客戶端發送資料，並等待連接關閉::"

#: ../../library/asyncio-protocol.rst:817
#, fuzzy
msgid ""
"The :ref:`TCP echo client using streams <asyncio-tcp-echo-client-streams>` "
"example uses the high-level :func:`asyncio.open_connection` function."
msgstr ""
":ref:`TCP echo client using streams <asyncio-tcp-echo-client-streams>` "
"示例使用高階 :func:`asyncio.open_connection` 函式。"

#: ../../library/asyncio-protocol.rst:824
#, fuzzy
msgid "UDP Echo Server"
msgstr "UDP 回顯伺服器"

#: ../../library/asyncio-protocol.rst:826
#, fuzzy
msgid ""
"A UDP echo server, using the :meth:`loop.create_datagram_endpoint` method, "
"sends back received data::"
msgstr "UDP 回顯伺服器使用 :meth:`loop.create_datagram_endpoint` "
"方法發回接收到的資料::"

#: ../../library/asyncio-protocol.rst:868
#, fuzzy
msgid "UDP Echo Client"
msgstr "UDP 回顯客戶端"

#: ../../library/asyncio-protocol.rst:870
#, fuzzy
msgid ""
"A UDP echo client, using the :meth:`loop.create_datagram_endpoint` method, "
"sends data and closes the transport when it receives the answer::"
msgstr "UDP 回顯客戶端使用 :meth:`loop.create_datagram_endpoint` "
"方法發送資料並在收到答案時關閉傳輸："

#: ../../library/asyncio-protocol.rst:925
#, fuzzy
msgid "Connecting Existing Sockets"
msgstr "連接現有 socket "

#: ../../library/asyncio-protocol.rst:927
#, fuzzy
msgid ""
"Wait until a socket receives data using the :meth:`loop.create_connection` "
"method with a protocol::"
msgstr "等到 socket 使用 :meth:`loop.create_connection` 方法和協定接收資料::"

#: ../../library/asyncio-protocol.rst:981
#, fuzzy
msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level :meth:`loop."
"add_reader` method to register an FD."
msgstr ""
":ref:`watch a file descriptor for read events <asyncio_example_watch_fd>` "
"示例使用低階 :meth:`loop.add_reader` 方法來註冊 FD。"

#: ../../library/asyncio-protocol.rst:985
#, fuzzy
msgid ""
"The :ref:`register an open socket to wait for data using streams "
"<asyncio_example_create_connection-streams>` example uses high-level streams "
"created by the :func:`open_connection` function in a coroutine."
msgstr ""
":ref:`註冊一個打開的 socket 以使用流 <asyncio_example_create_connection-"
"streams>` 示例使用協程中的 :func:`open_connection` 函式建立的高階流。"

#: ../../library/asyncio-protocol.rst:992
#, fuzzy
msgid "loop.subprocess_exec() and SubprocessProtocol"
msgstr "loop.subprocess_exec() 和 SubprocessProtocol"

#: ../../library/asyncio-protocol.rst:994
#, fuzzy
msgid ""
"An example of a subprocess protocol used to get the output of a subprocess "
"and to wait for the subprocess exit."
msgstr "用於獲取子行程輸出並等待子行程退出的子行程協定示例。"

#: ../../library/asyncio-protocol.rst:997
#, fuzzy
msgid "The subprocess is created by the :meth:`loop.subprocess_exec` method::"
msgstr "子行程由 :meth:`loop.subprocess_exec` 方法建立："

#: ../../library/asyncio-protocol.rst:1043
#, fuzzy
msgid ""
"See also the :ref:`same example <asyncio_example_create_subprocess_exec>` "
"written using high-level APIs."
msgstr "另請參閱 :ref:`使用高階 API 編寫的相同示例 "
"<asyncio_example_create_subprocess_exec>`。"
