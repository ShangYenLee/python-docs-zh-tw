# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Liang-Bo Wang <me@liang2.tw>, 2016
# Liang-Bo Wang <me@liang2.tw>, 2016
# Jason <chairco@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-09 00:17+0000\n"
"PO-Revision-Date: 2022-10-16 06:03+0800\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.1.1\n"

#: ../../library/unittest.rst:2
msgid ":mod:`unittest` --- Unit testing framework"
msgstr ":mod:`unittest` --- 單元測試框架"

#: ../../library/unittest.rst:12
msgid "**Source code:** :source:`Lib/unittest/__init__.py`"
msgstr "**原始碼：**\\ :source:`Lib/unittest/__init__.py`"

#: ../../library/unittest.rst:16
msgid ""
"(If you are already familiar with the basic concepts of testing, you might "
"want to skip to :ref:`the list of assert methods <assert-methods>`.)"
msgstr ""
"（假如你已經熟悉相關基礎的測試概念，你可能會希望跳過以下段落，直接參考 :ref:"
"`assert 方法清單 <assert-methods>`\\ 。）"

#: ../../library/unittest.rst:19
msgid ""
"The :mod:`unittest` unit testing framework was originally inspired by JUnit "
"and has a similar flavor as major unit testing frameworks in other "
"languages.  It supports test automation, sharing of setup and shutdown code "
"for tests, aggregation of tests into collections, and independence of the "
"tests from the reporting framework."
msgstr ""
":mod:`unittest` 原生的單元測試框架最初由 JUnit 開發，和其他程式語言相似有主要"
"的單元測試框架。支援自動化測試，對測試分享安裝與關閉程式碼，集合所有匯總的測"
"試，並且獨立各個測試報告框架。"

#: ../../library/unittest.rst:25
msgid ""
"To achieve this, :mod:`unittest` supports some important concepts in an "
"object-oriented way:"
msgstr ":mod:`unittest` 用來作為實現支援一些重要的物件導向方法的概念："

#: ../../library/unittest.rst:32
msgid "test fixture"
msgstr "test fixture"

#: ../../library/unittest.rst:29
msgid ""
"A :dfn:`test fixture` represents the preparation needed to perform one or "
"more tests, and any associated cleanup actions.  This may involve, for "
"example, creating temporary or proxy databases, directories, or starting a "
"server process."
msgstr ""
"一個 :dfn:`test fixture` 代表執行一個或多個測試所需要的準備，以及其他相關清理"
"操作，例如可以是建立臨時性的或是代理用 (proxy) 資料庫、目錄、或是啟動一個伺服"
"器程式。"

#: ../../library/unittest.rst:37
msgid "test case"
msgstr "test case（測試用例）"

#: ../../library/unittest.rst:35
msgid ""
"A :dfn:`test case` is the individual unit of testing.  It checks for a "
"specific response to a particular set of inputs.  :mod:`unittest` provides a "
"base class, :class:`TestCase`, which may be used to create new test cases."
msgstr ""
"一個 :dfn:`test case` 是一個獨立的單元測試。這是用來確認一個特定設定的輸入的"
"特殊回饋。 :mod:`unittest` 提供一個基礎類別，類別 :class:`TestCase`\\ ，可以"
"用來建立一個新的測試條例。"

#: ../../library/unittest.rst:41
msgid "test suite"
msgstr "test suite（測試套件）"

#: ../../library/unittest.rst:40
msgid ""
"A :dfn:`test suite` is a collection of test cases, test suites, or both.  It "
"is used to aggregate tests that should be executed together."
msgstr ""
":dfn:`test suite` 是一個搜集測試條例，測試套件，或是兩者皆有。它需要一起被執"
"行並用來匯總測試。"

#: ../../library/unittest.rst:48
msgid "test runner"
msgstr "test runner（測試執行器）"

#: ../../library/unittest.rst:44
msgid ""
"A :dfn:`test runner` is a component which orchestrates the execution of "
"tests and provides the outcome to the user.  The runner may use a graphical "
"interface, a textual interface, or return a special value to indicate the "
"results of executing the tests."
msgstr ""
":dfn:`test runner` 是一個編排測試執行與提供結果給使用者的一個元件。執行器可以"
"使用圖形化介面，文字介面或是回傳一個特別值用來標示出執行測試的結果。"

#: ../../library/unittest.rst:53
msgid "Module :mod:`doctest`"
msgstr ":mod:`doctest` 模組"

#: ../../library/unittest.rst:53
msgid "Another test-support module with a very different flavor."
msgstr "另一個執行測試的模組，但使用不一樣的測試方法與規範。"

#: ../../library/unittest.rst:57
msgid ""
"`Simple Smalltalk Testing: With Patterns <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"
msgstr ""
"`Simple Smalltalk Testing: With Patterns <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"

#: ../../library/unittest.rst:56
msgid ""
"Kent Beck's original paper on testing frameworks using the pattern shared "
"by :mod:`unittest`."
msgstr "Kent Beck 的原始論文討論使用 :mod:`unittest` 這樣模式的測試框架。"

#: ../../library/unittest.rst:61
msgid "`pytest <https://docs.pytest.org/>`_"
msgstr "`pytest <https://docs.pytest.org/>`_"

#: ../../library/unittest.rst:60
msgid ""
"Third-party unittest framework with a lighter-weight syntax for writing "
"tests.  For example, ``assert func(10) == 42``."
msgstr ""
"第三方的單元測試框架，但在撰寫測試時使用更輕量的語法。例如： ``assert "
"func(10) == 42``\\ 。"

#: ../../library/unittest.rst:65
msgid ""
"`The Python Testing Tools Taxonomy <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"
msgstr ""
"`The Python Testing Tools Taxonomy <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"

#: ../../library/unittest.rst:64
msgid ""
"An extensive list of Python testing tools including functional testing "
"frameworks and mock object libraries."
msgstr ""
"一份詳細的 Python 測試工具列表，包含 functional testing 框架和mock object 函"
"式庫。"

#: ../../library/unittest.rst:69
msgid ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"
msgstr ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"

#: ../../library/unittest.rst:68
msgid ""
"A special-interest-group for discussion of testing, and testing tools, in "
"Python."
msgstr "一個專門興趣的群組用來討論 Python 中的測試方式與測試工具。"

#: ../../library/unittest.rst:71
#, fuzzy
msgid ""
"The script :file:`Tools/unittestgui/unittestgui.py` in the Python source "
"distribution is a GUI tool for test discovery and execution.  This is "
"intended largely for ease of use for those new to unit testing.  For "
"production environments it is recommended that tests be driven by a "
"continuous integration system such as `Buildbot <https://buildbot.net/>`_, "
"`Jenkins <https://jenkins.io/>`_, `GitHub Actions <https://github.com/"
"features/actions>`_, or `AppVeyor <https://www.appveyor.com/>`_."
msgstr ""
"Python 源程式碼分發中的腳本 :file:`Tools/unittestgui/unittestgui.py` "
"是一個用於測試發現和執行的 GUI 工具。這主要是為了方便那些剛接觸單元測試的人使"
"用。對於生產環境，建議測試由持續集成系統驅動，例如`Buildbot <https://buildbot"
".net/>`_、`Jenkins <https://jenkins.io/>`_、`GitHub Actions <https://github."
"com/features/actions>`_，或`AppVeyor <https://www.appveyor.com/>`_。"

#: ../../library/unittest.rst:83
msgid "Basic example"
msgstr "簡單範例"

#: ../../library/unittest.rst:85
msgid ""
"The :mod:`unittest` module provides a rich set of tools for constructing and "
"running tests.  This section demonstrates that a small subset of the tools "
"suffice to meet the needs of most users."
msgstr ""
":mod:`unittest` 模組提供一系列豐富的工具用來建構與執行測試。本節將展示這一系"
"列工具中一部份，它們已能滿足大部份使用者需求。"

#: ../../library/unittest.rst:89
msgid "Here is a short script to test three string methods::"
msgstr ""
"這是一段簡短的腳本用來測試 3 個字串方法：\n"
"\n"
"::"

#: ../../library/unittest.rst:113
msgid ""
"A testcase is created by subclassing :class:`unittest.TestCase`.  The three "
"individual tests are defined with methods whose names start with the letters "
"``test``.  This naming convention informs the test runner about which "
"methods represent tests."
msgstr ""
"測試用例 (testcase) 可以透過繼承 :class:`unittest.TestCase` 類別來建立。這裡"
"定義了三個獨立的物件方法，名稱皆以 ``test`` 開頭。這樣的命名方式能告知 test "
"runner 哪些物件方法為定義的測試。"

#: ../../library/unittest.rst:118
msgid ""
"The crux of each test is a call to :meth:`~TestCase.assertEqual` to check "
"for an expected result; :meth:`~TestCase.assertTrue` or :meth:`~TestCase."
"assertFalse` to verify a condition; or :meth:`~TestCase.assertRaises` to "
"verify that a specific exception gets raised.  These methods are used "
"instead of the :keyword:`assert` statement so the test runner can accumulate "
"all test results and produce a report."
msgstr ""
"每個測試的關鍵為呼叫 :meth:`~TestCase.assertEqual` 來確認是否為期望的結果； :"
"meth:`~TestCase.assertTrue` 或是 :meth:`~TestCase.assertFalse` 用來驗證一個條"
"件式； :meth:`~TestCase.assertRaises` 用來驗證是否觸發一個特定的 exception。"
"使用這些物件方法來取代 :keyword:`assert` 陳述句，將能使 test runner 收集所有"
"的測試結果並產生一個報表。"

#: ../../library/unittest.rst:125
#, fuzzy
msgid ""
"The :meth:`~TestCase.setUp` and :meth:`~TestCase.tearDown` methods allow you "
"to define instructions that will be executed before and after each test "
"method. They are covered in more detail in the section :ref:`organizing-"
"tests`."
msgstr ""
":meth:`~TestCase.setUp` 和 :meth:`~TestCase.tearDown` "
"方法允許您定義將在每個測試方法之前和之後執行的指令。它們在 :ref:`organizing-"
"tests` 部分有更詳細的介紹。"

#: ../../library/unittest.rst:129
msgid ""
"The final block shows a simple way to run the tests. :func:`unittest.main` "
"provides a command-line interface to the test script.  When run from the "
"command line, the above script produces an output that looks like this::"
msgstr ""
"最後將顯示一個簡單的方法去執行測試 :func:`unittest.main` 提供一個命令執行列介"
"面測試腳本。當透過命令執行列執行，輸出結果將會像是：\n"
"\n"
"::"

#: ../../library/unittest.rst:139
msgid ""
"Passing the ``-v`` option to your test script will instruct :func:`unittest."
"main` to enable a higher level of verbosity, and produce the following "
"output::"
msgstr ""
"在測試時加入 ``-v`` 選項將指示 :func:`unittest.main` 提高 verbosity 層級，產"
"生以下的輸出：\n"
"\n"
"::"

#: ../../library/unittest.rst:151
msgid ""
"The above examples show the most commonly used :mod:`unittest` features "
"which are sufficient to meet many everyday testing needs.  The remainder of "
"the documentation explores the full feature set from first principles."
msgstr ""
"以上的例子顯示大多數使用 :mod:`unittest` 特徵足以滿足大多數日常測試的需求。接"
"下來第一部分文件的剩餘部分將繼續探索完整特徵設定。"

#: ../../library/unittest.rst:155
#, fuzzy
msgid ""
"The behavior of returning a value from a test method (other than the default "
"``None`` value), is now deprecated."
msgstr "從測試方法回傳值的行為（預設的 ``None`` 值除外）現在已棄用。"

#: ../../library/unittest.rst:163
msgid "Command-Line Interface"
msgstr "命令執行列介面 (Command-Line Interface)"

#: ../../library/unittest.rst:165
msgid ""
"The unittest module can be used from the command line to run tests from "
"modules, classes or even individual test methods::"
msgstr ""
"單元測試模組可以透過命令執行列執行測試模組，物件甚至個別的測試方法：\n"
"\n"
"::"

#: ../../library/unittest.rst:172
msgid ""
"You can pass in a list with any combination of module names, and fully "
"qualified class or method names."
msgstr "你可以通過一個串列與任何模組名稱的組合，完全符合類別與方法的名稱。"

#: ../../library/unittest.rst:175
msgid "Test modules can be specified by file path as well::"
msgstr ""
"測試模組可以根據檔案路徑指定：\n"
"\n"
"::"

#: ../../library/unittest.rst:179
msgid ""
"This allows you to use the shell filename completion to specify the test "
"module. The file specified must still be importable as a module. The path is "
"converted to a module name by removing the '.py' and converting path "
"separators into '.'. If you want to execute a test file that isn't "
"importable as a module you should execute the file directly instead."
msgstr ""
"這允許你使用 shell 檔案名稱補完功能 (filename completion) 來指定測試模組。給"
"定的檔案路徑必須亦能被當作模組 import。此路徑轉換為模組名稱的方式為移除 '."
"py' 並將路徑分隔符 (path separator) 轉換成 '.'。 假如你的測試檔案無法被 "
"import 成模組，你應該直接執行該測試檔案。"

#: ../../library/unittest.rst:185
msgid ""
"You can run tests with more detail (higher verbosity) by passing in the -v "
"flag::"
msgstr ""
"通過增加 -v 的旗標數，可以在你執行測試時得到更多細節（更高的 verbosity）：\n"
"\n"
"::"

#: ../../library/unittest.rst:189
msgid ""
"When executed without arguments :ref:`unittest-test-discovery` is started::"
msgstr ""
"若執行時不代任何引數，將執行 :ref:`unittest-test-discovery`\\ ：\n"
"\n"
"::"

#: ../../library/unittest.rst:193
msgid "For a list of all the command-line options::"
msgstr ""
"列出所有命令列選項：\n"
"\n"
"::"

#: ../../library/unittest.rst:197
msgid ""
"In earlier versions it was only possible to run individual test methods and "
"not modules or classes."
msgstr "在早期的版本可以個別執行測試方法和不需要模組或是類別。"

#: ../../library/unittest.rst:203
msgid "Command-line options"
msgstr "命令列模式選項"

#: ../../library/unittest.rst:205
msgid ":program:`unittest` supports these command-line options:"
msgstr ":program:`unittest` 支援以下命令列選項："

#: ../../library/unittest.rst:211
msgid ""
"The standard output and standard error streams are buffered during the test "
"run. Output during a passing test is discarded. Output is echoed normally on "
"test fail or error and is added to the failure messages."
msgstr ""
"Standard output 與 standard error stream 將在測試執行被緩衝 (buffer)。這些輸"
"出在測試通過時被丟棄。若是測試錯誤或失則，這些輸出將會正常地被印出，並且被加"
"入至錯誤訊息中。"

#: ../../library/unittest.rst:217
msgid ""
":kbd:`Control-C` during the test run waits for the current test to end and "
"then reports all the results so far. A second :kbd:`Control-C` raises the "
"normal :exc:`KeyboardInterrupt` exception."
msgstr ""
":kbd:`Control-C` 測試執行過程中等待正確的測試結果並回報目前為止所有的測試結"
"果。第二個 :kbd:`Control-C` 拋出一般例外 :exc:`KeyboardInterrupt`\\ 。"

#: ../../library/unittest.rst:221
msgid ""
"See `Signal Handling`_ for the functions that provide this functionality."
msgstr "參照 `Signal Handling`_ 針對函式提供的功能。"

#: ../../library/unittest.rst:225
msgid "Stop the test run on the first error or failure."
msgstr "在第一次錯誤或是失敗停止執行測試。"

#: ../../library/unittest.rst:229
#, fuzzy
msgid ""
"Only run test methods and classes that match the pattern or substring. This "
"option may be used multiple times, in which case all test cases that match "
"any of the given patterns are included."
msgstr "僅運行與模式或子字串匹配的測試方法和類。這個選項可以多次使用，在這種情況下，"
"所有匹配任何給定模式的測試用例都被包括在內。"

#: ../../library/unittest.rst:233
#, fuzzy
msgid ""
"Patterns that contain a wildcard character (``*``) are matched against the "
"test name using :meth:`fnmatch.fnmatchcase`; otherwise simple case-sensitive "
"substring matching is used."
msgstr "使用 fnmatch.fnmatchcase 將包含通配符 (``*``) "
"的模式與測試名稱進行匹配；否則使用簡單的區分大小寫的子字串匹配。"

#: ../../library/unittest.rst:237
#, fuzzy
msgid ""
"Patterns are matched against the fully qualified test method name as "
"imported by the test loader."
msgstr "模式與測試加載器導入的完全限定測試方法名稱匹配。"

#: ../../library/unittest.rst:240
#, fuzzy
msgid ""
"For example, ``-k foo`` matches ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_foo``, but not ``bar_tests.FooTest."
"test_something``."
msgstr ""
"例如，“-k foo”匹配“foo_tests.SomeTest.test_something”、“bar_tests.SomeTest."
"test_foo”，但不匹配“bar_tests.FooTest.test_something”。"

#: ../../library/unittest.rst:245
msgid "Show local variables in tracebacks."
msgstr "透過 traceback 顯示本地變數。"

#: ../../library/unittest.rst:247
msgid "The command-line options ``-b``, ``-c`` and ``-f`` were added."
msgstr "增加命令列模式選項 ``-b`` 、 ``-c`` 與 ``-f``\\ 。"

#: ../../library/unittest.rst:250
msgid "The command-line option ``--locals``."
msgstr "命令列選項 ``--locals``\\ 。"

#: ../../library/unittest.rst:253
msgid "The command-line option ``-k``."
msgstr "命令列選項 ``-k``\\ 。"

#: ../../library/unittest.rst:256
msgid ""
"The command line can also be used for test discovery, for running all of the "
"tests in a project or just a subset."
msgstr ""
"對執行所有的專案或是一個子集合測試，命令列模式可以可以被用來做測試探索。"

#: ../../library/unittest.rst:263
msgid "Test Discovery"
msgstr "Test Discovery（測試探索）"

#: ../../library/unittest.rst:267
msgid ""
"Unittest supports simple test discovery. In order to be compatible with test "
"discovery, all of the test files must be :ref:`modules <tut-modules>` or :"
"ref:`packages <tut-packages>` importable from the top-level directory of the "
"project (this means that their filenames must be valid :ref:`identifiers "
"<identifiers>`)."
msgstr ""
"單元測試支援簡單的 test discovery（測試探索）。為了相容於測試探索，所有的測試"
"檔案都要是\\ :ref:`模組 <tut-modules>`\\ 或是\\ :ref:`套件 <tut-packages>`，"
"並能從專案的最上層目錄中 import（代表它們的檔案名稱必須是有效的 :ref:"
"`identifiers <identifiers>`\\ ）。"

#: ../../library/unittest.rst:273
msgid ""
"Test discovery is implemented in :meth:`TestLoader.discover`, but can also "
"be used from the command line. The basic command-line usage is::"
msgstr ""
"Test discovery（測試探索）實作在 :meth:`TestLoader.discover`\\ ，但也可以被用"
"於命令列模式。基本的命令列模式用法如下：\n"
"\n"
"::"

#: ../../library/unittest.rst:281
msgid ""
"As a shortcut, ``python -m unittest`` is the equivalent of ``python -m "
"unittest discover``. If you want to pass arguments to test discovery the "
"``discover`` sub-command must be used explicitly."
msgstr ""
"``python -m unittest`` 作為捷徑，其功能相當於 ``python -m unittest "
"discover``\\ 。假如你想傳遞引數至探索測試的話，一定要明確地加入 ``discover`` "
"子指令。"

#: ../../library/unittest.rst:285
msgid "The ``discover`` sub-command has the following options:"
msgstr "``discover`` 子指令有以下幾個選項："

#: ../../library/unittest.rst:291
msgid "Verbose output"
msgstr "詳細（verbose）輸出"

#: ../../library/unittest.rst:295
msgid "Directory to start discovery (``.`` default)"
msgstr "開始尋找的資料夾（預設為 ``.``\\ ）"

#: ../../library/unittest.rst:299
msgid "Pattern to match test files (``test*.py`` default)"
msgstr "匹配測試檔案的模式（預設為 ``test*.py``\\ ）"

#: ../../library/unittest.rst:303
msgid "Top level directory of project (defaults to start directory)"
msgstr "專案的最高階層目錄 (defaults to start directory)"

#: ../../library/unittest.rst:305
msgid ""
"The :option:`-s`, :option:`-p`, and :option:`-t` options can be passed in as "
"positional arguments in that order. The following two command lines are "
"equivalent::"
msgstr ""
":option:`-s`, :option:`-p`, 和 :option:`-t` 選項依照傳遞位置作為引數排序順"
"序。以下兩個命令列被視為等價：\n"
"\n"
"::"

#: ../../library/unittest.rst:312
#, fuzzy
msgid ""
"As well as being a path it is possible to pass a package name, for example "
"``myproject.subpackage.test``, as the start directory. The package name you "
"supply will then be imported and its location on the filesystem will be used "
"as the start directory."
msgstr ""
"除了作為路徑，還可以傳遞包名稱作為起始目錄，例如 ``myproject.subpackage."
"test``。然後將導入您提供的包名稱，並將其在文件系統中的位置用作起始目錄。"

#: ../../library/unittest.rst:319
#, fuzzy
msgid ""
"Test discovery loads tests by importing them. Once test discovery has found "
"all the test files from the start directory you specify it turns the paths "
"into package names to import. For example :file:`foo/bar/baz.py` will be "
"imported as ``foo.bar.baz``."
msgstr ""
"測試發現通過導入加載測試。一旦測試發現從您指定的起始目錄中找到所有測試文件，"
"它就會將路徑轉換為要導入的包名稱。例如 :file:`foo/bar/baz.py` 將被導入為 "
"``foo.bar.baz``。"

#: ../../library/unittest.rst:324
#, fuzzy
msgid ""
"If you have a package installed globally and attempt test discovery on a "
"different copy of the package then the import *could* happen from the wrong "
"place. If this happens test discovery will warn you and exit."
msgstr "如果您全局安裝了一個包並嘗試在包的不同副本上進行測試發現，那麼導入 *可能* "
"從錯誤的地方發生。如果發生這種情況，測試發現將警告您並退出。"

#: ../../library/unittest.rst:328
#, fuzzy
msgid ""
"If you supply the start directory as a package name rather than a path to a "
"directory then discover assumes that whichever location it imports from is "
"the location you intended, so you will not get the warning."
msgstr "如果您提供起始目錄作為包名稱而不是目錄路徑，則 discover "
"會假定它從哪個位置導入是您想要的位置，因此您不會收到警告。"

#: ../../library/unittest.rst:333
#, fuzzy
msgid ""
"Test modules and packages can customize test loading and discovery by "
"through the `load_tests protocol`_."
msgstr "測試模組和包可以通過 load_tests 協定自定義測試加載和發現。"

#: ../../library/unittest.rst:336
#, fuzzy
msgid ""
"Test discovery supports :term:`namespace packages <namespace package>` for "
"the start directory. Note that you need to specify the top level directory "
"too (e.g. ``python -m unittest discover -s root/namespace -t root``)."
msgstr ""
"測試發現支援 :term:`namespace packages <namespace package>` "
"作為起始目錄。請注意，您還需要指定頂級目錄（例如 ``python -m unittest "
"discover -s root/namespace -t root``）。"

#: ../../library/unittest.rst:342
#, fuzzy
msgid ""
"Python 3.11 dropped the :term:`namespace packages <namespace package>` "
"support. It has been broken since Python 3.7. Start directory and "
"subdirectories containing tests must be regular package that have ``__init__."
"py`` file."
msgstr ""
"Python 3.11 放棄了對 :term:`namespace packages <namespace package>` 的支援。"
"自 Python 3.7 以來它已被破壞。包含測試的起始目錄和子目錄必須是具有 ``__init__"
".py`` 文件的常規包。"

#: ../../library/unittest.rst:348
#, fuzzy
msgid ""
"Directories containing start directory still can be a namespace package. In "
"this case, you need to specify start directory as dotted package name, and "
"target directory explicitly. For example::"
msgstr "包含起始目錄的目錄仍然可以是命名空間包。在這種情況下，您需要將起始目錄指定為"
"帶點的包名稱，並明確指定目標目錄。例如：："

#: ../../library/unittest.rst:364
#, fuzzy
msgid "Organizing test code"
msgstr "組織測試程式碼"

#: ../../library/unittest.rst:366
#, fuzzy
msgid ""
"The basic building blocks of unit testing are :dfn:`test cases` --- single "
"scenarios that must be set up and checked for correctness.  In :mod:"
"`unittest`, test cases are represented by :class:`unittest.TestCase` "
"instances. To make your own test cases you must write subclasses of :class:"
"`TestCase` or use :class:`FunctionTestCase`."
msgstr ""
"單元測試的基本構建塊是 :dfn:`test cases` --- 必須設定並檢查正確性的單一場景。"
"在 unittest 中，測試用例由 unittest.TestCase 實例表示。要製作自己的測試用例，"
"您必須編寫 :class:`TestCase` 的子類別或使用 :class:`FunctionTestCase`。"

#: ../../library/unittest.rst:372
#, fuzzy
msgid ""
"The testing code of a :class:`TestCase` instance should be entirely self "
"contained, such that it can be run either in isolation or in arbitrary "
"combination with any number of other test cases."
msgstr ":class:`TestCase` 實例的測試程式碼應該是完全自包含的，這樣它就可以單獨運行，"
"也可以與任意數量的其他測試用例任意組合運行。"

#: ../../library/unittest.rst:376
#, fuzzy
msgid ""
"The simplest :class:`TestCase` subclass will simply implement a test method "
"(i.e. a method whose name starts with ``test``) in order to perform specific "
"testing code::"
msgstr ""
"最簡單的 :class:`TestCase` 子類別將簡單地實作一個測試方法（即名稱以 ``test`` "
"開頭的方法）以執行特定的測試程式碼::"

#: ../../library/unittest.rst:387
#, fuzzy
msgid ""
"Note that in order to test something, we use one of the :meth:`assert\\*` "
"methods provided by the :class:`TestCase` base class.  If the test fails, an "
"exception will be raised with an explanatory message, and :mod:`unittest` "
"will identify the test case as a :dfn:`failure`.  Any other exceptions will "
"be treated as :dfn:`errors`."
msgstr ""
"請注意，為了測試某些東西，我們使用 :class:`TestCase` 基底類別提供的 :meth:`"
"assert\\*` 方法之一。如果測試失敗，將引發例外並顯示一條解釋性消息，unittest "
"會將測試用例標識為 failure。任何其他例外都將被視為 :dfn:`errors`。"

#: ../../library/unittest.rst:393
#, fuzzy
msgid ""
"Tests can be numerous, and their set-up can be repetitive.  Luckily, we can "
"factor out set-up code by implementing a method called :meth:`~TestCase."
"setUp`, which the testing framework will automatically call for every single "
"test we run::"
msgstr ""
"測試可能很多，而且它們的設定可能是重複的。幸運的是，我們可以通過實作一個名為 "
":meth:`~TestCase.setUp` "
"的方法來提取設定程式碼，測試框架將自動為我們運行的每個測試呼叫該方法::"

#: ../../library/unittest.rst:414
#, fuzzy
msgid ""
"The order in which the various tests will be run is determined by sorting "
"the test method names with respect to the built-in ordering for strings."
msgstr "運行各種測試的順序是通過根據字串的內建順序對測試方法名稱進行排序來確定的。"

#: ../../library/unittest.rst:418
#, fuzzy
msgid ""
"If the :meth:`~TestCase.setUp` method raises an exception while the test is "
"running, the framework will consider the test to have suffered an error, and "
"the test method will not be executed."
msgstr "如果 :meth:`~TestCase.setUp` "
"方法在測試運行時引發例外，框架將認為測試遇到錯誤，並且不會執行測試方法。"

#: ../../library/unittest.rst:422
#, fuzzy
msgid ""
"Similarly, we can provide a :meth:`~TestCase.tearDown` method that tidies up "
"after the test method has been run::"
msgstr "同樣，我們可以提供一個 :meth:`~TestCase.tearDown` "
"方法，在運行測試方法後進行整理："

#: ../../library/unittest.rst:434
#, fuzzy
msgid ""
"If :meth:`~TestCase.setUp` succeeded, :meth:`~TestCase.tearDown` will be run "
"whether the test method succeeded or not."
msgstr ""
"如果 :meth:`~TestCase.setUp` 成功，則 :meth:`~TestCase.tearDown` "
"將運行，無論測試方法是否成功。"

#: ../../library/unittest.rst:437
#, fuzzy
msgid ""
"Such a working environment for the testing code is called a :dfn:`test "
"fixture`.  A new TestCase instance is created as a unique test fixture used "
"to execute each individual test method.  Thus :meth:`~TestCase.setUp`, :meth:"
"`~TestCase.tearDown`, and :meth:`~TestCase.__init__` will be called once per "
"test."
msgstr ""
"這種用於測試程式碼的工作環境稱為 :dfn:`test fixture`。一個新的 TestCase "
"實例被建立為一個唯一的測試夾具，用於執行每個單獨的測試方法。因此 "
":meth:`~TestCase.setUp`、:meth:`~TestCase.tearDown` 和 :meth:`~TestCase."
"__init__` 將在每個測試中呼叫一次。"

#: ../../library/unittest.rst:443
#, fuzzy
msgid ""
"It is recommended that you use TestCase implementations to group tests "
"together according to the features they test.  :mod:`unittest` provides a "
"mechanism for this: the :dfn:`test suite`, represented by :mod:`unittest`'s :"
"class:`TestSuite` class.  In most cases, calling :func:`unittest.main` will "
"do the right thing and collect all the module's test cases for you and "
"execute them."
msgstr ""
"建議您使用 TestCase 實作根據測試的功能將測試分組在一起。 :mod:`unittest` "
"為此提供了一種機制：:dfn:`test suite`，由 :mod:`unittest` 的 "
":class:`TestSuite` 類表示。在大多數情況下，呼叫 :func:`unittest.main` "
"會做正確的事情並為您收集所有模組的測試用例並執行它們。"

#: ../../library/unittest.rst:450
#, fuzzy
msgid ""
"However, should you want to customize the building of your test suite, you "
"can do it yourself::"
msgstr "但是，如果您想自定義測試套件的構建，您可以自己做::"

#: ../../library/unittest.rst:463
#, fuzzy
msgid ""
"You can place the definitions of test cases and test suites in the same "
"modules as the code they are to test (such as :file:`widget.py`), but there "
"are several advantages to placing the test code in a separate module, such "
"as :file:`test_widget.py`:"
msgstr ""
"您可以將測試用例和測試套件的定義放在與它們要測試的程式碼相同的模組中（例如：f"
"ile:`widget."
"py`），但是將測試程式碼放在單獨的模組中有幾個優點，例如 :file:`test_widget."
"py`："

#: ../../library/unittest.rst:468
#, fuzzy
msgid "The test module can be run standalone from the command line."
msgstr "測試模組可以從命令列獨立運行。"

#: ../../library/unittest.rst:470
#, fuzzy
msgid "The test code can more easily be separated from shipped code."
msgstr "測試程式碼可以更容易地與發布的程式碼分開。"

#: ../../library/unittest.rst:472
#, fuzzy
msgid ""
"There is less temptation to change test code to fit the code it tests "
"without a good reason."
msgstr "沒有充分理由就更改測試程式碼以適應它測試的程式碼的誘惑較小。"

#: ../../library/unittest.rst:475
#, fuzzy
msgid ""
"Test code should be modified much less frequently than the code it tests."
msgstr "測試程式碼的修改頻率應該比它測試的程式碼低得多。"

#: ../../library/unittest.rst:477
#, fuzzy
msgid "Tested code can be refactored more easily."
msgstr "可以更輕鬆地重構經過測試的程式碼。"

#: ../../library/unittest.rst:479
#, fuzzy
msgid ""
"Tests for modules written in C must be in separate modules anyway, so why "
"not be consistent?"
msgstr "用 C 編寫的模組的測試無論如何都必須在單獨的模組中，那麼為什麼不保持一致呢？"

#: ../../library/unittest.rst:482
#, fuzzy
msgid ""
"If the testing strategy changes, there is no need to change the source code."
msgstr "如果測試策略發生變化，則無需更改源程式碼。"

#: ../../library/unittest.rst:488
#, fuzzy
msgid "Re-using old test code"
msgstr "重新使用舊的測試程式碼"

#: ../../library/unittest.rst:490
#, fuzzy
msgid ""
"Some users will find that they have existing test code that they would like "
"to run from :mod:`unittest`, without converting every old test function to "
"a :class:`TestCase` subclass."
msgstr "一些使用者會發現他們有現成的測試程式碼，他們想從 unittest 運行，"
"而不需要將每個舊測試函式轉換為 TestCase 子類別。"

#: ../../library/unittest.rst:494
#, fuzzy
msgid ""
"For this reason, :mod:`unittest` provides a :class:`FunctionTestCase` class. "
"This subclass of :class:`TestCase` can be used to wrap an existing test "
"function.  Set-up and tear-down functions can also be provided."
msgstr ""
"為此，unittest 提供了一個 FunctionTestCase 類。 :class:`TestCase` "
"的這個子類別可用於包裝現有的測試函式。還可以提供設定和拆卸功能。"

#: ../../library/unittest.rst:498
#, fuzzy
msgid "Given the following test function::"
msgstr "給定以下測試功能::"

#: ../../library/unittest.rst:505
#, fuzzy
msgid ""
"one can create an equivalent test case instance as follows, with optional "
"set-up and tear-down methods::"
msgstr "可以建立一個等效的測試用例實例，如下所示，具有可選的設定和拆卸方法::"

#: ../../library/unittest.rst:514
#, fuzzy
msgid ""
"Even though :class:`FunctionTestCase` can be used to quickly convert an "
"existing test base over to a :mod:`unittest`\\ -based system, this approach "
"is not recommended.  Taking the time to set up proper :class:`TestCase` "
"subclasses will make future test refactorings infinitely easier."
msgstr ""
"儘管 FunctionTestCase 可用於快速將現有測試基礎轉換為基於 unittest "
"的系統，但不推薦這種方法。花時間設定適當的 :class:`TestCase` "
"子類別將使未來的測試重構變得更加容易。"

#: ../../library/unittest.rst:519
#, fuzzy
msgid ""
"In some cases, the existing tests may have been written using the :mod:"
"`doctest` module.  If so, :mod:`doctest` provides a :class:`DocTestSuite` "
"class that can automatically build :class:`unittest.TestSuite` instances "
"from the existing :mod:`doctest`\\ -based tests."
msgstr ""
"在某些情況下，現有測試可能是使用 :mod:`doctest` 模組編寫的。如果是這樣， "
":mod:`doctest` 提供了一個 :class:`DocTestSuite` 類，可以從現有的"
" :mod:`doctest`\\ 自動構建 :class:`unittest.TestSuite` 實例。"

#: ../../library/unittest.rst:528
#, fuzzy
msgid "Skipping tests and expected failures"
msgstr "跳過測試和預期的失敗"

#: ../../library/unittest.rst:532
#, fuzzy
msgid ""
"Unittest supports skipping individual test methods and even whole classes of "
"tests.  In addition, it supports marking a test as an \"expected failure,\" "
"a test that is broken and will fail, but shouldn't be counted as a failure "
"on a :class:`TestResult`."
msgstr ""
"Unittest 支援跳過單個測試方法甚至整個類的測試。此外，它支援將測試標記為“預期"
"失敗”，即已損壞且將失敗的測試，但不應計為 TestResult 上的失敗。"

#: ../../library/unittest.rst:537
#, fuzzy
msgid ""
"Skipping a test is simply a matter of using the :func:`skip` :term:"
"`decorator` or one of its conditional variants, calling :meth:`TestCase."
"skipTest` within a :meth:`~TestCase.setUp` or test method, or raising :exc:"
"`SkipTest` directly."
msgstr ""
"跳過測試只是使用 :func:`skip` :term:`decorator` 或其條件變體之一，在 "
":meth:`~TestCase.setUp` 中呼叫 :meth:`TestCase.skipTest` "
"或測試方法，或直接提高 :exc:`SkipTest`。"

#: ../../library/unittest.rst:541
#, fuzzy
msgid "Basic skipping looks like this::"
msgstr "基本跳過看起來像這樣::"

#: ../../library/unittest.rst:566
#, fuzzy
msgid "This is the output of running the example above in verbose mode::"
msgstr "這是在詳細模式下運行上面示例的輸出："

#: ../../library/unittest.rst:578
#, fuzzy
msgid "Classes can be skipped just like methods::"
msgstr "可以像方法一樣跳過類::"

#: ../../library/unittest.rst:585
#, fuzzy
msgid ""
":meth:`TestCase.setUp` can also skip the test.  This is useful when a "
"resource that needs to be set up is not available."
msgstr ":meth:`TestCase.setUp` 也可以跳過測試。當需要設定的資源不可用時，這很有用。"

#: ../../library/unittest.rst:588
#, fuzzy
msgid "Expected failures use the :func:`expectedFailure` decorator. ::"
msgstr "預期失敗使用 :func:`expectedFailure` 裝飾器。 ::"

#: ../../library/unittest.rst:595
#, fuzzy
msgid ""
"It's easy to roll your own skipping decorators by making a decorator that "
"calls :func:`skip` on the test when it wants it to be skipped.  This "
"decorator skips the test unless the passed object has a certain attribute::"
msgstr ""
"通過製作一個在測試中呼叫 :func:`skip` 的裝飾器，當它想要跳過它時，很容易滾動"
"你自己的跳過裝飾器。除非傳遞的物件具有特定屬性，否則此裝飾器會跳過測試："

#: ../../library/unittest.rst:604
#, fuzzy
msgid ""
"The following decorators and exception implement test skipping and expected "
"failures:"
msgstr "以下裝飾器和例外實作了測試跳過和預期的失敗："

#: ../../library/unittest.rst:608
#, fuzzy
msgid ""
"Unconditionally skip the decorated test.  *reason* should describe why the "
"test is being skipped."
msgstr "無條件跳過裝飾測試。 *原因* 應該描述為什麼跳過測試。"

#: ../../library/unittest.rst:613
#, fuzzy
msgid "Skip the decorated test if *condition* is true."
msgstr "如果 *condition* 為真，則跳過裝飾測試。"

#: ../../library/unittest.rst:617
#, fuzzy
msgid "Skip the decorated test unless *condition* is true."
msgstr "除非 *condition* 為真，否則跳過裝飾測試。"

#: ../../library/unittest.rst:621
#, fuzzy
msgid ""
"Mark the test as an expected failure or error.  If the test fails or errors "
"in the test function itself (rather than in one of the :dfn:`test fixture` "
"methods) then it will be considered a success.  If the test passes, it will "
"be considered a failure."
msgstr ""
"將測試標記為預期的失敗或錯誤。如果測試失敗或測試函式本身出錯（而不是 :dfn:`"
"test fixture` 方法之一），那麼它將被視為成功。如果測試通過，則視為失敗。"

#: ../../library/unittest.rst:628
#, fuzzy
msgid "This exception is raised to skip a test."
msgstr "引發此例外以跳過測試。"

#: ../../library/unittest.rst:630
#, fuzzy
msgid ""
"Usually you can use :meth:`TestCase.skipTest` or one of the skipping "
"decorators instead of raising this directly."
msgstr "通常您可以使用 :meth:`TestCase.skipTest` "
"或其中一種跳過裝飾器，而不是直接引發它。"

#: ../../library/unittest.rst:633
#, fuzzy
msgid ""
"Skipped tests will not have :meth:`~TestCase.setUp` or :meth:`~TestCase."
"tearDown` run around them. Skipped classes will not have :meth:`~TestCase."
"setUpClass` or :meth:`~TestCase.tearDownClass` run. Skipped modules will not "
"have :func:`setUpModule` or :func:`tearDownModule` run."
msgstr ""
"跳過的測試不會有 :meth:`~TestCase.setUp` 或 :meth:`~TestCase.tearDown` "
"在它們周圍運行。跳過的課程將不會運行 :meth:`~TestCase.setUpClass` 或 "
":meth:`~TestCase.tearDownClass` 。跳過的模組將不會運行 :func:`setUpModule` "
"或 :func:`tearDownModule`。"

#: ../../library/unittest.rst:641
#, fuzzy
msgid "Distinguishing test iterations using subtests"
msgstr "使用子測試區分測試疊代"

#: ../../library/unittest.rst:645
#, fuzzy
msgid ""
"When there are very small differences among your tests, for instance some "
"parameters, unittest allows you to distinguish them inside the body of a "
"test method using the :meth:`~TestCase.subTest` context manager."
msgstr ""
"當您的測試之間存在非常小的差異時，例如某些參數，unittest 允許您使用 "
":meth:`~TestCase.subTest` 上下文管理器在測試方法的主體內區分它們。"

#: ../../library/unittest.rst:649
msgid "For example, the following test::"
msgstr ""
"舉例來說，以下測試：\n"
"\n"
"::"

#: ../../library/unittest.rst:661
msgid "will produce the following output::"
msgstr ""
"會有以下輸出：\n"
"\n"
"::"

#: ../../library/unittest.rst:693
#, fuzzy
msgid ""
"Without using a subtest, execution would stop after the first failure, and "
"the error would be less easy to diagnose because the value of ``i`` wouldn't "
"be displayed::"
msgstr "如果不使用子測試，執行將在第一次失敗後停止，並且錯誤將不太容易診斷，"
"因為不會顯示 ``i`` 的值::"

#: ../../library/unittest.rst:709
#, fuzzy
msgid "Classes and functions"
msgstr "類和函式"

#: ../../library/unittest.rst:711
#, fuzzy
msgid "This section describes in depth the API of :mod:`unittest`."
msgstr "本節深入介紹 :mod:`unittest` 的 API。"

#: ../../library/unittest.rst:717
#, fuzzy
msgid "Test cases"
msgstr "測試用例"

#: ../../library/unittest.rst:721
#, fuzzy
msgid ""
"Instances of the :class:`TestCase` class represent the logical test units in "
"the :mod:`unittest` universe.  This class is intended to be used as a base "
"class, with specific tests being implemented by concrete subclasses.  This "
"class implements the interface needed by the test runner to allow it to "
"drive the tests, and methods that the test code can use to check for and "
"report various kinds of failure."
msgstr ""
":class:`TestCase` 類的實例代表 :mod:`unittest` 宇宙中的邏輯測試單元。此類旨在"
"用作基底類別，具體測試由具體子類別實作。此類實作測試運行器所需的介面以允許它"
"驅動測試，以及測試程式碼可用於檢查和報告各種故障的方法。"

#: ../../library/unittest.rst:728
#, fuzzy
msgid ""
"Each instance of :class:`TestCase` will run a single base method: the method "
"named *methodName*. In most uses of :class:`TestCase`, you will neither "
"change the *methodName* nor reimplement the default ``runTest()`` method."
msgstr ""
":class:`TestCase` 的每個實例都將運行一個基本方法：名為 *methodName* 的方法。"
"在 :class:`TestCase` 的大多數使用中，您既不會更改 *methodName* "
"也不會重新實作預設的 ``runTest()`` 方法。"

#: ../../library/unittest.rst:733
#, fuzzy
msgid ""
":class:`TestCase` can be instantiated successfully without providing a "
"*methodName*. This makes it easier to experiment with :class:`TestCase` from "
"the interactive interpreter."
msgstr ""
":class:`TestCase` 可以在不提供 *methodName* 的情況下成功實例化。"
"這使得從交互式直譯器中試驗 :class:`TestCase` 變得更加容易。"

#: ../../library/unittest.rst:738
#, fuzzy
msgid ""
":class:`TestCase` instances provide three groups of methods: one group used "
"to run the test, another used by the test implementation to check conditions "
"and report failures, and some inquiry methods allowing information about the "
"test itself to be gathered."
msgstr ""
":class:`TestCase` 實例提供三組方法：一組用於運行測試，另一組用於測試實作檢查"
"條件和報告失敗，以及一些允許收集有關測試本身的資訊的查詢方法。"

#: ../../library/unittest.rst:743
#, fuzzy
msgid "Methods in the first group (running the test) are:"
msgstr "第一組（運行測試）中的方法是："

#: ../../library/unittest.rst:747
#, fuzzy
msgid ""
"Method called to prepare the test fixture.  This is called immediately "
"before calling the test method; other than :exc:`AssertionError` or :exc:"
"`SkipTest`, any exception raised by this method will be considered an error "
"rather than a test failure. The default implementation does nothing."
msgstr ""
"呼叫方法來準備測試夾具。這是在呼叫測試方法之前立即呼叫的；除了 "
":exc:`AssertionError` 或 :exc:`SkipTest` "
"之外，此方法引發的任何例外都將被視為錯誤而不是測試失敗。預設實作什麼也不做。"

#: ../../library/unittest.rst:755
#, fuzzy
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called even if the test method raised an "
"exception, so the implementation in subclasses may need to be particularly "
"careful about checking internal state.  Any exception, other than :exc:"
"`AssertionError` or :exc:`SkipTest`, raised by this method will be "
"considered an additional error rather than a test failure (thus increasing "
"the total number of reported errors). This method will only be called if "
"the :meth:`setUp` succeeds, regardless of the outcome of the test method. "
"The default implementation does nothing."
msgstr ""
"在呼叫測試方法並記錄結果後立即呼叫方法。即使測試方法引發例外也會呼叫它，因此"
"子類別中的實作可能需要特別小心檢查內部狀態。除了 :exc:`AssertionError` 或 "
":exc:`SkipTest` 之外，此方法引發的任何例外都將被視為附加錯誤而不是測試失敗（"
"從而增加報告錯誤的總數）。僅當 :meth:`setUp` "
"成功時才會呼叫此方法，而不管測試方法的結果如何。預設實作什麼也不做。"

#: ../../library/unittest.rst:768
#, fuzzy
msgid ""
"A class method called before tests in an individual class are run. "
"``setUpClass`` is called with the class as the only argument and must be "
"decorated as a :func:`classmethod`::"
msgstr ""
"在運行單個類中的測試之前呼叫的類方法。 ``setUpClass`` 以類作為唯一參數呼叫，"
"並且必須裝飾為 :func:`classmethod`::"

#: ../../library/unittest.rst:776 ../../library/unittest.rst:791
msgid "See `Class and Module Fixtures`_ for more details."
msgstr "更多細節請見 `Class and Module Fixtures`_\\ 。"

#: ../../library/unittest.rst:783
#, fuzzy
msgid ""
"A class method called after tests in an individual class have run. "
"``tearDownClass`` is called with the class as the only argument and must be "
"decorated as a :meth:`classmethod`::"
msgstr ""
"在單個類中的測試運行後呼叫的類方法。 ``tearDownClass`` 以類作為唯一參數呼叫，"
"並且必須裝飾為 :meth:`classmethod`::"

#: ../../library/unittest.rst:798
#, fuzzy
msgid ""
"Run the test, collecting the result into the :class:`TestResult` object "
"passed as *result*.  If *result* is omitted or ``None``, a temporary result "
"object is created (by calling the :meth:`defaultTestResult` method) and "
"used. The result object is returned to :meth:`run`'s caller."
msgstr ""
"運行測試，將結果收集到作為 *result* 傳遞的 :class:`TestResult` 對像中。"
"如果省略 *result* 或 ``None``，則會建立一個臨時結果物件（通過呼叫 "
"defaultTestResult 方法）並使用。結果物件回傳給 :meth:`run` 的呼叫者。"

#: ../../library/unittest.rst:804
#, fuzzy
msgid ""
"The same effect may be had by simply calling the :class:`TestCase` instance."
msgstr "只需呼叫 :class:`TestCase` 實例即可獲得相同的效果。"

#: ../../library/unittest.rst:807
#, fuzzy
msgid ""
"Previous versions of ``run`` did not return the result. Neither did calling "
"an instance."
msgstr "以前版本的 ``run`` 沒有回傳結果。呼叫實例也沒有。"

#: ../../library/unittest.rst:813
#, fuzzy
msgid ""
"Calling this during a test method or :meth:`setUp` skips the current test.  "
"See :ref:`unittest-skipping` for more information."
msgstr "在測試方法或 :meth:`setUp` "
"期間呼叫它會跳過當前測試。有關詳細資訊，請參閱 :ref:`unittest-skipping`。"

#: ../../library/unittest.rst:821
#, fuzzy
msgid ""
"Return a context manager which executes the enclosed code block as a "
"subtest.  *msg* and *params* are optional, arbitrary values which are "
"displayed whenever a subtest fails, allowing you to identify them clearly."
msgstr ""
"回傳一個上下文管理器，它將封閉的程式碼塊作為子測試執行。 *msg* 和 *params* "
"是可選的任意值，只要子測試失敗就會顯示這些值，以便您清楚地識別它們。"

#: ../../library/unittest.rst:826
#, fuzzy
msgid ""
"A test case can contain any number of subtest declarations, and they can be "
"arbitrarily nested."
msgstr "一個測試用例可以包含任意數量的子測試聲明，並且它們可以任意嵌套。"

#: ../../library/unittest.rst:829
msgid "See :ref:`subtests` for more information."
msgstr "更多資訊請見 :ref:`subtests`\\ 。"

#: ../../library/unittest.rst:836
#, fuzzy
msgid ""
"Run the test without collecting the result.  This allows exceptions raised "
"by the test to be propagated to the caller, and can be used to support "
"running tests under a debugger."
msgstr "運行測試而不收集結果。這允許將測試引發的例外傳播給呼叫者，並可用於支援在除錯"
"器下運行測試。"

#: ../../library/unittest.rst:842
#, fuzzy
msgid ""
"The :class:`TestCase` class provides several assert methods to check for and "
"report failures.  The following table lists the most commonly used methods "
"(see the tables below for more assert methods):"
msgstr ":class:`TestCase` 類提供了幾種斷言方法來檢查和報告失敗。下表列出了最常用的方"
"法（更多斷言方法見下表）："

#: ../../library/unittest.rst:847 ../../library/unittest.rst:968
#: ../../library/unittest.rst:1182 ../../library/unittest.rst:1309
#, fuzzy
msgid "Method"
msgstr "方法"

#: ../../library/unittest.rst:847 ../../library/unittest.rst:968
#: ../../library/unittest.rst:1182
#, fuzzy
msgid "Checks that"
msgstr "檢查那個"

#: ../../library/unittest.rst:847 ../../library/unittest.rst:968
#: ../../library/unittest.rst:1182 ../../library/unittest.rst:1309
#, fuzzy
msgid "New in"
msgstr "新進"

#: ../../library/unittest.rst:849
msgid ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"
msgstr ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"

#: ../../library/unittest.rst:849
msgid "``a == b``"
msgstr "``a == b``"

#: ../../library/unittest.rst:852
msgid ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"
msgstr ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"

#: ../../library/unittest.rst:852
msgid "``a != b``"
msgstr "``a != b``"

#: ../../library/unittest.rst:855
msgid ":meth:`assertTrue(x) <TestCase.assertTrue>`"
msgstr ":meth:`assertTrue(x) <TestCase.assertTrue>`"

#: ../../library/unittest.rst:855
msgid "``bool(x) is True``"
msgstr "``bool(x) is True``"

#: ../../library/unittest.rst:858
msgid ":meth:`assertFalse(x) <TestCase.assertFalse>`"
msgstr ":meth:`assertFalse(x) <TestCase.assertFalse>`"

#: ../../library/unittest.rst:858
msgid "``bool(x) is False``"
msgstr "``bool(x) is False``"

#: ../../library/unittest.rst:861
msgid ":meth:`assertIs(a, b) <TestCase.assertIs>`"
msgstr ":meth:`assertIs(a, b) <TestCase.assertIs>`"

#: ../../library/unittest.rst:861
msgid "``a is b``"
msgstr "``a is b``"

#: ../../library/unittest.rst:861 ../../library/unittest.rst:864
#: ../../library/unittest.rst:867 ../../library/unittest.rst:870
#: ../../library/unittest.rst:873 ../../library/unittest.rst:876
#: ../../library/unittest.rst:973 ../../library/unittest.rst:1190
#: ../../library/unittest.rst:1193 ../../library/unittest.rst:1196
#: ../../library/unittest.rst:1199 ../../library/unittest.rst:1202
#: ../../library/unittest.rst:1311 ../../library/unittest.rst:1314
#: ../../library/unittest.rst:1317 ../../library/unittest.rst:1320
#: ../../library/unittest.rst:1323 ../../library/unittest.rst:1326
msgid "3.1"
msgstr "3.1"

#: ../../library/unittest.rst:864
msgid ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"
msgstr ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"

#: ../../library/unittest.rst:864
msgid "``a is not b``"
msgstr "``a is not b``"

#: ../../library/unittest.rst:867
msgid ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"
msgstr ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"

#: ../../library/unittest.rst:867
msgid "``x is None``"
msgstr "``x is None``"

#: ../../library/unittest.rst:870
msgid ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"
msgstr ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"

#: ../../library/unittest.rst:870
msgid "``x is not None``"
msgstr "``x is not None``"

#: ../../library/unittest.rst:873
msgid ":meth:`assertIn(a, b) <TestCase.assertIn>`"
msgstr ":meth:`assertIn(a, b) <TestCase.assertIn>`"

#: ../../library/unittest.rst:873
msgid "``a in b``"
msgstr "``a in b``"

#: ../../library/unittest.rst:876
msgid ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"
msgstr ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"

#: ../../library/unittest.rst:876
msgid "``a not in b``"
msgstr "``a not in b``"

#: ../../library/unittest.rst:879
msgid ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"
msgstr ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"

#: ../../library/unittest.rst:879
msgid "``isinstance(a, b)``"
msgstr "``isinstance(a, b)``"

#: ../../library/unittest.rst:879 ../../library/unittest.rst:882
#: ../../library/unittest.rst:976 ../../library/unittest.rst:979
#: ../../library/unittest.rst:1205 ../../library/unittest.rst:1208
msgid "3.2"
msgstr "3.2"

#: ../../library/unittest.rst:882
msgid ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"
msgstr ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"

#: ../../library/unittest.rst:882
msgid "``not isinstance(a, b)``"
msgstr "``not isinstance(a, b)``"

#: ../../library/unittest.rst:886
#, fuzzy
msgid ""
"All the assert methods accept a *msg* argument that, if specified, is used "
"as the error message on failure (see also :data:`longMessage`). Note that "
"the *msg* keyword argument can be passed to :meth:`assertRaises`, :meth:"
"`assertRaisesRegex`, :meth:`assertWarns`, :meth:`assertWarnsRegex` only when "
"they are used as a context manager."
msgstr ""
"所有斷言方法都接受 *msg* 參數，如果指定，該參數將用作失敗時的錯誤消息（另請參"
"見 :data:`longMessage`）。請注意，*msg* 關鍵字參數可以傳遞給 :meth:`assertRais"
"es`、:meth:`assertRaisesRegex`、:meth:`assertWarns`、:meth:`assertWarnsRegex`"
" 只有當它們被用作上下文管理器時。"

#: ../../library/unittest.rst:894
#, fuzzy
msgid ""
"Test that *first* and *second* are equal.  If the values do not compare "
"equal, the test will fail."
msgstr "測試 *first* 和 *second* 是否相等。如果值比較不相等，則測試將失敗。"

#: ../../library/unittest.rst:897
#, fuzzy
msgid ""
"In addition, if *first* and *second* are the exact same type and one of "
"list, tuple, dict, set, frozenset or str or any type that a subclass "
"registers with :meth:`addTypeEqualityFunc` the type-specific equality "
"function will be called in order to generate a more useful default error "
"message (see also the :ref:`list of type-specific methods <type-specific-"
"methods>`)."
msgstr ""
"此外，如果 *first* 和 *second* 是完全相同的型別，並且是 "
"list、tuple、dict、set、frozenset 或 str 之一，或者是子類別使用 "
"addTypeEqualityFunc "
"註冊的任何型別，則型別特定的相等函式將被呼叫以生成更有用的預設錯誤消息（"
"另請參閱 :ref:`list of type-specific methods <type-specific-methods>`）。"

#: ../../library/unittest.rst:904
#, fuzzy
msgid "Added the automatic calling of type-specific equality function."
msgstr "新增了特定型別相等函式的自動呼叫。"

#: ../../library/unittest.rst:907
#, fuzzy
msgid ""
":meth:`assertMultiLineEqual` added as the default type equality function for "
"comparing strings."
msgstr ":meth:`assertMultiLineEqual` 新增為比較字串的預設型別相等函式。"

#: ../../library/unittest.rst:914
#, fuzzy
msgid ""
"Test that *first* and *second* are not equal.  If the values do compare "
"equal, the test will fail."
msgstr "測試 *first* 和 *second* 不相等。如果值確實比較相等，則測試將失敗。"

#: ../../library/unittest.rst:920
#, fuzzy
msgid "Test that *expr* is true (or false)."
msgstr "測試 *expr* 為真（或假）。"

#: ../../library/unittest.rst:922
#, fuzzy
msgid ""
"Note that this is equivalent to ``bool(expr) is True`` and not to ``expr is "
"True`` (use ``assertIs(expr, True)`` for the latter).  This method should "
"also be avoided when more specific methods are available (e.g. "
"``assertEqual(a, b)`` instead of ``assertTrue(a == b)``), because they "
"provide a better error message in case of failure."
msgstr ""
"請注意，這等效於“bool(expr) is True”而不是“expr is True”（後者使用“assertIs("
"expr, "
"True)”）。當更具體的方法可用時，也應避免使用此方法（例如，``assertEqual(a, "
"b)`` 而不是 ``assertTrue(a == b)``），因為它們會在失敗時提供更好的錯誤消息."

#: ../../library/unittest.rst:932
#, fuzzy
msgid "Test that *first* and *second* are (or are not) the same object."
msgstr "測試 *first* 和 *second* 是（或不是）同一個物件。"

#: ../../library/unittest.rst:940
#, fuzzy
msgid "Test that *expr* is (or is not) ``None``."
msgstr "測試 *expr* 是（或不是）``None``。"

#: ../../library/unittest.rst:948
#, fuzzy
msgid "Test that *member* is (or is not) in *container*."
msgstr "測試 *member* 在（或不在）*container* 中。"

#: ../../library/unittest.rst:956
#, fuzzy
msgid ""
"Test that *obj* is (or is not) an instance of *cls* (which can be a class or "
"a tuple of classes, as supported by :func:`isinstance`). To check for the "
"exact type, use :func:`assertIs(type(obj), cls) <assertIs>`."
msgstr ""
"測試 *obj* 是（或不是）*cls* 的實例（它可以是類或類的元組，由 "
":func:`isinstance` 支援）。要檢查確切的型別，請使用 :func:`assertIs(type(obj)"
", cls) <assertIs>`。"

#: ../../library/unittest.rst:964
#, fuzzy
msgid ""
"It is also possible to check the production of exceptions, warnings, and log "
"messages using the following methods:"
msgstr "還可以使用以下方法檢查例外、警告和日誌消息的產生："

#: ../../library/unittest.rst:970
msgid ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"
msgstr ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"

#: ../../library/unittest.rst:970
#, fuzzy
msgid "``fun(*args, **kwds)`` raises *exc*"
msgstr "``fun(*args, **kwds)`` 引發 *exc*"

#: ../../library/unittest.rst:973
#, fuzzy
msgid ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"
msgstr ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"

#: ../../library/unittest.rst:973
#, fuzzy
msgid "``fun(*args, **kwds)`` raises *exc* and the message matches regex *r*"
msgstr "``fun(*args, **kwds)`` 引發 *exc* 並且消息匹配正則表達式 *r*"

#: ../../library/unittest.rst:976
msgid ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"
msgstr ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"

#: ../../library/unittest.rst:976
#, fuzzy
msgid "``fun(*args, **kwds)`` raises *warn*"
msgstr "``fun(*args, **kwds)`` 引發 *warn*"

#: ../../library/unittest.rst:979
#, fuzzy
msgid ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"
msgstr ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"

#: ../../library/unittest.rst:979
#, fuzzy
msgid "``fun(*args, **kwds)`` raises *warn* and the message matches regex *r*"
msgstr "``fun(*args, **kwds)`` 引發 *warn* 並且消息匹配正則表達式 *r*"

#: ../../library/unittest.rst:982
msgid ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"
msgstr ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"

#: ../../library/unittest.rst:982
#, fuzzy
msgid "The ``with`` block logs on *logger* with minimum *level*"
msgstr "``with`` 塊以最小 *level* 登錄 *logger*"

#: ../../library/unittest.rst:982
msgid "3.4"
msgstr "3.4"

#: ../../library/unittest.rst:985
msgid ":meth:`assertNoLogs(logger, level) <TestCase.assertNoLogs>`"
msgstr ":meth:`assertNoLogs(logger, level) <TestCase.assertNoLogs>`"

#: ../../library/unittest.rst:985
#, fuzzy
msgid "The ``with`` block does not log on"
msgstr "``with`` 塊不登錄"

#: ../../library/unittest.rst:986
#, fuzzy
msgid "*logger* with minimum *level*"
msgstr "*logger* 最低 *level*"

#: ../../library/unittest.rst:985
msgid "3.10"
msgstr "3.10"

#: ../../library/unittest.rst:992
#, fuzzy
msgid ""
"Test that an exception is raised when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertRaises`.  The test passes if *exception* is raised, is an error if "
"another exception is raised, or fails if no exception is raised. To catch "
"any of a group of exceptions, a tuple containing the exception classes may "
"be passed as *exception*."
msgstr ""
"測試當 *callable* 被呼叫時是否會引發例外，"
"其中任何位置參數或關鍵字參數也傳遞給 :meth:`assertRaises`。如果引發 "
"*exception* 則測試通過，如果引發另一個例外則為錯誤，如果沒有引發例外則失敗。"
"要捕獲一組例外中的任何一個，可以將包含例外類的元組作為 *exception* 傳遞。"

#: ../../library/unittest.rst:999
#, fuzzy
msgid ""
"If only the *exception* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr "如果僅給出 *exception* 和可能的 *msg* "
"參數，則回傳一個上下文管理器，以便可以內聯而不是將被測程式碼編寫為函式::"

#: ../../library/unittest.rst:1006
#, fuzzy
msgid ""
"When used as a context manager, :meth:`assertRaises` accepts the additional "
"keyword argument *msg*."
msgstr "當用作上下文管理器時，:meth:`assertRaises` 接受額外的關鍵字參數 *msg*。"

#: ../../library/unittest.rst:1009
#, fuzzy
msgid ""
"The context manager will store the caught exception object in its :attr:"
"`exception` attribute.  This can be useful if the intention is to perform "
"additional checks on the exception raised::"
msgstr "上下文管理器會將捕獲的例外物件儲存在其 :attr:`exception` "
"屬性中。如果打算對引發的例外執行額外檢查，這可能很有用::"

#: ../../library/unittest.rst:1019
#, fuzzy
msgid "Added the ability to use :meth:`assertRaises` as a context manager."
msgstr "新增了使用 :meth:`assertRaises` 作為上下文管理器的能力。"

#: ../../library/unittest.rst:1022
msgid "Added the :attr:`exception` attribute."
msgstr "新增 :attr:`exception` 屬性。"

#: ../../library/unittest.rst:1025 ../../library/unittest.rst:1051
#: ../../library/unittest.rst:1092 ../../library/unittest.rst:1115
#, fuzzy
msgid "Added the *msg* keyword argument when used as a context manager."
msgstr "用作上下文管理器時新增了 *msg* 關鍵字參數。"

#: ../../library/unittest.rst:1032
#, fuzzy
msgid ""
"Like :meth:`assertRaises` but also tests that *regex* matches on the string "
"representation of the raised exception.  *regex* may be a regular expression "
"object or a string containing a regular expression suitable for use by :func:"
"`re.search`.  Examples::"
msgstr ""
"與 :meth:`assertRaises` 類似，但也測試 *regex* 匹配所引發例外的字串表示形式。"
" *regex* 可以是正則表達式對像或包含適合 :func:`re.search` "
"使用的正則表達式的字串。例子：："

#: ../../library/unittest.rst:1040 ../../library/unittest.rst:1108
msgid "or::"
msgstr ""
"或是：\n"
"\n"
"::"

#: ../../library/unittest.rst:1045
#, fuzzy
msgid "Added under the name ``assertRaisesRegexp``."
msgstr "在名稱 ``assertRaisesRegexp`` 下新增。"

#: ../../library/unittest.rst:1048
msgid "Renamed to :meth:`assertRaisesRegex`."
msgstr "重新命名為 :meth:`assertRaisesRegex`\\ 。"

#: ../../library/unittest.rst:1058
#, fuzzy
msgid ""
"Test that a warning is triggered when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertWarns`.  The test passes if *warning* is triggered and fails if it "
"isn't.  Any exception is an error. To catch any of a group of warnings, a "
"tuple containing the warning classes may be passed as *warnings*."
msgstr ""
"測試當 *callable* 使用任何位置參數或關鍵字參數呼叫時是否觸發警告，"
"這些參數也傳遞給 :meth:`assertWarns`。如果 *warning* 被觸發則測試通過，否則測"
"試失敗。任何例外都是錯誤。要捕獲一組警告中的任何一個，"
"可以將包含警告類的元組作為 *warnings* 傳遞。"

#: ../../library/unittest.rst:1065
#, fuzzy
msgid ""
"If only the *warning* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr "如果只給出 *warning* 和可能的 *msg* "
"參數，則回傳一個上下文管理器，以便可以內聯而不是將被測程式碼編寫為函式::"

#: ../../library/unittest.rst:1072
#, fuzzy
msgid ""
"When used as a context manager, :meth:`assertWarns` accepts the additional "
"keyword argument *msg*."
msgstr "當用作上下文管理器時，:meth:`assertWarns` 接受額外的關鍵字參數 *msg*。"

#: ../../library/unittest.rst:1075
#, fuzzy
msgid ""
"The context manager will store the caught warning object in its :attr:"
"`warning` attribute, and the source line which triggered the warnings in "
"the :attr:`filename` and :attr:`lineno` attributes. This can be useful if "
"the intention is to perform additional checks on the warning caught::"
msgstr ""
"上下文管理器會將捕獲的警告物件儲存在其 :attr:`warning` "
"屬性中，並將觸發警告的源程式碼行儲存在 :attr:`filename` 和 :attr:`lineno` "
"屬性中。如果打算對捕獲的警告執行額外檢查，這將很有用："

#: ../../library/unittest.rst:1087
#, fuzzy
msgid ""
"This method works regardless of the warning filters in place when it is "
"called."
msgstr "無論呼叫時是否存在警告過濾器，此方法都有效。"

#: ../../library/unittest.rst:1099
#, fuzzy
msgid ""
"Like :meth:`assertWarns` but also tests that *regex* matches on the message "
"of the triggered warning.  *regex* may be a regular expression object or a "
"string containing a regular expression suitable for use by :func:`re."
"search`.  Example::"
msgstr ""
"與 :meth:`assertWarns` 類似，但也測試 *regex* 與觸發警告的消息匹配。 *regex* "
"可以是正則表達式對像或包含適合 :func:`re.search` "
"使用的正則表達式的字串。例子：："

#: ../../library/unittest.rst:1120
#, fuzzy
msgid ""
"A context manager to test that at least one message is logged on the "
"*logger* or one of its children, with at least the given *level*."
msgstr "一個上下文管理器，用於測試至少一條消息記錄在 *logger* 或其子項之一上，"
"至少具有給定的 *level*。"

#: ../../library/unittest.rst:1124
#, fuzzy
msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a :class:"
"`str` giving the name of a logger.  The default is the root logger, which "
"will catch all messages that were not blocked by a non-propagating "
"descendent logger."
msgstr ""
"如果給定，*logger* 應該是 :class:`logging.Logger` 對像或 :class:`str` 給出記"
"錄器的名稱。預設是根記錄器，它將捕獲所有未被非傳播後代記錄器阻止的消息。"

#: ../../library/unittest.rst:1129 ../../library/unittest.rst:1170
#, fuzzy
msgid ""
"If given, *level* should be either a numeric logging level or its string "
"equivalent (for example either ``\"ERROR\"`` or :attr:`logging.ERROR`).  The "
"default is :attr:`logging.INFO`."
msgstr ""
"如果給定，*level* 應該是數字日誌記錄級別或其等效字串（例如 ``\"ERROR\"`` 或 "
":attr:`logging.ERROR`）。預設為 :attr:`logging.INFO`。"

#: ../../library/unittest.rst:1133
#, fuzzy
msgid ""
"The test passes if at least one message emitted inside the ``with`` block "
"matches the *logger* and *level* conditions, otherwise it fails."
msgstr "如果 ``with`` 塊內發出的至少一條消息與 *logger* 和 *level* "
"條件匹配，則測試通過，否則失敗。"

#: ../../library/unittest.rst:1136
#, fuzzy
msgid ""
"The object returned by the context manager is a recording helper which keeps "
"tracks of the matching log messages.  It has two attributes:"
msgstr "上下文管理器回傳的對像是一個記錄助手，它跟踪匹配的日誌消息。它有兩個屬性："

#: ../../library/unittest.rst:1142
#, fuzzy
msgid ""
"A list of :class:`logging.LogRecord` objects of the matching log messages."
msgstr "匹配日誌消息的 :class:`logging.LogRecord` 物件列表。"

#: ../../library/unittest.rst:1147
#, fuzzy
msgid ""
"A list of :class:`str` objects with the formatted output of matching "
"messages."
msgstr "帶有匹配消息的格式化輸出的 str 物件列表。"

#: ../../library/unittest.rst:1150
msgid "Example::"
msgstr ""
"範例：\n"
"\n"
"::"

#: ../../library/unittest.rst:1162
#, fuzzy
msgid ""
"A context manager to test that no messages are logged on the *logger* or one "
"of its children, with at least the given *level*."
msgstr "一個上下文管理器，用於測試沒有消息記錄在 *logger* 或其子項之一上，"
"至少具有給定的 *level*。"

#: ../../library/unittest.rst:1166
#, fuzzy
msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a :class:"
"`str` giving the name of a logger.  The default is the root logger, which "
"will catch all messages."
msgstr ""
"如果給定，*logger* 應該是 :class:`logging.Logger` 對像或 :class:`str` "
"給出記錄器的名稱。預設是根記錄器，它將捕獲所有消息。"

#: ../../library/unittest.rst:1174
#, fuzzy
msgid ""
"Unlike :meth:`assertLogs`, nothing will be returned by the context manager."
msgstr "與 :meth:`assertLogs` 不同，上下文管理器不會回傳任何內容。"

#: ../../library/unittest.rst:1179
#, fuzzy
msgid ""
"There are also other methods used to perform more specific checks, such as:"
msgstr "還有其他方法用於執行更具體的檢查，例如："

#: ../../library/unittest.rst:1184
msgid ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"
msgstr ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"

#: ../../library/unittest.rst:1184
msgid "``round(a-b, 7) == 0``"
msgstr "``round(a-b, 7) == 0``"

#: ../../library/unittest.rst:1187
msgid ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"
msgstr ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"

#: ../../library/unittest.rst:1187
msgid "``round(a-b, 7) != 0``"
msgstr "``round(a-b, 7) != 0``"

#: ../../library/unittest.rst:1190
msgid ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"
msgstr ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"

#: ../../library/unittest.rst:1190
msgid "``a > b``"
msgstr "``a > b``"

#: ../../library/unittest.rst:1193
msgid ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"
msgstr ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"

#: ../../library/unittest.rst:1193
msgid "``a >= b``"
msgstr "``a >= b``"

#: ../../library/unittest.rst:1196
msgid ":meth:`assertLess(a, b) <TestCase.assertLess>`"
msgstr ":meth:`assertLess(a, b) <TestCase.assertLess>`"

#: ../../library/unittest.rst:1196
msgid "``a < b``"
msgstr "``a < b``"

#: ../../library/unittest.rst:1199
msgid ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"
msgstr ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"

#: ../../library/unittest.rst:1199
msgid "``a <= b``"
msgstr "``a <= b``"

#: ../../library/unittest.rst:1202
msgid ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"
msgstr ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"

#: ../../library/unittest.rst:1202
msgid "``r.search(s)``"
msgstr "``r.search(s)``"

#: ../../library/unittest.rst:1205
msgid ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"
msgstr ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"

#: ../../library/unittest.rst:1205
msgid "``not r.search(s)``"
msgstr "``not r.search(s)``"

#: ../../library/unittest.rst:1208
msgid ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"
msgstr ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"

#: ../../library/unittest.rst:1208
#, fuzzy
msgid ""
"*a* and *b* have the same elements in the same number, regardless of their "
"order."
msgstr "*a* 和 *b* 具有相同編號的相同元素，無論它們的順序如何。"

#: ../../library/unittest.rst:1217
#, fuzzy
msgid ""
"Test that *first* and *second* are approximately (or not approximately) "
"equal by computing the difference, rounding to the given number of decimal "
"*places* (default 7), and comparing to zero.  Note that these methods round "
"the values to the given number of *decimal places* (i.e. like the :func:"
"`round` function) and not *significant digits*."
msgstr ""
"測試 *first* 和 *second* "
"是否近似（或不近似）相等，方法是計算差值，四捨五入到給定的小數位數*（預設為 "
"7），然後與零進行比較。請注意，這些方法將值四捨五入到給定的*小數位數*（即像 "
":func:`round` 函式）而不是*有效數字*。"

#: ../../library/unittest.rst:1223
#, fuzzy
msgid ""
"If *delta* is supplied instead of *places* then the difference between "
"*first* and *second* must be less or equal to (or greater than) *delta*."
msgstr ""
"如果提供 *delta* 而不是 *places*，則 *first* 和 *second* "
"之間的差異必須小於或等於（或大於）*delta*。"

#: ../../library/unittest.rst:1226
#, fuzzy
msgid "Supplying both *delta* and *places* raises a :exc:`TypeError`."
msgstr "同時提供 *delta* 和 *places* 會引發 :exc:`TypeError`。"

#: ../../library/unittest.rst:1228
#, fuzzy
msgid ""
":meth:`assertAlmostEqual` automatically considers almost equal objects that "
"compare equal.  :meth:`assertNotAlmostEqual` automatically fails if the "
"objects compare equal.  Added the *delta* keyword argument."
msgstr ""
":meth:`assertAlmostEqual` "
"自動考慮比較相等的幾乎相等的物件。如果對像比較相等，assertNotAlmostEqual "
"會自動失敗。新增了 *delta* 關鍵字參數。"

#: ../../library/unittest.rst:1239
#, fuzzy
msgid ""
"Test that *first* is respectively >, >=, < or <= than *second* depending on "
"the method name.  If not, the test will fail::"
msgstr "根據方法名稱，測試 *first* 分別是 >、>=、< 或 <= 而不是 "
"*second*。如果不是，測試將失敗::"

#: ../../library/unittest.rst:1251
#, fuzzy
msgid ""
"Test that a *regex* search matches (or does not match) *text*.  In case of "
"failure, the error message will include the pattern and the *text* (or the "
"pattern and the part of *text* that unexpectedly matched).  *regex* may be a "
"regular expression object or a string containing a regular expression "
"suitable for use by :func:`re.search`."
msgstr ""
"測試 *regex* 搜索匹配（或不匹配）*text*。如果失敗，錯誤消息將包括模式和 "
"*text*（或模式和 *text* 意外匹配的部分）。 *regex* "
"可以是正則表達式對像或包含適合 :func:`re.search` 使用的正則表達式的字串。"

#: ../../library/unittest.rst:1257
#, fuzzy
msgid "Added under the name ``assertRegexpMatches``."
msgstr "在名稱 ``assertRegexpMatches``下新增。"

#: ../../library/unittest.rst:1259
#, fuzzy
msgid ""
"The method ``assertRegexpMatches()`` has been renamed to :meth:`."
"assertRegex`."
msgstr "方法 ``assertRegexpMatches()`` 已重命名為 :meth:`.assertRegex`。"

#: ../../library/unittest.rst:1262
msgid ":meth:`.assertNotRegex`."
msgstr ":meth:`.assertNotRegex`\\ 。"

#: ../../library/unittest.rst:1264
#, fuzzy
msgid ""
"The name ``assertNotRegexpMatches`` is a deprecated alias for :meth:`."
"assertNotRegex`."
msgstr "名稱 ``assertNotRegexpMatches`` 是 :meth:`.assertNotRegex` 的棄用別名。"

#: ../../library/unittest.rst:1271
#, fuzzy
msgid ""
"Test that sequence *first* contains the same elements as *second*, "
"regardless of their order. When they don't, an error message listing the "
"differences between the sequences will be generated."
msgstr "測試序列 *first* 包含與 *second* 相同的元素，無論它們的順序如何。如果他們不這"
"樣做，將生成一條錯誤消息，列出序列之間的差異。"

#: ../../library/unittest.rst:1275
#, fuzzy
msgid ""
"Duplicate elements are *not* ignored when comparing *first* and *second*. It "
"verifies whether each element has the same count in both sequences. "
"Equivalent to: ``assertEqual(Counter(list(first)), Counter(list(second)))`` "
"but works with sequences of unhashable objects as well."
msgstr ""
"比較 *first* 和 *second* 時，*不會*忽略重複元素。它驗證每個元素在兩個序列中是"
"否具有相同的計數。等同於：``assertEqual(Counter(list(first)), "
"Counter(list(second)))`` 但也適用於無法散列的物件序列。"

#: ../../library/unittest.rst:1286
#, fuzzy
msgid ""
"The :meth:`assertEqual` method dispatches the equality check for objects of "
"the same type to different type-specific methods.  These methods are already "
"implemented for most of the built-in types, but it's also possible to "
"register new methods using :meth:`addTypeEqualityFunc`:"
msgstr ""
":meth:`assertEqual` 方法將相同型別物件的相等性檢查分派給不同型別特定的方法。"
"大多數內建型別已經實作了這些方法，但也可以使用 addTypeEqualityFunc "
"註冊新方法："

#: ../../library/unittest.rst:1293
#, fuzzy
msgid ""
"Registers a type-specific method called by :meth:`assertEqual` to check if "
"two objects of exactly the same *typeobj* (not subclasses) compare equal.  "
"*function* must take two positional arguments and a third msg=None keyword "
"argument just as :meth:`assertEqual` does.  It must raise :data:`self."
"failureException(msg) <failureException>` when inequality between the first "
"two parameters is detected -- possibly providing useful information and "
"explaining the inequalities in details in the error message."
msgstr ""
"註冊由 :meth:`assertEqual` 呼叫的特定於型別的方法，以檢查完全相同的 *typeobj*"
" （不是子類別）的兩個對像比較是否相等。 *function* "
"必須採用兩個位置參數和第三個 msg=None 關鍵字參數，就像 :meth:`assertEqual` "
"所做的那樣。當檢測到前兩個參數之間的不等式時，它必須引發 :data:`self."
"failureException(msg) <failureException>` —— "
"可能提供有用的資訊並在錯誤消息中詳細解釋不等式。"

#: ../../library/unittest.rst:1304
#, fuzzy
msgid ""
"The list of type-specific methods automatically used by :meth:`~TestCase."
"assertEqual` are summarized in the following table.  Note that it's usually "
"not necessary to invoke these methods directly."
msgstr "下表總結了 :meth:`~TestCase.assertEqual` "
"自動使用的特定於型別的方法列表。請注意，通常不需要直接呼叫這些方法。"

#: ../../library/unittest.rst:1309
#, fuzzy
msgid "Used to compare"
msgstr "用來比較"

#: ../../library/unittest.rst:1311
msgid ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"
msgstr ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"

#: ../../library/unittest.rst:1311
#, fuzzy
msgid "strings"
msgstr "字串"

#: ../../library/unittest.rst:1314
msgid ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"
msgstr ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"

#: ../../library/unittest.rst:1314
#, fuzzy
msgid "sequences"
msgstr "序列"

#: ../../library/unittest.rst:1317
msgid ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"
msgstr ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"

#: ../../library/unittest.rst:1317
#, fuzzy
msgid "lists"
msgstr "列出"

#: ../../library/unittest.rst:1320
msgid ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"
msgstr ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"

#: ../../library/unittest.rst:1320
#, fuzzy
msgid "tuples"
msgstr "元組"

#: ../../library/unittest.rst:1323
msgid ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"
msgstr ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"

#: ../../library/unittest.rst:1323
#, fuzzy
msgid "sets or frozensets"
msgstr "集或凍結集"

#: ../../library/unittest.rst:1326
msgid ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"
msgstr ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"

#: ../../library/unittest.rst:1326
#, fuzzy
msgid "dicts"
msgstr "口述"

#: ../../library/unittest.rst:1334
#, fuzzy
msgid ""
"Test that the multiline string *first* is equal to the string *second*. When "
"not equal a diff of the two strings highlighting the differences will be "
"included in the error message. This method is used by default when comparing "
"strings with :meth:`assertEqual`."
msgstr ""
"測試多行字串 *first* 是否等於字串 "
"*second*。當不等於兩個字串的差異時，突出顯示差異將包含在錯誤消息中。將字串與 "
":meth:`assertEqual` 進行比較時預設使用此方法。"

#: ../../library/unittest.rst:1344
#, fuzzy
msgid ""
"Tests that two sequences are equal.  If a *seq_type* is supplied, both "
"*first* and *second* must be instances of *seq_type* or a failure will be "
"raised.  If the sequences are different an error message is constructed that "
"shows the difference between the two."
msgstr ""
"測試兩個序列是否相等。如果提供了 *seq_type*，則 *first* 和 *second* 都必須是 "
"*seq_type* 的實例，否則將引發失敗。如果序列不同，則會構建一條錯誤消息，顯示兩"
"者之間的差異。"

#: ../../library/unittest.rst:1349
#, fuzzy
msgid ""
"This method is not called directly by :meth:`assertEqual`, but it's used to "
"implement :meth:`assertListEqual` and :meth:`assertTupleEqual`."
msgstr ""
"此方法不直接由 :meth:`assertEqual` 呼叫，但它用於實作 :meth:`assertListEqual`"
" 和 :meth:`assertTupleEqual`。"

#: ../../library/unittest.rst:1359
#, fuzzy
msgid ""
"Tests that two lists or tuples are equal.  If not, an error message is "
"constructed that shows only the differences between the two.  An error is "
"also raised if either of the parameters are of the wrong type. These methods "
"are used by default when comparing lists or tuples with :meth:`assertEqual`."
msgstr ""
"測試兩個列表或元組是否相等。如果不是，則構造一條錯誤消息，僅顯示兩者之間的差"
"異。如果任一參數的型別錯誤，也會引發錯誤。將列表或元組與 :meth:`assertEqual` "
"進行比較時預設使用這些方法。"

#: ../../library/unittest.rst:1370
#, fuzzy
msgid ""
"Tests that two sets are equal.  If not, an error message is constructed that "
"lists the differences between the sets.  This method is used by default when "
"comparing sets or frozensets with :meth:`assertEqual`."
msgstr ""
"測試兩組是否相等。如果不是，則構造一條錯誤消息，列出集合之間的差異。"
"將集合或凍結集合與 :meth:`assertEqual` 進行比較時預設使用此方法。"

#: ../../library/unittest.rst:1374
#, fuzzy
msgid ""
"Fails if either of *first* or *second* does not have a :meth:`set."
"difference` method."
msgstr "如果 *first* 或 *second* 中的任何一個沒有 :meth:`set.difference` 方法則失敗。"

#: ../../library/unittest.rst:1382
#, fuzzy
msgid ""
"Test that two dictionaries are equal.  If not, an error message is "
"constructed that shows the differences in the dictionaries. This method will "
"be used by default to compare dictionaries in calls to :meth:`assertEqual`."
msgstr ""
"測試兩個字典是否相等。如果不是，則會構造一條錯誤消息，顯示字典中的差異。預設"
"情況下，將使用此方法來比較呼叫 :meth:`assertEqual` 中的字典。"

#: ../../library/unittest.rst:1393
#, fuzzy
msgid ""
"Finally the :class:`TestCase` provides the following methods and attributes:"
msgstr "最後，:class:`TestCase` 提供了以下方法和屬性："

#: ../../library/unittest.rst:1398
#, fuzzy
msgid ""
"Signals a test failure unconditionally, with *msg* or ``None`` for the error "
"message."
msgstr "無條件地表示測試失敗，錯誤消息使用 *msg* 或 ``None``。"

#: ../../library/unittest.rst:1404
#, fuzzy
msgid ""
"This class attribute gives the exception raised by the test method.  If a "
"test framework needs to use a specialized exception, possibly to carry "
"additional information, it must subclass this exception in order to \"play "
"fair\" with the framework.  The initial value of this attribute is :exc:"
"`AssertionError`."
msgstr ""
"此類屬性給出了測試方法引發的例外。如果一個測試框架需要使用一個專門的例外，可"
"能攜帶額外的資訊，它必鬚子類別化這個例外，以便與框架“公平競爭”。此屬性的初始"
"值為 :exec:`AssertionError`。"

#: ../../library/unittest.rst:1413
#, fuzzy
msgid ""
"This class attribute determines what happens when a custom failure message "
"is passed as the msg argument to an assertXYY call that fails. ``True`` is "
"the default value. In this case, the custom message is appended to the end "
"of the standard failure message. When set to ``False``, the custom message "
"replaces the standard message."
msgstr ""
"此類屬性確定當自定義失敗消息作為 msg 參數傳遞給失敗的 assertXYY "
"呼叫時會發生什麼。 ``True`` 是預設值。在這種情況下，自定義消息將附加到標準失"
"敗消息的末尾。當設定為 ``False``時，自定義消息將替換標準消息。"

#: ../../library/unittest.rst:1419
#, fuzzy
msgid ""
"The class setting can be overridden in individual test methods by assigning "
"an instance attribute, self.longMessage, to ``True`` or ``False`` before "
"calling the assert methods."
msgstr "在呼叫斷言方法之前，通過將實例屬性 self.longMessage "
"分配給 ``True``或 ``False``，可以在各個測試方法中覆蓋類設定。"

#: ../../library/unittest.rst:1423
#, fuzzy
msgid "The class setting gets reset before each test call."
msgstr "在每次測試呼叫之前，類設定都會被重置。"

#: ../../library/unittest.rst:1430
#, fuzzy
msgid ""
"This attribute controls the maximum length of diffs output by assert methods "
"that report diffs on failure. It defaults to 80*8 characters. Assert methods "
"affected by this attribute are :meth:`assertSequenceEqual` (including all "
"the sequence comparison methods that delegate to it), :meth:"
"`assertDictEqual` and :meth:`assertMultiLineEqual`."
msgstr ""
"此屬性控制在失敗時報告差異的斷言方法輸出的差異的最大長度。預設為 80*8 "
"個字元。受此屬性影響的斷言方法是 :meth:`assertSequenceEqual`（包括委託給它的"
"所有序列比較方法）、:meth:`assertDictEqual` 和 :meth:`assertMultiLineEqual`。"

#: ../../library/unittest.rst:1437
#, fuzzy
msgid ""
"Setting ``maxDiff`` to ``None`` means that there is no maximum length of "
"diffs."
msgstr "將 ``maxDiff`` 設定為 ``None`` 意味著沒有最大長度的差異。"

#: ../../library/unittest.rst:1443
#, fuzzy
msgid ""
"Testing frameworks can use the following methods to collect information on "
"the test:"
msgstr "測試框架可以使用以下方法收集測試資訊："

#: ../../library/unittest.rst:1449
#, fuzzy
msgid ""
"Return the number of tests represented by this test object.  For :class:"
"`TestCase` instances, this will always be ``1``."
msgstr "回傳此測試物件表示的測試數。對於 :class:`TestCase` 實例，這將始終為 ``1``。"

#: ../../library/unittest.rst:1455
#, fuzzy
msgid ""
"Return an instance of the test result class that should be used for this "
"test case class (if no other result instance is provided to the :meth:`run` "
"method)."
msgstr "回傳應該用於此測試用例類的測試結果類的實例（如果沒有其他結果實例提供給 "
":meth:`run` 方法）。"

#: ../../library/unittest.rst:1459
#, fuzzy
msgid ""
"For :class:`TestCase` instances, this will always be an instance of :class:"
"`TestResult`; subclasses of :class:`TestCase` should override this as "
"necessary."
msgstr ""
"對於 :class:`TestCase` 實例，這將始終是 :class:`TestResult` 的實例； "
":class:`TestCase` 的子類別應該根據需要覆蓋它。"

#: ../../library/unittest.rst:1466
#, fuzzy
msgid ""
"Return a string identifying the specific test case.  This is usually the "
"full name of the test method, including the module and class name."
msgstr "回傳標識特定測試用例的字串。這通常是測試方法的全名，包括模組和類名。"

#: ../../library/unittest.rst:1472
#, fuzzy
msgid ""
"Returns a description of the test, or ``None`` if no description has been "
"provided.  The default implementation of this method returns the first line "
"of the test method's docstring, if available, or ``None``."
msgstr "回傳測試的描述，如果沒有提供描述則回傳 "
"``None``。此方法的預設實作回傳測試方法文檔字串的第一行（如果可用）或 ``None`` 。"

#: ../../library/unittest.rst:1477
#, fuzzy
msgid ""
"In 3.1 this was changed to add the test name to the short description even "
"in the presence of a docstring.  This caused compatibility issues with "
"unittest extensions and adding the test name was moved to the :class:"
"`TextTestResult` in Python 3.2."
msgstr ""
"在 3.1 中，這被更改為即使在存在文檔字串的情況下也將測試名稱新增到簡短描述中。"
"這導致了單元測試擴充的相容性問題，新增的測試名稱被移到了 Python 3.2 中的 "
"TextTestResult 中。"

#: ../../library/unittest.rst:1486
#, fuzzy
msgid ""
"Add a function to be called after :meth:`tearDown` to cleanup resources used "
"during the test. Functions will be called in reverse order to the order they "
"are added (:abbr:`LIFO (last-in, first-out)`).  They are called with any "
"arguments and keyword arguments passed into :meth:`addCleanup` when they are "
"added."
msgstr ""
"在 :meth:`tearDown` 之後新增一個要呼叫的函式，以清理測試期間使用的資源。函式"
"將以與它們被新增的順序相反的順序被呼叫（ :abbr:`LIFO（後進先出）`）。新增它"
"們時，將使用傳遞給 addCleanup 的任何參數和關鍵字參數呼叫它們。"

#: ../../library/unittest.rst:1492
#, fuzzy
msgid ""
"If :meth:`setUp` fails, meaning that :meth:`tearDown` is not called, then "
"any cleanup functions added will still be called."
msgstr "如果 :meth:`setUp` 失敗，意味著 :meth:`tearDown` "
"沒有被呼叫，那麼任何新增的清理函式仍然會被呼叫。"

#: ../../library/unittest.rst:1500
#, fuzzy
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :meth:`addCleanup` "
"and return the result of the :meth:`~object.__enter__` method."
msgstr ""
"輸入提供的 :term:`context manager`。如果成功，還通過 addCleanup 新增其 "
":meth:`~object.__exit__` 方法作為清理函式，並回傳 :meth:`~object.__enter__` "
"方法的結果。"

#: ../../library/unittest.rst:1510
#, fuzzy
msgid ""
"This method is called unconditionally after :meth:`tearDown`, or after :meth:"
"`setUp` if :meth:`setUp` raises an exception."
msgstr "此方法在 :meth:`tearDown` 之後或在 :meth:`setUp` 之後無條件呼叫，如果 "
":meth:`setUp` 引發例外。"

#: ../../library/unittest.rst:1513
#, fuzzy
msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addCleanup`. If you need cleanup functions to be called *prior* to :meth:"
"`tearDown` then you can call :meth:`doCleanups` yourself."
msgstr ""
"它負責呼叫 addCleanup 新增的所有清理函式。如果您需要在 :meth:`tearDown` "
"之前*呼叫清理函式，那麼您可以自己呼叫 :meth:`doCleanups`。"

#: ../../library/unittest.rst:1518
#, fuzzy
msgid ""
":meth:`doCleanups` pops methods off the stack of cleanup functions one at a "
"time, so it can be called at any time."
msgstr ":meth:`doCleanups` 一次從清理函式堆疊中彈出一個方法，因此可以隨時呼叫它。"

#: ../../library/unittest.rst:1526
#, fuzzy
msgid ""
"Add a function to be called after :meth:`tearDownClass` to cleanup resources "
"used during the test class. Functions will be called in reverse order to the "
"order they are added (:abbr:`LIFO (last-in, first-out)`). They are called "
"with any arguments and keyword arguments passed into :meth:`addClassCleanup` "
"when they are added."
msgstr ""
"在 :meth:`tearDownClass` 之後新增一個要呼叫的函式，以清理測試類期間使用的資源"
"。函式將以與它們被新增的順序相反的順序被呼叫（ :abbr:`LIFO（後進先出）`）。"
"新增它們時，將使用傳遞給 addClassCleanup 的任何參數和關鍵字參數呼叫它們。"

#: ../../library/unittest.rst:1532
#, fuzzy
msgid ""
"If :meth:`setUpClass` fails, meaning that :meth:`tearDownClass` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"如果 :meth:`setUpClass` 失敗，意味著 :meth:`tearDownClass` "
"沒有被呼叫，那麼新增的任何清理函式仍然會被呼叫。"

#: ../../library/unittest.rst:1540
#, fuzzy
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :meth:"
"`addClassCleanup` and return the result of the :meth:`~object.__enter__` "
"method."
msgstr ""
"輸入提供的 :term:`context manager`。如果成功，還通過 addClassCleanup 新增其 "
":meth:`~object.__exit__` 方法作為清理函式，並回傳 :meth:`~object.__enter__` "
"方法的結果。"

#: ../../library/unittest.rst:1550
#, fuzzy
msgid ""
"This method is called unconditionally after :meth:`tearDownClass`, or after :"
"meth:`setUpClass` if :meth:`setUpClass` raises an exception."
msgstr ""
"此方法在 :meth:`tearDownClass` 之後或在 :meth:`setUpClass` 之後無條件呼叫，"
"如果 :meth:`setUpClass` 引發例外。"

#: ../../library/unittest.rst:1553
#, fuzzy
msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addClassCleanup`. If you need cleanup functions to be called *prior* to :"
"meth:`tearDownClass` then you can call :meth:`doClassCleanups` yourself."
msgstr ""
"它負責呼叫 addClassCleanup 新增的所有清理函式。如果您需要在 "
":meth:`tearDownClass` 之前*呼叫清理函式，那麼您可以自己呼叫 "
":meth:`doClassCleanups`。"

#: ../../library/unittest.rst:1558
#, fuzzy
msgid ""
":meth:`doClassCleanups` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ":meth:`doClassCleanups` "
"一次從清理函式堆疊中彈出一個方法，因此可以隨時呼叫它。"

#: ../../library/unittest.rst:1566
#, fuzzy
msgid ""
"This class provides an API similar to :class:`TestCase` and also accepts "
"coroutines as test functions."
msgstr "此類提供類似於 :class:`TestCase` 的 API，並且還接受協程作為測試函式。"

#: ../../library/unittest.rst:1573
#, fuzzy
msgid ""
"Method called to prepare the test fixture. This is called after :meth:"
"`setUp`. This is called immediately before calling the test method; other "
"than :exc:`AssertionError` or :exc:`SkipTest`, any exception raised by this "
"method will be considered an error rather than a test failure. The default "
"implementation does nothing."
msgstr ""
"呼叫方法來準備測試夾具。這是在 :meth:`setUp` "
"之後呼叫的。這是在呼叫測試方法之前立即呼叫的；除了 :exc:`AssertionError` 或 "
":exc:`SkipTest` "
"之外，此方法引發的任何例外都將被視為錯誤而不是測試失敗。預設實作什麼也不做。"

#: ../../library/unittest.rst:1581
#, fuzzy
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called before :meth:`tearDown`. This is called "
"even if the test method raised an exception, so the implementation in "
"subclasses may need to be particularly careful about checking internal "
"state.  Any exception, other than :exc:`AssertionError` or :exc:`SkipTest`, "
"raised by this method will be considered an additional error rather than a "
"test failure (thus increasing the total number of reported errors). This "
"method will only be called if the :meth:`asyncSetUp` succeeds, regardless of "
"the outcome of the test method. The default implementation does nothing."
msgstr ""
"在呼叫測試方法並記錄結果後立即呼叫方法。這在 :meth:`tearDown` 之前呼叫。即使"
"測試方法引發例外也會呼叫它，因此子類別中的實作可能需要特別小心檢查內部狀態。"
"除了 :exc:`AssertionError` 或 :exc:`SkipTest` 之外，此方法引發的任何例外都將"
"被視為附加錯誤而不是測試失敗（從而增加報告錯誤的總數）。僅當 "
":meth:`asyncSetUp` "
"成功時才會呼叫此方法，無論測試方法的結果如何。預設實作什麼也不做。"

#: ../../library/unittest.rst:1593
#, fuzzy
msgid "This method accepts a coroutine that can be used as a cleanup function."
msgstr "此方法接受可用作清理功能的協程。"

#: ../../library/unittest.rst:1597
#, fuzzy
msgid ""
"Enter the supplied :term:`asynchronous context manager`.  If successful, "
"also add its :meth:`~object.__aexit__` method as a cleanup function by :meth:"
"`addAsyncCleanup` and return the result of the :meth:`~object.__aenter__` "
"method."
msgstr ""
"輸入提供的 :term:`非同步上下文管理器`。如果成功，還通過 addAsyncCleanup "
"新增其 :meth:`~object.__aexit__` 方法作為清理函式，並回傳 :meth:`~object."
"__aenter__` 方法的結果。"

#: ../../library/unittest.rst:1607
#, fuzzy
msgid ""
"Sets up a new event loop to run the test, collecting the result into the :"
"class:`TestResult` object passed as *result*.  If *result* is omitted or "
"``None``, a temporary result object is created (by calling the :meth:"
"`defaultTestResult` method) and used. The result object is returned to :meth:"
"`run`'s caller. At the end of the test all the tasks in the event loop are "
"cancelled."
msgstr ""
"設定一個新的事件循環來運行測試，將結果收集到作為 *result* 傳遞的 TestResult "
"對像中。如果省略 *result* 或 ``None``，則會建立一個臨時結果物件（通過呼叫 "
"defaultTestResult 方法）並使用。結果物件回傳給 :meth:`run` "
"的呼叫者。在測試結束時，事件循環中的所有任務都被取消。"

#: ../../library/unittest.rst:1615
#, fuzzy
msgid "An example illustrating the order::"
msgstr "說明順序的示例::"

#: ../../library/unittest.rst:1651
#, fuzzy
msgid ""
"After running the test, ``events`` would contain ``[\"setUp\", "
"\"asyncSetUp\", \"test_response\", \"asyncTearDown\", \"tearDown\", "
"\"cleanup\"]``."
msgstr ""
"運行測試後，``events`` 將包含 ``[\"setUp\", \"asyncSetUp\", \"test_response\""
", \"asyncTearDown\", \"tearDown\", \"cleanup\"]``。"

#: ../../library/unittest.rst:1656
#, fuzzy
msgid ""
"This class implements the portion of the :class:`TestCase` interface which "
"allows the test runner to drive the test, but does not provide the methods "
"which test code can use to check and report errors.  This is used to create "
"test cases using legacy test code, allowing it to be integrated into a :mod:"
"`unittest`-based test framework."
msgstr ""
"此類實作了 TestCase 介面的一部分，該介面允許測試運行器驅動測試，但不提供測試"
"程式碼可用於檢查和報告錯誤的方法。這用於使用遺留測試程式碼建立測試用例，"
"允許將其集成到基於 :mod:`unittest` 的測試框架中。"

#: ../../library/unittest.rst:1666
#, fuzzy
msgid "Deprecated aliases"
msgstr "棄用的別名"

#: ../../library/unittest.rst:1668
#, fuzzy
msgid ""
"For historical reasons, some of the :class:`TestCase` methods had one or "
"more aliases that are now deprecated.  The following table lists the correct "
"names along with their deprecated aliases:"
msgstr "由於歷史原因，一些 :class:`TestCase` "
"方法有一個或多個別名，現在已棄用。下表列出了正確的名稱及其已棄用的別名："

#: ../../library/unittest.rst:1673
#, fuzzy
msgid "Method Name"
msgstr "方法名稱"

#: ../../library/unittest.rst:1673
#, fuzzy
msgid "Deprecated alias"
msgstr "棄用的別名"

#: ../../library/unittest.rst:1675
msgid ":meth:`.assertEqual`"
msgstr ":meth:`.assertEqual`"

#: ../../library/unittest.rst:1675
msgid "failUnlessEqual"
msgstr "failUnlessEqual"

#: ../../library/unittest.rst:1675
msgid "assertEquals"
msgstr "assertEquals"

#: ../../library/unittest.rst:1676
msgid ":meth:`.assertNotEqual`"
msgstr ":meth:`.assertNotEqual`"

#: ../../library/unittest.rst:1676
msgid "failIfEqual"
msgstr "failIfEqual"

#: ../../library/unittest.rst:1676
msgid "assertNotEquals"
msgstr "assertNotEquals"

#: ../../library/unittest.rst:1677
msgid ":meth:`.assertTrue`"
msgstr ":meth:`.assertTrue`"

#: ../../library/unittest.rst:1677
msgid "failUnless"
msgstr "failUnless"

#: ../../library/unittest.rst:1677
msgid "assert\\_"
msgstr "assert\\_"

#: ../../library/unittest.rst:1678
msgid ":meth:`.assertFalse`"
msgstr ":meth:`.assertFalse`"

#: ../../library/unittest.rst:1678
msgid "failIf"
msgstr "failIf"

#: ../../library/unittest.rst:1679
msgid ":meth:`.assertRaises`"
msgstr ":meth:`.assertRaises`"

#: ../../library/unittest.rst:1679
msgid "failUnlessRaises"
msgstr "failUnlessRaises"

#: ../../library/unittest.rst:1680
msgid ":meth:`.assertAlmostEqual`"
msgstr ":meth:`.assertAlmostEqual`"

#: ../../library/unittest.rst:1680
msgid "failUnlessAlmostEqual"
msgstr "failUnlessAlmostEqual"

#: ../../library/unittest.rst:1680
msgid "assertAlmostEquals"
msgstr "assertAlmostEquals"

#: ../../library/unittest.rst:1681
msgid ":meth:`.assertNotAlmostEqual`"
msgstr ":meth:`.assertNotAlmostEqual`"

#: ../../library/unittest.rst:1681
msgid "failIfAlmostEqual"
msgstr "failIfAlmostEqual"

#: ../../library/unittest.rst:1681
msgid "assertNotAlmostEquals"
msgstr "assertNotAlmostEquals"

#: ../../library/unittest.rst:1682
msgid ":meth:`.assertRegex`"
msgstr ":meth:`.assertRegex`"

#: ../../library/unittest.rst:1682
msgid "assertRegexpMatches"
msgstr "assertRegexpMatches"

#: ../../library/unittest.rst:1683
msgid ":meth:`.assertNotRegex`"
msgstr ":meth:`.assertNotRegex`"

#: ../../library/unittest.rst:1683
msgid "assertNotRegexpMatches"
msgstr "assertNotRegexpMatches"

#: ../../library/unittest.rst:1684
msgid ":meth:`.assertRaisesRegex`"
msgstr ":meth:`.assertRaisesRegex`"

#: ../../library/unittest.rst:1684
msgid "assertRaisesRegexp"
msgstr "assertRaisesRegexp"

#: ../../library/unittest.rst:1687
#, fuzzy
msgid "The fail* aliases listed in the second column have been deprecated."
msgstr "第二列中列出的 fail* 別名已被棄用。"

#: ../../library/unittest.rst:1689
#, fuzzy
msgid "The assert* aliases listed in the third column have been deprecated."
msgstr "第三列中列出的 assert* 別名已被棄用。"

#: ../../library/unittest.rst:1691
#, fuzzy
msgid ""
"``assertRegexpMatches`` and ``assertRaisesRegexp`` have been renamed to :"
"meth:`.assertRegex` and :meth:`.assertRaisesRegex`."
msgstr ""
"``assertRegexpMatches`` 和 ``assertRaisesRegexp`` 已重命名為 :meth:`."
"assertRegex` 和 :meth:`.assertRaisesRegex`。"

#: ../../library/unittest.rst:1694
#, fuzzy
msgid ""
"The ``assertNotRegexpMatches`` name is deprecated in favor of :meth:`."
"assertNotRegex`."
msgstr "``assertNotRegexpMatches`` 名稱已棄用，取而代之的是 :meth:`.assertNotRegex`。"

#: ../../library/unittest.rst:1700
#, fuzzy
msgid "Grouping tests"
msgstr "分組測試"

#: ../../library/unittest.rst:1704
#, fuzzy
msgid ""
"This class represents an aggregation of individual test cases and test "
"suites. The class presents the interface needed by the test runner to allow "
"it to be run as any other test case.  Running a :class:`TestSuite` instance "
"is the same as iterating over the suite, running each test individually."
msgstr ""
"此類表示單個測試用例和測試套件的集合。該類提供了測試運行器所需的介面，以允許"
"它像任何其他測試用例一樣運行。運行 :class:`TestSuite` "
"實例與遍歷套件相同，分別運行每個測試。"

#: ../../library/unittest.rst:1709
#, fuzzy
msgid ""
"If *tests* is given, it must be an iterable of individual test cases or "
"other test suites that will be used to build the suite initially. Additional "
"methods are provided to add test cases and suites to the collection later on."
msgstr ""
"如果給出 *tests* ，它必須是單個測試用例或其他將用於最初構建套件的測試套件的可"
"疊代。提供了其他方法，以便稍後將測試用例和套件新增到集合中。"

#: ../../library/unittest.rst:1713
#, fuzzy
msgid ""
":class:`TestSuite` objects behave much like :class:`TestCase` objects, "
"except they do not actually implement a test.  Instead, they are used to "
"aggregate tests into groups of tests that should be run together. Some "
"additional methods are available to add tests to :class:`TestSuite` "
"instances:"
msgstr ""
":class:`TestSuite` 物件的行為很像 :class:`TestCase` 物件，只是它們實際上並不"
"執行測試。相反，它們用於將測試聚合到應該一起運行的測試組中。"
"一些額外的方法可用於將測試新增到 :class:`TestSuite` 實例："

#: ../../library/unittest.rst:1721
#, fuzzy
msgid "Add a :class:`TestCase` or :class:`TestSuite` to the suite."
msgstr "新增一個 :class:`TestCase` 或 :class:`TestSuite` 到套件中。"

#: ../../library/unittest.rst:1726
#, fuzzy
msgid ""
"Add all the tests from an iterable of :class:`TestCase` and :class:"
"`TestSuite` instances to this test suite."
msgstr "將可疊代的 :class:`TestCase` 和 :class:`TestSuite` "
"實例中的所有測試新增到此測試套件中。"

#: ../../library/unittest.rst:1729
#, fuzzy
msgid ""
"This is equivalent to iterating over *tests*, calling :meth:`addTest` for "
"each element."
msgstr "這相當於遍歷 *tests*，為每個元素呼叫 addTest。"

#: ../../library/unittest.rst:1732
#, fuzzy
msgid ":class:`TestSuite` shares the following methods with :class:`TestCase`:"
msgstr ":class:`TestSuite` 與 :class:`TestCase` 共享以下方法："

#: ../../library/unittest.rst:1737
#, fuzzy
msgid ""
"Run the tests associated with this suite, collecting the result into the "
"test result object passed as *result*.  Note that unlike :meth:`TestCase."
"run`, :meth:`TestSuite.run` requires the result object to be passed in."
msgstr ""
"運行與該套件關聯的測試，將結果收集到作為 *result* "
"傳遞的測試結果對像中。請注意，與 :meth:`TestCase.run` 不同，:meth:`TestSuite."
"run` 需要傳入結果物件。"

#: ../../library/unittest.rst:1745
#, fuzzy
msgid ""
"Run the tests associated with this suite without collecting the result. This "
"allows exceptions raised by the test to be propagated to the caller and can "
"be used to support running tests under a debugger."
msgstr "運行與該套件相關的測試而不收集結果。這允許將測試引發的例外傳播給呼叫者，並可"
"用於支援在除錯器下運行測試。"

#: ../../library/unittest.rst:1752
#, fuzzy
msgid ""
"Return the number of tests represented by this test object, including all "
"individual tests and sub-suites."
msgstr "回傳此測試物件表示的測試數，包括所有單獨的測試和子套件。"

#: ../../library/unittest.rst:1758
#, fuzzy
msgid ""
"Tests grouped by a :class:`TestSuite` are always accessed by iteration. "
"Subclasses can lazily provide tests by overriding :meth:`__iter__`. Note "
"that this method may be called several times on a single suite (for example "
"when counting tests or comparing for equality) so the tests returned by "
"repeated iterations before :meth:`TestSuite.run` must be the same for each "
"call iteration. After :meth:`TestSuite.run`, callers should not rely on the "
"tests returned by this method unless the caller uses a subclass that "
"overrides :meth:`TestSuite._removeTestAtIndex` to preserve test references."
msgstr ""
"按 :class:`TestSuite` 分組的測試總是通過疊代訪問。子類別可以通過覆蓋 "
":meth:`__iter__` 懶惰地提供測試。請注意，此方法可能會在單個套件上多次呼叫（例"
"如，在計算測試或比較相等性時），因此每次呼叫疊代之前重複疊代回傳的測試必須相"
"同。在 TestSuite.run 之後，呼叫者不應依賴此方法回傳的測試，"
"除非呼叫者使用覆蓋 TestSuite._removeTestAtIndex 的子類別來保留測試引用。"

#: ../../library/unittest.rst:1768
#, fuzzy
msgid ""
"In earlier versions the :class:`TestSuite` accessed tests directly rather "
"than through iteration, so overriding :meth:`__iter__` wasn't sufficient for "
"providing tests."
msgstr "在早期版本中，:class:`TestSuite` 直接訪問測試而不是通過疊代，因此重寫 "
":meth:`__iter__` 不足以提供測試。"

#: ../../library/unittest.rst:1773
#, fuzzy
msgid ""
"In earlier versions the :class:`TestSuite` held references to each :class:"
"`TestCase` after :meth:`TestSuite.run`. Subclasses can restore that behavior "
"by overriding :meth:`TestSuite._removeTestAtIndex`."
msgstr ""
"在早期版本中，TestSuite 在 TestSuite.run 之後持有對每個 TestCase 的引用。"
"子類別可以通過覆蓋 TestSuite._removeTestAtIndex 來恢復該行為。"

#: ../../library/unittest.rst:1778
#, fuzzy
msgid ""
"In the typical usage of a :class:`TestSuite` object, the :meth:`run` method "
"is invoked by a :class:`TestRunner` rather than by the end-user test harness."
msgstr ""
"在 :class:`TestSuite` 物件的典型用法中，:meth:`run` 方法由 "
":class:`TestRunner` 而不是最終使用者測試工具呼叫。"

#: ../../library/unittest.rst:1783
#, fuzzy
msgid "Loading and running tests"
msgstr "加載和運行測試"

#: ../../library/unittest.rst:1787
#, fuzzy
msgid ""
"The :class:`TestLoader` class is used to create test suites from classes and "
"modules.  Normally, there is no need to create an instance of this class; "
"the :mod:`unittest` module provides an instance that can be shared as :data:"
"`unittest.defaultTestLoader`.  Using a subclass or instance, however, allows "
"customization of some configurable properties."
msgstr ""
":class:`TestLoader` "
"類用於從類和模組建立測試套件。通常，不需要建立此類的實例； :mod:`unittest` "
"模組提供了一個可以共享為 :data:`unittest.defaultTestLoader` "
"的實例。然而，使用子類別或實例允許定制一些可配置的屬性。"

#: ../../library/unittest.rst:1793
#, fuzzy
msgid ":class:`TestLoader` objects have the following attributes:"
msgstr ":class:`TestLoader` 物件具有以下屬性："

#: ../../library/unittest.rst:1798
#, fuzzy
msgid ""
"A list of the non-fatal errors encountered while loading tests. Not reset by "
"the loader at any point. Fatal errors are signalled by the relevant method "
"raising an exception to the caller. Non-fatal errors are also indicated by a "
"synthetic test that will raise the original error when run."
msgstr ""
"加載測試時遇到的非致命錯誤的列表。加載程式在任何時候都不會重置。致命錯誤由相"
"關方法向呼叫者引發例外發出信號。非致命錯誤也由綜合測試指示，該測試將在運行時"
"引發原始錯誤。"

#: ../../library/unittest.rst:1807
#, fuzzy
msgid ":class:`TestLoader` objects have the following methods:"
msgstr ":class:`TestLoader` 物件具有以下方法："

#: ../../library/unittest.rst:1812
#, fuzzy
msgid ""
"Return a suite of all test cases contained in the :class:`TestCase`\\ -"
"derived :class:`testCaseClass`."
msgstr "回傳一組包含在 :class:`TestCase`\\ -派生的 :class:`testCaseClass` "
"中的所有測試用例。"

#: ../../library/unittest.rst:1815
#, fuzzy
msgid ""
"A test case instance is created for each method named by :meth:"
"`getTestCaseNames`. By default these are the method names beginning with "
"``test``. If :meth:`getTestCaseNames` returns no methods, but the :meth:"
"`runTest` method is implemented, a single test case is created for that "
"method instead."
msgstr ""
"為 getTestCaseNames 命名的每個方法建立一個測試用例實例。預設情況下，這些是以“"
"test”開頭的方法名稱。如果 :meth:`getTestCaseNames` 不回傳任何方法，但 "
":meth:`runTest` 方法被實作，則為該方法建立一個測試用例。"

#: ../../library/unittest.rst:1824
#, fuzzy
msgid ""
"Return a suite of all test cases contained in the given module. This method "
"searches *module* for classes derived from :class:`TestCase` and creates an "
"instance of the class for each test method defined for the class."
msgstr ""
"回傳給定模組中包含的一組所有測試用例。此方法在 *module* 中搜索派生自 "
":class:`TestCase` 的類，並為為該類定義的每個測試方法建立該類的實例。"

#: ../../library/unittest.rst:1831
#, fuzzy
msgid ""
"While using a hierarchy of :class:`TestCase`\\ -derived classes can be "
"convenient in sharing fixtures and helper functions, defining test methods "
"on base classes that are not intended to be instantiated directly does not "
"play well with this method.  Doing so, however, can be useful when the "
"fixtures are different and defined in subclasses."
msgstr ""
"雖然使用 :class:`TestCase`\\ 派生類的層次結構可以方便地共享固定裝置和輔助函式"
"，但在不打算直接實例化的基底類別上定義測試方法不能很好地使用此方法。但是，當"
"固定裝置不同並且在子類別中定義時，這樣做會很有用。"

#: ../../library/unittest.rst:1837
#, fuzzy
msgid ""
"If a module provides a ``load_tests`` function it will be called to load the "
"tests. This allows modules to customize test loading. This is the "
"`load_tests protocol`_.  The *pattern* argument is passed as the third "
"argument to ``load_tests``."
msgstr ""
"如果一個模組提供了一個 ``load_tests`` "
"函式，它將被呼叫來加載測試。這允許模組自定義測試加載。這是 `load_tests "
"協定`_。 *pattern* 參數作為第三個參數傳遞給 ``load_tests``。"

#: ../../library/unittest.rst:1842
#, fuzzy
msgid "Support for ``load_tests`` added."
msgstr "新增了對 ``load_tests`` 的支援。"

#: ../../library/unittest.rst:1845
#, fuzzy
msgid ""
"The undocumented and unofficial *use_load_tests* default argument is "
"deprecated and ignored, although it is still accepted for backward "
"compatibility.  The method also now accepts a keyword-only argument "
"*pattern* which is passed to ``load_tests`` as the third argument."
msgstr ""
"未記錄和非官方的 *use_load_tests* "
"預設參數已被棄用和忽略，儘管它仍然被接受以實作向後相容性。"
"該方法現在還接受一個僅限關鍵字的參數 *pattern*，它作為第三個參數傳遞給 "
"``load_tests``。"

#: ../../library/unittest.rst:1854
#, fuzzy
msgid "Return a suite of all test cases given a string specifier."
msgstr "回傳一組給定字串說明符的所有測試用例。"

#: ../../library/unittest.rst:1856
#, fuzzy
msgid ""
"The specifier *name* is a \"dotted name\" that may resolve either to a "
"module, a test case class, a test method within a test case class, a :class:"
"`TestSuite` instance, or a callable object which returns a :class:`TestCase` "
"or :class:`TestSuite` instance.  These checks are applied in the order "
"listed here; that is, a method on a possible test case class will be picked "
"up as \"a test method within a test case class\", rather than \"a callable "
"object\"."
msgstr ""
"說明符 *name* "
"是一個“點名”，可以解析為模組、測試用例類、測試用例類中的測試方法、TestSuite "
"實例或回傳以下內容的可呼叫物件： class:`TestCase` 或 :class:`TestSuite` 實例"
"。這些檢查按此處列出的順序應用；也就是說，可能的測試用例類上的方法將被選為“測"
"試用例類中的測試方法”，而不是“可呼叫物件”。"

#: ../../library/unittest.rst:1864
#, fuzzy
msgid ""
"For example, if you have a module :mod:`SampleTests` containing a :class:"
"`TestCase`\\ -derived class :class:`SampleTestCase` with three test methods "
"(:meth:`test_one`, :meth:`test_two`, and :meth:`test_three`), the specifier "
"``'SampleTests.SampleTestCase'`` would cause this method to return a suite "
"which will run all three test methods. Using the specifier ``'SampleTests."
"SampleTestCase.test_two'`` would cause it to return a test suite which will "
"run only the :meth:`test_two` test method. The specifier can refer to "
"modules and packages which have not been imported; they will be imported as "
"a side-effect."
msgstr ""
"例如，如果您有一個模組 :mod:`SampleTests` 包含一個 :class:`TestCase`\\ "
"派生類 :class:`SampleTestCase` 具有三個測試方法 (:meth:`test_one`, "
":meth:`test_two` , 和 :meth:`test_three`)，說明符 ``'SampleTests."
"SampleTestCase'`` 將導致此方法回傳一個套件，該套件將運行所有三個測試方法。"
"使用說明符 ``'SampleTests.SampleTestCase.test_two'`` "
"將導致它回傳一個測試套件，該套件將僅運行 :meth:`test_two` "
"測試方法。說明符可以引用未導入的模組和包；它們將作為副作用導入。"

#: ../../library/unittest.rst:1874
#, fuzzy
msgid "The method optionally resolves *name* relative to the given *module*."
msgstr "該方法可選地解析相對於給定*模組*的*名稱*。"

#: ../../library/unittest.rst:1876
#, fuzzy
msgid ""
"If an :exc:`ImportError` or :exc:`AttributeError` occurs while traversing "
"*name* then a synthetic test that raises that error when run will be "
"returned. These errors are included in the errors accumulated by self.errors."
msgstr ""
"如果在遍歷 *name* 時發生 :exc:`ImportError` 或 "
":exc:`AttributeError`，那麼將回傳一個在運行時引發該錯誤的綜合測試。"
"這些錯誤包含在 self.errors 累積的錯誤中。"

#: ../../library/unittest.rst:1885
#, fuzzy
msgid ""
"Similar to :meth:`loadTestsFromName`, but takes a sequence of names rather "
"than a single name.  The return value is a test suite which supports all the "
"tests defined for each name."
msgstr ""
"類似於 :meth:`loadTestsFromName`，但採用一系列名稱而不是單個名稱。回傳值是一"
"個測試套件，它支援為每個名稱定義的所有測試。"

#: ../../library/unittest.rst:1892
#, fuzzy
msgid ""
"Return a sorted sequence of method names found within *testCaseClass*; this "
"should be a subclass of :class:`TestCase`."
msgstr "回傳在 *testCaseClass* 中找到的方法名稱的排序序列；這應該是 :class:`TestCase`"
" 的子類別。"

#: ../../library/unittest.rst:1898
#, fuzzy
msgid ""
"Find all the test modules by recursing into subdirectories from the "
"specified start directory, and return a TestSuite object containing them. "
"Only test files that match *pattern* will be loaded. (Using shell style "
"pattern matching.) Only module names that are importable (i.e. are valid "
"Python identifiers) will be loaded."
msgstr ""
"通過遞迴到指定起始目錄的子目錄中找到所有測試模組，並回傳包含它們的 TestSuite "
"物件。只有匹配 *pattern* 的測試文件才會被加載。 （使用 shell "
"樣式模式匹配。）只有可導入的模組名稱（即有效的 Python 標識符）才會被加載。"

#: ../../library/unittest.rst:1904
#, fuzzy
msgid ""
"All test modules must be importable from the top level of the project. If "
"the start directory is not the top level directory then the top level "
"directory must be specified separately."
msgstr "所有測試模組都必須可以從項目的頂層導入。如果起始目錄不是頂級目錄，則必須單獨"
"指定頂級目錄。"

#: ../../library/unittest.rst:1908
#, fuzzy
msgid ""
"If importing a module fails, for example due to a syntax error, then this "
"will be recorded as a single error and discovery will continue.  If the "
"import failure is due to :exc:`SkipTest` being raised, it will be recorded "
"as a skip instead of an error."
msgstr ""
"如果導入模組失敗，例如由於語法錯誤，那麼這將被記錄為單個錯誤並且發現將繼續。"
"如果導入失敗是由於 :exc:`SkipTest` 被引發，它將被記錄為跳過而不是錯誤。"

#: ../../library/unittest.rst:1913
#, fuzzy
msgid ""
"If a package (a directory containing a file named :file:`__init__.py`) is "
"found, the package will be checked for a ``load_tests`` function. If this "
"exists then it will be called ``package.load_tests(loader, tests, "
"pattern)``. Test discovery takes care to ensure that a package is only "
"checked for tests once during an invocation, even if the load_tests function "
"itself calls ``loader.discover``."
msgstr ""
"如果找到一個包（一個包含名為 :file:`__init__.py` 的文件的目錄），"
"將檢查該包是否有 ``load_tests`` 函式。如果存在，那麼它將被稱為“package."
"load_tests(loader, tests, "
"pattern)”。測試發現會確保在呼叫期間僅檢查一次包的測試，即使 load_tests "
"函式本身呼叫 ``loader.discover``。"

#: ../../library/unittest.rst:1921
#, fuzzy
msgid ""
"If ``load_tests`` exists then discovery does *not* recurse into the package, "
"``load_tests`` is responsible for loading all tests in the package."
msgstr "如果 ``load_tests`` 存在，那麼發現*不會*遞迴到包中，``load_tests`` "
"負責加載包中的所有測試。"

#: ../../library/unittest.rst:1925
#, fuzzy
msgid ""
"The pattern is deliberately not stored as a loader attribute so that "
"packages can continue discovery themselves. *top_level_dir* is stored so "
"``load_tests`` does not need to pass this argument in to ``loader."
"discover()``."
msgstr ""
"該模式有意不儲存為加載程式屬性，以便包可以繼續自行發現。 *top_level_dir* "
"已儲存，因此 ``load_tests`` 不需要將此參數傳遞給 ``loader.discover()``。"

#: ../../library/unittest.rst:1930
#, fuzzy
msgid "*start_dir* can be a dotted module name as well as a directory."
msgstr "*start_dir* 可以是帶點的模組名稱以及目錄。"

#: ../../library/unittest.rst:1934
#, fuzzy
msgid ""
"Modules that raise :exc:`SkipTest` on import are recorded as skips, not "
"errors."
msgstr "在導入時引發 :exc:`SkipTest` 的模組被記錄為跳過，而不是錯誤。"

#: ../../library/unittest.rst:1938
#, fuzzy
msgid "*start_dir* can be a :term:`namespace packages <namespace package>`."
msgstr "*start_dir* 可以是 :term:`namespace packages <namespace package>`。"

#: ../../library/unittest.rst:1941
#, fuzzy
msgid ""
"Paths are sorted before being imported so that execution order is the same "
"even if the underlying file system's ordering is not dependent on file name."
msgstr "路徑在導入之前進行排序，因此即使底層文件系統的排序不依賴於文件名，執行順序也"
"是相同的。"

#: ../../library/unittest.rst:1946
#, fuzzy
msgid ""
"Found packages are now checked for ``load_tests`` regardless of whether "
"their path matches *pattern*, because it is impossible for a package name to "
"match the default pattern."
msgstr "找到的包現在會檢查 ``load_tests`` 而不管它們的路徑是否匹配 "
"*pattern*，因為包名稱不可能與預設模式匹配。"

#: ../../library/unittest.rst:1951
#, fuzzy
msgid ""
"*start_dir* can not be a :term:`namespace packages <namespace package>`. It "
"has been broken since Python 3.7 and Python 3.11 officially remove it."
msgstr ""
"*start_dir* 不能是 :term:`namespace packages <namespace package>`。自從 "
"Python 3.7 和 Python 3.11 正式刪除它後，它就被破壞了。"

#: ../../library/unittest.rst:1956
#, fuzzy
msgid ""
"The following attributes of a :class:`TestLoader` can be configured either "
"by subclassing or assignment on an instance:"
msgstr ":class:`TestLoader` 的以下屬性可以通過實例的子類別化或賦值來配置："

#: ../../library/unittest.rst:1962
#, fuzzy
msgid ""
"String giving the prefix of method names which will be interpreted as test "
"methods.  The default value is ``'test'``."
msgstr "字串給出將被解釋為測試方法的方法名稱的前綴。預設值為 ``'test'``。"

#: ../../library/unittest.rst:1965
#, fuzzy
msgid ""
"This affects :meth:`getTestCaseNames` and all the :meth:`loadTestsFrom\\*` "
"methods."
msgstr "這會影響 :meth:`getTestCaseNames` 和所有 :meth:`loadTestsFrom\\*` 方法。"

#: ../../library/unittest.rst:1971
#, fuzzy
msgid ""
"Function to be used to compare method names when sorting them in :meth:"
"`getTestCaseNames` and all the :meth:`loadTestsFrom\\*` methods."
msgstr ""
"在 :meth:`getTestCaseNames` 和所有 :meth:`loadTestsFrom\\*` "
"方法中排序時用於比較方法名稱的函式。"

#: ../../library/unittest.rst:1977
#, fuzzy
msgid ""
"Callable object that constructs a test suite from a list of tests. No "
"methods on the resulting object are needed.  The default value is the :class:"
"`TestSuite` class."
msgstr "從測試列表構造測試套件的可呼叫物件。結果對像上不需要任何方法。預設值是 "
":class:`TestSuite` 類。"

#: ../../library/unittest.rst:1981 ../../library/unittest.rst:1994
#, fuzzy
msgid "This affects all the :meth:`loadTestsFrom\\*` methods."
msgstr "這會影響所有 :meth:`loadTestsFrom\\*` 方法。"

#: ../../library/unittest.rst:1985
#, fuzzy
msgid ""
"List of Unix shell-style wildcard test name patterns that test methods have "
"to match to be included in test suites (see ``-k`` option)."
msgstr "測試方法必須匹配才能包含在測試套件中的 Unix shell "
"樣式通配符測試名稱模式列表（請參閱 ``-k``選項）。"

#: ../../library/unittest.rst:1988
#, fuzzy
msgid ""
"If this attribute is not ``None`` (the default), all test methods to be "
"included in test suites must match one of the patterns in this list. Note "
"that matches are always performed using :meth:`fnmatch.fnmatchcase`, so "
"unlike patterns passed to the ``-k`` option, simple substring patterns will "
"have to be converted using ``*`` wildcards."
msgstr ""
"如果此屬性不是 ``None`` （預設值），則所有要包含在測試套件中的測試方法都必須匹配此"
"列表中的模式之一。請注意，匹配始終使用 fnmatch.fnmatchcase 執行，因此與傳遞給"
" ``-k``選項的模式不同，簡單的子字串模式必須使用 ``*``通配符進行轉換。"

#: ../../library/unittest.rst:2001
#, fuzzy
msgid ""
"This class is used to compile information about which tests have succeeded "
"and which have failed."
msgstr "此類用於編譯有關哪些測試成功和哪些失敗的資訊。"

#: ../../library/unittest.rst:2004
#, fuzzy
msgid ""
"A :class:`TestResult` object stores the results of a set of tests.  The :"
"class:`TestCase` and :class:`TestSuite` classes ensure that results are "
"properly recorded; test authors do not need to worry about recording the "
"outcome of tests."
msgstr ""
":class:`TestResult` 物件儲存一組測試的結果。 :class:`TestCase` 和 "
":class:`TestSuite` 類確保正確記錄結果；測試作者無需擔心記錄測試結果。"

#: ../../library/unittest.rst:2009
#, fuzzy
msgid ""
"Testing frameworks built on top of :mod:`unittest` may want access to the :"
"class:`TestResult` object generated by running a set of tests for reporting "
"purposes; a :class:`TestResult` instance is returned by the :meth:"
"`TestRunner.run` method for this purpose."
msgstr ""
"構建在 unittest 之上的測試框架可能需要訪問通過運行一組測試生成的 TestResult "
"對像以用於報告目的； :class:`TestResult` 實例由 :meth:`TestRunner.run` "
"方法回傳用於此目的。"

#: ../../library/unittest.rst:2014
#, fuzzy
msgid ""
":class:`TestResult` instances have the following attributes that will be of "
"interest when inspecting the results of running a set of tests:"
msgstr ":class:`TestResult` 實例具有以下屬性，在檢查運行一組測試的結果時會感興趣："

#: ../../library/unittest.rst:2020
#, fuzzy
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test which raised an "
"unexpected exception."
msgstr "包含 2 元組的列表 :class:`TestCase` "
"實例和包含格式化回溯的字串。每個元組代表一個引發意外例外的測試。"

#: ../../library/unittest.rst:2026
#, fuzzy
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test where a failure "
"was explicitly signalled using the :meth:`TestCase.assert\\*` methods."
msgstr ""
"包含 2 元組的列表 :class:`TestCase` "
"實例和包含格式化回溯的字串。每個元組代表一個測試，其中使用 :meth:`TestCase."
"assert\\*` 方法明確指示失敗。"

#: ../../library/unittest.rst:2032
#, fuzzy
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding the reason for skipping the test."
msgstr "包含 TestCase 實例和字串的 2 元組的列表，其中包含跳過測試的原因。"

#: ../../library/unittest.rst:2039
#, fuzzy
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks.  Each tuple represents an expected failure or "
"error of the test case."
msgstr "包含 2 元組的列表 :class:`TestCase` "
"實例和包含格式化回溯的字串。每個元組代表測試用例的預期失敗或錯誤。"

#: ../../library/unittest.rst:2045
#, fuzzy
msgid ""
"A list containing :class:`TestCase` instances that were marked as expected "
"failures, but succeeded."
msgstr "包含被標記為預期失敗但成功的 TestCase 實例的列表。"

#: ../../library/unittest.rst:2050
#, fuzzy
msgid ""
"Set to ``True`` when the execution of tests should stop by :meth:`stop`."
msgstr "當測試的執行應該由 :meth:`stop` 停止時設定為 ``True``。"

#: ../../library/unittest.rst:2054
#, fuzzy
msgid "The total number of tests run so far."
msgstr "到目前為止運行的測試總數。"

#: ../../library/unittest.rst:2058
#, fuzzy
msgid ""
"If set to true, ``sys.stdout`` and ``sys.stderr`` will be buffered in "
"between :meth:`startTest` and :meth:`stopTest` being called. Collected "
"output will only be echoed onto the real ``sys.stdout`` and ``sys.stderr`` "
"if the test fails or errors. Any output is also attached to the failure / "
"error message."
msgstr ""
"如果設定為 true，``sys.stdout`` 和 ``sys.stderr`` 將在被呼叫的 startTest 和 "
"stopTest 之間進行緩衝。如果測試失敗或出錯，收集的輸出只會回顯到真正的 ``sys."
"stdout`` 和 ``sys.stderr`` 上。任何輸出也附加到失敗/錯誤消息。"

#: ../../library/unittest.rst:2067
#, fuzzy
msgid ""
"If set to true :meth:`stop` will be called on the first failure or error, "
"halting the test run."
msgstr "如果設定為 true :meth:`stop` 將在第一次失敗或錯誤時呼叫，停止測試運行。"

#: ../../library/unittest.rst:2074
#, fuzzy
msgid "If set to true then local variables will be shown in tracebacks."
msgstr "如果設定為 true，則局部變數將顯示在回溯中。"

#: ../../library/unittest.rst:2080
#, fuzzy
msgid ""
"Return ``True`` if all tests run so far have passed, otherwise returns "
"``False``."
msgstr "如果到目前為止運行的所有測試都已通過，則回傳 ``True``，否則回傳 ``False``。"

#: ../../library/unittest.rst:2083
#, fuzzy
msgid ""
"Returns ``False`` if there were any :attr:`unexpectedSuccesses` from tests "
"marked with the :func:`expectedFailure` decorator."
msgstr ""
"如果用 :func:`expectedFailure` 裝飾器標記的測試有任何 unexpectedSuccesses，"
"則回傳 ``False``。"

#: ../../library/unittest.rst:2089
#, fuzzy
msgid ""
"This method can be called to signal that the set of tests being run should "
"be aborted by setting the :attr:`shouldStop` attribute to ``True``. :class:"
"`TestRunner` objects should respect this flag and return without running any "
"additional tests."
msgstr ""
"通過將 shouldStop 屬性設定為 "
"True，可以呼叫此方法來發出正在運行的測試集應該中止的信號。 "
":class:`TestRunner` 物件應該遵守此旗標並在不運行任何其他測試的情況下回傳。"

#: ../../library/unittest.rst:2094
#, fuzzy
msgid ""
"For example, this feature is used by the :class:`TextTestRunner` class to "
"stop the test framework when the user signals an interrupt from the "
"keyboard.  Interactive tools which provide :class:`TestRunner` "
"implementations can use this in a similar manner."
msgstr ""
"例如，TextTestRunner 類使用此功能在使用者從鍵盤發出中斷信號時停止測試框架。"
"提供 :class:`TestRunner` 實作的交互式工具可以以類似的方式使用它。"

#: ../../library/unittest.rst:2099
#, fuzzy
msgid ""
"The following methods of the :class:`TestResult` class are used to maintain "
"the internal data structures, and may be extended in subclasses to support "
"additional reporting requirements.  This is particularly useful in building "
"tools which support interactive reporting while tests are being run."
msgstr ""
":class:`TestResult` 類的以下方法用於維護內部資料結構，並且可以在子類別中擴充"
"以支援額外的報告要求。這對於構建在運行測試時支援交互式報告的工具特別有用。"

#: ../../library/unittest.rst:2107
#, fuzzy
msgid "Called when the test case *test* is about to be run."
msgstr "當測試用例 *test* 即將運行時呼叫。"

#: ../../library/unittest.rst:2111
#, fuzzy
msgid ""
"Called after the test case *test* has been executed, regardless of the "
"outcome."
msgstr "在測試用例 *test* 執行後呼叫，不管結果如何。"

#: ../../library/unittest.rst:2116
#, fuzzy
msgid "Called once before any tests are executed."
msgstr "在執行任何測試之前呼叫一次。"

#: ../../library/unittest.rst:2123
#, fuzzy
msgid "Called once after all tests are executed."
msgstr "在執行所有測試後呼叫一次。"

#: ../../library/unittest.rst:2130
#, fuzzy
msgid ""
"Called when the test case *test* raises an unexpected exception. *err* is a "
"tuple of the form returned by :func:`sys.exc_info`: ``(type, value, "
"traceback)``."
msgstr ""
"當測試用例 *test* 引發意外例外時呼叫。 *err* 是 :func:`sys.exc_info`: ``("
"type, value, traceback)`` 回傳的形式的元組。"

#: ../../library/unittest.rst:2134
#, fuzzy
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`errors` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"預設實作將元組“(test, formatted_err)”附加到實例的 :attr:`errors` 屬性，其中 "
"*formatted_err* 是從 *err* 派生的格式化回溯。"

#: ../../library/unittest.rst:2141
#, fuzzy
msgid ""
"Called when the test case *test* signals a failure. *err* is a tuple of the "
"form returned by :func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"當測試用例 *test* 發出失敗信號時呼叫。 *err* 是 :func:`sys.exc_info`: ``("
"type, value, traceback)`` 回傳的形式的元組。"

#: ../../library/unittest.rst:2144
#, fuzzy
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`failures` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"預設實作將元組“(test, formatted_err)”附加到實例的 failures 屬性，其中 "
"*formatted_err* 是從 *err* 派生的格式化回溯。"

#: ../../library/unittest.rst:2151
#, fuzzy
msgid "Called when the test case *test* succeeds."
msgstr "當測試用例 *test* 成功時呼叫。"

#: ../../library/unittest.rst:2153
#, fuzzy
msgid "The default implementation does nothing."
msgstr "預設實作什麼也不做。"

#: ../../library/unittest.rst:2158
#, fuzzy
msgid ""
"Called when the test case *test* is skipped.  *reason* is the reason the "
"test gave for skipping."
msgstr "跳過測試用例 *test* 時呼叫。 *原因* 是測試給出的跳過的原因。"

#: ../../library/unittest.rst:2161
#, fuzzy
msgid ""
"The default implementation appends a tuple ``(test, reason)`` to the "
"instance's :attr:`skipped` attribute."
msgstr "預設實作附加一個元組``(test, reason)`` 到實例的 :attr:`skipped` 屬性。"

#: ../../library/unittest.rst:2167
#, fuzzy
msgid ""
"Called when the test case *test* fails or errors, but was marked with the :"
"func:`expectedFailure` decorator."
msgstr "當測試用例 *test* 失敗或錯誤時呼叫，但用 :func:`expectedFailure` 裝飾器標記。"

#: ../../library/unittest.rst:2170
#, fuzzy
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`expectedFailures` attribute, where *formatted_err* is a "
"formatted traceback derived from *err*."
msgstr ""
"預設實作將一個元組“(test, formatted_err)”附加到實例的 expectedFailures 屬性，"
"其中 *formatted_err* 是從 *err* 派生的格式化回溯。"

#: ../../library/unittest.rst:2177
#, fuzzy
msgid ""
"Called when the test case *test* was marked with the :func:`expectedFailure` "
"decorator, but succeeded."
msgstr "當測試用例 *test* 被 :func:`expectedFailure` 裝飾器標記時呼叫，但成功了。"

#: ../../library/unittest.rst:2180
#, fuzzy
msgid ""
"The default implementation appends the test to the instance's :attr:"
"`unexpectedSuccesses` attribute."
msgstr "預設實作將測試附加到實例的 unexpectedSuccesses 屬性。"

#: ../../library/unittest.rst:2186
#, fuzzy
msgid ""
"Called when a subtest finishes.  *test* is the test case corresponding to "
"the test method.  *subtest* is a custom :class:`TestCase` instance "
"describing the subtest."
msgstr "子測試完成時呼叫。 *test* 是測試方法對應的測試用例。 *subtest* "
"是描述子測試的自定義 TestCase 實例。"

#: ../../library/unittest.rst:2190
#, fuzzy
msgid ""
"If *outcome* is :const:`None`, the subtest succeeded.  Otherwise, it failed "
"with an exception where *outcome* is a tuple of the form returned by :func:"
"`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"如果 *outcome* 是 :const:`None`，則子測試成功。否則，它會失敗並出現例外，"
"其中 *outcome* 是 :func:`sys.exc_info`: ``(type, value, traceback)`` "
"回傳的形式的元組。"

#: ../../library/unittest.rst:2194
#, fuzzy
msgid ""
"The default implementation does nothing when the outcome is a success, and "
"records subtest failures as normal failures."
msgstr "當結果成功時，預設實作不執行任何操作，並將子測試失敗記錄為正常失敗。"

#: ../../library/unittest.rst:2202
#, fuzzy
msgid ""
"A concrete implementation of :class:`TestResult` used by the :class:"
"`TextTestRunner`."
msgstr "TextTestRunner 使用的 TestResult 的具體實作。"

#: ../../library/unittest.rst:2205
#, fuzzy
msgid ""
"This class was previously named ``_TextTestResult``. The old name still "
"exists as an alias but is deprecated."
msgstr "這個類以前被命名為“_TextTestResult”。舊名稱仍然作為別名存在，但已棄用。"

#: ../../library/unittest.rst:2212
#, fuzzy
msgid ""
"Instance of the :class:`TestLoader` class intended to be shared.  If no "
"customization of the :class:`TestLoader` is needed, this instance can be "
"used instead of repeatedly creating new instances."
msgstr "旨在共享的 TestLoader 類的實例。如果不需要自定義 "
"TestLoader，可以使用這個實例，而不是重複建立新實例。"

#: ../../library/unittest.rst:2220
#, fuzzy
msgid ""
"A basic test runner implementation that outputs results to a stream. If "
"*stream* is ``None``, the default, :data:`sys.stderr` is used as the output "
"stream. This class has a few configurable parameters, but is essentially "
"very simple.  Graphical applications which run test suites should provide "
"alternate implementations. Such implementations should accept ``**kwargs`` "
"as the interface to construct runners changes when features are added to "
"unittest."
msgstr ""
"將結果輸出到流的基本測試運行器實作。如果 *stream* 是 "
"``None``，預設情況下，:data:`sys.stderr` 被用作輸出流。這個類有一些可配置的參"
"數，但本質上非常簡單。運行測試套件的圖形應用程式應該提供替代實作。這樣的實作"
"應該接受``**kwargs``，因為當特性被新增到單元測試時，構造運行器的介面會發生變"
"化。"

#: ../../library/unittest.rst:2227
#, fuzzy
msgid ""
"By default this runner shows :exc:`DeprecationWarning`, :exc:"
"`PendingDeprecationWarning`, :exc:`ResourceWarning` and :exc:`ImportWarning` "
"even if they are :ref:`ignored by default <warning-ignored>`. Deprecation "
"warnings caused by :ref:`deprecated unittest methods <deprecated-aliases>` "
"are also special-cased and, when the warning filters are ``'default'`` or "
"``'always'``, they will appear only once per-module, in order to avoid too "
"many warning messages.  This behavior can be overridden using Python's :"
"option:`!-Wd` or :option:`!-Wa` options (see :ref:`Warning control <using-on-"
"warnings>`) and leaving *warnings* to ``None``."
msgstr ""
"預設情況下，此運行器會顯示 :exec:`DeprecationWarning`、:exc:`PendingDeprecatio"
"nWarning`、:exc:`ResourceWarning` 和 :exc:`ImportWarning`，"
"即使預設情況下忽略它們 <warning-ignored>`。由 :ref:`棄用的單元測試方法 "
"<deprecated-aliases>` 引起的棄用警告也是特殊情況，當警告過濾器是 "
"``'default'`` 或 ``'always'`` "
"時，它們只會出現一次每個模組，以避免過多的警告消息。可以使用 Python "
"的 :option:`!-Wd` 或 :option:`!-Wa` 選項（參見 :ref:`Warning control <using-on-"
"warnings>`）並將*warnings* 留給`` 來覆蓋此行為沒有``。"

#: ../../library/unittest.rst:2238
msgid "Added the ``warnings`` argument."
msgstr "新增 ``warnings`` 引數。"

#: ../../library/unittest.rst:2241
#, fuzzy
msgid ""
"The default stream is set to :data:`sys.stderr` at instantiation time rather "
"than import time."
msgstr "預設流在實例化時設定為 :data:`sys.stderr` 而不是導入時。"

#: ../../library/unittest.rst:2245
msgid "Added the tb_locals parameter."
msgstr "新增 tb_locals 參數。"

#: ../../library/unittest.rst:2250
#, fuzzy
msgid ""
"This method returns the instance of ``TestResult`` used by :meth:`run`. It "
"is not intended to be called directly, but can be overridden in subclasses "
"to provide a custom ``TestResult``."
msgstr ""
"此方法回傳由 :meth:`run` 使用的 ``TestResult`` "
"的實例。它不打算直接呼叫，但可以在子類別中重寫以提供自定義的 ``TestResult``。"

#: ../../library/unittest.rst:2254
#, fuzzy
msgid ""
"``_makeResult()`` instantiates the class or callable passed in the "
"``TextTestRunner`` constructor as the ``resultclass`` argument. It defaults "
"to :class:`TextTestResult` if no ``resultclass`` is provided. The result "
"class is instantiated with the following arguments::"
msgstr ""
"``_makeResult()`` 將在 `TextTestRunner`` "
"構造函式中傳遞的類或可呼叫物件實例化為 ``resultclass`` 參數。如果沒有提供 "
"``resultclass``，它預設為 :class:`TextTestResult`。結果類使用以下參數實例化："

#: ../../library/unittest.rst:2263
#, fuzzy
msgid ""
"This method is the main public interface to the ``TextTestRunner``. This "
"method takes a :class:`TestSuite` or :class:`TestCase` instance. A :class:"
"`TestResult` is created by calling :func:`_makeResult` and the test(s) are "
"run and the results printed to stdout."
msgstr ""
"此方法是 ``TextTestRunner`` 的主要公開介面。此方法採用 :class:`TestSuite` 或 "
":class:`TestCase` 實例。 :class:`TestResult` 是通過呼叫 :func:`_makeResult` "
"建立的，然後運行測試並將結果印出到標準輸出。"

#: ../../library/unittest.rst:2274
#, fuzzy
msgid ""
"A command-line program that loads a set of tests from *module* and runs "
"them; this is primarily for making test modules conveniently executable. The "
"simplest use for this function is to include the following line at the end "
"of a test script::"
msgstr "一個命令列程式，從 *module* 加載一組測試並運行它們；這主要是為了方便地執行測"
"試模組。此函式最簡單的用法是在測試腳本末尾包含以下行："

#: ../../library/unittest.rst:2282
#, fuzzy
msgid ""
"You can run tests with more detailed information by passing in the verbosity "
"argument::"
msgstr "您可以通過傳入詳細參數來運行具有更詳細資訊的測試："

#: ../../library/unittest.rst:2288
#, fuzzy
msgid ""
"The *defaultTest* argument is either the name of a single test or an "
"iterable of test names to run if no test names are specified via *argv*.  If "
"not specified or ``None`` and no test names are provided via *argv*, all "
"tests found in *module* are run."
msgstr ""
"如果沒有通過 *argv* 指定測試名稱，*defaultTest* "
"參數要么是單個測試的名稱，要么是要運行的可疊代測試名稱。如果未指定或 ``None`` "
"並且未通過 *argv* 提供測試名稱，則運行在 *module* 中找到的所有測試。"

#: ../../library/unittest.rst:2293
#, fuzzy
msgid ""
"The *argv* argument can be a list of options passed to the program, with the "
"first element being the program name.  If not specified or ``None``, the "
"values of :data:`sys.argv` are used."
msgstr "*argv* "
"參數可以是傳遞給程式的選項列表，第一個元素是程式名稱。如果未指定或 ``None`` ，"
"則使用 sys.argv 的值。"

#: ../../library/unittest.rst:2297
#, fuzzy
msgid ""
"The *testRunner* argument can either be a test runner class or an already "
"created instance of it. By default ``main`` calls :func:`sys.exit` with an "
"exit code indicating success or failure of the tests run."
msgstr ""
"*testRunner* "
"參數可以是測試運行器類，也可以是它的已建立實例。預設情況下，``main`` 呼叫 "
":func:`sys.exit` 並帶有指示測試運行成功或失敗的退出程式碼。"

#: ../../library/unittest.rst:2301
#, fuzzy
msgid ""
"The *testLoader* argument has to be a :class:`TestLoader` instance, and "
"defaults to :data:`defaultTestLoader`."
msgstr ""
"*testLoader* 參數必須是 :class:`TestLoader` 實例，預設為 "
":data:`defaultTestLoader`。"

#: ../../library/unittest.rst:2304
#, fuzzy
msgid ""
"``main`` supports being used from the interactive interpreter by passing in "
"the argument ``exit=False``. This displays the result on standard output "
"without calling :func:`sys.exit`::"
msgstr ""
"``main`` 支援通過傳入參數 ``exit=False`` 從交互式直譯器中使用。"
"這將在標準輸出上顯示結果而不呼叫 :func:`sys.exit`::"

#: ../../library/unittest.rst:2311
#, fuzzy
msgid ""
"The *failfast*, *catchbreak* and *buffer* parameters have the same effect as "
"the same-name `command-line options`_."
msgstr "*failfast*、*catchbreak* 和 *buffer* 參數與同名的“命令列選項”具有相同的效果。"

#: ../../library/unittest.rst:2314
#, fuzzy
msgid ""
"The *warnings* argument specifies the :ref:`warning filter <warning-filter>` "
"that should be used while running the tests.  If it's not specified, it will "
"remain ``None`` if a :option:`!-W` option is passed to :program:`python` "
"(see :ref:`Warning control <using-on-warnings>`), otherwise it will be set "
"to ``'default'``."
msgstr ""
"*warnings* 參數指定運行測試時應使用的警告過濾器 <warning-"
"filter>。如果未指定，如果將 :option:`!-W` 選項傳遞給 :program:`python`，"
"它將保持 ``None``（請參閱 :ref:`警告控制 <using-on-warnings>`） "
"，否則它將被設定為 ``'default'``。"

#: ../../library/unittest.rst:2320
#, fuzzy
msgid ""
"Calling ``main`` actually returns an instance of the ``TestProgram`` class. "
"This stores the result of the tests run as the ``result`` attribute."
msgstr "呼叫 ``main`` 實際上回傳了 ``TestProgram`` "
"類的一個實例。這會將測試運行的結果儲存為 ``result``屬性。"

#: ../../library/unittest.rst:2323
msgid "The *exit* parameter was added."
msgstr "新增 *exit* 參數。"

#: ../../library/unittest.rst:2326
#, fuzzy
msgid ""
"The *verbosity*, *failfast*, *catchbreak*, *buffer* and *warnings* "
"parameters were added."
msgstr "新增了 *verbosity*、*failfast*、*catchbreak*、*buffer* 和 *warnings* 參數。"

#: ../../library/unittest.rst:2330
#, fuzzy
msgid ""
"The *defaultTest* parameter was changed to also accept an iterable of test "
"names."
msgstr "*defaultTest* 參數已更改為也接受可疊代的測試名稱。"

#: ../../library/unittest.rst:2336
#, fuzzy
msgid "load_tests Protocol"
msgstr "load_tests 協定"

#: ../../library/unittest.rst:2340
#, fuzzy
msgid ""
"Modules or packages can customize how tests are loaded from them during "
"normal test runs or test discovery by implementing a function called "
"``load_tests``."
msgstr "模組或包可以通過實作一個名為 load_tests "
"的函式來自定義在正常測試運行或測試發現期間如何從它們加載測試。"

#: ../../library/unittest.rst:2343
#, fuzzy
msgid ""
"If a test module defines ``load_tests`` it will be called by :meth:"
"`TestLoader.loadTestsFromModule` with the following arguments::"
msgstr ""
"如果一個測試模組定義了 ``load_tests`` 它將被 :meth:`TestLoader."
"loadTestsFromModule` 使用以下參數呼叫："

#: ../../library/unittest.rst:2348
#, fuzzy
msgid ""
"where *pattern* is passed straight through from ``loadTestsFromModule``.  It "
"defaults to ``None``."
msgstr "其中 *pattern* 直接從 ``loadTestsFromModule`` 傳遞。它預設為 ``None`` 。"

#: ../../library/unittest.rst:2351
#, fuzzy
msgid "It should return a :class:`TestSuite`."
msgstr "它應該回傳一個 :class:`TestSuite`。"

#: ../../library/unittest.rst:2353
#, fuzzy
msgid ""
"*loader* is the instance of :class:`TestLoader` doing the loading. "
"*standard_tests* are the tests that would be loaded by default from the "
"module. It is common for test modules to only want to add or remove tests "
"from the standard set of tests. The third argument is used when loading "
"packages as part of test discovery."
msgstr ""
"*loader* 是執行加載的 :class:`TestLoader` 的實例。 *standard_tests* 是預設從"
"模組加載的測試。測試模組通常只想在標準測試集中新增或刪除測試。第三個參數在作"
"為測試發現的一部分加載包時使用。"

#: ../../library/unittest.rst:2359
#, fuzzy
msgid ""
"A typical ``load_tests`` function that loads tests from a specific set of :"
"class:`TestCase` classes may look like::"
msgstr "從一組特定的 :class:`TestCase` 類加載測試的典型 ``load_tests`` "
"函式可能如下所示："

#: ../../library/unittest.rst:2371
#, fuzzy
msgid ""
"If discovery is started in a directory containing a package, either from the "
"command line or by calling :meth:`TestLoader.discover`, then the package :"
"file:`__init__.py` will be checked for ``load_tests``.  If that function "
"does not exist, discovery will recurse into the package as though it were "
"just another directory.  Otherwise, discovery of the package's tests will be "
"left up to ``load_tests`` which is called with the following arguments::"
msgstr ""
"如果發現是在包含包的目錄中啟動的，無論是從命令列還是通過呼叫 "
":meth:`TestLoader.discover`，然後包 :file:`__init__.py` 將被檢查是否有 ``load_"
"tests``。如果該函式不存在，發現將遞迴到包中，就好像它只是另一個目錄一樣。否則"
"，包測試的發現將留給 ``load_tests``，它使用以下參數呼叫："

#: ../../library/unittest.rst:2380
#, fuzzy
msgid ""
"This should return a :class:`TestSuite` representing all the tests from the "
"package. (``standard_tests`` will only contain tests collected from :file:"
"`__init__.py`.)"
msgstr ""
"這應該回傳一個代表包中所有測試的 :class:`TestSuite`。 （``standard_tests`` "
"將只包含從 :file:`__init__.py` 收集的測試。）"

#: ../../library/unittest.rst:2384
#, fuzzy
msgid ""
"Because the pattern is passed into ``load_tests`` the package is free to "
"continue (and potentially modify) test discovery. A 'do nothing' "
"``load_tests`` function for a test package would look like::"
msgstr ""
"因為模式被傳遞到 ``load_tests`` "
"包可以自由地繼續（並可能修改）測試發現。測試包的“什麼都不做”``load_tests`` "
"函式看起來像："

#: ../../library/unittest.rst:2395
#, fuzzy
msgid ""
"Discovery no longer checks package names for matching *pattern* due to the "
"impossibility of package names matching the default pattern."
msgstr "由於包名稱不可能與預設模式匹配，因此 Discovery 不再檢查包名稱是否匹配 "
"*pattern*。"

#: ../../library/unittest.rst:2402
#, fuzzy
msgid "Class and Module Fixtures"
msgstr "類和模組夾具"

#: ../../library/unittest.rst:2404
#, fuzzy
msgid ""
"Class and module level fixtures are implemented in :class:`TestSuite`. When "
"the test suite encounters a test from a new class then :meth:`tearDownClass` "
"from the previous class (if there is one) is called, followed by :meth:"
"`setUpClass` from the new class."
msgstr ""
"類和模組級固定裝置在 :class:`TestSuite` "
"中實作。當測試套件遇到來自新類的測試時，會呼叫前一類（如果有的話）的 "
":meth:`tearDownClass` ，然後呼叫新類的 :meth:`setUpClass` 。"

#: ../../library/unittest.rst:2409
#, fuzzy
msgid ""
"Similarly if a test is from a different module from the previous test then "
"``tearDownModule`` from the previous module is run, followed by "
"``setUpModule`` from the new module."
msgstr ""
"類似地，如果測試來自與先前測試不同的模組，則運行先前模組中的``tearDownModule`"
"`，然後運行來自新模組的``setUpModule``。"

#: ../../library/unittest.rst:2413
#, fuzzy
msgid ""
"After all the tests have run the final ``tearDownClass`` and "
"``tearDownModule`` are run."
msgstr "在所有測試運行後，運行最終的 ``tearDownClass`` 和 ``tearDownModule``。"

#: ../../library/unittest.rst:2416
#, fuzzy
msgid ""
"Note that shared fixtures do not play well with [potential] features like "
"test parallelization and they break test isolation. They should be used with "
"care."
msgstr "請注意，共享夾具不能很好地發揮測試並行化等[潛在]功能的作用，並且它們會破壞測"
"試隔離。它們應該小心使用。"

#: ../../library/unittest.rst:2419
#, fuzzy
msgid ""
"The default ordering of tests created by the unittest test loaders is to "
"group all tests from the same modules and classes together. This will lead "
"to ``setUpClass`` / ``setUpModule`` (etc) being called exactly once per "
"class and module. If you randomize the order, so that tests from different "
"modules and classes are adjacent to each other, then these shared fixture "
"functions may be called multiple times in a single test run."
msgstr ""
"unittest "
"測試加載器建立的測試的預設順序是將來自相同模組和類的所有測試組合在一起。"
"這將導致每個類和模組只呼叫一次 ``setUpClass`` / ``setUpModule``（等）。如果您"
"隨機化順序，以便來自不同模組和類的測試彼此相鄰，那麼這些共享的夾具函式可能會"
"在一次測試運行中被多次呼叫。"

#: ../../library/unittest.rst:2426
#, fuzzy
msgid ""
"Shared fixtures are not intended to work with suites with non-standard "
"ordering. A ``BaseTestSuite`` still exists for frameworks that don't want to "
"support shared fixtures."
msgstr "共享固定裝置不適用於具有非標準排序的套件。 ``BaseTestSuite`` "
"仍然存在於不想支援共享夾具的框架中。"

#: ../../library/unittest.rst:2430
#, fuzzy
msgid ""
"If there are any exceptions raised during one of the shared fixture "
"functions the test is reported as an error. Because there is no "
"corresponding test instance an ``_ErrorHolder`` object (that has the same "
"interface as a :class:`TestCase`) is created to represent the error. If you "
"are just using the standard unittest test runner then this detail doesn't "
"matter, but if you are a framework author it may be relevant."
msgstr ""
"如果在其中一個共享夾具功能期間引發任何例外，則測試將報告為錯誤。因為沒有相應"
"的測試實例，所以建立了一個 `_ErrorHolder`` 物件（與 :class:`TestCase` "
"具有相同的介面）來表示錯誤。如果您只是使用標準的 unittest "
"測試運行器，那麼這個細節並不重要，但如果您是框架作者，它可能是相關的。"

#: ../../library/unittest.rst:2439
#, fuzzy
msgid "setUpClass and tearDownClass"
msgstr "setUpClass 和 tearDownClass"

#: ../../library/unittest.rst:2441
#, fuzzy
msgid "These must be implemented as class methods::"
msgstr "這些必須作為類方法實作："

#: ../../library/unittest.rst:2454
#, fuzzy
msgid ""
"If you want the ``setUpClass`` and ``tearDownClass`` on base classes called "
"then you must call up to them yourself. The implementations in :class:"
"`TestCase` are empty."
msgstr ""
"如果你想在基底類別上呼叫 ``setUpClass`` 和 ``tearDownClass`` "
"那麼你必須自己呼叫它們。 :class:`TestCase` 中的實作是空的。"

#: ../../library/unittest.rst:2458
#, fuzzy
msgid ""
"If an exception is raised during a ``setUpClass`` then the tests in the "
"class are not run and the ``tearDownClass`` is not run. Skipped classes will "
"not have ``setUpClass`` or ``tearDownClass`` run. If the exception is a :exc:"
"`SkipTest` exception then the class will be reported as having been skipped "
"instead of as an error."
msgstr ""
"如果在 ``setUpClass`` 期間引發例外，則不會運行該類中的測試並且不會運行 "
"``tearDownClass``。跳過的課程不會運行 ``setUpClass`` 或 ``tearDownClass``。"
"如果例外是 :exc:`SkipTest` 例外，那麼該類將被報告為已被跳過而不是錯誤。"

#: ../../library/unittest.rst:2466
#, fuzzy
msgid "setUpModule and tearDownModule"
msgstr "setUpModule 和 tearDownModule"

#: ../../library/unittest.rst:2468
#, fuzzy
msgid "These should be implemented as functions::"
msgstr "這些應該作為函式實作："

#: ../../library/unittest.rst:2476
#, fuzzy
msgid ""
"If an exception is raised in a ``setUpModule`` then none of the tests in the "
"module will be run and the ``tearDownModule`` will not be run. If the "
"exception is a :exc:`SkipTest` exception then the module will be reported as "
"having been skipped instead of as an error."
msgstr ""
"如果在 ``setUpModule`` 中引發例外，則模組中的所有測試都不會運行，並且 "
"``tearDownModule`` 也不會運行。如果例外是 :exc:`SkipTest` "
"例外，那麼模組將被報告為已被跳過而不是錯誤。"

#: ../../library/unittest.rst:2481
#, fuzzy
msgid ""
"To add cleanup code that must be run even in the case of an exception, use "
"``addModuleCleanup``:"
msgstr "要新增即使在出現例外的情況下也必須運行的清理程式碼，請使用 ``addModuleCleanup`` "
"："

#: ../../library/unittest.rst:2487
#, fuzzy
msgid ""
"Add a function to be called after :func:`tearDownModule` to cleanup "
"resources used during the test class. Functions will be called in reverse "
"order to the order they are added (:abbr:`LIFO (last-in, first-out)`). They "
"are called with any arguments and keyword arguments passed into :meth:"
"`addModuleCleanup` when they are added."
msgstr ""
"在 :func:`tearDownModule` 之後新增一個要呼叫的函式，以清理測試類期間使用的資"
"源。函式將以與它們被新增的順序相反的順序被呼叫（ :abbr:`LIFO（後進先出）`）"
"。新增它們時，會使用傳遞給 addModuleCleanup "
"的任何參數和關鍵字參數來呼叫它們。"

#: ../../library/unittest.rst:2493
#, fuzzy
msgid ""
"If :meth:`setUpModule` fails, meaning that :func:`tearDownModule` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"如果 :meth:`setUpModule` 失敗，意味著 :func:`tearDownModule` "
"沒有被呼叫，那麼任何新增的清理函式仍然會被呼叫。"

#: ../../library/unittest.rst:2501
#, fuzzy
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :func:"
"`addModuleCleanup` and return the result of the :meth:`~object.__enter__` "
"method."
msgstr ""
"輸入提供的 :term:`context manager`。如果成功，還通過 :func:`addModuleCleanup`"
" 新增其 :meth:`~object.__exit__` 方法作為清理函式，並回傳 :meth:`~object."
"__enter__` 方法的結果。"

#: ../../library/unittest.rst:2511
#, fuzzy
msgid ""
"This function is called unconditionally after :func:`tearDownModule`, or "
"after :func:`setUpModule` if :func:`setUpModule` raises an exception."
msgstr ""
"此函式在 :func:`tearDownModule` 之後或在 :func:`setUpModule` 之後無條件呼叫，"
"如果 :func:`setUpModule` 引發例外。"

#: ../../library/unittest.rst:2514
#, fuzzy
msgid ""
"It is responsible for calling all the cleanup functions added by :func:"
"`addModuleCleanup`. If you need cleanup functions to be called *prior* to :"
"func:`tearDownModule` then you can call :func:`doModuleCleanups` yourself."
msgstr ""
"它負責呼叫 addModuleCleanup 新增的所有清理函式。如果您需要在 "
":func:`tearDownModule` 之前*呼叫清理函式，那麼您可以自己呼叫 "
":func:`doModuleCleanups`。"

#: ../../library/unittest.rst:2519
#, fuzzy
msgid ""
":func:`doModuleCleanups` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ":func:`doModuleCleanups` 一次從清理函式的堆疊中彈出方法，因此可以隨時呼叫。"

#: ../../library/unittest.rst:2526
#, fuzzy
msgid "Signal Handling"
msgstr "信號處理"

#: ../../library/unittest.rst:2530
#, fuzzy
msgid ""
"The :option:`-c/--catch <unittest -c>` command-line option to unittest, "
"along with the ``catchbreak`` parameter to :func:`unittest.main()`, provide "
"more friendly handling of control-C during a test run. With catch break "
"behavior enabled control-C will allow the currently running test to "
"complete, and the test run will then end and report all the results so far. "
"A second control-c will raise a :exc:`KeyboardInterrupt` in the usual way."
msgstr ""
":option:`-c/--catch <unittest -c>` unittest 的命令列選項，以及 "
":func:`unittest.main()` 的 ``catchbreak`` 參數，"
"提供更友好的處理在測試運行期間使用 control-C。啟用 catch break "
"行為後，control-C "
"將允許當前運行的測試完成，然後測試運行將結束並報告到目前為止的所有結果。"
"第二個 control-c 將以通常的方式引發 :exc:`KeyboardInterrupt`。"

#: ../../library/unittest.rst:2537
#, fuzzy
msgid ""
"The control-c handling signal handler attempts to remain compatible with "
"code or tests that install their own :const:`signal.SIGINT` handler. If the "
"``unittest`` handler is called but *isn't* the installed :const:`signal."
"SIGINT` handler, i.e. it has been replaced by the system under test and "
"delegated to, then it calls the default handler. This will normally be the "
"expected behavior by code that replaces an installed handler and delegates "
"to it. For individual tests that need ``unittest`` control-c handling "
"disabled the :func:`removeHandler` decorator can be used."
msgstr ""
"control-c 處理信號處理程式試圖與安裝自己的 signal.SIGINT "
"處理程式的程式碼或測試保持相容。如果 ``unittest`` 處理程式被呼叫但 *不是* "
"安裝的 :const:`signal.SIGINT` 處理程式，即它已被被測系統替換並委託給，那麼它"
"會呼叫預設處理程式。這通常是替換已安裝處理程式並委託給它的程式碼的預期行為。"
"對於需要禁用 ``unittest`` control-c 處理的個別測試，可以使用 "
":func:`removeHandler` 裝飾器。"

#: ../../library/unittest.rst:2546
#, fuzzy
msgid ""
"There are a few utility functions for framework authors to enable control-c "
"handling functionality within test frameworks."
msgstr "框架作者有一些實用函式可以在測試框架中啟用 control-c 處理功能。"

#: ../../library/unittest.rst:2551
#, fuzzy
msgid ""
"Install the control-c handler. When a :const:`signal.SIGINT` is received "
"(usually in response to the user pressing control-c) all registered results "
"have :meth:`~TestResult.stop` called."
msgstr ""
"安裝 control-c 處理程式。當收到 :const:`signal.SIGINT` 時（"
"通常是響應使用者按下 control-c），所有註冊的結果都會呼叫 :meth:`~TestResult."
"stop`。"

#: ../../library/unittest.rst:2558
#, fuzzy
msgid ""
"Register a :class:`TestResult` object for control-c handling. Registering a "
"result stores a weak reference to it, so it doesn't prevent the result from "
"being garbage collected."
msgstr "為 control-c 處理註冊一個 TestResult "
"物件。註冊結果會儲存對它的弱引用，因此不會阻止結果被垃圾收集。"

#: ../../library/unittest.rst:2562
#, fuzzy
msgid ""
"Registering a :class:`TestResult` object has no side-effects if control-c "
"handling is not enabled, so test frameworks can unconditionally register all "
"results they create independently of whether or not handling is enabled."
msgstr ""
"如果未啟用 control-c 處理，則註冊 TestResult 對像沒有副作用，因此測試框架可以"
"無條件地註冊它們建立的所有結果，無論是否啟用處理。"

#: ../../library/unittest.rst:2569
#, fuzzy
msgid ""
"Remove a registered result. Once a result has been removed then :meth:"
"`~TestResult.stop` will no longer be called on that result object in "
"response to a control-c."
msgstr "刪除已註冊的結果。一旦結果被刪除，那麼 :meth:`~TestResult.stop` "
"將不再在該結果對像上呼叫以響應 control-c。"

#: ../../library/unittest.rst:2576
#, fuzzy
msgid ""
"When called without arguments this function removes the control-c handler if "
"it has been installed. This function can also be used as a test decorator to "
"temporarily remove the handler while the test is being executed::"
msgstr "當不帶參數呼叫時，此函式將刪除已安裝的 control-c "
"處理程式。此函式還可以用作測試裝飾器，以在執行測試時臨時刪除處理程式::"
