# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-24 00:16+0000\n"
"PO-Revision-Date: 2018-05-23 16:10+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/sqlite3.rst:2
msgid ":mod:`sqlite3` --- DB-API 2.0 interface for SQLite databases"
msgstr ":mod:`sqlite3` --- SQLite 資料庫的 DB-API 2.0 介面"

#: ../../library/sqlite3.rst:9
msgid "**Source code:** :source:`Lib/sqlite3/`"
msgstr "**原始碼：**\\ :source:`Lib/sqlite3/`"

#: ../../library/sqlite3.rst:23
#, fuzzy
msgid ""
"SQLite is a C library that provides a lightweight disk-based database that "
"doesn't require a separate server process and allows accessing the database "
"using a nonstandard variant of the SQL query language. Some applications can "
"use SQLite for internal data storage.  It's also possible to prototype an "
"application using SQLite and then port the code to a larger database such as "
"PostgreSQL or Oracle."
msgstr ""
"SQLite 是一個 C 庫，它提供基於磁盤的輕型資料庫，不需要單獨的伺服器行程，"
"並允許使用 SQL 查詢語言的非標準變體訪問資料庫。一些應用程式可以使用 SQLite "
"進行內部資料儲存。還可以使用 SQLite "
"製作應用程式原型，然後將程式碼移植到更大的資料庫，例如 PostgreSQL 或 Oracle。"

#: ../../library/sqlite3.rst:30
#, fuzzy
msgid ""
"The :mod:`!sqlite3` module was written by Gerhard Häring.  It provides an "
"SQL interface compliant with the DB-API 2.0 specification described by :pep:"
"`249`, and requires SQLite 3.7.15 or newer."
msgstr ""
":mod:`!sqlite3` 模組由 Gerhard Häring 編寫。它提供的 SQL 介面符合 :pep:`249` "
"描述的 DB-API 2.0 規範，並且需要 SQLite 3.7.15 或更新版本。"

#: ../../library/sqlite3.rst:34
#, fuzzy
msgid "This document includes four main sections:"
msgstr "本文檔包括四個主要部分："

#: ../../library/sqlite3.rst:36
#, fuzzy
msgid ":ref:`sqlite3-tutorial` teaches how to use the :mod:`!sqlite3` module."
msgstr ":ref:`sqlite3-tutorial` 教授如何使用 :mod:`!sqlite3` 模組。"

#: ../../library/sqlite3.rst:37
#, fuzzy
msgid ""
":ref:`sqlite3-reference` describes the classes and functions this module "
"defines."
msgstr ":ref:`sqlite3-reference` 描述了這個模組定義的類和函式。"

#: ../../library/sqlite3.rst:39
#, fuzzy
msgid ":ref:`sqlite3-howtos` details how to handle specific tasks."
msgstr ":ref:`sqlite3-howtos` 詳細說明瞭如何處理特定任務。"

#: ../../library/sqlite3.rst:40
#, fuzzy
msgid ""
":ref:`sqlite3-explanation` provides in-depth background on transaction "
"control."
msgstr ":ref:`sqlite3-explanation` 提供了有關事務控制的深入背景知識。"

#: ../../library/sqlite3.rst:47
msgid "https://www.sqlite.org"
msgstr "https://www.sqlite.org"

#: ../../library/sqlite3.rst:46
#, fuzzy
msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr "SQLite 網頁；該文檔描述了支援的 SQL 方言的語法和可用資料型別。"

#: ../../library/sqlite3.rst:50
msgid "https://www.w3schools.com/sql/"
msgstr "https://www.w3schools.com/sql/"

#: ../../library/sqlite3.rst:50
#, fuzzy
msgid "Tutorial, reference and examples for learning SQL syntax."
msgstr "學習 SQL 語法的教程、參考和示例。"

#: ../../library/sqlite3.rst:52
#, fuzzy
msgid ":pep:`249` - Database API Specification 2.0"
msgstr ":pep:`249` - 資料庫 API 規範 2.0"

#: ../../library/sqlite3.rst:53
msgid "PEP written by Marc-André Lemburg."
msgstr "PEP 由 Marc-André Lemburg 撰寫。"

#: ../../library/sqlite3.rst:66
#, fuzzy
msgid "Tutorial"
msgstr "教程"

#: ../../library/sqlite3.rst:68
#, fuzzy
msgid ""
"In this tutorial, you will create a database of Monty Python movies using "
"basic :mod:`!sqlite3` functionality. It assumes a fundamental understanding "
"of database concepts, including `cursors`_ and `transactions`_."
msgstr ""
"在本教程中，您將使用基本的 :mod:`!sqlite3` 功能建立 Monty Python "
"電影的資料庫。它假定對資料庫概念有基本的了解，包括“游標”和“事務”。"

#: ../../library/sqlite3.rst:73
#, fuzzy
msgid ""
"First, we need to create a new database and open a database connection to "
"allow :mod:`!sqlite3` to work with it. Call :func:`sqlite3.connect` to "
"create a connection to the database :file:`tutorial.db` in the current "
"working directory, implicitly creating it if it does not exist:"
msgstr ""
"首先，我們需要建立一個新資料庫並打開一個資料庫連接以允許 :mod:`!sqlite3` "
"使用它。呼叫 :func:`sqlite3.connect` 在當前工作目錄中建立到資料庫 "
":file:`tutorial.db` 的連接，如果它不存在則隱式建立它："

#: ../../library/sqlite3.rst:84
#, fuzzy
msgid ""
"The returned :class:`Connection` object ``con`` represents the connection to "
"the on-disk database."
msgstr "回傳的 :class:`Connection` 物件 ``con`` 表示與磁盤資料庫的連接。"

#: ../../library/sqlite3.rst:87
#, fuzzy
msgid ""
"In order to execute SQL statements and fetch results from SQL queries, we "
"will need to use a database cursor. Call :meth:`con.cursor() <Connection."
"cursor>` to create the :class:`Cursor`:"
msgstr ""
"為了執行 SQL 語句並從 SQL 查詢中獲取結果，我們需要使用資料庫游標。呼叫 "
":meth:`con.cursor() <Connection.cursor>` 來建立 :class:`Cursor`："

#: ../../library/sqlite3.rst:95
#, fuzzy
msgid ""
"Now that we've got a database connection and a cursor, we can create a "
"database table ``movie`` with columns for title, release year, and review "
"score. For simplicity, we can just use column names in the table declaration "
"-- thanks to the `flexible typing`_ feature of SQLite, specifying the data "
"types is optional. Execute the ``CREATE TABLE`` statement by calling :meth:"
"`cur.execute(...) <Cursor.execute>`:"
msgstr ""
"現在我們已經有了一個資料庫連接和一個游標，我們可以建立一個資料庫表“電影”，其"
"中包含標題、發行年份和評論分數的列。為簡單起見，我們可以在表聲明中只使用列名—"
"—感謝 SQLite 的“靈活型別”特性，指定資料型別是可選的。通過呼叫 cur."
"execute(...) <Cursor.execute> 來執行 CREATE TABLE 語句："

#: ../../library/sqlite3.rst:111
#, fuzzy
msgid ""
"We can verify that the new table has been created by querying the "
"``sqlite_master`` table built-in to SQLite, which should now contain an "
"entry for the ``movie`` table definition (see `The Schema Table`_ for "
"details). Execute that query by calling :meth:`cur.execute(...) <Cursor."
"execute>`, assign the result to ``res``, and call :meth:`res.fetchone() "
"<Cursor.fetchone>` to fetch the resulting row:"
msgstr ""
"我們可以通過查詢 SQLite 內建的 ``sqlite_master`` 表來驗證新表是否已經建立，"
"該表現在應該包含 ``movie`` 表定義的條目（有關詳細資訊，請參見 `The Schema "
"Table`_ ).通過呼叫 :meth:`cur.execute(...) <Cursor.execute>` 執行該查詢，"
"將結果分配給 ``res``，然後呼叫 :meth:`res.fetchone() <Cursor.fetchone> ` "
"獲取結果行："

#: ../../library/sqlite3.rst:125
#, fuzzy
msgid ""
"We can see that the table has been created, as the query returns a :class:"
"`tuple` containing the table's name. If we query ``sqlite_master`` for a non-"
"existent table ``spam``, :meth:`!res.fetchone()` will return ``None``:"
msgstr ""
"我們可以看到表已經建立，因為查詢回傳一個包含表名的元組。如果我們查詢 "
"``sqlite_master`` 一個不存在的表 ``spam``，:meth:`!res.fetchone()` 將回傳 "
"``None``："

#: ../../library/sqlite3.rst:136
#, fuzzy
msgid ""
"Now, add two rows of data supplied as SQL literals by executing an "
"``INSERT`` statement, once again by calling :meth:`cur.execute(...) <Cursor."
"execute>`:"
msgstr ""
"現在，通過執行 ``INSERT`` 語句新增兩行作為 SQL 文字提供的資料，再次呼叫 "
":meth:`cur.execute(...) <Cursor.execute>`："

#: ../../library/sqlite3.rst:148
#, fuzzy
msgid ""
"The ``INSERT`` statement implicitly opens a transaction, which needs to be "
"committed before changes are saved in the database (see :ref:`sqlite3-"
"controlling-transactions` for details). Call :meth:`con.commit() <Connection."
"commit>` on the connection object to commit the transaction:"
msgstr ""
"``INSERT`` 語句隱式打開一個事務，需要在將更改保存到資料庫之前提交該事務（有關"
"詳細資訊，請參閱 :ref:`sqlite3-controlling-transactions`）。"
"在連接對像上呼叫 con.commit() <Connection.commit> 以提交事務："

#: ../../library/sqlite3.rst:158
#, fuzzy
msgid ""
"We can verify that the data was inserted correctly by executing a ``SELECT`` "
"query. Use the now-familiar :meth:`cur.execute(...) <Cursor.execute>` to "
"assign the result to ``res``, and call :meth:`res.fetchall() <Cursor."
"fetchall>` to return all resulting rows:"
msgstr ""
"我們可以通過執行 ``SELECT``查詢來驗證資料是否正確插入。使用現在熟悉的 :meth:`cur"
".execute(...) <Cursor.execute>` 將結果分配給 ``res``，然後呼叫 :meth:`res."
"fetchall() <Cursor.fetchall> ` 回傳所有結果行："

#: ../../library/sqlite3.rst:170
#, fuzzy
msgid ""
"The result is a :class:`list` of two :class:`!tuple`\\s, one per row, each "
"containing that row's ``score`` value."
msgstr "結果是一個包含兩個 :class:`!tuple`\\s 的 :class:`list`，每行一個，"
"每個包含該行的 ``score`` 值。"

#: ../../library/sqlite3.rst:173
#, fuzzy
msgid ""
"Now, insert three more rows by calling :meth:`cur.executemany(...) <Cursor."
"executemany>`:"
msgstr "現在，通過呼叫 cur.executemany(...) <Cursor.executemany>` 再插入三行："

#: ../../library/sqlite3.rst:186
#, fuzzy
msgid ""
"Notice that ``?`` placeholders are used to bind ``data`` to the query. "
"Always use placeholders instead of :ref:`string formatting <tut-formatting>` "
"to bind Python values to SQL statements, to avoid `SQL injection attacks`_ "
"(see :ref:`sqlite3-placeholders` for more details)."
msgstr ""
"請注意，``?`` 佔位符用於將 ``data`` 綁定到查詢。始終使用佔位符而不是 :ref:`"
"string formatting <tut-formatting>` 將 Python 值綁定到 SQL 語句，以避免 `SQL "
"注入攻擊`_（有關詳細資訊，請參閱 :ref:`sqlite3-placeholders`）。"

#: ../../library/sqlite3.rst:192
#, fuzzy
msgid ""
"We can verify that the new rows were inserted by executing a ``SELECT`` "
"query, this time iterating over the results of the query:"
msgstr "我們可以通過執行 ``SELECT``查詢來驗證是否插入了新行，這次遍歷查詢結果："

#: ../../library/sqlite3.rst:206
#, fuzzy
msgid ""
"Each row is a two-item :class:`tuple` of ``(year, title)``, matching the "
"columns selected in the query."
msgstr "每行都是 ``(year, title)`` 的兩項 :class:`tuple`，與查詢中選擇的列相匹配。"

#: ../../library/sqlite3.rst:209
#, fuzzy
msgid ""
"Finally, verify that the database has been written to disk by calling :meth:"
"`con.close() <Connection.close>` to close the existing connection, opening a "
"new one, creating a new cursor, then querying the database:"
msgstr ""
"最後，通過呼叫 :meth:`con.close() <Connection.close>` 關閉現有連接，打開一個"
"新連接，建立一個新游標，然後查詢資料庫來驗證資料庫是否已寫入磁盤："

#: ../../library/sqlite3.rst:224
#, fuzzy
msgid ""
"You've now created an SQLite database using the :mod:`!sqlite3` module, "
"inserted data and retrieved values from it in multiple ways."
msgstr "您現在已經使用 :mod:`!sqlite3` 模組建立了一個 SQLite "
"資料庫，以多種方式插入資料並從中檢索值。"

#: ../../library/sqlite3.rst:236
#, fuzzy
msgid ":ref:`sqlite3-howtos` for further reading:"
msgstr ":ref:`sqlite3-howtos` 進一步閱讀："

#: ../../library/sqlite3.rst:238
msgid ":ref:`sqlite3-placeholders`"
msgstr ":ref:`sqlite3-placeholders`"

#: ../../library/sqlite3.rst:239
msgid ":ref:`sqlite3-adapters`"
msgstr ":ref:`sqlite3-adapters`"

#: ../../library/sqlite3.rst:240
msgid ":ref:`sqlite3-converters`"
msgstr ":ref:`sqlite3-converters`"

#: ../../library/sqlite3.rst:241 ../../library/sqlite3.rst:557
msgid ":ref:`sqlite3-connection-context-manager`"
msgstr ":ref:`sqlite3-connection-context-manager`"

#: ../../library/sqlite3.rst:242
msgid ":ref:`sqlite3-howto-row-factory`"
msgstr ":ref:`sqlite3-howto-row-factory`"

#: ../../library/sqlite3.rst:244
#, fuzzy
msgid ""
":ref:`sqlite3-explanation` for in-depth background on transaction control."
msgstr ":ref:`sqlite3-explanation` 深入了解事務控制的背景知識。"

#: ../../library/sqlite3.rst:249
#, fuzzy
msgid "Reference"
msgstr "參考"

#: ../../library/sqlite3.rst:257
#, fuzzy
msgid "Module functions"
msgstr "模組功能"

#: ../../library/sqlite3.rst:264
#, fuzzy
msgid "Open a connection to an SQLite database."
msgstr "打開與 SQLite 資料庫的連接。"

#: ../../library/sqlite3.rst:0
msgid "Parameters"
msgstr "參數"

#: ../../library/sqlite3.rst:266
#, fuzzy
msgid ""
"The path to the database file to be opened. Pass ``\":memory:\"`` to open a "
"connection to a database that is in RAM instead of on disk."
msgstr "要打開的資料庫文件的路徑。傳遞 ``\":memory:\"`` 以打開與位於 RAM "
"而不是磁盤上的資料庫的連接。"

#: ../../library/sqlite3.rst:272
#, fuzzy
msgid ""
"How many seconds the connection should wait before raising an :exc:"
"`OperationalError` when a table is locked. If another connection opens a "
"transaction to modify a table, that table will be locked until the "
"transaction is committed. Default five seconds."
msgstr ""
"當表被鎖定時，在引發 OperationalError 之前連接應該等待多少秒。如果另一個連接"
"打開一個事務來修改一個表，那麼該表將被鎖定，直到該事務被提交。預設五秒。"

#: ../../library/sqlite3.rst:279
#, fuzzy
msgid ""
"Control whether and how data types not :ref:`natively supported by SQLite "
"<sqlite3-types>` are looked up to be converted to Python types, using the "
"converters registered with :func:`register_converter`. Set it to any "
"combination (using ``|``, bitwise or) of :const:`PARSE_DECLTYPES` and :const:"
"`PARSE_COLNAMES` to enable this. Column names takes precedence over declared "
"types if both flags are set. Types cannot be detected for generated fields "
"(for example ``max(data)``), even when the *detect_types* parameter is set; :"
"class:`str` will be returned instead. By default (``0``), type detection is "
"disabled."
msgstr ""
"使用在 :func:`register_converter` 註冊的轉換器，控制是否以及如何查找不受 "
"SQLite <sqlite3-types> 原生支援的資料型別以轉換為 Python 型別。將其設定為 "
"PARSE_DECLTYPES 和 PARSE_COLNAMES 的任意組合（使用 "
"``|``、按位或）以啟用此功能。如果設定了兩個旗標，則列名優先於聲明的型別。"
"即使設定了 *detect_types* 參數，也無法檢測生成欄位的型別（例如 "
"``max(data)``）； :class:`str` "
"將被回傳。預設情況下（``0``），型別檢測被禁用。"

#: ../../library/sqlite3.rst:293
#, fuzzy
msgid ""
"The :attr:`~Connection.isolation_level` of the connection, controlling "
"whether and how transactions are implicitly opened. Can be ``\"DEFERRED\"`` "
"(default), ``\"EXCLUSIVE\"`` or ``\"IMMEDIATE\"``; or ``None`` to disable "
"opening transactions implicitly. See :ref:`sqlite3-controlling-transactions` "
"for more."
msgstr ""
"連接的 :attr:`~Connection."
"isolation_level`，控制事務是否以及如何隱式打開。可以是``\"DEFERRED\""
"``（預設），``\"EXCLUSIVE\"`` 或``\"IMMEDIATE\""
"``；或 ``None`` 以隱式禁用打開交易。有關更多資訊，請參閱 :ref:`sqlite3"
"-controlling-transactions`。"

#: ../../library/sqlite3.rst:301
#, fuzzy
msgid ""
"If ``True`` (default), :exc:`ProgrammingError` will be raised if the "
"database connection is used by a thread other than the one that created it. "
"If ``False``, the connection may be accessed in multiple threads; write "
"operations may need to be serialized by the user to avoid data corruption. "
"See :attr:`threadsafety` for more information."
msgstr ""
"如果 ``True``（預設值），如果資料庫連接被建立它的執行緒以外的執行緒使用，則會"
"引發 :exec:`ProgrammingError`。如果為 ``False``，則可以在多個執行緒中訪問連接；寫"
"操作可能需要由使用者序列化以避免資料損壞。有關詳細資訊，請參閱 :attr:`thread"
"safety`。"

#: ../../library/sqlite3.rst:310
#, fuzzy
msgid ""
"A custom subclass of :class:`Connection` to create the connection with, if "
"not the default :class:`Connection` class."
msgstr "Connection 的自定義子類別，用於建立連接，如果不是預設的 Connection 類。"

#: ../../library/sqlite3.rst:314
#, fuzzy
msgid ""
"The number of statements that :mod:`!sqlite3` should internally cache for "
"this connection, to avoid parsing overhead. By default, 128 statements."
msgstr ":mod:`!sqlite3` 應該為此連接在內部快取的語句數，以避免解析開銷。預設情況下，"
"128 個語句。"

#: ../../library/sqlite3.rst:319
#, fuzzy
msgid ""
"If set to ``True``, *database* is interpreted as a :abbr:`URI (Uniform "
"Resource Identifier)` with a file path and an optional query string. The "
"scheme part *must* be ``\"file:\"``, and the path can be relative or "
"absolute. The query string allows passing parameters to SQLite, enabling "
"various :ref:`sqlite3-uri-tricks`."
msgstr ""
"如果設定為 ``True``，*資料庫* 被解釋為帶有文件路徑和可選查詢字串的 :abbr:`UR"
"I（統一資源標識符）`。方案部分*必須*是``\"file:\""
"``，路徑可以是相對的或絕對的。查詢字串允許將參數傳遞給 SQLite，啟用各種 "
":ref:`sqlite3-uri-tricks`。"

#: ../../library/sqlite3.rst:0
#, fuzzy
msgid "Return type"
msgstr "回傳型別"

#: ../../library/sqlite3.rst:330
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect`` with argument "
"``database``."
msgstr ""
"引發一個附帶引數 ``database`` 的\\ :ref:`稽核事件 <auditing>` ``sqlite3.connect``。"

#: ../../library/sqlite3.rst:331
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect/handle`` with "
"argument ``connection_handle``."
msgstr ""
"引發一個附帶引數 ``connection_handle`` 的\\ :ref:`稽核事件 <auditing>` ``sqlite3.connect/handle``。"

#: ../../library/sqlite3.rst:333
msgid "The *uri* parameter."
msgstr "*uri* 參數。"

#: ../../library/sqlite3.rst:336
#, fuzzy
msgid ""
"*database* can now also be a :term:`path-like object`, not only a string."
msgstr "*database* 現在也可以是一個 :term:`path-like object`，而不僅僅是一個字串。"

#: ../../library/sqlite3.rst:339
msgid "The ``sqlite3.connect/handle`` auditing event."
msgstr "``sqlite3.connect/handle`` 稽核事件。"

#: ../../library/sqlite3.rst:344
#, fuzzy
msgid ""
"Return ``True`` if the string *statement* appears to contain one or more "
"complete SQL statements. No syntactic verification or parsing of any kind is "
"performed, other than checking that there are no unclosed string literals "
"and the statement is terminated by a semicolon."
msgstr ""
"如果字串 *statement* 似乎包含一個或多個完整的 SQL 語句，則回傳 ``True``。不執行"
"任何型別的語法驗證或解析，除了檢查沒有未閉合的字串文字和語句以分號終止。"

#: ../../library/sqlite3.rst:350
msgid "For example:"
msgstr "範例："

#: ../../library/sqlite3.rst:359
#, fuzzy
msgid ""
"This function may be useful during command-line input to determine if the "
"entered text seems to form a complete SQL statement, or if additional input "
"is needed before calling :meth:`~Cursor.execute`."
msgstr ""
"此函式在命令列輸入期間可能很有用，以確定輸入的文本是否構成完整的 SQL 語句，"
"或者在呼叫 :meth:`~Cursor.execute` 之前是否需要額外的輸入。"

#: ../../library/sqlite3.rst:365
#, fuzzy
msgid ""
"Enable or disable callback tracebacks. By default you will not get any "
"tracebacks in user-defined functions, aggregates, converters, authorizer "
"callbacks etc. If you want to debug them, you can call this function with "
"*flag* set to ``True``. Afterwards, you will get tracebacks from callbacks "
"on :data:`sys.stderr`. Use ``False`` to disable the feature again."
msgstr ""
"啟用或禁用回呼回溯。預設情況下，您不會在使用者定義的函式、聚合、轉換器、授權"
"回呼等中獲得任何回溯。如果您想除錯它們，您可以呼叫此函式並將 *flag* 設定為 "
"``True``。之後，您將從 :data:`sys.stderr` 上的回呼中獲得回溯。使用 ``False`` "
"再次禁用該功能。"

#: ../../library/sqlite3.rst:372
#, fuzzy
msgid ""
"Register an :func:`unraisable hook handler <sys.unraisablehook>` for an "
"improved debug experience:"
msgstr "註冊一個 :func:`unraisable 鉤子處理程式 <sys.unraisablehook>` "
"以改善除錯體驗："

#: ../../library/sqlite3.rst:397
#, fuzzy
msgid ""
"Register an *adapter* callable to adapt the Python type *type* into an "
"SQLite type. The adapter is called with a Python object of type *type* as "
"its sole argument, and must return a value of a :ref:`type that SQLite "
"natively understands <sqlite3-types>`."
msgstr ""
"註冊一個可呼叫的 *adapter* 以將 Python 型別 *type* 適配為 SQLite 型別。"
"適配器以 *type* 型別的 Python 對像作為其唯一參數呼叫，並且必須回傳 SQLite "
"本機理解的 :ref:`type 值 <sqlite3-types>`。"

#: ../../library/sqlite3.rst:405
#, fuzzy
msgid ""
"Register the *converter* callable to convert SQLite objects of type "
"*typename* into a Python object of a specific type. The converter is invoked "
"for all SQLite values of type *typename*; it is passed a :class:`bytes` "
"object and should return an object of the desired Python type. Consult the "
"parameter *detect_types* of :func:`connect` for information regarding how "
"type detection works."
msgstr ""
"註冊 *converter* 可呼叫物件，將 *typename* 型別的 SQLite "
"物件轉換為特定型別的 Python 物件。為所有型別為 *typename* 的 SQLite "
"值呼叫轉換器；它被傳遞給一個 bytes 物件，並且應該回傳一個所需 Python "
"型別的物件。請查閱 :func:`connect` 的參數 *detect_types* "
"以獲取有關型別檢測如何工作的資訊。"

#: ../../library/sqlite3.rst:413
#, fuzzy
msgid ""
"Note: *typename* and the name of the type in your query are matched case-"
"insensitively."
msgstr "注意： *typename* 和查詢中的型別名稱匹配時不區分大小寫。"

#: ../../library/sqlite3.rst:420
#, fuzzy
msgid "Module constants"
msgstr "模組常數"

#: ../../library/sqlite3.rst:424
#, fuzzy
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function by using the type name, parsed from the query "
"column name, as the converter dictionary key. The type name must be wrapped "
"in square brackets (``[]``)."
msgstr ""
"將此旗標值傳遞給 :func:`connect` 的 *detect_types* "
"參數，以使用從查詢列名稱解析的型別名稱作為轉換器字典鍵來查找轉換器函式。"
"型別名稱必須括在方括號 (``[]``) 中。"

#: ../../library/sqlite3.rst:434
#, fuzzy
msgid ""
"This flag may be combined with :const:`PARSE_DECLTYPES` using the ``|`` "
"(bitwise or) operator."
msgstr "此旗標可以使用 ``|``（按位或）運算符與 :const:`PARSE_DECLTYPES` 組合。"

#: ../../library/sqlite3.rst:439
#, fuzzy
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function using the declared types for each column. The "
"types are declared when the database table is created. :mod:`!sqlite3` will "
"look up a converter function using the first word of the declared type as "
"the converter dictionary key. For example:"
msgstr ""
"將此旗標值傳遞給 :func:`connect` 的 *detect_types* "
"參數，以使用每列的聲明型別查找轉換器函式。型別是在建立資料庫表時聲明的。 "
":mod:`!sqlite3` "
"將使用聲明型別的第一個單詞作為轉換器字典鍵來查找轉換器函式。例如："

#: ../../library/sqlite3.rst:455
#, fuzzy
msgid ""
"This flag may be combined with :const:`PARSE_COLNAMES` using the ``|`` "
"(bitwise or) operator."
msgstr "此旗標可以使用 ``|``（按位或）運算符與 :const:`PARSE_COLNAMES` 組合。"

#: ../../library/sqlite3.rst:462
#, fuzzy
msgid ""
"Flags that should be returned by the *authorizer_callback* callable passed "
"to :meth:`Connection.set_authorizer`, to indicate whether:"
msgstr ""
"應由傳遞給 Connection.set_authorizer 的 *authorizer_callback* "
"可呼叫函式回傳的旗標，以指示是否："

#: ../../library/sqlite3.rst:465
#, fuzzy
msgid "Access is allowed (:const:`!SQLITE_OK`),"
msgstr "允許訪問（:const:`!SQLITE_OK`），"

#: ../../library/sqlite3.rst:466
#, fuzzy
msgid ""
"The SQL statement should be aborted with an error (:const:`!SQLITE_DENY`)"
msgstr "SQL 語句應該因錯誤而中止 (:const:`!SQLITE_DENY`)"

#: ../../library/sqlite3.rst:467
#, fuzzy
msgid ""
"The column should be treated as a ``NULL`` value (:const:`!SQLITE_IGNORE`)"
msgstr "該列應被視為 ``NULL`` 值（:const:`!SQLITE_IGNORE`）"

#: ../../library/sqlite3.rst:471
#, fuzzy
msgid ""
"String constant stating the supported DB-API level. Required by the DB-API. "
"Hard-coded to ``\"2.0\"``."
msgstr "說明支援的 DB-API 級別的字串常數。 DB-API 需要。硬編碼為“2.0”。"

#: ../../library/sqlite3.rst:476
#, fuzzy
msgid ""
"String constant stating the type of parameter marker formatting expected by "
"the :mod:`!sqlite3` module. Required by the DB-API. Hard-coded to "
"``\"qmark\"``."
msgstr "字串常數，說明 :mod:`!sqlite3` 模組期望的參數標記格式型別。 DB-API "
"需要。硬編碼為 ``qmark``。"

#: ../../library/sqlite3.rst:482
#, fuzzy
msgid "The ``named`` DB-API parameter style is also supported."
msgstr "``named`` DB-API 參數樣式也受支援。"

#: ../../library/sqlite3.rst:486
#, fuzzy
msgid ""
"Version number of the runtime SQLite library as a :class:`string <str>`."
msgstr "運行時 SQLite 庫的版本號作為 :class:`string <str>`。"

#: ../../library/sqlite3.rst:490
#, fuzzy
msgid ""
"Version number of the runtime SQLite library as a :class:`tuple` of :class:"
"`integers <int>`."
msgstr "運行時 SQLite 庫的版本號作為 :class:`integers <int>` 的 :class:`tuple`。"

#: ../../library/sqlite3.rst:495
#, fuzzy
msgid ""
"Integer constant required by the DB-API 2.0, stating the level of thread "
"safety the :mod:`!sqlite3` module supports. This attribute is set based on "
"the default `threading mode <https://sqlite.org/threadsafe.html>`_ the "
"underlying SQLite library is compiled with. The SQLite threading modes are:"
msgstr ""
"DB-API 2.0 所需的整數常數，說明 :mod:`!sqlite3` "
"模組支援的執行緒安全級別。此屬性是基於預設的`執行緒模式 <https://sqlite.org/"
"threadsafe.html>`_ 底層 SQLite 庫編譯的。 SQLite 執行緒模式是："

#: ../../library/sqlite3.rst:500
#, fuzzy
msgid ""
"**Single-thread**: In this mode, all mutexes are disabled and SQLite is "
"unsafe to use in more than a single thread at once."
msgstr "**單執行緒**：在這種模式下，所有互斥量都被禁用，SQLite "
"一次在多個執行緒中使用是不安全的。"

#: ../../library/sqlite3.rst:502
#, fuzzy
msgid ""
"**Multi-thread**: In this mode, SQLite can be safely used by multiple "
"threads provided that no single database connection is used simultaneously "
"in two or more threads."
msgstr "**多執行緒**：在這種模式下，SQLite 可以被多個執行緒安全地使用，前提是沒有在兩"
"個或多個執行緒中同時使用單個資料庫連接。"

#: ../../library/sqlite3.rst:505
#, fuzzy
msgid ""
"**Serialized**: In serialized mode, SQLite can be safely used by multiple "
"threads with no restriction."
msgstr "**序列化**：在序列化模式下，SQLite可以不受限制地被多執行緒安全使用。"

#: ../../library/sqlite3.rst:508
#, fuzzy
msgid ""
"The mappings from SQLite threading modes to DB-API 2.0 threadsafety levels "
"are as follows:"
msgstr "從 SQLite 執行緒模式到 DB-API 2.0 執行緒安全級別的映射如下："

#: ../../library/sqlite3.rst:512
#, fuzzy
msgid "SQLite threading mode"
msgstr "SQLite執行緒模式"

#: ../../library/sqlite3.rst:512
msgid "`threadsafety`_"
msgstr "`threadsafety`_"

#: ../../library/sqlite3.rst:512
msgid "`SQLITE_THREADSAFE`_"
msgstr "`SQLITE_THREADSAFE`_"

#: ../../library/sqlite3.rst:512
#, fuzzy
msgid "DB-API 2.0 meaning"
msgstr "DB-API 2.0 含義"

#: ../../library/sqlite3.rst:515
#, fuzzy
msgid "single-thread"
msgstr "單執行緒"

#: ../../library/sqlite3.rst:515
msgid "0"
msgstr "0"

#: ../../library/sqlite3.rst:515
#, fuzzy
msgid "Threads may not share the module"
msgstr "執行緒不能共享模組"

#: ../../library/sqlite3.rst:518
#, fuzzy
msgid "multi-thread"
msgstr "多執行緒"

#: ../../library/sqlite3.rst:518 ../../library/sqlite3.rst:521
msgid "1"
msgstr "1"

#: ../../library/sqlite3.rst:518
msgid "2"
msgstr "2"

#: ../../library/sqlite3.rst:518
#, fuzzy
msgid "Threads may share the module, but not connections"
msgstr "執行緒可以共享模組，但不能共享連接"

#: ../../library/sqlite3.rst:521
#, fuzzy
msgid "serialized"
msgstr "序列化"

#: ../../library/sqlite3.rst:521
msgid "3"
msgstr "3"

#: ../../library/sqlite3.rst:521
#, fuzzy
msgid "Threads may share the module, connections and cursors"
msgstr "執行緒可以共享模組、連接和游標"

#: ../../library/sqlite3.rst:528
#, fuzzy
msgid "Set *threadsafety* dynamically instead of hard-coding it to ``1``."
msgstr "動態設定 *threadsafety* 而不是將其硬編碼為 ``1``。"

#: ../../library/sqlite3.rst:533
#, fuzzy
msgid ""
"Version number of this module as a :class:`string <str>`. This is not the "
"version of the SQLite library."
msgstr "此模組的版本號作為 :class:`string <str>`。這不是 SQLite 庫的版本。"

#: ../../library/sqlite3.rst:538
#, fuzzy
msgid ""
"Version number of this module as a :class:`tuple` of :class:`integers "
"<int>`. This is not the version of the SQLite library."
msgstr "此模組的版本號作為 :class:`integers <int>` 的 :class:`tuple`。這不是 SQLite "
"庫的版本。"

#: ../../library/sqlite3.rst:545
#, fuzzy
msgid "Connection objects"
msgstr "連接物件"

#: ../../library/sqlite3.rst:549
#, fuzzy
msgid ""
"Each open SQLite database is represented by a ``Connection`` object, which "
"is created using :func:`sqlite3.connect`. Their main purpose is creating :"
"class:`Cursor` objects, and :ref:`sqlite3-controlling-transactions`."
msgstr ""
"每個打開的 SQLite 資料庫都由一個 ``Connection`` 物件表示，該對像是使用 "
":func:`sqlite3.connect` 建立的。它們的主要目的是建立 :class:`Cursor` 物件和 "
":ref:`sqlite3-controlling-transactions`。"

#: ../../library/sqlite3.rst:556
msgid ":ref:`sqlite3-connection-shortcuts`"
msgstr ":ref:`sqlite3-connection-shortcuts`"

#: ../../library/sqlite3.rst:559
#, fuzzy
msgid "An SQLite database connection has the following attributes and methods:"
msgstr "SQLite 資料庫連接具有以下屬性和方法："

#: ../../library/sqlite3.rst:563
#, fuzzy
msgid ""
"Create and return a :class:`Cursor` object. The cursor method accepts a "
"single optional parameter *factory*. If supplied, this must be a callable "
"returning an instance of :class:`Cursor` or its subclasses."
msgstr ""
"建立並回傳一個 Cursor 物件。 cursor 方法接受一個可選參數 "
"*factory*。如果提供，這必須是可呼叫的，回傳 Cursor 或其子類別的實例。"

#: ../../library/sqlite3.rst:570
#, fuzzy
msgid ""
"Open a :class:`Blob` handle to an existing :abbr:`BLOB (Binary Large "
"OBject)`."
msgstr "打開現有 BLOB（二進位大物件）的 :class:`Blob` 句柄。"

#: ../../library/sqlite3.rst:573
#, fuzzy
msgid "The name of the table where the blob is located."
msgstr "Blob 所在的表的名稱。"

#: ../../library/sqlite3.rst:576
#, fuzzy
msgid "The name of the column where the blob is located."
msgstr "blob 所在列的名稱。"

#: ../../library/sqlite3.rst:579
#, fuzzy
msgid "The name of the row where the blob is located."
msgstr "Blob 所在行的名稱。"

#: ../../library/sqlite3.rst:582
#, fuzzy
msgid ""
"Set to ``True`` if the blob should be opened without write permissions. "
"Defaults to ``False``."
msgstr "如果應該在沒有寫權限的情況下打開 blob，則設定為 ``True``。預設為 ``False``。"

#: ../../library/sqlite3.rst:587
#, fuzzy
msgid ""
"The name of the database where the blob is located. Defaults to ``\"main\"``."
msgstr "Blob 所在的資料庫的名稱。預設為``\"main\"``。"

#: ../../library/sqlite3.rst:0
#, fuzzy
msgid "Raises"
msgstr "加薪"

#: ../../library/sqlite3.rst:591
#, fuzzy
msgid "When trying to open a blob in a ``WITHOUT ROWID`` table."
msgstr "嘗試在 ``WITHOUT ROWID`` 表中打開 blob 時。"

#: ../../library/sqlite3.rst:598
#, fuzzy
msgid ""
"The blob size cannot be changed using the :class:`Blob` class. Use the SQL "
"function ``zeroblob`` to create a blob with a fixed size."
msgstr "使用 Blob 類無法更改 blob 大小。使用 SQL 函式 ``zeroblob`` "
"建立一個固定大小的 blob。"

#: ../../library/sqlite3.rst:605
#, fuzzy
msgid ""
"Commit any pending transaction to the database. If there is no open "
"transaction, this method is a no-op."
msgstr "將任何掛起的事務提交到資料庫。如果沒有打開的事務，則此方法是空操作。"

#: ../../library/sqlite3.rst:610
#, fuzzy
msgid ""
"Roll back to the start of any pending transaction. If there is no open "
"transaction, this method is a no-op."
msgstr "回滾到任何未決事務的開始。如果沒有打開的事務，則此方法是空操作。"

#: ../../library/sqlite3.rst:615
#, fuzzy
msgid ""
"Close the database connection. Any pending transaction is not committed "
"implicitly; make sure to :meth:`commit` before closing to avoid losing "
"pending changes."
msgstr "關閉資料庫連接。任何掛起的事務都不會隱式提交；確保在關閉之前 :meth:`commit` "
"以避免丟失掛起的更改。"

#: ../../library/sqlite3.rst:622
#, fuzzy
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.execute` on it "
"with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"建立一個新的 Cursor 物件並使用給定的 *sql* 和 *parameters* "
"在其上呼叫 :meth:`~Cursor.execute`。回傳新的游標物件。"

#: ../../library/sqlite3.rst:628
#, fuzzy
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executemany` on "
"it with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"建立一個新的 Cursor 物件並使用給定的 *sql* 和 *parameters* "
"在其上呼叫 :meth:`~Cursor.executemany`。回傳新的游標物件。"

#: ../../library/sqlite3.rst:634
#, fuzzy
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executescript` "
"on it with the given *sql_script*. Return the new cursor object."
msgstr ""
"建立一個新的 Cursor 物件並使用給定的 *sql_script* 在其上呼叫 :meth:`~Cursor."
"executescript`。回傳新的游標物件。"

#: ../../library/sqlite3.rst:640
#, fuzzy
msgid "Create or remove a user-defined SQL function."
msgstr "建立或刪除使用者定義的 SQL 函式。"

#: ../../library/sqlite3.rst:642
#, fuzzy
msgid "The name of the SQL function."
msgstr "SQL 函式的名稱。"

#: ../../library/sqlite3.rst:645
#, fuzzy
msgid ""
"The number of arguments the SQL function can accept. If ``-1``, it may take "
"any number of arguments."
msgstr "SQL 函式可以接受的參數數量。如果為 ``-1``，則它可以接受任意數量的參數。"

#: ../../library/sqlite3.rst:649
#, fuzzy
msgid ""
"A callable that is called when the SQL function is invoked. The callable "
"must return :ref:`a type natively supported by SQLite <sqlite3-types>`. Set "
"to ``None`` to remove an existing SQL function."
msgstr ""
"呼叫 SQL 函式時呼叫的可呼叫物件。可呼叫物件必須回傳 :ref:`SQLite "
"<sqlite3-types>` 原生支援的型別。設定為 ``None`` 以刪除現有的 SQL 函式。"

#: ../../library/sqlite3.rst:656
#, fuzzy
msgid ""
"If ``True``, the created SQL function is marked as `deterministic <https://"
"sqlite.org/deterministic.html>`_, which allows SQLite to perform additional "
"optimizations."
msgstr ""
"如果為 ``True``，建立的 SQL 函式將被標記為“確定性 <https://sqlite.org/"
"deterministic.html>”，這允許 SQLite 執行額外的最佳化。"

#: ../../library/sqlite3.rst:661
#, fuzzy
msgid "If *deterministic* is used with SQLite versions older than 3.8.3."
msgstr "如果 *deterministic* 與低於 3.8.3 的 SQLite 版本一起使用。"

#: ../../library/sqlite3.rst:664
msgid "The *deterministic* parameter."
msgstr "新增 *deterministic* 參數。"

#: ../../library/sqlite3.rst:667 ../../library/sqlite3.rst:705
#: ../../library/sqlite3.rst:768 ../../library/sqlite3.rst:1019
#: ../../library/sqlite3.rst:1256 ../../library/sqlite3.rst:1383
#: ../../library/sqlite3.rst:1404
msgid "Example:"
msgstr "範例："

#: ../../library/sqlite3.rst:683
#, fuzzy
msgid "Create or remove a user-defined SQL aggregate function."
msgstr "建立或刪除使用者定義的 SQL 聚合函式。"

#: ../../library/sqlite3.rst:685
#, fuzzy
msgid "The name of the SQL aggregate function."
msgstr "SQL 聚合函式的名稱。"

#: ../../library/sqlite3.rst:688
#, fuzzy
msgid ""
"The number of arguments the SQL aggregate function can accept. If ``-1``, it "
"may take any number of arguments."
msgstr "SQL 聚合函式可以接受的參數數量。如果為 ``-1``，則它可以接受任意數量的參數。"

#: ../../library/sqlite3.rst:692
#, fuzzy
msgid ""
"A class must implement the following methods:  * ``step()``: Add a row to "
"the aggregate. * ``finalize()``: Return the final result of the aggregate "
"as   :ref:`a type natively supported by SQLite <sqlite3-types>`.  The number "
"of arguments that the ``step()`` method must accept is controlled by "
"*n_arg*.  Set to ``None`` to remove an existing SQL aggregate function."
msgstr ""
"一個類必須實作以下方法： * ``step()``：向聚合中新增一行。 * "
"``finalize()``：將聚合的最終結果回傳為 :ref:`SQLite <sqlite3-types> "
"原生支援的型別。 ``step()`` 方法必須接受的參數數量由 *n_arg* 控制。設定為 ``None`` "
"以刪除現有的 SQL 聚合函式。"

#: ../../library/sqlite3.rst:693
#, fuzzy
msgid "A class must implement the following methods:"
msgstr "一個類必須實作以下方法："

#: ../../library/sqlite3.rst:695
#, fuzzy
msgid "``step()``: Add a row to the aggregate."
msgstr "``step()``：向聚合中新增一行。"

#: ../../library/sqlite3.rst:696 ../../library/sqlite3.rst:752
#, fuzzy
msgid ""
"``finalize()``: Return the final result of the aggregate as :ref:`a type "
"natively supported by SQLite <sqlite3-types>`."
msgstr "``finalize()``：將聚合的最終結果回傳為 :ref:`SQLite <sqlite3-types> "
"原生支援的型別。"

#: ../../library/sqlite3.rst:699
#, fuzzy
msgid ""
"The number of arguments that the ``step()`` method must accept is controlled "
"by *n_arg*."
msgstr "``step()`` 方法必須接受的參數數量由 *n_arg* 控制。"

#: ../../library/sqlite3.rst:702
#, fuzzy
msgid "Set to ``None`` to remove an existing SQL aggregate function."
msgstr "設定為 ``None`` 以刪除現有的 SQL 聚合函式。"

#: ../../library/sqlite3.rst:737
#, fuzzy
msgid "Create or remove a user-defined aggregate window function."
msgstr "建立或刪除使用者定義的聚合窗口函式。"

#: ../../library/sqlite3.rst:739
#, fuzzy
msgid "The name of the SQL aggregate window function to create or remove."
msgstr "要建立或刪除的 SQL 聚合窗口函式的名稱。"

#: ../../library/sqlite3.rst:742
#, fuzzy
msgid ""
"The number of arguments the SQL aggregate window function can accept. If "
"``-1``, it may take any number of arguments."
msgstr "SQL 聚合窗口函式可以接受的參數數量。如果為 ``-1``，則它可以接受任意數量的參數。"

#: ../../library/sqlite3.rst:746
#, fuzzy
msgid ""
"A class that must implement the following methods:  * ``step()``: Add a row "
"to the current window. * ``value()``: Return the current value of the "
"aggregate. * ``inverse()``: Remove a row from the current window. * "
"``finalize()``: Return the final result of the aggregate as   :ref:`a type "
"natively supported by SQLite <sqlite3-types>`.  The number of arguments that "
"the ``step()`` and ``value()`` methods must accept is controlled by "
"*num_params*.  Set to ``None`` to remove an existing SQL aggregate window "
"function."
msgstr ""
"必須實作以下方法的類： * ``step()``：向當前窗口新增一行。 * "
"``value()``：回傳聚合的當前值。 * ``inverse()``: 從當前窗口中刪除一行。 * "
"``finalize()``：將聚合的最終結果回傳為 :ref:`SQLite <sqlite3-types> "
"原生支援的型別。 ``step()`` 和 ``value()`` 方法必須接受的參數數量由 "
"*num_params* 控制。設定為 ``None`` 以刪除現有的 SQL 聚合窗口函式。"

#: ../../library/sqlite3.rst:747
#, fuzzy
msgid "A class that must implement the following methods:"
msgstr "必須實作以下方法的類："

#: ../../library/sqlite3.rst:749
#, fuzzy
msgid "``step()``: Add a row to the current window."
msgstr "``step()``：向當前窗口新增一行。"

#: ../../library/sqlite3.rst:750
#, fuzzy
msgid "``value()``: Return the current value of the aggregate."
msgstr "``value()``：回傳聚合的當前值。"

#: ../../library/sqlite3.rst:751
#, fuzzy
msgid "``inverse()``: Remove a row from the current window."
msgstr "``inverse()``：從當前窗口中刪除一行。"

#: ../../library/sqlite3.rst:755
#, fuzzy
msgid ""
"The number of arguments that the ``step()`` and ``value()`` methods must "
"accept is controlled by *num_params*."
msgstr "``step()`` 和 ``value()`` 方法必須接受的參數數量由 *num_params* 控制。"

#: ../../library/sqlite3.rst:758
#, fuzzy
msgid "Set to ``None`` to remove an existing SQL aggregate window function."
msgstr "設定為 ``None`` 以刪除現有的 SQL 聚合窗口函式。"

#: ../../library/sqlite3.rst:760
#, fuzzy
msgid ""
"If used with a version of SQLite older than 3.25.0, which does not support "
"aggregate window functions."
msgstr "如果與不支援聚合窗口函式的 3.25.0 之前的 SQLite 版本一起使用。"

#: ../../library/sqlite3.rst:823
#, fuzzy
msgid ""
"Create a collation named *name* using the collating function *callable*. "
"*callable* is passed two :class:`string <str>` arguments, and it should "
"return an :class:`integer <int>`:"
msgstr ""
"使用歸類函式 *callable* 建立一個名為 *name* 的歸類。 *callable* 被傳遞了兩個 "
":class:`string <str>` 參數，它應該回傳一個 :class:`integer <int>`："

#: ../../library/sqlite3.rst:827
#, fuzzy
msgid "``1`` if the first is ordered higher than the second"
msgstr "``1`` 如果第一個比第二個高"

#: ../../library/sqlite3.rst:828
#, fuzzy
msgid "``-1`` if the first is ordered lower than the second"
msgstr "``-1`` 如果第一個比第二個低"

#: ../../library/sqlite3.rst:829
#, fuzzy
msgid "``0`` if they are ordered equal"
msgstr "``0`` 如果它們的順序相等"

#: ../../library/sqlite3.rst:831
#, fuzzy
msgid "The following example shows a reverse sorting collation:"
msgstr "以下示例顯示了反向排序規則："

#: ../../library/sqlite3.rst:859
#, fuzzy
msgid "Remove a collation function by setting *callable* to ``None``."
msgstr "通過將 *callable* 設定為 ``None`` 來刪除排序規則函式。"

#: ../../library/sqlite3.rst:861
#, fuzzy
msgid ""
"The collation name can contain any Unicode character.  Earlier, only ASCII "
"characters were allowed."
msgstr "排序規則名稱可以包含任何 Unicode 字元。早些時候，只允許使用 ASCII 字元。"

#: ../../library/sqlite3.rst:868
#, fuzzy
msgid ""
"Call this method from a different thread to abort any queries that might be "
"executing on the connection. Aborted queries will raise an :exc:"
"`OperationalError`."
msgstr "從不同的執行緒呼叫此方法以中止可能正在連接上執行的任何查詢。中止的查詢將引發 "
":exc:`OperationalError`。"

#: ../../library/sqlite3.rst:875
#, fuzzy
msgid ""
"Register callable *authorizer_callback* to be invoked for each attempt to "
"access a column of a table in the database. The callback should return one "
"of :const:`SQLITE_OK`, :const:`SQLITE_DENY`, or :const:`SQLITE_IGNORE` to "
"signal how access to the column should be handled by the underlying SQLite "
"library."
msgstr ""
"註冊可呼叫的 *authorizer_callback* 以在每次嘗試訪問資料庫中的表的列時呼叫。"
"回呼應回傳 :const:`SQLITE_OK`、:const:`SQLITE_DENY` 或 :const:`SQLITE_IGNORE`"
" 之一，以指示底層 SQLite 庫應如何處理對列的訪問。"

#: ../../library/sqlite3.rst:881
#, fuzzy
msgid ""
"The first argument to the callback signifies what kind of operation is to be "
"authorized. The second and third argument will be arguments or ``None`` "
"depending on the first argument. The 4th argument is the name of the "
"database (\"main\", \"temp\", etc.) if applicable. The 5th argument is the "
"name of the inner-most trigger or view that is responsible for the access "
"attempt or ``None`` if this access attempt is directly from input SQL code."
msgstr ""
"回呼的第一個參數表示要授權哪種操作。根據第一個參數，第二個和第三個參數將是參"
"數或 ``None`` 。第 4 個參數是資料庫的名稱（ ``main``、 ``temp``等）（如果適用）。第 5 "
"個參數是負責訪問嘗試的最內層觸發器或視圖的名稱，如果此訪問嘗試直接來自輸入 "
"SQL 程式碼，則為 ``None`` 。"

#: ../../library/sqlite3.rst:888
#, fuzzy
msgid ""
"Please consult the SQLite documentation about the possible values for the "
"first argument and the meaning of the second and third argument depending on "
"the first one. All necessary constants are available in the :mod:`!sqlite3` "
"module."
msgstr ""
"請查閱 SQLite 文檔，了解第一個參數的可能值以及第二個和第三個參數的含義，具體"
"取決於第一個參數。 :mod:`!sqlite3` 模組中提供了所有必需的常數。"

#: ../../library/sqlite3.rst:892
#, fuzzy
msgid "Passing ``None`` as *authorizer_callback* will disable the authorizer."
msgstr "將 ``None``作為 *authorizer_callback* 傳遞將禁用授權方。"

#: ../../library/sqlite3.rst:894
#, fuzzy
msgid "Added support for disabling the authorizer using ``None``."
msgstr "新增了對使用 ``None`` 禁用授權方的支援。"

#: ../../library/sqlite3.rst:900
#, fuzzy
msgid ""
"Register callable *progress_handler* to be invoked for every *n* "
"instructions of the SQLite virtual machine. This is useful if you want to "
"get called from SQLite during long-running operations, for example to update "
"a GUI."
msgstr ""
"註冊可呼叫的 *progress_handler* 為 SQLite 虛擬機的每個 *n* 指令呼叫。"
"如果你想在長時間運行的操作期間從 SQLite 呼叫它，這很有用，例如更新 GUI。"

#: ../../library/sqlite3.rst:905
#, fuzzy
msgid ""
"If you want to clear any previously installed progress handler, call the "
"method with ``None`` for *progress_handler*."
msgstr "如果您想清除任何以前安裝的進度處理程式，請為 *progress_handler* "
"呼叫帶有 ``None``的方法。"

#: ../../library/sqlite3.rst:908
#, fuzzy
msgid ""
"Returning a non-zero value from the handler function will terminate the "
"currently executing query and cause it to raise an :exc:`OperationalError` "
"exception."
msgstr "從處理函式回傳一個非零值將終止當前正在執行的查詢並導致它引發 "
":exc:`OperationalError` 例外。"

#: ../../library/sqlite3.rst:915
#, fuzzy
msgid ""
"Register callable *trace_callback* to be invoked for each SQL statement that "
"is actually executed by the SQLite backend."
msgstr "為 SQLite 後端實際執行的每個 SQL 語句註冊要呼叫的可呼叫 *trace_callback*。"

#: ../../library/sqlite3.rst:918
#, fuzzy
msgid ""
"The only argument passed to the callback is the statement (as :class:`str`) "
"that is being executed. The return value of the callback is ignored. Note "
"that the backend does not only run statements passed to the :meth:`Cursor."
"execute` methods.  Other sources include the :ref:`transaction management "
"<sqlite3-controlling-transactions>` of the :mod:`!sqlite3` module and the "
"execution of triggers defined in the current database."
msgstr ""
"傳遞給回呼的唯一參數是正在執行的語句（如 "
":class:`str`）。回呼的回傳值被忽略。請注意，後端不僅運行傳遞給 "
"Cursor.execute 方法的語句。其他來源包括 :ref:`!sqlite3` 模組的事務管理 "
"<sqlite3-controlling-transactions>` 和當前資料庫中定義的觸發器的執行。"

#: ../../library/sqlite3.rst:926
#, fuzzy
msgid "Passing ``None`` as *trace_callback* will disable the trace callback."
msgstr "將 ``None`` 作為 *trace_callback* 傳遞將禁用跟踪回呼。"

#: ../../library/sqlite3.rst:929
#, fuzzy
msgid ""
"Exceptions raised in the trace callback are not propagated. As a development "
"and debugging aid, use :meth:`~sqlite3.enable_callback_tracebacks` to enable "
"printing tracebacks from exceptions raised in the trace callback."
msgstr ""
"不會傳播跟踪回呼中引發的例外。作為開發和除錯輔助工具，使用 :meth:`~sqlite3."
"enable_callback_tracebacks` 啟用從跟踪回呼中引發的例外印出回溯。"

#: ../../library/sqlite3.rst:939
#, fuzzy
msgid ""
"Enable the SQLite engine to load SQLite extensions from shared libraries if "
"*enabled* is ``True``; else, disallow loading SQLite extensions. SQLite "
"extensions can define new functions, aggregates or whole new virtual table "
"implementations.  One well-known extension is the fulltext-search extension "
"distributed with SQLite."
msgstr ""
"如果 *enabled* 為 ``True``，則啟用 SQLite 引擎從共享庫加載 SQLite "
"擴充；否則，禁止加載 SQLite 擴充。 SQLite "
"擴充可以定義新函式、聚合或全新的虛擬表實作。一個眾所周知的擴充是與 SQLite "
"一起分發的全文搜索擴充。"

#: ../../library/sqlite3.rst:948
#, fuzzy
msgid ""
"The :mod:`!sqlite3` module is not built with loadable extension support by "
"default, because some platforms (notably macOS) have SQLite libraries which "
"are compiled without this feature. To get loadable extension support, you "
"must pass the :option:`--enable-loadable-sqlite-extensions` option to :"
"program:`configure`."
msgstr ""
"預設情況下，:mod:`!sqlite3` 模組沒有構建可加載擴充支援，因為某些平台（尤其是 "
"macOS）具有在沒有此功能的情況下編譯的 SQLite "
"庫。要獲得可加載擴充支援，您必須將 :option:`--enable-loadable-sqlite-"
"extensions` 選項傳遞給 :program:`configure`。"

#: ../../library/sqlite3.rst:955
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.enable_load_extension`` "
"with arguments ``connection``, ``enabled``."
msgstr ""
"引發一個附帶引數 ``connection``、``enabled`` 的\\ :ref:`稽核事件 <auditing>` ``sqlite3.enable_load_extension``。"

#: ../../library/sqlite3.rst:959
msgid "Added the ``sqlite3.enable_load_extension`` auditing event."
msgstr "加入 ``sqlite3.enable_load_extension`` 稽核事件。"

#: ../../library/sqlite3.rst:1002
#, fuzzy
msgid ""
"Load an SQLite extension from a shared library located at *path*. Enable "
"extension loading with :meth:`enable_load_extension` before calling this "
"method."
msgstr ""
"從位於 *path* 的共享庫加載 SQLite 擴充。在呼叫此方法之前使用 "
":meth:`enable_load_extension` 啟用擴充加載。"

#: ../../library/sqlite3.rst:1006
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.load_extension`` with "
"arguments ``connection``, ``path``."
msgstr ""
"引發一個附帶引數 ``connection``、``path`` 的\\ :ref:`稽核事件 <auditing>` ``sqlite3.load_extension``。"

#: ../../library/sqlite3.rst:1010
msgid "Added the ``sqlite3.load_extension`` auditing event."
msgstr "加入 ``sqlite3.load_extension`` 稽核事件。"

#: ../../library/sqlite3.rst:1015
#, fuzzy
msgid ""
"Return an :term:`iterator` to dump the database as SQL source code. Useful "
"when saving an in-memory database for later restoration. Similar to the ``."
"dump`` command in the :program:`sqlite3` shell."
msgstr ""
"回傳一個 :term:`iterator` 將資料庫轉儲為 SQL "
"源程式碼。在保存記憶體資料庫以供以後恢復時很有用。類似於 sqlite3 shell 中的 ."
"dump 命令。"

#: ../../library/sqlite3.rst:1033
#, fuzzy
msgid "Create a backup of an SQLite database."
msgstr "建立 SQLite 資料庫的備份。"

#: ../../library/sqlite3.rst:1035
#, fuzzy
msgid ""
"Works even if the database is being accessed by other clients or "
"concurrently by the same connection."
msgstr "即使資料庫正在被其他客戶端訪問或由同一連接同時訪問，也能正常工作。"

#: ../../library/sqlite3.rst:1038
#, fuzzy
msgid "The database connection to save the backup to."
msgstr "將備份保存到的資料庫連接。"

#: ../../library/sqlite3.rst:1041
#, fuzzy
msgid ""
"The number of pages to copy at a time. If equal to or less than ``0``, the "
"entire database is copied in a single step. Defaults to ``-1``."
msgstr "一次復印的頁數。如果等於或小於 ``0``，則整個資料庫將一步複製。預設為 ``-1``。"

#: ../../library/sqlite3.rst:1047
#, fuzzy
msgid ""
"If set to a callable, it is invoked with three integer arguments for every "
"backup iteration: the *status* of the last iteration, the *remaining* number "
"of pages still to be copied, and the *total* number of pages. Defaults to "
"``None``."
msgstr "如果設定為可呼叫，則每次備份疊代都會使用三個整數參數呼叫它：最後一次疊代的*狀"
"態*、仍要復制的*剩餘*頁數和*總*頁數。預設為 ``None`` 。"

#: ../../library/sqlite3.rst:1056
#, fuzzy
msgid ""
"The name of the database to back up. Either ``\"main\"`` (the default) for "
"the main database, ``\"temp\"`` for the temporary database, or the name of a "
"custom database as attached using the ``ATTACH DATABASE`` SQL statement."
msgstr ""
"要備份的資料庫的名稱。主資料庫的 ``main``（預設值），臨時資料庫的 ``temp``，或者使"
"用“ATTACH DATABASE”SQL 語句附加的自定義資料庫的名稱。"

#: ../../library/sqlite3.rst:1063
#, fuzzy
msgid ""
"The number of seconds to sleep between successive attempts to back up "
"remaining pages."
msgstr "在連續嘗試備份剩餘頁面之間休眠的秒數。"

#: ../../library/sqlite3.rst:1067
#, fuzzy
msgid "Example 1, copy an existing database into another:"
msgstr "示例1，將現有資料庫複製到另一個："

#: ../../library/sqlite3.rst:1086
#, fuzzy
msgid "Example 2, copy an existing database into a transient copy:"
msgstr "示例 2，將現有資料庫複製到臨時副本中："

#: ../../library/sqlite3.rst:1098
#, fuzzy
msgid "Get a connection runtime limit."
msgstr "獲取連接運行時限制。"

#: ../../library/sqlite3.rst:1100
#, fuzzy
msgid "The `SQLite limit category`_ to be queried."
msgstr "要查詢的“SQLite 限制類別”。"

#: ../../library/sqlite3.rst:1105 ../../library/sqlite3.rst:1142
#, fuzzy
msgid "If *category* is not recognised by the underlying SQLite library."
msgstr "如果 *category* 不被底層 SQLite 庫識別。"

#: ../../library/sqlite3.rst:1108
#, fuzzy
msgid ""
"Example, query the maximum length of an SQL statement for :class:"
"`Connection` ``con`` (the default is 1000000000):"
msgstr "例如，查詢 :class:`Connection` ``con`` 的 SQL 語句的最大長度（預設為 "
"1000000000）："

#: ../../library/sqlite3.rst:1128
#, fuzzy
msgid ""
"Set a connection runtime limit. Attempts to increase a limit above its hard "
"upper bound are silently truncated to the hard upper bound. Regardless of "
"whether or not the limit was changed, the prior value of the limit is "
"returned."
msgstr "設定連接運行時限制。將限制增加到其硬上限之上的嘗試會被默默地截斷到硬上限。無"
"論限制是否更改，都會回傳限制的先前值。"

#: ../../library/sqlite3.rst:1133
#, fuzzy
msgid "The `SQLite limit category`_ to be set."
msgstr "要設定的“SQLite 限制類別”。"

#: ../../library/sqlite3.rst:1136
#, fuzzy
msgid ""
"The value of the new limit. If negative, the current limit is unchanged."
msgstr "新限制的值。如果為負，則電流限制不變。"

#: ../../library/sqlite3.rst:1145
#, fuzzy
msgid ""
"Example, limit the number of attached databases to 1 for :class:`Connection` "
"``con`` (the default limit is 10):"
msgstr "例如，將連接的資料庫數量限制為 1 個 :class:`Connection` ``con``（預設限制為 "
"10）："

#: ../../library/sqlite3.rst:1162
#, fuzzy
msgid ""
"Serialize a database into a :class:`bytes` object.  For an ordinary on-disk "
"database file, the serialization is just a copy of the disk file.  For an in-"
"memory database or a \"temp\" database, the serialization is the same "
"sequence of bytes which would be written to disk if that database were "
"backed up to disk."
msgstr ""
"將資料庫序列化為 :class:`bytes` 物件。對於普通的磁盤資料庫文件，序列化只是磁"
"盤文件的一個副本。對於記憶體資料庫或“臨時”資料庫，序列化與將資料庫備份到磁盤"
"時寫入磁盤的位元組序列相同。"

#: ../../library/sqlite3.rst:1168
#, fuzzy
msgid "The database name to be serialized. Defaults to ``\"main\"``."
msgstr "要序列化的資料庫名稱。預設為``\"main\"``。"

#: ../../library/sqlite3.rst:1176
#, fuzzy
msgid ""
"This method is only available if the underlying SQLite library has the "
"serialize API."
msgstr "此方法僅在底層 SQLite 庫具有序列化 API 時可用。"

#: ../../library/sqlite3.rst:1184
#, fuzzy
msgid ""
"Deserialize a :meth:`serialized <serialize>` database into a :class:"
"`Connection`. This method causes the database connection to disconnect from "
"database *name*, and reopen *name* as an in-memory database based on the "
"serialization contained in *data*."
msgstr ""
"將 :meth:`serialized <serialize>` 資料庫反序列化為 :class:`Connection`。"
"此方法導致資料庫連接與資料庫 *name* 斷開連接，並根據 *data* 中包含的序列化將 "
"*name* 作為記憶體資料庫重新打開。"

#: ../../library/sqlite3.rst:1190
#, fuzzy
msgid "A serialized database."
msgstr "一個序列化的資料庫。"

#: ../../library/sqlite3.rst:1193
#, fuzzy
msgid "The database name to deserialize into. Defaults to ``\"main\"``."
msgstr "要反序列化到的資料庫名稱。預設為``\"main\"``。"

#: ../../library/sqlite3.rst:1197
#, fuzzy
msgid ""
"If the database connection is currently involved in a read transaction or a "
"backup operation."
msgstr "如果資料庫連接當前涉及讀取事務或備份操作。"

#: ../../library/sqlite3.rst:1201
#, fuzzy
msgid "If *data* does not contain a valid SQLite database."
msgstr "如果 *data* 不包含有效的 SQLite 資料庫。"

#: ../../library/sqlite3.rst:1204
#, fuzzy
msgid "If :func:`len(data) <len>` is larger than ``2**63 - 1``."
msgstr "如果 :func:`len(data) <len>` 大於 ``2**63 - 1``。"

#: ../../library/sqlite3.rst:1209
#, fuzzy
msgid ""
"This method is only available if the underlying SQLite library has the "
"deserialize API."
msgstr "此方法僅在底層 SQLite 庫具有反序列化 API 時可用。"

#: ../../library/sqlite3.rst:1216
#, fuzzy
msgid ""
"This read-only attribute corresponds to the low-level SQLite `autocommit "
"mode`_."
msgstr "這個只讀屬性對應於低階 SQLite 的“自動提交模式”。"

#: ../../library/sqlite3.rst:1219
#, fuzzy
msgid ""
"``True`` if a transaction is active (there are uncommitted changes), "
"``False`` otherwise."
msgstr "如果事務處於活動狀態（有未提交的更改），則為 ``True``，否則為 ``False``。"

#: ../../library/sqlite3.rst:1226
#, fuzzy
msgid ""
"This attribute controls the :ref:`transaction handling <sqlite3-controlling-"
"transactions>` performed by :mod:`!sqlite3`. If set to ``None``, "
"transactions are never implicitly opened. If set to one of ``\"DEFERRED\"``, "
"``\"IMMEDIATE\"``, or ``\"EXCLUSIVE\"``, corresponding to the underlying "
"`SQLite transaction behaviour`_, implicit :ref:`transaction management "
"<sqlite3-controlling-transactions>` is performed."
msgstr ""
"此屬性控制 :ref:`事務處理 <sqlite3-controlling-transactions>` 由 "
":mod:`!sqlite3` 執行。如果設定為 ``None`` ，則永遠不會隱式打開事務。如果設定為 ``"
"\"DEFERRED\"``、``\"IMMEDIATE\"`` 或 ``\"EXCLUSIVE\"`` 之一，對應於底層的 `"
"SQLite 事務行為`_，隱式 :ref:`事務管理 <sqlite3 -controlling-transactions>` "
"被執行。"

#: ../../library/sqlite3.rst:1234
#, fuzzy
msgid ""
"If not overridden by the *isolation_level* parameter of :func:`connect`, the "
"default is ``\"\"``, which is an alias for ``\"DEFERRED\"``."
msgstr ""
"如果未被 :func:`connect` 的 *isolation_level* 參數覆蓋，預設值為 ``\"\"``，"
"它是 ``\"DEFERRED\"`` 的別名。"

#: ../../library/sqlite3.rst:1239
#, fuzzy
msgid ""
"The initial :attr:`~Cursor.row_factory` for :class:`Cursor` objects created "
"from this connection. Assigning to this attribute does not affect the :attr:"
"`!row_factory` of existing cursors belonging to this connection, only new "
"ones. Is ``None`` by default, meaning each row is returned as a :class:"
"`tuple`."
msgstr ""
"從此連接建立的 Cursor 物件的初始 :attr:`~Cursor.row_factory`。"
"分配給此屬性不會影響屬於此連接的現有游標的 :attr:`!row_factory`，只會影響新游"
"標。預設情況下為 ``None`` ，這意味著每一行都作為一個元組回傳。"

#: ../../library/sqlite3.rst:1246 ../../library/sqlite3.rst:1528
#: ../../library/sqlite3.rst:1551
#, fuzzy
msgid "See :ref:`sqlite3-howto-row-factory` for more details."
msgstr "有關更多詳細資訊，請參閱 :ref:`sqlite3-howto-row-factory`。"

#: ../../library/sqlite3.rst:1250
#, fuzzy
msgid ""
"A callable that accepts a :class:`bytes` parameter and returns a text "
"representation of it. The callable is invoked for SQLite values with the "
"``TEXT`` data type. By default, this attribute is set to :class:`str`. If "
"you want to return ``bytes`` instead, set *text_factory* to ``bytes``."
msgstr ""
"一個接受 :class:`bytes` 參數並回傳它的文本表示的可呼叫物件。為具有 ``TEXT``"
"資料型別的 SQLite 值呼叫可呼叫物件。預設情況下，此屬性設定為 :class:`str`。"
"如果你想回傳 ``bytes``，設定 *text_factory* 為 ``bytes``。"

#: ../../library/sqlite3.rst:1290
#, fuzzy
msgid ""
"Return the total number of database rows that have been modified, inserted, "
"or deleted since the database connection was opened."
msgstr "回傳自資料庫連接打開以來已修改、插入或刪除的資料庫行的總數。"

#: ../../library/sqlite3.rst:1297
#, fuzzy
msgid "Cursor objects"
msgstr "光標物件"

#: ../../library/sqlite3.rst:1299
#, fuzzy
msgid ""
"A ``Cursor`` object represents a `database cursor`_ which is used to execute "
"SQL statements, and manage the context of a fetch operation. Cursors are "
"created using :meth:`Connection.cursor`, or by using any of the :ref:"
"`connection shortcut methods <sqlite3-connection-shortcuts>`."
msgstr ""
"一個“游標”物件代表一個“資料庫游標”，用於執行 SQL "
"語句，並管理獲取操作的上下文。游標是使用 :meth:`Connection.cursor` "
"或使用任何連接快捷方式 <sqlite3-connection-shortcuts>` 建立的。"

#: ../../library/sqlite3.rst:1306
#, fuzzy
msgid ""
"Cursor objects are :term:`iterators <iterator>`, meaning that if you :meth:"
"`~Cursor.execute` a ``SELECT`` query, you can simply iterate over the cursor "
"to fetch the resulting rows:"
msgstr ""
"游標對像是 :term:`iterators <iterator>`，這意味著如果您 :meth:`~Cursor."
"execute` 一個 `SELECT`` 查詢，您可以簡單地遍歷游標以獲取結果行："

#: ../../library/sqlite3.rst:1331
#, fuzzy
msgid "A :class:`Cursor` instance has the following attributes and methods."
msgstr ":class:`Cursor` 實例具有以下屬性和方法。"

#: ../../library/sqlite3.rst:1338
#, fuzzy
msgid ""
"Execute SQL a single SQL statement, optionally binding Python values using :"
"ref:`placeholders <sqlite3-placeholders>`."
msgstr ""
"執行 SQL 單個 SQL 語句，可選擇使用 :ref:`placeholders <sqlite3-placeholders>`"
" 綁定 Python 值。"

#: ../../library/sqlite3.rst:1342
#, fuzzy
msgid "A single SQL statement."
msgstr "單個 SQL 語句。"

#: ../../library/sqlite3.rst:1345
#, fuzzy
msgid ""
"Python values to bind to placeholders in *sql*. A :class:`!dict` if named "
"placeholders are used. A :term:`!sequence` if unnamed placeholders are used. "
"See :ref:`sqlite3-placeholders`."
msgstr ""
"綁定到 *sql* 中的佔位符的 Python 值。 A :class:`!dict` 如果使用命名佔位符。 "
"A :term:`!sequence` 如果使用未命名的佔位符。參見 "
":ref:`sqlite3-placeholders`。"

#: ../../library/sqlite3.rst:1352
#, fuzzy
msgid "If *sql* contains more than one SQL statement."
msgstr "如果 *sql* 包含多個 SQL 語句。"

#: ../../library/sqlite3.rst:1355
#, fuzzy
msgid ""
"If :attr:`~Connection.isolation_level` is not ``None``, *sql* is an "
"``INSERT``, ``UPDATE``, ``DELETE``, or ``REPLACE`` statement, and there is "
"no open transaction, a transaction is implicitly opened before executing "
"*sql*."
msgstr ""
"如果 :attr:`~Connection.isolation_level` 不是``None``，*sql* "
"是``INSERT``、``UPDATE``、``DELETE`` 或``REPLACE`` 語句，並且沒有打開的事務，"
"在執行 *sql* 之前隱式打開一個事務。"

#: ../../library/sqlite3.rst:1360
#, fuzzy
msgid "Use :meth:`executescript` to execute multiple SQL statements."
msgstr "使用 :meth:`executescript` 執行多個 SQL 語句。"

#: ../../library/sqlite3.rst:1364
#, fuzzy
msgid ""
"For every item in *parameters*, repeatedly execute the :ref:`parameterized "
"<sqlite3-placeholders>` SQL statement *sql*."
msgstr ""
"對於 *parameters* 中的每一項，重複執行 :ref:`parameterized "
"<sqlite3-placeholders>` SQL 語句 *sql*。"

#: ../../library/sqlite3.rst:1368
#, fuzzy
msgid "Uses the same implicit transaction handling as :meth:`~Cursor.execute`."
msgstr "使用與 :meth:`~Cursor.execute` 相同的隱式事務處理。"

#: ../../library/sqlite3.rst:1370
#, fuzzy
msgid "A single SQL :abbr:`DML (Data Manipulation Language)` statement."
msgstr "單個 SQL :abbr:`DML（資料操作語言）` 語句。"

#: ../../library/sqlite3.rst:1373
#, fuzzy
msgid ""
"An :term:`!iterable` of parameters to bind with the placeholders in *sql*. "
"See :ref:`sqlite3-placeholders`."
msgstr "與 *sql* 中的佔位符綁定的參數的 :term:`!iterable`。參見 "
":ref:`sqlite3-placeholders`。"

#: ../../library/sqlite3.rst:1379
#, fuzzy
msgid ""
"If *sql* contains more than one SQL statement, or is not a DML statment."
msgstr "如果 *sql* 包含多個 SQL 語句，或者不是 DML 語句。"

#: ../../library/sqlite3.rst:1396
#, fuzzy
msgid ""
"Execute the SQL statements in *sql_script*. If there is a pending "
"transaction, an implicit ``COMMIT`` statement is executed first. No other "
"implicit transaction control is performed; any transaction control must be "
"added to *sql_script*."
msgstr ""
"執行 *sql_script* 中的 SQL 語句。如果有待處理的事務，則首先執行隱式的 ``COMMIT``"
"語句。不執行其他隱式事務控制；任何事務控制都必須新增到 *sql_script*。"

#: ../../library/sqlite3.rst:1402
#, fuzzy
msgid "*sql_script* must be a :class:`string <str>`."
msgstr "*sql_script* 必須是一個 :class:`string <str>`。"

#: ../../library/sqlite3.rst:1420
#, fuzzy
msgid ""
"If :attr:`~Cursor.row_factory` is ``None``, return the next row query result "
"set as a :class:`tuple`. Else, pass it to the row factory and return its "
"result. Return ``None`` if no more data is available."
msgstr ""
"如果 :attr:`~Cursor.row_factory` 為``None``，回傳下一行查詢結果集為 :class:`tup"
"le`。否則，將其傳遞給行工廠並回傳其結果。如果沒有更多資料可用，則回傳 ``None``。"

#: ../../library/sqlite3.rst:1428
#, fuzzy
msgid ""
"Return the next set of rows of a query result as a :class:`list`. Return an "
"empty list if no more rows are available."
msgstr "將查詢結果的下一組行作為 :class:`list` "
"回傳。如果沒有更多行可用，則回傳一個空列表。"

#: ../../library/sqlite3.rst:1431
#, fuzzy
msgid ""
"The number of rows to fetch per call is specified by the *size* parameter. "
"If *size* is not given, :attr:`arraysize` determines the number of rows to "
"be fetched. If fewer than *size* rows are available, as many rows as are "
"available are returned."
msgstr ""
"每次呼叫要獲取的行數由 *size* 參數指定。如果未給出 *size*，則 "
":attr:`arraysize` 確定要獲取的行數。如果可用的行少於 *size* "
"行，則回傳盡可能多的可用行。"

#: ../../library/sqlite3.rst:1437
#, fuzzy
msgid ""
"Note there are performance considerations involved with the *size* "
"parameter. For optimal performance, it is usually best to use the arraysize "
"attribute. If the *size* parameter is used, then it is best for it to retain "
"the same value from one :meth:`fetchmany` call to the next."
msgstr ""
"請注意，*size* 參數涉及性能方面的考慮。為了獲得最佳性能，通常最好使用 "
"arraysize 屬性。如果使用 *size* 參數，那麼它最好保留與下一次 fetchmany "
"呼叫相同的值。"

#: ../../library/sqlite3.rst:1444
#, fuzzy
msgid ""
"Return all (remaining) rows of a query result as a :class:`list`. Return an "
"empty list if no rows are available. Note that the :attr:`arraysize` "
"attribute can affect the performance of this operation."
msgstr ""
"將查詢結果的所有（剩餘）行作為 list "
"回傳。如果沒有行可用，則回傳一個空列表。請注意 :attr:`arraysize` "
"屬性會影響此操作的性能。"

#: ../../library/sqlite3.rst:1451
#, fuzzy
msgid "Close the cursor now (rather than whenever ``__del__`` is called)."
msgstr "現在關閉游標（而不是每次呼叫 __del__ 時）。"

#: ../../library/sqlite3.rst:1453
#, fuzzy
msgid ""
"The cursor will be unusable from this point forward; a :exc:"
"`ProgrammingError` exception will be raised if any operation is attempted "
"with the cursor."
msgstr "從此時起，光標將無法使用；如果嘗試使用游標進行任何操作，將引發 "
":exc:`ProgrammingError` 例外。"

#: ../../library/sqlite3.rst:1458 ../../library/sqlite3.rst:1462
#, fuzzy
msgid "Required by the DB-API. Does nothing in :mod:`!sqlite3`."
msgstr "DB-API 需要。在 :mod:`!sqlite3` 中什麼都不做。"

#: ../../library/sqlite3.rst:1466
#, fuzzy
msgid ""
"Read/write attribute that controls the number of rows returned by :meth:"
"`fetchmany`. The default value is 1 which means a single row would be "
"fetched per call."
msgstr "控制 fetchmany 回傳的行數的讀/寫屬性。預設值為 "
"1，這意味著每次呼叫將獲取一行。"

#: ../../library/sqlite3.rst:1471
#, fuzzy
msgid ""
"Read-only attribute that provides the SQLite database :class:`Connection` "
"belonging to the cursor.  A :class:`Cursor` object created by calling :meth:"
"`con.cursor() <Connection.cursor>` will have a :attr:`connection` attribute "
"that refers to *con*:"
msgstr ""
"提供屬於游標的 SQLite 資料庫的只讀屬性 :class:`Connection`。通過呼叫 "
":meth:`con.cursor() <Connection.cursor>` 建立的 :class:`Cursor` "
"物件將具有引用 *con* 的 :attr:`connection` 屬性："

#: ../../library/sqlite3.rst:1485
#, fuzzy
msgid ""
"Read-only attribute that provides the column names of the last query. To "
"remain compatible with the Python DB API, it returns a 7-tuple for each "
"column where the last six items of each tuple are ``None``."
msgstr "提供上次查詢的列名的只讀屬性。為了與 Python DB API 保持相容，"
"它為每一列回傳一個 7 元組，其中每個元組的最後六項為 ``None`` 。"

#: ../../library/sqlite3.rst:1489
#, fuzzy
msgid "It is set for ``SELECT`` statements without any matching rows as well."
msgstr "它也為沒有任何匹配行的 ``SELECT`` 語句設定。"

#: ../../library/sqlite3.rst:1493
#, fuzzy
msgid ""
"Read-only attribute that provides the row id of the last inserted row. It is "
"only updated after successful ``INSERT`` or ``REPLACE`` statements using "
"the :meth:`execute` method.  For other statements, after :meth:`executemany` "
"or :meth:`executescript`, or if the insertion failed, the value of "
"``lastrowid`` is left unchanged.  The initial value of ``lastrowid`` is "
"``None``."
msgstr ""
"提供最後插入行的行 ID 的只讀屬性。它僅在成功使用 :meth:`execute` 方法的 "
"``INSERT`` 或 ``REPLACE`` 語句後更新。對於其他語句，在 :meth:`executemany` "
"或 :meth:`executescript` 之後，或者如果插入失敗，則 ``lastrowid`` "
"的值保持不變。 ``lastrowid`` 的初始值為``None``。"

#: ../../library/sqlite3.rst:1501
#, fuzzy
msgid "Inserts into ``WITHOUT ROWID`` tables are not recorded."
msgstr "插入 ``WITHOUT ROWID`` 表不被記錄。"

#: ../../library/sqlite3.rst:1503
msgid "Added support for the ``REPLACE`` statement."
msgstr "新增 ``REPLACE`` 陳述式的支援。"

#: ../../library/sqlite3.rst:1508
#, fuzzy
msgid ""
"Read-only attribute that provides the number of modified rows for "
"``INSERT``, ``UPDATE``, ``DELETE``, and ``REPLACE`` statements; is ``-1`` "
"for other statements, including :abbr:`CTE (Common Table Expression)` "
"queries. It is only updated by the :meth:`execute` and :meth:`executemany` "
"methods."
msgstr ""
"為 ``INSERT``、 ``UPDATE``、 ``DELETE``和 ``REPLACE`` 語句提供修改行數的只讀屬性；對於其他"
"語句是 ``-1``，包括 :abbr:`CTE（通用表表達式）`查詢。它僅由 :meth:`execute` 和 "
":meth:`executemany` 方法更新。"

#: ../../library/sqlite3.rst:1516
#, fuzzy
msgid ""
"Control how a row fetched from this :class:`!Cursor` is represented. If "
"``None``, a row is represented as a :class:`tuple`. Can be set to the "
"included :class:`sqlite3.Row`; or a :term:`callable` that accepts two "
"arguments, a :class:`Cursor` object and the :class:`!tuple` of row values, "
"and returns a custom object representing an SQLite row."
msgstr ""
"控制如何表示從此 :class:`!Cursor` 獲取的行。如果 ``None`` ，一行表示為一個元組。"
"可以設定為包含的 :class:`sqlite3.Row`;或接受兩個參數的 :term:`callable`，"
"一個 :class:`Cursor` 物件和 :class:`!tuple` 行值，並回傳一個表示 SQLite "
"行的自定義物件。"

#: ../../library/sqlite3.rst:1523
#, fuzzy
msgid ""
"Defaults to what :attr:`Connection.row_factory` was set to when the :class:`!"
"Cursor` was created. Assigning to this attribute does not affect :attr:"
"`Connection.row_factory` of the parent connection."
msgstr ""
"預設為 :attr:`Connection.row_factory` 在建立 :class:`!Cursor` 時設定的值。"
"分配給此屬性不會影響父連接的 :attr:`Connection.row_factory`。"

#: ../../library/sqlite3.rst:1539
#, fuzzy
msgid "Row objects"
msgstr "行物件"

#: ../../library/sqlite3.rst:1543
#, fuzzy
msgid ""
"A :class:`!Row` instance serves as a highly optimized :attr:`~Connection."
"row_factory` for :class:`Connection` objects. It supports iteration, "
"equality testing, :func:`len`, and :term:`mapping` access by column name and "
"index."
msgstr ""
":class:`!Row` 實例用作 :class:`Connection` 物件的高度最佳化的 "
":attr:`~Connection.row_factory`。它支援疊代、相等性測試、:func:`len` "
"和 :term:`mapping` 按列名和索引訪問。"

#: ../../library/sqlite3.rst:1548
#, fuzzy
msgid ""
"Two :class:`!Row` objects compare equal if they have identical column names "
"and values."
msgstr "如果兩個 :class:`!Row` 物件具有相同的列名和值，則它們比較相等。"

#: ../../library/sqlite3.rst:1555
#, fuzzy
msgid ""
"Return a :class:`list` of column names as :class:`strings <str>`. "
"Immediately after a query, it is the first member of each tuple in :attr:"
"`Cursor.description`."
msgstr ""
"回傳列名的 :class:`list` 作為 :class:`strings <str>`。在查詢之後，它是 "
":attr:`Cursor.description` 中每個元組的第一個成員。"

#: ../../library/sqlite3.rst:1559
#, fuzzy
msgid "Added support of slicing."
msgstr "新增了對切片的支援。"

#: ../../library/sqlite3.rst:1566
#, fuzzy
msgid "Blob objects"
msgstr "斑點物件"

#: ../../library/sqlite3.rst:1572
#, fuzzy
msgid ""
"A :class:`Blob` instance is a :term:`file-like object` that can read and "
"write data in an SQLite :abbr:`BLOB (Binary Large OBject)`. Call :func:"
"`len(blob) <len>` to get the size (number of bytes) of the blob. Use indices "
"and :term:`slices <slice>` for direct access to the blob data."
msgstr ""
":class:`Blob` 實例是一個類似文件的物件，可以在 SQLite :abbr:`BLOB (Binary "
"Large OBject)` 中讀取和寫入資料。呼叫 :func:`len(blob) <len>` 獲取 blob "
"的大小（位元組數）。使用索引和 :term:`slices <slice>` 來直接訪問 blob 資料。"

#: ../../library/sqlite3.rst:1577
#, fuzzy
msgid ""
"Use the :class:`Blob` as a :term:`context manager` to ensure that the blob "
"handle is closed after use."
msgstr "使用 :class:`Blob` 作為 :term:`context manager` 以確保 blob "
"句柄在使用後關閉。"

#: ../../library/sqlite3.rst:1607
#, fuzzy
msgid "Close the blob."
msgstr "關閉 blob。"

#: ../../library/sqlite3.rst:1609
#, fuzzy
msgid ""
"The blob will be unusable from this point onward.  An :class:`~sqlite3."
"Error` (or subclass) exception will be raised if any further operation is "
"attempted with the blob."
msgstr ""
"從此時起，blob 將無法使用。如果嘗試對 blob 進行任何進一步操作，將引發 "
":class:`~sqlite3.Error`（或子類別）例外。"

#: ../../library/sqlite3.rst:1615
#, fuzzy
msgid ""
"Read *length* bytes of data from the blob at the current offset position. If "
"the end of the blob is reached, the data up to :abbr:`EOF (End of File)` "
"will be returned.  When *length* is not specified, or is negative, :meth:"
"`~Blob.read` will read until the end of the blob."
msgstr ""
"從當前偏移位置的 blob 中讀取 *length* 位元組的資料。如果到達 blob 的末尾，"
"將回傳直到 :abbr:`EOF（文件末尾）` 的資料。當 *length* "
"未指定或為負數時，:meth:`~Blob.read` 將讀取到 blob 的末尾。"

#: ../../library/sqlite3.rst:1623
#, fuzzy
msgid ""
"Write *data* to the blob at the current offset.  This function cannot change "
"the blob length.  Writing beyond the end of the blob will raise :exc:"
"`ValueError`."
msgstr ""
"將 *data* 寫入當前偏移量的 blob。此函式不能更改 blob 長度。超出 blob "
"末尾的寫入將引發 :exc:`ValueError`。"

#: ../../library/sqlite3.rst:1629
#, fuzzy
msgid "Return the current access position of the blob."
msgstr "回傳 blob 的當前訪問位置。"

#: ../../library/sqlite3.rst:1633
#, fuzzy
msgid ""
"Set the current access position of the blob to *offset*.  The *origin* "
"argument defaults to :data:`os.SEEK_SET` (absolute blob positioning). Other "
"values for *origin* are :data:`os.SEEK_CUR` (seek relative to the current "
"position) and :data:`os.SEEK_END` (seek relative to the blob’s end)."
msgstr ""
"將 blob 的當前訪問位置設定為 *offset*。 *origin* 參數預設為 :data:`os."
"SEEK_SET`（絕對 blob 定位）。 *origin* 的其他值是 :data:`os."
"SEEK_CUR`（相對於當前位置查找）和 :data:`os.SEEK_END`（相對於 blob "
"的末尾查找）。"

#: ../../library/sqlite3.rst:1641
#, fuzzy
msgid "PrepareProtocol objects"
msgstr "PrepareProtocol 物件"

#: ../../library/sqlite3.rst:1645
#, fuzzy
msgid ""
"The PrepareProtocol type's single purpose is to act as a :pep:`246` style "
"adaption protocol for objects that can :ref:`adapt themselves <sqlite3-"
"conform>` to :ref:`native SQLite types <sqlite3-types>`."
msgstr ""
"PrepareProtocol 型別的唯一目的是充當物件的 :pep:`246` 樣式適配協定，"
"這些物件可以 :ref:`adapt themselves <sqlite3-conform>` 到 :ref:`native "
"SQLite types <sqlite3-types>`。"

#: ../../library/sqlite3.rst:1653
msgid "Exceptions"
msgstr "例外"

#: ../../library/sqlite3.rst:1655
#, fuzzy
msgid "The exception hierarchy is defined by the DB-API 2.0 (:pep:`249`)."
msgstr "例外層次結構由 DB-API 2.0 (:pep:`249`) 定義。"

#: ../../library/sqlite3.rst:1659
#, fuzzy
msgid ""
"This exception is not currently raised by the :mod:`!sqlite3` module, but "
"may be raised by applications using :mod:`!sqlite3`, for example if a user-"
"defined function truncates data while inserting. ``Warning`` is a subclass "
"of :exc:`Exception`."
msgstr ""
"此例外當前未由 :mod:`!sqlite3` 模組引發，但可能由使用 :mod:`!sqlite3` "
"的應用程式引發，例如，如果使用者定義的函式在插入時截斷資料。 ``Warning`` 是 "
":exc:`Exception` 的子類別。"

#: ../../library/sqlite3.rst:1666
#, fuzzy
msgid ""
"The base class of the other exceptions in this module. Use this to catch all "
"errors with one single :keyword:`except` statement. ``Error`` is a subclass "
"of :exc:`Exception`."
msgstr ""
"該模組中其他例外的基底類別。使用它通過一個 :keyword:`except` "
"語句捕獲所有錯誤。 ``Error`` 是 :exc:`Exception` 的子類別。"

#: ../../library/sqlite3.rst:1670
#, fuzzy
msgid ""
"If the exception originated from within the SQLite library, the following "
"two attributes are added to the exception:"
msgstr "如果例外源自 SQLite 庫，則將以下兩個屬性新增到例外中："

#: ../../library/sqlite3.rst:1675
#, fuzzy
msgid ""
"The numeric error code from the `SQLite API <https://sqlite.org/rescode."
"html>`_"
msgstr "來自 `SQLite API <https://sqlite.org/rescode.html>`_ 的數字錯誤程式碼"

#: ../../library/sqlite3.rst:1682
#, fuzzy
msgid ""
"The symbolic name of the numeric error code from the `SQLite API <https://"
"sqlite.org/rescode.html>`_"
msgstr "來自 `SQLite API <https://sqlite.org/rescode.html>`_ "
"的數字錯誤程式碼的符號名稱"

#: ../../library/sqlite3.rst:1689
#, fuzzy
msgid ""
"Exception raised for misuse of the low-level SQLite C API. In other words, "
"if this exception is raised, it probably indicates a bug in the :mod:`!"
"sqlite3` module. ``InterfaceError`` is a subclass of :exc:`Error`."
msgstr ""
"因濫用低階 SQLite C API 而引發的例外。換句話說，如果引發此例外，則可能表示 "
":mod:`!sqlite3` 模組中存在錯誤。 ``InterfaceError`` 是 :exc:`Error` "
"的子類別。"

#: ../../library/sqlite3.rst:1696
#, fuzzy
msgid ""
"Exception raised for errors that are related to the database. This serves as "
"the base exception for several types of database errors. It is only raised "
"implicitly through the specialised subclasses. ``DatabaseError`` is a "
"subclass of :exc:`Error`."
msgstr ""
"為與資料庫相關的錯誤引發的例外。這用作幾種型別的資料庫錯誤的基本例外。它僅通"
"過專門的子類別隱式引發。 ``DatabaseError`` 是 :exc:`Error` 的子類別。"

#: ../../library/sqlite3.rst:1703
#, fuzzy
msgid ""
"Exception raised for errors caused by problems with the processed data, like "
"numeric values out of range, and strings which are too long. ``DataError`` "
"is a subclass of :exc:`DatabaseError`."
msgstr ""
"因處理資料問題引起的錯誤引發例外，例如超出範圍的數值和太長的字串。 "
"``DataError`` 是 :exc:`DatabaseError` 的子類別。"

#: ../../library/sqlite3.rst:1709
#, fuzzy
msgid ""
"Exception raised for errors that are related to the database's operation, "
"and not necessarily under the control of the programmer. For example, the "
"database path is not found, or a transaction could not be processed. "
"``OperationalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"為與資料庫操作相關的錯誤引發的例外，不一定在程式員的控制下。例如，找不到資料"
"庫路徑，或者無法處理事務。 ``OperationalError`` 是 :exc:`DatabaseError` "
"的子類別。"

#: ../../library/sqlite3.rst:1717
#, fuzzy
msgid ""
"Exception raised when the relational integrity of the database is affected, "
"e.g. a foreign key check fails.  It is a subclass of :exc:`DatabaseError`."
msgstr "當資料庫的關係完整性受到影響時引發例外，例如外鍵檢查失敗。它是 "
":exc:`DatabaseError` 的子類別。"

#: ../../library/sqlite3.rst:1722
#, fuzzy
msgid ""
"Exception raised when SQLite encounters an internal error. If this is "
"raised, it may indicate that there is a problem with the runtime SQLite "
"library. ``InternalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"SQLite 遇到內部錯誤時引發例外。如果出現此問題，則可能表明運行時 SQLite "
"庫存在問題。 ``InternalError`` 是 :exc:`DatabaseError` 的子類別。"

#: ../../library/sqlite3.rst:1729
#, fuzzy
msgid ""
"Exception raised for :mod:`!sqlite3` API programming errors, for example "
"supplying the wrong number of bindings to a query, or trying to operate on a "
"closed :class:`Connection`. ``ProgrammingError`` is a subclass of :exc:"
"`DatabaseError`."
msgstr ""
"為 :mod:`!sqlite3` API 編程錯誤引發的例外，例如為查詢提供錯誤數量的綁定，"
"或試圖在關閉的 :class:`Connection` 上操作。 ``ProgrammingError`` 是 "
":exc:`DatabaseError` 的子類別。"

#: ../../library/sqlite3.rst:1736
#, fuzzy
msgid ""
"Exception raised in case a method or database API is not supported by the "
"underlying SQLite library. For example, setting *deterministic* to ``True`` "
"in :meth:`~Connection.create_function`, if the underlying SQLite library "
"does not support deterministic functions. ``NotSupportedError`` is a "
"subclass of :exc:`DatabaseError`."
msgstr ""
"如果底層 SQLite 庫不支援方法或資料庫 API，則會引發例外。例如，如果底層 "
"SQLite 庫不支援確定性函式，則在 :meth:`~Connection.create_function` 中將 "
"*deterministic* 設定為 ``True``。 ``NotSupportedError`` 是 "
":exc:`DatabaseError` 的子類別。"

#: ../../library/sqlite3.rst:1746
#, fuzzy
msgid "SQLite and Python types"
msgstr "SQLite 和 Python 型別"

#: ../../library/sqlite3.rst:1748
#, fuzzy
msgid ""
"SQLite natively supports the following types: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``."
msgstr "SQLite "
"原生支援以下型別：``NULL``、``INTEGER``、``REAL``、``TEXT``、``BLOB``。"

#: ../../library/sqlite3.rst:1751
#, fuzzy
msgid ""
"The following Python types can thus be sent to SQLite without any problem:"
msgstr "因此，以下 Python 型別可以毫無問題地發送到 SQLite："

#: ../../library/sqlite3.rst:1754 ../../library/sqlite3.rst:1771
#, fuzzy
msgid "Python type"
msgstr "蟒蛇型別"

#: ../../library/sqlite3.rst:1754 ../../library/sqlite3.rst:1771
#, fuzzy
msgid "SQLite type"
msgstr "SQLite型別"

#: ../../library/sqlite3.rst:1756 ../../library/sqlite3.rst:1773
msgid "``None``"
msgstr "``None``"

#: ../../library/sqlite3.rst:1756 ../../library/sqlite3.rst:1773
msgid "``NULL``"
msgstr "``NULL``"

#: ../../library/sqlite3.rst:1758 ../../library/sqlite3.rst:1775
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../library/sqlite3.rst:1758 ../../library/sqlite3.rst:1775
msgid "``INTEGER``"
msgstr "``INTEGER``"

#: ../../library/sqlite3.rst:1760 ../../library/sqlite3.rst:1777
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../library/sqlite3.rst:1760 ../../library/sqlite3.rst:1777
msgid "``REAL``"
msgstr "``REAL``"

#: ../../library/sqlite3.rst:1762
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../library/sqlite3.rst:1762 ../../library/sqlite3.rst:1779
msgid "``TEXT``"
msgstr "``TEXT``"

#: ../../library/sqlite3.rst:1764 ../../library/sqlite3.rst:1782
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../library/sqlite3.rst:1764 ../../library/sqlite3.rst:1782
msgid "``BLOB``"
msgstr "``BLOB``"

#: ../../library/sqlite3.rst:1768
#, fuzzy
msgid "This is how SQLite types are converted to Python types by default:"
msgstr "預設情況下，SQLite 型別是如何轉換為 Python 型別的："

#: ../../library/sqlite3.rst:1779
#, fuzzy
msgid "depends on :attr:`~Connection.text_factory`, :class:`str` by default"
msgstr "預設依賴於 :attr:`~Connection.text_factory`, :class:`str`"

#: ../../library/sqlite3.rst:1785
#, fuzzy
msgid ""
"The type system of the :mod:`!sqlite3` module is extensible in two ways: you "
"can store additional Python types in an SQLite database via :ref:`object "
"adapters <sqlite3-adapters>`, and you can let the :mod:`!sqlite3` module "
"convert SQLite types to Python types via :ref:`converters <sqlite3-"
"converters>`."
msgstr ""
":mod:`!sqlite3` 模組的型別系統可以通過兩種方式擴充：您可以通過 :ref:`object "
"adapters <sqlite3-adapters>` 在 SQLite 資料庫中儲存額外的 Python 型別，"
"並且您可以讓 :mod :`!sqlite3` 模組通過 :ref:`converters <sqlite3-converters>`"
" 將 SQLite 型別轉換為 Python 型別。"

#: ../../library/sqlite3.rst:1795
#, fuzzy
msgid "Default adapters and converters"
msgstr "預設適配器和轉換器"

#: ../../library/sqlite3.rst:1797
#, fuzzy
msgid ""
"There are default adapters for the date and datetime types in the datetime "
"module. They will be sent as ISO dates/ISO timestamps to SQLite."
msgstr "datetime 模組中有 date 和 datetime 型別的預設適配器。它們將作為 ISO 日期/ISO "
"時間戳發送到 SQLite。"

#: ../../library/sqlite3.rst:1800
#, fuzzy
msgid ""
"The default converters are registered under the name \"date\" for :class:"
"`datetime.date` and under the name \"timestamp\" for :class:`datetime."
"datetime`."
msgstr "預設轉換器在 datetime.date 的名稱 ``date``和 datetime.datetime "
"的名稱 ``timestamp`` 下註冊。"

#: ../../library/sqlite3.rst:1804
#, fuzzy
msgid ""
"This way, you can use date/timestamps from Python without any additional "
"fiddling in most cases. The format of the adapters is also compatible with "
"the experimental SQLite date/time functions."
msgstr ""
"這樣，在大多數情況下，您可以使用 Python 中的日期/時間戳，而無需任何額外操作。"
"適配器的格式也與實驗性 SQLite 日期/時間函式相容。"

#: ../../library/sqlite3.rst:1808
#, fuzzy
msgid "The following example demonstrates this."
msgstr "以下示例演示了這一點。"

#: ../../library/sqlite3.rst:1812
#, fuzzy
msgid ""
"If a timestamp stored in SQLite has a fractional part longer than 6 numbers, "
"its value will be truncated to microsecond precision by the timestamp "
"converter."
msgstr "如果儲存在 SQLite 中的時間戳的小數部分超過 6 "
"個數字，則其值將被時間戳轉換器截斷為微秒精度。"

#: ../../library/sqlite3.rst:1818
#, fuzzy
msgid ""
"The default \"timestamp\" converter ignores UTC offsets in the database and "
"always returns a naive :class:`datetime.datetime` object. To preserve UTC "
"offsets in timestamps, either leave converters disabled, or register an "
"offset-aware converter with :func:`register_converter`."
msgstr ""
"預設的“時間戳”轉換器忽略資料庫中的 UTC 偏移量，並始終回傳一個原始的 "
"datetime.datetime 物件。要在時間戳中保留 UTC 偏移量，請禁用轉換器，或使用 "
":func:`register_converter` 註冊一個偏移量感知轉換器。"

#: ../../library/sqlite3.rst:1827
#, fuzzy
msgid "How-to guides"
msgstr "操作指南"

#: ../../library/sqlite3.rst:1832
#, fuzzy
msgid "How to use placeholders to bind values in SQL queries"
msgstr "如何使用佔位符綁定 SQL 查詢中的值"

#: ../../library/sqlite3.rst:1834
#, fuzzy
msgid ""
"SQL operations usually need to use values from Python variables. However, "
"beware of using Python's string operations to assemble queries, as they are "
"vulnerable to `SQL injection attacks`_. For example, an attacker can simply "
"close the single quote and inject ``OR TRUE`` to select all rows::"
msgstr ""
"SQL 操作通常需要使用來自 Python 變數的值。但是，請注意使用 Python "
"的字串操作來組合查詢，因為它們容易受到“SQL 注入攻擊”。例如，"
"攻擊者可以簡單地關閉單引號並註入 ``OR TRUE`` 來選擇所有行::"

#: ../../library/sqlite3.rst:1847
#, fuzzy
msgid ""
"Instead, use the DB-API's parameter substitution. To insert a variable into "
"a query string, use a placeholder in the string, and substitute the actual "
"values into the query by providing them as a :class:`tuple` of values to the "
"second argument of the cursor's :meth:`~Cursor.execute` method."
msgstr ""
"相反，使用 DB-API 的參數替換。要將變數插入查詢字串，請在字串中使用佔位符，並"
"將實際值替換為查詢，方法是將它們作為值的 :class:`tuple` 提供給游標的 :meth:`~"
"Cursor 的第二個參數.execute` 方法。"

#: ../../library/sqlite3.rst:1852
#, fuzzy
msgid ""
"An SQL statement may use one of two kinds of placeholders: question marks "
"(qmark style) or named placeholders (named style). For the qmark style, "
"*parameters* must be a :term:`sequence` whose length must match the number "
"of placeholders, or a :exc:`ProgrammingError` is raised. For the named "
"style, *parameters* should be an instance of a :class:`dict` (or a "
"subclass), which must contain keys for all named parameters; any extra items "
"are ignored. Here's an example of both styles:"
msgstr ""
"SQL 語句可以使用兩種佔位符之一：問號（qmark 樣式）或命名佔位符（命名樣式）。"
"對於 qmark 樣式，*parameters* "
"必須是一個序列，其長度必須與占位符的數量相匹配，否則將引發一個 "
"ProgrammingError。對於命名樣式，*parameters* 應該是 :class:`dict`（或子類別）"
"的實例，它必須包含所有命名參數的鍵；任何額外的項目都將被忽略。這是兩種樣式的"
"示例："

#: ../../library/sqlite3.rst:1889
#, fuzzy
msgid ""
":pep:`249` numeric placeholders are *not* supported. If used, they will be "
"interpreted as named placeholders."
msgstr ":pep:`249` 數字佔位符 *不* 支援。如果使用，它們將被解釋為命名佔位符。"

#: ../../library/sqlite3.rst:1896
#, fuzzy
msgid "How to adapt custom Python types to SQLite values"
msgstr "如何使自定義 Python 型別適應 SQLite 值"

#: ../../library/sqlite3.rst:1898
#, fuzzy
msgid ""
"SQLite supports only a limited set of data types natively. To store custom "
"Python types in SQLite databases, *adapt* them to one of the :ref:`Python "
"types SQLite natively understands <sqlite3-types>`."
msgstr ""
"SQLite 本身只支援一組有限的資料型別。要將自定義 Python 型別儲存在 SQLite "
"資料庫中，*將它們*適配*為 :ref:`SQLite 原生理解的 Python 型別之一 "
"<sqlite3-types>`。"

#: ../../library/sqlite3.rst:1902
#, fuzzy
msgid ""
"There are two ways to adapt Python objects to SQLite types: letting your "
"object adapt itself, or using an *adapter callable*. The latter will take "
"precedence above the former. For a library that exports a custom type, it "
"may make sense to enable that type to adapt itself. As an application "
"developer, it may make more sense to take direct control by registering "
"custom adapter functions."
msgstr ""
"有兩種方法可以使 Python 物件適應 SQLite 型別：讓您的物件自行適應，或使用 *"
"adapter callable*。後者將優先於前者。對於導出自定義型別的庫，啟用該型別以適應"
"自身可能是有意義的。作為應用程式開發人員，通過註冊自定義適配器函式來直接控制"
"可能更有意義。"

#: ../../library/sqlite3.rst:1914
#, fuzzy
msgid "How to write adaptable objects"
msgstr "如何編寫自適應物件"

#: ../../library/sqlite3.rst:1916
#, fuzzy
msgid ""
"Suppose we have a :class:`!Point` class that represents a pair of "
"coordinates, ``x`` and ``y``, in a Cartesian coordinate system. The "
"coordinate pair will be stored as a text string in the database, using a "
"semicolon to separate the coordinates. This can be implemented by adding a "
"``__conform__(self, protocol)`` method which returns the adapted value. The "
"object passed to *protocol* will be of type :class:`PrepareProtocol`."
msgstr ""
"假設我們有一個 :class:`!Point` 類表示笛卡爾坐標系中的一對坐標，``x`` 和 ``y``"
"。坐標對將作為文本字串儲存在資料庫中，使用分號分隔坐標。這可以通過新增一個回"
"傳適應值的``__conform__(self, protocol)`` 方法來實作。傳遞給 *protocol* "
"的物件將是 :class:`PrepareProtocol` 型別。"

#: ../../library/sqlite3.rst:1947
#, fuzzy
msgid "How to register adapter callables"
msgstr "如何註冊適配器可呼叫物件"

#: ../../library/sqlite3.rst:1949
#, fuzzy
msgid ""
"The other possibility is to create a function that converts the Python "
"object to an SQLite-compatible type. This function can then be registered "
"using :func:`register_adapter`."
msgstr ""
"另一種可能性是建立一個將 Python 物件轉換為 SQLite 相容型別的函式。"
"然後可以使用 :func:`register_adapter` 註冊這個函式。"

#: ../../library/sqlite3.rst:1979
#, fuzzy
msgid "How to convert SQLite values to custom Python types"
msgstr "如何將 SQLite 值轉換為自定義 Python 型別"

#: ../../library/sqlite3.rst:1981
#, fuzzy
msgid ""
"Writing an adapter lets you convert *from* custom Python types *to* SQLite "
"values. To be able to convert *from* SQLite values *to* custom Python types, "
"we use *converters*."
msgstr ""
"編寫適配器可讓您將*從*自定義 Python 型別*轉換為* SQLite 值。為了能夠將 *從* "
"SQLite 值轉換為 * 自定義 Python 型別，我們使用 *converters*。"

#: ../../library/sqlite3.rst:1986
#, fuzzy
msgid ""
"Let's go back to the :class:`!Point` class. We stored the x and y "
"coordinates separated via semicolons as strings in SQLite."
msgstr "讓我們回到 :class:`!Point` 類。我們將通過分號分隔的 x 和 y 坐標儲存為 SQLite "
"中的字串。"

#: ../../library/sqlite3.rst:1989
#, fuzzy
msgid ""
"First, we'll define a converter function that accepts the string as a "
"parameter and constructs a :class:`!Point` object from it."
msgstr "首先，我們將定義一個轉換器函式，它接受字串作為參數並從中構造一個 "
":class:`!Point` 物件。"

#: ../../library/sqlite3.rst:1994
#, fuzzy
msgid ""
"Converter functions are **always** passed a :class:`bytes` object, no matter "
"the underlying SQLite data type."
msgstr "轉換器函式**總是**傳遞一個 :class:`bytes` 物件，無論底層 SQLite "
"資料型別如何。"

#: ../../library/sqlite3.rst:2003
#, fuzzy
msgid ""
"We now need to tell :mod:`!sqlite3` when it should convert a given SQLite "
"value. This is done when connecting to a database, using the *detect_types* "
"parameter of :func:`connect`. There are three options:"
msgstr ""
"我們現在需要告訴 :mod:`!sqlite3` 什麼時候應該轉換給定的 SQLite 值。"
"這是在連接到資料庫時使用 :func:`connect` 的 *detect_types* "
"參數完成的。共有三個選項："

#: ../../library/sqlite3.rst:2007
#, fuzzy
msgid "Implicit: set *detect_types* to :const:`PARSE_DECLTYPES`"
msgstr "隱式：將 *detect_types* 設定為 :const:`PARSE_DECLTYPES`"

#: ../../library/sqlite3.rst:2008
#, fuzzy
msgid "Explicit: set *detect_types* to :const:`PARSE_COLNAMES`"
msgstr "顯式：將 *detect_types* 設定為 :const:`PARSE_COLNAMES`"

#: ../../library/sqlite3.rst:2009
#, fuzzy
msgid ""
"Both: set *detect_types* to ``sqlite3.PARSE_DECLTYPES | sqlite3."
"PARSE_COLNAMES``. Column names take precedence over declared types."
msgstr ""
"兩者：將 *detect_types* 設定為 ``sqlite3.PARSE_DECLTYPES | sqlite3."
"PARSE_COLNAMES``。列名優先於聲明的型別。"

#: ../../library/sqlite3.rst:2013
#, fuzzy
msgid "The following example illustrates the implicit and explicit approaches:"
msgstr "以下示例說明了隱式和顯式方法："

#: ../../library/sqlite3.rst:2064
#, fuzzy
msgid "Adapter and converter recipes"
msgstr "適配器和轉換器配方"

#: ../../library/sqlite3.rst:2066
#, fuzzy
msgid "This section shows recipes for common adapters and converters."
msgstr "本節顯示常見適配器和轉換器的配方。"

#: ../../library/sqlite3.rst:2128
#, fuzzy
msgid "How to use connection shortcut methods"
msgstr "如何使用連接快捷方式"

#: ../../library/sqlite3.rst:2130
#, fuzzy
msgid ""
"Using the :meth:`~Connection.execute`, :meth:`~Connection.executemany`, and :"
"meth:`~Connection.executescript` methods of the :class:`Connection` class, "
"your code can be written more concisely because you don't have to create the "
"(often superfluous) :class:`Cursor` objects explicitly. Instead, the :class:"
"`Cursor` objects are created implicitly and these shortcut methods return "
"the cursor objects. This way, you can execute a ``SELECT`` statement and "
"iterate over it directly using only a single call on the :class:`Connection` "
"object."
msgstr ""
"使用 Connection 類的 :meth:`~Connection.execute`, :meth:`~Connection."
"executemany` 和 :meth:`~Connection.executescript` 方法，你的程式碼可以寫得更"
"簡潔因為您不必顯式建立（通常是多餘的） :class:`Cursor` "
"物件。相反，:class:`Cursor` "
"對像是隱式建立的，這些快捷方法回傳光標物件。這樣，您可以執行 ``SELECT`` "
"語句並直接使用對 :class:`Connection` 物件的一次呼叫直接疊代它。"

#: ../../library/sqlite3.rst:2171
#, fuzzy
msgid "How to use the connection context manager"
msgstr "如何使用連接上下文管理器"

#: ../../library/sqlite3.rst:2173
#, fuzzy
msgid ""
"A :class:`Connection` object can be used as a context manager that "
"automatically commits or rolls back open transactions when leaving the body "
"of the context manager. If the body of the :keyword:`with` statement "
"finishes without exceptions, the transaction is committed. If this commit "
"fails, or if the body of the ``with`` statement raises an uncaught "
"exception, the transaction is rolled back."
msgstr ""
":class:`Connection` "
"物件可以用作上下文管理器，在離開上下文管理器主體時自動提交或回滾打開的事務。"
"如果 :keyword:`with` 語句的主體無例外地完成，則事務被提交。如果此提交失敗，"
"或者如果 ``with`` 語句的主體引發未捕獲的例外，則事務將回滾。"

#: ../../library/sqlite3.rst:2182
#, fuzzy
msgid ""
"If there is no open transaction upon leaving the body of the ``with`` "
"statement, the context manager is a no-op."
msgstr "如果在離開 ``with`` 語句的主體時沒有打開事務，則上下文管理器是空操作。"

#: ../../library/sqlite3.rst:2187
#, fuzzy
msgid ""
"The context manager neither implicitly opens a new transaction nor closes "
"the connection."
msgstr "上下文管理器既不隱式打開新事務也不關閉連接。"

#: ../../library/sqlite3.rst:2220
#, fuzzy
msgid "How to work with SQLite URIs"
msgstr "如何使用 SQLite URI"

#: ../../library/sqlite3.rst:2222
#, fuzzy
msgid "Some useful URI tricks include:"
msgstr "一些有用的 URI 技巧包括："

#: ../../library/sqlite3.rst:2224
#, fuzzy
msgid "Open a database in read-only mode:"
msgstr "以只讀模式打開資料庫："

#: ../../library/sqlite3.rst:2233
#, fuzzy
msgid ""
"Do not implicitly create a new database file if it does not already exist; "
"will raise :exc:`~sqlite3.OperationalError` if unable to create a new file:"
msgstr "如果新資料庫文件不存在，不要隱式建立它；如果無法建立新文件，將引發 :exec:`~sql"
"ite3.OperationalError`："

#: ../../library/sqlite3.rst:2243
#, fuzzy
msgid "Create a shared named in-memory database:"
msgstr "建立一個共享的命名記憶體資料庫："

#: ../../library/sqlite3.rst:2257
#, fuzzy
msgid ""
"More information about this feature, including a list of parameters, can be "
"found in the `SQLite URI documentation`_."
msgstr "有關此功能的更多資訊，包括參數列表，可以在“SQLite URI 文檔”中找到。"

#: ../../library/sqlite3.rst:2266
#, fuzzy
msgid "How to create and use row factories"
msgstr "如何建立和使用行工廠"

#: ../../library/sqlite3.rst:2268
#, fuzzy
msgid ""
"By default, :mod:`!sqlite3` represents each row as a :class:`tuple`. If a :"
"class:`!tuple` does not suit your needs, you can use the :class:`sqlite3."
"Row` class or a custom :attr:`~Cursor.row_factory`."
msgstr ""
"預設情況下，:mod:`!sqlite3` 將每一行表示為一個 :class:`tuple`。如果 "
":class:`!tuple` 不適合您的需要，您可以使用 :class:`sqlite3.Row` 類或自定義 "
":attr:`~Cursor.row_factory`。"

#: ../../library/sqlite3.rst:2273
#, fuzzy
msgid ""
"While :attr:`!row_factory` exists as an attribute both on the :class:"
"`Cursor` and the :class:`Connection`, it is recommended to set :class:"
"`Connection.row_factory`, so all cursors created from the connection will "
"use the same row factory."
msgstr ""
"雖然 :attr:`!row_factory` 作為屬性存在於 :class:`Cursor` 和 "
":class:`Connection` 中，但建議設定 :class:`Connection."
"row_factory`，因此所有游標都從連接將使用同一行工廠。"

#: ../../library/sqlite3.rst:2278
#, fuzzy
msgid ""
":class:`!Row` provides indexed and case-insensitive named access to columns, "
"with minimal memory overhead and performance impact over a :class:`!tuple`. "
"To use :class:`!Row` as a row factory, assign it to the :attr:`!row_factory` "
"attribute:"
msgstr ""
":class:`!Row` 提供對列的索引和不區分大小寫的命名訪問，與 :class:`!tuple` "
"相比，記憶體開銷和性能影響最小。要將 :class:`!Row` 用作行工廠，請將其分配給 "
":attr:`!row_factory` 屬性："

#: ../../library/sqlite3.rst:2288
#, fuzzy
msgid "Queries now return :class:`!Row` objects:"
msgstr "查詢現在回傳 :class:`!Row` 物件："

#: ../../library/sqlite3.rst:2303
#, fuzzy
msgid ""
"You can create a custom :attr:`~Cursor.row_factory` that returns each row as "
"a :class:`dict`, with column names mapped to values:"
msgstr ""
"您可以建立一個自定義的 :attr:`~Cursor.row_factory` 將每一行作為 :class:`dict`"
" 回傳，並將列名映射到值："

#: ../../library/sqlite3.rst:2312
#, fuzzy
msgid ""
"Using it, queries now return a :class:`!dict` instead of a :class:`!tuple`:"
msgstr "使用它，查詢現在回傳 :class:`!dict` 而不是 :class:`!tuple`："

#: ../../library/sqlite3.rst:2322
#, fuzzy
msgid "The following row factory returns a :term:`named tuple`:"
msgstr "下面的行工廠回傳一個 :term:`named tuple`："

#: ../../library/sqlite3.rst:2333
#, fuzzy
msgid ":func:`!namedtuple_factory` can be used as follows:"
msgstr ":func:`!namedtuple_factory` 可以按如下方式使用："

#: ../../library/sqlite3.rst:2348
#, fuzzy
msgid ""
"With some adjustments, the above recipe can be adapted to use a :class:"
"`~dataclasses.dataclass`, or any other custom class, instead of a :class:"
"`~collections.namedtuple`."
msgstr ""
"通過一些調整，上面的配方可以適應使用 :class:`~dataclasses.dataclass` "
"或任何其他自定義類，而不是 :class:`~collections.namedtuple`。"

#: ../../library/sqlite3.rst:2356
msgid "Explanation"
msgstr "解釋"

#: ../../library/sqlite3.rst:2361
#, fuzzy
msgid "Transaction control"
msgstr "事務控制"

#: ../../library/sqlite3.rst:2363
#, fuzzy
msgid ""
"The :mod:`!sqlite3` module does not adhere to the transaction handling "
"recommended by :pep:`249`."
msgstr ":mod:`!sqlite3` 模組不遵守 :pep:`249` 推薦的事務處理。"

#: ../../library/sqlite3.rst:2366
#, fuzzy
msgid ""
"If the connection attribute :attr:`~Connection.isolation_level` is not "
"``None``, new transactions are implicitly opened before :meth:`~Cursor."
"execute` and :meth:`~Cursor.executemany` executes ``INSERT``, ``UPDATE``, "
"``DELETE``, or ``REPLACE`` statements; for other statements, no implicit "
"transaction handling is performed. Use the :meth:`~Connection.commit` and :"
"meth:`~Connection.rollback` methods to respectively commit and roll back "
"pending transactions. You can choose the underlying `SQLite transaction "
"behaviour`_ — that is, whether and what type of ``BEGIN`` statements :mod:`!"
"sqlite3` implicitly executes – via the :attr:`~Connection.isolation_level` "
"attribute."
msgstr ""
"如果連接屬性 :attr:`~Connection.isolation_level` 不是 ``None``，則在 "
":meth:`~Cursor.execute` 和 :meth:`~Cursor.executemany` 執行 ``INSERT "
"之前隱式打開新事務``、``UPDATE``、``DELETE`` 或 ``REPLACE`` "
"語句；對於其他語句，不執行隱式事務處理。使用 :meth:`~Connection.commit` 和 "
":meth:`~Connection.rollback` 方法分別提交和回滾掛起的事務。您可以通過 "
":attr:`~Connection.isolation_level` 屬性選擇底層的 `SQLite "
"事務行為`_——也就是說，是否以及什麼型別的 `BEGIN`` "
"語句隱式執行 :mod:`!sqlite3`。"

#: ../../library/sqlite3.rst:2379
#, fuzzy
msgid ""
"If :attr:`~Connection.isolation_level` is set to ``None``, no transactions "
"are implicitly opened at all. This leaves the underlying SQLite library in "
"`autocommit mode`_, but also allows the user to perform their own "
"transaction handling using explicit SQL statements. The underlying SQLite "
"library autocommit mode can be queried using the :attr:`~Connection."
"in_transaction` attribute."
msgstr ""
"如果 :attr:`~Connection.isolation_level` 設定為 "
"``None``，則根本不會隱式打開任何事務。這使得底層 SQLite "
"庫處於“自動提交模式”，但也允許使用者使用顯式 SQL 語句執行自己的事務處理。"
"可以使用 :attr:`~Connection.in_transaction` 屬性查詢底層 SQLite "
"庫自動提交模式。"

#: ../../library/sqlite3.rst:2387
#, fuzzy
msgid ""
"The :meth:`~Cursor.executescript` method implicitly commits any pending "
"transaction before execution of the given SQL script, regardless of the "
"value of :attr:`~Connection.isolation_level`."
msgstr ""
":meth:`~Cursor.executescript` 方法在執行給定 SQL "
"腳本之前隱式提交任何未決事務，而不管 :attr:`~Connection.isolation_level` "
"的值如何。"

#: ../../library/sqlite3.rst:2391
#, fuzzy
msgid ""
":mod:`!sqlite3` used to implicitly commit an open transaction before DDL "
"statements.  This is no longer the case."
msgstr ":mod:`!sqlite3` 用於在 DDL 語句之前隱式提交打開的事務。這已不再是這種情況。"
