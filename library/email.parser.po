# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-06-20 18:08+0800\n"
"PO-Revision-Date: 2018-05-23 16:01+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/email.parser.rst:2
msgid ":mod:`email.parser`: Parsing email messages"
msgstr ":mod:`email.parser`: 剖析電子郵件訊息"

#: ../../library/email.parser.rst:7
msgid "**Source code:** :source:`Lib/email/parser.py`"
msgstr "**原始碼：**\\ :source:`Lib/email/parser.py`"

#: ../../library/email.parser.rst:11
#, fuzzy
msgid ""
"Message object structures can be created in one of two ways: they can be "
"created from whole cloth by creating an :class:`~email.message.EmailMessage` "
"object, adding headers using the dictionary interface, and adding payload(s) "
"using :meth:`~email.message.EmailMessage.set_content` and related methods, "
"or they can be created by parsing a serialized representation of the email "
"message."
msgstr ""
"消息物件結構可以通過以下兩種方式之一建立：它們可以通過建立 :class:`~email."
"message.EmailMessage` "
"物件，使用字典介面新增標頭，並使用以下方法新增有效負載來建立： meth:`~email."
"message.EmailMessage.set_content` "
"和相關方法，或者它們可以通過剖析電子郵件消息的序列化表示來建立。"

#: ../../library/email.parser.rst:18
#, fuzzy
msgid ""
"The :mod:`email` package provides a standard parser that understands most "
"email document structures, including MIME documents.  You can pass the "
"parser a bytes, string or file object, and the parser will return to you the "
"root :class:`~email.message.EmailMessage` instance of the object structure.  "
"For simple, non-MIME messages the payload of this root object will likely be "
"a string containing the text of the message.  For MIME messages, the root "
"object will return ``True`` from its :meth:`~email.message.EmailMessage."
"is_multipart` method, and the subparts can be accessed via the payload "
"manipulation methods, such as :meth:`~email.message.EmailMessage.get_body`, :"
"meth:`~email.message.EmailMessage.iter_parts`, and :meth:`~email.message."
"EmailMessage.walk`."
msgstr ""
":mod:`email` 包提供了一個標準剖析器，可以理解大多數電子郵件文檔結構，包括 "
"MIME 文檔。您可以向剖析器傳遞一個位元組、字串或文件物件，剖析器將回傳給您物件"
"結構的根實例。對於簡單的非 MIME "
"消息，此根物件的有效負載可能是包含消息文本的字串。對於 MIME 消息，"
"根物件將從其 :meth:`~email.message.EmailMessage.is_multipart` 方法回傳 "
"``True``，子部分可以通過有效負載操作方法訪問，例如 :meth:`~ email.message."
"EmailMessage.get_body`、:meth:`~email.message.EmailMessage.iter_parts` "
"和 :meth:`~email.message.EmailMessage.walk`。"

#: ../../library/email.parser.rst:30
#, fuzzy
msgid ""
"There are actually two parser interfaces available for use, the :class:"
"`Parser` API and the incremental :class:`FeedParser` API.  The :class:"
"`Parser` API is most useful if you have the entire text of the message in "
"memory, or if the entire message lives in a file on the file system.  :class:"
"`FeedParser` is more appropriate when you are reading the message from a "
"stream which might block waiting for more input (such as reading an email "
"message from a socket).  The :class:`FeedParser` can consume and parse the "
"message incrementally, and only returns the root object when you close the "
"parser."
msgstr ""
"實際上有兩個剖析器介面可供使用，Parser API 和增量 FeedParser API。如果消息的"
"整個文本都在記憶體中，或者如果整個消息存在於文件系統的一個文件中，則 Parser "
"API 最有用。 :class:`FeedParser` 當您從流中讀取消息時可能會阻塞等待更多輸入（"
"例如從 socket 讀取電子郵件消息）時更合適。 :class:`FeedParser` "
"可以增量地使用和剖析消息，並且僅在您關閉剖析器時回傳根物件。"

#: ../../library/email.parser.rst:39
#, fuzzy
msgid ""
"Note that the parser can be extended in limited ways, and of course you can "
"implement your own parser completely from scratch.  All of the logic that "
"connects the :mod:`email` package's bundled parser and the :class:`~email."
"message.EmailMessage` class is embodied in the :mod:`policy` class, so a "
"custom parser can create message object trees any way it finds necessary by "
"implementing custom versions of the appropriate :mod:`policy` methods."
msgstr ""
"請注意，剖析器可以以有限的方式擴充，當然您可以完全從頭開始實作自己的剖析器。"
"連接 :mod:`email` 包的捆綁剖析器和 :class:`~email.message.EmailMessage` "
"類的所有邏輯都包含在 :mod:`policy` 類中，"
"因此自定義剖析器可以建立消息物件通過實施適當的 :mod:`policy` "
"方法的自定義版本，以任何它認為必要的方式樹。"

#: ../../library/email.parser.rst:49
#, fuzzy
msgid "FeedParser API"
msgstr "FeedParser API"

#: ../../library/email.parser.rst:51
#, fuzzy
msgid ""
"The :class:`BytesFeedParser`, imported from the :mod:`email.feedparser` "
"module, provides an API that is conducive to incremental parsing of email "
"messages, such as would be necessary when reading the text of an email "
"message from a source that can block (such as a socket).  The :class:"
"`BytesFeedParser` can of course be used to parse an email message fully "
"contained in a :term:`bytes-like object`, string, or file, but the :class:"
"`BytesParser` API may be more convenient for such use cases.  The semantics "
"and results of the two parser APIs are identical."
msgstr ""
"從 :mod:`email.feedparser` 模組導入的 :class:`BytesFeedParser` 提供了一個 API"
"，有助於對電子郵件進行增量剖析，例如從源讀取電子郵件文本時所必需的可以阻塞的"
"（例如 socket ）。 :class:`BytesFeedParser` 當然可以用來剖析完全包含在 :term"
":`bytes-like object`、字串或文件中的電子郵件消息，但 :class:`BytesParser` "
"API 可能更方便這樣的用例。兩個剖析器 API 的語義和結果是相同的。"

#: ../../library/email.parser.rst:60
#, fuzzy
msgid ""
"The :class:`BytesFeedParser`'s API is simple; you create an instance, feed "
"it a bunch of bytes until there's no more to feed it, then close the parser "
"to retrieve the root message object.  The :class:`BytesFeedParser` is "
"extremely accurate when parsing standards-compliant messages, and it does a "
"very good job of parsing non-compliant messages, providing information about "
"how a message was deemed broken.  It will populate a message object's :attr:"
"`~email.message.EmailMessage.defects` attribute with a list of any problems "
"it found in a message.  See the :mod:`email.errors` module for the list of "
"defects that it can find."
msgstr ""
":class:`BytesFeedParser` 的 API 很簡單；您建立一個實例，向它提供一堆位元組，"
"直到沒有更多的位元組可以提供給它，然後關閉剖析器以檢索根消息物件。 "
":class:`BytesFeedParser` 在剖析符合標準的消息時非常準確，並且它在剖析不符合標"
"準的消息方面做得非常好，提供有關消息如何被視為損壞的資訊。它將使用在消息中發"
"現的任何問題的列表填充消息物件的 :attr:`~email.message.EmailMessage.defects` "
"屬性。請參閱 :mod:`email.errors` 模組以獲取它可以找到的缺陷列表。"

#: ../../library/email.parser.rst:70
#, fuzzy
msgid "Here is the API for the :class:`BytesFeedParser`:"
msgstr "這是 :class:`BytesFeedParser` 的 API："

#: ../../library/email.parser.rst:75
#, fuzzy
msgid ""
"Create a :class:`BytesFeedParser` instance.  Optional *_factory* is a no-"
"argument callable; if not specified use the :attr:`~email.policy.Policy."
"message_factory` from the *policy*.  Call *_factory* whenever a new message "
"object is needed."
msgstr ""
"建立一個 :class:`BytesFeedParser` 實例。可選的 *_factory* "
"是一個無參數的可呼叫物件；如果未指定，請使用 *policy* 中的 :attr:`~email."
"policy.Policy.message_factory`。每當需要新的消息物件時呼叫 *_factory*。"

#: ../../library/email.parser.rst:80
#, fuzzy
msgid ""
"If *policy* is specified use the rules it specifies to update the "
"representation of the message.  If *policy* is not set, use the :class:"
"`compat32 <email.policy.Compat32>` policy, which maintains backward "
"compatibility with the Python 3.2 version of the email package and provides :"
"class:`~email.message.Message` as the default factory.  All other policies "
"provide :class:`~email.message.EmailMessage` as the default *_factory*. For "
"more information on what else *policy* controls, see the :mod:`~email."
"policy` documentation."
msgstr ""
"如果指定了 *policy*，則使用它指定的規則來更新消息的表示。如果未設定 "
"*policy*，請使用 :class:`compat32 <email.policy.Compat32>` 策略，"
"它保持與電子郵件包的 Python 3.2 版本的向後相容性，並提供 :class:`~"
"email.message.Message ` 作為預設工廠。所有其他策略都提供 :class:`~email."
"message.EmailMessage` 作為預設 *_factory*。有關 *policy* "
"控制的其他內容的更多資訊，請參閱 :mod:`~email.policy` 文檔。"

#: ../../library/email.parser.rst:89 ../../library/email.parser.rst:145
#, fuzzy
msgid ""
"Note: **The policy keyword should always be specified**; The default will "
"change to :data:`email.policy.default` in a future version of Python."
msgstr "注意：**應始終指定策略關鍵字**；在未來的 Python "
"版本中，預設值將更改為 :data:`email.policy.default`。"

#: ../../library/email.parser.rst:94 ../../library/email.parser.rst:122
msgid "Added the *policy* keyword."
msgstr "新增 *policy* 關鍵字。"

#: ../../library/email.parser.rst:95
#, fuzzy
msgid "*_factory* defaults to the policy ``message_factory``."
msgstr "*_factory* 預設為策略“message_factory”。"

#: ../../library/email.parser.rst:100
#, fuzzy
msgid ""
"Feed the parser some more data.  *data* should be a :term:`bytes-like "
"object` containing one or more lines.  The lines can be partial and the "
"parser will stitch such partial lines together properly.  The lines can have "
"any of the three common line endings: carriage return, newline, or carriage "
"return and newline (they can even be mixed)."
msgstr ""
"為剖析器提供更多資料。 *data* 應該是一個包含一行或多行的 :term:`bytes-like ob"
"ject`。這些行可以是部分的，剖析器會將這些部分的行正確地拼接在一起。這些行可以"
"有三種常見的行結尾中的任何一種：回車、換行或回車和換行（它們甚至可以混合）。"

#: ../../library/email.parser.rst:109
#, fuzzy
msgid ""
"Complete the parsing of all previously fed data and return the root message "
"object.  It is undefined what happens if :meth:`~feed` is called after this "
"method has been called."
msgstr "完成對所有先前提供的資料的剖析並回傳根消息物件。如果在呼叫此方法後呼叫 "
":meth:`~feed` 會發生什麼是未定義的。"

#: ../../library/email.parser.rst:116
#, fuzzy
msgid ""
"Works like :class:`BytesFeedParser` except that the input to the :meth:"
"`~BytesFeedParser.feed` method must be a string.  This is of limited "
"utility, since the only way for such a message to be valid is for it to "
"contain only ASCII text or, if :attr:`~email.policy.Policy.utf8` is "
"``True``, no binary attachments."
msgstr ""
"像 :class:`BytesFeedParser` 一樣工作，除了 :meth:`~BytesFeedParser.feed` "
"方法的輸入必須是一個字串。這是有限的實用性，"
"因為使此類消息有效的唯一方法是它僅包含 ASCII 文本，或者如果 :attr:`~email."
"policy.Policy.utf8` 為 ``True``，則不包含二進位文件附件。"

#: ../../library/email.parser.rst:126
#, fuzzy
msgid "Parser API"
msgstr "剖析器API"

#: ../../library/email.parser.rst:128
#, fuzzy
msgid ""
"The :class:`BytesParser` class, imported from the :mod:`email.parser` "
"module, provides an API that can be used to parse a message when the "
"complete contents of the message are available in a :term:`bytes-like "
"object` or file.  The :mod:`email.parser` module also provides :class:"
"`Parser` for parsing strings, and header-only parsers, :class:"
"`BytesHeaderParser` and :class:`HeaderParser`, which can be used if you're "
"only interested in the headers of the message.  :class:`BytesHeaderParser` "
"and :class:`HeaderParser` can be much faster in these situations, since they "
"do not attempt to parse the message body, instead setting the payload to the "
"raw body."
msgstr ""
"從 :mod:`email.parser` 模組導入的 :class:`BytesParser` 類提供了一個 "
"API，當消息的完整內容在 :term:`bytes- 中可用時，該 API "
"可用於剖析消息像物件`或文件。 :mod:`email.parser` 模組還提供了用於剖析字串的 "
":class:`Parser` 和僅標頭剖析器 :class:`BytesHeaderParser` 和 "
":class:`HeaderParser`，如果你是只對消息的標題感興趣。 "
":class:`BytesHeaderParser` 和 :class:`HeaderParser` 在這些情況下可以更快，因"
"為它們不嘗試剖析消息正文，而是將有效負載設定為原始正文。"

#: ../../library/email.parser.rst:141
#, fuzzy
msgid ""
"Create a :class:`BytesParser` instance.  The *_class* and *policy* arguments "
"have the same meaning and semantics as the *_factory* and *policy* arguments "
"of :class:`BytesFeedParser`."
msgstr ""
"建立一個 :class:`BytesParser` 實例。 *_class* 和 *policy* 參數與 "
"BytesFeedParser 的 *_factory* 和 *policy* 參數具有相同的含義和語義。"

#: ../../library/email.parser.rst:148
#, fuzzy
msgid ""
"Removed the *strict* argument that was deprecated in 2.4.  Added the "
"*policy* keyword."
msgstr "刪除了 2.4 中棄用的 *strict* 參數。新增了 *policy* 關鍵字。"

#: ../../library/email.parser.rst:151 ../../library/email.parser.rst:200
#: ../../library/email.parser.rst:280
#, fuzzy
msgid "*_class* defaults to the policy ``message_factory``."
msgstr "*_class* 預設為策略“message_factory”。"

#: ../../library/email.parser.rst:156
#, fuzzy
msgid ""
"Read all the data from the binary file-like object *fp*, parse the resulting "
"bytes, and return the message object.  *fp* must support both the :meth:`~io."
"IOBase.readline` and the :meth:`~io.IOBase.read` methods."
msgstr ""
"從二進位類文件物件 *fp* 中讀取所有數據"
"，剖析結果位元組，並回傳消息物件。 *fp* 必須同時支援 :meth:`~io.IOBase."
"readline` 和 :meth:`~io.IOBase.read` 方法。"

#: ../../library/email.parser.rst:161
#, fuzzy
msgid ""
"The bytes contained in *fp* must be formatted as a block of :rfc:`5322` (or, "
"if :attr:`~email.policy.Policy.utf8` is ``True``, :rfc:`6532`) style headers "
"and header continuation lines, optionally preceded by an envelope header.  "
"The header block is terminated either by the end of the data or by a blank "
"line.  Following the header block is the body of the message (which may "
"contain MIME-encoded subparts, including subparts with a :mailheader:"
"`Content-Transfer-Encoding` of ``8bit``)."
msgstr ""
"*fp* 中包含的位元組必須格式化為 :rfc:`5322` 的塊（或者，如果 :attr:`~email."
"policy.Policy.utf8` 為 ``True``，則 :rfc:`6532` ) 樣式標題和標題連續行，可選"
"地在信封標題之前。標題塊由資料末尾或空行終止。標頭塊之後是郵件正文（可能包含 "
"MIME 編碼的子部分，包括帶有 8 位 Content-Transfer-Encoding 的子部分）。"

#: ../../library/email.parser.rst:169
#, fuzzy
msgid ""
"Optional *headersonly* is a flag specifying whether to stop parsing after "
"reading the headers or not.  The default is ``False``, meaning it parses the "
"entire contents of the file."
msgstr "可選的 *headersonly* 是一個旗標，指定是否在讀取標頭後停止剖析。預設值為“False"
"”，表示它剖析文件的全部內容。"

#: ../../library/email.parser.rst:176
#, fuzzy
msgid ""
"Similar to the :meth:`parse` method, except it takes a :term:`bytes-like "
"object` instead of a file-like object.  Calling this method on a :term:"
"`bytes-like object` is equivalent to wrapping *bytes* in a :class:`~io."
"BytesIO` instance first and calling :meth:`parse`."
msgstr ""
"類似於 :meth:`parse` 方法，除了它需要一個 :term:`bytes-like object` "
"而不是一個 file-like 物件。在 :term:`bytes-like object` "
"上呼叫此方法等同於先將 *bytes* 包裝在 :class:`~io.BytesIO` 實例中，然後呼叫 "
":meth:`parse`。"

#: ../../library/email.parser.rst:181 ../../library/email.parser.rst:221
#, fuzzy
msgid "Optional *headersonly* is as with the :meth:`parse` method."
msgstr "可選的 *headersonly* 與 :meth:`parse` 方法一樣。"

#: ../../library/email.parser.rst:188
#, fuzzy
msgid ""
"Exactly like :class:`BytesParser`, except that *headersonly* defaults to "
"``True``."
msgstr "完全像 :class:`BytesParser`，除了 *headersonly* 預設為 ``True``。"

#: ../../library/email.parser.rst:196
#, fuzzy
msgid ""
"This class is parallel to :class:`BytesParser`, but handles string input."
msgstr "此類與 :class:`BytesParser` 平行，但處理字串輸入。"

#: ../../library/email.parser.rst:198 ../../library/email.parser.rst:245
#: ../../library/email.parser.rst:258 ../../library/email.parser.rst:268
#: ../../library/email.parser.rst:278
#, fuzzy
msgid "Removed the *strict* argument.  Added the *policy* keyword."
msgstr "刪除了 *strict* 參數。新增了 *policy* 關鍵字。"

#: ../../library/email.parser.rst:205
#, fuzzy
msgid ""
"Read all the data from the text-mode file-like object *fp*, parse the "
"resulting text, and return the root message object.  *fp* must support both "
"the :meth:`~io.TextIOBase.readline` and the :meth:`~io.TextIOBase.read` "
"methods on file-like objects."
msgstr ""
"從文本模式類文件物件 *fp* 中讀取所有數據"
"，剖析生成的文本，並回傳根消息物件。 *fp* 必須同時支援類文件物件的 :meth:`~io"
".TextIOBase.readline` 和 :meth:`~io.TextIOBase.read` 方法。"

#: ../../library/email.parser.rst:210
#, fuzzy
msgid ""
"Other than the text mode requirement, this method operates like :meth:"
"`BytesParser.parse`."
msgstr "除了文本模式要求外，此方法的操作類似於 :meth:`BytesParser.parse`。"

#: ../../library/email.parser.rst:216
#, fuzzy
msgid ""
"Similar to the :meth:`parse` method, except it takes a string object instead "
"of a file-like object.  Calling this method on a string is equivalent to "
"wrapping *text* in a :class:`~io.StringIO` instance first and calling :meth:"
"`parse`."
msgstr ""
"類似於 :meth:`parse` 方法，除了它採用字串物件而不是類文件物件。"
"在字串上呼叫此方法相當於先將 *text* 包裝在 :class:`~io.StringIO` 實例中，"
"然後呼叫 :meth:`parse`。"

#: ../../library/email.parser.rst:226
#, fuzzy
msgid ""
"Exactly like :class:`Parser`, except that *headersonly* defaults to ``True``."
msgstr "完全像 :class:`Parser`，除了 *headersonly* 預設為 ``True``。"

#: ../../library/email.parser.rst:230
#, fuzzy
msgid ""
"Since creating a message object structure from a string or a file object is "
"such a common task, four functions are provided as a convenience.  They are "
"available in the top-level :mod:`email` package namespace."
msgstr "由於從字串或文件物件建立消息物件結構是一項常見任務，因此提供了四個函式以方便"
"使用。它們在頂級 :mod:`email` 包命名空間中可用。"

#: ../../library/email.parser.rst:239
#, fuzzy
msgid ""
"Return a message object structure from a :term:`bytes-like object`.  This is "
"equivalent to ``BytesParser().parsebytes(s)``.  Optional *_class* and "
"*policy* are interpreted as with the :class:`~email.parser.BytesParser` "
"class constructor."
msgstr ""
"從 :term:`bytes-like object` 回傳消息物件結構。這相當於 ``BytesParser()."
"parsebytes(s)``。可選的 *_class* 和 *policy* 被解釋為 :class:`~email.parser."
"BytesParser` 類構造函式。"

#: ../../library/email.parser.rst:252
#, fuzzy
msgid ""
"Return a message object structure tree from an open binary :term:`file "
"object`.  This is equivalent to ``BytesParser().parse(fp)``.  *_class* and "
"*policy* are interpreted as with the :class:`~email.parser.BytesParser` "
"class constructor."
msgstr ""
"從打開的二進位 :term:`file object` 回傳消息物件結構樹。這相當於 "
"``BytesParser().parse(fp)``。 *_class* 和 *policy* 被解釋為 :class:`~email."
"parser.BytesParser` 類構造函式。"

#: ../../library/email.parser.rst:264
#, fuzzy
msgid ""
"Return a message object structure from a string.  This is equivalent to "
"``Parser().parsestr(s)``.  *_class* and *policy* are interpreted as with "
"the :class:`~email.parser.Parser` class constructor."
msgstr ""
"從字串回傳消息物件結構。這相當於 ``Parser().parsestr(s)``。 *_class* 和 "
"*policy* 被解釋為使用 :class:`~email.parser.Parser` 類構造函式。"

#: ../../library/email.parser.rst:274
#, fuzzy
msgid ""
"Return a message object structure tree from an open :term:`file object`. "
"This is equivalent to ``Parser().parse(fp)``.  *_class* and *policy* are "
"interpreted as with the :class:`~email.parser.Parser` class constructor."
msgstr ""
"從打開的 :term:`file object` 回傳消息物件結構樹。這等同於 ``Parser()."
"parse(fp)``。 *_class* 和 *policy* 被解釋為使用 :class:`~email.parser.Parser`"
" 類構造函式。"

#: ../../library/email.parser.rst:283
#, fuzzy
msgid ""
"Here's an example of how you might use :func:`message_from_bytes` at an "
"interactive Python prompt::"
msgstr "以下是您如何在交互式 Python 提示符下使用 message_from_bytes 的示例："

#: ../../library/email.parser.rst:291
#, fuzzy
msgid "Additional notes"
msgstr "補充筆記"

#: ../../library/email.parser.rst:293
#, fuzzy
msgid "Here are some notes on the parsing semantics:"
msgstr "以下是有關剖析語義的一些註釋："

#: ../../library/email.parser.rst:295
#, fuzzy
msgid ""
"Most non-\\ :mimetype:`multipart` type messages are parsed as a single "
"message object with a string payload.  These objects will return ``False`` "
"for :meth:`~email.message.EmailMessage.is_multipart`, and :meth:`~email."
"message.EmailMessage.iter_parts` will yield an empty list."
msgstr ""
"大多數非 \\ :mimetype:`multipart` "
"型別的消息被剖析為具有字串負載的單個消息物件。這些物件將為 :meth:`~email."
"message.EmailMessage.is_multipart` 回傳 ``False``，而 :meth:`~email.message."
"EmailMessage.iter_parts` 將產生一個空列表。"

#: ../../library/email.parser.rst:300
#, fuzzy
msgid ""
"All :mimetype:`multipart` type messages will be parsed as a container "
"message object with a list of sub-message objects for their payload.  The "
"outer container message will return ``True`` for :meth:`~email.message."
"EmailMessage.is_multipart`, and :meth:`~email.message.EmailMessage."
"iter_parts` will yield a list of subparts."
msgstr ""
"所有 :mimetype:`multipart` "
"型別的消息都將被剖析為容器消息物件，其中包含用於其負載的子消息物件列表。"
"外部容器消息將為 :meth:`~email.message.EmailMessage.is_multipart` 回傳 "
"``True``，而 :meth:`~email.message.EmailMessage.iter_parts` "
"將產生一個子部分列表。"

#: ../../library/email.parser.rst:306
#, fuzzy
msgid ""
"Most messages with a content type of :mimetype:`message/\\*` (such as :"
"mimetype:`message/delivery-status` and :mimetype:`message/rfc822`) will also "
"be parsed as container object containing a list payload of length 1.  Their :"
"meth:`~email.message.EmailMessage.is_multipart` method will return ``True``. "
"The single element yielded by :meth:`~email.message.EmailMessage.iter_parts` "
"will be a sub-message object."
msgstr ""
"大多數內容型別為 :mimetype:`message/\\*` 的消息（例如 :mimetype:`message/"
"delivery-status` 和 :mimetype:`message/rfc822`）"
"也將被剖析為包含列表負載的容器物件長度為 1。他們的 :meth:`~email.message."
"EmailMessage.is_multipart` 方法將回傳 ``True``。 :meth:`~email.message."
"EmailMessage.iter_parts` 產生的單個元素將是一個子消息物件。"

#: ../../library/email.parser.rst:313
#, fuzzy
msgid ""
"Some non-standards-compliant messages may not be internally consistent about "
"their :mimetype:`multipart`\\ -edness.  Such messages may have a :mailheader:"
"`Content-Type` header of type :mimetype:`multipart`, but their :meth:`~email."
"message.EmailMessage.is_multipart` method may return ``False``. If such "
"messages were parsed with the :class:`~email.parser.FeedParser`, they will "
"have an instance of the :class:`~email.errors."
"MultipartInvariantViolationDefect` class in their *defects* attribute list.  "
"See :mod:`email.errors` for details."
msgstr ""
"一些不符合標準的消息可能在內部不一致 :mimetype:`multipart`\\ -edness。"
"此類消息可能具有型別為 multipart 的 Content-Type 標頭，"
"但它們的方法可能會回傳 False。如果此類消息是使用 :class:`~email.parser."
"FeedParser` 剖析的，它們的 *defects* 屬性列表中將有一個 :class:`~email.errors"
".MultipartInvariantViolationDefect` "
"類的實例。有關詳細資訊，請參見 :mod:`email.errors`。"
