# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Andy Dai <daikeren@gmail.com>, 2015
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-25 00:15+0000\n"
"PO-Revision-Date: 2018-05-23 16:05+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/logging.rst:2
msgid ":mod:`logging` --- Logging facility for Python"
msgstr ":mod:`logging` --- Python 的日誌記錄工具"

#: ../../library/logging.rst:10
msgid "**Source code:** :source:`Lib/logging/__init__.py`"
msgstr "**原始碼：**\\ :source:`Lib/logging/__init__.py`"

#: ../../library/logging.rst:16
#, fuzzy
msgid ""
"This page contains the API reference information. For tutorial information "
"and discussion of more advanced topics, see"
msgstr "此頁麵包含 API 參考資訊。有關教程資訊和更高階主題的討論，請參閱"

#: ../../library/logging.rst:19
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`基礎教學 <logging-basic-tutorial>`"

#: ../../library/logging.rst:20
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`進階教學 <logging-advanced-tutorial>`"

#: ../../library/logging.rst:21
#, fuzzy
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`Logging Cookbook <logging-cookbook>`"

#: ../../library/logging.rst:25
#, fuzzy
msgid ""
"This module defines functions and classes which implement a flexible event "
"logging system for applications and libraries."
msgstr "該模組定義了為應用程式和庫實作靈活事件記錄系統的函式和類。"

#: ../../library/logging.rst:28
#, fuzzy
msgid ""
"The key benefit of having the logging API provided by a standard library "
"module is that all Python modules can participate in logging, so your "
"application log can include your own messages integrated with messages from "
"third-party modules."
msgstr ""
"使用標準庫模組提供的日誌記錄 API 的主要好處是所有 Python 模組都可以參與日誌記"
"錄，因此您的應用程式日誌可以包含您自己的消息以及來自第三方模組的消息。"

#: ../../library/logging.rst:33
#, fuzzy
msgid "The simplest example:"
msgstr "最簡單的例子："

#: ../../library/logging.rst:41
#, fuzzy
msgid ""
"The module provides a lot of functionality and flexibility.  If you are "
"unfamiliar with logging, the best way to get to grips with it is to view the "
"tutorials (**see the links above and on the right**)."
msgstr "該模組提供了大量的功能和靈活性。如果您不熟悉日誌記錄，掌握它的最佳方法是查看"
"教程（**請參閱上方和右側的鏈接**）。"

#: ../../library/logging.rst:45
#, fuzzy
msgid ""
"The basic classes defined by the module, together with their functions, are "
"listed below."
msgstr "下面列出了模組定義的基本類及其功能。"

#: ../../library/logging.rst:48
#, fuzzy
msgid "Loggers expose the interface that application code directly uses."
msgstr "記錄器公開應用程式程式碼直接使用的介面。"

#: ../../library/logging.rst:49
#, fuzzy
msgid ""
"Handlers send the log records (created by loggers) to the appropriate "
"destination."
msgstr "處理程式將日誌記錄（由記錄器建立）發送到適當的目的地。"

#: ../../library/logging.rst:51
#, fuzzy
msgid ""
"Filters provide a finer grained facility for determining which log records "
"to output."
msgstr "過濾器提供了一種更細粒度的工具來確定要輸出哪些日誌記錄。"

#: ../../library/logging.rst:53
#, fuzzy
msgid "Formatters specify the layout of log records in the final output."
msgstr "格式化程式指定最終輸出中日誌記錄的佈局。"

#: ../../library/logging.rst:59
#, fuzzy
msgid "Logger Objects"
msgstr "記錄器物件"

#: ../../library/logging.rst:61
#, fuzzy
msgid ""
"Loggers have the following attributes and methods.  Note that Loggers should "
"*NEVER* be instantiated directly, but always through the module-level "
"function ``logging.getLogger(name)``.  Multiple calls to :func:`getLogger` "
"with the same name will always return a reference to the same Logger object."
msgstr ""
"記錄器具有以下屬性和方法。請注意，Loggers 應該 *永遠* 直接實例化，"
"但始終通過模組級函式 logging.getLogger(name) 。多次呼叫同名的 "
":func:`getLogger` 將始終回傳對同一 Logger 物件的引用。"

#: ../../library/logging.rst:66
#, fuzzy
msgid ""
"The ``name`` is potentially a period-separated hierarchical value, like "
"``foo.bar.baz`` (though it could also be just plain ``foo``, for example). "
"Loggers that are further down in the hierarchical list are children of "
"loggers higher up in the list.  For example, given a logger with a name of "
"``foo``, loggers with names of ``foo.bar``, ``foo.bar.baz``, and ``foo.bam`` "
"are all descendants of ``foo``.  The logger name hierarchy is analogous to "
"the Python package hierarchy, and identical to it if you organise your "
"loggers on a per-module basis using the recommended construction ``logging."
"getLogger(__name__)``.  That's because in a module, ``__name__`` is the "
"module's name in the Python package namespace."
msgstr ""
"``name`` 可能是一個以句點分隔的分層值，例如 ``foo.bar.baz``（"
"儘管它也可以只是普通的 ``foo``）。在層次結構列表中更靠下的記錄器是列表中更高"
"記錄器的子代。例如，給定一個名稱為 ``foo``的記錄器，名稱為“foo.bar”、“foo.bar."
"baz”和“foo.bam”的記錄器都是``foo``。記錄器名稱層次結構類似於 Python "
"包層次結構，如果您使用推薦的構造“logging.getLogger(__name__)”在每個模組的基礎"
"上組織記錄器，則與它相同。那是因為在模組中，``__name__`` 是模組在 Python "
"包命名空間中的名稱。"

#: ../../library/logging.rst:82
#, fuzzy
msgid ""
"If this attribute evaluates to true, events logged to this logger will be "
"passed to the handlers of higher level (ancestor) loggers, in addition to "
"any handlers attached to this logger. Messages are passed directly to the "
"ancestor loggers' handlers - neither the level nor filters of the ancestor "
"loggers in question are considered."
msgstr ""
"如果此屬性評估為真，則記錄到此記錄器的事件將傳遞給更高階別（祖先）記錄器的處"
"理程式，以及附加到此記錄器的任何處理程式。消息直接傳遞給祖先記錄器的處理程式—"
"—既不考慮相關祖先記錄器的級別也不考慮過濾器。"

#: ../../library/logging.rst:88
#, fuzzy
msgid ""
"If this evaluates to false, logging messages are not passed to the handlers "
"of ancestor loggers."
msgstr "如果這評估為 false，則日誌記錄消息不會傳遞給祖先記錄器的處理程式。"

#: ../../library/logging.rst:91
#, fuzzy
msgid ""
"Spelling it out with an example: If the propagate attribute of the logger "
"named ``A.B.C`` evaluates to true, any event logged to ``A.B.C`` via a "
"method call such as ``logging.getLogger('A.B.C').error(...)`` will [subject "
"to passing that logger's level and filter settings] be passed in turn to any "
"handlers attached to loggers named ``A.B``, ``A`` and the root logger, after "
"first being passed to any handlers attached to ``A.B.C``. If any logger in "
"the chain ``A.B.C``, ``A.B``, ``A`` has its ``propagate`` attribute set to "
"false, then that is the last logger whose handlers are offered the event to "
"handle, and propagation stops at that point."
msgstr ""
"用一個例子來說明：如果名為 ``A.B.C`` 的記錄器的傳播屬性評估為真，"
"則任何事件記錄到 ``A.B.C`` 通過諸如 ``logging.getLogger('A.B.C') ."
"error(...)`` 將 [根據傳遞該記錄器的級別和過濾器設定] 依次傳遞給附加到名為 ``A"
".B``、``A`` 的記錄器和根記錄器的任何處理程式，首先被傳遞給附加到“A.B."
"C”的任何處理程式。如果鏈“A.B.C”、“A.B”、 ``A``中的任何記錄器的“傳播”屬性設定為 f"
"alse，那麼這是最後一個記錄器，其處理程式被提供要處理的事件，並且傳播在該點停"
"止。"

#: ../../library/logging.rst:100
#, fuzzy
msgid "The constructor sets this attribute to ``True``."
msgstr "構造函式將此屬性設定為 ``True``。"

#: ../../library/logging.rst:102
#, fuzzy
msgid ""
"If you attach a handler to a logger *and* one or more of its ancestors, it "
"may emit the same record multiple times. In general, you should not need to "
"attach a handler to more than one logger - if you just attach it to the "
"appropriate logger which is highest in the logger hierarchy, then it will "
"see all events logged by all descendant loggers, provided that their "
"propagate setting is left set to ``True``. A common scenario is to attach "
"handlers only to the root logger, and to let propagation take care of the "
"rest."
msgstr ""
"如果您將處理程式附加到記錄器*和*它的一個或多個祖先，它可能會多次發出相同的記"
"錄。通常，您不需要將一個處理程式附加到多個記錄器 - 如果您只是將它附加到記錄器"
"層次結構中最高的適當記錄器，那麼它將看到所有後代記錄器記錄的所有事件，前提是"
"它們的傳播設定保留為 ``True``。一個常見的場景是僅將處理程式附加到根記錄器，並讓"
"傳播處理其餘部分。"

#: ../../library/logging.rst:113
#, fuzzy
msgid ""
"Sets the threshold for this logger to *level*. Logging messages which are "
"less severe than *level* will be ignored; logging messages which have "
"severity *level* or higher will be emitted by whichever handler or handlers "
"service this logger, unless a handler's level has been set to a higher "
"severity level than *level*."
msgstr ""
"將此記錄器的閾值設定為 *level*。低於*級別*的日誌消息將被忽略；具有嚴重性 "
"*level* "
"或更高嚴重性的日誌消息將由為該記錄器服務的任何一個或多個處理程式發出，"
"除非處理程式的級別已設定為比 *level* 更高的嚴重性級別。"

#: ../../library/logging.rst:118
#, fuzzy
msgid ""
"When a logger is created, the level is set to :const:`NOTSET` (which causes "
"all messages to be processed when the logger is the root logger, or "
"delegation to the parent when the logger is a non-root logger). Note that "
"the root logger is created with level :const:`WARNING`."
msgstr ""
"建立記錄器時，級別設定為 :const:`NOTSET`（當記錄器是根記錄器時，這會導致處理"
"所有消息，或者當記錄器是非根記錄器時，將委託給父記錄器）。請注意，"
"根記錄器是使用 :const:`WARNING` 級別建立的。"

#: ../../library/logging.rst:123
#, fuzzy
msgid ""
"The term 'delegation to the parent' means that if a logger has a level of "
"NOTSET, its chain of ancestor loggers is traversed until either an ancestor "
"with a level other than NOTSET is found, or the root is reached."
msgstr "術語“委託給父級”意味著如果記錄器具有 NOTSET 級別，則遍歷其祖先記錄器鏈，"
"直到找到級別不是 NOTSET 的祖先，或者到達根。"

#: ../../library/logging.rst:127
#, fuzzy
msgid ""
"If an ancestor is found with a level other than NOTSET, then that ancestor's "
"level is treated as the effective level of the logger where the ancestor "
"search began, and is used to determine how a logging event is handled."
msgstr "如果發現祖先的級別不是 NOTSET，那麼該祖先的級別將被視為祖先搜索開始的記錄器的"
"有效級別，並用於確定如何處理日誌記錄事件。"

#: ../../library/logging.rst:131
#, fuzzy
msgid ""
"If the root is reached, and it has a level of NOTSET, then all messages will "
"be processed. Otherwise, the root's level will be used as the effective "
"level."
msgstr "如果到達根目錄，並且它的級別為 NOTSET，那麼將處理所有消息。否則，root "
"的級別將被用作有效級別。"

#: ../../library/logging.rst:134 ../../library/logging.rst:447
msgid "See :ref:`levels` for a list of levels."
msgstr "層級清單請見 :ref:`levels`\\ 。"

#: ../../library/logging.rst:136
#, fuzzy
msgid ""
"The *level* parameter now accepts a string representation of the level such "
"as 'INFO' as an alternative to the integer constants such as :const:`INFO`. "
"Note, however, that levels are internally stored as integers, and methods "
"such as e.g. :meth:`getEffectiveLevel` and :meth:`isEnabledFor` will return/"
"expect to be passed integers."
msgstr ""
"*level* 參數現在接受級別的字串表示形式，例如 ``INFO``，以替代整數常數，例如 :con"
"st:`INFO`。但是請注意，級別在內部儲存為整數，並且方法例如 :meth:`getEffectiveL"
"evel` 和 :meth:`isEnabledFor` 將回傳/期望傳遞整數。"

#: ../../library/logging.rst:146
#, fuzzy
msgid ""
"Indicates if a message of severity *level* would be processed by this "
"logger. This method checks first the module-level level set by ``logging."
"disable(level)`` and then the logger's effective level as determined by :"
"meth:`getEffectiveLevel`."
msgstr ""
"指示嚴重性為 *level* 的消息是否將由該記錄器處理。此方法首先檢查由 ``logging."
"disable(level)`` 設定的模組級級別，然後檢查由 :meth:`getEffectiveLevel` "
"確定的記錄器的有效級別。"

#: ../../library/logging.rst:154
#, fuzzy
msgid ""
"Indicates the effective level for this logger. If a value other than :const:"
"`NOTSET` has been set using :meth:`setLevel`, it is returned. Otherwise, the "
"hierarchy is traversed towards the root until a value other than :const:"
"`NOTSET` is found, and that value is returned. The value returned is an "
"integer, typically one of :const:`logging.DEBUG`, :const:`logging.INFO` etc."
msgstr ""
"指示此記錄器的有效級別。如果使用 :meth:`setLevel` 設定了 :const:`NOTSET` "
"以外的值，則回傳該值。否則，將向根遍歷層次結構，直到找到 :const:`NOTSET` "
"以外的值，並回傳該值。回傳的值是一個整數，通常是 :const:`logging."
"DEBUG`、:const:`logging.INFO` 等之一。"

#: ../../library/logging.rst:164
#, fuzzy
msgid ""
"Returns a logger which is a descendant to this logger, as determined by the "
"suffix. Thus, ``logging.getLogger('abc').getChild('def.ghi')`` would return "
"the same logger as would be returned by ``logging.getLogger('abc.def."
"ghi')``. This is a convenience method, useful when the parent logger is "
"named using e.g. ``__name__`` rather than a literal string."
msgstr ""
"回傳一個記錄器，它是此記錄器的後代，由後綴確定。因此，``logging."
"getLogger('abc').getChild('def.ghi')`` 將回傳與 ``logging.getLogger('abc.def."
"ghi')`` 相同的記錄器。這是一種方便的方法，在使用例如命名父記錄器時很有用。 "
"``__name__`` 而不是文字字串。"

#: ../../library/logging.rst:175
#, fuzzy
msgid ""
"Logs a message with level :const:`DEBUG` on this logger. The *msg* is the "
"message format string, and the *args* are the arguments which are merged "
"into *msg* using the string formatting operator. (Note that this means that "
"you can use keywords in the format string, together with a single dictionary "
"argument.) No % formatting operation is performed on *msg* when no *args* "
"are supplied."
msgstr ""
"在此記錄器上記錄一條級別為 :const:`DEBUG` 的消息。 *msg* "
"是消息格式字串，*args* 是使用字串格式化運算符合併到 *msg* 中的參數。 "
"（請注意，這意味著您可以在格式字串中使用關鍵字以及單個字典參數。）當未提供 "
"*args* 時，不會對 *msg* 執行 % 格式化操作。"

#: ../../library/logging.rst:181
#, fuzzy
msgid ""
"There are four keyword arguments in *kwargs* which are inspected: "
"*exc_info*, *stack_info*, *stacklevel* and *extra*."
msgstr "*kwargs* 中有四個關鍵字參數被檢查：*exc_info*、*stack_info*、*stacklevel* 和 "
"*extra*。"

#: ../../library/logging.rst:184
#, fuzzy
msgid ""
"If *exc_info* does not evaluate as false, it causes exception information to "
"be added to the logging message. If an exception tuple (in the format "
"returned by :func:`sys.exc_info`) or an exception instance is provided, it "
"is used; otherwise, :func:`sys.exc_info` is called to get the exception "
"information."
msgstr ""
"如果 *exc_info* "
"的計算結果不為假，它會導致將例外資訊新增到日誌消息中。如果提供了例外元組（以 "
":func:`sys.exc_info` 回傳的格式）或例外實例，則使用它；否則，呼叫 :func:`sys."
"exc_info` 獲取例外資訊。"

#: ../../library/logging.rst:189 ../../library/logging.rst:1067
#, fuzzy
msgid ""
"The second optional keyword argument is *stack_info*, which defaults to "
"``False``. If true, stack information is added to the logging message, "
"including the actual logging call. Note that this is not the same stack "
"information as that displayed through specifying *exc_info*: The former is "
"stack frames from the bottom of the stack up to the logging call in the "
"current thread, whereas the latter is information about stack frames which "
"have been unwound, following an exception, while searching for exception "
"handlers."
msgstr ""
"第二個可選關鍵字參數是 *stack_info*，預設為 ``False``。如果為 "
"true，堆疊資訊將新增到日誌消息中，包括實際的日誌記錄呼叫。請注意，"
"這與通過指定 *exc_info* 顯示的堆疊資訊不同：前者是從堆疊底部到當前執行緒中的"
"日誌記錄呼叫的堆疊幀，而後者是有關已被呼叫的堆疊幀的資訊展開，在例外之後，同"
"時搜索例外處理程式。"

#: ../../library/logging.rst:198 ../../library/logging.rst:1076
#, fuzzy
msgid ""
"You can specify *stack_info* independently of *exc_info*, e.g. to just show "
"how you got to a certain point in your code, even when no exceptions were "
"raised. The stack frames are printed following a header line which says:"
msgstr ""
"您可以獨立於 *exc_info* 指定 *stack_info*，例如只是展示你是如何到達程式碼中的"
"某個點的，即使沒有引發例外。堆疊幀在標題行之後印出，標題行表示："

#: ../../library/logging.rst:206 ../../library/logging.rst:1084
#, fuzzy
msgid ""
"This mimics the ``Traceback (most recent call last):`` which is used when "
"displaying exception frames."
msgstr "這模仿了顯示例外幀時使用的 ``Traceback (most recent call last):``。"

#: ../../library/logging.rst:209
#, fuzzy
msgid ""
"The third optional keyword argument is *stacklevel*, which defaults to "
"``1``. If greater than 1, the corresponding number of stack frames are "
"skipped when computing the line number and function name set in the :class:"
"`LogRecord` created for the logging event. This can be used in logging "
"helpers so that the function name, filename and line number recorded are not "
"the information for the helper function/method, but rather its caller. The "
"name of this parameter mirrors the equivalent one in the :mod:`warnings` "
"module."
msgstr ""
"第三個可選關鍵字參數是 *stacklevel*，預設為 ``1``。如果大於 1，"
"則在計算為日誌記錄事件建立的 LogRecord 中設定的行號和函式名稱時，將跳過相應數"
"量的堆疊幀。這可以用於記錄幫助器，以便記錄的函式名、文件名和行號不是幫助器函"
"式/方法的資訊，而是它的呼叫者的資訊。此參數的名稱反映了 :mod:`warnings` "
"模組中的等效名稱。"

#: ../../library/logging.rst:217
#, fuzzy
msgid ""
"The fourth keyword argument is *extra* which can be used to pass a "
"dictionary which is used to populate the __dict__ of the :class:`LogRecord` "
"created for the logging event with user-defined attributes. These custom "
"attributes can then be used as you like. For example, they could be "
"incorporated into logged messages. For example::"
msgstr ""
"第四個關鍵字參數是 *extra*，它可用於傳遞一個字典，"
"該字典用於填充為具有使用者定義屬性的日誌記錄事件建立的 LogRecord 的 __dict__"
"。然後可以隨意使用這些自定義屬性。例如，它們可以合併到記錄的消息中。例如：："

#: ../../library/logging.rst:229
#, fuzzy
msgid "would print something like"
msgstr "會印出類似的東西"

#: ../../library/logging.rst:235
#, fuzzy
msgid ""
"The keys in the dictionary passed in *extra* should not clash with the keys "
"used by the logging system. (See the section on :ref:`logrecord-attributes` "
"for more information on which keys are used by the logging system.)"
msgstr ""
"*extra* 中傳遞的字典中的鍵不應與日誌系統使用的鍵衝突。 "
"（有關日誌系統使用哪些鍵的更多資訊，請參閱 :ref:`logrecord-attributes` "
"部分。）"

#: ../../library/logging.rst:239
#, fuzzy
msgid ""
"If you choose to use these attributes in logged messages, you need to "
"exercise some care. In the above example, for instance, the :class:"
"`Formatter` has been set up with a format string which expects 'clientip' "
"and 'user' in the attribute dictionary of the :class:`LogRecord`. If these "
"are missing, the message will not be logged because a string formatting "
"exception will occur. So in this case, you always need to pass the *extra* "
"dictionary with these keys."
msgstr ""
"如果您選擇在記錄的消息中使用這些屬性，則需要謹慎行事。例如，在上面的例子中，:"
"class:`Formatter` 已經設定了一個格式字串，它需要 :class:`LogRecord` "
"的屬性字典中的 'clientip' 和 'user'。如果缺少這些，則不會記錄消息，因為會發生"
"字串格式例外。所以在這種情況下，你總是需要用這些鍵傳遞 *extra* 字典。"

#: ../../library/logging.rst:246 ../../library/logging.rst:1115
#, fuzzy
msgid ""
"While this might be annoying, this feature is intended for use in "
"specialized circumstances, such as multi-threaded servers where the same "
"code executes in many contexts, and interesting conditions which arise are "
"dependent on this context (such as remote client IP address and "
"authenticated user name, in the above example). In such circumstances, it is "
"likely that specialized :class:`Formatter`\\ s would be used with "
"particular :class:`Handler`\\ s."
msgstr ""
"雖然這可能很煩人，但此功能旨在用於特殊情況，例如多執行緒伺服器，其中相同的程"
"式碼在許多上下文中執行，並且出現的有趣條件取決於此上下文（例如遠程客戶端 IP "
"地址和經過身份驗證的上例中的使用者名）。在這種情況下，專門的 "
":class:`Formatter`\\ 可能會與特定的 :class:`Handler`\\ 一起使用。"

#: ../../library/logging.rst:253
#, fuzzy
msgid ""
"If no handler is attached to this logger (or any of its ancestors, taking "
"into account the relevant :attr:`Logger.propagate` attributes), the message "
"will be sent to the handler set on :attr:`lastResort`."
msgstr ""
"如果沒有處理程式附加到此記錄器（或其任何祖先，考慮到相關的 :attr:`Logger."
"propagate` 屬性），則消息將發送到在 :attr:`lastResort` 上設定的處理程式。"

#: ../../library/logging.rst:257 ../../library/logging.rst:1126
msgid "The *stack_info* parameter was added."
msgstr "新增 *stack_info* 參數。"

#: ../../library/logging.rst:260
#, fuzzy
msgid "The *exc_info* parameter can now accept exception instances."
msgstr "*exc_info* 參數現在可以接受例外實例。"

#: ../../library/logging.rst:263
msgid "The *stacklevel* parameter was added."
msgstr "新增 *stacklevel* 參數。"

#: ../../library/logging.rst:269
#, fuzzy
msgid ""
"Logs a message with level :const:`INFO` on this logger. The arguments are "
"interpreted as for :meth:`debug`."
msgstr "在此記錄器上記錄一條級別為 :const:`INFO` 的消息。參數被解釋為 :meth:`debug`。"

#: ../../library/logging.rst:275
#, fuzzy
msgid ""
"Logs a message with level :const:`WARNING` on this logger. The arguments are "
"interpreted as for :meth:`debug`."
msgstr "在此記錄器上記錄一條級別為 :const:`WARNING` "
"的消息。參數被解釋為 :meth:`debug`。"

#: ../../library/logging.rst:278
#, fuzzy
msgid ""
"There is an obsolete method ``warn`` which is functionally identical to "
"``warning``. As ``warn`` is deprecated, please do not use it - use "
"``warning`` instead."
msgstr ""
"有一個過時的方法 ``warn`` 在功能上與 ``warning`` 相同。由於 ``warn`` "
"已被棄用，請不要使用它 - 請改用 ``warning``。"

#: ../../library/logging.rst:284
#, fuzzy
msgid ""
"Logs a message with level :const:`ERROR` on this logger. The arguments are "
"interpreted as for :meth:`debug`."
msgstr "在此記錄器上記錄一條級別為 :const:`ERROR` "
"的消息。參數被解釋為 :meth:`debug`。"

#: ../../library/logging.rst:290
#, fuzzy
msgid ""
"Logs a message with level :const:`CRITICAL` on this logger. The arguments "
"are interpreted as for :meth:`debug`."
msgstr "在此記錄器上記錄一條級別為 :const:`CRITICAL` "
"的消息。參數被解釋為 :meth:`debug`。"

#: ../../library/logging.rst:296
#, fuzzy
msgid ""
"Logs a message with integer level *level* on this logger. The other "
"arguments are interpreted as for :meth:`debug`."
msgstr "在此記錄器上記錄一條整數級別 *level* 的消息。其他參數被解釋為 :meth:`debug`。"

#: ../../library/logging.rst:302
#, fuzzy
msgid ""
"Logs a message with level :const:`ERROR` on this logger. The arguments are "
"interpreted as for :meth:`debug`. Exception info is added to the logging "
"message. This method should only be called from an exception handler."
msgstr ""
"在此記錄器上記錄一條級別為 :const:`ERROR` 的消息。參數被解釋為 :meth:`debug`"
"。例外資訊被新增到日誌消息中。此方法只能從例外處理程式中呼叫。"

#: ../../library/logging.rst:309
#, fuzzy
msgid "Adds the specified filter *filter* to this logger."
msgstr "將指定的過濾器 *filter* 新增到此記錄器。"

#: ../../library/logging.rst:314
#, fuzzy
msgid "Removes the specified filter *filter* from this logger."
msgstr "從此記錄器中刪除指定的過濾器 *filter*。"

#: ../../library/logging.rst:319
#, fuzzy
msgid ""
"Apply this logger's filters to the record and return ``True`` if the record "
"is to be processed. The filters are consulted in turn, until one of them "
"returns a false value. If none of them return a false value, the record will "
"be processed (passed to handlers). If one returns a false value, no further "
"processing of the record occurs."
msgstr ""
"將此記錄器的過濾器應用於記錄，如果要處理記錄，則回傳 ``True``。依次查詢過濾器，"
"直到其中一個回傳錯誤值。如果它們都沒有回傳假值，則記錄將被處理（傳遞給處理程"
"序）。如果回傳假值，則不會對記錄進行進一步處理。"

#: ../../library/logging.rst:328
#, fuzzy
msgid "Adds the specified handler *hdlr* to this logger."
msgstr "將指定的處理程式 *hdlr* 新增到此記錄器。"

#: ../../library/logging.rst:333
#, fuzzy
msgid "Removes the specified handler *hdlr* from this logger."
msgstr "從此記錄器中刪除指定的處理程式 *hdlr*。"

#: ../../library/logging.rst:338
#, fuzzy
msgid ""
"Finds the caller's source filename and line number. Returns the filename, "
"line number, function name and stack information as a 4-element tuple. The "
"stack information is returned as ``None`` unless *stack_info* is ``True``."
msgstr ""
"查找呼叫者的源文件名和行號。以 4 "
"元素元組的形式回傳文件名、行號、函式名和堆疊資訊。除非 *stack_info* 為 "
"``True``，否則堆疊資訊回傳為``None``。"

#: ../../library/logging.rst:342
#, fuzzy
msgid ""
"The *stacklevel* parameter is passed from code calling the :meth:`debug` and "
"other APIs. If greater than 1, the excess is used to skip stack frames "
"before determining the values to be returned. This will generally be useful "
"when calling logging APIs from helper/wrapper code, so that the information "
"in the event log refers not to the helper/wrapper code, but to the code that "
"calls it."
msgstr ""
"*stacklevel* 參數從呼叫 debug 和其他 API 的程式碼傳遞而來。如果大於 "
"1，超出部分用於在確定要回傳的值之前跳過堆疊幀。這在從幫助程式/"
"包裝程式程式碼呼叫日誌記錄 API 時通常很有用，因此事件日誌中的資訊不是指幫助程"
"序/包裝程式程式碼，而是指呼叫它的程式碼。"

#: ../../library/logging.rst:352
#, fuzzy
msgid ""
"Handles a record by passing it to all handlers associated with this logger "
"and its ancestors (until a false value of *propagate* is found). This method "
"is used for unpickled records received from a socket, as well as those "
"created locally. Logger-level filtering is applied using :meth:`~Logger."
"filter`."
msgstr ""
"通過將記錄傳遞給與此記錄器及其祖先關聯的所有處理程式來處理記錄（直到找到 "
"*propagate* "
"的錯誤值）。此方法用於從 socket 接收到的未經處理的記錄，以及在本地建立的記錄。"
"使用 :meth:`~Logger.filter` 應用記錄器級過濾。"

#: ../../library/logging.rst:360
#, fuzzy
msgid ""
"This is a factory method which can be overridden in subclasses to create "
"specialized :class:`LogRecord` instances."
msgstr "這是一個工廠方法，可以在子類別中重寫以建立專門的 :class:`LogRecord` 實例。"

#: ../../library/logging.rst:365
#, fuzzy
msgid ""
"Checks to see if this logger has any handlers configured. This is done by "
"looking for handlers in this logger and its parents in the logger hierarchy. "
"Returns ``True`` if a handler was found, else ``False``. The method stops "
"searching up the hierarchy whenever a logger with the 'propagate' attribute "
"set to false is found - that will be the last logger which is checked for "
"the existence of handlers."
msgstr ""
"檢查此記錄器是否配置了任何處理程式。這是通過在此記錄器及其在記錄器層次結構中"
"的父項中查找處理程式來完成的。如果找到處理程式，則回傳 ``True``，否則回傳 ``False``"
"。只要發現“傳播”屬性設定為 false 的記錄器，該方法就會停止向上搜索層次結構——這"
"將是最後一個檢查處理程式是否存在的記錄器。"

#: ../../library/logging.rst:374
#, fuzzy
msgid "Loggers can now be pickled and unpickled."
msgstr "現在可以對記錄器進行 pickle 和 unpickled。"

#: ../../library/logging.rst:380
#, fuzzy
msgid "Logging Levels"
msgstr "記錄級別"

#: ../../library/logging.rst:382
#, fuzzy
msgid ""
"The numeric values of logging levels are given in the following table. These "
"are primarily of interest if you want to define your own levels, and need "
"them to have specific values relative to the predefined levels. If you "
"define a level with the same numeric value, it overwrites the predefined "
"value; the predefined name is lost."
msgstr ""
"下表給出了日誌記錄級別的數值。如果您想定義自己的級別，並且需要它們具有相對於"
"預定義級別的特定值，那麼這些主要是您感興趣的。如果您定義一個具有相同數值的級"
"別，它將覆蓋預定義的值；預定義名稱丟失。"

#: ../../library/logging.rst:389
#, fuzzy
msgid "Level"
msgstr "等級"

#: ../../library/logging.rst:389
#, fuzzy
msgid "Numeric value"
msgstr "數值"

#: ../../library/logging.rst:391
msgid "``CRITICAL``"
msgstr "``CRITICAL``"

#: ../../library/logging.rst:391
msgid "50"
msgstr "50"

#: ../../library/logging.rst:393
msgid "``ERROR``"
msgstr "``ERROR``"

#: ../../library/logging.rst:393
msgid "40"
msgstr "40"

#: ../../library/logging.rst:395
msgid "``WARNING``"
msgstr "``WARNING``"

#: ../../library/logging.rst:395
msgid "30"
msgstr "30"

#: ../../library/logging.rst:397
msgid "``INFO``"
msgstr "``INFO``"

#: ../../library/logging.rst:397
msgid "20"
msgstr "20"

#: ../../library/logging.rst:399
msgid "``DEBUG``"
msgstr "``DEBUG``"

#: ../../library/logging.rst:399
msgid "10"
msgstr "10"

#: ../../library/logging.rst:401
msgid "``NOTSET``"
msgstr "``NOTSET``"

#: ../../library/logging.rst:401
msgid "0"
msgstr "0"

#: ../../library/logging.rst:408
#, fuzzy
msgid "Handler Objects"
msgstr "處理程式物件"

#: ../../library/logging.rst:410
#, fuzzy
msgid ""
"Handlers have the following attributes and methods. Note that :class:"
"`Handler` is never instantiated directly; this class acts as a base for more "
"useful subclasses. However, the :meth:`__init__` method in subclasses needs "
"to call :meth:`Handler.__init__`."
msgstr ""
"處理程式具有以下屬性和方法。請注意 :class:`Handler` 永遠不會直接實例化；這個"
"類作為更有用的子類別的基礎。但是，子類別中的 :meth:`__init__` "
"方法需要呼叫 :meth:`Handler.__init__`。"

#: ../../library/logging.rst:419
#, fuzzy
msgid ""
"Initializes the :class:`Handler` instance by setting its level, setting the "
"list of filters to the empty list and creating a lock (using :meth:"
"`createLock`) for serializing access to an I/O mechanism."
msgstr "通過設定其級別初始化 Handler 實例，將過濾器列表設定為空列表並建立鎖（使用 "
"createLock）以序列化對 I/O 機制的訪問。"

#: ../../library/logging.rst:426
#, fuzzy
msgid ""
"Initializes a thread lock which can be used to serialize access to "
"underlying I/O functionality which may not be threadsafe."
msgstr "初始化執行緒鎖，該執行緒鎖可用於序列化對可能不是執行緒安全的基礎 I/O "
"功能的訪問。"

#: ../../library/logging.rst:432
#, fuzzy
msgid "Acquires the thread lock created with :meth:`createLock`."
msgstr "獲取使用 createLock 建立的執行緒鎖。"

#: ../../library/logging.rst:437
#, fuzzy
msgid "Releases the thread lock acquired with :meth:`acquire`."
msgstr "釋放通過 :meth:`acquire` 獲取的執行緒鎖。"

#: ../../library/logging.rst:442
#, fuzzy
msgid ""
"Sets the threshold for this handler to *level*. Logging messages which are "
"less severe than *level* will be ignored. When a handler is created, the "
"level is set to :const:`NOTSET` (which causes all messages to be processed)."
msgstr ""
"將此處理程式的閾值設定為 *level*。沒有*級別*嚴重的日誌消息將被忽略。建立處理"
"程式時，級別設定為 :const:`NOTSET`（這會導致處理所有消息）。"

#: ../../library/logging.rst:449
#, fuzzy
msgid ""
"The *level* parameter now accepts a string representation of the level such "
"as 'INFO' as an alternative to the integer constants such as :const:`INFO`."
msgstr "*level* 參數現在接受級別的字串表示形式，例如 ``INFO``，以替代整數常數，例如 "
":const:`INFO`。"

#: ../../library/logging.rst:457
#, fuzzy
msgid "Sets the :class:`Formatter` for this handler to *fmt*."
msgstr "將此處理程式的 :class:`Formatter` 設定為 *fmt*。"

#: ../../library/logging.rst:462
#, fuzzy
msgid "Adds the specified filter *filter* to this handler."
msgstr "將指定的過濾器 *filter* 新增到此處理程式。"

#: ../../library/logging.rst:467
#, fuzzy
msgid "Removes the specified filter *filter* from this handler."
msgstr "從此處理程式中刪除指定的過濾器 *filter*。"

#: ../../library/logging.rst:472
#, fuzzy
msgid ""
"Apply this handler's filters to the record and return ``True`` if the record "
"is to be processed. The filters are consulted in turn, until one of them "
"returns a false value. If none of them return a false value, the record will "
"be emitted. If one returns a false value, the handler will not emit the "
"record."
msgstr ""
"將此處理程式的過濾器應用於記錄，如果要處理記錄，則回傳 ``True``。依次查詢過濾器"
"，直到其中一個回傳錯誤值。如果它們都沒有回傳假值，則記錄將被發出。如果回傳一"
"個假值，處理程式將不會發出記錄。"

#: ../../library/logging.rst:481
#, fuzzy
msgid ""
"Ensure all logging output has been flushed. This version does nothing and is "
"intended to be implemented by subclasses."
msgstr "確保已刷新所有日誌記錄輸出。此版本不執行任何操作，旨在由子類別實作。"

#: ../../library/logging.rst:487
#, fuzzy
msgid ""
"Tidy up any resources used by the handler. This version does no output but "
"removes the handler from an internal list of handlers which is closed when :"
"func:`shutdown` is called. Subclasses should ensure that this gets called "
"from overridden :meth:`close` methods."
msgstr ""
"整理處理程式使用的所有資源。此版本不輸出任何內容，但會從內部處理程式列表中刪"
"除處理程式，該列表在呼叫 :func:`shutdown` 時關閉。子類別應確保從重寫的 close "
"方法中呼叫它。"

#: ../../library/logging.rst:495
#, fuzzy
msgid ""
"Conditionally emits the specified logging record, depending on filters which "
"may have been added to the handler. Wraps the actual emission of the record "
"with acquisition/release of the I/O thread lock."
msgstr "根據可能已新增到處理程式的過濾器，有條件地發出指定的日誌記錄。使用 I/O "
"執行緒鎖的獲取/釋放包裝記錄的實際發射。"

#: ../../library/logging.rst:502
#, fuzzy
msgid ""
"This method should be called from handlers when an exception is encountered "
"during an :meth:`emit` call. If the module-level attribute "
"``raiseExceptions`` is ``False``, exceptions get silently ignored. This is "
"what is mostly wanted for a logging system - most users will not care about "
"errors in the logging system, they are more interested in application "
"errors. You could, however, replace this with a custom handler if you wish. "
"The specified record is the one which was being processed when the exception "
"occurred. (The default value of ``raiseExceptions`` is ``True``, as that is "
"more useful during development)."
msgstr ""
"當在 :meth:`emit` 呼叫期間遇到例外時，應該從處理程式呼叫此方法。如果模組級屬"
"性 ``raiseExceptions`` 為 ``False``，例外會被忽略。這是日誌系統最需要的——大多數使用"
"者不會關心日誌系統中的錯誤，他們對應用程式錯誤更感興趣。但是，您可以根據需要"
"將其替換為自定義處理程式。指定的記錄是發生例外時正在處理的記錄。 "
"（``raiseExceptions`` 的預設值為 ``True``，因為這在開發過程中更有用）。"

#: ../../library/logging.rst:515
#, fuzzy
msgid ""
"Do formatting for a record - if a formatter is set, use it. Otherwise, use "
"the default formatter for the module."
msgstr "對記錄進行格式化 - "
"如果設定了格式化程式，請使用它。否則，使用模組的預設格式化程式。"

#: ../../library/logging.rst:521
#, fuzzy
msgid ""
"Do whatever it takes to actually log the specified logging record. This "
"version is intended to be implemented by subclasses and so raises a :exc:"
"`NotImplementedError`."
msgstr "盡一切可能實際記錄指定的日誌記錄。此版本旨在由子類別實作，因此引發了一個 "
"NotImplementedError。"

#: ../../library/logging.rst:525
#, fuzzy
msgid ""
"This method is called after a handler-level lock is acquired, which is "
"released after this method returns. When you override this method, note that "
"you should be careful when calling anything that invokes other parts of the "
"logging API which might do locking, because that might result in a deadlock. "
"Specifically:"
msgstr ""
"在獲取處理程式級別的鎖後呼叫此方法，該鎖在此方法回傳後釋放。當您覆蓋此方法時"
"，請注意，在呼叫任何可能會鎖定的日誌記錄 API "
"的其他部分時，您應該小心，因為這可能會導致死鎖。具體來說："

#: ../../library/logging.rst:531
#, fuzzy
msgid ""
"Logging configuration APIs acquire the module-level lock, and then "
"individual handler-level locks as those handlers are configured."
msgstr "日誌記錄配置 API "
"獲取模組級鎖，然後在配置這些處理程式時獲取單獨的處理程式級鎖。"

#: ../../library/logging.rst:534
#, fuzzy
msgid ""
"Many logging APIs lock the module-level lock. If such an API is called from "
"this method, it could cause a deadlock if a configuration call is made on "
"another thread, because that thread will try to acquire the module-level "
"lock *before* the handler-level lock, whereas this thread tries to acquire "
"the module-level lock *after* the handler-level lock (because in this "
"method, the handler-level lock has already been acquired)."
msgstr ""
"許多日誌記錄 API 鎖定模組級鎖。如果從這個方法呼叫這樣的 API，如果在另一個執行"
"緒上進行配置呼叫，它可能會導致死鎖，因為該執行緒將嘗試在處理程式級鎖*之前*獲"
"取模組級鎖，而該執行緒嘗試在處理程式級鎖*之後*獲取模組級鎖（因為在此方法中，"
"已經獲取了處理程式級鎖）。"

#: ../../library/logging.rst:541
#, fuzzy
msgid ""
"For a list of handlers included as standard, see :mod:`logging.handlers`."
msgstr "有關作為標準包含的處理程式列表，請參閱 :mod:`logging.handlers`。"

#: ../../library/logging.rst:546
#, fuzzy
msgid "Formatter Objects"
msgstr "格式化程式物件"

#: ../../library/logging.rst:550
#, fuzzy
msgid ""
":class:`Formatter` objects have the following attributes and methods. They "
"are responsible for converting a :class:`LogRecord` to (usually) a string "
"which can be interpreted by either a human or an external system. The base :"
"class:`Formatter` allows a formatting string to be specified. If none is "
"supplied, the default value of ``'%(message)s'`` is used, which just "
"includes the message in the logging call. To have additional items of "
"information in the formatted output (such as a timestamp), keep reading."
msgstr ""
":class:`Formatter` 物件具有以下屬性和方法。他們負責將 :class:`LogRecord` "
"轉換為（通常）可以由人類或外部系統解釋的字串。基底類別：`Formatter` "
"允許指定格式化字串。如果未提供，則使用預設值 ``'%(message)s'``，它僅在日誌記"
"錄呼叫中包含消息。要在格式化輸出中包含其他資訊項（例如時間戳），請繼續閱讀。"

#: ../../library/logging.rst:558
#, fuzzy
msgid ""
"A Formatter can be initialized with a format string which makes use of "
"knowledge of the :class:`LogRecord` attributes - such as the default value "
"mentioned above making use of the fact that the user's message and arguments "
"are pre-formatted into a :class:`LogRecord`'s *message* attribute.  This "
"format string contains standard Python %-style mapping keys. See section :"
"ref:`old-string-formatting` for more information on string formatting."
msgstr ""
"Formatter 可以使用格式字串進行初始化，格式字串利用了 :class:`LogRecord` "
"屬性的知識——例如上面提到的預設值，利用了使用者的消息和參數被預先格式化為 :"
"class 的事實:`LogRecord` 的 *message* 屬性。此格式字串包含標準 Python % "
"樣式的映射鍵。有關字串格式的更多資訊，請參閱 :ref:`old-string-formatting` "
"部分。"

#: ../../library/logging.rst:565
#, fuzzy
msgid ""
"The useful mapping keys in a :class:`LogRecord` are given in the section on :"
"ref:`logrecord-attributes`."
msgstr ":class:`LogRecord` 中有用的映射鍵在 :ref:`logrecord-attributes` 部分給出。"

#: ../../library/logging.rst:571
#, fuzzy
msgid ""
"Returns a new instance of the :class:`Formatter` class.  The instance is "
"initialized with a format string for the message as a whole, as well as a "
"format string for the date/time portion of a message.  If no *fmt* is "
"specified, ``'%(message)s'`` is used.  If no *datefmt* is specified, a "
"format is used which is described in the :meth:`formatTime` documentation."
msgstr ""
"回傳 :class:`Formatter` 類的新實例。該實例使用整個消息的格式字串以及消息的日"
"期/時間部分的格式字串進行初始化。如果未指定 *fmt*，則使用 ``'%(message)s'``。"
"如果未指定 *datefmt*，則使用格式，格式在 :meth:`formatTime` 文檔中有描述。"

#: ../../library/logging.rst:577
#, fuzzy
msgid ""
"The *style* parameter can be one of '%', '{' or '$' and determines how the "
"format string will be merged with its data: using one of %-formatting, :meth:"
"`str.format` or :class:`string.Template`. This only applies to the format "
"string *fmt* (e.g. ``'%(message)s'`` or ``{message}``), not to the actual "
"log messages passed to ``Logger.debug`` etc; see :ref:`formatting-styles` "
"for more information on using {- and $-formatting for log messages."
msgstr ""
"*style* 參數可以是 ``%``、 ``{``或 ``$``之一，並確定格式字串如何與其資料合併：使用 "
"%-formatting、str.format 或 :class:`string.Template`。這僅適用於格式字串 "
"*fmt*（例如 ``'%(message)s'`` 或 ``{message}``），不適用於傳遞給 ``Logger."
"debug`` 等的實際日誌消息；有關使用 {- 和 $-formatting 日誌消息的更多資訊，"
"請參閱 :ref:`formatting-styles`。"

#: ../../library/logging.rst:585
#, fuzzy
msgid ""
"The *defaults* parameter can be a dictionary with default values to use in "
"custom fields. For example: ``logging.Formatter('%(ip)s %(message)s', "
"defaults={\"ip\": None})``"
msgstr ""
"*defaults* 參數可以是具有預設值的字典，以在自定義欄位中使用。例如：``logging."
"Formatter(\\'%(ip)s %(message)s\\', defaults={\"ip\": None})``"

#: ../../library/logging.rst:589
msgid "The *style* parameter was added."
msgstr "新增 *style* 參數。"

#: ../../library/logging.rst:592
#, fuzzy
msgid ""
"The *validate* parameter was added. Incorrect or mismatched style and fmt "
"will raise a ``ValueError``. For example: ``logging.Formatter('%(asctime)s - "
"%(message)s', style='{')``."
msgstr ""
"新增了 *validate* 參數。不正確或不匹配的樣式和 fmt "
"將引發 ``ValueError``。例如：``logging.Formatter('%(asctime)s - %(message)s', "
"style='{')``。"

#: ../../library/logging.rst:597
msgid "The *defaults* parameter was added."
msgstr "新增 *defaults* 參數。"

#: ../../library/logging.rst:602
#, fuzzy
msgid ""
"The record's attribute dictionary is used as the operand to a string "
"formatting operation. Returns the resulting string. Before formatting the "
"dictionary, a couple of preparatory steps are carried out. The *message* "
"attribute of the record is computed using *msg* % *args*. If the formatting "
"string contains ``'(asctime)'``, :meth:`formatTime` is called to format the "
"event time. If there is exception information, it is formatted using :meth:"
"`formatException` and appended to the message. Note that the formatted "
"exception information is cached in attribute *exc_text*. This is useful "
"because the exception information can be pickled and sent across the wire, "
"but you should be careful if you have more than one :class:`Formatter` "
"subclass which customizes the formatting of exception information. In this "
"case, you will have to clear the cached value (by setting the *exc_text* "
"attribute to ``None``) after a formatter has done its formatting, so that "
"the next formatter to handle the event doesn't use the cached value, but "
"recalculates it afresh."
msgstr ""
"記錄的屬性字典用作字串格式化操作的操作數。回傳結果字串。在格式化字典之前，需"
"要執行幾個準備步驟。記錄的 *message* 屬性是使用 *msg* % *args* 計算的。"
"如果格式化字串包含 ``'(asctime)'``，則會呼叫 :meth:`formatTime` "
"來格式化事件時間。如果有例外資訊，則使用 :meth:`formatException` "
"格式化並附加到消息中。請注意，格式化的例外資訊快取在屬性 *exc_text* "
"中。這很有用，因為例外資訊可以被 pickle 並通過網絡發送，"
"但如果您有多個自定義例外資訊格式的 :class:`Formatter` "
"子類別，您應該小心。在這種情況下，您必須在格式化程式完成格式化後清除快取值（"
"通過將 *exc_text* "
"屬性設定為 ``None`` ），以便下一個處理事件的格式化程式不使用快取值，但重新計算它。"

#: ../../library/logging.rst:618
#, fuzzy
msgid ""
"If stack information is available, it's appended after the exception "
"information, using :meth:`formatStack` to transform it if necessary."
msgstr "如果堆疊資訊可用，它會附加在例外資訊之後，必要時使用 :meth:`formatStack` "
"對其進行轉換。"

#: ../../library/logging.rst:624
#, fuzzy
msgid ""
"This method should be called from :meth:`format` by a formatter which wants "
"to make use of a formatted time. This method can be overridden in formatters "
"to provide for any specific requirement, but the basic behavior is as "
"follows: if *datefmt* (a string) is specified, it is used with :func:`time."
"strftime` to format the creation time of the record. Otherwise, the format "
"'%Y-%m-%d %H:%M:%S,uuu' is used, where the uuu part is a millisecond value "
"and the other letters are as per the :func:`time.strftime` documentation.  "
"An example time in this format is ``2003-01-23 00:29:50,411``.  The "
"resulting string is returned."
msgstr ""
"這個方法應該由想要使用格式化時間的格式化程式從 :meth:`format` "
"呼叫。可以在格式化程式中覆蓋此方法以提供任何特定要求，但基本行為如下："
"如果指定了 *datefmt*（字串），則它與 :func:`time.strftime` "
"一起使用以格式化建立時間的記錄。否則，使用格式 '%Y-%m-%d %H:%M:%S,uuu'，其中 "
"uuu 部分是毫秒值，其他字母按照 :func:`time.strftime ` 文檔。"
"這種格式的示例時間是 ``2003-01-23 00:29:50,411``。回傳結果字串。"

#: ../../library/logging.rst:634
#, fuzzy
msgid ""
"This function uses a user-configurable function to convert the creation time "
"to a tuple. By default, :func:`time.localtime` is used; to change this for a "
"particular formatter instance, set the ``converter`` attribute to a function "
"with the same signature as :func:`time.localtime` or :func:`time.gmtime`. To "
"change it for all formatters, for example if you want all logging times to "
"be shown in GMT, set the ``converter`` attribute in the ``Formatter`` class."
msgstr ""
"此函式使用使用者可配置的函式將建立時間轉換為元組。預設情況下，使用 "
":func:`time.localtime`；要為特定的格式化程式實例更改此設定，請將 "
"``converter`` 屬性設定為具有與 time.localtime 或 time.gmtime "
"相同簽名的函式。要為所有格式化程式更改它，例如，"
"如果您希望所有日誌記錄時間都以 GMT 顯示，請在 ``Formatter`` 類中設定 "
"``converter`` 屬性。"

#: ../../library/logging.rst:642
#, fuzzy
msgid ""
"Previously, the default format was hard-coded as in this example: "
"``2010-09-06 22:38:15,292`` where the part before the comma is handled by a "
"strptime format string (``'%Y-%m-%d %H:%M:%S'``), and the part after the "
"comma is a millisecond value. Because strptime does not have a format "
"placeholder for milliseconds, the millisecond value is appended using "
"another format string, ``'%s,%03d'`` --- and both of these format strings "
"have been hardcoded into this method. With the change, these strings are "
"defined as class-level attributes which can be overridden at the instance "
"level when desired. The names of the attributes are ``default_time_format`` "
"(for the strptime format string) and ``default_msec_format`` (for appending "
"the millisecond value)."
msgstr ""
"以前，預設格式是硬編碼的，如本例所示：``2010-09-06 22:38:15,292`` "
"其中逗號前的部分由 strptime 格式字串處理（``'%Y-%m -%d "
"%H:%M:%S'``)，逗號後面的部分是毫秒值。因為 strptime "
"沒有毫秒的格式佔位符，所以使用另一個格式字串附加毫秒值，``'%s,%03d'`` --- 並"
"且這兩個格式字串都已硬編碼到此方法中。通過更改，這些字串被定義為類級別的屬性"
"，可以在需要時在實例級別覆蓋這些屬性。屬性的名稱是“default_time_format”（"
"用於 strptime 格式字串）和“default_msec_format”（用於附加毫秒值）。"

#: ../../library/logging.rst:655
#, fuzzy
msgid "The ``default_msec_format`` can be ``None``."
msgstr "``default_msec_format`` 可以是``None``。"

#: ../../library/logging.rst:660
#, fuzzy
msgid ""
"Formats the specified exception information (a standard exception tuple as "
"returned by :func:`sys.exc_info`) as a string. This default implementation "
"just uses :func:`traceback.print_exception`. The resulting string is "
"returned."
msgstr ""
"將指定的例外資訊（由 :func:`sys.exc_info` 回傳的標準例外元組）格式化為字串。"
"這個預設實作只使用 :func:`traceback.print_exception`。回傳結果字串。"

#: ../../library/logging.rst:667
#, fuzzy
msgid ""
"Formats the specified stack information (a string as returned by :func:"
"`traceback.print_stack`, but with the last newline removed) as a string. "
"This default implementation just returns the input value."
msgstr ""
"將指定的堆疊資訊（由 :func:`traceback.print_stack` "
"回傳的字串，但刪除了最後一個換行符）格式化為字串。此預設實作僅回傳輸入值。"

#: ../../library/logging.rst:673
#, fuzzy
msgid ""
"A base formatter class suitable for subclassing when you want to format a "
"number of records. You can pass a :class:`Formatter` instance which you want "
"to use to format each line (that corresponds to a single record). If not "
"specified, the default formatter (which just outputs the event message) is "
"used as the line formatter."
msgstr ""
"當您想要格式化多個記錄時，適合子類別化的基本格式化程式類。你可以傳遞一個 "
":class:`Formatter` 實例，你想用它來格式化每一行（對應於一條記錄）。如果未指定"
"，則使用預設格式化程式（僅輸出事件消息）作為行格式化程式。"

#: ../../library/logging.rst:681
#, fuzzy
msgid ""
"Return a header for a list of *records*. The base implementation just "
"returns the empty string. You will need to override this method if you want "
"specific behaviour, e.g. to show the count of records, a title or a "
"separator line."
msgstr "回傳 *records* 列表的標題。基本實作只回傳空字串。如果您想要特定的行為，例如，"
"您將需要重寫此方法顯示記錄數、標題或分隔線。"

#: ../../library/logging.rst:688
#, fuzzy
msgid ""
"Return a footer for a list of *records*. The base implementation just "
"returns the empty string. You will need to override this method if you want "
"specific behaviour, e.g. to show the count of records or a separator line."
msgstr "回傳 *records* 列表的頁腳。基本實作只回傳空字串。如果您想要特定的行為，例如，"
"您將需要重寫此方法顯示記錄數或分隔線。"

#: ../../library/logging.rst:695
#, fuzzy
msgid ""
"Return formatted text for a list of *records*. The base implementation just "
"returns the empty string if there are no records; otherwise, it returns the "
"concatenation of the header, each record formatted with the line formatter, "
"and the footer."
msgstr "回傳*記錄*列表的格式化文本。如果沒有記錄，基本實作只回傳空字串；否則，它回傳"
"標題的串聯，每條記錄用行格式化程式格式化，以及頁腳。"

#: ../../library/logging.rst:703
#, fuzzy
msgid "Filter Objects"
msgstr "過濾物件"

#: ../../library/logging.rst:705
#, fuzzy
msgid ""
"``Filters`` can be used by ``Handlers`` and ``Loggers`` for more "
"sophisticated filtering than is provided by levels. The base filter class "
"only allows events which are below a certain point in the logger hierarchy. "
"For example, a filter initialized with 'A.B' will allow events logged by "
"loggers 'A.B', 'A.B.C', 'A.B.C.D', 'A.B.D' etc. but not 'A.BB', 'B.A.B' etc. "
"If initialized with the empty string, all events are passed."
msgstr ""
"``Handlers`` 和 ``Loggers`` 可以使用 ``Filters`` 進行比級別提供的更複雜的過濾"
"。基本過濾器類僅允許記錄器層次結構中特定點以下的事件。例如，使用“A."
"B”初始化的過濾器將允許記錄器“A.B”、“A.B.C”、“A.B.C.D”、“A.B."
"D”等記錄事件，但不允許“A.BB”、“B.A."
"B”等記錄事件。如果用空字串初始化，則傳遞所有事件。"

#: ../../library/logging.rst:715
#, fuzzy
msgid ""
"Returns an instance of the :class:`Filter` class. If *name* is specified, it "
"names a logger which, together with its children, will have its events "
"allowed through the filter. If *name* is the empty string, allows every "
"event."
msgstr ""
"回傳 :class:`Filter` 類的一個實例。如果指定了 *name* "
"，它會命名一個記錄器，該記錄器及其子項將允許其事件通過過濾器。如果 *name* "
"是空字串，則允許每個事件。"

#: ../../library/logging.rst:722
#, fuzzy
msgid ""
"Is the specified record to be logged? Returns zero for no, nonzero for yes. "
"If deemed appropriate, the record may be modified in-place by this method."
msgstr "是否記錄指定的記錄？否回傳零，是回傳非零。如果認為合適，可以通過此方法就地修"
"改記錄。"

#: ../../library/logging.rst:726
#, fuzzy
msgid ""
"Note that filters attached to handlers are consulted before an event is "
"emitted by the handler, whereas filters attached to loggers are consulted "
"whenever an event is logged (using :meth:`debug`, :meth:`info`, etc.), "
"before sending an event to handlers. This means that events which have been "
"generated by descendant loggers will not be filtered by a logger's filter "
"setting, unless the filter has also been applied to those descendant loggers."
msgstr ""
"請注意，附加到處理程式的過濾器在處理程式發出事件之前會被查詢，而附加到記錄器"
"的過濾器會在記錄事件時被查詢（使用 debug、info 等），之前向處理程式發送事件。"
"這意味著由後代記錄器生成的事件不會被記錄器的過濾器設定過濾，除非過濾器也已應"
"用於那些後代記錄器。"

#: ../../library/logging.rst:733
#, fuzzy
msgid ""
"You don't actually need to subclass ``Filter``: you can pass any instance "
"which has a ``filter`` method with the same semantics."
msgstr "您實際上不需要子類別化 ``Filter``：您可以傳遞具有相同語義的 ``filter``方法的任何實"
"例。"

#: ../../library/logging.rst:736
#, fuzzy
msgid ""
"You don't need to create specialized ``Filter`` classes, or use other "
"classes with a ``filter`` method: you can use a function (or other callable) "
"as a filter. The filtering logic will check to see if the filter object has "
"a ``filter`` attribute: if it does, it's assumed to be a ``Filter`` and its :"
"meth:`~Filter.filter` method is called. Otherwise, it's assumed to be a "
"callable and called with the record as the single parameter. The returned "
"value should conform to that returned by :meth:`~Filter.filter`."
msgstr ""
"您不需要建立專門的 ``Filter``類，或使用其他帶有 ``filter``方法的類：您可以使用函式"
"（或其他可呼叫函式）作為過濾器。過濾邏輯將檢查過濾器對像是否具有 ``filter`` "
"屬性：如果有，則假定它是 ``Filter`` 並呼叫其 :meth:`~Filter.filter` "
"方法。否則，它被假定為可呼叫的，並使用記錄作為單個參數進行呼叫。回傳值應符合 "
":meth:`~Filter.filter` 回傳的值。"

#: ../../library/logging.rst:746
#, fuzzy
msgid ""
"Although filters are used primarily to filter records based on more "
"sophisticated criteria than levels, they get to see every record which is "
"processed by the handler or logger they're attached to: this can be useful "
"if you want to do things like counting how many records were processed by a "
"particular logger or handler, or adding, changing or removing attributes in "
"the :class:`LogRecord` being processed. Obviously changing the LogRecord "
"needs to be done with some care, but it does allow the injection of "
"contextual information into logs (see :ref:`filters-contextual`)."
msgstr ""
"雖然過濾器主要用於根據比級別更複雜的標準過濾記錄，但它們可以查看由它們所附加"
"的處理程式或記錄器處理的每條記錄：如果您想做一些事情，比如計算有多少，這可能"
"很有用記錄由特定的記錄器或處理程式處理，或者在正在處理的 LogRecord "
"中新增、更改或刪除屬性。顯然更改 LogRecord "
"需要小心，但它確實允許將上下文資訊注入日誌（請參閱 :ref:`filters-"
"contextual`）。"

#: ../../library/logging.rst:759
msgid "LogRecord Objects"
msgstr "LogRecord 物件"

#: ../../library/logging.rst:761
#, fuzzy
msgid ""
":class:`LogRecord` instances are created automatically by the :class:"
"`Logger` every time something is logged, and can be created manually via :"
"func:`makeLogRecord` (for example, from a pickled event received over the "
"wire)."
msgstr ""
":class:`LogRecord` 實例在每次記錄內容時由 :class:`Logger` 自動建立，"
"並且可以通過 :func:`makeLogRecord` 手動建立（例如，從通過線路接收的 pickled "
"事件）。"

#: ../../library/logging.rst:769
#, fuzzy
msgid "Contains all the information pertinent to the event being logged."
msgstr "包含與正在記錄的事件相關的所有資訊。"

#: ../../library/logging.rst:771
#, fuzzy
msgid ""
"The primary information is passed in *msg* and *args*, which are combined "
"using ``msg % args`` to create the :attr:`!message` attribute of the record."
msgstr ""
"主要資訊在 *msg* 和 *args* 中傳遞，它們使用 ``msg % args`` "
"組合以建立記錄的 :attr:`!message` 屬性。"

#: ../../library/logging.rst:0
#, fuzzy
msgid "Parameters"
msgstr "參數"

#: ../../library/logging.rst:775
#, fuzzy
msgid ""
"The name of the logger used to log the event represented by this :class:`!"
"LogRecord`. Note that the logger name in the :class:`!LogRecord` will always "
"have this value, even though it may be emitted by a handler attached to a "
"different (ancestor) logger."
msgstr ""
"用於記錄此 :class:`!LogRecord` "
"表示的事件的記錄器的名稱。請注意，:class:`!LogRecord` 中的記錄器名稱將始終具"
"有此值，即使它可能由附加到不同（祖先）記錄器的處理程式發出。"

#: ../../library/logging.rst:783
#, fuzzy
msgid ""
"The :ref:`numeric level <levels>` of the logging event (such as ``10`` for "
"``DEBUG``, ``20`` for ``INFO``, etc). Note that this is converted to *two* "
"attributes of the LogRecord: :attr:`!levelno` for the numeric value and :"
"attr:`!levelname` for the corresponding level name."
msgstr ""
"日誌事件的 :ref:`numeric level <levels>`（例如 ``DEBUG`` 為 ``10``，``INFO`` "
"為 ``20`` 等）。請注意，這將轉換為 LogRecord 的 *兩個* 屬性：:attr:`!levelno`"
" 表示數值，:attr:`!levelname` 表示相應的級別名稱。"

#: ../../library/logging.rst:790
#, fuzzy
msgid ""
"The full string path of the source file where the logging call was made."
msgstr "進行日誌記錄呼叫的源文件的完整字串路徑。"

#: ../../library/logging.rst:794
#, fuzzy
msgid "The line number in the source file where the logging call was made."
msgstr "進行記錄呼叫的源文件中的行號。"

#: ../../library/logging.rst:798
#, fuzzy
msgid ""
"The event description message, which can be a %-format string with "
"placeholders for variable data, or an arbitrary object (see :ref:`arbitrary-"
"object-messages`)."
msgstr "事件描述消息，可以是帶有變數資料佔位符的 % 格式字串，也可以是任意物件（參見 "
"arbitrary-object-messages）。"

#: ../../library/logging.rst:803
#, fuzzy
msgid ""
"Variable data to merge into the *msg* argument to obtain the event "
"description."
msgstr "可變資料合併到 *msg* 參數中以獲得事件描述。"

#: ../../library/logging.rst:807
#, fuzzy
msgid ""
"An exception tuple with the current exception information, as returned by :"
"func:`sys.exc_info`, or ``None`` if no exception information is available."
msgstr "包含當前例外資訊的例外元組，由 :func:`sys.exc_info` "
"回傳，如果沒有可用的例外資訊，則為 ``None``。"

#: ../../library/logging.rst:812
#, fuzzy
msgid ""
"The name of the function or method from which the logging call was invoked."
msgstr "呼叫日誌記錄呼叫的函式或方法的名稱。"

#: ../../library/logging.rst:816
#, fuzzy
msgid ""
"A text string representing stack information from the base of the stack in "
"the current thread, up to the logging call."
msgstr "一個文本字串，表示從當前執行緒中的堆疊底部到日誌記錄呼叫的堆疊資訊。"

#: ../../library/logging.rst:823
#, fuzzy
msgid ""
"Returns the message for this :class:`LogRecord` instance after merging any "
"user-supplied arguments with the message. If the user-supplied message "
"argument to the logging call is not a string, :func:`str` is called on it to "
"convert it to a string. This allows use of user-defined classes as messages, "
"whose ``__str__`` method can return the actual format string to be used."
msgstr ""
"在將任何使用者提供的參數與消息合併後，回傳此 LogRecord "
"實例的消息。如果使用者為日誌記錄呼叫提供的消息參數不是字串，則會對其呼叫 "
":func:`str` 以將其轉換為字串。這允許使用使用者定義的類作為消息，其 __str__ "
"方法可以回傳要使用的實際格式字串。"

#: ../../library/logging.rst:830
#, fuzzy
msgid ""
"The creation of a :class:`LogRecord` has been made more configurable by "
"providing a factory which is used to create the record. The factory can be "
"set using :func:`getLogRecordFactory` and :func:`setLogRecordFactory` (see "
"this for the factory's signature)."
msgstr ""
"通過提供用於建立記錄的工廠，LogRecord 的建立變得更加可配置。可以使用 "
":func:`getLogRecordFactory` 和 :func:`setLogRecordFactory` "
"設定工廠（請參閱工廠簽名）。"

#: ../../library/logging.rst:836
#, fuzzy
msgid ""
"This functionality can be used to inject your own values into a :class:"
"`LogRecord` at creation time. You can use the following pattern::"
msgstr "此功能可用於在建立時將您自己的值注入 :class:`LogRecord`。您可以使用以下模式："

#: ../../library/logging.rst:848
#, fuzzy
msgid ""
"With this pattern, multiple factories could be chained, and as long as they "
"don't overwrite each other's attributes or unintentionally overwrite the "
"standard attributes listed above, there should be no surprises."
msgstr "使用這種模式，可以鏈接多個工廠，只要它們不覆蓋彼此的屬性或無意中覆蓋上面列出"
"的標準屬性，就不會出現意外。"

#: ../../library/logging.rst:857
#, fuzzy
msgid "LogRecord attributes"
msgstr "日誌記錄屬性"

#: ../../library/logging.rst:859
#, fuzzy
msgid ""
"The LogRecord has a number of attributes, most of which are derived from the "
"parameters to the constructor. (Note that the names do not always correspond "
"exactly between the LogRecord constructor parameters and the LogRecord "
"attributes.) These attributes can be used to merge data from the record into "
"the format string. The following table lists (in alphabetical order) the "
"attribute names, their meanings and the corresponding placeholder in a %-"
"style format string."
msgstr ""
"LogRecord 有許多屬性，其中大部分是從構造函式的參數派生的。 （請注意，"
"LogRecord 構造函式參數和 LogRecord 屬性之間的名稱並不總是完全對應。）這些屬性"
"可用於將記錄中的資料合併到格式字串中。下表（按字母順序）列出了屬性名稱、"
"它們的含義以及 % 樣式格式字串中的相應佔位符。"

#: ../../library/logging.rst:867
#, fuzzy
msgid ""
"If you are using {}-formatting (:func:`str.format`), you can use ``{attrname}"
"`` as the placeholder in the format string. If you are using $-formatting (:"
"class:`string.Template`), use the form ``${attrname}``. In both cases, of "
"course, replace ``attrname`` with the actual attribute name you want to use."
msgstr ""
"如果您使用 {} 格式 (:func:`str.format`)，您可以使用 ``{attrname}`` "
"作為格式字串中的佔位符。如果您使用 $-formatting (:class:`string.Template`)，"
"請使用 ``${attrname}`` 形式。當然，在這兩種情況下，將 ``attrname`` "
"替換為您要使用的實際屬性名稱。"

#: ../../library/logging.rst:873
#, fuzzy
msgid ""
"In the case of {}-formatting, you can specify formatting flags by placing "
"them after the attribute name, separated from it with a colon. For example: "
"a placeholder of ``{msecs:03d}`` would format a millisecond value of ``4`` "
"as ``004``. Refer to the :meth:`str.format` documentation for full details "
"on the options available to you."
msgstr ""
"在 {} 格式化的情況下，您可以通過將它們放在屬性名稱之後來指定格式化旗標，並用"
"冒號將其分隔開。例如：``{msecs:03d}`` 的佔位符會將毫秒值 ``4`` 格式化為 "
"``004``。有關可用選項的完整詳細資訊，請參閱 :meth:`str.format` 文檔。"

#: ../../library/logging.rst:880
#, fuzzy
msgid "Attribute name"
msgstr "屬性名稱"

#: ../../library/logging.rst:880 ../../library/logging.rst:1271
msgid "Format"
msgstr "格式"

#: ../../library/logging.rst:880 ../../library/logging.rst:1271
msgid "Description"
msgstr "描述"

#: ../../library/logging.rst:0 ../../library/logging.rst:882
#, fuzzy
msgid "args"
msgstr "參數"

#: ../../library/logging.rst:882 ../../library/logging.rst:896
#: ../../library/logging.rst:924 ../../library/logging.rst:942
#, fuzzy
msgid "You shouldn't need to format this yourself."
msgstr "您不需要自己格式化。"

#: ../../library/logging.rst:882
#, fuzzy
msgid ""
"The tuple of arguments merged into ``msg`` to produce ``message``, or a dict "
"whose values are used for the merge (when there is only one argument, and it "
"is a dictionary)."
msgstr "參數元組合併到 ``msg`` 中以產生``message``，或者一個其值用於合併的字典（當只"
"有一個參數時，它是一個字典）。"

#: ../../library/logging.rst:887
#, fuzzy
msgid "asctime"
msgstr "時間"

#: ../../library/logging.rst:887
msgid "``%(asctime)s``"
msgstr "``%(asctime)s``"

#: ../../library/logging.rst:887
#, fuzzy
msgid ""
"Human-readable time when the :class:`LogRecord` was created.  By default "
"this is of the form '2003-07-08 16:49:45,896' (the numbers after the comma "
"are millisecond portion of the time)."
msgstr ""
"建立 :class:`LogRecord` 時的人類可讀時間。預設情況下，它的格式為“2003-07-08 "
"16:49:45,896”（逗號後的數字是時間的毫秒部分）。"

#: ../../library/logging.rst:893
#, fuzzy
msgid "created"
msgstr "建立"

#: ../../library/logging.rst:893
msgid "``%(created)f``"
msgstr "``%(created)f``"

#: ../../library/logging.rst:893
#, fuzzy
msgid ""
"Time when the :class:`LogRecord` was created (as returned by :func:`time."
"time`)."
msgstr "建立 :class:`LogRecord` 的時間（由 :func:`time.time` 回傳）。"

#: ../../library/logging.rst:0 ../../library/logging.rst:896
msgid "exc_info"
msgstr "exc_info"

#: ../../library/logging.rst:896
#, fuzzy
msgid ""
"Exception tuple (à la ``sys.exc_info``) or, if no exception has occurred, "
"``None``."
msgstr "例外元組（la ``sys.exc_info``）或者，如果沒有發生例外，則為``None``。"

#: ../../library/logging.rst:899
#, fuzzy
msgid "filename"
msgstr "文件名"

#: ../../library/logging.rst:899
msgid "``%(filename)s``"
msgstr "``%(filename)s``"

#: ../../library/logging.rst:899
#, fuzzy
msgid "Filename portion of ``pathname``."
msgstr "``pathname`` 的文件名部分。"

#: ../../library/logging.rst:901
#, fuzzy
msgid "funcName"
msgstr "函式名"

#: ../../library/logging.rst:901
msgid "``%(funcName)s``"
msgstr "``%(funcName)s``"

#: ../../library/logging.rst:901
#, fuzzy
msgid "Name of function containing the logging call."
msgstr "包含日誌記錄呼叫的函式名稱。"

#: ../../library/logging.rst:903
#, fuzzy
msgid "levelname"
msgstr "關卡名稱"

#: ../../library/logging.rst:903
msgid "``%(levelname)s``"
msgstr "``%(levelname)s``"

#: ../../library/logging.rst:903
#, fuzzy
msgid ""
"Text logging level for the message (``'DEBUG'``, ``'INFO'``, ``'WARNING'``, "
"``'ERROR'``, ``'CRITICAL'``)."
msgstr ""
"消息的文本日誌記錄級別（``'DEBUG'``、``'INFO'``、``'WARNING'``、``'ERROR'``、"
"``'CRITICAL'``）。"

#: ../../library/logging.rst:907
#, fuzzy
msgid "levelno"
msgstr "水平號"

#: ../../library/logging.rst:907
msgid "``%(levelno)s``"
msgstr "``%(levelno)s``"

#: ../../library/logging.rst:907
#, fuzzy
msgid ""
"Numeric logging level for the message (:const:`DEBUG`, :const:`INFO`, :const:"
"`WARNING`, :const:`ERROR`, :const:`CRITICAL`)."
msgstr ""
"消息的數字日誌記錄級別（ :const:`DEBUG`， :const:`INFO`， :const:`WARNING`"
"， :const:`ERROR`， :const:`CRITICAL`）。"

#: ../../library/logging.rst:912
#, fuzzy
msgid "lineno"
msgstr "線諾"

#: ../../library/logging.rst:912
msgid "``%(lineno)d``"
msgstr "``%(lineno)d``"

#: ../../library/logging.rst:912
#, fuzzy
msgid "Source line number where the logging call was issued (if available)."
msgstr "發出日誌記錄呼叫的源行號（如果可用）。"

#: ../../library/logging.rst:915
#, fuzzy
msgid "message"
msgstr "資訊"

#: ../../library/logging.rst:915
msgid "``%(message)s``"
msgstr "``%(message)s``"

#: ../../library/logging.rst:915
#, fuzzy
msgid ""
"The logged message, computed as ``msg % args``. This is set when :meth:"
"`Formatter.format` is invoked."
msgstr "記錄的消息，計算為“msg % args”。這是在呼叫 :meth:`Formatter.format` "
"時設定的。"

#: ../../library/logging.rst:919
msgid "module"
msgstr "模組"

#: ../../library/logging.rst:919
msgid "``%(module)s``"
msgstr "``%(module)s``"

#: ../../library/logging.rst:919
#, fuzzy
msgid "Module (name portion of ``filename``)."
msgstr "模組（``filename`` 的名稱部分）。"

#: ../../library/logging.rst:921
#, fuzzy
msgid "msecs"
msgstr "毫秒"

#: ../../library/logging.rst:921
msgid "``%(msecs)d``"
msgstr "``%(msecs)d``"

#: ../../library/logging.rst:921
#, fuzzy
msgid ""
"Millisecond portion of the time when the :class:`LogRecord` was created."
msgstr "建立 :class:`LogRecord` 的時間的毫秒部分。"

#: ../../library/logging.rst:0 ../../library/logging.rst:924
#, fuzzy
msgid "msg"
msgstr "消息"

#: ../../library/logging.rst:924
#, fuzzy
msgid ""
"The format string passed in the original logging call. Merged with ``args`` "
"to produce ``message``, or an arbitrary object (see :ref:`arbitrary-object-"
"messages`)."
msgstr ""
"在原始日誌記錄呼叫中傳遞的格式字串。與 ``args`` 合併生成 ``message`` "
"或任意物件（參見 :ref:`arbitrary-object-messages`）。"

#: ../../library/logging.rst:0 ../../library/logging.rst:929
#, fuzzy
msgid "name"
msgstr "姓名"

#: ../../library/logging.rst:929
msgid "``%(name)s``"
msgstr "``%(name)s``"

#: ../../library/logging.rst:929
#, fuzzy
msgid "Name of the logger used to log the call."
msgstr "用於記錄呼叫的記錄器的名稱。"

#: ../../library/logging.rst:931
#, fuzzy
msgid "pathname"
msgstr "路徑名"

#: ../../library/logging.rst:931
msgid "``%(pathname)s``"
msgstr "``%(pathname)s``"

#: ../../library/logging.rst:931
#, fuzzy
msgid ""
"Full pathname of the source file where the logging call was issued (if "
"available)."
msgstr "發出日誌記錄呼叫的源文件的完整路徑名（如果可用）。"

#: ../../library/logging.rst:934
#, fuzzy
msgid "process"
msgstr "過程"

#: ../../library/logging.rst:934
msgid "``%(process)d``"
msgstr "``%(process)d``"

#: ../../library/logging.rst:934
#, fuzzy
msgid "Process ID (if available)."
msgstr "行程 ID（如果可用）。"

#: ../../library/logging.rst:936
#, fuzzy
msgid "processName"
msgstr "行程名稱"

#: ../../library/logging.rst:936
msgid "``%(processName)s``"
msgstr "``%(processName)s``"

#: ../../library/logging.rst:936
#, fuzzy
msgid "Process name (if available)."
msgstr "行程名稱（如果可用）。"

#: ../../library/logging.rst:938
#, fuzzy
msgid "relativeCreated"
msgstr "相對建立"

#: ../../library/logging.rst:938
msgid "``%(relativeCreated)d``"
msgstr "``%(relativeCreated)d``"

#: ../../library/logging.rst:938
#, fuzzy
msgid ""
"Time in milliseconds when the LogRecord was created, relative to the time "
"the logging module was loaded."
msgstr "建立 LogRecord 時的時間（以毫秒為單位），相對於加載日誌記錄模組的時間。"

#: ../../library/logging.rst:942
msgid "stack_info"
msgstr "stack_info"

#: ../../library/logging.rst:942
#, fuzzy
msgid ""
"Stack frame information (where available) from the bottom of the stack in "
"the current thread, up to and including the stack frame of the logging call "
"which resulted in the creation of this record."
msgstr "當前執行緒中堆疊底部的堆疊幀資訊（如果可用），直到並包括導致建立此記錄的日誌"
"記錄呼叫的堆疊幀。"

#: ../../library/logging.rst:948
#, fuzzy
msgid "thread"
msgstr "線"

#: ../../library/logging.rst:948
msgid "``%(thread)d``"
msgstr "``%(thread)d``"

#: ../../library/logging.rst:948
#, fuzzy
msgid "Thread ID (if available)."
msgstr "執行緒 ID（如果可用）。"

#: ../../library/logging.rst:950
#, fuzzy
msgid "threadName"
msgstr "執行緒名稱"

#: ../../library/logging.rst:950
msgid "``%(threadName)s``"
msgstr "``%(threadName)s``"

#: ../../library/logging.rst:950
#, fuzzy
msgid "Thread name (if available)."
msgstr "執行緒名稱（如果可用）。"

#: ../../library/logging.rst:953
msgid "*processName* was added."
msgstr "新增 *processName*\\ 。"

#: ../../library/logging.rst:960
msgid "LoggerAdapter Objects"
msgstr "LoggerAdapter 物件"

#: ../../library/logging.rst:962
#, fuzzy
msgid ""
":class:`LoggerAdapter` instances are used to conveniently pass contextual "
"information into logging calls. For a usage example, see the section on :ref:"
"`adding contextual information to your logging output <context-info>`."
msgstr ""
":class:`LoggerAdapter` "
"實例用於方便地將上下文資訊傳遞到日誌呼叫中。有關用法示例，請參閱有關 :ref:`"
"將上下文資訊新增到您的日誌輸出 <context-info>` 的部分。"

#: ../../library/logging.rst:968
#, fuzzy
msgid ""
"Returns an instance of :class:`LoggerAdapter` initialized with an "
"underlying :class:`Logger` instance and a dict-like object."
msgstr ""
"回傳一個 :class:`LoggerAdapter` 的實例，該實例使用底層 :class:`Logger` "
"實例和一個類似 dict 的物件進行初始化。"

#: ../../library/logging.rst:973
#, fuzzy
msgid ""
"Modifies the message and/or keyword arguments passed to a logging call in "
"order to insert contextual information. This implementation takes the object "
"passed as *extra* to the constructor and adds it to *kwargs* using key "
"'extra'. The return value is a (*msg*, *kwargs*) tuple which has the "
"(possibly modified) versions of the arguments passed in."
msgstr ""
"修改傳遞給日誌記錄呼叫的消息和/或關鍵字參數以插入上下文資訊。"
"此實作將對像作為 *extra* 傳遞給構造函式，並使用鍵 ``extra``將其新增到 *kwargs*。"
"回傳值是一個 (*msg*, *kwargs*) 元組，其中包含傳入參數的（可能修改過的）版本。"

#: ../../library/logging.rst:979
#, fuzzy
msgid ""
"In addition to the above, :class:`LoggerAdapter` supports the following "
"methods of :class:`Logger`: :meth:`~Logger.debug`, :meth:`~Logger.info`, :"
"meth:`~Logger.warning`, :meth:`~Logger.error`, :meth:`~Logger.exception`, :"
"meth:`~Logger.critical`, :meth:`~Logger.log`, :meth:`~Logger.isEnabledFor`, :"
"meth:`~Logger.getEffectiveLevel`, :meth:`~Logger.setLevel` and :meth:"
"`~Logger.hasHandlers`. These methods have the same signatures as their "
"counterparts in :class:`Logger`, so you can use the two types of instances "
"interchangeably."
msgstr ""
"除了上述之外，:class:`LoggerAdapter` 還支援 :class:`Logger` "
"的以下方法：:meth:`~Logger.debug`, :meth:`~Logger.info`, :meth:`~Logger ."
"warning`, :meth:`~Logger.error`, :meth:`~Logger.exception`, :meth:`~Logger."
"critical`, :meth:`~Logger.log`, :meth:`~Logger .isEnabledFor`、:meth:`~Logger"
".getEffectiveLevel`、:meth:`~Logger.setLevel` 和:meth:`~Logger."
"hasHandlers`。這些方法與 Logger "
"中的對應方法具有相同的簽名，因此您可以互換使用這兩種型別的實例。"

#: ../../library/logging.rst:988
#, fuzzy
msgid ""
"The :meth:`~Logger.isEnabledFor`, :meth:`~Logger.getEffectiveLevel`, :meth:"
"`~Logger.setLevel` and :meth:`~Logger.hasHandlers` methods were added to :"
"class:`LoggerAdapter`.  These methods delegate to the underlying logger."
msgstr ""
":meth:`~Logger.isEnabledFor`、:meth:`~Logger."
"getEffectiveLevel`、:meth:`~Logger.setLevel` 和 :meth:`~Logger.hasHandlers` "
"方法已新增到 :class:`LoggerAdapter` .這些方法委託給底層記錄器。"

#: ../../library/logging.rst:993
#, fuzzy
msgid ""
"Attribute :attr:`manager` and method :meth:`_log` were added, which delegate "
"to the underlying logger and allow adapters to be nested."
msgstr "新增了屬性 :attr:`manager` "
"和方法 :meth:`_log`，它們委託給底層記錄器並允許嵌套適配器。"

#: ../../library/logging.rst:999
#, fuzzy
msgid "Thread Safety"
msgstr "執行緒安全"

#: ../../library/logging.rst:1001
#, fuzzy
msgid ""
"The logging module is intended to be thread-safe without any special work "
"needing to be done by its clients. It achieves this though using threading "
"locks; there is one lock to serialize access to the module's shared data, "
"and each handler also creates a lock to serialize access to its underlying I/"
"O."
msgstr ""
"日誌記錄模組旨在是執行緒安全的，不需要其客戶端完成任何特殊工作。它通過使用執"
"行緒鎖實作了這一點；有一個鎖來序列化對模組共享資料的訪問，"
"每個處理程式還建立一個鎖來序列化對其底層 I/O 的訪問。"

#: ../../library/logging.rst:1006
#, fuzzy
msgid ""
"If you are implementing asynchronous signal handlers using the :mod:`signal` "
"module, you may not be able to use logging from within such handlers. This "
"is because lock implementations in the :mod:`threading` module are not "
"always re-entrant, and so cannot be invoked from such signal handlers."
msgstr ""
"如果您使用 :mod:`signal` "
"模組實作非同步信號處理程式，您可能無法在此類處理程式中使用日誌記錄。這是因為 "
":mod:`threading` "
"模組中的鎖實作並不總是可重入的，因此不能從此類信號處理程式中呼叫。"

#: ../../library/logging.rst:1013
#, fuzzy
msgid "Module-Level Functions"
msgstr "模組級函式"

#: ../../library/logging.rst:1015
#, fuzzy
msgid ""
"In addition to the classes described above, there are a number of module-"
"level functions."
msgstr "除了上述類之外，還有許多模組級函式。"

#: ../../library/logging.rst:1021
#, fuzzy
msgid ""
"Return a logger with the specified name or, if name is ``None``, return a "
"logger which is the root logger of the hierarchy. If specified, the name is "
"typically a dot-separated hierarchical name like *'a'*, *'a.b'* or *'a.b.c."
"d'*. Choice of these names is entirely up to the developer who is using "
"logging."
msgstr ""
"回傳具有指定名稱的記錄器，或者，如果名稱為 ``None`` ，則回傳一個記錄器，它是層次結"
"構的根記錄器。如果指定，該名稱通常是點分隔的分層名稱，如 *'a'*、*'a.b'* 或 "
"*'a.b.c.d'*。這些名稱的選擇完全取決於使用日誌記錄的開發人員。"

#: ../../library/logging.rst:1026
#, fuzzy
msgid ""
"All calls to this function with a given name return the same logger "
"instance. This means that logger instances never need to be passed between "
"different parts of an application."
msgstr "使用給定名稱對該函式的所有呼叫都會回傳相同的記錄器實例。這意味著記錄器實例永"
"遠不需要在應用程式的不同部分之間傳遞。"

#: ../../library/logging.rst:1033
#, fuzzy
msgid ""
"Return either the standard :class:`Logger` class, or the last class passed "
"to :func:`setLoggerClass`. This function may be called from within a new "
"class definition, to ensure that installing a customized :class:`Logger` "
"class will not undo customizations already applied by other code. For "
"example::"
msgstr ""
"回傳標準 :class:`Logger` 類，或傳遞給 :func:`setLoggerClass` "
"的最後一個類。可以從新的類定義中呼叫此函式，以確保安裝自定義的 Logger "
"類不會撤消其他程式碼已經應用的自定義。例如：："

#: ../../library/logging.rst:1044
#, fuzzy
msgid "Return a callable which is used to create a :class:`LogRecord`."
msgstr "回傳一個用於建立 :class:`LogRecord` 的可呼叫物件。"

#: ../../library/logging.rst:1046
#, fuzzy
msgid ""
"This function has been provided, along with :func:`setLogRecordFactory`, to "
"allow developers more control over how the :class:`LogRecord` representing a "
"logging event is constructed."
msgstr ""
"此功能已與 :func:`setLogRecordFactory` 一起提供，以允許開發人員更好地控制 "
":class:`LogRecord` 表示日誌記錄事件的構造方式。"

#: ../../library/logging.rst:1051
#, fuzzy
msgid ""
"See :func:`setLogRecordFactory` for more information about the how the "
"factory is called."
msgstr "有關如何呼叫工廠的更多資訊，請參見 :func:`setLogRecordFactory`。"

#: ../../library/logging.rst:1056
#, fuzzy
msgid ""
"Logs a message with level :const:`DEBUG` on the root logger. The *msg* is "
"the message format string, and the *args* are the arguments which are merged "
"into *msg* using the string formatting operator. (Note that this means that "
"you can use keywords in the format string, together with a single dictionary "
"argument.)"
msgstr ""
"在根記錄器上記錄一條級別為 :const:`DEBUG` 的消息。 *msg* "
"是消息格式字串，*args* 是使用字串格式化運算符合併到 *msg* 中的參數。 "
"（請注意，這意味著您可以在格式字串中使用關鍵字以及單個字典參數。）"

#: ../../library/logging.rst:1061
#, fuzzy
msgid ""
"There are three keyword arguments in *kwargs* which are inspected: "
"*exc_info* which, if it does not evaluate as false, causes exception "
"information to be added to the logging message. If an exception tuple (in "
"the format returned by :func:`sys.exc_info`) or an exception instance is "
"provided, it is used; otherwise, :func:`sys.exc_info` is called to get the "
"exception information."
msgstr ""
"*kwargs* 中有三個關鍵字參數被檢查： *exc_info* 如果它的計算結果不為假，則會導"
"致將例外資訊新增到日誌消息中。如果提供了例外元組（以 :func:`sys.exc_info` "
"回傳的格式）或例外實例，則使用它；否則，呼叫 :func:`sys.exc_info` "
"獲取例外資訊。"

#: ../../library/logging.rst:1087
#, fuzzy
msgid ""
"The third optional keyword argument is *extra* which can be used to pass a "
"dictionary which is used to populate the __dict__ of the LogRecord created "
"for the logging event with user-defined attributes. These custom attributes "
"can then be used as you like. For example, they could be incorporated into "
"logged messages. For example::"
msgstr ""
"第三個可選關鍵字參數是 *extra* ，它可用於傳遞一個字典，"
"該字典用於填充為具有使用者定義屬性的日誌記錄事件建立的 LogRecord 的 __dict__ "
"。然後可以隨意使用這些自定義屬性。例如，它們可以合併到記錄的消息中。例如：："

#: ../../library/logging.rst:1098
#, fuzzy
msgid "would print something like:"
msgstr "會印出類似的東西："

#: ../../library/logging.rst:1104
#, fuzzy
msgid ""
"The keys in the dictionary passed in *extra* should not clash with the keys "
"used by the logging system. (See the :class:`Formatter` documentation for "
"more information on which keys are used by the logging system.)"
msgstr "*extra* 中傳遞的字典中的鍵不應與日誌系統使用的鍵衝突。 "
"（有關日誌系統使用哪些鍵的更多資訊，請參閱 Formatter 文檔。）"

#: ../../library/logging.rst:1108
#, fuzzy
msgid ""
"If you choose to use these attributes in logged messages, you need to "
"exercise some care. In the above example, for instance, the :class:"
"`Formatter` has been set up with a format string which expects 'clientip' "
"and 'user' in the attribute dictionary of the LogRecord. If these are "
"missing, the message will not be logged because a string formatting "
"exception will occur. So in this case, you always need to pass the *extra* "
"dictionary with these keys."
msgstr ""
"如果您選擇在記錄的消息中使用這些屬性，則需要謹慎行事。例如，在上面的例子中，:"
"class:`Formatter` 已經設定了一個格式字串，它需要 LogRecord 的屬性字典中的 "
"'clientip' 和 'user'。如果缺少這些，則不會記錄消息，因為會發生字串格式例外。"
"所以在這種情況下，你總是需要用這些鍵傳遞 *extra* 字典。"

#: ../../library/logging.rst:1122
#, fuzzy
msgid ""
"This function (as well as :func:`info`, :func:`warning`, :func:`error` and :"
"func:`critical`) will call :func:`basicConfig` if the root logger doesn't "
"have any handler attached."
msgstr ""
"如果根記錄器沒有，此函式（以及 :func:`info`、:func:`warning`、:func:`error` "
"和 :func:`critical`）將呼叫 :func:`basicConfig`附加的任何處理程式。"

#: ../../library/logging.rst:1131
#, fuzzy
msgid ""
"Logs a message with level :const:`INFO` on the root logger. The arguments "
"are interpreted as for :func:`debug`."
msgstr "在根記錄器上記錄一條級別為 :const:`INFO` 的消息。參數被解釋為 :func:`debug`。"

#: ../../library/logging.rst:1137
#, fuzzy
msgid ""
"Logs a message with level :const:`WARNING` on the root logger. The arguments "
"are interpreted as for :func:`debug`."
msgstr "在根記錄器上記錄一條級別為 :const:`WARNING` "
"的消息。參數被解釋為 :func:`debug`。"

#: ../../library/logging.rst:1140
#, fuzzy
msgid ""
"There is an obsolete function ``warn`` which is functionally identical to "
"``warning``. As ``warn`` is deprecated, please do not use it - use "
"``warning`` instead."
msgstr ""
"有一個過時的函式 ``warn`` 在功能上與 ``warning`` 相同。由於 ``warn`` "
"已被棄用，請不要使用它 - 請改用 ``warning``。"

#: ../../library/logging.rst:1147
#, fuzzy
msgid ""
"Logs a message with level :const:`ERROR` on the root logger. The arguments "
"are interpreted as for :func:`debug`."
msgstr "在根記錄器上記錄一條級別為 :const:`ERROR` "
"的消息。參數被解釋為 :func:`debug`。"

#: ../../library/logging.rst:1153
#, fuzzy
msgid ""
"Logs a message with level :const:`CRITICAL` on the root logger. The "
"arguments are interpreted as for :func:`debug`."
msgstr "在根記錄器上記錄一條級別為 :const:`CRITICAL` "
"的消息。參數被解釋為 :func:`debug`。"

#: ../../library/logging.rst:1159
#, fuzzy
msgid ""
"Logs a message with level :const:`ERROR` on the root logger. The arguments "
"are interpreted as for :func:`debug`. Exception info is added to the logging "
"message. This function should only be called from an exception handler."
msgstr ""
"在根記錄器上記錄一條級別為 :const:`ERROR` 的消息。參數被解釋為 :func:`debug`"
"。例外資訊被新增到日誌消息中。該函式只能從例外處理程式中呼叫。"

#: ../../library/logging.rst:1165
#, fuzzy
msgid ""
"Logs a message with level *level* on the root logger. The other arguments "
"are interpreted as for :func:`debug`."
msgstr "在根記錄器上記錄一條級別為 *level* 的消息。其他參數被解釋為 :func:`debug`。"

#: ../../library/logging.rst:1170
#, fuzzy
msgid ""
"Provides an overriding level *level* for all loggers which takes precedence "
"over the logger's own level. When the need arises to temporarily throttle "
"logging output down across the whole application, this function can be "
"useful. Its effect is to disable all logging calls of severity *level* and "
"below, so that if you call it with a value of INFO, then all INFO and DEBUG "
"events would be discarded, whereas those of severity WARNING and above would "
"be processed according to the logger's effective level. If ``logging."
"disable(logging.NOTSET)`` is called, it effectively removes this overriding "
"level, so that logging output again depends on the effective levels of "
"individual loggers."
msgstr ""
"為所有優先於記錄器自身級別的記錄器提供覆蓋級別 *level*。當需要臨時限制整個應"
"用程式的日誌記錄輸出時，此功能會很有用。它的作用是禁用所有嚴重級別*級別*及以"
"下的日誌記錄呼叫，因此如果您使用 INFO 值呼叫它，則所有 INFO 和 DEBUG "
"事件將被丟棄，而嚴重級別 WARNING 及以上的事件將根據記錄器的有效級別。"
"如果呼叫 logging.disable(logging.NOTSET) "
"，它會有效地刪除這個覆蓋級別，以便日誌輸出再次取決於各個記錄器的有效級別。"

#: ../../library/logging.rst:1181
#, fuzzy
msgid ""
"Note that if you have defined any custom logging level higher than "
"``CRITICAL`` (this is not recommended), you won't be able to rely on the "
"default value for the *level* parameter, but will have to explicitly supply "
"a suitable value."
msgstr ""
"請注意，如果您定義了任何高於 ``CRITICAL`` "
"的自定義日誌記錄級別（不推薦這樣做），您將無法依賴 *level* "
"參數的預設值，但必須顯式提供一個合適的值。"

#: ../../library/logging.rst:1186
#, fuzzy
msgid ""
"The *level* parameter was defaulted to level ``CRITICAL``. See :issue:"
"`28524` for more information about this change."
msgstr "*level* "
"參數預設為 ``CRITICAL`` 級別。有關此更改的更多資訊，請參見 :issue:`28524`。"

#: ../../library/logging.rst:1192
#, fuzzy
msgid ""
"Associates level *level* with text *levelName* in an internal dictionary, "
"which is used to map numeric levels to a textual representation, for example "
"when a :class:`Formatter` formats a message. This function can also be used "
"to define your own levels. The only constraints are that all levels used "
"must be registered using this function, levels should be positive integers "
"and they should increase in increasing order of severity."
msgstr ""
"將級別 *level* 與內部字典中的文本 *levelName* "
"相關聯，該字典用於將數字級別映射到文本表示形式，例如當 Formatter 格式化消息時"
"。此功能也可用於定義您自己的級別。唯一的限制是所有使用的級別都必須使用此函式"
"註冊，級別應該是正整數並且它們應該按嚴重性的遞增順序增加。"

#: ../../library/logging.rst:1199
#, fuzzy
msgid ""
"If you are thinking of defining your own levels, please see the section on :"
"ref:`custom-levels`."
msgstr "如果您正在考慮定義自己的級別，請參閱有關 :ref:`custom-levels` 的部分。"

#: ../../library/logging.rst:1204
#, fuzzy
msgid ""
"Returns a mapping from level names to their corresponding logging levels. "
"For example, the string \"CRITICAL\" maps to :const:`CRITICAL`. The returned "
"mapping is copied from an internal mapping on each call to this function."
msgstr ""
"回傳從級別名稱到相應日誌記錄級別的映射。例如，字串 ``CRITICAL`` 映射到 "
":const:`CRITICAL`。回傳的映射是從每次呼叫此函式時的內部映射複製而來的。"

#: ../../library/logging.rst:1212
#, fuzzy
msgid "Returns the textual or numeric representation of logging level *level*."
msgstr "回傳日誌記錄級別 *level* 的文本或數字表示。"

#: ../../library/logging.rst:1214
#, fuzzy
msgid ""
"If *level* is one of the predefined levels :const:`CRITICAL`, :const:"
"`ERROR`, :const:`WARNING`, :const:`INFO` or :const:`DEBUG` then you get the "
"corresponding string. If you have associated levels with names using :func:"
"`addLevelName` then the name you have associated with *level* is returned. "
"If a numeric value corresponding to one of the defined levels is passed in, "
"the corresponding string representation is returned."
msgstr ""
"如果 *level* 是預定義級別之一 :const:`CRITICAL`、:const:`ERROR`、:const:`WARN"
"ING`、:const:`INFO` 或 :const:`DEBUG` 那麼您將獲得相應的字串.如果您使用 "
":func:`addLevelName` 將級別與名稱相關聯，則回傳您與 *level* "
"關聯的名稱。如果傳入與定義級別之一對應的數值，則回傳相應的字串表示形式。"

#: ../../library/logging.rst:1221
#, fuzzy
msgid ""
"The *level* parameter also accepts a string representation of the level such "
"as 'INFO'. In such cases, this functions returns the corresponding numeric "
"value of the level."
msgstr "*level* 參數還接受級別的字串表示形式，例如 ``INFO``。在這種情況下，此函式回傳級"
"別的相應數值。"

#: ../../library/logging.rst:1225
#, fuzzy
msgid ""
"If no matching numeric or string value is passed in, the string 'Level %s' % "
"level is returned."
msgstr "如果沒有傳入匹配的數字或字串值，則回傳字串 'Level %s' % level。"

#: ../../library/logging.rst:1228
#, fuzzy
msgid ""
"Levels are internally integers (as they need to be compared in the logging "
"logic). This function is used to convert between an integer level and the "
"level name displayed in the formatted log output by means of the "
"``%(levelname)s`` format specifier (see :ref:`logrecord-attributes`), and "
"vice versa."
msgstr ""
"級別在內部是整數（因為它們需要在日誌記錄邏輯中進行比較）。此函式用於通過 "
"%(levelname)s 格式說明符（參見 :ref:`logrecord-attributes`）在格式化日誌輸出"
"中顯示的整數級別和級別名稱之間進行轉換，反之亦然."

#: ../../library/logging.rst:1234
#, fuzzy
msgid ""
"In Python versions earlier than 3.4, this function could also be passed a "
"text level, and would return the corresponding numeric value of the level. "
"This undocumented behaviour was considered a mistake, and was removed in "
"Python 3.4, but reinstated in 3.4.2 due to retain backward compatibility."
msgstr ""
"在 Python 3.4 之前的版本中，該函式也可以傳入一個文本級別，並回傳該級別對應的"
"數值。這種未記錄的行為被認為是一個錯誤，並在 Python 3.4 中被刪除，"
"但由於保持向後相容性而在 3.4.2 中恢復。"

#: ../../library/logging.rst:1242
#, fuzzy
msgid ""
"Creates and returns a new :class:`LogRecord` instance whose attributes are "
"defined by *attrdict*. This function is useful for taking a pickled :class:"
"`LogRecord` attribute dictionary, sent over a socket, and reconstituting it "
"as a :class:`LogRecord` instance at the receiving end."
msgstr ""
"建立並回傳一個新的 :class:`LogRecord` 實例，其屬性由 *attrdict* 定義。"
"此函式可用於獲取經過醃製的 LogRecord 屬性字典，通過 socket 發送，"
"並在接收端將其重構為 LogRecord 實例。"

#: ../../library/logging.rst:1250
#, fuzzy
msgid ""
"Does basic configuration for the logging system by creating a :class:"
"`StreamHandler` with a default :class:`Formatter` and adding it to the root "
"logger. The functions :func:`debug`, :func:`info`, :func:`warning`, :func:"
"`error` and :func:`critical` will call :func:`basicConfig` automatically if "
"no handlers are defined for the root logger."
msgstr ""
"通過建立一個帶有預設格式器的 StreamHandler "
"並將其新增到根記錄器來對日誌系統進行基本配置。如果沒有定義處理程式，函式 "
":func:`debug`、:func:`info`、:func:`warning`、:func:`error` 和 "
":func:`critical` 將自動呼叫 :func:`basicConfig`對於根記錄器。"

#: ../../library/logging.rst:1256
#, fuzzy
msgid ""
"This function does nothing if the root logger already has handlers "
"configured, unless the keyword argument *force* is set to ``True``."
msgstr "如果根記錄器已經配置了處理程式，則此函式不執行任何操作，除非關鍵字參數 "
"*force* 設定為 ``True``。"

#: ../../library/logging.rst:1259
#, fuzzy
msgid ""
"This function should be called from the main thread before other threads are "
"started. In versions of Python prior to 2.7.1 and 3.2, if this function is "
"called from multiple threads, it is possible (in rare circumstances) that a "
"handler will be added to the root logger more than once, leading to "
"unexpected results such as messages being duplicated in the log."
msgstr ""
"這個函式應該在其他執行緒啟動之前從主執行緒呼叫。在 2.7.1 和 3.2 之前的 "
"Python 版本中，如果從多個執行緒呼叫此函式，則可能（在極少數情況下）將處理程式"
"多次新增到根記錄器，從而導致意外結果，例如消息在日誌中被複製。"

#: ../../library/logging.rst:1266
#, fuzzy
msgid "The following keyword arguments are supported."
msgstr "支援以下關鍵字參數。"

#: ../../library/logging.rst:1273
msgid "*filename*"
msgstr "*filename*"

#: ../../library/logging.rst:1273
#, fuzzy
msgid ""
"Specifies that a :class:`FileHandler` be created, using the specified "
"filename, rather than a :class:`StreamHandler`."
msgstr "指定使用指定的文件名而不是 StreamHandler 建立 :class:`FileHandler`。"

#: ../../library/logging.rst:1277
msgid "*filemode*"
msgstr "*filemode*"

#: ../../library/logging.rst:1277
#, fuzzy
msgid ""
"If *filename* is specified, open the file in this :ref:`mode <filemodes>`. "
"Defaults to ``'a'``."
msgstr "如果指定了 *filename*，則在此 :ref:`mode <filemodes>` "
"中打開文件。預設為``'a'``。"

#: ../../library/logging.rst:1281
msgid "*format*"
msgstr "*format*"

#: ../../library/logging.rst:1281
#, fuzzy
msgid ""
"Use the specified format string for the handler. Defaults to attributes "
"``levelname``, ``name`` and ``message`` separated by colons."
msgstr "為處理程式使用指定的格式字串。預設為用冒號分隔的屬性 ``levelname``、``name`` "
"和 ``message``。"

#: ../../library/logging.rst:1286
msgid "*datefmt*"
msgstr "*datefmt*"

#: ../../library/logging.rst:1286
#, fuzzy
msgid ""
"Use the specified date/time format, as accepted by :func:`time.strftime`."
msgstr "使用 time.strftime 接受的指定日期/時間格式。"

#: ../../library/logging.rst:1289
msgid "*style*"
msgstr "*style*"

#: ../../library/logging.rst:1289
#, fuzzy
msgid ""
"If *format* is specified, use this style for the format string. One of "
"``'%'``, ``'{'`` or ``'$'`` for :ref:`printf-style <old-string-"
"formatting>`, :meth:`str.format` or :class:`string.Template` respectively. "
"Defaults to ``'%'``."
msgstr ""
"如果指定了 *format*，則將此樣式用於格式字串。 ``'%'``、``'{'`` 或 ``'$'`` "
"之一 :ref:`printf-style <old-string-formatting>`, :meth:`str.format`或 "
":class:`string.Template` 分別。預設為 ``%``。"

#: ../../library/logging.rst:1297
msgid "*level*"
msgstr "*level*"

#: ../../library/logging.rst:1297
#, fuzzy
msgid "Set the root logger level to the specified :ref:`level <levels>`."
msgstr "將根記錄器級別設定為指定的 :ref:`level <levels>`。"

#: ../../library/logging.rst:1300
msgid "*stream*"
msgstr "*stream*"

#: ../../library/logging.rst:1300
#, fuzzy
msgid ""
"Use the specified stream to initialize the :class:`StreamHandler`. Note that "
"this argument is incompatible with *filename* - if both are present, a "
"``ValueError`` is raised."
msgstr ""
"使用指定的流來初始化 :class:`StreamHandler`。請注意，此參數與 *filename* "
"不相容 - 如果兩者都存在，則會引發 ``ValueError``。"

#: ../../library/logging.rst:1306
msgid "*handlers*"
msgstr "*handlers*"

#: ../../library/logging.rst:1306
#, fuzzy
msgid ""
"If specified, this should be an iterable of already created handlers to add "
"to the root logger. Any handlers which don't already have a formatter set "
"will be assigned the default formatter created in this function. Note that "
"this argument is incompatible with *filename* or *stream* - if both are "
"present, a ``ValueError`` is raised."
msgstr ""
"如果指定，這應該是一個可疊代的已建立處理程式以新增到根記錄器。任何尚未設定格"
"式化程式的處理程式都將被分配在此函式中建立的預設格式化程式。請注意，此參數與 "
"*filename* 或 *stream* 不相容 - 如果兩者都存在，則會引發 ``ValueError``。"

#: ../../library/logging.rst:1315
msgid "*force*"
msgstr "*force*"

#: ../../library/logging.rst:1315
#, fuzzy
msgid ""
"If this keyword argument is specified as true, any existing handlers "
"attached to the root logger are removed and closed, before carrying out the "
"configuration as specified by the other arguments."
msgstr "如果此關鍵字參數指定為 true，則在執行其他參數指定的配置之前，將刪除並關閉附加"
"到根記錄器的任何現有處理程式。"

#: ../../library/logging.rst:1321
msgid "*encoding*"
msgstr "*encoding*"

#: ../../library/logging.rst:1321
#, fuzzy
msgid ""
"If this keyword argument is specified along with *filename*, its value is "
"used when the :class:`FileHandler` is created, and thus used when opening "
"the output file."
msgstr "如果此關鍵字參數與 *filename* 一起指定，則在建立 FileHandler "
"時使用它的值，因此在打開輸出文件時使用。"

#: ../../library/logging.rst:1326
msgid "*errors*"
msgstr "*errors*"

#: ../../library/logging.rst:1326
#, fuzzy
msgid ""
"If this keyword argument is specified along with *filename*, its value is "
"used when the :class:`FileHandler` is created, and thus used when opening "
"the output file. If not specified, the value 'backslashreplace' is used. "
"Note that if ``None`` is specified, it will be passed as such to :func:"
"`open`, which means that it will be treated the same as passing 'errors'."
msgstr ""
"如果此關鍵字參數與 *filename* 一起指定，則在建立 FileHandler 時使用它的值，因"
"此在打開輸出文件時使用。如果未指定，則使用值 ``backslashreplace`` 。請注意，"
"如果指定了 ``None``，它將被傳遞給 "
":func:`open`，這意味著它將被視為與傳遞“錯誤”相同。"

#: ../../library/logging.rst:1337
msgid "The *style* argument was added."
msgstr "新增 *style* 引數。"

#: ../../library/logging.rst:1340
#, fuzzy
msgid ""
"The *handlers* argument was added. Additional checks were added to catch "
"situations where incompatible arguments are specified (e.g. *handlers* "
"together with *stream* or *filename*, or *stream* together with *filename*)."
msgstr ""
"新增了 *handlers* "
"參數。新增了額外的檢查以捕獲指定不相容參數的情況（例如，*handlers* 與 "
"*stream* 或 *filename* 一起，或 *stream* 與 *filename* 一起）。"

#: ../../library/logging.rst:1346
msgid "The *force* argument was added."
msgstr "新增 *force* 引數。"

#: ../../library/logging.rst:1349
msgid "The *encoding* and *errors* arguments were added."
msgstr "新增 *encoding* 與 *errors* 引數。"

#: ../../library/logging.rst:1354
#, fuzzy
msgid ""
"Informs the logging system to perform an orderly shutdown by flushing and "
"closing all handlers. This should be called at application exit and no "
"further use of the logging system should be made after this call."
msgstr "通知日誌系統通過刷新和關閉所有處理程式來執行有序關閉。這應該在應用程式退出時"
"呼叫，並且在此呼叫之後不應進一步使用日誌系統。"

#: ../../library/logging.rst:1358
#, fuzzy
msgid ""
"When the logging module is imported, it registers this function as an exit "
"handler (see :mod:`atexit`), so normally there's no need to do that manually."
msgstr "導入日誌模組時，它會將此函式註冊為退出處理程式（請參閱 "
":mod:`atexit`），因此通常無需手動執行此操作。"

#: ../../library/logging.rst:1365
#, fuzzy
msgid ""
"Tells the logging system to use the class *klass* when instantiating a "
"logger. The class should define :meth:`__init__` such that only a name "
"argument is required, and the :meth:`__init__` should call :meth:`Logger."
"__init__`. This function is typically called before any loggers are "
"instantiated by applications which need to use custom logger behavior. After "
"this call, as at any other time, do not instantiate loggers directly using "
"the subclass: continue to use the :func:`logging.getLogger` API to get your "
"loggers."
msgstr ""
"告訴日誌系統在實例化記錄器時使用類 *klass*。該類應該定義 :meth:`__init__` "
"這樣只需要一個名稱參數，並且 :meth:`__init__` 應該呼叫 :meth:`Logger.__init__"
"`。通常在需要使用自定義記錄器行為的應用程式實例化任何記錄器之前呼叫此函式。在"
"這次呼叫之後，與其他任何時候一樣，不要直接使用子類別實例化記錄器：繼續使用 "
":func:`logging.getLogger` API 來獲取記錄器。"

#: ../../library/logging.rst:1376
#, fuzzy
msgid "Set a callable which is used to create a :class:`LogRecord`."
msgstr "設定一個用於建立 LogRecord 的可呼叫物件。"

#: ../../library/logging.rst:1378
#, fuzzy
msgid "The factory callable to be used to instantiate a log record."
msgstr "用於實例化日誌記錄的工廠可呼叫物件。"

#: ../../library/logging.rst:1380
#, fuzzy
msgid ""
"This function has been provided, along with :func:`getLogRecordFactory`, to "
"allow developers more control over how the :class:`LogRecord` representing a "
"logging event is constructed."
msgstr "此函式已與 getLogRecordFactory 一起提供，"
"以允許開發人員更好地控制表示日誌記錄事件的 LogRecord 的構建方式。"

#: ../../library/logging.rst:1385
#, fuzzy
msgid "The factory has the following signature:"
msgstr "工廠有以下簽名："

#: ../../library/logging.rst:1387
#, fuzzy
msgid ""
"``factory(name, level, fn, lno, msg, args, exc_info, func=None, sinfo=None, "
"**kwargs)``"
msgstr "``工廠（名稱、級別、fn、lno、味精、args、exc_info、func=None、sinfo=None、**k"
"wargs）``"

#: ../../library/logging.rst:1389
#, fuzzy
msgid "The logger name."
msgstr "記錄器名稱。"

#: ../../library/logging.rst:0
#, fuzzy
msgid "level"
msgstr "等級"

#: ../../library/logging.rst:1390
#, fuzzy
msgid "The logging level (numeric)."
msgstr "日誌記錄級別（數字）。"

#: ../../library/logging.rst:0
msgid "fn"
msgstr "fn"

#: ../../library/logging.rst:1391
#, fuzzy
msgid "The full pathname of the file where the logging call was made."
msgstr "進行日誌記錄呼叫的文件的完整路徑名。"

#: ../../library/logging.rst:0
msgid "lno"
msgstr "lno"

#: ../../library/logging.rst:1392
#, fuzzy
msgid "The line number in the file where the logging call was made."
msgstr "進行記錄呼叫的文件中的行號。"

#: ../../library/logging.rst:1393
#, fuzzy
msgid "The logging message."
msgstr "日誌消息。"

#: ../../library/logging.rst:1394
#, fuzzy
msgid "The arguments for the logging message."
msgstr "日誌消息的參數。"

#: ../../library/logging.rst:1395
#, fuzzy
msgid "An exception tuple, or ``None``."
msgstr "例外元組，或 ``None`` 。"

#: ../../library/logging.rst:0
msgid "func"
msgstr "func"

#: ../../library/logging.rst:1396
#, fuzzy
msgid "The name of the function or method which invoked the logging call."
msgstr "呼叫日誌呼叫的函式或方法的名稱。"

#: ../../library/logging.rst:0
msgid "sinfo"
msgstr "sinfo"

#: ../../library/logging.rst:1398
#, fuzzy
msgid ""
"A stack traceback such as is provided by :func:`traceback.print_stack`, "
"showing the call hierarchy."
msgstr "堆疊回溯，例如 :func:`traceback.print_stack` 提供的，顯示了呼叫層次結構。"

#: ../../library/logging.rst:0
msgid "kwargs"
msgstr "kwargs"

#: ../../library/logging.rst:1400
msgid "Additional keyword arguments."
msgstr "額外的關鍵字引數。"

#: ../../library/logging.rst:1404
#, fuzzy
msgid "Module-Level Attributes"
msgstr "模組級屬性"

#: ../../library/logging.rst:1408
#, fuzzy
msgid ""
"A \"handler of last resort\" is available through this attribute. This is a :"
"class:`StreamHandler` writing to ``sys.stderr`` with a level of ``WARNING``, "
"and is used to handle logging events in the absence of any logging "
"configuration. The end result is to just print the message to ``sys."
"stderr``. This replaces the earlier error message saying that \"no handlers "
"could be found for logger XYZ\". If you need the earlier behaviour for some "
"reason, ``lastResort`` can be set to ``None``."
msgstr ""
"通過此屬性可以使用“最後的處理程式”。這是一個寫入 sys.stderr 的 "
":class:`StreamHandler`，級別為 `WARNING``，用於在沒有任何日誌記錄配置的情況下"
"處理日誌記錄事件。最終結果只是將消息印出到“sys."
"stderr”。這取代了之前的錯誤消息“找不到記錄器 XYZ "
"的處理程式”。如果出於某種原因需要更早的行為，可以將 ``lastResort`` 設定為 "
"``None``。"

#: ../../library/logging.rst:1419
#, fuzzy
msgid "Integration with the warnings module"
msgstr "與警告模組集成"

#: ../../library/logging.rst:1421
#, fuzzy
msgid ""
"The :func:`captureWarnings` function can be used to integrate :mod:`logging` "
"with the :mod:`warnings` module."
msgstr ":func:`captureWarnings` 函式可用於將 :mod:`logging` 與 :mod:`warnings` "
"模組集成。"

#: ../../library/logging.rst:1426
#, fuzzy
msgid ""
"This function is used to turn the capture of warnings by logging on and off."
msgstr "此函式用於通過登錄和關閉來打開警告捕獲。"

#: ../../library/logging.rst:1429
#, fuzzy
msgid ""
"If *capture* is ``True``, warnings issued by the :mod:`warnings` module will "
"be redirected to the logging system. Specifically, a warning will be "
"formatted using :func:`warnings.formatwarning` and the resulting string "
"logged to a logger named ``'py.warnings'`` with a severity of :const:"
"`WARNING`."
msgstr ""
"如果 *capture* 為 ``True``，則 :mod:`warnings` "
"模組發出的警告將被重定向到日誌系統。具體來說，警告將使用 :func:`warnings."
"formatwarning` 進行格式化，並將生成的字串記錄到名為 ``'py.warnings'`` "
"的記錄器中，嚴重程度為 :const:`WARNING`。"

#: ../../library/logging.rst:1434
#, fuzzy
msgid ""
"If *capture* is ``False``, the redirection of warnings to the logging system "
"will stop, and warnings will be redirected to their original destinations (i."
"e. those in effect before ``captureWarnings(True)`` was called)."
msgstr ""
"如果 *capture* 為 ``False``，警告將停止重定向到日誌系統，並且警告將被重定向到它"
"們的原始目的地（即那些在呼叫“captureWarnings（True）”之前有效的目的地）。"

#: ../../library/logging.rst:1442
#, fuzzy
msgid "Module :mod:`logging.config`"
msgstr "模組 :mod:`logging.config`"

#: ../../library/logging.rst:1442
#, fuzzy
msgid "Configuration API for the logging module."
msgstr "日誌記錄模組的配置 API。"

#: ../../library/logging.rst:1445
#, fuzzy
msgid "Module :mod:`logging.handlers`"
msgstr "模組 :mod:`logging.handlers`"

#: ../../library/logging.rst:1445
#, fuzzy
msgid "Useful handlers included with the logging module."
msgstr "日誌記錄模組中包含有用的處理程式。"

#: ../../library/logging.rst:1449
#, fuzzy
msgid ":pep:`282` - A Logging System"
msgstr ":pep:`282` - 一個日誌系統"

#: ../../library/logging.rst:1448
#, fuzzy
msgid ""
"The proposal which described this feature for inclusion in the Python "
"standard library."
msgstr "描述此功能以包含在 Python 標準庫中的提案。"

#: ../../library/logging.rst:1454
#, fuzzy
msgid ""
"`Original Python logging package <https://old.red-dove.com/python_logging."
"html>`_"
msgstr "`原始 Python 日誌包 <https://old.red-dove.com/python_logging.html>`_"

#: ../../library/logging.rst:1452
#, fuzzy
msgid ""
"This is the original source for the :mod:`logging` package.  The version of "
"the package available from this site is suitable for use with Python 1.5.2, "
"2.1.x and 2.2.x, which do not include the :mod:`logging` package in the "
"standard library."
msgstr ""
"這是 :mod:`logging` 包的原始來源。此站點提供的包版本適用於 Python 1.5.2、"
"2.1.x 和 2.2.x，標準庫中不包括 :mod:`logging` 包。"
