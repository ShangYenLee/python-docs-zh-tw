# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-11 06:38+0000\n"
"PO-Revision-Date: 2018-05-23 16:04+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/importlib.rst:2
msgid ":mod:`!importlib` --- The implementation of :keyword:`!import`"
msgstr ":mod:`!importlib` --- :keyword:`!import` 的實作"

#: ../../library/importlib.rst:12
msgid "**Source code:** :source:`Lib/importlib/__init__.py`"
msgstr "**原始碼：**\\ :source:`Lib/importlib/__init__.py`"

#: ../../library/importlib.rst:18
msgid "Introduction"
msgstr "簡介"

#: ../../library/importlib.rst:20
#, fuzzy
msgid "The purpose of the :mod:`importlib` package is three-fold."
msgstr ":mod:`importlib` 包的目的有三個。"

#: ../../library/importlib.rst:22
#, fuzzy
msgid ""
"One is to provide the implementation of the :keyword:`import` statement (and "
"thus, by extension, the :func:`__import__` function) in Python source code. "
"This provides an implementation of :keyword:`!import` which is portable to "
"any Python interpreter. This also provides an implementation which is easier "
"to comprehend than one implemented in a programming language other than "
"Python."
msgstr ""
"一種是在 Python 源程式碼中提供 :keyword:`import` 語句的實作（因此，通過擴充，"
"提供 :func:`__import__` 函式）。這提供了可移植到任何 Python 直譯器的 "
":keyword:`!import` 的實作。這也提供了一種比用 Python "
"以外的編程語言實作的實作更容易理解的實作。"

#: ../../library/importlib.rst:29
#, fuzzy
msgid ""
"Two, the components to implement :keyword:`import` are exposed in this "
"package, making it easier for users to create their own custom objects "
"(known generically as an :term:`importer`) to participate in the import "
"process."
msgstr ""
"第二，實作 :keyword:`import` "
"的組件暴露在這個包中，使使用者更容易建立自己的自定義物件（通常稱為 "
":term:`importer`）以參與導入過程。"

#: ../../library/importlib.rst:33
#, fuzzy
msgid ""
"Three, the package contains modules exposing additional functionality for "
"managing aspects of Python packages:"
msgstr "第三，該包包含公開用於管理 Python 包方面的附加功能的模組："

#: ../../library/importlib.rst:36
#, fuzzy
msgid ""
":mod:`importlib.metadata` presents access to metadata from third-party "
"distributions."
msgstr ":mod:`importlib.metadata` 提供對來自第三方發行版的元資料的訪問。"

#: ../../library/importlib.rst:38
#, fuzzy
msgid ""
":mod:`importlib.resources` provides routines for accessing non-code "
"\"resources\" from Python packages."
msgstr ":mod:`importlib.resources` 提供從 Python 包訪問非程式碼“資源”的例程。"

#: ../../library/importlib.rst:44
msgid ":ref:`import`"
msgstr ":ref:`import`"

#: ../../library/importlib.rst:44
#, fuzzy
msgid "The language reference for the :keyword:`import` statement."
msgstr ":keyword:`import` 語句的語言參考。"

#: ../../library/importlib.rst:49
#, fuzzy
msgid ""
"`Packages specification <https://www.python.org/doc/essays/packages/>`__"
msgstr "`包規範 <https://www.python.org/doc/essays/packages/>`__"

#: ../../library/importlib.rst:47
#, fuzzy
msgid ""
"Original specification of packages. Some semantics have changed since the "
"writing of this document (e.g. redirecting based on ``None`` in :data:`sys."
"modules`)."
msgstr ""
"包裝的原始規格。自撰寫本文檔以來，一些語義發生了變化（例如，基於 :data:`sys."
"modules` 中的 ``None`` 進行重定向）。"

#: ../../library/importlib.rst:52
#, fuzzy
msgid "The :func:`.__import__` function"
msgstr ":func:`.__import__` 函式"

#: ../../library/importlib.rst:52
#, fuzzy
msgid "The :keyword:`import` statement is syntactic sugar for this function."
msgstr ":keyword:`import` 語句是此函式的語法糖。"

#: ../../library/importlib.rst:55
#, fuzzy
msgid ":ref:`sys-path-init`"
msgstr ":ref:`系統路徑初始化`"

#: ../../library/importlib.rst:55
#, fuzzy
msgid "The initialization of :data:`sys.path`."
msgstr ":data:`sys.path` 的初始化。"

#: ../../library/importlib.rst:58
msgid ":pep:`235`"
msgstr ":pep:`235`"

#: ../../library/importlib.rst:58
#, fuzzy
msgid "Import on Case-Insensitive Platforms"
msgstr "在不區分大小寫的平台上導入"

#: ../../library/importlib.rst:61
msgid ":pep:`263`"
msgstr ":pep:`263`"

#: ../../library/importlib.rst:61
#, fuzzy
msgid "Defining Python Source Code Encodings"
msgstr "定義 Python 源程式碼編碼"

#: ../../library/importlib.rst:64
msgid ":pep:`302`"
msgstr ":pep:`302`"

#: ../../library/importlib.rst:64
#, fuzzy
msgid "New Import Hooks"
msgstr "新的導入掛鉤"

#: ../../library/importlib.rst:67
msgid ":pep:`328`"
msgstr ":pep:`328`"

#: ../../library/importlib.rst:67
#, fuzzy
msgid "Imports: Multi-Line and Absolute/Relative"
msgstr "進口：多線和絕對/相對"

#: ../../library/importlib.rst:70
msgid ":pep:`366`"
msgstr ":pep:`366`"

#: ../../library/importlib.rst:70
#, fuzzy
msgid "Main module explicit relative imports"
msgstr "主模組顯式相對導入"

#: ../../library/importlib.rst:73
msgid ":pep:`420`"
msgstr ":pep:`420`"

#: ../../library/importlib.rst:73
#, fuzzy
msgid "Implicit namespace packages"
msgstr "隱式命名空間包"

#: ../../library/importlib.rst:76
msgid ":pep:`451`"
msgstr ":pep:`451`"

#: ../../library/importlib.rst:76
#, fuzzy
msgid "A ModuleSpec Type for the Import System"
msgstr "導入系統的 ModuleSpec 型別"

#: ../../library/importlib.rst:79
msgid ":pep:`488`"
msgstr ":pep:`488`"

#: ../../library/importlib.rst:79
#, fuzzy
msgid "Elimination of PYO files"
msgstr "消除 PYO 文件"

#: ../../library/importlib.rst:82
msgid ":pep:`489`"
msgstr ":pep:`489`"

#: ../../library/importlib.rst:82
#, fuzzy
msgid "Multi-phase extension module initialization"
msgstr "多相擴充模組初始化"

#: ../../library/importlib.rst:85
msgid ":pep:`552`"
msgstr ":pep:`552`"

#: ../../library/importlib.rst:85
#, fuzzy
msgid "Deterministic pycs"
msgstr "確定性pycs"

#: ../../library/importlib.rst:88
msgid ":pep:`3120`"
msgstr ":pep:`3120`"

#: ../../library/importlib.rst:88
#, fuzzy
msgid "Using UTF-8 as the Default Source Encoding"
msgstr "使用 UTF-8 作為預設源編碼"

#: ../../library/importlib.rst:90
msgid ":pep:`3147`"
msgstr ":pep:`3147`"

#: ../../library/importlib.rst:91
#, fuzzy
msgid "PYC Repository Directories"
msgstr "PYC 儲存庫目錄"

#: ../../library/importlib.rst:95
msgid "Functions"
msgstr "函式"

#: ../../library/importlib.rst:99
#, fuzzy
msgid "An implementation of the built-in :func:`__import__` function."
msgstr "內建 :func:`__import__` 函式的實作。"

#: ../../library/importlib.rst:102
#, fuzzy
msgid ""
"Programmatic importing of modules should use :func:`import_module` instead "
"of this function."
msgstr "模組的編程導入應該使用 :func:`import_module` 而不是這個函式。"

#: ../../library/importlib.rst:107
#, fuzzy
msgid ""
"Import a module. The *name* argument specifies what module to import in "
"absolute or relative terms (e.g. either ``pkg.mod`` or ``..mod``). If the "
"name is specified in relative terms, then the *package* argument must be set "
"to the name of the package which is to act as the anchor for resolving the "
"package name (e.g. ``import_module('..mod', 'pkg.subpkg')`` will import "
"``pkg.mod``)."
msgstr ""
"導入一個模組。 *name* 參數以絕對或相對術語指定要導入的模組（例如 ``pkg.mod`` "
"或 ``..mod``）。如果名稱以相對術語指定，則 *package* "
"參數必須設定為包的名稱，該包將充當解析包名稱的錨點（例如 ``import_module("
"'..mod', 'pkg .subpkg')`` 將導入 ``pkg.mod``)。"

#: ../../library/importlib.rst:115
#, fuzzy
msgid ""
"The :func:`import_module` function acts as a simplifying wrapper around :"
"func:`importlib.__import__`. This means all semantics of the function are "
"derived from :func:`importlib.__import__`. The most important difference "
"between these two functions is that :func:`import_module` returns the "
"specified package or module (e.g. ``pkg.mod``), while :func:`__import__` "
"returns the top-level package or module (e.g. ``pkg``)."
msgstr ""
":func:`import_module` 函式充當 :func:`importlib.__import__` 的簡化包裝器。"
"這意味著函式的所有語義都來自 :func:`importlib."
"__import__`。這兩個函式之間最重要的區別是 :func:`import_module` "
"回傳指定的包或模組（例如 ``pkg.mod``），而 :func:`__import__` "
"回傳頂級包或模組（例如``pkg``）。"

#: ../../library/importlib.rst:122
#, fuzzy
msgid ""
"If you are dynamically importing a module that was created since the "
"interpreter began execution (e.g., created a Python source file), you may "
"need to call :func:`invalidate_caches` in order for the new module to be "
"noticed by the import system."
msgstr ""
"如果您正在動態導入自直譯器開始執行以來建立的模組（例如，建立 Python "
"源文件），您可能需要呼叫 invalidate_caches 以便導入系統注意到新模組。"

#: ../../library/importlib.rst:127
#, fuzzy
msgid "Parent packages are automatically imported."
msgstr "父包會自動導入。"

#: ../../library/importlib.rst:132
#, fuzzy
msgid ""
"Find the loader for a module, optionally within the specified *path*. If the "
"module is in :attr:`sys.modules`, then ``sys.modules[name].__loader__`` is "
"returned (unless the loader would be ``None`` or is not set, in which case :"
"exc:`ValueError` is raised). Otherwise a search using :attr:`sys.meta_path` "
"is done. ``None`` is returned if no loader is found."
msgstr ""
"查找模組的加載程式，可選地在指定的*路徑*中。如果模組在 :attr:`sys.modules` "
"中，則回傳 ``sys.modules[name].__loader__``（除非加載程式為 ``None`` "
"或未設定，在這種情況下：exc :`ValueError` 被引發）。否則使用 :attr:`sys."
"meta_path` 進行搜索。如果找不到加載程式，則回傳 ``None`` 。"

#: ../../library/importlib.rst:138
#, fuzzy
msgid ""
"A dotted name does not have its parents implicitly imported as that requires "
"loading them and that may not be desired. To properly import a submodule you "
"will need to import all parent packages of the submodule and use the correct "
"argument to *path*."
msgstr ""
"帶點的名稱不會隱式導入其父項，因為這需要加載它們，而這可能是不希望的。要正確"
"導入子模組，您需要導入子模組的所有父包並使用正確的 *path* 參數。"

#: ../../library/importlib.rst:145
#, fuzzy
msgid ""
"If ``__loader__`` is not set, raise :exc:`ValueError`, just like when the "
"attribute is set to ``None``."
msgstr "如果未設定 `__loader__``，引發 :exec:`ValueError`，就像屬性設定為 ``None`` "
"時一樣。"

#: ../../library/importlib.rst:149
#, fuzzy
msgid "Use :func:`importlib.util.find_spec` instead."
msgstr "使用 :func:`importlib.util.find_spec` 代替。"

#: ../../library/importlib.rst:154
#, fuzzy
msgid ""
"Invalidate the internal caches of finders stored at :data:`sys.meta_path`. "
"If a finder implements ``invalidate_caches()`` then it will be called to "
"perform the invalidation.  This function should be called if any modules are "
"created/installed while your program is running to guarantee all finders "
"will notice the new module's existence."
msgstr ""
"使儲存在 :data:`sys.meta_path` 的查找器的內部快取失效。如果查找器實作了“inval"
"idate_caches()”，那麼它將被呼叫來執行失效。如果在您的程式運行時建立/安裝了任"
"何模組，則應呼叫此函式，以確保所有發現者都會注意到新模組的存在。"

#: ../../library/importlib.rst:162
#, fuzzy
msgid ""
"Namespace packages created/installed in a different :data:`sys.path` "
"location after the same namespace was already imported are noticed."
msgstr "注意在已導入同一命名空間後在不同的 :data:`sys.path` "
"位置建立/安裝的命名空間包。"

#: ../../library/importlib.rst:168
#, fuzzy
msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is useful "
"if you have edited the module source file using an external editor and want "
"to try out the new version without leaving the Python interpreter.  The "
"return value is the module object (which can be different if re-importing "
"causes a different object to be placed in :data:`sys.modules`)."
msgstr ""
"重新加載以前導入的*模組*。參數必須是一個模組物件，所以它之前必須已經成功導入"
"。如果您使用外部編輯器編輯了模組源文件並且想在不離開 Python "
"直譯器的情況下試用新版本，這將很有用。回傳值是模組物件（"
"如果重新導入導致將不同的物件放置在 :data:`sys.modules` "
"中，則回傳值可能不同）。"

#: ../../library/importlib.rst:175
#, fuzzy
msgid "When :func:`reload` is executed:"
msgstr "當 :func:`reload` 被執行時："

#: ../../library/importlib.rst:177
#, fuzzy
msgid ""
"Python module's code is recompiled and the module-level code re-executed, "
"defining a new set of objects which are bound to names in the module's "
"dictionary by reusing the :term:`loader` which originally loaded the "
"module.  The ``init`` function of extension modules is not called a second "
"time."
msgstr ""
"重新編譯 Python 模組的程式碼並重新執行模組級程式碼，通過重用最初加載模組的 "
"loader 定義一組新的物件，這些物件綁定到模組字典中的名稱。擴充模組的 ``init`` "
"函式不會被第二次呼叫。"

#: ../../library/importlib.rst:183
#, fuzzy
msgid ""
"As with all other objects in Python the old objects are only reclaimed after "
"their reference counts drop to zero."
msgstr "與 Python 中的所有其他對像一樣，舊物件僅在其引用計數降至零後才會被回收。"

#: ../../library/importlib.rst:186
#, fuzzy
msgid ""
"The names in the module namespace are updated to point to any new or changed "
"objects."
msgstr "模組命名空間中的名稱被更新為指向任何新的或更改的物件。"

#: ../../library/importlib.rst:189
#, fuzzy
msgid ""
"Other references to the old objects (such as names external to the module) "
"are not rebound to refer to the new objects and must be updated in each "
"namespace where they occur if that is desired."
msgstr "對舊物件的其他引用（例如模組外部的名稱）不會重新綁定以引用新物件，並且如果需"
"要，必須在它們出現的每個命名空間中進行更新。"

#: ../../library/importlib.rst:193
#, fuzzy
msgid "There are a number of other caveats:"
msgstr "還有許多其他警告："

#: ../../library/importlib.rst:195
#, fuzzy
msgid ""
"When a module is reloaded, its dictionary (containing the module's global "
"variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a "
"module does not define a name that was defined by the old version, the old "
"definition remains.  This feature can be used to the module's advantage if "
"it maintains a global table or cache of objects --- with a :keyword:`try` "
"statement it can test for the table's presence and skip its initialization "
"if desired::"
msgstr ""
"重新加載模組時，會保留其字典（包含模組的全局變數）。名稱的重新定義將覆蓋舊定"
"義，因此這通常不是問題。如果模組的新版本沒有定義舊版本定義的名稱，則保留舊定"
"義。如果維護全局表或物件快取，則此功能可用於模組的優勢---使用 :keyword:`try` "
"語句，它可以測試表的存在並在需要時跳過其初始化::"

#: ../../library/importlib.rst:209
#, fuzzy
msgid ""
"It is generally not very useful to reload built-in or dynamically loaded "
"modules.  Reloading :mod:`sys`, :mod:`__main__`, :mod:`builtins` and other "
"key modules is not recommended.  In many cases extension modules are not "
"designed to be initialized more than once, and may fail in arbitrary ways "
"when reloaded."
msgstr ""
"重新加載內建或動態加載的模組通常不是很有用。不建議重新加載 "
":mod:`sys`、:mod:`__main__`、:mod:`builtins` 和其他關鍵模組。在許多情況下，擴"
"充模組不會被設計為多次初始化，並且在重新加載時可能會以任意方式失敗。"

#: ../../library/importlib.rst:215
#, fuzzy
msgid ""
"If a module imports objects from another module using :keyword:`from` ... :"
"keyword:`import` ..., calling :func:`reload` for the other module does not "
"redefine the objects imported from it --- one way around this is to re-"
"execute the :keyword:`!from` statement, another is to use :keyword:`!import` "
"and qualified names (*module.name*) instead."
msgstr ""
"如果一個模組使用 :keyword:`from` ... :keyword:`import` ... "
"從另一個模組導入物件，為另一個模組呼叫 :func:`reload` "
"不會重新定義從它導入的物件 ---解決此問題的一種方法是重新執行 :keyword:`!from`"
" 語句，另一種方法是使用 :keyword:`!import` 和限定名稱 (*module.name*) 代替。"

#: ../../library/importlib.rst:221
#, fuzzy
msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances "
"--- they continue to use the old class definition.  The same is true for "
"derived classes."
msgstr "如果一個模組實例化了一個類的實例，重新加載定義類的模組不會影響實例的方法定義—"
"—它們繼續使用舊的類定義。派生類也是如此。"

#: ../../library/importlib.rst:227
#, fuzzy
msgid ""
":exc:`ModuleNotFoundError` is raised when the module being reloaded lacks a :"
"class:`~importlib.machinery.ModuleSpec`."
msgstr ""
":exc:`ModuleNotFoundError` 在重新加載的模組缺少 :class:`~importlib.machinery."
"ModuleSpec` 時引發。"

#: ../../library/importlib.rst:233
#, fuzzy
msgid ":mod:`importlib.abc` -- Abstract base classes related to import"
msgstr ":mod:`importlib.abc` -- 與導入相關的抽象基底類別"

#: ../../library/importlib.rst:238
msgid "**Source code:** :source:`Lib/importlib/abc.py`"
msgstr "**原始碼：**\\ :source:`Lib/importlib/abc.py`"

#: ../../library/importlib.rst:243
#, fuzzy
msgid ""
"The :mod:`importlib.abc` module contains all of the core abstract base "
"classes used by :keyword:`import`. Some subclasses of the core abstract base "
"classes are also provided to help in implementing the core ABCs."
msgstr ""
":mod:`importlib.abc` 模組包含 :keyword:`import` "
"使用的所有核心抽象基底類別。還提供了核心抽象基底類別的一些子類別，"
"以幫助實作核心 ABC。"

#: ../../library/importlib.rst:247
#, fuzzy
msgid "ABC hierarchy::"
msgstr "ABC 層次結構::"

#: ../../library/importlib.rst:263
#, fuzzy
msgid "An abstract base class representing a :term:`finder`."
msgstr "表示 :term:`finder` 的抽象基底類別。"

#: ../../library/importlib.rst:265
#, fuzzy
msgid "Use :class:`MetaPathFinder` or :class:`PathEntryFinder` instead."
msgstr "請改用 MetaPathFinder 或 PathEntryFinder。"

#: ../../library/importlib.rst:270
#, fuzzy
msgid ""
"An abstract method for finding a :term:`loader` for the specified module.  "
"Originally specified in :pep:`302`, this method was meant for use in :data:"
"`sys.meta_path` and in the path-based import subsystem."
msgstr ""
"為指定模組查找 :term:`loader` 的抽象方法。最初在 :pep:`302` 中指定，"
"此方法用於 :data:`sys.meta_path` 和基於路徑的導入子系統。"

#: ../../library/importlib.rst:274
#, fuzzy
msgid ""
"Returns ``None`` when called instead of raising :exc:`NotImplementedError`."
msgstr "呼叫時回傳 ``None`` 而不是引發 :exc:`NotImplementedError`。"

#: ../../library/importlib.rst:278
#, fuzzy
msgid ""
"Implement :meth:`MetaPathFinder.find_spec` or :meth:`PathEntryFinder."
"find_spec` instead."
msgstr "改為實施 MetaPathFinder.find_spec 或 PathEntryFinder.find_spec。"

#: ../../library/importlib.rst:285
#, fuzzy
msgid "An abstract base class representing a :term:`meta path finder`."
msgstr "表示 :term:`元路徑查找器` 的抽象基底類別。"

#: ../../library/importlib.rst:289 ../../library/importlib.rst:344
#, fuzzy
msgid "No longer a subclass of :class:`Finder`."
msgstr "不再是 Finder 的子類別。"

#: ../../library/importlib.rst:294
#, fuzzy
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  If this is a top-level import, *path* will be ``None``.  "
"Otherwise, this is a search for a subpackage or module and *path* will be "
"the value of :attr:`__path__` from the parent package. If a spec cannot be "
"found, ``None`` is returned. When passed in, ``target`` is a module object "
"that the finder may use to make a more educated guess about what spec to "
"return. :func:`importlib.util.spec_from_loader` may be useful for "
"implementing concrete ``MetaPathFinders``."
msgstr ""
"為指定模組查找 :term:`spec <module spec>` "
"的抽象方法。如果這是頂級導入，*path* "
"將為 ``None``。否則，這是對子包或模組的搜索，*path* 將是來自父包的 "
":attr:`__path__` 的值。如果找不到規範，則回傳 ``None`` 。傳入時，``target`` "
"是一個模組物件，查找器可以使用它來對要回傳的規范進行更有根據的猜測。 "
":func:`importlib.util.spec_from_loader` 可能對實作具體的 ``MetaPathFinders`` "
"有用。"

#: ../../library/importlib.rst:308
#, fuzzy
msgid ""
"A legacy method for finding a :term:`loader` for the specified module.  If "
"this is a top-level import, *path* will be ``None``. Otherwise, this is a "
"search for a subpackage or module and *path* will be the value of :attr:"
"`__path__` from the parent package. If a loader cannot be found, ``None`` is "
"returned."
msgstr ""
"為指定模組查找 :term:`loader` 的傳統方法。如果這是頂級導入，*path* "
"將為 ``None``。否則，這是對子包或模組的搜索，*path* 將是來自父包的 "
":attr:`__path__` 的值。如果找不到加載程式，則回傳 ``None`` 。"

#: ../../library/importlib.rst:314
#, fuzzy
msgid ""
"If :meth:`find_spec` is defined, backwards-compatible functionality is "
"provided."
msgstr "如果定義了 :meth:`find_spec`，則提供向後相容的功能。"

#: ../../library/importlib.rst:317
#, fuzzy
msgid ""
"Returns ``None`` when called instead of raising :exc:`NotImplementedError`. "
"Can use :meth:`find_spec` to provide functionality."
msgstr ""
"呼叫時回傳 ``None`` 而不是引發 :exc:`NotImplementedError`。可以使用 "
":meth:`find_spec` 來提供功能。"

#: ../../library/importlib.rst:322 ../../library/importlib.rst:378
#: ../../library/importlib.rst:386 ../../library/importlib.rst:902
#: ../../library/importlib.rst:959
#, fuzzy
msgid "Use :meth:`find_spec` instead."
msgstr "使用 :meth:`find_spec` 代替。"

#: ../../library/importlib.rst:327
#, fuzzy
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :func:`importlib.invalidate_caches` when "
"invalidating the caches of all finders on :data:`sys.meta_path`."
msgstr ""
"一個可選的方法，在呼叫時應該使查找器使用的任何內部快取無效。 "
"importlib.invalidate_caches 在使 sys.meta_path 上所有查找器的快取無效時使用。"

#: ../../library/importlib.rst:331
#, fuzzy
msgid "Returns ``None`` when called instead of ``NotImplemented``."
msgstr "呼叫時回傳 ``None``而不是 ``NotImplemented`` 。"

#: ../../library/importlib.rst:337
#, fuzzy
msgid ""
"An abstract base class representing a :term:`path entry finder`.  Though it "
"bears some similarities to :class:`MetaPathFinder`, ``PathEntryFinder`` is "
"meant for use only within the path-based import subsystem provided by :class:"
"`importlib.machinery.PathFinder`."
msgstr ""
"一個表示 :term:`path entry finder` 的抽象基底類別。儘管它與 MetaPathFinder "
"有一些相似之處，但 PathEntryFinder 僅適用於 importlib.machinery.PathFinder "
"提供的基於路徑的導入子系統。"

#: ../../library/importlib.rst:349
#, fuzzy
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  The finder will search for the module only within the :"
"term:`path entry` to which it is assigned.  If a spec cannot be found, "
"``None`` is returned.  When passed in, ``target`` is a module object that "
"the finder may use to make a more educated guess about what spec to return. :"
"func:`importlib.util.spec_from_loader` may be useful for implementing "
"concrete ``PathEntryFinders``."
msgstr ""
"為指定模組查找 :term:`spec <module spec>` 的抽象方法。查找器將僅在分配給它的"
"路徑條目中搜索模組。如果找不到規範，則回傳 ``None`` 。傳入時，``target`` "
"是一個模組物件，查找器可以使用它來對要回傳的規范進行更有根據的猜測。 "
":func:`importlib.util.spec_from_loader` 可能對實作具體的 ``PathEntryFinders``"
" 有用。"

#: ../../library/importlib.rst:361
#, fuzzy
msgid ""
"A legacy method for finding a :term:`loader` for the specified module.  "
"Returns a 2-tuple of ``(loader, portion)`` where ``portion`` is a sequence "
"of file system locations contributing to part of a namespace package. The "
"loader may be ``None`` while specifying ``portion`` to signify the "
"contribution of the file system locations to a namespace package. An empty "
"list can be used for ``portion`` to signify the loader is not part of a "
"namespace package. If ``loader`` is ``None`` and ``portion`` is the empty "
"list then no loader or location for a namespace package were found (i.e. "
"failure to find anything for the module)."
msgstr ""
"為指定模組查找 :term:`loader` 的傳統方法。回傳 ``(loader, portion)`` "
"的二元組，其中 ``portion`` 是構成命名空間包一部分的一系列文件系統位置。加載程"
"序可以是 ``None`` ，同時指定“部分”以表示文件系統位置對命名空間包的貢獻。空列表可用"
"於“部分”以表示加載程式不是命名空間包的一部分。如果 ``loader`` 為 ``None`` 且 "
"``portion`` "
"為空列表，則找不到命名空間包的加載器或位置（即找不到模組的任何內容）。"

#: ../../library/importlib.rst:371
#, fuzzy
msgid ""
"If :meth:`find_spec` is defined then backwards-compatible functionality is "
"provided."
msgstr "如果定義了 :meth:`find_spec`，則提供向後相容的功能。"

#: ../../library/importlib.rst:374
#, fuzzy
msgid ""
"Returns ``(None, [])`` instead of raising :exc:`NotImplementedError`. Uses :"
"meth:`find_spec` when available to provide functionality."
msgstr ""
"回傳 ``(None, [])`` 而不是引發 :exec:`NotImplementedError`。在可用時使用 "
":meth:`find_spec` 來提供功能。"

#: ../../library/importlib.rst:383
#, fuzzy
msgid ""
"A concrete implementation of :meth:`Finder.find_module` which is equivalent "
"to ``self.find_loader(fullname)[0]``."
msgstr ":meth:`Finder.find_module` 的具體實作，相當於 ``self."
"find_loader(fullname)[0]``。"

#: ../../library/importlib.rst:391
#, fuzzy
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :meth:`importlib.machinery.PathFinder."
"invalidate_caches` when invalidating the caches of all cached finders."
msgstr ""
"一個可選的方法，在呼叫時應該使查找器使用的任何內部快取無效。 "
"importlib.machinery.PathFinder.invalidate_caches "
"在使所有快取查找器的快取無效時使用。"

#: ../../library/importlib.rst:399
#, fuzzy
msgid ""
"An abstract base class for a :term:`loader`. See :pep:`302` for the exact "
"definition for a loader."
msgstr ":term:`loader` 的抽象基底類別。有關加載程式的確切定義，請參閱 :pep:`302`。"

#: ../../library/importlib.rst:402
#, fuzzy
msgid ""
"Loaders that wish to support resource reading should implement a :meth:"
"`get_resource_reader` method as specified by :class:`importlib.resources.abc."
"ResourceReader`."
msgstr ""
"希望支援資源讀取的加載器應該實作由 importlib.resources.abc.ResourceReader "
"指定的 get_resource_reader 方法。"

#: ../../library/importlib.rst:406
#, fuzzy
msgid "Introduced the optional :meth:`get_resource_reader` method."
msgstr "引入了可選的 get_resource_reader 方法。"

#: ../../library/importlib.rst:411
#, fuzzy
msgid ""
"A method that returns the module object to use when importing a module.  "
"This method may return ``None``, indicating that default module creation "
"semantics should take place."
msgstr "回傳模組對像以在導入模組時使用的方法。此方法可能會回傳 ``None``，表示應該使用預"
"設的模組建立語義。"

#: ../../library/importlib.rst:417
#, fuzzy
msgid "This method is no longer optional when :meth:`exec_module` is defined."
msgstr "當定義了 :meth:`exec_module` 時，此方法不再是可選的。"

#: ../../library/importlib.rst:423
#, fuzzy
msgid ""
"An abstract method that executes the module in its own namespace when a "
"module is imported or reloaded.  The module should already be initialized "
"when :meth:`exec_module` is called.  When this method exists, :meth:"
"`create_module` must be defined."
msgstr ""
"導入或重新加載模組時在其自己的命名空間中執行模組的抽象方法。當 "
":meth:`exec_module` 被呼叫時，模組應該已經被初始化。當此方法存在時，必須定義 "
":meth:`create_module`。"

#: ../../library/importlib.rst:430
msgid ":meth:`create_module` must also be defined."
msgstr ":meth:`create_module` 也必須被定義。"

#: ../../library/importlib.rst:435
#, fuzzy
msgid ""
"A legacy method for loading a module.  If the module cannot be loaded, :exc:"
"`ImportError` is raised, otherwise the loaded module is returned."
msgstr "加載模組的遺留方法。如果無法加載模組，則引發 "
":exc:`ImportError`，否則回傳加載的模組。"

#: ../../library/importlib.rst:439
#, fuzzy
msgid ""
"If the requested module already exists in :data:`sys.modules`, that module "
"should be used and reloaded. Otherwise the loader should create a new module "
"and insert it into :data:`sys.modules` before any loading begins, to prevent "
"recursion from the import.  If the loader inserted a module and the load "
"fails, it must be removed by the loader from :data:`sys.modules`; modules "
"already in :data:`sys.modules` before the loader began execution should be "
"left alone (see :func:`importlib.util.module_for_loader`)."
msgstr ""
"如果請求的模組已存在於 :data:`sys.modules` 中，則應使用並重新加載該模組。"
"否則加載器應該建立一個新模組並在任何加載開始之前將其插入 :data:`sys."
"modules`，以防止導入遞迴。如果加載器插入了一個模組並且加載失敗，"
"它必須被加載器從 :data:`sys.modules` 中移除；在加載程式開始執行之前已經在 "
":data:`sys.modules` 中的模組應該單獨保留（參見 :func:`importlib.util."
"module_for_loader`）。"

#: ../../library/importlib.rst:448
#, fuzzy
msgid ""
"The loader should set several attributes on the module (note that some of "
"these attributes can change when a module is reloaded):"
msgstr "加載器應該在模組上設定幾個屬性（請注意，當重新加載模組時，其中一些屬性可能會"
"發生變化）："

#: ../../library/importlib.rst:454
msgid ":attr:`__name__`"
msgstr ":attr:`__name__`"

#: ../../library/importlib.rst:453
#, fuzzy
msgid ""
"The module's fully qualified name. It is ``'__main__'`` for an executed "
"module."
msgstr "模組的完全限定名稱。對於已執行的模組，它是 ``'__main__'``。"

#: ../../library/importlib.rst:459
msgid ":attr:`__file__`"
msgstr ":attr:`__file__`"

#: ../../library/importlib.rst:457
#, fuzzy
msgid ""
"The location the :term:`loader` used to load the module. For example, for "
"modules loaded from a .py file this is the filename. It is not set on all "
"modules (e.g. built-in modules)."
msgstr ":term:`loader` 用於加載模組的位置。例如，對於從 .py "
"文件加載的模組，這是文件名。它不是在所有模組上設定的（例如內建模組）。"

#: ../../library/importlib.rst:463
msgid ":attr:`__cached__`"
msgstr ":attr:`__cached__`"

#: ../../library/importlib.rst:462
#, fuzzy
msgid ""
"The filename of a compiled version of the module's code. It is not set on "
"all modules (e.g. built-in modules)."
msgstr "模組程式碼的編譯版本的文件名。它不是在所有模組上設定的（例如內建模組）。"

#: ../../library/importlib.rst:471
msgid ":attr:`__path__`"
msgstr ":attr:`__path__`"

#: ../../library/importlib.rst:466
#, fuzzy
msgid ""
"The list of locations where the package's submodules will be found. Most of "
"the time this is a single directory. The import system passes this attribute "
"to ``__import__()`` and to finders in the same way as :attr:`sys.path` but "
"just for the package. It is not set on non-package modules so it can be used "
"as an indicator that the module is a package."
msgstr ""
"將找到包的子模組的位置列表。大多數時候這是一個單一的目錄。"
"導入系統將此屬性傳遞給 ``__import__()`` 並以與 :attr:`sys.path` 相同的方式傳"
"遞給查找器，但只是針對包。它沒有在非包模組上設定，因此可以用作模組是包的指示"
"符。"

#: ../../library/importlib.rst:476
msgid ":attr:`__package__`"
msgstr ":attr:`__package__`"

#: ../../library/importlib.rst:474
#, fuzzy
msgid ""
"The fully qualified name of the package the module is in (or the empty "
"string for a top-level module). If the module is a package then this is the "
"same as :attr:`__name__`."
msgstr "模組所在包的完全限定名稱（或頂級模組的空字串）。如果模組是一個包，那麼這與 "
":attr:`__name__` 相同。"

#: ../../library/importlib.rst:479
msgid ":attr:`__loader__`"
msgstr ":attr:`__loader__`"

#: ../../library/importlib.rst:479
#, fuzzy
msgid "The :term:`loader` used to load the module."
msgstr ":term:`loader` 用於加載模組。"

#: ../../library/importlib.rst:481
#, fuzzy
msgid ""
"When :meth:`exec_module` is available then backwards-compatible "
"functionality is provided."
msgstr "當 :meth:`exec_module` 可用時，就會提供向後相容的功能。"

#: ../../library/importlib.rst:484
#, fuzzy
msgid ""
"Raise :exc:`ImportError` when called instead of :exc:`NotImplementedError`.  "
"Functionality provided when :meth:`exec_module` is available."
msgstr ""
"在呼叫時引發 :exc:`ImportError` 而不是 :exc:`NotImplementedError`。 "
"exec_module 可用時提供的功能。"

#: ../../library/importlib.rst:489
#, fuzzy
msgid ""
"The recommended API for loading a module is :meth:`exec_module` (and :meth:"
"`create_module`).  Loaders should implement it instead of :meth:"
"`load_module`.  The import machinery takes care of all the other "
"responsibilities of :meth:`load_module` when :meth:`exec_module` is "
"implemented."
msgstr ""
"推薦的用於加載模組的 API 是 :meth:`exec_module`（和 :meth:`create_module`）。"
"加載器應該實作它而不是 :meth:`load_module`。當 :meth:`exec_module` 被實作時，"
"導入機制負責 load_module 的所有其他職責。"

#: ../../library/importlib.rst:498
#, fuzzy
msgid ""
"A legacy method which when implemented calculates and returns the given "
"module's representation, as a string.  The module type's default :meth:"
"`__repr__` will use the result of this method as appropriate."
msgstr "一種遺留方法，在實作時計算並回傳給定模組的表示形式，作為字串。模組型別的預設 "
":meth:`__repr__` 將酌情使用此方法的結果。"

#: ../../library/importlib.rst:504
#, fuzzy
msgid "Made optional instead of an abstractmethod."
msgstr "使可選而不是抽象方法。"

#: ../../library/importlib.rst:507
#, fuzzy
msgid "The import machinery now takes care of this automatically."
msgstr "進口機器現在自動處理這個。"

#: ../../library/importlib.rst:513
#, fuzzy
msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loading arbitrary resources from the storage back-end."
msgstr ":term:`loader` 的抽象基底類別，它實作可選的 :pep:`302` "
"協定，用於從儲存後端加載任意資源。"

#: ../../library/importlib.rst:517
#, fuzzy
msgid ""
"This ABC is deprecated in favour of supporting resource loading through :"
"class:`importlib.resources.abc.ResourceReader`."
msgstr "此 ABC 已棄用，支援通過 importlib.resources.abc.ResourceReader 加載資源。"

#: ../../library/importlib.rst:523
#, fuzzy
msgid ""
"An abstract method to return the bytes for the data located at *path*. "
"Loaders that have a file-like storage back-end that allows storing arbitrary "
"data can implement this abstract method to give direct access to the data "
"stored. :exc:`OSError` is to be raised if the *path* cannot be found. The "
"*path* is expected to be constructed using a module's :attr:`__file__` "
"attribute or an item from a package's :attr:`__path__`."
msgstr ""
"回傳位於 *path* 的資料位元組的抽象方法。具有允許儲存任意資料的類文件儲存後端"
"的加載器可以實作此抽象方法以直接訪問儲存的資料。 :exc:`OSError` 如果找不到 "
"*path* 將被引發。 *path* 應該使用模組的 :attr:`__file__` 屬性或來自包的 "
":attr:`__path__` 的項目來構建。"

#: ../../library/importlib.rst:531
#, fuzzy
msgid "Raises :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "引發 :exc:`OSError` 而不是 :exc:`NotImplementedError`。"

#: ../../library/importlib.rst:537
#, fuzzy
msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loaders that inspect modules."
msgstr ":term:`loader` 的抽象基底類別，它為檢查模組的加載程式實作可選的 :pep:`302` "
"協定。"

#: ../../library/importlib.rst:542
#, fuzzy
msgid ""
"Return the code object for a module, or ``None`` if the module does not have "
"a code object (as would be the case, for example, for a built-in module).  "
"Raise an :exc:`ImportError` if loader cannot find the requested module."
msgstr ""
"回傳模組的程式碼物件，如果模組沒有程式碼物件（例如，內建模組就是這種情況），"
"則回傳 ``None``。如果加載程式找不到請求的模組，則引發 :exc:`ImportError`。"

#: ../../library/importlib.rst:548
#, fuzzy
msgid ""
"While the method has a default implementation, it is suggested that it be "
"overridden if possible for performance."
msgstr "雖然該方法具有預設實作，但建議在可能的情況下覆蓋它以提高性能。"

#: ../../library/importlib.rst:554
#, fuzzy
msgid "No longer abstract and a concrete implementation is provided."
msgstr "不再抽象，給出具體實作。"

#: ../../library/importlib.rst:559
#, fuzzy
msgid ""
"An abstract method to return the source of a module. It is returned as a "
"text string using :term:`universal newlines`, translating all recognized "
"line separators into ``'\\n'`` characters.  Returns ``None`` if no source is "
"available (e.g. a built-in module). Raises :exc:`ImportError` if the loader "
"cannot find the module specified."
msgstr ""
"回傳模組源的抽象方法。它使用 :term:`universal newlines` 作為文本字串回傳，"
"將所有可識別的行分隔符轉換為 ``'\\n"
"'`` 字元。如果沒有可用的源（例如內建模組），則回傳 ``None`` 。如果加載程式找不到指"
"定的模組，則引發 :exc:`ImportError`。"

#: ../../library/importlib.rst:565 ../../library/importlib.rst:574
#: ../../library/importlib.rst:624
#, fuzzy
msgid "Raises :exc:`ImportError` instead of :exc:`NotImplementedError`."
msgstr "引發 :exc:`ImportError` 而不是 :exc:`NotImplementedError`。"

#: ../../library/importlib.rst:570
#, fuzzy
msgid ""
"An optional method to return a true value if the module is a package, a "
"false value otherwise. :exc:`ImportError` is raised if the :term:`loader` "
"cannot find the module."
msgstr "如果模組是包，則回傳真值的可選方法，否則回傳假值。如果 loader 找不到模組，"
"則會引發 ImportError。"

#: ../../library/importlib.rst:579
#, fuzzy
msgid "Create a code object from Python source."
msgstr "從 Python 源程式碼建立一個程式碼物件。"

#: ../../library/importlib.rst:581
#, fuzzy
msgid ""
"The *data* argument can be whatever the :func:`compile` function supports (i."
"e. string or bytes). The *path* argument should be the \"path\" to where the "
"source code originated from, which can be an abstract concept (e.g. location "
"in a zip file)."
msgstr ""
"*data* 參數可以是 :func:`compile` 函式支援的任何內容（即字串或位元組）。 "
"*path* 參數應該是源程式碼來源的“路徑”，它可以是一個抽象概念（例如 zip "
"文件中的位置）。"

#: ../../library/importlib.rst:586
#, fuzzy
msgid ""
"With the subsequent code object one can execute it in a module by running "
"``exec(code, module.__dict__)``."
msgstr "使用後續程式碼物件，可以通過運行 exec(code, module.__dict__) "
"來在模組中執行它。"

#: ../../library/importlib.rst:591
#, fuzzy
msgid "Made the method static."
msgstr "使方法靜態。"

#: ../../library/importlib.rst:596
#, fuzzy
msgid "Implementation of :meth:`Loader.exec_module`."
msgstr ":meth:`Loader.exec_module` 的實作。"

#: ../../library/importlib.rst:602
#, fuzzy
msgid "Implementation of :meth:`Loader.load_module`."
msgstr ":meth:`Loader.load_module` 的實作。"

#: ../../library/importlib.rst:604
#, fuzzy
msgid "use :meth:`exec_module` instead."
msgstr "使用 :meth:`exec_module` 代替。"

#: ../../library/importlib.rst:610
#, fuzzy
msgid ""
"An abstract base class which inherits from :class:`InspectLoader` that, when "
"implemented, helps a module to be executed as a script. The ABC represents "
"an optional :pep:`302` protocol."
msgstr "一個繼承自 InspectLoader 的抽象基底類別，在實作時幫助模組作為腳本執行。 ABC "
"代表一個可選的 :pep:`302` 協定。"

#: ../../library/importlib.rst:616
#, fuzzy
msgid ""
"An abstract method that is to return the value of :attr:`__file__` for the "
"specified module. If no path is available, :exc:`ImportError` is raised."
msgstr "一個抽象方法，回傳指定模組的 :attr:`__file__` "
"的值。如果沒有可用路徑，則會引發 :exec:`ImportError`。"

#: ../../library/importlib.rst:620
#, fuzzy
msgid ""
"If source code is available, then the method should return the path to the "
"source file, regardless of whether a bytecode was used to load the module."
msgstr "如果源程式碼可用，則該方法應回傳源文件的路徑，而不管是否使用位元組碼加載模組"
"。"

#: ../../library/importlib.rst:630
#, fuzzy
msgid ""
"An abstract base class which inherits from :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, providing concrete implementations of :meth:"
"`ResourceLoader.get_data` and :meth:`ExecutionLoader.get_filename`."
msgstr ""
"繼承自 ResourceLoader 和 ExecutionLoader 的抽象基底類別，提供 "
"ResourceLoader.get_data 和 ExecutionLoader.get_filename 的具體實作。"

#: ../../library/importlib.rst:634
#, fuzzy
msgid ""
"The *fullname* argument is a fully resolved name of the module the loader is "
"to handle. The *path* argument is the path to the file for the module."
msgstr "*fullname* 參數是加載程式要處理的模組的完全解析名稱。 *path* "
"參數是模組文件的路徑。"

#: ../../library/importlib.rst:641
#, fuzzy
msgid "The name of the module the loader can handle."
msgstr "加載程式可以處理的模組的名稱。"

#: ../../library/importlib.rst:645
#, fuzzy
msgid "Path to the file of the module."
msgstr "模組文件的路徑。"

#: ../../library/importlib.rst:649
#, fuzzy
msgid "Calls super's ``load_module()``."
msgstr "呼叫 super 的 ``load_module()``。"

#: ../../library/importlib.rst:651
#, fuzzy
msgid "Use :meth:`Loader.exec_module` instead."
msgstr "使用 :meth:`Loader.exec_module` 代替。"

#: ../../library/importlib.rst:656 ../../library/importlib.rst:1104
#, fuzzy
msgid "Returns :attr:`path`."
msgstr "回傳 :attr:`path`。"

#: ../../library/importlib.rst:660
#, fuzzy
msgid "Reads *path* as a binary file and returns the bytes from it."
msgstr "將 *path* 作為二進位文件讀取並從中回傳位元組。"

#: ../../library/importlib.rst:665
#, fuzzy
msgid ""
"An abstract base class for implementing source (and optionally bytecode) "
"file loading. The class inherits from both :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, requiring the implementation of:"
msgstr "用於實作源（和可選的位元組碼）文件加載的抽象基底類別。該類繼承自 "
"ResourceLoader 和 ExecutionLoader，需要實作："

#: ../../library/importlib.rst:669
msgid ":meth:`ResourceLoader.get_data`"
msgstr ":meth:`ResourceLoader.get_data`"

#: ../../library/importlib.rst:672
msgid ":meth:`ExecutionLoader.get_filename`"
msgstr ":meth:`ExecutionLoader.get_filename`"

#: ../../library/importlib.rst:671
#, fuzzy
msgid ""
"Should only return the path to the source file; sourceless loading is not "
"supported."
msgstr "應該只回傳源文件的路徑；不支援無源加載。"

#: ../../library/importlib.rst:674
#, fuzzy
msgid ""
"The abstract methods defined by this class are to add optional bytecode file "
"support. Not implementing these optional methods (or causing them to raise :"
"exc:`NotImplementedError`) causes the loader to only work with source code. "
"Implementing the methods allows the loader to work with source *and* "
"bytecode files; it does not allow for *sourceless* loading where only "
"bytecode is provided.  Bytecode files are an optimization to speed up "
"loading by removing the parsing step of Python's compiler, and so no "
"bytecode-specific API is exposed."
msgstr ""
"此類定義的抽象方法用於新增可選的位元組碼文件支援。不實作這些可選方法（"
"或導致它們引發 :exc:`NotImplementedError`）會導致加載程式只能使用源程式碼。"
"實作這些方法允許加載器使用源 * 和 * 位元組碼文件；它不允許在僅提供位元組碼的"
"情況下進行*無源*加載。位元組碼文件是一種最佳化，通過刪除 Python "
"編譯器的解析步驟來加速加載，因此沒有暴露特定於位元組碼的 API。"

#: ../../library/importlib.rst:685
#, fuzzy
msgid ""
"Optional abstract method which returns a :class:`dict` containing metadata "
"about the specified path.  Supported dictionary keys are:"
msgstr "可選的抽象方法，它回傳一個包含有關指定路徑的元資料的 "
":class:`dict`。支援的字典鍵是："

#: ../../library/importlib.rst:688
#, fuzzy
msgid ""
"``'mtime'`` (mandatory): an integer or floating-point number representing "
"the modification time of the source code;"
msgstr "``'mtime'``（必選）：表示源程式碼修改時間的整數或浮點數；"

#: ../../library/importlib.rst:690
#, fuzzy
msgid "``'size'`` (optional): the size in bytes of the source code."
msgstr "``'size'``（可選）：源程式碼的位元組大小。"

#: ../../library/importlib.rst:692
#, fuzzy
msgid ""
"Any other keys in the dictionary are ignored, to allow for future "
"extensions. If the path cannot be handled, :exc:`OSError` is raised."
msgstr "字典中的任何其他鍵都將被忽略，以允許將來擴充。如果無法處理路徑，則會引發：exc"
":`OSError`。"

#: ../../library/importlib.rst:697 ../../library/importlib.rst:710
#, fuzzy
msgid "Raise :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "提高 :exc:`OSError` 而不是 :exc:`NotImplementedError`。"

#: ../../library/importlib.rst:702
#, fuzzy
msgid ""
"Optional abstract method which returns the modification time for the "
"specified path."
msgstr "回傳指定路徑的修改時間的可選抽象方法。"

#: ../../library/importlib.rst:705
#, fuzzy
msgid ""
"This method is deprecated in favour of :meth:`path_stats`.  You don't have "
"to implement it, but it is still available for compatibility purposes. "
"Raise :exc:`OSError` if the path cannot be handled."
msgstr ""
"此方法已棄用，取而代之的是 :meth:`path_stats`。您不必實施它，但出於相容性目的"
"，它仍然可用。如果無法處理路徑，則引發 :exc:`OSError`。"

#: ../../library/importlib.rst:715
#, fuzzy
msgid ""
"Optional abstract method which writes the specified bytes to a file path. "
"Any intermediate directories which do not exist are to be created "
"automatically."
msgstr "將指定位元組寫入文件路徑的可選抽象方法。將自動建立任何不存在的中間目錄。"

#: ../../library/importlib.rst:719
#, fuzzy
msgid ""
"When writing to the path fails because the path is read-only (:attr:`errno."
"EACCES`/:exc:`PermissionError`), do not propagate the exception."
msgstr "當由於路徑是只讀的（:attr:`errno."
"EACCES`/:exc:`PermissionError`）而寫入路徑失敗時，不要傳播例外。"

#: ../../library/importlib.rst:723
#, fuzzy
msgid "No longer raises :exc:`NotImplementedError` when called."
msgstr "呼叫時不再引發 :exc:`NotImplementedError`。"

#: ../../library/importlib.rst:728
#, fuzzy
msgid "Concrete implementation of :meth:`InspectLoader.get_code`."
msgstr "InspectLoader.get_code 的具體實作。"

#: ../../library/importlib.rst:732
#, fuzzy
msgid "Concrete implementation of :meth:`Loader.exec_module`."
msgstr "Loader.exec_module 的具體實作。"

#: ../../library/importlib.rst:738
#, fuzzy
msgid "Concrete implementation of :meth:`Loader.load_module`."
msgstr "Loader.load_module 的具體實作。"

#: ../../library/importlib.rst:740
#, fuzzy
msgid "Use :meth:`exec_module` instead."
msgstr "使用 :meth:`exec_module` 代替。"

#: ../../library/importlib.rst:745
#, fuzzy
msgid "Concrete implementation of :meth:`InspectLoader.get_source`."
msgstr "InspectLoader.get_source 的具體實作。"

#: ../../library/importlib.rst:749
#, fuzzy
msgid ""
"Concrete implementation of :meth:`InspectLoader.is_package`. A module is "
"determined to be a package if its file path (as provided by :meth:"
"`ExecutionLoader.get_filename`) is a file named ``__init__`` when the file "
"extension is removed **and** the module name itself does not end in "
"``__init__``."
msgstr ""
"InspectLoader.is_package 的具體實作。如果一個模組的文件路徑（由 "
"ExecutionLoader.get_filename 提供）是一個名為 ``__init__`` "
"的文件，當文件擴充名被刪除時，模組被確定為一個包 ** 並且 ** "
"模組名稱本身確實如此不以 ``__init__`` 結尾。"

#: ../../library/importlib.rst:758
#, fuzzy
msgid ":mod:`importlib.machinery` -- Importers and path hooks"
msgstr ":mod:`importlib.machinery` -- 導入器和路徑掛鉤"

#: ../../library/importlib.rst:763
msgid "**Source code:** :source:`Lib/importlib/machinery.py`"
msgstr "**原始碼：**\\ :source:`Lib/importlib/machinery.py`"

#: ../../library/importlib.rst:767
#, fuzzy
msgid ""
"This module contains the various objects that help :keyword:`import` find "
"and load modules."
msgstr "該模組包含各種幫助 :keyword:`import` 查找和加載模組的物件。"

#: ../../library/importlib.rst:772
#, fuzzy
msgid ""
"A list of strings representing the recognized file suffixes for source "
"modules."
msgstr "表示源模組的已識別文件後綴的字串列表。"

#: ../../library/importlib.rst:779
#, fuzzy
msgid ""
"A list of strings representing the file suffixes for non-optimized bytecode "
"modules."
msgstr "表示未最佳化位元組碼模組的文件後綴的字串列表。"

#: ../../library/importlib.rst:784 ../../library/importlib.rst:794
#, fuzzy
msgid "Use :attr:`BYTECODE_SUFFIXES` instead."
msgstr "請改用 BYTECODE_SUFFIXES。"

#: ../../library/importlib.rst:789
#, fuzzy
msgid ""
"A list of strings representing the file suffixes for optimized bytecode "
"modules."
msgstr "表示最佳化位元組碼模組的文件後綴的字串列表。"

#: ../../library/importlib.rst:799
#, fuzzy
msgid ""
"A list of strings representing the recognized file suffixes for bytecode "
"modules (including the leading dot)."
msgstr "表示位元組碼模組（包括前導點）的已識別文件後綴的字串列表。"

#: ../../library/importlib.rst:804
#, fuzzy
msgid "The value is no longer dependent on ``__debug__``."
msgstr "該值不再依賴於``__debug__``。"

#: ../../library/importlib.rst:809
#, fuzzy
msgid ""
"A list of strings representing the recognized file suffixes for extension "
"modules."
msgstr "表示擴充模組的已識別文件後綴的字串列表。"

#: ../../library/importlib.rst:816
#, fuzzy
msgid ""
"Returns a combined list of strings representing all file suffixes for "
"modules recognized by the standard import machinery. This is a helper for "
"code which simply needs to know if a filesystem path potentially refers to a "
"module without needing any details on the kind of module (for example, :func:"
"`inspect.getmodulename`)."
msgstr ""
"回傳表示標準導入機制識別的模組的所有文件後綴的字串組合列表。這是程式碼的幫助"
"程式，它只需要知道文件系統路徑是否可能引用模組，而不需要有關模組型別的任何詳"
"細資訊（例如，:func:`inspect.getmodulename`）。"

#: ../../library/importlib.rst:827
#, fuzzy
msgid ""
"An :term:`importer` for built-in modules. All known built-in modules are "
"listed in :data:`sys.builtin_module_names`. This class implements the :class:"
"`importlib.abc.MetaPathFinder` and :class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"內建模組的 :term:`importer`。所有已知的內建模組都列在 :data:`sys."
"builtin_module_names` 中。此類實作 importlib.abc.MetaPathFinder 和 "
"importlib.abc.InspectLoader ABC。"

#: ../../library/importlib.rst:832 ../../library/importlib.rst:846
#: ../../library/importlib.rst:859 ../../library/importlib.rst:874
#, fuzzy
msgid ""
"Only class methods are defined by this class to alleviate the need for "
"instantiation."
msgstr "此類僅定義類方法以減少實例化的需要。"

#: ../../library/importlib.rst:835
#, fuzzy
msgid ""
"As part of :pep:`489`, the builtin importer now implements :meth:`Loader."
"create_module` and :meth:`Loader.exec_module`"
msgstr ""
"作為 :pep:`489` 的一部分，內建導入器現在實作了 :meth:`Loader.create_module` "
"和 :meth:`Loader.exec_module`"

#: ../../library/importlib.rst:842
#, fuzzy
msgid ""
"An :term:`importer` for frozen modules. This class implements the :class:"
"`importlib.abc.MetaPathFinder` and :class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"凍結模組的 :term:`importer`。此類實作 importlib.abc.MetaPathFinder 和 "
"importlib.abc.InspectLoader ABC。"

#: ../../library/importlib.rst:849
#, fuzzy
msgid ""
"Gained :meth:`~Loader.create_module` and :meth:`~Loader.exec_module` methods."
msgstr "獲得 :meth:`~Loader.create_module` 和 :meth:`~Loader.exec_module` 方法。"

#: ../../library/importlib.rst:856
#, fuzzy
msgid ""
":term:`Finder <finder>` for modules declared in the Windows registry.  This "
"class implements the :class:`importlib.abc.MetaPathFinder` ABC."
msgstr ""
":term:`Finder <finder>` 用於在 Windows 註冊表中聲明的模組。此類實作 "
"importlib.abc.MetaPathFinder ABC。"

#: ../../library/importlib.rst:864
#, fuzzy
msgid ""
"Use :mod:`site` configuration instead. Future versions of Python may not "
"enable this finder by default."
msgstr "請改用 :mod:`site` 配置。預設情況下，未來版本的 Python 可能不會啟用此查找器。"

#: ../../library/importlib.rst:871
#, fuzzy
msgid ""
"A :term:`Finder <finder>` for :data:`sys.path` and package ``__path__`` "
"attributes. This class implements the :class:`importlib.abc.MetaPathFinder` "
"ABC."
msgstr ""
"一個 :term:`Finder <finder>` 用於 :data:`sys.path` 和包 ``__path__`` 屬性。"
"此類實作 importlib.abc.MetaPathFinder ABC。"

#: ../../library/importlib.rst:879
#, fuzzy
msgid ""
"Class method that attempts to find a :term:`spec <module spec>` for the "
"module specified by *fullname* on :data:`sys.path` or, if defined, on "
"*path*. For each path entry that is searched, :data:`sys."
"path_importer_cache` is checked. If a non-false object is found then it is "
"used as the :term:`path entry finder` to look for the module being searched "
"for. If no entry is found in :data:`sys.path_importer_cache`, then :data:"
"`sys.path_hooks` is searched for a finder for the path entry and, if found, "
"is stored in :data:`sys.path_importer_cache` along with being queried about "
"the module. If no finder is ever found then ``None`` is both stored in the "
"cache and returned."
msgstr ""
"類方法試圖為由 *fullname* 指定的模組在 :data:`sys.path` 或者，如果已定義，"
"則在 *path* 上找到 :term:`spec <module "
"spec>`。對於搜索到的每個路徑條目，都會檢查 :data:`sys."
"path_importer_cache`。如果找到非假物件，則將其用作 :term:`path entry finder` "
"以查找正在搜索的模組。如果在 :data:`sys.path_importer_cache` 中沒有找到條目，"
"則在 :data:`sys.path_hooks` 中搜索路徑條目的查找器，如果找到，則儲存在 "
":data:`sys.path_importer_cache` "
"中被詢問有關模組的資訊。如果沒有找到查找器，則將 ``None``儲存在快取中並回傳。"

#: ../../library/importlib.rst:893
#, fuzzy
msgid ""
"If the current working directory -- represented by an empty string -- is no "
"longer valid then ``None`` is returned but no value is cached in :data:`sys."
"path_importer_cache`."
msgstr "如果當前工作目錄——由空字串表示——不再有效，則回傳 ``None`` 但沒有值快取在 "
"sys.path_importer_cache 中。"

#: ../../library/importlib.rst:900
#, fuzzy
msgid "A legacy wrapper around :meth:`find_spec`."
msgstr ":meth:`find_spec` 的遺留包裝器。"

#: ../../library/importlib.rst:907
#, fuzzy
msgid ""
"Calls :meth:`importlib.abc.PathEntryFinder.invalidate_caches` on all finders "
"stored in :data:`sys.path_importer_cache` that define the method. Otherwise "
"entries in :data:`sys.path_importer_cache` set to ``None`` are deleted."
msgstr ""
"在定義方法的 sys.path_importer_cache 中儲存的所有查找器上呼叫 "
"importlib.abc.PathEntryFinder.invalidate_caches 。否則，將刪除 "
"sys.path_importer_cache 中設定為 ``None`` 的條目。"

#: ../../library/importlib.rst:912
#, fuzzy
msgid "Entries of ``None`` in :data:`sys.path_importer_cache` are deleted."
msgstr ":data:`sys.path_importer_cache` 中的 ``None`` 條目被刪除。"

#: ../../library/importlib.rst:915
#, fuzzy
msgid ""
"Calls objects in :data:`sys.path_hooks` with the current working directory "
"for ``''`` (i.e. the empty string)."
msgstr "使用 ``''`` 的當前工作目錄（即空字串）呼叫 :data:`sys.path_hooks` 中的物件。"

#: ../../library/importlib.rst:922
#, fuzzy
msgid ""
"A concrete implementation of :class:`importlib.abc.PathEntryFinder` which "
"caches results from the file system."
msgstr "importlib.abc.PathEntryFinder 的具體實作，它快取來自文件系統的結果。"

#: ../../library/importlib.rst:925
#, fuzzy
msgid ""
"The *path* argument is the directory for which the finder is in charge of "
"searching."
msgstr "*path* 參數是查找器負責搜索的目錄。"

#: ../../library/importlib.rst:928
#, fuzzy
msgid ""
"The *loader_details* argument is a variable number of 2-item tuples each "
"containing a loader and a sequence of file suffixes the loader recognizes. "
"The loaders are expected to be callables which accept two arguments of the "
"module's name and the path to the file found."
msgstr ""
"*loader_details* 參數是可變數量的 2 項元組，每個元組包含一個加載器和加載器識"
"別的一系列文件後綴。加載器應該是可呼叫的，它接受模組名稱和找到的文件路徑的兩"
"個參數。"

#: ../../library/importlib.rst:933
#, fuzzy
msgid ""
"The finder will cache the directory contents as necessary, making stat calls "
"for each module search to verify the cache is not outdated. Because cache "
"staleness relies upon the granularity of the operating system's state "
"information of the file system, there is a potential race condition of "
"searching for a module, creating a new file, and then searching for the "
"module the new file represents. If the operations happen fast enough to fit "
"within the granularity of stat calls, then the module search will fail. To "
"prevent this from happening, when you create a module dynamically, make sure "
"to call :func:`importlib.invalidate_caches`."
msgstr ""
"查找器將根據需要快取目錄內容，對每個模組搜索進行統計呼叫以驗證快取是否過時。"
"因為快取過時依賴於文件系統的操作系統狀態資訊的粒度，所以存在搜索模組、建立新"
"文件然後搜索新文件代表的模組的潛在競爭條件。如果操作發生的速度足夠快以適應 "
"stat 呼叫的粒度，那麼模組搜索將失敗。為防止這種情況發生，當您動態建立模組時，"
"請確保呼叫 :func:`importlib.invalidate_caches`。"

#: ../../library/importlib.rst:947
#, fuzzy
msgid "The path the finder will search in."
msgstr "查找器將搜索的路徑。"

#: ../../library/importlib.rst:951
#, fuzzy
msgid "Attempt to find the spec to handle *fullname* within :attr:`path`."
msgstr "嘗試在 :attr:`path` 中找到處理 *fullname* 的規範。"

#: ../../library/importlib.rst:957
#, fuzzy
msgid "Attempt to find the loader to handle *fullname* within :attr:`path`."
msgstr "嘗試在 :attr:`path` 中找到處理 *fullname* 的加載器。"

#: ../../library/importlib.rst:964
#, fuzzy
msgid "Clear out the internal cache."
msgstr "清除內部快取。"

#: ../../library/importlib.rst:968
#, fuzzy
msgid ""
"A class method which returns a closure for use on :attr:`sys.path_hooks`. An "
"instance of :class:`FileFinder` is returned by the closure using the path "
"argument given to the closure directly and *loader_details* indirectly."
msgstr ""
"一個回傳閉包的類方法，用於 :attr:`sys.path_hooks`。 :class:`FileFinder` "
"的一個實例由閉包使用直接給閉包的路徑參數和間接地 *loader_details* 回傳。"

#: ../../library/importlib.rst:973
#, fuzzy
msgid ""
"If the argument to the closure is not an existing directory, :exc:"
"`ImportError` is raised."
msgstr "如果閉包的參數不是現有目錄，則會引發 :exc:`ImportError`。"

#: ../../library/importlib.rst:979
#, fuzzy
msgid ""
"A concrete implementation of :class:`importlib.abc.SourceLoader` by "
"subclassing :class:`importlib.abc.FileLoader` and providing some concrete "
"implementations of other methods."
msgstr ""
"importlib.abc.SourceLoader 的具體實作，通過子類別化 importlib.abc.FileLoader "
"並提供其他方法的一些具體實作。"

#: ../../library/importlib.rst:987
#, fuzzy
msgid "The name of the module that this loader will handle."
msgstr "此加載程式將處理的模組的名稱。"

#: ../../library/importlib.rst:991
#, fuzzy
msgid "The path to the source file."
msgstr "源文件的路徑。"

#: ../../library/importlib.rst:995
#, fuzzy
msgid "Return ``True`` if :attr:`path` appears to be for a package."
msgstr "如果 :attr:`path` 似乎是一個包，則回傳 ``True``。"

#: ../../library/importlib.rst:999
#, fuzzy
msgid ""
"Concrete implementation of :meth:`importlib.abc.SourceLoader.path_stats`."
msgstr "importlib.abc.SourceLoader.path_stats 的具體實作。"

#: ../../library/importlib.rst:1003
#, fuzzy
msgid "Concrete implementation of :meth:`importlib.abc.SourceLoader.set_data`."
msgstr "importlib.abc.SourceLoader.set_data 的具體實作。"

#: ../../library/importlib.rst:1007 ../../library/importlib.rst:1050
#, fuzzy
msgid ""
"Concrete implementation of :meth:`importlib.abc.Loader.load_module` where "
"specifying the name of the module to load is optional."
msgstr "importlib.abc.Loader.load_module "
"的具體實作，其中指定要加載的模組的名稱是可選的。"

#: ../../library/importlib.rst:1012 ../../library/importlib.rst:1055
#, fuzzy
msgid "Use :meth:`importlib.abc.Loader.exec_module` instead."
msgstr "使用 :meth:`importlib.abc.Loader.exec_module` 代替。"

#: ../../library/importlib.rst:1017
#, fuzzy
msgid ""
"A concrete implementation of :class:`importlib.abc.FileLoader` which can "
"import bytecode files (i.e. no source code files exist)."
msgstr "importlib.abc.FileLoader "
"的具體實作，它可以導入位元組碼文件（即不存在源程式碼文件）。"

#: ../../library/importlib.rst:1020
#, fuzzy
msgid ""
"Please note that direct use of bytecode files (and thus not source code "
"files) inhibits your modules from being usable by all Python implementations "
"or new versions of Python which change the bytecode format."
msgstr "請注意，直接使用位元組碼文件（因此不是源程式碼文件）會阻止您的模組被所有 "
"Python 實作或更改位元組碼格式的 Python 新版本使用。"

#: ../../library/importlib.rst:1029
#, fuzzy
msgid "The name of the module the loader will handle."
msgstr "加載程式將處理的模組的名稱。"

#: ../../library/importlib.rst:1033
#, fuzzy
msgid "The path to the bytecode file."
msgstr "位元組碼文件的路徑。"

#: ../../library/importlib.rst:1037
#, fuzzy
msgid "Determines if the module is a package based on :attr:`path`."
msgstr "確定模組是否是基於 :attr:`path` 的包。"

#: ../../library/importlib.rst:1041
#, fuzzy
msgid "Returns the code object for :attr:`name` created from :attr:`path`."
msgstr "回傳從 :attr:`path` 建立的 :attr:`name` 的程式碼物件。"

#: ../../library/importlib.rst:1045
#, fuzzy
msgid ""
"Returns ``None`` as bytecode files have no source when this loader is used."
msgstr "回傳 ``None`` ，因為使用此加載器時位元組碼文件沒有源。"

#: ../../library/importlib.rst:1060
#, fuzzy
msgid ""
"A concrete implementation of :class:`importlib.abc.ExecutionLoader` for "
"extension modules."
msgstr "擴充模組的 importlib.abc.ExecutionLoader 的具體實作。"

#: ../../library/importlib.rst:1063
#, fuzzy
msgid ""
"The *fullname* argument specifies the name of the module the loader is to "
"support. The *path* argument is the path to the extension module's file."
msgstr "*fullname* 參數指定加載器要支援的模組的名稱。 *path* "
"參數是擴充模組文件的路徑。"

#: ../../library/importlib.rst:1070
#, fuzzy
msgid "Name of the module the loader supports."
msgstr "加載程式支援的模組的名稱。"

#: ../../library/importlib.rst:1074
#, fuzzy
msgid "Path to the extension module."
msgstr "擴充模組的路徑。"

#: ../../library/importlib.rst:1078
#, fuzzy
msgid ""
"Creates the module object from the given specification in accordance with :"
"pep:`489`."
msgstr "根據 :pep:`489` 從給定的規範建立模組物件。"

#: ../../library/importlib.rst:1085
#, fuzzy
msgid "Initializes the given module object in accordance with :pep:`489`."
msgstr "根據 :pep:`489` 初始化給定的模組物件。"

#: ../../library/importlib.rst:1091
#, fuzzy
msgid ""
"Returns ``True`` if the file path points to a package's ``__init__`` module "
"based on :attr:`EXTENSION_SUFFIXES`."
msgstr "如果文件路徑指向基於 EXTENSION_SUFFIXES 的包的 __init__ 模組，則回傳 True。"

#: ../../library/importlib.rst:1096
#, fuzzy
msgid "Returns ``None`` as extension modules lack a code object."
msgstr "回傳 ``None`` ，因為擴充模組缺少程式碼物件。"

#: ../../library/importlib.rst:1100
#, fuzzy
msgid "Returns ``None`` as extension modules do not have source code."
msgstr "回傳 ``None`` ，因為擴充模組沒有源程式碼。"

#: ../../library/importlib.rst:1111
#, fuzzy
msgid ""
"A concrete implementation of :class:`importlib.abc.InspectLoader` for "
"namespace packages.  This is an alias for a private class and is only made "
"public for introspecting the ``__loader__`` attribute on namespace packages::"
msgstr ""
"命名空間包的 importlib.abc.InspectLoader 的具體實作。這是私有類的別名，"
"僅在對命名空間包的 ``__loader__`` 屬性進行內省時公開："

#: ../../library/importlib.rst:1129
#, fuzzy
msgid ""
"A specification for a module's import-system-related state.  This is "
"typically exposed as the module's :attr:`__spec__` attribute.  In the "
"descriptions below, the names in parentheses give the corresponding "
"attribute available directly on the module object, e.g. ``module.__spec__."
"origin == module.__file__``.  Note, however, that while the *values* are "
"usually equivalent, they can differ since there is no synchronization "
"between the two objects.  For example, it is possible to update the "
"module's :attr:`__file__` at runtime and this will not be automatically "
"reflected in the module's :attr:`__spec__.origin`, and vice versa."
msgstr ""
"模組導入系統相關狀態的規範。這通常作為模組的 :attr:`__spec__` 屬性公開。在下"
"面的描述中，括號中的名稱給出了直接在模組對像上可用的相應屬性，例如``"
"module.__spec__.origin == module.__file__``。但是請注意，雖然 *values* "
"通常是等價的，但它們可能不同，因為兩個物件之間沒有同步。例如，"
"可以在運行時更新模組的 :attr:`__file__` 而這不會自動反映在模組的 "
":attr:`__spec__.origin` 中，反之亦然。"

#: ../../library/importlib.rst:1143
msgid "(:attr:`__name__`)"
msgstr "(:attr:`__name__`)"

#: ../../library/importlib.rst:1145
#, fuzzy
msgid ""
"The module's fully qualified name. The :term:`finder` should always set this "
"attribute to a non-empty string."
msgstr "模組的完全限定名稱。 :term:`finder` 應始終將此屬性設定為非空字串。"

#: ../../library/importlib.rst:1150
msgid "(:attr:`__loader__`)"
msgstr "(:attr:`__loader__`)"

#: ../../library/importlib.rst:1152
#, fuzzy
msgid ""
"The :term:`loader` used to load the module. The :term:`finder` should always "
"set this attribute."
msgstr ":term:`loader` 用於加載模組。 :term:`finder` 應該總是設定這個屬性。"

#: ../../library/importlib.rst:1157
msgid "(:attr:`__file__`)"
msgstr "(:attr:`__file__`)"

#: ../../library/importlib.rst:1159
#, fuzzy
msgid ""
"The location the :term:`loader` should use to load the module. For example, "
"for modules loaded from a .py file this is the filename. The :term:`finder` "
"should always set this attribute to a meaningful value for the :term:"
"`loader` to use.  In the uncommon case that there is not one (like for "
"namespace packages), it should be set to ``None``."
msgstr ""
":term:`loader` 應該用來加載模組的位置。例如，對於從 .py "
"文件加載的模組，這是文件名。 :term:`finder` "
"應該始終將此屬性設定為一個有意義的值，以便 :term:`loader` "
"使用。在不存在的罕見情況下（如命名空間包），應將其設定為 ``None`` 。"

#: ../../library/importlib.rst:1167
msgid "(:attr:`__path__`)"
msgstr "(:attr:`__path__`)"

#: ../../library/importlib.rst:1169
#, fuzzy
msgid ""
"The list of locations where the package's submodules will be found. Most of "
"the time this is a single directory. The :term:`finder` should set this "
"attribute to a list, even an empty one, to indicate to the import system "
"that the module is a package.  It should be set to ``None`` for non-package "
"modules.  It is set automatically later to a special object for namespace "
"packages."
msgstr ""
"將找到包的子模組的位置列表。大多數時候這是一個單一的目錄。 :term:`finder` 應"
"該將此屬性設定為一個列表，即使是一個空列表，以嚮導入系統指示該模組是一個包。"
"對於非包模組，它應該設定為 ``None`` 。它稍後會自動設定為命名空間包的特殊物件。"

#: ../../library/importlib.rst:1178
#, fuzzy
msgid ""
"The :term:`finder` may set this attribute to an object containing "
"additional, module-specific data to use when loading the module.  Otherwise "
"it should be set to ``None``."
msgstr ":term:`finder` 可以將此屬性設定為一個物件，該物件包含加載模組時要使用的額外的"
"、特定於模組的資料。否則應設定為 ``None`` 。"

#: ../../library/importlib.rst:1184
msgid "(:attr:`__cached__`)"
msgstr "(:attr:`__cached__`)"

#: ../../library/importlib.rst:1186
#, fuzzy
msgid ""
"The filename of a compiled version of the module's code. The :term:`finder` "
"should always set this attribute but it may be ``None`` for modules that do "
"not need compiled code stored."
msgstr ""
"模組程式碼的編譯版本的文件名。 :term:`finder` "
"應始終設定此屬性，但對於不需要儲存已編譯程式碼的模組，它可能是 ``None``。"

#: ../../library/importlib.rst:1192
msgid "(:attr:`__package__`)"
msgstr "(:attr:`__package__`)"

#: ../../library/importlib.rst:1194
#, fuzzy
msgid ""
"(Read-only) The fully qualified name of the package the module is in (or the "
"empty string for a top-level module). If the module is a package then this "
"is the same as :attr:`name`."
msgstr "（只讀）模組所在包的完全限定名稱（或頂級模組的空字串）。如果模組是一個包，"
"那麼這與 :attr:`name` 相同。"

#: ../../library/importlib.rst:1201
#, fuzzy
msgid "``True`` if the spec's :attr:`origin` refers to a loadable location,"
msgstr "``True`` 如果規範的 :attr:`origin` 指的是可加載位置，"

#: ../../library/importlib.rst:1201
#, fuzzy
msgid ""
"``False`` otherwise.  This value impacts how :attr:`origin` is interpreted "
"and how the module's :attr:`__file__` is populated."
msgstr "否則為 ``False``。該值會影響 :attr:`origin` 的解釋方式以及模組的 :attr:`__file__` "
"的填充方式。"

#: ../../library/importlib.rst:1206
#, fuzzy
msgid ":mod:`importlib.util` -- Utility code for importers"
msgstr ":mod:`importlib.util` -- 導入器的實用程式程式碼"

#: ../../library/importlib.rst:1212
msgid "**Source code:** :source:`Lib/importlib/util.py`"
msgstr "**原始碼：**\\ :source:`Lib/importlib/util.py`"

#: ../../library/importlib.rst:1216
#, fuzzy
msgid ""
"This module contains the various objects that help in the construction of "
"an :term:`importer`."
msgstr "該模組包含有助於構建 :term:`importer` 的各種物件。"

#: ../../library/importlib.rst:1221
#, fuzzy
msgid ""
"The bytes which represent the bytecode version number. If you need help with "
"loading/writing bytecode then consider :class:`importlib.abc.SourceLoader`."
msgstr ""
"表示位元組碼版本號的位元組。如果您在加載/編寫位元組碼方面需要幫助，請考慮 "
":class:`importlib.abc.SourceLoader`。"

#: ../../library/importlib.rst:1228
#, fuzzy
msgid ""
"Return the :pep:`3147`/:pep:`488` path to the byte-compiled file associated "
"with the source *path*.  For example, if *path* is ``/foo/bar/baz.py`` the "
"return value would be ``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python "
"3.2. The ``cpython-32`` string comes from the current magic tag (see :func:"
"`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined then :exc:"
"`NotImplementedError` will be raised)."
msgstr ""
"將 :pep:`3147`/:pep:`488` 路徑回傳到與源 *path* 關聯的位元組編譯文件。例如，"
"如果 *path* 是 ``/foo/bar/baz.py``，對於 Python 3.2，回傳值將是 ``/foo/bar/"
"__pycache__/baz.cpython-32.pyc``。 ``cpython-32`` "
"字串來自當前的魔術標籤（參見 :func:`get_tag`；如果未定義 :attr:`sys."
"implementation.cache_tag`，則將引發 :exec:`NotImplementedError`）。"

#: ../../library/importlib.rst:1235
#, fuzzy
msgid ""
"The *optimization* parameter is used to specify the optimization level of "
"the bytecode file. An empty string represents no optimization, so ``/foo/bar/"
"baz.py`` with an *optimization* of ``''`` will result in a bytecode path of "
"``/foo/bar/__pycache__/baz.cpython-32.pyc``. ``None`` causes the "
"interpreter's optimization level to be used. Any other value's string "
"representation is used, so ``/foo/bar/baz.py`` with an *optimization* of "
"``2`` will lead to the bytecode path of ``/foo/bar/__pycache__/baz."
"cpython-32.opt-2.pyc``. The string representation of *optimization* can only "
"be alphanumeric, else :exc:`ValueError` is raised."
msgstr ""
"*optimization* "
"參數用於指定位元組碼文件的最佳化級別。一個空字串表示沒有最佳化，所以 ``/foo/"
"bar/baz.py`` 的 *optimization* 為 ``''`` 將導致位元組碼路徑為 ``/foo/bar/"
"__pycache__/baz。 cpython-32.pyc``。 ``None`` "
"導致使用直譯器的最佳化級別。使用任何其他值的字串表示形式，因此 *最佳化* "
"為 ``2``的“/foo/bar/baz.py”將導致位元組碼路徑為“/foo/bar/__pycache__/baz”。 "
"cpython-32.opt-2.pyc``。 *optimization* 的字串表示只能是字母數字，否則會引發 "
":exc:`ValueError`。"

#: ../../library/importlib.rst:1245
#, fuzzy
msgid ""
"The *debug_override* parameter is deprecated and can be used to override the "
"system's value for ``__debug__``. A ``True`` value is the equivalent of "
"setting *optimization* to the empty string. A ``False`` value is the same as "
"setting *optimization* to ``1``. If both *debug_override* an *optimization* "
"are not ``None`` then :exc:`TypeError` is raised."
msgstr ""
"*debug_override* 參數已棄用，可用於覆蓋系統的 ``__debug__`` 值。 ``True`` "
"值相當於將 *optimization* 設定為空字串。 ``False`` 值與將 *optimization* "
"設定為 ``1`` 相同。如果 *debug_override* 和 *optimization* 都不是 ``None`` "
"則引發 :exc:`TypeError`。"

#: ../../library/importlib.rst:1253
#, fuzzy
msgid ""
"The *optimization* parameter was added and the *debug_override* parameter "
"was deprecated."
msgstr "新增了 *optimization* 參數，棄用了 *debug_override* 參數。"

#: ../../library/importlib.rst:1257 ../../library/importlib.rst:1273
#: ../../library/importlib.rst:1423
#, fuzzy
msgid "Accepts a :term:`path-like object`."
msgstr "接受一個 :term:`path-like object`。"

#: ../../library/importlib.rst:1263
#, fuzzy
msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source "
"code file path.  For example, if *path* is ``/foo/bar/__pycache__/baz."
"cpython-32.pyc`` the returned path would be ``/foo/bar/baz.py``.  *path* "
"need not exist, however if it does not conform to :pep:`3147` or :pep:`488` "
"format, a :exc:`ValueError` is raised. If :attr:`sys.implementation."
"cache_tag` is not defined, :exc:`NotImplementedError` is raised."
msgstr ""
"給定 :pep:`3147` 文件名的*路徑*，回傳關聯的源程式碼文件路徑。例如，如果 "
"*path* 是 ``/foo/bar/__pycache__/baz.cpython-32.pyc`` 回傳的路徑將是 ``/foo/"
"bar/baz.py``。 *path* 不需要存在，但是如果它不符合 :pep:`3147` 或 :pep:`488` "
"格式，則會引發 :exc:`ValueError`。如果未定義 :attr:`sys.implementation."
"cache_tag`，則引發 :exec:`NotImplementedError`。"

#: ../../library/importlib.rst:1278
#, fuzzy
msgid ""
"Decode the given bytes representing source code and return it as a string "
"with universal newlines (as required by :meth:`importlib.abc.InspectLoader."
"get_source`)."
msgstr ""
"解碼表示源程式碼的給定位元組並將其作為帶有通用換行符的字串回傳（根據 "
"importlib.abc.InspectLoader.get_source 的要求）。"

#: ../../library/importlib.rst:1286
#, fuzzy
msgid "Resolve a relative module name to an absolute one."
msgstr "將相對模組名稱解析為絕對名稱。"

#: ../../library/importlib.rst:1288
#, fuzzy
msgid ""
"If  **name** has no leading dots, then **name** is simply returned. This "
"allows for usage such as ``importlib.util.resolve_name('sys', __spec__."
"parent)`` without doing a check to see if the **package** argument is needed."
msgstr ""
"如果 **name** 沒有前導點，則直接回傳 **name**。這允許使用諸如 ``importlib."
"util.resolve_name('sys', __spec__.parent)`` 而無需檢查是否需要 **package** "
"參數。"

#: ../../library/importlib.rst:1293
#, fuzzy
msgid ""
":exc:`ImportError` is raised if **name** is a relative module name but "
"**package** is a false value (e.g. ``None`` or the empty string). :exc:"
"`ImportError` is also raised if a relative name would escape its containing "
"package (e.g. requesting ``..bacon`` from within the ``spam`` package)."
msgstr ""
"如果 **name** 是相對模組名稱但 **package** 是假值（例如 ``None`` 或空字串），"
"則會引發 :exc:`ImportError`。 :exc:`ImportError` "
"如果相對名稱將轉義其包含的包（例如，從 ``spam`` 包中請求 ``.."
"bacon``）也會引發。"

#: ../../library/importlib.rst:1301
#, fuzzy
msgid ""
"To improve consistency with import statements, raise :exc:`ImportError` "
"instead of :exc:`ValueError` for invalid relative import attempts."
msgstr ""
"為了提高與 import 語句的一致性，針對無效的相對導入嘗試引發 :exc:`ImportError`"
" 而不是 :exc:`ValueError`。"

#: ../../library/importlib.rst:1308
#, fuzzy
msgid ""
"Find the :term:`spec <module spec>` for a module, optionally relative to the "
"specified **package** name. If the module is in :attr:`sys.modules`, then "
"``sys.modules[name].__spec__`` is returned (unless the spec would be "
"``None`` or is not set, in which case :exc:`ValueError` is raised). "
"Otherwise a search using :attr:`sys.meta_path` is done. ``None`` is returned "
"if no spec is found."
msgstr ""
"查找模組的 :term:`spec <module spec>`，可以選擇相對於指定的**包**名稱。"
"如果模組在 :attr:`sys.modules` 中，則回傳 ``sys.modules[name].__spec__``（"
"除非規範為 ``None`` 或未設定，在這種情況下：exc :`ValueError` 被引發）。"
"否則使用 :attr:`sys.meta_path` 進行搜索。如果未找到規範，則回傳 ``None`` 。"

#: ../../library/importlib.rst:1315
#, fuzzy
msgid ""
"If **name** is for a submodule (contains a dot), the parent module is "
"automatically imported."
msgstr "如果 **name** 用於子模組（包含一個點），則自動導入父模組。"

#: ../../library/importlib.rst:1318
#, fuzzy
msgid "**name** and **package** work the same as for :func:`import_module`."
msgstr "**name** 和 **package** 與 :func:`import_module` 的工作方式相同。"

#: ../../library/importlib.rst:1322
#, fuzzy
msgid ""
"Raises :exc:`ModuleNotFoundError` instead of :exc:`AttributeError` if "
"**package** is in fact not a package (i.e. lacks a :attr:`__path__` "
"attribute)."
msgstr ""
"如果 **package** 實際上不是包（即缺少 :attr:`__path__` 屬性），則引發 "
":exc:`ModuleNotFoundError` 而不是 :exc:`AttributeError`。"

#: ../../library/importlib.rst:1329
#, fuzzy
msgid ""
"Create a new module based on **spec** and :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."
msgstr ""
"基於 **spec** 和 :meth:`spec.loader.create_module <importlib.abc.Loader."
"create_module>` 建立一個新模組。"

#: ../../library/importlib.rst:1332
#, fuzzy
msgid ""
"If :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"does not return ``None``, then any pre-existing attributes will not be "
"reset. Also, no :exc:`AttributeError` will be raised if triggered while "
"accessing **spec** or setting an attribute on the module."
msgstr ""
"如果 :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"沒有回傳 ``None``，那麼任何預先存在的屬性都不會被重置。此外，如果在訪問 "
"**spec** 或在模組上設定屬性時觸發，則不會引發 :exc:`AttributeError`。"

#: ../../library/importlib.rst:1337
#, fuzzy
msgid ""
"This function is preferred over using :class:`types.ModuleType` to create a "
"new module as **spec** is used to set as many import-controlled attributes "
"on the module as possible."
msgstr "此函式優於使用 types.ModuleType 建立新模組，因為 **spec** "
"用於在模組上設定盡可能多的導入控制屬性。"

#: ../../library/importlib.rst:1345
#, fuzzy
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to handle "
"selecting the proper module object to load with. The decorated method is "
"expected to have a call signature taking two positional arguments (e.g. "
"``load_module(self, module)``) for which the second argument will be the "
"module **object** to be used by the loader. Note that the decorator will not "
"work on static methods because of the assumption of two arguments."
msgstr ""
"importlib.abc.Loader.load_module 的 :term:`decorator` 來處理選擇要加載的正確"
"模組物件。裝飾方法應該有一個帶有兩個位置參數的呼叫簽名（例如 ``load_module("
"self, module)``），第二個參數將是加載程式要使用的模組**物件**。請注意，由於假"
"設有兩個參數，裝飾器將不適用於靜態方法。"

#: ../../library/importlib.rst:1354
#, fuzzy
msgid ""
"The decorated method will take in the **name** of the module to be loaded as "
"expected for a :term:`loader`. If the module is not found in :data:`sys."
"modules` then a new one is constructed. Regardless of where the module came "
"from, :attr:`__loader__` set to **self** and :attr:`__package__` is set "
"based on what :meth:`importlib.abc.InspectLoader.is_package` returns (if "
"available). These attributes are set unconditionally to support reloading."
msgstr ""
"修飾的方法將接受要加載的模組的**名稱**，如 :term:`loader` 所預期的那樣。"
"如果在 :data:`sys.modules` "
"中找不到該模組，則會構建一個新模組。無論模組來自何處，:attr:`__loader__` "
"設定為 **self** 和 :attr:`__package__` 是根據 :meth:`importlib.abc."
"InspectLoader.is_package` 回傳的內容設定的（如果可用） ."
"這些屬性被無條件設定以支援重新加載。"

#: ../../library/importlib.rst:1362
#, fuzzy
msgid ""
"If an exception is raised by the decorated method and a module was added to :"
"data:`sys.modules`, then the module will be removed to prevent a partially "
"initialized module from being in left in :data:`sys.modules`. If the module "
"was already in :data:`sys.modules` then it is left alone."
msgstr ""
"如果修飾方法引發例外並且模組被新增到 :data:`sys.modules`，"
"則該模組將被刪除以防止部分初始化的模組留在 :data:`sys.modules` 中。"
"如果該模組已經在 :data:`sys.modules` 中，那麼它將被單獨保留。"

#: ../../library/importlib.rst:1367
#, fuzzy
msgid ""
":attr:`__loader__` and :attr:`__package__` are automatically set (when "
"possible)."
msgstr ":attr:`__loader__` 和 :attr:`__package__` 會自動設定（如果可能）。"

#: ../../library/importlib.rst:1371
#, fuzzy
msgid ""
"Set :attr:`__name__`, :attr:`__loader__` :attr:`__package__` unconditionally "
"to support reloading."
msgstr "無條件設定 :attr:`__name__`, :attr:`__loader__` :attr:`__package__` "
"支援重載。"

#: ../../library/importlib.rst:1375
#, fuzzy
msgid ""
"The import machinery now directly performs all the functionality provided by "
"this function."
msgstr "導入機制現在直接執行此函式提供的所有功能。"

#: ../../library/importlib.rst:1381
#, fuzzy
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to set the :"
"attr:`__loader__` attribute on the returned module. If the attribute is "
"already set the decorator does nothing. It is assumed that the first "
"positional argument to the wrapped method (i.e. ``self``) is what :attr:"
"`__loader__` should be set to."
msgstr ""
"用於 importlib.abc.Loader.load_module 的裝飾器，用於在回傳的模組上設定 "
"__loader__ "
"屬性。如果該屬性已經設定，則裝飾器什麼都不做。假設包裝方法的第一個位置參數（"
"即 ``self``）是 :attr:`__loader__` 應該設定的。"

#: ../../library/importlib.rst:1388
#, fuzzy
msgid ""
"Set ``__loader__`` if set to ``None``, as if the attribute does not exist."
msgstr "如果設定為 ``None``，則設定“__loader__”，就好像該屬性不存在一樣。"

#: ../../library/importlib.rst:1392 ../../library/importlib.rst:1401
#, fuzzy
msgid "The import machinery takes care of this automatically."
msgstr "進口機器會自動處理這個問題。"

#: ../../library/importlib.rst:1397
#, fuzzy
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to set the :"
"attr:`__package__` attribute on the returned module. If :attr:`__package__` "
"is set and has a value other than ``None`` it will not be changed."
msgstr ""
"importlib.abc.Loader.load_module 的裝飾器，用於在回傳的模組上設定 "
"__package__ 屬性。如果 :attr:`__package__` 被設定並且有一個不同於 ``None`` "
"的值，它不會被改變。"

#: ../../library/importlib.rst:1406
#, fuzzy
msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on a loader.  The parameters have the same meaning as they do "
"for ModuleSpec.  The function uses available :term:`loader` APIs, such as :"
"meth:`InspectLoader.is_package`, to fill in any missing information on the "
"spec."
msgstr ""
"用於建立基於加載器的 :class:`~importlib.machinery.ModuleSpec` "
"實例的工廠函式。這些參數與 ModuleSpec "
"的含義相同。該函式使用可用的 :term:`loader` API，例如 :meth:`InspectLoader."
"is_package`，來填充規範中任何缺失的資訊。"

#: ../../library/importlib.rst:1416
#, fuzzy
msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on the path to a file.  Missing information will be filled in "
"on the spec by making use of loader APIs and by the implication that the "
"module will be file-based."
msgstr ""
"用於根據文件路徑建立 :class:`~importlib.machinery.ModuleSpec` "
"實例的工廠函式。缺失的資訊將通過使用加載器 API "
"和模組將基於文件的暗示來填補規範。"

#: ../../library/importlib.rst:1428
#, fuzzy
msgid ""
"Return the hash of *source_bytes* as bytes. A hash-based ``.pyc`` file "
"embeds the :func:`source_hash` of the corresponding source file's contents "
"in its header."
msgstr ""
"以位元組形式回傳 *source_bytes* 的散列。基於散列的 .pyc "
"文件在其標頭中嵌入了相應源文件內容的 :func:`source_hash`。"

#: ../../library/importlib.rst:1436
#, fuzzy
msgid ""
"A class which postpones the execution of the loader of a module until the "
"module has an attribute accessed."
msgstr "一個類，它推遲模組加載器的執行，直到模組訪問了一個屬性。"

#: ../../library/importlib.rst:1439
#, fuzzy
msgid ""
"This class **only** works with loaders that define :meth:`~importlib.abc."
"Loader.exec_module` as control over what module type is used for the module "
"is required. For those same reasons, the loader's :meth:`~importlib.abc."
"Loader.create_module` method must return ``None`` or a type for which its "
"``__class__`` attribute can be mutated along with not using :term:`slots "
"<__slots__>`. Finally, modules which substitute the object placed into :attr:"
"`sys.modules` will not work as there is no way to properly replace the "
"module references throughout the interpreter safely; :exc:`ValueError` is "
"raised if such a substitution is detected."
msgstr ""
"此類**僅**與定義 :meth:`~importlib.abc.Loader.exec_module` "
"的加載器一起工作，因為需要控制模組使用的模組型別。出於同樣的原因，加載器的 "
":meth:`~importlib.abc.Loader.create_module` 方法必須回傳 ``None`` 或其 "
"`__class__`` 屬性可以隨著不使用而發生突變的型別：term： `插槽 "
"<__slots__>`。最後，替換放置在 :attr:`sys.modules` 中的物件的模組將無法工作，"
"因為無法在整個直譯器中安全地正確替換模組引用；如果檢測到此類替換，則會引發 "
":exc:`ValueError`。"

#: ../../library/importlib.rst:1450
#, fuzzy
msgid ""
"For projects where startup time is critical, this class allows for "
"potentially minimizing the cost of loading a module if it is never used. For "
"projects where startup time is not essential then use of this class is "
"**heavily** discouraged due to error messages created during loading being "
"postponed and thus occurring out of context."
msgstr ""
"對於啟動時間很關鍵的項目，如果從未使用過該類，則該類可以最大程度地降低加載模"
"組的成本。對於啟動時間不是必需的項目，由於在加載期間建立的錯誤消息被推遲並因"
"此在上下文之外發生，因此**強烈**不鼓勵使用此類。"

#: ../../library/importlib.rst:1458
#, fuzzy
msgid ""
"Began calling :meth:`~importlib.abc.Loader.create_module`, removing the "
"compatibility warning for :class:`importlib.machinery.BuiltinImporter` and :"
"class:`importlib.machinery.ExtensionFileLoader`."
msgstr ""
"開始呼叫 :meth:`~importlib.abc.Loader.create_module`，刪除 :class:`importlib."
"machinery.BuiltinImporter` 和 :class:`importlib.machinery."
"ExtensionFileLoader` 的相容性警告。"

#: ../../library/importlib.rst:1465
#, fuzzy
msgid ""
"A class method which returns a callable that creates a lazy loader. This is "
"meant to be used in situations where the loader is passed by class instead "
"of by instance. ::"
msgstr "一個回傳可呼叫物件的類方法，它建立了一個惰性加載器。這意味著在加載器由類而不"
"是實例傳遞的情況下使用。 ::"

#: ../../library/importlib.rst:1478
msgid "Examples"
msgstr "範例"

#: ../../library/importlib.rst:1481
#, fuzzy
msgid "Importing programmatically"
msgstr "以編程方式導入"

#: ../../library/importlib.rst:1483
#, fuzzy
msgid ""
"To programmatically import a module, use :func:`importlib.import_module`. ::"
msgstr "要以編程方式導入模組，請使用 :func:`importlib.import_module`。 ::"

#: ../../library/importlib.rst:1492
#, fuzzy
msgid "Checking if a module can be imported"
msgstr "檢查模組是否可以導入"

#: ../../library/importlib.rst:1494
#, fuzzy
msgid ""
"If you need to find out if a module can be imported without actually doing "
"the import, then you should use :func:`importlib.util.find_spec`."
msgstr "如果您需要確定是否可以在不實際執行導入的情況下導入模組，那麼您應該使用 "
":func:`importlib.util.find_spec`。"

#: ../../library/importlib.rst:1497
#, fuzzy
msgid ""
"Note that if ``name`` is a submodule (contains a dot), :func:`importlib.util."
"find_spec` will import the parent module. ::"
msgstr ""
"請注意，如果 ``name`` 是一個子模組（包含一個點），:func:`importlib.util."
"find_spec` 將導入父模組。 ::"

#: ../../library/importlib.rst:1520
#, fuzzy
msgid "Importing a source file directly"
msgstr "直接導入源文件"

#: ../../library/importlib.rst:1522
#, fuzzy
msgid "To import a Python source file directly, use the following recipe::"
msgstr "要直接導入 Python 源文件，請使用以下方法："

#: ../../library/importlib.rst:1539
#, fuzzy
msgid "Implementing lazy imports"
msgstr "實施延遲導入"

#: ../../library/importlib.rst:1541
#, fuzzy
msgid "The example below shows how to implement lazy imports::"
msgstr "下面的示例顯示瞭如何實作惰性導入::"

#: ../../library/importlib.rst:1563
#, fuzzy
msgid "Setting up an importer"
msgstr "設定進口商"

#: ../../library/importlib.rst:1565
#, fuzzy
msgid ""
"For deep customizations of import, you typically want to implement an :term:"
"`importer`. This means managing both the :term:`finder` and :term:`loader` "
"side of things. For finders there are two flavours to choose from depending "
"on your needs: a :term:`meta path finder` or a :term:`path entry finder`. "
"The former is what you would put on :attr:`sys.meta_path` while the latter "
"is what you create using a :term:`path entry hook` on :attr:`sys.path_hooks` "
"which works with :attr:`sys.path` entries to potentially create a finder. "
"This example will show you how to register your own importers so that import "
"will use them (for creating an importer for yourself, read the documentation "
"for the appropriate classes defined within this package)::"
msgstr ""
"對於導入的深度自定義，您通常希望實作一個 :term:`importer`。"
"這意味著同時管理事物的 :term:`finder` 和 :term:`loader` 方面。對於查找器，有"
"兩種風格可供選擇，具體取決於您的需要：元路徑查找器或路徑入口查找器。"
"前者是你要放在 :attr:`sys.meta_path` 上的，而後者是你使用 :term:`path entry "
"hook` 在 :attr:`sys.path_hooks` 上建立的，它與 :attr:`sys 一起工作.path` "
"條目可能會建立一個查找器。此示例將向您展示如何註冊您自己的導入器，以便 "
"import 將使用它們（要為您自己建立導入器，請閱讀此包中定義的適當類的文檔）："

#: ../../library/importlib.rst:1597
#, fuzzy
msgid "Approximating :func:`importlib.import_module`"
msgstr "近似 :func:`importlib.import_module`"

#: ../../library/importlib.rst:1599
#, fuzzy
msgid ""
"Import itself is implemented in Python code, making it possible to expose "
"most of the import machinery through importlib. The following helps "
"illustrate the various APIs that importlib exposes by providing an "
"approximate implementation of :func:`importlib.import_module`::"
msgstr ""
"Import 本身是用 Python 程式碼實作的，這使得通過 importlib "
"公開大部分導入機製成為可能。以下內容通過提供 importlib.import_module:: "
"的近似實作來幫助說明 importlib 公開的各種 API："

#~ msgid "**Source code:** :source:`Lib/importlib/resources.py`"
#~ msgstr "**原始碼：**\\ :source:`Lib/importlib/resources.py`"

#~ msgid "(``__name__``)"
#~ msgstr "(``__name__``)"

#~ msgid "(``__loader__``)"
#~ msgstr "(``__loader__``)"

#~ msgid "(``__file__``)"
#~ msgstr "(``__file__``)"

#~ msgid "(``__path__``)"
#~ msgstr "(``__path__``)"

#~ msgid "(``__cached__``)"
#~ msgstr "(``__cached__``)"

#~ msgid "(``__package__``)"
#~ msgstr "(``__package__``)"
