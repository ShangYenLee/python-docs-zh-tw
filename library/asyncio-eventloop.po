# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-26 00:19+0000\n"
"PO-Revision-Date: 2022-02-20 12:36+0800\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../library/asyncio-eventloop.rst:8
msgid "Event Loop"
msgstr "事件循環"

#: ../../library/asyncio-eventloop.rst:10
msgid ""
"**Source code:** :source:`Lib/asyncio/events.py`, :source:`Lib/asyncio/"
"base_events.py`"
msgstr ""
"**原始碼：**\\ :source:`Lib/asyncio/events.py`\\ 、\\ :source:`Lib/asyncio/"
"base_events.py`"

#: ../../library/asyncio-eventloop.rst:16
msgid "Preface"
msgstr "前言"

#: ../../library/asyncio-eventloop.rst:17
#, fuzzy
msgid ""
"The event loop is the core of every asyncio application. Event loops run "
"asynchronous tasks and callbacks, perform network IO operations, and run "
"subprocesses."
msgstr "事件循環是每個非同步應用程式的核心。事件循環運行非同步任務和回呼，執行網絡 "
"IO 操作，並運行子行程。"

#: ../../library/asyncio-eventloop.rst:21
#, fuzzy
msgid ""
"Application developers should typically use the high-level asyncio "
"functions, such as :func:`asyncio.run`, and should rarely need to reference "
"the loop object or call its methods.  This section is intended mostly for "
"authors of lower-level code, libraries, and frameworks, who need finer "
"control over the event loop behavior."
msgstr ""
"應用程式開發人員通常應使用高階非同步函式，例如 :func:`asyncio.run`，並且很少"
"需要引用循環對像或呼叫其方法。本節主要面向底層程式碼、庫和框架的作者，他們需"
"要更好地控制事件循環行為。"

#: ../../library/asyncio-eventloop.rst:28
msgid "Obtaining the Event Loop"
msgstr "獲取事件循環"

#: ../../library/asyncio-eventloop.rst:29
#, fuzzy
msgid ""
"The following low-level functions can be used to get, set, or create an "
"event loop:"
msgstr "以下低階函式可用於獲取、設定或建立事件循環："

#: ../../library/asyncio-eventloop.rst:34
#, fuzzy
msgid "Return the running event loop in the current OS thread."
msgstr "回傳當前操作系統執行緒中正在運行的事件循環。"

#: ../../library/asyncio-eventloop.rst:36
#, fuzzy
msgid "Raise a :exc:`RuntimeError` if there is no running event loop."
msgstr "如果沒有正在運行的事件循環，則引發 :exc:`RuntimeError`。"

#: ../../library/asyncio-eventloop.rst:38
#, fuzzy
msgid "This function can only be called from a coroutine or a callback."
msgstr "此函式只能從協程或回呼中呼叫。"

#: ../../library/asyncio-eventloop.rst:44
#, fuzzy
msgid "Get the current event loop."
msgstr "獲取當前事件循環。"

#: ../../library/asyncio-eventloop.rst:46
#, fuzzy
msgid ""
"When called from a coroutine or a callback (e.g. scheduled with call_soon or "
"similar API), this function will always return the running event loop."
msgstr "當從協程或回呼（例如使用 call_soon 或類似 API "
"調度）呼叫時，此函式將始終回傳正在運行的事件循環。"

#: ../../library/asyncio-eventloop.rst:50
#, fuzzy
msgid ""
"If there is no running event loop set, the function will return the result "
"of the ``get_event_loop_policy().get_event_loop()`` call."
msgstr ""
"如果沒有設定正在運行的事件循環，該函式將回傳 ``get_event_loop_policy()."
"get_event_loop()`` 呼叫的結果。"

#: ../../library/asyncio-eventloop.rst:53
#, fuzzy
msgid ""
"Because this function has rather complex behavior (especially when custom "
"event loop policies are in use), using the :func:`get_running_loop` function "
"is preferred to :func:`get_event_loop` in coroutines and callbacks."
msgstr ""
"因為此函式具有相當複雜的行為（尤其是在使用自定義事件循環策略時），"
"所以在協程和回呼中使用 :func:`get_running_loop` 函式優於 "
":func:`get_event_loop`。"

#: ../../library/asyncio-eventloop.rst:58
#, fuzzy
msgid ""
"As noted above, consider using the higher-level :func:`asyncio.run` "
"function, instead of using these lower level functions to manually create "
"and close an event loop."
msgstr "如上所述，考慮使用更高階別的 :func:`asyncio.run` "
"函式，而不是使用這些較低階別的函式來手動建立和關閉事件循環。"

#: ../../library/asyncio-eventloop.rst:63
#, fuzzy
msgid ""
"In Python versions 3.10.0--3.10.8 and 3.11.0 this function (and other "
"functions which use it implicitly) emitted a :exc:`DeprecationWarning` if "
"there was no running event loop, even if the current loop was set on the "
"policy. In Python versions 3.10.9, 3.11.1 and 3.12 they emit a :exc:"
"`DeprecationWarning` if there is no running event loop and no current loop "
"is set. In some future Python release this will become an error."
msgstr ""
"在 Python 版本 3.10.0--3.10.8 和 3.11.0 "
"中，如果沒有正在運行的事件循環，此函式（以及其他隱式使用它的函式）會發出 "
"DeprecationWarning，即使當前循環設定為政策。在 Python 版本 3.10.9、3.11.1 和 "
"3.12 中，如果沒有正在運行的事件循環並且沒有設定當前循環，它們會發出一個 "
"DeprecationWarning。在未來的某些 Python 版本中，這將成為一個錯誤。"

#: ../../library/asyncio-eventloop.rst:74
#, fuzzy
msgid "Set *loop* as the current event loop for the current OS thread."
msgstr "將 *loop* 設定為當前操作系統執行緒的當前事件循環。"

#: ../../library/asyncio-eventloop.rst:78
#, fuzzy
msgid "Create and return a new event loop object."
msgstr "建立並回傳一個新的事件循環物件。"

#: ../../library/asyncio-eventloop.rst:80
#, fuzzy
msgid ""
"Note that the behaviour of :func:`get_event_loop`, :func:`set_event_loop`, "
"and :func:`new_event_loop` functions can be altered by :ref:`setting a "
"custom event loop policy <asyncio-policies>`."
msgstr ""
"請注意 :func:`get_event_loop`、:func:`set_event_loop` 和 "
":func:`new_event_loop` 函式的行為可以通過 :ref:`setting a custom event loop "
"policy <asyncio-policies>` 來改變。"

#: ../../library/asyncio-eventloop.rst:86
msgid "Contents"
msgstr "目錄"

#: ../../library/asyncio-eventloop.rst:87
#, fuzzy
msgid "This documentation page contains the following sections:"
msgstr "本文檔頁麵包含以下部分："

#: ../../library/asyncio-eventloop.rst:89
#, fuzzy
msgid ""
"The `Event Loop Methods`_ section is the reference documentation of the "
"event loop APIs;"
msgstr "`Event Loop Methods`_ 部分是事件循環 API 的參考文檔；"

#: ../../library/asyncio-eventloop.rst:92
#, fuzzy
msgid ""
"The `Callback Handles`_ section documents the :class:`Handle` and :class:"
"`TimerHandle` instances which are returned from scheduling methods such as :"
"meth:`loop.call_soon` and :meth:`loop.call_later`;"
msgstr ""
"`Callback Handles`_ 部分記錄了從諸如 loop.call_soon 和 loop.call_later "
"等調度方法回傳的 Handle 和 TimerHandle 實例；"

#: ../../library/asyncio-eventloop.rst:96
#, fuzzy
msgid ""
"The `Server Objects`_ section documents types returned from event loop "
"methods like :meth:`loop.create_server`;"
msgstr "`Server Objects`_ 部分記錄了從事件循環方法回傳的型別，例如 :meth:`loop."
"create_server`；"

#: ../../library/asyncio-eventloop.rst:99
#, fuzzy
msgid ""
"The `Event Loop Implementations`_ section documents the :class:"
"`SelectorEventLoop` and :class:`ProactorEventLoop` classes;"
msgstr ""
"`Event Loop Implementations`_ 部分記錄了 SelectorEventLoop 和 "
"ProactorEventLoop 類；"

#: ../../library/asyncio-eventloop.rst:102
#, fuzzy
msgid ""
"The `Examples`_ section showcases how to work with some event loop APIs."
msgstr "`Examples`_ 部分展示瞭如何使用一些事件循環 API。"

#: ../../library/asyncio-eventloop.rst:109
#, fuzzy
msgid "Event Loop Methods"
msgstr "事件循環方法"

#: ../../library/asyncio-eventloop.rst:111
#, fuzzy
msgid "Event loops have **low-level** APIs for the following:"
msgstr "事件循環具有用於以下內容的**低階** API："

#: ../../library/asyncio-eventloop.rst:119
#, fuzzy
msgid "Running and stopping the loop"
msgstr "運行和停止循環"

#: ../../library/asyncio-eventloop.rst:123
#, fuzzy
msgid "Run until the *future* (an instance of :class:`Future`) has completed."
msgstr "運行直到 *future*（Future 的一個實例）完成。"

#: ../../library/asyncio-eventloop.rst:126
#, fuzzy
msgid ""
"If the argument is a :ref:`coroutine object <coroutine>` it is implicitly "
"scheduled to run as a :class:`asyncio.Task`."
msgstr ""
"如果參數是 :ref:`coroutine object <coroutine>` 它被隱式安排為作為 "
":class:`asyncio.Task` 運行。"

#: ../../library/asyncio-eventloop.rst:129
#, fuzzy
msgid "Return the Future's result or raise its exception."
msgstr "回傳 Future 的結果或引發其例外。"

#: ../../library/asyncio-eventloop.rst:133
#, fuzzy
msgid "Run the event loop until :meth:`stop` is called."
msgstr "運行事件循環直到 :meth:`stop` 被呼叫。"

#: ../../library/asyncio-eventloop.rst:135
#, fuzzy
msgid ""
"If :meth:`stop` is called before :meth:`run_forever()` is called, the loop "
"will poll the I/O selector once with a timeout of zero, run all callbacks "
"scheduled in response to I/O events (and those that were already scheduled), "
"and then exit."
msgstr ""
"如果 :meth:`stop` 在 :meth:`run_forever()` 被呼叫之前被呼叫，循環將輪詢 I/O "
"選擇器一次，超時為零，運行所有為響應 I/O "
"事件而安排的回呼（和那些已經安排好的），然後退出。"

#: ../../library/asyncio-eventloop.rst:140
#, fuzzy
msgid ""
"If :meth:`stop` is called while :meth:`run_forever` is running, the loop "
"will run the current batch of callbacks and then exit. Note that new "
"callbacks scheduled by callbacks will not run in this case; instead, they "
"will run the next time :meth:`run_forever` or :meth:`run_until_complete` is "
"called."
msgstr ""
"如果 :meth:`stop` 在 :meth:`run_forever` 運行時被呼叫，循環將運行當前批次的回"
"呼，然後退出。請注意，在這種情況下，不會運行由回呼調度的新回呼；相反，"
"它們將在下次呼叫 :meth:`run_forever` 或 :meth:`run_until_complete` 時運行。"

#: ../../library/asyncio-eventloop.rst:148
#, fuzzy
msgid "Stop the event loop."
msgstr "停止事件循環。"

#: ../../library/asyncio-eventloop.rst:152
#, fuzzy
msgid "Return ``True`` if the event loop is currently running."
msgstr "如果事件循環當前正在運行，則回傳 ``True``。"

#: ../../library/asyncio-eventloop.rst:156
#, fuzzy
msgid "Return ``True`` if the event loop was closed."
msgstr "如果事件循環已關閉，則回傳 ``True``。"

#: ../../library/asyncio-eventloop.rst:160
#, fuzzy
msgid "Close the event loop."
msgstr "關閉事件循環。"

#: ../../library/asyncio-eventloop.rst:162
#, fuzzy
msgid ""
"The loop must not be running when this function is called. Any pending "
"callbacks will be discarded."
msgstr "呼叫此函式時，循環不得運行。任何掛起的回呼都將被丟棄。"

#: ../../library/asyncio-eventloop.rst:165
#, fuzzy
msgid ""
"This method clears all queues and shuts down the executor, but does not wait "
"for the executor to finish."
msgstr "此方法清除所有隊列並關閉執行器，但不等待執行器完成。"

#: ../../library/asyncio-eventloop.rst:168
#, fuzzy
msgid ""
"This method is idempotent and irreversible.  No other methods should be "
"called after the event loop is closed."
msgstr "這種方法是冪等的，不可逆的。事件循環關閉後不應呼叫其他方法。"

#: ../../library/asyncio-eventloop.rst:173
#, fuzzy
msgid ""
"Schedule all currently open :term:`asynchronous generator` objects to close "
"with an :meth:`~agen.aclose()` call.  After calling this method, the event "
"loop will issue a warning if a new asynchronous generator is iterated. This "
"should be used to reliably finalize all scheduled asynchronous generators."
msgstr ""
"安排所有當前打開的非同步生成器物件通過呼叫關閉。呼叫此方法後，如果疊代了新的"
"非同步生成器，事件循環將發出警告。這應該用於可靠地完成所有預定的非同步生成器"
"。"

#: ../../library/asyncio-eventloop.rst:179
#, fuzzy
msgid ""
"Note that there is no need to call this function when :func:`asyncio.run` is "
"used."
msgstr "請注意，使用 :func:`asyncio.run` 時無需呼叫此函式。"

#: ../../library/asyncio-eventloop.rst:182
#: ../../library/asyncio-eventloop.rst:1216
#: ../../library/asyncio-eventloop.rst:1604
msgid "Example::"
msgstr ""
"範例：\n"
"\n"
"::"

#: ../../library/asyncio-eventloop.rst:194
#, fuzzy
msgid ""
"Schedule the closure of the default executor and wait for it to join all of "
"the threads in the :class:`~concurrent.futures.ThreadPoolExecutor`. Once "
"this method has been called, using the default executor with :meth:`loop."
"run_in_executor` will raise a :exc:`RuntimeError`."
msgstr ""
"安排預設執行器的關閉並等待它加入 :class:`~concurrent.futures."
"ThreadPoolExecutor` 中的所有執行緒。呼叫此方法後，將預設執行程式與 "
":meth:`loop.run_in_executor` 一起使用將引發 :exc:`RuntimeError`。"

#: ../../library/asyncio-eventloop.rst:202
#, fuzzy
msgid ""
"Do not call this method when using :func:`asyncio.run`, as the latter "
"handles default executor shutdown automatically."
msgstr "使用 :func:`asyncio.run` "
"時不要呼叫此方法，因為後者會自動處理預設執行程式關閉。"

#: ../../library/asyncio-eventloop.rst:209
#, fuzzy
msgid "Scheduling callbacks"
msgstr "安排回呼"

#: ../../library/asyncio-eventloop.rst:213
#, fuzzy
msgid ""
"Schedule the *callback* :term:`callback` to be called with *args* arguments "
"at the next iteration of the event loop."
msgstr "安排在事件循環的下一次疊代中使用 *args* 參數呼叫 *callback* "
":term:`callback`。"

#: ../../library/asyncio-eventloop.rst:216
#, fuzzy
msgid ""
"Return an instance of :class:`asyncio.Handle`, which can be used later to "
"cancel the callback."
msgstr "回傳 :class:`asyncio.Handle` 的實例，稍後可以使用它來取消回呼。"

#: ../../library/asyncio-eventloop.rst:219
#, fuzzy
msgid ""
"Callbacks are called in the order in which they are registered. Each "
"callback will be called exactly once."
msgstr "回呼按照它們註冊的順序被呼叫。每個回呼將被呼叫一次。"

#: ../../library/asyncio-eventloop.rst:222
#, fuzzy
msgid ""
"The optional keyword-only *context* argument specifies a custom :class:"
"`contextvars.Context` for the *callback* to run in. Callbacks use the "
"current context when no *context* is provided."
msgstr ""
"可選的僅關鍵字 *context* 參數為要運行的 *callback* 指定一個自定義的 "
":class:`contextvars.Context`。當沒有提供 *context* 時，回呼使用當前上下文。"

#: ../../library/asyncio-eventloop.rst:226
#, fuzzy
msgid "Unlike :meth:`call_soon_threadsafe`, this method is not thread-safe."
msgstr "與 :meth:`call_soon_threadsafe` 不同，此方法不是執行緒安全的。"

#: ../../library/asyncio-eventloop.rst:230
#, fuzzy
msgid ""
"A thread-safe variant of :meth:`call_soon`. When scheduling callbacks from "
"another thread, this function *must* be used, since :meth:`call_soon` is not "
"thread-safe."
msgstr "call_soon 的執行緒安全變體。當從另一個執行緒調度回呼時，*必須*使用此函式，"
"因為 call_soon 不是執行緒安全的。"

#: ../../library/asyncio-eventloop.rst:234
#, fuzzy
msgid ""
"Raises :exc:`RuntimeError` if called on a loop that's been closed. This can "
"happen on a secondary thread when the main application is shutting down."
msgstr "如果在已關閉的循環上呼叫，則引發 "
":exc:`RuntimeError`。當主應用程式關閉時，這可能發生在輔助執行緒上。"

#: ../../library/asyncio-eventloop.rst:238
#, fuzzy
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr "請參閱文檔的 :ref:`並發和多執行緒 <asyncio-multithreading>` 部分。"

#: ../../library/asyncio-eventloop.rst:241
#: ../../library/asyncio-eventloop.rst:291
#: ../../library/asyncio-eventloop.rst:311
#, fuzzy
msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr "新增了 *context* 僅關鍵字參數。有關更多詳細資訊，請參見 :pep:`567`。"

#: ../../library/asyncio-eventloop.rst:249
#, fuzzy
msgid ""
"Most :mod:`asyncio` scheduling functions don't allow passing keyword "
"arguments.  To do that, use :func:`functools.partial`::"
msgstr "大多數 :mod:`asyncio` 調度函式不允許傳遞關鍵字參數。為此，請使用 "
"func:`functools.partial`::"

#: ../../library/asyncio-eventloop.rst:256
#, fuzzy
msgid ""
"Using partial objects is usually more convenient than using lambdas, as "
"asyncio can render partial objects better in debug and error messages."
msgstr "使用部分物件通常比使用 lambda 更方便，因為 asyncio "
"可以在除錯和錯誤消息中更好地呈現部分物件。"

#: ../../library/asyncio-eventloop.rst:264
#, fuzzy
msgid "Scheduling delayed callbacks"
msgstr "安排延遲回呼"

#: ../../library/asyncio-eventloop.rst:266
#, fuzzy
msgid ""
"Event loop provides mechanisms to schedule callback functions to be called "
"at some point in the future.  Event loop uses monotonic clocks to track time."
msgstr "事件循環提供了安排回呼函式在未來某個時間呼叫的機制。事件循環使用單調時鐘來跟"
"踪時間。"

#: ../../library/asyncio-eventloop.rst:273
#, fuzzy
msgid ""
"Schedule *callback* to be called after the given *delay* number of seconds "
"(can be either an int or a float)."
msgstr "安排*回呼*在給定的*延遲*秒數後呼叫（可以是整數或浮點數）。"

#: ../../library/asyncio-eventloop.rst:276
#: ../../library/asyncio-eventloop.rst:308
#, fuzzy
msgid ""
"An instance of :class:`asyncio.TimerHandle` is returned which can be used to "
"cancel the callback."
msgstr "回傳一個 asyncio.TimerHandle 實例，可用於取消回呼。"

#: ../../library/asyncio-eventloop.rst:279
#, fuzzy
msgid ""
"*callback* will be called exactly once.  If two callbacks are scheduled for "
"exactly the same time, the order in which they are called is undefined."
msgstr "*callback* 只會被呼叫一次。如果兩個回呼被安排在完全相同的時間，它們被呼叫的順"
"序是未定義的。"

#: ../../library/asyncio-eventloop.rst:283
#, fuzzy
msgid ""
"The optional positional *args* will be passed to the callback when it is "
"called. If you want the callback to be called with keyword arguments use :"
"func:`functools.partial`."
msgstr "可選的位置 *args* 將在呼叫時傳遞給回呼。如果您希望使用關鍵字參數呼叫回呼，"
"請使用 func:`functools.partial`。"

#: ../../library/asyncio-eventloop.rst:287
#, fuzzy
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *callback* to run in. The current "
"context is used when no *context* is provided."
msgstr ""
"一個可選的僅限關鍵字的 *context* 參數允許為要運行的 *callback* "
"指定一個自定義的 :class:`contextvars.Context`。當沒有提供 *context* "
"時使用當前上下文。"

#: ../../library/asyncio-eventloop.rst:295
#, fuzzy
msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"*delay* could not exceed one day. This has been fixed in Python 3.8."
msgstr "在具有預設事件循環實作的 Python 3.7 及更早版本中，*延遲* 不能超過一天。"
"這已在 Python 3.8 中修復。"

#: ../../library/asyncio-eventloop.rst:302
#, fuzzy
msgid ""
"Schedule *callback* to be called at the given absolute timestamp *when* (an "
"int or a float), using the same time reference as :meth:`loop.time`."
msgstr "安排 *callback* 在給定的絕對時間戳 *when*（整數或浮點數）呼叫，使用與 "
":meth:`loop.time` 相同的時間參考。"

#: ../../library/asyncio-eventloop.rst:306
#, fuzzy
msgid "This method's behavior is the same as :meth:`call_later`."
msgstr "此方法的行為與 call_later 相同。"

#: ../../library/asyncio-eventloop.rst:315
#, fuzzy
msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"difference between *when* and the current time could not exceed one day.  "
"This has been fixed in Python 3.8."
msgstr ""
"在具有預設事件循環實作的 Python 3.7 及更早版本中，*when* "
"與當前時間之間的差異不能超過一天。這已在 Python 3.8 中修復。"

#: ../../library/asyncio-eventloop.rst:322
#, fuzzy
msgid ""
"Return the current time, as a :class:`float` value, according to the event "
"loop's internal monotonic clock."
msgstr "根據事件循環的內部單調時鐘，以 :class:`float` 值的形式回傳當前時間。"

#: ../../library/asyncio-eventloop.rst:326
#, fuzzy
msgid ""
"In Python 3.7 and earlier timeouts (relative *delay* or absolute *when*) "
"should not exceed one day.  This has been fixed in Python 3.8."
msgstr "在 Python 3.7 和更早版本中，超時（相對 *delay* 或絕對 *when*）不應超過一天。"
"這已在 Python 3.8 中修復。"

#: ../../library/asyncio-eventloop.rst:332
#, fuzzy
msgid "The :func:`asyncio.sleep` function."
msgstr ":func:`asyncio.sleep` 函式。"

#: ../../library/asyncio-eventloop.rst:336
#, fuzzy
msgid "Creating Futures and Tasks"
msgstr "建立期貨和任務"

#: ../../library/asyncio-eventloop.rst:340
#, fuzzy
msgid "Create an :class:`asyncio.Future` object attached to the event loop."
msgstr "建立一個附加到事件循環的 asyncio.Future 物件。"

#: ../../library/asyncio-eventloop.rst:342
#, fuzzy
msgid ""
"This is the preferred way to create Futures in asyncio. This lets third-"
"party event loops provide alternative implementations of the Future object "
"(with better performance or instrumentation)."
msgstr "這是在 asyncio 中建立 Futures 的首選方式。這讓第三方事件循環提供 Future "
"物件的替代實作（具有更好的性能或檢測）。"

#: ../../library/asyncio-eventloop.rst:350
#, fuzzy
msgid ""
"Schedule the execution of :ref:`coroutine <coroutine>` *coro*. Return a :"
"class:`Task` object."
msgstr "安排 :ref:`coroutine <coroutine>` *coro* 的執行。回傳一個 :class:`Task` "
"物件。"

#: ../../library/asyncio-eventloop.rst:353
#, fuzzy
msgid ""
"Third-party event loops can use their own subclass of :class:`Task` for "
"interoperability. In this case, the result type is a subclass of :class:"
"`Task`."
msgstr "第三方事件循環可以使用它們自己的 Task 子類別來實作互操作性。在這種情況下，"
"結果型別是 Task 的子類別。"

#: ../../library/asyncio-eventloop.rst:357
#, fuzzy
msgid ""
"If the *name* argument is provided and not ``None``, it is set as the name "
"of the task using :meth:`Task.set_name`."
msgstr "如果提供了 *name* 參數而不是 ``None``，則使用 Task.set_name "
"將其設定為任務的名稱。"

#: ../../library/asyncio-eventloop.rst:360
#, fuzzy
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. The current context "
"copy is created when no *context* is provided."
msgstr ""
"一個可選的僅限關鍵字的 *context* 參數允許為 *coro* "
"指定一個自定義的 :class:`contextvars.Context` 在其中運行。"
"當前上下文副本在沒有提供 *context* 時建立。"

#: ../../library/asyncio-eventloop.rst:364
msgid "Added the *name* parameter."
msgstr "加入 *name* 參數。"

#: ../../library/asyncio-eventloop.rst:367
msgid "Added the *context* parameter."
msgstr "加入 *context* 參數。"

#: ../../library/asyncio-eventloop.rst:372
#, fuzzy
msgid "Set a task factory that will be used by :meth:`loop.create_task`."
msgstr "設定將由 :meth:`loop.create_task` 使用的任務工廠。"

#: ../../library/asyncio-eventloop.rst:375
#, fuzzy
msgid ""
"If *factory* is ``None`` the default task factory will be set. Otherwise, "
"*factory* must be a *callable* with the signature matching ``(loop, coro, "
"context=None)``, where *loop* is a reference to the active event loop, and "
"*coro* is a coroutine object.  The callable must return a :class:`asyncio."
"Future`-compatible object."
msgstr ""
"如果*factory* 為``None``，將設定預設任務工廠。否則，*factory* 必須是一個 "
"*callable*，其簽名匹配``(loop, coro, context=None)``，其中 *loop* "
"是對活動事件循環的引用，*coro* 是協程物件.可呼叫物件必須回傳一個相容 "
"asyncio.Future 的物件。"

#: ../../library/asyncio-eventloop.rst:383
#, fuzzy
msgid "Return a task factory or ``None`` if the default one is in use."
msgstr "如果正在使用預設任務工廠，則回傳任務工廠或 ``None`` 。"

#: ../../library/asyncio-eventloop.rst:387
#, fuzzy
msgid "Opening network connections"
msgstr "打開網絡連接"

#: ../../library/asyncio-eventloop.rst:397
#, fuzzy
msgid ""
"Open a streaming transport connection to a given address specified by *host* "
"and *port*."
msgstr "打開流式傳輸連接到由 *host* 和 *port* 指定的給定地址。"

#: ../../library/asyncio-eventloop.rst:400
#, fuzzy
msgid ""
"The socket family can be either :py:data:`~socket.AF_INET` or :py:data:"
"`~socket.AF_INET6` depending on *host* (or the *family* argument, if "
"provided)."
msgstr ""
" socket 系列可以是 :py:data:`~socket.AF_INET` 或 :py:data:`~socket.AF_INET6` "
"取決於 *host* （或 *family* 參數，如果提供）。"

#: ../../library/asyncio-eventloop.rst:404
#, fuzzy
msgid "The socket type will be :py:data:`~socket.SOCK_STREAM`."
msgstr " socket 型別將為 :py:data:`~socket.SOCK_STREAM`。"

#: ../../library/asyncio-eventloop.rst:406
#: ../../library/asyncio-eventloop.rst:1132
#: ../../library/asyncio-eventloop.rst:1148
#, fuzzy
msgid ""
"*protocol_factory* must be a callable returning an :ref:`asyncio protocol "
"<asyncio-protocol>` implementation."
msgstr "*protocol_factory* 必須是可呼叫的，回傳 :ref:`asyncio 協定 <asyncio-"
"protocol>` 實作。"

#: ../../library/asyncio-eventloop.rst:409
#, fuzzy
msgid ""
"This method will try to establish the connection in the background. When "
"successful, it returns a ``(transport, protocol)`` pair."
msgstr "此方法將嘗試在後台建立連接。成功時，它回傳一個``(transport, protocol)`` 對。"

#: ../../library/asyncio-eventloop.rst:412
#, fuzzy
msgid "The chronological synopsis of the underlying operation is as follows:"
msgstr "底層操作的時間概要如下："

#: ../../library/asyncio-eventloop.rst:414
#, fuzzy
msgid ""
"The connection is established and a :ref:`transport <asyncio-transport>` is "
"created for it."
msgstr "建立連接並為其建立 :ref:`transport <asyncio-transport>`。"

#: ../../library/asyncio-eventloop.rst:417
#, fuzzy
msgid ""
"*protocol_factory* is called without arguments and is expected to return a :"
"ref:`protocol <asyncio-protocol>` instance."
msgstr ""
"*protocol_factory* 被呼叫時沒有參數，預計會回傳一個 :ref:`protocol <asyncio-"
"protocol>` 實例。"

#: ../../library/asyncio-eventloop.rst:420
#, fuzzy
msgid ""
"The protocol instance is coupled with the transport by calling its :meth:"
"`~BaseProtocol.connection_made` method."
msgstr "協定實例通過呼叫其 :meth:`~BaseProtocol.connection_made` 方法與傳輸耦合。"

#: ../../library/asyncio-eventloop.rst:423
#, fuzzy
msgid "A ``(transport, protocol)`` tuple is returned on success."
msgstr "成功時回傳一個``(transport, protocol)``元組。"

#: ../../library/asyncio-eventloop.rst:425
#, fuzzy
msgid ""
"The created transport is an implementation-dependent bidirectional stream."
msgstr "建立的傳輸是依賴於實作的雙向流。"

#: ../../library/asyncio-eventloop.rst:428
#: ../../library/asyncio-eventloop.rst:549
#, fuzzy
msgid "Other arguments:"
msgstr "其他論點："

#: ../../library/asyncio-eventloop.rst:430
#, fuzzy
msgid ""
"*ssl*: if given and not false, a SSL/TLS transport is created (by default a "
"plain TCP transport is created).  If *ssl* is a :class:`ssl.SSLContext` "
"object, this context is used to create the transport; if *ssl* is :const:"
"`True`, a default context returned from :func:`ssl.create_default_context` "
"is used."
msgstr ""
"*ssl*：如果給定且不為 false，則建立 SSL/TLS 傳輸（預設情況下建立普通 TCP "
"傳輸）。如果 *ssl* 是 :class:`ssl.SSLContext` 物件，則此上下文用於建立傳輸；"
"如果 *ssl* 為 :const:`True`，則使用從 :func:`ssl.create_default_context` "
"回傳的預設上下文。"

#: ../../library/asyncio-eventloop.rst:436
#, fuzzy
msgid ":ref:`SSL/TLS security considerations <ssl-security>`"
msgstr ":ref:`SSL/TLS 安全考慮 <ssl-security>`"

#: ../../library/asyncio-eventloop.rst:438
#, fuzzy
msgid ""
"*server_hostname* sets or overrides the hostname that the target server's "
"certificate will be matched against.  Should only be passed if *ssl* is not "
"``None``.  By default the value of the *host* argument is used.  If *host* "
"is empty, there is no default and you must pass a value for "
"*server_hostname*.  If *server_hostname* is an empty string, hostname "
"matching is disabled (which is a serious security risk, allowing for "
"potential man-in-the-middle attacks)."
msgstr ""
"*server_hostname* 設定或覆蓋目標伺服器證書將與之匹配的主機名。僅當 *ssl* "
"不是 ``None`` 時才應傳遞。預設情況下，使用 *host* 參數的值。如果 *host* "
"為空，則沒有預設值，您必須為 *server_hostname* 傳遞一個值。如果 "
"*server_hostname* 是一個空字串，主機名匹配被禁用（這是一個嚴重的安全風險，允"
"許潛在的中間人攻擊）。"

#: ../../library/asyncio-eventloop.rst:446
#, fuzzy
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to getaddrinfo() for *host* resolution. If given, "
"these should all be integers from the corresponding :mod:`socket` module "
"constants."
msgstr ""
"*family*、*proto*、*flags* 是可選的地址族、協定和旗標，將傳遞給 getaddrinfo()"
" 以進行 *host* 解析。如果給定，這些應該都是來自相應 :mod:`socket` "
"模組常數的整數。"

#: ../../library/asyncio-eventloop.rst:451
#, fuzzy
msgid ""
"*happy_eyeballs_delay*, if given, enables Happy Eyeballs for this "
"connection. It should be a floating-point number representing the amount of "
"time in seconds to wait for a connection attempt to complete, before "
"starting the next attempt in parallel. This is the \"Connection Attempt "
"Delay\" as defined in :rfc:`8305`. A sensible default value recommended by "
"the RFC is ``0.25`` (250 milliseconds)."
msgstr ""
"*happy_eyeballs_delay*，如果給定，為這個連接啟用 Happy Eyeballs。它應該是一個"
"浮點數，表示在開始下一次並行嘗試之前等待連接嘗試完成的時間（以秒為單位）。"
"這是 :rfc:`8305` 中定義的“連接嘗試延遲”。 RFC 推薦的合理預設值是“0.25”（250 "
"毫秒）。"

#: ../../library/asyncio-eventloop.rst:459
#, fuzzy
msgid ""
"*interleave* controls address reordering when a host name resolves to "
"multiple IP addresses. If ``0`` or unspecified, no reordering is done, and "
"addresses are tried in the order returned by :meth:`getaddrinfo`. If a "
"positive integer is specified, the addresses are interleaved by address "
"family, and the given integer is interpreted as \"First Address Family "
"Count\" as defined in :rfc:`8305`. The default is ``0`` if "
"*happy_eyeballs_delay* is not specified, and ``1`` if it is."
msgstr ""
"*interleave* 控制主機名解析為多個 IP 地址時的地址重新排序。如果 ``0`` "
"或未指定，則不進行重新排序，並按照 getaddrinfo "
"回傳的順序嘗試地址。如果指定了正整數，則地址按地址族交錯，給定的整數被解釋為 "
":rfc:`8305` 中定義的“第一個地址族計數”。如果未指定 "
"*happy_eyeballs_delay*，則預設值為 ``0``，如果指定，則預設為 ``1``。"

#: ../../library/asyncio-eventloop.rst:468
#, fuzzy
msgid ""
"*sock*, if given, should be an existing, already connected :class:`socket."
"socket` object to be used by the transport. If *sock* is given, none of "
"*host*, *port*, *family*, *proto*, *flags*, *happy_eyeballs_delay*, "
"*interleave* and *local_addr* should be specified."
msgstr ""
"*sock*，如果給定，應該是一個現有的、已經連接的 :class:`socket.socket` "
"物件，供傳輸使用。如果給出 *sock*，則不應指定 *host*、*port*、*family*、*prot"
"o*、*flags*、*happy_eyeballs_delay*、*interleave* 和 *local_addr*。"

#: ../../library/asyncio-eventloop.rst:476
#: ../../library/asyncio-eventloop.rst:580
#: ../../library/asyncio-eventloop.rst:804
#, fuzzy
msgid ""
"The *sock* argument transfers ownership of the socket to the transport "
"created. To close the socket, call the transport's :meth:`~asyncio."
"BaseTransport.close` method."
msgstr ""
"*sock* 參數將 socket 的所有權轉移到建立的傳輸。要關閉 socket ，請呼叫傳輸的 "
":meth:`~asyncio.BaseTransport.close` 方法。"

#: ../../library/asyncio-eventloop.rst:480
#, fuzzy
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket locally.  The *local_host* and *local_port* are looked up using "
"``getaddrinfo()``, similarly to *host* and *port*."
msgstr ""
"*local_addr*，如果給定的話，是一個``(local_host, "
"local_port)``元組，用於在本地綁定 socket 。 *local_host* 和 *local_port* 使用 "
"``getaddrinfo()`` 查找，類似於 *host* 和 *port*。"

#: ../../library/asyncio-eventloop.rst:484
#: ../../library/asyncio-eventloop.rst:895
#, fuzzy
msgid ""
"*ssl_handshake_timeout* is (for a TLS connection) the time in seconds to "
"wait for the TLS handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* 是（對於 TLS 連接）在中止連接之前等待 TLS "
"握手完成的時間（以秒為單位）。 ``60.0`` 秒，如果``無``（預設）。"

#: ../../library/asyncio-eventloop.rst:488
#: ../../library/asyncio-eventloop.rst:721
#: ../../library/asyncio-eventloop.rst:815
#: ../../library/asyncio-eventloop.rst:899
#, fuzzy
msgid ""
"*ssl_shutdown_timeout* is the time in seconds to wait for the SSL shutdown "
"to complete before aborting the connection. ``30.0`` seconds if ``None`` "
"(default)."
msgstr ""
"*ssl_shutdown_timeout* 是在中止連接之前等待 SSL "
"關閉完成的時間（以秒為單位）。 ``30.0`` 秒，如果 ``None``（預設）。"

#: ../../library/asyncio-eventloop.rst:494
#: ../../library/asyncio-eventloop.rst:733
#, fuzzy
msgid "Added support for SSL/TLS in :class:`ProactorEventLoop`."
msgstr "在 ProactorEventLoop 中新增了對 SSL/TLS 的支援。"

#: ../../library/asyncio-eventloop.rst:498
#, fuzzy
msgid ""
"The socket option :py:data:`~socket.TCP_NODELAY` is set by default for all "
"TCP connections."
msgstr " socket 選項 :py:data:`~socket.TCP_NODELAY` 預設為所有 TCP 連接設定。"

#: ../../library/asyncio-eventloop.rst:503
#: ../../library/asyncio-eventloop.rst:825
msgid "Added the *ssl_handshake_timeout* parameter."
msgstr "增加 *ssl_handshake_timeout* 參數。"

#: ../../library/asyncio-eventloop.rst:507
msgid "Added the *happy_eyeballs_delay* and *interleave* parameters."
msgstr "加入 *happy_eyeballs_delay* 和 *interleave* 參數。"

#: ../../library/asyncio-eventloop.rst:509
#, fuzzy
msgid ""
"Happy Eyeballs Algorithm: Success with Dual-Stack Hosts. When a server's "
"IPv4 path and protocol are working, but the server's IPv6 path and protocol "
"are not working, a dual-stack client application experiences significant "
"connection delay compared to an IPv4-only client.  This is undesirable "
"because it causes the dual-stack client to have a worse user experience.  "
"This document specifies requirements for algorithms that reduce this user-"
"visible delay and provides an algorithm."
msgstr ""
"快樂眼球演算法：雙棧主機的成功。當伺服器的 IPv4 路徑和協定正常工作，"
"但伺服器的 IPv6 路徑和協定不工作時，與純 IPv4 客戶端相比，雙棧客戶端應用程式"
"會經歷顯著的連接延遲。這是不可取的，因為它會導致雙棧客戶端的使用者體驗更差。"
"本文檔規定了減少這種使用者可見延遲的演算法要求，並提供了一種演算法。"

#: ../../library/asyncio-eventloop.rst:518
msgid "For more information: https://tools.ietf.org/html/rfc6555"
msgstr "更多資訊請見：\\ https://tools.ietf.org/html/rfc6555"

#: ../../library/asyncio-eventloop.rst:522
#: ../../library/asyncio-eventloop.rst:641
#: ../../library/asyncio-eventloop.rst:747
#: ../../library/asyncio-eventloop.rst:782
#: ../../library/asyncio-eventloop.rst:829
#: ../../library/asyncio-eventloop.rst:907
msgid "Added the *ssl_shutdown_timeout* parameter."
msgstr "增加 *ssl_shutdown_timeout* 參數。"

#: ../../library/asyncio-eventloop.rst:526
#, fuzzy
msgid ""
"The :func:`open_connection` function is a high-level alternative API.  It "
"returns a pair of (:class:`StreamReader`, :class:`StreamWriter`) that can be "
"used directly in async/await code."
msgstr ""
":func:`open_connection` 函式是一個高階替代 API。它回傳一對 "
"(:class:`StreamReader`, :class:`StreamWriter`) "
"可以直接在非同步/等待程式碼中使用。"

#: ../../library/asyncio-eventloop.rst:536
#, fuzzy
msgid "Create a datagram connection."
msgstr "建立資料報連接。"

#: ../../library/asyncio-eventloop.rst:538
#, fuzzy
msgid ""
"The socket family can be either :py:data:`~socket.AF_INET`, :py:data:"
"`~socket.AF_INET6`, or :py:data:`~socket.AF_UNIX`, depending on *host* (or "
"the *family* argument, if provided)."
msgstr ""
" socket 系列可以是 :py:data:`~socket.AF_INET`、:py:data:`~socket.AF_INET6` 或 "
":py:data:`~socket.AF_UNIX`，具體取決於 *host*（或*family* "
"參數，如果提供的話）。"

#: ../../library/asyncio-eventloop.rst:542
#, fuzzy
msgid "The socket type will be :py:data:`~socket.SOCK_DGRAM`."
msgstr " socket 型別將為 :py:data:`~socket.SOCK_DGRAM`。"

#: ../../library/asyncio-eventloop.rst:544
#: ../../library/asyncio-eventloop.rst:664
#: ../../library/asyncio-eventloop.rst:796
#, fuzzy
msgid ""
"*protocol_factory* must be a callable returning a :ref:`protocol <asyncio-"
"protocol>` implementation."
msgstr "*protocol_factory* 必須是可呼叫的，回傳一個 :ref:`protocol <asyncio-"
"protocol>` 實作。"

#: ../../library/asyncio-eventloop.rst:547
#: ../../library/asyncio-eventloop.rst:623
#, fuzzy
msgid "A tuple of ``(transport, protocol)`` is returned on success."
msgstr "成功回傳一個“(transport, protocol)”元組。"

#: ../../library/asyncio-eventloop.rst:551
#, fuzzy
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket locally.  The *local_host* and *local_port* are looked up using :"
"meth:`getaddrinfo`."
msgstr ""
"*local_addr*，如果給定的話，是一個``(local_host, "
"local_port)``元組，用於在本地綁定 socket 。 *local_host* 和 *local_port* 使用 "
":meth:`getaddrinfo` 查找。"

#: ../../library/asyncio-eventloop.rst:555
#, fuzzy
msgid ""
"*remote_addr*, if given, is a ``(remote_host, remote_port)`` tuple used to "
"connect the socket to a remote address.  The *remote_host* and *remote_port* "
"are looked up using :meth:`getaddrinfo`."
msgstr ""
"*remote_addr*，如果給定的話，是一個``(remote_host, "
"remote_port)``元組，用於將 socket 連接到遠程地址。使用 :meth:`getaddrinfo` "
"查找 *remote_host* 和 *remote_port*。"

#: ../../library/asyncio-eventloop.rst:559
#, fuzzy
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to :meth:`getaddrinfo` for *host* resolution. If "
"given, these should all be integers from the corresponding :mod:`socket` "
"module constants."
msgstr ""
"*family*、*proto*、*flags* 是可選的地址族、協定和旗標，將傳遞給 "
":meth:`getaddrinfo` 以進行 *host* 解析。如果給定，這些應該都是來自相應 "
":mod:`socket` 模組常數的整數。"

#: ../../library/asyncio-eventloop.rst:564
#, fuzzy
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows and some "
"Unixes. If the :py:data:`~socket.SO_REUSEPORT` constant is not defined then "
"this capability is unsupported."
msgstr ""
"*reuse_port* 告訴內核允許此端點綁定到與其他現有端點綁定到的相同端口，只要它們"
"在建立時都設定此旗標即可。 Windows 和某些 Unix 不支援此選項。如果 "
":py:data:`~socket.SO_REUSEPORT` 常數未定義，則不支援此功能。"

#: ../../library/asyncio-eventloop.rst:570
#, fuzzy
msgid ""
"*allow_broadcast* tells the kernel to allow this endpoint to send messages "
"to the broadcast address."
msgstr "*allow_broadcast* 告訴內核允許此端點向廣播地址發送消息。"

#: ../../library/asyncio-eventloop.rst:573
#, fuzzy
msgid ""
"*sock* can optionally be specified in order to use a preexisting, already "
"connected, :class:`socket.socket` object to be used by the transport. If "
"specified, *local_addr* and *remote_addr* should be omitted (must be :const:"
"`None`)."
msgstr ""
"*sock* 可以選擇指定，以便使用傳輸使用的預先存在的、已經連接的 :class:`socket."
"socket` 物件。如果指定，*local_addr* 和 *remote_addr* 應該省略（必須是 "
":const:`None`）。"

#: ../../library/asyncio-eventloop.rst:584
#, fuzzy
msgid ""
"See :ref:`UDP echo client protocol <asyncio-udp-echo-client-protocol>` and :"
"ref:`UDP echo server protocol <asyncio-udp-echo-server-protocol>` examples."
msgstr ""
"請參閱 :ref:`UDP 回顯客戶端協定 <asyncio-udp-echo-client-protocol>` 和 :ref:`"
"UDP 回顯伺服器協定 <asyncio-udp-echo-server-protocol>` 示例。"

#: ../../library/asyncio-eventloop.rst:587
#, fuzzy
msgid ""
"The *family*, *proto*, *flags*, *reuse_address*, *reuse_port*, "
"*allow_broadcast*, and *sock* parameters were added."
msgstr ""
"新增了 "
"*family*、*proto*、*flags*、*reuse_address*、*reuse_port*、*allow_broadcast* "
"和 *sock* 參數。"

#: ../../library/asyncio-eventloop.rst:591
#, fuzzy
msgid ""
"The *reuse_address* parameter is no longer supported, as using :py:data:"
"`~sockets.SO_REUSEADDR` poses a significant security concern for UDP. "
"Explicitly passing ``reuse_address=True`` will raise an exception."
msgstr ""
"不再支援 *reuse_address* 參數，因為使用 :py:data:`~sockets.SO_REUSEADDR` "
"會給 UDP 帶來嚴重的安全問題。顯式傳遞 ``reuse_address=True`` 將引發例外。"

#: ../../library/asyncio-eventloop.rst:596
#, fuzzy
msgid ""
"When multiple processes with differing UIDs assign sockets to an identical "
"UDP socket address with ``SO_REUSEADDR``, incoming packets can become "
"randomly distributed among the sockets."
msgstr ""
"當具有不同 UID 的多個行程使用 ``SO_REUSEADDR`` 將 socket 分配給相同的 UDP "
" socket 地址時，傳入的資料包可以隨機分佈在 socket 之間。"

#: ../../library/asyncio-eventloop.rst:600
#, fuzzy
msgid ""
"For supported platforms, *reuse_port* can be used as a replacement for "
"similar functionality. With *reuse_port*, :py:data:`~sockets.SO_REUSEPORT` "
"is used instead, which specifically prevents processes with differing UIDs "
"from assigning sockets to the same socket address."
msgstr ""
"對於受支援的平台，*reuse_port* 可用作類似功能的替代品。對於 *reuse_port*，"
"使用 :py:data:`~sockets.SO_REUSEPORT` 來代替，它專門防止具有不同 UID "
"的行程將 socket 分配給相同的 socket 地址。"

#: ../../library/asyncio-eventloop.rst:606
msgid "Added support for Windows."
msgstr "新增對於 Windows 的支援。"

#: ../../library/asyncio-eventloop.rst:609
#, fuzzy
msgid ""
"The *reuse_address* parameter, disabled since Python 3.9.0, 3.8.1, 3.7.6 and "
"3.6.10, has been entirely removed."
msgstr "*reuse_address* 參數，自 Python 3.9.0、3.8.1、3.7.6 和 3.6.10 "
"起被禁用，已被完全刪除。"

#: ../../library/asyncio-eventloop.rst:618
#, fuzzy
msgid "Create a Unix connection."
msgstr "建立 Unix 連接。"

#: ../../library/asyncio-eventloop.rst:620
#, fuzzy
msgid ""
"The socket family will be :py:data:`~socket.AF_UNIX`; socket type will be :"
"py:data:`~socket.SOCK_STREAM`."
msgstr ""
" socket 系列將是 :py:data:`~socket.AF_UNIX`； socket 型別將為 :py:data:`~socket."
"SOCK_STREAM`。"

#: ../../library/asyncio-eventloop.rst:625
#, fuzzy
msgid ""
"*path* is the name of a Unix domain socket and is required, unless a *sock* "
"parameter is specified.  Abstract Unix sockets, :class:`str`, :class:"
"`bytes`, and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* 是 Unix 域 socket 的名稱並且是必需的，除非指定了 *sock* 參數。支援抽象 "
"Unix  socket 、:class:`str`、:class:`bytes` 和 :class:`~pathlib.Path` 路徑。"

#: ../../library/asyncio-eventloop.rst:630
#, fuzzy
msgid ""
"See the documentation of the :meth:`loop.create_connection` method for "
"information about arguments to this method."
msgstr "有關此方法參數的資訊，請參閱 :meth:`loop.create_connection` 方法的文檔。"

#: ../../library/asyncio-eventloop.rst:633
#: ../../library/asyncio-eventloop.rst:773
#: ../../library/asyncio-eventloop.rst:1199
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`適用 <availability>`：Unix。"

#: ../../library/asyncio-eventloop.rst:635
#, fuzzy
msgid ""
"Added the *ssl_handshake_timeout* parameter. The *path* parameter can now be "
"a :term:`path-like object`."
msgstr ""
"新增了 *ssl_handshake_timeout* 參數。 *path* 參數現在可以是一個 :term:`path-"
"like object`。"

#: ../../library/asyncio-eventloop.rst:645
#, fuzzy
msgid "Creating network servers"
msgstr "建立網絡伺服器"

#: ../../library/asyncio-eventloop.rst:657
#, fuzzy
msgid ""
"Create a TCP server (socket type :data:`~socket.SOCK_STREAM`) listening on "
"*port* of the *host* address."
msgstr "建立一個 TCP 伺服器（ socket 型別 :data:`~socket.SOCK_STREAM`）偵聽 *host* "
"地址的 *port*。"

#: ../../library/asyncio-eventloop.rst:660
#, fuzzy
msgid "Returns a :class:`Server` object."
msgstr "回傳一個 :class:`Server` 物件。"

#: ../../library/asyncio-eventloop.rst:662
msgid "Arguments:"
msgstr "引數："

#: ../../library/asyncio-eventloop.rst:667
#, fuzzy
msgid ""
"The *host* parameter can be set to several types which determine where the "
"server would be listening:"
msgstr "*host* 參數可以設定為多種型別，以確定伺服器將在哪裡偵聽："

#: ../../library/asyncio-eventloop.rst:670
#, fuzzy
msgid ""
"If *host* is a string, the TCP server is bound to a single network interface "
"specified by *host*."
msgstr "如果 *host* 是一個字串，則 TCP 伺服器綁定到 *host* 指定的單個網絡介面。"

#: ../../library/asyncio-eventloop.rst:673
#, fuzzy
msgid ""
"If *host* is a sequence of strings, the TCP server is bound to all network "
"interfaces specified by the sequence."
msgstr "如果 *host* 是一個字串序列，則 TCP 伺服器綁定到該序列指定的所有網絡介面。"

#: ../../library/asyncio-eventloop.rst:676
#, fuzzy
msgid ""
"If *host* is an empty string or ``None``, all interfaces are assumed and a "
"list of multiple sockets will be returned (most likely one for IPv4 and "
"another one for IPv6)."
msgstr "如果 *host* 是空字串或 ``None`` ，則假定所有介面並回傳多個 socket 的列表（"
"很可能一個用於 IPv4，另一個用於 IPv6）。"

#: ../../library/asyncio-eventloop.rst:680
#, fuzzy
msgid ""
"The *port* parameter can be set to specify which port the server should "
"listen on. If ``0`` or ``None`` (the default), a random unused port will be "
"selected (note that if *host* resolves to multiple network interfaces, a "
"different random port will be selected for each interface)."
msgstr ""
"可以設定 *port* 參數來指定伺服器應該監聽哪個端口。如果為 ``0``或 ``None`` （預設值），"
"將選擇一個隨機未使用的端口（請注意，如果 *host* "
"解析為多個網絡介面，將為每個介面選擇一個不同的隨機端口）。"

#: ../../library/asyncio-eventloop.rst:685
#, fuzzy
msgid ""
"*family* can be set to either :data:`socket.AF_INET` or :data:`~socket."
"AF_INET6` to force the socket to use IPv4 or IPv6. If not set, the *family* "
"will be determined from host name (defaults to :data:`~socket.AF_UNSPEC`)."
msgstr ""
"*family* 可以設定為 :data:`socket.AF_INET` 或 :data:`~socket.AF_INET6` "
"以強制 socket 使用 IPv4 或 IPv6。如果未設定，*family* "
"將從主機名確定（預設為 :data:`~socket.AF_UNSPEC`）。"

#: ../../library/asyncio-eventloop.rst:690
#, fuzzy
msgid "*flags* is a bitmask for :meth:`getaddrinfo`."
msgstr "*flags* 是 :meth:`getaddrinfo` 的位掩碼。"

#: ../../library/asyncio-eventloop.rst:692
#, fuzzy
msgid ""
"*sock* can optionally be specified in order to use a preexisting socket "
"object. If specified, *host* and *port* must not be specified."
msgstr "可以選擇指定 *sock* 以使用預先存在的 socket 物件。如果指定，則不得指定 *host* "
"和 *port*。"

#: ../../library/asyncio-eventloop.rst:697
#, fuzzy
msgid ""
"The *sock* argument transfers ownership of the socket to the server created. "
"To close the socket, call the server's :meth:`~asyncio.Server.close` method."
msgstr ""
"*sock* 參數將 socket 的所有權轉移到建立的伺服器。要關閉 socket ，請呼叫伺服器的 "
":meth:`~asyncio.Server.close` 方法。"

#: ../../library/asyncio-eventloop.rst:701
#, fuzzy
msgid ""
"*backlog* is the maximum number of queued connections passed to :meth:"
"`~socket.socket.listen` (defaults to 100)."
msgstr "*backlog* 是傳遞給 :meth:`~socket.socket.listen` 的最大排隊連接數（預設為 "
"100）。"

#: ../../library/asyncio-eventloop.rst:704
#, fuzzy
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` instance to enable TLS over "
"the accepted connections."
msgstr "*ssl* 可以設定為 :class:`~ssl.SSLContext` 實例以在接受的連接上啟用 TLS。"

#: ../../library/asyncio-eventloop.rst:707
#, fuzzy
msgid ""
"*reuse_address* tells the kernel to reuse a local socket in ``TIME_WAIT`` "
"state, without waiting for its natural timeout to expire. If not specified "
"will automatically be set to ``True`` on Unix."
msgstr ""
"*reuse_address* 告訴內核在 ``TIME_WAIT`` "
"狀態下重用本地 socket ，而不等待其自然超時到期。如果未指定，將在 Unix "
"上自動設定為 ``True``。"

#: ../../library/asyncio-eventloop.rst:712
#, fuzzy
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows."
msgstr ""
"*reuse_port* 告訴內核允許此端點綁定到與其他現有端點綁定到的相同端口，只要它們"
"在建立時都設定此旗標即可。 Windows 不支援此選項。"

#: ../../library/asyncio-eventloop.rst:717
#, fuzzy
msgid ""
"*ssl_handshake_timeout* is (for a TLS server) the time in seconds to wait "
"for the TLS handshake to complete before aborting the connection. ``60.0`` "
"seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* 是（對於 TLS 伺服器）在中止連接之前等待 TLS "
"握手完成的時間（以秒為單位）。 ``60.0`` 秒，如果``無``（預設）。"

#: ../../library/asyncio-eventloop.rst:725
#, fuzzy
msgid ""
"*start_serving* set to ``True`` (the default) causes the created server to "
"start accepting connections immediately.  When set to ``False``, the user "
"should await on :meth:`Server.start_serving` or :meth:`Server.serve_forever` "
"to make the server to start accepting connections."
msgstr ""
"*start_serving* 設定為 ``True``（預設值）會導致建立的伺服器立即開始接受連接。"
"當設定為 ``False`` 時，使用者應該等待 :meth:`Server.start_serving` "
"或 :meth:`Server.serve_forever` 使伺服器開始接受連接。"

#: ../../library/asyncio-eventloop.rst:737
#, fuzzy
msgid "The *host* parameter can be a sequence of strings."
msgstr "*host* 參數可以是字串序列。"

#: ../../library/asyncio-eventloop.rst:741
#, fuzzy
msgid ""
"Added *ssl_handshake_timeout* and *start_serving* parameters. The socket "
"option :py:data:`~socket.TCP_NODELAY` is set by default for all TCP "
"connections."
msgstr ""
"新增了 *ssl_handshake_timeout* 和 *start_serving* 參數。 socket 選項 "
":py:data:`~socket.TCP_NODELAY` 預設為所有 TCP 連接設定。"

#: ../../library/asyncio-eventloop.rst:751
#, fuzzy
msgid ""
"The :func:`start_server` function is a higher-level alternative API that "
"returns a pair of :class:`StreamReader` and :class:`StreamWriter` that can "
"be used in an async/await code."
msgstr ""
":func:`start_server` 函式是一個更高階別的替代 "
"API，它回傳一對可以在非同步/等待程式碼中使用的 :class:`StreamReader` "
"和 :class:`StreamWriter`。"

#: ../../library/asyncio-eventloop.rst:762
#, fuzzy
msgid ""
"Similar to :meth:`loop.create_server` but works with the :py:data:`~socket."
"AF_UNIX` socket family."
msgstr "類似於 :meth:`loop.create_server` 但適用於 :py:data:`~socket.AF_UNIX` "
" socket 系列。"

#: ../../library/asyncio-eventloop.rst:765
#, fuzzy
msgid ""
"*path* is the name of a Unix domain socket, and is required, unless a *sock* "
"argument is provided.  Abstract Unix sockets, :class:`str`, :class:`bytes`, "
"and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* 是 Unix 域 socket 的名稱，並且是必需的，除非提供了 *sock* 參數。"
"支援抽象 Unix  socket 、:class:`str`、:class:`bytes` 和 :class:`~pathlib.Path` "
"路徑。"

#: ../../library/asyncio-eventloop.rst:770
#, fuzzy
msgid ""
"See the documentation of the :meth:`loop.create_server` method for "
"information about arguments to this method."
msgstr "有關此方法參數的資訊，請參閱 :meth:`loop.create_server` 方法的文檔。"

#: ../../library/asyncio-eventloop.rst:777
msgid ""
"Added the *ssl_handshake_timeout* and *start_serving* parameters. The *path* "
"parameter can now be a :class:`~pathlib.Path` object."
msgstr ""
"新增 *ssl_handshake_timeout* 與 *start_serving* 參數。\\ *path* 參數現在可為"
"一個 :class:`~pathlib.Path` 物件。"

#: ../../library/asyncio-eventloop.rst:789
#, fuzzy
msgid "Wrap an already accepted connection into a transport/protocol pair."
msgstr "將已接受的連接包裝到傳輸/協定對中。"

#: ../../library/asyncio-eventloop.rst:791
#, fuzzy
msgid ""
"This method can be used by servers that accept connections outside of "
"asyncio but that use asyncio to handle them."
msgstr "接受 asyncio 外部連接但使用 asyncio 處理它們的伺服器可以使用此方法。"

#: ../../library/asyncio-eventloop.rst:794
#: ../../library/asyncio-eventloop.rst:881
msgid "Parameters:"
msgstr "參數："

#: ../../library/asyncio-eventloop.rst:799
#, fuzzy
msgid ""
"*sock* is a preexisting socket object returned from :meth:`socket.accept "
"<socket.socket.accept>`."
msgstr "*sock* 是從 :meth:`socket.accept <socket.socket.accept>` "
"回傳的預先存在的 socket 物件。"

#: ../../library/asyncio-eventloop.rst:808
#, fuzzy
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` to enable SSL over the "
"accepted connections."
msgstr "*ssl* 可以設定為 :class:`~ssl.SSLContext` 以在接受的連接上啟用 SSL。"

#: ../../library/asyncio-eventloop.rst:811
#, fuzzy
msgid ""
"*ssl_handshake_timeout* is (for an SSL connection) the time in seconds to "
"wait for the SSL handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* 是（對於 SSL 連接）在中止連接之前等待 SSL "
"握手完成的時間（以秒為單位）。 ``60.0`` 秒，如果``無``（預設）。"

#: ../../library/asyncio-eventloop.rst:819
#, fuzzy
msgid "Returns a ``(transport, protocol)`` pair."
msgstr "回傳一個``（傳輸，協定）``對。"

#: ../../library/asyncio-eventloop.rst:833
#, fuzzy
msgid "Transferring files"
msgstr "傳輸文件"

#: ../../library/asyncio-eventloop.rst:838
#, fuzzy
msgid ""
"Send a *file* over a *transport*.  Return the total number of bytes sent."
msgstr "通過*傳輸*發送*文件*。回傳發送的總位元組數。"

#: ../../library/asyncio-eventloop.rst:841
#, fuzzy
msgid "The method uses high-performance :meth:`os.sendfile` if available."
msgstr "該方法使用高性能 os.sendfile（如果可用）。"

#: ../../library/asyncio-eventloop.rst:843
#, fuzzy
msgid "*file* must be a regular file object opened in binary mode."
msgstr "*file* 必須是以二進位模式打開的常規文件物件。"

#: ../../library/asyncio-eventloop.rst:845
#: ../../library/asyncio-eventloop.rst:1087
#, fuzzy
msgid ""
"*offset* tells from where to start reading the file. If specified, *count* "
"is the total number of bytes to transmit as opposed to sending the file "
"until EOF is reached. File position is always updated, even when this method "
"raises an error, and :meth:`file.tell() <io.IOBase.tell>` can be used to "
"obtain the actual number of bytes sent."
msgstr ""
"*offset* 告訴從哪裡開始讀取文件。如果指定，*count* 是要傳輸的位元組總數，"
"而不是在到達 EOF 之前發送文件。文件位置始終更新，即使此方法引發錯誤，並且 "
":meth:`file.tell() <io.IOBase.tell>` 可用於獲取實際發送的位元組數。"

#: ../../library/asyncio-eventloop.rst:852
#, fuzzy
msgid ""
"*fallback* set to ``True`` makes asyncio to manually read and send the file "
"when the platform does not support the sendfile system call (e.g. Windows or "
"SSL socket on Unix)."
msgstr ""
"*fallback* 設定為 ``True`` 使 asyncio 在平台不支援 sendfile 系統呼叫（例如 "
"Windows 或 Unix 上的 SSL  socket ）時手動讀取和發送文件。"

#: ../../library/asyncio-eventloop.rst:856
#, fuzzy
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support the "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"如果系統不支援 *sendfile* 系統呼叫並且 *fallback* 為 "
"``False``，則引發 :exec:`SendfileNotAvailableError`。"

#: ../../library/asyncio-eventloop.rst:863
#, fuzzy
msgid "TLS Upgrade"
msgstr "TLS 升級"

#: ../../library/asyncio-eventloop.rst:870
#, fuzzy
msgid "Upgrade an existing transport-based connection to TLS."
msgstr "將現有的基於傳輸的連接升級到 TLS。"

#: ../../library/asyncio-eventloop.rst:872
#, fuzzy
msgid ""
"Create a TLS coder/decoder instance and insert it between the *transport* "
"and the *protocol*. The coder/decoder implements both *transport*-facing "
"protocol and *protocol*-facing transport."
msgstr ""
"建立一個 TLS 編碼器/解碼器實例並將其插入到 *transport* 和 *protocol* "
"之間。編碼器/解碼器同時實作*transport*-facing 協定和*protocol*-facing 傳輸。"

#: ../../library/asyncio-eventloop.rst:876
#, fuzzy
msgid ""
"Return the created two-interface instance. After *await*, the *protocol* "
"must stop using the original *transport* and communicate with the returned "
"object only because the coder caches *protocol*-side data and sporadically "
"exchanges extra TLS session packets with *transport*."
msgstr ""
"回傳建立的雙介面實例。在 *await* 之後，*protocol* 必須停止使用原始的 "
"*transport* 並僅與回傳的物件通信，因為編碼器快取 *protocol* 端資料並偶爾與 "
"*transport* 交換額外的 TLS 會話資料包。"

#: ../../library/asyncio-eventloop.rst:883
#, fuzzy
msgid ""
"*transport* and *protocol* instances that methods like :meth:`~loop."
"create_server` and :meth:`~loop.create_connection` return."
msgstr ""
"*transport* 和 *protocol* 實例，方法如 :meth:`~loop.create_server` 和 "
":meth:`~loop.create_connection` 回傳。"

#: ../../library/asyncio-eventloop.rst:887
#, fuzzy
msgid "*sslcontext*: a configured instance of :class:`~ssl.SSLContext`."
msgstr "*sslcontext*: :class:`~ssl.SSLContext` 的配置實例。"

#: ../../library/asyncio-eventloop.rst:889
#, fuzzy
msgid ""
"*server_side* pass ``True`` when a server-side connection is being upgraded "
"(like the one created by :meth:`~loop.create_server`)."
msgstr ""
"*server_side* 在升級伺服器端連接時傳遞 ``True``（就像由 :meth:`~loop."
"create_server` 建立的連接）。"

#: ../../library/asyncio-eventloop.rst:892
#, fuzzy
msgid ""
"*server_hostname*: sets or overrides the host name that the target server's "
"certificate will be matched against."
msgstr "*server_hostname*：設定或覆蓋目標伺服器證書將與之匹配的主機名。"

#: ../../library/asyncio-eventloop.rst:912
#, fuzzy
msgid "Watching file descriptors"
msgstr "查看文件描述器"

#: ../../library/asyncio-eventloop.rst:916
#, fuzzy
msgid ""
"Start monitoring the *fd* file descriptor for read availability and invoke "
"*callback* with the specified arguments once *fd* is available for reading."
msgstr "開始監視 *fd* 文件描述器的讀取可用性，並在 *fd* "
"可用於讀取時呼叫帶有指定參數的 *callback*。"

#: ../../library/asyncio-eventloop.rst:922
#, fuzzy
msgid ""
"Stop monitoring the *fd* file descriptor for read availability. Returns "
"``True`` if *fd* was previously being monitored for reads."
msgstr "停止監視 *fd* 文件描述器的讀取可用性。如果 *fd* 之前被監視讀取，則回傳 "
"``True``。"

#: ../../library/asyncio-eventloop.rst:927
#, fuzzy
msgid ""
"Start monitoring the *fd* file descriptor for write availability and invoke "
"*callback* with the specified arguments once *fd* is available for writing."
msgstr "開始監視 *fd* 文件描述器的寫入可用性，並在 *fd* "
"可用於寫入時呼叫帶有指定參數的 *callback*。"

#: ../../library/asyncio-eventloop.rst:931
#: ../../library/asyncio-eventloop.rst:1186
#, fuzzy
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *callback*."
msgstr ""
"使用 func:`functools.partial` :ref:`將關鍵字參數 <asyncio-pass-keywords>` "
"傳遞給 *callback*。"

#: ../../library/asyncio-eventloop.rst:936
#, fuzzy
msgid ""
"Stop monitoring the *fd* file descriptor for write availability. Returns "
"``True`` if *fd* was previously being monitored for writes."
msgstr "停止監視 *fd* 文件描述器的寫入可用性。如果 *fd* 之前被監視以進行寫入，則回傳 "
"``True``。"

#: ../../library/asyncio-eventloop.rst:939
#, fuzzy
msgid ""
"See also :ref:`Platform Support <asyncio-platform-support>` section for some "
"limitations of these methods."
msgstr "有關這些方法的一些限制，另請參閱 :ref:`Platform Support <asyncio-platform-"
"support>` 部分。"

#: ../../library/asyncio-eventloop.rst:944
#, fuzzy
msgid "Working with socket objects directly"
msgstr "直接使用 socket 物件"

#: ../../library/asyncio-eventloop.rst:946
#, fuzzy
msgid ""
"In general, protocol implementations that use transport-based APIs such as :"
"meth:`loop.create_connection` and :meth:`loop.create_server` are faster than "
"implementations that work with sockets directly. However, there are some use "
"cases when performance is not critical, and working with :class:`~socket."
"socket` objects directly is more convenient."
msgstr ""
"通常，使用基於傳輸的 API（例如 :meth:`loop.create_connection` 和 :meth:`loop."
"create_server` "
"的協定實作比直接使用 socket 的實作更快。但是，在某些用例中，性能並不重要，"
"直接使用 :class:`~socket.socket` 物件會更方便。"

#: ../../library/asyncio-eventloop.rst:955
#, fuzzy
msgid ""
"Receive up to *nbytes* from *sock*.  Asynchronous version of :meth:`socket."
"recv() <socket.socket.recv>`."
msgstr ""
"從 *sock* 接收最多 *nbytes*。 :meth:`socket.recv() <socket.socket.recv>` "
"的非同步版本。"

#: ../../library/asyncio-eventloop.rst:958
#, fuzzy
msgid "Return the received data as a bytes object."
msgstr "將接收到的資料作為位元組物件回傳。"

#: ../../library/asyncio-eventloop.rst:960
#: ../../library/asyncio-eventloop.rst:974
#: ../../library/asyncio-eventloop.rst:985
#: ../../library/asyncio-eventloop.rst:997
#: ../../library/asyncio-eventloop.rst:1012
#: ../../library/asyncio-eventloop.rst:1027
#: ../../library/asyncio-eventloop.rst:1037
#: ../../library/asyncio-eventloop.rst:1063
#: ../../library/asyncio-eventloop.rst:1101
#, fuzzy
msgid "*sock* must be a non-blocking socket."
msgstr "*sock* 必須是非阻塞 socket 。"

#: ../../library/asyncio-eventloop.rst:962
#, fuzzy
msgid ""
"Even though this method was always documented as a coroutine method, "
"releases before Python 3.7 returned a :class:`Future`. Since Python 3.7 this "
"is an ``async def`` method."
msgstr ""
"儘管此方法始終被記錄為協程方法，但 Python 3.7 之前的版本回傳了一個 Future。"
"從 Python 3.7 開始，這是一個 ``async def`` 方法。"

#: ../../library/asyncio-eventloop.rst:969
#, fuzzy
msgid ""
"Receive data from *sock* into the *buf* buffer.  Modeled after the blocking :"
"meth:`socket.recv_into() <socket.socket.recv_into>` method."
msgstr ""
"從 *sock* 接收資料到 *buf* 緩衝區。模仿阻塞 :meth:`socket.recv_into() <socket"
".socket.recv_into>` 方法。"

#: ../../library/asyncio-eventloop.rst:972
#, fuzzy
msgid "Return the number of bytes written to the buffer."
msgstr "回傳寫入緩衝區的位元組數。"

#: ../../library/asyncio-eventloop.rst:980
#, fuzzy
msgid ""
"Receive a datagram of up to *bufsize* from *sock*.  Asynchronous version of :"
"meth:`socket.recvfrom() <socket.socket.recvfrom>`."
msgstr ""
"從 *sock* 接收最大為 *bufsize* 的資料報。 :meth:`socket.recvfrom() <socket."
"socket.recvfrom>` 的非同步版本。"

#: ../../library/asyncio-eventloop.rst:983
#, fuzzy
msgid "Return a tuple of (received data, remote address)."
msgstr "回傳一個元組（接收到的資料，遠程地址）。"

#: ../../library/asyncio-eventloop.rst:991
#, fuzzy
msgid ""
"Receive a datagram of up to *nbytes* from *sock* into *buf*. Asynchronous "
"version of :meth:`socket.recvfrom_into() <socket.socket.recvfrom_into>`."
msgstr ""
"從 *sock* 接收一個最多 *nbytes* 的資料報到 *buf*。 :meth:`socket."
"recvfrom_into() <socket.socket.recvfrom_into>` 的非同步版本。"

#: ../../library/asyncio-eventloop.rst:995
#, fuzzy
msgid "Return a tuple of (number of bytes received, remote address)."
msgstr "回傳一個元組（接收到的位元組數，遠程地址）。"

#: ../../library/asyncio-eventloop.rst:1003
#, fuzzy
msgid ""
"Send *data* to the *sock* socket. Asynchronous version of :meth:`socket."
"sendall() <socket.socket.sendall>`."
msgstr ""
"將 *data* 發送到 *sock*  socket 。 :meth:`socket.sendall() <socket.socket."
"sendall>` 的非同步版本。"

#: ../../library/asyncio-eventloop.rst:1006
#, fuzzy
msgid ""
"This method continues to send to the socket until either all data in *data* "
"has been sent or an error occurs.  ``None`` is returned on success.  On "
"error, an exception is raised. Additionally, there is no way to determine "
"how much data, if any, was successfully processed by the receiving end of "
"the connection."
msgstr ""
"此方法繼續發送到 socket ，直到 *data* 中的所有資料都已發送或發生錯誤。成功時回"
"傳 ``None`` 。出錯時，會引發例外。此外，無法確定連接的接收端成功處理了多少資料（如"
"果有的話）。"

#: ../../library/asyncio-eventloop.rst:1014
#: ../../library/asyncio-eventloop.rst:1065
#, fuzzy
msgid ""
"Even though the method was always documented as a coroutine method, before "
"Python 3.7 it returned a :class:`Future`. Since Python 3.7, this is an "
"``async def`` method."
msgstr ""
"儘管該方法始終被記錄為協程方法，但在 Python 3.7 之前它回傳了一個 Future。從 "
"Python 3.7 開始，這是一個 ``async def`` 方法。"

#: ../../library/asyncio-eventloop.rst:1021
#, fuzzy
msgid ""
"Send a datagram from *sock* to *address*. Asynchronous version of :meth:"
"`socket.sendto() <socket.socket.sendto>`."
msgstr ""
"將資料報從 *sock* 發送到 *address*。 :meth:`socket.sendto() <socket.socket."
"sendto>` 的非同步版本。"

#: ../../library/asyncio-eventloop.rst:1025
#, fuzzy
msgid "Return the number of bytes sent."
msgstr "回傳發送的位元組數。"

#: ../../library/asyncio-eventloop.rst:1033
#, fuzzy
msgid "Connect *sock* to a remote socket at *address*."
msgstr "將 *sock* 連接到位於 *address* 的遠程 socket 。"

#: ../../library/asyncio-eventloop.rst:1035
#, fuzzy
msgid ""
"Asynchronous version of :meth:`socket.connect() <socket.socket.connect>`."
msgstr ":meth:`socket.connect() <socket.socket.connect>` 的非同步版本。"

#: ../../library/asyncio-eventloop.rst:1039
#, fuzzy
msgid ""
"``address`` no longer needs to be resolved.  ``sock_connect`` will try to "
"check if the *address* is already resolved by calling :func:`socket."
"inet_pton`.  If not, :meth:`loop.getaddrinfo` will be used to resolve the "
"*address*."
msgstr ""
"``address`` 不再需要解析。 ``sock_connect`` 將嘗試檢查 *address* "
"是否已通過呼叫 :func:`socket.inet_pton` 解析。如果不是，:meth:`loop."
"getaddrinfo` 將用於解析 *address*。"

#: ../../library/asyncio-eventloop.rst:1048
#, fuzzy
msgid ""
":meth:`loop.create_connection` and  :func:`asyncio.open_connection() "
"<open_connection>`."
msgstr ""
":meth:`loop.create_connection` 和 :func:`asyncio.open_connection() "
"<open_connection>`。"

#: ../../library/asyncio-eventloop.rst:1054
#, fuzzy
msgid ""
"Accept a connection.  Modeled after the blocking :meth:`socket.accept() "
"<socket.socket.accept>` method."
msgstr "接受連接。模仿阻塞 :meth:`socket.accept() <socket.socket.accept>` 方法。"

#: ../../library/asyncio-eventloop.rst:1057
#, fuzzy
msgid ""
"The socket must be bound to an address and listening for connections. The "
"return value is a pair ``(conn, address)`` where *conn* is a *new* socket "
"object usable to send and receive data on the connection, and *address* is "
"the address bound to the socket on the other end of the connection."
msgstr ""
" socket 必須綁定到一個地址並偵聽連接。回傳值是一對“(conn, address)”，其中 "
"*conn* 是一個 *new*  socket 物件，可用於在連接上發送和接收資料，而 *address* "
"是綁定到另一個 socket 的地址連接結束。"

#: ../../library/asyncio-eventloop.rst:1072
msgid ":meth:`loop.create_server` and :func:`start_server`."
msgstr ":meth:`loop.create_server` 和 :func:`start_server`\\ 。"

#: ../../library/asyncio-eventloop.rst:1077
#, fuzzy
msgid ""
"Send a file using high-performance :mod:`os.sendfile` if possible. Return "
"the total number of bytes sent."
msgstr "如果可能，使用高性能 os.sendfile 發送文件。回傳發送的總位元組數。"

#: ../../library/asyncio-eventloop.rst:1080
#, fuzzy
msgid ""
"Asynchronous version of :meth:`socket.sendfile() <socket.socket.sendfile>`."
msgstr ":meth:`socket.sendfile() <socket.socket.sendfile>` 的非同步版本。"

#: ../../library/asyncio-eventloop.rst:1082
#, fuzzy
msgid ""
"*sock* must be a non-blocking :const:`socket.SOCK_STREAM` :class:`~socket."
"socket`."
msgstr "*sock* 必須是非阻塞的 :const:`socket.SOCK_STREAM` :class:`~socket.socket`。"

#: ../../library/asyncio-eventloop.rst:1085
#, fuzzy
msgid "*file* must be a regular file object open in binary mode."
msgstr "*file* 必須是以二進位模式打開的常規文件物件。"

#: ../../library/asyncio-eventloop.rst:1094
#, fuzzy
msgid ""
"*fallback*, when set to ``True``, makes asyncio manually read and send the "
"file when the platform does not support the sendfile syscall (e.g. Windows "
"or SSL socket on Unix)."
msgstr ""
"*fallback*，當設定為 ``True`` 時，當平台不支援 sendfile 系統呼叫（例如 "
"Windows 或 Unix 上的 SSL  socket ）時，使 asyncio 手動讀取和發送文件。"

#: ../../library/asyncio-eventloop.rst:1098
#, fuzzy
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"如果系統不支援 *sendfile* 系統呼叫並且 *fallback* 為 "
"``False``，則引發 :exec:`SendfileNotAvailableError`。"

#: ../../library/asyncio-eventloop.rst:1107
msgid "DNS"
msgstr "DNS"

#: ../../library/asyncio-eventloop.rst:1112
#, fuzzy
msgid "Asynchronous version of :meth:`socket.getaddrinfo`."
msgstr ":meth:`socket.getaddrinfo` 的非同步版本。"

#: ../../library/asyncio-eventloop.rst:1116
#, fuzzy
msgid "Asynchronous version of :meth:`socket.getnameinfo`."
msgstr ":meth:`socket.getnameinfo` 的非同步版本。"

#: ../../library/asyncio-eventloop.rst:1118
#, fuzzy
msgid ""
"Both *getaddrinfo* and *getnameinfo* methods were always documented to "
"return a coroutine, but prior to Python 3.7 they were, in fact, returning :"
"class:`asyncio.Future` objects.  Starting with Python 3.7 both methods are "
"coroutines."
msgstr ""
"*getaddrinfo* 和 *getnameinfo* 方法總是被記錄為回傳協程，但在 Python 3.7 "
"之前，它們實際上回傳 :class:`asyncio.Future` 物件。從 Python 3.7 "
"開始，這兩種方法都是協程。"

#: ../../library/asyncio-eventloop.rst:1126
#, fuzzy
msgid "Working with pipes"
msgstr "使用管道"

#: ../../library/asyncio-eventloop.rst:1130
#, fuzzy
msgid "Register the read end of *pipe* in the event loop."
msgstr "在事件循環中註冊 *pipe* 的讀取端。"

#: ../../library/asyncio-eventloop.rst:1135
#, fuzzy
msgid "*pipe* is a :term:`file-like object <file object>`."
msgstr "*pipe* 是一個 :term:`類文件物件 <file object>`。"

#: ../../library/asyncio-eventloop.rst:1137
#, fuzzy
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports the :class:"
"`ReadTransport` interface and *protocol* is an object instantiated by the "
"*protocol_factory*."
msgstr ""
"回傳對 ``(transport, protocol)``，其中 *transport* 支援 ReadTransport "
"介面，*protocol* 是由 *protocol_factory* 實例化的物件。"

#: ../../library/asyncio-eventloop.rst:1141
#: ../../library/asyncio-eventloop.rst:1157
#, fuzzy
msgid ""
"With :class:`SelectorEventLoop` event loop, the *pipe* is set to non-"
"blocking mode."
msgstr "使用 SelectorEventLoop 事件循環，*pipe* 被設定為非阻塞模式。"

#: ../../library/asyncio-eventloop.rst:1146
#, fuzzy
msgid "Register the write end of *pipe* in the event loop."
msgstr "在事件循環中註冊 *pipe* 的寫端。"

#: ../../library/asyncio-eventloop.rst:1151
#, fuzzy
msgid "*pipe* is :term:`file-like object <file object>`."
msgstr "*pipe* 是 :term:`類文件物件 <file object>`。"

#: ../../library/asyncio-eventloop.rst:1153
#, fuzzy
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports :class:"
"`WriteTransport` interface and *protocol* is an object instantiated by the "
"*protocol_factory*."
msgstr ""
"回傳對``(transport, protocol)``，其中*transport* 支援 :class:`WriteTransport` "
"介面，*protocol* 是由*protocol_factory* 實例化的物件。"

#: ../../library/asyncio-eventloop.rst:1162
#, fuzzy
msgid ""
":class:`SelectorEventLoop` does not support the above methods on Windows.  "
"Use :class:`ProactorEventLoop` instead for Windows."
msgstr ""
":class:`SelectorEventLoop` 在 Windows 上不支援上述方法。在 Windows 中使用 "
"ProactorEventLoop 代替。"

#: ../../library/asyncio-eventloop.rst:1167
#, fuzzy
msgid ""
"The :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` methods."
msgstr ":meth:`loop.subprocess_exec` 和 :meth:`loop.subprocess_shell` 方法。"

#: ../../library/asyncio-eventloop.rst:1172
#, fuzzy
msgid "Unix signals"
msgstr "Unix 信號"

#: ../../library/asyncio-eventloop.rst:1176
#, fuzzy
msgid "Set *callback* as the handler for the *signum* signal."
msgstr "將 *callback* 設定為 *signum* 信號的處理程式。"

#: ../../library/asyncio-eventloop.rst:1178
#, fuzzy
msgid ""
"The callback will be invoked by *loop*, along with other queued callbacks "
"and runnable coroutines of that event loop. Unlike signal handlers "
"registered using :func:`signal.signal`, a callback registered with this "
"function is allowed to interact with the event loop."
msgstr ""
"回呼將由 *loop* 呼叫，連同其他排隊的回呼和該事件循環的可運行協程。與使用 "
":func:`signal.signal` "
"註冊的信號處理程式不同，使用此函式註冊的回呼允許與事件循環交互。"

#: ../../library/asyncio-eventloop.rst:1183
#, fuzzy
msgid ""
"Raise :exc:`ValueError` if the signal number is invalid or uncatchable. "
"Raise :exc:`RuntimeError` if there is a problem setting up the handler."
msgstr ""
"如果信號編號無效或無法捕獲，則引發 "
":exc:`ValueError`。如果在設定處理程式時出現問題，則引發 :exc:`RuntimeError`。"

#: ../../library/asyncio-eventloop.rst:1189
#, fuzzy
msgid ""
"Like :func:`signal.signal`, this function must be invoked in the main thread."
msgstr "和 :func:`signal.signal` 一樣，這個函式必須在主執行緒中呼叫。"

#: ../../library/asyncio-eventloop.rst:1194
#, fuzzy
msgid "Remove the handler for the *sig* signal."
msgstr "刪除 *sig* 信號的處理程式。"

#: ../../library/asyncio-eventloop.rst:1196
#, fuzzy
msgid ""
"Return ``True`` if the signal handler was removed, or ``False`` if no "
"handler was set for the given signal."
msgstr "如果刪除了信號處理程式，則回傳 ``True``，如果沒有為給定信號設定處理程式，則回傳“"
"False”。"

#: ../../library/asyncio-eventloop.rst:1203
#, fuzzy
msgid "The :mod:`signal` module."
msgstr ":mod:`signal` 模組。"

#: ../../library/asyncio-eventloop.rst:1207
#, fuzzy
msgid "Executing code in thread or process pools"
msgstr "在執行緒或行程池中執行程式碼"

#: ../../library/asyncio-eventloop.rst:1211
#, fuzzy
msgid "Arrange for *func* to be called in the specified executor."
msgstr "安排在指定的執行器中呼叫 *func*。"

#: ../../library/asyncio-eventloop.rst:1213
#, fuzzy
msgid ""
"The *executor* argument should be an :class:`concurrent.futures.Executor` "
"instance. The default executor is used if *executor* is ``None``."
msgstr ""
"*executor* 參數應該是一個 :class:`concurrent.futures.Executor` 實例。如果 "
"*executor* 為 ``None``，則使用預設執行器。"

#: ../../library/asyncio-eventloop.rst:1258
#, fuzzy
msgid ""
"Note that the entry point guard (``if __name__ == '__main__'``) is required "
"for option 3 due to the peculiarities of :mod:`multiprocessing`, which is "
"used by :class:`~concurrent.futures.ProcessPoolExecutor`. See :ref:`Safe "
"importing of main module <multiprocessing-safe-main-import>`."
msgstr ""
"請注意，由於 multiprocessing 的特殊性，選項 3 需要入口點守衛（``if __name__ "
"== '__main__'``），它被 :class:`~concurrent.futures.ProcessPoolExecutor "
"使用`。請參閱 :ref:`主模組的安全導入 <multiprocessing-safe-main-import>`。"

#: ../../library/asyncio-eventloop.rst:1263
#, fuzzy
msgid "This method returns a :class:`asyncio.Future` object."
msgstr "此方法回傳一個 :class:`asyncio.Future` 物件。"

#: ../../library/asyncio-eventloop.rst:1265
#, fuzzy
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *func*."
msgstr ""
"使用 func:`functools.partial` :ref:`將關鍵字參數 <asyncio-pass-keywords>` "
"傳遞給 *func*。"

#: ../../library/asyncio-eventloop.rst:1268
#, fuzzy
msgid ""
":meth:`loop.run_in_executor` no longer configures the ``max_workers`` of the "
"thread pool executor it creates, instead leaving it up to the thread pool "
"executor (:class:`~concurrent.futures.ThreadPoolExecutor`) to set the "
"default."
msgstr ""
":meth:`loop.run_in_executor` 不再配置它建立的執行緒池執行器的 "
"``max_workers``，而是將其留給執行緒池執行器 (:class:`~concurrent.futures."
"ThreadPoolExecutor`) 來設定預設。"

#: ../../library/asyncio-eventloop.rst:1277
#, fuzzy
msgid ""
"Set *executor* as the default executor used by :meth:`run_in_executor`. "
"*executor* must be an instance of :class:`~concurrent.futures."
"ThreadPoolExecutor`."
msgstr ""
"將 *executor* 設定為 :meth:`run_in_executor` 使用的預設執行器。 *executor* "
"必須是 :class:`~concurrent.futures.ThreadPoolExecutor` 的實例。"

#: ../../library/asyncio-eventloop.rst:1281
#, fuzzy
msgid ""
"*executor* must be an instance of :class:`~concurrent.futures."
"ThreadPoolExecutor`."
msgstr "*executor* 必須是 :class:`~concurrent.futures.ThreadPoolExecutor` 的實例。"

#: ../../library/asyncio-eventloop.rst:1287
#, fuzzy
msgid "Error Handling API"
msgstr "錯誤處理介面"

#: ../../library/asyncio-eventloop.rst:1289
#, fuzzy
msgid "Allows customizing how exceptions are handled in the event loop."
msgstr "允許自定義在事件循環中處理例外的方式。"

#: ../../library/asyncio-eventloop.rst:1293
#, fuzzy
msgid "Set *handler* as the new event loop exception handler."
msgstr "將 *handler* 設定為新的事件循環例外處理程式。"

#: ../../library/asyncio-eventloop.rst:1295
#, fuzzy
msgid ""
"If *handler* is ``None``, the default exception handler will be set.  "
"Otherwise, *handler* must be a callable with the signature matching ``(loop, "
"context)``, where ``loop`` is a reference to the active event loop, and "
"``context`` is a ``dict`` object containing the details of the exception "
"(see :meth:`call_exception_handler` documentation for details about context)."
msgstr ""
"如果 *handler* 是``None``，預設的例外處理程式將被設定。否則，*handler* "
"必須是一個簽名匹配``(loop, context)`` 的可呼叫物件，其中``loop`` "
"是對活動事件循環的引用，``context`` 是一個``dict` ` "
"包含例外詳細資訊的物件（有關上下文的詳細資訊，請參閱 call_exception_handler "
"文檔）。"

#: ../../library/asyncio-eventloop.rst:1305
#, fuzzy
msgid ""
"Return the current exception handler, or ``None`` if no custom exception "
"handler was set."
msgstr "回傳當前例外處理程式，如果未設定自定義例外處理程式，則回傳 ``None``。"

#: ../../library/asyncio-eventloop.rst:1312
#, fuzzy
msgid "Default exception handler."
msgstr "預設例外處理程式。"

#: ../../library/asyncio-eventloop.rst:1314
#, fuzzy
msgid ""
"This is called when an exception occurs and no exception handler is set. "
"This can be called by a custom exception handler that wants to defer to the "
"default handler behavior."
msgstr "當發生例外並且沒有設定例外處理程式時呼叫它。這可以由想要遵循預設處理程式行為"
"的自定義例外處理程式呼叫。"

#: ../../library/asyncio-eventloop.rst:1318
#, fuzzy
msgid ""
"*context* parameter has the same meaning as in :meth:"
"`call_exception_handler`."
msgstr "*context* 參數與 call_exception_handler 中的含義相同。"

#: ../../library/asyncio-eventloop.rst:1323
#, fuzzy
msgid "Call the current event loop exception handler."
msgstr "呼叫當前事件循環例外處理程式。"

#: ../../library/asyncio-eventloop.rst:1325
#, fuzzy
msgid ""
"*context* is a ``dict`` object containing the following keys (new keys may "
"be introduced in future Python versions):"
msgstr "*context* 是一個 ``dict`` 物件，包含以下鍵（新鍵可能會在未來的 Python "
"版本中引入）："

#: ../../library/asyncio-eventloop.rst:1328
#, fuzzy
msgid "'message': Error message;"
msgstr "'message'：錯誤資訊；"

#: ../../library/asyncio-eventloop.rst:1329
#, fuzzy
msgid "'exception' (optional): Exception object;"
msgstr "'exception'（可選）：例外物件；"

#: ../../library/asyncio-eventloop.rst:1330
#, fuzzy
msgid "'future' (optional): :class:`asyncio.Future` instance;"
msgstr "'未來'（可選）：:class:`asyncio.Future` 實例；"

#: ../../library/asyncio-eventloop.rst:1331
#, fuzzy
msgid "'task' (optional): :class:`asyncio.Task` instance;"
msgstr "'任務'（可選）：:class:`asyncio.Task` 實例；"

#: ../../library/asyncio-eventloop.rst:1332
#, fuzzy
msgid "'handle' (optional): :class:`asyncio.Handle` instance;"
msgstr "'句柄'（可選）：:class:`asyncio.Handle` 實例；"

#: ../../library/asyncio-eventloop.rst:1333
#, fuzzy
msgid "'protocol' (optional): :ref:`Protocol <asyncio-protocol>` instance;"
msgstr "“協定”（可選）： :ref:`Protocol <asyncio-protocol>` 實例；"

#: ../../library/asyncio-eventloop.rst:1334
#, fuzzy
msgid "'transport' (optional): :ref:`Transport <asyncio-transport>` instance;"
msgstr "'transport'（可選）： :ref:`Transport <asyncio-transport>` 實例；"

#: ../../library/asyncio-eventloop.rst:1335
#, fuzzy
msgid "'socket' (optional): :class:`socket.socket` instance;"
msgstr "' socket '（可選）：:class:`socket.socket` 實例；"

#: ../../library/asyncio-eventloop.rst:1337
#, fuzzy
msgid "'asyncgen' (optional): Asynchronous generator that caused"
msgstr "'asyncgen'（可選）：引起的非同步生成器"

#: ../../library/asyncio-eventloop.rst:1337
#, fuzzy
msgid "the exception."
msgstr "例外。"

#: ../../library/asyncio-eventloop.rst:1341
#, fuzzy
msgid ""
"This method should not be overloaded in subclassed event loops.  For custom "
"exception handling, use the :meth:`set_exception_handler()` method."
msgstr "此方法不應在子類別事件循環中重載。對於自定義例外處理，請使用 "
"set_exception_handler() 方法。"

#: ../../library/asyncio-eventloop.rst:1346
#, fuzzy
msgid "Enabling debug mode"
msgstr "啟用除錯模式"

#: ../../library/asyncio-eventloop.rst:1350
#, fuzzy
msgid "Get the debug mode (:class:`bool`) of the event loop."
msgstr "獲取事件循環的除錯模式 (:class:`bool`)。"

#: ../../library/asyncio-eventloop.rst:1352
#, fuzzy
msgid ""
"The default value is ``True`` if the environment variable :envvar:"
"`PYTHONASYNCIODEBUG` is set to a non-empty string, ``False`` otherwise."
msgstr "如果環境變數 PYTHONASYNCIODEBUG 設定為非空字串，則預設值為 True，否則為 "
"False。"

#: ../../library/asyncio-eventloop.rst:1358
#, fuzzy
msgid "Set the debug mode of the event loop."
msgstr "設定事件循環的除錯模式。"

#: ../../library/asyncio-eventloop.rst:1362
#, fuzzy
msgid ""
"The new :ref:`Python Development Mode <devmode>` can now also be used to "
"enable the debug mode."
msgstr "新的 :ref:`Python 開發模式 <devmode>` 現在也可用於啟用除錯模式。"

#: ../../library/asyncio-eventloop.rst:1367
#, fuzzy
msgid "The :ref:`debug mode of asyncio <asyncio-debug-mode>`."
msgstr ":ref:`asyncio 的除錯模式 <asyncio-debug-mode>`。"

#: ../../library/asyncio-eventloop.rst:1371
#, fuzzy
msgid "Running Subprocesses"
msgstr "運行子行程"

#: ../../library/asyncio-eventloop.rst:1373
#, fuzzy
msgid ""
"Methods described in this subsections are low-level.  In regular async/await "
"code consider using the high-level :func:`asyncio.create_subprocess_shell` "
"and :func:`asyncio.create_subprocess_exec` convenience functions instead."
msgstr ""
"本小節中描述的方法是低階的。在常規非同步/等待程式碼中考慮使用高階 "
"asyncio.create_subprocess_shell 和 asyncio.create_subprocess_exec 便利函式。"

#: ../../library/asyncio-eventloop.rst:1380
#, fuzzy
msgid ""
"On Windows, the default event loop :class:`ProactorEventLoop` supports "
"subprocesses, whereas :class:`SelectorEventLoop` does not. See :ref:"
"`Subprocess Support on Windows <asyncio-windows-subprocess>` for details."
msgstr ""
"在 Windows 上，預設事件循環 ProactorEventLoop 支援子行程，而 "
"SelectorEventLoop 不支援。有關詳細資訊，請參閱 :ref:`Windows 上的子行程支援 "
"<asyncio-windows-subprocess>`。"

#: ../../library/asyncio-eventloop.rst:1389
#, fuzzy
msgid ""
"Create a subprocess from one or more string arguments specified by *args*."
msgstr "從 *args* 指定的一個或多個字串參數建立一個子行程。"

#: ../../library/asyncio-eventloop.rst:1392
#, fuzzy
msgid "*args* must be a list of strings represented by:"
msgstr "*args* 必須是由以下內容表示的字串列表："

#: ../../library/asyncio-eventloop.rst:1394
msgid ":class:`str`;"
msgstr ":class:`str`\\ ；"

#: ../../library/asyncio-eventloop.rst:1395
#, fuzzy
msgid ""
"or :class:`bytes`, encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`."
msgstr "或 :class:`bytes`，編碼為 :ref:`文件系統編碼 <filesystem-encoding>`。"

#: ../../library/asyncio-eventloop.rst:1398
#, fuzzy
msgid ""
"The first string specifies the program executable, and the remaining strings "
"specify the arguments.  Together, string arguments form the ``argv`` of the "
"program."
msgstr "第一個字串指定程式可執行文件，其餘字串指定參數。字串參數一起構成程式的 "
"``argv``。"

#: ../../library/asyncio-eventloop.rst:1402
#, fuzzy
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=False`` and the list of strings passed as the first "
"argument; however, where :class:`~subprocess.Popen` takes a single argument "
"which is list of strings, *subprocess_exec* takes multiple string arguments."
msgstr ""
"這類似於使用 ``shell=False`` 呼叫的標準庫 subprocess.Popen "
"類和作為第一個參數傳遞的字串列表；但是，其中 :class:`~subprocess.Popen` "
"接受一個字串列表參數，*subprocess_exec* 接受多個字串參數。"

#: ../../library/asyncio-eventloop.rst:1408
#, fuzzy
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the :class:"
"`asyncio.SubprocessProtocol` class."
msgstr ""
"*protocol_factory* 必須是可呼叫的，回傳 :class:`asyncio.SubprocessProtocol` "
"類的子類別。"

#: ../../library/asyncio-eventloop.rst:1411
msgid "Other parameters:"
msgstr "其他參數："

#: ../../library/asyncio-eventloop.rst:1413
#, fuzzy
msgid "*stdin* can be any of these:"
msgstr "*stdin* 可以是以下任何一個："

#: ../../library/asyncio-eventloop.rst:1415
#, fuzzy
msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard input stream using :meth:`~loop.connect_write_pipe`"
msgstr "一個類似文件的物件，表示要使用 :meth:`~loop.connect_write_pipe` "
"連接到子行程的標準輸入流的管道"

#: ../../library/asyncio-eventloop.rst:1418
#: ../../library/asyncio-eventloop.rst:1430
#: ../../library/asyncio-eventloop.rst:1442
#, fuzzy
msgid ""
"the :const:`subprocess.PIPE` constant (default) which will create a new pipe "
"and connect it,"
msgstr ":const:`subprocess.PIPE` 常數（預設），它將建立一個新管道並連接它，"

#: ../../library/asyncio-eventloop.rst:1420
#: ../../library/asyncio-eventloop.rst:1432
#: ../../library/asyncio-eventloop.rst:1444
#, fuzzy
msgid ""
"the value ``None`` which will make the subprocess inherit the file "
"descriptor from this process"
msgstr "值 ``None`` 將使子行程從該行程繼承文件描述器"

#: ../../library/asyncio-eventloop.rst:1422
#: ../../library/asyncio-eventloop.rst:1434
#: ../../library/asyncio-eventloop.rst:1446
#, fuzzy
msgid ""
"the :const:`subprocess.DEVNULL` constant which indicates that the special :"
"data:`os.devnull` file will be used"
msgstr ":const:`subprocess.DEVNULL` 常數，表示將使用特殊的 :data:`os.devnull` 文件"

#: ../../library/asyncio-eventloop.rst:1425
#, fuzzy
msgid "*stdout* can be any of these:"
msgstr "*stdout* 可以是以下任何一個："

#: ../../library/asyncio-eventloop.rst:1427
#, fuzzy
msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard output stream using :meth:`~loop.connect_write_pipe`"
msgstr "一個類似文件的物件，表示要使用 :meth:`~loop.connect_write_pipe` "
"連接到子行程的標準輸出流的管道"

#: ../../library/asyncio-eventloop.rst:1437
#, fuzzy
msgid "*stderr* can be any of these:"
msgstr "*stderr* 可以是以下任何一個："

#: ../../library/asyncio-eventloop.rst:1439
#, fuzzy
msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard error stream using :meth:`~loop.connect_write_pipe`"
msgstr "一個類似文件的物件，表示要使用 :meth:`~loop.connect_write_pipe` "
"連接到子行程的標準錯誤流的管道"

#: ../../library/asyncio-eventloop.rst:1448
#, fuzzy
msgid ""
"the :const:`subprocess.STDOUT` constant which will connect the standard "
"error stream to the process' standard output stream"
msgstr ":const:`subprocess.STDOUT` 常數，它將標準錯誤流連接到行程的標準輸出流"

#: ../../library/asyncio-eventloop.rst:1451
#, fuzzy
msgid ""
"All other keyword arguments are passed to :class:`subprocess.Popen` without "
"interpretation, except for *bufsize*, *universal_newlines*, *shell*, *text*, "
"*encoding* and *errors*, which should not be specified at all."
msgstr ""
"除了 *bufsize*、*universal_newlines*、*shell*、*text*、*encoding* 和 *errors*"
" 外，所有其他關鍵字參數都無需解釋地傳遞給 :class:`subprocess."
"Popen`，它們不應在全部。"

#: ../../library/asyncio-eventloop.rst:1456
#, fuzzy
msgid ""
"The ``asyncio`` subprocess API does not support decoding the streams as "
"text. :func:`bytes.decode` can be used to convert the bytes returned from "
"the stream to text."
msgstr "``asyncio`` 子行程 API 不支援將流解碼為文本。 :func:`bytes.decode` "
"可用於將從流回傳的位元組轉換為文本。"

#: ../../library/asyncio-eventloop.rst:1460
#, fuzzy
msgid ""
"See the constructor of the :class:`subprocess.Popen` class for documentation "
"on other arguments."
msgstr "有關其他參數的文檔，請參閱 subprocess.Popen 類的構造函式。"

#: ../../library/asyncio-eventloop.rst:1463
#, fuzzy
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`asyncio.SubprocessTransport` base class and *protocol* is an "
"object instantiated by the *protocol_factory*."
msgstr ""
"回傳一對 ``(transport, protocol)``，其中 *transport* 符合 :class:`asyncio."
"SubprocessTransport` 基底類別，*protocol* 是由 *protocol_factory* "
"實例化的物件。"

#: ../../library/asyncio-eventloop.rst:1471
#, fuzzy
msgid ""
"Create a subprocess from *cmd*, which can be a :class:`str` or a :class:"
"`bytes` string encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`, using the platform's \"shell\" syntax."
msgstr ""
"從 *cmd* 建立一個子行程，它可以是一個 :class:`str` 或 :class:`bytes` "
"字串編碼為 :ref:`filesystem encoding <filesystem-"
"encoding>`，使用平台的 ``shell``語法."

#: ../../library/asyncio-eventloop.rst:1476
#, fuzzy
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=True``."
msgstr "這類似於用 ``shell=True`` 呼叫的標準庫 :class:`subprocess.Popen` 類。"

#: ../../library/asyncio-eventloop.rst:1479
#, fuzzy
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the :class:"
"`SubprocessProtocol` class."
msgstr "*protocol_factory* 必須是可呼叫的，回傳 :class:`SubprocessProtocol` "
"類的子類別。"

#: ../../library/asyncio-eventloop.rst:1482
#, fuzzy
msgid ""
"See :meth:`~loop.subprocess_exec` for more details about the remaining "
"arguments."
msgstr "有關剩餘參數的更多詳細資訊，請參見 :meth:`~loop.subprocess_exec`。"

#: ../../library/asyncio-eventloop.rst:1485
#, fuzzy
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`SubprocessTransport` base class and *protocol* is an object "
"instantiated by the *protocol_factory*."
msgstr ""
"回傳一對 ``(transport, protocol)``，其中 *transport* 符合 "
":class:`SubprocessTransport` 基底類別，*protocol* 是由 *protocol_factory* "
"實例化的物件。"

#: ../../library/asyncio-eventloop.rst:1490
#, fuzzy
msgid ""
"It is the application's responsibility to ensure that all whitespace and "
"special characters are quoted appropriately to avoid `shell injection "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ "
"vulnerabilities. The :func:`shlex.quote` function can be used to properly "
"escape whitespace and special characters in strings that are going to be "
"used to construct shell commands."
msgstr ""
"應用程式有責任確保所有空格和特殊字元都被適當地引用以避免`shell 注入 "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ 漏洞。 "
":func:`shlex.quote` 函式可用於正確轉義將用於構造 shell "
"命令的字串中的空格和特殊字元。"

#: ../../library/asyncio-eventloop.rst:1499
#, fuzzy
msgid "Callback Handles"
msgstr "回呼句柄"

#: ../../library/asyncio-eventloop.rst:1503
#, fuzzy
msgid ""
"A callback wrapper object returned by :meth:`loop.call_soon`, :meth:`loop."
"call_soon_threadsafe`."
msgstr ":meth:`loop.call_soon`, :meth:`loop.call_soon_threadsafe` "
"回傳的回呼包裝器物件。"

#: ../../library/asyncio-eventloop.rst:1508
#, fuzzy
msgid ""
"Cancel the callback.  If the callback has already been canceled or executed, "
"this method has no effect."
msgstr "取消回呼。如果回呼已被取消或執行，則此方法無效。"

#: ../../library/asyncio-eventloop.rst:1513
#, fuzzy
msgid "Return ``True`` if the callback was cancelled."
msgstr "如果回呼被取消，則回傳 ``True``。"

#: ../../library/asyncio-eventloop.rst:1519
#, fuzzy
msgid ""
"A callback wrapper object returned by :meth:`loop.call_later`, and :meth:"
"`loop.call_at`."
msgstr "loop.call_later 和 loop.call_at 回傳的回呼包裝器物件。"

#: ../../library/asyncio-eventloop.rst:1522
#, fuzzy
msgid "This class is a subclass of :class:`Handle`."
msgstr "這個類是 Handle 的子類別。"

#: ../../library/asyncio-eventloop.rst:1526
#, fuzzy
msgid "Return a scheduled callback time as :class:`float` seconds."
msgstr "以 :class:`float` 秒的形式回傳預定的回呼時間。"

#: ../../library/asyncio-eventloop.rst:1528
#, fuzzy
msgid ""
"The time is an absolute timestamp, using the same time reference as :meth:"
"`loop.time`."
msgstr "時間是一個絕對時間戳，使用與 :meth:`loop.time` 相同的時間參考。"

#: ../../library/asyncio-eventloop.rst:1535
#, fuzzy
msgid "Server Objects"
msgstr "伺服器物件"

#: ../../library/asyncio-eventloop.rst:1537
#, fuzzy
msgid ""
"Server objects are created by :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :func:`start_server`, and :func:`start_unix_server` "
"functions."
msgstr ""
"伺服器物件由 :meth:`loop.create_server`、:meth:`loop."
"create_unix_server`、:func:`start_server` 和 :func:`start_unix_server` "
"函式建立。"

#: ../../library/asyncio-eventloop.rst:1541
#, fuzzy
msgid "Do not instantiate the class directly."
msgstr "不要直接實例化類。"

#: ../../library/asyncio-eventloop.rst:1545
#, fuzzy
msgid ""
"*Server* objects are asynchronous context managers.  When used in an ``async "
"with`` statement, it's guaranteed that the Server object is closed and not "
"accepting new connections when the ``async with`` statement is completed::"
msgstr ""
"*Server* 對像是非同步上下文管理器。在 ``async with`` 語句中使用時，保證在 ``"
"async with`` 語句完成時伺服器物件關閉並且不接受新連接::"

#: ../../library/asyncio-eventloop.rst:1558
#, fuzzy
msgid "Server object is an asynchronous context manager since Python 3.7."
msgstr "伺服器對像是自 Python 3.7 以來的非同步上下文管理器。"

#: ../../library/asyncio-eventloop.rst:1563
#, fuzzy
msgid ""
"Stop serving: close listening sockets and set the :attr:`sockets` attribute "
"to ``None``."
msgstr "停止服務：關閉監聽 socket 並將 :attr:`sockets` 屬性設定為 ``None``。"

#: ../../library/asyncio-eventloop.rst:1566
#, fuzzy
msgid ""
"The sockets that represent existing incoming client connections are left "
"open."
msgstr "表示現有傳入客戶端連接的 socket 保持打開狀態。"

#: ../../library/asyncio-eventloop.rst:1569
#, fuzzy
msgid ""
"The server is closed asynchronously, use the :meth:`wait_closed` coroutine "
"to wait until the server is closed."
msgstr "伺服器非同步關閉，使用 :meth:`wait_closed` 協程等待伺服器關閉。"

#: ../../library/asyncio-eventloop.rst:1574
#, fuzzy
msgid "Return the event loop associated with the server object."
msgstr "回傳與伺服器物件關聯的事件循環。"

#: ../../library/asyncio-eventloop.rst:1580
#, fuzzy
msgid "Start accepting connections."
msgstr "開始接受連接。"

#: ../../library/asyncio-eventloop.rst:1582
#, fuzzy
msgid ""
"This method is idempotent, so it can be called when the server is already "
"serving."
msgstr "此方法是冪等的，因此可以在伺服器已服務時呼叫。"

#: ../../library/asyncio-eventloop.rst:1585
#, fuzzy
msgid ""
"The *start_serving* keyword-only parameter to :meth:`loop.create_server` "
"and :meth:`asyncio.start_server` allows creating a Server object that is not "
"accepting connections initially.  In this case ``Server.start_serving()``, "
"or :meth:`Server.serve_forever` can be used to make the Server start "
"accepting connections."
msgstr ""
":meth:`loop.create_server` 和 :meth:`asyncio.start_server` 的 *start_serving* "
"關鍵字參數允許建立一個最初不接受連接的伺服器物件。在這種情況下，``Server."
"start_serving()`` 或 :meth:`Server.serve_forever` 可用於使伺服器開始接受連接。"

#: ../../library/asyncio-eventloop.rst:1596
#, fuzzy
msgid ""
"Start accepting connections until the coroutine is cancelled. Cancellation "
"of ``serve_forever`` task causes the server to be closed."
msgstr "開始接受連接，直到協程被取消。取消 ``serve_forever`` 任務會導致伺服器關閉。"

#: ../../library/asyncio-eventloop.rst:1600
#, fuzzy
msgid ""
"This method can be called if the server is already accepting connections.  "
"Only one ``serve_forever`` task can exist per one *Server* object."
msgstr "如果伺服器已經在接受連接，則可以呼叫此方法。每個 *Server* 對像只能存在一個 "
"``serve_forever`` 任務。"

#: ../../library/asyncio-eventloop.rst:1622
#, fuzzy
msgid "Return ``True`` if the server is accepting new connections."
msgstr "如果伺服器正在接受新連接，則回傳 ``True``。"

#: ../../library/asyncio-eventloop.rst:1628
#, fuzzy
msgid "Wait until the :meth:`close` method completes."
msgstr "等到 :meth:`close` 方法完成。"

#: ../../library/asyncio-eventloop.rst:1632
#, fuzzy
msgid "List of :class:`socket.socket` objects the server is listening on."
msgstr "伺服器正在偵聽的 :class:`socket.socket` 物件列表。"

#: ../../library/asyncio-eventloop.rst:1634
#, fuzzy
msgid ""
"Prior to Python 3.7 ``Server.sockets`` used to return an internal list of "
"server sockets directly.  In 3.7 a copy of that list is returned."
msgstr "在 Python 3.7 之前，``Server.sockets`` 用於直接回傳伺服器 socket 的內部列表。"
"在 3.7 中，回傳該列表的副本。"

#: ../../library/asyncio-eventloop.rst:1644
#, fuzzy
msgid "Event Loop Implementations"
msgstr "事件循環實作"

#: ../../library/asyncio-eventloop.rst:1646
#, fuzzy
msgid ""
"asyncio ships with two different event loop implementations: :class:"
"`SelectorEventLoop` and :class:`ProactorEventLoop`."
msgstr "asyncio 附帶了兩種不同的事件循環實作：SelectorEventLoop 和 "
"ProactorEventLoop。"

#: ../../library/asyncio-eventloop.rst:1649
#, fuzzy
msgid ""
"By default asyncio is configured to use :class:`SelectorEventLoop` on Unix "
"and :class:`ProactorEventLoop` on Windows."
msgstr ""
"預設情況下，asyncio 配置為在 Unix 上使用 SelectorEventLoop，在 Windows "
"上使用 ProactorEventLoop。"

#: ../../library/asyncio-eventloop.rst:1655
#, fuzzy
msgid "An event loop based on the :mod:`selectors` module."
msgstr "基於 :mod:`selectors` 模組的事件循環。"

#: ../../library/asyncio-eventloop.rst:1657
#, fuzzy
msgid ""
"Uses the most efficient *selector* available for the given platform.  It is "
"also possible to manually configure the exact selector implementation to be "
"used::"
msgstr "使用給定平台可用的最有效的*選擇器*。也可以手動配置要使用的確切選擇器實作："

#: ../../library/asyncio-eventloop.rst:1672
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`適用 <availability>`：Unix、Windows。"

#: ../../library/asyncio-eventloop.rst:1677
#, fuzzy
msgid "An event loop for Windows that uses \"I/O Completion Ports\" (IOCP)."
msgstr "使用“I/O 完成端口”(IOCP) 的 Windows 事件循環。"

#: ../../library/asyncio-eventloop.rst:1679
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`適用 <availability>`：Windows。"

#: ../../library/asyncio-eventloop.rst:1683
#, fuzzy
msgid ""
"`MSDN documentation on I/O Completion Ports <https://docs.microsoft.com/en-"
"ca/windows/desktop/FileIO/i-o-completion-ports>`_."
msgstr ""
"`關於 I/O 完成端口的 MSDN 文檔 <https://docs.microsoft.com/en-ca/windows/"
"desktop/FileIO/i-o-completion-ports>`_。"

#: ../../library/asyncio-eventloop.rst:1689
#, fuzzy
msgid "Abstract base class for asyncio-compliant event loops."
msgstr "非同步相容事件循環的抽象基底類別。"

#: ../../library/asyncio-eventloop.rst:1691
#, fuzzy
msgid ""
"The :ref:`asyncio-event-loop-methods` section lists all methods that an "
"alternative implementation of ``AbstractEventLoop`` should have defined."
msgstr ""
":ref:`asyncio-event-loop-methods` 部分列出了``AbstractEventLoop`` "
"的替代實作應該定義的所有方法。"

#: ../../library/asyncio-eventloop.rst:1697
msgid "Examples"
msgstr "範例"

#: ../../library/asyncio-eventloop.rst:1699
#, fuzzy
msgid ""
"Note that all examples in this section **purposefully** show how to use the "
"low-level event loop APIs, such as :meth:`loop.run_forever` and :meth:`loop."
"call_soon`.  Modern asyncio applications rarely need to be written this way; "
"consider using the high-level functions like :func:`asyncio.run`."
msgstr ""
"請注意，本節中的所有示例都**有目的地**展示瞭如何使用低階事件循環 API，例如 "
":meth:`loop.run_forever` 和 :meth:`loop.call_soon`。現代 asyncio "
"應用程式很少需要以這種方式編寫；考慮使用像 :func:`asyncio.run` "
"這樣的高階函式。"

#: ../../library/asyncio-eventloop.rst:1709
#, fuzzy
msgid "Hello World with call_soon()"
msgstr "使用 call_soon() 的 Hello World"

#: ../../library/asyncio-eventloop.rst:1711
#, fuzzy
msgid ""
"An example using the :meth:`loop.call_soon` method to schedule a callback. "
"The callback displays ``\"Hello World\"`` and then stops the event loop::"
msgstr "使用 :meth:`loop.call_soon` 方法安排回呼的示例。回呼顯示``\"Hello World\"`` "
"然後停止事件循環::"

#: ../../library/asyncio-eventloop.rst:1735
#, fuzzy
msgid ""
"A similar :ref:`Hello World <coroutine>` example created with a coroutine "
"and the :func:`run` function."
msgstr "使用協程和 :func:`run` 函式建立的類似 :ref:`Hello World <coroutine>` 示例。"

#: ../../library/asyncio-eventloop.rst:1742
#, fuzzy
msgid "Display the current date with call_later()"
msgstr "使用 call_later() 顯示當前日期"

#: ../../library/asyncio-eventloop.rst:1744
#, fuzzy
msgid ""
"An example of a callback displaying the current date every second. The "
"callback uses the :meth:`loop.call_later` method to reschedule itself after "
"5 seconds, and then stops the event loop::"
msgstr "每秒顯示當前日期的回呼示例。回呼使用 :meth:`loop.call_later` 方法在 5 "
"秒後重新安排自己，然後停止事件循環::"

#: ../../library/asyncio-eventloop.rst:1772
#, fuzzy
msgid ""
"A similar :ref:`current date <asyncio_example_sleep>` example created with a "
"coroutine and the :func:`run` function."
msgstr ""
"使用協程和 :func:`run` 函式建立的類似 :ref:`current date "
"<asyncio_example_sleep>` 示例。"

#: ../../library/asyncio-eventloop.rst:1779
#, fuzzy
msgid "Watch a file descriptor for read events"
msgstr "觀察讀取事件的文件描述器"

#: ../../library/asyncio-eventloop.rst:1781
#, fuzzy
msgid ""
"Wait until a file descriptor received some data using the :meth:`loop."
"add_reader` method and then close the event loop::"
msgstr "等到文件描述器使用 loop.add_reader 方法接收到一些資料，然後關閉事件循環::"

#: ../../library/asyncio-eventloop.rst:1819
#, fuzzy
msgid ""
"A similar :ref:`example <asyncio_example_create_connection>` using "
"transports, protocols, and the :meth:`loop.create_connection` method."
msgstr ""
"一個類似的例子 <asyncio_example_create_connection>` 使用傳輸、協定和 "
":meth:`loop.create_connection` 方法。"

#: ../../library/asyncio-eventloop.rst:1823
#, fuzzy
msgid ""
"Another similar :ref:`example <asyncio_example_create_connection-streams>` "
"using the high-level :func:`asyncio.open_connection` function and streams."
msgstr ""
"另一個類似的例子 <asyncio_example_create_connection-streams>` 使用高階 "
":func:`asyncio.open_connection` 函式和流。"

#: ../../library/asyncio-eventloop.rst:1831
#, fuzzy
msgid "Set signal handlers for SIGINT and SIGTERM"
msgstr "為 SIGINT 和 SIGTERM 設定信號處理程式"

#: ../../library/asyncio-eventloop.rst:1833
#, fuzzy
msgid "(This ``signals`` example only works on Unix.)"
msgstr "（此“信號”示例僅適用於 Unix。）"

#: ../../library/asyncio-eventloop.rst:1835
#, fuzzy
msgid ""
"Register handlers for signals :py:data:`SIGINT` and :py:data:`SIGTERM` using "
"the :meth:`loop.add_signal_handler` method::"
msgstr ""
"使用 loop.add_signal_handler 方法為信號 :py:data:`SIGINT` 和 "
":py:data:`SIGTERM` 註冊處理程式::"
