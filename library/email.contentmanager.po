# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-26 18:54+0800\n"
"PO-Revision-Date: 2018-05-23 14:43+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/email.contentmanager.rst:2
msgid ":mod:`email.contentmanager`: Managing MIME Content"
msgstr ":mod:`email.contentmanager`: 管理 MIME 內容"

#: ../../library/email.contentmanager.rst:10
msgid "**Source code:** :source:`Lib/email/contentmanager.py`"
msgstr "**原始碼：**\\ :source:`Lib/email/contentmanager.py`"

#: ../../library/email.contentmanager.rst:14
msgid "[1]_"
msgstr "[1]_"

#: ../../library/email.contentmanager.rst:19
#, fuzzy
msgid ""
"Base class for content managers.  Provides the standard registry mechanisms "
"to register converters between MIME content and other representations, as "
"well as the ``get_content`` and ``set_content`` dispatch methods."
msgstr ""
"內容管理器的基底類別。提供標準註冊機制來註冊 MIME "
"內容和其他表示形式之間的轉換器，以及 ``get_content`` 和 ``set_content`` "
"調度方法。"

#: ../../library/email.contentmanager.rst:26
#, fuzzy
msgid ""
"Look up a handler function based on the ``mimetype`` of *msg* (see next "
"paragraph), call it, passing through all arguments, and return the result of "
"the call.  The expectation is that the handler will extract the payload from "
"*msg* and return an object that encodes information about the extracted data."
msgstr ""
"根據 *msg* 的 ``mimetype`` "
"查找處理函式（見下一段），呼叫它，傳遞所有參數，並回傳呼叫結果。"
"期望處理程式將從 *msg* "
"中提取有效負載並回傳一個物件，該對像對有關提取資料的資訊進行編碼。"

#: ../../library/email.contentmanager.rst:32
#, fuzzy
msgid ""
"To find the handler, look for the following keys in the registry, stopping "
"with the first one found:"
msgstr "要查找處理程式，請在註冊表中查找以下鍵，找到第一個就停止："

#: ../../library/email.contentmanager.rst:35
#, fuzzy
msgid "the string representing the full MIME type (``maintype/subtype``)"
msgstr "表示完整 MIME 型別的字串（``maintype/subtype``）"

#: ../../library/email.contentmanager.rst:36
#, fuzzy
msgid "the string representing the ``maintype``"
msgstr "表示 ``maintype`` 的字串"

#: ../../library/email.contentmanager.rst:37
#, fuzzy
msgid "the empty string"
msgstr "空字串"

#: ../../library/email.contentmanager.rst:39
#, fuzzy
msgid ""
"If none of these keys produce a handler, raise a :exc:`KeyError` for the "
"full MIME type."
msgstr "如果這些鍵都沒有產生處理程式，則為完整的 MIME 型別引發 :exc:`KeyError`。"

#: ../../library/email.contentmanager.rst:45
#, fuzzy
msgid ""
"If the ``maintype`` is ``multipart``, raise a :exc:`TypeError`; otherwise "
"look up a handler function based on the type of *obj* (see next paragraph), "
"call :meth:`~email.message.EmailMessage.clear_content` on the *msg*, and "
"call the handler function, passing through all arguments.  The expectation "
"is that the handler will transform and store *obj* into *msg*, possibly "
"making other changes to *msg* as well, such as adding various MIME headers "
"to encode information needed to interpret the stored data."
msgstr ""
"如果 ``maintype`` 是 ``multipart``，引發 :exc:`TypeError`；否則根據 *obj* "
"的型別查找處理函式（見下一段），在 *msg* 上呼叫 :meth:`~email.message."
"EmailMessage.clear_content`，並呼叫處理函式，傳遞所有參數.預期處理程式會將 "
"*obj* 轉換並儲存到 *msg*，可能還會對 *msg* 進行其他更改，例如新增各種 MIME "
"標頭以對解釋儲存資料所需的資訊進行編碼。"

#: ../../library/email.contentmanager.rst:54
#, fuzzy
msgid ""
"To find the handler, obtain the type of *obj* (``typ = type(obj)``), and "
"look for the following keys in the registry, stopping with the first one "
"found:"
msgstr "要找到處理程式，請獲取 *obj* 的型別（``typ = "
"type(obj)``），並在註冊表中查找以下鍵，找到第一個就停止："

#: ../../library/email.contentmanager.rst:58
#, fuzzy
msgid "the type itself (``typ``)"
msgstr "型別本身（``typ``）"

#: ../../library/email.contentmanager.rst:59
#, fuzzy
msgid ""
"the type's fully qualified name (``typ.__module__ + '.' + typ."
"__qualname__``)."
msgstr "型別的完全限定名稱（``typ.__module__ + '.' + typ.__qualname__``）。"

#: ../../library/email.contentmanager.rst:61
#, fuzzy
msgid "the type's qualname (``typ.__qualname__``)"
msgstr "型別的質量名（``typ.__qualname__``）"

#: ../../library/email.contentmanager.rst:62
#, fuzzy
msgid "the type's name (``typ.__name__``)."
msgstr "型別的名稱（``typ.__name__``）。"

#: ../../library/email.contentmanager.rst:64
#, fuzzy
msgid ""
"If none of the above match, repeat all of the checks above for each of the "
"types in the :term:`MRO` (``typ.__mro__``).  Finally, if no other key yields "
"a handler, check for a handler for the key ``None``.  If there is no handler "
"for ``None``, raise a :exc:`KeyError` for the fully qualified name of the "
"type."
msgstr ""
"如果以上都不匹配，請對 :term:`MRO` (``typ.__mro__``) 中的每種型別重複上述所有"
"檢查。最後，如果沒有其他鍵產生處理程式，請檢查鍵 ``None`` 的處理程式。如果沒有“None"
"”的處理程式，則為該型別的完全限定名稱引發 KeyError。"

#: ../../library/email.contentmanager.rst:70
#, fuzzy
msgid ""
"Also add a :mailheader:`MIME-Version` header if one is not present (see "
"also :class:`.MIMEPart`)."
msgstr "如果不存在，還要新增一個 :mailheader:`MIME-Version` 標頭（另請參閱 :class:`."
"MIMEPart`）。"

#: ../../library/email.contentmanager.rst:76
#, fuzzy
msgid ""
"Record the function *handler* as the handler for *key*.  For the possible "
"values of *key*, see :meth:`get_content`."
msgstr "將函式 *handler* 記錄為 *key* 的處理程式。有關 *key* "
"的可能值，請參閱 :meth:`get_content`。"

#: ../../library/email.contentmanager.rst:82
#, fuzzy
msgid ""
"Record *handler* as the function to call when an object of a type matching "
"*typekey* is passed to :meth:`set_content`.  For the possible values of "
"*typekey*, see :meth:`set_content`."
msgstr ""
"將 *handler* 記錄為當型別匹配 *typekey* 的對像傳遞給 :meth:`set_content` "
"時呼叫的函式。有關 *typekey* 的可能值，請參閱 :meth:`set_content`。"

#: ../../library/email.contentmanager.rst:88
#, fuzzy
msgid "Content Manager Instances"
msgstr "內容管理器實例"

#: ../../library/email.contentmanager.rst:90
#, fuzzy
msgid ""
"Currently the email package provides only one concrete content manager, :"
"data:`raw_data_manager`, although more may be added in the future. :data:"
"`raw_data_manager` is the :attr:`~email.policy.EmailPolicy.content_manager` "
"provided by :attr:`~email.policy.EmailPolicy` and its derivatives."
msgstr ""
"目前，電子郵件包僅提供一個具體的內容管理器 :data:`raw_data_manager`，儘管將來"
"可能會新增更多。 :data:`raw_data_manager` 是 :attr:`~email.policy.EmailPolicy"
".content_manager` 由 :attr:`~email.policy.EmailPolicy` 及其衍生物提供。"

#: ../../library/email.contentmanager.rst:99
#, fuzzy
msgid ""
"This content manager provides only a minimum interface beyond that provided "
"by :class:`~email.message.Message` itself:  it deals only with text, raw "
"byte strings, and :class:`~email.message.Message` objects.  Nevertheless, it "
"provides significant advantages compared to the base API: ``get_content`` on "
"a text part will return a unicode string without the application needing to "
"manually decode it, ``set_content`` provides a rich set of options for "
"controlling the headers added to a part and controlling the content transfer "
"encoding, and it enables the use of the various ``add_`` methods, thereby "
"simplifying the creation of multipart messages."
msgstr ""
"除了 :class:`~email.message.Message` "
"本身提供的介面之外，此內容管理器僅提供最小介面：它僅處理文本、"
"原始位元組字串和 :class:`~email.message.Message` 物件。然而，與基本 API "
"相比，它提供了顯著的優勢：文本部分的 ``get_content`` 將回傳一個 unicode "
"字串，而不需要應用程式手動解碼它，``set_content`` 提供了一組豐富的選項來控制"
"標題新增到一個部分並控制內容傳輸編碼，它允許使用各種“add_”方法，從而簡化多部"
"分消息的建立。"

#: ../../library/email.contentmanager.rst:111
#, fuzzy
msgid ""
"Return the payload of the part as either a string (for ``text`` parts), an :"
"class:`~email.message.EmailMessage` object (for ``message/rfc822`` parts), "
"or a ``bytes`` object (for all other non-multipart types).  Raise a :exc:"
"`KeyError` if called on a ``multipart``.  If the part is a ``text`` part and "
"*errors* is specified, use it as the error handler when decoding the payload "
"to unicode.  The default error handler is ``replace``."
msgstr ""
"將部分的有效負載作為字串（對於 ``text`` 部分）、:class:`~email.message."
"EmailMessage` 物件（對於 ``message/rfc822`` 部分）或 ``bytes 回傳`` "
"物件（對於所有其他非多部分型別）。如果在 ``multipart`` 上呼叫，則引發 "
":exc:`KeyError`。如果該部分是“文本”部分並且指定了 *errors*，"
"則在將有效負載解碼為 unicode 時將其用作錯誤處理程式。預設的錯誤處理程式是 "
"``replace``。"

#: ../../library/email.contentmanager.rst:130
#, fuzzy
msgid "Add headers and payload to *msg*:"
msgstr "將標頭和有效負載新增到 *msg*："

#: ../../library/email.contentmanager.rst:132
#, fuzzy
msgid ""
"Add a :mailheader:`Content-Type` header with a ``maintype/subtype`` value."
msgstr "新增帶有 ``maintype/subtype`` 值的 :mailheader:`Content-Type` 標頭。"

#: ../../library/email.contentmanager.rst:135
#, fuzzy
msgid ""
"For ``str``, set the MIME ``maintype`` to ``text``, and set the subtype to "
"*subtype* if it is specified, or ``plain`` if it is not."
msgstr ""
"對於 ``str``，將 MIME ``maintype`` 設定為 ``text``，如果指定，"
"則將子型別設定為 *subtype*，如果未指定，則設定為 ``plain``。"

#: ../../library/email.contentmanager.rst:137
#, fuzzy
msgid ""
"For ``bytes``, use the specified *maintype* and *subtype*, or raise a :exc:"
"`TypeError` if they are not specified."
msgstr "對於 ``bytes``，使用指定的 *maintype* 和 *subtype*，如果未指定則引發 "
":exc:`TypeError`。"

#: ../../library/email.contentmanager.rst:139
#, fuzzy
msgid ""
"For :class:`~email.message.EmailMessage` objects, set the maintype to "
"``message``, and set the subtype to *subtype* if it is specified or "
"``rfc822`` if it is not.  If *subtype* is ``partial``, raise an error "
"(``bytes`` objects must be used to construct ``message/partial`` parts)."
msgstr ""
"對於 :class:`~email.message.EmailMessage` 物件，將主型別設定為``message``，如"
"果指定則將子型別設定為*subtype*，否則設定為``rfc822``。如果 *subtype* 是 "
"``partial``，則引發錯誤（``bytes`` 物件必須用於構造 ``message/partial`` "
"部分）。"

#: ../../library/email.contentmanager.rst:145
#, fuzzy
msgid ""
"If *charset* is provided (which is valid only for ``str``), encode the "
"string to bytes using the specified character set.  The default is "
"``utf-8``.  If the specified *charset* is a known alias for a standard MIME "
"charset name, use the standard charset instead."
msgstr ""
"如果提供了 *charset*（僅對 ``str`` "
"有效），則使用指定的字元集將字串編碼為位元組。預設是 ``utf-8``。如果指定的 "
"*charset* 是標準 MIME 字元集名稱的已知別名，請改用標準字元集。"

#: ../../library/email.contentmanager.rst:150
#, fuzzy
msgid ""
"If *cte* is set, encode the payload using the specified content transfer "
"encoding, and set the :mailheader:`Content-Transfer-Encoding` header to that "
"value.  Possible values for *cte* are ``quoted-printable``, ``base64``, "
"``7bit``, ``8bit``, and ``binary``.  If the input cannot be encoded in the "
"specified encoding (for example, specifying a *cte* of ``7bit`` for an input "
"that contains non-ASCII values), raise a :exc:`ValueError`."
msgstr ""
"如果設定了 *cte*，則使用指定的內容傳輸編碼對有效負載進行編碼，並將 "
":mailheader:`Content-Transfer-Encoding` 標頭設定為該值。 *cte* 的可能值為"
"``quoted-printable``、``base64``、``7bit``、``8bit`` "
"和``binary``。如果輸入無法以指定的編碼進行編碼（例如，為包含非 ASCII "
"值的輸入指定 ``7bit`` 的 *cte*），則引發 :exc:`ValueError`。"

#: ../../library/email.contentmanager.rst:158
#, fuzzy
msgid ""
"For ``str`` objects, if *cte* is not set use heuristics to determine the "
"most compact encoding."
msgstr "對於 ``str`` 物件，如果未設定 *cte*，則使用試探法來確定最緊湊的編碼。"

#: ../../library/email.contentmanager.rst:160
#, fuzzy
msgid ""
"For :class:`~email.message.EmailMessage`, per :rfc:`2046`, raise an error if "
"a *cte* of ``quoted-printable`` or ``base64`` is requested for *subtype* "
"``rfc822``, and for any *cte* other than ``7bit`` for *subtype* ``external-"
"body``.  For ``message/rfc822``, use ``8bit`` if *cte* is not specified.  "
"For all other values of *subtype*, use ``7bit``."
msgstr ""
"對於 :class:`~email.message.EmailMessage`，根據 :rfc:`2046`，如果 *subtype* "
"``quoted-printable`` 或 ``base64`` 的 *cte* 被請求，則引發錯誤`rfc822``，"
"以及對於 *subtype* ``external-body`` 的 ``7bit`` 以外的任何 *cte*。對於 ``"
"message/rfc822``，如果未指定 *cte*，則使用 ``8bit``。對於 *subtype* "
"的所有其他值，請使用 ``7bit``。"

#: ../../library/email.contentmanager.rst:167
#, fuzzy
msgid ""
"A *cte* of ``binary`` does not actually work correctly yet. The "
"``EmailMessage`` object as modified by ``set_content`` is correct, but :"
"class:`~email.generator.BytesGenerator` does not serialize it correctly."
msgstr ""
"``binary`` 的 *cte* 實際上還不能正常工作。由 `set_content`` 修改的 "
"``EmailMessage`` 對像是正確的，但是 :class:`~email.generator.BytesGenerator` "
"沒有正確序列化它。"

#: ../../library/email.contentmanager.rst:172
#, fuzzy
msgid ""
"If *disposition* is set, use it as the value of the :mailheader:`Content-"
"Disposition` header.  If not specified, and *filename* is specified, add the "
"header with the value ``attachment``. If *disposition* is not specified and "
"*filename* is also not specified, do not add the header.  The only valid "
"values for *disposition* are ``attachment`` and ``inline``."
msgstr ""
"如果設定了 *disposition*，將其用作 :mailheader:`Content-Disposition` "
"標頭的值。如果未指定，但指定了 *filename*，則新增值為 ``attachment``的標頭。"
"如果未指定 *disposition* 且 *filename* 也未指定，則不要新增標題。 "
"*disposition* 的唯一有效值是 ``attachment``和 ``inline``。"

#: ../../library/email.contentmanager.rst:179
#, fuzzy
msgid ""
"If *filename* is specified, use it as the value of the ``filename`` "
"parameter of the :mailheader:`Content-Disposition` header."
msgstr ""
"如果指定了 *filename*，則將其用作 :mailheader:`Content-Disposition` 標頭的 "
"``filename`` 參數的值。"

#: ../../library/email.contentmanager.rst:182
#, fuzzy
msgid ""
"If *cid* is specified, add a :mailheader:`Content-ID` header with *cid* as "
"its value."
msgstr "如果指定了 *cid*，則新增一個以 *cid* 為值的 :mailheader:`Content-ID` 標頭。"

#: ../../library/email.contentmanager.rst:185
#, fuzzy
msgid ""
"If *params* is specified, iterate its ``items`` method and use the resulting "
"``(key, value)`` pairs to set additional parameters on the :mailheader:"
"`Content-Type` header."
msgstr ""
"如果指定了 *params*，疊代它的 ``items`` 方法並使用生成的 ``(key, value)`` "
"對在 :mailheader:`Content-Type` 標頭上設定額外的參數。"

#: ../../library/email.contentmanager.rst:189
#, fuzzy
msgid ""
"If *headers* is specified and is a list of strings of the form ``headername: "
"headervalue`` or a list of ``header`` objects (distinguished from strings by "
"having a ``name`` attribute), add the headers to *msg*."
msgstr ""
"如果 *headers* 被指定並且是一個字串列表，形式為 ``headername: headervalue`` "
"或 ``header`` 物件列表（通過具有 ``name`` "
"屬性與字串區分），新增標題到*消息*。"

#: ../../library/email.contentmanager.rst:196
msgid "Footnotes"
msgstr "註解"

#: ../../library/email.contentmanager.rst:197
#, fuzzy
msgid ""
"Originally added in 3.4 as a :term:`provisional module <provisional package>`"
msgstr "最初在 3.4 中新增為 :term:`臨時模組 <臨時包>`"
