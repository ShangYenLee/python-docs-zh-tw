# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-13 19:36+0000\n"
"PO-Revision-Date: 2018-05-23 16:14+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/unittest.mock.rst:3
msgid ":mod:`unittest.mock` --- mock object library"
msgstr ":mod:`unittest.mock` ---模擬物件函式庫"

#: ../../library/unittest.mock.rst:13
msgid "**Source code:** :source:`Lib/unittest/mock.py`"
msgstr "**原始碼：**\\ :source:`Lib/unittest/mock.py`"

#: ../../library/unittest.mock.rst:17
#, fuzzy
msgid ""
":mod:`unittest.mock` is a library for testing in Python. It allows you to "
"replace parts of your system under test with mock objects and make "
"assertions about how they have been used."
msgstr ""
":mod:`unittest.mock` 是一個用於 Python 測試的庫。它允許您用模擬物件替換被測系"
"統的某些部分，並對它們的使用方式做出斷言。"

#: ../../library/unittest.mock.rst:21
#, fuzzy
msgid ""
":mod:`unittest.mock` provides a core :class:`Mock` class removing the need "
"to create a host of stubs throughout your test suite. After performing an "
"action, you can make assertions about which methods / attributes were used "
"and arguments they were called with. You can also specify return values and "
"set needed attributes in the normal way."
msgstr ""
":mod:`unittest.mock` 提供了一個核心 :class:`Mock` 類，無需在整個測試套件中建"
"立大量存根。執行操作後，您可以斷言使用了哪些方法/屬性以及呼叫它們時使用的參數"
"。您還可以指定回傳值並以正常方式設定所需的屬性。"

#: ../../library/unittest.mock.rst:27
#, fuzzy
msgid ""
"Additionally, mock provides a :func:`patch` decorator that handles patching "
"module and class level attributes within the scope of a test, along with :"
"const:`sentinel` for creating unique objects. See the `quick guide`_ for "
"some examples of how to use :class:`Mock`, :class:`MagicMock` and :func:"
"`patch`."
msgstr ""
"此外，mock 提供了一個 :func:`patch` "
"裝飾器，用於處理測試範圍內的修補模組和類級別屬性，以及 :const:`sentinel` "
"用於建立唯一物件。有關如何使用 :class:`Mock`、:class:`MagicMock` 和 "
":func:`patch` 的一些示例，請參閱“快速指南”。"

#: ../../library/unittest.mock.rst:33
#, fuzzy
msgid ""
"Mock is designed for use with :mod:`unittest` and is based on the 'action -> "
"assertion' pattern instead of 'record -> replay' used by many mocking "
"frameworks."
msgstr ""
"Mock 設計用於 :mod:`unittest` 並且基於 'action -> assertion' "
"模式而不是許多模擬框架使用的 'record -> replay'。"

#: ../../library/unittest.mock.rst:37
#, fuzzy
msgid ""
"There is a backport of :mod:`unittest.mock` for earlier versions of Python, "
"available as `mock on PyPI <https://pypi.org/project/mock>`_."
msgstr ""
"對於早期版本的 Python，有一個 :mod:`unittest.mock` 的反向移植，在 PyPI "
"<https://pypi.org/project/mock>`_ 上作為`mock 可用。"

#: ../../library/unittest.mock.rst:42
#, fuzzy
msgid "Quick Guide"
msgstr "快速指南"

#: ../../library/unittest.mock.rst:60
#, fuzzy
msgid ""
":class:`Mock` and :class:`MagicMock` objects create all attributes and "
"methods as you access them and store details of how they have been used. You "
"can configure them, to specify return values or limit what attributes are "
"available, and then make assertions about how they have been used:"
msgstr ""
":class:`Mock` 和 :class:`MagicMock` 物件在您訪問它們時建立所有屬性和方法，並"
"儲存它們如何被使用的詳細資訊。您可以配置它們，指定回傳值或限制可用的屬性，然"
"後斷言它們的使用方式："

#: ../../library/unittest.mock.rst:72
#, fuzzy
msgid ""
":attr:`side_effect` allows you to perform side effects, including raising an "
"exception when a mock is called:"
msgstr ":attr:`side_effect` 允許您執行副作用，包括在呼叫模擬時引發例外："

#: ../../library/unittest.mock.rst:92
#, fuzzy
msgid ""
"Mock has many other ways you can configure it and control its behaviour. For "
"example the *spec* argument configures the mock to take its specification "
"from another object. Attempting to access attributes or methods on the mock "
"that don't exist on the spec will fail with an :exc:`AttributeError`."
msgstr ""
"Mock 有許多其他方法可以配置它並控制它的行為。例如，*spec* 參數將 mock "
"配置為從另一個物件獲取其規範。嘗試訪問 mock "
"上不存在於規範中的屬性或方法將失敗並出現 :exc:`AttributeError`。"

#: ../../library/unittest.mock.rst:97
#, fuzzy
msgid ""
"The :func:`patch` decorator / context manager makes it easy to mock classes "
"or objects in a module under test. The object you specify will be replaced "
"with a mock (or other object) during the test and restored when the test "
"ends::"
msgstr ""
":func:`patch` 裝飾器/上下文管理器可以輕鬆模擬被測模組中的類或物件。您指定的物"
"件將在測試期間被替換為模擬（或其他物件）並在測試結束時恢復::"

#: ../../library/unittest.mock.rst:116
#, fuzzy
msgid ""
"When you nest patch decorators the mocks are passed in to the decorated "
"function in the same order they applied (the normal *Python* order that "
"decorators are applied). This means from the bottom up, so in the example "
"above the mock for ``module.ClassName1`` is passed in first."
msgstr ""
"當您嵌套補丁裝飾器時，模擬將按照它們應用的相同順序傳遞給裝飾函式（"
"裝飾器應用的正常 *Python* 順序）。這意味著自下而上，因此在上面的示例中，"
"首先傳入 ``module.ClassName1`` 的模擬。"

#: ../../library/unittest.mock.rst:121
#, fuzzy
msgid ""
"With :func:`patch` it matters that you patch objects in the namespace where "
"they are looked up. This is normally straightforward, but for a quick guide "
"read :ref:`where to patch <where-to-patch>`."
msgstr ""
"使用 :func:`patch` "
"重要的是在查找它們的名稱空間中修補物件。這通常很簡單，但要獲得快速指南，"
"請閱讀 :ref:`where to patch <where-to-patch>`。"

#: ../../library/unittest.mock.rst:125
#, fuzzy
msgid ""
"As well as a decorator :func:`patch` can be used as a context manager in a "
"with statement:"
msgstr "除了裝飾器 :func:`patch` 之外，還可以在 with 語句中用作上下文管理器："

#: ../../library/unittest.mock.rst:135
#, fuzzy
msgid ""
"There is also :func:`patch.dict` for setting values in a dictionary just "
"during a scope and restoring the dictionary to its original state when the "
"test ends:"
msgstr "還有 :func:`patch.dict` "
"用於在範圍內設定字典中的值並在測試結束時將字典恢復到其原始狀態："

#: ../../library/unittest.mock.rst:146
#, fuzzy
msgid ""
"Mock supports the mocking of Python :ref:`magic methods <magic-methods>`. "
"The easiest way of using magic methods is with the :class:`MagicMock` class. "
"It allows you to do things like:"
msgstr ""
"Mock 支援模擬 Python :ref:`magic methods <magic-methods>`。"
"使用魔術方法最簡單的方法是使用 :class:`MagicMock` 類。它允許您執行以下操作："

#: ../../library/unittest.mock.rst:156
#, fuzzy
msgid ""
"Mock allows you to assign functions (or other Mock instances) to magic "
"methods and they will be called appropriately. The :class:`MagicMock` class "
"is just a Mock variant that has all of the magic methods pre-created for you "
"(well, all the useful ones anyway)."
msgstr ""
"Mock 允許您將函式（或其他 Mock 實例）分配給魔法方法，它們將被適當地呼叫。 "
":class:`MagicMock` 類只是一個 Mock "
"變體，它具有為您預先建立的所有魔術方法（好吧，無論如何都是有用的）。"

#: ../../library/unittest.mock.rst:161
#, fuzzy
msgid ""
"The following is an example of using magic methods with the ordinary Mock "
"class:"
msgstr "以下是在普通 Mock 類中使用魔術方法的示例："

#: ../../library/unittest.mock.rst:169
#, fuzzy
msgid ""
"For ensuring that the mock objects in your tests have the same api as the "
"objects they are replacing, you can use :ref:`auto-speccing <auto-"
"speccing>`. Auto-speccing can be done through the *autospec* argument to "
"patch, or the :func:`create_autospec` function. Auto-speccing creates mock "
"objects that have the same attributes and methods as the objects they are "
"replacing, and any functions and methods (including constructors) have the "
"same call signature as the real object."
msgstr ""
"為了確保測試中的模擬物件與它們要替換的物件具有相同的 API，您可以使用 :ref"
":`auto-speccing <auto-speccing>`。 Auto-speccing 可以通過 patch 的 *autospec*"
" 參數或 create_autospec 函式來完成。 Auto-speccing 建立模擬物件，這些模擬物件"
"與它們要替換的物件具有相同的屬性和方法，並且任何函式和方法（包括構造函式）都"
"具有與真實物件相同的呼叫簽名。"

#: ../../library/unittest.mock.rst:177
#, fuzzy
msgid ""
"This ensures that your mocks will fail in the same way as your production "
"code if they are used incorrectly:"
msgstr "如果使用不當，這可以確保您的模擬將以與生產程式碼相同的方式失敗："

#: ../../library/unittest.mock.rst:193
#, fuzzy
msgid ""
":func:`create_autospec` can also be used on classes, where it copies the "
"signature of the ``__init__`` method, and on callable objects where it "
"copies the signature of the ``__call__`` method."
msgstr ""
":func:`create_autospec` 也可以用在類上，它複製 ``__init__`` "
"方法的簽名，也可以用在可呼叫物件上，它複製 ``__call__`` 方法的簽名。"

#: ../../library/unittest.mock.rst:200
#, fuzzy
msgid "The Mock Class"
msgstr "模擬班"

#: ../../library/unittest.mock.rst:211
#, fuzzy
msgid ""
":class:`Mock` is a flexible mock object intended to replace the use of stubs "
"and test doubles throughout your code. Mocks are callable and create "
"attributes as new mocks when you access them [#]_. Accessing the same "
"attribute will always return the same mock. Mocks record how you use them, "
"allowing you to make assertions about what your code has done to them."
msgstr ""
":class:`Mock` 是一個靈活的模擬物件，旨在取代整個程式碼中對存根和測試替身的使"
"用。模擬是可呼叫的，並在您訪問它們時將屬性建立為新模擬 "
"[#]_。訪問相同的屬性將始終回傳相同的模擬。 Mocks "
"記錄你如何使用它們，允許你斷言你的程式碼對它們做了什麼。"

#: ../../library/unittest.mock.rst:217
#, fuzzy
msgid ""
":class:`MagicMock` is a subclass of :class:`Mock` with all the magic methods "
"pre-created and ready to use. There are also non-callable variants, useful "
"when you are mocking out objects that aren't callable: :class:"
"`NonCallableMock` and :class:`NonCallableMagicMock`"
msgstr ""
":class:`MagicMock` 是 :class:`Mock` 的子類別，所有魔術方法都已預先建立並可以"
"使用。還有不可呼叫的變體，當您模擬不可呼叫的物件時很有用：:class:`NonCallable"
"Mock` 和 :class:`NonCallableMagicMock`"

#: ../../library/unittest.mock.rst:222
#, fuzzy
msgid ""
"The :func:`patch` decorators makes it easy to temporarily replace classes in "
"a particular module with a :class:`Mock` object. By default :func:`patch` "
"will create a :class:`MagicMock` for you. You can specify an alternative "
"class of :class:`Mock` using the *new_callable* argument to :func:`patch`."
msgstr ""
":func:`patch` 裝飾器可以輕鬆地將特定模組中的類臨時替換為 :class:`Mock` "
"物件。預設情況下，:func:`patch` 會為你建立一個 :class:`MagicMock`。您可以使用 "
":func:`patch` 的 *new_callable* 參數指定 :class:`Mock` 的替代類。"

#: ../../library/unittest.mock.rst:230
#, fuzzy
msgid ""
"Create a new :class:`Mock` object. :class:`Mock` takes several optional "
"arguments that specify the behaviour of the Mock object:"
msgstr "建立一個新的 Mock 物件。 :class:`Mock` 採用幾個可選參數來指定 Mock "
"物件的行為："

#: ../../library/unittest.mock.rst:233
#, fuzzy
msgid ""
"*spec*: This can be either a list of strings or an existing object (a class "
"or instance) that acts as the specification for the mock object. If you pass "
"in an object then a list of strings is formed by calling dir on the object "
"(excluding unsupported magic attributes and methods). Accessing any "
"attribute not in this list will raise an :exc:`AttributeError`."
msgstr ""
"*spec*：這可以是字串列表或充當模擬物件規範的現有物件（類或實例）。如果您傳入"
"一個物件，則通過對該物件呼叫 dir "
"來形成一個字串列表（不包括不受支援的魔術屬性和方法）。"
"訪問不在此列表中的任何屬性將引發 :exc:`AttributeError`。"

#: ../../library/unittest.mock.rst:239
#, fuzzy
msgid ""
"If *spec* is an object (rather than a list of strings) then :attr:`~instance."
"__class__` returns the class of the spec object. This allows mocks to pass :"
"func:`isinstance` tests."
msgstr ""
"如果 *spec* 是一個物件（而不是字串列表），則 :attr:`~instance."
"__class__` 回傳 spec 物件的類。這允許模擬通過 :func:`isinstance` 測試。"

#: ../../library/unittest.mock.rst:243
#, fuzzy
msgid ""
"*spec_set*: A stricter variant of *spec*. If used, attempting to *set* or "
"get an attribute on the mock that isn't on the object passed as *spec_set* "
"will raise an :exc:`AttributeError`."
msgstr ""
"*spec_set*：*spec* 的更嚴格變體。如果使用，嘗試 *set* 或獲取不在作為 "
"*spec_set* 傳遞的物件上的 mock 屬性將引發 :exc:`AttributeError`。"

#: ../../library/unittest.mock.rst:247
#, fuzzy
msgid ""
"*side_effect*: A function to be called whenever the Mock is called. See the :"
"attr:`~Mock.side_effect` attribute. Useful for raising exceptions or "
"dynamically changing return values. The function is called with the same "
"arguments as the mock, and unless it returns :data:`DEFAULT`, the return "
"value of this function is used as the return value."
msgstr ""
"*side_effect*：每當呼叫 Mock 時要呼叫的函式。請參閱 :attr:`~Mock.side_effect`"
" 屬性。用於引發例外或動態更改回傳值。該函式使用與 mock 相同的參數呼叫，"
"除非它回傳 :data:`DEFAULT`，否則該函式的回傳值將用作回傳值。"

#: ../../library/unittest.mock.rst:253
#, fuzzy
msgid ""
"Alternatively *side_effect* can be an exception class or instance. In this "
"case the exception will be raised when the mock is called."
msgstr "或者 *side_effect* 可以是例外類或實例。在這種情況下，呼叫模擬時將引發例外。"

#: ../../library/unittest.mock.rst:256
#, fuzzy
msgid ""
"If *side_effect* is an iterable then each call to the mock will return the "
"next value from the iterable."
msgstr "如果 *side_effect* 是一個可疊代物件，那麼每次呼叫 mock "
"都會回傳可疊代物件的下一個值。"

#: ../../library/unittest.mock.rst:259
#, fuzzy
msgid "A *side_effect* can be cleared by setting it to ``None``."
msgstr "*side_effect* 可以通過將其設定為 ``None`` 來清除。"

#: ../../library/unittest.mock.rst:261
#, fuzzy
msgid ""
"*return_value*: The value returned when the mock is called. By default this "
"is a new Mock (created on first access). See the :attr:`return_value` "
"attribute."
msgstr ""
"*return_value*：呼叫 mock 時回傳的值。預設情況下，這是一個新的模擬（在第一次"
"訪問時建立）。請參閱 :attr:`return_value` 屬性。"

#: ../../library/unittest.mock.rst:265
#, fuzzy
msgid ""
"*unsafe*: By default, accessing any attribute whose name starts with "
"*assert*, *assret*, *asert*, *aseert* or *assrt* will raise an :exc:"
"`AttributeError`. Passing ``unsafe=True`` will allow access to these "
"attributes."
msgstr ""
"*不安全*：預設情況下，訪問任何名稱以 *assert*、*assret*、*asert*、*aseert* "
"或 *assrt* 開頭的屬性將引發 :exc:`AttributeError`。傳遞 ``unsafe=True`` "
"將允許訪問這些屬性。"

#: ../../library/unittest.mock.rst:272
#, fuzzy
msgid ""
"*wraps*: Item for the mock object to wrap. If *wraps* is not ``None`` then "
"calling the Mock will pass the call through to the wrapped object (returning "
"the real result). Attribute access on the mock will return a Mock object "
"that wraps the corresponding attribute of the wrapped object (so attempting "
"to access an attribute that doesn't exist will raise an :exc:"
"`AttributeError`)."
msgstr ""
"*wraps*：要包裝的模擬物件的項目。如果 *wraps* 不是 ``None``，那麼呼叫 Mock "
"會將呼叫傳遞給包裝物件（回傳真實結果）。對 mock 的屬性訪問將回傳一個 Mock "
"物件，該物件包裝了被包裝物件的相應屬性（因此嘗試訪問不存在的屬性將引發 "
":exc:`AttributeError`）。"

#: ../../library/unittest.mock.rst:279
#, fuzzy
msgid ""
"If the mock has an explicit *return_value* set then calls are not passed to "
"the wrapped object and the *return_value* is returned instead."
msgstr "如果 mock 有一個明確的 *return_value* 集，那麼呼叫不會傳遞給包裝物件，"
"而是回傳 *return_value*。"

#: ../../library/unittest.mock.rst:282
#, fuzzy
msgid ""
"*name*: If the mock has a name then it will be used in the repr of the mock. "
"This can be useful for debugging. The name is propagated to child mocks."
msgstr "*name*：如果 mock 有一個名字，那麼它將在 mock 的 repr "
"中使用。這對於除錯很有用。該名稱被傳播到子模擬。"

#: ../../library/unittest.mock.rst:286
#, fuzzy
msgid ""
"Mocks can also be called with arbitrary keyword arguments. These will be "
"used to set attributes on the mock after it is created. See the :meth:"
"`configure_mock` method for details."
msgstr ""
"模擬也可以用任意關鍵字參數呼叫。這些將用於在建立模擬後設定模擬的屬性。有關詳"
"細資訊，請參閱 :meth:`configure_mock` 方法。"

#: ../../library/unittest.mock.rst:292
#, fuzzy
msgid "Assert that the mock was called at least once."
msgstr "斷言模擬至少被呼叫一次。"

#: ../../library/unittest.mock.rst:303
#, fuzzy
msgid "Assert that the mock was called exactly once."
msgstr "斷言模擬被呼叫了一次。"

#: ../../library/unittest.mock.rst:321
#, fuzzy
msgid ""
"This method is a convenient way of asserting that the last call has been "
"made in a particular way:"
msgstr "此方法是斷言最後一次呼叫是以特定方式進行的一種便捷方式："

#: ../../library/unittest.mock.rst:331
#, fuzzy
msgid ""
"Assert that the mock was called exactly once and that call was with the "
"specified arguments."
msgstr "斷言模擬只被呼叫一次，並且該呼叫帶有指定的參數。"

#: ../../library/unittest.mock.rst:346
#, fuzzy
msgid "assert the mock has been called with the specified arguments."
msgstr "斷言已使用指定參數呼叫模擬。"

#: ../../library/unittest.mock.rst:348
#, fuzzy
msgid ""
"The assert passes if the mock has *ever* been called, unlike :meth:"
"`assert_called_with` and :meth:`assert_called_once_with` that only pass if "
"the call is the most recent one, and in the case of :meth:"
"`assert_called_once_with` it must also be the only call."
msgstr ""
"如果模擬 *曾經* 被呼叫，斷言就會通過，不像 :meth:`assert_called_with` 和 "
":meth:`assert_called_once_with` 只有在最近一次呼叫時才會通過，在 "
":meth:`assert_called_once_with` 的情況下它也必須是唯一的電話。"

#: ../../library/unittest.mock.rst:361
#, fuzzy
msgid ""
"assert the mock has been called with the specified calls. The :attr:"
"`mock_calls` list is checked for the calls."
msgstr "斷言已使用指定的呼叫呼叫模擬。檢查 :attr:`mock_calls` 列表中的呼叫。"

#: ../../library/unittest.mock.rst:364
#, fuzzy
msgid ""
"If *any_order* is false then the calls must be sequential. There can be "
"extra calls before or after the specified calls."
msgstr "如果 *any_order* 為 "
"false，則呼叫必須是連續的。在指定的呼叫之前或之後可以有額外的呼叫。"

#: ../../library/unittest.mock.rst:368
#, fuzzy
msgid ""
"If *any_order* is true then the calls can be in any order, but they must all "
"appear in :attr:`mock_calls`."
msgstr "如果 *any_order* 為真，則呼叫可以按任何順序進行，但它們必須全部出現在 "
"mock_calls 中。"

#: ../../library/unittest.mock.rst:383
#, fuzzy
msgid "Assert the mock was never called."
msgstr "斷言模擬從未被呼叫。"

#: ../../library/unittest.mock.rst:398
#, fuzzy
msgid "The reset_mock method resets all the call attributes on a mock object:"
msgstr "reset_mock 方法重置模擬物件上的所有呼叫屬性："

#: ../../library/unittest.mock.rst:408
#, fuzzy
msgid "Added two keyword-only arguments to the reset_mock function."
msgstr "向 reset_mock 函式新增了兩個僅限關鍵字的參數。"

#: ../../library/unittest.mock.rst:411
#, fuzzy
msgid ""
"This can be useful where you want to make a series of assertions that reuse "
"the same object. Note that :meth:`reset_mock` *doesn't* clear the return "
"value, :attr:`side_effect` or any child attributes you have set using normal "
"assignment by default. In case you want to reset *return_value* or :attr:"
"`side_effect`, then pass the corresponding parameter as ``True``. Child "
"mocks and the return value mock (if any) are reset as well."
msgstr ""
"這在您想要進行一系列重用同一物件的斷言時很有用。請注意 :meth:`reset_mock` "
"*不會*清除回傳值、:attr:`side_effect` 或您預設使用正常賦值設定的任何子屬性。"
"如果您想重置 *return_value* 或 :attr:`side_effect`，則將相應的參數作為 "
"``True`` 傳遞。子模擬和回傳值模擬（如果有）也被重置。"

#: ../../library/unittest.mock.rst:419
#, fuzzy
msgid "*return_value*, and :attr:`side_effect` are keyword-only arguments."
msgstr "*return_value* 和 :attr:`side_effect` 是僅限關鍵字的參數。"

#: ../../library/unittest.mock.rst:425
#, fuzzy
msgid ""
"Add a spec to a mock. *spec* can either be an object or a list of strings. "
"Only attributes on the *spec* can be fetched as attributes from the mock."
msgstr "向模擬新增規範。 *spec* 可以是物件或字串列表。只有 *spec* 上的屬性才能作為 "
"mock 中的屬性獲取。"

#: ../../library/unittest.mock.rst:429
#, fuzzy
msgid "If *spec_set* is true then only attributes on the spec can be set."
msgstr "如果 *spec_set* 為真，則只能設定規範中的屬性。"

#: ../../library/unittest.mock.rst:434
#, fuzzy
msgid ""
"Attach a mock as an attribute of this one, replacing its name and parent. "
"Calls to the attached mock will be recorded in the :attr:`method_calls` and :"
"attr:`mock_calls` attributes of this one."
msgstr ""
"附加一個模擬作為這個的屬性，替換它的名稱和父級。"
"對附加模擬的呼叫將記錄在這個模擬的 :attr:`method_calls` 和 :attr:`mock_calls`"
" 屬性中。"

#: ../../library/unittest.mock.rst:441
#, fuzzy
msgid "Set attributes on the mock through keyword arguments."
msgstr "通過關鍵字參數在 mock 上設定屬性。"

#: ../../library/unittest.mock.rst:443
#, fuzzy
msgid ""
"Attributes plus return values and side effects can be set on child mocks "
"using standard dot notation and unpacking a dictionary in the method call:"
msgstr "可以使用標準點符號在子模擬上設定屬性加上回傳值和副作用，並在方法呼叫中解壓字"
"典："

#: ../../library/unittest.mock.rst:457
#, fuzzy
msgid "The same thing can be achieved in the constructor call to mocks:"
msgstr "同樣的事情可以在構造函式呼叫 mocks 中實作："

#: ../../library/unittest.mock.rst:470
#, fuzzy
msgid ""
":meth:`configure_mock` exists to make it easier to do configuration after "
"the mock has been created."
msgstr ":meth:`configure_mock` 的存在是為了在建立模擬後更容易進行配置。"

#: ../../library/unittest.mock.rst:476
#, fuzzy
msgid ""
":class:`Mock` objects limit the results of ``dir(some_mock)`` to useful "
"results. For mocks with a *spec* this includes all the permitted attributes "
"for the mock."
msgstr ""
":class:`Mock` 物件將 ``dir(some_mock)`` 的結果限制為有用的結果。對於帶有 "
"*spec* 的模擬，這包括模擬的所有允許屬性。"

#: ../../library/unittest.mock.rst:480
#, fuzzy
msgid ""
"See :data:`FILTER_DIR` for what this filtering does, and how to switch it "
"off."
msgstr "請參閱 :data:`FILTER_DIR` 以了解此過濾的作用以及如何將其關閉。"

#: ../../library/unittest.mock.rst:486
#, fuzzy
msgid ""
"Create the child mocks for attributes and return value. By default child "
"mocks will be the same type as the parent. Subclasses of Mock may want to "
"override this to customize the way child mocks are made."
msgstr "為屬性和回傳值建立子模擬。預設情況下，子模擬將與父模擬具有相同的型別。 Mock "
"的子類別可能希望重寫它以自定義子模擬的製作方式。"

#: ../../library/unittest.mock.rst:491
#, fuzzy
msgid ""
"For non-callable mocks the callable variant will be used (rather than any "
"custom subclass)."
msgstr "對於不可呼叫的模擬，將使用可呼叫的變體（而不是任何自定義子類別）。"

#: ../../library/unittest.mock.rst:497
#, fuzzy
msgid "A boolean representing whether or not the mock object has been called:"
msgstr "表示是否已呼叫模擬物件的布爾值："

#: ../../library/unittest.mock.rst:508
#, fuzzy
msgid "An integer telling you how many times the mock object has been called:"
msgstr "一個整數告訴你模擬物件被呼叫了多少次："

#: ../../library/unittest.mock.rst:520
#, fuzzy
msgid "Set this to configure the value returned by calling the mock:"
msgstr "設定此項以配置通過呼叫模擬回傳的值："

#: ../../library/unittest.mock.rst:527
#, fuzzy
msgid ""
"The default return value is a mock object and you can configure it in the "
"normal way:"
msgstr "預設回傳值是一個模擬物件，你可以用正常的方式配置它："

#: ../../library/unittest.mock.rst:536
#, fuzzy
msgid ":attr:`return_value` can also be set in the constructor:"
msgstr ":attr:`return_value` 也可以在構造函式中設定："

#: ../../library/unittest.mock.rst:547
#, fuzzy
msgid ""
"This can either be a function to be called when the mock is called, an "
"iterable or an exception (class or instance) to be raised."
msgstr "這可以是呼叫模擬時要呼叫的函式、可疊代物件或要引發的例外（類或實例）。"

#: ../../library/unittest.mock.rst:550
#, fuzzy
msgid ""
"If you pass in a function it will be called with same arguments as the mock "
"and unless the function returns the :data:`DEFAULT` singleton the call to "
"the mock will then return whatever the function returns. If the function "
"returns :data:`DEFAULT` then the mock will return its normal value (from "
"the :attr:`return_value`)."
msgstr ""
"如果你傳入一個函式，它將使用與 mock 相同的參數呼叫，除非函式回傳 "
":data:`DEFAULT` 單例，否則對 mock 的呼叫將回傳函式回傳的任何內容。"
"如果函式回傳 :data:`DEFAULT` 則模擬將回傳其正常值（來自 "
":attr:`return_value`）。"

#: ../../library/unittest.mock.rst:556
#, fuzzy
msgid ""
"If you pass in an iterable, it is used to retrieve an iterator which must "
"yield a value on every call.  This value can either be an exception instance "
"to be raised, or a value to be returned from the call to the mock (:data:"
"`DEFAULT` handling is identical to the function case)."
msgstr ""
"如果傳入一個可疊代物件，它用於檢索一個疊代器，該疊代器必須在每次呼叫時產生一"
"個值。該值可以是要引發的例外實例，也可以是從對模擬的呼叫回傳的值（:data:`DE"
"FAULT` 處理與函式案例相同）。"

#: ../../library/unittest.mock.rst:561
#, fuzzy
msgid ""
"An example of a mock that raises an exception (to test exception handling of "
"an API):"
msgstr "引發例外的模擬示例（用於測試 API 的例外處理）："

#: ../../library/unittest.mock.rst:571
#, fuzzy
msgid "Using :attr:`side_effect` to return a sequence of values:"
msgstr "使用 :attr:`side_effect` 回傳值序列："

#: ../../library/unittest.mock.rst:578
#, fuzzy
msgid "Using a callable:"
msgstr "使用可呼叫物件："

#: ../../library/unittest.mock.rst:588
#, fuzzy
msgid ""
":attr:`side_effect` can be set in the constructor. Here's an example that "
"adds one to the value the mock is called with and returns it:"
msgstr ":attr:`side_effect` "
"可以在構造函式中設定。下面是一個示例，它將呼叫模擬的值加一併回傳它："

#: ../../library/unittest.mock.rst:598
#, fuzzy
msgid "Setting :attr:`side_effect` to ``None`` clears it:"
msgstr "將 :attr:`side_effect` 設定為 ``None`` 清除它："

#: ../../library/unittest.mock.rst:612
#, fuzzy
msgid ""
"This is either ``None`` (if the mock hasn't been called), or the arguments "
"that the mock was last called with. This will be in the form of a tuple: the "
"first member, which can also be accessed through the ``args`` property, is "
"any ordered arguments the mock was called with (or an empty tuple) and the "
"second member, which can also be accessed through the ``kwargs`` property, "
"is any keyword arguments (or an empty dictionary)."
msgstr ""
"這要么是 ``None`` （如果尚未呼叫模擬），要么是上次呼叫模擬時使用的參數。這將採用元"
"組的形式：第一個成員，也可以通過 ``args`` 屬性訪問，是呼叫 mock 的任何有序參"
"數（或空元組），第二個成員，可以也可以通過 ``kwargs``屬性訪問，是任何關鍵字參數"
"（或空字典）。"

#: ../../library/unittest.mock.rst:645
#, fuzzy
msgid ""
":attr:`call_args`, along with members of the lists :attr:`call_args_list`, :"
"attr:`method_calls` and :attr:`mock_calls` are :data:`call` objects. These "
"are tuples, so they can be unpacked to get at the individual arguments and "
"make more complex assertions. See :ref:`calls as tuples <calls-as-tuples>`."
msgstr ""
":attr:`call_args` 以及列表的成員 :attr:`call_args_list`、:attr:`method_calls` "
"和 :attr:`mock_calls` 是 :data:`call` "
"物件。這些是元組，因此可以將它們解包以獲取各個參數並做出更複雜的斷言。參見 "
":ref:`calls as tuples <calls-as-tuples>`。"

#: ../../library/unittest.mock.rst:651
msgid "Added ``args`` and ``kwargs`` properties."
msgstr "新增 ``args`` 與 ``kwargs`` 特性。"

#: ../../library/unittest.mock.rst:657
#, fuzzy
msgid ""
"This is a list of all the calls made to the mock object in sequence (so the "
"length of the list is the number of times it has been called). Before any "
"calls have been made it is an empty list. The :data:`call` object can be "
"used for conveniently constructing lists of calls to compare with :attr:"
"`call_args_list`."
msgstr ""
"這是按順序對模擬物件進行的所有呼叫的列表（因此列表的長度是它被呼叫的次數）。"
"在進行任何呼叫之前，它是一個空列表。 :data:`call` "
"物件可用於方便地構建呼叫列表以與 :attr:`call_args_list` 進行比較。"

#: ../../library/unittest.mock.rst:673
#, fuzzy
msgid ""
"Members of :attr:`call_args_list` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
":attr:`call_args_list` 的成員是 :data:`call` "
"物件。這些可以解包為元組以獲取各個參數。參見 :ref:`calls as tuples <calls-as-"
"tuples>`。"

#: ../../library/unittest.mock.rst:680
#, fuzzy
msgid ""
"As well as tracking calls to themselves, mocks also track calls to methods "
"and attributes, and *their* methods and attributes:"
msgstr "除了跟踪對自身的呼叫，模擬還跟踪對方法和屬性的呼叫，以及*它們的*方法和屬性："

#: ../../library/unittest.mock.rst:691
#, fuzzy
msgid ""
"Members of :attr:`method_calls` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
":attr:`method_calls` 的成員是 :data:`call` "
"物件。這些可以解包為元組以獲取各個參數。參見 :ref:`calls as tuples <calls-as-"
"tuples>`。"

#: ../../library/unittest.mock.rst:698
#, fuzzy
msgid ""
":attr:`mock_calls` records *all* calls to the mock object, its methods, "
"magic methods *and* return value mocks."
msgstr ":attr:`mock_calls` "
"記錄*所有*對模擬物件的呼叫、它的方法、魔術方法*和*回傳值模擬。"

#: ../../library/unittest.mock.rst:716
#, fuzzy
msgid ""
"Members of :attr:`mock_calls` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
":attr:`mock_calls` 的成員是 :data:`call` "
"物件。這些可以解包為元組以獲取各個參數。參見 :ref:`calls as tuples <calls-as-"
"tuples>`。"

#: ../../library/unittest.mock.rst:722
#, fuzzy
msgid ""
"The way :attr:`mock_calls` are recorded means that where nested calls are "
"made, the parameters of ancestor calls are not recorded and so will always "
"compare equal:"
msgstr ":attr:`mock_calls` 的記錄方式意味著在進行嵌套呼叫的地方，不記錄祖先呼叫的參數"
"，因此將始終比較相等："

#: ../../library/unittest.mock.rst:736
#, fuzzy
msgid ""
"Normally the :attr:`__class__` attribute of an object will return its type. "
"For a mock object with a :attr:`spec`, ``__class__`` returns the spec class "
"instead. This allows mock objects to pass :func:`isinstance` tests for the "
"object they are replacing / masquerading as:"
msgstr ""
"通常一個物件的 :attr:`__class__` 屬性會回傳它的型別。對於帶有 :attr:`spec` "
"的模擬物件，``__class__`` 回傳規範類。這允許模擬物件通過它們正在替換/"
"偽裝的物件的 isinstance 測試："

#: ../../library/unittest.mock.rst:745
#, fuzzy
msgid ""
":attr:`__class__` is assignable to, this allows a mock to pass an :func:"
"`isinstance` check without forcing you to use a spec:"
msgstr ":attr:`__class__` 可賦值給，這允許模擬通過 :func:`isinstance` "
"檢查而不強制您使用規範："

#: ../../library/unittest.mock.rst:755
#, fuzzy
msgid ""
"A non-callable version of :class:`Mock`. The constructor parameters have the "
"same meaning of :class:`Mock`, with the exception of *return_value* and "
"*side_effect* which have no meaning on a non-callable mock."
msgstr ""
":class:`Mock` 的不可呼叫版本。構造函式參數與 :class:`Mock` 具有相同的含義，"
"但 *return_value* 和 *side_effect* 除外，它們在不可呼叫的模擬中沒有意義。"

#: ../../library/unittest.mock.rst:759
#, fuzzy
msgid ""
"Mock objects that use a class or an instance as a :attr:`spec` or :attr:"
"`spec_set` are able to pass :func:`isinstance` tests:"
msgstr ""
"使用類或實例作為 :attr:`spec` 或 :attr:`spec_set` 的模擬物件能夠通過 "
":func:`isinstance` 測試："

#: ../../library/unittest.mock.rst:769
#, fuzzy
msgid ""
"The :class:`Mock` classes have support for mocking magic methods. See :ref:"
"`magic methods <magic-methods>` for the full details."
msgstr ""
":class:`Mock` 類支援模擬魔法方法。有關完整詳細資訊，請參閱 :ref:`magic "
"methods <magic-methods>`。"

#: ../../library/unittest.mock.rst:772
#, fuzzy
msgid ""
"The mock classes and the :func:`patch` decorators all take arbitrary keyword "
"arguments for configuration. For the :func:`patch` decorators the keywords "
"are passed to the constructor of the mock being created. The keyword "
"arguments are for configuring attributes of the mock:"
msgstr ""
"模擬類和 :func:`patch` 裝飾器都採用任意關鍵字參數進行配置。對於 :func:`patch`"
" 裝飾器，關鍵字被傳遞給正在建立的 mock "
"的構造函式。關鍵字參數用於配置模擬的屬性："

#: ../../library/unittest.mock.rst:783
#, fuzzy
msgid ""
"The return value and side effect of child mocks can be set in the same way, "
"using dotted notation. As you can't use dotted names directly in a call you "
"have to create a dictionary and unpack it using ``**``:"
msgstr ""
"子模擬的回傳值和副作用可以使用點分符號以相同的方式設定。由於您不能在呼叫中直"
"接使用帶點的名稱，因此您必須建立一個字典並使用 ``**`` 將其解壓縮："

#: ../../library/unittest.mock.rst:798
#, fuzzy
msgid ""
"A callable mock which was created with a *spec* (or a *spec_set*) will "
"introspect the specification object's signature when matching calls to the "
"mock.  Therefore, it can match the actual call's arguments regardless of "
"whether they were passed positionally or by name::"
msgstr ""
"使用 *spec*（或 *spec_set*）建立的可呼叫模擬將在匹配對模擬的呼叫時自省規範物"
"件的簽名。因此，它可以匹配實際呼叫的參數，無論它們是按位置傳遞還是按名稱傳遞:"
":"

#: ../../library/unittest.mock.rst:811
#, fuzzy
msgid ""
"This applies to :meth:`~Mock.assert_called_with`, :meth:`~Mock."
"assert_called_once_with`, :meth:`~Mock.assert_has_calls` and :meth:`~Mock."
"assert_any_call`.  When :ref:`auto-speccing`, it will also apply to method "
"calls on the mock object."
msgstr ""
"這適用於 :meth:`~Mock.assert_called_with`、:meth:`~Mock."
"assert_called_once_with`、:meth:`~Mock.assert_has_calls` 和 :meth:`~Mock."
"assert_any_call`。當 :ref:`auto-speccing` "
"時，它也將應用於模擬物件上的方法呼叫。"

#: ../../library/unittest.mock.rst:816
#, fuzzy
msgid "Added signature introspection on specced and autospecced mock objects."
msgstr "新增了對 specced 和 autospecced 模擬物件的簽名自省。"

#: ../../library/unittest.mock.rst:822
#, fuzzy
msgid ""
"A mock intended to be used as a property, or other descriptor, on a class. :"
"class:`PropertyMock` provides :meth:`__get__` and :meth:`__set__` methods so "
"you can specify a return value when it is fetched."
msgstr ""
"旨在用作類的屬性或其他描述器的模擬。 :class:`PropertyMock` 提供 "
":meth:`__get__` 和 :meth:`__set__` 方法，因此您可以在獲取時指定回傳值。"

#: ../../library/unittest.mock.rst:826
#, fuzzy
msgid ""
"Fetching a :class:`PropertyMock` instance from an object calls the mock, "
"with no args. Setting it calls the mock with the value being set. ::"
msgstr "從物件中獲取 PropertyMock "
"實例呼叫模擬，不帶參數。設定它會呼叫帶有設定值的模擬。 ::"

#: ../../library/unittest.mock.rst:847
#, fuzzy
msgid ""
"Because of the way mock attributes are stored you can't directly attach a :"
"class:`PropertyMock` to a mock object. Instead you can attach it to the mock "
"type object::"
msgstr "由於模擬屬性的儲存方式，您不能直接將 PropertyMock "
"附加到模擬物件。相反，您可以將它附加到模擬型別物件::"

#: ../../library/unittest.mock.rst:861
#, fuzzy
msgid ""
"An asynchronous version of :class:`MagicMock`. The :class:`AsyncMock` object "
"will behave so the object is recognized as an async function, and the result "
"of a call is an awaitable."
msgstr ""
":class:`MagicMock` 的非同步版本。 :class:`AsyncMock` "
"物件的行為將被識別為非同步函式，並且呼叫的結果是可等待的。"

#: ../../library/unittest.mock.rst:871
#, fuzzy
msgid ""
"The result of ``mock()`` is an async function which will have the outcome of "
"``side_effect`` or ``return_value`` after it has been awaited:"
msgstr "``mock()`` 的結果是一個非同步函式，在等待它之後會有 ``side_effect`` 或 "
"``return_value`` 的結果："

#: ../../library/unittest.mock.rst:874
#, fuzzy
msgid ""
"if ``side_effect`` is a function, the async function will return the result "
"of that function,"
msgstr "如果 ``side_effect`` 是一個函式，非同步函式將回傳該函式的結果，"

#: ../../library/unittest.mock.rst:876
#, fuzzy
msgid ""
"if ``side_effect`` is an exception, the async function will raise the "
"exception,"
msgstr "如果 ``side_effect`` 是例外，則非同步函式將引發例外，"

#: ../../library/unittest.mock.rst:878
#, fuzzy
msgid ""
"if ``side_effect`` is an iterable, the async function will return the next "
"value of the iterable, however, if the sequence of result is exhausted, "
"``StopAsyncIteration`` is raised immediately,"
msgstr ""
"如果 ``side_effect`` 是一個可疊代物件，非同步函式將回傳可疊代物件的下一個值，"
"但是，如果結果序列已用完，則立即引發 ``StopAsyncIteration``，"

#: ../../library/unittest.mock.rst:881
#, fuzzy
msgid ""
"if ``side_effect`` is not defined, the async function will return the value "
"defined by ``return_value``, hence, by default, the async function returns a "
"new :class:`AsyncMock` object."
msgstr ""
"如果沒有定義 side_effect ，非同步函式將回傳由 return_value "
"定義的值，因此，預設情況下，非同步函式回傳一個新的 AsyncMock 物件。"

#: ../../library/unittest.mock.rst:886
#, fuzzy
msgid ""
"Setting the *spec* of a :class:`Mock` or :class:`MagicMock` to an async "
"function will result in a coroutine object being returned after calling."
msgstr "將 :class:`Mock` 或 :class:`MagicMock` 的 *spec* "
"設定為非同步函式將導致在呼叫後回傳協程物件。"

#: ../../library/unittest.mock.rst:898
#, fuzzy
msgid ""
"Setting the *spec* of a :class:`Mock`, :class:`MagicMock`, or :class:"
"`AsyncMock` to a class with asynchronous and synchronous functions will "
"automatically detect the synchronous functions and set them as :class:"
"`MagicMock` (if the parent mock is :class:`AsyncMock` or :class:`MagicMock`) "
"or :class:`Mock` (if the parent mock is :class:`Mock`). All asynchronous "
"functions will be :class:`AsyncMock`."
msgstr ""
"將 :class:`Mock`、:class:`MagicMock` 或 :class:`AsyncMock` 的 *spec* "
"設定為具有非同步和同步功能的類將自動檢測同步功能並將它們設定為 :class:` "
"MagicMock`（如果父 mock 是 :class:`AsyncMock` "
"或 :class:`MagicMock`）或 :class:`Mock`（如果父 mock "
"是 :class:`Mock`）。所有非同步函式都將是 :class:`AsyncMock`。"

#: ../../library/unittest.mock.rst:926
#, fuzzy
msgid ""
"Assert that the mock was awaited at least once. Note that this is separate "
"from the object having been called, the ``await`` keyword must be used:"
msgstr "斷言至少等待了一次模擬。請注意，這與被呼叫的物件是分開的，必須使用 ``await`` "
"關鍵字："

#: ../../library/unittest.mock.rst:945
#, fuzzy
msgid "Assert that the mock was awaited exactly once."
msgstr "斷言 mock 只等待了一次。"

#: ../../library/unittest.mock.rst:961
#, fuzzy
msgid "Assert that the last await was with the specified arguments."
msgstr "斷言最後一個 await 是帶有指定參數的。"

#: ../../library/unittest.mock.rst:978
#, fuzzy
msgid ""
"Assert that the mock was awaited exactly once and with the specified "
"arguments."
msgstr "斷言模擬只被等待一次並帶有指定的參數。"

#: ../../library/unittest.mock.rst:995
#, fuzzy
msgid "Assert the mock has ever been awaited with the specified arguments."
msgstr "斷言曾經用指定的參數等待模擬。"

#: ../../library/unittest.mock.rst:1011
#, fuzzy
msgid ""
"Assert the mock has been awaited with the specified calls. The :attr:"
"`await_args_list` list is checked for the awaits."
msgstr "斷言已通過指定的呼叫等待模擬。 :attr:`await_args_list` 列表被檢查等待。"

#: ../../library/unittest.mock.rst:1014
#, fuzzy
msgid ""
"If *any_order* is false then the awaits must be sequential. There can be "
"extra calls before or after the specified awaits."
msgstr "如果 *any_order* "
"為假，則等待必須是連續的。在指定的等待之前或之後可以有額外的呼叫。"

#: ../../library/unittest.mock.rst:1018
#, fuzzy
msgid ""
"If *any_order* is true then the awaits can be in any order, but they must "
"all appear in :attr:`await_args_list`."
msgstr "如果 *any_order* 為真，則等待可以按任何順序進行，但它們必須全部出現在 "
":attr:`await_args_list` 中。"

#: ../../library/unittest.mock.rst:1038
#, fuzzy
msgid "Assert that the mock was never awaited."
msgstr "斷言從未等待模擬。"

#: ../../library/unittest.mock.rst:1045
#, fuzzy
msgid ""
"See :func:`Mock.reset_mock`. Also sets :attr:`await_count` to 0, :attr:"
"`await_args` to None, and clears the :attr:`await_args_list`."
msgstr ""
"請參閱 :func:`Mock.reset_mock`。還將 :attr:`await_count` 設定為 0，將 "
":attr:`await_args` 設定為 None，並清除 :attr:`await_args_list`。"

#: ../../library/unittest.mock.rst:1050
#, fuzzy
msgid ""
"An integer keeping track of how many times the mock object has been awaited."
msgstr "一個整數，用於跟踪模擬物件已等待的次數。"

#: ../../library/unittest.mock.rst:1065
#, fuzzy
msgid ""
"This is either ``None`` (if the mock hasn’t been awaited), or the arguments "
"that the mock was last awaited with. Functions the same as :attr:`Mock."
"call_args`."
msgstr "這要么是 ``None`` （如果還沒有等待模擬），要么是最後一次等待模擬的參數。功能與 "
"Mock.call_args 相同。"

#: ../../library/unittest.mock.rst:1083
#, fuzzy
msgid ""
"This is a list of all the awaits made to the mock object in sequence (so the "
"length of the list is the number of times it has been awaited). Before any "
"awaits have been made it is an empty list."
msgstr "這是按順序對模擬物件進行的所有等待的列表（因此列表的長度是等待它的次數）。在"
"進行任何等待之前，它是一個空列表。"

#: ../../library/unittest.mock.rst:1102
#, fuzzy
msgid "Calling"
msgstr "呼喚"

#: ../../library/unittest.mock.rst:1104
#, fuzzy
msgid ""
"Mock objects are callable. The call will return the value set as the :attr:"
"`~Mock.return_value` attribute. The default return value is a new Mock "
"object; it is created the first time the return value is accessed (either "
"explicitly or by calling the Mock) - but it is stored and the same one "
"returned each time."
msgstr ""
"模擬物件是可呼叫的。該呼叫將回傳設定為 :attr:`~Mock.return_value` 屬性的值。"
"預設回傳值是一個新的 Mock 物件；它是在第一次訪問回傳值時建立的（"
"顯式地或通過呼叫 Mock）——但它被儲存並且每次都回傳相同的值。"

#: ../../library/unittest.mock.rst:1110
#, fuzzy
msgid ""
"Calls made to the object will be recorded in the attributes like :attr:"
"`~Mock.call_args` and :attr:`~Mock.call_args_list`."
msgstr "對物件的呼叫將記錄在屬性中，例如 :attr:`~Mock.call_args` 和 :attr:`~Mock."
"call_args_list`。"

#: ../../library/unittest.mock.rst:1113
#, fuzzy
msgid ""
"If :attr:`~Mock.side_effect` is set then it will be called after the call "
"has been recorded, so if :attr:`side_effect` raises an exception the call is "
"still recorded."
msgstr ""
"如果 :attr:`~Mock.side_effect` 被設定，那麼它將在呼叫被記錄後被呼叫，"
"所以如果 :attr:`side_effect` 引發例外，呼叫仍然被記錄。"

#: ../../library/unittest.mock.rst:1117
#, fuzzy
msgid ""
"The simplest way to make a mock raise an exception when called is to make :"
"attr:`~Mock.side_effect` an exception class or instance:"
msgstr "使 mock 在呼叫時引發例外的最簡單方法是使 :attr:`~Mock.side_effect` "
"成為例外類或實例："

#: ../../library/unittest.mock.rst:1135
#, fuzzy
msgid ""
"If :attr:`side_effect` is a function then whatever that function returns is "
"what calls to the mock return. The :attr:`side_effect` function is called "
"with the same arguments as the mock. This allows you to vary the return "
"value of the call dynamically, based on the input:"
msgstr ""
"如果 :attr:`side_effect` "
"是一個函式，那麼無論該函式回傳什麼，都是對模擬回傳的呼叫。 "
":attr:`side_effect` "
"函式使用與模擬相同的參數呼叫。這允許您根據輸入動態地改變呼叫的回傳值："

#: ../../library/unittest.mock.rst:1151
#, fuzzy
msgid ""
"If you want the mock to still return the default return value (a new mock), "
"or any set return value, then there are two ways of doing this. Either "
"return :attr:`mock.return_value` from inside :attr:`side_effect`, or return :"
"data:`DEFAULT`:"
msgstr ""
"如果您希望模擬仍然回傳預設回傳值（新模擬）或任何設定的回傳值，那麼有兩種方法"
"可以做到這一點。從 side_effect 內部回傳 :attr:`mock.return_value`，或者回傳 "
":data:`DEFAULT`："

#: ../../library/unittest.mock.rst:1170
#, fuzzy
msgid ""
"To remove a :attr:`side_effect`, and return to the default behaviour, set "
"the :attr:`side_effect` to ``None``:"
msgstr "要刪除 :attr:`side_effect` 並回傳預設行為，請將 :attr:`side_effect` 設定為 "
"``None``："

#: ../../library/unittest.mock.rst:1184
#, fuzzy
msgid ""
"The :attr:`side_effect` can also be any iterable object. Repeated calls to "
"the mock will return values from the iterable (until the iterable is "
"exhausted and a :exc:`StopIteration` is raised):"
msgstr ""
":attr:`side_effect` 也可以是任何可疊代物件。重複呼叫 mock 將從 iterable "
"回傳值（直到 iterable 耗盡並引發 :exc:`StopIteration`）："

#: ../../library/unittest.mock.rst:1200
#, fuzzy
msgid ""
"If any members of the iterable are exceptions they will be raised instead of "
"returned::"
msgstr "如果 iterable 的任何成員是例外，它們將被引發而不是回傳::"

#: ../../library/unittest.mock.rst:1218
#, fuzzy
msgid "Deleting Attributes"
msgstr "刪除屬性"

#: ../../library/unittest.mock.rst:1220
#, fuzzy
msgid ""
"Mock objects create attributes on demand. This allows them to pretend to be "
"objects of any type."
msgstr "模擬物件按需建立屬性。這使他們可以偽裝成任何型別的物件。"

#: ../../library/unittest.mock.rst:1223
#, fuzzy
msgid ""
"You may want a mock object to return ``False`` to a :func:`hasattr` call, or "
"raise an :exc:`AttributeError` when an attribute is fetched. You can do this "
"by providing an object as a :attr:`spec` for a mock, but that isn't always "
"convenient."
msgstr ""
"您可能希望模擬物件向 :func:`hasattr` 呼叫回傳 ``False``，"
"或者在獲取屬性時引發 :exc:`AttributeError`。您可以通過提供一個物件作為模擬的 "
":attr:`spec` 來做到這一點，但這並不總是很方便。"

#: ../../library/unittest.mock.rst:1227
#, fuzzy
msgid ""
"You \"block\" attributes by deleting them. Once deleted, accessing an "
"attribute will raise an :exc:`AttributeError`."
msgstr "您可以通過刪除屬性來“阻止”它們。刪除後，訪問屬性將引發 "
":exc:`AttributeError`。"

#: ../../library/unittest.mock.rst:1244
#, fuzzy
msgid "Mock names and the name attribute"
msgstr "模擬名稱和名稱屬性"

#: ../../library/unittest.mock.rst:1246
#, fuzzy
msgid ""
"Since \"name\" is an argument to the :class:`Mock` constructor, if you want "
"your mock object to have a \"name\" attribute you can't just pass it in at "
"creation time. There are two alternatives. One option is to use :meth:`~Mock."
"configure_mock`::"
msgstr ""
"由於 ``name``是 :class:`Mock` 構造函式的參數，如果您希望模擬物件具有 ``name``屬性，"
"則不能只在建立時傳入它。有兩種選擇。一種選擇是使用 :meth:`~Mock."
"configure_mock`::"

#: ../../library/unittest.mock.rst:1256
#, fuzzy
msgid ""
"A simpler option is to simply set the \"name\" attribute after mock "
"creation::"
msgstr "一個更簡單的選擇是在模擬建立後簡單地設定 ``name``屬性："

#: ../../library/unittest.mock.rst:1263
#, fuzzy
msgid "Attaching Mocks as Attributes"
msgstr "附加模擬作為屬性"

#: ../../library/unittest.mock.rst:1265
#, fuzzy
msgid ""
"When you attach a mock as an attribute of another mock (or as the return "
"value) it becomes a \"child\" of that mock. Calls to the child are recorded "
"in the :attr:`~Mock.method_calls` and :attr:`~Mock.mock_calls` attributes of "
"the parent. This is useful for configuring child mocks and then attaching "
"them to the parent, or for attaching mocks to a parent that records all "
"calls to the children and allows you to make assertions about the order of "
"calls between mocks:"
msgstr ""
"當您將模擬附加為另一個模擬的屬性（或作為回傳值）時，它成為該模擬的“孩子”。"
"對子行程的呼叫記錄在父行程的 :attr:`~Mock.method_calls` 和 :attr:`~Mock."
"mock_calls` 屬性中。這對於配置子 mocks 然後將它們附加到父級，或者將 mocks "
"附加到記錄對子級的所有呼叫並允許您對 mocks "
"之間的呼叫順序進行斷言的父級很有用："

#: ../../library/unittest.mock.rst:1283
#, fuzzy
msgid ""
"The exception to this is if the mock has a name. This allows you to prevent "
"the \"parenting\" if for some reason you don't want it to happen."
msgstr "例外情況是模擬有名稱。如果出於某種原因您不希望它發生，這可以讓您阻止“育兒”。"

#: ../../library/unittest.mock.rst:1294
#, fuzzy
msgid ""
"Mocks created for you by :func:`patch` are automatically given names. To "
"attach mocks that have names to a parent you use the :meth:`~Mock."
"attach_mock` method::"
msgstr ""
":func:`patch` 為您建立的模擬會自動命名。要將具有名稱的模擬附加到父物件，"
"您可以使用 :meth:`~Mock.attach_mock` 方法::"

#: ../../library/unittest.mock.rst:1312
#, fuzzy
msgid ""
"The only exceptions are magic methods and attributes (those that have "
"leading and trailing double underscores). Mock doesn't create these but "
"instead raises an :exc:`AttributeError`. This is because the interpreter "
"will often implicitly request these methods, and gets *very* confused to get "
"a new Mock object when it expects a magic method. If you need magic method "
"support see :ref:`magic methods <magic-methods>`."
msgstr ""
"唯一的例外是魔術方法和屬性（具有前導和尾隨雙底線的那些）。 Mock "
"不會建立這些，而是會引發 :exc:`AttributeError`。這是因為直譯器通常會隱式地請"
"求這些方法，並且在它期望一個魔術方法時*非常*困惑地獲取一個新的 Mock "
"物件。如果您需要魔術方法支援，請參閱 :ref:`魔術方法 <magic-methods>`。"

#: ../../library/unittest.mock.rst:1321
#, fuzzy
msgid "The patchers"
msgstr "修補程式"

#: ../../library/unittest.mock.rst:1323
#, fuzzy
msgid ""
"The patch decorators are used for patching objects only within the scope of "
"the function they decorate. They automatically handle the unpatching for "
"you, even if exceptions are raised. All of these functions can also be used "
"in with statements or as class decorators."
msgstr ""
"補丁裝飾器僅用於在它們裝飾的函式範圍內修補物件。即使出現例外，它們也會自動為"
"您處理未打補丁的工作。所有這些函式也可以用在 with 語句中或用作類裝飾器。"

#: ../../library/unittest.mock.rst:1330
#, fuzzy
msgid "patch"
msgstr "修補"

#: ../../library/unittest.mock.rst:1334
#, fuzzy
msgid ""
"The key is to do the patching in the right namespace. See the section `where "
"to patch`_."
msgstr "關鍵是在正確的命名空間中進行修補。請參閱“在哪裡打補丁”部分。"

#: ../../library/unittest.mock.rst:1338
#, fuzzy
msgid ""
":func:`patch` acts as a function decorator, class decorator or a context "
"manager. Inside the body of the function or with statement, the *target* is "
"patched with a *new* object. When the function/with statement exits the "
"patch is undone."
msgstr ""
":func:`patch` 充當函式裝飾器、類裝飾器或上下文管理器。在函式體或 with "
"語句中，*target* 用 *new* 物件修補。當 function/with 語句退出時，補丁被撤銷。"

#: ../../library/unittest.mock.rst:1343
#, fuzzy
msgid ""
"If *new* is omitted, then the target is replaced with an :class:`AsyncMock` "
"if the patched object is an async function or a :class:`MagicMock` "
"otherwise. If :func:`patch` is used as a decorator and *new* is omitted, the "
"created mock is passed in as an extra argument to the decorated function. "
"If :func:`patch` is used as a context manager the created mock is returned "
"by the context manager."
msgstr ""
"如果省略 *new*，則如果修補物件是非同步函式，目標將替換為 AsyncMock，"
"否則替換為 MagicMock。如果 :func:`patch` 被用作裝飾器並且 *new* 被省略，"
"建立的 mock 將作為額外參數傳遞給裝飾函式。如果 :func:`patch` "
"被用作上下文管理器，建立的模擬將由上下文管理器回傳。"

#: ../../library/unittest.mock.rst:1351
#, fuzzy
msgid ""
"*target* should be a string in the form ``'package.module.ClassName'``. The "
"*target* is imported and the specified object replaced with the *new* "
"object, so the *target* must be importable from the environment you are "
"calling :func:`patch` from. The target is imported when the decorated "
"function is executed, not at decoration time."
msgstr ""
"*target* 應該是 ``'package.module.ClassName'`` 形式的字串。 *target* "
"被導入並且指定的物件替換為 *new* 物件，因此 *target* 必須可以從您呼叫 "
":func:`patch` 的環境中導入。目標是在執行裝飾函式時導入的，而不是在裝飾時。"

#: ../../library/unittest.mock.rst:1357
#, fuzzy
msgid ""
"The *spec* and *spec_set* keyword arguments are passed to the :class:"
"`MagicMock` if patch is creating one for you."
msgstr "*spec* 和 *spec_set* 關鍵字參數被傳遞給 :class:`MagicMock` 如果 patch "
"正在為你建立一個。"

#: ../../library/unittest.mock.rst:1360
#, fuzzy
msgid ""
"In addition you can pass ``spec=True`` or ``spec_set=True``, which causes "
"patch to pass in the object being mocked as the spec/spec_set object."
msgstr ""
"此外，您可以傳遞 ``spec=True`` 或 ``spec_set=True``，這會導致 patch "
"將被模擬的物件作為 spec/spec_set 物件傳遞。"

#: ../../library/unittest.mock.rst:1363
#, fuzzy
msgid ""
"*new_callable* allows you to specify a different class, or callable object, "
"that will be called to create the *new* object. By default :class:"
"`AsyncMock` is used for async functions and :class:`MagicMock` for the rest."
msgstr ""
"*new_callable* 允許您指定一個不同的類或可呼叫物件，它將被呼叫以建立 *new* "
"物件。預設情況下 :class:`AsyncMock` 用於非同步函式，而 :class:`MagicMock` "
"用於其餘部分。"

#: ../../library/unittest.mock.rst:1367
#, fuzzy
msgid ""
"A more powerful form of *spec* is *autospec*. If you set ``autospec=True`` "
"then the mock will be created with a spec from the object being replaced. "
"All attributes of the mock will also have the spec of the corresponding "
"attribute of the object being replaced. Methods and functions being mocked "
"will have their arguments checked and will raise a :exc:`TypeError` if they "
"are called with the wrong signature. For mocks replacing a class, their "
"return value (the 'instance') will have the same spec as the class. See the :"
"func:`create_autospec` function and :ref:`auto-speccing`."
msgstr ""
"*spec* 的一種更強大的形式是 *autospec*。如果您設定 ``autospec=True`` 那麼模擬"
"將使用來自被替換物件的規範建立。模擬的所有屬性也將具有被替換物件的相應屬性的"
"規範。被模擬的方法和函式將檢查其參數，如果使用錯誤的簽名呼叫它們，將引發 :exc"
":`TypeError`。對於替換類的模擬，它們的回傳值（“實例”）將具有與類相同的規範。"
"請參閱 :func:`create_autospec` 函式和 :ref:`auto-speccing`。"

#: ../../library/unittest.mock.rst:1377
#, fuzzy
msgid ""
"Instead of ``autospec=True`` you can pass ``autospec=some_object`` to use an "
"arbitrary object as the spec instead of the one being replaced."
msgstr ""
"您可以傳遞 ``autospec=some_object`` 而不是 ``autospec=True`` "
"以使用任意物件作為規範而不是被替換的物件。"

#: ../../library/unittest.mock.rst:1380
#, fuzzy
msgid ""
"By default :func:`patch` will fail to replace attributes that don't exist. "
"If you pass in ``create=True``, and the attribute doesn't exist, patch will "
"create the attribute for you when the patched function is called, and delete "
"it again after the patched function has exited. This is useful for writing "
"tests against attributes that your production code creates at runtime. It is "
"off by default because it can be dangerous. With it switched on you can "
"write passing tests against APIs that don't actually exist!"
msgstr ""
"預設情況下 :func:`patch` 將無法替換不存在的屬性。如果你傳入 "
"``create=True``，並且該屬性不存在，patch 會在呼叫補丁函式時為您建立該屬性，並"
"在補丁函式退出後再次刪除它。這對於針對您的生產程式碼在運行時建立的屬性編寫測"
"試很有用。預設情況下它是關閉的，因為它可能很危險。啟用它後，"
"您可以針對實際上不存在的 API 編寫通過測試！"

#: ../../library/unittest.mock.rst:1390
#, fuzzy
msgid ""
"If you are patching builtins in a module then you don't need to pass "
"``create=True``, it will be added by default."
msgstr "如果你正在修補模組中的內建函式，那麼你不需要傳遞 "
"``create=True``，它會預設新增。"

#: ../../library/unittest.mock.rst:1394
#, fuzzy
msgid ""
"Patch can be used as a :class:`TestCase` class decorator. It works by "
"decorating each test method in the class. This reduces the boilerplate code "
"when your test methods share a common patchings set. :func:`patch` finds "
"tests by looking for method names that start with ``patch.TEST_PREFIX``. By "
"default this is ``'test'``, which matches the way :mod:`unittest` finds "
"tests. You can specify an alternative prefix by setting ``patch."
"TEST_PREFIX``."
msgstr ""
"補丁可以用作 :class:`TestCase` 類裝飾器。它通過裝飾類中的每個測試方法來工作。"
"當您的測試方法共享一個公開補丁集時，這會減少樣板程式碼。 :func:`patch` "
"通過查找以 ``patch.TEST_PREFIX`` 開頭的方法名稱來查找測試。預設情況下，這是 "
"``'test'``，它匹配 unittest 查找測試的方式。您可以通過設定 patch.TEST_PREFIX "
"來指定替代前綴。"

#: ../../library/unittest.mock.rst:1401
#, fuzzy
msgid ""
"Patch can be used as a context manager, with the with statement. Here the "
"patching applies to the indented block after the with statement. If you use "
"\"as\" then the patched object will be bound to the name after the \"as\"; "
"very useful if :func:`patch` is creating a mock object for you."
msgstr ""
"補丁可以用作上下文管理器，使用 with 語句。這裡的補丁適用於 with "
"語句之後的縮進塊。如果您使用 ``as``，那麼修補後的物件將綁定到 ``as``之後的名稱；"
"如果 :func:`patch` 正在為您建立模擬物件，則非常有用。"

#: ../../library/unittest.mock.rst:1406
#, fuzzy
msgid ""
":func:`patch` takes arbitrary keyword arguments. These will be passed to :"
"class:`AsyncMock` if the patched object is asynchronous, to :class:"
"`MagicMock` otherwise or to *new_callable* if specified."
msgstr ""
":func:`patch` 採用任意關鍵字參數。如果打補丁的物件是非同步的，這些將被傳遞給 "
":class:`AsyncMock`，否則傳遞給 :class:`MagicMock`，或者如果指定則傳遞給 "
"*new_callable*。"

#: ../../library/unittest.mock.rst:1410
#, fuzzy
msgid ""
"``patch.dict(...)``, ``patch.multiple(...)`` and ``patch.object(...)`` are "
"available for alternate use-cases."
msgstr ""
"``patch.dict(...)``、``patch.multiple(...)`` 和 ``patch.object(...)`` "
"可用於替代用例。"

#: ../../library/unittest.mock.rst:1413
#, fuzzy
msgid ""
":func:`patch` as function decorator, creating the mock for you and passing "
"it into the decorated function::"
msgstr ":func:`patch` 作為函式裝飾器，為您建立模擬並將其傳遞給裝飾函式::"

#: ../../library/unittest.mock.rst:1423
#, fuzzy
msgid ""
"Patching a class replaces the class with a :class:`MagicMock` *instance*. If "
"the class is instantiated in the code under test then it will be the :attr:"
"`~Mock.return_value` of the mock that will be used."
msgstr ""
"給類打補丁會用 :class:`MagicMock` *實例* "
"替換該類。如果該類在被測程式碼中實例化，那麼將使用模擬的 :attr:`~Mock."
"return_value`。"

#: ../../library/unittest.mock.rst:1427
#, fuzzy
msgid ""
"If the class is instantiated multiple times you could use :attr:`~Mock."
"side_effect` to return a new mock each time. Alternatively you can set the "
"*return_value* to be anything you want."
msgstr ""
"如果該類被多次實例化，您可以使用 :attr:`~Mock.side_effect` "
"每次都回傳一個新的模擬。或者，您可以將 *return_value* 設定為您想要的任何值。"

#: ../../library/unittest.mock.rst:1431
#, fuzzy
msgid ""
"To configure return values on methods of *instances* on the patched class "
"you must do this on the :attr:`return_value`. For example::"
msgstr "要在修補類的 *instances* 方法上配置回傳值，您必須在 :attr:`return_value` "
"上執行此操作。例如：："

#: ../../library/unittest.mock.rst:1445
#, fuzzy
msgid ""
"If you use *spec* or *spec_set* and :func:`patch` is replacing a *class*, "
"then the return value of the created mock will have the same spec. ::"
msgstr ""
"如果您使用 *spec* 或 *spec_set* 並且 :func:`patch` 正在替換 *class*，"
"那麼建立的 mock 的回傳值將具有相同的規範。 ::"

#: ../../library/unittest.mock.rst:1455
#, fuzzy
msgid ""
"The *new_callable* argument is useful where you want to use an alternative "
"class to the default :class:`MagicMock` for the created mock. For example, "
"if you wanted a :class:`NonCallableMock` to be used::"
msgstr "*new_callable* 參數在您想使用預設類的替代類來建立模擬時很有用。例如，"
"如果你想使用 NonCallableMock::"

#: ../../library/unittest.mock.rst:1468
#, fuzzy
msgid ""
"Another use case might be to replace an object with an :class:`io.StringIO` "
"instance::"
msgstr "另一個用例可能是用 io.StringIO 實例替換物件："

#: ../../library/unittest.mock.rst:1481
#, fuzzy
msgid ""
"When :func:`patch` is creating a mock for you, it is common that the first "
"thing you need to do is to configure the mock. Some of that configuration "
"can be done in the call to patch. Any arbitrary keywords you pass into the "
"call will be used to set attributes on the created mock::"
msgstr ""
"當 :func:`patch` 為您建立模擬時，通常您需要做的第一件事就是配置模擬。"
"一些配置可以在呼叫 patch 時完成。您傳遞給呼叫的任意關鍵字都將用於在建立的 "
"mock:: 上設定屬性"

#: ../../library/unittest.mock.rst:1493
#, fuzzy
msgid ""
"As well as attributes on the created mock attributes, like the :attr:`~Mock."
"return_value` and :attr:`~Mock.side_effect`, of child mocks can also be "
"configured. These aren't syntactically valid to pass in directly as keyword "
"arguments, but a dictionary with these as keys can still be expanded into a :"
"func:`patch` call using ``**``::"
msgstr ""
"以及建立的模擬屬性的屬性，如 :attr:`~Mock.return_value` 和 :attr:`~Mock."
"side_effect`，也可以配置子模擬。這些在語法上不能直接作為關鍵字參數直接傳遞，"
"但仍然可以使用 ``**`` 將以這些作為鍵的字典擴充為 :func:`patch` 呼叫："

#: ../../library/unittest.mock.rst:1509
#, fuzzy
msgid ""
"By default, attempting to patch a function in a module (or a method or an "
"attribute in a class) that does not exist will fail with :exc:"
"`AttributeError`::"
msgstr "預設情況下，嘗試修補不存在的模組中的函式（或類中的方法或屬性）將失敗並顯示 "
":exc:`AttributeError`::"

#: ../../library/unittest.mock.rst:1521
#, fuzzy
msgid ""
"but adding ``create=True`` in the call to :func:`patch` will make the "
"previous example work as expected::"
msgstr "但是在對 :func:`patch` 的呼叫中新增 ``create=True`` "
"將使前面的示例按預期工作::"

#: ../../library/unittest.mock.rst:1532
#, fuzzy
msgid ""
":func:`patch` now returns an :class:`AsyncMock` if the target is an async "
"function."
msgstr ":func:`patch` 現在回傳一個 :class:`AsyncMock` 如果目標是一個非同步函式。"

#: ../../library/unittest.mock.rst:1536
msgid "patch.object"
msgstr "patch.object"

#: ../../library/unittest.mock.rst:1540
#, fuzzy
msgid ""
"patch the named member (*attribute*) on an object (*target*) with a mock "
"object."
msgstr "使用模擬物件在物件 (*target*) 上修補命名成員 (*attribute*)。"

#: ../../library/unittest.mock.rst:1543
#, fuzzy
msgid ""
":func:`patch.object` can be used as a decorator, class decorator or a "
"context manager. Arguments *new*, *spec*, *create*, *spec_set*, *autospec* "
"and *new_callable* have the same meaning as for :func:`patch`. Like :func:"
"`patch`, :func:`patch.object` takes arbitrary keyword arguments for "
"configuring the mock object it creates."
msgstr ""
":func:`patch.object` 可以用作裝飾器、類裝飾器或上下文管理器。參數 "
"*new*、*spec*、*create*、*spec_set*、*autospec* 和 *new_callable* 與 "
":func:`patch` 的含義相同。像 :func:`patch` 一樣，:func:`patch.object` "
"採用任意關鍵字參數來配置它建立的模擬物件。"

#: ../../library/unittest.mock.rst:1549
#, fuzzy
msgid ""
"When used as a class decorator :func:`patch.object` honours ``patch."
"TEST_PREFIX`` for choosing which methods to wrap."
msgstr "當用作類裝飾器時 :func:`patch.object` 尊重 ``patch.TEST_PREFIX`` "
"來選擇要包裝的方法。"

#: ../../library/unittest.mock.rst:1552
#, fuzzy
msgid ""
"You can either call :func:`patch.object` with three arguments or two "
"arguments. The three argument form takes the object to be patched, the "
"attribute name and the object to replace the attribute with."
msgstr "您可以使用三個參數或兩個參數呼叫 :func:`patch."
"object`。三參數形式採用要修補的物件、屬性名稱和替換屬性的物件。"

#: ../../library/unittest.mock.rst:1556
#, fuzzy
msgid ""
"When calling with the two argument form you omit the replacement object, and "
"a mock is created for you and passed in as an extra argument to the "
"decorated function:"
msgstr "當使用兩個參數形式呼叫時，您將省略替換物件，並為您建立一個模擬並將其作為額外"
"參數傳遞給裝飾函式："

#: ../../library/unittest.mock.rst:1567
#, fuzzy
msgid ""
"*spec*, *create* and the other arguments to :func:`patch.object` have the "
"same meaning as they do for :func:`patch`."
msgstr "*spec*、*create* 和 :func:`patch.object` 的其他參數與 :func:`patch` "
"的含義相同。"

#: ../../library/unittest.mock.rst:1572
msgid "patch.dict"
msgstr "patch.dict"

#: ../../library/unittest.mock.rst:1576
#, fuzzy
msgid ""
"Patch a dictionary, or dictionary like object, and restore the dictionary to "
"its original state after the test."
msgstr "修補字典，或類似字典的物件，並在測試後將字典恢復到其原始狀態。"

#: ../../library/unittest.mock.rst:1579
#, fuzzy
msgid ""
"*in_dict* can be a dictionary or a mapping like container. If it is a "
"mapping then it must at least support getting, setting and deleting items "
"plus iterating over keys."
msgstr "*in_dict* 可以是字典或類似容器的映射。如果它是一個映射，那麼它必須至少支援獲"
"取、設定和刪除項目以及遍歷鍵。"

#: ../../library/unittest.mock.rst:1583
#, fuzzy
msgid ""
"*in_dict* can also be a string specifying the name of the dictionary, which "
"will then be fetched by importing it."
msgstr "*in_dict* 也可以是一個字串，指定字典的名稱，然後通過導入它來獲取。"

#: ../../library/unittest.mock.rst:1586
#, fuzzy
msgid ""
"*values* can be a dictionary of values to set in the dictionary. *values* "
"can also be an iterable of ``(key, value)`` pairs."
msgstr "*values* 可以是要在字典中設定的值的字典。 *values* 也可以是 ``(key, value)`` "
"對的可疊代。"

#: ../../library/unittest.mock.rst:1589
#, fuzzy
msgid ""
"If *clear* is true then the dictionary will be cleared before the new values "
"are set."
msgstr "如果 *clear* 為真，則在設定新值之前將清除字典。"

#: ../../library/unittest.mock.rst:1592
#, fuzzy
msgid ""
":func:`patch.dict` can also be called with arbitrary keyword arguments to "
"set values in the dictionary."
msgstr ":func:`patch.dict` 也可以使用任意關鍵字參數呼叫以在字典中設定值。"

#: ../../library/unittest.mock.rst:1597
#, fuzzy
msgid ""
":func:`patch.dict` now returns the patched dictionary when used as a context "
"manager."
msgstr ":func:`patch.dict` 現在在用作上下文管理器時回傳修補後的字典。"

#: ../../library/unittest.mock.rst:1600
#, fuzzy
msgid ""
":func:`patch.dict` can be used as a context manager, decorator or class "
"decorator:"
msgstr ":func:`patch.dict` 可以用作上下文管理器、裝飾器或類裝飾器："

#: ../../library/unittest.mock.rst:1610
#, fuzzy
msgid ""
"When used as a class decorator :func:`patch.dict` honours ``patch."
"TEST_PREFIX`` (default to ``'test'``) for choosing which methods to wrap:"
msgstr ""
"當用作類裝飾器時 :func:`patch.dict` 榮譽``patch."
"TEST_PREFIX``（預設為 ``'test'`` ）來選擇要包裝的方法："

#: ../../library/unittest.mock.rst:1621
#, fuzzy
msgid ""
"If you want to use a different prefix for your test, you can inform the "
"patchers of the different prefix by setting ``patch.TEST_PREFIX``. For more "
"details about how to change the value of see :ref:`test-prefix`."
msgstr ""
"如果你想為你的測試使用不同的前綴，你可以通過設定 ``patch.TEST_PREFIX`` "
"通知補丁程式不同的前綴。有關如何更改值的更多詳細資訊，請參閱 :ref:`test-"
"prefix`。"

#: ../../library/unittest.mock.rst:1625
#, fuzzy
msgid ""
":func:`patch.dict` can be used to add members to a dictionary, or simply let "
"a test change a dictionary, and ensure the dictionary is restored when the "
"test ends."
msgstr ":func:`patch.dict` "
"可用於向字典新增成員，或者簡單地讓測試更改字典，並確保在測試結束時恢復字典。"

#: ../../library/unittest.mock.rst:1646
#, fuzzy
msgid ""
"Keywords can be used in the :func:`patch.dict` call to set values in the "
"dictionary:"
msgstr "可以在 patch.dict 呼叫中使用關鍵字來設定字典中的值："

#: ../../library/unittest.mock.rst:1656
#, fuzzy
msgid ""
":func:`patch.dict` can be used with dictionary like objects that aren't "
"actually dictionaries. At the very minimum they must support item getting, "
"setting, deleting and either iteration or membership test. This corresponds "
"to the magic methods :meth:`__getitem__`, :meth:`__setitem__`, :meth:"
"`__delitem__` and either :meth:`__iter__` or :meth:`__contains__`."
msgstr ""
":func:`patch.dict` 可以與實際上不是字典的類似字典的物件一起使用。它們至少必須"
"支援項目獲取、設定、刪除以及疊代或成員測試。這對應於魔法方法 "
":meth:`__getitem__`、:meth:`__setitem__`、:meth:`__delitem__` 和 "
":meth:`__iter__` 或 :meth:`__contains__`。"

#: ../../library/unittest.mock.rst:1685
msgid "patch.multiple"
msgstr "patch.multiple"

#: ../../library/unittest.mock.rst:1689
#, fuzzy
msgid ""
"Perform multiple patches in a single call. It takes the object to be patched "
"(either as an object or a string to fetch the object by importing) and "
"keyword arguments for the patches::"
msgstr "在一次呼叫中執行多個補丁。它採用要修補的物件（作為物件或通過導入獲取物件的字"
"串）和修補程式的關鍵字參數："

#: ../../library/unittest.mock.rst:1696
#, fuzzy
msgid ""
"Use :data:`DEFAULT` as the value if you want :func:`patch.multiple` to "
"create mocks for you. In this case the created mocks are passed into a "
"decorated function by keyword, and a dictionary is returned when :func:"
"`patch.multiple` is used as a context manager."
msgstr ""
"如果您希望 :func:`patch.multiple` 為您建立模擬，請使用 :data:`DEFAULT` "
"作為值。在這種情況下，建立的模擬通過關鍵字傳遞到裝飾函式中，並在 :func:`patch"
".multiple` 用作上下文管理器時回傳字典。"

#: ../../library/unittest.mock.rst:1701
#, fuzzy
msgid ""
":func:`patch.multiple` can be used as a decorator, class decorator or a "
"context manager. The arguments *spec*, *spec_set*, *create*, *autospec* and "
"*new_callable* have the same meaning as for :func:`patch`. These arguments "
"will be applied to *all* patches done by :func:`patch.multiple`."
msgstr ""
":func:`patch.multiple` 可以用作裝飾器、類裝飾器或上下文管理器。參數 "
"*spec*、*spec_set*、*create*、*autospec* 和 *new_callable* 與 :func:`patch` "
"的含義相同。這些參數將應用於由 :func:`patch.multiple` 完成的 *所有* 補丁。"

#: ../../library/unittest.mock.rst:1706
#, fuzzy
msgid ""
"When used as a class decorator :func:`patch.multiple` honours ``patch."
"TEST_PREFIX`` for choosing which methods to wrap."
msgstr "當用作類裝飾器時 :func:`patch.multiple` 榮譽 ``patch.TEST_PREFIX`` "
"用於選擇要包裝的方法。"

#: ../../library/unittest.mock.rst:1709
#, fuzzy
msgid ""
"If you want :func:`patch.multiple` to create mocks for you, then you can "
"use :data:`DEFAULT` as the value. If you use :func:`patch.multiple` as a "
"decorator then the created mocks are passed into the decorated function by "
"keyword. ::"
msgstr ""
"如果你想要 :func:`patch.multiple` 為你建立模擬，那麼你可以使用 "
":data:`DEFAULT` 作為值。如果您使用 :func:`patch.multiple` "
"作為裝飾器，那麼建立的模擬將通過關鍵字傳遞到裝飾函式中。 ::"

#: ../../library/unittest.mock.rst:1723
#, fuzzy
msgid ""
":func:`patch.multiple` can be nested with other ``patch`` decorators, but "
"put arguments passed by keyword *after* any of the standard arguments "
"created by :func:`patch`::"
msgstr ""
":func:`patch.multiple` 可以與其他 ``patch`` "
"裝飾器嵌套，但將通過關鍵字傳遞的參數放在*之後*由 :func:`patch`:: "
"建立的任何標準參數："

#: ../../library/unittest.mock.rst:1735
#, fuzzy
msgid ""
"If :func:`patch.multiple` is used as a context manager, the value returned "
"by the context manager is a dictionary where created mocks are keyed by "
"name::"
msgstr "如果 :func:`patch.multiple` "
"被用作上下文管理器，則上下文管理器回傳的值是一個字典，其中建立的 mock "
"以名稱為鍵："

#: ../../library/unittest.mock.rst:1749
#, fuzzy
msgid "patch methods: start and stop"
msgstr "修補方法：啟動和停止"

#: ../../library/unittest.mock.rst:1751
#, fuzzy
msgid ""
"All the patchers have :meth:`start` and :meth:`stop` methods. These make it "
"simpler to do patching in ``setUp`` methods or where you want to do multiple "
"patches without nesting decorators or with statements."
msgstr ""
"所有的修補程式都有 :meth:`start` 和 :meth:`stop` 方法。這些使得在 ``setUp`` "
"方法中進行修補或者您想在沒有嵌套裝飾器或 with "
"語句的情況下進行多個修補的地方變得更簡單。"

#: ../../library/unittest.mock.rst:1755
#, fuzzy
msgid ""
"To use them call :func:`patch`, :func:`patch.object` or :func:`patch.dict` "
"as normal and keep a reference to the returned ``patcher`` object. You can "
"then call :meth:`start` to put the patch in place and :meth:`stop` to undo "
"it."
msgstr ""
"要使用它們，請像往常一樣呼叫 :func:`patch`、:func:`patch.object` 或 "
":func:`patch.dict` 並保留對回傳的 ``patcher`` 物件的引用。然後，您可以呼叫 "
":meth:`start` 將補丁放置到位，然後呼叫 :meth:`stop` 撤消它。"

#: ../../library/unittest.mock.rst:1759
#, fuzzy
msgid ""
"If you are using :func:`patch` to create a mock for you then it will be "
"returned by the call to ``patcher.start``. ::"
msgstr "如果您使用 :func:`patch` 為您建立一個模擬，那麼它將通過呼叫 ``patcher.start``"
" 回傳。 ::"

#: ../../library/unittest.mock.rst:1773
#, fuzzy
msgid ""
"A typical use case for this might be for doing multiple patches in the "
"``setUp`` method of a :class:`TestCase`::"
msgstr "一個典型的用例可能是在 TestCase::class 的 setUp 方法中做多個補丁："

#: ../../library/unittest.mock.rst:1795
#, fuzzy
msgid ""
"If you use this technique you must ensure that the patching is \"undone\" by "
"calling ``stop``. This can be fiddlier than you might think, because if an "
"exception is raised in the ``setUp`` then ``tearDown`` is not called. :meth:"
"`unittest.TestCase.addCleanup` makes this easier::"
msgstr ""
"如果你使用這種技術，你必須通過呼叫 ``stop`` "
"來確保補丁被“撤銷”。這可能比您想像的要復雜，因為如果在 ``setUp`` 中引發例外，"
"則不會呼叫 ``tearDown``。 :meth:`unittest.TestCase.addCleanup` 使這更容易::"

#: ../../library/unittest.mock.rst:1810
#, fuzzy
msgid ""
"As an added bonus you no longer need to keep a reference to the ``patcher`` "
"object."
msgstr "作為額外的好處，您不再需要保留對 ``patcher`` 物件的引用。"

#: ../../library/unittest.mock.rst:1813
#, fuzzy
msgid ""
"It is also possible to stop all patches which have been started by using :"
"func:`patch.stopall`."
msgstr "也可以停止使用 :func:`patch.stopall` 啟動的所有補丁。"

#: ../../library/unittest.mock.rst:1818
#, fuzzy
msgid "Stop all active patches. Only stops patches started with ``start``."
msgstr "停止所有活動補丁。只停止以 ``start`` 開頭的補丁。"

#: ../../library/unittest.mock.rst:1824
#, fuzzy
msgid "patch builtins"
msgstr "補丁內建"

#: ../../library/unittest.mock.rst:1825
#, fuzzy
msgid ""
"You can patch any builtins within a module. The following example patches "
"builtin :func:`ord`::"
msgstr "您可以修補模組中的任何內建函式。以下示例補丁內建 :func:`ord`::"

#: ../../library/unittest.mock.rst:1840
msgid "TEST_PREFIX"
msgstr "TEST_PREFIX"

#: ../../library/unittest.mock.rst:1842
#, fuzzy
msgid ""
"All of the patchers can be used as class decorators. When used in this way "
"they wrap every test method on the class. The patchers recognise methods "
"that start with ``'test'`` as being test methods. This is the same way that "
"the :class:`unittest.TestLoader` finds test methods by default."
msgstr ""
"所有的修補程式都可以用作類裝飾器。當以這種方式使用時，它們將每個測試方法包裝"
"在類中。修補程式將以 ``'test'`` 開頭的方法識別為測試方法。這與 unittest.TestLoader "
"預設查找測試方法的方式相同。"

#: ../../library/unittest.mock.rst:1847
#, fuzzy
msgid ""
"It is possible that you want to use a different prefix for your tests. You "
"can inform the patchers of the different prefix by setting ``patch."
"TEST_PREFIX``::"
msgstr ""
"您可能希望為測試使用不同的前綴。您可以通過設定 ``patch.TEST_PREFIX`` "
"來通知補丁程式不同的前綴："

#: ../../library/unittest.mock.rst:1870
#, fuzzy
msgid "Nesting Patch Decorators"
msgstr "嵌套補丁裝飾器"

#: ../../library/unittest.mock.rst:1872
#, fuzzy
msgid ""
"If you want to perform multiple patches then you can simply stack up the "
"decorators."
msgstr "如果你想執行多個補丁，那麼你可以簡單地堆疊裝飾器。"

#: ../../library/unittest.mock.rst:1875
#, fuzzy
msgid "You can stack up multiple patch decorators using this pattern:"
msgstr "您可以使用此模式堆疊多個補丁裝飾器："

#: ../../library/unittest.mock.rst:1891
#, fuzzy
msgid ""
"Note that the decorators are applied from the bottom upwards. This is the "
"standard way that Python applies decorators. The order of the created mocks "
"passed into your test function matches this order."
msgstr "請注意，裝飾器是從底部向上應用的。這是 Python "
"應用裝飾器的標準方式。傳遞到您的測試函式中的已建立模擬的順序與此順序匹配。"

#: ../../library/unittest.mock.rst:1899
#, fuzzy
msgid "Where to patch"
msgstr "在哪裡打補丁"

#: ../../library/unittest.mock.rst:1901
#, fuzzy
msgid ""
":func:`patch` works by (temporarily) changing the object that a *name* "
"points to with another one. There can be many names pointing to any "
"individual object, so for patching to work you must ensure that you patch "
"the name used by the system under test."
msgstr ""
":func:`patch` 的工作原理是（暫時）將 *name* 指向的物件更改為另一個物件。可以"
"有許多指向任何單個物件的名稱，因此要使修補工作，您必須確保修補被測系統使用的"
"名稱。"

#: ../../library/unittest.mock.rst:1906
#, fuzzy
msgid ""
"The basic principle is that you patch where an object is *looked up*, which "
"is not necessarily the same place as where it is defined. A couple of "
"examples will help to clarify this."
msgstr "基本原則是在 *查找* 物件的位置進行修補，這不一定與定義物件的位置相同。幾個例"
"子將有助於澄清這一點。"

#: ../../library/unittest.mock.rst:1910
#, fuzzy
msgid ""
"Imagine we have a project that we want to test with the following structure::"
msgstr "假設我們有一個項目，我們想要使用以下結構進行測試："

#: ../../library/unittest.mock.rst:1919
#, fuzzy
msgid ""
"Now we want to test ``some_function`` but we want to mock out ``SomeClass`` "
"using :func:`patch`. The problem is that when we import module b, which we "
"will have to do then it imports ``SomeClass`` from module a. If we use :func:"
"`patch` to mock out ``a.SomeClass`` then it will have no effect on our test; "
"module b already has a reference to the *real* ``SomeClass`` and it looks "
"like our patching had no effect."
msgstr ""
"現在我們想測試 ``some_function`` 但我們想使用 :func:`patch` 模擬 "
"``SomeClass``。問題是當我們導入模組 b 時，我們必須這樣做，然後它從模組 a "
"導入 ``SomeClass``。如果我們使用 :func:`patch` 模擬出 ``a.SomeClass`` "
"那麼它對我們的測試沒有影響；模組 b 已經引用了 *real* "
"``SomeClass``，看起來我們的補丁沒有效果。"

#: ../../library/unittest.mock.rst:1926
#, fuzzy
msgid ""
"The key is to patch out ``SomeClass`` where it is used (or where it is "
"looked up). In this case ``some_function`` will actually look up "
"``SomeClass`` in module b, where we have imported it. The patching should "
"look like::"
msgstr ""
"關鍵是在使用它的地方（或查找它的地方）修補 "
"``SomeClass``。在這種情況下，``some_function`` 實際上會在我們導入它的模組 b "
"中查找 ``SomeClass``。修補程式應如下所示："

#: ../../library/unittest.mock.rst:1932
#, fuzzy
msgid ""
"However, consider the alternative scenario where instead of ``from a import "
"SomeClass`` module b does ``import a`` and ``some_function`` uses ``a."
"SomeClass``. Both of these import forms are common. In this case the class "
"we want to patch is being looked up in the module and so we have to patch "
"``a.SomeClass`` instead::"
msgstr ""
"但是，請考慮另一種情況，即模組 b 不使用 ``from a import SomeClass`` ``import "
"a`` 而 ``some_function`` 使用 ``a.SomeClass``。這兩種導入形式都很常見。在這種"
"情況下，我們要修補的類正在模組中查找，因此我們必須改為修補 ``a.SomeClass``::"

#: ../../library/unittest.mock.rst:1941
#, fuzzy
msgid "Patching Descriptors and Proxy Objects"
msgstr "修補描述器和代理物件"

#: ../../library/unittest.mock.rst:1943
#, fuzzy
msgid ""
"Both patch_ and patch.object_ correctly patch and restore descriptors: class "
"methods, static methods and properties. You should patch these on the "
"*class* rather than an instance. They also work with *some* objects that "
"proxy attribute access, like the `django settings object <https://web."
"archive.org/web/20200603181648/http://www.voidspace.org.uk/python/weblog/"
"arch_d7_2010_12_04.shtml#e1198>`_."
msgstr ""
"patch_ 和 patch.object_ 都正確地修補和恢復描述器：類方法、靜態方法和屬性。"
"您應該在 *class* 而不是實例上修補它們。他們還使用 *一些* "
"代理屬性訪問的物件，比如`django 設定物件 <https://web.archive.org/web/"
"20200603181648/http://www.voidspace.org.uk/python/weblog/ arch_d7_2010_12_04."
"shtml#e1198>`_。"

#: ../../library/unittest.mock.rst:1951
#, fuzzy
msgid "MagicMock and magic method support"
msgstr "MagicMock 和魔術方法支援"

#: ../../library/unittest.mock.rst:1956
#, fuzzy
msgid "Mocking Magic Methods"
msgstr "模擬魔術方法"

#: ../../library/unittest.mock.rst:1958
#, fuzzy
msgid ""
":class:`Mock` supports mocking the Python protocol methods, also known as "
"\"magic methods\". This allows mock objects to replace containers or other "
"objects that implement Python protocols."
msgstr ":class:`Mock` 支援模擬 Python 協定方法，也稱為“魔術方法”。"
"這允許模擬物件替換容器或其他實作 Python 協定的物件。"

#: ../../library/unittest.mock.rst:1962
#, fuzzy
msgid ""
"Because magic methods are looked up differently from normal methods [#]_, "
"this support has been specially implemented. This means that only specific "
"magic methods are supported. The supported list includes *almost* all of "
"them. If there are any missing that you need please let us know."
msgstr ""
"因為魔術方法的查找方式不同於普通方法[#]_，所以專門實作了這種支援。這意味著只"
"支援特定的魔法方法。支援的列表包括*幾乎*所有這些。如果有任何您需要的遺漏，請"
"告訴我們。"

#: ../../library/unittest.mock.rst:1967
#, fuzzy
msgid ""
"You mock magic methods by setting the method you are interested in to a "
"function or a mock instance. If you are using a function then it *must* take "
"``self`` as the first argument [#]_."
msgstr "您可以通過將您感興趣的方法設定為函式或模擬實例來模擬魔法方法。如果您使用的是"
"函式，那麼它*必須*將 ``self``作為第一個參數 [#]_。"

#: ../../library/unittest.mock.rst:1990
#, fuzzy
msgid ""
"One use case for this is for mocking objects used as context managers in a :"
"keyword:`with` statement:"
msgstr "一個用例是模擬在 :keyword:`with` 語句中用作上下文管理器的物件："

#: ../../library/unittest.mock.rst:2002
#, fuzzy
msgid ""
"Calls to magic methods do not appear in :attr:`~Mock.method_calls`, but they "
"are recorded in :attr:`~Mock.mock_calls`."
msgstr ""
"對魔術方法的呼叫不會出現在 :attr:`~Mock.method_calls` 中，但它們會記錄在 "
":attr:`~Mock.mock_calls` 中。"

#: ../../library/unittest.mock.rst:2007
#, fuzzy
msgid ""
"If you use the *spec* keyword argument to create a mock then attempting to "
"set a magic method that isn't in the spec will raise an :exc:"
"`AttributeError`."
msgstr "如果您使用 *spec* 關鍵字參數來建立模擬，則嘗試設定不在規範中的魔術方法將引發 "
":exc:`AttributeError`。"

#: ../../library/unittest.mock.rst:2010
#, fuzzy
msgid "The full list of supported magic methods is:"
msgstr "支援的魔法方法的完整列表是："

#: ../../library/unittest.mock.rst:2012
msgid "``__hash__``, ``__sizeof__``, ``__repr__`` and ``__str__``"
msgstr "``__hash__``\\ 、\\ ``__sizeof__``\\ 、\\ ``__repr__`` 和 ``__str__``"

#: ../../library/unittest.mock.rst:2013
msgid "``__dir__``, ``__format__`` and ``__subclasses__``"
msgstr "``__dir__``\\ 、\\ ``__format__`` 和 ``__subclasses__``"

#: ../../library/unittest.mock.rst:2014
msgid "``__round__``, ``__floor__``, ``__trunc__`` and ``__ceil__``"
msgstr ""
"``__round__``\\ 、\\ ``__floor__``\\ 、\\ ``__trunc__`` 和 ``__ceil__``"

#: ../../library/unittest.mock.rst:2015
#, fuzzy
msgid ""
"Comparisons: ``__lt__``, ``__gt__``, ``__le__``, ``__ge__``, ``__eq__`` and "
"``__ne__``"
msgstr "比較：``__lt__``、``__gt__``、``__le__``、``__ge__``、``__eq__`` 和 "
"``__ne__``"

#: ../../library/unittest.mock.rst:2017
#, fuzzy
msgid ""
"Container methods: ``__getitem__``, ``__setitem__``, ``__delitem__``, "
"``__contains__``, ``__len__``, ``__iter__``, ``__reversed__`` and "
"``__missing__``"
msgstr ""
"容器方法：``__getitem__``、``__setitem__``、``__delitem__``、``__contains__``"
"、``__len__``、``__iter__``、``__reversed__`` 和 ``__missing__``"

#: ../../library/unittest.mock.rst:2020
#, fuzzy
msgid ""
"Context manager: ``__enter__``, ``__exit__``, ``__aenter__`` and "
"``__aexit__``"
msgstr "上下文管理器：``__enter__``、``__exit__``、``__aenter__`` 和 ``__aexit__``"

#: ../../library/unittest.mock.rst:2021
#, fuzzy
msgid "Unary numeric methods: ``__neg__``, ``__pos__`` and ``__invert__``"
msgstr "一元數值方法：``__neg__``、``__pos__`` 和 ``__invert__``"

#: ../../library/unittest.mock.rst:2022
#, fuzzy
msgid ""
"The numeric methods (including right hand and in-place variants): "
"``__add__``, ``__sub__``, ``__mul__``, ``__matmul__``, ``__truediv__``, "
"``__floordiv__``, ``__mod__``, ``__divmod__``, ``__lshift__``, "
"``__rshift__``, ``__and__``, ``__xor__``, ``__or__``, and ``__pow__``"
msgstr ""
"數值方法（包括右手和就地變體）：``__add__``、``__sub__``、``__mul__``、``__ma"
"tmul__``、``__truediv__``、``__floordiv__``、 ``__mod__``、``__divmod__``、``"
"__lshift__``、``__rshift__``、``__and__``、``__xor__``、``__or__`` 和 "
"``__pow__``"

#: ../../library/unittest.mock.rst:2026
#, fuzzy
msgid ""
"Numeric conversion methods: ``__complex__``, ``__int__``, ``__float__`` and "
"``__index__``"
msgstr "數值轉換方法：``__complex__``、``__int__``、``__float__`` 和 ``__index__``"

#: ../../library/unittest.mock.rst:2028
#, fuzzy
msgid "Descriptor methods: ``__get__``, ``__set__`` and ``__delete__``"
msgstr "描述器方法：``__get__``、``__set__`` 和 ``__delete__``"

#: ../../library/unittest.mock.rst:2029
#, fuzzy
msgid ""
"Pickling: ``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, "
"``__getnewargs__``, ``__getstate__`` and ``__setstate__``"
msgstr ""
"酸洗：``__reduce__``，``__reduce_ex__``，``__getinitargs__``，``__getnewargs_"
"_``，``__getstate__`` 和``__setstate__``"

#: ../../library/unittest.mock.rst:2031
#, fuzzy
msgid "File system path representation: ``__fspath__``"
msgstr "文件系統路徑表示：``__fspath__``"

#: ../../library/unittest.mock.rst:2032
#, fuzzy
msgid "Asynchronous iteration methods: ``__aiter__`` and ``__anext__``"
msgstr "非同步疊代方法：``__aiter__`` 和 ``__anext__``"

#: ../../library/unittest.mock.rst:2034
#, fuzzy
msgid "Added support for :func:`os.PathLike.__fspath__`."
msgstr "新增了對 :func:`os.PathLike.__fspath__` 的支援。"

#: ../../library/unittest.mock.rst:2037
#, fuzzy
msgid ""
"Added support for ``__aenter__``, ``__aexit__``, ``__aiter__`` and "
"``__anext__``."
msgstr "新增了對“__aenter__”、“__aexit__”、“__aiter__”和“__anext__”的支援。"

#: ../../library/unittest.mock.rst:2041
#, fuzzy
msgid ""
"The following methods exist but are *not* supported as they are either in "
"use by mock, can't be set dynamically, or can cause problems:"
msgstr "以下方法存在但 *不* 支援，因為它們要么被 mock "
"使用，要么不能動態設定，要么會導致問題："

#: ../../library/unittest.mock.rst:2044
msgid "``__getattr__``, ``__setattr__``, ``__init__`` and ``__new__``"
msgstr ""
"``__getattr__``\\ 、\\ ``__setattr__``\\ 、\\ ``__init__`` 和 ``__new__``"

#: ../../library/unittest.mock.rst:2045
msgid ""
"``__prepare__``, ``__instancecheck__``, ``__subclasscheck__``, ``__del__``"
msgstr ""
"``__prepare__``\\ 、\\ ``__instancecheck__``\\ 、\\ "
"``__subclasscheck__``\\ 、\\ ``__del__``"

#: ../../library/unittest.mock.rst:2050
#, fuzzy
msgid "Magic Mock"
msgstr "魔法模擬"

#: ../../library/unittest.mock.rst:2052
#, fuzzy
msgid ""
"There are two ``MagicMock`` variants: :class:`MagicMock` and :class:"
"`NonCallableMagicMock`."
msgstr ""
"有兩個 ``MagicMock`` 變體：:class:`MagicMock` 和 "
":class:`NonCallableMagicMock`。"

#: ../../library/unittest.mock.rst:2057
#, fuzzy
msgid ""
"``MagicMock`` is a subclass of :class:`Mock` with default implementations of "
"most of the magic methods. You can use ``MagicMock`` without having to "
"configure the magic methods yourself."
msgstr ""
"``MagicMock`` 是 :class:`Mock` 的子類別，具有大多數魔術方法的預設實作。"
"您可以使用 ``MagicMock`` 而無需自己配置魔術方法。"

#: ../../library/unittest.mock.rst:2061
#, fuzzy
msgid "The constructor parameters have the same meaning as for :class:`Mock`."
msgstr "構造函式參數與 Mock 的含義相同。"

#: ../../library/unittest.mock.rst:2063
#, fuzzy
msgid ""
"If you use the *spec* or *spec_set* arguments then *only* magic methods that "
"exist in the spec will be created."
msgstr "如果您使用 *spec* 或 *spec_set* 參數，則 *僅* 規範中存在的魔術方法將被建立。"

#: ../../library/unittest.mock.rst:2069
#, fuzzy
msgid "A non-callable version of :class:`MagicMock`."
msgstr ":class:`MagicMock` 的不可呼叫版本。"

#: ../../library/unittest.mock.rst:2071
#, fuzzy
msgid ""
"The constructor parameters have the same meaning as for :class:`MagicMock`, "
"with the exception of *return_value* and *side_effect* which have no meaning "
"on a non-callable mock."
msgstr ""
"構造函式參數與 :class:`MagicMock` 具有相同的含義，但 *return_value* 和 "
"*side_effect* 除外，它們在不可呼叫的模擬中沒有意義。"

#: ../../library/unittest.mock.rst:2075
#, fuzzy
msgid ""
"The magic methods are setup with :class:`MagicMock` objects, so you can "
"configure them and use them in the usual way:"
msgstr "魔術方法是用 :class:`MagicMock` "
"物件設定的，因此您可以配置它們並以通常的方式使用它們："

#: ../../library/unittest.mock.rst:2085
#, fuzzy
msgid ""
"By default many of the protocol methods are required to return objects of a "
"specific type. These methods are preconfigured with a default return value, "
"so that they can be used without you having to do anything if you aren't "
"interested in the return value. You can still *set* the return value "
"manually if you want to change the default."
msgstr ""
"預設情況下，許多協定方法都需要回傳特定型別的物件。這些方法預先配置了預設回傳"
"值，因此如果您對回傳值不感興趣，則無需執行任何操作即可使用它們。如果您想更改"
"預設值，您仍然可以手動*設定*回傳值。"

#: ../../library/unittest.mock.rst:2091
#, fuzzy
msgid "Methods and their defaults:"
msgstr "方法及其預設值："

#: ../../library/unittest.mock.rst:2093
msgid "``__lt__``: ``NotImplemented``"
msgstr "``__lt__``\\ ：\\ ``NotImplemented``"

#: ../../library/unittest.mock.rst:2094
msgid "``__gt__``: ``NotImplemented``"
msgstr "``__gt__``\\ ：\\ ``NotImplemented``"

#: ../../library/unittest.mock.rst:2095
msgid "``__le__``: ``NotImplemented``"
msgstr "``__le__``\\ ：\\ ``NotImplemented``"

#: ../../library/unittest.mock.rst:2096
msgid "``__ge__``: ``NotImplemented``"
msgstr "``__ge__``\\ ：\\ ``NotImplemented``"

#: ../../library/unittest.mock.rst:2097
msgid "``__int__``: ``1``"
msgstr "``__int__``\\ ：\\ ``1``"

#: ../../library/unittest.mock.rst:2098
msgid "``__contains__``: ``False``"
msgstr "``__contains__``\\ ：\\ ``False``"

#: ../../library/unittest.mock.rst:2099
msgid "``__len__``: ``0``"
msgstr "``__len__``\\ ：\\ ``0``"

#: ../../library/unittest.mock.rst:2100
msgid "``__iter__``: ``iter([])``"
msgstr "``__iter__``\\ ：\\ ``iter([])``"

#: ../../library/unittest.mock.rst:2101
msgid "``__exit__``: ``False``"
msgstr "``__exit__``\\ ：\\ ``False``"

#: ../../library/unittest.mock.rst:2102
msgid "``__aexit__``: ``False``"
msgstr "``__aexit__``\\ ：\\ ``False``"

#: ../../library/unittest.mock.rst:2103
msgid "``__complex__``: ``1j``"
msgstr "``__complex__``\\ ：\\ ``1j``"

#: ../../library/unittest.mock.rst:2104
msgid "``__float__``: ``1.0``"
msgstr "``__float__``\\ ：\\ ``1.0``"

#: ../../library/unittest.mock.rst:2105
msgid "``__bool__``: ``True``"
msgstr "``__bool__``\\ ：\\ ``True``"

#: ../../library/unittest.mock.rst:2106
msgid "``__index__``: ``1``"
msgstr "``__index__``\\ ：\\ ``1``"

#: ../../library/unittest.mock.rst:2107
#, fuzzy
msgid "``__hash__``: default hash for the mock"
msgstr "``__hash__``：模擬的預設雜湊"

#: ../../library/unittest.mock.rst:2108
#, fuzzy
msgid "``__str__``: default str for the mock"
msgstr "``__str__``：模擬的預設 str"

#: ../../library/unittest.mock.rst:2109
#, fuzzy
msgid "``__sizeof__``: default sizeof for the mock"
msgstr "``__sizeof__``：模擬的預設 sizeof"

#: ../../library/unittest.mock.rst:2111
msgid "For example:"
msgstr "舉例來說："

#: ../../library/unittest.mock.rst:2123
#, fuzzy
msgid ""
"The two equality methods, :meth:`__eq__` and :meth:`__ne__`, are special. "
"They do the default equality comparison on identity, using the :attr:`~Mock."
"side_effect` attribute, unless you change their return value to return "
"something else::"
msgstr ""
":meth:`__eq__` 和 :meth:`__ne__` 這兩個相等方法是特殊的。它們使用 "
":attr:`~Mock.side_effect` "
"屬性對身份進行預設相等比較，除非您更改它們的回傳值以回傳其他內容::"

#: ../../library/unittest.mock.rst:2137
#, fuzzy
msgid ""
"The return value of :meth:`MagicMock.__iter__` can be any iterable object "
"and isn't required to be an iterator:"
msgstr ":meth:`MagicMock.__iter__` 的回傳值可以是任何可疊代物件，不需要是疊代器："

#: ../../library/unittest.mock.rst:2147
#, fuzzy
msgid ""
"If the return value *is* an iterator, then iterating over it once will "
"consume it and subsequent iterations will result in an empty list:"
msgstr "如果回傳值*是*一個疊代器，那麼疊代一次就會消耗它，隨後的疊代將導致一個空列表"
"："

#: ../../library/unittest.mock.rst:2156
#, fuzzy
msgid ""
"``MagicMock`` has all of the supported magic methods configured except for "
"some of the obscure and obsolete ones. You can still set these up if you "
"want."
msgstr "``MagicMock`` 配置了所有支援的魔法方法，除了一些晦澀和過時的方法。如果需要，"
"您仍然可以設定這些。"

#: ../../library/unittest.mock.rst:2159
#, fuzzy
msgid ""
"Magic methods that are supported but not setup by default in ``MagicMock`` "
"are:"
msgstr "``MagicMock`` 支援但預設不設定的魔法方法有："

#: ../../library/unittest.mock.rst:2161
msgid "``__subclasses__``"
msgstr "``__subclasses__``"

#: ../../library/unittest.mock.rst:2162
msgid "``__dir__``"
msgstr "``__dir__``"

#: ../../library/unittest.mock.rst:2163
msgid "``__format__``"
msgstr "``__format__``"

#: ../../library/unittest.mock.rst:2164
msgid "``__get__``, ``__set__`` and ``__delete__``"
msgstr "``__get__``\\ 、\\ ``__set__`` 和 ``__delete__``"

#: ../../library/unittest.mock.rst:2165
msgid "``__reversed__`` and ``__missing__``"
msgstr "``__reversed__`` 和 ``__missing__``"

#: ../../library/unittest.mock.rst:2166
#, fuzzy
msgid ""
"``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, ``__getnewargs__``, "
"``__getstate__`` and ``__setstate__``"
msgstr ""
"``__reduce__``、``__reduce_ex__``、``__getinitargs__``、``__getnewargs__``、`"
"`__getstate__`` 和 ``__setstate__``"

#: ../../library/unittest.mock.rst:2168
msgid "``__getformat__``"
msgstr "``__getformat__``"

#: ../../library/unittest.mock.rst:2172
#, fuzzy
msgid ""
"Magic methods *should* be looked up on the class rather than the instance. "
"Different versions of Python are inconsistent about applying this rule. The "
"supported protocol methods should work with all supported versions of Python."
msgstr ""
"魔術方法*應該*在類而不是實例上查找。不同版本的 Python "
"在應用此規則方面不一致。支援的協定方法應該適用於所有支援的 Python 版本。"

#: ../../library/unittest.mock.rst:2176
#, fuzzy
msgid ""
"The function is basically hooked up to the class, but each ``Mock`` instance "
"is kept isolated from the others."
msgstr "該函式基本上與類掛鉤，但每個 ``Mock``實例都與其他實例保持隔離。"

#: ../../library/unittest.mock.rst:2181
#, fuzzy
msgid "Helpers"
msgstr "幫手"

#: ../../library/unittest.mock.rst:2184
#, fuzzy
msgid "sentinel"
msgstr "哨兵"

#: ../../library/unittest.mock.rst:2188
#, fuzzy
msgid ""
"The ``sentinel`` object provides a convenient way of providing unique "
"objects for your tests."
msgstr "``sentinel`` 物件提供了一種為您的測試提供獨特物件的便捷方式。"

#: ../../library/unittest.mock.rst:2191
#, fuzzy
msgid ""
"Attributes are created on demand when you access them by name. Accessing the "
"same attribute will always return the same object. The objects returned have "
"a sensible repr so that test failure messages are readable."
msgstr "當您按名稱訪問屬性時，它們是按需建立的。訪問相同的屬性將始終回傳相同的物件。"
"回傳的物件具有合理的 repr，以便測試失敗消息是可讀的。"

#: ../../library/unittest.mock.rst:2195
#, fuzzy
msgid ""
"The ``sentinel`` attributes now preserve their identity when they are :mod:"
"`copied <copy>` or :mod:`pickled <pickle>`."
msgstr ""
"``sentinel`` 屬性現在在 :mod:`copied <copy>` 或 :mod:`pickled <pickle>` "
"時保留它們的身份。"

#: ../../library/unittest.mock.rst:2199
#, fuzzy
msgid ""
"Sometimes when testing you need to test that a specific object is passed as "
"an argument to another method, or returned. It can be common to create named "
"sentinel objects to test this. :data:`sentinel` provides a convenient way of "
"creating and testing the identity of objects like this."
msgstr ""
"有時在測試時，您需要測試特定物件是作為參數傳遞給另一個方法，還是回傳。建立命"
"名哨兵物件來測試它可能很常見。 :data:`sentinel` "
"提供了一種方便的方法來建立和測試這樣的物件的身份。"

#: ../../library/unittest.mock.rst:2204
#, fuzzy
msgid ""
"In this example we monkey patch ``method`` to return ``sentinel."
"some_object``:"
msgstr "在這個例子中，我們猴子修補“方法”以回傳“sentinel.some_object”："

#: ../../library/unittest.mock.rst:2216
msgid "DEFAULT"
msgstr "DEFAULT"

#: ../../library/unittest.mock.rst:2221
#, fuzzy
msgid ""
"The :data:`DEFAULT` object is a pre-created sentinel (actually ``sentinel."
"DEFAULT``). It can be used by :attr:`~Mock.side_effect` functions to "
"indicate that the normal return value should be used."
msgstr ""
":data:`DEFAULT` 物件是一個預先建立的哨兵（實際上是 ``sentinel.DEFAULT``）。 "
":attr:`~Mock.side_effect` 函式可以使用它來指示應該使用正常的回傳值。"

#: ../../library/unittest.mock.rst:2227
#, fuzzy
msgid "call"
msgstr "稱呼"

#: ../../library/unittest.mock.rst:2231
#, fuzzy
msgid ""
":func:`call` is a helper object for making simpler assertions, for comparing "
"with :attr:`~Mock.call_args`, :attr:`~Mock.call_args_list`, :attr:`~Mock."
"mock_calls` and :attr:`~Mock.method_calls`. :func:`call` can also be used "
"with :meth:`~Mock.assert_has_calls`."
msgstr ""
":func:`call` 是一個輔助物件，用於進行更簡單的斷言，用於與 :attr:`~Mock."
"call_args`、:attr:`~Mock.call_args_list`、:attr:`~Mock.mock_calls` 和 :attr "
"進行比較:`~Mock.method_calls`。 :func:`call` 也可以與 :meth:`~Mock."
"assert_has_calls` 一起使用。"

#: ../../library/unittest.mock.rst:2244
#, fuzzy
msgid ""
"For a call object that represents multiple calls, :meth:`call_list` returns "
"a list of all the intermediate calls as well as the final call."
msgstr "對於表示多個呼叫的呼叫物件，call_list 回傳所有中間呼叫以及最終呼叫的列表。"

#: ../../library/unittest.mock.rst:2248
#, fuzzy
msgid ""
"``call_list`` is particularly useful for making assertions on \"chained "
"calls\". A chained call is multiple calls on a single line of code. This "
"results in multiple entries in :attr:`~Mock.mock_calls` on a mock. Manually "
"constructing the sequence of calls can be tedious."
msgstr ""
"``call_list`` "
"對於對“鍊式呼叫”進行斷言特別有用。鍊式呼叫是對單行程式碼的多次呼叫。"
"這會導致模擬中的 :attr:`~Mock.mock_calls` "
"中有多個條目。手動構建呼叫序列可能很乏味。"

#: ../../library/unittest.mock.rst:2253
#, fuzzy
msgid ""
":meth:`~call.call_list` can construct the sequence of calls from the same "
"chained call:"
msgstr ":meth:`~call.call_list` 可以從同一個鍊式呼叫構造呼叫序列："

#: ../../library/unittest.mock.rst:2270
#, fuzzy
msgid ""
"A ``call`` object is either a tuple of (positional args, keyword args) or "
"(name, positional args, keyword args) depending on how it was constructed. "
"When you construct them yourself this isn't particularly interesting, but "
"the ``call`` objects that are in the :attr:`Mock.call_args`, :attr:`Mock."
"call_args_list` and :attr:`Mock.mock_calls` attributes can be introspected "
"to get at the individual arguments they contain."
msgstr ""
"``call`` 物件是（位置參數，關鍵字參數）或（名稱，位置參數，關鍵字參數）的元組"
"，具體取決於它的構造方式。當你自己構建它們時，這並不是特別有趣，但是 Mock."
"call_args、Mock.call_args_list 和 Mock.mock_calls 中的 ``call`` "
"物件可以內省屬性以獲取它們包含的各個參數。"

#: ../../library/unittest.mock.rst:2277
#, fuzzy
msgid ""
"The ``call`` objects in :attr:`Mock.call_args` and :attr:`Mock."
"call_args_list` are two-tuples of (positional args, keyword args) whereas "
"the ``call`` objects in :attr:`Mock.mock_calls`, along with ones you "
"construct yourself, are three-tuples of (name, positional args, keyword "
"args)."
msgstr ""
":attr:`Mock.call_args` 和 :attr:`Mock.call_args_list` 中的 ``call`` "
"物件是（位置參數，關鍵字參數）的二元組，而 :attr: 中的 ``call`` 物件Mock."
"mock_calls` 以及您自己構造的那些是（名稱、位置參數、關鍵字參數）的三元組。"

#: ../../library/unittest.mock.rst:2282
#, fuzzy
msgid ""
"You can use their \"tupleness\" to pull out the individual arguments for "
"more complex introspection and assertions. The positional arguments are a "
"tuple (an empty tuple if there are no positional arguments) and the keyword "
"arguments are a dictionary:"
msgstr "您可以使用它們的“元組”來提取單個參數以進行更複雜的內省和斷言。位置參數是一個"
"元組（如果沒有位置參數，則為空元組），關鍵字參數是一個字典："

#: ../../library/unittest.mock.rst:2315
msgid "create_autospec"
msgstr "create_autospec"

#: ../../library/unittest.mock.rst:2319
#, fuzzy
msgid ""
"Create a mock object using another object as a spec. Attributes on the mock "
"will use the corresponding attribute on the *spec* object as their spec."
msgstr "使用另一個物件作為規範建立模擬物件。 mock 上的屬性將使用 *spec* "
"物件上的相應屬性作為它們的規範。"

#: ../../library/unittest.mock.rst:2323
#, fuzzy
msgid ""
"Functions or methods being mocked will have their arguments checked to "
"ensure that they are called with the correct signature."
msgstr "被模擬的函式或方法將檢查其參數，以確保使用正確的簽名呼叫它們。"

#: ../../library/unittest.mock.rst:2326
#, fuzzy
msgid ""
"If *spec_set* is ``True`` then attempting to set attributes that don't exist "
"on the spec object will raise an :exc:`AttributeError`."
msgstr "如果 *spec_set* 為 ``True`` 則嘗試設定規範物件上不存在的屬性將引發 "
":exc:`AttributeError`。"

#: ../../library/unittest.mock.rst:2329
#, fuzzy
msgid ""
"If a class is used as a spec then the return value of the mock (the instance "
"of the class) will have the same spec. You can use a class as the spec for "
"an instance object by passing ``instance=True``. The returned mock will only "
"be callable if instances of the mock are callable."
msgstr ""
"如果一個類被用作規範，那麼模擬的回傳值（類的實例）將具有相同的規範。"
"您可以通過傳遞 ``instance=True`` 將類用作實例物件的規範。只有當 mock "
"的實例可呼叫時，回傳的 mock 才可呼叫。"

#: ../../library/unittest.mock.rst:2334
#, fuzzy
msgid ""
":func:`create_autospec` also takes arbitrary keyword arguments that are "
"passed to the constructor of the created mock."
msgstr ":func:`create_autospec` 還接受傳遞給建立的 mock 的構造函式的任意關鍵字參數。"

#: ../../library/unittest.mock.rst:2337
#, fuzzy
msgid ""
"See :ref:`auto-speccing` for examples of how to use auto-speccing with :func:"
"`create_autospec` and the *autospec* argument to :func:`patch`."
msgstr ""
"有關如何使用 auto-speccing 和 :func:`create_autospec` 以及 :func:`patch` 的 "
"*autospec* 參數的示例，請參閱 :ref:`auto-speccing`。"

#: ../../library/unittest.mock.rst:2343
#, fuzzy
msgid ""
":func:`create_autospec` now returns an :class:`AsyncMock` if the target is "
"an async function."
msgstr ":func:`create_autospec` 現在回傳一個 :class:`AsyncMock` "
"如果目標是一個非同步函式。"

#: ../../library/unittest.mock.rst:2348
msgid "ANY"
msgstr "ANY"

#: ../../library/unittest.mock.rst:2352
#, fuzzy
msgid ""
"Sometimes you may need to make assertions about *some* of the arguments in a "
"call to mock, but either not care about some of the arguments or want to "
"pull them individually out of :attr:`~Mock.call_args` and make more complex "
"assertions on them."
msgstr ""
"有時您可能需要對 mock 呼叫中的*某些*參數進行斷言，但要么不關心某些參數，"
"要么想將它們單獨從 :attr:`~Mock.call_args` "
"中提取出來並使其變得更複雜對他們的斷言。"

#: ../../library/unittest.mock.rst:2357
#, fuzzy
msgid ""
"To ignore certain arguments you can pass in objects that compare equal to "
"*everything*. Calls to :meth:`~Mock.assert_called_with` and :meth:`~Mock."
"assert_called_once_with` will then succeed no matter what was passed in."
msgstr ""
"要忽略某些參數，您可以傳入比較等於 *everything* 的物件。無論傳入什麼，呼叫 "
":meth:`~Mock.assert_called_with` 和 :meth:`~Mock.assert_called_once_with` "
"都會成功。"

#: ../../library/unittest.mock.rst:2366
#, fuzzy
msgid ""
":data:`ANY` can also be used in comparisons with call lists like :attr:"
"`~Mock.mock_calls`:"
msgstr ":data:`ANY` 也可用於與呼叫列表進行比較，例如 :attr:`~Mock.mock_calls`："

#: ../../library/unittest.mock.rst:2379
msgid "FILTER_DIR"
msgstr "FILTER_DIR"

#: ../../library/unittest.mock.rst:2383
#, fuzzy
msgid ""
":data:`FILTER_DIR` is a module level variable that controls the way mock "
"objects respond to :func:`dir`. The default is ``True``, which uses the "
"filtering described below, to only show useful members. If you dislike this "
"filtering, or need to switch it off for diagnostic purposes, then set ``mock."
"FILTER_DIR = False``."
msgstr ""
":data:`FILTER_DIR` 是一個模組級變數，用於控制模擬物件響應 :func:`dir` "
"的方式。預設值為 ``True``，它使用下面描述的過濾來僅顯示有用的成員。如果你不喜"
"歡這個過濾，或者為了診斷目的需要關閉它，那麼設定 ``mock.FILTER_DIR = "
"False``。"

#: ../../library/unittest.mock.rst:2389
#, fuzzy
msgid ""
"With filtering on, ``dir(some_mock)`` shows only useful attributes and will "
"include any dynamically created attributes that wouldn't normally be shown. "
"If the mock was created with a *spec* (or *autospec* of course) then all the "
"attributes from the original are shown, even if they haven't been accessed "
"yet:"
msgstr ""
"啟用過濾後，``dir(some_mock)`` "
"僅顯示有用的屬性，並將包括通常不會顯示的任何動態建立的屬性。如果模擬是使用 "
"*spec*（當然是 "
"*autospec*）建立的，那麼將顯示原始的所有屬性，即使它們尚未被訪問："

#: ../../library/unittest.mock.rst:2416
#, fuzzy
msgid ""
"Many of the not-very-useful (private to :class:`Mock` rather than the thing "
"being mocked) underscore and double underscore prefixed attributes have been "
"filtered from the result of calling :func:`dir` on a :class:`Mock`. If you "
"dislike this behaviour you can switch it off by setting the module level "
"switch :data:`FILTER_DIR`:"
msgstr ""
"許多不是很有用的（私有於 :class:`Mock` 而不是被模擬的東西）"
"底線和雙底線前綴屬性已從呼叫 :func:`dir` 的結果中過濾掉 :class:`模擬`。如"
"果你不喜歡這種行為，你可以通過設定模組級別開關將其關閉 :data:`FILTER_DIR`："

#: ../../library/unittest.mock.rst:2437
#, fuzzy
msgid ""
"Alternatively you can just use ``vars(my_mock)`` (instance members) and "
"``dir(type(my_mock))`` (type members) to bypass the filtering irrespective "
"of :data:`mock.FILTER_DIR`."
msgstr ""
"或者，您可以只使用 ``vars(my_mock)``（實例成員）和 "
"``dir(type(my_mock))``（型別成員）來繞過過濾，而不管 :data:`mock."
"FILTER_DIR`。"

#: ../../library/unittest.mock.rst:2443
msgid "mock_open"
msgstr "mock_open"

#: ../../library/unittest.mock.rst:2447
#, fuzzy
msgid ""
"A helper function to create a mock to replace the use of :func:`open`. It "
"works for :func:`open` called directly or used as a context manager."
msgstr "一個幫助函式來建立一個模擬來代替 :func:`open` 的使用。"
"它適用於直接呼叫或用作上下文管理器的 :func:`open`。"

#: ../../library/unittest.mock.rst:2450
#, fuzzy
msgid ""
"The *mock* argument is the mock object to configure. If ``None`` (the "
"default) then a :class:`MagicMock` will be created for you, with the API "
"limited to methods or attributes available on standard file handles."
msgstr ""
"*mock* 參數是要配置的模擬物件。如果 ``None``（預設值），那麼將為您建立一個 "
":class:`MagicMock`，API 僅限於標准文件句柄上可用的方法或屬性。"

#: ../../library/unittest.mock.rst:2454
#, fuzzy
msgid ""
"*read_data* is a string for the :meth:`~io.IOBase.read`, :meth:`~io.IOBase."
"readline`, and :meth:`~io.IOBase.readlines` methods of the file handle to "
"return.  Calls to those methods will take data from *read_data* until it is "
"depleted.  The mock of these methods is pretty simplistic: every time the "
"*mock* is called, the *read_data* is rewound to the start.  If you need more "
"control over the data that you are feeding to the tested code you will need "
"to customize this mock for yourself.  When that is insufficient, one of the "
"in-memory filesystem packages on `PyPI <https://pypi.org>`_ can offer a "
"realistic filesystem for testing."
msgstr ""
"*read_data* 是文件句柄的 :meth:`~io.IOBase.read`、:meth:`~io.IOBase.readline`"
" 和 :meth:`~io.IOBase.readlines` 方法的字串回傳。對這些方法的呼叫將從 "
"*read_data* 中獲取資料，直到它被耗盡。這些方法的模擬非常簡單：每次呼叫 *mock*"
" 時，*read_data* 都會倒回到開頭。如果您需要對提供給測試程式碼的資料進行更多控"
"制，則需要為自己自定義此模擬。當這還不夠時，`PyPI <https://pypi.org>`_ "
"上的記憶體文件系統包之一可以提供用於測試的真實文件系統。"

#: ../../library/unittest.mock.rst:2464
#, fuzzy
msgid ""
"Added :meth:`~io.IOBase.readline` and :meth:`~io.IOBase.readlines` support. "
"The mock of :meth:`~io.IOBase.read` changed to consume *read_data* rather "
"than returning it on each call."
msgstr ""
"新增 :meth:`~io.IOBase.readline` 和 :meth:`~io.IOBase.readlines` 支援。 "
":meth:`~io.IOBase.read` 的模擬更改為使用 *read_data* "
"而不是在每次呼叫時回傳它。"

#: ../../library/unittest.mock.rst:2469
#, fuzzy
msgid "*read_data* is now reset on each call to the *mock*."
msgstr "*read_data* 現在在每次呼叫 *mock* 時重置。"

#: ../../library/unittest.mock.rst:2472
#, fuzzy
msgid ""
"Added :meth:`__iter__` to implementation so that iteration (such as in for "
"loops) correctly consumes *read_data*."
msgstr "在實作中新增了 :meth:`__iter__` 以便疊代（例如在 for 循環中）正確使用 "
"*read_data*。"

#: ../../library/unittest.mock.rst:2476
#, fuzzy
msgid ""
"Using :func:`open` as a context manager is a great way to ensure your file "
"handles are closed properly and is becoming common::"
msgstr "使用 :func:`open` "
"作為上下文管理器是確保正確關閉文件句柄的好方法，並且正在變得普遍::"

#: ../../library/unittest.mock.rst:2482
#, fuzzy
msgid ""
"The issue is that even if you mock out the call to :func:`open` it is the "
"*returned object* that is used as a context manager (and has :meth:"
"`__enter__` and :meth:`__exit__` called)."
msgstr ""
"問題是，即使您模擬了對 :func:`open` 的呼叫，它也是用作上下文管理器的 "
"*回傳物件*（並且呼叫了 :meth:`__enter__` 和 :meth:`__exit__`） ."

#: ../../library/unittest.mock.rst:2486
#, fuzzy
msgid ""
"Mocking context managers with a :class:`MagicMock` is common enough and "
"fiddly enough that a helper function is useful. ::"
msgstr "使用 :class:`MagicMock` "
"模擬上下文管理器非常普遍和繁瑣，以至於輔助函式很有用。 ::"

#: ../../library/unittest.mock.rst:2503
#, fuzzy
msgid "And for reading files::"
msgstr "並用於讀取文件::"

#: ../../library/unittest.mock.rst:2516
#, fuzzy
msgid "Autospeccing"
msgstr "自動指定"

#: ../../library/unittest.mock.rst:2518
#, fuzzy
msgid ""
"Autospeccing is based on the existing :attr:`spec` feature of mock. It "
"limits the api of mocks to the api of an original object (the spec), but it "
"is recursive (implemented lazily) so that attributes of mocks only have the "
"same api as the attributes of the spec. In addition mocked functions / "
"methods have the same call signature as the original so they raise a :exc:"
"`TypeError` if they are called incorrectly."
msgstr ""
"Autospeccing 基於 mock 的現有 :attr:`spec` 特性。它將模擬的 api "
"限制為原始物件（規範）的 api，但它是遞迴的（延遲實作），"
"因此模擬的屬性僅具有與規範的屬性相同的 api。此外，模擬函式/方法與原始函式/方"
"法具有相同的呼叫簽名，因此如果呼叫不正確，它們會引發 :exc:`TypeError`。"

#: ../../library/unittest.mock.rst:2525
#, fuzzy
msgid "Before I explain how auto-speccing works, here's why it is needed."
msgstr "在我解釋自動指定如何工作之前，這裡是需要它的原因。"

#: ../../library/unittest.mock.rst:2527
#, fuzzy
msgid ""
":class:`Mock` is a very powerful and flexible object, but it suffers from "
"two flaws when used to mock out objects from a system under test. One of "
"these flaws is specific to the :class:`Mock` api and the other is a more "
"general problem with using mock objects."
msgstr ""
":class:`Mock` "
"是一個非常強大和靈活的物件，但在用於從被測系統模擬物件時存在兩個缺陷。"
"其中一個缺陷是 :class:`Mock` api 特有的，另一個是使用模擬物件的更普遍的問題。"

#: ../../library/unittest.mock.rst:2532
#, fuzzy
msgid ""
"First the problem specific to :class:`Mock`. :class:`Mock` has two assert "
"methods that are extremely handy: :meth:`~Mock.assert_called_with` and :meth:"
"`~Mock.assert_called_once_with`."
msgstr ""
"首先是 :class:`Mock` 特有的問題。 :class:`Mock` "
"有兩個非常方便的斷言方法：:meth:`~Mock.assert_called_with` 和 :meth:`~Mock."
"assert_called_once_with`。"

#: ../../library/unittest.mock.rst:2545
#, fuzzy
msgid ""
"Because mocks auto-create attributes on demand, and allow you to call them "
"with arbitrary arguments, if you misspell one of these assert methods then "
"your assertion is gone:"
msgstr "因為模擬會根據需要自動建立屬性，並允許您使用任意參數呼叫它們，所以如果您拼錯"
"了這些斷言方法之一，那麼您的斷言就會消失："

#: ../../library/unittest.mock.rst:2555
#, fuzzy
msgid "Your tests can pass silently and incorrectly because of the typo."
msgstr "由於拼寫錯誤，您的測試可能會悄無聲息地錯誤地通過。"

#: ../../library/unittest.mock.rst:2557
#, fuzzy
msgid ""
"The second issue is more general to mocking. If you refactor some of your "
"code, rename members and so on, any tests for code that is still using the "
"*old api* but uses mocks instead of the real objects will still pass. This "
"means your tests can all pass even though your code is broken."
msgstr ""
"第二個問題對嘲笑更為普遍。如果你重構你的一些程式碼，重命名成員等等，任何仍然"
"使用*舊 api* 但使用模擬而不是真實物件的程式碼測試仍然會通過。這意味著即使您的"
"程式碼被破壞，您的測試也可以全部通過。"

#: ../../library/unittest.mock.rst:2562
#, fuzzy
msgid ""
"Note that this is another reason why you need integration tests as well as "
"unit tests. Testing everything in isolation is all fine and dandy, but if "
"you don't test how your units are \"wired together\" there is still lots of "
"room for bugs that tests might have caught."
msgstr ""
"請注意，這是您需要集成測試和單元測試的另一個原因。孤立地測試所有東西都很好而"
"且花花公子，但是如果你不測試你的單元是如何“連接在一起”的，那麼測試可能發現的"
"錯誤仍然有很大的空間。"

#: ../../library/unittest.mock.rst:2567
#, fuzzy
msgid ""
":mod:`mock` already provides a feature to help with this, called speccing. "
"If you use a class or instance as the :attr:`spec` for a mock then you can "
"only access attributes on the mock that exist on the real class:"
msgstr ""
":mod:`mock` 已經提供了一個功能來幫助解決這個問題，稱為 speccing。"
"如果您使用類或實例作為 mock 的 :attr:`spec`，那麼您只能訪問真實類中存在的 "
"mock 上的屬性："

#: ../../library/unittest.mock.rst:2578
#, fuzzy
msgid ""
"The spec only applies to the mock itself, so we still have the same issue "
"with any methods on the mock:"
msgstr "該規範僅適用於 mock 本身，因此我們對 mock 上的任何方法仍然存在相同的問題："

#: ../../library/unittest.mock.rst:2587
#, fuzzy
msgid ""
"Auto-speccing solves this problem. You can either pass ``autospec=True`` to :"
"func:`patch` / :func:`patch.object` or use the :func:`create_autospec` "
"function to create a mock with a spec. If you use the ``autospec=True`` "
"argument to :func:`patch` then the object that is being replaced will be "
"used as the spec object. Because the speccing is done \"lazily\" (the spec "
"is created as attributes on the mock are accessed) you can use it with very "
"complex or deeply nested objects (like modules that import modules that "
"import modules) without a big performance hit."
msgstr ""
"自動指定解決了這個問題。您可以將 ``autospec=True`` 傳遞給 :func:`patch` / "
":func:`patch.object` 或使用 :func:`create_autospec` 函式建立帶有規範的模擬。"
"如果您對 :func:`patch` 使用 ``autospec=True`` "
"參數，那麼被替換的物件將用作規範物件。因為規範是“延遲”完成的（規範是在訪問 "
"mock 上的屬性時建立的），您可以將它用於非常複雜或深度嵌套的物件（例如導入模組"
"的模組導入模組）而不會造成很大的性能損失。"

#: ../../library/unittest.mock.rst:2596
#, fuzzy
msgid "Here's an example of it in use::"
msgstr "這是一個使用中的例子::"

#: ../../library/unittest.mock.rst:2606
#, fuzzy
msgid ""
"You can see that :class:`request.Request` has a spec. :class:`request."
"Request` takes two arguments in the constructor (one of which is *self*). "
"Here's what happens if we try to call it incorrectly::"
msgstr ""
"你可以看到 :class:`request.Request` 有一個規範。 :class:`request.Request` "
"在構造函式中接受兩個參數（其中一個是 "
"*self*）。如果我們嘗試錯誤地呼叫它，會發生以下情況："

#: ../../library/unittest.mock.rst:2615
#, fuzzy
msgid ""
"The spec also applies to instantiated classes (i.e. the return value of "
"specced mocks)::"
msgstr "該規範也適用於實例化類（即指定模擬的回傳值）::"

#: ../../library/unittest.mock.rst:2622
#, fuzzy
msgid ""
":class:`Request` objects are not callable, so the return value of "
"instantiating our mocked out :class:`request.Request` is a non-callable "
"mock. With the spec in place any typos in our asserts will raise the correct "
"error::"
msgstr ""
":class:`Request` 物件不可呼叫，因此實例化我們模擬的回傳值 :class:`request."
"Request` "
"是不可呼叫的模擬。有了規範，我們斷言中的任何拼寫錯誤都會引發正確的錯誤::"

#: ../../library/unittest.mock.rst:2634
#, fuzzy
msgid ""
"In many cases you will just be able to add ``autospec=True`` to your "
"existing :func:`patch` calls and then be protected against bugs due to typos "
"and api changes."
msgstr ""
"在許多情況下，您只需將 ``autospec=True`` 新增到現有的 :func:`patch` 呼叫中，"
"然後就可以防止由於拼寫錯誤和 api 更改而導致的錯誤。"

#: ../../library/unittest.mock.rst:2638
#, fuzzy
msgid ""
"As well as using *autospec* through :func:`patch` there is a :func:"
"`create_autospec` for creating autospecced mocks directly:"
msgstr ""
"除了通過 :func:`patch` 使用 *autospec* 之外，還有一個 :func:`create_autospec`"
" 用於直接建立 autospecced 模擬："

#: ../../library/unittest.mock.rst:2646
#, fuzzy
msgid ""
"This isn't without caveats and limitations however, which is why it is not "
"the default behaviour. In order to know what attributes are available on the "
"spec object, autospec has to introspect (access attributes) the spec. As you "
"traverse attributes on the mock a corresponding traversal of the original "
"object is happening under the hood. If any of your specced objects have "
"properties or descriptors that can trigger code execution then you may not "
"be able to use autospec. On the other hand it is much better to design your "
"objects so that introspection is safe [#]_."
msgstr ""
"然而，這並非沒有警告和限制，這就是為什麼它不是預設行為的原因。為了知道規範對"
"像上有哪些屬性可用，autospec 必須內省（訪問屬性）規範。當您遍歷 mock 上的屬性"
"時，原始物件的相應遍歷正在發生。如果您指定的任何物件具有可以觸發程式碼執行的"
"屬性或描述器，那麼您可能無法使用自動指定。另一方面，最好設計你的物件，"
"這樣內省是安全的 [#]_。"

#: ../../library/unittest.mock.rst:2655
#, fuzzy
msgid ""
"A more serious problem is that it is common for instance attributes to be "
"created in the :meth:`__init__` method and not to exist on the class at all. "
"*autospec* can't know about any dynamically created attributes and restricts "
"the api to visible attributes. ::"
msgstr ""
"一個更嚴重的問題是實例屬性在 :meth:`__init__` "
"方法中建立並且根本不存在於類中是很常見的。 *autospec* "
"無法了解任何動態建立的屬性並將 api 限制為可見屬性。 ::"

#: ../../library/unittest.mock.rst:2672
#, fuzzy
msgid ""
"There are a few different ways of resolving this problem. The easiest, but "
"not necessarily the least annoying, way is to simply set the required "
"attributes on the mock after creation. Just because *autospec* doesn't allow "
"you to fetch attributes that don't exist on the spec it doesn't prevent you "
"setting them::"
msgstr ""
"有幾種不同的方法可以解決這個問題。"
"最簡單但不一定最煩人的方法是在建立後簡單地在 mock 上設定所需的屬性。僅僅因為 "
"*autospec* 不允許您獲取規範中不存在的屬性，它不會阻止您設定它們::"

#: ../../library/unittest.mock.rst:2683
#, fuzzy
msgid ""
"There is a more aggressive version of both *spec* and *autospec* that *does* "
"prevent you setting non-existent attributes. This is useful if you want to "
"ensure your code only *sets* valid attributes too, but obviously it prevents "
"this particular scenario:"
msgstr ""
"*spec* 和 *autospec* 都有一個更激進的版本，它 *does* 阻止您設定不存在的屬性。"
"如果你想確保你的程式碼也只*設定*有效屬性，這很有用，但顯然它可以防止這種特殊"
"情況："

#: ../../library/unittest.mock.rst:2696
#, fuzzy
msgid ""
"Probably the best way of solving the problem is to add class attributes as "
"default values for instance members initialised in :meth:`__init__`. Note "
"that if you are only setting default attributes in :meth:`__init__` then "
"providing them via class attributes (shared between instances of course) is "
"faster too. e.g."
msgstr ""
"解決該問題的最佳方法可能是為在 :meth:`__init__` "
"中初始化的實例成員新增類屬性作為預設值。請注意，如果您僅在 :meth:`__init__` "
"中設定預設屬性，那麼通過類屬性（當然在實例之間共享）提供它們也會更快。例如"

#: ../../library/unittest.mock.rst:2706
#, fuzzy
msgid ""
"This brings up another issue. It is relatively common to provide a default "
"value of ``None`` for members that will later be an object of a different "
"type. ``None`` would be useless as a spec because it wouldn't let you access "
"*any* attributes or methods on it. As ``None`` is *never* going to be useful "
"as a spec, and probably indicates a member that will normally of some other "
"type, autospec doesn't use a spec for members that are set to ``None``. "
"These will just be ordinary mocks (well - MagicMocks):"
msgstr ""
"這就引出了另一個問題。為稍後將成為不同型別物件的成員提供預設值 ``None`` 是相對常見"
"的。 ``None`` 作為規範是無用的，因為它不會讓您訪問它的*任何*屬性或方法。由於 "
"``None`` *永遠*不會*用作規範，並且可能表示通常屬於其他型別的成員，autospec "
"不會對設定為 ``None`` 的成員使用規範。這些只是普通的模擬（好吧 - "
"MagicMocks）："

#: ../../library/unittest.mock.rst:2721
#, fuzzy
msgid ""
"If modifying your production classes to add defaults isn't to your liking "
"then there are more options. One of these is simply to use an instance as "
"the spec rather than the class. The other is to create a subclass of the "
"production class and add the defaults to the subclass without affecting the "
"production class. Both of these require you to use an alternative object as "
"the spec. Thankfully :func:`patch` supports this - you can simply pass the "
"alternative object as the *autospec* argument::"
msgstr ""
"如果您不喜歡修改生產類以新增預設值，那麼還有更多選擇。其中之一就是簡單地使用"
"實例作為規範而不是類。另一種是建立生產類的子類別，在不影響生產類的情況下，將"
"預設值新增到子類別中。這兩個都要求您使用替代物件作為規範。值得慶幸的是 "
":func:`patch` 支援這個 - 你可以簡單地將替代物件作為 *autospec* 參數傳遞::"

#: ../../library/unittest.mock.rst:2742
#, fuzzy
msgid ""
"This only applies to classes or already instantiated objects. Calling a "
"mocked class to create a mock instance *does not* create a real instance. It "
"is only attribute lookups - along with calls to :func:`dir` - that are done."
msgstr ""
"這僅適用於類或已經實例化的物件。呼叫模擬類來建立模擬實例*不會*建立真實實例。"
"它只是屬性查找 - 以及對 :func:`dir` 的呼叫 - 已經完成。"

#: ../../library/unittest.mock.rst:2747
#, fuzzy
msgid "Sealing mocks"
msgstr "密封模擬"

#: ../../library/unittest.mock.rst:2756
#, fuzzy
msgid ""
"Seal will disable the automatic creation of mocks when accessing an "
"attribute of the mock being sealed or any of its attributes that are already "
"mocks recursively."
msgstr "當訪問被密封的模擬的屬性或其任何已經遞迴模擬的屬性時，Seal "
"將禁用模擬的自動建立。"

#: ../../library/unittest.mock.rst:2759
#, fuzzy
msgid ""
"If a mock instance with a name or a spec is assigned to an attribute it "
"won't be considered in the sealing chain. This allows one to prevent seal "
"from fixing part of the mock object. ::"
msgstr "如果將具有名稱或規範的模擬實例分配給屬性，則不會在密封鏈中考慮該屬性。這樣可"
"以防止印章固定模擬物件的一部分。 ::"

#~ msgid "``__getformat__`` and ``__setformat__``"
#~ msgstr "``__getformat__`` 和 ``__setformat__``"
