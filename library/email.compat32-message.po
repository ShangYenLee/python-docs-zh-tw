# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-31 08:13+0000\n"
"PO-Revision-Date: 2018-07-15 18:56+0800\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/email.compat32-message.rst:4
msgid ""
":mod:`email.message.Message`: Representing an email message using the :data:"
"`~email.policy.compat32` API"
msgstr ""
":mod:`email.message.Message`: 使用 :data:`~email.policy.compat32` API "
"表示電子郵件訊息"

#: ../../library/email.compat32-message.rst:12
#, fuzzy
msgid ""
"The :class:`Message` class is very similar to the :class:`~email.message."
"EmailMessage` class, without the methods added by that class, and with the "
"default behavior of certain other methods being slightly different.  We also "
"document here some methods that, while supported by the :class:`~email."
"message.EmailMessage` class, are not recommended unless you are dealing with "
"legacy code."
msgstr ""
":class:`Message` 類與 :class:`~email.message.EmailMessage` 類非常相似，沒有該"
"類新增的方法，並且某些其他方法的預設行為略有不同。我們還在這裡記錄了一些方法"
"，雖然 :class:`~email.message.EmailMessage` "
"類支援這些方法，但不推薦使用這些方法，除非您正在處理遺留程式碼。"

#: ../../library/email.compat32-message.rst:19
#, fuzzy
msgid "The philosophy and structure of the two classes is otherwise the same."
msgstr "這兩個類的理念和結構在其他方面是相同的。"

#: ../../library/email.compat32-message.rst:21
#, fuzzy
msgid ""
"This document describes the behavior under the default (for :class:"
"`Message`) policy :attr:`~email.policy.Compat32`.  If you are going to use "
"another policy, you should be using the :class:`~email.message.EmailMessage` "
"class instead."
msgstr ""
"本文檔描述了預設（對於 :class:`Message`）策略 :attr:`~email.policy.Compat32` "
"下的行為。如果您要使用其他策略，則應該改用 :class:`~email.message."
"EmailMessage` 類。"

#: ../../library/email.compat32-message.rst:25
#, fuzzy
msgid ""
"An email message consists of *headers* and a *payload*.  Headers must be :"
"rfc:`5322` style names and values, where the field name and value are "
"separated by a colon.  The colon is not part of either the field name or the "
"field value.  The payload may be a simple text message, or a binary object, "
"or a structured sequence of sub-messages each with their own set of headers "
"and their own payload.  The latter type of payload is indicated by the "
"message having a MIME type such as :mimetype:`multipart/\\*` or :mimetype:"
"`message/rfc822`."
msgstr ""
"一封電子郵件由 *headers* 和 *payload* 組成。標頭必須是 :rfc:`5322` 樣式名稱和"
"值，其中欄位名稱和值由冒號分隔。冒號不是欄位名稱或欄位值的一部分。有效負載可"
"以是簡單的文本消息，或二進位物件，或結構化的子消息序列，每個子消息都有自己的"
"一組標頭和自己的有效負載。後一種型別的有效負載由具有 MIME 型別的消息指示，"
"例如 :mimetype:`multipart/\\*` 或 :mimetype:`message/rfc822`。"

#: ../../library/email.compat32-message.rst:34
#, fuzzy
msgid ""
"The conceptual model provided by a :class:`Message` object is that of an "
"ordered dictionary of headers with additional methods for accessing both "
"specialized information from the headers, for accessing the payload, for "
"generating a serialized version of the message, and for recursively walking "
"over the object tree.  Note that duplicate headers are supported but special "
"methods must be used to access them."
msgstr ""
":class:`Message` 物件提供的概念模型是一個有序的標頭字典，帶有額外的方法，用於"
"訪問標頭中的專門資訊、訪問負載、生成消息的序列化版本以及遞迴遍歷物件樹。請注"
"意，支援重複標頭，但必須使用特殊方法來訪問它們。"

#: ../../library/email.compat32-message.rst:41
#, fuzzy
msgid ""
"The :class:`Message` pseudo-dictionary is indexed by the header names, which "
"must be ASCII values.  The values of the dictionary are strings that are "
"supposed to contain only ASCII characters; there is some special handling "
"for non-ASCII input, but it doesn't always produce the correct results.  "
"Headers are stored and returned in case-preserving form, but field names are "
"matched case-insensitively.  There may also be a single envelope header, "
"also known as the *Unix-From* header or the ``From_`` header.  The *payload* "
"is either a string or bytes, in the case of simple message objects, or a "
"list of :class:`Message` objects, for MIME container documents (e.g. :"
"mimetype:`multipart/\\*` and :mimetype:`message/rfc822`)."
msgstr ""
":class:`Message` 偽字典由標頭名稱索引，標頭名稱必須是 ASCII 值。"
"字典的值是應該只包含 ASCII 字元的字串；對非 ASCII 輸入有一些特殊處理，但它並"
"不總是產生正確的結果。標題以保留大小寫的形式儲存和回傳，但欄位名稱匹配時不區"
"分大小寫。也可能有一個信封標頭，也稱為 *Unix-From* 標頭或 ``From_`` "
"標頭。在簡單消息物件的情況下，*payload* 可以是字串或位元組，對於 MIME "
"容器文檔（例如 :mimetype:`multipart/\\*` 和 :mimetype: `消息/rfc822`）。"

#: ../../library/email.compat32-message.rst:52
#, fuzzy
msgid "Here are the methods of the :class:`Message` class:"
msgstr "以下是 Message 類的方法："

#: ../../library/email.compat32-message.rst:57
#, fuzzy
msgid ""
"If *policy* is specified (it must be an instance of a :mod:`~email.policy` "
"class) use the rules it specifies to update and serialize the representation "
"of the message.  If *policy* is not set, use the :class:`compat32 <email."
"policy.Compat32>` policy, which maintains backward compatibility with the "
"Python 3.2 version of the email package.  For more information see the :mod:"
"`~email.policy` documentation."
msgstr ""
"如果指定了 *policy*（它必須是 :mod:`~email.policy` "
"類的一個實例）使用它指定的規則來更新和序列化消息的表示。如果未設定 *policy*，"
"請使用 :class:`compat32 <email.policy.Compat32>` 策略，它保持與電子郵件包的 "
"Python 3.2 版本的向後相容性。有關詳細資訊，請參閱 :mod:`~email.policy` 文檔。"

#: ../../library/email.compat32-message.rst:64
msgid "The *policy* keyword argument was added."
msgstr "新增 *policy* 關鍵字引數。"

#: ../../library/email.compat32-message.rst:69
#, fuzzy
msgid ""
"Return the entire message flattened as a string.  When optional *unixfrom* "
"is true, the envelope header is included in the returned string. *unixfrom* "
"defaults to ``False``.  For backward compatibility reasons, *maxheaderlen* "
"defaults to ``0``, so if you want a different value you must override it "
"explicitly (the value specified for *max_line_length* in the policy will be "
"ignored by this method).  The *policy* argument may be used to override the "
"default policy obtained from the message instance. This can be used to "
"control some of the formatting produced by the method, since the specified "
"*policy* will be passed to the ``Generator``."
msgstr ""
"回傳扁平化為字串的整個消息。當可選的 *unixfrom* "
"為真時，信封標頭包含在回傳的字串中。 *unixfrom* 預設為 "
"``False``。出於向後相容的原因，*maxheaderlen* "
"預設為 ``0``，因此如果您想要一個不同的值，則必須顯式覆蓋它（"
"此方法將忽略策略中為 *max_line_length* 指定的值）。 *policy* 參數可用於覆蓋從"
"消息實例獲得的預設策略。這可用於控制該方法生成的一些格式，因為指定的*策略*將"
"傳遞給“生成器”。"

#: ../../library/email.compat32-message.rst:79
#: ../../library/email.compat32-message.rst:121
#, fuzzy
msgid ""
"Flattening the message may trigger changes to the :class:`Message` if "
"defaults need to be filled in to complete the transformation to a string "
"(for example, MIME boundaries may be generated or modified)."
msgstr "如果需要填充預設值以完成到字串的轉換（例如，可能會生成或修改 MIME 邊界），"
"則扁平化消息可能會觸發對 Message 的更改。"

#: ../../library/email.compat32-message.rst:83
#, fuzzy
msgid ""
"Note that this method is provided as a convenience and may not always format "
"the message the way you want.  For example, by default it does not do the "
"mangling of lines that begin with ``From`` that is required by the Unix mbox "
"format.  For more flexibility, instantiate a :class:`~email.generator."
"Generator` instance and use its :meth:`~email.generator.Generator.flatten` "
"method directly.  For example::"
msgstr ""
"請注意，此方法是為方便起見而提供的，可能並不總是按照您想要的方式格式化消息。"
"例如，預設情況下，它不會對以 ``From`` 開頭的行進行處理，這是 Unix mbox "
"格式所要求的。為了更靈活，實例化一個 :class:`~email.generator.Generator` "
"實例並直接使用它的 :meth:`~email.generator.Generator.flatten` 方法。例如：："

#: ../../library/email.compat32-message.rst:97
#, fuzzy
msgid ""
"If the message object contains binary data that is not encoded according to "
"RFC standards, the non-compliant data will be replaced by unicode \"unknown "
"character\" code points.  (See also :meth:`.as_bytes` and :class:`~email."
"generator.BytesGenerator`.)"
msgstr ""
"如果消息物件包含未根據 RFC 標準編碼的二進位資料，"
"則不符合標準的資料將被替換為 unicode“未知字元”程式碼點。 （另見 :meth:`."
"as_bytes` 和 :class:`~email.generator.BytesGenerator`。）"

#: ../../library/email.compat32-message.rst:102
msgid "the *policy* keyword argument was added."
msgstr "新增 *policy* 關鍵字引數。"

#: ../../library/email.compat32-message.rst:107
#, fuzzy
msgid ""
"Equivalent to :meth:`.as_string()`.  Allows ``str(msg)`` to produce a string "
"containing the formatted message."
msgstr "相當於 :meth:`.as_string()`。允許 ``str(msg)`` 生成包含格式化消息的字串。"

#: ../../library/email.compat32-message.rst:113
#, fuzzy
msgid ""
"Return the entire message flattened as a bytes object.  When optional "
"*unixfrom* is true, the envelope header is included in the returned string.  "
"*unixfrom* defaults to ``False``.  The *policy* argument may be used to "
"override the default policy obtained from the message instance. This can be "
"used to control some of the formatting produced by the method, since the "
"specified *policy* will be passed to the ``BytesGenerator``."
msgstr ""
"回傳扁平化為位元組物件的整個消息。當可選的 *unixfrom* "
"為真時，信封標頭包含在回傳的字串中。 *unixfrom* 預設為 ``False``。 *policy* "
"參數可用於覆蓋從消息實例獲得的預設策略。這可用於控制該方法生成的一些格式，"
"因為指定的 *policy* 將傳遞給 ``BytesGenerator``。"

#: ../../library/email.compat32-message.rst:125
#, fuzzy
msgid ""
"Note that this method is provided as a convenience and may not always format "
"the message the way you want.  For example, by default it does not do the "
"mangling of lines that begin with ``From`` that is required by the Unix mbox "
"format.  For more flexibility, instantiate a :class:`~email.generator."
"BytesGenerator` instance and use its :meth:`~email.generator.BytesGenerator."
"flatten` method directly. For example::"
msgstr ""
"請注意，此方法是為方便起見而提供的，可能並不總是按照您想要的方式格式化消息。"
"例如，預設情況下，它不會對以 ``From`` 開頭的行進行處理，這是 Unix mbox "
"格式所要求的。為了更靈活，實例化一個 :class:`~email.generator.BytesGenerator` "
"實例並直接使用它的 :meth:`~email.generator.BytesGenerator.flatten` "
"方法。例如：："

#: ../../library/email.compat32-message.rst:145
#, fuzzy
msgid ""
"Equivalent to :meth:`.as_bytes()`.  Allows ``bytes(msg)`` to produce a bytes "
"object containing the formatted message."
msgstr "相當於 :meth:`.as_bytes()`。允許 ``bytes(msg)`` "
"生成包含格式化消息的位元組物件。"

#: ../../library/email.compat32-message.rst:153
#, fuzzy
msgid ""
"Return ``True`` if the message's payload is a list of sub-\\ :class:"
"`Message` objects, otherwise return ``False``.  When :meth:`is_multipart` "
"returns ``False``, the payload should be a string object (which might be a "
"CTE encoded binary payload).  (Note that :meth:`is_multipart` returning "
"``True`` does not necessarily mean that \"msg.get_content_maintype() == "
"'multipart'\" will return the ``True``. For example, ``is_multipart`` will "
"return ``True`` when the :class:`Message` is of type ``message/rfc822``.)"
msgstr ""
"如果消息的有效負載是子\\ :class:`Message` 物件的列表，則回傳 ``True``，"
"否則回傳 ``False``。當 :meth:`is_multipart` 回傳 ``False`` "
"時，負載應該是一個字串物件（它可能是一個 CTE 編碼的二進位負載）。 "
"（請注意 :meth:`is_multipart` 回傳 ``True`` 並不一定意味著“msg."
"get_content_maintype() == 'multipart'”將回傳 ``True``。例如，``is_multipart``"
" 將當 Message 的型別為 ``message/rfc822`` 時回傳 ``True``。）"

#: ../../library/email.compat32-message.rst:165
#, fuzzy
msgid ""
"Set the message's envelope header to *unixfrom*, which should be a string."
msgstr "將消息的信封標頭設定為 *unixfrom*，這應該是一個字串。"

#: ../../library/email.compat32-message.rst:170
#, fuzzy
msgid ""
"Return the message's envelope header.  Defaults to ``None`` if the envelope "
"header was never set."
msgstr "回傳消息的信封頭。如果從未設定信封標頭，則預設為 ``None`` 。"

#: ../../library/email.compat32-message.rst:176
#, fuzzy
msgid ""
"Add the given *payload* to the current payload, which must be ``None`` or a "
"list of :class:`Message` objects before the call. After the call, the "
"payload will always be a list of :class:`Message` objects.  If you want to "
"set the payload to a scalar object (e.g. a string), use :meth:`set_payload` "
"instead."
msgstr ""
"將給定的 *payload* 新增到當前的 payload 中，在呼叫之前它必須是 ``None`` 或 "
":class:`Message` 物件的列表。呼叫之後，有效載荷將始終是一個 Message "
"物件列表。如果您想將有效負載設定為標量物件（例如字串），請改用 "
":meth:`set_payload`。"

#: ../../library/email.compat32-message.rst:182
#, fuzzy
msgid ""
"This is a legacy method.  On the :class:`~email.emailmessage.EmailMessage` "
"class its functionality is replaced by :meth:`~email.message.EmailMessage."
"set_content` and the related ``make`` and ``add`` methods."
msgstr ""
"這是一種遺留方法。在 :class:`~email.emailmessage.EmailMessage` 類中，"
"它的功能被 :meth:`~email.message.EmailMessage.set_content` 和相關的 ``make`` "
"和 ``add`` 方法所取代。"

#: ../../library/email.compat32-message.rst:190
#, fuzzy
msgid ""
"Return the current payload, which will be a list of :class:`Message` objects "
"when :meth:`is_multipart` is ``True``, or a string when :meth:`is_multipart` "
"is ``False``.  If the payload is a list and you mutate the list object, you "
"modify the message's payload in place."
msgstr ""
"回傳當前有效負載，當 is_multipart 為 True 時，它將是一個 Message 物件列表，"
"當 is_multipart 為 False 時，它將是一個字串。如果有效載荷是一個列表並且您改變"
"了列表物件，則您就地修改了消息的有效載荷。"

#: ../../library/email.compat32-message.rst:195
#, fuzzy
msgid ""
"With optional argument *i*, :meth:`get_payload` will return the *i*-th "
"element of the payload, counting from zero, if :meth:`is_multipart` is "
"``True``.  An :exc:`IndexError` will be raised if *i* is less than 0 or "
"greater than or equal to the number of items in the payload.  If the payload "
"is a string (i.e.  :meth:`is_multipart` is ``False``) and *i* is given, a :"
"exc:`TypeError` is raised."
msgstr ""
"使用可選參數 *i*，如果 is_multipart 為 True，則 get_payload 將回傳負載的第 i*"
" 個元素，從零開始計數。如果 *i* 小於 0 或大於或等於有效負載中的項目數，"
"將引發 :exc:`IndexError`。如果有效負載是一個字串（即 :meth:`is_multipart` 是 "
"``False``）並且給出了 *i*，則會引發 :exc:`TypeError`。"

#: ../../library/email.compat32-message.rst:202
#, fuzzy
msgid ""
"Optional *decode* is a flag indicating whether the payload should be decoded "
"or not, according to the :mailheader:`Content-Transfer-Encoding` header. "
"When ``True`` and the message is not a multipart, the payload will be "
"decoded if this header's value is ``quoted-printable`` or ``base64``. If "
"some other encoding is used, or :mailheader:`Content-Transfer-Encoding` "
"header is missing, the payload is returned as-is (undecoded).  In all cases "
"the returned value is binary data.  If the message is a multipart and the "
"*decode* flag is ``True``, then ``None`` is returned.  If the payload is "
"base64 and it was not perfectly formed (missing padding, characters outside "
"the base64 alphabet), then an appropriate defect will be added to the "
"message's defect property (:class:`~email.errors.InvalidBase64PaddingDefect` "
"or :class:`~email.errors.InvalidBase64CharactersDefect`, respectively)."
msgstr ""
"可選的 *decode* 是一個旗標，指示是否應根據 :mailheader:`Content-Transfer-"
"Encoding` 標頭對有效負載進行解碼。當 ``True`` 且消息不是多部分時，"
"如果此標頭的值為 ``quoted-printable`` 或 "
"``base64``，則有效負載將被解碼。如果使用了一些其他編碼，或者 :mailheader"
":`Content-Transfer-Encoding` 標頭丟失，則有效負載按原樣回傳（未解碼）。在所有"
"情況下，回傳值都是二進位資料。如果消息是多部分的並且 *decode* "
"旗標為 ``True``，則回傳 ``None``。如果有效負載是 base64 且格式不完整（缺少填充，"
"base64 "
"字母表之外的字元），則將在消息的缺陷屬性中新增適當的缺陷（:class:`~email."
"errors.InvalidBase64PaddingDefect` 或 :class: `~email.errors."
"InvalidBase64CharactersDefect`）。"

#: ../../library/email.compat32-message.rst:216
#, fuzzy
msgid ""
"When *decode* is ``False`` (the default) the body is returned as a string "
"without decoding the :mailheader:`Content-Transfer-Encoding`.  However, for "
"a :mailheader:`Content-Transfer-Encoding` of 8bit, an attempt is made to "
"decode the original bytes using the ``charset`` specified by the :mailheader:"
"`Content-Type` header, using the ``replace`` error handler. If no "
"``charset`` is specified, or if the ``charset`` given is not recognized by "
"the email package, the body is decoded using the default ASCII charset."
msgstr ""
"當 *decode* 為 ``False``（預設值）時，正文將作為字串回傳，而不解碼 "
":mailheader:`Content-Transfer-Encoding`。但是，對於 8 位的 Content-Transfer-"
"Encoding，嘗試使用 Content-Type 標頭指定的 charset 解碼原始位元組，使用 "
"``替換``錯誤處理程式。如果未指定 ``charset``，"
"或者如果電子郵件包無法識別給定的 ``charset``，則使用預設的 ASCII "
"字元集對正文進行解碼。"

#: ../../library/email.compat32-message.rst:225
#, fuzzy
msgid ""
"This is a legacy method.  On the :class:`~email.emailmessage.EmailMessage` "
"class its functionality is replaced by :meth:`~email.message.EmailMessage."
"get_content` and :meth:`~email.message.EmailMessage.iter_parts`."
msgstr ""
"這是一種遺留方法。在 :class:`~email.emailmessage.EmailMessage` 類中，"
"它的功能被 :meth:`~email.message.EmailMessage.get_content` 和 :meth:`~email."
"message.EmailMessage.iter_parts` 取代。"

#: ../../library/email.compat32-message.rst:233
#, fuzzy
msgid ""
"Set the entire message object's payload to *payload*.  It is the client's "
"responsibility to ensure the payload invariants.  Optional *charset* sets "
"the message's default character set; see :meth:`set_charset` for details."
msgstr ""
"將整個消息物件的有效負載設定為 *payload*。確保有效載荷不變數是客戶的責任。"
"可選的 *charset* "
"設定消息的預設字元集；有關詳細資訊，請參閱 :meth:`set_charset`。"

#: ../../library/email.compat32-message.rst:237
#, fuzzy
msgid ""
"This is a legacy method.  On the :class:`~email.emailmessage.EmailMessage` "
"class its functionality is replaced by :meth:`~email.message.EmailMessage."
"set_content`."
msgstr ""
"這是一種遺留方法。在 :class:`~email.emailmessage.EmailMessage` 類中，"
"它的功能被 :meth:`~email.message.EmailMessage.set_content` 取代。"

#: ../../library/email.compat32-message.rst:244
#, fuzzy
msgid ""
"Set the character set of the payload to *charset*, which can either be a :"
"class:`~email.charset.Charset` instance (see :mod:`email.charset`), a string "
"naming a character set, or ``None``.  If it is a string, it will be "
"converted to a :class:`~email.charset.Charset` instance.  If *charset* is "
"``None``, the ``charset`` parameter will be removed from the :mailheader:"
"`Content-Type` header (the message will not be otherwise modified).  "
"Anything else will generate a :exc:`TypeError`."
msgstr ""
"將有效載荷的字元集設定為 *charset*，它可以是一個 :class:`~email.charset."
"Charset` 實例（參見 :mod:`email.charset`），一個命名字元集的字串，或者 ` "
"`無``。如果它是一個字串，它將被轉換為一個 :class:`~email.charset.Charset` "
"實例。如果 *charset* 為 ``None``，則 ``charset`` 參數將從 :mailheader"
":`Content-Type` 標頭中刪除（郵件不會以其他方式修改）。其他任何東西都會產生 "
":exc:`TypeError`。"

#: ../../library/email.compat32-message.rst:252
#, fuzzy
msgid ""
"If there is no existing :mailheader:`MIME-Version` header one will be "
"added.  If there is no existing :mailheader:`Content-Type` header, one will "
"be added with a value of :mimetype:`text/plain`.  Whether the :mailheader:"
"`Content-Type` header already exists or not, its ``charset`` parameter will "
"be set to *charset.output_charset*.   If *charset.input_charset* and "
"*charset.output_charset* differ, the payload will be re-encoded to the "
"*output_charset*.  If there is no existing :mailheader:`Content-Transfer-"
"Encoding` header, then the payload will be transfer-encoded, if needed, "
"using the specified :class:`~email.charset.Charset`, and a header with the "
"appropriate value will be added.  If a :mailheader:`Content-Transfer-"
"Encoding` header already exists, the payload is assumed to already be "
"correctly encoded using that :mailheader:`Content-Transfer-Encoding` and is "
"not modified."
msgstr ""
"如果不存在現有的 :mailheader:`MIME-Version` "
"標頭，將新增一個。如果不存在現有的:mailheader:`Content-Type` "
"標頭，將新增一個值為:mimetype:`text/plain` 的標頭。無論 :mailheader:`Content-"
"Type` 標頭是否已經存在，其 ``charset`` 參數都將設定為 *charset."
"output_charset*。如果 *charset.input_charset* 和 *charset.output_charset* "
"不同，有效負載將被重新編碼為 *output_charset*。如果不存在：mailheader"
":`Content-Transfer-Encoding` "
"標頭，則有效負載將被傳輸編碼，如果需要，使用指定的 :class:`~email.charset."
"Charset` 和帶有適當的標頭將增加價值。如果 :mailheader:`Content-Transfer-"
"Encoding` 標頭已經存在，則假定有效負載已使用該 :mailheader:`Content-Transfer-"
"Encoding` 正確編碼並且未被修改。"

#: ../../library/email.compat32-message.rst:266
#, fuzzy
msgid ""
"This is a legacy method.  On the :class:`~email.emailmessage.EmailMessage` "
"class its functionality is replaced by the *charset* parameter of the :meth:"
"`email.emailmessage.EmailMessage.set_content` method."
msgstr ""
"這是一種遺留方法。在 :class:`~email.emailmessage.EmailMessage` "
"類中，它的功能被 :meth:`email.emailmessage.EmailMessage.set_content` "
"方法的*charset* 參數取代。"

#: ../../library/email.compat32-message.rst:274
#, fuzzy
msgid ""
"Return the :class:`~email.charset.Charset` instance associated with the "
"message's payload."
msgstr "回傳與消息有效負載關聯的 :class:`~email.charset.Charset` 實例。"

#: ../../library/email.compat32-message.rst:277
#, fuzzy
msgid ""
"This is a legacy method.  On the :class:`~email.emailmessage.EmailMessage` "
"class it always returns ``None``."
msgstr "這是一種遺留方法。在 :class:`~email.emailmessage.EmailMessage` 類中，"
"它總是回傳 ``None``。"

#: ../../library/email.compat32-message.rst:282
#, fuzzy
msgid ""
"The following methods implement a mapping-like interface for accessing the "
"message's :rfc:`2822` headers.  Note that there are some semantic "
"differences between these methods and a normal mapping (i.e. dictionary) "
"interface.  For example, in a dictionary there are no duplicate keys, but "
"here there may be duplicate message headers.  Also, in dictionaries there is "
"no guaranteed order to the keys returned by :meth:`keys`, but in a :class:"
"`Message` object, headers are always returned in the order they appeared in "
"the original message, or were added to the message later.  Any header "
"deleted and then re-added are always appended to the end of the header list."
msgstr ""
"以下方法實作了一個類似映射的介面，用於訪問消息的 :rfc:`2822` 標頭。請注意，這"
"些方法與法線映射（即字典）介面之間存在一些語義差異。例如，字典中沒有重複的鍵"
"，但這裡可能有重複的消息頭。此外，在字典中，keys 回傳的鍵沒有保證的順序，"
"但在 Message 對像中，標頭總是按照它們在原始消息中出現的順序回傳，或者被新增到"
"消息稍後。刪除並重新新增的任何標頭始終附加到標頭列表的末尾。"

#: ../../library/email.compat32-message.rst:292
#, fuzzy
msgid ""
"These semantic differences are intentional and are biased toward maximal "
"convenience."
msgstr "這些語義差異是有意為之的，並且偏向於最大限度地方便。"

#: ../../library/email.compat32-message.rst:295
#, fuzzy
msgid ""
"Note that in all cases, any envelope header present in the message is not "
"included in the mapping interface."
msgstr "請注意，在所有情況下，消息中出現的任何信封標頭都不包含在映射介面中。"

#: ../../library/email.compat32-message.rst:298
#, fuzzy
msgid ""
"In a model generated from bytes, any header values that (in contravention of "
"the RFCs) contain non-ASCII bytes will, when retrieved through this "
"interface, be represented as :class:`~email.header.Header` objects with a "
"charset of ``unknown-8bit``."
msgstr ""
"在從位元組生成的模型中，任何（違反 RFC）包含非 ASCII "
"位元組的標頭值在通過此介面檢索時將表示為字元集為 :class:`~email.header."
"Header` 的物件``未知 8 位``。"

#: ../../library/email.compat32-message.rst:306
#, fuzzy
msgid "Return the total number of headers, including duplicates."
msgstr "回傳標頭總數，包括重複項。"

#: ../../library/email.compat32-message.rst:311
#, fuzzy
msgid ""
"Return ``True`` if the message object has a field named *name*. Matching is "
"done case-insensitively and *name* should not include the trailing colon. "
"Used for the ``in`` operator, e.g.::"
msgstr ""
"如果消息對像有一個名為 *name* 的欄位，則回傳 "
"``True``。匹配不區分大小寫，*name* 不應包含結尾的冒號。用於 ``in`` "
"運算符，例如：::"

#: ../../library/email.compat32-message.rst:321
#, fuzzy
msgid ""
"Return the value of the named header field.  *name* should not include the "
"colon field separator.  If the header is missing, ``None`` is returned; a :"
"exc:`KeyError` is never raised."
msgstr "回傳命名頭欄位的值。 *name* "
"不應包含冒號欄位分隔符。如果缺少標頭，則回傳 ``None`` ；永遠不會引發 "
":exc:`KeyError`。"

#: ../../library/email.compat32-message.rst:325
#, fuzzy
msgid ""
"Note that if the named field appears more than once in the message's "
"headers, exactly which of those field values will be returned is undefined.  "
"Use the :meth:`get_all` method to get the values of all the extant named "
"headers."
msgstr "請注意，如果命名欄位在消息的標頭中出現多次，則將回傳哪些欄位值是未定義的。"
"使用 :meth:`get_all` 方法獲取所有現存命名標頭的值。"

#: ../../library/email.compat32-message.rst:333
#, fuzzy
msgid ""
"Add a header to the message with field name *name* and value *val*.  The "
"field is appended to the end of the message's existing fields."
msgstr "使用欄位名稱 *name* 和值 *val* "
"向消息新增標頭。該欄位附加到消息現有欄位的末尾。"

#: ../../library/email.compat32-message.rst:336
#, fuzzy
msgid ""
"Note that this does *not* overwrite or delete any existing header with the "
"same name.  If you want to ensure that the new header is the only one "
"present in the message with field name *name*, delete the field first, e.g.::"
msgstr ""
"請注意，這 *不會* 覆蓋或刪除任何具有相同名稱的現有標頭。"
"如果要確保新標頭是消息中唯一具有欄位名稱 *name* "
"的標頭，請先刪除該欄位，例如：::"

#: ../../library/email.compat32-message.rst:346
#, fuzzy
msgid ""
"Delete all occurrences of the field with name *name* from the message's "
"headers.  No exception is raised if the named field isn't present in the "
"headers."
msgstr "從消息的標題中刪除名稱為 *name* "
"的所有欄位。如果標頭中不存在命名欄位，則不會引發例外。"

#: ../../library/email.compat32-message.rst:353
#, fuzzy
msgid "Return a list of all the message's header field names."
msgstr "回傳所有消息的標題欄位名稱的列表。"

#: ../../library/email.compat32-message.rst:358
#, fuzzy
msgid "Return a list of all the message's field values."
msgstr "回傳所有消息欄位值的列表。"

#: ../../library/email.compat32-message.rst:363
#, fuzzy
msgid ""
"Return a list of 2-tuples containing all the message's field headers and "
"values."
msgstr "回傳包含所有消息欄位標題和值的二元組列表。"

#: ../../library/email.compat32-message.rst:369
#, fuzzy
msgid ""
"Return the value of the named header field.  This is identical to :meth:"
"`__getitem__` except that optional *failobj* is returned if the named header "
"is missing (defaults to ``None``)."
msgstr ""
"回傳命名頭欄位的值。這與 :meth:`__getitem__` 相同，"
"只是如果命名標頭丟失則回傳可選的 *failobj*（預設為 ``None``）。"

#: ../../library/email.compat32-message.rst:373
#, fuzzy
msgid "Here are some additional useful methods:"
msgstr "以下是一些其他有用的方法："

#: ../../library/email.compat32-message.rst:378
#, fuzzy
msgid ""
"Return a list of all the values for the field named *name*. If there are no "
"such named headers in the message, *failobj* is returned (defaults to "
"``None``)."
msgstr "回傳名為 *name* 的欄位的所有值的列表。如果消息中沒有這樣的命名標頭，則回傳 "
"*failobj*（預設為 ``None`` ）。"

#: ../../library/email.compat32-message.rst:385
#, fuzzy
msgid ""
"Extended header setting.  This method is similar to :meth:`__setitem__` "
"except that additional header parameters can be provided as keyword "
"arguments.  *_name* is the header field to add and *_value* is the *primary* "
"value for the header."
msgstr ""
"擴充標題設定。此方法與 :meth:`__setitem__` "
"類似，不同之處在於附加的標頭參數可以作為關鍵字參數提供。 *_name* "
"是要新增的標頭欄位，*_value* 是標頭的 *primary* 值。"

#: ../../library/email.compat32-message.rst:390
#, fuzzy
msgid ""
"For each item in the keyword argument dictionary *_params*, the key is taken "
"as the parameter name, with underscores converted to dashes (since dashes "
"are illegal in Python identifiers).  Normally, the parameter will be added "
"as ``key=\"value\"`` unless the value is ``None``, in which case only the "
"key will be added.  If the value contains non-ASCII characters, it can be "
"specified as a three tuple in the format ``(CHARSET, LANGUAGE, VALUE)``, "
"where ``CHARSET`` is a string naming the charset to be used to encode the "
"value, ``LANGUAGE`` can usually be set to ``None`` or the empty string (see :"
"rfc:`2231` for other possibilities), and ``VALUE`` is the string value "
"containing non-ASCII code points.  If a three tuple is not passed and the "
"value contains non-ASCII characters, it is automatically encoded in :rfc:"
"`2231` format using a ``CHARSET`` of ``utf-8`` and a ``LANGUAGE`` of "
"``None``."
msgstr ""
"對於關鍵字參數字典 *_params* 中的每一項，鍵作為參數名稱，底線轉換為破折號（"
"因為破折號在 Python 標識符中是非法的）。通常情況下，參數將被新增為 ``key="
"\"value\"`` 除非值為 ``None``，在這種情況下只會新增鍵。如果該值包含非 ASCII "
"字元，則可以將其指定為格式為“(CHARSET, LANGUAGE, "
"VALUE)”的三元組，其中 ``CHARSET`` 是命名用於編碼的字元集的字串值，``LANGUAGE`` "
"通常可以設定為``None`` 或空字串（其他可能性見 :rfc:`2231`），``VALUE`` "
"是包含非 ASCII 程式碼點的字串值.如果未傳遞三元組且值包含非 ASCII 字元，"
"則使用 ``utf-8`` 的 ``CHARSET`` 和 ``LANGUAGE`` 自動編碼為 :rfc:`2231` "
"格式的``無``。"

#: ../../library/email.compat32-message.rst:404
msgid "Here's an example::"
msgstr ""
"以下是個範例：\n"
"\n"
"::"

#: ../../library/email.compat32-message.rst:408
#, fuzzy
msgid "This will add a header that looks like ::"
msgstr "這將新增一個標題，看起來像 ::"

#: ../../library/email.compat32-message.rst:412
#, fuzzy
msgid "An example with non-ASCII characters::"
msgstr "非 ASCII 字元的示例："

#: ../../library/email.compat32-message.rst:417
#, fuzzy
msgid "Which produces ::"
msgstr "哪個產生::"

#: ../../library/email.compat32-message.rst:424
#, fuzzy
msgid ""
"Replace a header.  Replace the first header found in the message that "
"matches *_name*, retaining header order and field name case.  If no matching "
"header was found, a :exc:`KeyError` is raised."
msgstr ""
"替換標題。替換在消息中找到的與 *_name* "
"匹配的第一個標頭，保留標頭順序和欄位名稱大小寫。如果未找到匹配的標頭，"
"則會引發 :exc:`KeyError`。"

#: ../../library/email.compat32-message.rst:431
#, fuzzy
msgid ""
"Return the message's content type.  The returned string is coerced to lower "
"case of the form :mimetype:`maintype/subtype`.  If there was no :mailheader:"
"`Content-Type` header in the message the default type as given by :meth:"
"`get_default_type` will be returned.  Since according to :rfc:`2045`, "
"messages always have a default type, :meth:`get_content_type` will always "
"return a value."
msgstr ""
"回傳消息的內容型別。回傳的字串被強制轉換為 :mimetype:`maintype/subtype` "
"形式的小寫。如果郵件中沒有:mailheader:`Content-Type` 標頭，則將回傳 "
":meth:`get_default_type` 給出的預設型別。由於根據 "
":rfc:`2045`，消息始終具有預設型別，因此 :meth:`get_content_type` "
"將始終回傳一個值。"

#: ../../library/email.compat32-message.rst:438
#, fuzzy
msgid ""
":rfc:`2045` defines a message's default type to be :mimetype:`text/plain` "
"unless it appears inside a :mimetype:`multipart/digest` container, in which "
"case it would be :mimetype:`message/rfc822`.  If the :mailheader:`Content-"
"Type` header has an invalid type specification, :rfc:`2045` mandates that "
"the default type be :mimetype:`text/plain`."
msgstr ""
":rfc:`2045` 將消息的預設型別定義為 :mimetype:`text/plain` 除非它出現在 "
":mimetype:`multipart/digest` 容器中，在這種情況下它將是 :mimetype:`message/"
"rfc822` .如果 :mailheader:`Content-Type` 標頭的型別規範無效，則 :rfc:`2045` "
"要求預設型別為 :mimetype:`text/plain`。"

#: ../../library/email.compat32-message.rst:447
#, fuzzy
msgid ""
"Return the message's main content type.  This is the :mimetype:`maintype` "
"part of the string returned by :meth:`get_content_type`."
msgstr "回傳消息的主要內容型別。這是 :meth:`get_content_type` 回傳的字串的 "
":mimetype:`maintype` 部分。"

#: ../../library/email.compat32-message.rst:453
#, fuzzy
msgid ""
"Return the message's sub-content type.  This is the :mimetype:`subtype` part "
"of the string returned by :meth:`get_content_type`."
msgstr "回傳消息的子內容型別。這是 :meth:`get_content_type` 回傳的字串的 "
":mimetype:`subtype` 部分。"

#: ../../library/email.compat32-message.rst:459
#, fuzzy
msgid ""
"Return the default content type.  Most messages have a default content type "
"of :mimetype:`text/plain`, except for messages that are subparts of :"
"mimetype:`multipart/digest` containers.  Such subparts have a default "
"content type of :mimetype:`message/rfc822`."
msgstr ""
"回傳預設內容型別。大多數消息的預設內容型別為 :mimetype:`text/plain`，但屬於 "
":mimetype:`multipart/digest` 容器子部分的消息除外。"
"此類子部分的預設內容型別為 :mimetype:`message/rfc822`。"

#: ../../library/email.compat32-message.rst:467
#, fuzzy
msgid ""
"Set the default content type.  *ctype* should either be :mimetype:`text/"
"plain` or :mimetype:`message/rfc822`, although this is not enforced.  The "
"default content type is not stored in the :mailheader:`Content-Type` header."
msgstr ""
"設定預設內容型別。 *ctype* 應該是 :mimetype:`text/plain` 或 :mimetype:`"
"message/rfc822`，雖然這不是強制的。預設內容型別不儲存在:mailheader:`Content-"
"Type` 標頭中。"

#: ../../library/email.compat32-message.rst:475
#, fuzzy
msgid ""
"Return the message's :mailheader:`Content-Type` parameters, as a list. The "
"elements of the returned list are 2-tuples of key/value pairs, as split on "
"the ``'='`` sign.  The left hand side of the ``'='`` is the key, while the "
"right hand side is the value.  If there is no ``'='`` sign in the parameter "
"the value is the empty string, otherwise the value is as described in :meth:"
"`get_param` and is unquoted if optional *unquote* is ``True`` (the default)."
msgstr ""
"回傳郵件的:mailheader:`Content-Type` 參數，作為列表。回傳列表的元素是鍵/"
"值對的 2 元組，在 ``=``符號上拆分。 ``'='`` 的左側是鍵，右側是值。"
"如果參數中沒有 ``'='`` 符號，則該值為空字串，否則該值如 :meth:`get_param` "
"中所述，如果可選 *unquote* 為 ``True`` (預設）。"

#: ../../library/email.compat32-message.rst:483
#, fuzzy
msgid ""
"Optional *failobj* is the object to return if there is no :mailheader:"
"`Content-Type` header.  Optional *header* is the header to search instead "
"of :mailheader:`Content-Type`."
msgstr ""
"可選 *failobj* 是在沒有 :mailheader:`Content-Type` 標頭時要回傳的物件。"
"可選的 *header* 是要搜索的標題，而不是 :mailheader:`Content-Type`。"

#: ../../library/email.compat32-message.rst:487
#: ../../library/email.compat32-message.rst:525
#, fuzzy
msgid ""
"This is a legacy method.  On the :class:`~email.emailmessage.EmailMessage` "
"class its functionality is replaced by the *params* property of the "
"individual header objects returned by the header access methods."
msgstr ""
"這是一種遺留方法。在 :class:`~email.emailmessage.EmailMessage` 類中，"
"它的功能被標頭訪問方法回傳的各個標頭物件的 *params* 屬性所取代。"

#: ../../library/email.compat32-message.rst:495
#, fuzzy
msgid ""
"Return the value of the :mailheader:`Content-Type` header's parameter "
"*param* as a string.  If the message has no :mailheader:`Content-Type` "
"header or if there is no such parameter, then *failobj* is returned "
"(defaults to ``None``)."
msgstr ""
"將 :mailheader:`Content-Type` 標頭的參數 *param* "
"的值作為字串回傳。如果郵件沒有:mailheader:`Content-Type` "
"標頭或者沒有這樣的參數，則回傳 *failobj*（預設為 ``None``）。"

#: ../../library/email.compat32-message.rst:500
#, fuzzy
msgid ""
"Optional *header* if given, specifies the message header to use instead of :"
"mailheader:`Content-Type`."
msgstr "可選的 *header* 如果給定，指定要使用的郵件標題而不是 :mailheader:`Content-"
"Type`。"

#: ../../library/email.compat32-message.rst:503
#, fuzzy
msgid ""
"Parameter keys are always compared case insensitively.  The return value can "
"either be a string, or a 3-tuple if the parameter was :rfc:`2231` encoded.  "
"When it's a 3-tuple, the elements of the value are of the form ``(CHARSET, "
"LANGUAGE, VALUE)``.  Note that both ``CHARSET`` and ``LANGUAGE`` can be "
"``None``, in which case you should consider ``VALUE`` to be encoded in the "
"``us-ascii`` charset.  You can usually ignore ``LANGUAGE``."
msgstr ""
"參數鍵總是不區分大小寫地進行比較。如果參數是 :rfc:`2231` "
"編碼，則回傳值可以是字串或三元組。當它是 3 元組時，值的元素的形式為``("
"CHARSET, LANGUAGE, VALUE)``。請注意，``CHARSET`` 和``LANGUAGE`` "
"都可以是``None``，在這種情況下，您應該考慮將``VALUE`` 編碼為``us-ascii`` "
"字元集。你通常可以忽略``LANGUAGE``。"

#: ../../library/email.compat32-message.rst:511
#, fuzzy
msgid ""
"If your application doesn't care whether the parameter was encoded as in :"
"rfc:`2231`, you can collapse the parameter value by calling :func:`email."
"utils.collapse_rfc2231_value`, passing in the return value from :meth:"
"`get_param`.  This will return a suitably decoded Unicode string when the "
"value is a tuple, or the original string unquoted if it isn't.  For example::"
msgstr ""
"如果您的應用程式不關心參數是否編碼為 :rfc:`2231`，您可以通過呼叫 :func:`email."
"utils.collapse_rfc2231_value` 折疊參數值，傳入 :meth:` "
"的回傳值get_param`。當值是一個元組時，這將回傳一個適當解碼的 Unicode "
"字串，如果不是，則回傳不帶引號的原始字串。例如：："

#: ../../library/email.compat32-message.rst:521
#, fuzzy
msgid ""
"In any case, the parameter value (either the returned string, or the "
"``VALUE`` item in the 3-tuple) is always unquoted, unless *unquote* is set "
"to ``False``."
msgstr "在任何情況下，參數值（回傳的字串，或 3 元組中的 ``VALUE``項）始終不帶引號，除非 "
"*unquote* 設定為 ``False``。"

#: ../../library/email.compat32-message.rst:534
#, fuzzy
msgid ""
"Set a parameter in the :mailheader:`Content-Type` header.  If the parameter "
"already exists in the header, its value will be replaced with *value*.  If "
"the :mailheader:`Content-Type` header as not yet been defined for this "
"message, it will be set to :mimetype:`text/plain` and the new parameter "
"value will be appended as per :rfc:`2045`."
msgstr ""
"在 :mailheader:`Content-Type` 標頭中設定一個參數。如果該參數已存在於標頭中，"
"則其值將替換為 *value*。如果 :mailheader:`Content-Type` "
"標頭尚未為此郵件定義，它將被設定為 :mimetype:`text/plain` "
"並且新的參數值將按照 :rfc:`2045` 附加。"

#: ../../library/email.compat32-message.rst:540
#, fuzzy
msgid ""
"Optional *header* specifies an alternative header to :mailheader:`Content-"
"Type`, and all parameters will be quoted as necessary unless optional "
"*requote* is ``False`` (the default is ``True``)."
msgstr ""
"可選的 *header* 為 :mailheader:`Content-Type` "
"指定了一個替代標頭，所有參數都將在必要時被引用，除非可選的 *requote* 為 "
"``False``（預設為 ``True``）。"

#: ../../library/email.compat32-message.rst:544
#, fuzzy
msgid ""
"If optional *charset* is specified, the parameter will be encoded according "
"to :rfc:`2231`. Optional *language* specifies the RFC 2231 language, "
"defaulting to the empty string.  Both *charset* and *language* should be "
"strings."
msgstr ""
"如果指定了可選的 *charset*，則參數將根據 :rfc:`2231` 進行編碼。可選的 "
"*language* 指定 RFC 2231 語言，預設為空字串。 *charset* 和 *language* "
"都應該是字串。"

#: ../../library/email.compat32-message.rst:549
#, fuzzy
msgid ""
"If *replace* is ``False`` (the default) the header is moved to the end of "
"the list of headers.  If *replace* is ``True``, the header will be updated "
"in place."
msgstr ""
"如果 *replace* 是 ``False``（預設值），標題將移動到標題列表的末尾。如果 "
"*replace* 是 ``True``，標題將被更新到位。"

#: ../../library/email.compat32-message.rst:553
#, fuzzy
msgid "``replace`` keyword was added."
msgstr "新增了``replace``關鍵字。"

#: ../../library/email.compat32-message.rst:558
#, fuzzy
msgid ""
"Remove the given parameter completely from the :mailheader:`Content-Type` "
"header.  The header will be re-written in place without the parameter or its "
"value.  All values will be quoted as necessary unless *requote* is ``False`` "
"(the default is ``True``).  Optional *header* specifies an alternative to :"
"mailheader:`Content-Type`."
msgstr ""
"從 :mailheader:`Content-Type` "
"標頭中完全刪除給定參數。標頭將在沒有參數或其值的情況下重新寫入。除非*requote*"
" 為 ``False``（預設為 ``True``），否則所有值都將在必要時被引用。可選的 *header* "
"指定 :mailheader:`Content-Type` 的替代方法。"

#: ../../library/email.compat32-message.rst:567
#, fuzzy
msgid ""
"Set the main type and subtype for the :mailheader:`Content-Type` header. "
"*type* must be a string in the form :mimetype:`maintype/subtype`, otherwise "
"a :exc:`ValueError` is raised."
msgstr ""
"設定 :mailheader:`Content-Type` 標頭的主要型別和子型別。 *type* 必須是 "
":mimetype:`maintype/subtype` 形式的字串，否則會引發 :exc:`ValueError`。"

#: ../../library/email.compat32-message.rst:571
#, fuzzy
msgid ""
"This method replaces the :mailheader:`Content-Type` header, keeping all the "
"parameters in place.  If *requote* is ``False``, this leaves the existing "
"header's quoting as is, otherwise the parameters will be quoted (the "
"default)."
msgstr ""
"此方法替換 :mailheader:`Content-Type` 標頭，保留所有參數。如果 *requote* "
"為 ``False``，則現有標頭的引用保持原樣，否則參數將被引用（預設）。"

#: ../../library/email.compat32-message.rst:576
#, fuzzy
msgid ""
"An alternative header can be specified in the *header* argument. When the :"
"mailheader:`Content-Type` header is set a :mailheader:`MIME-Version` header "
"is also added."
msgstr ""
"可以在 *header* 參數中指定替代標頭。當設定 :mailheader:`Content-Type` "
"標頭時，還會新增 :mailheader:`MIME-Version` 標頭。"

#: ../../library/email.compat32-message.rst:580
#, fuzzy
msgid ""
"This is a legacy method.  On the :class:`~email.emailmessage.EmailMessage` "
"class its functionality is replaced by the ``make_`` and ``add_`` methods."
msgstr ""
"這是一種遺留方法。在 :class:`~email.emailmessage.EmailMessage` 類中，"
"它的功能被 ``make_`` 和 ``add_`` 方法取代。"

#: ../../library/email.compat32-message.rst:587
#, fuzzy
msgid ""
"Return the value of the ``filename`` parameter of the :mailheader:`Content-"
"Disposition` header of the message.  If the header does not have a "
"``filename`` parameter, this method falls back to looking for the ``name`` "
"parameter on the :mailheader:`Content-Type` header.  If neither is found, or "
"the header is missing, then *failobj* is returned. The returned string will "
"always be unquoted as per :func:`email.utils.unquote`."
msgstr ""
"回傳消息的 :mailheader:`Content-Disposition` 標頭的 ``filename`` 參數的值。"
"如果標頭沒有 ``filename`` 參數，則此方法回退到在 :mailheader:`Content-Type` "
"標頭上尋找 ``name`` 參數。如果兩者均未找到，或者標頭丟失，則回傳 *failobj*。"
"根據 :func:`email.utils.unquote` 回傳的字串將始終不帶引號。"

#: ../../library/email.compat32-message.rst:598
#, fuzzy
msgid ""
"Return the value of the ``boundary`` parameter of the :mailheader:`Content-"
"Type` header of the message, or *failobj* if either the header is missing, "
"or has no ``boundary`` parameter.  The returned string will always be "
"unquoted as per :func:`email.utils.unquote`."
msgstr ""
"回傳消息的 :mailheader:`Content-Type` 標頭的 ``boundary`` 參數的值，"
"如果標頭丟失或沒有 ``boundary`` 參數，則回傳 *failobj*。根據 :func:`email."
"utils.unquote` 回傳的字串將始終不帶引號。"

#: ../../library/email.compat32-message.rst:606
#, fuzzy
msgid ""
"Set the ``boundary`` parameter of the :mailheader:`Content-Type` header to "
"*boundary*.  :meth:`set_boundary` will always quote *boundary* if "
"necessary.  A :exc:`~email.errors.HeaderParseError` is raised if the message "
"object has no :mailheader:`Content-Type` header."
msgstr ""
"將 :mailheader:`Content-Type` 標頭的 ``boundary`` 參數設定為 *boundary*。 "
":meth:`set_boundary` 將始終在必要時引用 *boundary*。如果消息對像沒有 Content-"
"Type 標頭，則會引發 :exc:`~email.errors.HeaderParseError`。"

#: ../../library/email.compat32-message.rst:611
#, fuzzy
msgid ""
"Note that using this method is subtly different than deleting the old :"
"mailheader:`Content-Type` header and adding a new one with the new boundary "
"via :meth:`add_header`, because :meth:`set_boundary` preserves the order of "
"the :mailheader:`Content-Type` header in the list of headers. However, it "
"does *not* preserve any continuation lines which may have been present in "
"the original :mailheader:`Content-Type` header."
msgstr ""
"請注意，使用此方法與刪除舊的 :mailheader:`Content-Type` "
"標頭並通過 :meth:`add_header` "
"新增具有新邊界的新標頭略有不同，因為 :meth:`set_boundary` 保留了:mailheader"
":`Content-Type` 標題列表中的標題。但是，它 *不* 保留原始 :mailheader"
":`Content-Type` 標頭中可能存在的任何續行。"

#: ../../library/email.compat32-message.rst:621
#, fuzzy
msgid ""
"Return the ``charset`` parameter of the :mailheader:`Content-Type` header, "
"coerced to lower case.  If there is no :mailheader:`Content-Type` header, or "
"if that header has no ``charset`` parameter, *failobj* is returned."
msgstr ""
"回傳 :mailheader:`Content-Type` 標頭的 ``charset`` 參數，強制為小寫。"
"如果沒有 :mailheader:`Content-Type` 標頭，或者如果該標頭沒有 ``charset`` "
"參數，則回傳 *failobj*。"

#: ../../library/email.compat32-message.rst:625
#, fuzzy
msgid ""
"Note that this method differs from :meth:`get_charset` which returns the :"
"class:`~email.charset.Charset` instance for the default encoding of the "
"message body."
msgstr ""
"請注意，此方法不同於 :meth:`get_charset`，後者回傳消息正文預設編碼的 "
":class:`~email.charset.Charset` 實例。"

#: ../../library/email.compat32-message.rst:631
#, fuzzy
msgid ""
"Return a list containing the character set names in the message.  If the "
"message is a :mimetype:`multipart`, then the list will contain one element "
"for each subpart in the payload, otherwise, it will be a list of length 1."
msgstr ""
"回傳包含消息中字元集名稱的列表。如果消息是 "
":mimetype:`multipart`，則列表將包含有效載荷中每個子部分的一個元素，否則，"
"它將是一個長度為 1 的列表。"

#: ../../library/email.compat32-message.rst:635
#, fuzzy
msgid ""
"Each item in the list will be a string which is the value of the ``charset`` "
"parameter in the :mailheader:`Content-Type` header for the represented "
"subpart.  However, if the subpart has no :mailheader:`Content-Type` header, "
"no ``charset`` parameter, or is not of the :mimetype:`text` main MIME type, "
"then that item in the returned list will be *failobj*."
msgstr ""
"列表中的每個項目都是一個字串，它是代表子部分的 Content-Type 標頭中的 charset "
"參數的值。但是，如果子部分沒有 Content-Type 標頭，沒有 charset 參數，"
"或者不是 :mimetype:`text` 主要 MIME 型別，則回傳列表中的該項目將為 "
"*故障物件*。"

#: ../../library/email.compat32-message.rst:645
#, fuzzy
msgid ""
"Return the lowercased value (without parameters) of the message's :"
"mailheader:`Content-Disposition` header if it has one, or ``None``.  The "
"possible values for this method are *inline*, *attachment* or ``None`` if "
"the message follows :rfc:`2183`."
msgstr ""
"回傳郵件的 :mailheader:`Content-Disposition` "
"標頭的小寫值（不帶參數），如果有的話，或者 ``None``。如果消息跟在 :rfc:`2183`"
" 之後，此方法的可能值是 *inline*、*attachment* 或 ``None``。"

#: ../../library/email.compat32-message.rst:654
#, fuzzy
msgid ""
"The :meth:`walk` method is an all-purpose generator which can be used to "
"iterate over all the parts and subparts of a message object tree, in depth-"
"first traversal order.  You will typically use :meth:`walk` as the iterator "
"in a ``for`` loop; each iteration returns the next subpart."
msgstr ""
":meth:`walk` 方法是一種通用生成器，可用於以深度優先遍歷順序疊代消息物件樹的所"
"有部分和子部分。您通常會使用 :meth:`walk` 作為 ``for`` "
"循環中的疊代器；每次疊代回傳下一個子部分。"

#: ../../library/email.compat32-message.rst:659
#, fuzzy
msgid ""
"Here's an example that prints the MIME type of every part of a multipart "
"message structure:"
msgstr "下面是一個印出多部分消息結構每個部分的 MIME 型別的示例："

#: ../../library/email.compat32-message.rst:685
#, fuzzy
msgid ""
"``walk`` iterates over the subparts of any part where :meth:`is_multipart` "
"returns ``True``, even though ``msg.get_content_maintype() == 'multipart'`` "
"may return ``False``.  We can see this in our example by making use of the "
"``_structure`` debug helper function:"
msgstr ""
"``walk`` 遍歷任何部分的子部分，其中 :meth:`is_multipart` 回傳 ``True``，即使 "
"``msg.get_content_maintype() == 'multipart'`` 可能回傳 ``False``。"
"我們可以在我們的示例中通過使用 ``_structure`` 除錯輔助函式看到這一點："

#: ../../library/email.compat32-message.rst:712
#, fuzzy
msgid ""
"Here the ``message`` parts are not ``multiparts``, but they do contain "
"subparts. ``is_multipart()`` returns ``True`` and ``walk`` descends into the "
"subparts."
msgstr ""
"這裡的“消息”部分不是“多部分”，但它們確實包含子部分。 ``is_multipart()`` 回傳 "
"``True`` 和 ``walk`` 下降到子部分。"

#: ../../library/email.compat32-message.rst:717
#, fuzzy
msgid ""
":class:`Message` objects can also optionally contain two instance "
"attributes, which can be used when generating the plain text of a MIME "
"message."
msgstr ":class:`Message` 對像還可以選擇包含兩個實例屬性，可在生成 MIME "
"消息的純文本時使用。"

#: ../../library/email.compat32-message.rst:723
#, fuzzy
msgid ""
"The format of a MIME document allows for some text between the blank line "
"following the headers, and the first multipart boundary string. Normally, "
"this text is never visible in a MIME-aware mail reader because it falls "
"outside the standard MIME armor.  However, when viewing the raw text of the "
"message, or when viewing the message in a non-MIME aware reader, this text "
"can become visible."
msgstr ""
"MIME "
"文檔的格式允許在標題後面的空行和第一個多部分邊界字串之間有一些文本。通常，"
"此文本在支援 MIME 的郵件閱讀器中永遠不可見，因為它不在標準 MIME "
"防護範圍之內。但是，在查看消息的原始文本時，或者在非 MIME "
"感知閱讀器中查看消息時，此文本可能會變得可見。"

#: ../../library/email.compat32-message.rst:730
#, fuzzy
msgid ""
"The *preamble* attribute contains this leading extra-armor text for MIME "
"documents.  When the :class:`~email.parser.Parser` discovers some text after "
"the headers but before the first boundary string, it assigns this text to "
"the message's *preamble* attribute.  When the :class:`~email.generator."
"Generator` is writing out the plain text representation of a MIME message, "
"and it finds the message has a *preamble* attribute, it will write this text "
"in the area between the headers and the first boundary.  See :mod:`email."
"parser` and :mod:`email.generator` for details."
msgstr ""
"*preamble* 屬性包含用於 MIME 文檔的這個領先的額外裝甲文本。當 :class:`~email."
"parser.Parser` 在標頭之後但在第一個邊界字串之前發現一些文本時，"
"它會將此文本分配給消息的 *preamble* 屬性。當 :class:`~email.generator."
"Generator` 正在寫出 MIME 消息的純文本表示時，它發現該消息具有 *preamble* "
"屬性，它會將此文本寫入標題和第一個邊界。有關詳細資訊，請參閱 :mod:`email."
"parser` 和 :mod:`email.generator`。"

#: ../../library/email.compat32-message.rst:740
#, fuzzy
msgid ""
"Note that if the message object has no preamble, the *preamble* attribute "
"will be ``None``."
msgstr "請注意，如果消息對像沒有前導碼，*preamble* 屬性將為 ``None``。"

#: ../../library/email.compat32-message.rst:746
#, fuzzy
msgid ""
"The *epilogue* attribute acts the same way as the *preamble* attribute, "
"except that it contains text that appears between the last boundary and the "
"end of the message."
msgstr "*epilogue* 屬性與 *preamble* "
"屬性的作用相同，只是它包含出現在最後一個邊界和消息結尾之間的文本。"

#: ../../library/email.compat32-message.rst:750
#, fuzzy
msgid ""
"You do not need to set the epilogue to the empty string in order for the :"
"class:`~email.generator.Generator` to print a newline at the end of the file."
msgstr "您不需要將尾聲設定為空字串，以便 :class:`~email.generator.Generator` "
"在文件末尾印出換行符。"

#: ../../library/email.compat32-message.rst:757
#, fuzzy
msgid ""
"The *defects* attribute contains a list of all the problems found when "
"parsing this message.  See :mod:`email.errors` for a detailed description of "
"the possible parsing defects."
msgstr "*defects* 屬性包含解析此消息時發現的所有問題的列表。有關可能的解析缺陷的詳細"
"描述，請參見 :mod:`email.errors`。"
