# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-15 20:43+0000\n"
"PO-Revision-Date: 2018-05-23 16:13+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/timeit.rst:2
msgid ":mod:`timeit` --- Measure execution time of small code snippets"
msgstr ":mod:`timeit` --- 測量小程式碼片段的執行時間"

#: ../../library/timeit.rst:7
msgid "**Source code:** :source:`Lib/timeit.py`"
msgstr "**原始碼：**\\ :source:`Lib/timeit.py`"

#: ../../library/timeit.rst:15
#, fuzzy
msgid ""
"This module provides a simple way to time small bits of Python code. It has "
"both a :ref:`timeit-command-line-interface` as well as a :ref:`callable "
"<python-interface>` one.  It avoids a number of common traps for measuring "
"execution times. See also Tim Peters' introduction to the \"Algorithms\" "
"chapter in the second edition of *Python Cookbook*, published by O'Reilly."
msgstr ""
"這個模組提供了一種簡單的方法來為一小段 Python 程式碼計時。它有一個 :ref"
":`timeit-command-line-interface` 和一個 :ref:`callable <python-"
"interface>`。它避免了許多測量執行時間的常見陷阱。另請參閱 Tim Peters 對 "
"O'Reilly 出版的 *Python Cookbook* 第二版中“演算法”章節的介紹。"

#: ../../library/timeit.rst:23
msgid "Basic Examples"
msgstr "基礎範例"

#: ../../library/timeit.rst:25
#, fuzzy
msgid ""
"The following example shows how the :ref:`timeit-command-line-interface` can "
"be used to compare three different expressions:"
msgstr "以下示例顯示瞭如何使用 :ref:`timeit-command-line-interface` "
"來比較三個不同的表達式："

#: ../../library/timeit.rst:37
#, fuzzy
msgid "This can be achieved from the :ref:`python-interface` with::"
msgstr "這可以通過 :ref:`python-interface` 實作："

#: ../../library/timeit.rst:47
#, fuzzy
msgid "A callable can also be passed from the :ref:`python-interface`::"
msgstr "也可以從 :ref:`python-interface` 傳遞可呼叫物件："

#: ../../library/timeit.rst:52
#, fuzzy
msgid ""
"Note however that :func:`.timeit` will automatically determine the number of "
"repetitions only when the command-line interface is used.  In the :ref:"
"`timeit-examples` section you can find more advanced examples."
msgstr ""
"但是請注意 :func:`.timeit` 將僅在使用命令列界面時自動確定重複次數。在 :ref"
":`timeit-examples` 部分，您可以找到更多高階示例。"

#: ../../library/timeit.rst:60
msgid "Python Interface"
msgstr "Python 介面"

#: ../../library/timeit.rst:62
#, fuzzy
msgid "The module defines three convenience functions and a public class:"
msgstr "該模組定義了三個便利函式和一個公開類："

#: ../../library/timeit.rst:67
#, fuzzy
msgid ""
"Create a :class:`Timer` instance with the given statement, *setup* code and "
"*timer* function and run its :meth:`.timeit` method with *number* "
"executions. The optional *globals* argument specifies a namespace in which "
"to execute the code."
msgstr ""
"使用給定的語句、*setup* 程式碼和 *timer* 函式建立一個 :class:`Timer` 實例，"
"並運行其 :meth:`.timeit` 方法並執行 *number* 次。可選的 *globals* "
"參數指定在其中執行程式碼的名稱空間。"

#: ../../library/timeit.rst:72 ../../library/timeit.rst:83
#: ../../library/timeit.rst:120
msgid "The optional *globals* parameter was added."
msgstr "新增 *globals* 選用參數。"

#: ../../library/timeit.rst:78
#, fuzzy
msgid ""
"Create a :class:`Timer` instance with the given statement, *setup* code and "
"*timer* function and run its :meth:`.repeat` method with the given *repeat* "
"count and *number* executions.  The optional *globals* argument specifies a "
"namespace in which to execute the code."
msgstr ""
"使用給定的語句、*setup* 程式碼和 *timer* 函式建立一個 :class:`Timer` 實例，"
"並使用給定的 *repeat* 計數和 *number* 執行來運行其 :meth:`.repeat` 方法。"
"可選的 *globals* 參數指定在其中執行程式碼的名稱空間。"

#: ../../library/timeit.rst:86 ../../library/timeit.rst:181
msgid "Default value of *repeat* changed from 3 to 5."
msgstr "*repeat* 的預設值從 3 更改為 5。"

#: ../../library/timeit.rst:91
#, fuzzy
msgid "The default timer, which is always :func:`time.perf_counter`."
msgstr "預設計時器，始終為 :func:`time.perf_counter`。"

#: ../../library/timeit.rst:93
msgid ":func:`time.perf_counter` is now the default timer."
msgstr ":func:`time.perf_counter` 現在是預設計時器。"

#: ../../library/timeit.rst:99
#, fuzzy
msgid "Class for timing execution speed of small code snippets."
msgstr "用於計時小程式碼片段執行速度的類。"

#: ../../library/timeit.rst:101
#, fuzzy
msgid ""
"The constructor takes a statement to be timed, an additional statement used "
"for setup, and a timer function.  Both statements default to ``'pass'``; the "
"timer function is platform-dependent (see the module doc string). *stmt* and "
"*setup* may also contain multiple statements separated by ``;`` or newlines, "
"as long as they don't contain multi-line string literals.  The statement "
"will by default be executed within timeit's namespace; this behavior can be "
"controlled by passing a namespace to *globals*."
msgstr ""
"構造函式採用一條要計時的語句、一條用於設定的附加語句和一個計時器函式。"
"兩個語句都預設為 ``'pass'``；計時器功能是平台相關的（請參閱模組文檔字串）。 "
"*stmt* 和 *setup* 也可以包含多個由 ``;`` "
"或換行符分隔的語句，只要它們不包含多行字串文字即可。預設情況下，該語句將在 "
"timeit 的命名空間內執行；可以通過將名稱空間傳遞給 *globals* 來控制此行為。"

#: ../../library/timeit.rst:109
#, fuzzy
msgid ""
"To measure the execution time of the first statement, use the :meth:`."
"timeit` method.  The :meth:`.repeat` and :meth:`.autorange` methods are "
"convenience methods to call :meth:`.timeit` multiple times."
msgstr ""
"要測量第一條語句的執行時間，請使用 :meth:`.timeit` 方法。 :meth:`.repeat` 和 "
":meth:`.autorange` 方法是多次呼叫 :meth:`.timeit` 的便捷方法。"

#: ../../library/timeit.rst:113
#, fuzzy
msgid ""
"The execution time of *setup* is excluded from the overall timed execution "
"run."
msgstr "*setup* 的執行時間不包括在整體定時執行運行中。"

#: ../../library/timeit.rst:115
#, fuzzy
msgid ""
"The *stmt* and *setup* parameters can also take objects that are callable "
"without arguments.  This will embed calls to them in a timer function that "
"will then be executed by :meth:`.timeit`.  Note that the timing overhead is "
"a little larger in this case because of the extra function calls."
msgstr ""
"*stmt* 和 *setup* 參數也可以採用無需參數即可呼叫的物件。這會將對它們的呼叫嵌"
"入到一個計時器函式中，然後由 :meth:`.timeit` "
"執行。請注意，由於額外的函式呼叫，這種情況下的時序開銷稍大。"

#: ../../library/timeit.rst:125
#, fuzzy
msgid ""
"Time *number* executions of the main statement.  This executes the setup "
"statement once, and then returns the time it takes to execute the main "
"statement a number of times, measured in seconds as a float. The argument is "
"the number of times through the loop, defaulting to one million.  The main "
"statement, the setup statement and the timer function to be used are passed "
"to the constructor."
msgstr ""
"主語句的時間 *number* 執行。這將執行一次設定語句，然後回傳多次執行主語句所花"
"費的時間，以秒為單位測量為浮點數。參數是循環次數，預設為一百萬次。主語句、設"
"定語句和要使用的定時器函式被傳遞給構造函式。"

#: ../../library/timeit.rst:134
#, fuzzy
msgid ""
"By default, :meth:`.timeit` temporarily turns off :term:`garbage collection` "
"during the timing.  The advantage of this approach is that it makes "
"independent timings more comparable.  The disadvantage is that GC may be an "
"important component of the performance of the function being measured.  If "
"so, GC can be re-enabled as the first statement in the *setup* string.  For "
"example::"
msgstr ""
"預設情況下，:meth:`.timeit` 在計時期間暫時關閉 :term:`garbage "
"collection`。這種方法的優點是它使獨立計時更具可比性。缺點是 GC "
"可能是被測函式性能的重要組成部分。如果是這樣，GC 可以作為 *setup* "
"字串中的第一條語句重新啟用。例如：："

#: ../../library/timeit.rst:146
#, fuzzy
msgid "Automatically determine how many times to call :meth:`.timeit`."
msgstr "自動判斷呼叫 :meth:`.timeit` 的次數。"

#: ../../library/timeit.rst:148
#, fuzzy
msgid ""
"This is a convenience function that calls :meth:`.timeit` repeatedly so that "
"the total time >= 0.2 second, returning the eventual (number of loops, time "
"taken for that number of loops). It calls :meth:`.timeit` with increasing "
"numbers from the sequence 1, 2, 5, 10, 20, 50, ... until the time taken is "
"at least 0.2 second."
msgstr ""
"這是一個方便的函式，它重複呼叫 :meth:`.timeit` 以便總時間 >= 0.2 "
"秒，回傳最終值（循環次數，該循環次數所花費的時間）。它呼叫 :meth:`.timeit` "
"並從序列 1、2、5、10、20、50 中遞增數字，...直到所用時間至少為 0.2 秒。"

#: ../../library/timeit.rst:154
#, fuzzy
msgid ""
"If *callback* is given and is not ``None``, it will be called after each "
"trial with two arguments: ``callback(number, time_taken)``."
msgstr ""
"如果給出 *callback* "
"並且不是 ``None``，它將在每次試驗後使用兩個參數呼叫：“callback(number, "
"time_taken)”。"

#: ../../library/timeit.rst:162
msgid "Call :meth:`.timeit` a few times."
msgstr "呼叫 :meth:`.timeit` 數次。"

#: ../../library/timeit.rst:164
#, fuzzy
msgid ""
"This is a convenience function that calls the :meth:`.timeit` repeatedly, "
"returning a list of results.  The first argument specifies how many times to "
"call :meth:`.timeit`.  The second argument specifies the *number* argument "
"for :meth:`.timeit`."
msgstr ""
"這是一個重複呼叫 :meth:`.timeit` 的便捷函式，回傳結果列表。"
"第一個參數指定呼叫 :meth:`.timeit` 的次數。第二個參數指定 :meth:`.timeit` 的 "
"*number* 參數。"

#: ../../library/timeit.rst:171
#, fuzzy
msgid ""
"It's tempting to calculate mean and standard deviation from the result "
"vector and report these.  However, this is not very useful. In a typical "
"case, the lowest value gives a lower bound for how fast your machine can run "
"the given code snippet; higher values in the result vector are typically not "
"caused by variability in Python's speed, but by other processes interfering "
"with your timing accuracy. So the :func:`min` of the result is probably the "
"only number you should be interested in.  After that, you should look at the "
"entire vector and apply common sense rather than statistics."
msgstr ""
"從結果向量計算平均值和標準差並報告這些是很誘人的。但是，這不是很有用。在典型"
"情況下，最低值給出了機器運行給定程式碼片段的速度下限；"
"結果向量中較高的值通常不是由 Python "
"速度的可變性引起的，而是由其他行程干擾您的計時精度引起的。所以結果的 "
":func:`min` 可能是您唯一應該感興趣的數字。之後，您應該查看整個向量並應用常識"
"而不是統計資料。"

#: ../../library/timeit.rst:187
#, fuzzy
msgid "Helper to print a traceback from the timed code."
msgstr "從定時程式碼印出回溯的助手。"

#: ../../library/timeit.rst:189
#, fuzzy
msgid "Typical use::"
msgstr "典型用途::"

#: ../../library/timeit.rst:197
#, fuzzy
msgid ""
"The advantage over the standard traceback is that source lines in the "
"compiled template will be displayed.  The optional *file* argument directs "
"where the traceback is sent; it defaults to :data:`sys.stderr`."
msgstr ""
"與標準回溯相比的優勢在於將顯示已編譯模板中的源程式碼行。可選的 *file* "
"參數指示回溯發送的位置；它預設為 :data:`sys.stderr`。"

#: ../../library/timeit.rst:205
msgid "Command-Line Interface"
msgstr "命令執行列介面"

#: ../../library/timeit.rst:207
#, fuzzy
msgid ""
"When called as a program from the command line, the following form is used::"
msgstr "當從命令列作為程式呼叫時，使用以下形式："

#: ../../library/timeit.rst:211
#, fuzzy
msgid "Where the following options are understood:"
msgstr "了解以下選項的地方："

#: ../../library/timeit.rst:217
#, fuzzy
msgid "how many times to execute 'statement'"
msgstr "執行“語句”多少次"

#: ../../library/timeit.rst:221
#, fuzzy
msgid "how many times to repeat the timer (default 5)"
msgstr "多少次重複定時器（預設5）"

#: ../../library/timeit.rst:225
#, fuzzy
msgid "statement to be executed once initially (default ``pass``)"
msgstr "最初執行一次的語句（預設``pass``）"

#: ../../library/timeit.rst:229
#, fuzzy
msgid ""
"measure process time, not wallclock time, using :func:`time.process_time` "
"instead of :func:`time.perf_counter`, which is the default"
msgstr ""
"測量行程時間，而不是掛鐘時間，使用 :func:`time.process_time` 而不是 "
":func:`time.perf_counter`，這是預設的"

#: ../../library/timeit.rst:236
#, fuzzy
msgid ""
"specify a time unit for timer output; can select ``nsec``, ``usec``, "
"``msec``, or ``sec``"
msgstr "指定定時器輸出的時間單位；可以選擇``nsec``、``usec``、``msec`` "
"或``sec``"

#: ../../library/timeit.rst:242
#, fuzzy
msgid "print raw timing results; repeat for more digits precision"
msgstr "印出原始計時結果；重複更多數字精度"

#: ../../library/timeit.rst:246
#, fuzzy
msgid "print a short usage message and exit"
msgstr "印出一條簡短的使用資訊並退出"

#: ../../library/timeit.rst:248
#, fuzzy
msgid ""
"A multi-line statement may be given by specifying each line as a separate "
"statement argument; indented lines are possible by enclosing an argument in "
"quotes and using leading spaces.  Multiple :option:`-s` options are treated "
"similarly."
msgstr ""
"可以通過將每一行指定為單獨的語句參數來給出多行語句；通過將參數括在引號中並使"
"用前導空格，可以實作縮進行。多個 :option:`-s` 選項的處理方式類似。"

#: ../../library/timeit.rst:253
#, fuzzy
msgid ""
"If :option:`-n` is not given, a suitable number of loops is calculated by "
"trying increasing numbers from the sequence 1, 2, 5, 10, 20, 50, ... until "
"the total time is at least 0.2 seconds."
msgstr "如果未給出 :option:`-n`，則通過嘗試從序列 1、2、5、10、20、50 "
"中遞增數字來計算合適的循環次數，直到總時間至少為 0.2 秒."

#: ../../library/timeit.rst:257
#, fuzzy
msgid ""
":func:`default_timer` measurements can be affected by other programs running "
"on the same machine, so the best thing to do when accurate timing is "
"necessary is to repeat the timing a few times and use the best time.  The :"
"option:`-r` option is good for this; the default of 5 repetitions is "
"probably enough in most cases.  You can use :func:`time.process_time` to "
"measure CPU time."
msgstr ""
":func:`default_timer` 測量可能會受到同一台機器上運行的其他程式的影響，因此當"
"需要準確計時時，最好的辦法是重複計時幾次並使用最佳時間。 :option:`-r` "
"選項對此很有用；在大多數情況下，預設的 5 次重複可能就足夠了。您可以使用 "
":func:`time.process_time` 來測量 CPU 時間。"

#: ../../library/timeit.rst:265
#, fuzzy
msgid ""
"There is a certain baseline overhead associated with executing a pass "
"statement. The code here doesn't try to hide it, but you should be aware of "
"it.  The baseline overhead can be measured by invoking the program without "
"arguments, and it might differ between Python versions."
msgstr ""
"執行 pass 語句會產生一定的基線開銷。此處的程式碼不會試圖隱藏它，但您應該意識"
"到這一點。基線開銷可以通過不帶參數呼叫程式來衡量，它可能因 Python 版本而異。"

#: ../../library/timeit.rst:274
msgid "Examples"
msgstr "範例"

#: ../../library/timeit.rst:276
#, fuzzy
msgid ""
"It is possible to provide a setup statement that is executed only once at "
"the beginning:"
msgstr "可以提供一個只在開始時執行一次的設定語句："

#: ../../library/timeit.rst:285
#, fuzzy
msgid ""
"In the output, there are three fields. The loop count, which tells you how "
"many times the statement body was run per timing loop repetition. The "
"repetition count ('best of 5') which tells you how many times the timing "
"loop was repeated, and finally the time the statement body took on average "
"within the best repetition of the timing loop. That is, the time the fastest "
"repetition took divided by the loop count."
msgstr ""
"在輸出中，有三個欄位。循環計數，它告訴您語句體在每次定時循環重複中運行了多少"
"次。重複計數（“5 次最佳”）告訴您計時循環重複了多少次，最後是語句主體在計時循"
"環的最佳重複中平均花費的時間。也就是說，最快的重複時間除以循環次數。"

#: ../../library/timeit.rst:300
#, fuzzy
msgid "The same can be done using the :class:`Timer` class and its methods::"
msgstr "使用 :class:`Timer` 類及其方法也可以完成同樣的工作："

#: ../../library/timeit.rst:310
#, fuzzy
msgid ""
"The following examples show how to time expressions that contain multiple "
"lines. Here we compare the cost of using :func:`hasattr` vs. :keyword:`try`/:"
"keyword:`except` to test for missing and present object attributes:"
msgstr ""
"以下示例顯示如何對包含多行的表達式計時。在這裡，我們比較了使用 "
":func:`hasattr` 和 :keyword:`try`/:keyword:`except` "
"來測試缺少和存在的物件屬性的成本："

#: ../../library/timeit.rst:356
#, fuzzy
msgid ""
"To give the :mod:`timeit` module access to functions you define, you can "
"pass a *setup* parameter which contains an import statement::"
msgstr "要讓 :mod:`timeit` 模組訪問您定義的函式，您可以傳遞一個包含導入語句的 *setup*"
" 參數::"

#: ../../library/timeit.rst:367
#, fuzzy
msgid ""
"Another option is to pass :func:`globals` to the  *globals* parameter, which "
"will cause the code to be executed within your current global namespace.  "
"This can be more convenient than individually specifying imports::"
msgstr ""
"另一種選擇是將 :func:`globals` 傳遞給 *globals* "
"參數，這將導致程式碼在您當前的全局命名空間內執行。這比單獨指定導入更方便："
