# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Adrian Liaw <adrianliaw2000@gmail.com>, 2018
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-24 00:16+0000\n"
"PO-Revision-Date: 2022-04-21 17:59+0800\n"
"Last-Translator: Jordan Su <newjordansu1126@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../library/urllib.request.rst:2
msgid ":mod:`urllib.request` --- Extensible library for opening URLs"
msgstr ":mod:`urllib.request` --- 用來開啟 URLs 的可擴充函式庫"

#: ../../library/urllib.request.rst:11
msgid "**Source code:** :source:`Lib/urllib/request.py`"
msgstr "**原始碼：**\\ :source:`Lib/urllib/request.py`"

#: ../../library/urllib.request.rst:15
msgid ""
"The :mod:`urllib.request` module defines functions and classes which help in "
"opening URLs (mostly HTTP) in a complex world --- basic and digest "
"authentication, redirections, cookies and more."
msgstr ""
":mod:`urllib.request` module（模組）定義了一些函式與 class（類別）用以開啟 "
"URLs（大部分是 HTTP），並處理各式複雜情況如：basic 驗證與 digest 驗證、重新導"
"向、cookies。"

#: ../../library/urllib.request.rst:21
msgid ""
"The `Requests package <https://requests.readthedocs.io/en/master/>`_ is "
"recommended for a higher-level HTTP client interface."
msgstr ""
"有關於更高階的 HTTP 用戶端介面，推薦使用 `Requests 套件 <https://requests."
"readthedocs.io/en/master/>`_\\ 。"

#: ../../includes/wasm-notavail.rst:3
#, fuzzy
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ":ref:`Availability <availability>`：不是 Emscripten，不是 WASI。"

#: ../../includes/wasm-notavail.rst:5
#, fuzzy
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"此模組在 WebAssembly 平台 ``wasm32-emscripten`` 和 ``wasm32-wasi`` 上不起作用或不可用"
"。有關更多資訊，請參閱 :ref:`wasm-availability`。"

#: ../../library/urllib.request.rst:26
msgid "The :mod:`urllib.request` module defines the following functions:"
msgstr ":mod:`urllib.request` module 定義下列函式："

#: ../../library/urllib.request.rst:31
msgid ""
"Open the URL *url*, which can be either a string or a :class:`Request` "
"object."
msgstr "打開 URL *url*，其值可以是一個字串或是一個 :class:`Request` 物件。"

#: ../../library/urllib.request.rst:34
msgid ""
"*data* must be an object specifying additional data to be sent to the "
"server, or ``None`` if no such data is needed.  See :class:`Request` for "
"details."
msgstr ""
"*data* 必須是一個包含傳送給伺服器額外資料的物件，若不需要傳送額外資料則指定"
"為 ``None``\\ 。更多細節請見 :class:`Request`\\ 。"

#: ../../library/urllib.request.rst:38
msgid ""
"urllib.request module uses HTTP/1.1 and includes ``Connection:close`` header "
"in its HTTP requests."
msgstr ""
"urllib.request module 使用 HTTP/1.1 並包含 ``Connection:close`` header（標"
"頭）在其 HTTP 請求中。"

#: ../../library/urllib.request.rst:41
msgid ""
"The optional *timeout* parameter specifies a timeout in seconds for blocking "
"operations like the connection attempt (if not specified, the global default "
"timeout setting will be used).  This actually only works for HTTP, HTTPS and "
"FTP connections."
msgstr ""
"透過選擇性參數 *timeout* 來指定 blocking operations（阻塞性操作，如：嘗試連"
"接）的 timeout（超時時間），以秒為單位。若沒有指定值，則會使用全域預設超時時"
"間設定。實際上，此參數僅作用於 HTTP、HTTPS 以及 FTP 的連接。"

#: ../../library/urllib.request.rst:46
msgid ""
"If *context* is specified, it must be a :class:`ssl.SSLContext` instance "
"describing the various SSL options. See :class:`~http.client."
"HTTPSConnection` for more details."
msgstr ""
"若 *context* 有被指定時，它必須是一個 :class:`ssl.SSLContext` 的實例並描述著"
"各種 SSL 選項。更多細節請見 :class:`~http.client.HTTPSConnection`\\ 。"

#: ../../library/urllib.request.rst:50
msgid ""
"The optional *cafile* and *capath* parameters specify a set of trusted CA "
"certificates for HTTPS requests.  *cafile* should point to a single file "
"containing a bundle of CA certificates, whereas *capath* should point to a "
"directory of hashed certificate files.  More information can be found in :"
"meth:`ssl.SSLContext.load_verify_locations`."
msgstr ""
"選擇性參數 *cafile* 與 *capath* 用來指定一組 HTTPS 請求中所需之受信任 CA 憑"
"證。*cafile* 的值應該指向內容包含一堆 CA 憑證的單一檔案，而 *capath* 則指向存"
"放一堆雜湊後的憑證檔案的目錄。欲瞭解更多的資訊請參見 :meth:`ssl.SSLContext."
"load_verify_locations`\\ 。"

#: ../../library/urllib.request.rst:56
msgid "The *cadefault* parameter is ignored."
msgstr "參數 *cadefault* 已被忽略。"

#: ../../library/urllib.request.rst:58
msgid ""
"This function always returns an object which can work as a :term:`context "
"manager` and has the properties *url*, *headers*, and *status*. See :class:"
"`urllib.response.addinfourl` for more detail on these properties."
msgstr ""
"這個函數總是回傳一個可作為 :term:`context manager` 使用的物件，並有著特性 "
"(property) *url*、*headers* 與 *status*。欲知更多這些特性細節請參見 :class:"
"`urllib.response.addinfourl`\\ 。"

#: ../../library/urllib.request.rst:62
msgid ""
"For HTTP and HTTPS URLs, this function returns a :class:`http.client."
"HTTPResponse` object slightly modified. In addition to the three new methods "
"above, the msg attribute contains the same information as the :attr:`~http."
"client.HTTPResponse.reason` attribute --- the reason phrase returned by "
"server --- instead of the response headers as it is specified in the "
"documentation for :class:`~http.client.HTTPResponse`."
msgstr ""
"對於 HTTP 與 HTTPS 的 URLs，這個函式回傳一個稍有不同的 :class:`http.client."
"HTTPResponse` 物件。除了上述提到的三個方法外，另有 msg 屬性並有著與 :attr:"
"`~http.client.HTTPResponse.reason` 相同的資訊 --- 由伺服器回傳的原因敘述 "
"(reason phrase)，而不是在 :class:`~http.client.HTTPResponse` 文件中提到的回"
"應 headers。"

#: ../../library/urllib.request.rst:70
msgid ""
"For FTP, file, and data URLs and requests explicitly handled by legacy :"
"class:`URLopener` and :class:`FancyURLopener` classes, this function returns "
"a :class:`urllib.response.addinfourl` object."
msgstr ""
"對於 FTP、檔案、資料的 URLs、以及那些由傳統 classes :class:`URLopener` 與 :"
"class:`FancyURLopener` 所處理的請求，這個函式會回傳一個 :class:`urllib."
"response.addinfourl` 物件。"

#: ../../library/urllib.request.rst:74
msgid "Raises :exc:`~urllib.error.URLError` on protocol errors."
msgstr "當遇到協定上的錯誤時會引發 :exc:`~urllib.error.URLError`\\ 。"

#: ../../library/urllib.request.rst:76
msgid ""
"Note that ``None`` may be returned if no handler handles the request (though "
"the default installed global :class:`OpenerDirector` uses :class:"
"`UnknownHandler` to ensure this never happens)."
msgstr ""
"請注意若沒有 handler 處理請求時，``None`` 值將會被回傳。（即使有預設的全域類"
"別 :class:`OpenerDirector` 使用 :class:`UnknownHandler` 來確保這種情況不會發"
"生）"

#: ../../library/urllib.request.rst:80
msgid ""
"In addition, if proxy settings are detected (for example, when a ``*_proxy`` "
"environment variable like :envvar:`http_proxy` is set), :class:"
"`ProxyHandler` is default installed and makes sure the requests are handled "
"through the proxy."
msgstr ""
"另外，若有偵測到代理服務的設定（例如當 ``*_proxy`` 環境變數像是：\\ :envvar:"
"`http_proxy` 有被設置時），:class:`ProxyHandler` 會被預設使用以確保請求有透過"
"代理服務來處理。"

#: ../../library/urllib.request.rst:85
msgid ""
"The legacy ``urllib.urlopen`` function from Python 2.6 and earlier has been "
"discontinued; :func:`urllib.request.urlopen` corresponds to the old "
"``urllib2.urlopen``.  Proxy handling, which was done by passing a dictionary "
"parameter to ``urllib.urlopen``, can be obtained by using :class:"
"`ProxyHandler` objects."
msgstr ""
"Python 2.6 或更早版本的遺留函式 ``urllib.urlopen`` 已經不再被維護；新函式 :"
"func:`urllib.request.urlopen` 對應到舊函式 ``urllib2.urlopen``。有關代理服務"
"的處理，以往是透過傳遞 dictionary（字典）參數給 ``urllib.urlopen`` 來取得的，"
"現在則可以透過 :class:`ProxyHandler` 物件來取得。"

#: ../../library/urllib.request.rst:102
msgid ""
"Raises an :ref:`auditing event <auditing>` ``urllib.Request`` with arguments "
"``fullurl``, ``data``, ``headers``, ``method``."
msgstr ""
"觸發一個 :ref:`auditing event <auditing>` ``urllib.Request`` 及其引數 "
"``fullurl``、``data``、``headers``、``method``。"

#: ../../library/urllib.request.rst:93
msgid ""
"The default opener raises an :ref:`auditing event <auditing>` ``urllib."
"Request`` with arguments ``fullurl``, ``data``, ``headers``, ``method`` "
"taken from the request object."
msgstr ""
"預設的 opener 會觸發一個 :ref:`auditing event <auditing>` ``urllib.Request`` "
"與其從請求物件中所獲得的引數 ``fullurl``、``data``、``headers``、``method``。"

#: ../../library/urllib.request.rst:97
msgid "*cafile* and *capath* were added."
msgstr "新增 *cafile* 與 *capath*。"

#: ../../library/urllib.request.rst:100
msgid ""
"HTTPS virtual hosts are now supported if possible (that is, if :data:`ssl."
"HAS_SNI` is true)."
msgstr ""
"HTTPS 虛擬主機 (virtual hosts) 現已支援，只要 :data:`ssl.HAS_SNI` 的值為 "
"true。"

#: ../../library/urllib.request.rst:104
msgid "*data* can be an iterable object."
msgstr "*data* 可以是一個可疊代物件。"

#: ../../library/urllib.request.rst:107
msgid "*cadefault* was added."
msgstr "*cadefault* 被新增。"

#: ../../library/urllib.request.rst:110
msgid "*context* was added."
msgstr "*context* 被新增。"

#: ../../library/urllib.request.rst:113
msgid ""
"HTTPS connection now send an ALPN extension with protocol indicator "
"``http/1.1`` when no *context* is given. Custom *context* should set ALPN "
"protocols with :meth:`~ssl.SSLContext.set_alpn_protocol`."
msgstr ""
"當 *context* 沒有被指定時，HTTPS 連線現在會傳送一個帶有協定指示器 "
"``http/1.1`` 的 ALPN 擴充 (extension)。自訂的 *context* 應該利用 :meth:`~ssl."
"SSLContext.set_alpn_protocol` 來自行設定 ALPN 協定。"

#: ../../library/urllib.request.rst:120
msgid ""
"*cafile*, *capath* and *cadefault* are deprecated in favor of *context*. "
"Please use :meth:`ssl.SSLContext.load_cert_chain` instead, or let :func:`ssl."
"create_default_context` select the system's trusted CA certificates for you."
msgstr ""
"*cafile*、*capath*、*cadefault* 已經被棄用並應改為使用 *context*。請改用 :"
"meth:`ssl.SSLContext.load_cert_chain`，或是讓 :func:`ssl."
"create_default_context` 選取系統中受信任的 CA 憑證。"

#: ../../library/urllib.request.rst:128
msgid ""
"Install an :class:`OpenerDirector` instance as the default global opener. "
"Installing an opener is only necessary if you want urlopen to use that "
"opener; otherwise, simply call :meth:`OpenerDirector.open` instead of :func:"
"`~urllib.request.urlopen`.  The code does not check for a real :class:"
"`OpenerDirector`, and any class with the appropriate interface will work."
msgstr ""
"安裝一個 :class:`OpenerDirector` 實例作為預設的全域 opener。僅在當你想要讓 "
"urlopen 使用該 opener 時安裝一個 opener，否則的話應直接呼叫 :meth:"
"`OpenerDirector.open` 而非 :func:`~urllib.request.urlopen`\\ 。程式碼不會檢"
"查 class 是否真的為 :class:`OpenerDirector`，而是任何具有正確介面的 class 都"
"能適用。"

#: ../../library/urllib.request.rst:138
msgid ""
"Return an :class:`OpenerDirector` instance, which chains the handlers in the "
"order given. *handler*\\s can be either instances of :class:`BaseHandler`, "
"or subclasses of :class:`BaseHandler` (in which case it must be possible to "
"call the constructor without any parameters).  Instances of the following "
"classes will be in front of the *handler*\\s, unless the *handler*\\s "
"contain them, instances of them or subclasses of them: :class:`ProxyHandler` "
"(if proxy settings are detected), :class:`UnknownHandler`, :class:"
"`HTTPHandler`, :class:`HTTPDefaultErrorHandler`, :class:"
"`HTTPRedirectHandler`, :class:`FTPHandler`, :class:`FileHandler`, :class:"
"`HTTPErrorProcessor`."
msgstr ""
"回傳一個 :class:`OpenerDirector` 實例，以給定的順序把 handlers 串接起來。"
"*handler*\\s 可以是 :class:`BaseHandler` 的實例，亦或是 :class:`BaseHandler` "
"的 subclasses（這個情況下必須有不帶參數的建構函式能夠被呼叫）。以下 classes "
"的實例順位會在 *handler*\\s 之前，除非 *handler*\\s 已經包含它們，是它們的實"
"例，或是它們的 subclasses：\\ :class:`ProxyHandler`\\ （如果代理服務設定被偵"
"測到）、\\ :class:`UnknownHandler`\\ 、\\ :class:`HTTPHandler`\\ 、\\ :class:"
"`HTTPDefaultErrorHandler`\\ 、\\ :class:`HTTPRedirectHandler`\\ 、\\ :class:"
"`FTPHandler`\\ 、\\ :class:`FileHandler`\\ 、\\ :class:"
"`HTTPErrorProcessor`\\ 。"

#: ../../library/urllib.request.rst:148
msgid ""
"If the Python installation has SSL support (i.e., if the :mod:`ssl` module "
"can be imported), :class:`HTTPSHandler` will also be added."
msgstr ""
"如果 Python 安裝時已帶有 SSL 支援（如果 :mod:`ssl` module 能夠被 import），"
"則 :class:`HTTPSHandler` 也在上述 class 之中。"

#: ../../library/urllib.request.rst:151
msgid ""
"A :class:`BaseHandler` subclass may also change its :attr:`handler_order` "
"attribute to modify its position in the handlers list."
msgstr ""
"一個 :class:`BaseHandler` 的 subclass 可能透過改變其 :attr:`handler_order` 屬"
"性來調整它在 handlers list 中的位置。"

#: ../../library/urllib.request.rst:157
msgid ""
"Convert the pathname *path* from the local syntax for a path to the form "
"used in the path component of a URL.  This does not produce a complete URL.  "
"The return value will already be quoted using the :func:`~urllib.parse."
"quote` function."
msgstr ""
"將路徑名 *path* 從路徑的本地語法 (local syntax) 轉換為 URL 中的 path "
"component（路徑元件）格式。本函式並不會產生完整的 URL。回傳值將使用 :func:"
"`~urllib.parse.quote` 函式先進行編碼過。"

#: ../../library/urllib.request.rst:164
msgid ""
"Convert the path component *path* from a percent-encoded URL to the local "
"syntax for a path.  This does not accept a complete URL.  This function "
"uses :func:`~urllib.parse.unquote` to decode *path*."
msgstr ""
"將一個用 \"%\" 編碼過的 URL path component *path* 轉換為路徑的本地語法 "
"(local syntax)。本函式並不接受完整的 URL。本函式使用 :func:`~urllib.parse."
"unquote` 來將 *path* 解碼。"

#: ../../library/urllib.request.rst:170
msgid ""
"This helper function returns a dictionary of scheme to proxy server URL "
"mappings. It scans the environment for variables named ``<scheme>_proxy``, "
"in a case insensitive approach, for all operating systems first, and when it "
"cannot find it, looks for proxy information from System Configuration for "
"macOS and Windows Systems Registry for Windows. If both lowercase and "
"uppercase environment variables exist (and disagree), lowercase is preferred."
msgstr ""
"這個輔助函式 (helper function) 回傳一個代理伺服器 URL mappings（對映）的 "
"dictionary。在所有的作業系統中，它首先掃描環境中有著 ``<scheme>_proxy`` 名稱"
"的變數（忽略大小寫的），如果找不到的話就會在 macOS 中的系統設定 (System "
"Configuration) 或是 Windows 系統中的 Windows Systems Registry 尋找代理服務設"
"定。如果大小寫的環境變數同時存在且值有不同，小寫的環境變數會被選用。"

#: ../../library/urllib.request.rst:180
msgid ""
"If the environment variable ``REQUEST_METHOD`` is set, which usually "
"indicates your script is running in a CGI environment, the environment "
"variable ``HTTP_PROXY`` (uppercase ``_PROXY``) will be ignored. This is "
"because that variable can be injected by a client using the \"Proxy:\" HTTP "
"header. If you need to use an HTTP proxy in a CGI environment, either use "
"``ProxyHandler`` explicitly, or make sure the variable name is in lowercase "
"(or at least the ``_proxy`` suffix)."
msgstr ""
"如果環境變數 ``REQUEST_METHOD`` 有被設置（通常這代表著你的 script 是運行在一"
"個共用閘道介面 (CGI) 環境中），那麼環境變數 ``HTTP_PROXY`` （大寫的 "
"``_PROXY``）將被忽略。這是因為變數可以透過使用 \"Proxy:\" HTTP header 被注"
"入。如果需要在共用閘道介面環境中使用 HTTP 代理服務，可以明確使用 "
"``ProxyHandler``，亦或是確認變數名稱是小寫的（或至少 ``_proxy`` 後綴是小寫"
"的）。"

#: ../../library/urllib.request.rst:189
msgid "The following classes are provided:"
msgstr "提供了以下的 classes："

#: ../../library/urllib.request.rst:193
msgid "This class is an abstraction of a URL request."
msgstr "這個 class 是一個 URL 請求的抽象 class。"

#: ../../library/urllib.request.rst:195
msgid "*url* should be a string containing a valid URL."
msgstr "*url* 是一個包含有效 URL 的字串。"

#: ../../library/urllib.request.rst:197
msgid ""
"*data* must be an object specifying additional data to send to the server, "
"or ``None`` if no such data is needed.  Currently HTTP requests are the only "
"ones that use *data*.  The supported object types include bytes, file-like "
"objects, and iterables of bytes-like objects. If no ``Content-Length`` nor "
"``Transfer-Encoding`` header field has been provided, :class:`HTTPHandler` "
"will set these headers according to the type of *data*.  ``Content-Length`` "
"will be used to send bytes objects, while ``Transfer-Encoding: chunked`` as "
"specified in :rfc:`7230`, Section 3.3.1 will be used to send files and other "
"iterables."
msgstr ""
"*data* 必須是一個包含要送到伺服器的附加資料的物件，若不需帶附加資料則其值應"
"為 ``None``。目前 HTTP 請求是唯一有使用 *data* 參數的，其支援的物件型別包含位"
"元組、類檔案物件 (file-like objects)、以及可疊代的類位元組串物件 (bytes-like "
"objects)。如果沒有提供 ``Content-Length`` 及 ``Transfer-Encoding`` headers 欄"
"位，:class:`HTTPHandler` 將會根據 *data* 的型別設置這些 header。``Content-"
"Length`` 會被用來傳送位元組串物件，而 :rfc:`7230` 章節 3.3.1 所定義的 "
"``Transfer-Encoding: chunked`` 則會被用來傳送檔案或是其它可疊代物件 "
"(iterables)。"

#: ../../library/urllib.request.rst:207
msgid ""
"For an HTTP POST request method, *data* should be a buffer in the standard :"
"mimetype:`application/x-www-form-urlencoded` format.  The :func:`urllib."
"parse.urlencode` function takes a mapping or sequence of 2-tuples and "
"returns an ASCII string in this format. It should be encoded to bytes before "
"being used as the *data* parameter."
msgstr ""
"對於一個 HTTP POST 請求方法，*data* 應為一個標準 :mimetype:`application/x-"
"www-form-urlencoded` 格式的 buffer。:func:`urllib.parse.urlencode` 方法接受一"
"個 mapping 或是 sequence（序列）的 2-tuples，並回傳一個對應格式的 ASCII 字"
"串。在被作為 *data* 參數前它應該被編碼成位元組串。"

#: ../../library/urllib.request.rst:213
msgid ""
"*headers* should be a dictionary, and will be treated as if :meth:"
"`add_header` was called with each key and value as arguments. This is often "
"used to \"spoof\" the ``User-Agent`` header value, which is used by a "
"browser to identify itself -- some HTTP servers only allow requests coming "
"from common browsers as opposed to scripts. For example, Mozilla Firefox may "
"identify itself as ``\"Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 "
"Firefox/2.0.0.11\"``, while :mod:`urllib`'s default user agent string is "
"``\"Python-urllib/2.6\"`` (on Python 2.6). All header keys are sent in camel "
"case."
msgstr ""
"*headers* 必須是一個 dictionary，並會被視為如同每對 key 和 value 作為引數來呼"
"叫 :meth:`add_header`\\ 。經常用於「偽裝」 ``User-Agent``  header 的值，這個 "
"header 是用來讓一個瀏覽器向伺服器表明自己的身分 --- 有些 HTTP 伺服器僅允許來"
"自普通瀏覽器的請求，而不接受來自程式腳本的請求。例如，Mozilla Firefox 會將 "
"header 的值設為 ``\"Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 "
"Firefox/2.0.0.11\"``，而 :mod:`urllib` 的值則是 ``\"Python-urllib/2.6\"``\\ "
"（在 Python 2.6 上）。所有 header 的鍵都會以 camel case（駝峰式大小寫）來傳"
"送。"

#: ../../library/urllib.request.rst:224
msgid ""
"An appropriate ``Content-Type`` header should be included if the *data* "
"argument is present.  If this header has not been provided and *data* is not "
"None, ``Content-Type: application/x-www-form-urlencoded`` will be added as a "
"default."
msgstr ""
"當有給定 *data* 引數時，一個適當的 ``Content-Type`` header 應該被設置。如果這"
"個 header 沒有被提供且 *data* 也不為 None 時，預設值 ``Content-Type: "
"application/x-www-form-urlencoded`` 會被新增至請求中。"

#: ../../library/urllib.request.rst:229
msgid ""
"The next two arguments are only of interest for correct handling of third-"
"party HTTP cookies:"
msgstr ""
"接下來的兩個引數的介紹提供給那些有興趣正確處理第三方 HTTP cookies 的使用者："

#: ../../library/urllib.request.rst:232
msgid ""
"*origin_req_host* should be the request-host of the origin transaction, as "
"defined by :rfc:`2965`.  It defaults to ``http.cookiejar."
"request_host(self)``.  This is the host name or IP address of the original "
"request that was initiated by the user. For example, if the request is for "
"an image in an HTML document, this should be the request-host of the request "
"for the page containing the image."
msgstr ""
"*origin_req_host* 應為原始傳輸互動的請求主機 (request-host)，如同在 :rfc:"
"`2965` 中的定義。預設值為 ``http.cookiejar.request_host(self)``\\ 。這是使用"
"者發起的原始請求的主機名稱或是 IP 位址。例如當請求是要求一個 HTML 文件中的一"
"個影像，則這個屬性應為請求包含影像頁面的請求主機。"

#: ../../library/urllib.request.rst:240
msgid ""
"*unverifiable* should indicate whether the request is unverifiable, as "
"defined by :rfc:`2965`.  It defaults to ``False``.  An unverifiable request "
"is one whose URL the user did not have the option to approve.  For example, "
"if the request is for an image in an HTML document, and the user had no "
"option to approve the automatic fetching of the image, this should be true."
msgstr ""
"*unverifiable* 應該標示一個請求是否是無法驗證的，如同在 :rfc:`2965` 中的定"
"義。其預設值為 ``False``。一個無法驗證的請求是指使用者沒有機會去批准請求的 "
"URL，例如一個對於 HTML 文件中的影像所做的請求，而使用者沒有機會去批准是否能自"
"動擷取影像，則這個值應該為 true。"

#: ../../library/urllib.request.rst:247
msgid ""
"*method* should be a string that indicates the HTTP request method that will "
"be used (e.g. ``'HEAD'``).  If provided, its value is stored in the :attr:"
"`~Request.method` attribute and is used by :meth:`get_method()`. The default "
"is ``'GET'`` if *data* is ``None`` or ``'POST'`` otherwise. Subclasses may "
"indicate a different default method by setting the :attr:`~Request.method` "
"attribute in the class itself."
msgstr ""
"*method* 應為一個標示 HTTP 請求方法的字串（例如：``'HEAD'``）。如果有提供值，"
"則會被存在 :attr:`~Request.method` 屬性中且被 :meth:`get_method()` 所使用。"
"當 *data* 是 ``None`` 時，其預設值為 ``'GET'``，否則預設值為 ``'POST'``。"
"Subclasses 可以透過設置其 :attr:`~Request.method` 屬性來設定不一樣的預設請求"
"方法。"

#: ../../library/urllib.request.rst:255
msgid ""
"The request will not work as expected if the data object is unable to "
"deliver its content more than once (e.g. a file or an iterable that can "
"produce the content only once) and the request is retried for HTTP redirects "
"or authentication.  The *data* is sent to the HTTP server right away after "
"the headers.  There is no support for a 100-continue expectation in the "
"library."
msgstr ""
"如果資料物件無法重複提供其內容（例如一個檔案或是只能產生一次內容的可疊代物"
"件）且請求因為 HTTP 重導向 (redirects) 或是 HTTP 驗證 (authentication) 而被重"
"新嘗試傳送，則該請求不會正常運作。*data* 會接在 headers 之後被送至 HTTP 伺服"
"器。此函式庫沒有支援 100-continue expectation。"

#: ../../library/urllib.request.rst:262
msgid ":attr:`Request.method` argument is added to the Request class."
msgstr "新增 :attr:`Request.method` 引數到 Request class。"

#: ../../library/urllib.request.rst:265
msgid "Default :attr:`Request.method` may be indicated at the class level."
msgstr "能夠在 class 中設置預設的 :attr:`Request.method`\\ 。"

#: ../../library/urllib.request.rst:268
msgid ""
"Do not raise an error if the ``Content-Length`` has not been provided and "
"*data* is neither ``None`` nor a bytes object. Fall back to use chunked "
"transfer encoding instead."
msgstr ""
"如果 ``Content-Length`` 尚未被提供且 *data* 既不是 ``None`` 也不是一個位元組"
"串物件，則不會觸發錯誤，並 fall back（後備）使用分塊傳輸編碼 (chunked "
"transfer encoding)。"

#: ../../library/urllib.request.rst:275
#, fuzzy
msgid ""
"The :class:`OpenerDirector` class opens URLs via :class:`BaseHandler`\\ s "
"chained together. It manages the chaining of handlers, and recovery from "
"errors."
msgstr ""
":class:`OpenerDirector` 類通過鏈接在一起的 :class:`BaseHandler`\\ 打開 "
"URL。它管理處理程式的鏈接，以及從錯誤中恢復。"

#: ../../library/urllib.request.rst:281
#, fuzzy
msgid ""
"This is the base class for all registered handlers --- and handles only the "
"simple mechanics of registration."
msgstr "這是所有已註冊處理程式的基底類別——並且僅處理簡單的註冊機制。"

#: ../../library/urllib.request.rst:287
#, fuzzy
msgid ""
"A class which defines a default handler for HTTP error responses; all "
"responses are turned into :exc:`~urllib.error.HTTPError` exceptions."
msgstr "定義 HTTP 錯誤響應的預設處理程式的類；所有響應都變成 :exc:`~urllib.error."
"HTTPError` 例外。"

#: ../../library/urllib.request.rst:293
#, fuzzy
msgid "A class to handle redirections."
msgstr "一個處理重定向的類。"

#: ../../library/urllib.request.rst:298
#, fuzzy
msgid "A class to handle HTTP Cookies."
msgstr "一個處理 HTTP Cookies 的類。"

#: ../../library/urllib.request.rst:303
#, fuzzy
msgid ""
"Cause requests to go through a proxy. If *proxies* is given, it must be a "
"dictionary mapping protocol names to URLs of proxies. The default is to read "
"the list of proxies from the environment variables ``<protocol>_proxy``.  If "
"no proxy environment variables are set, then in a Windows environment proxy "
"settings are obtained from the registry's Internet Settings section, and in "
"a macOS environment proxy information is retrieved from the System "
"Configuration Framework."
msgstr ""
"導致請求通過代理。如果給出了 *proxies*，它必須是一個將協定名稱映射到代理 URL "
"的字典。預設是從環境變數``<protocol>_proxy``中讀取代理列表。如果未設定代理環"
"境變數，則在 Windows 環境中代理設定是從註冊表的 Internet 設定部分獲取的，"
"而在 macOS 環境中代理資訊是從系統配置框架中檢索的。"

#: ../../library/urllib.request.rst:311
#, fuzzy
msgid "To disable autodetected proxy pass an empty dictionary."
msgstr "要禁用自動檢測的代理，請傳遞一個空字典。"

#: ../../library/urllib.request.rst:313
#, fuzzy
msgid ""
"The :envvar:`no_proxy` environment variable can be used to specify hosts "
"which shouldn't be reached via proxy; if set, it should be a comma-separated "
"list of hostname suffixes, optionally with ``:port`` appended, for example "
"``cern.ch,ncsa.uiuc.edu,some.host:8080``."
msgstr ""
":envvar:`no_proxy` 環境變數可用於指定不應通過代理訪問的主機；如果設定，它應該"
"是一個以逗號分隔的主機名後綴列表，可以選擇附加“:port”，例如“cern.ch,ncsa.uiuc"
".edu,some.host:8080”。"

#: ../../library/urllib.request.rst:320
#, fuzzy
msgid ""
"``HTTP_PROXY`` will be ignored if a variable ``REQUEST_METHOD`` is set; see "
"the documentation on :func:`~urllib.request.getproxies`."
msgstr ""
"如果設定了變數“REQUEST_METHOD”，“HTTP_PROXY”將被忽略；請參閱有關 "
":func:`~urllib.request.getproxies` 的文檔。"

#: ../../library/urllib.request.rst:326
#, fuzzy
msgid "Keep a database of  ``(realm, uri) -> (user, password)`` mappings."
msgstr "保留``(realm, uri) -> (user, password)`` 映射的資料庫。"

#: ../../library/urllib.request.rst:331
#, fuzzy
msgid ""
"Keep a database of  ``(realm, uri) -> (user, password)`` mappings. A realm "
"of ``None`` is considered a catch-all realm, which is searched if no other "
"realm fits."
msgstr ""
"保留``(realm, uri) -> (user, password)`` 映射的資料庫。一個 ``None`` 的領域被認為是"
"一個包羅萬象的領域，如果沒有其他領域適合，就會搜索它。"

#: ../../library/urllib.request.rst:338
#, fuzzy
msgid ""
"A variant of :class:`HTTPPasswordMgrWithDefaultRealm` that also has a "
"database of ``uri -> is_authenticated`` mappings.  Can be used by a "
"BasicAuth handler to determine when to send authentication credentials "
"immediately instead of waiting for a ``401`` response first."
msgstr ""
":class:`HTTPPasswordMgrWithDefaultRealm` 的一個變體，它也有一個 ``uri -> "
"is_authenticated`` 映射的資料庫。 BasicAuth "
"處理程式可以使用它來確定何時立即發送身份驗證憑據，而不是先等待 ``401``響應。"

#: ../../library/urllib.request.rst:348
#, fuzzy
msgid ""
"This is a mixin class that helps with HTTP authentication, both to the "
"remote host and to a proxy. *password_mgr*, if given, should be something "
"that is compatible with :class:`HTTPPasswordMgr`; refer to section :ref:"
"`http-password-mgr` for information on the interface that must be "
"supported.  If *passwd_mgr* also provides ``is_authenticated`` and "
"``update_authenticated`` methods (see :ref:`http-password-mgr-with-prior-"
"auth`), then the handler will use the ``is_authenticated`` result for a "
"given URI to determine whether or not to send authentication credentials "
"with the request.  If ``is_authenticated`` returns ``True`` for the URI, "
"credentials are sent.  If ``is_authenticated`` is ``False``, credentials are "
"not sent, and then if a ``401`` response is received the request is re-sent "
"with the authentication credentials.  If authentication succeeds, "
"``update_authenticated`` is called to set ``is_authenticated`` ``True`` for "
"the URI, so that subsequent requests to the URI or any of its super-URIs "
"will automatically include the authentication credentials."
msgstr ""
"這是一個混合類，有助於對遠程主機和代理進行 HTTP 身份驗證。 "
"*password_mgr*，如果給定的話，應該是與 HTTPPasswordMgr "
"相容的東西；有關必須支援的介面的資訊，請參閱 :ref:`http-password-mgr` "
"部分。如果*passwd_mgr* 還提供了``is_authenticated`` "
"和``update_authenticated`` 方法（參見 :ref:`http-password-mgr-with-prior-"
"auth`），那麼處理程式將使用``is_authenticated`` 結果對於給定的 "
"URI，以確定是否隨請求發送身份驗證憑據。如果 ``is_authenticated`` 為 URI 回傳 "
"``True``，則發送憑據。如果 ``is_authenticated`` 為 ``False``，則不發送憑據，"
"然後如果收到 ``401`` "
"響應，則將使用身份驗證憑據重新發送請求。如果身份驗證成功，將呼叫 "
"``update_authenticated`` 為 URI 設定 ``is_authenticated`` ``True``，以便對 "
"URI 或其任何超級 URI 的後續請求將自動包含身份驗證憑據。"

#: ../../library/urllib.request.rst:365
msgid "Added ``is_authenticated`` support."
msgstr "新增 ``is_authenticated`` 的支援。"

#: ../../library/urllib.request.rst:371
#, fuzzy
msgid ""
"Handle authentication with the remote host. *password_mgr*, if given, should "
"be something that is compatible with :class:`HTTPPasswordMgr`; refer to "
"section :ref:`http-password-mgr` for information on the interface that must "
"be supported. HTTPBasicAuthHandler will raise a :exc:`ValueError` when "
"presented with a wrong Authentication scheme."
msgstr ""
"處理與遠程主機的身份驗證。 *password_mgr*，如果給定的話，應該是與 "
"HTTPPasswordMgr 相容的東西；有關必須支援的介面的資訊，請參閱 :ref:`http-"
"password-mgr` 部分。當出現錯誤的身份驗證方案時，HTTPBasicAuthHandler 將引發 "
":exc:`ValueError`。"

#: ../../library/urllib.request.rst:380 ../../library/urllib.request.rst:414
#, fuzzy
msgid ""
"Handle authentication with the proxy. *password_mgr*, if given, should be "
"something that is compatible with :class:`HTTPPasswordMgr`; refer to "
"section :ref:`http-password-mgr` for information on the interface that must "
"be supported."
msgstr ""
"使用代理處理身份驗證。 *password_mgr*，如果給定的話，應該是與 "
"HTTPPasswordMgr 相容的東西；有關必須支援的介面的資訊，請參閱 :ref:`http-"
"password-mgr` 部分。"

#: ../../library/urllib.request.rst:388
#, fuzzy
msgid ""
"This is a mixin class that helps with HTTP authentication, both to the "
"remote host and to a proxy. *password_mgr*, if given, should be something "
"that is compatible with :class:`HTTPPasswordMgr`; refer to section :ref:"
"`http-password-mgr` for information on the interface that must be supported."
msgstr ""
"這是一個混合類，有助於對遠程主機和代理進行 HTTP 身份驗證。 "
"*password_mgr*，如果給定的話，應該是與 HTTPPasswordMgr "
"相容的東西；有關必須支援的介面的資訊，請參閱 :ref:`http-password-mgr` 部分。"

#: ../../library/urllib.request.rst:397
#, fuzzy
msgid ""
"Handle authentication with the remote host. *password_mgr*, if given, should "
"be something that is compatible with :class:`HTTPPasswordMgr`; refer to "
"section :ref:`http-password-mgr` for information on the interface that must "
"be supported. When both Digest Authentication Handler and Basic "
"Authentication Handler are both added, Digest Authentication is always tried "
"first. If the Digest Authentication returns a 40x response again, it is sent "
"to Basic Authentication handler to Handle.  This Handler method will raise "
"a :exc:`ValueError` when presented with an authentication scheme other than "
"Digest or Basic."
msgstr ""
"處理與遠程主機的身份驗證。 *password_mgr*，如果給定的話，應該是與 "
"HTTPPasswordMgr 相容的東西；有關必須支援的介面的資訊，請參閱 :ref:`http-"
"password-mgr` 部分。當同時新增 Digest Authentication Handler 和 Basic "
"Authentication Handler 時，總是先嘗試 Digest Authentication。如果 Digest "
"Authentication 再次回傳 40x 響應，則將其發送到 Basic Authentication handler "
"進行處理。當使用 Digest 或 Basic 以外的身份驗證方案時，此處理程式方法將引發 "
":exc:`ValueError`。"

#: ../../library/urllib.request.rst:407
#, fuzzy
msgid "Raise :exc:`ValueError` on unsupported Authentication Scheme."
msgstr "在不支援的身份驗證方案上引發 :exc:`ValueError`。"

#: ../../library/urllib.request.rst:422
#, fuzzy
msgid "A class to handle opening of HTTP URLs."
msgstr "處理 HTTP URL 打開的類。"

#: ../../library/urllib.request.rst:427
#, fuzzy
msgid ""
"A class to handle opening of HTTPS URLs.  *context* and *check_hostname* "
"have the same meaning as in :class:`http.client.HTTPSConnection`."
msgstr ""
"處理 HTTPS URL 打開的類。 *context* 和 *check_hostname* 與 "
"http.client.HTTPSConnection 中的含義相同。"

#: ../../library/urllib.request.rst:430
msgid "*context* and *check_hostname* were added."
msgstr "新增 *context* 與 *check_hostname*\\ 。"

#: ../../library/urllib.request.rst:436
#, fuzzy
msgid "Open local files."
msgstr "打開本地文件。"

#: ../../library/urllib.request.rst:440
#, fuzzy
msgid "Open data URLs."
msgstr "打開資料 URL。"

#: ../../library/urllib.request.rst:446
#, fuzzy
msgid "Open FTP URLs."
msgstr "打開 FTP URL。"

#: ../../library/urllib.request.rst:451
#, fuzzy
msgid ""
"Open FTP URLs, keeping a cache of open FTP connections to minimize delays."
msgstr "打開 FTP URL，保留打開的 FTP 連接的快取以最大程度地減少延遲。"

#: ../../library/urllib.request.rst:456
#, fuzzy
msgid "A catch-all class to handle unknown URLs."
msgstr "一個用於處理未知 URL 的包羅萬象的類。"

#: ../../library/urllib.request.rst:461 ../../library/urllib.request.rst:1167
#, fuzzy
msgid "Process HTTP error responses."
msgstr "處理 HTTP 錯誤響應。"

#: ../../library/urllib.request.rst:467
#, fuzzy
msgid "Request Objects"
msgstr "請求物件"

#: ../../library/urllib.request.rst:469
#, fuzzy
msgid ""
"The following methods describe :class:`Request`'s public interface, and so "
"all may be overridden in subclasses.  It also defines several public "
"attributes that can be used by clients to inspect the parsed request."
msgstr ""
"以下方法描述了 Request 的公開介面，因此所有方法都可以在子類別中被覆蓋。它還定"
"義了幾個公開屬性，客戶端可以使用這些屬性來檢查已解析的請求。"

#: ../../library/urllib.request.rst:476
#, fuzzy
msgid "The original URL passed to the constructor."
msgstr "傳遞給構造函式的原始 URL。"

#: ../../library/urllib.request.rst:480
#, fuzzy
msgid ""
"Request.full_url is a property with setter, getter and a deleter. Getting :"
"attr:`~Request.full_url` returns the original request URL with the fragment, "
"if it was present."
msgstr ""
"Request.full_url 是一個具有 setter、getter 和 deleter 的屬性。獲取 "
":attr:`~Request.full_url` 回傳帶有片段的原始請求 URL（如果存在）。"

#: ../../library/urllib.request.rst:486
#, fuzzy
msgid "The URI scheme."
msgstr "URI 方案。"

#: ../../library/urllib.request.rst:490
#, fuzzy
msgid ""
"The URI authority, typically a host, but may also contain a port separated "
"by a colon."
msgstr "URI 權威，通常是一個主機，但也可能包含一個由冒號分隔的端口。"

#: ../../library/urllib.request.rst:495
#, fuzzy
msgid "The original host for the request, without port."
msgstr "請求的原始主機，沒有端口。"

#: ../../library/urllib.request.rst:499
#, fuzzy
msgid ""
"The URI path.  If the :class:`Request` uses a proxy, then selector will be "
"the full URL that is passed to the proxy."
msgstr "URI 路徑。如果 :class:`Request` 使用代理，則選擇器將是傳遞給代理的完整 URL。"

#: ../../library/urllib.request.rst:504
#, fuzzy
msgid "The entity body for the request, or ``None`` if not specified."
msgstr "請求的實體主體，如果未指定，則為 ``None`` 。"

#: ../../library/urllib.request.rst:506
#, fuzzy
msgid ""
"Changing value of :attr:`Request.data` now deletes \"Content-Length\" header "
"if it was previously set or calculated."
msgstr "更改 :attr:`Request.data` 的值現在會刪除“Content-"
"Length”標頭（如果之前已設定或計算）。"

#: ../../library/urllib.request.rst:512
#, fuzzy
msgid ""
"boolean, indicates whether the request is unverifiable as defined by :rfc:"
"`2965`."
msgstr "布爾值，指示請求是否不可驗證，如 :rfc:`2965` 所定義。"

#: ../../library/urllib.request.rst:517
#, fuzzy
msgid ""
"The HTTP request method to use.  By default its value is :const:`None`, "
"which means that :meth:`~Request.get_method` will do its normal computation "
"of the method to be used.  Its value can be set (thus overriding the default "
"computation in :meth:`~Request.get_method`) either by providing a default "
"value by setting it at the class level in a :class:`Request` subclass, or by "
"passing a value in to the :class:`Request` constructor via the *method* "
"argument."
msgstr ""
"要使用的 HTTP "
"請求方法。預設情況下，它的值為 :const:`None`，這意味著 :meth:`~Request."
"get_method` 將對要使用的方法進行正常計算。可以設定它的值（從而覆蓋 "
":meth:`~Request.get_method` 中的預設計算），方法是通過在 Request "
"子類別的類級別設定它來提供預設值，或者傳遞一個值通過 *method* "
"參數進入 :class:`Request` 構造函式。"

#: ../../library/urllib.request.rst:527
#, fuzzy
msgid ""
"A default value can now be set in subclasses; previously it could only be "
"set via the constructor argument."
msgstr "現在可以在子類別中設定預設值；以前它只能通過構造函式參數設定。"

#: ../../library/urllib.request.rst:534
#, fuzzy
msgid ""
"Return a string indicating the HTTP request method.  If :attr:`Request."
"method` is not ``None``, return its value, otherwise return ``'GET'`` if :"
"attr:`Request.data` is ``None``, or ``'POST'`` if it's not. This is only "
"meaningful for HTTP requests."
msgstr ""
"回傳一個字串，指示 HTTP 請求方法。如果 :attr:`Request.method` "
"不是 ``None``，回傳它的值，否則回傳 ``'GET'`` 如果 :attr:`Request.data` "
"是 ``None`` 或 ``'POST'`` 如果不是。這僅對 HTTP 請求有意義。"

#: ../../library/urllib.request.rst:539
#, fuzzy
msgid "get_method now looks at the value of :attr:`Request.method`."
msgstr "get_method 現在查看 :attr:`Request.method` 的值。"

#: ../../library/urllib.request.rst:545
#, fuzzy
msgid ""
"Add another header to the request.  Headers are currently ignored by all "
"handlers except HTTP handlers, where they are added to the list of headers "
"sent to the server.  Note that there cannot be more than one header with the "
"same name, and later calls will overwrite previous calls in case the *key* "
"collides. Currently, this is no loss of HTTP functionality, since all "
"headers which have meaning when used more than once have a (header-specific) "
"way of gaining the same functionality using only one header.  Note that "
"headers added using this method are also added to redirected requests."
msgstr ""
"向請求新增另一個標頭。標頭目前被所有處理程式忽略，除了 HTTP 處理程式，它們被"
"新增到發送到伺服器的標頭列表中。請注意，同名的標頭不能超過一個，以後的呼叫將"
"覆蓋之前的呼叫，以防 *key* 發生衝突。目前，這並沒有失去 HTTP 功能，因為所有在"
"使用不止一次時有意義的標頭都有一種（特定於標頭的）方式來僅使用一個標頭獲得相"
"同的功能。請注意，使用此方法新增的標頭也會新增到重定向請求中。"

#: ../../library/urllib.request.rst:557
#, fuzzy
msgid "Add a header that will not be added to a redirected request."
msgstr "新增一個不會新增到重定向請求的標頭。"

#: ../../library/urllib.request.rst:562
#, fuzzy
msgid ""
"Return whether the instance has the named header (checks both regular and "
"unredirected)."
msgstr "回傳實例是否具有命名標頭（檢查常規和未重定向）。"

#: ../../library/urllib.request.rst:568
#, fuzzy
msgid ""
"Remove named header from the request instance (both from regular and "
"unredirected headers)."
msgstr "從請求實例中刪除命名標頭（包括常規標頭和未重定向標頭）。"

#: ../../library/urllib.request.rst:576
#, fuzzy
msgid "Return the URL given in the constructor."
msgstr "回傳構造函式中給定的 URL。"

#: ../../library/urllib.request.rst:580
#, fuzzy
msgid "Returns :attr:`Request.full_url`"
msgstr "回傳 :attr:`Request.full_url`"

#: ../../library/urllib.request.rst:585
#, fuzzy
msgid ""
"Prepare the request by connecting to a proxy server. The *host* and *type* "
"will replace those of the instance, and the instance's selector will be the "
"original URL given in the constructor."
msgstr "通過連接到代理伺服器來準備請求。 *host* 和 *type* 將替換實例的那些，"
"實例的選擇器將是構造函式中給出的原始 URL。"

#: ../../library/urllib.request.rst:592
#, fuzzy
msgid ""
"Return the value of the given header. If the header is not present, return "
"the default value."
msgstr "回傳給定標頭的值。如果標頭不存在，則回傳預設值。"

#: ../../library/urllib.request.rst:598
#, fuzzy
msgid ""
"Return a list of tuples (header_name, header_value) of the Request headers."
msgstr "回傳請求標頭的元組列表 (header_name, header_value)。"

#: ../../library/urllib.request.rst:600
#, fuzzy
msgid ""
"The request methods add_data, has_data, get_data, get_type, get_host, "
"get_selector, get_origin_req_host and is_unverifiable that were deprecated "
"since 3.3 have been removed."
msgstr ""
"刪除了自 3.3 起棄用的請求方法 "
"add_data、has_data、get_data、get_type、get_host、get_selector、"
"get_origin_req_host 和 is_unverifiable。"

#: ../../library/urllib.request.rst:609
msgid "OpenerDirector Objects"
msgstr "OpenerDirector 物件"

#: ../../library/urllib.request.rst:611
#, fuzzy
msgid ":class:`OpenerDirector` instances have the following methods:"
msgstr ":class:`OpenerDirector` 實例具有以下方法："

#: ../../library/urllib.request.rst:616
#, fuzzy
msgid ""
"*handler* should be an instance of :class:`BaseHandler`.  The following "
"methods are searched, and added to the possible chains (note that HTTP "
"errors are a special case).  Note that, in the following, *protocol* should "
"be replaced with the actual protocol to handle, for example :meth:"
"`http_response` would be the HTTP protocol response handler.  Also *type* "
"should be replaced with the actual HTTP code, for example :meth:"
"`http_error_404` would handle HTTP 404 errors."
msgstr ""
"*handler* 應該是 :class:`BaseHandler` "
"的一個實例。搜索以下方法，並將其新增到可能的鏈中（注意 HTTP "
"錯誤是一種特殊情況）。請注意，在下文中，*protocol* "
"應替換為要處理的實際協定，例如 :meth:`http_response` 將是 HTTP "
"協定響應處理程式。此外，*type* 應替換為實際的 HTTP "
"程式碼，例如 :meth:`http_error_404` 將處理 HTTP 404 錯誤。"

#: ../../library/urllib.request.rst:624
#, fuzzy
msgid ""
":meth:`<protocol>_open` --- signal that the handler knows how to open "
"*protocol* URLs."
msgstr ":meth:`<protocol>_open` --- 處理程式知道如何打開 *protocol* URL 的信號。"

#: ../../library/urllib.request.rst:627
msgid "See |protocol_open|_ for more information."
msgstr "更多資訊請見 |protocol_open|_\\ 。"

#: ../../library/urllib.request.rst:629
#, fuzzy
msgid ""
":meth:`http_error_\\<type\\>` --- signal that the handler knows how to "
"handle HTTP errors with HTTP error code *type*."
msgstr ""
":meth:`http_error_\\<type\\>` --- 表示處理程式知道如何使用 HTTP 錯誤程式碼 "
"*type* 處理 HTTP 錯誤。"

#: ../../library/urllib.request.rst:632
msgid "See |http_error_nnn|_ for more information."
msgstr "更多資訊請見 |http_error_nnn|_\\ 。"

#: ../../library/urllib.request.rst:634
#, fuzzy
msgid ""
":meth:`<protocol>_error` --- signal that the handler knows how to handle "
"errors from (non-\\ ``http``) *protocol*."
msgstr ":meth:`<protocol>_error` --- 表明處理程式知道如何處理來自（非\\"
"``http``）*協定*的錯誤。"

#: ../../library/urllib.request.rst:637
#, fuzzy
msgid ""
":meth:`<protocol>_request` --- signal that the handler knows how to pre-"
"process *protocol* requests."
msgstr ":meth:`<protocol>_request` --- 處理程式知道如何預處理 *protocol* 請求的信號。"

#: ../../library/urllib.request.rst:640
msgid "See |protocol_request|_ for more information."
msgstr "更多資訊請見 |protocol_request|_\\ 。"

#: ../../library/urllib.request.rst:642
#, fuzzy
msgid ""
":meth:`<protocol>_response` --- signal that the handler knows how to post-"
"process *protocol* responses."
msgstr ":meth:`<protocol>_response` --- 處理程式知道如何後處理 *protocol* "
"響應的信號。"

#: ../../library/urllib.request.rst:645
msgid "See |protocol_response|_ for more information."
msgstr "更多資訊請見 |protocol_response|_\\ 。"

#: ../../library/urllib.request.rst:654
#, fuzzy
msgid ""
"Open the given *url* (which can be a request object or a string), optionally "
"passing the given *data*. Arguments, return values and exceptions raised are "
"the same as those of :func:`urlopen` (which simply calls the :meth:`open` "
"method on the currently installed global :class:`OpenerDirector`).  The "
"optional *timeout* parameter specifies a timeout in seconds for blocking "
"operations like the connection attempt (if not specified, the global default "
"timeout setting will be used). The timeout feature actually works only for "
"HTTP, HTTPS and FTP connections."
msgstr ""
"打開給定的 *url*（可以是請求對像或字串），可選擇傳遞給定的 *data*。參數、"
"回傳值和引發的例外與 :func:`urlopen` 的相同（它只是呼叫當前安裝的全局 "
":class:`OpenerDirector` 上的 :meth:`open` 方法）。可選的 *timeout* 參數以秒為"
"單位指定超時以阻止連接嘗試等操作（如果未指定，將使用全局預設超時設定）。"
"超時功能實際上只適用於 HTTP、HTTPS 和 FTP 連接。"

#: ../../library/urllib.request.rst:666
#, fuzzy
msgid ""
"Handle an error of the given protocol.  This will call the registered error "
"handlers for the given protocol with the given arguments (which are protocol "
"specific).  The HTTP protocol is a special case which uses the HTTP response "
"code to determine the specific error handler; refer to the :meth:"
"`http_error_\\<type\\>` methods of the handler classes."
msgstr ""
"處理給定協定的錯誤。這將使用給定參數（特定於協定）呼叫給定協定的已註冊錯誤處"
"理程式。 HTTP 協定是一種特殊情況，它使用 HTTP "
"響應程式碼來確定具體的錯誤處理程式；請參考處理程式類的 :meth:`http_error_\\<"
"type\\>` 方法。"

#: ../../library/urllib.request.rst:672
#, fuzzy
msgid ""
"Return values and exceptions raised are the same as those of :func:`urlopen`."
msgstr "回傳值和引發的例外與 :func:`urlopen` 的相同。"

#: ../../library/urllib.request.rst:674
#, fuzzy
msgid "OpenerDirector objects open URLs in three stages:"
msgstr "OpenerDirector 物件分三個階段打開 URL："

#: ../../library/urllib.request.rst:676
#, fuzzy
msgid ""
"The order in which these methods are called within each stage is determined "
"by sorting the handler instances."
msgstr "這些方法在每個階段中的呼叫順序由處理程式實例的排序決定。"

#: ../../library/urllib.request.rst:679
#, fuzzy
msgid ""
"Every handler with a method named like :meth:`<protocol>_request` has that "
"method called to pre-process the request."
msgstr "每個具有類似 :meth:`<protocol>_request` "
"方法的處理程式都會呼叫該方法來預處理請求。"

#: ../../library/urllib.request.rst:682
#, fuzzy
msgid ""
"Handlers with a method named like :meth:`<protocol>_open` are called to "
"handle the request. This stage ends when a handler either returns a non-\\ :"
"const:`None` value (ie. a response), or raises an exception (usually :exc:"
"`~urllib.error.URLError`).  Exceptions are allowed to propagate."
msgstr ""
"呼叫具有類似 :meth:`<protocol>_open` 方法的處理程式來處理請求。"
"當處理程式回傳非 \\ :const:`None` 值（即響應）或引發例外（通常為 :exc:`~urllib"
".error.URLError`）時，此階段結束。允許例外傳播。"

#: ../../library/urllib.request.rst:687
#, fuzzy
msgid ""
"In fact, the above algorithm is first tried for methods named :meth:"
"`default_open`.  If all such methods return :const:`None`, the algorithm is "
"repeated for methods named like :meth:`<protocol>_open`.  If all such "
"methods return :const:`None`, the algorithm is repeated for methods named :"
"meth:`unknown_open`."
msgstr ""
"事實上，上面的演算法首先針對名為 :meth:`default_open` 的方法進行了嘗試。如果"
"所有這些方法都回傳 :const:`None`，則對名為 :meth:`<protocol>_open` 的方法重複該"
"演算法。如果所有這些方法都回傳 :const:`None`，則對名為 :meth:`unknown_open` "
"的方法重複該演算法。"

#: ../../library/urllib.request.rst:693
#, fuzzy
msgid ""
"Note that the implementation of these methods may involve calls of the "
"parent :class:`OpenerDirector` instance's :meth:`~OpenerDirector.open` and :"
"meth:`~OpenerDirector.error` methods."
msgstr ""
"請注意，這些方法的實作可能涉及父 :class:`OpenerDirector` 實例的 "
":meth:`~OpenerDirector.open` 和 :meth:`~OpenerDirector.error` 方法的呼叫。"

#: ../../library/urllib.request.rst:697
#, fuzzy
msgid ""
"Every handler with a method named like :meth:`<protocol>_response` has that "
"method called to post-process the response."
msgstr "每個具有類似 :meth:`<protocol>_response` "
"方法的處理程式都會呼叫該方法來對響應進行後處理。"

#: ../../library/urllib.request.rst:704
msgid "BaseHandler Objects"
msgstr "BaseHandler 物件"

#: ../../library/urllib.request.rst:706
#, fuzzy
msgid ""
":class:`BaseHandler` objects provide a couple of methods that are directly "
"useful, and others that are meant to be used by derived classes.  These are "
"intended for direct use:"
msgstr ":class:`BaseHandler` 物件提供了幾個直接有用的方法，以及其他旨在由派生類使用的"
"方法。這些旨在直接使用："

#: ../../library/urllib.request.rst:713
#, fuzzy
msgid "Add a director as parent."
msgstr "新增主管作為父級。"

#: ../../library/urllib.request.rst:718
#, fuzzy
msgid "Remove any parents."
msgstr "刪除任何父母。"

#: ../../library/urllib.request.rst:720
#, fuzzy
msgid ""
"The following attribute and methods should only be used by classes derived "
"from :class:`BaseHandler`."
msgstr "以下屬性和方法只能由派生自 :class:`BaseHandler` 的類使用。"

#: ../../library/urllib.request.rst:725
#, fuzzy
msgid ""
"The convention has been adopted that subclasses defining :meth:"
"`<protocol>_request` or :meth:`<protocol>_response` methods are named :class:"
"`\\*Processor`; all others are named :class:`\\*Handler`."
msgstr ""
"已經採用的約定是，定義 :meth:`<protocol>_request` 或 "
":meth:`<protocol>_response` 方法的子類別被命名為 :class:`\\*Processor`；"
"所有其他的都被命名為 :class:`\\*Handler`。"

#: ../../library/urllib.request.rst:732
#, fuzzy
msgid ""
"A valid :class:`OpenerDirector`, which can be used to open using a different "
"protocol, or handle errors."
msgstr "一個有效的 :class:`OpenerDirector`，可用於使用不同的協定打開或處理錯誤。"

#: ../../library/urllib.request.rst:738
#, fuzzy
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to catch all URLs."
msgstr "此方法*未*在 :class:`BaseHandler` 中定義，但如果子類別想要捕獲所有 "
"URL，則應定義它。"

#: ../../library/urllib.request.rst:741
#, fuzzy
msgid ""
"This method, if implemented, will be called by the parent :class:"
"`OpenerDirector`.  It should return a file-like object as described in the "
"return value of the :meth:`~OpenerDirector.open` method of :class:"
"`OpenerDirector`, or ``None``. It should raise :exc:`~urllib.error."
"URLError`, unless a truly exceptional thing happens (for example, :exc:"
"`MemoryError` should not be mapped to :exc:`URLError`)."
msgstr ""
"這個方法，如果被實作，將被父 OpenerDirector "
"呼叫。它應該回傳一個類似文件的物件，如 OpenerDirector 的 "
":meth:`~OpenerDirector.open` 方法的回傳值中所述，或 ``None``。它應該引發 "
":exc:`~urllib.error."
"URLError`，除非發生真正例外的事情（例如，:exc:`MemoryError` 不應映射到 "
":exc:`URLError`）。"

#: ../../library/urllib.request.rst:748
#, fuzzy
msgid "This method will be called before any protocol-specific open method."
msgstr "此方法將在任何特定於協定的打開方法之前被呼叫。"

#: ../../library/urllib.request.rst:755
#, fuzzy
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to handle URLs with the given protocol."
msgstr "此方法*未*在 :class:`BaseHandler` 中定義，但如果子類別想要使用給定協定處理 "
"URL，則應定義它。"

#: ../../library/urllib.request.rst:758
#, fuzzy
msgid ""
"This method, if defined, will be called by the parent :class:"
"`OpenerDirector`. Return values should be the same as for  :meth:"
"`default_open`."
msgstr "這個方法，如果被定義，將被父 OpenerDirector 呼叫。回傳值應與 "
":meth:`default_open` 相同。"

#: ../../library/urllib.request.rst:764
#, fuzzy
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to catch all URLs with no specific registered handler "
"to open it."
msgstr ""
"此方法*未*在 :class:`BaseHandler` 中定義，"
"但如果子類別想要捕獲所有沒有特定註冊處理程式的 URL 來打開它，則應該定義它。"

#: ../../library/urllib.request.rst:768
#, fuzzy
msgid ""
"This method, if implemented, will be called by the :attr:`parent` :class:"
"`OpenerDirector`.  Return values should be the same as for :meth:"
"`default_open`."
msgstr ""
"此方法如果實作，將由 :attr:`parent` :class:`OpenerDirector` 呼叫。回傳值應與 "
":meth:`default_open` 相同。"

#: ../../library/urllib.request.rst:775
#, fuzzy
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"override it if they intend to provide a catch-all for otherwise unhandled "
"HTTP errors.  It will be called automatically by the  :class:"
"`OpenerDirector` getting the error, and should not normally be called in "
"other circumstances."
msgstr ""
"此方法*未*在 :class:`BaseHandler` 中定義，但如果子類別打算為其他未處理的 "
"HTTP 錯誤提供一個包羅萬象的方法，則它們應該覆蓋它。它會被 "
":class:`OpenerDirector` 得到錯誤自動呼叫，通常不應在其他情況下呼叫。"

#: ../../library/urllib.request.rst:780
#, fuzzy
msgid ""
"*req* will be a :class:`Request` object, *fp* will be a file-like object "
"with the HTTP error body, *code* will be the three-digit code of the error, "
"*msg* will be the user-visible explanation of the code and *hdrs* will be a "
"mapping object with the headers of the error."
msgstr ""
"*req* 將是一個 Request 物件，*fp* 將是一個帶有 HTTP "
"錯誤主體的類文件物件，*code* 將是錯誤的三位數程式碼，*msg* "
"將是使用者可見的程式碼解釋和 *hdrs* 將是一個帶有錯誤標題的映射物件。"

#: ../../library/urllib.request.rst:785
#, fuzzy
msgid ""
"Return values and exceptions raised should be the same as those of :func:"
"`urlopen`."
msgstr "回傳值和引發的例外應該與 :func:`urlopen` 的相同。"

#: ../../library/urllib.request.rst:792
#, fuzzy
msgid ""
"*nnn* should be a three-digit HTTP error code.  This method is also not "
"defined in :class:`BaseHandler`, but will be called, if it exists, on an "
"instance of a subclass, when an HTTP error with code *nnn* occurs."
msgstr ""
"*nnn* 應該是一個三位數的 HTTP 錯誤程式碼。此方法也未在 :class:`BaseHandler` "
"中定義，但如果出現程式碼為 *nnn* 的 HTTP "
"錯誤，則會在子類別的實例上呼叫（如果存在）。"

#: ../../library/urllib.request.rst:796
#, fuzzy
msgid "Subclasses should override this method to handle specific HTTP errors."
msgstr "子類別應該覆蓋此方法來處理特定的 HTTP 錯誤。"

#: ../../library/urllib.request.rst:798
#, fuzzy
msgid ""
"Arguments, return values and exceptions raised should be the same as for :"
"meth:`http_error_default`."
msgstr "參數、回傳值和引發的例外應該與 :meth:`http_error_default` 相同。"

#: ../../library/urllib.request.rst:806
#, fuzzy
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to pre-process requests of the given protocol."
msgstr "此方法*未*在 :class:`BaseHandler` "
"中定義，但如果子類別想要預處理給定協定的請求，則應定義它。"

#: ../../library/urllib.request.rst:809
#, fuzzy
msgid ""
"This method, if defined, will be called by the parent :class:"
"`OpenerDirector`. *req* will be a :class:`Request` object. The return value "
"should be a :class:`Request` object."
msgstr ""
"這個方法，如果被定義，將被父 OpenerDirector 呼叫。 *req* 將是一個 Request "
"物件。回傳值應該是一個 Request 物件。"

#: ../../library/urllib.request.rst:818
#, fuzzy
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to post-process responses of the given protocol."
msgstr "此方法*未*在 :class:`BaseHandler` "
"中定義，但如果子類別想要對給定協定的響應進行後處理，則應定義它。"

#: ../../library/urllib.request.rst:821
#, fuzzy
msgid ""
"This method, if defined, will be called by the parent :class:"
"`OpenerDirector`. *req* will be a :class:`Request` object. *response* will "
"be an object implementing the same interface as the return value of :func:"
"`urlopen`.  The return value should implement the same interface as the "
"return value of :func:`urlopen`."
msgstr ""
"這個方法，如果被定義，將被父 OpenerDirector 呼叫。 *req* 將是一個 Request "
"物件。 *response* 將是一個實作與 :func:`urlopen` 的回傳值相同介面的物件。"
"回傳值應該實作與 :func:`urlopen` 的回傳值相同的介面。"

#: ../../library/urllib.request.rst:831
msgid "HTTPRedirectHandler Objects"
msgstr "HTTPRedirectHandler 物件"

#: ../../library/urllib.request.rst:835
#, fuzzy
msgid ""
"Some HTTP redirections require action from this module's client code.  If "
"this is the case, :exc:`~urllib.error.HTTPError` is raised.  See :rfc:`2616` "
"for details of the precise meanings of the various redirection codes."
msgstr ""
"某些 HTTP 重定向需要來自此模組的客戶端程式碼的操作。如果是這種情況，則會引發 "
":exc:`~urllib.error.HTTPError`。有關各種重定向程式碼的準確含義的詳細資訊，"
"請參閱 :rfc:`2616`。"

#: ../../library/urllib.request.rst:839
#, fuzzy
msgid ""
"An :class:`HTTPError` exception raised as a security consideration if the "
"HTTPRedirectHandler is presented with a redirected URL which is not an HTTP, "
"HTTPS or FTP URL."
msgstr ""
"如果 HTTPRedirectHandler 提供的重定向 URL 不是 HTTP、HTTPS 或 FTP URL，"
"則作為安全考慮引發 :class:`HTTPError` 例外。"

#: ../../library/urllib.request.rst:846
#, fuzzy
msgid ""
"Return a :class:`Request` or ``None`` in response to a redirect. This is "
"called by the default implementations of the :meth:`http_error_30\\*` "
"methods when a redirection is received from the server.  If a redirection "
"should take place, return a new :class:`Request` to allow :meth:"
"`http_error_30\\*` to perform the redirect to *newurl*.  Otherwise, raise :"
"exc:`~urllib.error.HTTPError` if no other handler should try to handle this "
"URL, or return ``None`` if you can't but another handler might."
msgstr ""
"回傳一個 :class:`Request` 或 ``None`` "
"以響應重定向。當從伺服器接收到重定向時，這由 :meth:`http_error_30\\*` "
"方法的預設實作呼叫。如果應該進行重定向，回傳一個新的 :class:`Request` "
"以允許 :meth:`http_error_30\\*` 執行到*newurl* 的重定向。否則，"
"如果沒有其他處理程式應該嘗試處理此 URL，則引發 :exc:`~urllib.error."
"HTTPError`，或者如果您不能但另一個處理程式可能會回傳 ``None``。"

#: ../../library/urllib.request.rst:856
#, fuzzy
msgid ""
"The default implementation of this method does not strictly follow :rfc:"
"`2616`, which says that 301 and 302 responses to ``POST`` requests must not "
"be automatically redirected without confirmation by the user.  In reality, "
"browsers do allow automatic redirection of these responses, changing the "
"POST to a ``GET``, and the default implementation reproduces this behavior."
msgstr ""
"此方法的預設實作並不嚴格遵循 :rfc:`2616`，它表示對 ``POST`` 請求的 301 和 "
"302 響應不得在未經使用者確認的情況下自動重定向。實際上，瀏覽器確實允許自動重"
"定向這些響應，將 POST 更改為 ``GET``，並且預設實作重現了此行為。"

#: ../../library/urllib.request.rst:865
#, fuzzy
msgid ""
"Redirect to the ``Location:`` or ``URI:`` URL.  This method is called by the "
"parent :class:`OpenerDirector` when getting an HTTP 'moved permanently' "
"response."
msgstr ""
"重定向到 ``Location:`` 或 ``URI:`` URL。當獲取 HTTP“永久移動”響應時，"
"此方法由父級 OpenerDirector 呼叫。"

#: ../../library/urllib.request.rst:871
#, fuzzy
msgid ""
"The same as :meth:`http_error_301`, but called for the 'found' response."
msgstr "與 :meth:`http_error_301` 相同，但要求“找到”響應。"

#: ../../library/urllib.request.rst:876
#, fuzzy
msgid ""
"The same as :meth:`http_error_301`, but called for the 'see other' response."
msgstr "與 :meth:`http_error_301` 相同，但要求“查看其他”響應。"

#: ../../library/urllib.request.rst:881
#, fuzzy
msgid ""
"The same as :meth:`http_error_301`, but called for the 'temporary redirect' "
"response. It does not allow changing the request method from ``POST`` to "
"``GET``."
msgstr "與 :meth:`http_error_301` "
"相同，但要求“臨時重定向”響應。它不允許將請求方法從 ``POST``更改為 ``GET``。"

#: ../../library/urllib.request.rst:888
#, fuzzy
msgid ""
"The same as :meth:`http_error_301`, but called for the 'permanent redirect' "
"response. It does not allow changing the request method from ``POST`` to "
"``GET``."
msgstr "與 :meth:`http_error_301` "
"相同，但要求“永久重定向”響應。它不允許將請求方法從 ``POST``更改為 ``GET``。"

#: ../../library/urllib.request.rst:898
msgid "HTTPCookieProcessor Objects"
msgstr "HTTPCookieProcessor 物件"

#: ../../library/urllib.request.rst:900
#, fuzzy
msgid ":class:`HTTPCookieProcessor` instances have one attribute:"
msgstr ":class:`HTTPCookieProcessor` 實例有一個屬性："

#: ../../library/urllib.request.rst:904
#, fuzzy
msgid "The :class:`http.cookiejar.CookieJar` in which cookies are stored."
msgstr "儲存 cookie 的 :class:`http.cookiejar.CookieJar`。"

#: ../../library/urllib.request.rst:910
msgid "ProxyHandler Objects"
msgstr "ProxyHandler 物件"

#: ../../library/urllib.request.rst:916
#, fuzzy
msgid ""
"The :class:`ProxyHandler` will have a method :meth:`<protocol>_open` for "
"every *protocol* which has a proxy in the *proxies* dictionary given in the "
"constructor.  The method will modify requests to go through the proxy, by "
"calling ``request.set_proxy()``, and call the next handler in the chain to "
"actually execute the protocol."
msgstr ""
":class:`ProxyHandler` 將有一個方法 :meth:`<protocol>_open` 用於每個 "
"*protocol*，它在構造函式中給定的 *proxies* "
"字典中有一個代理。該方法將通過呼叫“request."
"set_proxy()”修改請求以通過代理，並呼叫鏈中的下一個處理程式來實際執行協定。"

#: ../../library/urllib.request.rst:926
msgid "HTTPPasswordMgr Objects"
msgstr "HTTPPasswordMgr 物件"

#: ../../library/urllib.request.rst:928
#, fuzzy
msgid ""
"These methods are available on :class:`HTTPPasswordMgr` and :class:"
"`HTTPPasswordMgrWithDefaultRealm` objects."
msgstr ""
"這些方法在 :class:`HTTPPasswordMgr` 和 "
":class:`HTTPPasswordMgrWithDefaultRealm` 對像上可用。"

#: ../../library/urllib.request.rst:934
#, fuzzy
msgid ""
"*uri* can be either a single URI, or a sequence of URIs. *realm*, *user* and "
"*passwd* must be strings. This causes ``(user, passwd)`` to be used as "
"authentication tokens when authentication for *realm* and a super-URI of any "
"of the given URIs is given."
msgstr ""
"*uri* 可以是單個 URI，也可以是 URI 序列。 *realm*、*user* 和 *passwd* "
"必須是字串。這會導致 ``(user, passwd)`` 在對 *realm* 和任何給定 URI 的超級 "
"URI 進行身份驗證時用作身份驗證令牌。"

#: ../../library/urllib.request.rst:942
#, fuzzy
msgid ""
"Get user/password for given realm and URI, if any.  This method will return "
"``(None, None)`` if there is no matching user/password."
msgstr "獲取給定領域和 URI 的使用者/密碼（如果有）。如果沒有匹配的使用者/密碼，"
"此方法將回傳 ``(None, None)``。"

#: ../../library/urllib.request.rst:945
#, fuzzy
msgid ""
"For :class:`HTTPPasswordMgrWithDefaultRealm` objects, the realm ``None`` "
"will be searched if the given *realm* has no matching user/password."
msgstr ""
"對於 :class:`HTTPPasswordMgrWithDefaultRealm` 物件，如果給定的 *realm* "
"沒有匹配的使用者/密碼，將搜索領域 ``None``。"

#: ../../library/urllib.request.rst:952
msgid "HTTPPasswordMgrWithPriorAuth Objects"
msgstr "HTTPPasswordMgrWithPriorAuth 物件"

#: ../../library/urllib.request.rst:954
#, fuzzy
msgid ""
"This password manager extends :class:`HTTPPasswordMgrWithDefaultRealm` to "
"support tracking URIs for which authentication credentials should always be "
"sent."
msgstr "此密碼管理器擴充 HTTPPasswordMgrWithDefaultRealm "
"以支援跟踪應始終發送身份驗證憑據的 URI。"

#: ../../library/urllib.request.rst:961
#, fuzzy
msgid ""
"*realm*, *uri*, *user*, *passwd* are as for :meth:`HTTPPasswordMgr."
"add_password`.  *is_authenticated* sets the initial value of the "
"``is_authenticated`` flag for the given URI or list of URIs. If "
"*is_authenticated* is specified as ``True``, *realm* is ignored."
msgstr ""
"*realm*、*uri*、*user*、*passwd* 與 :meth:`HTTPPasswordMgr.add_password` "
"相同。 *is_authenticated* 為給定的 URI 或 URI "
"列表設定“is_authenticated”旗標的初始值。如果 *is_authenticated* 指定為 "
"``True``，則忽略 *realm*。"

#: ../../library/urllib.request.rst:969
#, fuzzy
msgid "Same as for :class:`HTTPPasswordMgrWithDefaultRealm` objects"
msgstr "與 :class:`HTTPPasswordMgrWithDefaultRealm` 物件相同"

#: ../../library/urllib.request.rst:975
#, fuzzy
msgid ""
"Update the ``is_authenticated`` flag for the given *uri* or list of URIs."
msgstr "為給定的 *uri* 或 URI 列表更新 ``is_authenticated`` 旗標。"

#: ../../library/urllib.request.rst:981
#, fuzzy
msgid ""
"Returns the current state of the ``is_authenticated`` flag for the given URI."
msgstr "回傳給定 URI 的 ``is_authenticated`` 旗標的當前狀態。"

#: ../../library/urllib.request.rst:988
msgid "AbstractBasicAuthHandler Objects"
msgstr "AbstractBasicAuthHandler 物件"

#: ../../library/urllib.request.rst:993
#, fuzzy
msgid ""
"Handle an authentication request by getting a user/password pair, and re-"
"trying the request.  *authreq* should be the name of the header where the "
"information about the realm is included in the request, *host* specifies the "
"URL and path to authenticate for, *req* should be the (failed) :class:"
"`Request` object, and *headers* should be the error headers."
msgstr ""
"通過獲取使用者/密碼對並重試請求來處理身份驗證請求。 *authreq* "
"應該是請求中包含領域資訊的標頭名稱，*host* 指定要驗證的 URL 和路徑，*req* "
"應該是（失敗的） :class:`Request` 物件, *headers* 應該是錯誤標題。"

#: ../../library/urllib.request.rst:999
#, fuzzy
msgid ""
"*host* is either an authority (e.g. ``\"python.org\"``) or a URL containing "
"an authority component (e.g. ``\"http://python.org/\"``). In either case, "
"the authority must not contain a userinfo component (so, ``\"python.org\"`` "
"and ``\"python.org:80\"`` are fine, ``\"joe:password@python.org\"`` is not)."
msgstr ""
"*host* 是一個權威（例如 ``\"python.org\"``）或一個包含權威組件的 URL（例如 ``"
"\"http://python.org/\""
"``）。在任何一種情況下，權限都不能包含使用者資訊組件（因此，``\"python.org\""
"`` 和 ``\"python.org:80\"`` 都可以，``\"joe:password@python.org\" `` 不是）。"

#: ../../library/urllib.request.rst:1008
msgid "HTTPBasicAuthHandler Objects"
msgstr "HTTPBasicAuthHandler 物件"

#: ../../library/urllib.request.rst:1013 ../../library/urllib.request.rst:1024
#: ../../library/urllib.request.rst:1049 ../../library/urllib.request.rst:1060
#, fuzzy
msgid "Retry the request with authentication information, if available."
msgstr "如果可用，請使用身份驗證資訊重試請求。"

#: ../../library/urllib.request.rst:1019
msgid "ProxyBasicAuthHandler Objects"
msgstr "ProxyBasicAuthHandler 物件"

#: ../../library/urllib.request.rst:1030
msgid "AbstractDigestAuthHandler Objects"
msgstr "AbstractDigestAuthHandler 物件"

#: ../../library/urllib.request.rst:1035
#, fuzzy
msgid ""
"*authreq* should be the name of the header where the information about the "
"realm is included in the request, *host* should be the host to authenticate "
"to, *req* should be the (failed) :class:`Request` object, and *headers* "
"should be the error headers."
msgstr ""
"*authreq* 應該是請求中包含領域資訊的標頭名稱，*host* "
"應該是要驗證的主機，*req* 應該是（失敗的） :class:`Request` 物件， *headers* "
"應該是錯誤標題。"

#: ../../library/urllib.request.rst:1044
msgid "HTTPDigestAuthHandler Objects"
msgstr "HTTPDigestAuthHandler 物件"

#: ../../library/urllib.request.rst:1055
msgid "ProxyDigestAuthHandler Objects"
msgstr "ProxyDigestAuthHandler 物件"

#: ../../library/urllib.request.rst:1066
msgid "HTTPHandler Objects"
msgstr "HTTPHandler 物件"

#: ../../library/urllib.request.rst:1071
#, fuzzy
msgid ""
"Send an HTTP request, which can be either GET or POST, depending on ``req."
"has_data()``."
msgstr "發送 HTTP 請求，可以是 GET 或 POST，具體取決於 ``req.has_data()``。"

#: ../../library/urllib.request.rst:1078
msgid "HTTPSHandler Objects"
msgstr "HTTPSHandler 物件"

#: ../../library/urllib.request.rst:1083
#, fuzzy
msgid ""
"Send an HTTPS request, which can be either GET or POST, depending on ``req."
"has_data()``."
msgstr "發送 HTTPS 請求，可以是 GET 或 POST，具體取決於 ``req.has_data()``。"

#: ../../library/urllib.request.rst:1090
msgid "FileHandler Objects"
msgstr "FileHandler 物件"

#: ../../library/urllib.request.rst:1095
#, fuzzy
msgid ""
"Open the file locally, if there is no host name, or the host name is "
"``'localhost'``."
msgstr "在本地打開文件，如果沒有主機名，或者主機名為 ``'localhost'``。"

#: ../../library/urllib.request.rst:1098
#, fuzzy
msgid ""
"This method is applicable only for local hostnames.  When a remote hostname "
"is given, an :exc:`~urllib.error.URLError` is raised."
msgstr "此方法僅適用於本地主機名。當給出遠程主機名時，會引發 :exc:`~urllib.error."
"URLError`。"

#: ../../library/urllib.request.rst:1106
msgid "DataHandler Objects"
msgstr "DataHandler 物件"

#: ../../library/urllib.request.rst:1110
#, fuzzy
msgid ""
"Read a data URL. This kind of URL contains the content encoded in the URL "
"itself. The data URL syntax is specified in :rfc:`2397`. This implementation "
"ignores white spaces in base64 encoded data URLs so the URL may be wrapped "
"in whatever source file it comes from. But even though some browsers don't "
"mind about a missing padding at the end of a base64 encoded data URL, this "
"implementation will raise an :exc:`ValueError` in that case."
msgstr ""
"讀取資料 URL。這種 URL 包含 URL 本身編碼的內容。資料 URL 語法在 :rfc:`2397` "
"中指定。此實作忽略 base64 編碼資料 URL 中的空格，因此 URL "
"可以包裝在它來自的任何源文件中。但是，即使某些瀏覽器不介意 base64 編碼資料 "
"URL 末尾缺少填充，此實作也會在這種情況下引發 :exc:`ValueError`。"

#: ../../library/urllib.request.rst:1121
msgid "FTPHandler Objects"
msgstr "FTPHandler 物件"

#: ../../library/urllib.request.rst:1126
#, fuzzy
msgid ""
"Open the FTP file indicated by *req*. The login is always done with empty "
"username and password."
msgstr "打開 *req* 指示的 FTP 文件。登錄始終使用空的使用者名和密碼完成。"

#: ../../library/urllib.request.rst:1133
msgid "CacheFTPHandler Objects"
msgstr "CacheFTPHandler 物件"

#: ../../library/urllib.request.rst:1135
#, fuzzy
msgid ""
":class:`CacheFTPHandler` objects are :class:`FTPHandler` objects with the "
"following additional methods:"
msgstr ":class:`CacheFTPHandler` 對像是具有以下附加方法的 :class:`FTPHandler` 物件："

#: ../../library/urllib.request.rst:1141
#, fuzzy
msgid "Set timeout of connections to *t* seconds."
msgstr "將連接超時設定為 *t* 秒。"

#: ../../library/urllib.request.rst:1146
#, fuzzy
msgid "Set maximum number of cached connections to *m*."
msgstr "將最大快取連接數設定為 *m*。"

#: ../../library/urllib.request.rst:1152
msgid "UnknownHandler Objects"
msgstr "UnknownHandler 物件"

#: ../../library/urllib.request.rst:1157
#, fuzzy
msgid "Raise a :exc:`~urllib.error.URLError` exception."
msgstr "引發 :exc:`~urllib.error.URLError` 例外。"

#: ../../library/urllib.request.rst:1163
msgid "HTTPErrorProcessor Objects"
msgstr "HTTPErrorProcessor 物件"

#: ../../library/urllib.request.rst:1169
#, fuzzy
msgid "For 200 error codes, the response object is returned immediately."
msgstr "對於 200 錯誤程式碼，立即回傳響應物件。"

#: ../../library/urllib.request.rst:1171
#, fuzzy
msgid ""
"For non-200 error codes, this simply passes the job on to the :meth:"
"`http_error_\\<type\\>` handler methods, via :meth:`OpenerDirector.error`. "
"Eventually, :class:`HTTPDefaultErrorHandler` will raise an :exc:`~urllib."
"error.HTTPError` if no other handler handles the error."
msgstr ""
"對於非 200 錯誤程式碼，這只是通過 OpenerDirector.error 將作業傳遞給 :meth:`"
"http_error_\\<type\\>` 處理程式方法。最終，如果沒有其他處理程式處理錯誤，"
"HTTPDefaultErrorHandler 將引發：exc:~urllib.error.HTTPError。"

#: ../../library/urllib.request.rst:1179
#, fuzzy
msgid "Process HTTPS error responses."
msgstr "處理 HTTPS 錯誤響應。"

#: ../../library/urllib.request.rst:1181
#, fuzzy
msgid "The behavior is same as :meth:`http_response`."
msgstr "行為與 :meth:`http_response` 相同。"

#: ../../library/urllib.request.rst:1187
#, fuzzy
msgid "Examples"
msgstr "例子"

#: ../../library/urllib.request.rst:1189
#, fuzzy
msgid ""
"In addition to the examples below, more examples are given in :ref:`urllib-"
"howto`."
msgstr "除了下面的示例，更多示例在 :ref:`urllib-howto` 中給出。"

#: ../../library/urllib.request.rst:1192
#, fuzzy
msgid ""
"This example gets the python.org main page and displays the first 300 bytes "
"of it. ::"
msgstr "此示例獲取 python.org 主頁並顯示它的前 300 個位元組。 ::"

#: ../../library/urllib.request.rst:1205
#, fuzzy
msgid ""
"Note that urlopen returns a bytes object.  This is because there is no way "
"for urlopen to automatically determine the encoding of the byte stream it "
"receives from the HTTP server. In general, a program will decode the "
"returned bytes object to string once it determines or guesses the "
"appropriate encoding."
msgstr ""
"請注意，urlopen 回傳一個位元組物件。這是因為 urlopen 無法自動確定它從 HTTP 服"
"務器接收到的位元組流的編碼。通常，程式一旦確定或猜測出適當的編碼，就會將回傳"
"的位元組物件解碼為字串。"

#: ../../library/urllib.request.rst:1211
#, fuzzy
msgid ""
"The following W3C document, https://www.w3.org/International/O-charset\\ , "
"lists the various ways in which an (X)HTML or an XML document could have "
"specified its encoding information."
msgstr ""
"以下 W3C 文檔 https://www.w3.org/International/O-charset\\ 列出了 (X)HTML 或 "
"XML 文檔指定其編碼資訊的各種方式。"

#: ../../library/urllib.request.rst:1215
#, fuzzy
msgid ""
"As the python.org website uses *utf-8* encoding as specified in its meta "
"tag, we will use the same for decoding the bytes object. ::"
msgstr "由於 python.org 網站使用元標記中指定的 *utf-8* "
"編碼，我們將使用相同的編碼來解碼位元組物件。 ::"

#: ../../library/urllib.request.rst:1224
#, fuzzy
msgid ""
"It is also possible to achieve the same result without using the :term:"
"`context manager` approach. ::"
msgstr "不使用 :term:`context manager` 方法也可以達到相同的結果。 ::"

#: ../../library/urllib.request.rst:1233
#, fuzzy
msgid ""
"In the following example, we are sending a data-stream to the stdin of a CGI "
"and reading the data it returns to us. Note that this example will only work "
"when the Python installation supports SSL. ::"
msgstr ""
"在下面的示例中，我們將資料流發送到 CGI "
"的標準輸入並讀取它回傳給我們的資料。請注意，此示例僅在 Python 安裝支援 SSL "
"時才有效。 ::"

#: ../../library/urllib.request.rst:1245
#, fuzzy
msgid "The code for the sample CGI used in the above example is::"
msgstr "上例中使用的示例 CGI 的程式碼是："

#: ../../library/urllib.request.rst:1252
#, fuzzy
msgid "Here is an example of doing a ``PUT`` request using :class:`Request`::"
msgstr "下面是使用 Request::class 執行 ``PUT`` 請求的示例："

#: ../../library/urllib.request.rst:1262
#, fuzzy
msgid "Use of Basic HTTP Authentication::"
msgstr "使用基本 HTTP 身份驗證::"

#: ../../library/urllib.request.rst:1276
#, fuzzy
msgid ""
":func:`build_opener` provides many handlers by default, including a :class:"
"`ProxyHandler`.  By default, :class:`ProxyHandler` uses the environment "
"variables named ``<scheme>_proxy``, where ``<scheme>`` is the URL scheme "
"involved.  For example, the :envvar:`http_proxy` environment variable is "
"read to obtain the HTTP proxy's URL."
msgstr ""
":func:`build_opener` 預設提供許多處理程式，包括 "
":class:`ProxyHandler`。預設情況下，:class:`ProxyHandler` 使用名為 "
"``<scheme>_proxy`` 的環境變數，其中 ``<scheme>`` 是涉及的 URL 方案。例如，"
"讀取 :envvar:`http_proxy` 環境變數以獲取 HTTP 代理的 URL。"

#: ../../library/urllib.request.rst:1282
#, fuzzy
msgid ""
"This example replaces the default :class:`ProxyHandler` with one that uses "
"programmatically supplied proxy URLs, and adds proxy authorization support "
"with :class:`ProxyBasicAuthHandler`. ::"
msgstr ""
"此示例將預設的 ProxyHandler 替換為使用以編程方式提供的代理 URL，並使用 "
"ProxyBasicAuthHandler 新增代理授權支援。 ::"

#: ../../library/urllib.request.rst:1294
#, fuzzy
msgid "Adding HTTP headers:"
msgstr "新增 HTTP 標頭："

#: ../../library/urllib.request.rst:1296
#, fuzzy
msgid "Use the *headers* argument to the :class:`Request` constructor, or::"
msgstr "使用 Request 構造函式的 *headers* 參數，或者："

#: ../../library/urllib.request.rst:1305
#, fuzzy
msgid ""
":class:`OpenerDirector` automatically adds a :mailheader:`User-Agent` header "
"to every :class:`Request`.  To change this::"
msgstr ""
":class:`OpenerDirector` 自動將 :mailheader:`User-Agent` 標頭新增到每個 "
":class:`Request`。要更改此::"

#: ../../library/urllib.request.rst:1313
#, fuzzy
msgid ""
"Also, remember that a few standard headers (:mailheader:`Content-Length`, :"
"mailheader:`Content-Type` and :mailheader:`Host`) are added when the :class:"
"`Request` is passed to :func:`urlopen` (or :meth:`OpenerDirector.open`)."
msgstr ""
"另外，請記住，當將 :class:`Request` 傳遞給:func "
"時，會新增一些標準標頭（:mailheader:`Content-Length`、:mailheader:`Content-"
"Type` 和:mailheader:`Host`）： `urlopen`（或 :meth:`OpenerDirector.open`）。"

#: ../../library/urllib.request.rst:1320
#, fuzzy
msgid ""
"Here is an example session that uses the ``GET`` method to retrieve a URL "
"containing parameters::"
msgstr "這是一個使用 ``GET``方法檢索包含參數的 URL 的示例會話："

#: ../../library/urllib.request.rst:1331
#, fuzzy
msgid ""
"The following example uses the ``POST`` method instead. Note that params "
"output from urlencode is encoded to bytes before it is sent to urlopen as "
"data::"
msgstr "以下示例改為使用 ``POST`` 方法。請注意，urlencode 的參數輸出在作為資料發送到 "
"urlopen 之前被編碼為位元組："

#: ../../library/urllib.request.rst:1342
#, fuzzy
msgid ""
"The following example uses an explicitly specified HTTP proxy, overriding "
"environment settings::"
msgstr "以下示例使用明確指定的 HTTP 代理，覆蓋環境設定："

#: ../../library/urllib.request.rst:1352
#, fuzzy
msgid ""
"The following example uses no proxies at all, overriding environment "
"settings::"
msgstr "以下示例根本不使用代理，覆蓋環境設定："

#: ../../library/urllib.request.rst:1362
#, fuzzy
msgid "Legacy interface"
msgstr "舊版界面"

#: ../../library/urllib.request.rst:1364
#, fuzzy
msgid ""
"The following functions and classes are ported from the Python 2 module "
"``urllib`` (as opposed to ``urllib2``).  They might become deprecated at "
"some point in the future."
msgstr "以下函式和類是從 Python 2 "
"模組 ``urllib``（相對於 ``urllib2`` ）移植而來的。它們可能會在將來的某個時候被棄用。"

#: ../../library/urllib.request.rst:1370
#, fuzzy
msgid ""
"Copy a network object denoted by a URL to a local file. If the URL points to "
"a local file, the object will not be copied unless filename is supplied. "
"Return a tuple ``(filename, headers)`` where *filename* is the local file "
"name under which the object can be found, and *headers* is whatever the :"
"meth:`info` method of the object returned by :func:`urlopen` returned (for a "
"remote object). Exceptions are the same as for :func:`urlopen`."
msgstr ""
"將 URL 表示的網絡物件複製到本地文件。如果 URL "
"指向本地文件，除非提供文件名，否則不會復制該物件。回傳一個元組 ``(filename, "
"headers)`` 其中 *filename* 是可以找到物件的本地文件名，*headers* 是 :func "
"回傳的物件的 :meth:`info` 方法:`urlopen` 回傳（對於遠程物件）。例外情況與 "
":func:`urlopen` 相同。"

#: ../../library/urllib.request.rst:1377
#, fuzzy
msgid ""
"The second argument, if present, specifies the file location to copy to (if "
"absent, the location will be a tempfile with a generated name). The third "
"argument, if present, is a callable that will be called once on "
"establishment of the network connection and once after each block read "
"thereafter.  The callable will be passed three arguments; a count of blocks "
"transferred so far, a block size in bytes, and the total size of the file.  "
"The third argument may be ``-1`` on older FTP servers which do not return a "
"file size in response to a retrieval request."
msgstr ""
"第二個參數（如果存在）指定要復製到的文件位置（如果不存在，該位置將是具有生成"
"名稱的臨時文件）。第三個參數（如果存在）是一個可呼叫物件，它將在建立網絡連接"
"時呼叫一次，並在之後的每個塊讀取後呼叫一次。可呼叫物件將傳遞三個參數；到目前"
"為止傳輸的塊數、塊大小（以位元組為單位）以及文件的總大小。第三個參數在較舊的 "
"FTP 伺服器上可能是 ``-1``，這些伺服器不會回傳文件大小來響應檢索請求。"

#: ../../library/urllib.request.rst:1386
#, fuzzy
msgid "The following example illustrates the most common usage scenario::"
msgstr "以下示例說明了最常見的使用場景："

#: ../../library/urllib.request.rst:1393
#, fuzzy
msgid ""
"If the *url* uses the :file:`http:` scheme identifier, the optional *data* "
"argument may be given to specify a ``POST`` request (normally the request "
"type is ``GET``).  The *data* argument must be a bytes object in standard :"
"mimetype:`application/x-www-form-urlencoded` format; see the :func:`urllib."
"parse.urlencode` function."
msgstr ""
"如果 *url* 使用 :file:`http:` 方案標識符，可選的 *data* 參數可以指定一個 "
"``POST`` 請求（通常請求型別是 ``GET``）。 *data* 參數必須是標準 :mimetype:`"
"application/x-www-form-urlencoded` 格式的位元組物件；請參閱 :func:`urllib."
"parse.urlencode` 函式。"

#: ../../library/urllib.request.rst:1399
#, fuzzy
msgid ""
":func:`urlretrieve` will raise :exc:`ContentTooShortError` when it detects "
"that the amount of data available  was less than the expected amount (which "
"is the size reported by a  *Content-Length* header). This can occur, for "
"example, when the  download is interrupted."
msgstr ""
":func:`urlretrieve` 將在檢測到可用資料量小於預期量（這是 *Content-Length* "
"標頭報告的大小）時引發 "
":exc:`ContentTooShortError`。例如，當下載中斷時可能會發生這種情況。"

#: ../../library/urllib.request.rst:1404
#, fuzzy
msgid ""
"The *Content-Length* is treated as a lower bound: if there's more data  to "
"read, urlretrieve reads more data, but if less data is available,  it raises "
"the exception."
msgstr "*Content-Length* 被視為下限：如果有更多資料要讀取，urlretrieve "
"會讀取更多資料，但如果可用資料較少，則會引發例外。"

#: ../../library/urllib.request.rst:1408
#, fuzzy
msgid ""
"You can still retrieve the downloaded data in this case, it is stored  in "
"the :attr:`content` attribute of the exception instance."
msgstr "在這種情況下，您仍然可以檢索下載的資料，它儲存在例外實例的 :attr:`content` "
"屬性中。"

#: ../../library/urllib.request.rst:1411
#, fuzzy
msgid ""
"If no *Content-Length* header was supplied, urlretrieve can not check the "
"size of the data it has downloaded, and just returns it.  In this case you "
"just have to assume that the download was successful."
msgstr ""
"如果沒有提供 *Content-Length* 標頭，urlretrieve 無法檢查已下載資料的大小，而"
"只是回傳它。在這種情況下，您只需假設下載成功即可。"

#: ../../library/urllib.request.rst:1417
#, fuzzy
msgid ""
"Cleans up temporary files that may have been left behind by previous calls "
"to :func:`urlretrieve`."
msgstr "清理之前呼叫 urlretrieve 可能留下的臨時文件。"

#: ../../library/urllib.request.rst:1424
#, fuzzy
msgid ""
"Base class for opening and reading URLs.  Unless you need to support opening "
"objects using schemes other than :file:`http:`, :file:`ftp:`, or :file:`file:"
"`, you probably want to use :class:`FancyURLopener`."
msgstr ""
"打開和讀取 URL 的基底類別。除非您需要支援使用 :file:`http:`、:file:`ftp:` 或 "
":file:`file:` 以外的方案打開物件，否則您可能想要使用 "
":class:`FancyURLopener`。"

#: ../../library/urllib.request.rst:1428
#, fuzzy
msgid ""
"By default, the :class:`URLopener` class sends a :mailheader:`User-Agent` "
"header of ``urllib/VVV``, where *VVV* is the :mod:`urllib` version number. "
"Applications can define their own :mailheader:`User-Agent` header by "
"subclassing :class:`URLopener` or :class:`FancyURLopener` and setting the "
"class attribute :attr:`version` to an appropriate string value in the "
"subclass definition."
msgstr ""
"預設情況下，:class:`URLopener` 類發送 ``urllib/VVV`` 的 :mailheader:`User-"
"Agent` 標頭，其中 *VVV* 是 :mod:`urllib` 版本號。應用程式可以通過繼承 "
":class:`URLopener` 或 :class:`FancyURLopener` 並將類屬性 :attr:`version` "
"設定為子類別定義中的適當字串值來定義自己的 :mailheader:`User-Agent` 標頭。"

#: ../../library/urllib.request.rst:1434
#, fuzzy
msgid ""
"The optional *proxies* parameter should be a dictionary mapping scheme names "
"to proxy URLs, where an empty dictionary turns proxies off completely.  Its "
"default value is ``None``, in which case environmental proxy settings will "
"be used if present, as discussed in the definition of :func:`urlopen`, above."
msgstr ""
"可選的 *proxies* 參數應該是將方案名稱映射到代理 URL 的字典，其中空字典會完全"
"關閉代理。它的預設值為``None``，在這種情況下，如果存在環境代理設定，將使用它"
"，如上面 :func:`urlopen` 的定義中所討論的。"

#: ../../library/urllib.request.rst:1439
#, fuzzy
msgid ""
"Additional keyword parameters, collected in *x509*, may be used for "
"authentication of the client when using the :file:`https:` scheme.  The "
"keywords *key_file* and *cert_file* are supported to provide an  SSL key and "
"certificate; both are needed to support client authentication."
msgstr ""
"在 *x509* 中收集的其他關鍵字參數可用於在使用 :file:`https:` "
"方案時對客戶端進行身份驗證。支援關鍵字 *key_file* 和 *cert_file* "
"提供SSL密鑰和證書；兩者都需要支援客戶端身份驗證。"

#: ../../library/urllib.request.rst:1444
#, fuzzy
msgid ""
":class:`URLopener` objects will raise an :exc:`OSError` exception if the "
"server returns an error code."
msgstr "如果伺服器回傳錯誤程式碼，:class:`URLopener` 物件將引發 :exc:`OSError` 例外。"

#: ../../library/urllib.request.rst:1449
#, fuzzy
msgid ""
"Open *fullurl* using the appropriate protocol.  This method sets up cache "
"and proxy information, then calls the appropriate open method with its input "
"arguments.  If the scheme is not recognized, :meth:`open_unknown` is called. "
"The *data* argument has the same meaning as the *data* argument of :func:"
"`urlopen`."
msgstr ""
"使用適當的協定打開 *fullurl*。此方法設定快取和代理資訊，然後使用其輸入參數呼"
"叫適當的打開方法。如果該方案未被識別，則呼叫 :meth:`open_unknown`。 *data* "
"參數與 :func:`urlopen` 的 *data* 參數含義相同。"

#: ../../library/urllib.request.rst:1455
#, fuzzy
msgid "This method always quotes *fullurl* using :func:`~urllib.parse.quote`."
msgstr "此方法始終使用 :func:`~urllib.parse.quote` 引用 *fullurl*。"

#: ../../library/urllib.request.rst:1459
#, fuzzy
msgid "Overridable interface to open unknown URL types."
msgstr "用於打開未知 URL 型別的可重寫介面。"

#: ../../library/urllib.request.rst:1464
#, fuzzy
msgid ""
"Retrieves the contents of *url* and places it in *filename*.  The return "
"value is a tuple consisting of a local filename and either an :class:`email."
"message.Message` object containing the response headers (for remote URLs) or "
"``None`` (for local URLs).  The caller must then open and read the contents "
"of *filename*.  If *filename* is not given and the URL refers to a local "
"file, the input filename is returned.  If the URL is non-local and "
"*filename* is not given, the filename is the output of :func:`tempfile."
"mktemp` with a suffix that matches the suffix of the last path component of "
"the input URL.  If *reporthook* is given, it must be a function accepting "
"three numeric parameters: A chunk number, the maximum size chunks are read "
"in and the total size of the download (-1 if unknown).  It will be called "
"once at the start and after each chunk of data is read from the network.  "
"*reporthook* is ignored for local URLs."
msgstr ""
"檢索 *url* 的內容並將其放入 "
"*filename*。回傳值是一個元組，由本地文件名和包含響應標頭（對於遠程 "
"URL）或 ``None`` （對於本地 URL）的 :class:`email.message.Message` 物件組成。"
"然後呼叫者必須打開並讀取 *filename* 的內容。如果未給出 *filename* 且 URL "
"引用本地文件，則回傳輸入文件名。如果 URL 是非本地的且未給出 *filename*，"
"則文件名是 :func:`tempfile.mktemp` 的輸出，其後綴與輸入 URL "
"的最後一個路徑組件的後綴相匹配。如果給出 *reporthook*，它必須是一個接受三個數"
"字參數的函式：塊號、讀入的最大塊大小和下載的總大小（如果未知則為 "
"-1）。它將在開始時和從網絡讀取每個資料塊後呼叫一次。 *reporthook* 被本地 URL "
"忽略。"

#: ../../library/urllib.request.rst:1477
#, fuzzy
msgid ""
"If the *url* uses the :file:`http:` scheme identifier, the optional *data* "
"argument may be given to specify a ``POST`` request (normally the request "
"type is ``GET``).  The *data* argument must in standard :mimetype:"
"`application/x-www-form-urlencoded` format; see the :func:`urllib.parse."
"urlencode` function."
msgstr ""
"如果 *url* 使用 :file:`http:` 方案標識符，可選的 *data* 參數可以指定一個 "
"``POST`` 請求（通常請求型別是 ``GET``）。 *data* 參數必須採用標準的 "
":mimetype:`application/x-www-form-urlencoded` 格式；請參閱 :func:`urllib."
"parse.urlencode` 函式。"

#: ../../library/urllib.request.rst:1486
#, fuzzy
msgid ""
"Variable that specifies the user agent of the opener object.  To get :mod:"
"`urllib` to tell servers that it is a particular user agent, set this in a "
"subclass as a class variable or in the constructor before calling the base "
"constructor."
msgstr ""
"指定開啟者物件的使用者代理的變數。要讓 :mod:`urllib` 告訴伺服器它是一個特定的"
"使用者代理，請在子類別中將其設定為類變數或在呼叫基本構造函式之前在構造函式中"
"設定。"

#: ../../library/urllib.request.rst:1496
#, fuzzy
msgid ""
":class:`FancyURLopener` subclasses :class:`URLopener` providing default "
"handling for the following HTTP response codes: 301, 302, 303, 307 and 401.  "
"For the 30x response codes listed above, the :mailheader:`Location` header "
"is used to fetch the actual URL.  For 401 response codes (authentication "
"required), basic HTTP authentication is performed.  For the 30x response "
"codes, recursion is bounded by the value of the *maxtries* attribute, which "
"defaults to 10."
msgstr ""
":class:`FancyURLopener` 子類別 :class:`URLopener` 為以下 HTTP "
"響應程式碼提供預設處理：301、302、303、307 和 401。對於上面列出的 30x "
"響應程式碼，:mailheader:`Location` 標頭是用於獲取實際的 URL。對於 401 "
"響應程式碼（需要身份驗證），執行基本的 HTTP 身份驗證。對於 30x 響應程式碼，"
"遞迴受 *maxtries* 屬性值的限制，預設為 10。"

#: ../../library/urllib.request.rst:1503
#, fuzzy
msgid ""
"For all other response codes, the method :meth:`http_error_default` is "
"called which you can override in subclasses to handle the error "
"appropriately."
msgstr "對於所有其他響應程式碼，方法 :meth:`http_error_default` "
"被呼叫，您可以在子類別中重寫該方法以適當地處理錯誤。"

#: ../../library/urllib.request.rst:1508
#, fuzzy
msgid ""
"According to the letter of :rfc:`2616`, 301 and 302 responses to POST "
"requests must not be automatically redirected without confirmation by the "
"user.  In reality, browsers do allow automatic redirection of these "
"responses, changing the POST to a GET, and :mod:`urllib` reproduces this "
"behaviour."
msgstr ""
"根據 :rfc:`2616` 的信件，POST 請求的 301 和 302 響應在沒有使用者確認的情況下"
"不得自動重定向。實際上，瀏覽器確實允許自動重定向這些響應，將 POST 更改為 "
"GET，並且 :mod:`urllib` 重現了這種行為。"

#: ../../library/urllib.request.rst:1513
#, fuzzy
msgid ""
"The parameters to the constructor are the same as those for :class:"
"`URLopener`."
msgstr "構造函式的參數與 URLopener 的參數相同。"

#: ../../library/urllib.request.rst:1517
#, fuzzy
msgid ""
"When performing basic authentication, a :class:`FancyURLopener` instance "
"calls its :meth:`prompt_user_passwd` method.  The default implementation "
"asks the users for the required information on the controlling terminal.  A "
"subclass may override this method to support more appropriate behavior if "
"needed."
msgstr ""
"在執行基本身份驗證時，FancyURLopener 實例呼叫其 prompt_user_passwd 方法。預設"
"實作要求使用者在控制終端上提供所需資訊。如果需要，子類別可以覆蓋此方法以支援"
"更合適的行為。"

#: ../../library/urllib.request.rst:1522
#, fuzzy
msgid ""
"The :class:`FancyURLopener` class offers one additional method that should "
"be overloaded to provide the appropriate behavior:"
msgstr ":class:`FancyURLopener` 類提供了一個額外的方法，應該重載以提供適當的行為："

#: ../../library/urllib.request.rst:1527
#, fuzzy
msgid ""
"Return information needed to authenticate the user at the given host in the "
"specified security realm.  The return value should be a tuple, ``(user, "
"password)``, which can be used for basic authentication."
msgstr ""
"回傳在指定安全領域的給定主機上對使用者進行身份驗證所需的資訊。回傳值應該是一"
"個元組，``(user, password)``，可用於基本身份驗證。"

#: ../../library/urllib.request.rst:1531
#, fuzzy
msgid ""
"The implementation prompts for this information on the terminal; an "
"application should override this method to use an appropriate interaction "
"model in the local environment."
msgstr "實作在終端提示此資訊；應用程式應該覆蓋此方法以在本地環境中使用適當的交互模型"
"。"

#: ../../library/urllib.request.rst:1537
#, fuzzy
msgid ":mod:`urllib.request` Restrictions"
msgstr ":mod:`urllib.request` 限制"

#: ../../library/urllib.request.rst:1543
#, fuzzy
msgid ""
"Currently, only the following protocols are supported: HTTP (versions 0.9 "
"and 1.0), FTP, local files, and data URLs."
msgstr "目前，僅支援以下協定：HTTP（版本 0.9 和 1.0）、FTP、本地文件和資料 URL。"

#: ../../library/urllib.request.rst:1546
#, fuzzy
msgid "Added support for data URLs."
msgstr "新增了對資料 URL 的支援。"

#: ../../library/urllib.request.rst:1548
#, fuzzy
msgid ""
"The caching feature of :func:`urlretrieve` has been disabled until someone "
"finds the time to hack proper processing of Expiration time headers."
msgstr ":func:`urlretrieve` "
"的快取功能已被禁用，直到有人找到時間破解過期時間標頭的正確處理。"

#: ../../library/urllib.request.rst:1551
#, fuzzy
msgid ""
"There should be a function to query whether a particular URL is in the cache."
msgstr "應該有一個函式來查詢特定的 URL 是否在快取中。"

#: ../../library/urllib.request.rst:1553
#, fuzzy
msgid ""
"For backward compatibility, if a URL appears to point to a local file but "
"the file can't be opened, the URL is re-interpreted using the FTP protocol.  "
"This can sometimes cause confusing error messages."
msgstr "為了向後相容，如果 URL 似乎指向本地文件但無法打開該文件，則會使用 FTP "
"協定重新解釋該 URL。這有時會導致令人困惑的錯誤消息。"

#: ../../library/urllib.request.rst:1557
#, fuzzy
msgid ""
"The :func:`urlopen` and :func:`urlretrieve` functions can cause arbitrarily "
"long delays while waiting for a network connection to be set up.  This means "
"that it is difficult to build an interactive web client using these "
"functions without using threads."
msgstr ""
":func:`urlopen` 和 :func:`urlretrieve` "
"函式在等待建立網絡連接時可能導致任意長的延遲。"
"這意味著很難在不使用執行緒的情況下使用這些功能構建交互式 Web 客戶端。"

#: ../../library/urllib.request.rst:1566
#, fuzzy
msgid ""
"The data returned by :func:`urlopen` or :func:`urlretrieve` is the raw data "
"returned by the server.  This may be binary data (such as an image), plain "
"text or (for example) HTML.  The HTTP protocol provides type information in "
"the reply header, which can be inspected by looking at the :mailheader:"
"`Content-Type` header.  If the returned data is HTML, you can use the "
"module :mod:`html.parser` to parse it."
msgstr ""
":func:`urlopen` 或 :func:`urlretrieve` 回傳的資料是伺服器回傳的原始資料。這可"
"能是二進位資料（例如圖像）、純文本或（例如）HTML。 HTTP "
"協定在回覆標頭中提供型別資訊，可以通過查看:mailheader:`Content-Type` "
"標頭來檢查。如果回傳的資料是 HTML，您可以使用 :mod:`html.parser` "
"模組來解析它。"

#: ../../library/urllib.request.rst:1575
#, fuzzy
msgid ""
"The code handling the FTP protocol cannot differentiate between a file and a "
"directory.  This can lead to unexpected behavior when attempting to read a "
"URL that points to a file that is not accessible.  If the URL ends in a ``/"
"``, it is assumed to refer to a directory and will be handled accordingly.  "
"But if an attempt to read a file leads to a 550 error (meaning the URL "
"cannot be found or is not accessible, often for permission reasons), then "
"the path is treated as a directory in order to handle the case when a "
"directory is specified by a URL but the trailing ``/`` has been left off.  "
"This can cause misleading results when you try to fetch a file whose read "
"permissions make it inaccessible; the FTP code will try to read it, fail "
"with a 550 error, and then perform a directory listing for the unreadable "
"file. If fine-grained control is needed, consider using the :mod:`ftplib` "
"module, subclassing :class:`FancyURLopener`, or changing *_urlopener* to "
"meet your needs."
msgstr ""
"處理 FTP 協定的程式碼無法區分文件和目錄。當嘗試讀取指向無法訪問的文件的 URL "
"時，這可能會導致意外行為。如果 URL 以 ``/`` "
"結尾，則假定它指向一個目錄並將進行相應處理。但是，如果嘗試讀取文件導致 550 "
"錯誤（意味著無法找到或無法訪問 URL，通常是出於權限原因），"
"則該路徑將被視為目錄以處理指定目錄的情況通過 URL 但尾隨的``/`` 已被刪除。當您"
"嘗試獲取其讀取權限使其無法訪問的文件時，這可能會導致誤導性結果； FTP "
"程式碼將嘗試讀取它，失敗並回傳 550 "
"錯誤，然後為不可讀文件執行目錄列表。如果需要細粒度控制，請考慮使用 ftplib "
"模組、子類別 FancyURLopener 或更改 *_urlopener* 以滿足您的需求。"

#: ../../library/urllib.request.rst:1592
#, fuzzy
msgid ":mod:`urllib.response` --- Response classes used by urllib"
msgstr ":mod:`urllib.response` --- urllib 使用的響應類"

#: ../../library/urllib.request.rst:1597
#, fuzzy
msgid ""
"The :mod:`urllib.response` module defines functions and classes which define "
"a minimal file-like interface, including ``read()`` and ``readline()``. "
"Functions defined by this module are used internally by the :mod:`urllib."
"request` module. The typical response object is a :class:`urllib.response."
"addinfourl` instance:"
msgstr ""
":mod:`urllib.response` "
"模組定義了函式和類，它們定義了一個最小的類似文件的介面，包括 ``read()`` 和 "
"``readline()``。此模組定義的函式由 :mod:`urllib.request` 模組在內部使用。"
"典型的響應對像是一個 urllib.response.addinfol 實例："

#: ../../library/urllib.request.rst:1606
#, fuzzy
msgid ""
"URL of the resource retrieved, commonly used to determine if a redirect was "
"followed."
msgstr "檢索到的資源的 URL，通常用於確定是否遵循了重定向。"

#: ../../library/urllib.request.rst:1610
#, fuzzy
msgid ""
"Returns the headers of the response in the form of an :class:`~email.message."
"EmailMessage` instance."
msgstr "以 :class:`~email.message.EmailMessage` 實例的形式回傳響應的標頭。"

#: ../../library/urllib.request.rst:1616
#, fuzzy
msgid "Status code returned by server."
msgstr "伺服器回傳的狀態程式碼。"

#: ../../library/urllib.request.rst:1620
#, fuzzy
msgid "Deprecated in favor of :attr:`~addinfourl.url`."
msgstr "已棄用，取而代之的是 :attr:`~addinfol.url`。"

#: ../../library/urllib.request.rst:1625
#, fuzzy
msgid "Deprecated in favor of :attr:`~addinfourl.headers`."
msgstr "已棄用，取而代之的是 :attr:`~addinfol.headers`。"

#: ../../library/urllib.request.rst:1630 ../../library/urllib.request.rst:1635
#, fuzzy
msgid "Deprecated in favor of :attr:`~addinfourl.status`."
msgstr "已棄用，取而代之的是 :attr:`~addinfol.status`。"
