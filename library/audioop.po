# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-15 20:43+0000\n"
"PO-Revision-Date: 2022-05-22 02:00+0800\n"
"Last-Translator: Liang-Bo Wang <me@liang2.tw>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../library/audioop.rst:2
msgid ":mod:`audioop` --- Manipulate raw audio data"
msgstr ":mod:`audioop` --- 操作原始聲音檔案"

#: ../../library/audioop.rst:11
msgid ""
"The :mod:`audioop` module is deprecated (see :pep:`PEP 594 <594#audioop>` "
"for details)."
msgstr ""
":mod:`audioop` 模組 (module) 即將被棄用（詳見 :pep:`PEP 594 <594#audioop>`"
"\\ ）。"

#: ../../library/audioop.rst:14
#, fuzzy
msgid ""
"The :mod:`audioop` module contains some useful operations on sound "
"fragments. It operates on sound fragments consisting of signed integer "
"samples 8, 16, 24 or 32 bits wide, stored in :term:`bytes-like objects "
"<bytes-like object>`.  All scalar items are integers, unless specified "
"otherwise."
msgstr ""
":mod:`audioop` 模組包含一些對聲音片段有用的操作。它對由 8、16、24 或 32 "
"位寬的有符號整數樣本組成的聲音片段進行操作，這些樣本儲存在 :term:`bytes-like "
"objects <bytes-like object>` 中。除非另有說明，否則所有標量項都是整數。"

#: ../../library/audioop.rst:19
#, fuzzy
msgid ""
"Support for 24-bit samples was added. All functions now accept any :term:"
"`bytes-like object`. String input now results in an immediate error."
msgstr "新增了對 24 位樣本的支援。所有函式現在都接受任何 :term:`bytes-like "
"object`。字串輸入現在會導致立即錯誤。"

#: ../../library/audioop.rst:30
#, fuzzy
msgid ""
"This module provides support for a-LAW, u-LAW and Intel/DVI ADPCM encodings."
msgstr "該模組支援 a-LAW、u-LAW 和 Intel/DVI ADPCM 編碼。"

#: ../../library/audioop.rst:34
#, fuzzy
msgid ""
"A few of the more complicated operations only take 16-bit samples, otherwise "
"the sample size (in bytes) is always a parameter of the operation."
msgstr "一些更複雜的操作只需要 16 "
"位樣本，否則樣本大小（以位元組為單位）始終是操作的參數。"

#: ../../library/audioop.rst:37
#, fuzzy
msgid "The module defines the following variables and functions:"
msgstr "該模組定義了以下變數和函式："

#: ../../library/audioop.rst:42
#, fuzzy
msgid ""
"This exception is raised on all errors, such as unknown number of bytes per "
"sample, etc."
msgstr "所有錯誤都會引發此例外，例如每個樣本的未知位元組數等。"

#: ../../library/audioop.rst:48
#, fuzzy
msgid ""
"Return a fragment which is the addition of the two samples passed as "
"parameters. *width* is the sample width in bytes, either ``1``, ``2``, ``3`` "
"or ``4``.  Both fragments should have the same length.  Samples are "
"truncated in case of overflow."
msgstr ""
"回傳一個片段，它是作為參數傳遞的兩個樣本的加法。 *width* "
"是以位元組為單位的樣本寬度，可以是 ``1``、``2``、``3`` 或 "
"``4``。兩個片段的長度應該相同。如果溢出，樣本將被截斷。"

#: ../../library/audioop.rst:55
#, fuzzy
msgid ""
"Decode an Intel/DVI ADPCM coded fragment to a linear fragment.  See the "
"description of :func:`lin2adpcm` for details on ADPCM coding. Return a tuple "
"``(sample, newstate)`` where the sample has the width specified in *width*."
msgstr ""
"將 Intel/DVI ADPCM 編碼片段解碼為線性片段。有關 ADPCM 編碼的詳細資訊，請參閱 "
":func:`lin2adpcm` 的說明。回傳一個元組``(sample, newstate)``，"
"其中樣本的寬度在 *width* 中指定。"

#: ../../library/audioop.rst:62
#, fuzzy
msgid ""
"Convert sound fragments in a-LAW encoding to linearly encoded sound "
"fragments. a-LAW encoding always uses 8 bits samples, so *width* refers only "
"to the sample width of the output fragment here."
msgstr ""
"將 a-LAW 編碼中的聲音片段轉換為線性編碼的聲音片段。 a-LAW 編碼始終使用 8 "
"位樣本，因此 *width* 僅指此處輸出片段的樣本寬度。"

#: ../../library/audioop.rst:69
#, fuzzy
msgid "Return the average over all samples in the fragment."
msgstr "回傳片段中所有樣本的平均值。"

#: ../../library/audioop.rst:74
#, fuzzy
msgid ""
"Return the average peak-peak value over all samples in the fragment. No "
"filtering is done, so the usefulness of this routine is questionable."
msgstr "回傳片段中所有樣本的平均峰峰值。沒有過濾，所以這個例程的用處值得懷疑。"

#: ../../library/audioop.rst:80
#, fuzzy
msgid ""
"Return a fragment that is the original fragment with a bias added to each "
"sample.  Samples wrap around in case of overflow."
msgstr "回傳一個片段，該片段是原始片段，每個樣本都新增了偏差。樣品環繞以防溢出。"

#: ../../library/audioop.rst:86
#, fuzzy
msgid ""
"\"Byteswap\" all samples in a fragment and returns the modified fragment. "
"Converts big-endian samples to little-endian and vice versa."
msgstr "“位元組交換”片段中的所有樣本並回傳修改後的片段。將大端樣本轉換為小端樣本，反"
"之亦然。"

#: ../../library/audioop.rst:94
#, fuzzy
msgid ""
"Return the number of zero crossings in the fragment passed as an argument."
msgstr "回傳作為參數傳遞的片段中的零交叉數。"

#: ../../library/audioop.rst:99
#, fuzzy
msgid ""
"Return a factor *F* such that ``rms(add(fragment, mul(reference, -F)))`` is "
"minimal, i.e., return the factor with which you should multiply *reference* "
"to make it match as well as possible to *fragment*.  The fragments should "
"both contain 2-byte samples."
msgstr ""
"回傳一個因子 *F* 使得 ``rms(add(fragment, mul(reference, -F)))`` "
"最小，即回傳一個因子，您應該將 *reference* "
"與該因子相乘以使其匹配以及可能*片段*。這些片段都應包含 2 位元組樣本。"

#: ../../library/audioop.rst:104
#, fuzzy
msgid "The time taken by this routine is proportional to ``len(fragment)``."
msgstr "此例程所花費的時間與 ``len(fragment)`` 成正比。"

#: ../../library/audioop.rst:109
#, fuzzy
msgid ""
"Try to match *reference* as well as possible to a portion of *fragment* "
"(which should be the longer fragment).  This is (conceptually) done by "
"taking slices out of *fragment*, using :func:`findfactor` to compute the "
"best match, and minimizing the result.  The fragments should both contain 2-"
"byte samples. Return a tuple ``(offset, factor)`` where *offset* is the "
"(integer) offset into *fragment* where the optimal match started and "
"*factor* is the (floating-point) factor as per :func:`findfactor`."
msgstr ""
"盡量將 *reference* 與 *fragment* "
"的一部分（應該是較長的片段）相匹配。這是（概念上）通過從 *fragment* "
"中取出切片，使用 :func:`findfactor` 計算最佳匹配並將結果最小化來完成的。"
"這些片段都應包含 2 位元組樣本。回傳一個元組 ``(offset, factor)`` 其中 "
"*offset* 是最佳匹配開始的 *fragment* 的（整數）偏移量，*factor* 是根據 "
":func:`findfactor 的（浮點）因子`。"

#: ../../library/audioop.rst:120
#, fuzzy
msgid ""
"Search *fragment* for a slice of length *length* samples (not bytes!) with "
"maximum energy, i.e., return *i* for which ``rms(fragment[i*2:(i"
"+length)*2])`` is maximal.  The fragments should both contain 2-byte samples."
msgstr ""
"在 *fragment* 中搜索具有最大能量的長度 *length* 樣本（不是位元組！）的切片，"
"即回傳 *i* 其中 ``rms(fragment[i*2:(i+length)*2])` ` 是最大的。"
"這些片段都應包含 2 位元組樣本。"

#: ../../library/audioop.rst:124
#, fuzzy
msgid "The routine takes time proportional to ``len(fragment)``."
msgstr "該例程花費的時間與 ``len(fragment)`` 成正比。"

#: ../../library/audioop.rst:129
#, fuzzy
msgid "Return the value of sample *index* from the fragment."
msgstr "從片段中回傳樣本 *index* 的值。"

#: ../../library/audioop.rst:134
#, fuzzy
msgid ""
"Convert samples to 4 bit Intel/DVI ADPCM encoding.  ADPCM coding is an "
"adaptive coding scheme, whereby each 4 bit number is the difference between "
"one sample and the next, divided by a (varying) step.  The Intel/DVI ADPCM "
"algorithm has been selected for use by the IMA, so it may well become a "
"standard."
msgstr ""
"將樣本轉換為 4 位 Intel/DVI ADPCM 編碼。 ADPCM 編碼是一種自適應編碼方案，"
"其中每個 4 位數字是一個樣本與下一個樣本之間的差異，除以（變化的）步長。 "
"Intel/DVI ADPCM 演算法已被 IMA 選擇使用，因此很可能成為標準。"

#: ../../library/audioop.rst:139
#, fuzzy
msgid ""
"*state* is a tuple containing the state of the coder.  The coder returns a "
"tuple ``(adpcmfrag, newstate)``, and the *newstate* should be passed to the "
"next call of :func:`lin2adpcm`.  In the initial call, ``None`` can be passed "
"as the state. *adpcmfrag* is the ADPCM coded fragment packed 2 4-bit values "
"per byte."
msgstr ""
"*state* 是一個包含編碼器狀態的元組。編碼器回傳一個元組``(adpcmfrag, "
"newstate)``，*newstate* 應該傳遞給 lin2adpcm "
"的下一次呼叫。在初始呼叫中， ``None`` 可以作為狀態傳遞。 *adpcmfrag* 是 ADPCM "
"編碼片段，每個位元組包含 2 個 4 位值。"

#: ../../library/audioop.rst:147
#, fuzzy
msgid ""
"Convert samples in the audio fragment to a-LAW encoding and return this as a "
"bytes object.  a-LAW is an audio encoding format whereby you get a dynamic "
"range of about 13 bits using only 8 bit samples.  It is used by the Sun "
"audio hardware, among others."
msgstr ""
"將音頻片段中的樣本轉換為 a-LAW 編碼並將其作為位元組物件回傳。 a-LAW "
"是一種音頻編碼格式，您僅使用 8 位樣本即可獲得大約 13 位的動態範圍。它被 Sun "
"音頻硬件等使用。"

#: ../../library/audioop.rst:155
#, fuzzy
msgid "Convert samples between 1-, 2-, 3- and 4-byte formats."
msgstr "在 1、2、3 和 4 位元組格式之間轉換樣本。"

#: ../../library/audioop.rst:159
#, fuzzy
msgid ""
"In some audio formats, such as .WAV files, 16, 24 and 32 bit samples are "
"signed, but 8 bit samples are unsigned.  So when converting to 8 bit wide "
"samples for these formats, you need to also add 128 to the result::"
msgstr ""
"在某些音頻格式中，例如 .WAV 文件，16、24 和 32 位樣本是有符號的，但 8 "
"位樣本是無符號的。因此，當將這些格式轉換為 8 位寬樣本時，您還需要將 128 "
"新增到結果中："

#: ../../library/audioop.rst:166
#, fuzzy
msgid ""
"The same, in reverse, has to be applied when converting from 8 to 16, 24 or "
"32 bit width samples."
msgstr "當從 8 位寬度樣本轉換為 16、24 或 32 位寬度樣本時，必須反過來應用相同的方法。"

#: ../../library/audioop.rst:172
#, fuzzy
msgid ""
"Convert samples in the audio fragment to u-LAW encoding and return this as a "
"bytes object.  u-LAW is an audio encoding format whereby you get a dynamic "
"range of about 14 bits using only 8 bit samples.  It is used by the Sun "
"audio hardware, among others."
msgstr ""
"將音頻片段中的樣本轉換為 u-LAW 編碼並將其作為位元組物件回傳。 u-LAW "
"是一種音頻編碼格式，您僅使用 8 位樣本即可獲得大約 14 位的動態範圍。它被 Sun "
"音頻硬件等使用。"

#: ../../library/audioop.rst:180
#, fuzzy
msgid ""
"Return the maximum of the *absolute value* of all samples in a fragment."
msgstr "回傳片段中所有樣本的*絕對值*的最大值。"

#: ../../library/audioop.rst:185
#, fuzzy
msgid "Return the maximum peak-peak value in the sound fragment."
msgstr "回傳聲音片段中的最大峰峰值。"

#: ../../library/audioop.rst:190
#, fuzzy
msgid ""
"Return a tuple consisting of the minimum and maximum values of all samples "
"in the sound fragment."
msgstr "回傳由聲音片段中所有樣本的最小值和最大值組成的元組。"

#: ../../library/audioop.rst:196
#, fuzzy
msgid ""
"Return a fragment that has all samples in the original fragment multiplied "
"by the floating-point value *factor*.  Samples are truncated in case of "
"overflow."
msgstr "回傳一個片段，該片段將原始片段中的所有樣本乘以浮點值 "
"*factor*。如果溢出，樣本將被截斷。"

#: ../../library/audioop.rst:202
#, fuzzy
msgid "Convert the frame rate of the input fragment."
msgstr "轉換輸入片段的幀速率。"

#: ../../library/audioop.rst:204
#, fuzzy
msgid ""
"*state* is a tuple containing the state of the converter.  The converter "
"returns a tuple ``(newfragment, newstate)``, and *newstate* should be passed "
"to the next call of :func:`ratecv`.  The initial call should pass ``None`` "
"as the state."
msgstr ""
"*state* 是一個包含轉換器狀態的元組。轉換器回傳一個元組``(newfragment, "
"newstate)``，*newstate* "
"應該傳遞給下一次呼叫 :func:`ratecv`。初始呼叫應傳遞 ``None`` 作為狀態。"

#: ../../library/audioop.rst:208
#, fuzzy
msgid ""
"The *weightA* and *weightB* arguments are parameters for a simple digital "
"filter and default to ``1`` and ``0`` respectively."
msgstr "*weightA* 和 *weightB* 參數是簡單數字濾波器的參數，預設分別為 ``1``和 ``0``。"

#: ../../library/audioop.rst:214
#, fuzzy
msgid "Reverse the samples in a fragment and returns the modified fragment."
msgstr "反轉片段中的樣本並回傳修改後的片段。"

#: ../../library/audioop.rst:219
#, fuzzy
msgid ""
"Return the root-mean-square of the fragment, i.e. ``sqrt(sum(S_i^2)/n)``."
msgstr "回傳片段的均方根，即 ``sqrt(sum(S_i^2)/n)``。"

#: ../../library/audioop.rst:221
#, fuzzy
msgid "This is a measure of the power in an audio signal."
msgstr "這是衡量音頻信號功率的指標。"

#: ../../library/audioop.rst:226
#, fuzzy
msgid ""
"Convert a stereo fragment to a mono fragment.  The left channel is "
"multiplied by *lfactor* and the right channel by *rfactor* before adding the "
"two channels to give a mono signal."
msgstr "將立體片段轉換為單聲道片段。左聲道乘以 *lfactor*，右聲道乘以 "
"*rfactor*，然後將兩個聲道相加得到單聲道信號。"

#: ../../library/audioop.rst:233
#, fuzzy
msgid ""
"Generate a stereo fragment from a mono fragment.  Each pair of samples in "
"the stereo fragment are computed from the mono sample, whereby left channel "
"samples are multiplied by *lfactor* and right channel samples by *rfactor*."
msgstr ""
"從單聲道片段生成立體聲片段。立體片段中的每對樣本都是從單聲道樣本計算得出的，"
"其中左聲道樣本乘以*lfactor*，右聲道樣本乘以*rfactor*。"

#: ../../library/audioop.rst:240
#, fuzzy
msgid ""
"Convert sound fragments in u-LAW encoding to linearly encoded sound "
"fragments. u-LAW encoding always uses 8 bits samples, so *width* refers only "
"to the sample width of the output fragment here."
msgstr ""
"將 u-LAW 編碼的聲音片段轉換為線性編碼的聲音片段。 u-LAW 編碼始終使用 8 "
"位樣本，因此 *width* 僅指此處輸出片段的樣本寬度。"

#: ../../library/audioop.rst:244
#, fuzzy
msgid ""
"Note that operations such as :func:`.mul` or :func:`.max` make no "
"distinction between mono and stereo fragments, i.e. all samples are treated "
"equal.  If this is a problem the stereo fragment should be split into two "
"mono fragments first and recombined later.  Here is an example of how to do "
"that::"
msgstr ""
"請注意，諸如 :func:`.mul` 或 :func:`.max` 之類的操作不會區分單聲道和立體聲片"
"段，即所有樣本都被平等對待。如果這是一個問題，應該先將立體聲片段分成兩個單聲"
"道片段，然後再重新組合。這是一個如何做到這一點的例子::"

#: ../../library/audioop.rst:258
#, fuzzy
msgid ""
"If you use the ADPCM coder to build network packets and you want your "
"protocol to be stateless (i.e. to be able to tolerate packet loss) you "
"should not only transmit the data but also the state.  Note that you should "
"send the *initial* state (the one you passed to :func:`lin2adpcm`) along to "
"the decoder, not the final state (as returned by the coder).  If you want to "
"use :class:`struct.Struct` to store the state in binary you can code the "
"first element (the predicted value) in 16 bits and the second (the delta "
"index) in 8."
msgstr ""
"如果您使用 ADPCM 編碼器構建網絡資料包並且您希望您的協定是無狀態的（即能夠容忍"
"資料包丟失），您不僅應該傳輸資料還應該傳輸狀態。請注意，您應該將*初始*狀態（"
"您傳遞給 lin2adpcm 的那個）發送到解碼器，而不是最終狀態（由編碼器回傳）。"
"如果您想使用 struct.Struct 以二進位形式儲存狀態，您可以將第一個元素（預測值）"
"編碼為 16 位，將第二個元素（增量索引）編碼為 8 位。"

#: ../../library/audioop.rst:266
#, fuzzy
msgid ""
"The ADPCM coders have never been tried against other ADPCM coders, only "
"against themselves.  It could well be that I misinterpreted the standards in "
"which case they will not be interoperable with the respective standards."
msgstr ""
"ADPCM 編碼器從未針對其他 ADPCM 編碼器進行過測試，僅針對它們自己。很可能是我誤"
"解了標準，在這種情況下，它們將無法與各自的標準互操作。"

#: ../../library/audioop.rst:270
#, fuzzy
msgid ""
"The :func:`find\\*` routines might look a bit funny at first sight. They are "
"primarily meant to do echo cancellation.  A reasonably fast way to do this "
"is to pick the most energetic piece of the output sample, locate that in the "
"input sample and subtract the whole output sample from the input sample::"
msgstr ""
":func:`find\\*` 例程乍一看可能有點滑稽。它們主要用於消除迴聲。一種相當快速的"
"方法是選擇輸出樣本中能量最大的部分，將其定位在輸入樣本中，然後從輸入樣本中減"
"去整個輸出樣本："
