# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-25 00:20+0000\n"
"PO-Revision-Date: 2018-05-23 16:07+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/optparse.rst:2
msgid ":mod:`optparse` --- Parser for command line options"
msgstr ":mod:`optparse` --- 命令列選項的解析器"

#: ../../library/optparse.rst:11
msgid "**Source code:** :source:`Lib/optparse.py`"
msgstr "**原始碼：**\\ :source:`Lib/optparse.py`"

#: ../../library/optparse.rst:13
#, fuzzy
msgid ""
"The :mod:`optparse` module is deprecated and will not be developed further; "
"development will continue with the :mod:`argparse` module."
msgstr ":mod:`optparse` 模組已棄用，不會進一步開發； argparse 模組將繼續開發。"

#: ../../library/optparse.rst:19
#, fuzzy
msgid ""
":mod:`optparse` is a more convenient, flexible, and powerful library for "
"parsing command-line options than the old :mod:`getopt` module.  :mod:"
"`optparse` uses a more declarative style of command-line parsing: you create "
"an instance of :class:`OptionParser`, populate it with options, and parse "
"the command line. :mod:`optparse` allows users to specify options in the "
"conventional GNU/POSIX syntax, and additionally generates usage and help "
"messages for you."
msgstr ""
":mod:`optparse` 是一個比舊的 :mod:`getopt` "
"模組更方便、更靈活、更強大的命令列選項解析庫。 :mod:`optparse` "
"使用更具聲明性的命令列解析樣式：您建立一個 :class:`OptionParser` "
"的實例，用選項填充它，然後解析命令列。 :mod:`optparse` 允許使用者在傳統的 "
"GNU/POSIX 語法中指定選項，並另外為您生成用法和幫助消息。"

#: ../../library/optparse.rst:26
#, fuzzy
msgid "Here's an example of using :mod:`optparse` in a simple script::"
msgstr "這是在簡單腳本中使用 :mod:`optparse` 的示例："

#: ../../library/optparse.rst:39
#, fuzzy
msgid ""
"With these few lines of code, users of your script can now do the \"usual "
"thing\" on the command-line, for example::"
msgstr "使用這幾行程式碼，您腳本的使用者現在可以在命令列上執行“常規操作”，例如："

#: ../../library/optparse.rst:44
#, fuzzy
msgid ""
"As it parses the command line, :mod:`optparse` sets attributes of the "
"``options`` object returned by :meth:`parse_args` based on user-supplied "
"command-line values.  When :meth:`parse_args` returns from parsing this "
"command line, ``options.filename`` will be ``\"outfile\"`` and ``options."
"verbose`` will be ``False``.  :mod:`optparse` supports both long and short "
"options, allows short options to be merged together, and allows options to "
"be associated with their arguments in a variety of ways.  Thus, the "
"following command lines are all equivalent to the above example::"
msgstr ""
"在解析命令列時，:mod:`optparse` 根據使用者提供的命令列值設定 "
":meth:`parse_args` 回傳的 ``options`` 物件的屬性。當 :meth:`parse_args` "
"從解析此命令列回傳時，``options.filename`` 將是 ``\"outfile\"`` 而 ``options."
"verbose`` 將是 ``False``。 :mod:`optparse` 支援長選項和短選項，允許將短選項合"
"併在一起，並允許選項以多種方式與其參數相關聯。因此，以下命令列都等同於上面的"
"示例："

#: ../../library/optparse.rst:58
#, fuzzy
msgid "Additionally, users can run one of the following ::"
msgstr "此外，使用者可以運行以下其中一項 ::"

#: ../../library/optparse.rst:63
#, fuzzy
msgid ""
"and :mod:`optparse` will print out a brief summary of your script's options:"
msgstr "和 :mod:`optparse` 將印出出腳本選項的簡短摘要："

#: ../../library/optparse.rst:74
#, fuzzy
msgid ""
"where the value of *yourscript* is determined at runtime (normally from "
"``sys.argv[0]``)."
msgstr "其中 *yourscript* 的值在運行時確定（通常來自 ``sys.argv[0]``）。"

#: ../../library/optparse.rst:81
#, fuzzy
msgid "Background"
msgstr "背景"

#: ../../library/optparse.rst:83
#, fuzzy
msgid ""
":mod:`optparse` was explicitly designed to encourage the creation of "
"programs with straightforward, conventional command-line interfaces.  To "
"that end, it supports only the most common command-line syntax and semantics "
"conventionally used under Unix.  If you are unfamiliar with these "
"conventions, read this section to acquaint yourself with them."
msgstr ""
":mod:`optparse` 明確旨在鼓勵使用簡單、傳統的命令列界面建立程式。為此，"
"它僅支援 Unix 下通常使用的最常見的命令列語法和語義。如果您不熟悉這些約定，請"
"閱讀本節以熟悉它們。"

#: ../../library/optparse.rst:93
#, fuzzy
msgid "Terminology"
msgstr "術語"

#: ../../library/optparse.rst:104
#, fuzzy
msgid "argument"
msgstr "爭論"

#: ../../library/optparse.rst:96
#, fuzzy
msgid ""
"a string entered on the command-line, and passed by the shell to ``execl()`` "
"or ``execv()``.  In Python, arguments are elements of ``sys.argv[1:]`` "
"(``sys.argv[0]`` is the name of the program being executed).  Unix shells "
"also use the term \"word\"."
msgstr ""
"在命令列上輸入的字串，並由 shell 傳遞給 ``execl()`` 或 ``execv()``。在 "
"Python 中，參數是 ``sys.argv[1:]`` 的元素（``sys.argv[0]`` "
"是正在執行的程式的名稱）。 Unix shell 也使用術語 ``word``。"

#: ../../library/optparse.rst:101
#, fuzzy
msgid ""
"It is occasionally desirable to substitute an argument list other than ``sys."
"argv[1:]``, so you should read \"argument\" as \"an element of ``sys."
"argv[1:]``, or of some other list provided as a substitute for ``sys."
"argv[1:]``\"."
msgstr ""
"有時需要用 ``sys.argv[1:]`` "
"以外的參數列表來替換，因此您應該將 ``argument`` 讀作“``sys.argv[1:]`` "
"的一個元素，或者一些提供的其他列表可替代 ``sys.argv[1:]``\"。"

#: ../../library/optparse.rst:134
#, fuzzy
msgid "option"
msgstr "選項"

#: ../../library/optparse.rst:107
#, fuzzy
msgid ""
"an argument used to supply extra information to guide or customize the "
"execution of a program.  There are many different syntaxes for options; the "
"traditional Unix syntax is a hyphen (\"-\") followed by a single letter, e."
"g. ``-x`` or ``-F``.  Also, traditional Unix syntax allows multiple options "
"to be merged into a single argument, e.g. ``-x -F`` is equivalent to ``-"
"xF``.  The GNU project introduced ``--`` followed by a series of hyphen-"
"separated words, e.g. ``--file`` or ``--dry-run``.  These are the only two "
"option syntaxes provided by :mod:`optparse`."
msgstr ""
"用於提供額外資訊以指導或自定義程式執行的參數。選項有許多不同的語法；傳統的 "
"Unix 語法是一個連字元（ ``-``）後跟一個字母，例如``-x`` 或 ``-F``。此外，傳統的 "
"Unix 語法允許將多個選項合併到一個參數中，例如``-x -F`` 等同於 ``-xF``。 GNU "
"項目引入了 ``--`` 後跟一系列連字元分隔的單詞，例如``--file`` 或 ``--dry-"
"run``。這些是 :mod:`optparse` 提供的僅有的兩個選項語法。"

#: ../../library/optparse.rst:116
#, fuzzy
msgid "Some other option syntaxes that the world has seen include:"
msgstr "世界上已經看到的其他一些選項語法包括："

#: ../../library/optparse.rst:118
#, fuzzy
msgid ""
"a hyphen followed by a few letters, e.g. ``-pf`` (this is *not* the same as "
"multiple options merged into a single argument)"
msgstr "一個連字元後跟幾個字母，例如``-pf``（這*不*與合併到單個參數中的多個選項相同）"

#: ../../library/optparse.rst:121
#, fuzzy
msgid ""
"a hyphen followed by a whole word, e.g. ``-file`` (this is technically "
"equivalent to the previous syntax, but they aren't usually seen in the same "
"program)"
msgstr "一個連字元後跟一個完整的單詞，例如``-file``（這在技術上等同於前面的語法，但它"
"們通常不會出現在同一個程式中）"

#: ../../library/optparse.rst:125
#, fuzzy
msgid ""
"a plus sign followed by a single letter, or a few letters, or a word, e.g. "
"``+f``, ``+rgb``"
msgstr "一個加號後跟一個字母，或幾個字母，或一個詞，例如``+f``, ``+rgb``"

#: ../../library/optparse.rst:128
#, fuzzy
msgid ""
"a slash followed by a letter, or a few letters, or a word, e.g. ``/f``, ``/"
"file``"
msgstr "一個斜杠後跟一個字母，或幾個字母，或一個詞，例如``/f``, ``/文件``"

#: ../../library/optparse.rst:131
#, fuzzy
msgid ""
"These option syntaxes are not supported by :mod:`optparse`, and they never "
"will be.  This is deliberate: the first three are non-standard on any "
"environment, and the last only makes sense if you're exclusively targeting "
"Windows or certain legacy platforms (e.g. VMS, MS-DOS)."
msgstr ""
":mod:`optparse` 不支援這些選項語法，而且永遠不會。這是故意的：前三個在任何環"
"境下都是非標準的，而最後一個只有在您專門針對 Windows 或某些遺留平台（例如 VMS"
"、MS-DOS）時才有意義。"

#: ../../library/optparse.rst:160
#, fuzzy
msgid "option argument"
msgstr "選項參數"

#: ../../library/optparse.rst:137
#, fuzzy
msgid ""
"an argument that follows an option, is closely associated with that option, "
"and is consumed from the argument list when that option is. With :mod:"
"`optparse`, option arguments may either be in a separate argument from their "
"option:"
msgstr "選項後面的參數與該選項密切相關，並在該選項存在時從參數列表中使用。使用 "
":mod:`optparse`，選項參數可以在與其選項不同的參數中："

#: ../../library/optparse.rst:147
#, fuzzy
msgid "or included in the same argument:"
msgstr "或包含在同一參數中："

#: ../../library/optparse.rst:154
#, fuzzy
msgid ""
"Typically, a given option either takes an argument or it doesn't. Lots of "
"people want an \"optional option arguments\" feature, meaning that some "
"options will take an argument if they see it, and won't if they don't.  This "
"is somewhat controversial, because it makes parsing ambiguous: if ``-a`` "
"takes an optional argument and ``-b`` is another option entirely, how do we "
"interpret ``-ab``?  Because of this ambiguity, :mod:`optparse` does not "
"support this feature."
msgstr ""
"通常，給定的選項要么接受參數，要么不接受。許多人想要一個“可選選項參數”特性，"
"這意味著一些選項如果他們看到它就會接受一個參數，如果他們沒有看到則不會。這有"
"點爭議，因為它使解析變得模棱兩可：如果 ``-a`` 接受一個可選參數而 ``-b`` "
"完全是另一個選項，我們如何解釋 ``-ab``？由於這種歧義，:mod:`optparse` "
"不支援此功能。"

#: ../../library/optparse.rst:165
#, fuzzy
msgid "positional argument"
msgstr "位置參數"

#: ../../library/optparse.rst:163
#, fuzzy
msgid ""
"something leftover in the argument list after options have been parsed, i.e. "
"after options and their arguments have been parsed and removed from the "
"argument list."
msgstr "解析選項後參數列表中剩餘的東西，即在選項及其參數被解析並從參數列表中刪除之後"
"。"

#: ../../library/optparse.rst:171
#, fuzzy
msgid "required option"
msgstr "必選項"

#: ../../library/optparse.rst:168
#, fuzzy
msgid ""
"an option that must be supplied on the command-line; note that the phrase "
"\"required option\" is self-contradictory in English.  :mod:`optparse` "
"doesn't prevent you from implementing required options, but doesn't give you "
"much help at it either."
msgstr ""
"必須在命令列上提供的選項；請注意，短語“required option”在英語中是自相矛盾的。"
" :mod:`optparse` 不會阻止您實作所需的選項，但也不會給您太多幫助。"

#: ../../library/optparse.rst:173
#, fuzzy
msgid "For example, consider this hypothetical command-line::"
msgstr "例如，考慮這個假設的命令列::"

#: ../../library/optparse.rst:177
#, fuzzy
msgid ""
"``-v`` and ``--report`` are both options.  Assuming that ``--report`` takes "
"one argument, ``report.txt`` is an option argument.  ``foo`` and ``bar`` are "
"positional arguments."
msgstr ""
"``-v`` 和 ``--report`` 都是選項。假設 ``--report`` 接受一個參數，``report."
"txt`` 是一個選項參數。 ``foo`` 和 ``bar`` 是位置參數。"

#: ../../library/optparse.rst:185
#, fuzzy
msgid "What are options for?"
msgstr "選項有什麼用？"

#: ../../library/optparse.rst:187
#, fuzzy
msgid ""
"Options are used to provide extra information to tune or customize the "
"execution of a program.  In case it wasn't clear, options are usually "
"*optional*.  A program should be able to run just fine with no options "
"whatsoever.  (Pick a random program from the Unix or GNU toolsets.  Can it "
"run without any options at all and still make sense?  The main exceptions "
"are ``find``, ``tar``, and ``dd``\\ ---all of which are mutant oddballs that "
"have been rightly criticized for their non-standard syntax and confusing "
"interfaces.)"
msgstr ""
"選項用於提供額外資訊以調整或自定義程式的執行。如果不清楚，選項通常是*可選的*"
"。一個程式應該能夠在沒有任何選項的情況下運行得很好。 （從 Unix 或 GNU "
"工具集中隨機選擇一個程式。它可以在沒有任何選項的情況下運行並且仍然有意義嗎？"
"主要的例外是 ``find``、``tar`` 和 ``dd``\\ -- "
"-所有這些都是變異的怪人，因其不標準的語法和令人困惑的界面而受到正確的批評。）"

#: ../../library/optparse.rst:195
#, fuzzy
msgid ""
"Lots of people want their programs to have \"required options\".  Think "
"about it. If it's required, then it's *not optional*!  If there is a piece "
"of information that your program absolutely requires in order to run "
"successfully, that's what positional arguments are for."
msgstr ""
"許多人希望他們的程式具有“必需的選項”。想想看。如果它是必需的，那麼它*不是可選"
"的*！如果有一條資訊是您的程式為了成功運行而絕對需要的，那麼這就是位置參數的用"
"途。"

#: ../../library/optparse.rst:200
#, fuzzy
msgid ""
"As an example of good command-line interface design, consider the humble "
"``cp`` utility, for copying files.  It doesn't make much sense to try to "
"copy files without supplying a destination and at least one source. Hence, "
"``cp`` fails if you run it with no arguments.  However, it has a flexible, "
"useful syntax that does not require any options at all::"
msgstr ""
"作為良好命令列界面設計的示例，請考慮用於復製文件的不起眼的 ``cp``實用程式。在不"
"提供目的地和至少一個來源的情況下嘗試複製文件沒有多大意義。因此，"
"如果不帶參數運行 ``cp`` "
"就會失敗。然而，它有一個靈活、有用的語法，根本不需要任何選項："

#: ../../library/optparse.rst:209
#, fuzzy
msgid ""
"You can get pretty far with just that.  Most ``cp`` implementations provide "
"a bunch of options to tweak exactly how the files are copied: you can "
"preserve mode and modification time, avoid following symlinks, ask before "
"clobbering existing files, etc.  But none of this distracts from the core "
"mission of ``cp``, which is to copy either one file to another, or several "
"files to another directory."
msgstr ""
"你可以做到這一點。大多數 ``cp`` 實作提供了一堆選項來精確調整文件的複制方式："
"您可以保留模式和修改時間，避免跟隨符號鏈接，在破壞現有文件之前詢問等等。但是"
"這些都不會分散核心任務``cp`` "
"的意思是將一個文件複製到另一個文件，或者將多個文件複製到另一個目錄。"

#: ../../library/optparse.rst:220
#, fuzzy
msgid "What are positional arguments for?"
msgstr "什麼是位置參數？"

#: ../../library/optparse.rst:222
#, fuzzy
msgid ""
"Positional arguments are for those pieces of information that your program "
"absolutely, positively requires to run."
msgstr "位置參數用於您的程式絕對、肯定需要運行的那些資訊。"

#: ../../library/optparse.rst:225
#, fuzzy
msgid ""
"A good user interface should have as few absolute requirements as possible.  "
"If your program requires 17 distinct pieces of information in order to run "
"successfully, it doesn't much matter *how* you get that information from the "
"user---most people will give up and walk away before they successfully run "
"the program.  This applies whether the user interface is a command-line, a "
"configuration file, or a GUI: if you make that many demands on your users, "
"most of them will simply give up."
msgstr ""
"一個好的使用者界面應該有盡可能少的絕對要求。如果您的程式需要 17 條不同的資訊"
"才能成功運行，那麼*如何*從使用者那裡獲得這些資訊並不重要——大多數人會在成功運"
"行該程式之前放棄並走開。無論使用者界面是命令列、配置文件還是 "
"GUI，這都適用：如果您對使用者提出那麼多要求，他們中的大多數人都會簡單地放棄。"

#: ../../library/optparse.rst:233
#, fuzzy
msgid ""
"In short, try to minimize the amount of information that users are "
"absolutely required to supply---use sensible defaults whenever possible.  Of "
"course, you also want to make your programs reasonably flexible.  That's "
"what options are for.  Again, it doesn't matter if they are entries in a "
"config file, widgets in the \"Preferences\" dialog of a GUI, or command-line "
"options---the more options you implement, the more flexible your program is, "
"and the more complicated its implementation becomes.  Too much flexibility "
"has drawbacks as well, of course; too many options can overwhelm users and "
"make your code much harder to maintain."
msgstr ""
"簡而言之，盡量減少使用者絕對需要提供的資訊量——盡可能使用合理的預設值。當然，"
"您還希望使您的程式具有相當的靈活性。這就是選項的用途。同樣，無論它們是配置文"
"件中的條目、GUI 的“首選項”對話框中的小部件，還是命令列選項，都沒有關係——您實"
"作的選項越多，您的程式就越靈活，並且它的實施變得更加複雜。當然，太多的靈活性"
"也有缺點；太多的選項會使使用者不知所措，並使您的程式碼更難維護。"

#: ../../library/optparse.rst:246
#, fuzzy
msgid "Tutorial"
msgstr "教程"

#: ../../library/optparse.rst:248
#, fuzzy
msgid ""
"While :mod:`optparse` is quite flexible and powerful, it's also "
"straightforward to use in most cases.  This section covers the code patterns "
"that are common to any :mod:`optparse`\\ -based program."
msgstr ""
"雖然 :mod:`optparse` 非常靈活和強大，但在大多數情況下使用起來也很簡單。"
"本節涵蓋任何基於 :mod:`optparse`\\ 的程式通用的程式碼模式。"

#: ../../library/optparse.rst:252
#, fuzzy
msgid ""
"First, you need to import the OptionParser class; then, early in the main "
"program, create an OptionParser instance::"
msgstr "首先，您需要導入 OptionParser 類；然後，在主程式的早期，建立一個 "
"OptionParser 實例："

#: ../../library/optparse.rst:259
#, fuzzy
msgid "Then you can start defining options.  The basic syntax is::"
msgstr "然後您可以開始定義選項。基本語法是："

#: ../../library/optparse.rst:264
#, fuzzy
msgid ""
"Each option has one or more option strings, such as ``-f`` or ``--file``, "
"and several option attributes that tell :mod:`optparse` what to expect and "
"what to do when it encounters that option on the command line."
msgstr ""
"每個選項都有一個或多個選項字串，例如 ``-f`` 或 ``--file``，以及幾個選項屬性，"
"告訴 :mod:`optparse` 遇到該選項時期望什麼以及做什麼在命令列上。"

#: ../../library/optparse.rst:268
#, fuzzy
msgid ""
"Typically, each option will have one short option string and one long option "
"string, e.g.::"
msgstr "通常，每個選項都有一個短選項字串和一個長選項字串，例如："

#: ../../library/optparse.rst:273
#, fuzzy
msgid ""
"You're free to define as many short option strings and as many long option "
"strings as you like (including zero), as long as there is at least one "
"option string overall."
msgstr "您可以自由定義任意數量的短選項字串和任意數量的長選項字串（包括零），只要總體"
"上至少有一個選項字串即可。"

#: ../../library/optparse.rst:277
#, fuzzy
msgid ""
"The option strings passed to :meth:`OptionParser.add_option` are effectively "
"labels for the option defined by that call.  For brevity, we will frequently "
"refer to *encountering an option* on the command line; in reality, :mod:"
"`optparse` encounters *option strings* and looks up options from them."
msgstr ""
"傳遞給 OptionParser.add_option 的選項字串實際上是該呼叫定義的選項的標籤。為簡"
"潔起見，我們將經常提到在命令列上*遇到一個選項*；實際上，:mod:`optparse` 遇到 "
"*option strings* 並從中查找選項。"

#: ../../library/optparse.rst:283
#, fuzzy
msgid ""
"Once all of your options are defined, instruct :mod:`optparse` to parse your "
"program's command line::"
msgstr "定義所有選項後，指示 :mod:`optparse` 解析程式的命令列::"

#: ../../library/optparse.rst:288
#, fuzzy
msgid ""
"(If you like, you can pass a custom argument list to :meth:`parse_args`, but "
"that's rarely necessary: by default it uses ``sys.argv[1:]``.)"
msgstr ""
"（如果願意，您可以將自定義參數列表傳遞給 "
":meth:`parse_args`，但很少需要這樣做：預設情況下它使用 ``sys.argv[1:]``。）"

#: ../../library/optparse.rst:291
msgid ":meth:`parse_args` returns two values:"
msgstr ":meth:`parse_args` 回傳兩個值："

#: ../../library/optparse.rst:293
#, fuzzy
msgid ""
"``options``, an object containing values for all of your options---e.g. if "
"``--file`` takes a single string argument, then ``options.file`` will be the "
"filename supplied by the user, or ``None`` if the user did not supply that "
"option"
msgstr ""
"``options``，一個包含所有選項值的物件——例如如果 ``--file`` 採用單個字串參數，"
"則 ``options.file`` 將是使用者提供的文件名，如果使用者未提供該選項，則為 "
"``None``"

#: ../../library/optparse.rst:298
#, fuzzy
msgid ""
"``args``, the list of positional arguments leftover after parsing options"
msgstr "``args``，解析選項後剩餘的位置參數列表"

#: ../../library/optparse.rst:300
#, fuzzy
msgid ""
"This tutorial section only covers the four most important option "
"attributes: :attr:`~Option.action`, :attr:`~Option.type`, :attr:`~Option."
"dest` (destination), and :attr:`~Option.help`. Of these, :attr:`~Option."
"action` is the most fundamental."
msgstr ""
"本教程部分僅涵蓋四個最重要的選項屬性：:attr:`~Option.action`、:attr:`~Option."
"type`、:attr:`~Option.dest`（目的地）和 :attr:` ~Option."
"help`。其中，:attr:`~Option.action` 是最基本的。"

#: ../../library/optparse.rst:309
#, fuzzy
msgid "Understanding option actions"
msgstr "了解選項操作"

#: ../../library/optparse.rst:311
#, fuzzy
msgid ""
"Actions tell :mod:`optparse` what to do when it encounters an option on the "
"command line.  There is a fixed set of actions hard-coded into :mod:"
"`optparse`; adding new actions is an advanced topic covered in section :ref:"
"`optparse-extending-optparse`.  Most actions tell :mod:`optparse` to store a "
"value in some variable---for example, take a string from the command line "
"and store it in an attribute of ``options``."
msgstr ""
"動作告訴 :mod:`optparse` 當它在命令列上遇到一個選項時該怎麼做。"
"有一組固定的動作硬編碼到 :mod:`optparse` 中；新增新操作是 optparse-extending-"
"optparse 部分涵蓋的高階主題。大多數操作告訴 :mod:`optparse` "
"將值儲存在某個變數中——例如，從命令列獲取一個字串並將其儲存在 ``options`` "
"的屬性中。"

#: ../../library/optparse.rst:318
#, fuzzy
msgid ""
"If you don't specify an option action, :mod:`optparse` defaults to ``store``."
msgstr "如果您不指定選項操作，則 :mod:`optparse` 預設為 ``store``。"

#: ../../library/optparse.rst:324
#, fuzzy
msgid "The store action"
msgstr "商店行動"

#: ../../library/optparse.rst:326
#, fuzzy
msgid ""
"The most common option action is ``store``, which tells :mod:`optparse` to "
"take the next argument (or the remainder of the current argument), ensure "
"that it is of the correct type, and store it to your chosen destination."
msgstr ""
"最常見的選項操作是 ``store``，它告訴 :mod:`optparse` 獲取下一個參數（或當前參"
"數的剩餘部分），確保它是正確的型別，並將其儲存到您選擇的目的地。"

#: ../../library/optparse.rst:330
msgid "For example::"
msgstr ""
"舉例來說：\n"
"\n"
"::"

#: ../../library/optparse.rst:335
#, fuzzy
msgid ""
"Now let's make up a fake command line and ask :mod:`optparse` to parse it::"
msgstr "現在讓我們組成一個偽造的命令列並請求 :mod:`optparse` 來解析它::"

#: ../../library/optparse.rst:340
#, fuzzy
msgid ""
"When :mod:`optparse` sees the option string ``-f``, it consumes the next "
"argument, ``foo.txt``, and stores it in ``options.filename``.  So, after "
"this call to :meth:`parse_args`, ``options.filename`` is ``\"foo.txt\"``."
msgstr ""
"當 :mod:`optparse` 看到選項字串 ``-f`` 時，它會使用下一個參數 ``foo.txt``，"
"並將其儲存在 ``options.filename`` 中。因此，在呼叫 :meth:`parse_args` "
"之後，``options.filename`` 是 ``\"foo.txt\"``。"

#: ../../library/optparse.rst:344
#, fuzzy
msgid ""
"Some other option types supported by :mod:`optparse` are ``int`` and "
"``float``. Here's an option that expects an integer argument::"
msgstr ":mod:`optparse` 支援的其他一些選項型別是 ``int`` 和 "
"``float``。這是一個需要整數參數的選項："

#: ../../library/optparse.rst:349
#, fuzzy
msgid ""
"Note that this option has no long option string, which is perfectly "
"acceptable. Also, there's no explicit action, since the default is ``store``."
msgstr "請注意，此選項沒有長選項字串，這是完全可以接受的。此外，沒有明確的操作，因為"
"預設值為 ``store``。"

#: ../../library/optparse.rst:352
#, fuzzy
msgid ""
"Let's parse another fake command-line.  This time, we'll jam the option "
"argument right up against the option: since ``-n42`` (one argument) is "
"equivalent to ``-n 42`` (two arguments), the code ::"
msgstr "讓我們解析另一個偽造的命令列。這一次，我們將選項參數直接放在選項上：因為“-n42"
"”（一個參數）等同於“-n 42”（兩個參數），程式碼："

#: ../../library/optparse.rst:359
#, fuzzy
msgid "will print ``42``."
msgstr "將印出 ``42``。"

#: ../../library/optparse.rst:361
#, fuzzy
msgid ""
"If you don't specify a type, :mod:`optparse` assumes ``string``.  Combined "
"with the fact that the default action is ``store``, that means our first "
"example can be a lot shorter::"
msgstr ""
"如果您不指定型別，則 :mod:`optparse` 假定為 ``string``。結合預設操作是 "
"``store`` 的事實，這意味著我們的第一個示例可以更短::"

#: ../../library/optparse.rst:367
#, fuzzy
msgid ""
"If you don't supply a destination, :mod:`optparse` figures out a sensible "
"default from the option strings: if the first long option string is ``--foo-"
"bar``, then the default destination is ``foo_bar``.  If there are no long "
"option strings, :mod:`optparse` looks at the first short option string: the "
"default destination for ``-f`` is ``f``."
msgstr ""
"如果你不提供目的地，:mod:`optparse` "
"會從選項字串中計算出一個合理的預設值：如果第一個長選項字串是``--foo-"
"bar``，那麼預設目的地是``foo_bar ``。如果沒有長選項字串，optparse "
"會查看第一個短選項字串：``-f`` 的預設目的地是``f``。"

#: ../../library/optparse.rst:373
#, fuzzy
msgid ""
":mod:`optparse` also includes the built-in ``complex`` type.  Adding types "
"is covered in section :ref:`optparse-extending-optparse`."
msgstr ""
":mod:`optparse` 還包括內建的 ``complex`` 型別。新增型別在 :ref:`optparse-"
"extending-optparse` 部分介紹。"

#: ../../library/optparse.rst:380
#, fuzzy
msgid "Handling boolean (flag) options"
msgstr "處理布爾（旗標）選項"

#: ../../library/optparse.rst:382
#, fuzzy
msgid ""
"Flag options---set a variable to true or false when a particular option is "
"seen---are quite common.  :mod:`optparse` supports them with two separate "
"actions, ``store_true`` and ``store_false``.  For example, you might have a "
"``verbose`` flag that is turned on with ``-v`` and off with ``-q``::"
msgstr ""
"標記選項——當看到特定選項時將變數設定為 true 或 false——很常見。 "
":mod:`optparse` 通過兩個獨立的操作支援它們，``store_true`` 和 "
"``store_false``。例如，您可能有一個 ``verbose`` 旗標，它用 ``-v`` 打開並用 "
"``-q`` 關閉："

#: ../../library/optparse.rst:390
#, fuzzy
msgid ""
"Here we have two different options with the same destination, which is "
"perfectly OK.  (It just means you have to be a bit careful when setting "
"default values---see below.)"
msgstr "在這裡，我們有兩個不同的選項，但目的地相同，這完全沒問題。 "
"（這只是意味著您在設定預設值時必須小心一點——見下文。）"

#: ../../library/optparse.rst:394
#, fuzzy
msgid ""
"When :mod:`optparse` encounters ``-v`` on the command line, it sets "
"``options.verbose`` to ``True``; when it encounters ``-q``, ``options."
"verbose`` is set to ``False``."
msgstr ""
"當 :mod:`optparse` 在命令列遇到 ``-v`` 時，它將 ``options.verbose`` 設定為 "
"``True``；當它遇到 ``-q`` 時，``options.verbose`` 被設定為 ``False``。"

#: ../../library/optparse.rst:402
#, fuzzy
msgid "Other actions"
msgstr "其他行為"

#: ../../library/optparse.rst:404
#, fuzzy
msgid "Some other actions supported by :mod:`optparse` are:"
msgstr ":mod:`optparse` 支援的其他一些操作是："

#: ../../library/optparse.rst:407 ../../library/optparse.rst:928
msgid "``\"store_const\"``"
msgstr "``\"store_const\"``"

#: ../../library/optparse.rst:407 ../../library/optparse.rst:928
#, fuzzy
msgid "store a constant value, pre-set via :attr:`Option.const`"
msgstr "儲存一個常數值，通過 :attr:`Option.const` 預先設定"

#: ../../library/optparse.rst:410 ../../library/optparse.rst:937
msgid "``\"append\"``"
msgstr "``\"append\"``"

#: ../../library/optparse.rst:410 ../../library/optparse.rst:937
#, fuzzy
msgid "append this option's argument to a list"
msgstr "將此選項的參數附加到列表"

#: ../../library/optparse.rst:413 ../../library/optparse.rst:943
msgid "``\"count\"``"
msgstr "``\"count\"``"

#: ../../library/optparse.rst:413 ../../library/optparse.rst:943
#, fuzzy
msgid "increment a counter by one"
msgstr "將計數器加一"

#: ../../library/optparse.rst:416 ../../library/optparse.rst:946
msgid "``\"callback\"``"
msgstr "``\"callback\"``"

#: ../../library/optparse.rst:416 ../../library/optparse.rst:946
#, fuzzy
msgid "call a specified function"
msgstr "呼叫指定函式"

#: ../../library/optparse.rst:418
#, fuzzy
msgid ""
"These are covered in section :ref:`optparse-reference-guide`, and section :"
"ref:`optparse-option-callbacks`."
msgstr ""
"這些在 :ref:`optparse-reference-guide` 和 :ref:`optparse-option-callbacks "
"部分中有介紹。"

#: ../../library/optparse.rst:425
#, fuzzy
msgid "Default values"
msgstr "預設值"

#: ../../library/optparse.rst:427
#, fuzzy
msgid ""
"All of the above examples involve setting some variable (the "
"\"destination\") when certain command-line options are seen.  What happens "
"if those options are never seen?  Since we didn't supply any defaults, they "
"are all set to ``None``.  This is usually fine, but sometimes you want more "
"control.  :mod:`optparse` lets you supply a default value for each "
"destination, which is assigned before the command line is parsed."
msgstr ""
"當看到某些命令列選項時，上述所有示例都涉及設定一些變數（“目標”）。如果從未見"
"過這些選項會怎樣？由於我們沒有提供任何預設值，因此它們都設定為 ``None`` 。這通常很"
"好，但有時您需要更多控制。 :mod:`optparse` "
"允許您為每個目的地提供一個預設值，該預設值是在解析命令列之前分配的。"

#: ../../library/optparse.rst:434
#, fuzzy
msgid ""
"First, consider the verbose/quiet example.  If we want :mod:`optparse` to "
"set ``verbose`` to ``True`` unless ``-q`` is seen, then we can do this::"
msgstr ""
"首先，考慮冗長/安靜的例子。如果我們希望 :mod:`optparse` 將 ``verbose`` "
"設定為 ``True`` 除非看到 ``-q``，那麼我們可以這樣做::"

#: ../../library/optparse.rst:440
#, fuzzy
msgid ""
"Since default values apply to the *destination* rather than to any "
"particular option, and these two options happen to have the same "
"destination, this is exactly equivalent::"
msgstr "由於預設值適用於 *destination* "
"而不是任何特定選項，並且這兩個選項恰好具有相同的目的地，因此這完全等價："

#: ../../library/optparse.rst:447
#, fuzzy
msgid "Consider this::"
msgstr "考慮這個::"

#: ../../library/optparse.rst:452
#, fuzzy
msgid ""
"Again, the default value for ``verbose`` will be ``True``: the last default "
"value supplied for any particular destination is the one that counts."
msgstr "同樣，“詳細”的預設值將是 ``True``：為任何特定目的地提供的最後一個預設值是重要的。"

#: ../../library/optparse.rst:455
#, fuzzy
msgid ""
"A clearer way to specify default values is the :meth:`set_defaults` method "
"of OptionParser, which you can call at any time before calling :meth:"
"`parse_args`::"
msgstr ""
"一種更清晰的指定預設值的方法是 OptionParser 的 set_defaults 方法，"
"您可以在呼叫 parse_args 之前隨時呼叫該方法 :meth:`parse_args`::"

#: ../../library/optparse.rst:462
#, fuzzy
msgid ""
"As before, the last value specified for a given option destination is the "
"one that counts.  For clarity, try to use one method or the other of setting "
"default values, not both."
msgstr "和以前一樣，為給定選項目標指定的最後一個值才是最重要的。為清楚起見，請嘗試使"
"用一種或另一種方法來設定預設值，而不是同時使用兩種方法。"

#: ../../library/optparse.rst:470
#, fuzzy
msgid "Generating help"
msgstr "生成幫助"

#: ../../library/optparse.rst:472
#, fuzzy
msgid ""
":mod:`optparse`'s ability to generate help and usage text automatically is "
"useful for creating user-friendly command-line interfaces.  All you have to "
"do is supply a :attr:`~Option.help` value for each option, and optionally a "
"short usage message for your whole program.  Here's an OptionParser "
"populated with user-friendly (documented) options::"
msgstr ""
":mod:`optparse` "
"自動生成幫助和用法文本的能力對於建立使用者友好的命令列界面很有用。"
"您所要做的就是為每個選項提供一個 :attr:`~Option.help` "
"值，並為您的整個程式提供一個簡短的使用資訊。這是一個 OptionParser "
"填充了使用者友好的（記錄的）選項::"

#: ../../library/optparse.rst:493
#, fuzzy
msgid ""
"If :mod:`optparse` encounters either ``-h`` or ``--help`` on the command-"
"line, or if you just call :meth:`parser.print_help`, it prints the following "
"to standard output:"
msgstr ""
"如果 :mod:`optparse` 在命令列遇到 ``-h`` 或 ``--help``，或者如果您只是呼叫 "
":meth:`parser.print_help`，它會將以下內容印出到標準輸出:"

#: ../../library/optparse.rst:510
#, fuzzy
msgid ""
"(If the help output is triggered by a help option, :mod:`optparse` exits "
"after printing the help text.)"
msgstr "（如果幫助輸出是由幫助選項觸發的，則 :mod:`optparse` 在印出幫助文本後退出。）"

#: ../../library/optparse.rst:513
#, fuzzy
msgid ""
"There's a lot going on here to help :mod:`optparse` generate the best "
"possible help message:"
msgstr "這裡有很多事情可以幫助 :mod:`optparse` 生成最好的幫助消息："

#: ../../library/optparse.rst:516
#, fuzzy
msgid "the script defines its own usage message::"
msgstr "該腳本定義了自己的用法消息::"

#: ../../library/optparse.rst:520
#, fuzzy
msgid ""
":mod:`optparse` expands ``%prog`` in the usage string to the name of the "
"current program, i.e. ``os.path.basename(sys.argv[0])``.  The expanded "
"string is then printed before the detailed option help."
msgstr ""
":mod:`optparse` 將用法字串中的 ``%prog`` 擴充為當前程式的名稱，即 ``os.path."
"basename(sys.argv[0])``。然後在詳細選項幫助之前印出擴充字串。"

#: ../../library/optparse.rst:524
#, fuzzy
msgid ""
"If you don't supply a usage string, :mod:`optparse` uses a bland but "
"sensible default: ``\"Usage: %prog [options]\"``, which is fine if your "
"script doesn't take any positional arguments."
msgstr ""
"如果您不提供用法字串，:mod:`optparse` 使用平淡但合理的預設值：``\"Usage: "
"%prog [options]\"``，如果您的腳本不採用任何位置參數，這很好."

#: ../../library/optparse.rst:528
#, fuzzy
msgid ""
"every option defines a help string, and doesn't worry about line-wrapping---"
"\\ :mod:`optparse` takes care of wrapping lines and making the help output "
"look good."
msgstr "每個選項都定義了一個幫助字串，不用擔心換行---\\ :mod:`optparse` "
"負責換行並使幫助輸出看起來不錯。"

#: ../../library/optparse.rst:532
#, fuzzy
msgid ""
"options that take a value indicate this fact in their automatically "
"generated help message, e.g. for the \"mode\" option::"
msgstr "帶值的選項在其自動生成的幫助消息中表明了這一事實，例如對於“模式”選項::"

#: ../../library/optparse.rst:537
#, fuzzy
msgid ""
"Here, \"MODE\" is called the meta-variable: it stands for the argument that "
"the user is expected to supply to ``-m``/``--mode``.  By default, :mod:"
"`optparse` converts the destination variable name to uppercase and uses that "
"for the meta-variable.  Sometimes, that's not what you want---for example, "
"the ``--filename`` option explicitly sets ``metavar=\"FILE\"``, resulting in "
"this automatically generated option description::"
msgstr ""
"這裡， ``MODE``被稱為元變數：它代表使用者期望提供給``-m``/``--mode`` "
"的參數。預設情況下，:mod:`optparse` 將目標變數名稱轉換為大寫並將其用於元變數"
"。有時，這不是您想要的——例如，``--filename`` 選項顯式設定 ``metavar=\"FILE\""
"``，導致這個自動生成的選項描述::"

#: ../../library/optparse.rst:546
#, fuzzy
msgid ""
"This is important for more than just saving space, though: the manually "
"written help text uses the meta-variable ``FILE`` to clue the user in that "
"there's a connection between the semi-formal syntax ``-f FILE`` and the "
"informal semantic description \"write output to FILE\". This is a simple but "
"effective way to make your help text a lot clearer and more useful for end "
"users."
msgstr ""
"不過，這不僅僅是為了節省空間很重要：手動編寫的幫助文本使用元變數 ``FILE`` "
"來提示使用者半正式語法``-f FILE`` 和非正式語義描述“將輸出寫入文件”。這是一種"
"簡單但有效的方法，可以使您的幫助文本更清晰，對最終使用者更有用。"

#: ../../library/optparse.rst:552
#, fuzzy
msgid ""
"options that have a default value can include ``%default`` in the help "
"string---\\ :mod:`optparse` will replace it with :func:`str` of the option's "
"default value.  If an option has no default value (or the default value is "
"``None``), ``%default`` expands to ``none``."
msgstr ""
"具有預設值的選項可以在幫助字串中包含 ``%default`` ---\\ :mod:`optparse` "
"將用選項預設值的 :func:`str` "
"替換它。如果選項沒有預設值（或預設值為 ``None``），“%default”擴充為 ``none``。"

#: ../../library/optparse.rst:558
#, fuzzy
msgid "Grouping Options"
msgstr "分組選項"

#: ../../library/optparse.rst:560
#, fuzzy
msgid ""
"When dealing with many options, it is convenient to group these options for "
"better help output.  An :class:`OptionParser` can contain several option "
"groups, each of which can contain several options."
msgstr ""
"在處理很多選項時，可以方便地將這些選項分組，以便更好地幫助輸出。 "
":class:`OptionParser` 可以包含多個選項組，每個選項組可以包含多個選項。"

#: ../../library/optparse.rst:564
#, fuzzy
msgid "An option group is obtained using the class :class:`OptionGroup`:"
msgstr "使用類 OptionGroup 獲得一個選項組："

#: ../../library/optparse.rst:568 ../../library/optparse.rst:1637
#, fuzzy
msgid "where"
msgstr "在哪裡"

#: ../../library/optparse.rst:570
#, fuzzy
msgid ""
"parser is the :class:`OptionParser` instance the group will be inserted in to"
msgstr "parser 是組將被插入到的 OptionParser 實例"

#: ../../library/optparse.rst:572
#, fuzzy
msgid "title is the group title"
msgstr "title 是組標題"

#: ../../library/optparse.rst:573
#, fuzzy
msgid "description, optional, is a long description of the group"
msgstr "description，可選，是對組的詳細描述"

#: ../../library/optparse.rst:575
#, fuzzy
msgid ""
":class:`OptionGroup` inherits from :class:`OptionContainer` (like :class:"
"`OptionParser`) and so the :meth:`add_option` method can be used to add an "
"option to the group."
msgstr ""
":class:`OptionGroup` 繼承自 :class:`OptionContainer`（如 "
":class:`OptionParser`），因此 :meth:`add_option` 方法可用於向組中新增選項。"

#: ../../library/optparse.rst:579
#, fuzzy
msgid ""
"Once all the options are declared, using the :class:`OptionParser` method :"
"meth:`add_option_group` the group is added to the previously defined parser."
msgstr "聲明所有選項後，使用 OptionParser 方法 add_option_group "
"將組新增到先前定義的解析器中。"

#: ../../library/optparse.rst:582
#, fuzzy
msgid ""
"Continuing with the parser defined in the previous section, adding an :class:"
"`OptionGroup` to a parser is easy::"
msgstr "繼續上一節中定義的解析器，將 :class:`OptionGroup` 新增到解析器很容易::"

#: ../../library/optparse.rst:591
#, fuzzy
msgid "This would result in the following help output:"
msgstr "這將導致以下幫助輸出："

#: ../../library/optparse.rst:612
#, fuzzy
msgid ""
"A bit more complete example might involve using more than one group: still "
"extending the previous example::"
msgstr "一個更完整的例子可能涉及使用多個組：仍然擴充前面的例子："

#: ../../library/optparse.rst:629
#, fuzzy
msgid "that results in the following output:"
msgstr "結果如下："

#: ../../library/optparse.rst:655
#, fuzzy
msgid ""
"Another interesting method, in particular when working programmatically with "
"option groups is:"
msgstr "另一個有趣的方法，特別是在以編程方式使用選項組時是："

#: ../../library/optparse.rst:660
#, fuzzy
msgid ""
"Return the :class:`OptionGroup` to which the short or long option string "
"*opt_str* (e.g. ``'-o'`` or ``'--option'``) belongs. If there's no such :"
"class:`OptionGroup`, return ``None``."
msgstr ""
"回傳短或長選項字串 *opt_str*（例如 ``'-o'`` 或 ``'--option'``）所屬的 :class:"
"`OptionGroup`。如果沒有這樣的 :class:`OptionGroup`，回傳``None``。"

#: ../../library/optparse.rst:667
#, fuzzy
msgid "Printing a version string"
msgstr "印出版本字串"

#: ../../library/optparse.rst:669
#, fuzzy
msgid ""
"Similar to the brief usage string, :mod:`optparse` can also print a version "
"string for your program.  You have to supply the string as the ``version`` "
"argument to OptionParser::"
msgstr ""
"類似於簡要用法字串，:mod:`optparse` 也可以為您的程式印出版本字串。"
"您必須提供字串作為 OptionParser:: 的 ``version`` 參數："

#: ../../library/optparse.rst:675
#, fuzzy
msgid ""
"``%prog`` is expanded just like it is in ``usage``.  Apart from that, "
"``version`` can contain anything you like.  When you supply it, :mod:"
"`optparse` automatically adds a ``--version`` option to your parser. If it "
"encounters this option on the command line, it expands your ``version`` "
"string (by replacing ``%prog``), prints it to stdout, and exits."
msgstr ""
"``%prog`` 就像在 ``usage`` 中一樣展開。除此之外，``version`` "
"可以包含任何你喜歡的東西。當您提供它時，:mod:`optparse` "
"會自動向您的解析器新增一個 ``--version`` 選項。如果它在命令列上遇到這個選項，"
"它會擴充你的 ``version`` 字串（通過替換 "
"``%prog``），將它印出到標準輸出，然後退出。"

#: ../../library/optparse.rst:681
#, fuzzy
msgid "For example, if your script is called ``/usr/bin/foo``:"
msgstr "例如，如果您的腳本名為“/usr/bin/foo”："

#: ../../library/optparse.rst:688
#, fuzzy
msgid ""
"The following two methods can be used to print and get the ``version`` "
"string:"
msgstr "以下兩種方法可用於印出和獲取 ``version`` 字串："

#: ../../library/optparse.rst:692
#, fuzzy
msgid ""
"Print the version message for the current program (``self.version``) to "
"*file* (default stdout).  As with :meth:`print_usage`, any occurrence of "
"``%prog`` in ``self.version`` is replaced with the name of the current "
"program.  Does nothing if ``self.version`` is empty or undefined."
msgstr ""
"將當前程式的版本消息 (``self.version``) 印出到 "
"*file*（預設標準輸出）。與 :meth:`print_usage` 一樣，``self.version`` "
"中任何出現的 ``%prog`` 都被替換為當前程式的名稱。如果 ``self.version`` "
"為空或未定義，則不執行任何操作。"

#: ../../library/optparse.rst:699
#, fuzzy
msgid ""
"Same as :meth:`print_version` but returns the version string instead of "
"printing it."
msgstr "與 :meth:`print_version` 相同，但回傳版本字串而不是印出它。"

#: ../../library/optparse.rst:706
#, fuzzy
msgid "How :mod:`optparse` handles errors"
msgstr ":mod:`optparse` 如何處理錯誤"

#: ../../library/optparse.rst:708
#, fuzzy
msgid ""
"There are two broad classes of errors that :mod:`optparse` has to worry "
"about: programmer errors and user errors.  Programmer errors are usually "
"erroneous calls to :func:`OptionParser.add_option`, e.g. invalid option "
"strings, unknown option attributes, missing option attributes, etc.  These "
"are dealt with in the usual way: raise an exception (either :exc:`optparse."
"OptionError` or :exc:`TypeError`) and let the program crash."
msgstr ""
":mod:`optparse` 必須擔心兩大類錯誤：程式員錯誤和使用者錯誤。"
"程式員的錯誤通常是對 :func:`OptionParser.add_option` 的錯誤呼叫，例如無效的選"
"項字串、未知的選項屬性、缺失的選項屬性等。這些以通常的方式處理：引發例外（:ex"
"c:`optparse.OptionError` 或 :exc:`TypeError`）並讓程式崩潰。"

#: ../../library/optparse.rst:715
#, fuzzy
msgid ""
"Handling user errors is much more important, since they are guaranteed to "
"happen no matter how stable your code is.  :mod:`optparse` can automatically "
"detect some user errors, such as bad option arguments (passing ``-n 4x`` "
"where ``-n`` takes an integer argument), missing arguments (``-n`` at the "
"end of the command line, where ``-n`` takes an argument of any type).  Also, "
"you can call :func:`OptionParser.error` to signal an application-defined "
"error condition::"
msgstr ""
"處理使用者錯誤更為重要，因為無論您的程式碼多麼穩定，它們都一定會發生。 "
":mod:`optparse` 可以自動檢測一些使用者錯誤，例如錯誤的選項參數（傳遞 ``-n "
"4x``，其中 ``-n`` 採用整數參數），缺少參數（``-n`` 在命令列的末尾，其中 "
"``-n`` 接受任何型別的參數）。此外，您可以呼叫 :func:`OptionParser.error` "
"來指示應用程式定義的錯誤條件::"

#: ../../library/optparse.rst:728
#, fuzzy
msgid ""
"In either case, :mod:`optparse` handles the error the same way: it prints "
"the program's usage message and an error message to standard error and exits "
"with error status 2."
msgstr "在任何一種情況下，optparse 都以相同的方式處理錯誤："
"它將程式的使用消息和錯誤消息印出到標準錯誤並以錯誤狀態 2 退出。"

#: ../../library/optparse.rst:732
#, fuzzy
msgid ""
"Consider the first example above, where the user passes ``4x`` to an option "
"that takes an integer:"
msgstr "考慮上面的第一個例子，使用者將 ``4x`` 傳遞給一個接受整數的選項："

#: ../../library/optparse.rst:742
#, fuzzy
msgid "Or, where the user fails to pass a value at all:"
msgstr "或者，使用者根本無法傳遞值："

#: ../../library/optparse.rst:751
#, fuzzy
msgid ""
":mod:`optparse`\\ -generated error messages take care always to mention the "
"option involved in the error; be sure to do the same when calling :func:"
"`OptionParser.error` from your application code."
msgstr ""
":mod:`optparse`\\ - 生成的錯誤消息總是注意提及錯誤中涉及的選項；"
"從您的應用程式程式碼呼叫 :func:`OptionParser.error` 時一定要執行相同的操作。"

#: ../../library/optparse.rst:755
#, fuzzy
msgid ""
"If :mod:`optparse`'s default error-handling behaviour does not suit your "
"needs, you'll need to subclass OptionParser and override its :meth:"
"`~OptionParser.exit` and/or :meth:`~OptionParser.error` methods."
msgstr ""
"如果 :mod:`optparse` 的預設錯誤處理行為不適合您的需要，您需要子類別化 "
"OptionParser 並覆蓋它的 :meth:`~OptionParser.exit` 和/或 :meth:`~"
"OptionParser.error ` 方法。"

#: ../../library/optparse.rst:763
#, fuzzy
msgid "Putting it all together"
msgstr "把它們放在一起"

#: ../../library/optparse.rst:765
#, fuzzy
msgid "Here's what :mod:`optparse`\\ -based scripts usually look like::"
msgstr "以下是基於 :mod:`optparse`\\ 的腳本通常看起來像："

#: ../../library/optparse.rst:793
#, fuzzy
msgid "Reference Guide"
msgstr "參考指南"

#: ../../library/optparse.rst:799
#, fuzzy
msgid "Creating the parser"
msgstr "建立解析器"

#: ../../library/optparse.rst:801
#, fuzzy
msgid ""
"The first step in using :mod:`optparse` is to create an OptionParser "
"instance."
msgstr "使用 :mod:`optparse` 的第一步是建立一個 OptionParser 實例。"

#: ../../library/optparse.rst:805
#, fuzzy
msgid ""
"The OptionParser constructor has no required arguments, but a number of "
"optional keyword arguments.  You should always pass them as keyword "
"arguments, i.e. do not rely on the order in which the arguments are declared."
msgstr "OptionParser 構造函式沒有必需的參數，但有一些可選的關鍵字參數。您應該始終將它"
"們作為關鍵字參數傳遞，即不要依賴聲明參數的順序。"

#: ../../library/optparse.rst:814
#, fuzzy
msgid "``usage`` (default: ``\"%prog [options]\"``)"
msgstr "``usage``（預設：``\"%prog [options]\"``）"

#: ../../library/optparse.rst:810
#, fuzzy
msgid ""
"The usage summary to print when your program is run incorrectly or with a "
"help option.  When :mod:`optparse` prints the usage string, it expands "
"``%prog`` to ``os.path.basename(sys.argv[0])`` (or to ``prog`` if you passed "
"that keyword argument).  To suppress a usage message, pass the special "
"value :data:`optparse.SUPPRESS_USAGE`."
msgstr ""
"當您的程式運行不正確或有幫助選項時要印出的使用摘要。當 :mod:`optparse` "
"印出用法字串時，它將 ``%prog`` 擴充為 ``os.path.basename(sys.argv[0])``（"
"或者擴充為 ``prog`` "
"如果你傳遞了關鍵字參數）。要抑制使用消息，請傳遞特殊值 :data:`optparse."
"SUPPRESS_USAGE`。"

#: ../../library/optparse.rst:821
#, fuzzy
msgid "``option_list`` (default: ``[]``)"
msgstr "``option_list``（預設值：``[]``）"

#: ../../library/optparse.rst:817
#, fuzzy
msgid ""
"A list of Option objects to populate the parser with.  The options in "
"``option_list`` are added after any options in ``standard_option_list`` (a "
"class attribute that may be set by OptionParser subclasses), but before any "
"version or help options. Deprecated; use :meth:`add_option` after creating "
"the parser instead."
msgstr ""
"用於填充解析器的選項物件列表。 ``option_list`` "
"中的選項新增在``standard_option_list``（一個類屬性，可以由 OptionParser "
"子類別設定）中的任何選項之後，但在任何版本或幫助選項之前。棄用；"
"在建立解析器之後使用 :meth:`add_option` 代替。"

#: ../../library/optparse.rst:824
#, fuzzy
msgid "``option_class`` (default: optparse.Option)"
msgstr "``option_class``（預設：optparse.Option）"

#: ../../library/optparse.rst:824
#, fuzzy
msgid "Class to use when adding options to the parser in :meth:`add_option`."
msgstr "在 add_option 中向解析器新增選項時使用的類。"

#: ../../library/optparse.rst:830
#, fuzzy
msgid "``version`` (default: ``None``)"
msgstr "``version``（預設：``None``）"

#: ../../library/optparse.rst:827
#, fuzzy
msgid ""
"A version string to print when the user supplies a version option. If you "
"supply a true value for ``version``, :mod:`optparse` automatically adds a "
"version option with the single option string ``--version``.  The substring "
"``%prog`` is expanded the same as for ``usage``."
msgstr ""
"當使用者提供版本選項時要印出的版本字串。如果您為 ``version`` "
"提供真值，optparse` 會自動新增一個帶有單個選項字串 ``--version`` 的版本選項。"
"子串 ``%prog`` 的擴充與 ``usage`` 相同。"

#: ../../library/optparse.rst:835
#, fuzzy
msgid "``conflict_handler`` (default: ``\"error\"``)"
msgstr "``衝突處理程式``（預設：``“錯誤”``）"

#: ../../library/optparse.rst:833
#, fuzzy
msgid ""
"Specifies what to do when options with conflicting option strings are added "
"to the parser; see section :ref:`optparse-conflicts-between-options`."
msgstr ""
"指定將具有衝突選項字串的選項新增到解析器時要執行的操作；請參閱部分：ref"
"：`optparse-conflicts-between-options`。"

#: ../../library/optparse.rst:841
#, fuzzy
msgid "``description`` (default: ``None``)"
msgstr "``描述``（預設：``無``）"

#: ../../library/optparse.rst:838
#, fuzzy
msgid ""
"A paragraph of text giving a brief overview of your program. :mod:`optparse` "
"reformats this paragraph to fit the current terminal width and prints it "
"when the user requests help (after ``usage``, but before the list of "
"options)."
msgstr ""
"一段文字簡要概述了您的程式。 :mod:`optparse` "
"重新格式化此段以適應當前終端寬度，並在使用者請求幫助時印出它（在 ``usage`` "
"之後，但在選項列表之前）。"

#: ../../library/optparse.rst:846
#, fuzzy
msgid "``formatter`` (default: a new :class:`IndentedHelpFormatter`)"
msgstr "``formatter``（預設：一個新的 IndentedHelpFormatter）"

#: ../../library/optparse.rst:844
#, fuzzy
msgid ""
"An instance of optparse.HelpFormatter that will be used for printing help "
"text.  :mod:`optparse` provides two concrete classes for this purpose: "
"IndentedHelpFormatter and TitledHelpFormatter."
msgstr ""
"將用於印出幫助文本的 optparse.HelpFormatter 實例。 :mod:`optparse` "
"為此提供了兩個具體類：IndentedHelpFormatter 和 TitledHelpFormatter。"

#: ../../library/optparse.rst:850
#, fuzzy
msgid "``add_help_option`` (default: ``True``)"
msgstr "``add_help_option``（預設值：``True``）"

#: ../../library/optparse.rst:849
#, fuzzy
msgid ""
"If true, :mod:`optparse` will add a help option (with option strings ``-h`` "
"and ``--help``) to the parser."
msgstr "如果為真，:mod:`optparse` 將向解析器新增一個幫助選項（帶有選項字串 ``-h`` 和 "
"``--help``）。"

#: ../../library/optparse.rst:854
msgid "``prog``"
msgstr "``prog``"

#: ../../library/optparse.rst:853
#, fuzzy
msgid ""
"The string to use when expanding ``%prog`` in ``usage`` and ``version`` "
"instead of ``os.path.basename(sys.argv[0])``."
msgstr ""
"在 ``usage`` 和 ``version`` 中擴充 ``%prog`` 而不是 ``os.path.basename(sys."
"argv[0])`` 時使用的字串。"

#: ../../library/optparse.rst:856
#, fuzzy
msgid "``epilog`` (default: ``None``)"
msgstr "``epilog``（預設值：``None``）"

#: ../../library/optparse.rst:857
#, fuzzy
msgid "A paragraph of help text to print after the option help."
msgstr "在選項幫助之後印出一段幫助文本。"

#: ../../library/optparse.rst:862
#, fuzzy
msgid "Populating the parser"
msgstr "填充解析器"

#: ../../library/optparse.rst:864
#, fuzzy
msgid ""
"There are several ways to populate the parser with options.  The preferred "
"way is by using :meth:`OptionParser.add_option`, as shown in section :ref:"
"`optparse-tutorial`.  :meth:`add_option` can be called in one of two ways:"
msgstr ""
"有幾種方法可以用選項填充解析器。首選方法是使用 OptionParser.add_option，如 "
"optparse-tutorial 部分所示。 :meth:`add_option` "
"可以通過以下兩種方式之一呼叫："

#: ../../library/optparse.rst:868
#, fuzzy
msgid "pass it an Option instance (as returned by :func:`make_option`)"
msgstr "傳遞給它一個 Option 實例（由 :func:`make_option` 回傳）"

#: ../../library/optparse.rst:870
#, fuzzy
msgid ""
"pass it any combination of positional and keyword arguments that are "
"acceptable to :func:`make_option` (i.e., to the Option constructor), and it "
"will create the Option instance for you"
msgstr ""
"將 :func:`make_option` 可接受的位置參數和關鍵字參數的任意組合傳遞給它（即，"
"傳遞給 Option 構造函式），它將為您建立 Option 實例"

#: ../../library/optparse.rst:874
#, fuzzy
msgid ""
"The other alternative is to pass a list of pre-constructed Option instances "
"to the OptionParser constructor, as in::"
msgstr "另一種選擇是將預先構造的 Option 實例列表傳遞給 OptionParser 構造函式，如："

#: ../../library/optparse.rst:885
#, fuzzy
msgid ""
"(:func:`make_option` is a factory function for creating Option instances; "
"currently it is an alias for the Option constructor.  A future version of :"
"mod:`optparse` may split Option into several classes, and :func:"
"`make_option` will pick the right class to instantiate.  Do not instantiate "
"Option directly.)"
msgstr ""
"（:func:`make_option` 是一個用於建立 Option 實例的工廠函式；目前它是 Option "
"構造函式的別名。:mod:`optparse` 的未來版本可能會將 Option "
"拆分為幾個類，並且 :func:`make_option`將選擇正確的類來實例化。不要直接實例化 "
"Option。）"

#: ../../library/optparse.rst:894
#, fuzzy
msgid "Defining options"
msgstr "定義選項"

#: ../../library/optparse.rst:896
#, fuzzy
msgid ""
"Each Option instance represents a set of synonymous command-line option "
"strings, e.g. ``-f`` and ``--file``.  You can specify any number of short or "
"long option strings, but you must specify at least one overall option string."
msgstr ""
"每個 Option 實例代表一組同義的命令列選項字串，例如``-f`` 和 ``--file``。您可"
"以指定任意數量的短選項字串或長選項字串，但您必須至少指定一個整體選項字串。"

#: ../../library/optparse.rst:900
#, fuzzy
msgid ""
"The canonical way to create an :class:`Option` instance is with the :meth:"
"`add_option` method of :class:`OptionParser`."
msgstr "建立 Option 實例的規範方法是使用 OptionParser 的 add_option 方法。"

#: ../../library/optparse.rst:906
#, fuzzy
msgid "To define an option with only a short option string::"
msgstr "定義一個只有短選項字串的選項："

#: ../../library/optparse.rst:910
#, fuzzy
msgid "And to define an option with only a long option string::"
msgstr "並定義一個只有長選項字串的選項："

#: ../../library/optparse.rst:914
#, fuzzy
msgid ""
"The keyword arguments define attributes of the new Option object.  The most "
"important option attribute is :attr:`~Option.action`, and it largely "
"determines which other attributes are relevant or required.  If you pass "
"irrelevant option attributes, or fail to pass required ones, :mod:`optparse` "
"raises an :exc:`OptionError` exception explaining your mistake."
msgstr ""
"關鍵字參數定義新選項物件的屬性。最重要的選項屬性是 :attr:`~Option.action`，它"
"在很大程度上決定了哪些其他屬性是相關的或必需的。如果你傳遞了不相關的選項屬性"
"，或者沒有傳遞必需的屬性，optparse 會引發一個 OptionError "
"例外來解釋你的錯誤。"

#: ../../library/optparse.rst:920
#, fuzzy
msgid ""
"An option's *action* determines what :mod:`optparse` does when it encounters "
"this option on the command-line.  The standard option actions hard-coded "
"into :mod:`optparse` are:"
msgstr ""
"選項的 *action* 決定 :mod:`optparse` 在命令列上遇到此選項時執行的操作。"
"硬編碼到 :mod:`optparse` 中的標準選項操作是："

#: ../../library/optparse.rst:925
msgid "``\"store\"``"
msgstr "``\"store\"``"

#: ../../library/optparse.rst:925
#, fuzzy
msgid "store this option's argument (default)"
msgstr "儲存此選項的參數（預設）"

#: ../../library/optparse.rst:931
msgid "``\"store_true\"``"
msgstr "``\"store_true\"``"

#: ../../library/optparse.rst:931
#, fuzzy
msgid "store ``True``"
msgstr "儲存``真實``"

#: ../../library/optparse.rst:934
msgid "``\"store_false\"``"
msgstr "``\"store_false\"``"

#: ../../library/optparse.rst:934
#, fuzzy
msgid "store ``False``"
msgstr "儲存``假``"

#: ../../library/optparse.rst:940
msgid "``\"append_const\"``"
msgstr "``\"append_const\"``"

#: ../../library/optparse.rst:940
#, fuzzy
msgid "append a constant value to a list, pre-set via :attr:`Option.const`"
msgstr "將常數值附加到列表，通過 :attr:`Option.const` 預先設定"

#: ../../library/optparse.rst:949 ../../library/optparse.rst:1243
msgid "``\"help\"``"
msgstr "``\"help\"``"

#: ../../library/optparse.rst:949
#, fuzzy
msgid ""
"print a usage message including all options and the documentation for them"
msgstr "印出一條使用消息，包括所有選項和它們的文檔"

#: ../../library/optparse.rst:951
#, fuzzy
msgid ""
"(If you don't supply an action, the default is ``\"store\"``.  For this "
"action, you may also supply :attr:`~Option.type` and :attr:`~Option.dest` "
"option attributes; see :ref:`optparse-standard-option-actions`.)"
msgstr ""
"（如果你不提供一個動作，預設是 ``\"store\"``。對於這個動作，你也可以提供 "
":attr:`~Option.type` 和 :attr:`~Option.dest` 選項屬性; 參見 :ref:`optparse-"
"standard-option-actions`。）"

#: ../../library/optparse.rst:955
#, fuzzy
msgid ""
"As you can see, most actions involve storing or updating a value somewhere. :"
"mod:`optparse` always creates a special object for this, conventionally "
"called ``options``, which is an instance of :class:`optparse.Values`."
msgstr ""
"如您所見，大多數操作都涉及在某處儲存或更新值。 :mod:`optparse` "
"總是為此建立一個特殊物件，通常稱為 ``options``，它是 :class:`optparse.Values`"
" 的一個實例。"

#: ../../library/optparse.rst:961
#, fuzzy
msgid ""
"An object holding parsed argument names and values as attributes. Normally "
"created by calling when calling :meth:`OptionParser.parse_args`, and can be "
"overridden by a custom subclass passed to the *values* argument of :meth:"
"`OptionParser.parse_args` (as described in :ref:`optparse-parsing-"
"arguments`)."
msgstr ""
"將已解析的參數名稱和值作為屬性保存的物件。通常在呼叫 OptionParser.parse_args "
"時呼叫建立，並且可以被傳遞給 OptionParser.parse_args 的 *values* "
"參數的自定義子類別覆蓋（如 optparse-parsing 中所述） -參數`）。"

#: ../../library/optparse.rst:966
#, fuzzy
msgid ""
"Option arguments (and various other values) are stored as attributes of this "
"object, according to the :attr:`~Option.dest` (destination) option attribute."
msgstr "根據 :attr:`~Option."
"dest`（目標）選項屬性，選項參數（和各種其他值）儲存為該物件的屬性。"

#: ../../library/optparse.rst:970
msgid "For example, when you call ::"
msgstr ""
"例如說，當你呼叫：\n"
"\n"
"::"

#: ../../library/optparse.rst:974
#, fuzzy
msgid ""
"one of the first things :mod:`optparse` does is create the ``options`` "
"object::"
msgstr ":mod:`optparse` 做的第一件事就是建立 ``options`` 物件::"

#: ../../library/optparse.rst:978
#, fuzzy
msgid "If one of the options in this parser is defined with ::"
msgstr "如果此解析器中的選項之一是用 :: 定義的"

#: ../../library/optparse.rst:982
#, fuzzy
msgid "and the command-line being parsed includes any of the following::"
msgstr "並且正在解析的命令列包括以下任何一項："

#: ../../library/optparse.rst:989
#, fuzzy
msgid ""
"then :mod:`optparse`, on seeing this option, will do the equivalent of ::"
msgstr "然後 :mod:`optparse`，在看到這個選項時，將做相當於 ::"

#: ../../library/optparse.rst:993
#, fuzzy
msgid ""
"The :attr:`~Option.type` and :attr:`~Option.dest` option attributes are "
"almost as important as :attr:`~Option.action`, but :attr:`~Option.action` is "
"the only one that makes sense for *all* options."
msgstr ""
":attr:`~Option.type` 和 :attr:`~Option.dest` 選項屬性幾乎與 :attr:`~Option."
"action` 一樣重要，但是 :attr:`~Option.action` "
"是唯一的對*所有*選項有意義的一個。"

#: ../../library/optparse.rst:1001
#, fuzzy
msgid "Option attributes"
msgstr "選項屬性"

#: ../../library/optparse.rst:1005
#, fuzzy
msgid ""
"A single command line argument, with various attributes passed by keyword to "
"the constructor. Normally created with :meth:`OptionParser.add_option` "
"rather than directly, and can be overridden by a custom class via the "
"*option_class* argument to :class:`OptionParser`."
msgstr ""
"單個命令列參數，具有通過關鍵字傳遞給構造函式的各種屬性。通常使用 "
":meth:`OptionParser.add_option` 建立，而不是直接建立，"
"並且可以通過自定義類通過 *option_class* 參數覆蓋 :class:`OptionParser`。"

#: ../../library/optparse.rst:1011
#, fuzzy
msgid ""
"The following option attributes may be passed as keyword arguments to :meth:"
"`OptionParser.add_option`.  If you pass an option attribute that is not "
"relevant to a particular option, or fail to pass a required option "
"attribute, :mod:`optparse` raises :exc:`OptionError`."
msgstr ""
"以下選項屬性可以作為關鍵字參數傳遞給 :meth:`OptionParser."
"add_option`。如果您傳遞與特定選項無關的選項屬性，或者未能傳遞必需的選項屬性，"
"則 :mod:`optparse` 會引發 :exc:`OptionError`。"

#: ../../library/optparse.rst:1018
#, fuzzy
msgid "(default: ``\"store\"``)"
msgstr "（預設值：``“商店”``）"

#: ../../library/optparse.rst:1020
#, fuzzy
msgid ""
"Determines :mod:`optparse`'s behaviour when this option is seen on the "
"command line; the available options are documented :ref:`here <optparse-"
"standard-option-actions>`."
msgstr ""
"當在命令列上看到此選項時，確定 :mod:`optparse` 的行為；可用選項記錄在 :ref:`"
"此處 <optparse-standard-option-actions>`。"

#: ../../library/optparse.rst:1026
#, fuzzy
msgid "(default: ``\"string\"``)"
msgstr "（預設值：``“字串”``）"

#: ../../library/optparse.rst:1028
#, fuzzy
msgid ""
"The argument type expected by this option (e.g., ``\"string\"`` or "
"``\"int\"``); the available option types are documented :ref:`here <optparse-"
"standard-option-types>`."
msgstr ""
"此選項期望的參數型別（例如，``\"string\"`` 或 ``\"int\"``）；"
"可用的選項型別記錄在 :ref:`here <optparse-standard-option-types>`。"

#: ../../library/optparse.rst:1034 ../../library/optparse.rst:1084
#, fuzzy
msgid "(default: derived from option strings)"
msgstr "（預設：派生自選項字串）"

#: ../../library/optparse.rst:1036
#, fuzzy
msgid ""
"If the option's action implies writing or modifying a value somewhere, this "
"tells :mod:`optparse` where to write it: :attr:`~Option.dest` names an "
"attribute of the ``options`` object that :mod:`optparse` builds as it parses "
"the command line."
msgstr ""
"如果選項的操作意味著在某處寫入或修改值，這會告訴 :mod:`optparse` "
"將它寫入何處 :attr:`~Option.dest` 命名 options 物件的屬性 :mod:`optparse` "
"在解析命令列時構建。"

#: ../../library/optparse.rst:1043
#, fuzzy
msgid ""
"The value to use for this option's destination if the option is not seen on "
"the command line.  See also :meth:`OptionParser.set_defaults`."
msgstr "如果在命令列上看不到該選項，則用於此選項目標的值。另見 :meth:`OptionParser."
"set_defaults`。"

#: ../../library/optparse.rst:1048
#, fuzzy
msgid "(default: 1)"
msgstr "（預設值：1）"

#: ../../library/optparse.rst:1050
#, fuzzy
msgid ""
"How many arguments of type :attr:`~Option.type` should be consumed when this "
"option is seen.  If > 1, :mod:`optparse` will store a tuple of values to :"
"attr:`~Option.dest`."
msgstr ""
"當看到這個選項時，應該消耗多少型別的參數 :attr:`~Option.type`。如果 > "
"1，:mod:`optparse` 會將一個值元組儲存到 :attr:`~Option.dest`。"

#: ../../library/optparse.rst:1056
#, fuzzy
msgid "For actions that store a constant value, the constant value to store."
msgstr "對於儲存常數值的操作，要儲存的常數值。"

#: ../../library/optparse.rst:1060
#, fuzzy
msgid ""
"For options of type ``\"choice\"``, the list of strings the user may choose "
"from."
msgstr "對於 ``\"choice\"`` 型別的選項，使用者可以從中選擇的字串列表。"

#: ../../library/optparse.rst:1065
#, fuzzy
msgid ""
"For options with action ``\"callback\"``, the callable to call when this "
"option is seen.  See section :ref:`optparse-option-callbacks` for detail on "
"the arguments passed to the callable."
msgstr ""
"對於帶有操作 ``\"callback\"`` 的選項，看到此選項時呼叫的可呼叫物件。有關傳遞給可呼叫參數"
"的詳細資訊，請參閱 :ref:`optparse-option-callbacks` 部分。"

#: ../../library/optparse.rst:1072
#, fuzzy
msgid ""
"Additional positional and keyword arguments to pass to ``callback`` after "
"the four standard callback arguments."
msgstr "在四個標準回呼參數之後傳遞給 ``callback`` 的附加位置和關鍵字參數。"

#: ../../library/optparse.rst:1077
#, fuzzy
msgid ""
"Help text to print for this option when listing all available options after "
"the user supplies a :attr:`~Option.help` option (such as ``--help``).  If no "
"help text is supplied, the option will be listed without help text.  To hide "
"this option, use the special value :data:`optparse.SUPPRESS_HELP`."
msgstr ""
"在使用者提供 :attr:`~Option.help` 選項（例如 ``--help``）後列出所有可用選項時"
"印出此選項的幫助文本。如果沒有提供幫助文本，選項將在沒有幫助文本的情況下列出"
"。要隱藏此選項，請使用特殊值 :data:`optparse.SUPPRESS_HELP`。"

#: ../../library/optparse.rst:1086
#, fuzzy
msgid ""
"Stand-in for the option argument(s) to use when printing help text.  See "
"section :ref:`optparse-tutorial` for an example."
msgstr "印出幫助文本時要使用的選項參數的替代。有關示例，請參見部分 :ref:`optparse-"
"tutorial`。"

#: ../../library/optparse.rst:1093
#, fuzzy
msgid "Standard option actions"
msgstr "標準選項操作"

#: ../../library/optparse.rst:1095
#, fuzzy
msgid ""
"The various option actions all have slightly different requirements and "
"effects. Most actions have several relevant option attributes which you may "
"specify to guide :mod:`optparse`'s behaviour; a few have required "
"attributes, which you must specify for any option using that action."
msgstr ""
"各種選項操作的要求和效果都略有不同。大多數操作都有幾個相關的選項屬性，"
"您可以指定這些屬性來指導 :mod:`optparse` "
"的行為；一些具有必需的屬性，您必須為使用該操作的任何選項指定這些屬性。"

#: ../../library/optparse.rst:1100
#, fuzzy
msgid ""
"``\"store\"`` [relevant: :attr:`~Option.type`, :attr:`~Option.dest`, :attr:"
"`~Option.nargs`, :attr:`~Option.choices`]"
msgstr ""
"``\"儲存\"`` [相關：:attr:`~Option.type`, :attr:`~Option.dest`, "
":attr:`~Option.nargs`, :attr:`~Option.choices`]"

#: ../../library/optparse.rst:1103
#, fuzzy
msgid ""
"The option must be followed by an argument, which is converted to a value "
"according to :attr:`~Option.type` and stored in :attr:`~Option.dest`.  If :"
"attr:`~Option.nargs` > 1, multiple arguments will be consumed from the "
"command line; all will be converted according to :attr:`~Option.type` and "
"stored to :attr:`~Option.dest` as a tuple.  See the :ref:`optparse-standard-"
"option-types` section."
msgstr ""
"該選項後面必須跟一個參數，該參數根據 :attr:`~Option.type` "
"轉換為一個值並儲存在 :attr:`~Option.dest` 中。如果 :attr:`~Option.nargs` > "
"1，將從命令列使用多個參數； all 將根據 :attr:`~Option.type` "
"轉換並作為元組儲存到 :attr:`~Option.dest`。請參閱 :ref:`optparse-standard-"
"option-types` 部分。"

#: ../../library/optparse.rst:1110
#, fuzzy
msgid ""
"If :attr:`~Option.choices` is supplied (a list or tuple of strings), the "
"type defaults to ``\"choice\"``."
msgstr "如果提供 :attr:`~Option.choices`（字串列表或元組），型別預設為``\"choice\""
"``。"

#: ../../library/optparse.rst:1113
#, fuzzy
msgid "If :attr:`~Option.type` is not supplied, it defaults to ``\"string\"``."
msgstr "如果未提供 :attr:`~Option.type`，則預設為``\"string\"``。"

#: ../../library/optparse.rst:1115
#, fuzzy
msgid ""
"If :attr:`~Option.dest` is not supplied, :mod:`optparse` derives a "
"destination from the first long option string (e.g., ``--foo-bar`` implies "
"``foo_bar``). If there are no long option strings, :mod:`optparse` derives a "
"destination from the first short option string (e.g., ``-f`` implies ``f``)."
msgstr ""
"如果未提供 :attr:`~Option.dest`，則 :mod:`optparse` "
"從第一個長選項字串派生一個目的地（例如，``--foo-bar`` 表示 "
"``foo_bar``）。如果沒有長選項字串，:mod:`optparse` "
"從第一個短選項字串中導出一個目的地（例如，``-f`` 表示``f``）。"

#: ../../library/optparse.rst:1120 ../../library/optparse.rst:1140
#: ../../library/optparse.rst:1162 ../../library/optparse.rst:1180
#: ../../library/optparse.rst:1219 ../../library/optparse.rst:1257
msgid "Example::"
msgstr ""
"範例：\n"
"\n"
"::"

#: ../../library/optparse.rst:1125
#, fuzzy
msgid "As it parses the command line ::"
msgstr "因為它解析命令列 ::"

#: ../../library/optparse.rst:1129
#, fuzzy
msgid ":mod:`optparse` will set ::"
msgstr ":mod:`optparse` 將設定 ::"

#: ../../library/optparse.rst:1135
#, fuzzy
msgid ""
"``\"store_const\"`` [required: :attr:`~Option.const`; relevant: :attr:"
"`~Option.dest`]"
msgstr "``\"store_const\"`` [需要：:attr:`~Option.const`;相關：:attr:`~Option.dest`]"

#: ../../library/optparse.rst:1138
#, fuzzy
msgid "The value :attr:`~Option.const` is stored in :attr:`~Option.dest`."
msgstr "值 :attr:`~Option.const` 儲存在 :attr:`~Option.dest` 中。"

#: ../../library/optparse.rst:1149
#, fuzzy
msgid "If ``--noisy`` is seen, :mod:`optparse` will set  ::"
msgstr "如果看到``--noisy``，:mod:`optparse` 將設定 ::"

#: ../../library/optparse.rst:1153
#, fuzzy
msgid "``\"store_true\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"store_true\"`` [相關： :attr:`~Option.dest`]"

#: ../../library/optparse.rst:1155
#, fuzzy
msgid ""
"A special case of ``\"store_const\"`` that stores ``True`` to :attr:`~Option."
"dest`."
msgstr "``\"store_const\"`` 的一個特例，它將 ``True`` 儲存到 :attr:`~Option.dest`。"

#: ../../library/optparse.rst:1158
#, fuzzy
msgid "``\"store_false\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"store_false\"`` [相關： :attr:`~Option.dest`]"

#: ../../library/optparse.rst:1160
#, fuzzy
msgid "Like ``\"store_true\"``, but stores ``False``."
msgstr "類似於``\"store_true\"``，但儲存``False``。"

#: ../../library/optparse.rst:1167
#, fuzzy
msgid ""
"``\"append\"`` [relevant: :attr:`~Option.type`, :attr:`~Option.dest`, :attr:"
"`~Option.nargs`, :attr:`~Option.choices`]"
msgstr ""
"``\"追加\"`` [相關： :attr:`~Option.type`， :attr:`~Option."
"dest`， :attr:`~Option.nargs`， :attr:`~Option.choices`]"

#: ../../library/optparse.rst:1170
#, fuzzy
msgid ""
"The option must be followed by an argument, which is appended to the list "
"in :attr:`~Option.dest`.  If no default value for :attr:`~Option.dest` is "
"supplied, an empty list is automatically created when :mod:`optparse` first "
"encounters this option on the command-line.  If :attr:`~Option.nargs` > 1, "
"multiple arguments are consumed, and a tuple of length :attr:`~Option.nargs` "
"is appended to :attr:`~Option.dest`."
msgstr ""
"該選項後面必須跟一個參數，該參數附加到 :attr:`~Option.dest` 中的列表。"
"如果沒有提供 :attr:`~Option.dest` 的預設值，當 :mod:`optparse` "
"在命令列上第一次遇到這個選項時，會自動建立一個空列表。如果 :attr:`~Option."
"nargs` > 1，多個參數被消耗，並且一個長度為 :attr:`~Option.nargs` "
"的元組附加到 :attr:`~Option.dest`。"

#: ../../library/optparse.rst:1177
#, fuzzy
msgid ""
"The defaults for :attr:`~Option.type` and :attr:`~Option.dest` are the same "
"as for the ``\"store\"`` action."
msgstr ":attr:`~Option.type` 和 :attr:`~Option.dest` 的預設值與 ``\"store\"`` "
"操作相同。"

#: ../../library/optparse.rst:1184
#, fuzzy
msgid ""
"If ``-t3`` is seen on the command-line, :mod:`optparse` does the equivalent "
"of::"
msgstr "如果在命令列上看到 ``-t3``，則 :mod:`optparse` 相當於："

#: ../../library/optparse.rst:1190
#, fuzzy
msgid "If, a little later on, ``--tracks=4`` is seen, it does::"
msgstr "如果稍後看到 ``--tracks=4``，它會："

#: ../../library/optparse.rst:1194
#, fuzzy
msgid ""
"The ``append`` action calls the ``append`` method on the current value of "
"the option.  This means that any default value specified must have an "
"``append`` method.  It also means that if the default value is non-empty, "
"the default elements will be present in the parsed value for the option, "
"with any values from the command line appended after those default values::"
msgstr ""
"``append`` 操作在選項的當前值上呼叫 ``append`` 方法。"
"這意味著任何指定的預設值都必須有一個 ``append`` 方法。這也意味著如果預設值是"
"非空的，預設元素將出現在選項的解析值中，命令列中的任何值附加在這些預設值之後:"
":"

#: ../../library/optparse.rst:1205
#, fuzzy
msgid ""
"``\"append_const\"`` [required: :attr:`~Option.const`; relevant: :attr:"
"`~Option.dest`]"
msgstr "``\"append_const\"`` [需要：:attr:`~Option.const`;相關：:attr:`~Option.dest`]"

#: ../../library/optparse.rst:1208
#, fuzzy
msgid ""
"Like ``\"store_const\"``, but the value :attr:`~Option.const` is appended "
"to :attr:`~Option.dest`; as with ``\"append\"``, :attr:`~Option.dest` "
"defaults to ``None``, and an empty list is automatically created the first "
"time the option is encountered."
msgstr ""
"類似於 ``\"store_const\"``，但是值 :attr:`~Option.const` 附加到 "
":attr:`~Option.dest`；與 ``\"append\"`` 一樣，:attr:`~Option.dest` 預設為 "
"``None``，第一次遇到該選項時會自動建立一個空列表。"

#: ../../library/optparse.rst:1213
#, fuzzy
msgid "``\"count\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"count\"`` [相關：:attr:`~Option.dest`]"

#: ../../library/optparse.rst:1215
#, fuzzy
msgid ""
"Increment the integer stored at :attr:`~Option.dest`.  If no default value "
"is supplied, :attr:`~Option.dest` is set to zero before being incremented "
"the first time."
msgstr ""
"增加儲存在 :attr:`~Option.dest` 中的整數。如果未提供預設值，則 :attr:`~Option"
".dest` 在第一次遞增之前設定為零。"

#: ../../library/optparse.rst:1223
#, fuzzy
msgid ""
"The first time ``-v`` is seen on the command line, :mod:`optparse` does the "
"equivalent of::"
msgstr "第一次在命令列上看到 ``-v`` 時，:mod:`optparse` 相當於："

#: ../../library/optparse.rst:1229
#, fuzzy
msgid "Every subsequent occurrence of ``-v`` results in  ::"
msgstr "隨後每次出現 ``-v``都會導致 ::"

#: ../../library/optparse.rst:1233
#, fuzzy
msgid ""
"``\"callback\"`` [required: :attr:`~Option.callback`; relevant: :attr:"
"`~Option.type`, :attr:`~Option.nargs`, :attr:`~Option.callback_args`, :attr:"
"`~Option.callback_kwargs`]"
msgstr ""
"``\"回呼\"`` [需要：:attr:`~Option.callback`;相關：:attr:`~Option.type`, "
":attr:`~Option.nargs`, :attr:`~Option.callback_args`, :attr:`~Option."
"callback_kwargs`]"

#: ../../library/optparse.rst:1237
#, fuzzy
msgid ""
"Call the function specified by :attr:`~Option.callback`, which is called "
"as ::"
msgstr "呼叫 :attr:`~Option.callback` 指定的函式，稱為 ::"

#: ../../library/optparse.rst:1241
msgid "See section :ref:`optparse-option-callbacks` for more detail."
msgstr "更多細節請見 :ref:`optparse-option-callbacks`\\ 。"

#: ../../library/optparse.rst:1245
#, fuzzy
msgid ""
"Prints a complete help message for all the options in the current option "
"parser.  The help message is constructed from the ``usage`` string passed to "
"OptionParser's constructor and the :attr:`~Option.help` string passed to "
"every option."
msgstr ""
"印出當前選項解析器中所有選項的完整幫助消息。幫助消息由傳遞給 OptionParser "
"的構造函式的 ``usage`` 字串和傳遞給每個選項的 :attr:`~Option.help` 字串構成。"

#: ../../library/optparse.rst:1250
#, fuzzy
msgid ""
"If no :attr:`~Option.help` string is supplied for an option, it will still "
"be listed in the help message.  To omit an option entirely, use the special "
"value :data:`optparse.SUPPRESS_HELP`."
msgstr ""
"如果沒有為選項提供 :attr:`~Option.help` "
"字串，它仍會列在幫助消息中。要完全省略一個選項，請使用特殊值 :data:`optparse."
"SUPPRESS_HELP`。"

#: ../../library/optparse.rst:1254
#, fuzzy
msgid ""
":mod:`optparse` automatically adds a :attr:`~Option.help` option to all "
"OptionParsers, so you do not normally need to create one."
msgstr ""
":mod:`optparse` 自動新增一個 :attr:`~Option.help` 選項到所有 "
"OptionParsers，所以你通常不需要建立一個。"

#: ../../library/optparse.rst:1272
#, fuzzy
msgid ""
"If :mod:`optparse` sees either ``-h`` or ``--help`` on the command line, it "
"will print something like the following help message to stdout (assuming "
"``sys.argv[0]`` is ``\"foo.py\"``):"
msgstr ""
"如果 :mod:`optparse` 在命令列上看到 ``-h`` 或 "
"``--help``，它將向標準輸出印出類似於以下幫助消息的內容（假設 ``sys.argv[0]` `"
" 是 ``\"foo.py\"``):"

#: ../../library/optparse.rst:1285
#, fuzzy
msgid ""
"After printing the help message, :mod:`optparse` terminates your process "
"with ``sys.exit(0)``."
msgstr "印出幫助消息後，:mod:`optparse` 使用 ``sys.exit(0)`` 終止您的行程。"

#: ../../library/optparse.rst:1288
msgid "``\"version\"``"
msgstr "``\"version\"``"

#: ../../library/optparse.rst:1290
#, fuzzy
msgid ""
"Prints the version number supplied to the OptionParser to stdout and exits. "
"The version number is actually formatted and printed by the "
"``print_version()`` method of OptionParser.  Generally only relevant if the "
"``version`` argument is supplied to the OptionParser constructor.  As with :"
"attr:`~Option.help` options, you will rarely create ``version`` options, "
"since :mod:`optparse` automatically adds them when needed."
msgstr ""
"將提供給 OptionParser 的版本號印出到標準輸出並退出。版本號實際上是由 "
"OptionParser 的 ``print_version()`` 方法格式化和印出的。通常只有在將 "
"``version`` 參數提供給 OptionParser 構造函式時才相關。與 :attr:`~Option.help`"
" 選項一樣，您很少會建立 ``version`` 選項，因為 :mod:`optparse` "
"在需要時自動新增它們。"

#: ../../library/optparse.rst:1301
#, fuzzy
msgid "Standard option types"
msgstr "標準選項型別"

#: ../../library/optparse.rst:1303
#, fuzzy
msgid ""
":mod:`optparse` has five built-in option types: ``\"string\"``, ``\"int\"``, "
"``\"choice\"``, ``\"float\"`` and ``\"complex\"``.  If you need to add new "
"option types, see section :ref:`optparse-extending-optparse`."
msgstr ""
":mod:`optparse` 有五種內建選項型別：``\"string\"``、``\"int\"``、``\"choice\""
"``、``\"float\"`` 和 ``\"complex “``。如果您需要新增新的選項型別，請參閱 "
"optparse-extending-optparse 部分。"

#: ../../library/optparse.rst:1307
#, fuzzy
msgid ""
"Arguments to string options are not checked or converted in any way: the "
"text on the command line is stored in the destination (or passed to the "
"callback) as-is."
msgstr "不以任何方式檢查或轉換字串選項的參數：命令列上的文本按原樣儲存在目標中（或傳"
"遞給回呼）。"

#: ../../library/optparse.rst:1310
#, fuzzy
msgid "Integer arguments (type ``\"int\"``) are parsed as follows:"
msgstr "整數參數（型別``\"int\"``）解析如下："

#: ../../library/optparse.rst:1312
#, fuzzy
msgid "if the number starts with ``0x``, it is parsed as a hexadecimal number"
msgstr "如果數字以 ``0x`` 開頭，則將其解析為十六進位數"

#: ../../library/optparse.rst:1314
#, fuzzy
msgid "if the number starts with ``0``, it is parsed as an octal number"
msgstr "如果數字以 ``0`` 開頭，則將其解析為八進位數"

#: ../../library/optparse.rst:1316
#, fuzzy
msgid "if the number starts with ``0b``, it is parsed as a binary number"
msgstr "如果數字以 ``0b`` 開頭，則將其解析為二進位數"

#: ../../library/optparse.rst:1318
#, fuzzy
msgid "otherwise, the number is parsed as a decimal number"
msgstr "否則，該數字被解析為十進位數"

#: ../../library/optparse.rst:1321
#, fuzzy
msgid ""
"The conversion is done by calling :func:`int` with the appropriate base (2, "
"8, 10, or 16).  If this fails, so will :mod:`optparse`, although with a more "
"useful error message."
msgstr ""
"轉換是通過使用適當的基數（2、8、10 或 16）呼叫 :func:`int` "
"來完成的。如果失敗，那麼 :mod:`optparse` "
"也會失敗，儘管會出現更有用的錯誤消息。"

#: ../../library/optparse.rst:1325
#, fuzzy
msgid ""
"``\"float\"`` and ``\"complex\"`` option arguments are converted directly "
"with :func:`float` and :func:`complex`, with similar error-handling."
msgstr ""
"``\"float\"`` 和 ``\"complex\"`` 選項參數直接用 :func:`float` 和 "
":func:`complex` 轉換，具有類似的錯誤處理。"

#: ../../library/optparse.rst:1328
#, fuzzy
msgid ""
"``\"choice\"`` options are a subtype of ``\"string\"`` options.  The :attr:"
"`~Option.choices` option attribute (a sequence of strings) defines the set "
"of allowed option arguments.  :func:`optparse.check_choice` compares user-"
"supplied option arguments against this master list and raises :exc:"
"`OptionValueError` if an invalid string is given."
msgstr ""
"``\"choice\"`` 選項是 ``\"string\"`` 選項的子型別。 :attr:`~Option.choices` "
"選項屬性（字串序列）定義允許的選項參數集。 :func:`optparse.check_choice` "
"將使用者提供的選項參數與此主列表進行比較，如果給出的字串無效，則引發 "
":exc:`OptionValueError`。"

#: ../../library/optparse.rst:1338
#, fuzzy
msgid "Parsing arguments"
msgstr "解析參數"

#: ../../library/optparse.rst:1340
#, fuzzy
msgid ""
"The whole point of creating and populating an OptionParser is to call its :"
"meth:`parse_args` method::"
msgstr "建立和填充 OptionParser 的全部要點是呼叫它的 parse_args 方法::"

#: ../../library/optparse.rst:1345
#, fuzzy
msgid "where the input parameters are"
msgstr "輸入參數在哪裡"

#: ../../library/optparse.rst:1348 ../../library/optparse.rst:1362
#: ../../library/optparse.rst:1681
msgid "``args``"
msgstr "``args``"

#: ../../library/optparse.rst:1348
#, fuzzy
msgid "the list of arguments to process (default: ``sys.argv[1:]``)"
msgstr "要處理的參數列表（預設值：``sys.argv[1:]``）"

#: ../../library/optparse.rst:1353
msgid "``values``"
msgstr "``values``"

#: ../../library/optparse.rst:1351
#, fuzzy
msgid ""
"an :class:`optparse.Values` object to store option arguments in (default: a "
"new instance of :class:`Values`) -- if you give an existing object, the "
"option defaults will not be initialized on it"
msgstr ""
"一個 :class:`optparse.Values` 物件來儲存選項參數（預設：一個新的 "
":class:`Values` 實例）——如果你給一個現有的物件，選項預設值將不會被初始化"

#: ../../library/optparse.rst:1355
#, fuzzy
msgid "and the return values are"
msgstr "回傳值是"

#: ../../library/optparse.rst:1359
msgid "``options``"
msgstr "``options``"

#: ../../library/optparse.rst:1358
#, fuzzy
msgid ""
"the same object that was passed in as ``values``, or the optparse.Values "
"instance created by :mod:`optparse`"
msgstr "作為 ``values`` 傳入的同一物件，或由 optparse 建立的 optparse.Values 實例"

#: ../../library/optparse.rst:1362
#, fuzzy
msgid "the leftover positional arguments after all options have been processed"
msgstr "處理完所有選項後剩餘的位置參數"

#: ../../library/optparse.rst:1364
#, fuzzy
msgid ""
"The most common usage is to supply neither keyword argument.  If you supply "
"``values``, it will be modified with repeated :func:`setattr` calls (roughly "
"one for every option argument stored to an option destination) and returned "
"by :meth:`parse_args`."
msgstr ""
"最常見的用法是既不提供關鍵字參數。如果您提供 ``values``，它將通過重複的 "
"setattr 呼叫進行修改（對於儲存到選項目標的每個選項參數大約一個呼叫）並由 "
"parse_args 回傳。"

#: ../../library/optparse.rst:1369
#, fuzzy
msgid ""
"If :meth:`parse_args` encounters any errors in the argument list, it calls "
"the OptionParser's :meth:`error` method with an appropriate end-user error "
"message. This ultimately terminates your process with an exit status of 2 "
"(the traditional Unix exit status for command-line errors)."
msgstr ""
"如果 :meth:`parse_args` 在參數列表中遇到任何錯誤，它會呼叫 OptionParser 的 "
":meth:`error` 方法並顯示適當的最終使用者錯誤消息。這最終會終止您的行程，"
"退出狀態為 2（命令列錯誤的傳統 Unix 退出狀態）。"

#: ../../library/optparse.rst:1378
#, fuzzy
msgid "Querying and manipulating your option parser"
msgstr "查詢和操作您的選項解析器"

#: ../../library/optparse.rst:1380
#, fuzzy
msgid ""
"The default behavior of the option parser can be customized slightly, and "
"you can also poke around your option parser and see what's there.  "
"OptionParser provides several methods to help you out:"
msgstr "選項解析器的預設行為可以稍微定制，您也可以四處查看您的選項解析器，看看那裡有"
"什麼。 OptionParser 提供了幾種方法來幫助你："

#: ../../library/optparse.rst:1386
#, fuzzy
msgid ""
"Set parsing to stop on the first non-option.  For example, if ``-a`` and ``-"
"b`` are both simple options that take no arguments, :mod:`optparse` normally "
"accepts this syntax::"
msgstr ""
"將解析設定為在第一個非選項處停止。例如，如果 ``-a`` 和 ``-b`` "
"都是不帶參數的簡單選項，則 :mod:`optparse` 通常接受以下語法："

#: ../../library/optparse.rst:1392
#, fuzzy
msgid "and treats it as equivalent to  ::"
msgstr "並將其視為等同於 ::"

#: ../../library/optparse.rst:1396
#, fuzzy
msgid ""
"To disable this feature, call :meth:`disable_interspersed_args`.  This "
"restores traditional Unix syntax, where option parsing stops with the first "
"non-option argument."
msgstr ""
"要禁用此功能，請呼叫 :meth:`disable_interspersed_args`。這恢復了傳統的 Unix "
"語法，其中選項解析以第一個非選項參數停止。"

#: ../../library/optparse.rst:1400
#, fuzzy
msgid ""
"Use this if you have a command processor which runs another command which "
"has options of its own and you want to make sure these options don't get "
"confused.  For example, each command might have a different set of options."
msgstr "如果你有一個命令處理器運行另一個有自己的選項的命令並且你想確保這些選項不會混"
"淆，請使用這個。例如，每個命令可能有一組不同的選項。"

#: ../../library/optparse.rst:1406
#, fuzzy
msgid ""
"Set parsing to not stop on the first non-option, allowing interspersing "
"switches with command arguments.  This is the default behavior."
msgstr "將解析設定為在第一個非選項上不停止，允許使用命令參數散佈開關。這是預設行為。"

#: ../../library/optparse.rst:1411
#, fuzzy
msgid ""
"Returns the Option instance with the option string *opt_str*, or ``None`` if "
"no options have that option string."
msgstr "回傳帶有選項字串 *opt_str* 的 Option 實例，如果沒有選項具有該選項字串，"
"則回傳 ``None``。"

#: ../../library/optparse.rst:1416
#, fuzzy
msgid ""
"Return ``True`` if the OptionParser has an option with option string "
"*opt_str* (e.g., ``-q`` or ``--verbose``)."
msgstr ""
"如果 OptionParser 有一個帶有選項字串 *opt_str* 的選項，則回傳 "
"``True``（例如，``-q`` 或 ``--verbose``）。"

#: ../../library/optparse.rst:1421
#, fuzzy
msgid ""
"If the :class:`OptionParser` has an option corresponding to *opt_str*, that "
"option is removed.  If that option provided any other option strings, all of "
"those option strings become invalid. If *opt_str* does not occur in any "
"option belonging to this :class:`OptionParser`, raises :exc:`ValueError`."
msgstr ""
"如果 :class:`OptionParser` 有一個對應於 *opt_str* 的選項，該選項將被刪除。如"
"果該選項提供了任何其他選項字串，則所有這些選項字串都將無效。如果 *opt_str* "
"未出現在屬於此 OptionParser 的任何選項中，則引發 :exec:`ValueError`。"

#: ../../library/optparse.rst:1430
#, fuzzy
msgid "Conflicts between options"
msgstr "選項之間的衝突"

#: ../../library/optparse.rst:1432
#, fuzzy
msgid ""
"If you're not careful, it's easy to define options with conflicting option "
"strings::"
msgstr "如果您不小心，很容易定義帶有衝突選項字串的選項::"

#: ../../library/optparse.rst:1439
#, fuzzy
msgid ""
"(This is particularly true if you've defined your own OptionParser subclass "
"with some standard options.)"
msgstr "（如果您使用一些標準選項定義了自己的 OptionParser 子類別，則尤其如此。）"

#: ../../library/optparse.rst:1442
#, fuzzy
msgid ""
"Every time you add an option, :mod:`optparse` checks for conflicts with "
"existing options.  If it finds any, it invokes the current conflict-handling "
"mechanism. You can set the conflict-handling mechanism either in the "
"constructor::"
msgstr ""
"每次新增選項時，:mod:`optparse` 都會檢查與現有選項的衝突。如果找到任何衝突，"
"它會呼叫當前的衝突處理機制。您可以在構造函式中設定衝突處理機制::"

#: ../../library/optparse.rst:1448
#, fuzzy
msgid "or with a separate call::"
msgstr "或者單獨呼叫::"

#: ../../library/optparse.rst:1452
#, fuzzy
msgid "The available conflict handlers are:"
msgstr "可用的衝突處理程式是："

#: ../../library/optparse.rst:1456
#, fuzzy
msgid "``\"error\"`` (default)"
msgstr "``“錯誤”``（預設）"

#: ../../library/optparse.rst:1455
#, fuzzy
msgid ""
"assume option conflicts are a programming error and raise :exc:"
"`OptionConflictError`"
msgstr "假設選項衝突是一個編程錯誤並引發 :exc:`OptionConflictError`"

#: ../../library/optparse.rst:1460
msgid "``\"resolve\"``"
msgstr "``\"resolve\"``"

#: ../../library/optparse.rst:1459
#, fuzzy
msgid "resolve option conflicts intelligently (see below)"
msgstr "智能地解決選項衝突（見下文）"

#: ../../library/optparse.rst:1462
#, fuzzy
msgid ""
"As an example, let's define an :class:`OptionParser` that resolves conflicts "
"intelligently and add conflicting options to it::"
msgstr "例如，讓我們定義一個 OptionParser 來智能地解決衝突並向其新增衝突選項::"

#: ../../library/optparse.rst:1469
#, fuzzy
msgid ""
"At this point, :mod:`optparse` detects that a previously added option is "
"already using the ``-n`` option string.  Since ``conflict_handler`` is "
"``\"resolve\"``, it resolves the situation by removing ``-n`` from the "
"earlier option's list of option strings.  Now ``--dry-run`` is the only way "
"for the user to activate that option.  If the user asks for help, the help "
"message will reflect that::"
msgstr ""
"此時，:mod:`optparse` 檢測到先前新增的選項已經在使用 ``-n`` 選項字串。由於 "
"``conflict_handler`` 是 ``\"resolve\"``，"
"它通過從早期選項的選項字串列表中刪除 ``-n`` 來解決這種情況。現在 ``--dry-"
"run`` 是使用者激活該選項的唯一方法。如果使用者尋求幫助，幫助消息將反映："

#: ../../library/optparse.rst:1480
#, fuzzy
msgid ""
"It's possible to whittle away the option strings for a previously added "
"option until there are none left, and the user has no way of invoking that "
"option from the command-line.  In that case, :mod:`optparse` removes that "
"option completely, so it doesn't show up in help text or anywhere else. "
"Carrying on with our existing OptionParser::"
msgstr ""
"可以削減之前新增的選項的選項字串，直到沒有剩餘為止，並且使用者無法從命令列呼"
"叫該選項。在這種情況下，:mod:`optparse` "
"會完全刪除該選項，因此它不會出現在幫助文本或其他任何地方。繼續我們現有的 "
"OptionParser::"

#: ../../library/optparse.rst:1488
#, fuzzy
msgid ""
"At this point, the original ``-n``/``--dry-run`` option is no longer "
"accessible, so :mod:`optparse` removes it, leaving this help text::"
msgstr "此時，原來的 ``-n``/``--dry-run`` 選項不再可用，因此 :mod:`optparse` "
"將其刪除，留下此幫助文本::"

#: ../../library/optparse.rst:1500
#, fuzzy
msgid "Cleanup"
msgstr "清理"

#: ../../library/optparse.rst:1502
#, fuzzy
msgid ""
"OptionParser instances have several cyclic references.  This should not be a "
"problem for Python's garbage collector, but you may wish to break the cyclic "
"references explicitly by calling :meth:`~OptionParser.destroy` on your "
"OptionParser once you are done with it.  This is particularly useful in long-"
"running applications where large object graphs are reachable from your "
"OptionParser."
msgstr ""
"OptionParser 實例有幾個循環引用。這對 Python 的垃圾收集器來說應該不是問題，"
"但您可能希望在完成後通過在 OptionParser 上呼叫 :meth:`~OptionParser.destroy` "
"來顯式中斷循環引用。這在長時間運行的應用程式中特別有用，"
"在這些應用程式中可以從 OptionParser 訪問大型對像圖。"

#: ../../library/optparse.rst:1513
#, fuzzy
msgid "Other methods"
msgstr "其他方法"

#: ../../library/optparse.rst:1515
#, fuzzy
msgid "OptionParser supports several other public methods:"
msgstr "OptionParser 支援其他幾種公開方法："

#: ../../library/optparse.rst:1519
#, fuzzy
msgid ""
"Set the usage string according to the rules described above for the "
"``usage`` constructor keyword argument.  Passing ``None`` sets the default "
"usage string; use :data:`optparse.SUPPRESS_USAGE` to suppress a usage "
"message."
msgstr ""
"根據上述規則為 ``usage`` 構造函式關鍵字參數設定用法字串。傳遞 ``None`` "
"設定預設用法字串；使用 :data:`optparse.SUPPRESS_USAGE` 來抑制使用資訊。"

#: ../../library/optparse.rst:1525
#, fuzzy
msgid ""
"Print the usage message for the current program (``self.usage``) to *file* "
"(default stdout).  Any occurrence of the string ``%prog`` in ``self.usage`` "
"is replaced with the name of the current program.  Does nothing if ``self."
"usage`` is empty or not defined."
msgstr ""
"將當前程式 (``self.usage``) 的使用資訊印出到 "
"*file*（預設標準輸出）。 ``self.usage`` 中出現的任何字串 ``%prog`` "
"都將替換為當前程式的名稱。如果 ``self.usage`` "
"為空或未定義，則不執行任何操作。"

#: ../../library/optparse.rst:1532
#, fuzzy
msgid ""
"Same as :meth:`print_usage` but returns the usage string instead of printing "
"it."
msgstr "與 :meth:`print_usage` 相同，但回傳用法字串而不是印出它。"

#: ../../library/optparse.rst:1537
#, fuzzy
msgid ""
"Set default values for several option destinations at once.  Using :meth:"
"`set_defaults` is the preferred way to set default values for options, since "
"multiple options can share the same destination.  For example, if several "
"\"mode\" options all set the same destination, any one of them can set the "
"default, and the last one wins::"
msgstr ""
"一次為多個選項目標設定預設值。使用 :meth:`set_defaults` 是為選項設定預設值的"
"首選方法，因為多個選項可以共享同一個目的地。例如，如果幾個“模式”選項都設定相"
"同的目的地，則其中任何一個都可以設定預設值，最後一個獲勝::"

#: ../../library/optparse.rst:1550
#, fuzzy
msgid "To avoid this confusion, use :meth:`set_defaults`::"
msgstr "為避免這種混淆，請使用 :meth:`set_defaults`::"

#: ../../library/optparse.rst:1562
#, fuzzy
msgid "Option Callbacks"
msgstr "期權回呼"

#: ../../library/optparse.rst:1564
#, fuzzy
msgid ""
"When :mod:`optparse`'s built-in actions and types aren't quite enough for "
"your needs, you have two choices: extend :mod:`optparse` or define a "
"callback option. Extending :mod:`optparse` is more general, but overkill for "
"a lot of simple cases.  Quite often a simple callback is all you need."
msgstr ""
"當 :mod:`optparse` 的內建操作和型別不足以滿足您的需求時，您有兩個選擇：擴充 "
":mod:`optparse` 或定義回呼選項。擴充 :mod:`optparse` 更通用，但對於很多簡單的"
"情況來說有點矯枉過正。通常，您只需要一個簡單的回呼即可。"

#: ../../library/optparse.rst:1569
#, fuzzy
msgid "There are two steps to defining a callback option:"
msgstr "定義回呼選項有兩個步驟："

#: ../../library/optparse.rst:1571
#, fuzzy
msgid "define the option itself using the ``\"callback\"`` action"
msgstr "使用 ``\"callback\"`` 操作定義選項本身"

#: ../../library/optparse.rst:1573
#, fuzzy
msgid ""
"write the callback; this is a function (or method) that takes at least four "
"arguments, as described below"
msgstr "編寫回呼；這是一個至少有四個參數的函式（或方法），如下所述"

#: ../../library/optparse.rst:1580
#, fuzzy
msgid "Defining a callback option"
msgstr "定義回呼選項"

#: ../../library/optparse.rst:1582
#, fuzzy
msgid ""
"As always, the easiest way to define a callback option is by using the :meth:"
"`OptionParser.add_option` method.  Apart from :attr:`~Option.action`, the "
"only option attribute you must specify is ``callback``, the function to "
"call::"
msgstr ""
"與往常一樣，定義回呼選項的最簡單方法是使用 OptionParser.add_option 方法。"
"除了 :attr:`~Option.action` 之外，您必須指定的唯一選項屬性是 "
"``callback``，即要呼叫的函式："

#: ../../library/optparse.rst:1588
#, fuzzy
msgid ""
"``callback`` is a function (or other callable object), so you must have "
"already defined ``my_callback()`` when you create this callback option. In "
"this simple case, :mod:`optparse` doesn't even know if ``-c`` takes any "
"arguments, which usually means that the option takes no arguments---the mere "
"presence of ``-c`` on the command-line is all it needs to know.  In some "
"circumstances, though, you might want your callback to consume an arbitrary "
"number of command-line arguments.  This is where writing callbacks gets "
"tricky; it's covered later in this section."
msgstr ""
"``callback`` 是一個函式（或其他可呼叫物件），"
"因此您在建立此回呼選項時必須已經定義了 "
"``my_callback()``。在這種簡單的情況下，:mod:`optparse` 甚至不知道 ``-c`` "
"是否接受任何參數，這通常意味著該選項不接受任何參數——僅存在 ``-c``命令列就是它"
"需要知道的全部。但是，在某些情況下，您可能希望回呼使用任意數量的命令列參數。"
"這是編寫回呼變得棘手的地方；本節後面將對此進行介紹。"

#: ../../library/optparse.rst:1597
#, fuzzy
msgid ""
":mod:`optparse` always passes four particular arguments to your callback, "
"and it will only pass additional arguments if you specify them via :attr:"
"`~Option.callback_args` and :attr:`~Option.callback_kwargs`.  Thus, the "
"minimal callback function signature is::"
msgstr ""
":mod:`optparse` 總是將四個特定參數傳遞給您的回呼，如果您通過 :attr:`~Option."
"callback_args` 和 :attr:`~Option.callback_kwargs` "
"指定它們，它只會傳遞額外的參數。因此，最小的回呼函式簽名是："

#: ../../library/optparse.rst:1604
#, fuzzy
msgid "The four arguments to a callback are described below."
msgstr "回呼的四個參數如下所述。"

#: ../../library/optparse.rst:1606
#, fuzzy
msgid ""
"There are several other option attributes that you can supply when you "
"define a callback option:"
msgstr "在定義回呼選項時，您可以提供其他幾個選項屬性："

#: ../../library/optparse.rst:1613
msgid ":attr:`~Option.type`"
msgstr ":attr:`~Option.type`"

#: ../../library/optparse.rst:1610
#, fuzzy
msgid ""
"has its usual meaning: as with the ``\"store\"`` or ``\"append\"`` actions, "
"it instructs :mod:`optparse` to consume one argument and convert it to :attr:"
"`~Option.type`.  Rather than storing the converted value(s) anywhere, "
"though, :mod:`optparse` passes it to your callback function."
msgstr ""
"具有其通常的含義：與 ``\"store\"`` 或 ``\"append\"`` 操作一樣，它指示 "
":mod:`optparse` 使用一個參數並將其轉換為 :attr:`~Option.type` ."
"不過，:mod:`optparse` "
"不是將轉換後的值儲存在任何地方，而是將其傳遞給您的回呼函式。"

#: ../../library/optparse.rst:1619
msgid ":attr:`~Option.nargs`"
msgstr ":attr:`~Option.nargs`"

#: ../../library/optparse.rst:1616
#, fuzzy
msgid ""
"also has its usual meaning: if it is supplied and > 1, :mod:`optparse` will "
"consume :attr:`~Option.nargs` arguments, each of which must be convertible "
"to :attr:`~Option.type`.  It then passes a tuple of converted values to your "
"callback."
msgstr ""
"也有其通常的含義：如果它被提供並且 > 1，:mod:`optparse` 將使用 :attr:`~Option"
".nargs` 參數，每個參數都必須可轉換為 :attr:`~Option."
"type`。然後它將轉換值的元組傳遞給您的回呼。"

#: ../../library/optparse.rst:1622
msgid ":attr:`~Option.callback_args`"
msgstr ":attr:`~Option.callback_args`"

#: ../../library/optparse.rst:1622
#, fuzzy
msgid "a tuple of extra positional arguments to pass to the callback"
msgstr "要傳遞給回呼的額外位置參數的元組"

#: ../../library/optparse.rst:1626
msgid ":attr:`~Option.callback_kwargs`"
msgstr ":attr:`~Option.callback_kwargs`"

#: ../../library/optparse.rst:1625
#, fuzzy
msgid "a dictionary of extra keyword arguments to pass to the callback"
msgstr "要傳遞給回呼的額外關鍵字參數的字典"

#: ../../library/optparse.rst:1631
#, fuzzy
msgid "How callbacks are called"
msgstr "如何呼叫回呼"

#: ../../library/optparse.rst:1633
#, fuzzy
msgid "All callbacks are called as follows::"
msgstr "所有回呼呼叫如下::"

#: ../../library/optparse.rst:1640
msgid "``option``"
msgstr "``option``"

#: ../../library/optparse.rst:1640
#, fuzzy
msgid "is the Option instance that's calling the callback"
msgstr "是呼叫回呼的 Option 實例"

#: ../../library/optparse.rst:1647
msgid "``opt_str``"
msgstr "``opt_str``"

#: ../../library/optparse.rst:1643
#, fuzzy
msgid ""
"is the option string seen on the command-line that's triggering the "
"callback. (If an abbreviated long option was used, ``opt_str`` will be the "
"full, canonical option string---e.g. if the user puts ``--foo`` on the "
"command-line as an abbreviation for ``--foobar``, then ``opt_str`` will be "
"``\"--foobar\"``.)"
msgstr ""
"是在觸發回呼的命令列上看到的選項字串。 （如果使用了縮寫的長選項，``opt_str`` "
"將是完整的、規範的選項字串——例如，如果使用者在命令列上輸入 ``--foo`` 作為 "
"``-- foobar``，那麼 ``opt_str`` 將是 ``\"--foobar\"``。）"

#: ../../library/optparse.rst:1654
msgid "``value``"
msgstr "``value``"

#: ../../library/optparse.rst:1650
#, fuzzy
msgid ""
"is the argument to this option seen on the command-line.  :mod:`optparse` "
"will only expect an argument if :attr:`~Option.type` is set; the type of "
"``value`` will be the type implied by the option's type.  If :attr:`~Option."
"type` for this option is ``None`` (no argument expected), then ``value`` "
"will be ``None``.  If :attr:`~Option.nargs` > 1, ``value`` will be a tuple "
"of values of the appropriate type."
msgstr ""
"是在命令列上看到的此選項的參數。 :mod:`optparse` 僅在設定了 :attr:`~Option."
"type` 時才需要一個參數； ``value`` 的型別將是選項型別隱含的型別。"
"如果此選項的 :attr:`~Option.type` 為 ``None``（不需要參數），則 ``value`` "
"將為 ``None``。如果 :attr:`~Option.nargs` > 1，``value`` "
"將是適當型別的值的元組。"

#: ../../library/optparse.rst:1677
msgid "``parser``"
msgstr "``parser``"

#: ../../library/optparse.rst:1657
#, fuzzy
msgid ""
"is the OptionParser instance driving the whole thing, mainly useful because "
"you can access some other interesting data through its instance attributes:"
msgstr "是驅動整個事情的 OptionParser "
"實例，主要是有用的，因為您可以通過它的實例屬性訪問一些其他有趣的資料："

#: ../../library/optparse.rst:1664
msgid "``parser.largs``"
msgstr "``parser.largs``"

#: ../../library/optparse.rst:1661
#, fuzzy
msgid ""
"the current list of leftover arguments, ie. arguments that have been "
"consumed but are neither options nor option arguments. Feel free to modify "
"``parser.largs``, e.g. by adding more arguments to it.  (This list will "
"become ``args``, the second return value of :meth:`parse_args`.)"
msgstr ""
"當前剩餘參數列表，即。已使用但既不是選項也不是選項參數的參數。隨意修改``parse"
"r.largs``，例如通過向其新增更多參數。 （此列表將成為 ``args``，即 "
":meth:`parse_args` 的第二個回傳值。）"

#: ../../library/optparse.rst:1670
msgid "``parser.rargs``"
msgstr "``parser.rargs``"

#: ../../library/optparse.rst:1667
#, fuzzy
msgid ""
"the current list of remaining arguments, ie. with ``opt_str`` and ``value`` "
"(if applicable) removed, and only the arguments following them still there.  "
"Feel free to modify ``parser.rargs``, e.g. by consuming more arguments."
msgstr ""
"當前剩餘參數列表，即。刪除了 ``opt_str`` 和 "
"``value``（如果適用），只有它們後面的參數仍然存在。隨意修改``parser."
"rargs``，例如通過消耗更多的參數。"

#: ../../library/optparse.rst:1677
msgid "``parser.values``"
msgstr "``parser.values``"

#: ../../library/optparse.rst:1673
#, fuzzy
msgid ""
"the object where option values are by default stored (an instance of "
"optparse.OptionValues).  This lets callbacks use the same mechanism as the "
"rest of :mod:`optparse` for storing option values; you don't need to mess "
"around with globals or closures.  You can also access or modify the value(s) "
"of any options already encountered on the command-line."
msgstr ""
"預設儲存選項值的物件（optparse.OptionValues 的一個實例）。這讓回呼使用與 "
"optparse 的其餘部分相同的機制來儲存選項值；您不需要弄亂全局變數或閉包。您還可"
"以訪問或修改命令列中已遇到的任何選項的值。"

#: ../../library/optparse.rst:1680
#, fuzzy
msgid ""
"is a tuple of arbitrary positional arguments supplied via the :attr:`~Option."
"callback_args` option attribute."
msgstr "是通過 :attr:`~Option.callback_args` 選項屬性提供的任意位置參數的元組。"

#: ../../library/optparse.rst:1686
msgid "``kwargs``"
msgstr "``kwargs``"

#: ../../library/optparse.rst:1684
#, fuzzy
msgid ""
"is a dictionary of arbitrary keyword arguments supplied via :attr:`~Option."
"callback_kwargs`."
msgstr "是通過 :attr:`~Option.callback_kwargs` 提供的任意關鍵字參數的字典。"

#: ../../library/optparse.rst:1691
#, fuzzy
msgid "Raising errors in a callback"
msgstr "在回呼中引發錯誤"

#: ../../library/optparse.rst:1693
#, fuzzy
msgid ""
"The callback function should raise :exc:`OptionValueError` if there are any "
"problems with the option or its argument(s).  :mod:`optparse` catches this "
"and terminates the program, printing the error message you supply to "
"stderr.  Your message should be clear, concise, accurate, and mention the "
"option at fault. Otherwise, the user will have a hard time figuring out what "
"they did wrong."
msgstr ""
"如果選項或其參數有任何問題，回呼函式應該引發 :exec:`OptionValueError`。 "
":mod:`optparse` 捕獲這個並終止程式，印出您提供給 stderr 的錯誤消息。您的資訊"
"應該清晰、簡潔、準確，並提及錯誤的選項。否則，使用者將很難找出他們做錯了什麼"
"。"

#: ../../library/optparse.rst:1703
#, fuzzy
msgid "Callback example 1: trivial callback"
msgstr "回呼示例 1：普通回呼"

#: ../../library/optparse.rst:1705
#, fuzzy
msgid ""
"Here's an example of a callback option that takes no arguments, and simply "
"records that the option was seen::"
msgstr "這是一個不帶參數的回呼選項的示例，它只是記錄該選項已被看到："

#: ../../library/optparse.rst:1713
#, fuzzy
msgid "Of course, you could do that with the ``\"store_true\"`` action."
msgstr "當然，您可以使用 ``\"store_true\"`` 操作來做到這一點。"

#: ../../library/optparse.rst:1719
#, fuzzy
msgid "Callback example 2: check option order"
msgstr "回呼示例2：查詢期權順序"

#: ../../library/optparse.rst:1721
#, fuzzy
msgid ""
"Here's a slightly more interesting example: record the fact that ``-a`` is "
"seen, but blow up if it comes after ``-b`` in the command-line.  ::"
msgstr "這裡有一個更有趣的例子：記錄看到 ``-a`` 的事實，但如果它在命令列中出現在 "
"``-b`` 之後，就爆炸。 ::"

#: ../../library/optparse.rst:1736
#, fuzzy
msgid "Callback example 3: check option order (generalized)"
msgstr "回呼示例 3：檢查選項順序（通用）"

#: ../../library/optparse.rst:1738
#, fuzzy
msgid ""
"If you want to re-use this callback for several similar options (set a flag, "
"but blow up if ``-b`` has already been seen), it needs a bit of work: the "
"error message and the flag that it sets must be generalized.  ::"
msgstr ""
"如果你想為幾個類似的選項重新使用這個回呼（設定一個旗標，但如果已經看到 ``-b``"
" 則爆炸），它需要一些工作：錯誤消息和它設定的旗標必須概括。 ::"

#: ../../library/optparse.rst:1755
#, fuzzy
msgid "Callback example 4: check arbitrary condition"
msgstr "回呼示例 4：檢查任意條件"

#: ../../library/optparse.rst:1757
#, fuzzy
msgid ""
"Of course, you could put any condition in there---you're not limited to "
"checking the values of already-defined options.  For example, if you have "
"options that should not be called when the moon is full, all you have to do "
"is this::"
msgstr "當然，您可以在其中放置任何條件——您不僅限於檢查已定義選項的值。例如，如果您有"
"在滿月時不應呼叫的選項，您所要做的就是："

#: ../../library/optparse.rst:1770
#, fuzzy
msgid ""
"(The definition of ``is_moon_full()`` is left as an exercise for the reader.)"
msgstr "（``is_moon_full()`` 的定義留給讀者作為練習。）"

#: ../../library/optparse.rst:1776
#, fuzzy
msgid "Callback example 5: fixed arguments"
msgstr "回呼示例 5：固定參數"

#: ../../library/optparse.rst:1778
#, fuzzy
msgid ""
"Things get slightly more interesting when you define callback options that "
"take a fixed number of arguments.  Specifying that a callback option takes "
"arguments is similar to defining a ``\"store\"`` or ``\"append\"`` option: "
"if you define :attr:`~Option.type`, then the option takes one argument that "
"must be convertible to that type; if you further define :attr:`~Option."
"nargs`, then the option takes :attr:`~Option.nargs` arguments."
msgstr ""
"當您定義採用固定數量參數的回呼選項時，事情會變得稍微有趣一些。指定回呼選項採"
"用參數類似於定義 ``store``或 ``append``選項：如果你定義 :attr:`~Option."
"type，那麼該選項採用一個必須的參數可轉換為該型別；如果您進一步定義 "
":attr:`~Option.nargs`，則該選項採用 :attr:`~Option.nargs` 參數。"

#: ../../library/optparse.rst:1785
#, fuzzy
msgid ""
"Here's an example that just emulates the standard ``\"store\"`` action::"
msgstr "這是一個模擬標準“儲存”操作的示例："

#: ../../library/optparse.rst:1794
#, fuzzy
msgid ""
"Note that :mod:`optparse` takes care of consuming 3 arguments and converting "
"them to integers for you; all you have to do is store them.  (Or whatever; "
"obviously you don't need a callback for this example.)"
msgstr "請注意 :mod:`optparse` 負責處理 3 "
"個參數並將它們轉換為整數；您所要做的就是儲存它們。 "
"（或其他；顯然您不需要此示例的回呼。）"

#: ../../library/optparse.rst:1802
#, fuzzy
msgid "Callback example 6: variable arguments"
msgstr "回呼示例 6：可變參數"

#: ../../library/optparse.rst:1804
#, fuzzy
msgid ""
"Things get hairy when you want an option to take a variable number of "
"arguments. For this case, you must write a callback, as :mod:`optparse` "
"doesn't provide any built-in capabilities for it.  And you have to deal with "
"certain intricacies of conventional Unix command-line parsing that :mod:"
"`optparse` normally handles for you.  In particular, callbacks should "
"implement the conventional rules for bare ``--`` and ``-`` arguments:"
msgstr ""
"當您希望一個選項接受可變數量的參數時，事情就變得棘手了。對於這種情況，您必須"
"編寫一個回呼，因為 :mod:`optparse` 沒有為它提供任何內建功能。而且您必須處理 "
":mod:`optparse` 通常為您處理的傳統 Unix "
"命令列解析的某些複雜問題。特別是，回呼應該為裸參數實作常規規則："

#: ../../library/optparse.rst:1811
#, fuzzy
msgid "either ``--`` or ``-`` can be option arguments"
msgstr "``--`` 或 ``-`` 可以是選項參數"

#: ../../library/optparse.rst:1813
#, fuzzy
msgid ""
"bare ``--`` (if not the argument to some option): halt command-line "
"processing and discard the ``--``"
msgstr "裸``--``（如果不是某些選項的參數）：停止命令列處理並丟棄``--``"

#: ../../library/optparse.rst:1816
#, fuzzy
msgid ""
"bare ``-`` (if not the argument to some option): halt command-line "
"processing but keep the ``-`` (append it to ``parser.largs``)"
msgstr "裸露的``-``（如果不是某些選項的參數）：停止命令列處理但保留``-``（將其附加到`"
"`parser.largs``）"

#: ../../library/optparse.rst:1819
#, fuzzy
msgid ""
"If you want an option that takes a variable number of arguments, there are "
"several subtle, tricky issues to worry about.  The exact implementation you "
"choose will be based on which trade-offs you're willing to make for your "
"application (which is why :mod:`optparse` doesn't support this sort of thing "
"directly)."
msgstr ""
"如果您想要一個帶有可變數量參數的選項，則需要擔心幾個微妙、棘手的問題。您選擇"
"的確切實作將基於您願意為您的應用程式做出哪些權衡（這就是為什麼 "
":mod:`optparse` 不直接支援這種事情）。"

#: ../../library/optparse.rst:1825
#, fuzzy
msgid ""
"Nevertheless, here's a stab at a callback for an option with variable "
"arguments::"
msgstr "然而，這裡有一個帶有可變參數的選項的回呼："

#: ../../library/optparse.rst:1859
#, fuzzy
msgid "Extending :mod:`optparse`"
msgstr "擴充 :mod:`optparse`"

#: ../../library/optparse.rst:1861
#, fuzzy
msgid ""
"Since the two major controlling factors in how :mod:`optparse` interprets "
"command-line options are the action and type of each option, the most likely "
"direction of extension is to add new actions and new types."
msgstr "由於 :mod:`optparse` 如何解釋命令列選項的兩個主要控制因素是每個選項的操作和型"
"別，因此最可能的擴充方向是新增新操作和新型別。"

#: ../../library/optparse.rst:1869
#, fuzzy
msgid "Adding new types"
msgstr "新增新型別"

#: ../../library/optparse.rst:1871
#, fuzzy
msgid ""
"To add new types, you need to define your own subclass of :mod:`optparse`'s :"
"class:`Option` class.  This class has a couple of attributes that define :"
"mod:`optparse`'s types: :attr:`~Option.TYPES` and :attr:`~Option."
"TYPE_CHECKER`."
msgstr ""
"要新增新型別，您需要定義自己的 :mod:`optparse` 的 :class:`Option` "
"類的子類別。這個類有幾個定義 :mod:`optparse` 型別的屬性：:attr:`~Option."
"TYPES` 和 :attr:`~Option.TYPE_CHECKER`。"

#: ../../library/optparse.rst:1877
#, fuzzy
msgid ""
"A tuple of type names; in your subclass, simply define a new tuple :attr:"
"`TYPES` that builds on the standard one."
msgstr "型別名稱的元組；在您的子類別中，只需定義一個基於標準元組的新元組 "
":attr:`TYPES`。"

#: ../../library/optparse.rst:1882
#, fuzzy
msgid ""
"A dictionary mapping type names to type-checking functions.  A type-checking "
"function has the following signature::"
msgstr "將型別名稱映射到型別檢查函式的字典。型別檢查函式具有以下簽名："

#: ../../library/optparse.rst:1887
#, fuzzy
msgid ""
"where ``option`` is an :class:`Option` instance, ``opt`` is an option string "
"(e.g., ``-f``), and ``value`` is the string from the command line that must "
"be checked and converted to your desired type.  ``check_mytype()`` should "
"return an object of the hypothetical type ``mytype``.  The value returned by "
"a type-checking function will wind up in the OptionValues instance returned "
"by :meth:`OptionParser.parse_args`, or be passed to a callback as the "
"``value`` parameter."
msgstr ""
"其中 ``option`` 是一個 Option 實例，``opt`` "
"是一個選項字串（例如，``-f``），``value`` "
"是來自命令列的字串必須檢查並轉換為您想要的型別。 ``check_mytype()`` "
"應該回傳一個假設型別為 ``mytype`` 的物件。型別檢查函式回傳的值將在 "
"OptionParser.parse_args 回傳的 OptionValues 實例中結束，或者作為 value "
"參數傳遞給回呼。"

#: ../../library/optparse.rst:1895
#, fuzzy
msgid ""
"Your type-checking function should raise :exc:`OptionValueError` if it "
"encounters any problems.  :exc:`OptionValueError` takes a single string "
"argument, which is passed as-is to :class:`OptionParser`'s :meth:`error` "
"method, which in turn prepends the program name and the string ``\"error:"
"\"`` and prints everything to stderr before terminating the process."
msgstr ""
"如果遇到任何問題，您的型別檢查函式應該引發 :exec:`OptionValueError`。 "
":exc:`OptionValueError` 採用單個字串參數，按原樣傳遞給 :class:`OptionParser` "
"的 :meth:`error` 方法，該方法依次將程式名稱和字串 ``\"error: \"`` "
"並在終止行程之前將所有內容印出到 stderr。"

#: ../../library/optparse.rst:1901
#, fuzzy
msgid ""
"Here's a silly example that demonstrates adding a ``\"complex\"`` option "
"type to parse Python-style complex numbers on the command line.  (This is "
"even sillier than it used to be, because :mod:`optparse` 1.3 added built-in "
"support for complex numbers, but never mind.)"
msgstr ""
"這是一個愚蠢的例子，它演示瞭如何在命令列上新增一個 ``complex`` 選項型別來解析 "
"Python 風格的複數。 （這甚至比以前更愚蠢，因為 :mod:`optparse` 1.3 "
"新增了對複數的內建支援，但沒關係。）"

#: ../../library/optparse.rst:1906
#, fuzzy
msgid "First, the necessary imports::"
msgstr "首先，必要的進口::"

#: ../../library/optparse.rst:1911
#, fuzzy
msgid ""
"You need to define your type-checker first, since it's referred to later (in "
"the :attr:`~Option.TYPE_CHECKER` class attribute of your Option subclass)::"
msgstr "您需要先定義型別檢查器，因為稍後會引用它（在 Option 子類別的 :attr:`~Option."
"TYPE_CHECKER` 類屬性中）："

#: ../../library/optparse.rst:1921
#, fuzzy
msgid "Finally, the Option subclass::"
msgstr "最後，選項子類別::"

#: ../../library/optparse.rst:1928
#, fuzzy
msgid ""
"(If we didn't make a :func:`copy` of :attr:`Option.TYPE_CHECKER`, we would "
"end up modifying the :attr:`~Option.TYPE_CHECKER` attribute of :mod:"
"`optparse`'s Option class.  This being Python, nothing stops you from doing "
"that except good manners and common sense.)"
msgstr ""
"（如果我們不復制 :attr:`Option.TYPE_CHECKER` 的 :func:`copy`，我們最終會修改 "
":attr:`~Option.TYPE_CHECKER` 的 :mod:`optparse` 選項的屬性類。這是 "
"Python，除了良好的舉止和常識，沒有什麼能阻止你這樣做。）"

#: ../../library/optparse.rst:1933
#, fuzzy
msgid ""
"That's it!  Now you can write a script that uses the new option type just "
"like any other :mod:`optparse`\\ -based script, except you have to instruct "
"your OptionParser to use MyOption instead of Option::"
msgstr ""
"就是這樣！現在你可以編寫一個使用新選項型別的腳本，就像任何其他基於 "
":mod:`optparse`\\ 的腳本一樣，除了你必須指示你的 OptionParser 使用 MyOption "
"而不是 Option::"

#: ../../library/optparse.rst:1940
#, fuzzy
msgid ""
"Alternately, you can build your own option list and pass it to OptionParser; "
"if you don't use :meth:`add_option` in the above way, you don't need to tell "
"OptionParser which option class to use::"
msgstr ""
"或者，您可以構建自己的選項列表並將其傳遞給 OptionParser；"
"如果您不按上述方式使用 add_option ，則無需告訴 OptionParser "
"要使用哪個選項類::"

#: ../../library/optparse.rst:1951
#, fuzzy
msgid "Adding new actions"
msgstr "新增新動作"

#: ../../library/optparse.rst:1953
#, fuzzy
msgid ""
"Adding new actions is a bit trickier, because you have to understand that :"
"mod:`optparse` has a couple of classifications for actions:"
msgstr "新增新動作有點棘手，因為您必須了解 :mod:`optparse` 有幾個動作分類："

#: ../../library/optparse.rst:1959
#, fuzzy
msgid "\"store\" actions"
msgstr "“儲存”動作"

#: ../../library/optparse.rst:1957
#, fuzzy
msgid ""
"actions that result in :mod:`optparse` storing a value to an attribute of "
"the current OptionValues instance; these options require a :attr:`~Option."
"dest` attribute to be supplied to the Option constructor."
msgstr ""
"導致 optparse 將值儲存到當前 OptionValues 實例的屬性的操作；"
"這些選項需要將一個 :attr:`~Option.dest` 屬性提供給 Option 構造函式。"

#: ../../library/optparse.rst:1965
#, fuzzy
msgid "\"typed\" actions"
msgstr "“輸入”動作"

#: ../../library/optparse.rst:1962
#, fuzzy
msgid ""
"actions that take a value from the command line and expect it to be of a "
"certain type; or rather, a string that can be converted to a certain type. "
"These options require a :attr:`~Option.type` attribute to the Option "
"constructor."
msgstr ""
"從命令列獲取值並期望它是某種型別的操作；或者更確切地說，一個可以轉換為特定型"
"別的字串。這些選項需要 Option 構造函式的 :attr:`~Option.type` 屬性。"

#: ../../library/optparse.rst:1967
#, fuzzy
msgid ""
"These are overlapping sets: some default \"store\" actions are "
"``\"store\"``, ``\"store_const\"``, ``\"append\"``, and ``\"count\"``, while "
"the default \"typed\" actions are ``\"store\"``, ``\"append\"``, and "
"``\"callback\"``."
msgstr ""
"這些是重疊的集合：一些預設的“儲存”操作是“儲存”、“儲存常數”、“追加”和“計數”，"
"而預設的“型別化” \" 動作是 ``\"store\"``、``\"append\"`` 和 ``\"callback\""
"``。"

#: ../../library/optparse.rst:1971
#, fuzzy
msgid ""
"When you add an action, you need to categorize it by listing it in at least "
"one of the following class attributes of Option (all are lists of strings):"
msgstr "當你新增一個動作時，你需要通過將它至少列在 Option "
"的以下類屬性之一中來對其進行分類（都是字串列表）："

#: ../../library/optparse.rst:1976
#, fuzzy
msgid "All actions must be listed in ACTIONS."
msgstr "所有操作都必須在 ACTIONS 中列出。"

#: ../../library/optparse.rst:1980
#, fuzzy
msgid "\"store\" actions are additionally listed here."
msgstr "“儲存”操作在此處另外列出。"

#: ../../library/optparse.rst:1984
#, fuzzy
msgid "\"typed\" actions are additionally listed here."
msgstr "“鍵入的”操作在此處另外列出。"

#: ../../library/optparse.rst:1988
#, fuzzy
msgid ""
"Actions that always take a type (i.e. whose options always take a value) are "
"additionally listed here.  The only effect of this is that :mod:`optparse` "
"assigns the default type, ``\"string\"``, to options with no explicit type "
"whose action is listed in :attr:`ALWAYS_TYPED_ACTIONS`."
msgstr ""
"始終採用型別（即其選項始終採用值）的操作在此處另外列出。這樣做的唯一影響是 "
":mod:`optparse` 將預設型別 ``\"string\"`` 分配給沒有顯式型別的選項，其操作在 "
":attr:`ALWAYS_TYPED_ACTIONS` 中列出。"

#: ../../library/optparse.rst:1993
#, fuzzy
msgid ""
"In order to actually implement your new action, you must override Option's :"
"meth:`take_action` method and add a case that recognizes your action."
msgstr "為了實際實施您的新操作，您必須覆蓋 Option 的 :meth:`take_action` "
"方法並新增一個可識別您的操作的案例。"

#: ../../library/optparse.rst:1996
#, fuzzy
msgid ""
"For example, let's add an ``\"extend\"`` action.  This is similar to the "
"standard ``\"append\"`` action, but instead of taking a single value from "
"the command-line and appending it to an existing list, ``\"extend\"`` will "
"take multiple values in a single comma-delimited string, and extend an "
"existing list with them.  That is, if ``--names`` is an ``\"extend\"`` "
"option of type ``\"string\"``, the command line ::"
msgstr ""
"例如，讓我們新增一個 ``\"extend\"`` 動作。這類似於標準的 ``\"append\"`` "
"操作，但不是從命令列獲取單個值並將其附加到現有列表，``\"extend\"`` 將在單個逗"
"號中獲取多個值-分隔的字串，並用它們擴充現有列表。也就是說，如果``--names`` "
"是型別為``\"string\"`` 的``\"extend\"`` 選項，則命令列::"

#: ../../library/optparse.rst:2005
#, fuzzy
msgid "would result in a list  ::"
msgstr "將產生一個列表 ::"

#: ../../library/optparse.rst:2009
#, fuzzy
msgid "Again we define a subclass of Option::"
msgstr "我們再次定義 Option:: 的子類別"

#: ../../library/optparse.rst:2026
#, fuzzy
msgid "Features of note:"
msgstr "備註特點："

#: ../../library/optparse.rst:2028
#, fuzzy
msgid ""
"``\"extend\"`` both expects a value on the command-line and stores that "
"value somewhere, so it goes in both :attr:`~Option.STORE_ACTIONS` and :attr:"
"`~Option.TYPED_ACTIONS`."
msgstr ""
"``\"extend\"`` "
"都需要命令列上的值並將該值儲存在某處，因此它同時出現在 :attr:`~Option."
"STORE_ACTIONS` 和 :attr:`~Option.TYPED_ACTIONS` 中。"

#: ../../library/optparse.rst:2032
#, fuzzy
msgid ""
"to ensure that :mod:`optparse` assigns the default type of ``\"string\"`` to "
"``\"extend\"`` actions, we put the ``\"extend\"`` action in :attr:`~Option."
"ALWAYS_TYPED_ACTIONS` as well."
msgstr ""
"為了確保 :mod:`optparse` 將預設型別 ``\"string\"`` 分配給 ``\"extend\"`` "
"操作，我們將 ``\"extend\"`` 操作放在 :attr:`~Option 中。 "
"ALWAYS_TYPED_ACTIONS` 也是如此。"

#: ../../library/optparse.rst:2036
#, fuzzy
msgid ""
":meth:`MyOption.take_action` implements just this one new action, and passes "
"control back to :meth:`Option.take_action` for the standard :mod:`optparse` "
"actions."
msgstr ""
":meth:`MyOption.take_action` 僅實作這一新操作，並將控制權交還給 :meth:`Option"
".take_action` 以執行標準 :mod:`optparse` 操作。"

#: ../../library/optparse.rst:2040
#, fuzzy
msgid ""
"``values`` is an instance of the optparse_parser.Values class, which "
"provides the very useful :meth:`ensure_value` method. :meth:`ensure_value` "
"is essentially :func:`getattr` with a safety valve; it is called as ::"
msgstr ""
"``values`` 是 optparse_parser.Values 類的一個實例，它提供了非常有用的 "
":meth:`ensure_value` 方法。 :meth:`ensure_value` 本質上是帶有安全閥的 "
":func:`getattr`；它被稱為 ::"

#: ../../library/optparse.rst:2046
#, fuzzy
msgid ""
"If the ``attr`` attribute of ``values`` doesn't exist or is ``None``, then "
"ensure_value() first sets it to ``value``, and then returns 'value. This is "
"very handy for actions like ``\"extend\"``, ``\"append\"``, and "
"``\"count\"``, all of which accumulate data in a variable and expect that "
"variable to be of a certain type (a list for the first two, an integer for "
"the latter).  Using :meth:`ensure_value` means that scripts using your "
"action don't have to worry about setting a default value for the option "
"destinations in question; they can just leave the default as ``None`` and :"
"meth:`ensure_value` will take care of getting it right when it's needed."
msgstr ""
"如果 ``values`` 的 ``attr`` 屬性不存在或為 ``None``，則 ensure_value() "
"首先將其設定為 ``value``，然後回傳 \\'value。這對於像``\"extend\"``、``"
"\"append\"`` 和``\"count\"`` 這樣的操作非常方便，所有這些操作都在變數中累積資"
"料並期望該變數是某種型別（前兩個的列表，後者的整數）。使用 "
":meth:`ensure_value` "
"意味著使用您的操作的腳本不必擔心為相關選項目標設定預設值；"
"他們可以將預設值保留為 ``None`` 並且 :meth:`ensure_value` "
"將在需要時處理好它。"

#: ../../library/optparse.rst:2057
#, fuzzy
msgid "Exceptions"
msgstr "例外情況"

#: ../../library/optparse.rst:2061
#, fuzzy
msgid ""
"Raised if an :class:`Option` instance is created with invalid or "
"inconsistent arguments."
msgstr "如果 :class:`Option` 實例是使用無效或不一致的參數建立的，則引發。"

#: ../../library/optparse.rst:2066
#, fuzzy
msgid "Raised if conflicting options are added to an :class:`OptionParser`."
msgstr "如果將衝突的選項新增到 OptionParser 則引發。"

#: ../../library/optparse.rst:2070
#, fuzzy
msgid "Raised if an invalid option value is encountered on the command line."
msgstr "如果在命令列上遇到無效的選項值，則引發。"

#: ../../library/optparse.rst:2074
#, fuzzy
msgid "Raised if an invalid option is passed on the command line."
msgstr "如果在命令列上傳遞了無效選項，則引發。"

#: ../../library/optparse.rst:2078
#, fuzzy
msgid "Raised if an ambiguous option is passed on the command line."
msgstr "如果在命令列上傳遞了不明確的選項，則引發。"
