# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Leon H., 2017
# Adrian Liaw <adrianliaw2000@gmail.com>, 2018
# Matt Wang <mattwang44@gmail.com>, 2021
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-17 00:16+0000\n"
"PO-Revision-Date: 2022-06-12 15:22+0800\n"
"Last-Translator: Matt Wang <mattwang44@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.1\n"

#: ../../library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "內建型別"

#: ../../library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr "以下章節描述了直譯器中内建的標準型別。"

#: ../../library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr "主要內建型別為數字、序列、映射、class（類別）、實例和例外。"

#: ../../library/stdtypes.rst:18
msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never "
"return the collection instance itself but ``None``."
msgstr ""
"有些集合類別是 mutable（可變的）。那些用於原地 (in-place) 加入、移除或重新排"
"列其成員且不回傳特定項的 method（方法），也只會回傳 ``None`` 而非集合實例自"
"己。"

#: ../../library/stdtypes.rst:22
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared for equality, tested for truth "
"value, and converted to a string (with the :func:`repr` function or the "
"slightly different :func:`str` function).  The latter function is implicitly "
"used when an object is written by the :func:`print` function."
msgstr ""
"某些操作已被多種物件型別支援；特別是實務上所有物件都已經可以做相等性比較、真"
"值檢測及被轉換為字串（使用 :func:`repr` 函式或稍有差異的 :func:`str` 函式），"
"後者為當物件傳入 :func:`print` 函式印出時在背後被調用的函式。"

#: ../../library/stdtypes.rst:32
msgid "Truth Value Testing"
msgstr "真值檢測"

#: ../../library/stdtypes.rst:41
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or :"
"keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"任何物件都可以進行檢測以判斷是否為真值，以便在 :keyword:`if` 或 :keyword:"
"`while` 條件中使用，或是作為如下所述 boolean（布林）運算之運算元所用。"

#: ../../library/stdtypes.rst:46
msgid ""
"By default, an object is considered true unless its class defines either a :"
"meth:`__bool__` method that returns ``False`` or a :meth:`__len__` method "
"that returns zero, when called with the object. [1]_  Here are most of the "
"built-in objects considered false:"
msgstr ""
"預設情況下，一個物件會被視為真值，除非它的 class 定義了會回傳 ``False`` 的 :"
"meth:`__bool__` method 或是定義了會回傳零的 :meth:`__len__` method。[1]_ 以下"
"列出了大部分會被視為 false 的內建物件："

#: ../../library/stdtypes.rst:55
msgid "constants defined to be false: ``None`` and ``False``."
msgstr "定義為 false 之常數：``None`` 與 ``False``。"

#: ../../library/stdtypes.rst:57
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr ""
"任何數值型別的零：``0``、``0.0``、``0j``、``Decimal(0)``、``Fraction(0, 1)``"

#: ../../library/stdtypes.rst:60
msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"
msgstr ""
"空的序列和集合：``''``、``()``、``[]``、``{}``、``set()``、``range(0)``"

#: ../../library/stdtypes.rst:69
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"除非另有特別說明，產生 boolean 結果的操作或內建函式都會回傳 ``0`` 或 "
"``False`` 作為假值、``1`` 或 ``True`` 作為真值。（重要例外： boolean 運算 "
"``or`` 和 ``and`` 回傳的是其中一個運算元。）"

#: ../../library/stdtypes.rst:78
#, fuzzy
msgid "Boolean Operations --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"
msgstr "布爾運算 --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"

#: ../../library/stdtypes.rst:82
#, fuzzy
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "這些是布爾運算，按優先級升序排列："

#: ../../library/stdtypes.rst:85 ../../library/stdtypes.rst:143
#: ../../library/stdtypes.rst:275 ../../library/stdtypes.rst:363
#: ../../library/stdtypes.rst:413 ../../library/stdtypes.rst:922
#: ../../library/stdtypes.rst:1127
#, fuzzy
msgid "Operation"
msgstr "手術"

#: ../../library/stdtypes.rst:85 ../../library/stdtypes.rst:275
#: ../../library/stdtypes.rst:363 ../../library/stdtypes.rst:413
#: ../../library/stdtypes.rst:922 ../../library/stdtypes.rst:1127
msgid "Result"
msgstr "結果"

#: ../../library/stdtypes.rst:85 ../../library/stdtypes.rst:275
#: ../../library/stdtypes.rst:413 ../../library/stdtypes.rst:922
#: ../../library/stdtypes.rst:1127 ../../library/stdtypes.rst:2372
#: ../../library/stdtypes.rst:3590
msgid "Notes"
msgstr "註解"

#: ../../library/stdtypes.rst:87
msgid "``x or y``"
msgstr "``x or y``"

#: ../../library/stdtypes.rst:87
#, fuzzy
msgid "if *x* is true, then *x*, else *y*"
msgstr "如果 *x* 為真，則 *x*，否則 *y*"

#: ../../library/stdtypes.rst:87 ../../library/stdtypes.rst:285
#: ../../library/stdtypes.rst:924 ../../library/stdtypes.rst:927
#: ../../library/stdtypes.rst:1138 ../../library/stdtypes.rst:2378
#: ../../library/stdtypes.rst:3596
msgid "\\(1)"
msgstr "\\(1)"

#: ../../library/stdtypes.rst:90
msgid "``x and y``"
msgstr "``x and y``"

#: ../../library/stdtypes.rst:90
#, fuzzy
msgid "if *x* is false, then *x*, else *y*"
msgstr "如果 *x* 為假，則 *x*，否則 *y*"

#: ../../library/stdtypes.rst:90 ../../library/stdtypes.rst:288
#: ../../library/stdtypes.rst:308 ../../library/stdtypes.rst:1166
#: ../../library/stdtypes.rst:2382 ../../library/stdtypes.rst:2384
#: ../../library/stdtypes.rst:3600 ../../library/stdtypes.rst:3602
msgid "\\(2)"
msgstr "\\(2)"

#: ../../library/stdtypes.rst:93
msgid "``not x``"
msgstr "``not x``"

#: ../../library/stdtypes.rst:93
#, fuzzy
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "如果 *x* 為假，則為 ``True``，否則為 ``False``"

#: ../../library/stdtypes.rst:93 ../../library/stdtypes.rst:936
#: ../../library/stdtypes.rst:1169 ../../library/stdtypes.rst:2386
#: ../../library/stdtypes.rst:2388 ../../library/stdtypes.rst:2390
#: ../../library/stdtypes.rst:2392 ../../library/stdtypes.rst:3604
#: ../../library/stdtypes.rst:3606 ../../library/stdtypes.rst:3608
#: ../../library/stdtypes.rst:3610
msgid "\\(3)"
msgstr "\\(3)"

#: ../../library/stdtypes.rst:102 ../../library/stdtypes.rst:319
#: ../../library/stdtypes.rst:431 ../../library/stdtypes.rst:973
#: ../../library/stdtypes.rst:1177 ../../library/stdtypes.rst:2418
#: ../../library/stdtypes.rst:3640
msgid "Notes:"
msgstr "註解："

#: ../../library/stdtypes.rst:105
#, fuzzy
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr "這是一個短路運算符，因此它僅在第一個參數為假時才計算第二個參數。"

#: ../../library/stdtypes.rst:109
#, fuzzy
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr "這是一個短路運算符，因此它僅在第一個參數為真時才計算第二個參數。"

#: ../../library/stdtypes.rst:113
#, fuzzy
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"``not`` 的優先級低於非布爾運算符，因此 ``not a == b`` 被解釋為 ``not (a == "
"b)``，而 ``a == not b``是語法錯誤。"

#: ../../library/stdtypes.rst:120
#, fuzzy
msgid "Comparisons"
msgstr "比較"

#: ../../library/stdtypes.rst:134
#, fuzzy
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x "
"< y and y <= z``, except that *y* is evaluated only once (but in both cases "
"*z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"Python 中有八種比較操作。它們都具有相同的優先級（高於布爾運算的優先級）。比較"
"可以任意鏈接；例如，``x < y <= z`` 等同於 ``x < y and y <= z``，除了 *y* "
"只計算一次（但在這兩種情況下，*z* 都不會在所有當 ``x < y`` 被發現為假時）。"

#: ../../library/stdtypes.rst:140
#, fuzzy
msgid "This table summarizes the comparison operations:"
msgstr "下表總結了比較操作："

#: ../../library/stdtypes.rst:143 ../../library/stdtypes.rst:2349
#: ../../library/stdtypes.rst:2372 ../../library/stdtypes.rst:3567
#: ../../library/stdtypes.rst:3590
#, fuzzy
msgid "Meaning"
msgstr "意義"

#: ../../library/stdtypes.rst:145
msgid "``<``"
msgstr "``<``"

#: ../../library/stdtypes.rst:145
#, fuzzy
msgid "strictly less than"
msgstr "嚴格小於"

#: ../../library/stdtypes.rst:147
msgid "``<=``"
msgstr "``<=``"

#: ../../library/stdtypes.rst:147
#, fuzzy
msgid "less than or equal"
msgstr "小於或等於"

#: ../../library/stdtypes.rst:149
msgid "``>``"
msgstr "``>``"

#: ../../library/stdtypes.rst:149
#, fuzzy
msgid "strictly greater than"
msgstr "嚴格大於"

#: ../../library/stdtypes.rst:151
msgid "``>=``"
msgstr "``>=``"

#: ../../library/stdtypes.rst:151
#, fuzzy
msgid "greater than or equal"
msgstr "大於或等於"

#: ../../library/stdtypes.rst:153
msgid "``==``"
msgstr "``==``"

#: ../../library/stdtypes.rst:153
#, fuzzy
msgid "equal"
msgstr "平等的"

#: ../../library/stdtypes.rst:155
msgid "``!=``"
msgstr "``!=``"

#: ../../library/stdtypes.rst:155
#, fuzzy
msgid "not equal"
msgstr "不等於"

#: ../../library/stdtypes.rst:157
msgid "``is``"
msgstr "``is``"

#: ../../library/stdtypes.rst:157
#, fuzzy
msgid "object identity"
msgstr "物件標識"

#: ../../library/stdtypes.rst:159
msgid "``is not``"
msgstr "``is not``"

#: ../../library/stdtypes.rst:159
#, fuzzy
msgid "negated object identity"
msgstr "否定物件身份"

#: ../../library/stdtypes.rst:166
#, fuzzy
msgid ""
"Objects of different types, except different numeric types, never compare "
"equal. The ``==`` operator is always defined but for some object types (for "
"example, class objects) is equivalent to :keyword:`is`. The ``<``, ``<=``, "
"``>`` and ``>=`` operators are only defined where they make sense; for "
"example, they raise a :exc:`TypeError` exception when one of the arguments "
"is a complex number."
msgstr ""
"不同型別的物件，除了不同的數字型別，永遠不會比較相等。 ``==`` "
"運算符始終被定義，但對於某些對像型別（例如，類物件）等同於 :keyword:`is`。 "
"``<``、``<=``、``>`` 和 ``>=`` "
"運算符只在它們有意義的地方定義；例如，當其中一個參數是複數時，它們會引發 "
":exc:`TypeError` 例外。"

#: ../../library/stdtypes.rst:180
#, fuzzy
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`~object.__eq__` method."
msgstr "一個類的不同實例通常比較為不相等，除非該類定義了 :meth:`~object.__eq__` "
"方法。"

#: ../../library/stdtypes.rst:183
#, fuzzy
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines enough of "
"the methods :meth:`~object.__lt__`, :meth:`~object.__le__`, :meth:`~object."
"__gt__`, and :meth:`~object.__ge__` (in general, :meth:`~object.__lt__` and :"
"meth:`~object.__eq__` are sufficient, if you want the conventional meanings "
"of the comparison operators)."
msgstr ""
"一個類的實例不能相對於同一類的其他實例或其他型別的物件進行排序，"
"除非該類定義了足夠多的方法 :meth:`~object.__lt__`, :meth:`~object.__le__` , "
":meth:`~object.__gt__` 和 :meth:`~object.__ge__` （一般來說， :meth:`~object."
"__lt__` 和 :meth:`~object.__eq__` "
"就足夠了，如果你想的話比較運算符的常規含義）。"

#: ../../library/stdtypes.rst:190
#, fuzzy
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ":keyword:`is` 和 :keyword:`is not` "
"運算符的行為無法自定義；它們也可以應用於任何兩個物件並且永遠不會引發例外。"

#: ../../library/stdtypes.rst:198
#, fuzzy
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and :"
"keyword:`not in`, are supported by types that are :term:`iterable` or "
"implement the :meth:`__contains__` method."
msgstr ""
"具有相同句法優先級的另外兩個操作，:keyword:`in` 和 :keyword:`not in`，由 "
":term:`iterable` 型別或實作 :meth:`__contains__` 方法的型別支援。"

#: ../../library/stdtypes.rst:205
#, fuzzy
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "數值型別 --- :class:`int`, :class:`float`, :class:`complex`"

#: ../../library/stdtypes.rst:215
#, fuzzy
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating "
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating point "
"numbers are usually implemented using :c:expr:`double` in C; information "
"about the precision and internal representation of floating point numbers "
"for the machine on which your program is running is available in :data:`sys."
"float_info`.  Complex numbers have a real and imaginary part, which are each "
"a floating point number.  To extract these parts from a complex number *z*, "
"use ``z.real`` and ``z.imag``. (The standard library includes the additional "
"numeric types :mod:`fractions.Fraction`, for rationals, and :mod:`decimal."
"Decimal`, for floating-point numbers with user-definable precision.)"
msgstr ""
"共有三種不同的數字型別：整數、浮點數和復數。此外，布爾值是整數的一個子型別。"
"整數具有無限精度。浮點數通常使用 C 中的 :c:expr:`double` "
"實作；有關運行程式的機器的浮點數精度和內部表示的資訊，請參見 :data:`sys."
"float_info`。複數具有實部和虛部，每個都是浮點數。要從復數 *z* "
"中提取這些部分，請使用 ``z.real`` 和 ``z.imag``。 "
"（標準庫包括額外的數值型別 :mod:`fractions."
"Fraction`，用於有理數，和 :mod:`decimal."
"Decimal`，用於具有使用者可定義精度的浮點數。）"

#: ../../library/stdtypes.rst:237
#, fuzzy
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers.  Numeric literals containing a decimal "
"point or an exponent sign yield floating point numbers.  Appending ``'j'`` "
"or ``'J'`` to a numeric literal yields an imaginary number (a complex number "
"with a zero real part) which you can add to an integer or float to get a "
"complex number with real and imaginary parts."
msgstr ""
"數字是由數字文字建立的，或者是內建函式和運算符的結果。樸素的整數文字（包括十"
"六進位、八進位和二進位數）產生整數。包含小數點或指數符號的數字文字產生浮點數"
"。將 ``'j'`` 或 ``'J'`` 附加到數字文字會產生一個虛數（實數部分為零的複數），"
"您可以將其新增到整數或浮點數以獲得實數的複數和虛部。"

#: ../../library/stdtypes.rst:262
#, fuzzy
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where integer is narrower than "
"floating point, which is narrower than complex. A comparison between numbers "
"of different types behaves as though the exact values of those numbers were "
"being compared. [2]_"
msgstr ""
"Python 完全支援混合算術：當一個二元算術運算符具有不同數值型別的操作數時，具有"
"“較窄”型別的操作數被擴大到另一個，其中整數比浮點數窄，浮點數比複數窄。不同型"
"別的數字之間的比較表現得好像正在比較這些數字的確切值。 [2]_"

#: ../../library/stdtypes.rst:268
#, fuzzy
msgid ""
"The constructors :func:`int`, :func:`float`, and :func:`complex` can be used "
"to produce numbers of a specific type."
msgstr "構造函式 :func:`int`、:func:`float` 和 :func:`complex` "
"可用於生成特定型別的數字。"

#: ../../library/stdtypes.rst:271
#, fuzzy
msgid ""
"All numeric types (except complex) support the following operations (for "
"priorities of the operations, see :ref:`operator-summary`):"
msgstr "所有數字型別（複數除外）都支援以下操作（有關操作的優先級，請參閱：ref"
"：`operator-summary`）："

#: ../../library/stdtypes.rst:275
#, fuzzy
msgid "Full documentation"
msgstr "完整文檔"

#: ../../library/stdtypes.rst:277
msgid "``x + y``"
msgstr "``x + y``"

#: ../../library/stdtypes.rst:277
#, fuzzy
msgid "sum of *x* and *y*"
msgstr "*x* 和 *y* 的總和"

#: ../../library/stdtypes.rst:279
msgid "``x - y``"
msgstr "``x - y``"

#: ../../library/stdtypes.rst:279
#, fuzzy
msgid "difference of *x* and *y*"
msgstr "*x* 和 *y* 的區別"

#: ../../library/stdtypes.rst:281
msgid "``x * y``"
msgstr "``x * y``"

#: ../../library/stdtypes.rst:281
#, fuzzy
msgid "product of *x* and *y*"
msgstr "*x* 和 *y* 的乘積"

#: ../../library/stdtypes.rst:283
msgid "``x / y``"
msgstr "``x / y``"

#: ../../library/stdtypes.rst:283
#, fuzzy
msgid "quotient of *x* and *y*"
msgstr "*x* 和 *y* 的商"

#: ../../library/stdtypes.rst:285
msgid "``x // y``"
msgstr "``x // y``"

#: ../../library/stdtypes.rst:285
#, fuzzy
msgid "floored quotient of *x* and *y*"
msgstr "*x* 和 *y* 的底商"

#: ../../library/stdtypes.rst:288
msgid "``x % y``"
msgstr "``x % y``"

#: ../../library/stdtypes.rst:288
#, fuzzy
msgid "remainder of ``x / y``"
msgstr "``x / y`` 的餘數"

#: ../../library/stdtypes.rst:290
msgid "``-x``"
msgstr "``-x``"

#: ../../library/stdtypes.rst:290
#, fuzzy
msgid "*x* negated"
msgstr "*x* 否定"

#: ../../library/stdtypes.rst:292
msgid "``+x``"
msgstr "``+x``"

#: ../../library/stdtypes.rst:292
#, fuzzy
msgid "*x* unchanged"
msgstr "*x* 不變"

#: ../../library/stdtypes.rst:294
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: ../../library/stdtypes.rst:294
#, fuzzy
msgid "absolute value or magnitude of *x*"
msgstr "*x* 的絕對值或大小"

#: ../../library/stdtypes.rst:294
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../../library/stdtypes.rst:297
msgid "``int(x)``"
msgstr "``int(x)``"

#: ../../library/stdtypes.rst:297
#, fuzzy
msgid "*x* converted to integer"
msgstr "*x* 轉換為整數"

#: ../../library/stdtypes.rst:297
msgid "\\(3)\\(6)"
msgstr "\\(3)\\(6)"

#: ../../library/stdtypes.rst:297
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../../library/stdtypes.rst:299
msgid "``float(x)``"
msgstr "``float(x)``"

#: ../../library/stdtypes.rst:299
#, fuzzy
msgid "*x* converted to floating point"
msgstr "*x* 轉換為浮點數"

#: ../../library/stdtypes.rst:299
msgid "\\(4)\\(6)"
msgstr "\\(4)\\(6)"

#: ../../library/stdtypes.rst:299
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../../library/stdtypes.rst:301
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: ../../library/stdtypes.rst:301
#, fuzzy
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr "實部 *re*、虛部 *im* 的複數。 *im* 預設為零。"

#: ../../library/stdtypes.rst:301 ../../library/stdtypes.rst:1159
#: ../../library/stdtypes.rst:2380 ../../library/stdtypes.rst:3627
msgid "\\(6)"
msgstr "\\(6)"

#: ../../library/stdtypes.rst:301
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../../library/stdtypes.rst:305
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: ../../library/stdtypes.rst:305
#, fuzzy
msgid "conjugate of the complex number *c*"
msgstr "複數的共軛 *c*"

#: ../../library/stdtypes.rst:308
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../../library/stdtypes.rst:308
#, fuzzy
msgid "the pair ``(x // y, x % y)``"
msgstr "這對``(x // y, x % y)``"

#: ../../library/stdtypes.rst:308
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../../library/stdtypes.rst:310
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: ../../library/stdtypes.rst:310 ../../library/stdtypes.rst:312
#, fuzzy
msgid "*x* to the power *y*"
msgstr "*x* 的 *y* 次方"

#: ../../library/stdtypes.rst:310 ../../library/stdtypes.rst:312
#: ../../library/stdtypes.rst:1148 ../../library/stdtypes.rst:1151
#: ../../library/stdtypes.rst:2405 ../../library/stdtypes.rst:2408
#: ../../library/stdtypes.rst:2411 ../../library/stdtypes.rst:3623
#: ../../library/stdtypes.rst:3630
msgid "\\(5)"
msgstr "\\(5)"

#: ../../library/stdtypes.rst:310
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../../library/stdtypes.rst:312
msgid "``x ** y``"
msgstr "``x ** y``"

#: ../../library/stdtypes.rst:322
#, fuzzy
msgid ""
"Also referred to as integer division.  The resultant value is a whole "
"integer, though the result's type is not necessarily int.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""
"也稱為整數除法。結果值是一個整數，儘管結果的型別不一定是 "
"int。結果總是向負無窮大捨入：``1//2`` 是 ``0``，``(-1)//2`` 是 ``-1``，``1/"
"/(- 2)``是``-1``，``(-1)//(-2)``是``0``。"

#: ../../library/stdtypes.rst:328
#, fuzzy
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr "不適用於復數。如果合適，請使用 :func:`abs` 轉換為浮點數。"

#: ../../library/stdtypes.rst:339
#, fuzzy
msgid ""
"Conversion from :class:`float` to :class:`int` truncates, discarding the "
"fractional part. See functions :func:`math.floor` and :func:`math.ceil` for "
"alternative conversions."
msgstr ""
"從 :class:`float` 到 :class:`int` 的轉換會截斷，丟棄小數部分。請參閱函式 "
":func:`math.floor` 和 :func:`math.ceil` 以了解替代轉換。"

#: ../../library/stdtypes.rst:344
#, fuzzy
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr "float 還接受帶有可選前綴 ``+``或 ``-``的字串 ``nan``和 ``inf``，表示非數字 (NaN) "
"和正無窮大或負無窮大。"

#: ../../library/stdtypes.rst:348
#, fuzzy
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr "Python 將 ``pow(0, 0)`` 和 ``0 ** 0`` 定義為 ``1``，這在編程語言中很常見。"

#: ../../library/stdtypes.rst:352
#, fuzzy
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr "接受的數字文字包括數字 ``0``到 ``9``或任何 Unicode "
"等價物（具有 ``Nd``屬性的程式碼點）。"

#: ../../library/stdtypes.rst:355
#, fuzzy
msgid ""
"See https://www.unicode.org/Public/14.0.0/ucd/extracted/DerivedNumericType."
"txt for a complete list of code points with the ``Nd`` property."
msgstr ""
"有關具有 ``Nd``屬性的程式碼點的完整列表，請參閱 https://www.unicode.org/Public/"
"14.0.0/ucd/extracted/DerivedNumericType.txt。"

#: ../../library/stdtypes.rst:359
#, fuzzy
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr "所有 numbers.Real 型別（int 和 float）還包括以下操作："

#: ../../library/stdtypes.rst:365
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: ../../library/stdtypes.rst:365
#, fuzzy
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* 截斷為 :class:`~numbers.Integral`"

#: ../../library/stdtypes.rst:368
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: ../../library/stdtypes.rst:368
#, fuzzy
msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it "
"defaults to 0."
msgstr "*x* 四捨五入為 *n* 位，四捨五入為偶數。如果省略 *n*，則預設為 0。"

#: ../../library/stdtypes.rst:372
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: ../../library/stdtypes.rst:372
#, fuzzy
msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "最偉大的 :class:`~numbers.Integral` <= *x*"

#: ../../library/stdtypes.rst:375
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: ../../library/stdtypes.rst:375
#, fuzzy
msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr "最少 :class:`~numbers.Integral` >= *x*"

#: ../../library/stdtypes.rst:379
#, fuzzy
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr "有關其他數字運算，請參閱 :mod:`math` 和 :mod:`cmath` 模組。"

#: ../../library/stdtypes.rst:388
#, fuzzy
msgid "Bitwise Operations on Integer Types"
msgstr "整數型別的按位運算"

#: ../../library/stdtypes.rst:402
#, fuzzy
msgid ""
"Bitwise operations only make sense for integers. The result of bitwise "
"operations is calculated as though carried out in two's complement with an "
"infinite number of sign bits."
msgstr "按位運算只對整數有意義。按位運算的結果被計算為好像在具有無限數量的符號位的二"
"進位補碼中執行。"

#: ../../library/stdtypes.rst:406
#, fuzzy
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and "
"``-``)."
msgstr "二元按位運算的優先級都低於數值運算，高於比較；一元運算 ``~``與其他一元數值運算（"
" ``+``和 ``-``）具有相同的優先級。"

#: ../../library/stdtypes.rst:410
#, fuzzy
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr "下表列出了按優先級升序排列的按位運算："

#: ../../library/stdtypes.rst:415
msgid "``x | y``"
msgstr "``x | y``"

#: ../../library/stdtypes.rst:415
#, fuzzy
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "*x* 和 *y* 的按位 :dfn:`or`"

#: ../../library/stdtypes.rst:415 ../../library/stdtypes.rst:418
#: ../../library/stdtypes.rst:421 ../../library/stdtypes.rst:1172
#: ../../library/stdtypes.rst:2394 ../../library/stdtypes.rst:2398
#: ../../library/stdtypes.rst:3612 ../../library/stdtypes.rst:3616
msgid "\\(4)"
msgstr "\\(4)"

#: ../../library/stdtypes.rst:418
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: ../../library/stdtypes.rst:418
#, fuzzy
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "按位 :dfn: *x* 和 *y* 的異或"

#: ../../library/stdtypes.rst:421
msgid "``x & y``"
msgstr "``x & y``"

#: ../../library/stdtypes.rst:421
#, fuzzy
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "*x* 和 *y* 的按位 :dfn:`and`"

#: ../../library/stdtypes.rst:424
msgid "``x << n``"
msgstr "``x << n``"

#: ../../library/stdtypes.rst:424
#, fuzzy
msgid "*x* shifted left by *n* bits"
msgstr "*x* 左移 *n* 位"

#: ../../library/stdtypes.rst:424
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../../library/stdtypes.rst:426
msgid "``x >> n``"
msgstr "``x >> n``"

#: ../../library/stdtypes.rst:426
#, fuzzy
msgid "*x* shifted right by *n* bits"
msgstr "*x* 右移 *n* 位"

#: ../../library/stdtypes.rst:426
msgid "(1)(3)"
msgstr "(1)(3)"

#: ../../library/stdtypes.rst:428
msgid "``~x``"
msgstr "``~x``"

#: ../../library/stdtypes.rst:428
#, fuzzy
msgid "the bits of *x* inverted"
msgstr "*x* 的位反轉"

#: ../../library/stdtypes.rst:434
#, fuzzy
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr "負班次計數是非法的，會導致引發 :exc:`ValueError`。"

#: ../../library/stdtypes.rst:437
#, fuzzy
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``."
msgstr "左移 *n* 位相當於乘以 ``pow(2, n)``。"

#: ../../library/stdtypes.rst:440
#, fuzzy
msgid ""
"A right shift by *n* bits is equivalent to floor division by ``pow(2, n)``."
msgstr "右移 *n* 位相當於除以 ``pow(2, n)``。"

#: ../../library/stdtypes.rst:443
#, fuzzy
msgid ""
"Performing these calculations with at least one extra sign extension bit in "
"a finite two's complement representation (a working bit-width of ``1 + max(x."
"bit_length(), y.bit_length())`` or more) is sufficient to get the same "
"result as if there were an infinite number of sign bits."
msgstr ""
"在有限二進位補碼表示中使用至少一個額外的符號擴充位執行這些計算（工作位寬為 ``"
"1 + max(x.bit_length(), y.bit_length())`` "
"或更多）足以得到的結果就好像有無限多的符號位一樣。"

#: ../../library/stdtypes.rst:450
#, fuzzy
msgid "Additional Methods on Integer Types"
msgstr "整數型別的附加方法"

#: ../../library/stdtypes.rst:452
#, fuzzy
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides a few more methods:"
msgstr ""
"int 型別實作了 :class:`numbers.Integral` :term:`abstract base "
"class`。此外，它還提供了幾個方法："

#: ../../library/stdtypes.rst:457
#, fuzzy
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr "回傳表示二進位整數所需的位數，不包括符號和前導零：："

#: ../../library/stdtypes.rst:466
#, fuzzy
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then ``x."
"bit_length()`` returns ``0``."
msgstr ""
"更準確地說，如果 ``x`` 不為零，則 ``x.bit_length()`` 是唯一的正整數 ``k`` "
"使得 ``2**(k-1) <= abs(x) < 2**k``。等價地，當 ``abs(x)`` "
"足夠小以具有正確舍入的對數時，則 ``k = 1 + int(log(abs(x), 2))``。如果 ``x`` "
"為零，則 ``x.bit_length()`` 回傳 ``0``。"

#: ../../library/stdtypes.rst:472 ../../library/stdtypes.rst:495
#: ../../library/stdtypes.rst:540 ../../library/stdtypes.rst:584
msgid "Equivalent to::"
msgstr ""
"等價於：\n"
"\n"
"::"

#: ../../library/stdtypes.rst:483
#, fuzzy
msgid ""
"Return the number of ones in the binary representation of the absolute value "
"of the integer. This is also known as the population count. Example::"
msgstr "回傳整數絕對值的二進位表示形式中的個數。這也稱為人口計數。例子：："

#: ../../library/stdtypes.rst:504
#, fuzzy
msgid "Return an array of bytes representing an integer."
msgstr "回傳表示整數的位元組數組。"

#: ../../library/stdtypes.rst:516
#, fuzzy
msgid ""
"The integer is represented using *length* bytes, and defaults to 1.  An :exc:"
"`OverflowError` is raised if the integer is not representable with the given "
"number of bytes."
msgstr "整數使用 *length* 位元組表示，預設為 1。如果整數不能用給定的位元組數表示，"
"則會引發 :exc:`OverflowError`。"

#: ../../library/stdtypes.rst:520
#, fuzzy
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the "
"most significant byte is at the beginning of the byte array.  If *byteorder* "
"is ``\"little\"``, the most significant byte is at the end of the byte array."
msgstr ""
"*byteorder* 參數確定用於表示整數的位元組順序，預設為 ``big``。如果 *byteorder* "
"是``\"big\"``，最高有效位元組在位元組數組的開頭。如果 *byteorder* 是 ``"
"\"little\"``，則最高有效位元組位於位元組數組的末尾。"

#: ../../library/stdtypes.rst:526
#, fuzzy
msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer is "
"given, an :exc:`OverflowError` is raised. The default value for *signed* is "
"``False``."
msgstr ""
"*signed* 參數確定是否使用二進位補碼來表示整數。如果 *signed* 為 ``False`` "
"並且給出了一個負整數，則會引發 :exc:`OverflowError`。 *signed* "
"的預設值為 ``False``。"

#: ../../library/stdtypes.rst:531
#, fuzzy
msgid ""
"The default values can be used to conveniently turn an integer into a single "
"byte object::"
msgstr "預設值可用於方便地將整數轉換為單位元組物件::"

#: ../../library/stdtypes.rst:537
#, fuzzy
msgid ""
"However, when using the default arguments, don't try to convert a value "
"greater than 255 or you'll get an :exc:`OverflowError`."
msgstr "但是，當使用預設參數時，不要嘗試轉換大於 255 的值，否則您會得到一個 "
":exc:`OverflowError`。"

#: ../../library/stdtypes.rst:553
#, fuzzy
msgid "Added default argument values for ``length`` and ``byteorder``."
msgstr "新增了``length`` 和``byteorder`` 的預設參數值。"

#: ../../library/stdtypes.rst:558
#, fuzzy
msgid "Return the integer represented by the given array of bytes."
msgstr "回傳由給定位元組數組表示的整數。"

#: ../../library/stdtypes.rst:571
#, fuzzy
msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an "
"iterable producing bytes."
msgstr "參數 *bytes* 必須是一個 :term:`bytes-like object` "
"或一個可疊代的產生位元組的物件。"

#: ../../library/stdtypes.rst:574
#, fuzzy
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the "
"most significant byte is at the beginning of the byte array.  If *byteorder* "
"is ``\"little\"``, the most significant byte is at the end of the byte "
"array.  To request the native byte order of the host system, use :data:`sys."
"byteorder` as the byte order value."
msgstr ""
"*byteorder* 參數確定用於表示整數的位元組順序，預設為 ``big``。如果 *byteorder* "
"是``\"big\"``，最高有效位元組在位元組數組的開頭。如果 *byteorder* 是 ``"
"\"little\""
"``，則最高有效位元組位於位元組數組的末尾。要請求主機系統的本機位元組順序，"
"請使用 :data:`sys.byteorder` 作為位元組順序值。"

#: ../../library/stdtypes.rst:581
#, fuzzy
msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr "*signed* 參數指示是否使用二進位補碼來表示整數。"

#: ../../library/stdtypes.rst:601
#, fuzzy
msgid "Added default argument value for ``byteorder``."
msgstr "為 ``byteorder`` 新增了預設參數值。"

#: ../../library/stdtypes.rst:606
#, fuzzy
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original "
"integer and with a positive denominator. The integer ratio of integers "
"(whole numbers) is always the integer as the numerator and ``1`` as the "
"denominator."
msgstr "回傳一對整數，其比率正好等於原始整數並且具有正分母。整數（整數）的整數比總是"
"以整數為分子， ``1``為分母。"

#: ../../library/stdtypes.rst:614
#, fuzzy
msgid "Additional Methods on Float"
msgstr "浮動的其他方法"

#: ../../library/stdtypes.rst:616
#, fuzzy
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"float 型別實作了 :class:`numbers.Real` :term:`abstract base class`。 float "
"還具有以下附加方法。"

#: ../../library/stdtypes.rst:621
#, fuzzy
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original float "
"and with a positive denominator.  Raises :exc:`OverflowError` on infinities "
"and a :exc:`ValueError` on NaNs."
msgstr ""
"回傳一對整數，其比率正好等於原始浮點數並具有正分母。在無窮大上引發 "
":exc:`OverflowError`，在 NaN 上引發 :exc:`ValueError`。"

#: ../../library/stdtypes.rst:628
#, fuzzy
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr "如果 float 實例是有限整數值，則回傳 ``True``，否則回傳 ``False``："

#: ../../library/stdtypes.rst:636
#, fuzzy
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"兩種方法支援十六進位字串之間的轉換。由於 Python "
"的浮點數在內部儲存為二進位數，因此將浮點數轉換為 *decimal* 字串或從 *decimal*"
" 字串轉換通常會出現小的捨入誤差。相反，十六進位字串允許精確表示和指定浮點數。"
"這在除錯和數值計算時很有用。"

#: ../../library/stdtypes.rst:647
#, fuzzy
msgid ""
"Return a representation of a floating-point number as a hexadecimal string.  "
"For finite floating-point numbers, this representation will always include a "
"leading ``0x`` and a trailing ``p`` and exponent."
msgstr "將浮點數的表示形式回傳為十六進位字串。對於有限浮點數，此表示將始終包含前導“0x"
"”和尾隨 ``p``和指數。"

#: ../../library/stdtypes.rst:655
#, fuzzy
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr "回傳由十六進位字串 *s* 表示的浮點數的類方法。字串 *s* 可能有前導和尾隨空格。"

#: ../../library/stdtypes.rst:660
#, fuzzy
msgid ""
"Note that :meth:`float.hex` is an instance method, while :meth:`float."
"fromhex` is a class method."
msgstr "請注意 :meth:`float.hex` 是一個實例方法，而 :meth:`float.fromhex` "
"是一個類方法。"

#: ../../library/stdtypes.rst:663
#, fuzzy
msgid "A hexadecimal string takes the form::"
msgstr "十六進位字串採用以下形式："

#: ../../library/stdtypes.rst:667
#, fuzzy
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and "
"there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2 "
"of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted "
"by :meth:`float.fromhex`."
msgstr ""
"其中可選的“符號”可以是 ``+``或 ``-``，“整數”和“分數”是十六進位數字的字串，“指數”是"
"十進位整數帶有可選的前導旗標。大小寫無關緊要，整數或小數必須至少有一位十六進"
"制數字。此語法類似於 C99 標準第 6.4.4.2 節中指定的語法，也類似於 Java 1.5 "
"及以後版本中使用的語法。特別是，:meth:`float.hex` 的輸出可用作 C 或 Java "
"程式碼中的十六進位浮點文字，以及由 C 的 ``%a`` 格式字元或 Java 的 ``"
"Double.toHexString 生成的十六進位字串`` 被 :meth:`float.fromhex` 接受。"

#: ../../library/stdtypes.rst:680
#, fuzzy
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"請注意，指數是以十進位而不是十六進位表示的，它給出了乘以係數的 2 "
"的次方。例如，十六進位字串“0x3.a7p10”表示浮點數“(3 + 10./16 + 7./16**2) * 2."
"0**10”，即“3740.0” `::"

#: ../../library/stdtypes.rst:690
#, fuzzy
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr "將反向轉換應用於 ``3740.0`` 會給出表示相同數字的不同十六進位字串::"

#: ../../library/stdtypes.rst:700
#, fuzzy
msgid "Hashing of numeric types"
msgstr "數字型別的散列"

#: ../../library/stdtypes.rst:702
#, fuzzy
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement "
"that ``hash(x) == hash(y)`` whenever ``x == y`` (see the :meth:`~object."
"__hash__` method documentation for more details).  For ease of "
"implementation and efficiency across a variety of numeric types (including :"
"class:`int`, :class:`float`, :class:`decimal.Decimal` and :class:`fractions."
"Fraction`) Python's hash for numeric types is based on a single mathematical "
"function that's defined for any rational number, and hence applies to all "
"instances of :class:`int` and :class:`fractions.Fraction`, and all finite "
"instances of :class:`float` and :class:`decimal.Decimal`.  Essentially, this "
"function is given by reduction modulo ``P`` for a fixed prime ``P``.  The "
"value of ``P`` is made available to Python as the :attr:`modulus` attribute "
"of :data:`sys.hash_info`."
msgstr ""
"對於數字 ``x`` 和 ``y``，可能是不同的型別，只要 ``x == y`` 就要求 ``hash(x) "
"== hash(y)``（見： meth:`~object.__hash__` 方法文檔了解更多細節）。為了在各種"
"數字型別（包括 :class:`int`、:class:`float`、:class:`decimal.Decimal` 和 "
":class:`fractions.Fraction`）中易於實作和提高效率，Python 的數字雜湊types "
"基於為任何有理數定義的單個數學函式，因此適用於 int 和 fractions.Fraction "
"的所有實例，以及 float 和 float 的所有有限實例 :class:`decimal."
"Decimal`。本質上，這個函式是通過對固定素數 ``P``取模 ``P``的歸約給出的。 ``P`` "
"的值作為 sys.hash_info 的 :attr:`modulus` 屬性提供給 Python。"

#: ../../library/stdtypes.rst:717
#, fuzzy
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"目前，使用的素數在 32 位 C 長整數的機器上是“P = 2**31 - 1”，在 64 位 C "
"長整數的機器上是“P = 2**61 - 1”。"

#: ../../library/stdtypes.rst:720
#, fuzzy
msgid "Here are the rules in detail:"
msgstr "以下是詳細規則："

#: ../../library/stdtypes.rst:722
#, fuzzy
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible "
"by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n, "
"P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""
"如果 ``x = m / n`` 是一個非負有理數並且 ``n`` 不能被 ``P`` 整除，定義 "
"``hash(x)`` 為 ``m * invmod(n, P ) % P``，其中 ``invmod(n, P)`` 給出 ``n`` "
"模 ``P`` 的倒數。"

#: ../../library/stdtypes.rst:726
#, fuzzy
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule "
"above doesn't apply; in this case define ``hash(x)`` to be the constant "
"value ``sys.hash_info.inf``."
msgstr ""
"如果 ``x = m / n`` 是一個非負有理數並且 ``n`` 可以被 ``P`` 整除（但 ``m`` "
"不是）那麼 ``n`` 沒有逆模 ` `P`` 和上面的規則不適用；在這種情況下，將 "
"``hash(x)`` 定義為常數值 ``sys.hash_info.inf``。"

#: ../../library/stdtypes.rst:731
#, fuzzy
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as ``-"
"hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"如果 ``x = m / n`` 是負有理數，則將 ``hash(x)`` 定義為 "
"``-hash(-x)``。如果生成的散列為 ``-1``，請將其替換為 ``-2``。"

#: ../../library/stdtypes.rst:735
#, fuzzy
msgid ""
"The particular values ``sys.hash_info.inf`` and ``-sys.hash_info.inf`` are "
"used as hash values for positive infinity or negative infinity "
"(respectively)."
msgstr "特定值“sys.hash_info.inf”和“-sys.hash_info."
"inf”分別用作正無窮大或負無窮大的雜湊值（分別）。"

#: ../../library/stdtypes.rst:739
#, fuzzy
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + sys.hash_info."
"imag * hash(z.imag)``, reduced modulo ``2**sys.hash_info.width`` so that it "
"lies in ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - "
"1))``.  Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""
"對於 :class:`complex` 數 ``z``，實部和虛部的雜湊值通過計算``hash(z.real) + "
"sys.hash_info.imag * hash(z.imag)` 組合在一起`，減少模數 ``2**sys.hash_info."
"width`` 使其位於 ``range(-2**(sys.hash_info.width - 1), 2**("
"sys.hash_info.width - 1 ））``。同樣，如果結果為 ``-1``，則將其替換為 ``-2``。"

#: ../../library/stdtypes.rst:747
#, fuzzy
msgid ""
"To clarify the above rules, here's some example Python code, equivalent to "
"the built-in hash, for computing the hash of a rational number, :class:"
"`float`, or :class:`complex`::"
msgstr ""
"為了闡明上述規則，這裡有一些示例 Python "
"程式碼，相當於內建雜湊，用於計算有理數的雜湊，:class:`float`, "
"或 :class:`complex`::"

#: ../../library/stdtypes.rst:802
#, fuzzy
msgid "Iterator Types"
msgstr "疊代器型別"

#: ../../library/stdtypes.rst:810
#, fuzzy
msgid ""
"Python supports a concept of iteration over containers.  This is implemented "
"using two distinct methods; these are used to allow user-defined classes to "
"support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr "Python 支援容器疊代的概念。這是使用兩種不同的方法實作的；這些用於允許使用者定"
"義的類支援疊代。下面更詳細描述的序列始終支援疊代方法。"

#: ../../library/stdtypes.rst:815
#, fuzzy
msgid ""
"One method needs to be defined for container objects to provide :term:"
"`iterable` support:"
msgstr "需要為容器物件定義一個方法來提供 :term:`iterable` 支援："

#: ../../library/stdtypes.rst:822
#, fuzzy
msgid ""
"Return an :term:`iterator` object.  The object is required to support the "
"iterator protocol described below.  If a container supports different types "
"of iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iter` slot of the type structure for Python objects "
"in the Python/C API."
msgstr ""
"回傳一個 :term:`iterator` 物件。該物件需要支援下面描述的疊代器協定。如果容器"
"支援不同型別的疊代，則可以提供額外的方法來專門為這些疊代型別請求疊代器。 "
"（支援多種形式疊代的物件的示例是支援廣度優先和深度優先遍歷的樹結構。）"
"此方法對應於型別結構的 :c:member:`~PyTypeObject.tp_iter` 槽對於 Python/C API "
"中的 Python 物件。"

#: ../../library/stdtypes.rst:831
#, fuzzy
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr "疊代器物件本身需要支援以下兩種方法，它們共同構成疊代器協定："

#: ../../library/stdtypes.rst:837
#, fuzzy
msgid ""
"Return the :term:`iterator` object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and :keyword:"
"`in` statements.  This method corresponds to the :c:member:`~PyTypeObject."
"tp_iter` slot of the type structure for Python objects in the Python/C API."
msgstr ""
"回傳 :term:`iterator` 物件本身。這是允許容器和疊代器與 :keyword:`for` 和 "
":keyword:`in` 語句一起使用所必需的。此方法對應於 Python/C API 中 Python "
"對像型別結構的 :c:member:`~PyTypeObject.tp_iter` 槽。"

#: ../../library/stdtypes.rst:846
#, fuzzy
msgid ""
"Return the next item from the :term:`iterator`.  If there are no further "
"items, raise the :exc:`StopIteration` exception.  This method corresponds to "
"the :c:member:`~PyTypeObject.tp_iternext` slot of the type structure for "
"Python objects in the Python/C API."
msgstr ""
"從 :term:`iterator` 回傳下一個項目。如果沒有其他項目，則引發 "
":exc:`StopIteration` 例外。此方法對應於 Python/C API 中 Python "
"對像型別結構的 :c:member:`~PyTypeObject.tp_iternext` 槽。"

#: ../../library/stdtypes.rst:851
#, fuzzy
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized "
"forms.  The specific types are not important beyond their implementation of "
"the iterator protocol."
msgstr "Python 定義了幾個疊代器物件來支援對通用和特定序列型別、字典和其他更專業形式的"
"疊代。除了疊代器協定的實作之外，特定型別並不重要。"

#: ../../library/stdtypes.rst:856
#, fuzzy
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises :exc:"
"`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""
"一旦疊代器的 :meth:`~iterator.__next__` 方法引發 :exc:`StopIteration`，它必須"
"在後續呼叫中繼續這樣做。不遵守此屬性的實作被視為已損壞。"

#: ../../library/stdtypes.rst:864
#, fuzzy
msgid "Generator Types"
msgstr "發電機型別"

#: ../../library/stdtypes.rst:866
#, fuzzy
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`__iter__` method is "
"implemented as a generator, it will automatically return an iterator object "
"(technically, a generator object) supplying the :meth:`__iter__` and :meth:"
"`~generator.__next__` methods. More information about generators can be "
"found in :ref:`the documentation for the yield expression <yieldexpr>`."
msgstr ""
"Python 的 :term:`generator`\\s 提供了一種實作疊代器協定的便捷方式。"
"如果一個容器物件的 :meth:`__iter__` "
"方法被實作為一個生成器，它會自動回傳一個疊代器物件（技術上，一個生成器物件）"
"提供 :meth:`__iter__` 和 :meth:`~generator.__next__` "
"方法.有關生成器的更多資訊可以在 :ref:`yield 表達式的文檔 <yieldexpr>` "
"中找到。"

#: ../../library/stdtypes.rst:878
#, fuzzy
msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr "序列型別 --- :class:`list`, :class:`tuple`, :class:`range`"

#: ../../library/stdtypes.rst:880
#, fuzzy
msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated "
"sections."
msgstr ""
"共有三種基本序列型別：列表、元組和範圍物件。專為處理 :ref:`binary data "
"<binaryseq>` 和 :ref:`text strings <textseq>` "
"而定制的其他序列型別在專用部分中進行了描述。"

#: ../../library/stdtypes.rst:889
#, fuzzy
msgid "Common Sequence Operations"
msgstr "常見的序列操作"

#: ../../library/stdtypes.rst:893
#, fuzzy
msgid ""
"The operations in the following table are supported by most sequence types, "
"both mutable and immutable. The :class:`collections.abc.Sequence` ABC is "
"provided to make it easier to correctly implement these operations on custom "
"sequence types."
msgstr ""
"大多數序列型別都支援下表中的操作，包括可變的和不可變的。 :class:`collections."
"abc.Sequence` ABC 的提供是為了更容易在自定義序列型別上正確實作這些操作。"

#: ../../library/stdtypes.rst:898
#, fuzzy
msgid ""
"This table lists the sequence operations sorted in ascending priority.  In "
"the table, *s* and *t* are sequences of the same type, *n*, *i*, *j* and *k* "
"are integers and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s*."
msgstr ""
"此表列出了按優先級升序排序的序列操作。表中*s*和*t*是同型別的序列，*n*、*i*、*"
"j*和*k*是整數，*x*是滿足任意型別和值限制的任意物件由 *s* 強加。"

#: ../../library/stdtypes.rst:903
#, fuzzy
msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the "
"comparison operations. The ``+`` (concatenation) and ``*`` (repetition) "
"operations have the same priority as the corresponding numeric operations. "
"[3]_"
msgstr ""
" ``in``和“not in”操作與比較操作具有相同的優先級。 "
"``+``（串聯）和``*``（重複）操作與相應的數字操作具有相同的優先級。 [3]_"

#: ../../library/stdtypes.rst:924
msgid "``x in s``"
msgstr "``x in s``"

#: ../../library/stdtypes.rst:924
#, fuzzy
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "``True`` 如果 *s* 的一項等於 *x*，否則``False``"

#: ../../library/stdtypes.rst:927
msgid "``x not in s``"
msgstr "``x not in s``"

#: ../../library/stdtypes.rst:927
#, fuzzy
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "``False`` 如果 *s* 的一項等於 *x*，否則``True``"

#: ../../library/stdtypes.rst:930
msgid "``s + t``"
msgstr "``s + t``"

#: ../../library/stdtypes.rst:930
#, fuzzy
msgid "the concatenation of *s* and *t*"
msgstr "*s* 和 *t* 的串聯"

#: ../../library/stdtypes.rst:930
msgid "(6)(7)"
msgstr "(6)(7)"

#: ../../library/stdtypes.rst:933
msgid "``s * n`` or ``n * s``"
msgstr "``s * n`` 或 ``n * s``"

#: ../../library/stdtypes.rst:933
#, fuzzy
msgid "equivalent to adding *s* to itself *n* times"
msgstr "相當於將 *s* 新增到自身 *n* 次"

#: ../../library/stdtypes.rst:933
msgid "(2)(7)"
msgstr "(2)(7)"

#: ../../library/stdtypes.rst:936
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../../library/stdtypes.rst:936
#, fuzzy
msgid "*i*\\ th item of *s*, origin 0"
msgstr "*i*\\*s*的第一項，原點0"

#: ../../library/stdtypes.rst:938
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: ../../library/stdtypes.rst:938
#, fuzzy
msgid "slice of *s* from *i* to *j*"
msgstr "從 *i* 到 *j* 的 *s* 切片"

#: ../../library/stdtypes.rst:938
msgid "(3)(4)"
msgstr "(3)(4)"

#: ../../library/stdtypes.rst:940
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: ../../library/stdtypes.rst:940
#, fuzzy
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr "從 *i* 到 *j* 的 *s* 切片，步驟 *k*"

#: ../../library/stdtypes.rst:940
msgid "(3)(5)"
msgstr "(3)(5)"

#: ../../library/stdtypes.rst:943
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../../library/stdtypes.rst:943
#, fuzzy
msgid "length of *s*"
msgstr "*s* 的長度"

#: ../../library/stdtypes.rst:945
msgid "``min(s)``"
msgstr "``min(s)``"

#: ../../library/stdtypes.rst:945
#, fuzzy
msgid "smallest item of *s*"
msgstr "*s* 的最小項目"

#: ../../library/stdtypes.rst:947
msgid "``max(s)``"
msgstr "``max(s)``"

#: ../../library/stdtypes.rst:947
#, fuzzy
msgid "largest item of *s*"
msgstr "*s* 的最大項目"

#: ../../library/stdtypes.rst:949
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: ../../library/stdtypes.rst:949
#, fuzzy
msgid ""
"index of the first occurrence of *x* in *s* (at or after index *i* and "
"before index *j*)"
msgstr "*s* 中第一次出現 *x* 的索引（在索引 *i* 或索引 *i* 之後和索引 *j* 之前）"

#: ../../library/stdtypes.rst:949 ../../library/stdtypes.rst:3598
msgid "\\(8)"
msgstr "\\(8)"

#: ../../library/stdtypes.rst:953
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: ../../library/stdtypes.rst:953
#, fuzzy
msgid "total number of occurrences of *x* in *s*"
msgstr "*x* 在 *s* 中出現的總次數"

#: ../../library/stdtypes.rst:957
#, fuzzy
msgid ""
"Sequences of the same type also support comparisons.  In particular, tuples "
"and lists are compared lexicographically by comparing corresponding "
"elements. This means that to compare equal, every element must compare equal "
"and the two sequences must be of the same type and have the same length.  "
"(For full details see :ref:`comparisons` in the language reference.)"
msgstr ""
"相同型別的序列也支援比較。特別地，元組和列表通過比較相應的元素來按字典順序進"
"行比較。這意味著要比較相等，每個元素都必須比較相等，並且兩個序列必須具有相同"
"的型別和相同的長度。 （有關完整詳細資訊，請參閱語言參考中的 "
":ref:`comparisons`。）"

#: ../../library/stdtypes.rst:967
#, fuzzy
msgid ""
"Forward and reversed iterators over mutable sequences access values using an "
"index.  That index will continue to march forward (or backward) even if the "
"underlying sequence is mutated.  The iterator terminates only when an :exc:"
"`IndexError` or a :exc:`StopIteration` is encountered (or when the index "
"drops below zero)."
msgstr ""
"可變序列上的正向和反向疊代器使用索引訪問值。即使基礎序列發生突變，該索引也將"
"繼續前進（或後退）。疊代器僅在遇到 :exc:`IndexError` 或 :exc:`StopIteration` "
"時終止（或當索引降到零以下時）。"

#: ../../library/stdtypes.rst:976
#, fuzzy
msgid ""
"While the ``in`` and ``not in`` operations are used only for simple "
"containment testing in the general case, some specialised sequences (such "
"as :class:`str`, :class:`bytes` and :class:`bytearray`) also use them for "
"subsequence testing::"
msgstr ""
"雖然 ``in`` 和 ``not in`` 操作在一般情況下僅用於簡單的包含測試，但一些特殊序"
"列（例如 :class:`str`、:class:`bytes` 和 :class: `bytearray`) "
"也將它們用於後續測試::"

#: ../../library/stdtypes.rst:985
#, fuzzy
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider::"
msgstr ""
"*n* 的值小於 ``0`` 被視為 ``0``（產生與 *s* 相同型別的空序列）。請注意，序列 "
"*s* 中的項目不會被複製；它們被多次引用。這常常困擾著新的 Python "
"程式員；考慮：："

#: ../../library/stdtypes.rst:997
#, fuzzy
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty "
"list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single "
"list. You can create a list of different lists this way::"
msgstr ""
"發生的事情是 ``[[]]`` 是一個包含空列表的單元素列表，因此 ``[[]] * 3`` "
"的所有三個元素都是對這個空列表的引用。修改 ``lists`` "
"的任何元素都會修改這個單個列表。您可以通過這種方式建立不同列表的列表："

#: ../../library/stdtypes.rst:1009
#, fuzzy
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-multidimensional-"
"list`."
msgstr "FAQ 條目中提供了進一步的解釋 :ref:`faq-multidimensional-list`。"

#: ../../library/stdtypes.rst:1013
#, fuzzy
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*: "
"``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""
"如果 *i* 或 *j* 為負，則索引相對於序列 *s* 的末尾：``len(s) + i`` 或 ``len(s)"
" + j`` 被替換。但請注意，``-0`` 仍然是 ``0``。"

#: ../../library/stdtypes.rst:1018
#, fuzzy
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal "
"to *j*, the slice is empty."
msgstr ""
"*s* 從 *i* 到 *j* 的切片被定義為索引為 *k* 的項目序列，使得 ``i <= k < j``。"
"如果 *i* 或 *j* 大於 ``len(s)``，請使用 ``len(s)``。如果省略 *i* "
"或 ``None`` ，請使用 ``0``。如果省略 *j* 或 ``None`` ，請使用“len(s)”。如果 *i* 大於或等於 "
"*j*，則切片為空。"

#: ../../library/stdtypes.rst:1025
#, fuzzy
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of "
"items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other "
"words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is "
"``None``, it is treated like ``1``."
msgstr ""
"*s* 從 *i* 到 *j* 的切片 *k* 被定義為索引為 ``x = i + n*k`` 的項目序列，使得 "
"``0 <= n < (j-i )/k``。換句話說，索引是 ``i``、``i+k``、``i+2*k``、``i+3*k`` "
"等等，當 *j* 是時停止達到（但不包括 *j*）。當 *k* 為正時，如果 *i* 和 *j* "
"較大，則將其縮減為 ``len(s)``。當 *k* 為負數時，如果 *i* 和 *j* 較大，"
"則減少為 ``len(s) - 1``。如果 *i* 或 *j* 被省略或 ``None`` ，它們將成為“結束”值（"
"結束取決於 *k* 的符號）。注意，*k* 不能為零。如果 *k* 為 ``None`` ，則將其視為 ``1``。"

#: ../../library/stdtypes.rst:1036
#, fuzzy
msgid ""
"Concatenating immutable sequences always results in a new object.  This "
"means that building up a sequence by repeated concatenation will have a "
"quadratic runtime cost in the total sequence length.  To get a linear "
"runtime cost, you must switch to one of the alternatives below:"
msgstr ""
"連接不可變序列總是會產生一個新物件。這意味著通過重複串聯構建序列將在總序列長"
"度中產生二次運行時間成本。要獲得線性運行時成本，您必須切換到以下替代方案之一"
"："

#: ../../library/stdtypes.rst:1041
#, fuzzy
msgid ""
"if concatenating :class:`str` objects, you can build a list and use :meth:"
"`str.join` at the end or else write to an :class:`io.StringIO` instance and "
"retrieve its value when complete"
msgstr ""
"如果連接 :class:`str` 物件，您可以構建一個列表並在末尾使用 :meth:`str.join` "
"或者寫入 :class:`io.StringIO` 實例並在完成時檢索其值"

#: ../../library/stdtypes.rst:1045
#, fuzzy
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use :meth:`bytes."
"join` or :class:`io.BytesIO`, or you can do in-place concatenation with a :"
"class:`bytearray` object.  :class:`bytearray` objects are mutable and have "
"an efficient overallocation mechanism"
msgstr ""
"如果連接 :class:`bytes` 物件，您可以類似地使用 :meth:`bytes.join` 或 :class:`io."
"BytesIO`，或者您可以使用 :class:`bytearray` 物件進行就地連接。 "
":class:`bytearray` 對像是可變的並且有一個高效的過度分配機制"

#: ../../library/stdtypes.rst:1050
#, fuzzy
msgid "if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr "如果連接 :class:`tuple` 物件，則改為擴充 :class:`list`"

#: ../../library/stdtypes.rst:1052
#, fuzzy
msgid "for other types, investigate the relevant class documentation"
msgstr "對於其他型別，調查相關的類文檔"

#: ../../library/stdtypes.rst:1056
#, fuzzy
msgid ""
"Some sequence types (such as :class:`range`) only support item sequences "
"that follow specific patterns, and hence don't support sequence "
"concatenation or repetition."
msgstr "某些序列型別（例如 "
":class:`range`）僅支援遵循特定模式的項目序列，因此不支援序列連接或重複。"

#: ../../library/stdtypes.rst:1061
#, fuzzy
msgid ""
"``index`` raises :exc:`ValueError` when *x* is not found in *s*. Not all "
"implementations support passing the additional arguments *i* and *j*. These "
"arguments allow efficient searching of subsections of the sequence. Passing "
"the extra arguments is roughly equivalent to using ``s[i:j].index(x)``, only "
"without copying any data and with the returned index being relative to the "
"start of the sequence rather than the start of the slice."
msgstr ""
"當在 *s* 中找不到 *x* 時，``index`` 引發 :exec:`ValueError`。"
"並非所有實作都支援傳遞附加參數 *i* 和 *j*。這些參數允許高效搜索序列的子部分。"
"傳遞額外的參數大致等同於使用 ``s[i:j].index(x)``，只是不復制任何資料並且回傳"
"的索引是相對於序列的開始而不是切片的開始."

#: ../../library/stdtypes.rst:1072
#, fuzzy
msgid "Immutable Sequence Types"
msgstr "不可變序列型別"

#: ../../library/stdtypes.rst:1079
#, fuzzy
msgid ""
"The only operation that immutable sequence types generally implement that is "
"not also implemented by mutable sequence types is support for the :func:"
"`hash` built-in."
msgstr "不可變序列型別通常實作但不由可變序列型別實作的唯一操作是支援 :func:`hash` "
"內建。"

#: ../../library/stdtypes.rst:1083
#, fuzzy
msgid ""
"This support allows immutable sequences, such as :class:`tuple` instances, "
"to be used as :class:`dict` keys and stored in :class:`set` and :class:"
"`frozenset` instances."
msgstr "此支援允許將不可變序列（例如 tuple 實例）用作 dict 鍵並儲存在 set 和 "
"frozenset 實例中。"

#: ../../library/stdtypes.rst:1087
#, fuzzy
msgid ""
"Attempting to hash an immutable sequence that contains unhashable values "
"will result in :exc:`TypeError`."
msgstr "嘗試散列包含不可散列值的不可變序列將導致 :exc:`TypeError`。"

#: ../../library/stdtypes.rst:1094
#, fuzzy
msgid "Mutable Sequence Types"
msgstr "可變序列型別"

#: ../../library/stdtypes.rst:1101
#, fuzzy
msgid ""
"The operations in the following table are defined on mutable sequence types. "
"The :class:`collections.abc.MutableSequence` ABC is provided to make it "
"easier to correctly implement these operations on custom sequence types."
msgstr ""
"下表中的操作是在可變序列型別上定義的。 :class:`collections.abc."
"MutableSequence` ABC 的提供是為了更容易在自定義序列型別上正確實作這些操作。"

#: ../../library/stdtypes.rst:1105
#, fuzzy
msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any "
"iterable object and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s* (for example, :class:`bytearray` only accepts "
"integers that meet the value restriction ``0 <= x <= 255``)."
msgstr ""
"在表中，*s* 是可變序列型別的實例，*t* 是任何可疊代物件，*x* 是滿足 *s* "
"強加的任何型別和值限制的任意物件（例如，:class:` bytearray` "
"只接受滿足值限制的整數``0 <= x <= 255``）。"

#: ../../library/stdtypes.rst:1129
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../../library/stdtypes.rst:1129
#, fuzzy
msgid "item *i* of *s* is replaced by *x*"
msgstr "*s* 的項目 *i* 被 *x* 替換"

#: ../../library/stdtypes.rst:1132
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../../library/stdtypes.rst:1132
#, fuzzy
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr "從 *i* 到 *j* 的 *s* 切片被可疊代 *t* 的內容替換"

#: ../../library/stdtypes.rst:1136
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../../library/stdtypes.rst:1136
#, fuzzy
msgid "same as ``s[i:j] = []``"
msgstr "與 s[i:j] = [] 相同"

#: ../../library/stdtypes.rst:1138
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../../library/stdtypes.rst:1138
#, fuzzy
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "``s[i:j:k]`` 的元素被 *t* 的元素替換"

#: ../../library/stdtypes.rst:1141
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../../library/stdtypes.rst:1141
#, fuzzy
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "從列表中刪除 ``s[i:j:k]`` 的元素"

#: ../../library/stdtypes.rst:1144
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: ../../library/stdtypes.rst:1144
#, fuzzy
msgid ""
"appends *x* to the end of the sequence (same as ``s[len(s):len(s)] = [x]``)"
msgstr "將 *x* 附加到序列的末尾（與 ``s[len(s):len(s)] = [x]`` 相同）"

#: ../../library/stdtypes.rst:1148
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: ../../library/stdtypes.rst:1148
#, fuzzy
msgid "removes all items from *s* (same as ``del s[:]``)"
msgstr "從 *s* 中刪除所有項目（與 ``del s[:]`` 相同）"

#: ../../library/stdtypes.rst:1151
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: ../../library/stdtypes.rst:1151
#, fuzzy
msgid "creates a shallow copy of *s* (same as ``s[:]``)"
msgstr "建立 *s* 的淺表副本（與 ``s[:]`` 相同）"

#: ../../library/stdtypes.rst:1154
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` 或 ``s += t``"

#: ../../library/stdtypes.rst:1154
#, fuzzy
msgid ""
"extends *s* with the contents of *t* (for the most part the same as "
"``s[len(s):len(s)] = t``)"
msgstr "使用 *t* 的內容擴充 *s*（大部分與 ``s[len(s):len(s)] = t`` 相同）"

#: ../../library/stdtypes.rst:1159
msgid "``s *= n``"
msgstr "``s *= n``"

#: ../../library/stdtypes.rst:1159
#, fuzzy
msgid "updates *s* with its contents repeated *n* times"
msgstr "更新 *s* 其內容重複 *n* 次"

#: ../../library/stdtypes.rst:1162
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: ../../library/stdtypes.rst:1162
#, fuzzy
msgid ""
"inserts *x* into *s* at the index given by *i* (same as ``s[i:i] = [x]``)"
msgstr "在 *i* 給定的索引處將 *x* 插入 *s* （與 ``s[i:i] = [x]`` 相同）"

#: ../../library/stdtypes.rst:1166
msgid "``s.pop()`` or ``s.pop(i)``"
msgstr "``s.pop()`` 或 ``s.pop(i)``"

#: ../../library/stdtypes.rst:1166
#, fuzzy
msgid "retrieves the item at *i* and also removes it from *s*"
msgstr "檢索位於 *i* 的項目並將其從 *s* 中刪除"

#: ../../library/stdtypes.rst:1169
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../../library/stdtypes.rst:1169
#, fuzzy
msgid "remove the first item from *s* where ``s[i]`` is equal to *x*"
msgstr "從 *s* 中刪除第一項，其中 ``s[i]`` 等於 *x*"

#: ../../library/stdtypes.rst:1172
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: ../../library/stdtypes.rst:1172
#, fuzzy
msgid "reverses the items of *s* in place"
msgstr "反轉 *s* 的項目"

#: ../../library/stdtypes.rst:1180
#, fuzzy
msgid "*t* must have the same length as the slice it is replacing."
msgstr "*t* 必須與其要替換的切片具有相同的長度。"

#: ../../library/stdtypes.rst:1183
#, fuzzy
msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last "
"item is removed and returned."
msgstr "可選參數 *i* 預設為 ``-1``，因此預設情況下最後一項將被刪除並回傳。"

#: ../../library/stdtypes.rst:1187
#, fuzzy
msgid ":meth:`remove` raises :exc:`ValueError` when *x* is not found in *s*."
msgstr "當在 *s* 中找不到 *x* 時，:meth:`remove` 引發 :exc:`ValueError`。"

#: ../../library/stdtypes.rst:1190
#, fuzzy
msgid ""
"The :meth:`reverse` method modifies the sequence in place for economy of "
"space when reversing a large sequence.  To remind users that it operates by "
"side effect, it does not return the reversed sequence."
msgstr ":meth:`reverse` 方法在反轉大序列時修改序列以節省空間。為了提醒使用者它是有副"
"作用的，它不會回傳相反的序列。"

#: ../../library/stdtypes.rst:1195
#, fuzzy
msgid ""
":meth:`clear` and :meth:`!copy` are included for consistency with the "
"interfaces of mutable containers that don't support slicing operations (such "
"as :class:`dict` and :class:`set`). :meth:`!copy` is not part of the :class:"
"`collections.abc.MutableSequence` ABC, but most concrete mutable sequence "
"classes provide it."
msgstr ""
"包括 :meth:`clear` 和 :meth:`!copy` "
"是為了與不支援切片操作的可變容器的介面（例如 :class:`dict` "
"和 :class:`set`）保持一致。 :meth:`!copy` 不是 :class:`collections.abc."
"MutableSequence` ABC 的一部分，但大多數具體的可變序列類都提供了它。"

#: ../../library/stdtypes.rst:1201
#, fuzzy
msgid ":meth:`clear` and :meth:`!copy` methods."
msgstr ":meth:`clear` 和 :meth:`!copy` 方法。"

#: ../../library/stdtypes.rst:1205
#, fuzzy
msgid ""
"The value *n* is an integer, or an object implementing :meth:`~object."
"__index__`.  Zero and negative values of *n* clear the sequence.  Items in "
"the sequence are not copied; they are referenced multiple times, as "
"explained for ``s * n`` under :ref:`typesseq-common`."
msgstr ""
"值 *n* 是一個整數，或者是一個實作 :meth:`~object.__index__` 的物件。 *n* "
"的零值和負值清除序列。序列中的項目不會被複製；它們被多次引用，如 :ref"
":`typesseq-common` 下對 `s * n` 的解釋。"

#: ../../library/stdtypes.rst:1214
msgid "Lists"
msgstr "List（串列）"

#: ../../library/stdtypes.rst:1218
#, fuzzy
msgid ""
"Lists are mutable sequences, typically used to store collections of "
"homogeneous items (where the precise degree of similarity will vary by "
"application)."
msgstr "列表是可變序列，通常用於儲存同類項的集合（其中相似度的精確程度將因應用程式而"
"異）。"

#: ../../library/stdtypes.rst:1224
#, fuzzy
msgid "Lists may be constructed in several ways:"
msgstr "列表可以用幾種方式構造："

#: ../../library/stdtypes.rst:1226
#, fuzzy
msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr "使用一對方括號表示空列表：``[]``"

#: ../../library/stdtypes.rst:1227
#, fuzzy
msgid ""
"Using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr "使用方括號，用逗號分隔項目：``[a]``, ``[a, b, c]``"

#: ../../library/stdtypes.rst:1228
#, fuzzy
msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr "使用列表理解：``[x for x in iterable]``"

#: ../../library/stdtypes.rst:1229
#, fuzzy
msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr "使用型別構造函式：``list()`` 或 ``list(iterable)``"

#: ../../library/stdtypes.rst:1231
#, fuzzy
msgid ""
"The constructor builds a list whose items are the same and in the same order "
"as *iterable*'s items.  *iterable* may be either a sequence, a container "
"that supports iteration, or an iterator object.  If *iterable* is already a "
"list, a copy is made and returned, similar to ``iterable[:]``. For example, "
"``list('abc')`` returns ``['a', 'b', 'c']`` and ``list( (1, 2, 3) )`` "
"returns ``[1, 2, 3]``. If no argument is given, the constructor creates a "
"new empty list, ``[]``."
msgstr ""
"構造函式構建一個列表，其項目與 *iterable* 的項目相同且順序相同。 *iterable* "
"可以是一個序列，一個支援疊代的容器，或者一個疊代器物件。如果 *iterable* "
"已經是一個列表，則建立並回傳一個副本，類似於 "
"``iterable[:]``。例如，``list('abc')`` 回傳``['a', 'b', 'c']`` 和``list( (1, "
"2, 3) )`` 回傳``[ 1, 2, "
"3]``。如果沒有給出參數，構造函式會建立一個新的空列表，``[]``。"

#: ../../library/stdtypes.rst:1240
#, fuzzy
msgid ""
"Many other operations also produce lists, including the :func:`sorted` built-"
"in."
msgstr "許多其他操作也會生成列表，包括內建的 :func:`sorted`。"

#: ../../library/stdtypes.rst:1243
#, fuzzy
msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and :ref:`mutable "
"<typesseq-mutable>` sequence operations. Lists also provide the following "
"additional method:"
msgstr ""
"列表實作了所有 :ref:`common <typesseq-common>` 和 :ref:`mutable <typesseq-"
"mutable>` 序列操作。列表還提供以下附加方法："

#: ../../library/stdtypes.rst:1249
#, fuzzy
msgid ""
"This method sorts the list in place, using only ``<`` comparisons between "
"items. Exceptions are not suppressed - if any comparison operations fail, "
"the entire sort operation will fail (and the list will likely be left in a "
"partially modified state)."
msgstr ""
"此方法對列表進行就地排序，僅使用項目之間的 ``<``比較。不抑制例外 - "
"如果任何比較操作失敗，整個排序操作將失敗（並且列表可能會保留部分修改狀態）。"

#: ../../library/stdtypes.rst:1254
#, fuzzy
msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword (:ref:"
"`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""
":meth:`sort` 接受兩個只能通過關鍵字傳遞的參數（:ref:`keyword-only arguments "
"<keyword-only_parameter>`）："

#: ../../library/stdtypes.rst:1257
#, fuzzy
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element (for example, ``key=str.lower``). The "
"key corresponding to each item in the list is calculated once and then used "
"for the entire sorting process. The default value of ``None`` means that "
"list items are sorted directly without calculating a separate key value."
msgstr ""
"*key* 指定一個參數的函式，用於從每個列表元素中提取比較鍵（例如，``key=str."
"lower``）。列表中每個項目對應的鍵被計算一次，然後用於整個排序過程。 ``None`` "
"的預設值意味著列表項直接排序而不計算單獨的鍵值。"

#: ../../library/stdtypes.rst:1264
#, fuzzy
msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x style "
"*cmp* function to a *key* function."
msgstr ":func:`functools.cmp_to_key` 實用程式可用於將 2.x 樣式的 *cmp* 函式轉換為 "
"*key* 函式。"

#: ../../library/stdtypes.rst:1267
#, fuzzy
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr "*reverse* "
"是一個布爾值。如果設定為 ``True``，則列表元素的排序就好像每個比較都被反轉一樣。"

#: ../../library/stdtypes.rst:1270
#, fuzzy
msgid ""
"This method modifies the sequence in place for economy of space when sorting "
"a large sequence.  To remind users that it operates by side effect, it does "
"not return the sorted sequence (use :func:`sorted` to explicitly request a "
"new sorted list instance)."
msgstr ""
"在對大型序列進行排序時，此方法會修改序列以節省空間。為了提醒使用者它是通過副"
"作用操作的，它不會回傳排序序列（使用 :func:`sorted` "
"明確請求一個新的排序列表實例）。"

#: ../../library/stdtypes.rst:1275
#, fuzzy
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal "
"--- this is helpful for sorting in multiple passes (for example, sort by "
"department, then by salary grade)."
msgstr ""
":meth:`sort` 方法保證穩定。如果保證不改變比較相等的元素的相對順序，則排序是穩"
"定的——這有助於多次排序（例如，按部門排序，然後按工資等級排序）。"

#: ../../library/stdtypes.rst:1280
#, fuzzy
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr "有關排序示例和簡短的排序教程，請參閱 :ref:`sortinghowto`。"

#: ../../library/stdtypes.rst:1284
#, fuzzy
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the "
"list appear empty for the duration, and raises :exc:`ValueError` if it can "
"detect that the list has been mutated during a sort."
msgstr ""
"在對列表進行排序時，嘗試改變甚至檢查列表的效果是不確定的。 Python 的 C "
"實作使列表在持續時間內顯示為空，如果它可以檢測到列表在排序過程中發生了變化，"
"則會引發 :exc:`ValueError`。"

#: ../../library/stdtypes.rst:1293
#, fuzzy
msgid "Tuples"
msgstr "元組"

#: ../../library/stdtypes.rst:1297
#, fuzzy
msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the :func:`enumerate` "
"built-in). Tuples are also used for cases where an immutable sequence of "
"homogeneous data is needed (such as allowing storage in a :class:`set` or :"
"class:`dict` instance)."
msgstr ""
"元組是不可變的序列，通常用於儲存異構資料的集合（例如由 :func:`enumerate` "
"內建生成的二元組）。元組也用於需要同質資料的不可變序列的情況（例如允許儲存在 "
":class:`set` 或 :class:`dict` 實例中）。"

#: ../../library/stdtypes.rst:1305
#, fuzzy
msgid "Tuples may be constructed in a number of ways:"
msgstr "元組可以通過多種方式構造："

#: ../../library/stdtypes.rst:1307
#, fuzzy
msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr "使用一對圓括號表示空元組：``()``"

#: ../../library/stdtypes.rst:1308
#, fuzzy
msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr "對單例元組使用尾隨逗號：``a,`` 或 ``(a,)``"

#: ../../library/stdtypes.rst:1309
#, fuzzy
msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr "用逗號分隔項目：``a, b, c`` 或 ``(a, b, c)``"

#: ../../library/stdtypes.rst:1310
#, fuzzy
msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr "使用內建的 :func:`tuple`：``tuple()`` 或 ``tuple(iterable)``"

#: ../../library/stdtypes.rst:1312
#, fuzzy
msgid ""
"The constructor builds a tuple whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* is "
"already a tuple, it is returned unchanged. For example, ``tuple('abc')`` "
"returns ``('a', 'b', 'c')`` and ``tuple( [1, 2, 3] )`` returns ``(1, 2, "
"3)``. If no argument is given, the constructor creates a new empty tuple, "
"``()``."
msgstr ""
"構造函式構建一個元組，其項目與 *iterable* 的項目相同且順序相同。 *iterable* "
"可以是一個序列，一個支援疊代的容器，或者一個疊代器物件。如果 *iterable* "
"已經是一個元組，則回傳原樣。例如，``tuple('abc')`` 回傳 ``('a', 'b', 'c')`` "
"而 ``tuple( [1, 2, 3] )`` 回傳 ``( "
"1、2、3）``。如果沒有給出參數，構造函式會建立一個新的空元組，``()``。"

#: ../../library/stdtypes.rst:1320
#, fuzzy
msgid ""
"Note that it is actually the comma which makes a tuple, not the parentheses. "
"The parentheses are optional, except in the empty tuple case, or when they "
"are needed to avoid syntactic ambiguity. For example, ``f(a, b, c)`` is a "
"function call with three arguments, while ``f((a, b, c))`` is a function "
"call with a 3-tuple as the sole argument."
msgstr ""
"請注意，構成元組的實際上是逗號，而不是括號。括號是可選的，除非在空元組的情況"
"下，或者當需要它們以避免句法歧義時。例如，``f(a, b, c)`` "
"是一個帶有三個參數的函式呼叫，而``f((a, b, c))`` 是一個帶有 3 "
"元組作為唯一參數的函式呼叫爭論。"

#: ../../library/stdtypes.rst:1326
#, fuzzy
msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence "
"operations."
msgstr "元組實作所有 :ref:`common <typesseq-common>` 序列操作。"

#: ../../library/stdtypes.rst:1329
#, fuzzy
msgid ""
"For heterogeneous collections of data where access by name is clearer than "
"access by index, :func:`collections.namedtuple` may be a more appropriate "
"choice than a simple tuple object."
msgstr ""
"對於通過名稱訪問比通過索引訪問更清晰的異構資料集合，:func:`collections."
"namedtuple` 可能是比簡單的元組物件更合適的選擇。"

#: ../../library/stdtypes.rst:1337
#, fuzzy
msgid "Ranges"
msgstr "範圍"

#: ../../library/stdtypes.rst:1341
#, fuzzy
msgid ""
"The :class:`range` type represents an immutable sequence of numbers and is "
"commonly used for looping a specific number of times in :keyword:`for` loops."
msgstr ":class:`range` 型別表示一個不可變的數字序列，通常用於在 :keyword:`for` "
"循環中循環特定次數。"

#: ../../library/stdtypes.rst:1348
#, fuzzy
msgid ""
"The arguments to the range constructor must be integers (either built-in :"
"class:`int` or any object that implements the :meth:`~object.__index__` "
"special method).  If the *step* argument is omitted, it defaults to ``1``. "
"If the *start* argument is omitted, it defaults to ``0``. If *step* is "
"zero, :exc:`ValueError` is raised."
msgstr ""
"範圍構造函式的參數必須是整數（內建 :class:`int` 或任何實作 :meth:`~object."
"__index__` 特殊方法的物件）。如果省略 *step* 參數，則預設為 ``1``。如果省略 "
"*start* 參數，則預設為 ``0``。如果 *step* 為零，則會引發 :exc:`ValueError`。"

#: ../../library/stdtypes.rst:1354
#, fuzzy
msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by the "
"formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < stop``."
msgstr ""
"對於正 *step*，範圍 ``r`` 的內容由公式 ``r[i] = start + step*i`` 確定，其中 "
"``i >= 0`` 和 ``r[我] <停止``。"

#: ../../library/stdtypes.rst:1358
#, fuzzy
msgid ""
"For a negative *step*, the contents of the range are still determined by the "
"formula ``r[i] = start + step*i``, but the constraints are ``i >= 0`` and "
"``r[i] > stop``."
msgstr ""
"對於負*step*，範圍的內容仍然由公式 ``r[i] = start + step*i`` 確定，"
"但約束條件是 ``i >= 0`` 和 ``r[ i] > 停止``。"

#: ../../library/stdtypes.rst:1362
#, fuzzy
msgid ""
"A range object will be empty if ``r[0]`` does not meet the value constraint. "
"Ranges do support negative indices, but these are interpreted as indexing "
"from the end of the sequence determined by the positive indices."
msgstr "如果 r[0] 不滿足值約束，範圍物件將為空。範圍確實支援負索引，但這些被解釋為從"
"正索引確定的序列末尾開始索引。"

#: ../../library/stdtypes.rst:1367
#, fuzzy
msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are "
"permitted but some features (such as :func:`len`) may raise :exc:"
"`OverflowError`."
msgstr ""
"允許包含大於 :data:`sys.maxsize` 的絕對值的範圍，但某些功能（例如 "
":func:`len`）可能會引發 :exc:`OverflowError`。"

#: ../../library/stdtypes.rst:1371
#, fuzzy
msgid "Range examples::"
msgstr "範圍示例::"

#: ../../library/stdtypes.rst:1388
#, fuzzy
msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence "
"operations except concatenation and repetition (due to the fact that range "
"objects can only represent sequences that follow a strict pattern and "
"repetition and concatenation will usually violate that pattern)."
msgstr ""
"範圍實作所有 :ref:`common <typesseq-common>` 序列操作，除了連接和重複（由於範"
"圍對像只能表示遵循嚴格模式的序列，而重複和連接通常會違反該模式）。"

#: ../../library/stdtypes.rst:1395
#, fuzzy
msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not "
"supplied)"
msgstr "*start* 參數的值（如果未提供參數則為 ``0``）"

#: ../../library/stdtypes.rst:1400
#, fuzzy
msgid "The value of the *stop* parameter"
msgstr "*stop* 參數的值"

#: ../../library/stdtypes.rst:1404
#, fuzzy
msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not "
"supplied)"
msgstr "*step* 參數的值（如果未提供參數，則為 ``1``）"

#: ../../library/stdtypes.rst:1407
#, fuzzy
msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or :"
"class:`tuple` is that a :class:`range` object will always take the same "
"(small) amount of memory, no matter the size of the range it represents (as "
"it only stores the ``start``, ``stop`` and ``step`` values, calculating "
"individual items and subranges as needed)."
msgstr ""
":class:`range` 型別相對於常規 :class:`list` 或 :class:`tuple` 的優勢在於 "
":class:`range` 物件將始終佔用相同（小）的記憶體量，不不管它代表的範圍大小（因"
"為它只儲存“開始”、“停止”和“步進”值，根據需要計算單個項目和子範圍）。"

#: ../../library/stdtypes.rst:1413
#, fuzzy
msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and "
"provide features such as containment tests, element index lookup, slicing "
"and support for negative indices (see :ref:`typesseq`):"
msgstr ""
"Range 物件實作 :class:`collections.abc.Sequence` ABC，並提供諸如包含測試、元"
"素索引查找、切片和負索引支援等功能（請參閱 :ref:`typesseq`）："

#: ../../library/stdtypes.rst:1433
#, fuzzy
msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them as "
"sequences.  That is, two range objects are considered equal if they "
"represent the same sequence of values.  (Note that two range objects that "
"compare equal might have different :attr:`~range.start`, :attr:`~range.stop` "
"and :attr:`~range.step` attributes, for example ``range(0) == range(2, 1, "
"3)`` or ``range(0, 3, 2) == range(0, 4, 2)``.)"
msgstr ""
"使用 ``==`` 和 ``!=`` 測試範圍對像是否相等將它們作為序列進行比較。也就是說，"
"如果兩個範圍物件表示相同的值序列，則它們被認為是相等的。 （請注意，"
"比較相等的兩個範圍物件可能具有不同的 :attr:`~range.start`、:attr:`~range."
"stop` 和 :attr:`~range.step` 屬性，例如 ``range(0 ) == 範圍(2, 1, 3)`` "
"或``範圍(0, 3, 2) == 範圍(0, 4, 2)``。）"

#: ../../library/stdtypes.rst:1440
#, fuzzy
msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test :"
"class:`int` objects for membership in constant time instead of iterating "
"through all items."
msgstr "實作序列 ABC。支援切片和負索引。在恆定時間內測試 int "
"物件的成員資格，而不是遍歷所有項目。"

#: ../../library/stdtypes.rst:1446
#, fuzzy
msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of "
"values they define (instead of comparing based on object identity)."
msgstr "定義 '==' 和 '!=' "
"以根據它們定義的值序列比較範圍物件（而不是根據物件標識進行比較）。"

#: ../../library/stdtypes.rst:1451
#, fuzzy
msgid ""
"The :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` "
"attributes."
msgstr ":attr:`~range.start`、:attr:`~range.stop` 和 :attr:`~range.step` 屬性。"

#: ../../library/stdtypes.rst:1457
#, fuzzy
msgid ""
"The `linspace recipe <https://code.activestate.com/recipes/579000/>`_ shows "
"how to implement a lazy version of range suitable for floating point "
"applications."
msgstr ""
"`linspace 配方 <https://code.activestate.com/recipes/579000/>`_ "
"展示瞭如何實作適用於浮點應用程式的惰性版本範圍。"

#: ../../library/stdtypes.rst:1469
#, fuzzy
msgid "Text Sequence Type --- :class:`str`"
msgstr "文本序列型別 --- :class:`str`"

#: ../../library/stdtypes.rst:1471
#, fuzzy
msgid ""
"Textual data in Python is handled with :class:`str` objects, or :dfn:"
"`strings`. Strings are immutable :ref:`sequences <typesseq>` of Unicode code "
"points.  String literals are written in a variety of ways:"
msgstr ""
"Python 中的文本資料使用 :class:`str` 對像或 :dfn:`strings` 處理。"
"字串是不可變的 :ref:`sequences <typesseq>` Unicode "
"程式碼點。字串字面量有多種寫法："

#: ../../library/stdtypes.rst:1476
#, fuzzy
msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr "單引號：``'允許嵌入 ``雙``引號'``"

#: ../../library/stdtypes.rst:1477
#, fuzzy
msgid "Double quotes: ``\"allows embedded 'single' quotes\"``"
msgstr "雙引號：``“允許嵌入‘單’引號”``"

#: ../../library/stdtypes.rst:1478
#, fuzzy
msgid ""
"Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double "
"quotes\"\"\"``"
msgstr "三引號：``\\'\\'\\'三個單引號\\'\\'\\'``, ``\"\"\"三個雙引號\"\"\"``"

#: ../../library/stdtypes.rst:1480
#, fuzzy
msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace "
"will be included in the string literal."
msgstr "三引號字串可能跨越多行 - 所有相關的空格都將包含在字串文字中。"

#: ../../library/stdtypes.rst:1483
#, fuzzy
msgid ""
"String literals that are part of a single expression and have only "
"whitespace between them will be implicitly converted to a single string "
"literal. That is, ``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""
"作為單個表達式的一部分並且它們之間只有空格的字串文字將被隱式轉換為單個字串文"
"字。也就是說，``(\"spam\" \"eggs\") == \"spam eggs\"``。"

#: ../../library/stdtypes.rst:1487
#, fuzzy
msgid ""
"See :ref:`strings` for more about the various forms of string literal, "
"including supported escape sequences, and the ``r`` (\"raw\") prefix that "
"disables most escape sequence processing."
msgstr ""
"有關各種形式的字串文字的更多資訊，請參閱 :ref:`strings`，包括支援的轉義序列，"
"以及禁用大多數轉義序列處理的 ``r``（“原始”）前綴。"

#: ../../library/stdtypes.rst:1491
#, fuzzy
msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr "也可以使用 :class:`str` 構造函式從其他物件建立字串。"

#: ../../library/stdtypes.rst:1494
#, fuzzy
msgid ""
"Since there is no separate \"character\" type, indexing a string produces "
"strings of length 1. That is, for a non-empty string *s*, ``s[0] == s[0:1]``."
msgstr "由於沒有單獨的“字元”型別，索引字串會產生長度為 1 的字串。也就是說，"
"對於非空字串 *s*，``s[0] == s[0:1]``。"

#: ../../library/stdtypes.rst:1500
#, fuzzy
msgid ""
"There is also no mutable string type, but :meth:`str.join` or :class:`io."
"StringIO` can be used to efficiently construct strings from multiple "
"fragments."
msgstr "也沒有可變的字串型別，但是 :meth:`str.join` 或 :class:`io.StringIO` "
"可用於有效地從多個片段構造字串。"

#: ../../library/stdtypes.rst:1504
#, fuzzy
msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is "
"once again permitted on string literals. It has no effect on the meaning of "
"string literals and cannot be combined with the ``r`` prefix."
msgstr ""
"為了向後相容 Python 2 系列，再次允許在字串文字上使用 ``u`` "
"前綴。它對字串文字的含義沒有影響，不能與 ``r`` 前綴結合使用。"

#: ../../library/stdtypes.rst:1516
#, fuzzy
msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not "
"provided, returns the empty string.  Otherwise, the behavior of ``str()`` "
"depends on whether *encoding* or *errors* is given, as follows."
msgstr ""
"回傳 *object* 的 :ref:`string <textseq>` 版本。如果未提供 "
"*object*，則回傳空字串。否則，``str()`` 的行為取決於是否給出 *encoding* 或 "
"*errors*，如下所示。"

#: ../../library/stdtypes.rst:1520
#, fuzzy
msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns :meth:"
"`type(object).__str__(object) <object.__str__>`, which is the \"informal\" "
"or nicely printable string representation of *object*.  For string objects, "
"this is the string itself.  If *object* does not have a :meth:`~object."
"__str__` method, then :func:`str` falls back to returning :meth:"
"`repr(object) <repr>`."
msgstr ""
"如果既沒有給出 *encoding* 也沒有給出 *errors*，``str(object)`` 回傳 "
":meth:`type(object).__str__(object) <object."
"__str__>`，這是“非正式的”或者很好印出的*object* "
"的字串表示。對於字串物件，這是字串本身。如果 *object* 沒有 :meth:`~object."
"__str__` 方法，則 :func:`str` 回退到回傳 :meth:`repr(object) <repr>`。"

#: ../../library/stdtypes.rst:1532
#, fuzzy
msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a :"
"term:`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  In "
"this case, if *object* is a :class:`bytes` (or :class:`bytearray`) object, "
"then ``str(bytes, encoding, errors)`` is equivalent to :meth:`bytes."
"decode(encoding, errors) <bytes.decode>`.  Otherwise, the bytes object "
"underlying the buffer object is obtained before calling :meth:`bytes."
"decode`.  See :ref:`binaryseq` and :ref:`bufferobjects` for information on "
"buffer objects."
msgstr ""
"如果至少給出了 *encoding* 或 *errors* 之一，*object* "
"應該是一個類似位元組的物件（例如 :class:`bytes` 或 "
":class:`bytearray`）。在這種情況下，如果 *object* 是一個 bytes（或 "
"bytearray）物件，那麼 str(bytes, encoding, errors) 等價於 bytes.decode "
"（編碼，錯誤）<bytes.decode>`。否則，在呼叫 bytes.decode "
"之前獲取緩衝區對像下的位元組物件。有關緩衝區物件的資訊，請參閱 "
":ref:`binaryseq` 和 :ref:`bufferobjects`。"

#: ../../library/stdtypes.rst:1541
#, fuzzy
msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal "
"string representation (see also the :option:`-b` command-line option to "
"Python).  For example::"
msgstr ""
"將 :class:`bytes` 對像傳遞給 :func:`str` 而沒有 *encoding* 或 *errors* "
"參數屬於回傳非正式字串表示的第一種情況（另請參見 :option:`-b` 命令- Python "
"的行選項）。例如：："

#: ../../library/stdtypes.rst:1549
#, fuzzy
msgid ""
"For more information on the ``str`` class and its methods, see :ref:"
"`textseq` and the :ref:`string-methods` section below.  To output formatted "
"strings, see the :ref:`f-strings` and :ref:`formatstrings` sections.  In "
"addition, see the :ref:`stringservices` section."
msgstr ""
"有關 ``str`` 類及其方法的更多資訊，請參閱下面的 :ref:`textseq` 和 :ref"
":`string-methods` 部分。要輸出格式化字串，請參閱 :ref:`f-strings` "
"和 :ref:`formatstrings` 部分。此外，請參閱 :ref:`stringservices` 部分。"

#: ../../library/stdtypes.rst:1561
#, fuzzy
msgid "String Methods"
msgstr "字串方法"

#: ../../library/stdtypes.rst:1566
#, fuzzy
msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr "字串實作所有 :ref:`common <typesseq-common>` "
"序列操作，以及下面描述的其他方法。"

#: ../../library/stdtypes.rst:1569
#, fuzzy
msgid ""
"Strings also support two styles of string formatting, one providing a large "
"degree of flexibility and customization (see :meth:`str.format`, :ref:"
"`formatstrings` and :ref:`string-formatting`) and the other based on C "
"``printf`` style formatting that handles a narrower range of types and is "
"slightly harder to use correctly, but is often faster for the cases it can "
"handle (:ref:`old-string-formatting`)."
msgstr ""
"字串還支援兩種字串格式化樣式，一種提供了很大程度的靈活性和自定義（請參閱:meth"
":`str.format`、:ref:`formatstrings` 和 :ref:`string-formatting`），"
"另一種基於C ``printf`` 風格的格式化處理範圍較窄的型別並且更難正確使用，但對於"
"它可以處理的情況通常更快（:ref:`old-string-formatting`）。"

#: ../../library/stdtypes.rst:1576
#, fuzzy
msgid ""
"The :ref:`textservices` section of the standard library covers a number of "
"other modules that provide various text related utilities (including regular "
"expression support in the :mod:`re` module)."
msgstr ""
"標準庫的 :ref:`textservices` "
"部分涵蓋了許多提供各種文本相關實用程式的其他模組（包括 :mod:`re` "
"模組中的正則表達式支援）。"

#: ../../library/stdtypes.rst:1582
#, fuzzy
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr "回傳字串的副本，其中第一個字元大寫，其餘字元小寫。"

#: ../../library/stdtypes.rst:1585
#, fuzzy
msgid ""
"The first character is now put into titlecase rather than uppercase. This "
"means that characters like digraphs will only have their first letter "
"capitalized, instead of the full character."
msgstr "第一個字元現在被放入標題而不是大寫。這意味著像二合字母這樣的字元只會將首字母"
"大寫，而不是整個字元。"

#: ../../library/stdtypes.rst:1592
#, fuzzy
msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used for "
"caseless matching."
msgstr "回傳字串的大小寫副本。大小寫字串可用於無大小寫匹配。"

#: ../../library/stdtypes.rst:1595
#, fuzzy
msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is "
"intended to remove all case distinctions in a string. For example, the "
"German lowercase letter ``'ß'`` is equivalent to ``\"ss\"``. Since it is "
"already lowercase, :meth:`lower` would do nothing to ``'ß'``; :meth:"
"`casefold` converts it to ``\"ss\"``."
msgstr ""
"Casefolding "
"類似於小寫，但更激進，因為它旨在刪除字串中的所有大小寫區別。例如，"
"德語小寫字母 ``\\'ß\\'`` 等同於 ``\"ss\"``。因為它已經是小寫了，所以 "
":meth:`lower` 對 ``\\'ß\\'`` 沒有任何作用； :meth:`casefold` 將其轉換為 ``"
"\"ss\"``。"

#: ../../library/stdtypes.rst:1601
#, fuzzy
msgid ""
"The casefolding algorithm is described in section 3.13 of the Unicode "
"Standard."
msgstr "Unicode 標準的第 3.13 節描述了 casefolding 演算法。"

#: ../../library/stdtypes.rst:1609
#, fuzzy
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"以長度*寬度*的字串為中心回傳。使用指定的 *fillchar* 完成填充（預設為 ASCII "
"空格）。如果 *width* 小於或等於 ``len(s)``，則回傳原始字串。"

#: ../../library/stdtypes.rst:1617
#, fuzzy
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"回傳 [*start*, *end*] 範圍內子字串 *sub* 的非重疊出現次數。可選參數 *start* "
"和 *end* 被解釋為切片符號。"

#: ../../library/stdtypes.rst:1621
#, fuzzy
msgid ""
"If *sub* is empty, returns the number of empty strings between characters "
"which is the length of the string plus one."
msgstr "如果 *sub* 為空，則回傳字元之間的空字串數，即字串的長度加一。"

#: ../../library/stdtypes.rst:1627
#, fuzzy
msgid "Return the string encoded to :class:`bytes`."
msgstr "回傳編碼為 :class:`bytes` 的字串。"

#: ../../library/stdtypes.rst:1629 ../../library/stdtypes.rst:2764
#, fuzzy
msgid ""
"*encoding* defaults to ``'utf-8'``; see :ref:`standard-encodings` for "
"possible values."
msgstr "*編碼*預設為``'utf-8'``；請參閱 :ref:`standard-encodings` 了解可能的值。"

#: ../../library/stdtypes.rst:1632
#, fuzzy
msgid ""
"*errors* controls how encoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, "
"``'backslashreplace'`` and any other name registered via :func:`codecs."
"register_error`. See :ref:`error-handlers` for details."
msgstr ""
"*errors* 控制如何處理編碼錯誤。如果 ``'strict'``（預設值），則會引發 "
":exc:`UnicodeError` 例外。其他可能的值是``'ignore'``、``'replace'``、``'xmlch"
"arrefreplace'``、``'backslashreplace'`` 以及通過 :func:`codecs."
"register_error` 註冊的任何其他名稱。有關詳細資訊，請參閱 :ref:`error-"
"handlers`。"

#: ../../library/stdtypes.rst:1639
#, fuzzy
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless an encoding error actually occurs, :ref:`devmode` is enabled or a :"
"ref:`debug build <debug-build>` is used."
msgstr ""
"出於性能原因，不檢查 *errors* 的值是否有效，除非實際發生編碼錯誤，啟用 "
":ref:`devmode` 或使用 :ref:`debug build <debug-build>`。"

#: ../../library/stdtypes.rst:1644 ../../library/stdtypes.rst:2783
msgid "Added support for keyword arguments."
msgstr "新增關鍵字引數的支援。"

#: ../../library/stdtypes.rst:1647 ../../library/stdtypes.rst:2786
#, fuzzy
msgid ""
"The value of the *errors* argument is now checked in :ref:`devmode` and in :"
"ref:`debug mode <debug-build>`."
msgstr "*errors* 參數的值現在在 :ref:`devmode` 和 :ref:`debug mode <debug-build>` "
"中檢查。"

#: ../../library/stdtypes.rst:1654
#, fuzzy
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""
"如果字串以指定的 *suffix* 結尾，則回傳 ``True``，否則回傳 ``False``。 *suffix* "
"也可以是要查找的後綴元組。使用可選的 "
"*start*，測試從該位置開始。使用可選的*end*，在該位置停止比較。"

#: ../../library/stdtypes.rst:1662
#, fuzzy
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current "
"column is set to zero and the string is examined character by character.  If "
"the character is a tab (``\\t``), one or more space characters are inserted "
"in the result until the current column is equal to the next tab position. "
"(The tab character itself is not copied.)  If the character is a newline "
"(``\\n``) or return (``\\r``), it is copied and the current column is reset "
"to zero.  Any other character is copied unchanged and the current column is "
"incremented by one regardless of how the character is represented when "
"printed."
msgstr ""
"回傳字串的副本，其中所有製表符都被一個或多個空格替換，具體取決於當前列和給定"
"的製表符大小。製表符位置每隔 *tabsize* 個字元出現一次（預設值為 8，在第 "
"0、8、16 列等處給出製表符位置）。要擴充字串，將當前列設定為零，然後逐個字元地"
"檢查字串。如果該字元是製表符 (``\\t"
"``)，則在結果中插入一個或多個空格字元，直到當前列等於下一個製表符位置。 "
"（不復制製表符本身。）如果字元是換行符 (``\\n"
"``) 或回車符 (``\\r"
"``)，則復制它並將當前列重置為零。任何其他字元都被原封不動地複制，"
"並且當前列遞增 1，而不管該字元在印出時如何表示。"

#: ../../library/stdtypes.rst:1683
#, fuzzy
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""
"回傳在切片 ``s[start:end]`` 中找到子字串 *sub* 的字串中的最低索引。可選參數 "
"*start* 和 *end* 被解釋為切片符號。如果未找到 *sub*，則回傳 ``-1``。"

#: ../../library/stdtypes.rst:1689
#, fuzzy
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
":meth:`~str.find` 方法應該只在你需要知道 *sub* 的位置時使用。要檢查 *sub* "
"是否為子字串，請使用 :keyword:`in` 運算符::"

#: ../../library/stdtypes.rst:1699
#, fuzzy
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of "
"the corresponding argument."
msgstr ""
"執行字串格式化操作。呼叫此方法的字串可以包含文字文本或由大括號“{}”分隔的替換"
"欄位。每個替換欄位包含位置參數的數字索引或關鍵字參數的名稱。回傳字串的副本，"
"其中每個替換欄位都替換為相應參數的字串值。"

#: ../../library/stdtypes.rst:1709
#, fuzzy
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options "
"that can be specified in format strings."
msgstr "有關可在格式字串中指定的各種格式化選項的說明，請參閱 :ref:`formatstrings`。"

#: ../../library/stdtypes.rst:1713
#, fuzzy
msgid ""
"When formatting a number (:class:`int`, :class:`float`, :class:`complex`, :"
"class:`decimal.Decimal` and subclasses) with the ``n`` type (ex: ``'{:n}'."
"format(1234)``), the function temporarily sets the ``LC_CTYPE`` locale to "
"the ``LC_NUMERIC`` locale to decode ``decimal_point`` and ``thousands_sep`` "
"fields of :c:func:`localeconv` if they are non-ASCII or longer than 1 byte, "
"and the ``LC_NUMERIC`` locale is different than the ``LC_CTYPE`` locale.  "
"This temporary change affects other threads."
msgstr ""
"當使用 ``n`` 型別（例如：`` '{:n}'.format(1234)``)，該函式臨時將 ``LC_CTYPE``"
" 語言環境設定為 ``LC_NUMERIC`` 語言環境以解碼 ``decimal_point`` 和 "
"``thousands_sep`` 欄位 :c:func:`localeconv` 如果它們是非 ASCII 或長於 1 "
"個位元組，並且 ``LC_NUMERIC`` 區域設定不同於 ``LC_CTYPE`` "
"區域設定。此臨時更改會影響其他執行緒。"

#: ../../library/stdtypes.rst:1722
#, fuzzy
msgid ""
"When formatting a number with the ``n`` type, the function sets temporarily "
"the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale in some cases."
msgstr ""
"當使用 ``n`` 型別格式化數字時，該函式在某些情況下會臨時將 ``LC_CTYPE`` "
"區域設定為 ``LC_NUMERIC`` 區域設定。"

#: ../../library/stdtypes.rst:1730
#, fuzzy
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict`.  This is useful if for example "
"``mapping`` is a dict subclass:"
msgstr ""
"與``str.format(**mapping)`` 類似，除了``mapping`` "
"是直接使用的，而不是複製到 :class:`dict`。如果 ``mapping`` 是一個 dict "
"子類別，這將很有用："

#: ../../library/stdtypes.rst:1746
#, fuzzy
msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is "
"not found."
msgstr "類似於 :meth:`~str.find`，但在未找到子字串時引發 :exc:`ValueError`。"

#: ../../library/stdtypes.rst:1752
#, fuzzy
msgid ""
"Return ``True`` if all characters in the string are alphanumeric and there "
"is at least one character, ``False`` otherwise.  A character ``c`` is "
"alphanumeric if one of the following returns ``True``: ``c.isalpha()``, ``c."
"isdecimal()``, ``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""
"如果字串中的所有字元都是字母數字且至少有一個字元，則回傳 ``True``，否則回傳“Fals"
"e”。如果以下其中一項回傳 True，則字元 ``c`` 為字母數字：``c.isalpha()``、``c."
"isdecimal()``、``c.isdigit()`` ，或``c.isnumeric()``。"

#: ../../library/stdtypes.rst:1760
#, fuzzy
msgid ""
"Return ``True`` if all characters in the string are alphabetic and there is "
"at least one character, ``False`` otherwise.  Alphabetic characters are "
"those characters defined in the Unicode character database as \"Letter\", i."
"e., those with general category property being one of \"Lm\", \"Lt\", "
"\"Lu\", \"Ll\", or \"Lo\".  Note that this is different from the "
"\"Alphabetic\" property defined in the Unicode Standard."
msgstr ""
"如果字串中的所有字元都是字母且至少有一個字元，則回傳 ``True``，否則回傳 ``False``。"
"字母字元是那些在 Unicode 字元資料庫中定義為“字母”的字元，即那些具有一般類別屬"
"性為 ``Lm``、 ``Lt``、 ``Lu``、 ``Ll``或 ``Lo``之一的字元。請注意，這與 Unicode "
"標準中定義的“字母”屬性不同。"

#: ../../library/stdtypes.rst:1769
#, fuzzy
msgid ""
"Return ``True`` if the string is empty or all characters in the string are "
"ASCII, ``False`` otherwise. ASCII characters have code points in the range "
"U+0000-U+007F."
msgstr ""
"如果字串為空或字串中的所有字元都是 ASCII，則回傳 ``True``，否則回傳 ``False``。 "
"ASCII 字元的程式碼點在 U+0000-U+007F 範圍內。"

#: ../../library/stdtypes.rst:1778
#, fuzzy
msgid ""
"Return ``True`` if all characters in the string are decimal characters and "
"there is at least one character, ``False`` otherwise. Decimal characters are "
"those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC "
"DIGIT ZERO.  Formally a decimal character is a character in the Unicode "
"General Category \"Nd\"."
msgstr ""
"如果字串中的所有字元都是十進位字元並且至少有一個字元，則回傳 ``True``，否則回傳“"
"False”。十進位字元是那些可用於構成以 10 "
"為基數的數字的字元，例如U+0660，阿拉伯-印度數字零。形式上，十進位字元是 "
"Unicode 通用類別 ``Nd``中的字元。"

#: ../../library/stdtypes.rst:1788
#, fuzzy
msgid ""
"Return ``True`` if all characters in the string are digits and there is at "
"least one character, ``False`` otherwise.  Digits include decimal characters "
"and digits that need special handling, such as the compatibility superscript "
"digits. This covers digits which cannot be used to form numbers in base 10, "
"like the Kharosthi numbers.  Formally, a digit is a character that has the "
"property value Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""
"如果字串中的所有字元都是數字並且至少有一個字元，則回傳 ``True``，否則回傳 ``False``"
"。數字包括十進位字元和需要特殊處理的數字，例如相容性上標數字。"
"這涵蓋了不能用於構成以 10 為基數的數字的數字，例如 Kharosthi 數字。形式上，"
"數字是具有屬性值 Numeric_Type=Digit 或 Numeric_Type=Decimal 的字元。"

#: ../../library/stdtypes.rst:1798
#, fuzzy
msgid ""
"Return ``True`` if the string is a valid identifier according to the "
"language definition, section :ref:`identifiers`."
msgstr "如果字串是根據語言定義的有效標識符，則回傳 True，部分 :ref:`identifiers`。"

#: ../../library/stdtypes.rst:1801
#, fuzzy
msgid ""
"Call :func:`keyword.iskeyword` to test whether string ``s`` is a reserved "
"identifier, such as :keyword:`def` and :keyword:`class`."
msgstr ""
"呼叫 :func:`keyword.iskeyword` 測試字串 ``s`` 是否為保留標識符，例如 "
":keyword:`def` 和 :keyword:`class`。"

#: ../../library/stdtypes.rst:1804
msgid "Example: ::"
msgstr ""
"範例：\n"
"\n"
"::"

#: ../../library/stdtypes.rst:1817
#, fuzzy
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr "如果字串中的所有大小寫字元 [4]_ 都是小寫並且至少有一個大小寫字元，則回傳 "
"``True``，否則回傳``False``。"

#: ../../library/stdtypes.rst:1823
#, fuzzy
msgid ""
"Return ``True`` if all characters in the string are numeric characters, and "
"there is at least one character, ``False`` otherwise. Numeric characters "
"include digit characters, and all characters that have the Unicode numeric "
"value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric "
"characters are those with the property value Numeric_Type=Digit, "
"Numeric_Type=Decimal or Numeric_Type=Numeric."
msgstr ""
"如果字串中的所有字元都是數字字元，並且至少有一個字元，則回傳 ``True``，否則回傳“"
"False”。數字字元包括數字字元，以及所有具有 Unicode "
"數值屬性的字元，例如U+2155，粗俗分數的五分之一。形式上，"
"數字字元是那些具有屬性值 Numeric_Type=Digit、Numeric_Type=Decimal 或 "
"Numeric_Type=Numeric 的字元。"

#: ../../library/stdtypes.rst:1833
#, fuzzy
msgid ""
"Return ``True`` if all characters in the string are printable or the string "
"is empty, ``False`` otherwise.  Nonprintable characters are those characters "
"defined in the Unicode character database as \"Other\" or \"Separator\", "
"excepting the ASCII space (0x20) which is considered printable.  (Note that "
"printable characters in this context are those which should not be escaped "
"when :func:`repr` is invoked on a string.  It has no bearing on the handling "
"of strings written to :data:`sys.stdout` or :data:`sys.stderr`.)"
msgstr ""
"如果字串中的所有字元都是可印出的或字串為空，則回傳 ``True``，否則回傳 ``False``。"
"不可印出字元是在 Unicode 字元資料庫中定義為“其他”或“分隔符”的那些字元，"
"但被視為可印出的 ASCII 空格 (0x20) 除外。 （請注意，"
"此上下文中的可印出字元是在對字串呼叫 :func:`repr` 時不應轉義的字元。它與寫入 "
":data:`sys.stdout` 或 :data 的字串的處理無關:`sys.stderr`。）"

#: ../../library/stdtypes.rst:1844
#, fuzzy
msgid ""
"Return ``True`` if there are only whitespace characters in the string and "
"there is at least one character, ``False`` otherwise."
msgstr "如果字串中只有空白字元且至少有一個字元，則回傳 ``True``，否則回傳 ``False``。"

#: ../../library/stdtypes.rst:1847
#, fuzzy
msgid ""
"A character is *whitespace* if in the Unicode character database (see :mod:"
"`unicodedata`), either its general category is ``Zs`` (\"Separator, "
"space\"), or its bidirectional class is one of ``WS``, ``B``, or ``S``."
msgstr ""
"如果在 Unicode 字元資料庫（參見 :mod:`unicodedata`）中，一個字元是 "
"*whitespace*，它的一般類別是 ``Zs``（“分隔符，空格”），或者它的雙向類是 ``WS "
"之一``、``B`` 或 ``S``。"

#: ../../library/stdtypes.rst:1855
#, fuzzy
msgid ""
"Return ``True`` if the string is a titlecased string and there is at least "
"one character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return ``False`` "
"otherwise."
msgstr ""
"如果字串是大寫字母字串並且至少有一個字元，則回傳 ``True``，例如，大寫字元只能跟"
"隨非大寫字元，而小寫字元只能跟隨大寫字元。否則回傳``False``。"

#: ../../library/stdtypes.rst:1862
#, fuzzy
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr "如果字串中的所有大小寫字元 [4]_ 都是大寫並且至少有一個大小寫字元，則回傳 "
"``True``，否則回傳``False``。"

#: ../../library/stdtypes.rst:1880
#, fuzzy
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. A :"
"exc:`TypeError` will be raised if there are any non-string values in "
"*iterable*, including :class:`bytes` objects.  The separator between "
"elements is the string providing this method."
msgstr ""
"回傳一個字串，它是 *iterable* 中字串的串聯。如果 *iterable* "
"中有任何非字串值，包括 :class:`bytes` 物件，將引發 "
":exc:`TypeError`。元素之間的分隔符是提供此方法的字串。"

#: ../../library/stdtypes.rst:1888
#, fuzzy
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"回傳在長度 * 寬度 * 的字串中左對齊的字串。使用指定的 *fillchar* 完成填充（"
"預設為 ASCII 空格）。如果 *width* 小於或等於 ``len(s)``，則回傳原始字串。"

#: ../../library/stdtypes.rst:1895
#, fuzzy
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr "回傳所有大小寫字元 [4]_ 都轉換為小寫的字串副本。"

#: ../../library/stdtypes.rst:1898
#, fuzzy
msgid ""
"The lowercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr "使用的小寫演算法在 Unicode 標準的第 3.13 節中進行了描述。"

#: ../../library/stdtypes.rst:1904
#, fuzzy
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"回傳刪除前導字元的字串副本。 *chars* "
"參數是一個字串，指定要刪除的字元集。如果省略或 ``None`` ，*chars* "
"參數預設為刪除空格。 *chars* 參數不是前綴；相反，它的值的所有組合都被剝離::"

#: ../../library/stdtypes.rst:1914
#, fuzzy
msgid ""
"See :meth:`str.removeprefix` for a method that will remove a single prefix "
"string rather than all of a set of characters.  For example::"
msgstr "請參閱 :meth:`str.removeprefix` "
"以了解將刪除單個前綴字串而不是所有字元集的方法。例如：："

#: ../../library/stdtypes.rst:1925
#, fuzzy
msgid ""
"This static method returns a translation table usable for :meth:`str."
"translate`."
msgstr "此靜態方法回傳可用於 :meth:`str.translate` 的轉換錶。"

#: ../../library/stdtypes.rst:1927
#, fuzzy
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode ordinals, "
"strings (of arbitrary lengths) or ``None``.  Character keys will then be "
"converted to ordinals."
msgstr ""
"如果只有一個參數，它必須是一個字典，將 Unicode 序數（整數）或字元（長度為 1 "
"的字串）映射到 Unicode "
"序數、字串（任意長度）或 ``None`` 。然後字元鍵將被轉換為序數。"

#: ../../library/stdtypes.rst:1932
#, fuzzy
msgid ""
"If there are two arguments, they must be strings of equal length, and in the "
"resulting dictionary, each character in x will be mapped to the character at "
"the same position in y.  If there is a third argument, it must be a string, "
"whose characters will be mapped to ``None`` in the result."
msgstr ""
"如果有兩個參數，它們必須是等長的字串，並且在生成的字典中，x "
"中的每個字元將映射到 y 中相同位置的字元。如果有第三個參數，它必須是一個字串，"
"其字元將映射到結果中的 ``None`` 。"

#: ../../library/stdtypes.rst:1940
#, fuzzy
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""
"在第一次出現 *sep* 處拆分字串，並回傳一個包含分隔符之前的部分、分隔符本身和分"
"隔符之後的部分的三元組。如果未找到分隔符，則回傳包含字串本身的 3 "
"元組，後跟兩個空字串。"

#: ../../library/stdtypes.rst:1948
#, fuzzy
msgid ""
"If the string starts with the *prefix* string, return "
"``string[len(prefix):]``. Otherwise, return a copy of the original string::"
msgstr "如果字串以 *prefix* 字串開頭，則回傳 "
"``string[len(prefix):]``。否則，回傳原始字串的副本::"

#: ../../library/stdtypes.rst:1962
#, fuzzy
msgid ""
"If the string ends with the *suffix* string and that *suffix* is not empty, "
"return ``string[:-len(suffix)]``. Otherwise, return a copy of the original "
"string::"
msgstr ""
"如果字串以 *suffix* 字串結尾並且 *suffix* 不為空，則回傳 "
"``string[:-len(suffix)]``。否則，回傳原始字串的副本::"

#: ../../library/stdtypes.rst:1976
#, fuzzy
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced "
"by *new*.  If the optional argument *count* is given, only the first *count* "
"occurrences are replaced."
msgstr "回傳字串的副本，所有出現的子字串 *old* 都替換為 *new*。如果給出了可選參數 "
"*count*，則僅替換前 *count* 次出現。"

#: ../../library/stdtypes.rst:1983
#, fuzzy
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start* "
"and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""
"回傳字串中找到子字串 *sub* 的最高索引，這樣 *sub* 就包含在 ``s[start:end]`` "
"中。可選參數 *start* 和 *end* 被解釋為切片符號。失敗時回傳 ``-1``。"

#: ../../library/stdtypes.rst:1990
#, fuzzy
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr "類似於 :meth:`rfind` 但在未找到子字串 *sub* 時引發 :exc:`ValueError`。"

#: ../../library/stdtypes.rst:1996
#, fuzzy
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"回傳在長度 * 寬度 * 的字串中右對齊的字串。使用指定的 *fillchar* 完成填充（"
"預設為 ASCII 空格）。如果 *width* 小於或等於 ``len(s)``，則回傳原始字串。"

#: ../../library/stdtypes.rst:2003
#, fuzzy
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"在最後一次出現 *sep* 處拆分字串，並回傳一個包含分隔符之前的部分、分隔符本身和"
"分隔符之後的部分的三元組。如果未找到分隔符，則回傳包含兩個空字串的 3 "
"元組，後跟字串本身。"

#: ../../library/stdtypes.rst:2011
#, fuzzy
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""
"回傳字串中的單詞列表，使用 *sep* 作為分隔符字串。如果給出 *maxsplit*，"
"則最多進行 *maxsplit* 拆分，*最右邊的*。如果未指定 *sep* "
"或 ``None`` ，則任何空白字串都是分隔符。除了從右側拆分外，rsplit "
"的行為類似於下面詳細描述的 split。"

#: ../../library/stdtypes.rst:2020
#, fuzzy
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"回傳刪除尾隨字元的字串副本。 *chars* "
"參數是一個字串，指定要刪除的字元集。如果省略或 ``None`` ，*chars* "
"參數預設為刪除空格。 *chars* 參數不是後綴；相反，它的值的所有組合都被剝離::"

#: ../../library/stdtypes.rst:2030
#, fuzzy
msgid ""
"See :meth:`str.removesuffix` for a method that will remove a single suffix "
"string rather than all of a set of characters.  For example::"
msgstr "請參閱 :meth:`str.removesuffix` "
"以了解將刪除單個後綴字串而不是所有字元集的方法。例如：："

#: ../../library/stdtypes.rst:2040
#, fuzzy
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""
"回傳字串中的單詞列表，使用 *sep* 作為分隔符字串。如果給出 *maxsplit*，"
"最多完成 *maxsplit* 拆分（因此，列表將最多有 ``maxsplit+1`` 元素）。"
"如果未指定 *maxsplit* 或 ``-1``，則對拆分次數沒有限制（進行所有可能的拆分）。"

#: ../../library/stdtypes.rst:2046
#, fuzzy
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"(for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). "
"Splitting an empty string with a specified separator returns ``['']``."
msgstr ""
"如果給出 "
"*sep*，則連續的分隔符不會組合在一起，並被視為分隔空字串（例如，``'1,,2'."
"split(',')`` 回傳 ``['1', ' ', '2']``). *sep* "
"參數可能包含多個字元（例如，``'1<>2<>3'.split('<>')`` 回傳 ``['1', '2', '3' "
"]``）。使用指定的分隔符拆分空字串會回傳“['']”。"

#: ../../library/stdtypes.rst:2052 ../../library/stdtypes.rst:2068
#: ../../library/stdtypes.rst:2120 ../../library/stdtypes.rst:2188
#: ../../library/stdtypes.rst:2255 ../../library/stdtypes.rst:3102
#: ../../library/stdtypes.rst:3118 ../../library/stdtypes.rst:3209
#: ../../library/stdtypes.rst:3225 ../../library/stdtypes.rst:3250
#: ../../library/stdtypes.rst:3264 ../../library/stdtypes.rst:3292
#: ../../library/stdtypes.rst:3306 ../../library/stdtypes.rst:3324
#: ../../library/stdtypes.rst:3351 ../../library/stdtypes.rst:3374
#: ../../library/stdtypes.rst:3401 ../../library/stdtypes.rst:3443
#: ../../library/stdtypes.rst:3467
msgid "For example::"
msgstr ""
"舉例來說：\n"
"\n"
"::"

#: ../../library/stdtypes.rst:2061
#, fuzzy
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive whitespace are regarded as a single separator, "
"and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty "
"string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""
"如果未指定 *sep* 或為 ``None``，則應用不同的拆分演算法：連續的空格被視為單個分隔"
"符，如果字串有，則結果將在開頭或結尾不包含空字串前導或尾隨空格。因此，用 ``None`` "
"分隔符拆分一個空字串或僅由空格組成的字串會回傳“[]”。"

#: ../../library/stdtypes.rst:2083
#, fuzzy
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line "
"breaks are not included in the resulting list unless *keepends* is given and "
"true."
msgstr "回傳字串中的行列表，在行邊界處斷開。換行符不包含在結果列表中，除非 *keepends*"
" 已給出且為真。"

#: ../../library/stdtypes.rst:2087
#, fuzzy
msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr "此方法在以下行邊界上拆分。特別是，邊界是 :term:`universal newlines` 的超集。"

#: ../../library/stdtypes.rst:2091
#, fuzzy
msgid "Representation"
msgstr "表示"

#: ../../library/stdtypes.rst:2091
msgid "Description"
msgstr "描述"

#: ../../library/stdtypes.rst:2093
msgid "``\\n``"
msgstr "``\\n``"

#: ../../library/stdtypes.rst:2093
#, fuzzy
msgid "Line Feed"
msgstr "換行"

#: ../../library/stdtypes.rst:2095
msgid "``\\r``"
msgstr "``\\r``"

#: ../../library/stdtypes.rst:2095
#, fuzzy
msgid "Carriage Return"
msgstr "回車"

#: ../../library/stdtypes.rst:2097
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: ../../library/stdtypes.rst:2097
#, fuzzy
msgid "Carriage Return + Line Feed"
msgstr "回車+換行"

#: ../../library/stdtypes.rst:2099
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` 或 ``\\x0b``"

#: ../../library/stdtypes.rst:2099
#, fuzzy
msgid "Line Tabulation"
msgstr "行製表"

#: ../../library/stdtypes.rst:2101
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` 或 ``\\x0c``"

#: ../../library/stdtypes.rst:2101
#, fuzzy
msgid "Form Feed"
msgstr "換頁"

#: ../../library/stdtypes.rst:2103
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: ../../library/stdtypes.rst:2103
#, fuzzy
msgid "File Separator"
msgstr "文件分隔符"

#: ../../library/stdtypes.rst:2105
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: ../../library/stdtypes.rst:2105
#, fuzzy
msgid "Group Separator"
msgstr "組分隔符"

#: ../../library/stdtypes.rst:2107
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: ../../library/stdtypes.rst:2107
#, fuzzy
msgid "Record Separator"
msgstr "記錄分隔符"

#: ../../library/stdtypes.rst:2109
msgid "``\\x85``"
msgstr "``\\x85``"

#: ../../library/stdtypes.rst:2109
#, fuzzy
msgid "Next Line (C1 Control Code)"
msgstr "下一行（C1 控制程式碼）"

#: ../../library/stdtypes.rst:2111
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: ../../library/stdtypes.rst:2111
#, fuzzy
msgid "Line Separator"
msgstr "行分隔符"

#: ../../library/stdtypes.rst:2113
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: ../../library/stdtypes.rst:2113
#, fuzzy
msgid "Paragraph Separator"
msgstr "段落分隔符"

#: ../../library/stdtypes.rst:2118
#, fuzzy
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "``\\v`` 和 ``\\f`` 新增到行邊界列表中。"

#: ../../library/stdtypes.rst:2127
#, fuzzy
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr "與 :meth:`~str.split` 不同，當給出分隔符字串 *sep* "
"時，此方法回傳空字串的空列表，並且終端換行符不會導致額外的行::"

#: ../../library/stdtypes.rst:2136
#, fuzzy
msgid "For comparison, ``split('\\n')`` gives::"
msgstr ""
"為了比較，``split('\\n"
"')`` 給出："

#: ../../library/stdtypes.rst:2146
#, fuzzy
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""
"如果字串以 *prefix* 開頭，則回傳 ``True``，否則回傳 ``False``。 *prefix* "
"也可以是要查找的前綴元組。使用可選的 *start*，測試字串從該位置開始。"
"使用可選的 *end*，停止在該位置比較字串。"

#: ../../library/stdtypes.rst:2154
#, fuzzy
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"回傳刪除了前導字元和尾隨字元的字串副本。 *chars* "
"參數是一個字串，指定要刪除的字元集。如果省略或 ``None`` ，*chars* "
"參數預設為刪除空格。 *chars* "
"參數不是前綴或後綴；相反，它的值的所有組合都被剝離::"

#: ../../library/stdtypes.rst:2165
#, fuzzy
msgid ""
"The outermost leading and trailing *chars* argument values are stripped from "
"the string. Characters are removed from the leading end until reaching a "
"string character that is not contained in the set of characters in *chars*. "
"A similar action takes place on the trailing end. For example::"
msgstr ""
"最外面的前導和尾隨 *chars* 參數值從字串中刪除。從前端刪除字元，直到到達 "
"*chars* 中的字元集中不包含的字串字元。類似的動作發生在尾端。例如：："

#: ../../library/stdtypes.rst:2178
#, fuzzy
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase "
"and vice versa. Note that it is not necessarily true that ``s.swapcase()."
"swapcase() == s``."
msgstr "回傳字串的副本，其中大寫字元轉換為小寫，反之亦然。請注意，``s.swapcase()."
"swapcase() == s`` 不一定為真。"

#: ../../library/stdtypes.rst:2185
#, fuzzy
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr "回傳字串的首字母大寫版本，其中單詞以大寫字元開頭，其餘字元為小寫。"

#: ../../library/stdtypes.rst:2193 ../../library/stdtypes.rst:3411
#, fuzzy
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it "
"means that apostrophes in contractions and possessives form word boundaries, "
"which may not be the desired result::"
msgstr ""
"該演算法使用一個簡單的獨立於語言的單詞定義作為連續字母組。該定義適用於許多上"
"下文，但它意味著縮寫中的撇號和所有格形成單詞邊界，這可能不是預期的結果::"

#: ../../library/stdtypes.rst:2201
#, fuzzy
msgid ""
"The :func:`string.capwords` function does not have this problem, as it "
"splits words on spaces only."
msgstr ":func:`string.capwords` 函式沒有這個問題，因為它只在空格處拆分單詞。"

#: ../../library/stdtypes.rst:2204
#, fuzzy
msgid ""
"Alternatively, a workaround for apostrophes can be constructed using regular "
"expressions::"
msgstr "或者，可以使用正則表達式構造撇號的解決方法："

#: ../../library/stdtypes.rst:2219
#, fuzzy
msgid ""
"Return a copy of the string in which each character has been mapped through "
"the given translation table.  The table must be an object that implements "
"indexing via :meth:`__getitem__`, typically a :term:`mapping` or :term:"
"`sequence`.  When indexed by a Unicode ordinal (an integer), the table "
"object can do any of the following: return a Unicode ordinal or a string, to "
"map the character to one or more other characters; return ``None``, to "
"delete the character from the return string; or raise a :exc:`LookupError` "
"exception, to map the character to itself."
msgstr ""
"回傳字串的副本，其中每個字元都已通過給定的轉換錶進行映射。該表必須是通過 "
":meth:`__getitem__` 實作索引的物件，通常是 :term:`mapping` 或 "
":term:`sequence`。當由 Unicode "
"序號（整數）索引時，表物件可以執行以下任何操作：回傳 Unicode "
"序號或字串，將字元映射到一個或多個其他字元； return "
"``None``，從回傳字串中刪除字元；或引發 :exc:`LookupError` "
"例外，將字元映射到自身。"

#: ../../library/stdtypes.rst:2228
#, fuzzy
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from character-"
"to-character mappings in different formats."
msgstr "您可以使用 :meth:`str.maketrans` 從不同格式的字元到字元映射建立轉換映射。"

#: ../../library/stdtypes.rst:2231
#, fuzzy
msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr "另請參閱 :mod:`codecs` 模組以獲得更靈活的自定義字元映射方法。"

#: ../../library/stdtypes.rst:2237
#, fuzzy
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"回傳所有大小寫字元 [4]_ 都轉換為大寫的字串副本。請注意，如果 s.upper()."
"isupper() 包含未區分大小寫的字元或者結果字元的 Unicode 類別不是 ``Lu``（字母, "
"大寫), 但例如 ``Lt``（字母，標題）。"

#: ../../library/stdtypes.rst:2243
#, fuzzy
msgid ""
"The uppercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr "使用的大寫字母演算法在 Unicode 標準的第 3.13 節中進行了描述。"

#: ../../library/stdtypes.rst:2249
#, fuzzy
msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make a "
"string of length *width*. A leading sign prefix (``'+'``/``'-'``) is handled "
"by inserting the padding *after* the sign character rather than before. The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"回傳字串的副本，其中填充了 ASCII ``'0'`` 數字以構成長度為 *width* 的字串。前"
"導符號前綴（``'+'``/``'-'``）通過在符號字元*之後*而不是之前插入填充來處理。"
"如果 *width* 小於或等於 ``len(s)``，則回傳原始字串。"

#: ../../library/stdtypes.rst:2267
#, fuzzy
msgid "``printf``-style String Formatting"
msgstr "``printf`` 風格的字串格式化"

#: ../../library/stdtypes.rst:2280
#, fuzzy
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  Using the newer :ref:`formatted string literals <f-"
"strings>`, the :meth:`str.format` interface, or :ref:`template strings "
"<template-strings>` may help avoid these errors.  Each of these alternatives "
"provides their own trade-offs and benefits of simplicity, flexibility, and/"
"or extensibility."
msgstr ""
"此處描述的格式化操作表現出各種怪癖，這些怪癖會導致許多常見錯誤（例如無法正確"
"顯示元組和字典）。使用較新的 :ref:`格式化字串文字 <f-strings>`、:meth:`str."
"format` 介面或 :ref:`模板字串 <template-strings>` 可能有助於避免這些錯誤。這"
"些備選方案中的每一個都提供了它們自己的權衡和簡單性、靈活性和/或可擴充性的好處"
"。"

#: ../../library/stdtypes.rst:2288
#, fuzzy
msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or *interpolation* "
"operator. Given ``format % values`` (where *format* is a string), ``%`` "
"conversion specifications in *format* are replaced with zero or more "
"elements of *values*. The effect is similar to using the :c:func:`sprintf` "
"in the C language."
msgstr ""
"字串對像有一個獨特的內建操作：``%`` 運算符（取模）。這也稱為字串 *formatting*"
" 或 *interpolation* 運算符。給定 ``format % values``（其中 *format* "
"是一個字串），*format* 中的 ``%`` 轉換規範被替換為 *values* "
"的零個或多個元素。效果類似於在 C 語言中使用 :c:func:`sprintf`。"

#: ../../library/stdtypes.rst:2294
#, fuzzy
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"如果 *format* 需要單個參數，*values* 可以是單個非元組物件。 [5]_ "
"否則，*values* "
"必須是一個元組，其項數正好由格式字串指定，或者是一個映射物件（例如，字典）。"

#: ../../library/stdtypes.rst:2304 ../../library/stdtypes.rst:3522
#, fuzzy
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr "轉換說明符包含兩個或多個字元並具有以下組件，它們必須按以下順序出現："

#: ../../library/stdtypes.rst:2307 ../../library/stdtypes.rst:3525
#, fuzzy
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "``'%'`` 字元，標記說明符的開始。"

#: ../../library/stdtypes.rst:2309 ../../library/stdtypes.rst:3527
#, fuzzy
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters "
"(for example, ``(somename)``)."
msgstr "映射鍵（可選），由帶括號的字元序列組成（例如，``(somename)``）。"

#: ../../library/stdtypes.rst:2312 ../../library/stdtypes.rst:3530
#, fuzzy
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr "轉換旗標（可選），影響某些轉換型別的結果。"

#: ../../library/stdtypes.rst:2315 ../../library/stdtypes.rst:3533
#, fuzzy
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the "
"object to convert comes after the minimum field width and optional precision."
msgstr ""
"最小欄位寬度（可選）。如果指定為 ``'*'``（星號），則實際寬度從 *values* "
"中元組的下一個元素讀取，並且要轉換的物件位於最小欄位寬度和可選精度之後。"

#: ../../library/stdtypes.rst:2319 ../../library/stdtypes.rst:3537
#, fuzzy
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual precision is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr ""
"精度（可選），以``'.'``（點）形式給出，後跟精度。如果指定為 ``*``（星號），"
"則實際精度從 *values* 中元組的下一個元素讀取，並且要轉換的值位於精度之後。"

#: ../../library/stdtypes.rst:2324 ../../library/stdtypes.rst:3542
#, fuzzy
msgid "Length modifier (optional)."
msgstr "長度修飾符（可選）。"

#: ../../library/stdtypes.rst:2326 ../../library/stdtypes.rst:3544
#, fuzzy
msgid "Conversion type."
msgstr "轉換型別。"

#: ../../library/stdtypes.rst:2328
#, fuzzy
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""
"當正確的參數是一個字典（或其他映射型別）時，字串中的格式*必須*包括一個帶括號"
"的映射鍵到字典中，緊接在 ``%``字元之後插入。映射鍵從映射中選擇要格式化的值。例如"
"："

#: ../../library/stdtypes.rst:2337 ../../library/stdtypes.rst:3555
#, fuzzy
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a "
"sequential parameter list)."
msgstr "在這種情況下，格式中不能出現 ``*``說明符（因為它們需要順序參數列表）。"

#: ../../library/stdtypes.rst:2340 ../../library/stdtypes.rst:3558
#, fuzzy
msgid "The conversion flag characters are:"
msgstr "轉換旗標字元是："

#: ../../library/stdtypes.rst:2349 ../../library/stdtypes.rst:3567
#, fuzzy
msgid "Flag"
msgstr "旗幟"

#: ../../library/stdtypes.rst:2351 ../../library/stdtypes.rst:3569
msgid "``'#'``"
msgstr "``'#'``"

#: ../../library/stdtypes.rst:2351 ../../library/stdtypes.rst:3569
#, fuzzy
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr "值轉換將使用“替代形式”（定義如下）。"

#: ../../library/stdtypes.rst:2354 ../../library/stdtypes.rst:3572
msgid "``'0'``"
msgstr "``'0'``"

#: ../../library/stdtypes.rst:2354 ../../library/stdtypes.rst:3572
#, fuzzy
msgid "The conversion will be zero padded for numeric values."
msgstr "對於數值，轉換將被零填充。"

#: ../../library/stdtypes.rst:2356 ../../library/stdtypes.rst:3574
msgid "``'-'``"
msgstr "``'-'``"

#: ../../library/stdtypes.rst:2356 ../../library/stdtypes.rst:3574
#, fuzzy
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr "轉換後的值是左調整的（如果兩者都給定，則覆蓋 ``'0'`` 轉換）。"

#: ../../library/stdtypes.rst:2359 ../../library/stdtypes.rst:3577
msgid "``' '``"
msgstr "``' '``"

#: ../../library/stdtypes.rst:2359 ../../library/stdtypes.rst:3577
#, fuzzy
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr "（一個空格）在有符號轉換產生的正數（或空字串）之前應該留一個空格。"

#: ../../library/stdtypes.rst:2362 ../../library/stdtypes.rst:3580
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/stdtypes.rst:2362 ../../library/stdtypes.rst:3580
#, fuzzy
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides "
"a \"space\" flag)."
msgstr "符號字元（``'+'`` 或 ``'-'``）將在轉換之前（覆蓋“空格”旗標）。"

#: ../../library/stdtypes.rst:2366 ../../library/stdtypes.rst:3584
#, fuzzy
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as "
"it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""
"可能存在長度修飾符（``h``、``l`` 或 ``L``），但會被忽略，因為 Python "
"不需要它——例如``%ld`` 與 ``%d`` 相同。"

#: ../../library/stdtypes.rst:2369 ../../library/stdtypes.rst:3587
#, fuzzy
msgid "The conversion types are:"
msgstr "轉換型別是："

#: ../../library/stdtypes.rst:2372 ../../library/stdtypes.rst:3590
#, fuzzy
msgid "Conversion"
msgstr "轉換"

#: ../../library/stdtypes.rst:2374 ../../library/stdtypes.rst:3592
msgid "``'d'``"
msgstr "``'d'``"

#: ../../library/stdtypes.rst:2374 ../../library/stdtypes.rst:2376
#: ../../library/stdtypes.rst:3592 ../../library/stdtypes.rst:3594
#, fuzzy
msgid "Signed integer decimal."
msgstr "有符號整數十進位。"

#: ../../library/stdtypes.rst:2376 ../../library/stdtypes.rst:3594
msgid "``'i'``"
msgstr "``'i'``"

#: ../../library/stdtypes.rst:2378 ../../library/stdtypes.rst:3596
msgid "``'o'``"
msgstr "``'o'``"

#: ../../library/stdtypes.rst:2378 ../../library/stdtypes.rst:3596
#, fuzzy
msgid "Signed octal value."
msgstr "帶符號的八進位值。"

#: ../../library/stdtypes.rst:2380 ../../library/stdtypes.rst:3598
msgid "``'u'``"
msgstr "``'u'``"

#: ../../library/stdtypes.rst:2380 ../../library/stdtypes.rst:3598
#, fuzzy
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "過時的型別——它與 ``d``相同。"

#: ../../library/stdtypes.rst:2382 ../../library/stdtypes.rst:3600
msgid "``'x'``"
msgstr "``'x'``"

#: ../../library/stdtypes.rst:2382 ../../library/stdtypes.rst:3600
#, fuzzy
msgid "Signed hexadecimal (lowercase)."
msgstr "帶符號的十六進位（小寫）。"

#: ../../library/stdtypes.rst:2384 ../../library/stdtypes.rst:3602
msgid "``'X'``"
msgstr "``'X'``"

#: ../../library/stdtypes.rst:2384 ../../library/stdtypes.rst:3602
#, fuzzy
msgid "Signed hexadecimal (uppercase)."
msgstr "帶符號的十六進位（大寫）。"

#: ../../library/stdtypes.rst:2386 ../../library/stdtypes.rst:3604
msgid "``'e'``"
msgstr "``'e'``"

#: ../../library/stdtypes.rst:2386 ../../library/stdtypes.rst:3604
#, fuzzy
msgid "Floating point exponential format (lowercase)."
msgstr "浮點指數格式（小寫）。"

#: ../../library/stdtypes.rst:2388 ../../library/stdtypes.rst:3606
msgid "``'E'``"
msgstr "``'E'``"

#: ../../library/stdtypes.rst:2388 ../../library/stdtypes.rst:3606
#, fuzzy
msgid "Floating point exponential format (uppercase)."
msgstr "浮點指數格式（大寫）。"

#: ../../library/stdtypes.rst:2390 ../../library/stdtypes.rst:3608
msgid "``'f'``"
msgstr "``'f'``"

#: ../../library/stdtypes.rst:2390 ../../library/stdtypes.rst:2392
#: ../../library/stdtypes.rst:3608 ../../library/stdtypes.rst:3610
#, fuzzy
msgid "Floating point decimal format."
msgstr "浮點十進位格式。"

#: ../../library/stdtypes.rst:2392 ../../library/stdtypes.rst:3610
msgid "``'F'``"
msgstr "``'F'``"

#: ../../library/stdtypes.rst:2394 ../../library/stdtypes.rst:3612
msgid "``'g'``"
msgstr "``'g'``"

#: ../../library/stdtypes.rst:2394 ../../library/stdtypes.rst:3612
#, fuzzy
msgid ""
"Floating point format. Uses lowercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr "浮點格式。如果指數小於 -4 "
"或不小於精度，則使用小寫指數格式，否則使用小數格式。"

#: ../../library/stdtypes.rst:2398 ../../library/stdtypes.rst:3616
msgid "``'G'``"
msgstr "``'G'``"

#: ../../library/stdtypes.rst:2398 ../../library/stdtypes.rst:3616
#, fuzzy
msgid ""
"Floating point format. Uses uppercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr "浮點格式。如果指數小於 -4 "
"或不小於精度，則使用大寫指數格式，否則使用小數格式。"

#: ../../library/stdtypes.rst:2402 ../../library/stdtypes.rst:3620
msgid "``'c'``"
msgstr "``'c'``"

#: ../../library/stdtypes.rst:2402
#, fuzzy
msgid "Single character (accepts integer or single character string)."
msgstr "單個字元（接受整數或單個字串）。"

#: ../../library/stdtypes.rst:2405 ../../library/stdtypes.rst:3633
msgid "``'r'``"
msgstr "``'r'``"

#: ../../library/stdtypes.rst:2405
#, fuzzy
msgid "String (converts any Python object using :func:`repr`)."
msgstr "字串（使用 :func:`repr` 轉換任何 Python 物件）。"

#: ../../library/stdtypes.rst:2408 ../../library/stdtypes.rst:3627
msgid "``'s'``"
msgstr "``'s'``"

#: ../../library/stdtypes.rst:2408
#, fuzzy
msgid "String (converts any Python object using :func:`str`)."
msgstr "字串（使用 :func:`str` 轉換任何 Python 物件）。"

#: ../../library/stdtypes.rst:2411 ../../library/stdtypes.rst:3630
msgid "``'a'``"
msgstr "``'a'``"

#: ../../library/stdtypes.rst:2411
#, fuzzy
msgid "String (converts any Python object using :func:`ascii`)."
msgstr "字串（使用 :func:`ascii` 轉換任何 Python 物件）。"

#: ../../library/stdtypes.rst:2414 ../../library/stdtypes.rst:3636
msgid "``'%'``"
msgstr "``'%'``"

#: ../../library/stdtypes.rst:2414 ../../library/stdtypes.rst:3636
#, fuzzy
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr "沒有參數被轉換，在結果中產生一個 ``'%'`` 字元。"

#: ../../library/stdtypes.rst:2421 ../../library/stdtypes.rst:3643
#, fuzzy
msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be "
"inserted before the first digit."
msgstr "替代形式導致在第一個數字之前插入前導八進位說明符 (``'0o'``)。"

#: ../../library/stdtypes.rst:2425 ../../library/stdtypes.rst:3647
#, fuzzy
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr "替代形式導致前導 ``0x``或 ``0X``（取決於是否使用 ``x``或 ``X``格式）在第一個數字。"

#: ../../library/stdtypes.rst:2429 ../../library/stdtypes.rst:3651
#, fuzzy
msgid ""
"The alternate form causes the result to always contain a decimal point, even "
"if no digits follow it."
msgstr "替代形式導致結果始終包含小數點，即使後面沒有數字。"

#: ../../library/stdtypes.rst:2432 ../../library/stdtypes.rst:3654
#, fuzzy
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr "精度決定小數點後的位數，預設為6。"

#: ../../library/stdtypes.rst:2436 ../../library/stdtypes.rst:3658
#, fuzzy
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr "替代形式導致結果始終包含小數點，並且不會像其他情況那樣刪除尾隨零。"

#: ../../library/stdtypes.rst:2439 ../../library/stdtypes.rst:3661
#, fuzzy
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr "精度決定小數點前後的有效位數，預設為6。"

#: ../../library/stdtypes.rst:2443 ../../library/stdtypes.rst:3665
#, fuzzy
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr "如果精度為 ``N``，則輸出將被截斷為 ``N``個字元。"

#: ../../library/stdtypes.rst:2446 ../../library/stdtypes.rst:3674
msgid "See :pep:`237`."
msgstr "參閱 :pep:`237`\\ 。"

#: ../../library/stdtypes.rst:2448
#, fuzzy
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr "由於 Python 字串有明確的長度，``%s`` 轉換不假定 ``'\\0'`` 是字串的結尾。"

#: ../../library/stdtypes.rst:2453
#, fuzzy
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr "絕對值超過 1e50 的數字的 ``%f`` 轉換不再被 ``%g`` 轉換替換。"

#: ../../library/stdtypes.rst:2464
#, fuzzy
msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"
msgstr "二進位序列型別 --- :class:`bytes`, :class:`bytearray`, :class:`memoryview`"

#: ../../library/stdtypes.rst:2472
#, fuzzy
msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` and :"
"class:`bytearray`. They are supported by :class:`memoryview` which uses the :"
"ref:`buffer protocol <bufferobjects>` to access the memory of other binary "
"objects without needing to make a copy."
msgstr ""
"用於操作二進位資料的核心內建型別是 :class:`bytes` 和 :class:`bytearray`。"
"它們由 :class:`memoryview` 支援，它使用 :ref:`buffer 協定 <bufferobjects>` "
"來訪問其他二進位物件的記憶體而無需複制。"

#: ../../library/stdtypes.rst:2477
#, fuzzy
msgid ""
"The :mod:`array` module supports efficient storage of basic data types like "
"32-bit integers and IEEE754 double-precision floating values."
msgstr ":mod:`array` 模組支援高效儲存基本資料型別，例如 32 位整數和 IEEE754 "
"雙精度浮點值。"

#: ../../library/stdtypes.rst:2483
#, fuzzy
msgid "Bytes Objects"
msgstr "位元組物件"

#: ../../library/stdtypes.rst:2487
#, fuzzy
msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major "
"binary protocols are based on the ASCII text encoding, bytes objects offer "
"several methods that are only valid when working with ASCII compatible data "
"and are closely related to string objects in a variety of other ways."
msgstr ""
"位元組對像是單位元組的不可變序列。由於許多主要的二進位協定都基於 ASCII "
"文本編碼，因此 bytes 物件提供了幾種方法，這些方法僅在處理 ASCII "
"相容資料時有效，並且在其他方面與字串物件密切相關。"

#: ../../library/stdtypes.rst:2494
#, fuzzy
msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for "
"string literals, except that a ``b`` prefix is added:"
msgstr "首先，位元組字面量的語法與字串字面量的語法基本相同，除了新增了 ``b``前綴："

#: ../../library/stdtypes.rst:2497
#, fuzzy
msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr "單引號：``b'仍然允許嵌入 ``雙``引號'``"

#: ../../library/stdtypes.rst:2498
#, fuzzy
msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``"
msgstr "雙引號：``b\"仍然允許嵌入\\'單\\'引號\"``"

#: ../../library/stdtypes.rst:2499
#, fuzzy
msgid ""
"Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"
msgstr "三引號：``b\\'\\'\\'3 個單引號\\'\\'\\'``, ``b\"\"\"3 個雙引號\"\"\"``"

#: ../../library/stdtypes.rst:2501
#, fuzzy
msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be entered "
"into bytes literals using the appropriate escape sequence."
msgstr ""
"位元組文字中只允許使用 ASCII 字元（無論聲明的源程式碼編碼如何）。"
"必須使用適當的轉義序列將任何超過 127 的二進位值輸入到位元組文字中。"

#: ../../library/stdtypes.rst:2505
#, fuzzy
msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to "
"disable processing of escape sequences. See :ref:`strings` for more about "
"the various forms of bytes literal, including supported escape sequences."
msgstr ""
"與字串文字一樣，位元組文字也可以使用 ``r`` 前綴來禁用轉義序列的處理。有關各種"
"形式的位元組文字的更多資訊，包括支援的轉義序列，請參閱 :ref:`strings`。"

#: ../../library/stdtypes.rst:2509
#, fuzzy
msgid ""
"While bytes literals and representations are based on ASCII text, bytes "
"objects actually behave like immutable sequences of integers, with each "
"value in the sequence restricted such that ``0 <= x < 256`` (attempts to "
"violate this restriction will trigger :exc:`ValueError`). This is done "
"deliberately to emphasise that while many binary formats include ASCII based "
"elements and can be usefully manipulated with some text-oriented algorithms, "
"this is not generally the case for arbitrary binary data (blindly applying "
"text processing algorithms to binary data formats that are not ASCII "
"compatible will usually lead to data corruption)."
msgstr ""
"雖然位元組字面量和表示基於 ASCII "
"文本，但位元組物件實際上表現得像不可變的整數序列，序列中的每個值都受到限制，"
"例如 ``0 <= x < 256``（試圖違反此限制將觸發 :exc :`值錯誤`)。"
"這樣做是為了強調雖然許多二進位格式包括基於 ASCII 的元素並且可以使用一些面向文"
"本的演算法進行有效操作，但對於任意二進位資料通常情況並非如此（"
"盲目地將文本處理演算法應用於不是ASCII 相容通常會導致資料損壞）。"

#: ../../library/stdtypes.rst:2519
#, fuzzy
msgid ""
"In addition to the literal forms, bytes objects can be created in a number "
"of other ways:"
msgstr "除了文字形式之外，還可以通過多種其他方式建立位元組物件："

#: ../../library/stdtypes.rst:2522
#, fuzzy
msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr "指定長度的零填充位元組物件：``bytes(10)``"

#: ../../library/stdtypes.rst:2523
#, fuzzy
msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr "來自整數的可疊代：``bytes(range(20))``"

#: ../../library/stdtypes.rst:2524
#, fuzzy
msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr "通過緩衝協定複製現有的二進位資料：``bytes(obj)``"

#: ../../library/stdtypes.rst:2526
#, fuzzy
msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr "另請參閱內建的 :ref:`bytes <func-bytes>`。"

#: ../../library/stdtypes.rst:2528
#, fuzzy
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytes type has an additional class method to read data in "
"that format:"
msgstr "由於2個十六進位數正好對應一個位元組，因此十六進位數是描述二進位資料的常用格式"
"。因此，位元組型別有一個額外的類方法來讀取該格式的資料："

#: ../../library/stdtypes.rst:2534
#, fuzzy
msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the given "
"string object.  The string must contain two hexadecimal digits per byte, "
"with ASCII whitespace being ignored."
msgstr ""
"這個 :class:`bytes` 類方法回傳一個位元組物件，解碼給定的字串物件。該字串每個"
"位元組必須包含兩個十六進位數字，忽略 ASCII 空格。"

#: ../../library/stdtypes.rst:2541
#, fuzzy
msgid ""
":meth:`bytes.fromhex` now skips all ASCII whitespace in the string, not just "
"spaces."
msgstr ":meth:`bytes.fromhex` 現在跳過字串中的所有 ASCII 空格，而不僅僅是空格。"

#: ../../library/stdtypes.rst:2545
#, fuzzy
msgid ""
"A reverse conversion function exists to transform a bytes object into its "
"hexadecimal representation."
msgstr "存在反向轉換函式，可將位元組物件轉換為其十六進位表示形式。"

#: ../../library/stdtypes.rst:2550 ../../library/stdtypes.rst:2635
#, fuzzy
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the instance."
msgstr "回傳一個字串物件，其中包含實例中每個位元組的兩個十六進位數字。"

#: ../../library/stdtypes.rst:2556
#, fuzzy
msgid ""
"If you want to make the hex string easier to read, you can specify a single "
"character separator *sep* parameter to include in the output. By default, "
"this separator will be included between each byte. A second optional "
"*bytes_per_sep* parameter controls the spacing. Positive values calculate "
"the separator position from the right, negative values from the left."
msgstr ""
"如果要使十六進位字串更易於閱讀，可以指定單個字元分隔符 *sep* "
"參數以包含在輸出中。預設情況下，此分隔符將包含在每個位元組之間。第二個可選的 "
"*bytes_per_sep* 參數控制間距。正值從右側計算分隔符位置，負值從左側計算。"

#: ../../library/stdtypes.rst:2573
#, fuzzy
msgid ""
":meth:`bytes.hex` now supports optional *sep* and *bytes_per_sep* parameters "
"to insert separators between bytes in the hex output."
msgstr ""
":meth:`bytes.hex` 現在支援可選的 *sep* 和 *bytes_per_sep* "
"參數以在十六進位輸出的位元組之間插入分隔符。"

#: ../../library/stdtypes.rst:2577
#, fuzzy
msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a bytes "
"object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a bytes "
"object of length 1.  (This contrasts with text strings, where both indexing "
"and slicing will produce a string of length 1)"
msgstr ""
"由於位元組對像是整數序列（類似於元組），對於位元組物件 *b*，``b[0]`` "
"將是一個整數，而``b[0:1]`` 將是一個位元組長度為 1 "
"的物件。（這與文本字串形成對比，其中索引和切片都將生成長度為 1 的字串）"

#: ../../library/stdtypes.rst:2582
#, fuzzy
msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) "
"since it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can "
"always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""
"位元組物件的表示使用文字格式（``b'...'``）因為它通常比例如更有用。 "
"``位元組（[46、46、46]）``。您始終可以使用 list(b) "
"將位元組物件轉換為整數列表。"

#: ../../library/stdtypes.rst:2590
#, fuzzy
msgid "Bytearray Objects"
msgstr "位元組數組物件"

#: ../../library/stdtypes.rst:2594
#, fuzzy
msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` "
"objects."
msgstr ":class:`bytearray` 對像是 :class:`bytes` 物件的可變物件。"

#: ../../library/stdtypes.rst:2599
#, fuzzy
msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they are "
"always created by calling the constructor:"
msgstr "bytearray 對像沒有專門的文字語法，它們總是通過呼叫構造函式來建立："

#: ../../library/stdtypes.rst:2602
#, fuzzy
msgid "Creating an empty instance: ``bytearray()``"
msgstr "建立一個空實例：``bytearray()``"

#: ../../library/stdtypes.rst:2603
#, fuzzy
msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr "建立一個給定長度的零填充實例：``bytearray(10)``"

#: ../../library/stdtypes.rst:2604
#, fuzzy
msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr "來自整數的可疊代：``bytearray(range(20))``"

#: ../../library/stdtypes.rst:2605
#, fuzzy
msgid ""
"Copying existing binary data via the buffer protocol:  ``bytearray(b'Hi!')``"
msgstr "通過緩衝協定複製現有的二進位資料：``bytearray(b'Hi!')``"

#: ../../library/stdtypes.rst:2607
#, fuzzy
msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable <typesseq-"
"mutable>` sequence operations in addition to the common bytes and bytearray "
"operations described in :ref:`bytes-methods`."
msgstr ""
"由於 bytearray 對像是可變的，因此除了 bytes-methods 中描述的常見位元組和 "
"bytearray 操作之外，它們還支援 mutable <typesseq-mutable> 序列操作。"

#: ../../library/stdtypes.rst:2611
#, fuzzy
msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr "另請參閱 :ref:`bytearray <func-bytearray>` 內建。"

#: ../../library/stdtypes.rst:2613
#, fuzzy
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytearray type has an additional class method to read data "
"in that format:"
msgstr ""
"由於2個十六進位數正好對應一個位元組，因此十六進位數是描述二進位資料的常用格式"
"。因此，bytearray 型別有一個額外的類方法來讀取該格式的資料："

#: ../../library/stdtypes.rst:2619
#, fuzzy
msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding the "
"given string object.  The string must contain two hexadecimal digits per "
"byte, with ASCII whitespace being ignored."
msgstr ""
"這個 :class:`bytearray` 類方法回傳 bytearray "
"物件，解碼給定的字串物件。該字串每個位元組必須包含兩個十六進位數字，忽略 "
"ASCII 空格。"

#: ../../library/stdtypes.rst:2626
#, fuzzy
msgid ""
":meth:`bytearray.fromhex` now skips all ASCII whitespace in the string, not "
"just spaces."
msgstr ":meth:`bytearray.fromhex` 現在跳過字串中的所有 ASCII 空格，而不僅僅是空格。"

#: ../../library/stdtypes.rst:2630
#, fuzzy
msgid ""
"A reverse conversion function exists to transform a bytearray object into "
"its hexadecimal representation."
msgstr "存在反向轉換函式，可將位元組數組物件轉換為其十六進位表示形式。"

#: ../../library/stdtypes.rst:2643
#, fuzzy
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`bytearray.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
"與 :meth:`bytes.hex` 類似，:meth:`bytearray.hex` 現在支援可選的 *sep* 和 "
"*bytes_per_sep* 參數以在十六進位輸出中的位元組之間插入分隔符。"

#: ../../library/stdtypes.rst:2648
#, fuzzy
msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a "
"bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be "
"a bytearray object of length 1.  (This contrasts with text strings, where "
"both indexing and slicing will produce a string of length 1)"
msgstr ""
"由於位元組數組對像是整數序列（類似於列表），對於位元組數組物件 *b*，``b[0]`` "
"將是一個整數，而``b[0:1]`` 將是一個位元組數組長度為 1 "
"的物件。（這與文本字串形成對比，其中索引和切片都將生成長度為 1 的字串）"

#: ../../library/stdtypes.rst:2653
#, fuzzy
msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. "
"``bytearray([46, 46, 46])``.  You can always convert a bytearray object into "
"a list of integers using ``list(b)``."
msgstr ""
"bytearray 物件的表示使用位元組文字格式（``bytearray(b'...')``），因為它通常比"
"例如``bytearray([46, 46, 46])``。您始終可以使用 list(b) 將 bytearray "
"物件轉換為整數列表。"

#: ../../library/stdtypes.rst:2662
#, fuzzy
msgid "Bytes and Bytearray Operations"
msgstr "位元組和位元組數組操作"

#: ../../library/stdtypes.rst:2667
#, fuzzy
msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-common>` "
"sequence operations. They interoperate not just with operands of the same "
"type, but with any :term:`bytes-like object`. Due to this flexibility, they "
"can be freely mixed in operations without causing errors. However, the "
"return type of the result may depend on the order of operands."
msgstr ""
"bytes 和 bytearray 對像都支援 :ref:`common <typesseq-common>` "
"序列操作。它們不僅與相同型別的操作數互操作，而且與任何 :term:`bytes-like "
"object` 互操作。由於這種靈活性，它們可以在操作中自由混合而不會導致錯誤。但是"
"，結果的回傳型別可能取決於操作數的順序。"

#: ../../library/stdtypes.rst:2675
#, fuzzy
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr "bytes 和 bytearray 物件的方法不接受字串作為它們的參數，就像字串的方法不接受位"
"元組作為它們的參數一樣。例如，你必須寫::"

#: ../../library/stdtypes.rst:2682
msgid "and::"
msgstr ""
"和：\n"
"\n"
"::"

#: ../../library/stdtypes.rst:2687
#, fuzzy
msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible "
"binary formats, and hence should be avoided when working with arbitrary "
"binary data. These restrictions are covered below."
msgstr "某些位元組和位元組數組操作假設使用 ASCII "
"相容的二進位格式，因此在處理任意二進位資料時應避免使用。下面介紹了這些限制。"

#: ../../library/stdtypes.rst:2692
#, fuzzy
msgid ""
"Using these ASCII based operations to manipulate binary data that is not "
"stored in an ASCII based format may lead to data corruption."
msgstr "使用這些基於 ASCII 的操作來操作未以基於 ASCII "
"的格式儲存的二進位資料可能會導致資料損壞。"

#: ../../library/stdtypes.rst:2695
#, fuzzy
msgid ""
"The following methods on bytes and bytearray objects can be used with "
"arbitrary binary data."
msgstr "位元組和位元組數組物件的以下方法可用於任意二進位資料。"

#: ../../library/stdtypes.rst:2701
#, fuzzy
msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"回傳 [*start*, *end*] 範圍內子序列 *sub* 的非重疊出現次數。可選參數 *start* "
"和 *end* 被解釋為切片符號。"

#: ../../library/stdtypes.rst:2705 ../../library/stdtypes.rst:2810
#: ../../library/stdtypes.rst:2832 ../../library/stdtypes.rst:2898
#: ../../library/stdtypes.rst:2911
#, fuzzy
msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an "
"integer in the range 0 to 255."
msgstr "要搜索的子序列可以是任何 :term:`bytes-like object` 或 0 到 255 範圍內的整數。"

#: ../../library/stdtypes.rst:2708
#, fuzzy
msgid ""
"If *sub* is empty, returns the number of empty slices between characters "
"which is the length of the bytes object plus one."
msgstr "如果 *sub* 為空，則回傳字元之間的空切片數，即位元組物件的長度加一。"

#: ../../library/stdtypes.rst:2711 ../../library/stdtypes.rst:2822
#: ../../library/stdtypes.rst:2835 ../../library/stdtypes.rst:2901
#: ../../library/stdtypes.rst:2914
#, fuzzy
msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr "還接受 0 到 255 範圍內的整數作為子序列。"

#: ../../library/stdtypes.rst:2718
#, fuzzy
msgid ""
"If the binary data starts with the *prefix* string, return "
"``bytes[len(prefix):]``. Otherwise, return a copy of the original binary "
"data::"
msgstr "如果二進位資料以 *prefix* 字串開頭，則回傳 "
"``bytes[len(prefix):]``。否則，回傳原始二進位資料的副本::"

#: ../../library/stdtypes.rst:2727
#, fuzzy
msgid "The *prefix* may be any :term:`bytes-like object`."
msgstr "*prefix* 可以是任何 :term:`bytes-like object`。"

#: ../../library/stdtypes.rst:2731 ../../library/stdtypes.rst:2753
#: ../../library/stdtypes.rst:2886 ../../library/stdtypes.rst:2979
#: ../../library/stdtypes.rst:2993 ../../library/stdtypes.rst:3024
#: ../../library/stdtypes.rst:3038 ../../library/stdtypes.rst:3080
#: ../../library/stdtypes.rst:3150 ../../library/stdtypes.rst:3168
#: ../../library/stdtypes.rst:3196 ../../library/stdtypes.rst:3335
#: ../../library/stdtypes.rst:3390 ../../library/stdtypes.rst:3433
#: ../../library/stdtypes.rst:3454 ../../library/stdtypes.rst:3476
#: ../../library/stdtypes.rst:3678
#, fuzzy
msgid ""
"The bytearray version of this method does *not* operate in place - it always "
"produces a new object, even if no changes were made."
msgstr "此方法的 bytearray 版本 *不* 就地操作 - "
"它總是生成一個新物件，即使未進行任何更改。"

#: ../../library/stdtypes.rst:2740
#, fuzzy
msgid ""
"If the binary data ends with the *suffix* string and that *suffix* is not "
"empty, return ``bytes[:-len(suffix)]``.  Otherwise, return a copy of the "
"original binary data::"
msgstr ""
"如果二進位資料以 *suffix* 字串結尾並且 *suffix* 不為空，則回傳 "
"``bytes[:-len(suffix)]``。否則，回傳原始二進位資料的副本::"

#: ../../library/stdtypes.rst:2749
#, fuzzy
msgid "The *suffix* may be any :term:`bytes-like object`."
msgstr "*suffix* 可以是任何 :term:`bytes-like object`。"

#: ../../library/stdtypes.rst:2762
#, fuzzy
msgid "Return the bytes decoded to a :class:`str`."
msgstr "將解碼後的位元組回傳到 :class:`str`。"

#: ../../library/stdtypes.rst:2767
#, fuzzy
msgid ""
"*errors* controls how decoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, and any other name registered via :func:"
"`codecs.register_error`. See :ref:`error-handlers` for details."
msgstr ""
"*errors* 控制如何處理解碼錯誤。如果 ``'strict'``（預設值），則會引發 "
":exc:`UnicodeError` 例外。其他可能的值是“忽略”、“替換”以及通過 "
"codecs.register_error 註冊的任何其他名稱。有關詳細資訊，請參閱 :ref:`error-"
"handlers`。"

#: ../../library/stdtypes.rst:2773
#, fuzzy
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless a decoding error actually occurs, :ref:`devmode` is enabled or a :ref:"
"`debug build <debug-build>` is used."
msgstr ""
"出於性能原因，不檢查 *errors* 的值是否有效，除非實際發生解碼錯誤，啟用 "
":ref:`devmode` 或使用 :ref:`debug build <debug-build>`。"

#: ../../library/stdtypes.rst:2779
#, fuzzy
msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any :term:"
"`bytes-like object` directly, without needing to make a temporary :class:`!"
"bytes` or :class:`!bytearray` object."
msgstr ""
"將 *encoding* 參數傳遞給 :class:`str` 允許直接解碼任何 :term:`bytes-like "
"object`，而不需要建立一個臨時的 :class:`!bytes` 或 :class:`!bytearray` 物件。"

#: ../../library/stdtypes.rst:2794
#, fuzzy
msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, "
"otherwise return ``False``.  *suffix* can also be a tuple of suffixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"如果二進位資料以指定的 *suffix* 結尾，則回傳 ``True``，否則回傳 ``False``。 "
"*suffix* 也可以是要查找的後綴元組。使用可選的 "
"*start*，測試從該位置開始。使用可選的*end*，在該位置停止比較。"

#: ../../library/stdtypes.rst:2799
#, fuzzy
msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr "要搜索的後綴可以是任何 :term:`bytes-like object`。"

#: ../../library/stdtypes.rst:2805
#, fuzzy
msgid ""
"Return the lowest index in the data where the subsequence *sub* is found, "
"such that *sub* is contained in the slice ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation.  Return "
"``-1`` if *sub* is not found."
msgstr ""
"回傳資料中找到子序列 *sub* 的最低索引，這樣 *sub* 就包含在切片 "
"``s[start:end]`` 中。可選參數 *start* 和 *end* 被解釋為切片符號。如果未找到 "
"*sub*，則回傳 ``-1``。"

#: ../../library/stdtypes.rst:2815
#, fuzzy
msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
":meth:`~bytes.find` 方法應該只在你需要知道 *sub* 的位置時使用。要檢查 *sub* "
"是否為子字串，請使用 :keyword:`in` 運算符::"

#: ../../library/stdtypes.rst:2829
#, fuzzy
msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the subsequence "
"is not found."
msgstr "類似於 :meth:`~bytes.find`，但在未找到子序列時引發 :exc:`ValueError`。"

#: ../../library/stdtypes.rst:2842
#, fuzzy
msgid ""
"Return a bytes or bytearray object which is the concatenation of the binary "
"data sequences in *iterable*.  A :exc:`TypeError` will be raised if there "
"are any values in *iterable* that are not :term:`bytes-like objects <bytes-"
"like object>`, including :class:`str` objects.  The separator between "
"elements is the contents of the bytes or bytearray object providing this "
"method."
msgstr ""
"回傳一個 bytes 或 bytearray 物件，它是 *iterable* 中二進位資料序列的串聯。"
"如果 *iterable* 中有任何值不是 :term:`bytes-like objects <bytes-like "
"object>`，包括 :class:`str` 物件，將引發 :exc:`TypeError`。元素之間的分隔符是"
"提供此方法的位元組或位元組數組物件的內容。"

#: ../../library/stdtypes.rst:2853
#, fuzzy
msgid ""
"This static method returns a translation table usable for :meth:`bytes."
"translate` that will map each character in *from* into the character at the "
"same position in *to*; *from* and *to* must both be :term:`bytes-like "
"objects <bytes-like object>` and have the same length."
msgstr ""
"此靜態方法回傳可用於 bytes.translate 的轉換錶，它將 *from* "
"中的每個字元映射到 *to* 中相同位置的字元； *from* 和 *to* 必須都是 :term"
":`bytes-like objects <bytes-like object>` 並且具有相同的長度。"

#: ../../library/stdtypes.rst:2864
#, fuzzy
msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing a copy of the original sequence, followed "
"by two empty bytes or bytearray objects."
msgstr ""
"在第一次出現 *sep* 時拆分序列，並回傳一個三元組，其中包含分隔符之前的部分、分"
"隔符本身或其位元組數組副本以及分隔符之後的部分。如果未找到分隔符，則回傳包含"
"原始序列副本的三元組，後跟兩個空位元組或位元組數組物件。"

#: ../../library/stdtypes.rst:2871 ../../library/stdtypes.rst:2928
#, fuzzy
msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr "要搜索的分隔符可以是任何 :term:`bytes-like object`。"

#: ../../library/stdtypes.rst:2877
#, fuzzy
msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr "回傳序列的副本，所有出現的子序列 *old* 都替換為 *new*。如果給出了可選參數 "
"*count*，則僅替換前 *count* 次出現。"

#: ../../library/stdtypes.rst:2881
#, fuzzy
msgid ""
"The subsequence to search for and its replacement may be any :term:`bytes-"
"like object`."
msgstr "要搜索的子序列及其替換可以是任何 :term:`bytes-like object`。"

#: ../../library/stdtypes.rst:2893
#, fuzzy
msgid ""
"Return the highest index in the sequence where the subsequence *sub* is "
"found, such that *sub* is contained within ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation. Return "
"``-1`` on failure."
msgstr ""
"回傳找到子序列 *sub* 的序列中的最高索引，這樣 *sub* 包含在 ``s[start:end]`` "
"中。可選參數 *start* 和 *end* 被解釋為切片符號。失敗時回傳 ``-1``。"

#: ../../library/stdtypes.rst:2908
#, fuzzy
msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the subsequence "
"*sub* is not found."
msgstr "類似於 :meth:`~bytes.rfind` 但在未找到子序列 *sub* 時引發 :exc:`ValueError`。"

#: ../../library/stdtypes.rst:2921
#, fuzzy
msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing two empty bytes or bytearray objects, "
"followed by a copy of the original sequence."
msgstr ""
"在最後一次出現 *sep* 時拆分序列，並回傳一個三元組，其中包含分隔符之前的部分、"
"分隔符本身或其位元組數組副本以及分隔符之後的部分。如果未找到分隔符，則回傳包"
"含兩個空位元組或位元組數組物件的三元組，後跟原始序列的副本。"

#: ../../library/stdtypes.rst:2934
#, fuzzy
msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, "
"otherwise return ``False``.  *prefix* can also be a tuple of prefixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"如果二進位資料以指定的 *prefix* 開頭，則回傳 ``True``，否則回傳 ``False``。 "
"*prefix* 也可以是要查找的前綴元組。使用可選的 "
"*start*，測試從該位置開始。使用可選的*end*，在該位置停止比較。"

#: ../../library/stdtypes.rst:2939
#, fuzzy
msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr "要搜索的前綴可以是任何 :term:`bytes-like object`。"

#: ../../library/stdtypes.rst:2945
#, fuzzy
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in "
"the optional argument *delete* are removed, and the remaining bytes have "
"been mapped through the given translation table, which must be a bytes "
"object of length 256."
msgstr ""
"回傳 bytes 或 bytearray 物件的副本，其中刪除了可選參數 *delete* "
"中出現的所有位元組，其餘位元組已通過給定的轉換錶進行映射，"
"該轉換錶必須是長度為 256 的 bytes 物件。"

#: ../../library/stdtypes.rst:2950
#, fuzzy
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation table."
msgstr "您可以使用 :func:`bytes.maketrans` 方法建立轉換錶。"

#: ../../library/stdtypes.rst:2953
#, fuzzy
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr "對於只刪除字元的翻譯，將 *table* 參數設定為 ``None``::"

#: ../../library/stdtypes.rst:2959
#, fuzzy
msgid "*delete* is now supported as a keyword argument."
msgstr "*delete* 現在支援作為關鍵字參數。"

#: ../../library/stdtypes.rst:2963
#, fuzzy
msgid ""
"The following methods on bytes and bytearray objects have default behaviours "
"that assume the use of ASCII compatible binary formats, but can still be "
"used with arbitrary binary data by passing appropriate arguments. Note that "
"all of the bytearray methods in this section do *not* operate in place, and "
"instead produce new objects."
msgstr ""
"bytes 和 bytearray 物件的以下方法具有假定使用 ASCII 相容二進位格式的預設行為"
"，但仍然可以通過傳遞適當的參數與任意二進位資料一起使用。請注意，本節中的所有 "
"bytearray 方法 *不* 就地操作，而是生成新物件。"

#: ../../library/stdtypes.rst:2972
#, fuzzy
msgid ""
"Return a copy of the object centered in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"回傳以長度 * 寬度 * 的序列為中心的物件的副本。填充是使用指定的 *fillbyte* （"
"預設為 ASCII 空格）完成的。對於 :class:`bytes` 物件，如果 *width* 小於或等於 "
"``len(s)`` 則回傳原始序列。"

#: ../../library/stdtypes.rst:2986
#, fuzzy
msgid ""
"Return a copy of the object left justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"回傳以長度 * 寬度 * 的序列左對齊的物件副本。填充是使用指定的 *fillbyte* （"
"預設為 ASCII 空格）完成的。對於 :class:`bytes` 物件，如果 *width* 小於或等於 "
"``len(s)`` 則回傳原始序列。"

#: ../../library/stdtypes.rst:3000
#, fuzzy
msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a prefix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"回傳刪除了指定前導位元組的序列副本。 *chars* "
"參數是一個二進位序列，指定要刪除的位元組值集——這個名稱指的是這個方法通常用於 "
"ASCII 字元。如果省略或 ``None`` ，*chars* 參數預設為刪除 ASCII 空格。 *chars* "
"參數不是前綴；相反，它的值的所有組合都被剝離::"

#: ../../library/stdtypes.rst:3012
#, fuzzy
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removeprefix` for a method that will remove a "
"single prefix string rather than all of a set of characters.  For example::"
msgstr ""
"要刪除的位元組值的二進位序列可以是任何 :term:`bytes-like object`。請參閱 "
":meth:`~bytes.removeprefix` "
"以了解將刪除單個前綴字串而不是所有字元集的方法。例如：："

#: ../../library/stdtypes.rst:3031
#, fuzzy
msgid ""
"Return a copy of the object right justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"回傳以長度 * 寬度 * 的序列右對齊的物件副本。填充是使用指定的 *fillbyte* （"
"預設為 ASCII 空格）完成的。對於 :class:`bytes` 物件，如果 *width* 小於或等於 "
"``len(s)`` 則回傳原始序列。"

#: ../../library/stdtypes.rst:3045
#, fuzzy
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are "
"done, the *rightmost* ones.  If *sep* is not specified or ``None``, any "
"subsequence consisting solely of ASCII whitespace is a separator. Except for "
"splitting from the right, :meth:`rsplit` behaves like :meth:`split` which is "
"described in detail below."
msgstr ""
"將二進位序列拆分為相同型別的子序列，使用 *sep* 作為分隔符字串。如果給出 "
"*maxsplit*，則最多進行 *maxsplit* 拆分，*最右邊的*。如果未指定 *sep* 或 ``None`` ，"
"則任何僅由 ASCII 空格組成的子序列都是分隔符。除了從右側拆分外，rsplit "
"的行為類似於下面詳細描述的 split。"

#: ../../library/stdtypes.rst:3056
#, fuzzy
msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"回傳刪除了指定尾隨位元組的序列副本。 *chars* "
"參數是一個二進位序列，指定要刪除的位元組值集——這個名稱指的是這個方法通常用於 "
"ASCII 字元。如果省略或 ``None`` ，*chars* 參數預設為刪除 ASCII 空格。 *chars* "
"參數不是後綴；相反，它的值的所有組合都被剝離::"

#: ../../library/stdtypes.rst:3068
#, fuzzy
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removesuffix` for a method that will remove a "
"single suffix string rather than all of a set of characters.  For example::"
msgstr ""
"要刪除的位元組值的二進位序列可以是任何 :term:`bytes-like object`。請參閱 "
":meth:`~bytes.removesuffix` "
"以了解將刪除單個後綴字串而不是所有字元集的方法。例如：："

#: ../../library/stdtypes.rst:3087
#, fuzzy
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given and non-negative, at most "
"*maxsplit* splits are done (thus, the list will have at most ``maxsplit+1`` "
"elements).  If *maxsplit* is not specified or is ``-1``, then there is no "
"limit on the number of splits (all possible splits are made)."
msgstr ""
"將二進位序列拆分為相同型別的子序列，使用 *sep* 作為分隔符字串。如果給出 "
"*maxsplit* 且非負，則最多完成 *maxsplit* 拆分（因此，列表將最多包含 "
"``maxsplit+1`` 元素）。如果 *maxsplit* "
"未指定或為 ``-1``，則拆分次數沒有限制（所有可能的拆分都會進行）。"

#: ../../library/stdtypes.rst:3093
#, fuzzy
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty subsequences (for example, ``b'1,,2'.split(b',')`` "
"returns ``[b'1', b'', b'2']``).  The *sep* argument may consist of a "
"multibyte sequence (for example, ``b'1<>2<>3'.split(b'<>')`` returns "
"``[b'1', b'2', b'3']``). Splitting an empty sequence with a specified "
"separator returns ``[b'']`` or ``[bytearray(b'')]`` depending on the type of "
"object being split.  The *sep* argument may be any :term:`bytes-like object`."
msgstr ""
"如果給出 "
"*sep*，則連續的定界符不會組合在一起，並被視為定界空子序列（例如，``b'1,,2'."
"split(b',')`` 回傳 ``[b'1 ', b'', b'2']``). *sep* "
"參數可能包含多位元組序列（例如，``b'1<>2<>3'.split(b'<>')`` 回傳 ``[b'1', "
"b'2 ', b'3']``).使用指定的分隔符拆分空序列會回傳“[b'']”或“[bytearray(b'')]”，"
"具體取決於要拆分的物件的型別。 *sep* 參數可以是任何 :term:`bytes-like "
"object`。"

#: ../../library/stdtypes.rst:3111
#, fuzzy
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive ASCII whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or end "
"if the sequence has leading or trailing whitespace.  Consequently, splitting "
"an empty sequence or a sequence consisting solely of ASCII whitespace "
"without a specified separator returns ``[]``."
msgstr ""
"如果 *sep* 未指定或為 ``None``，則應用不同的拆分演算法：連續的 ASCII 空格的運行"
"被視為單個分隔符，如果序列的開頭或結尾處不包含空字串，則結果將不包含空字串有"
"前導或尾隨空格。因此，拆分空序列或僅由沒有指定分隔符的 ASCII "
"空格組成的序列會回傳“[]”。"

#: ../../library/stdtypes.rst:3132
#, fuzzy
msgid ""
"Return a copy of the sequence with specified leading and trailing bytes "
"removed. The *chars* argument is a binary sequence specifying the set of "
"byte values to be removed - the name refers to the fact this method is "
"usually used with ASCII characters.  If omitted or ``None``, the *chars* "
"argument defaults to removing ASCII whitespace. The *chars* argument is not "
"a prefix or suffix; rather, all combinations of its values are stripped::"
msgstr ""
"回傳刪除了指定前導和尾隨位元組的序列副本。 *chars* "
"參數是一個二進位序列，指定要刪除的位元組值集——這個名稱指的是這個方法通常用於 "
"ASCII 字元。如果省略或 ``None`` ，*chars* 參數預設為刪除 ASCII 空格。 *chars* "
"參數不是前綴或後綴；相反，它的值的所有組合都被剝離::"

#: ../../library/stdtypes.rst:3145
#, fuzzy
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`."
msgstr "要刪除的位元組值的二進位序列可以是任何 :term:`bytes-like object`。"

#: ../../library/stdtypes.rst:3154
#, fuzzy
msgid ""
"The following methods on bytes and bytearray objects assume the use of ASCII "
"compatible binary formats and should not be applied to arbitrary binary "
"data. Note that all of the bytearray methods in this section do *not* "
"operate in place, and instead produce new objects."
msgstr ""
"位元組和位元組數組物件的以下方法假定使用 ASCII "
"相容的二進位格式，不應應用於任意二進位資料。請注意，本節中的所有 bytearray "
"方法 *不* 就地操作，而是生成新物件。"

#: ../../library/stdtypes.rst:3162
#, fuzzy
msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII "
"character, and the first byte capitalized and the rest lowercased. Non-ASCII "
"byte values are passed through unchanged."
msgstr "回傳序列的副本，每個位元組都被解釋為 ASCII "
"字元，第一個位元組大寫，其餘位元組小寫。非 ASCII 位元組值不加改變地通過。"

#: ../../library/stdtypes.rst:3175
#, fuzzy
msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced by "
"one or more ASCII spaces, depending on the current column and the given tab "
"size.  Tab positions occur every *tabsize* bytes (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the sequence, the "
"current column is set to zero and the sequence is examined byte by byte.  If "
"the byte is an ASCII tab character (``b'\\t'``), one or more space "
"characters are inserted in the result until the current column is equal to "
"the next tab position. (The tab character itself is not copied.)  If the "
"current byte is an ASCII newline (``b'\\n'``) or carriage return "
"(``b'\\r'``), it is copied and the current column is reset to zero.  Any "
"other byte value is copied unchanged and the current column is incremented "
"by one regardless of how the byte value is represented when printed::"
msgstr ""
"回傳序列的副本，其中所有 ASCII 製表符都被一個或多個 ASCII "
"空格替換，具體取決於當前列和給定的製表符大小。製表符位置每隔 *tabsize* "
"位元組出現一次（預設值為 8，在第 0、8、16 "
"列等處給出製表符位置）。為了擴充序列，將當前列設定為零，並逐位元組檢查序列。"
"如果位元組是 ASCII 製表符 (``b'\\t"
"'``)，一個或多個空格字元將插入結果中，直到當前列等於下一個製表符位置。 "
"（不復制製表符本身。）如果當前位元組是 ASCII 換行符 (``b'\\n"
"'``) 或回車符 (``b'\\r"
"'``)，則它被複製並且當前列重置為零。任何其他位元組值都被原封不動地複制，"
"並且當前列遞增 1，而不管位元組值在印出時如何表示："

#: ../../library/stdtypes.rst:3203
#, fuzzy
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetical ASCII "
"characters or ASCII decimal digits and the sequence is not empty, ``False`` "
"otherwise. Alphabetic ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII decimal "
"digits are those byte values in the sequence ``b'0123456789'``."
msgstr ""
"如果序列中的所有位元組都是字母 ASCII 字元或 ASCII "
"十進位數字並且序列不為空，則回傳 ``True``，否則回傳 ``False``。字母 ASCII 字元是序"
"列“b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ”中的那些位元組值。 "
"ASCII 十進位數字是序列“b'0123456789”中的那些位元組值。"

#: ../../library/stdtypes.rst:3220
#, fuzzy
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetic ASCII characters "
"and the sequence is not empty, ``False`` otherwise.  Alphabetic ASCII "
"characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"如果序列中的所有位元組都是字母 ASCII "
"字元並且序列不為空，則回傳 ``True``，否則回傳 ``False``。字母 ASCII 字元是序列“b'ab"
"cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ”中的那些位元組值。"

#: ../../library/stdtypes.rst:3236
#, fuzzy
msgid ""
"Return ``True`` if the sequence is empty or all bytes in the sequence are "
"ASCII, ``False`` otherwise. ASCII bytes are in the range 0-0x7F."
msgstr "如果序列為空或序列中的所有位元組都是 ASCII，則回傳 ``True``，否則回傳 ``False``。 "
"ASCII 位元組在 0-0x7F 範圍內。"

#: ../../library/stdtypes.rst:3246
#, fuzzy
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII decimal digits and "
"the sequence is not empty, ``False`` otherwise. ASCII decimal digits are "
"those byte values in the sequence ``b'0123456789'``."
msgstr ""
"如果序列中的所有位元組都是 ASCII "
"十進位數字並且序列不為空，則回傳 ``True``，否則回傳 ``False``。 ASCII "
"十進位數字是序列“b'0123456789”中的那些位元組值。"

#: ../../library/stdtypes.rst:3261
#, fuzzy
msgid ""
"Return ``True`` if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, ``False`` otherwise."
msgstr "如果序列中至少有一個小寫 ASCII 字元且沒有大寫 ASCII "
"字元，則回傳 ``True``，否則回傳 ``False``。"

#: ../../library/stdtypes.rst:3271 ../../library/stdtypes.rst:3313
#: ../../library/stdtypes.rst:3329 ../../library/stdtypes.rst:3379
#: ../../library/stdtypes.rst:3448
#, fuzzy
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"小寫 ASCII 字元是序列“b'abcdefghijklmnopqrstuvwxyz”中的那些位元組值。大寫 "
"ASCII 字元是序列“b'ABCDEFGHIJKLMNOPQRSTUVWXYZ”中的那些位元組值。"

#: ../../library/stdtypes.rst:3279
#, fuzzy
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, ``False`` otherwise.  ASCII whitespace characters are "
"those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""
"如果序列中的所有位元組都是 ASCII "
"空白且序列不為空，則回傳 ``True``，否則回傳 ``False``。 ASCII 空白字元是序列 ``b' "
"\\t\\n"
"\\r\\x0b\\f'`` "
"中的那些位元組值（空格、製表符、換行符、回車符、垂直製表符、換頁符）。"

#: ../../library/stdtypes.rst:3288
#, fuzzy
msgid ""
"Return ``True`` if the sequence is ASCII titlecase and the sequence is not "
"empty, ``False`` otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""
"如果序列是 ASCII titlecase 且序列不為空，則回傳 ``True``，否則回傳 ``False``。有關“"
"titlecase”定義的更多詳細資訊，請參閱 :meth:`bytes.title`。"

#: ../../library/stdtypes.rst:3303
#, fuzzy
msgid ""
"Return ``True`` if there is at least one uppercase alphabetic ASCII "
"character in the sequence and no lowercase ASCII characters, ``False`` "
"otherwise."
msgstr "如果序列中至少有一個大寫字母 ASCII 字元且沒有小寫 ASCII "
"字元，則回傳 ``True``，否則回傳 ``False``。"

#: ../../library/stdtypes.rst:3321
#, fuzzy
msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters "
"converted to their corresponding lowercase counterpart."
msgstr "回傳序列的副本，其中所有大寫 ASCII 字元都轉換為對應的小寫字元。"

#: ../../library/stdtypes.rst:3346
#, fuzzy
msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line "
"boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list unless "
"*keepends* is given and true."
msgstr ""
"回傳二進位序列中的行列表，在 ASCII 行邊界處斷開。此方法使用 :term:`universal "
"newlines` 方法來拆分行。換行符不包含在結果列表中，除非 *keepends* "
"已給出且為真。"

#: ../../library/stdtypes.rst:3358
#, fuzzy
msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"與 :meth:`~bytes.split` 不同，當給出分隔符字串 *sep* "
"時，此方法回傳空字串的空列表，並且終端換行符不會導致額外的行::"

#: ../../library/stdtypes.rst:3371
#, fuzzy
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart and vice-versa."
msgstr "回傳序列的副本，其中所有小寫 ASCII 字元都轉換為相應的大寫字元，反之亦然。"

#: ../../library/stdtypes.rst:3383
#, fuzzy
msgid ""
"Unlike :func:`str.swapcase()`, it is always the case that ``bin.swapcase()."
"swapcase() == bin`` for the binary versions. Case conversions are "
"symmetrical in ASCII, even though that is not generally true for arbitrary "
"Unicode code points."
msgstr ""
"與 :func:`str.swapcase()` 不同，二進位版本總是 ``bin.swapcase().swapcase() "
"== bin``。大小寫轉換在 ASCII 中是對稱的，儘管對於任意 Unicode "
"程式碼點通常不是這樣。"

#: ../../library/stdtypes.rst:3397
#, fuzzy
msgid ""
"Return a titlecased version of the binary sequence where words start with an "
"uppercase ASCII character and the remaining characters are lowercase. "
"Uncased byte values are left unmodified."
msgstr "回傳二進位序列的首字母大寫版本，其中單詞以大寫 ASCII "
"字元開頭，其餘字元為小寫。 Uncased 位元組值保持不變。"

#: ../../library/stdtypes.rst:3406
#, fuzzy
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other byte "
"values are uncased."
msgstr ""
"小寫 ASCII 字元是序列“b'abcdefghijklmnopqrstuvwxyz”中的那些位元組值。大寫 "
"ASCII 字元是序列“b'ABCDEFGHIJKLMNOPQRSTUVWXYZ”中的那些位元組值。所有其他位元"
"組值都是不區分大小寫的。"

#: ../../library/stdtypes.rst:3419
#, fuzzy
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr "可以使用正則表達式構建撇號的解決方法："

#: ../../library/stdtypes.rst:3440
#, fuzzy
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart."
msgstr "回傳序列的副本，其中所有小寫 ASCII 字元都轉換為相應的大寫字元。"

#: ../../library/stdtypes.rst:3461
#, fuzzy
msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to make "
"a sequence of length *width*. A leading sign prefix (``b'+'``/ ``b'-'``) is "
"handled by inserting the padding *after* the sign character rather than "
"before. For :class:`bytes` objects, the original sequence is returned if "
"*width* is less than or equal to ``len(seq)``."
msgstr ""
"回傳用 ASCII ``b'0'`` 數字填充的序列的副本，以構成長度 * 寬度 * "
"的序列。前導符號前綴（``b'+'``/ "
"``b'-'``）通過在符號字元*之後*而不是之前插入填充來處理。對於 :class:`bytes` "
"物件，如果 *width* 小於或等於 ``len(seq)`` 則回傳原始序列。"

#: ../../library/stdtypes.rst:3483
#, fuzzy
msgid "``printf``-style Bytes Formatting"
msgstr "``printf`` 風格的位元組格式化"

#: ../../library/stdtypes.rst:3500
#, fuzzy
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  If the value being printed may be a tuple or "
"dictionary, wrap it in a tuple."
msgstr ""
"此處描述的格式化操作表現出各種怪癖，這些怪癖會導致許多常見錯誤（例如無法正確"
"顯示元組和字典）。如果要印出的值可能是元組或字典，請將其包裝在元組中。"

#: ../../library/stdtypes.rst:3505
#, fuzzy
msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in operation: "
"the ``%`` operator (modulo). This is also known as the bytes *formatting* or "
"*interpolation* operator. Given ``format % values`` (where *format* is a "
"bytes object), ``%`` conversion specifications in *format* are replaced with "
"zero or more elements of *values*. The effect is similar to using the :c:"
"func:`sprintf` in the C language."
msgstr ""
"位元組物件（``bytes``/``bytearray``）有一個獨特的內建操作：``%`` "
"運算符（取模）。這也稱為位元組 *formatting* 或 *interpolation* 運算符。給定 "
"``format % values``（其中 *format* 是位元組物件），*format* 中的 ``%`` "
"轉換規範被替換為 *values* 的零個或多個元素。效果類似於在 C 語言中使用 "
":c:func:`sprintf`。"

#: ../../library/stdtypes.rst:3512
#, fuzzy
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format bytes object, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"如果 *format* 需要單個參數，*values* 可以是單個非元組物件。 [5]_ "
"否則，*values* "
"必須是一個元組，其項數恰好由格式位元組對像或單個映射物件（例如字典）指定。"

#: ../../library/stdtypes.rst:3546
#, fuzzy
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the bytes object *must* include a parenthesised mapping key into "
"that dictionary inserted immediately after the ``'%'`` character. The "
"mapping key selects the value to be formatted from the mapping.  For example:"
msgstr ""
"當正確的參數是一個字典（或其他映射型別）時，位元組對像中的格式*必須*包括一個"
"帶括號的映射鍵到字典中，緊接在 ``%``字元之後插入。映射鍵從映射中選擇要格式化的值"
"。例如："

#: ../../library/stdtypes.rst:3620
#, fuzzy
msgid "Single byte (accepts integer or single byte objects)."
msgstr "單位元組（接受整數或單位元組物件）。"

#: ../../library/stdtypes.rst:3623
msgid "``'b'``"
msgstr "``'b'``"

#: ../../library/stdtypes.rst:3623
#, fuzzy
msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>` or "
"has :meth:`__bytes__`)."
msgstr ""
"位元組（任何遵循 :ref:`buffer protocol <bufferobjects>` 或具有 "
":meth:`__bytes__` 的物件）。"

#: ../../library/stdtypes.rst:3627
#, fuzzy
msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 code "
"bases."
msgstr "``'s'`` 是 ``'b'`` 的別名，只能用於 Python2/3 程式碼庫。"

#: ../../library/stdtypes.rst:3630
#, fuzzy
msgid ""
"Bytes (converts any Python object using ``repr(obj).encode('ascii', "
"'backslashreplace')``)."
msgstr ""
"位元組（使用 ``repr(obj).encode('ascii', 'backslashreplace')`` 轉換任何 "
"Python 物件）。"

#: ../../library/stdtypes.rst:3633
#, fuzzy
msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 code "
"bases."
msgstr "``'r'`` 是 ``'a'`` 的別名，只能用於 Python2/3 程式碼庫。"

#: ../../library/stdtypes.rst:3633
msgid "\\(7)"
msgstr "\\(7)"

#: ../../library/stdtypes.rst:3668
#, fuzzy
msgid "``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%s'`` 已棄用，但不會在 3.x 系列中刪除。"

#: ../../library/stdtypes.rst:3671
#, fuzzy
msgid "``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%r'`` 已棄用，但不會在 3.x 系列中刪除。"

#: ../../library/stdtypes.rst:3683
#, fuzzy
msgid ":pep:`461` - Adding % formatting to bytes and bytearray"
msgstr ":pep:`461` - 將 % 格式新增到 bytes 和 bytearray"

#: ../../library/stdtypes.rst:3690
#, fuzzy
msgid "Memory Views"
msgstr "記憶體視圖"

#: ../../library/stdtypes.rst:3692
#, fuzzy
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of "
"an object that supports the :ref:`buffer protocol <bufferobjects>` without "
"copying."
msgstr ""
":class:`memoryview` 物件允許 Python 程式碼訪問支援 :ref:`緩衝協定 "
"<bufferobjects>` 的物件的內部資料而無需複制。"

#: ../../library/stdtypes.rst:3698
#, fuzzy
msgid ""
"Create a :class:`memoryview` that references *object*.  *object* must "
"support the buffer protocol.  Built-in objects that support the buffer "
"protocol include :class:`bytes` and :class:`bytearray`."
msgstr ""
"建立一個引用 *object* 的 :class:`memoryview`。 *object* "
"必須支援緩衝協定。支援緩衝協定的內建物件包括 :class:`bytes` "
"和 :class:`bytearray`。"

#: ../../library/stdtypes.rst:3702
#, fuzzy
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating *object*.  For many simple types such "
"as :class:`bytes` and :class:`bytearray`, an element is a single byte, but "
"other types such as :class:`array.array` may have bigger elements."
msgstr ""
":class:`memoryview` 具有 *element* 的概念，它是由原始 *object* "
"處理的原子記憶體單元。對於許多簡單型別，例如 :class:`bytes` 和 "
":class:`bytearray`，一個元素是單個位元組，但其他型別，例如 :class:`array."
"array` 可能有更大的元素。"

#: ../../library/stdtypes.rst:3707
#, fuzzy
msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`. If "
"``view.ndim = 0``, the length is 1. If ``view.ndim = 1``, the length is "
"equal to the number of elements in the view. For higher dimensions, the "
"length is equal to the length of the nested list representation of the view. "
"The :class:`~memoryview.itemsize` attribute will give you the number of "
"bytes in a single element."
msgstr ""
"``len(view)`` 等於 :class:`~memoryview.tolist` 的長度。如果 ``view.ndim = "
"0``，則長度為 1。如果``view.ndim = 1``，則長度等於視圖中的元素數。對於更高的"
"維度，長度等於視圖的嵌套列表表示的長度。 :class:`~memoryview.itemsize` "
"屬性將為您提供單個元素中的位元組數。"

#: ../../library/stdtypes.rst:3714
#, fuzzy
msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. One-"
"dimensional slicing will result in a subview::"
msgstr ":class:`memoryview` 支援切片和索引以公開其資料。一維切片將產生一個子視圖::"

#: ../../library/stdtypes.rst:3727
#, fuzzy
msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers from "
"the :mod:`struct` module, indexing with an integer or a tuple of integers is "
"also supported and returns a single *element* with the correct type.  One-"
"dimensional memoryviews can be indexed with an integer or a one-integer "
"tuple.  Multi-dimensional memoryviews can be indexed with tuples of exactly "
"*ndim* integers where *ndim* is the number of dimensions.  Zero-dimensional "
"memoryviews can be indexed with the empty tuple."
msgstr ""
"如果 :class:`~memoryview.format` 是來自 :mod:`struct` "
"模組的原生格式說明符之一，則還支援使用整數或整數元組進行索引，"
"並回傳具有正確型別的單個 *element* ."
"一維記憶體視圖可以用整數或單整數元組索引。多維記憶體視圖可以使用精確 *ndim* "
"整數的元組進行索引，其中 *ndim* 是維數。零維記憶體視圖可以用空元組索引。"

#: ../../library/stdtypes.rst:3736
#, fuzzy
msgid "Here is an example with a non-byte format::"
msgstr "這是一個非位元組格式的例子："

#: ../../library/stdtypes.rst:3748
#, fuzzy
msgid ""
"If the underlying object is writable, the memoryview supports one-"
"dimensional slice assignment. Resizing is not allowed::"
msgstr "如果底層對像是可寫的，則記憶體視圖支援一維切片分配。不允許調整大小::"

#: ../../library/stdtypes.rst:3769
#, fuzzy
msgid ""
"One-dimensional memoryviews of :term:`hashable` (read-only) types with "
"formats 'B', 'b' or 'c' are also hashable. The hash is defined as ``hash(m) "
"== hash(m.tobytes())``::"
msgstr ""
"格式為 ``B``、 ``b``或 ``c``的 "
":term:`hashable`（只讀）型別的一維記憶體視圖也是可散列的。散列定義為``hash(m)"
" == hash(m.tobytes())``::"

#: ../../library/stdtypes.rst:3781
#, fuzzy
msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional memoryviews "
"with formats 'B', 'b' or 'c' are now :term:`hashable`."
msgstr "現在可以對一維記憶體視圖進行切片。格式為 ``B``、 ``b``或 ``c``的一維記憶體視圖現在是可"
"散列的。"

#: ../../library/stdtypes.rst:3785
#, fuzzy
msgid ""
"memoryview is now registered automatically with :class:`collections.abc."
"Sequence`"
msgstr "memoryview 現在自動註冊了 :class:`collections.abc.Sequence`"

#: ../../library/stdtypes.rst:3789
#, fuzzy
msgid "memoryviews can now be indexed with tuple of integers."
msgstr "memoryviews 現在可以用整數元組索引。"

#: ../../library/stdtypes.rst:3792
#, fuzzy
msgid ":class:`memoryview` has several methods:"
msgstr ":class:`memoryview` 有幾個方法："

#: ../../library/stdtypes.rst:3796
#, fuzzy
msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are "
"equivalent and if all corresponding values are equal when the operands' "
"respective format codes are interpreted using :mod:`struct` syntax."
msgstr ""
"如果使用 :mod:`struct` 語法解釋操作數各自的格式程式碼時，如果 memoryview 和 "
":pep:`3118` 導出器的形狀相同，並且所有對應值都相等，則它們是相等的。"

#: ../../library/stdtypes.rst:3800
#, fuzzy
msgid ""
"For the subset of :mod:`struct` format strings currently supported by :meth:"
"`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == w.tolist()``::"
msgstr ""
"對於 :meth:`tolist` 當前支援的 :mod:`struct` 格式字串的子集，如果 ``v."
"tolist() == w.tolist() 則 ``v`` 和 ``w`` 相等``::"

#: ../../library/stdtypes.rst:3819
#, fuzzy
msgid ""
"If either format string is not supported by the :mod:`struct` module, then "
"the objects will always compare as unequal (even if the format strings and "
"buffer contents are identical)::"
msgstr "如果 :mod:`struct` 模組不支援任一格式字串，則物件將始終比較為不相等（即使格式"
"字串和緩衝區內容相同）::"

#: ../../library/stdtypes.rst:3835
#, fuzzy
msgid ""
"Note that, as with floating point numbers, ``v is w`` does *not* imply ``v "
"== w`` for memoryview objects."
msgstr "請注意，與浮點數一樣，``v is w`` *不* 暗示記憶體視圖物件的``v == w``。"

#: ../../library/stdtypes.rst:3838
#, fuzzy
msgid ""
"Previous versions compared the raw memory disregarding the item format and "
"the logical array structure."
msgstr "以前的版本不考慮項目格式和邏輯數組結構來比較原始記憶體。"

#: ../../library/stdtypes.rst:3844
#, fuzzy
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr "將緩衝區中的資料作為位元組串回傳。這相當於在記憶體視圖上呼叫 bytes 構造函式。"
" ::"

#: ../../library/stdtypes.rst:3853
#, fuzzy
msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` "
"supports all format strings, including those that are not in :mod:`struct` "
"module syntax."
msgstr ""
"對於非連續數組，結果等於所有元素都轉換為位元組的扁平化列表表示。 "
":meth:`tobytes` 支援所有格式字串，包括那些不在 :mod:`struct` "
"模組語法中的字串。"

#: ../../library/stdtypes.rst:3858
#, fuzzy
msgid ""
"*order* can be {'C', 'F', 'A'}.  When *order* is 'C' or 'F', the data of the "
"original array is converted to C or Fortran order. For contiguous views, 'A' "
"returns an exact copy of the physical memory. In particular, in-memory "
"Fortran order is preserved. For non-contiguous views, the data is converted "
"to C first. *order=None* is the same as *order='C'*."
msgstr ""
"*order* 可以是 {'C', 'F', 'A'}。當*order*為'C'或'F'時，將原數組的資料轉換為C"
"或Fortran順序。對於連續視圖， ``A``回傳物理記憶體的精確副本。特別是，"
"保留了記憶體中的 Fortran 順序。對於非連續視圖，首先將資料轉換為 C。 "
"*order=None* 與 *order='C'* 相同。"

#: ../../library/stdtypes.rst:3867
#, fuzzy
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the buffer. ::"
msgstr "回傳一個字串物件，其中包含緩衝區中每個位元組的兩個十六進位數字。 ::"

#: ../../library/stdtypes.rst:3876
#, fuzzy
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`memoryview.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
"與 :meth:`bytes.hex` 類似，:meth:`memoryview.hex` 現在支援可選的 *sep* 和 "
"*bytes_per_sep* 參數以在十六進位輸出中的位元組之間插入分隔符。"

#: ../../library/stdtypes.rst:3883
#, fuzzy
msgid "Return the data in the buffer as a list of elements. ::"
msgstr "將緩衝區中的資料作為元素列表回傳。 ::"

#: ../../library/stdtypes.rst:3893
#, fuzzy
msgid ""
":meth:`tolist` now supports all single character native formats in :mod:"
"`struct` module syntax as well as multi-dimensional representations."
msgstr ":meth:`tolist` 現在支援 :mod:`struct` "
"模組語法中的所有單字元本機格式以及多維表示。"

#: ../../library/stdtypes.rst:3900
#, fuzzy
msgid ""
"Return a readonly version of the memoryview object.  The original memoryview "
"object is unchanged. ::"
msgstr "回傳記憶體視圖物件的只讀版本。原始 memoryview 對像沒有改變。 ::"

#: ../../library/stdtypes.rst:3919
#, fuzzy
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a :"
"class:`bytearray` would temporarily forbid resizing); therefore, calling "
"release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""
"釋放記憶體視圖物件暴露的底層緩衝區。許多對像在持有視圖時會採取特殊操作（例如"
"，bytearray 會暫時禁止調整大小）；因此，呼叫 release() "
"可以方便地盡快移除這些限制（並釋放任何懸空資源）。"

#: ../../library/stdtypes.rst:3925
#, fuzzy
msgid ""
"After this method has been called, any further operation on the view raises "
"a :class:`ValueError` (except :meth:`release()` itself which can be called "
"multiple times)::"
msgstr ""
"呼叫此方法後，對視圖的任何進一步操作都會引發 :class:`ValueError`（除了 "
":meth:`release()` 本身可以多次呼叫）::"

#: ../../library/stdtypes.rst:3936
#, fuzzy
msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr "上下文管理協定可以用於類似的效果，使用``with``語句::"

#: ../../library/stdtypes.rst:3952
#, fuzzy
msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to "
"``[byte_length//new_itemsize]``, which means that the result view will be "
"one-dimensional. The return value is a new memoryview, but the buffer itself "
"is not copied. Supported casts are 1D -> C-:term:`contiguous` and C-"
"contiguous -> 1D."
msgstr ""
"將記憶體視圖轉換為新格式或形狀。 *shape* 預設為 ``[byte_length//new_itemsize]"
"``，這意味著結果視圖將是一維的。回傳值是一個新的記憶體視圖，但緩衝區本身沒有"
"被複製。支援的轉換為 1D -> C-:term:`contiguous` 和 C-contiguous -> 1D。"

#: ../../library/stdtypes.rst:3958
#, fuzzy
msgid ""
"The destination format is restricted to a single element native format in :"
"mod:`struct` syntax. One of the formats must be a byte format ('B', 'b' or "
"'c'). The byte length of the result must be the same as the original length."
msgstr ""
"目標格式僅限於 :mod:`struct` 語法中的單個元素本機格式。其中一種格式必須是位元"
"組格式（ ``B``、 ``b``或 ``c``）。結果的位元組長度必須與原始長度相同。"

#: ../../library/stdtypes.rst:3963
#, fuzzy
msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr "將 1D/long 轉換為 1D/無符號位元組::"

#: ../../library/stdtypes.rst:3986
#, fuzzy
msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr "將一維/無符號位元組轉換為一維/字元::"

#: ../../library/stdtypes.rst:3999
#, fuzzy
msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr "將 1D/bytes 轉換為 3D/ints 到 1D/signed char::"

#: ../../library/stdtypes.rst:4025
#, fuzzy
msgid "Cast 1D/unsigned long to 2D/unsigned long::"
msgstr "將 1D/unsigned long 轉換為 2D/unsigned long::"

#: ../../library/stdtypes.rst:4039
#, fuzzy
msgid "The source format is no longer restricted when casting to a byte view."
msgstr "轉換為位元組視圖時，源格式不再受限。"

#: ../../library/stdtypes.rst:4042
#, fuzzy
msgid "There are also several readonly attributes available:"
msgstr "還有幾個只讀屬性可用："

#: ../../library/stdtypes.rst:4046
#, fuzzy
msgid "The underlying object of the memoryview::"
msgstr "記憶體視圖的底層物件::"

#: ../../library/stdtypes.rst:4057
#, fuzzy
msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the "
"amount of space in bytes that the array would use in a contiguous "
"representation. It is not necessarily equal to ``len(m)``::"
msgstr ""
"``nbytes == product(shape) * itemsize == len(m."
"tobytes())``。這是數組在連續表示中使用的空間量（以位元組為單位）。"
"它不一定等於 ``len(m)``::"

#: ../../library/stdtypes.rst:4076
#, fuzzy
msgid "Multi-dimensional arrays::"
msgstr "多維數組::"

#: ../../library/stdtypes.rst:4093
#, fuzzy
msgid "A bool indicating whether the memory is read only."
msgstr "指示記憶體是否只讀的布爾值。"

#: ../../library/stdtypes.rst:4097
#, fuzzy
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view. A memoryview can be created from exporters with "
"arbitrary format strings, but some methods (e.g. :meth:`tolist`) are "
"restricted to native single element formats."
msgstr ""
"包含視圖中每個元素的格式（在 :mod:`struct` 模組樣式中）的字串。可以從具有任意"
"格式字串的導出器建立記憶體視圖，但某些方法（例如 :meth:`tolist`）僅限於本機單"
"元素格式。"

#: ../../library/stdtypes.rst:4102
#, fuzzy
msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This "
"means that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr "格式 ``B``現在根據結構模組語法處理。這意味著``memoryview(b'abc')[0] == b'abc'[0]"
" == 97``。"

#: ../../library/stdtypes.rst:4108
#, fuzzy
msgid "The size in bytes of each element of the memoryview::"
msgstr "記憶體視圖中每個元素的大小（以位元組為單位）："

#: ../../library/stdtypes.rst:4121
#, fuzzy
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr "一個整數，指示記憶體表示的多維數組的維數。"

#: ../../library/stdtypes.rst:4126
#, fuzzy
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr "長度為 :attr:`ndim` 的整數元組，給出記憶體的形狀作為 N 維數組。"

#: ../../library/stdtypes.rst:4129 ../../library/stdtypes.rst:4137
#, fuzzy
msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr "當 ndim = 0 時，一個空元組而不是 ``None`` 。"

#: ../../library/stdtypes.rst:4134
#, fuzzy
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr "一個整數元組，其長度為 "
":attr:`ndim`，給出以位元組為單位的大小，以訪問數組每個維度的每個元素。"

#: ../../library/stdtypes.rst:4142
#, fuzzy
msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr "在內部用於 PIL 樣式數組。該值僅供參考。"

#: ../../library/stdtypes.rst:4146
#, fuzzy
msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr "指示記憶體是否為 C-:term:`contiguous` 的布爾值。"

#: ../../library/stdtypes.rst:4152
#, fuzzy
msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr "指示記憶體是否為 Fortran :term:`contiguous` 的布爾值。"

#: ../../library/stdtypes.rst:4158
#, fuzzy
msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr "指示記憶體是否連續的布爾值。"

#: ../../library/stdtypes.rst:4166
#, fuzzy
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "設定型別 --- :class:`set`, :class:`frozenset`"

#: ../../library/stdtypes.rst:4170
#, fuzzy
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union, "
"difference, and symmetric difference. (For other containers see the built-"
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:"
"`collections` module.)"
msgstr ""
":dfn:`set` 對像是不同的 :term:`hashable` 物件的無序集合。常見用途包括成員資格"
"測試、從序列中刪除重複項以及計算數學運算（例如交集、並集、差集和對稱差集）。 "
"（對於其他容器，請參閱內建的 :class:`dict`、:class:`list` 和 :class:`tuple` "
"類，以及 :mod:`collections` 模組。）"

#: ../../library/stdtypes.rst:4177
#, fuzzy
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x "
"in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""
"與其他集合一樣，集合支援“x in set”、“len(set)”和“for x in set”。作為無序集合"
"，集合不記錄元素位置或插入順序。因此，集合不支援索引、切片或其他類似序列的行"
"為。"

#: ../../library/stdtypes.rst:4182
#, fuzzy
msgid ""
"There are currently two built-in set types, :class:`set` and :class:"
"`frozenset`. The :class:`set` type is mutable --- the contents can be "
"changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since "
"it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type "
"is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element "
"of another set."
msgstr ""
"目前有兩種內建的集合型別，:class:`set` 和 :class:`frozenset`。 :class:`set` "
"型別是可變的——可以使用 :meth:`~set.add` 和 :meth:`~set.remove` 等方法更改內容"
"。因為它是可變的，所以它沒有散列值，不能用作字典鍵或另一個集合的元素。 "
":class:`frozenset` 型別是不可變的和 :term:`hashable` --- "
"它的內容在建立後不能更改；因此它可以用作字典鍵或另一個集合的元素。"

#: ../../library/stdtypes.rst:4190
#, fuzzy
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated "
"list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in "
"addition to the :class:`set` constructor."
msgstr ""
"非空集（不是凍結集）可以通過將逗號分隔的元素列表放在大括號內來建立，例如：``{"
"'jack', 'sjoerd'}``，除了 :class:`set`構造函式。"

#: ../../library/stdtypes.rst:4194
#, fuzzy
msgid "The constructors for both classes work the same:"
msgstr "這兩個類的構造函式工作相同："

#: ../../library/stdtypes.rst:4199
#, fuzzy
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""
"回傳一個新的 set 或 frozenset 物件，其元素取自 *iterable*。集合的元素必須是 "
":term:`hashable`。要表示集合的集合，內部集合必須是 :class:`frozenset` 物件。"
"如果未指定 *iterable*，則回傳一個新的空集。"

#: ../../library/stdtypes.rst:4205
#, fuzzy
msgid "Sets can be created by several means:"
msgstr "可以通過多種方式建立集合："

#: ../../library/stdtypes.rst:4207
#, fuzzy
msgid ""
"Use a comma-separated list of elements within braces: ``{'jack', 'sjoerd'}``"
msgstr "在大括號內使用逗號分隔的元素列表：``{'jack', 'sjoerd'}``"

#: ../../library/stdtypes.rst:4208
#, fuzzy
msgid ""
"Use a set comprehension: ``{c for c in 'abracadabra' if c not in 'abc'}``"
msgstr "使用集合理解：``{c for c in 'abracadabra' if c not in 'abc'}``"

#: ../../library/stdtypes.rst:4209
#, fuzzy
msgid ""
"Use the type constructor: ``set()``, ``set('foobar')``, ``set(['a', 'b', "
"'foo'])``"
msgstr "使用型別構造函式：``set()``、``set('foobar')``、``set(['a', 'b', 'foo'])``"

#: ../../library/stdtypes.rst:4211
#, fuzzy
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ":class:`set` 和 :class:`frozenset` 的實例提供以下操作："

#: ../../library/stdtypes.rst:4216
#, fuzzy
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr "回傳集合 *s* 中元素的數量（*s* 的基數）。"

#: ../../library/stdtypes.rst:4220
#, fuzzy
msgid "Test *x* for membership in *s*."
msgstr "測試 *x* 是否屬於 *s*。"

#: ../../library/stdtypes.rst:4224
#, fuzzy
msgid "Test *x* for non-membership in *s*."
msgstr "測試 *x* 是否屬於 *s*。"

#: ../../library/stdtypes.rst:4228
#, fuzzy
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are "
"disjoint if and only if their intersection is the empty set."
msgstr "如果集合沒有與 *other* 相同的元素，則回傳 "
"``True``。當且僅當它們的交集是空集時，集合才不相交。"

#: ../../library/stdtypes.rst:4234
#, fuzzy
msgid "Test whether every element in the set is in *other*."
msgstr "測試集合中的每個元素是否都在 *other* 中。"

#: ../../library/stdtypes.rst:4238
#, fuzzy
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr "測試集合是否是 *other* 的真子集，即 ``set <= other and set != other``。"

#: ../../library/stdtypes.rst:4244
#, fuzzy
msgid "Test whether every element in *other* is in the set."
msgstr "測試 *other* 中的每個元素是否都在集合中。"

#: ../../library/stdtypes.rst:4248
#, fuzzy
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr "測試該集合是否是 *other* 的真超集，即 ``set >= other 和 set != other``。"

#: ../../library/stdtypes.rst:4254
#, fuzzy
msgid "Return a new set with elements from the set and all others."
msgstr "回傳一個新集合，其中包含集合中的元素和所有其他元素。"

#: ../../library/stdtypes.rst:4259
#, fuzzy
msgid "Return a new set with elements common to the set and all others."
msgstr "回傳一個新集合，其中包含該集合和所有其他元素共有的元素。"

#: ../../library/stdtypes.rst:4264
#, fuzzy
msgid "Return a new set with elements in the set that are not in the others."
msgstr "回傳一個新集合，該集合中的元素不在其他集合中。"

#: ../../library/stdtypes.rst:4269
#, fuzzy
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr "回傳一個新集合，其元素位於集合或 *other* 中，但不能同時包含在兩者中。"

#: ../../library/stdtypes.rst:4273
#, fuzzy
msgid "Return a shallow copy of the set."
msgstr "回傳集合的淺表副本。"

#: ../../library/stdtypes.rst:4276
#, fuzzy
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :"
"meth:`difference`, :meth:`symmetric_difference`, :meth:`issubset`, and :meth:"
"`issuperset` methods will accept any iterable as an argument.  In contrast, "
"their operator based counterparts require their arguments to be sets.  This "
"precludes error-prone constructions like ``set('abc') & 'cbs'`` in favor of "
"the more readable ``set('abc').intersection('cbs')``."
msgstr ""
"注意，union、intersection、difference、symmetric_difference、issubset 和 "
"issuperset 的非運算符版本方法將接受任何可疊代對像作為參數。相比之下，他們基於"
"運算符的對手要求他們的參數是集合。這排除了像``set('abc') & 'cbs'`` "
"這樣容易出錯的結構，取而代之的是更具可讀性的``set('abc')."
"intersection('cbs')``。"

#: ../../library/stdtypes.rst:4283
#, fuzzy
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two "
"sets are equal if and only if every element of each set is contained in the "
"other (each is a subset of the other). A set is less than another set if and "
"only if the first set is a proper subset of the second set (is a subset, but "
"is not equal). A set is greater than another set if and only if the first "
"set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""
":class:`set` 和 :class:`frozenset` 都支援集合到集合的比較。兩個集合相等當且僅"
"當每個集合的每個元素都包含在另一個集合中（每個集合都是另一個集合的子集）。一"
"個集合小於另一個集合當且僅當第一個集合是第二個集合的真子集（是子集，但不相等"
"）。一個集合大於另一個集合當且僅當第一個集合是第二個集合的真超集（是超集，但"
"不相等）。"

#: ../../library/stdtypes.rst:4290
#, fuzzy
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
":class:`set` 的實例根據其成員與 :class:`frozenset` "
"的實例進行比較。例如，``set('abc') == frozenset('abc')`` 回傳 ``True`` "
"``set('abc') in set([frozenset('abc')]) 也是如此``。"

#: ../../library/stdtypes.rst:4294
#, fuzzy
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two nonempty disjoint sets are not equal and are "
"not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``."
msgstr ""
"子集和相等比較不會推廣到總排序函式。例如，任何兩個非空的不相交集都不相等，也"
"不是彼此的子集，所以下面的*所有*都回傳``False``：``a<b``，``a==b``，或 "
"``a>b``。"

#: ../../library/stdtypes.rst:4299
#, fuzzy
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr "由於集合僅定義部分排序（子集關係），因此 list.sort "
"方法的輸出對於集合列表是未定義的。"

#: ../../library/stdtypes.rst:4302
#, fuzzy
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr "集合元素，如字典鍵，必須是 :term:`hashable`。"

#: ../../library/stdtypes.rst:4304
#, fuzzy
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""
"混合 :class:`set` 實例和 :class:`frozenset` "
"的二進位操作回傳第一個操作數的型別。例如：``frozenset('ab') | set('bc')`` "
"回傳一個 frozenset 的實例。"

#: ../../library/stdtypes.rst:4308
#, fuzzy
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr "下表列出了適用於 :class:`set` 但不適用於 :class:`frozenset` "
"的不可變實例的操作："

#: ../../library/stdtypes.rst:4314
#, fuzzy
msgid "Update the set, adding elements from all others."
msgstr "更新集合，新增所有其他元素。"

#: ../../library/stdtypes.rst:4319
#, fuzzy
msgid "Update the set, keeping only elements found in it and all others."
msgstr "更新集合，只保留其中找到的元素和所有其他元素。"

#: ../../library/stdtypes.rst:4324
#, fuzzy
msgid "Update the set, removing elements found in others."
msgstr "更新集合，刪除在其他集合中找到的元素。"

#: ../../library/stdtypes.rst:4329
#, fuzzy
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr "更新集合，只保留在任一集合中找到的元素，而不是在兩個集合中找到的元素。"

#: ../../library/stdtypes.rst:4333
#, fuzzy
msgid "Add element *elem* to the set."
msgstr "將元素 *elem* 新增到集合中。"

#: ../../library/stdtypes.rst:4337
#, fuzzy
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not "
"contained in the set."
msgstr "從集合中刪除元素 *elem*。如果 *elem* 不包含在集合中，則引發 :exc:`KeyError`。"

#: ../../library/stdtypes.rst:4342
#, fuzzy
msgid "Remove element *elem* from the set if it is present."
msgstr "如果元素 *elem* 存在，則將其從集合中移除。"

#: ../../library/stdtypes.rst:4346
#, fuzzy
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` "
"if the set is empty."
msgstr "從集合中刪除並回傳任意元素。如果集合為空，則引發 :exc:`KeyError`。"

#: ../../library/stdtypes.rst:4351
#, fuzzy
msgid "Remove all elements from the set."
msgstr "從集合中刪除所有元素。"

#: ../../library/stdtypes.rst:4354
#, fuzzy
msgid ""
"Note, the non-operator versions of the :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, and :meth:"
"`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""
"請注意，非運算符版本的 update、intersection_update、difference_update 和 "
"symmetric_difference_update 方法將接受任何可疊代對像作為參數。"

#: ../../library/stdtypes.rst:4359
#, fuzzy
msgid ""
"Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, and :"
"meth:`discard` methods may be a set.  To support searching for an equivalent "
"frozenset, a temporary one is created from *elem*."
msgstr ""
"請注意，:meth:`__contains__`、:meth:`remove` 和 :meth:`discard` 方法的 *elem* "
"參數可能是一個集合。為了支援搜索等效的 frozenset，從 *elem* "
"建立了一個臨時的。"

#: ../../library/stdtypes.rst:4367
#, fuzzy
msgid "Mapping Types --- :class:`dict`"
msgstr "映射型別 --- :class:`dict`"

#: ../../library/stdtypes.rst:4377
#, fuzzy
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built-in :class:"
"`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""
":term:`mapping` 物件將 :term:`hashable` 值映射到任意物件。映射是可變物件。目"
"前只有一種標準映射型別，即 :dfn:`dictionary`。 （對於其他容器，請參閱內建的 "
":class:`list`、:class:`set` 和 :class:`tuple` 類，以及 :mod:`collections` "
"模組。）"

#: ../../library/stdtypes.rst:4383
#, fuzzy
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not :"
"term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys. Values that compare equal (such as ``1``, ``1.0``, "
"and ``True``) can be used interchangeably to index the same dictionary entry."
msgstr ""
"字典的鍵 *幾乎* 是任意值。不是 :term:`hashable` 的值，即包含列表、字典或其他"
"可變型別的值（按值而不是物件標識進行比較）不能用作鍵。比較相等的值（例如 "
"``1``、``1.0`` 和 ``True``）可以互換使用以索引相同的字典條目。"

#: ../../library/stdtypes.rst:4394
#, fuzzy
msgid ""
"Return a new dictionary initialized from an optional positional argument and "
"a possibly empty set of keyword arguments."
msgstr "回傳從可選位置參數和一組可能為空的關鍵字參數初始化的新字典。"

#: ../../library/stdtypes.rst:4397
#, fuzzy
msgid "Dictionaries can be created by several means:"
msgstr "可以通過多種方式建立字典："

#: ../../library/stdtypes.rst:4399
#, fuzzy
msgid ""
"Use a comma-separated list of ``key: value`` pairs within braces: ``{'jack': "
"4098, 'sjoerd': 4127}`` or ``{4098: 'jack', 4127: 'sjoerd'}``"
msgstr ""
"在大括號內使用逗號分隔的“key: value”對列表：``{'jack': 4098, 'sjoerd': "
"4127}`` 或 ``{4098: 'jack', 4127: 'sjoerd' }``"

#: ../../library/stdtypes.rst:4401
#, fuzzy
msgid "Use a dict comprehension: ``{}``, ``{x: x ** 2 for x in range(10)}``"
msgstr "使用字典理解：``{}``, ``{x: x ** 2 for x in range(10)}``"

#: ../../library/stdtypes.rst:4402
#, fuzzy
msgid ""
"Use the type constructor: ``dict()``, ``dict([('foo', 100), ('bar', "
"200)])``, ``dict(foo=100, bar=200)``"
msgstr ""
"使用型別構造器：``dict()``, ``dict([('foo', 100), ('bar', 200)])``, ``dict("
"foo=100, bar=200) ``"

#: ../../library/stdtypes.rst:4405
#, fuzzy
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is "
"created with the same key-value pairs as the mapping object.  Otherwise, the "
"positional argument must be an :term:`iterable` object.  Each item in the "
"iterable must itself be an iterable with exactly two objects.  The first "
"object of each item becomes a key in the new dictionary, and the second "
"object the corresponding value.  If a key occurs more than once, the last "
"value for that key becomes the corresponding value in the new dictionary."
msgstr ""
"如果沒有給出位置參數，則會建立一個空字典。如果給出了一個位置參數並且它是一個"
"映射物件，則使用與映射物件相同的鍵值對建立一個字典。否則，位置參數必須是一個 "
":term:`iterable` 物件。 iterable 中的每個項目本身必須是一個恰好有兩個物件的 i"
"terable。每個項目的第一個物件成為新字典中的鍵，第二個物件成為相應的值。如果某"
"個鍵出現多次，則該鍵的最後一個值將成為新字典中的對應值。"

#: ../../library/stdtypes.rst:4415
#, fuzzy
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces "
"the value from the positional argument."
msgstr "如果給出了關鍵字參數，則關鍵字參數及其值將新增到從位置參數建立的字典中。如果"
"要新增的鍵已經存在，則關鍵字參數中的值將替換位置參數中的值。"

#: ../../library/stdtypes.rst:4420
#, fuzzy
msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr "為了說明，以下示例都回傳等於``{\"one\": 1, \"two\": 2, \"three\": 3}``::"

#: ../../library/stdtypes.rst:4432
#, fuzzy
msgid ""
"Providing keyword arguments as in the first example only works for keys that "
"are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr "在第一個示例中提供關鍵字參數僅適用於作為有效 Python "
"標識符的鍵。否則，可以使用任何有效的密鑰。"

#: ../../library/stdtypes.rst:4436
#, fuzzy
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr "這些是字典支援的操作（因此，自定義映射型別也應該支援）："

#: ../../library/stdtypes.rst:4441
#, fuzzy
msgid "Return a list of all the keys used in the dictionary *d*."
msgstr "回傳字典 *d* 中使用的所有鍵的列表。"

#: ../../library/stdtypes.rst:4445
#, fuzzy
msgid "Return the number of items in the dictionary *d*."
msgstr "回傳字典 *d* 中的項目數。"

#: ../../library/stdtypes.rst:4449
#, fuzzy
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is "
"not in the map."
msgstr "回傳帶有鍵 *key* 的 *d* 項。如果 *key* 不在地圖中，則引發 :exc:`KeyError`。"

#: ../../library/stdtypes.rst:4454
#, fuzzy
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, :"
"exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot be "
"an instance variable::"
msgstr ""
"如果 dict 的子類別定義了一個方法 :meth:`__missing__` 並且 *key* 不存在，則 "
"``d[key]`` 操作以鍵 *key* 作為參數呼叫該方法。然後，``d[key]`` "
"操作回傳或引發 ``__missing__(key)`` 呼叫回傳或引發的任何內容。"
"沒有其他操作或方法呼叫 :meth:`__missing__`。如果未定義 :meth:`__missing__`，"
"則引發 :exc:`KeyError`。 :meth:`__missing__` "
"必須是一個方法；它不能是實例變數::"

#: ../../library/stdtypes.rst:4472
#, fuzzy
msgid ""
"The example above shows part of the implementation of :class:`collections."
"Counter`.  A different ``__missing__`` method is used by :class:`collections."
"defaultdict`."
msgstr ""
"上面的示例顯示了 :class:`collections.Counter` 的部分實作。 "
":class:`collections.defaultdict` 使用了一個不同的``__missing__`` 方法。"

#: ../../library/stdtypes.rst:4478
#, fuzzy
msgid "Set ``d[key]`` to *value*."
msgstr "將 ``d[key]`` 設定為 *value*。"

#: ../../library/stdtypes.rst:4482
#, fuzzy
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the "
"map."
msgstr "從 *d* 中刪除 ``d[key]``。如果 *key* 不在地圖中，則引發 :exc:`KeyError`。"

#: ../../library/stdtypes.rst:4487
#, fuzzy
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr "如果 *d* 有一個鍵 *key*，則回傳 ``True``，否則回傳``False``。"

#: ../../library/stdtypes.rst:4491
#, fuzzy
msgid "Equivalent to ``not key in d``."
msgstr "等同於``not key in d``。"

#: ../../library/stdtypes.rst:4495
#, fuzzy
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr "回傳字典鍵的疊代器。這是 ``iter(d.keys())`` 的快捷方式。"

#: ../../library/stdtypes.rst:4500
#, fuzzy
msgid "Remove all items from the dictionary."
msgstr "從字典中刪除所有項目。"

#: ../../library/stdtypes.rst:4504
#, fuzzy
msgid "Return a shallow copy of the dictionary."
msgstr "回傳字典的淺表副本。"

#: ../../library/stdtypes.rst:4508
#, fuzzy
msgid ""
"Create a new dictionary with keys from *iterable* and values set to *value*."
msgstr "使用 *iterable* 中的鍵和設定為 *value* 的值建立一個新字典。"

#: ../../library/stdtypes.rst:4510
#, fuzzy
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``.  All of the values refer to just a single instance, so "
"it generally doesn't make sense for *value* to be a mutable object such as "
"an empty list.  To get distinct values, use a :ref:`dict comprehension "
"<dict>` instead."
msgstr ""
":meth:`fromkeys` 是一個回傳新字典的類方法。 *值* "
"預設為 ``None`` 。所有的值都只引用一個實例，所以 *value* "
"是一個可變物件（如空列表）通常沒有意義。要獲得不同的值，請改用 :ref:`dict "
"comprehension <dict>`。"

#: ../../library/stdtypes.rst:4518
#, fuzzy
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If "
"*default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""
"如果 *key* 在字典中，則回傳 *key* 的值，否則回傳 *default*。如果沒有給出 "
"*default*，它預設為 ``None``，因此該方法永遠不會引發 :exc:`KeyError`。"

#: ../../library/stdtypes.rst:4524
#, fuzzy
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See "
"the :ref:`documentation of view objects <dict-views>`."
msgstr "回傳字典項目的新視圖（``（鍵，值）`` 對）。請參閱 :ref:`視圖物件的文檔 <dict-"
"views>`。"

#: ../../library/stdtypes.rst:4529
#, fuzzy
msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation of "
"view objects <dict-views>`."
msgstr "回傳字典鍵的新視圖。請參閱 :ref:`視圖物件的文檔 <dict-views>`。"

#: ../../library/stdtypes.rst:4534
#, fuzzy
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a :"
"exc:`KeyError` is raised."
msgstr ""
"如果 *key* 在字典中，刪除它並回傳它的值，否則回傳 *default*。如果未給出 "
"*default* 且 *key* 不在字典中，則會引發 :exc:`KeyError`。"

#: ../../library/stdtypes.rst:4540
#, fuzzy
msgid ""
"Remove and return a ``(key, value)`` pair from the dictionary. Pairs are "
"returned in :abbr:`LIFO (last-in, first-out)` order."
msgstr "從字典中刪除並回傳一個 ``(key, value)`` 對。對以 LIFO（後進先出）順序回傳。"

#: ../../library/stdtypes.rst:4543
#, fuzzy
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling :meth:"
"`popitem` raises a :exc:`KeyError`."
msgstr ""
":meth:`popitem` "
"可用於破壞性地疊代字典，這在集合演算法中經常使用。如果字典為空，呼叫 "
":meth:`popitem` 會引發 :exc:`KeyError`。"

#: ../../library/stdtypes.rst:4547
#, fuzzy
msgid ""
"LIFO order is now guaranteed. In prior versions, :meth:`popitem` would "
"return an arbitrary key/value pair."
msgstr "現在保證後進先出順序。在以前的版本中，:meth:`popitem` "
"會回傳一個任意的鍵/值對。"

#: ../../library/stdtypes.rst:4553
#, fuzzy
msgid ""
"Return a reverse iterator over the keys of the dictionary. This is a "
"shortcut for ``reversed(d.keys())``."
msgstr "回傳字典鍵的反向疊代器。這是``reversed(d.keys())`` 的快捷方式。"

#: ../../library/stdtypes.rst:4560
#, fuzzy
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""
"如果 *key* 在字典中，回傳它的值。如果不是，則插入值為 *default* 的 *key* "
"並回傳 *default*。 *預設*預設為 ``None`` 。"

#: ../../library/stdtypes.rst:4566
#, fuzzy
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr "使用來自 *other* 的鍵/值對更新字典，覆蓋現有鍵。回傳 ``None`` 。"

#: ../../library/stdtypes.rst:4569
#, fuzzy
msgid ""
":meth:`update` accepts either another dictionary object or an iterable of "
"key/value pairs (as tuples or other iterables of length two).  If keyword "
"arguments are specified, the dictionary is then updated with those key/value "
"pairs: ``d.update(red=1, blue=2)``."
msgstr ""
":meth:`update` 接受另一個字典對像或可疊代的鍵/值對（作為元組或其他長度為 2 "
"的可疊代）。如果指定了關鍵字參數，則字典將使用這些鍵/值對進行更新：``d."
"update(red=1, blue=2)``。"

#: ../../library/stdtypes.rst:4576
#, fuzzy
msgid ""
"Return a new view of the dictionary's values.  See the :ref:`documentation "
"of view objects <dict-views>`."
msgstr "回傳字典值的新視圖。請參閱 :ref:`視圖物件的文檔 <dict-views>`。"

#: ../../library/stdtypes.rst:4579
#, fuzzy
msgid ""
"An equality comparison between one ``dict.values()`` view and another will "
"always return ``False``. This also applies when comparing ``dict.values()`` "
"to itself::"
msgstr ""
"一個 ``dict.values()`` 視圖與另一個視圖之間的相等性比較將始終回傳 ``False``。"
"這也適用於將 ``dict.values()`` 與自身進行比較時："

#: ../../library/stdtypes.rst:4589
#, fuzzy
msgid ""
"Create a new dictionary with the merged keys and values of *d* and *other*, "
"which must both be dictionaries. The values of *other* take priority when "
"*d* and *other* share keys."
msgstr ""
"使用 *d* 和 *other* 的合併鍵和值建立一個新字典，它們必須都是字典。當 *d* 和 "
"*other* 共享鍵時，*other* 的值優先。"

#: ../../library/stdtypes.rst:4597
#, fuzzy
msgid ""
"Update the dictionary *d* with keys and values from *other*, which may be "
"either a :term:`mapping` or an :term:`iterable` of key/value pairs. The "
"values of *other* take priority when *d* and *other* share keys."
msgstr ""
"使用來自 *other* 的鍵和值更新字典 *d*，它可以是鍵/值對的 :term:`mapping` 或 "
":term:`iterable`。當 *d* 和 *other* 共享鍵時，*other* 的值優先。"

#: ../../library/stdtypes.rst:4603
#, fuzzy
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs (regardless of ordering). Order comparisons ('<', '<=', '>=', "
"'>') raise :exc:`TypeError`."
msgstr ""
"當且僅當它們具有相同的“(key, value)”對（無論順序如何）時，字典才比較相等。順"
"序比較（'<'、'<='、'>='、'>'）引發 :exec:`TypeError`。"

#: ../../library/stdtypes.rst:4607
#, fuzzy
msgid ""
"Dictionaries preserve insertion order.  Note that updating a key does not "
"affect the order.  Keys added after deletion are inserted at the end. ::"
msgstr "字典保留插入順序。請注意，更新密鑰不會影響順序。刪除後新增的鍵插入到最後。 ::"

#: ../../library/stdtypes.rst:4625
#, fuzzy
msgid ""
"Dictionary order is guaranteed to be insertion order.  This behavior was an "
"implementation detail of CPython from 3.6."
msgstr "字典順序保證是插入順序。此行為是 CPython 從 3.6 開始的一個實作細節。"

#: ../../library/stdtypes.rst:4629
#, fuzzy
msgid "Dictionaries and dictionary views are reversible. ::"
msgstr "字典和字典視圖是可逆的。 ::"

#: ../../library/stdtypes.rst:4641
#, fuzzy
msgid "Dictionaries are now reversible."
msgstr "字典現在是可逆的。"

#: ../../library/stdtypes.rst:4646
#, fuzzy
msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of a :"
"class:`dict`."
msgstr ":class:`types.MappingProxyType` 可用於建立 :class:`dict` 的只讀視圖。"

#: ../../library/stdtypes.rst:4653
msgid "Dictionary view objects"
msgstr "字典視圖物件"

#: ../../library/stdtypes.rst:4655
#, fuzzy
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and :meth:"
"`dict.items` are *view objects*.  They provide a dynamic view on the "
"dictionary's entries, which means that when the dictionary changes, the view "
"reflects these changes."
msgstr ""
":meth:`dict.keys`、:meth:`dict.values` 和 :meth:`dict.items` 回傳的對像是*視"
"圖物件*。它們提供字典條目的動態視圖，這意味著當字典發生變化時，視圖會反映這些"
"變化。"

#: ../../library/stdtypes.rst:4660
#, fuzzy
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr "可以疊代字典視圖以產生它們各自的資料，並支援成員測試："

#: ../../library/stdtypes.rst:4665
#, fuzzy
msgid "Return the number of entries in the dictionary."
msgstr "回傳字典中的條目數。"

#: ../../library/stdtypes.rst:4669
#, fuzzy
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr "回傳字典中鍵、值或項（表示為 ``(key, value)`` 的元組）的疊代器。"

#: ../../library/stdtypes.rst:4672
#, fuzzy
msgid ""
"Keys and values are iterated over in insertion order. This allows the "
"creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = zip(d."
"values(), d.keys())``.  Another way to create the same list is ``pairs = "
"[(v, k) for (k, v) in d.items()]``."
msgstr ""
"鍵和值按插入順序疊代。這允許使用 :func:`zip` 建立 ``(value, key)`` 對：``"
"pairs = zip(d.values(), d.keys())``。另一種建立相同列表的方法是 ``pairs = [("
"v, k) for (k, v) in d.items()]``。"

#: ../../library/stdtypes.rst:4677
#, fuzzy
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise "
"a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr "在字典中新增或刪除條目時疊代視圖可能會引發 :exc:`RuntimeError` "
"或無法疊代所有條目。"

#: ../../library/stdtypes.rst:4680
#, fuzzy
msgid "Dictionary order is guaranteed to be insertion order."
msgstr "字典順序保證是插入順序。"

#: ../../library/stdtypes.rst:4685
#, fuzzy
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""
"如果 *x* 在底層字典的鍵、值或項中，則回傳 ``True``（在後一種情況下，*x* "
"應該是一個 ``(key, value)`` 元組）。"

#: ../../library/stdtypes.rst:4690
#, fuzzy
msgid ""
"Return a reverse iterator over the keys, values or items of the dictionary. "
"The view will be iterated in reverse order of the insertion."
msgstr "回傳字典的鍵、值或項目的反向疊代器。視圖將按照插入的相反順序疊代。"

#: ../../library/stdtypes.rst:4693
#, fuzzy
msgid "Dictionary views are now reversible."
msgstr "字典視圖現在是可逆的。"

#: ../../library/stdtypes.rst:4698
#, fuzzy
msgid ""
"Return a :class:`types.MappingProxyType` that wraps the original dictionary "
"to which the view refers."
msgstr "回傳一個 types.MappingProxyType ，它包裝了視圖所引用的原始字典。"

#: ../../library/stdtypes.rst:4703
#, fuzzy
msgid ""
"Keys views are set-like since their entries are unique and :term:"
"`hashable`.  If all values are hashable, so that ``(key, value)`` pairs are "
"unique and hashable, then the items view is also set-like.  (Values views "
"are not treated as set-like since the entries are generally not unique.)  "
"For set-like views, all of the operations defined for the abstract base "
"class :class:`collections.abc.Set` are available (for example, ``==``, "
"``<``, or ``^``)."
msgstr ""
"鍵視圖類似於集合，因為它們的條目是唯一的並且是可散列的。如果所有值都是可散列"
"的，那麼“(key, value)”對是唯一且可散列的，那麼項目視圖也是類似集合的。 "
"（值視圖不被視為類集合，因為條目通常不是唯一的。）對於類集合視圖，"
"為抽象基底類別 :class:`collections.abc.Set` "
"定義的所有操作都是可用的（例如、``==``、``<`` 或 ``^``）。"

#: ../../library/stdtypes.rst:4710
#, fuzzy
msgid "An example of dictionary view usage::"
msgstr "字典視圖用法示例::"

#: ../../library/stdtypes.rst:4751
#, fuzzy
msgid "Context Manager Types"
msgstr "上下文管理器型別"

#: ../../library/stdtypes.rst:4758
#, fuzzy
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context "
"defined by a context manager.  This is implemented using a pair of methods "
"that allow user-defined classes to define a runtime context that is entered "
"before the statement body is executed and exited when the statement ends:"
msgstr ""
"Python 的 :keyword:`with` 語句支援由上下文管理器定義的運行時上下文的概念。這是"
"使用一對方法實作的，這些方法允許使用者定義的類定義一個運行時上下文，該上下文"
"在語句主體執行之前進入並在語句結束時退出："

#: ../../library/stdtypes.rst:4766
#, fuzzy
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`!as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""
"輸入運行時上下文並回傳此對像或與運行時上下文相關的另一個物件。此方法回傳的值"
"綁定到使用此上下文管理器的 :keyword:`with` 語句的 :keyword:`!as` "
"子句中的標識符。"

#: ../../library/stdtypes.rst:4771
#, fuzzy
msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow :func:"
"`open` to be used as the context expression in a :keyword:`with` statement."
msgstr ""
"回傳自身的上下文管理器的一個例子是 :term:`文件物件`。文件對像從 __enter__() "
"回傳自己，以允許 :func:`open` 用作 :keyword:`with` 語句中的上下文表達式。"

#: ../../library/stdtypes.rst:4775
#, fuzzy
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside "
"the :keyword:`!with` statement."
msgstr ""
"回傳相關物件的上下文管理器的一個例子是 :func:`decimal.localcontext` 回傳的那"
"個。這些管理器將活動十進位上下文設定為原始十進位上下文的副本，然後回傳該副本"
"。這允許對 :keyword:`with` 語句主體中的當前十進位上下文進行更改，而不會影響 "
":keyword:`!with` 語句之外的程式碼。"

#: ../../library/stdtypes.rst:4785
#, fuzzy
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while "
"executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""
"退出運行時上下文並回傳一個布爾旗標，指示是否應抑制發生的任何例外。如果在執行:"
"keyword:`with` 語句的主體時發生例外，則參數包含例外型別、值和回溯資訊。否則，"
"所有三個參數都是 ``None`` 。"

#: ../../library/stdtypes.rst:4790
#, fuzzy
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`!with` statement. Otherwise "
"the exception continues propagating after this method has finished "
"executing. Exceptions that occur during execution of this method will "
"replace any exception that occurred in the body of the :keyword:`!with` "
"statement."
msgstr ""
"從此方法回傳真值將導致 :keyword:`with` "
"語句抑制例外並繼續執行緊跟在 :keyword:`!with` "
"語句之後的語句。否則例外會在此方法執行完畢後繼續傳播。"
"執行此方法期間發生的例外將替換 :keyword:`!with` 語句主體中發生的任何例外。"

#: ../../library/stdtypes.rst:4797
#, fuzzy
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows "
"context management code to easily detect whether or not an :meth:`__exit__` "
"method has actually failed."
msgstr ""
"傳入的例外不應顯式重新引發 - 相反，此方法應回傳一個 false "
"值以指示該方法已成功完成並且不想抑制引發的例外。"
"這允許上下文管理程式碼輕鬆檢測 :meth:`__exit__` 方法是否真的失敗了。"

#: ../../library/stdtypes.rst:4803
#, fuzzy
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""
"Python 定義了幾個上下文管理器來支援簡單的執行緒同步、快速關閉文件或其他物件，"
"以及對活動的十進位算術上下文進行更簡單的操作。除了上下文管理協定的實作之外，"
"特定型別不會被特殊對待。有關示例，請參閱 :mod:`contextlib` 模組。"

#: ../../library/stdtypes.rst:4809
#, fuzzy
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the :class:`contextlib.contextmanager` "
"decorator, it will return a context manager implementing the necessary :meth:"
"`~contextmanager.__enter__` and :meth:`~contextmanager.__exit__` methods, "
"rather than the iterator produced by an undecorated generator function."
msgstr ""
"Python 的 :term:`generator`\\s 和 :class:`contextlib.contextmanager` 裝飾器提"
"供了一種實作這些協定的便捷方式。如果一個生成器函式被裝飾了 :class:`contextlib."
"contextmanager` "
"裝飾器，它將回傳一個上下文管理器實作必要的 :meth:`~contextmanager.__enter__` "
"和 :meth:`~contextmanager.__exit__` "
"方法，而不是由未修飾的生成器函式生成的疊代器。"

#: ../../library/stdtypes.rst:4816
#, fuzzy
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to "
"define these methods must provide them as a normal Python accessible method. "
"Compared to the overhead of setting up the runtime context, the overhead of "
"a single class dictionary lookup is negligible."
msgstr ""
"請注意，在 Python/C API 中的 Python "
"物件的型別結構中，這些方法中的任何一個都沒有特定的插槽。"
"想要定義這些方法的擴充型別必須將它們作為普通的 Python 可訪問方法提供。與設定"
"運行時上下文的開銷相比，單個類字典查找的開銷可以忽略不計。"

#: ../../library/stdtypes.rst:4824
#, fuzzy
msgid ""
"Type Annotation Types --- :ref:`Generic Alias <types-genericalias>`, :ref:"
"`Union <types-union>`"
msgstr ""
"型別註釋型別 --- :ref:`Generic Alias <types-genericalias>`, :ref:`Union "
"<types-union>`"

#: ../../library/stdtypes.rst:4829
#, fuzzy
msgid ""
"The core built-in types for :term:`type annotations <annotation>` are :ref:"
"`Generic Alias <types-genericalias>` and :ref:`Union <types-union>`."
msgstr ""
":term:`type annotations <annotation>` 的核心內建型別是 :ref:`Generic Alias "
"<types-genericalias>` 和 :ref:`Union <types-union>`。"

#: ../../library/stdtypes.rst:4836
#, fuzzy
msgid "Generic Alias Type"
msgstr "通用別名型別"

#: ../../library/stdtypes.rst:4842
#, fuzzy
msgid ""
"``GenericAlias`` objects are generally created by :ref:`subscripting "
"<subscriptions>` a class. They are most often used with :ref:`container "
"classes <sequence-types>`, such as :class:`list` or :class:`dict`. For "
"example, ``list[int]`` is a ``GenericAlias`` object created by subscripting "
"the ``list`` class with the argument :class:`int`. ``GenericAlias`` objects "
"are intended primarily for use with :term:`type annotations <annotation>`."
msgstr ""
"``GenericAlias`` 物件通常由 :ref:`subscripting <subscriptions>` 類建立。"
"它們最常與 :ref:`container classes <sequence-types>` 一起使用，例如 "
":class:`list` 或 :class:`dict`。例如，``list[int]`` 是一個``GenericAlias`` "
"物件，通過使用參數 :class:`int` 為 ``list`` 類下標建立。 ``GenericAlias`` "
"物件主要用於 :term:`type annotations <annotation>`。"

#: ../../library/stdtypes.rst:4852
#, fuzzy
msgid ""
"It is generally only possible to subscript a class if the class implements "
"the special method :meth:`~object.__class_getitem__`."
msgstr "通常只有在類實作特殊方法 :meth:`~object.__class_getitem__` 時才可能下標該類。"

#: ../../library/stdtypes.rst:4855
#, fuzzy
msgid ""
"A ``GenericAlias`` object acts as a proxy for a :term:`generic type`, "
"implementing *parameterized generics*."
msgstr "``GenericAlias`` 物件充當泛型型別的代理，實作*參數化泛型*。"

#: ../../library/stdtypes.rst:4858
#, fuzzy
msgid ""
"For a container class, the argument(s) supplied to a :ref:`subscription "
"<subscriptions>` of the class may indicate the type(s) of the elements an "
"object contains. For example, ``set[bytes]`` can be used in type annotations "
"to signify a :class:`set` in which all the elements are of type :class:"
"`bytes`."
msgstr ""
"對於容器類，提供給類的 :ref:`subscription <subscriptions>` "
"的參數可能指示物件包含的元素的型別。例如，``set[bytes]`` "
"可以用在型別註釋中來表示一個 :class:`set`，其中所有元素都是 :class:`bytes` "
"型別。"

#: ../../library/stdtypes.rst:4864
#, fuzzy
msgid ""
"For a class which defines :meth:`~object.__class_getitem__` but is not a "
"container, the argument(s) supplied to a subscription of the class will "
"often indicate the return type(s) of one or more methods defined on an "
"object. For example, :mod:`regular expressions <re>` can be used on both "
"the :class:`str` data type and the :class:`bytes` data type:"
msgstr ""
"對於定義 :meth:`~object.__class_getitem__` 但不是容器的類，提供給該類訂閱的參"
"數通常會指示在對像上定義的一個或多個方法的回傳型別.例如，:mod:`regular "
"expressions <re>` 可用於 :class:`str` 資料型別和 :class:`bytes` 資料型別："

#: ../../library/stdtypes.rst:4870
#, fuzzy
msgid ""
"If ``x = re.search('foo', 'foo')``, ``x`` will be a :ref:`re.Match <match-"
"objects>` object where the return values of ``x.group(0)`` and ``x[0]`` will "
"both be of type :class:`str`. We can represent this kind of object in type "
"annotations with the ``GenericAlias`` ``re.Match[str]``."
msgstr ""
"如果 ``x = re.search('foo', 'foo')``，``x`` 將是一個 :ref:`re.Match <match-"
"objects>` 物件，其中 ``x 的回傳值.group(0)`` 和 ``x[0]`` 都是 str 型別。"
"我們可以用 ``GenericAlias`` ``re.Match[str]`` 在型別註解中表示這種物件。"

#: ../../library/stdtypes.rst:4876
#, fuzzy
msgid ""
"If ``y = re.search(b'bar', b'bar')``, (note the ``b`` for :class:`bytes`), "
"``y`` will also be an instance of ``re.Match``, but the return values of ``y."
"group(0)`` and ``y[0]`` will both be of type :class:`bytes`. In type "
"annotations, we would represent this variety of :ref:`re.Match <match-"
"objects>` objects with ``re.Match[bytes]``."
msgstr ""
"如果 ``y = re.search(b'bar', b'bar')``，（注意 ``b`` 代表 "
":class:`bytes`），``y`` 也將是一個實例``re.Match``，但是 ``y.group(0)`` 和 "
"``y[0]`` 的回傳值都是 :class:`bytes` 型別。在型別註解中，我們會用 ``re."
"Match[bytes]`` 表示這種型別的 :ref:`re.Match <match-objects>` 物件。"

#: ../../library/stdtypes.rst:4882
#, fuzzy
msgid ""
"``GenericAlias`` objects are instances of the class :class:`types."
"GenericAlias`, which can also be used to create ``GenericAlias`` objects "
"directly."
msgstr ""
"``GenericAlias`` 對像是類 :class:`types.GenericAlias` 的實例，"
"也可用於直接建立 ``GenericAlias`` 物件。"

#: ../../library/stdtypes.rst:4888
#, fuzzy
msgid ""
"Creates a ``GenericAlias`` representing a type ``T`` parameterized by types "
"*X*, *Y*, and more depending on the ``T`` used. For example, a function "
"expecting a :class:`list` containing :class:`float` elements::"
msgstr ""
"建立一個代表由 *X*、*Y* 等型別參數化的型別 `T`` 的 ``GenericAlias``，"
"具體取決於所使用的 ``T``。例如，一個函式需要一個包含 :class:`float` 元素的 "
":class:`list`::"

#: ../../library/stdtypes.rst:4896
#, fuzzy
msgid ""
"Another example for :term:`mapping` objects, using a :class:`dict`, which is "
"a generic type expecting two type parameters representing the key type and "
"the value type.  In this example, the function expects a ``dict`` with keys "
"of type :class:`str` and values of type :class:`int`::"
msgstr ""
":term:`mapping` 物件的另一個示例，使用 :class:`dict`，它是一個泛型型別，需要"
"兩個型別參數來表示鍵型別和值型別。在此示例中，該函式需要一個 ``dict``，"
"其鍵型別為 str 型別，值型別為 int 型別::"

#: ../../library/stdtypes.rst:4904
#, fuzzy
msgid ""
"The builtin functions :func:`isinstance` and :func:`issubclass` do not "
"accept ``GenericAlias`` types for their second argument::"
msgstr ""
"內建函式 :func:`isinstance` 和 :func:`issubclass` 的第二個參數不接受 "
"``GenericAlias`` 型別::"

#: ../../library/stdtypes.rst:4912
#, fuzzy
msgid ""
"The Python runtime does not enforce :term:`type annotations <annotation>`. "
"This extends to generic types and their type parameters. When creating a "
"container object from a ``GenericAlias``, the elements in the container are "
"not checked against their type. For example, the following code is "
"discouraged, but will run without errors::"
msgstr ""
"Python 運行時不強制執行 :term:`type annotations "
"<annotation>`。這擴充到泛型型別及其型別參數。從 ``GenericAlias`` 建立容器物件"
"時，不會根據其型別檢查容器中的元素。例如，不鼓勵使用以下程式碼，但運行時不會"
"出錯："

#: ../../library/stdtypes.rst:4922
#, fuzzy
msgid ""
"Furthermore, parameterized generics erase type parameters during object "
"creation::"
msgstr "此外，參數化泛型在物件建立期間擦除型別參數::"

#: ../../library/stdtypes.rst:4933
#, fuzzy
msgid ""
"Calling :func:`repr` or :func:`str` on a generic shows the parameterized "
"type::"
msgstr "在泛型上呼叫 :func:`repr` 或 :func:`str` 顯示參數化型別::"

#: ../../library/stdtypes.rst:4941
#, fuzzy
msgid ""
"The :meth:`~object.__getitem__` method of generic containers will raise an "
"exception to disallow mistakes like ``dict[str][str]``::"
msgstr "通用容器的 :meth:`~object.__getitem__` 方法將引發例外以禁止類似 "
"``dict[str][str]`` 的錯誤::"

#: ../../library/stdtypes.rst:4949
#, fuzzy
msgid ""
"However, such expressions are valid when :ref:`type variables <generics>` "
"are used.  The index must have as many elements as there are type variable "
"items in the ``GenericAlias`` object's :attr:`~genericalias.__args__`. ::"
msgstr ""
"但是，當使用 :ref:`type variables <generics>` 時，這樣的表達式是有效的。"
"索引的元素數量必須與 ``GenericAlias`` "
"物件的型別變數項一樣多 :attr:`~genericalias.__args__`。 ::"

#: ../../library/stdtypes.rst:4960
#, fuzzy
msgid "Standard Generic Classes"
msgstr "標准通用類"

#: ../../library/stdtypes.rst:4962
#, fuzzy
msgid ""
"The following standard library classes support parameterized generics. This "
"list is non-exhaustive."
msgstr "以下標準庫類支援參數化泛型。此列表並非詳盡無遺。"

#: ../../library/stdtypes.rst:4965
msgid ":class:`tuple`"
msgstr ":class:`tuple`"

#: ../../library/stdtypes.rst:4966
msgid ":class:`list`"
msgstr ":class:`list`"

#: ../../library/stdtypes.rst:4967
msgid ":class:`dict`"
msgstr ":class:`dict`"

#: ../../library/stdtypes.rst:4968
msgid ":class:`set`"
msgstr ":class:`set`"

#: ../../library/stdtypes.rst:4969
msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

#: ../../library/stdtypes.rst:4970
msgid ":class:`type`"
msgstr ":class:`type`"

#: ../../library/stdtypes.rst:4971
msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

#: ../../library/stdtypes.rst:4972
msgid ":class:`collections.defaultdict`"
msgstr ":class:`collections.defaultdict`"

#: ../../library/stdtypes.rst:4973
msgid ":class:`collections.OrderedDict`"
msgstr ":class:`collections.OrderedDict`"

#: ../../library/stdtypes.rst:4974
msgid ":class:`collections.Counter`"
msgstr ":class:`collections.Counter`"

#: ../../library/stdtypes.rst:4975
msgid ":class:`collections.ChainMap`"
msgstr ":class:`collections.ChainMap`"

#: ../../library/stdtypes.rst:4976
msgid ":class:`collections.abc.Awaitable`"
msgstr ":class:`collections.abc.Awaitable`"

#: ../../library/stdtypes.rst:4977
msgid ":class:`collections.abc.Coroutine`"
msgstr ":class:`collections.abc.Coroutine`"

#: ../../library/stdtypes.rst:4978
msgid ":class:`collections.abc.AsyncIterable`"
msgstr ":class:`collections.abc.AsyncIterable`"

#: ../../library/stdtypes.rst:4979
msgid ":class:`collections.abc.AsyncIterator`"
msgstr ":class:`collections.abc.AsyncIterator`"

#: ../../library/stdtypes.rst:4980
msgid ":class:`collections.abc.AsyncGenerator`"
msgstr ":class:`collections.abc.AsyncGenerator`"

#: ../../library/stdtypes.rst:4981
msgid ":class:`collections.abc.Iterable`"
msgstr ":class:`collections.abc.Iterable`"

#: ../../library/stdtypes.rst:4982
msgid ":class:`collections.abc.Iterator`"
msgstr ":class:`collections.abc.Iterator`"

#: ../../library/stdtypes.rst:4983
msgid ":class:`collections.abc.Generator`"
msgstr ":class:`collections.abc.Generator`"

#: ../../library/stdtypes.rst:4984
msgid ":class:`collections.abc.Reversible`"
msgstr ":class:`collections.abc.Reversible`"

#: ../../library/stdtypes.rst:4985
msgid ":class:`collections.abc.Container`"
msgstr ":class:`collections.abc.Container`"

#: ../../library/stdtypes.rst:4986
msgid ":class:`collections.abc.Collection`"
msgstr ":class:`collections.abc.Collection`"

#: ../../library/stdtypes.rst:4987
msgid ":class:`collections.abc.Callable`"
msgstr ":class:`collections.abc.Callable`"

#: ../../library/stdtypes.rst:4988
msgid ":class:`collections.abc.Set`"
msgstr ":class:`collections.abc.Set`"

#: ../../library/stdtypes.rst:4989
msgid ":class:`collections.abc.MutableSet`"
msgstr ":class:`collections.abc.MutableSet`"

#: ../../library/stdtypes.rst:4990
msgid ":class:`collections.abc.Mapping`"
msgstr ":class:`collections.abc.Mapping`"

#: ../../library/stdtypes.rst:4991
msgid ":class:`collections.abc.MutableMapping`"
msgstr ":class:`collections.abc.MutableMapping`"

#: ../../library/stdtypes.rst:4992
msgid ":class:`collections.abc.Sequence`"
msgstr ":class:`collections.abc.Sequence`"

#: ../../library/stdtypes.rst:4993
msgid ":class:`collections.abc.MutableSequence`"
msgstr ":class:`collections.abc.MutableSequence`"

#: ../../library/stdtypes.rst:4994
msgid ":class:`collections.abc.ByteString`"
msgstr ":class:`collections.abc.ByteString`"

#: ../../library/stdtypes.rst:4995
msgid ":class:`collections.abc.MappingView`"
msgstr ":class:`collections.abc.MappingView`"

#: ../../library/stdtypes.rst:4996
msgid ":class:`collections.abc.KeysView`"
msgstr ":class:`collections.abc.KeysView`"

#: ../../library/stdtypes.rst:4997
msgid ":class:`collections.abc.ItemsView`"
msgstr ":class:`collections.abc.ItemsView`"

#: ../../library/stdtypes.rst:4998
msgid ":class:`collections.abc.ValuesView`"
msgstr ":class:`collections.abc.ValuesView`"

#: ../../library/stdtypes.rst:4999
msgid ":class:`contextlib.AbstractContextManager`"
msgstr ":class:`contextlib.AbstractContextManager`"

#: ../../library/stdtypes.rst:5000
msgid ":class:`contextlib.AbstractAsyncContextManager`"
msgstr ":class:`contextlib.AbstractAsyncContextManager`"

#: ../../library/stdtypes.rst:5001
msgid ":class:`dataclasses.Field`"
msgstr ":class:`dataclasses.Field`"

#: ../../library/stdtypes.rst:5002
msgid ":class:`functools.cached_property`"
msgstr ":class:`functools.cached_property`"

#: ../../library/stdtypes.rst:5003
msgid ":class:`functools.partialmethod`"
msgstr ":class:`functools.partialmethod`"

#: ../../library/stdtypes.rst:5004
msgid ":class:`os.PathLike`"
msgstr ":class:`os.PathLike`"

#: ../../library/stdtypes.rst:5005
msgid ":class:`queue.LifoQueue`"
msgstr ":class:`queue.LifoQueue`"

#: ../../library/stdtypes.rst:5006
msgid ":class:`queue.Queue`"
msgstr ":class:`queue.Queue`"

#: ../../library/stdtypes.rst:5007
msgid ":class:`queue.PriorityQueue`"
msgstr ":class:`queue.PriorityQueue`"

#: ../../library/stdtypes.rst:5008
msgid ":class:`queue.SimpleQueue`"
msgstr ":class:`queue.SimpleQueue`"

#: ../../library/stdtypes.rst:5009
msgid ":ref:`re.Pattern <re-objects>`"
msgstr ":ref:`re.Pattern <re-objects>`"

#: ../../library/stdtypes.rst:5010
msgid ":ref:`re.Match <match-objects>`"
msgstr ":ref:`re.Match <match-objects>`"

#: ../../library/stdtypes.rst:5011
msgid ":class:`shelve.BsdDbShelf`"
msgstr ":class:`shelve.BsdDbShelf`"

#: ../../library/stdtypes.rst:5012
msgid ":class:`shelve.DbfilenameShelf`"
msgstr ":class:`shelve.DbfilenameShelf`"

#: ../../library/stdtypes.rst:5013
msgid ":class:`shelve.Shelf`"
msgstr ":class:`shelve.Shelf`"

#: ../../library/stdtypes.rst:5014
msgid ":class:`types.MappingProxyType`"
msgstr ":class:`types.MappingProxyType`"

#: ../../library/stdtypes.rst:5015
msgid ":class:`weakref.WeakKeyDictionary`"
msgstr ":class:`weakref.WeakKeyDictionary`"

#: ../../library/stdtypes.rst:5016
msgid ":class:`weakref.WeakMethod`"
msgstr ":class:`weakref.WeakMethod`"

#: ../../library/stdtypes.rst:5017
msgid ":class:`weakref.WeakSet`"
msgstr ":class:`weakref.WeakSet`"

#: ../../library/stdtypes.rst:5018
msgid ":class:`weakref.WeakValueDictionary`"
msgstr ":class:`weakref.WeakValueDictionary`"

#: ../../library/stdtypes.rst:5023
#, fuzzy
msgid "Special Attributes of ``GenericAlias`` objects"
msgstr "``GenericAlias`` 物件的特殊屬性"

#: ../../library/stdtypes.rst:5025
#, fuzzy
msgid "All parameterized generics implement special read-only attributes."
msgstr "所有參數化泛型都實作特殊的只讀屬性。"

#: ../../library/stdtypes.rst:5029
#, fuzzy
msgid "This attribute points at the non-parameterized generic class::"
msgstr "該屬性指向非參數化泛型類::"

#: ../../library/stdtypes.rst:5037
#, fuzzy
msgid ""
"This attribute is a :class:`tuple` (possibly of length 1) of generic types "
"passed to the original :meth:`~object.__class_getitem__` of the generic "
"class::"
msgstr "此屬性是傳遞給通用類的原始 :meth:`~object.__class_getitem__` "
"的泛型型別的元組（長度可能為 1）::"

#: ../../library/stdtypes.rst:5047
#, fuzzy
msgid ""
"This attribute is a lazily computed tuple (possibly empty) of unique type "
"variables found in ``__args__``::"
msgstr "此屬性是在 ``__args__`` 中找到的唯一型別變數的惰性計算元組（可能為空）::"

#: ../../library/stdtypes.rst:5058
#, fuzzy
msgid ""
"A ``GenericAlias`` object with :class:`typing.ParamSpec` parameters may not "
"have correct ``__parameters__`` after substitution because :class:`typing."
"ParamSpec` is intended primarily for static type checking."
msgstr ""
"帶有 :class:`typing.ParamSpec` 參數的 ``GenericAlias`` "
"對像在替換後可能沒有正確的 ``__parameters__`` 因為 :class:`typing.ParamSpec` "
"主要用於靜態型別檢查。"

#: ../../library/stdtypes.rst:5065
#, fuzzy
msgid ""
"A boolean that is true if the alias has been unpacked using the ``*`` "
"operator (see :data:`~typing.TypeVarTuple`)."
msgstr "如果別名已使用 ``*``運算符解壓縮，則為 true 的布爾值（請參閱 :data:`~typing."
"TypeVarTuple`）。"

#: ../../library/stdtypes.rst:5074
#, fuzzy
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - 型別提示"

#: ../../library/stdtypes.rst:5074
#, fuzzy
msgid "Introducing Python's framework for type annotations."
msgstr "介紹 Python 的型別註釋框架。"

#: ../../library/stdtypes.rst:5079
#, fuzzy
msgid ":pep:`585` - Type Hinting Generics In Standard Collections"
msgstr ":pep:`585` - 標準集合中的型別提示泛型"

#: ../../library/stdtypes.rst:5077
#, fuzzy
msgid ""
"Introducing the ability to natively parameterize standard-library classes, "
"provided they implement the special class method :meth:`~object."
"__class_getitem__`."
msgstr "引入本機參數化標準庫類的能力，前提是它們實作了特殊的類方法 :meth:`~object."
"__class_getitem__`。"

#: ../../library/stdtypes.rst:5082
#, fuzzy
msgid ""
":ref:`Generics`, :ref:`user-defined generics <user-defined-generics>` and :"
"class:`typing.Generic`"
msgstr ""
":ref:`Generics`, :ref:`user-defined generics <user-defined-generics>` 和 "
":class:`typing.Generic`"

#: ../../library/stdtypes.rst:5082
#, fuzzy
msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr "有關如何實作可以在運行時參數化並被靜態型別檢查器理解的泛型類的文檔。"

#: ../../library/stdtypes.rst:5091
#, fuzzy
msgid "Union Type"
msgstr "聯盟型別"

#: ../../library/stdtypes.rst:5097
#, fuzzy
msgid ""
"A union object holds the value of the ``|`` (bitwise or) operation on "
"multiple :ref:`type objects <bltin-type-objects>`.  These types are intended "
"primarily for :term:`type annotations <annotation>`. The union type "
"expression enables cleaner type hinting syntax compared to :data:`typing."
"Union`."
msgstr ""
"聯合物件保存多個 :ref:`type objects <bltin-type-objects>` "
"上的``|``（按位或）操作的值。這些型別主要用於 :term:`type annotations "
"<annotation>`。與 :data:`typing.Union` "
"相比，聯合型別表達式支援更清晰的型別提示語法。"

#: ../../library/stdtypes.rst:5104
#, fuzzy
msgid ""
"Defines a union object which holds types *X*, *Y*, and so forth. ``X | Y`` "
"means either X or Y.  It is equivalent to ``typing.Union[X, Y]``. For "
"example, the following function expects an argument of type :class:`int` or :"
"class:`float`::"
msgstr ""
"定義一個包含型別 *X*、*Y* 等的聯合物件。 ``X | Y`` 表示 X 或 Y。它等同於 "
"``typing.Union[X, Y]``。例如，以下函式需要一個型別為 int 或 float 的參數："

#: ../../library/stdtypes.rst:5114
#, fuzzy
msgid ""
"Union objects can be tested for equality with other union objects.  Details:"
msgstr "可以測試聯合對像是否與其他聯合物件相等。細節："

#: ../../library/stdtypes.rst:5116
#, fuzzy
msgid "Unions of unions are flattened::"
msgstr "工會的工會被壓扁::"

#: ../../library/stdtypes.rst:5120
#, fuzzy
msgid "Redundant types are removed::"
msgstr "刪除了冗餘型別::"

#: ../../library/stdtypes.rst:5124
#, fuzzy
msgid "When comparing unions, the order is ignored::"
msgstr "比較聯合時，忽略順序::"

#: ../../library/stdtypes.rst:5128
#, fuzzy
msgid "It is compatible with :data:`typing.Union`::"
msgstr "它與 :data:`typing.Union`:: 相容"

#: ../../library/stdtypes.rst:5132
#, fuzzy
msgid "Optional types can be spelled as a union with ``None``::"
msgstr "可選型別可以拼寫為帶有 ``None``的聯合::"

#: ../../library/stdtypes.rst:5139
#, fuzzy
msgid ""
"Calls to :func:`isinstance` and :func:`issubclass` are also supported with a "
"union object::"
msgstr "聯合對像也支援對 :func:`isinstance` 和 :func:`issubclass` 的呼叫::"

#: ../../library/stdtypes.rst:5145
#, fuzzy
msgid ""
"However, union objects containing :ref:`parameterized generics <types-"
"genericalias>` cannot be used::"
msgstr "但是，不能使用包含 :ref:`parameterized generics <types-genericalias>` "
"的聯合物件::"

#: ../../library/stdtypes.rst:5153
#, fuzzy
msgid ""
"The user-exposed type for the union object can be accessed from :data:`types."
"UnionType` and used for :func:`isinstance` checks.  An object cannot be "
"instantiated from the type::"
msgstr ""
"聯合物件的使用者公開型別可以從 :data:`types.UnionType` 訪問並用於 "
":func:`isinstance` 檢查。對像不能從型別實例化：："

#: ../../library/stdtypes.rst:5166
#, fuzzy
msgid ""
"The :meth:`__or__` method for type objects was added to support the syntax "
"``X | Y``.  If a metaclass implements :meth:`__or__`, the Union may override "
"it::"
msgstr ""
"新增了型別物件的 :meth:`__or__` 方法以支援語法 ``X | Y``。如果一個元類實作了 "
":meth:`__or__`，Union 可能會覆蓋它::"

#: ../../library/stdtypes.rst:5184
#, fuzzy
msgid ":pep:`604` -- PEP proposing the ``X | Y`` syntax and the Union type."
msgstr ":pep:`604` -- PEP 提議 ``X | Y`` 語法和 Union 型別。"

#: ../../library/stdtypes.rst:5192
#, fuzzy
msgid "Other Built-in Types"
msgstr "其他內建型別"

#: ../../library/stdtypes.rst:5194
#, fuzzy
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr "直譯器支援其他幾種物件。其中大多數只支援一兩個操作。"

#: ../../library/stdtypes.rst:5201
msgid "Modules"
msgstr "模組"

#: ../../library/stdtypes.rst:5203
#, fuzzy
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the :keyword:"
"`import` statement is not, strictly speaking, an operation on a module "
"object; ``import foo`` does not require a module object named *foo* to "
"exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""
"模組上唯一的特殊操作是屬性訪問：``m.name``，其中 *m* 是一個模組，*name* 訪問 "
"*m* 的符號表中定義的名稱。模組屬性可以分配給。 （請注意 :keyword:`import` "
"語句嚴格來說不是對模組物件的操作；``import foo`` 不需要名為 *foo* "
"的模組物件存在，而是需要一個（外部） *定義* 某處名為 *foo* 的模組。）"

#: ../../library/stdtypes.rst:5210
#, fuzzy
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the "
"dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to "
"the :attr:`~object.__dict__` attribute is not possible (you can write ``m."
"__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't write "
"``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is not "
"recommended."
msgstr ""
"每個模組的一個特殊屬性是 :attr:`~object."
"__dict__`。這是包含模組符號表的字典。修改這個字典實際上會改變模組的符號表，"
"但是直接賦值給 :attr:`~object.__dict__` 屬性是不可能的（你可以寫 ``m."
"__dict__['a'] = 1``，它定義``m.a`` 為 ``1``，但你不能寫 ``m.__dict__ = "
"{}``）。不建議直接修改 :attr:`~object.__dict__`。"

#: ../../library/stdtypes.rst:5218
#, fuzzy
msgid ""
"Modules built into the interpreter are written like this: ``<module "
"'sys' (built-in)>``.  If loaded from a file, they are written as ``<module "
"'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"直譯器內建的模組是這樣寫的：``<module 'sys' (built-"
"in)>``。如果從文件加載，它們被寫為``<module 'os' from '/usr/local/lib/pythonX"
".Y/os.pyc'>``。"

#: ../../library/stdtypes.rst:5226
#, fuzzy
msgid "Classes and Class Instances"
msgstr "類和類實例"

#: ../../library/stdtypes.rst:5228
#, fuzzy
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "有關這些，請參閱 :ref:`objects` 和 :ref:`class`。"

#: ../../library/stdtypes.rst:5234
msgid "Functions"
msgstr "函式"

#: ../../library/stdtypes.rst:5236
#, fuzzy
msgid ""
"Function objects are created by function definitions.  The only operation on "
"a function object is to call it: ``func(argument-list)``."
msgstr "函式物件由函式定義建立。對函式物件的唯一操作是呼叫它：``func(argument-"
"list)``。"

#: ../../library/stdtypes.rst:5239
#, fuzzy
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr "函式物件實際上有兩種風格：內建函式和使用者定義函式。兩者都支援相同的操作（呼"
"叫函式），但實作不同，因此對像型別不同。"

#: ../../library/stdtypes.rst:5243
msgid "See :ref:`function` for more information."
msgstr "更多資訊請見 :ref:`function`\\ 。"

#: ../../library/stdtypes.rst:5249
#, fuzzy
msgid "Methods"
msgstr "方法"

#: ../../library/stdtypes.rst:5253
#, fuzzy
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: built-in methods (such as :meth:`append` on lists) and "
"class instance methods.  Built-in methods are described with the types that "
"support them."
msgstr ""
"方法是使用屬性符號呼叫的函式。有兩種風格：內建方法（例如列表上的 "
":meth:`append`）和類實例方法。內建方法與支援它們的型別一起描述。"

#: ../../library/stdtypes.rst:5258
#, fuzzy
msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called :dfn:"
"`instance method`) object. When called, it will add the ``self`` argument to "
"the argument list.  Bound methods have two special read-only attributes: ``m."
"__self__`` is the object on which the method operates, and ``m.__func__`` is "
"the function implementing the method.  Calling ``m(arg-1, arg-2, ..., arg-"
"n)`` is completely equivalent to calling ``m.__func__(m.__self__, arg-1, "
"arg-2, ..., arg-n)``."
msgstr ""
"如果您通過實例訪問方法（在類命名空間中定義的函式），您將獲得一個特殊物件：:df"
"n:`bound method`（也稱為 :dfn:`instance method`）物件。呼叫時，它會將 ``self``"
" 參數新增到參數列表中。綁定方法有兩個特殊的只讀屬性：``m.__self__`` "
"是方法操作的物件，``m.__func__`` 是實作方法的函式。呼叫``m(arg-1, arg-2, "
"..., arg-n)`` 完全等同於呼叫``m.__func__(m.__self__, arg-1, arg-2, ..., "
"arg-n)``。"

#: ../../library/stdtypes.rst:5267
#, fuzzy
msgid ""
"Like function objects, bound method objects support getting arbitrary "
"attributes.  However, since method attributes are actually stored on the "
"underlying function object (``meth.__func__``), setting method attributes on "
"bound methods is disallowed.  Attempting to set an attribute on a method "
"results in an :exc:`AttributeError` being raised.  In order to set a method "
"attribute, you need to explicitly set it on the underlying function object::"
msgstr ""
"與函式對像一樣，綁定方法物件支援獲取任意屬性。但是，由於方法屬性實際上儲存在"
"底層函式物件（``meth.__func__``）中，因此不允許在綁定方法上設定方法屬性。"
"嘗試在方法上設定屬性會導致引發 "
":exc:`AttributeError`。為了設定方法屬性，您需要在底層函式對像上顯式設定它::"

#: ../../library/stdtypes.rst:5287 ../../library/stdtypes.rst:5318
msgid "See :ref:`types` for more information."
msgstr "更多資訊請見 :ref:`types`\\ 。"

#: ../../library/stdtypes.rst:5295
#, fuzzy
msgid "Code Objects"
msgstr "程式碼物件"

#: ../../library/stdtypes.rst:5301
#, fuzzy
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\" "
"executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their :attr:"
"`__code__` attribute. See also the :mod:`code` module."
msgstr ""
"實作使用程式碼物件來表示“偽編譯”的可執行 Python 程式碼，例如函式體。它們不同"
"於函式物件，因為它們不包含對其全局執行環境的引用。程式碼物件由內建的 "
":func:`compile` 函式回傳，並且可以通過它們的 :attr:`__code__` "
"屬性從函式對像中提取。另見 :mod:`code` 模組。"

#: ../../library/stdtypes.rst:5308
msgid ""
"Accessing ``__code__`` raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"__code__\"``."
msgstr ""
"存取 ``__code__`` 會引發一個附帶引數 ``obj`` 與 ``\"__code__\"`` 的\\ :ref:`稽核事件 <auditing>` ``object."
"__getattr__``。"

#: ../../library/stdtypes.rst:5315
#, fuzzy
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr "可以通過將程式碼物件（而不是源字串）傳遞給 :func:`exec` 或 :func:`eval` "
"內建函式來執行或評估程式碼物件。"

#: ../../library/stdtypes.rst:5324
#, fuzzy
msgid "Type Objects"
msgstr "型別物件"

#: ../../library/stdtypes.rst:5330
#, fuzzy
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all "
"standard built-in types."
msgstr ""
"型別物件表示各種對像型別。物件的型別由內建函式 :func:`type` "
"訪問。型別沒有特殊操作。標準模組 :mod:`types` 定義所有標準內建型別的名稱。"

#: ../../library/stdtypes.rst:5335
#, fuzzy
msgid "Types are written like this: ``<class 'int'>``."
msgstr "型別是這樣寫的：``<class 'int'>``。"

#: ../../library/stdtypes.rst:5341
#, fuzzy
msgid "The Null Object"
msgstr "空物件"

#: ../../library/stdtypes.rst:5343
#, fuzzy
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name).  ``type(None)()`` produces the same singleton."
msgstr ""
"該物件由未顯式回傳值的函式回傳。它不支援任何特殊操作。只有一個空物件，名為“No"
"ne”（內建名稱）。 ``type(None)()`` 產生相同的單例。"

#: ../../library/stdtypes.rst:5347
#, fuzzy
msgid "It is written as ``None``."
msgstr "它被寫成 ``None`` 。"

#: ../../library/stdtypes.rst:5354
#, fuzzy
msgid "The Ellipsis Object"
msgstr "省略號物件"

#: ../../library/stdtypes.rst:5356
#, fuzzy
msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It supports "
"no special operations.  There is exactly one ellipsis object, named :const:"
"`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces the :const:"
"`Ellipsis` singleton."
msgstr ""
"該物件通常通過切片使用（參見 "
":ref:`slicings`）。它不支援任何特殊操作。只有一個省略號物件，名為 "
":const:`Ellipsis`（內建名稱）。 ``type(Ellipsis)()`` 產生 :const:`Ellipsis` "
"單例。"

#: ../../library/stdtypes.rst:5361
#, fuzzy
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr "它被寫成“省略號”或“...”。"

#: ../../library/stdtypes.rst:5367
#, fuzzy
msgid "The NotImplemented Object"
msgstr "NotImplemented 物件"

#: ../../library/stdtypes.rst:5369
#, fuzzy
msgid ""
"This object is returned from comparisons and binary operations when they are "
"asked to operate on types they don't support. See :ref:`comparisons` for "
"more information.  There is exactly one ``NotImplemented`` object. "
"``type(NotImplemented)()`` produces the singleton instance."
msgstr ""
"當要求比較和二進位操作對它們不支援的型別進行操作時，會回傳此物件。有關詳細資"
"訊，請參閱 :ref:`比較`。只有一個 ``NotImplemented`` 物件。 "
"``type(NotImplemented)()`` 生成單例實例。"

#: ../../library/stdtypes.rst:5374
#, fuzzy
msgid "It is written as ``NotImplemented``."
msgstr "它被寫成 ``NotImplemented`` 。"

#: ../../library/stdtypes.rst:5380
#, fuzzy
msgid "Boolean Values"
msgstr "布爾值"

#: ../../library/stdtypes.rst:5382
#, fuzzy
msgid ""
"Boolean values are the two constant objects ``False`` and ``True``.  They "
"are used to represent truth values (although other values can also be "
"considered false or true).  In numeric contexts (for example when used as "
"the argument to an arithmetic operator), they behave like the integers 0 and "
"1, respectively. The built-in function :func:`bool` can be used to convert "
"any value to a Boolean, if the value can be interpreted as a truth value "
"(see section :ref:`truth` above)."
msgstr ""
"布爾值是兩個常數物件 ``False``和 ``True``。它們用於表示真值（儘管其他值也可以被認為"
"是假或真）。在數字上下文中（例如用作算術運算符的參數時），"
"它們的行為分別類似於整數 0 和 1。內建函式 :func:`bool` "
"可用於將任何值轉換為布爾值，前提是該值可以解釋為真值（請參閱上面的 "
":ref:`truth` 部分）。"

#: ../../library/stdtypes.rst:5395
#, fuzzy
msgid "They are written as ``False`` and ``True``, respectively."
msgstr "它們分別寫為 ``False``和 ``True``。"

#: ../../library/stdtypes.rst:5401
#, fuzzy
msgid "Internal Objects"
msgstr "內部物件"

#: ../../library/stdtypes.rst:5403
#, fuzzy
msgid ""
"See :ref:`types` for this information.  It describes stack frame objects, "
"traceback objects, and slice objects."
msgstr "有關此資訊，請參閱 :ref:`types`。它描述堆疊幀物件、回溯物件和切片物件。"

#: ../../library/stdtypes.rst:5410
#, fuzzy
msgid "Special Attributes"
msgstr "特殊屬性"

#: ../../library/stdtypes.rst:5412
#, fuzzy
msgid ""
"The implementation adds a few special read-only attributes to several object "
"types, where they are relevant.  Some of these are not reported by the :func:"
"`dir` built-in function."
msgstr "該實作向幾個相關的對像型別新增了一些特殊的只讀屬性。其中一些不是由 "
":func:`dir` 內建函式報告的。"

#: ../../library/stdtypes.rst:5419
#, fuzzy
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr "用於儲存物件（可寫）屬性的字典或其他映射物件。"

#: ../../library/stdtypes.rst:5425
#, fuzzy
msgid "The class to which a class instance belongs."
msgstr "類實例所屬的類。"

#: ../../library/stdtypes.rst:5430
#, fuzzy
msgid "The tuple of base classes of a class object."
msgstr "類物件的基底類別元組。"

#: ../../library/stdtypes.rst:5435
#, fuzzy
msgid ""
"The name of the class, function, method, descriptor, or generator instance."
msgstr "類、函式、方法、描述器或生成器實例的名稱。"

#: ../../library/stdtypes.rst:5441
#, fuzzy
msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or "
"generator instance."
msgstr "類、函式、方法、描述器或生成器實例的限定名稱。"

#: ../../library/stdtypes.rst:5449
#, fuzzy
msgid ""
"This attribute is a tuple of classes that are considered when looking for "
"base classes during method resolution."
msgstr "此屬性是在方法解析期間查找基底類別時考慮的類的元組。"

#: ../../library/stdtypes.rst:5455
#, fuzzy
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~class.__mro__`."
msgstr "元類可以覆蓋此方法，以自定義其實例的方法解析順序。它在類實例化時呼叫，"
"其結果儲存在 :attr:`~class.__mro__` 中。"

#: ../../library/stdtypes.rst:5462
#, fuzzy
msgid ""
"Each class keeps a list of weak references to its immediate subclasses.  "
"This method returns a list of all those references still alive.  The list is "
"in definition order.  Example::"
msgstr "每個類都有一個對其直接子類別的弱引用列表。此方法回傳所有那些仍然存在的引用的"
"列表。該列表按定義順序排列。例子：："

#: ../../library/stdtypes.rst:5473
#, fuzzy
msgid "Integer string conversion length limitation"
msgstr "整數字串轉換長度限制"

#: ../../library/stdtypes.rst:5475
#, fuzzy
msgid ""
"CPython has a global limit for converting between :class:`int` and :class:"
"`str` to mitigate denial of service attacks. This limit *only* applies to "
"decimal or other non-power-of-two number bases. Hexadecimal, octal, and "
"binary conversions are unlimited. The limit can be configured."
msgstr ""
"CPython 對 :class:`int` 和 :class:`str` 之間的轉換有一個全局限制，以減輕拒絕"
"服務攻擊。此限制*僅*適用於十進位或其他非二次方數基數。十六進位、八進位和二進"
"制轉換是無限的。可以配置限制。"

#: ../../library/stdtypes.rst:5480
#, fuzzy
msgid ""
"The :class:`int` type in CPython is an arbitrary length number stored in "
"binary form (commonly known as a \"bignum\"). There exists no algorithm that "
"can convert a string to a binary integer or a binary integer to a string in "
"linear time, *unless* the base is a power of 2. Even the best known "
"algorithms for base 10 have sub-quadratic complexity. Converting a large "
"value such as ``int('1' * 500_000)`` can take over a second on a fast CPU."
msgstr ""
"CPython 中的 :class:`int` 型別是以二進位形式儲存的任意長度數字（通常稱為“bign"
"um”）。不存在可以在線性時間內將字串轉換為二進位整數或將二進位整數轉換為字串的"
"演算法，*除非*基數是 2 的冪。即使以 10 "
"為基數的最著名演算法也具有次二次復雜度。在快速 CPU 上轉換一個大值，如 ``int("
"'1' * 500_000)`` 可能需要超過一秒的時間。"

#: ../../library/stdtypes.rst:5487
#, fuzzy
msgid ""
"Limiting conversion size offers a practical way to avoid `CVE-2020-10735 "
"<https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-10735>`_."
msgstr ""
"限制轉換大小提供了一種避免`CVE-2020-10735 <https://cve.mitre.org/cgi-bin/"
"cvename.cgi?name=CVE-2020-10735>`_ 的實用方法。"

#: ../../library/stdtypes.rst:5490
#, fuzzy
msgid ""
"The limit is applied to the number of digit characters in the input or "
"output string when a non-linear conversion algorithm would be involved.  "
"Underscores and the sign are not counted towards the limit."
msgstr "當涉及非線性轉換演算法時，該限制適用於輸入或輸出字串中的數字字元數。底線和"
"符號不計入限制。"

#: ../../library/stdtypes.rst:5494
#, fuzzy
msgid ""
"When an operation would exceed the limit, a :exc:`ValueError` is raised:"
msgstr "當操作超出限制時，會引發 :exc:`ValueError`："

#: ../../library/stdtypes.rst:5516
#, fuzzy
msgid ""
"The default limit is 4300 digits as provided in :data:`sys.int_info."
"default_max_str_digits <sys.int_info>`. The lowest limit that can be "
"configured is 640 digits as provided in :data:`sys.int_info."
"str_digits_check_threshold <sys.int_info>`."
msgstr ""
"預設限制為 4300 位，如 :data:`sys.int_info.default_max_str_digits <sys."
"int_info>` 中所提供。可以配置的最低限制是 640 位數字，如 :data:`"
"sys.int_info.str_digits_check_threshold <sys.int_info>` 中所提供。"

#: ../../library/stdtypes.rst:5521
#, fuzzy
msgid "Verification:"
msgstr "確認："

#: ../../library/stdtypes.rst:5536
#, fuzzy
msgid "Affected APIs"
msgstr "受影響的 API"

#: ../../library/stdtypes.rst:5538
#, fuzzy
msgid ""
"The limitation only applies to potentially slow conversions between :class:"
"`int` and :class:`str` or :class:`bytes`:"
msgstr "該限制僅適用於 int 和 str 或 bytes 之間潛在的緩慢轉換："

#: ../../library/stdtypes.rst:5541
#, fuzzy
msgid "``int(string)`` with default base 10."
msgstr "``int(string)`` 預設以 10 為基數。"

#: ../../library/stdtypes.rst:5542
#, fuzzy
msgid "``int(string, base)`` for all bases that are not a power of 2."
msgstr "``int(string, base)`` 適用於所有不是 2 的冪的基數。"

#: ../../library/stdtypes.rst:5543
msgid "``str(integer)``."
msgstr "``str(integer)``。"

#: ../../library/stdtypes.rst:5544
msgid "``repr(integer)``."
msgstr "``repr(integer)``。"

#: ../../library/stdtypes.rst:5545
#, fuzzy
msgid ""
"any other string conversion to base 10, for example ``f\"{integer}\"``, "
"``\"{}\".format(integer)``, or ``b\"%d\" % integer``."
msgstr ""
"任何其他以 10 為基數的字串轉換，例如 ``f\"{integer}\"``、``\"{}\"."
"format(integer)`` 或 ``b\"%d\" % integer``。"

#: ../../library/stdtypes.rst:5548
#, fuzzy
msgid "The limitations do not apply to functions with a linear algorithm:"
msgstr "這些限制不適用於具有線性演算法的函式："

#: ../../library/stdtypes.rst:5550
#, fuzzy
msgid "``int(string, base)`` with base 2, 4, 8, 16, or 32."
msgstr "``int(string, base)`` 以 2、4、8、16 或 32 為底數。"

#: ../../library/stdtypes.rst:5551
#, fuzzy
msgid ":func:`int.from_bytes` and :func:`int.to_bytes`."
msgstr ":func:`int.from_bytes` 和 :func:`int.to_bytes`。"

#: ../../library/stdtypes.rst:5552
#, fuzzy
msgid ":func:`hex`, :func:`oct`, :func:`bin`."
msgstr ":func:`hex`, :func:`oct`, :func:`bin`。"

#: ../../library/stdtypes.rst:5553
#, fuzzy
msgid ":ref:`formatspec` for hex, octal, and binary numbers."
msgstr ":ref:`formatspec` 用於十六進位、八進位和二進位數。"

#: ../../library/stdtypes.rst:5554
#, fuzzy
msgid ":class:`str` to :class:`float`."
msgstr ":class:`str` 到 :class:`float`。"

#: ../../library/stdtypes.rst:5555
#, fuzzy
msgid ":class:`str` to :class:`decimal.Decimal`."
msgstr ":class:`str` 到 :class:`decimal.Decimal`。"

#: ../../library/stdtypes.rst:5558
#, fuzzy
msgid "Configuring the limit"
msgstr "配置限制"

#: ../../library/stdtypes.rst:5560
#, fuzzy
msgid ""
"Before Python starts up you can use an environment variable or an "
"interpreter command line flag to configure the limit:"
msgstr "在 Python 啟動之前，您可以使用環境變數或直譯器命令列旗標來配置限制："

#: ../../library/stdtypes.rst:5563
#, fuzzy
msgid ""
":envvar:`PYTHONINTMAXSTRDIGITS`, e.g. ``PYTHONINTMAXSTRDIGITS=640 python3`` "
"to set the limit to 640 or ``PYTHONINTMAXSTRDIGITS=0 python3`` to disable "
"the limitation."
msgstr ""
":envvar:`PYTHONINTMAXSTRDIGITS`，例如``PYTHONINTMAXSTRDIGITS=640 python3`` "
"將限制設定為 640 或 ``PYTHONINTMAXSTRDIGITS=0 python3`` 禁用限制。"

#: ../../library/stdtypes.rst:5566
#, fuzzy
msgid ""
":option:`-X int_max_str_digits <-X>`, e.g. ``python3 -X "
"int_max_str_digits=640``"
msgstr ""
":option:`-X int_max_str_digits <-X>`，例如``python3 -X "
"int_max_str_digits=640``"

#: ../../library/stdtypes.rst:5568
#, fuzzy
msgid ""
":data:`sys.flags.int_max_str_digits` contains the value of :envvar:"
"`PYTHONINTMAXSTRDIGITS` or :option:`-X int_max_str_digits <-X>`. If both the "
"env var and the ``-X`` option are set, the ``-X`` option takes precedence. A "
"value of *-1* indicates that both were unset, thus a value of :data:`sys."
"int_info.default_max_str_digits` was used during initialization."
msgstr ""
":data:`sys.flags.int_max_str_digits` 包含 :envvar:`PYTHONINTMAXSTRDIGITS` "
"或 :option:`-X int_max_str_digits <-X>` 的值。如果同時設定了 env var 和 ``-X``"
" 選項，則 ``-X`` 選項優先。 *-1* 值表示兩者均未設定，因此在初始化期間使用了 "
":data:`sys.int_info.default_max_str_digits` 的值。"

#: ../../library/stdtypes.rst:5574
#, fuzzy
msgid ""
"From code, you can inspect the current limit and set a new one using these :"
"mod:`sys` APIs:"
msgstr "從程式碼中，您可以檢查當前限制並使用這些 :mod:`sys` API 設定新限制："

#: ../../library/stdtypes.rst:5577
#, fuzzy
msgid ""
":func:`sys.get_int_max_str_digits` and :func:`sys.set_int_max_str_digits` "
"are a getter and setter for the interpreter-wide limit. Subinterpreters have "
"their own limit."
msgstr ""
":func:`sys.get_int_max_str_digits` 和 :func:`sys.set_int_max_str_digits` "
"是直譯器範圍限制的 getter 和 setter。子直譯器有其自身的限制。"

#: ../../library/stdtypes.rst:5581
#, fuzzy
msgid ""
"Information about the default and minimum can be found in :attr:`sys."
"int_info`:"
msgstr "有關預設值和最小值的資訊可以在 :attr:`sys.int_info` 中找到："

#: ../../library/stdtypes.rst:5583
#, fuzzy
msgid ""
":data:`sys.int_info.default_max_str_digits <sys.int_info>` is the compiled-"
"in default limit."
msgstr ":data:`sys.int_info.default_max_str_digits <sys.int_info>` 是內建的預設限制。"

#: ../../library/stdtypes.rst:5585
#, fuzzy
msgid ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` is the lowest "
"accepted value for the limit (other than 0 which disables it)."
msgstr ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` "
"是限制的最低接受值（除了 0 禁用它）。"

#: ../../library/stdtypes.rst:5592
#, fuzzy
msgid ""
"Setting a low limit *can* lead to problems. While rare, code exists that "
"contains integer constants in decimal in their source that exceed the "
"minimum threshold. A consequence of setting the limit is that Python source "
"code containing decimal integer literals longer than the limit will "
"encounter an error during parsing, usually at startup time or import time or "
"even at installation time - anytime an up to date ``.pyc`` does not already "
"exist for the code. A workaround for source that contains such large "
"constants is to convert them to ``0x`` hexadecimal form as it has no limit."
msgstr ""
"設定下限*可能*會導致問題。雖然很少見，但存在在其源程式碼中包含超過最小閾值的"
"十進位整數常數的程式碼。設定限制的結果是包含十進位整數文字的 Python "
"源程式碼長於限制將在解析過程中遇到錯誤，通常是在啟動時或導入時甚至在安裝時 - "
"任何時候更新 ``.pyc``該程式碼尚不存在。"
"包含如此大常數的源的解決方法是將它們轉換為 ``0x`` "
"十六進位形式，因為它沒有限制。"

#: ../../library/stdtypes.rst:5601
#, fuzzy
msgid ""
"Test your application thoroughly if you use a low limit. Ensure your tests "
"run with the limit set early via the environment or flag so that it applies "
"during startup and even during any installation step that may invoke Python "
"to precompile ``.py`` sources to ``.pyc`` files."
msgstr ""
"如果您使用下限，請徹底測試您的應用程式。確保您的測試在早期通過環境或旗標設定"
"的限制下運行，以便它在啟動期間應用，甚至在任何可能呼叫 Python 將 ``.py`` "
"源預編譯為 ``.pyc`` 文件的安裝步驟中應用。"

#: ../../library/stdtypes.rst:5607
#, fuzzy
msgid "Recommended configuration"
msgstr "推薦配置"

#: ../../library/stdtypes.rst:5609
#, fuzzy
msgid ""
"The default :data:`sys.int_info.default_max_str_digits` is expected to be "
"reasonable for most applications. If your application requires a different "
"limit, set it from your main entry point using Python version agnostic code "
"as these APIs were added in security patch releases in versions before 3.11."
msgstr ""
"預設 :data:`sys.int_info.default_max_str_digits` "
"對於大多數應用程式來說都是合理的。如果您的應用程式需要不同的限制，請使用與 "
"Python 版本無關的程式碼從主入口點進行設定，因為這些 API 已新增到 3.11 "
"之前版本的安全補丁版本中。"

#: ../../library/stdtypes.rst:5614
msgid "Example::"
msgstr ""
"範例：\n"
"\n"
"::"

#: ../../library/stdtypes.rst:5626
#, fuzzy
msgid "If you need to disable it entirely, set it to ``0``."
msgstr "如果您需要完全禁用它，請將其設定為 ``0``。"

#: ../../library/stdtypes.rst:5630
msgid "Footnotes"
msgstr "註解"

#: ../../library/stdtypes.rst:5631
#, fuzzy
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr "有關這些特殊方法的更多資訊，請參閱 Python 參考手冊 (:ref:`customization`)。"

#: ../../library/stdtypes.rst:5634
#, fuzzy
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, "
"and similarly for tuples."
msgstr "因此，列表“[1, 2]”被認為等於“[1.0, 2.0]”，元組也是如此。"

#: ../../library/stdtypes.rst:5637
#, fuzzy
msgid "They must have since the parser can't tell the type of the operands."
msgstr "他們必須有，因為解析器無法分辨操作數的型別。"

#: ../../library/stdtypes.rst:5639
#, fuzzy
msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr "大小寫字元是那些具有一般類別屬性的字元，它們是 ``Lu``（字母，大寫）、 ``Ll``（字母"
"，小寫）或 ``Lt``（字母，titlecase）之一。"

#: ../../library/stdtypes.rst:5642
#, fuzzy
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr "因此，要僅格式化一個元組，您應該提供一個單例元組，其唯一元素是要格式化的元組"
"。"
