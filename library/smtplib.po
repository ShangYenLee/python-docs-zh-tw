# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-24 00:16+0000\n"
"PO-Revision-Date: 2018-05-23 16:10+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../library/smtplib.rst:2
msgid ":mod:`smtplib` --- SMTP protocol client"
msgstr ":mod:`smtplib` --- SMTP 協定用戶端"

#: ../../library/smtplib.rst:9
msgid "**Source code:** :source:`Lib/smtplib.py`"
msgstr "**原始碼：**\\ :source:`Lib/smtplib.py`"

#: ../../library/smtplib.rst:17
#, fuzzy
msgid ""
"The :mod:`smtplib` module defines an SMTP client session object that can be "
"used to send mail to any internet machine with an SMTP or ESMTP listener "
"daemon.  For details of SMTP and ESMTP operation, consult :rfc:`821` (Simple "
"Mail Transfer Protocol) and :rfc:`1869` (SMTP Service Extensions)."
msgstr ""
":mod:`smtplib` 模組定義了一個 SMTP 用戶端會話物件，可用於將郵件發送到任何具"
"有 SMTP 或 ESMTP 偵聽器守護程式的網際網路機器。有關 SMTP 和 ESMTP 操作的詳細資"
"訊，請參閱 :rfc:`821`（簡單郵件傳輸協定）和 :rfc:`1869`（SMTP 服務擴充）。"

#: ../../includes/wasm-notavail.rst:3
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ":ref:`Availability <availability>`：非 Emscripten、非 WASI。"

#: ../../includes/wasm-notavail.rst:5
#, fuzzy
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"此模組在 WebAssembly 平台 ``wasm32-emscripten`` 和 ``wasm32-wasi`` 上不起作用"
"或不可用。有關更多資訊，請參閱 :ref:`wasm-availability`。"

#: ../../library/smtplib.rst:26
#, fuzzy
msgid ""
"An :class:`SMTP` instance encapsulates an SMTP connection.  It has methods "
"that support a full repertoire of SMTP and ESMTP operations. If the optional "
"host and port parameters are given, the SMTP :meth:`connect` method is "
"called with those parameters during initialization.  If specified, "
"*local_hostname* is used as the FQDN of the local host in the HELO/EHLO "
"command.  Otherwise, the local hostname is found using :func:`socket."
"getfqdn`.  If the :meth:`connect` call returns anything other than a success "
"code, an :exc:`SMTPConnectError` is raised. The optional *timeout* parameter "
"specifies a timeout in seconds for blocking operations like the connection "
"attempt (if not specified, the global default timeout setting will be "
"used).  If the timeout expires, :exc:`TimeoutError` is raised.  The optional "
"source_address parameter allows binding to some specific source address in a "
"machine with multiple network interfaces, and/or to some specific source TCP "
"port. It takes a 2-tuple (host, port), for the socket to bind to as its "
"source address before connecting. If omitted (or if host or port are ``''`` "
"and/or 0 respectively) the OS default behavior will be used."
msgstr ""
":class:`SMTP` 實例封裝了 SMTP 連接。它的方法支援完整的 SMTP 和 ESMTP 操作。如"
"果提供了可選的主機和端口參數，則在初始化期間使用這些參數呼叫 SMTP :meth:"
"`connect` 方法。如果指定，*local_hostname* 將用作 HELO/EHLO 命令中本地主機的 "
"FQDN。否則，使用 :func:`socket.getfqdn` 找到本地主機名。如果 :meth:`connect` "
"呼叫回傳成功程式碼以外的任何內容，則會引發 :exc:`SMTPConnectError`。可選的 "
"*timeout* 參數以秒為單位指定超時以阻止連接嘗試等操作（如果未指定，將使用全局"
"預設超時設定）。如果超時到期，則會引發 :exc:`TimeoutError`。可選的 "
"source_address 參數允許綁定到具有多個網絡介面的機器中的某個特定源地址，和/或"
"綁定到某個特定源 TCP 端口。它需要一個 2 元組（主機，端口），以便 socket 在連"
"接之前綁定到它的源地址。如果省略（或者如果主機或端口分別為 ``''`` 和/或 0），"
"將使用操作系統預設行為。"

#: ../../library/smtplib.rst:44
#, fuzzy
msgid ""
"For normal use, you should only require the initialization/connect, :meth:"
"`sendmail`, and :meth:`SMTP.quit` methods. An example is included below."
msgstr ""
"對於正常使用，您應該只需要初始化/連接、:meth:`sendmail` 和:meth:`SMTP.quit` "
"方法。下麵包含一個示例。"

#: ../../library/smtplib.rst:48
#, fuzzy
msgid ""
"The :class:`SMTP` class supports the :keyword:`with` statement.  When used "
"like this, the SMTP ``QUIT`` command is issued automatically when the :"
"keyword:`!with` statement exits.  E.g.::"
msgstr ""
":class:`SMTP` 類支援 :keyword:`with` 語句。像這樣使用時，SMTP ``QUIT`` 命令會"
"在 :keyword:`!with` 語句退出時自動發出。例如。：："

#: ../../library/smtplib.rst:70
msgid ""
"Raises an :ref:`auditing event <auditing>` ``smtplib.send`` with arguments "
"``self``, ``data``."
msgstr ""
"引發一個附帶引數 ``self``、``data`` 的\\ :ref:`稽核事件 <auditing>` "
"``smtplib.send``。"

#: ../../library/smtplib.rst:61
msgid ""
"All commands will raise an :ref:`auditing event <auditing>` ``smtplib.SMTP."
"send`` with arguments ``self`` and ``data``, where ``data`` is the bytes "
"about to be sent to the remote host."
msgstr ""
"所有指令都會引發一個附帶引數 ``self``、``data`` 的\\ :ref:`稽核事件 "
"<auditing>` ``smtplib.SMTP.send``，其中 ``data`` 為即將傳送至遠端的位元組。"

#: ../../library/smtplib.rst:65
msgid "Support for the :keyword:`with` statement was added."
msgstr "新增了對 :keyword:`with` 陳述式的支援。"

#: ../../library/smtplib.rst:68 ../../library/smtplib.rst:100
msgid "source_address argument was added."
msgstr "新增 source_address 引數。"

#: ../../library/smtplib.rst:71
msgid "The SMTPUTF8 extension (:rfc:`6531`) is now supported."
msgstr "現在支援 SMTPUTF8 擴充 (:rfc:`6531`)。"

#: ../../library/smtplib.rst:74 ../../library/smtplib.rst:115
#, fuzzy
msgid ""
"If the *timeout* parameter is set to be zero, it will raise a :class:"
"`ValueError` to prevent the creation of a non-blocking socket"
msgstr ""
"如果 *timeout* 參數設定為零，它將引發 :class:`ValueError` 以防止建立非阻塞 "
"socket "

#: ../../library/smtplib.rst:82
#, fuzzy
msgid ""
"An :class:`SMTP_SSL` instance behaves exactly the same as instances of :"
"class:`SMTP`. :class:`SMTP_SSL` should be used for situations where SSL is "
"required from the beginning of the connection and using :meth:`starttls` is "
"not appropriate. If *host* is not specified, the local host is used. If "
"*port* is zero, the standard SMTP-over-SSL port (465) is used.  The optional "
"arguments *local_hostname*, *timeout* and *source_address* have the same "
"meaning as they do in the :class:`SMTP` class.  *context*, also optional, "
"can contain a :class:`~ssl.SSLContext` and allows configuring various "
"aspects of the secure connection.  Please read :ref:`ssl-security` for best "
"practices."
msgstr ""
":class:`SMTP_SSL` 實例的行為與 :class:`SMTP` 的實例完全相同。 :class:"
"`SMTP_SSL` 應用於從連接開始就需要 SSL 且使用 :meth:`starttls` 不合適的情況。"
"如果未指定 *host*，則使用本地主機。如果 *port* 為零，則使用標準 SMTP-over-"
"SSL 端口 (465)。可選參數 *local_hostname*、*timeout* 和 *source_address* 與它"
"們在 SMTP 類中的含義相同。 *context*，也是可選的，可以包含 :class:`~ssl."
"SSLContext` 並允許配置安全連接的各個方面。請閱讀 :ref:`ssl-security` 以獲得最"
"佳實踐。"

#: ../../library/smtplib.rst:93
#, fuzzy
msgid ""
"*keyfile* and *certfile* are a legacy alternative to *context*, and can "
"point to a PEM formatted private key and certificate chain file for the SSL "
"connection."
msgstr ""
"*keyfile* 和 *certfile* 是 *context* 的傳統替代方案，可以指向用於 SSL 連接的 "
"PEM 格式私鑰和證書鏈文件。"

#: ../../library/smtplib.rst:97 ../../library/smtplib.rst:428
msgid "*context* was added."
msgstr "新增 *context*\\ 。"

#: ../../library/smtplib.rst:103
#, fuzzy
msgid ""
"The class now supports hostname check with :attr:`ssl.SSLContext."
"check_hostname` and *Server Name Indication* (see :data:`ssl.HAS_SNI`)."
msgstr ""
"該類現在支援使用 :attr:`ssl.SSLContext.check_hostname` 和 *Server Name "
"Indication* 進行主機名檢查（參見 :data:`ssl.HAS_SNI`）。"

#: ../../library/smtplib.rst:110 ../../library/smtplib.rst:414
#, fuzzy
msgid ""
"*keyfile* and *certfile* are deprecated in favor of *context*. Please use :"
"meth:`ssl.SSLContext.load_cert_chain` instead, or let :func:`ssl."
"create_default_context` select the system's trusted CA certificates for you."
msgstr ""
"*keyfile* 和 *certfile* 已棄用，取而代之的是 *context*。請改用 :meth:`ssl."
"SSLContext.load_cert_chain`，或讓 :func:`ssl.create_default_context` 為您選擇"
"系統的可信 CA 證書。"

#: ../../library/smtplib.rst:122
#, fuzzy
msgid ""
"The LMTP protocol, which is very similar to ESMTP, is heavily based on the "
"standard SMTP client. It's common to use Unix sockets for LMTP, so our :meth:"
"`connect` method must support that as well as a regular host:port server. "
"The optional arguments local_hostname and source_address have the same "
"meaning as they do in the :class:`SMTP` class. To specify a Unix socket, you "
"must use an absolute path for *host*, starting with a '/'."
msgstr ""
"與 ESMTP 非常相似的 LMTP 協定在很大程度上基於標準的 SMTP 用戶端。將 Unix  "
"socket 用於 LMTP 很常見，因此我們的 :meth:`connect` 方法必須支援它以及常規的 "
"host:port 伺服器。可選參數 local_hostname 和 source_address 與它們在 SMTP 類"
"中的含義相同。要指定 Unix  socket ，您必須使用 *host* 的絕對路徑，以 ``/``開"
"頭。"

#: ../../library/smtplib.rst:129
#, fuzzy
msgid ""
"Authentication is supported, using the regular SMTP mechanism. When using a "
"Unix socket, LMTP generally don't support or require any authentication, but "
"your mileage might vary."
msgstr ""
"支援身份驗證，使用常規的 SMTP 機制。使用 Unix  socket 時，LMTP 通常不支援或不"
"需要任何身份驗證，但您的情況可能會有所不同。"

#: ../../library/smtplib.rst:133
msgid "The optional *timeout* parameter was added."
msgstr "新增 *timeout* 選用參數。"

#: ../../library/smtplib.rst:137
#, fuzzy
msgid "A nice selection of exceptions is defined as well:"
msgstr "還定義了一個很好的例外選擇："

#: ../../library/smtplib.rst:142
#, fuzzy
msgid ""
"Subclass of :exc:`OSError` that is the base exception class for all the "
"other exceptions provided by this module."
msgstr "OSError 的子類別，它是此模組提供的所有其他例外的基例外類。"

#: ../../library/smtplib.rst:145
#, fuzzy
msgid "SMTPException became subclass of :exc:`OSError`"
msgstr "SMTPException 成為 OSError 的子類別"

#: ../../library/smtplib.rst:151
#, fuzzy
msgid ""
"This exception is raised when the server unexpectedly disconnects, or when "
"an attempt is made to use the :class:`SMTP` instance before connecting it to "
"a server."
msgstr ""
"當伺服器意外斷開連接時，或者在將它連接到伺服器之前嘗試使用 SMTP 實例時，會引"
"發此例外。"

#: ../../library/smtplib.rst:158
#, fuzzy
msgid ""
"Base class for all exceptions that include an SMTP error code. These "
"exceptions are generated in some instances when the SMTP server returns an "
"error code.  The error code is stored in the :attr:`smtp_code` attribute of "
"the error, and the :attr:`smtp_error` attribute is set to the error message."
msgstr ""
"包含 SMTP 錯誤程式碼的所有例外的基底類別。當 SMTP 伺服器回傳錯誤程式碼時，在"
"某些情況下會生成這些例外。錯誤程式碼儲存在錯誤的 :attr:`smtp_code` 屬性中，:"
"attr:`smtp_error` 屬性設定為錯誤消息。"

#: ../../library/smtplib.rst:166
#, fuzzy
msgid ""
"Sender address refused.  In addition to the attributes set by on all :exc:"
"`SMTPResponseException` exceptions, this sets 'sender' to the string that "
"the SMTP server refused."
msgstr ""
"發件人地址被拒絕。除了由所有 :exc:`SMTPResponseException` 例外設定的屬性外，"
"這會將“發件人”設定為 SMTP 伺服器拒絕的字串。"

#: ../../library/smtplib.rst:173
#, fuzzy
msgid ""
"All recipient addresses refused.  The errors for each recipient are "
"accessible through the attribute :attr:`recipients`, which is a dictionary "
"of exactly the same sort as :meth:`SMTP.sendmail` returns."
msgstr ""
"所有收件人地址均被拒絕。每個收件人的錯誤都可以通過屬性 recipients 訪問，這是"
"一個與 SMTP.sendmail 回傳的型別完全相同的字典。"

#: ../../library/smtplib.rst:180
#, fuzzy
msgid "The SMTP server refused to accept the message data."
msgstr "SMTP 伺服器拒絕接受郵件資料。"

#: ../../library/smtplib.rst:185
#, fuzzy
msgid "Error occurred during establishment of a connection  with the server."
msgstr "與伺服器建立連接時發生錯誤。"

#: ../../library/smtplib.rst:190
#, fuzzy
msgid "The server refused our ``HELO`` message."
msgstr "伺服器拒絕了我們的 ``HELO`` 消息。"

#: ../../library/smtplib.rst:195
#, fuzzy
msgid "The command or option attempted is not supported by the server."
msgstr "伺服器不支援嘗試的命令或選項。"

#: ../../library/smtplib.rst:202
#, fuzzy
msgid ""
"SMTP authentication went wrong.  Most probably the server didn't accept the "
"username/password combination provided."
msgstr "SMTP 身份驗證出錯。很可能伺服器不接受提供的使用者名/密碼組合。"

#: ../../library/smtplib.rst:210
msgid ":rfc:`821` - Simple Mail Transfer Protocol"
msgstr ":rfc:`821` - 簡單郵件傳輸協定"

#: ../../library/smtplib.rst:209
#, fuzzy
msgid ""
"Protocol definition for SMTP.  This document covers the model, operating "
"procedure, and protocol details for SMTP."
msgstr "SMTP 的協定定義。本文檔涵蓋了 SMTP 的模型、操作過程和協定詳細資訊。"

#: ../../library/smtplib.rst:214
msgid ":rfc:`1869` - SMTP Service Extensions"
msgstr ":rfc:`1869` - SMTP 服務擴充"

#: ../../library/smtplib.rst:213
#, fuzzy
msgid ""
"Definition of the ESMTP extensions for SMTP.  This describes a framework for "
"extending SMTP with new commands, supporting dynamic discovery of the "
"commands provided by the server, and defines a few additional commands."
msgstr ""
"SMTP 的 ESMTP 擴充的定義。這描述了一個用新命令擴充 SMTP 的框架，支援伺服器提"
"供的命令的動態發現，並定義了一些額外的命令。"

#: ../../library/smtplib.rst:221
msgid "SMTP Objects"
msgstr "SMTP 物件"

#: ../../library/smtplib.rst:223
msgid "An :class:`SMTP` instance has the following methods:"
msgstr ":class:`SMTP` 實例具有以下方法："

#: ../../library/smtplib.rst:228
#, fuzzy
msgid ""
"Set the debug output level.  A value of 1 or ``True`` for *level* results in "
"debug messages for connection and for all messages sent to and received from "
"the server.  A value of 2 for *level* results in these messages being "
"timestamped."
msgstr ""
"設定除錯輸出級別。 *level* 的值為 1 或 ``True`` 會導致連接除錯消息以及發送到"
"伺服器和從伺服器接收的所有消息。 *level* 的值為 2 會導致這些消息被加上時間"
"戳。"

#: ../../library/smtplib.rst:233
#, fuzzy
msgid "Added debuglevel 2."
msgstr "新增除錯級別 2。"

#: ../../library/smtplib.rst:238
#, fuzzy
msgid ""
"Send a command *cmd* to the server.  The optional argument *args* is simply "
"concatenated to the command, separated by a space."
msgstr "向伺服器發送命令 *cmd*。可選參數 *args* 簡單地連接到命令，由空格分隔。"

#: ../../library/smtplib.rst:241
#, fuzzy
msgid ""
"This returns a 2-tuple composed of a numeric response code and the actual "
"response line (multiline responses are joined into one long line.)"
msgstr ""
"這將回傳一個由數字響應程式碼和實際響應行組成的 2 元組（多行響應連接成一個長"
"行。）"

#: ../../library/smtplib.rst:244
#, fuzzy
msgid ""
"In normal operation it should not be necessary to call this method "
"explicitly. It is used to implement other methods and may be useful for "
"testing private extensions."
msgstr ""
"在正常操作中，不需要顯式呼叫此方法。它用於實作其他方法，可能對測試私有擴充很"
"有用。"

#: ../../library/smtplib.rst:248
#, fuzzy
msgid ""
"If the connection to the server is lost while waiting for the reply, :exc:"
"`SMTPServerDisconnected` will be raised."
msgstr ""
"如果在等待回覆時與伺服器的連接丟失，將引發 :exc:`SMTPServerDisconnected`。"

#: ../../library/smtplib.rst:254
#, fuzzy
msgid ""
"Connect to a host on a given port.  The defaults are to connect to the local "
"host at the standard SMTP port (25). If the hostname ends with a colon "
"(``':'``) followed by a number, that suffix will be stripped off and the "
"number interpreted as the port number to use. This method is automatically "
"invoked by the constructor if a host is specified during instantiation.  "
"Returns a 2-tuple of the response code and message sent by the server in its "
"connection response."
msgstr ""
"連接到給定端口上的主機。預設設定是通過標準 SMTP 端口 (25) 連接到本地主機。如"
"果主機名以冒號 (``':'``) 結尾，後跟一個數字，則該後綴將被刪除，並將數字解釋為"
"要使用的端口號。如果在實例化期間指定了主機，則構造函式會自動呼叫此方法。回傳"
"伺服器在其連接響應中發送的響應程式碼和消息的二元組。"

#: ../../library/smtplib.rst:273
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``smtplib.connect`` with "
"arguments ``self``, ``host``, ``port``."
msgstr ""
"使用參數 ``self``、``host``、``port`` 引發 :ref:`auditing 事件 <auditing>` "
"``smtplib.connect``。"

#: ../../library/smtplib.rst:267
#, fuzzy
msgid ""
"Identify yourself to the SMTP server using ``HELO``.  The hostname argument "
"defaults to the fully qualified domain name of the local host. The message "
"returned by the server is stored as the :attr:`helo_resp` attribute of the "
"object."
msgstr ""
"使用 ``HELO`` 向 SMTP 伺服器標識您自己。主機名參數預設為本地主機的完全限定域"
"名。伺服器回傳的消息儲存為物件的 :attr:`helo_resp` 屬性。"

#: ../../library/smtplib.rst:272
#, fuzzy
msgid ""
"In normal operation it should not be necessary to call this method "
"explicitly. It will be implicitly called by the :meth:`sendmail` when "
"necessary."
msgstr ""
"在正常操作中，不需要顯式呼叫此方法。必要時，它會被 :meth:`sendmail` 隱式呼"
"叫。"

#: ../../library/smtplib.rst:278
#, fuzzy
msgid ""
"Identify yourself to an ESMTP server using ``EHLO``.  The hostname argument "
"defaults to the fully qualified domain name of the local host.  Examine the "
"response for ESMTP option and store them for use by :meth:`has_extn`. Also "
"sets several informational attributes: the message returned by the server is "
"stored as the :attr:`ehlo_resp` attribute, :attr:`does_esmtp` is set to "
"``True`` or ``False`` depending on whether the server supports ESMTP, and :"
"attr:`esmtp_features` will be a dictionary containing the names of the SMTP "
"service extensions this server supports, and their parameters (if any)."
msgstr ""
"使用 ``EHLO``向 ESMTP 伺服器標識您自己。主機名參數預設為本地主機的完全限定域"
"名。檢查 ESMTP 選項的響應並儲存它們以供 :meth:`has_extn` 使用。還設定了幾個資"
"訊屬性：伺服器回傳的消息儲存為 :attr:`ehlo_resp` 屬性，:attr:`does_esmtp` 設"
"定為 ``True`` 或 ``False`` 取決於伺服器是否支援ESMTP 和 :attr:"
"`esmtp_features` 將是一個字典，其中包含此伺服器支援的 SMTP 服務擴充的名稱及其"
"參數（如果有）。"

#: ../../library/smtplib.rst:288
#, fuzzy
msgid ""
"Unless you wish to use :meth:`has_extn` before sending mail, it should not "
"be necessary to call this method explicitly.  It will be implicitly called "
"by :meth:`sendmail` when necessary."
msgstr ""
"除非您希望在發送郵件之前使用 :meth:`has_extn`，否則沒有必要顯式呼叫此方法。必"
"要時，它會被 :meth:`sendmail` 隱式呼叫。"

#: ../../library/smtplib.rst:294
#, fuzzy
msgid ""
"This method calls :meth:`ehlo` and/or :meth:`helo` if there has been no "
"previous ``EHLO`` or ``HELO`` command this session.  It tries ESMTP ``EHLO`` "
"first."
msgstr ""
"如果此會話之前沒有 ``EHLO`` 或 ``HELO`` 命令，則此方法呼叫 :meth:`ehlo` 和/"
"或 :meth:`helo`。它首先嘗試 ESMTP ``EHLO``。"

#: ../../library/smtplib.rst:298 ../../library/smtplib.rst:328
#: ../../library/smtplib.rst:420 ../../library/smtplib.rst:489
msgid ":exc:`SMTPHeloError`"
msgstr ":exc:`SMTPHeloError`"

#: ../../library/smtplib.rst:299 ../../library/smtplib.rst:328
#: ../../library/smtplib.rst:420 ../../library/smtplib.rst:489
msgid "The server didn't reply properly to the ``HELO`` greeting."
msgstr "伺服器沒有正確回覆 ``HELO`` 問候語。"

#: ../../library/smtplib.rst:303
#, fuzzy
msgid ""
"Return :const:`True` if *name* is in the set of SMTP service extensions "
"returned by the server, :const:`False` otherwise. Case is ignored."
msgstr ""
"如果 *name* 在伺服器回傳的 SMTP 服務擴充集中，則回傳 :const:`True`，否則回"
"傳 :const:`False`。忽略大小寫。"

#: ../../library/smtplib.rst:309
#, fuzzy
msgid ""
"Check the validity of an address on this server using SMTP ``VRFY``. Returns "
"a tuple consisting of code 250 and a full :rfc:`822` address (including "
"human name) if the user address is valid. Otherwise returns an SMTP error "
"code of 400 or greater and an error string."
msgstr ""
"使用 SMTP ``VRFY`` 檢查此伺服器上地址的有效性。如果使用者地址有效，則回傳一個"
"由程式碼 250 和完整的 :rfc:`822` 地址（包括人名）組成的元組。否則回傳 400 或"
"更大的 SMTP 錯誤程式碼和錯誤字串。"

#: ../../library/smtplib.rst:316
#, fuzzy
msgid "Many sites disable SMTP ``VRFY`` in order to foil spammers."
msgstr "許多站點禁用 SMTP ``VRFY`` 以阻止垃圾郵件發送者。"

#: ../../library/smtplib.rst:321
#, fuzzy
msgid ""
"Log in on an SMTP server that requires authentication. The arguments are the "
"username and the password to authenticate with. If there has been no "
"previous ``EHLO`` or ``HELO`` command this session, this method tries ESMTP "
"``EHLO`` first. This method will return normally if the authentication was "
"successful, or may raise the following exceptions:"
msgstr ""
"登錄需要身份驗證的 SMTP 伺服器。參數是用於驗證的使用者名和密碼。如果此會話之"
"前沒有 ``EHLO``或 ``HELO``命令，則此方法首先嘗試 ESMTP ``EHLO``。如果身份驗證"
"成功，此方法將正常回傳，或者可能引發以下例外："

#: ../../library/smtplib.rst:331
msgid ":exc:`SMTPAuthenticationError`"
msgstr ":exc:`SMTPAuthenticationError`"

#: ../../library/smtplib.rst:331
#, fuzzy
msgid "The server didn't accept the username/password combination."
msgstr "伺服器不接受使用者名/密碼組合。"

#: ../../library/smtplib.rst:334 ../../library/smtplib.rst:423
#: ../../library/smtplib.rst:500
msgid ":exc:`SMTPNotSupportedError`"
msgstr ":exc:`SMTPNotSupportedError`"

#: ../../library/smtplib.rst:334
msgid "The ``AUTH`` command is not supported by the server."
msgstr "伺服器不支援 ``AUTH`` 命令。"

#: ../../library/smtplib.rst:337
msgid ":exc:`SMTPException`"
msgstr ":exc:`SMTPException`"

#: ../../library/smtplib.rst:337
#, fuzzy
msgid "No suitable authentication method was found."
msgstr "未找到合適的身份驗證方法。"

#: ../../library/smtplib.rst:339
#, fuzzy
msgid ""
"Each of the authentication methods supported by :mod:`smtplib` are tried in "
"turn if they are advertised as supported by the server.  See :meth:`auth` "
"for a list of supported authentication methods.  *initial_response_ok* is "
"passed through to :meth:`auth`."
msgstr ""
":mod:`smtplib` 支援的每一種身份驗證方法，如果它們被廣告為伺服器支援，則會依次"
"嘗試。有關受支援的身份驗證方法的列表，請參閱 :meth:`auth`。 "
"*initial_response_ok* 傳遞給 :meth:`auth`。"

#: ../../library/smtplib.rst:344
#, fuzzy
msgid ""
"Optional keyword argument *initial_response_ok* specifies whether, for "
"authentication methods that support it, an \"initial response\" as specified "
"in :rfc:`4954` can be sent along with the ``AUTH`` command, rather than "
"requiring a challenge/response."
msgstr ""
"可選關鍵字參數 *initial_response_ok* 指定對於支援它的身份驗證方法，是否可以"
"將 :rfc:`4954` 中指定的“初始響應”與 ``AUTH`` 命令一起發送，而不是要求質詢/響"
"應."

#: ../../library/smtplib.rst:349
#, fuzzy
msgid ""
":exc:`SMTPNotSupportedError` may be raised, and the *initial_response_ok* "
"parameter was added."
msgstr ""
":exc:`SMTPNotSupportedError` 可能會被引發，並且新增了 *initial_response_ok* "
"參數。"

#: ../../library/smtplib.rst:356
#, fuzzy
msgid ""
"Issue an ``SMTP`` ``AUTH`` command for the specified authentication "
"*mechanism*, and handle the challenge response via *authobject*."
msgstr ""
"為指定的身份驗證*機制*發出 ``SMTP`` ``AUTH`` 命令，並通過 *authobject* 處理質"
"詢響應。"

#: ../../library/smtplib.rst:359
#, fuzzy
msgid ""
"*mechanism* specifies which authentication mechanism is to be used as "
"argument to the ``AUTH`` command; the valid values are those listed in the "
"``auth`` element of :attr:`esmtp_features`."
msgstr ""
"*mechanism* 指定哪種身份驗證機制將用作 ``AUTH`` 命令的參數；有效值是在 "
"esmtp_features 的 ``auth`` 元素中列出的值。"

#: ../../library/smtplib.rst:363
#, fuzzy
msgid ""
"*authobject* must be a callable object taking an optional single argument:"
msgstr "*authobject* 必須是一個帶有可選單個參數的可呼叫物件："

#: ../../library/smtplib.rst:365
msgid "data = authobject(challenge=None)"
msgstr "data = authobject(challenge=None)"

#: ../../library/smtplib.rst:367
#, fuzzy
msgid ""
"If optional keyword argument *initial_response_ok* is true, ``authobject()`` "
"will be called first with no argument.  It can return the :rfc:`4954` "
"\"initial response\" ASCII ``str`` which will be encoded and sent with the "
"``AUTH`` command as below.  If the ``authobject()`` does not support an "
"initial response (e.g. because it requires a challenge), it should return "
"``None`` when called with ``challenge=None``.  If *initial_response_ok* is "
"false, then ``authobject()`` will not be called first with ``None``."
msgstr ""
"如果可選的關鍵字參數 *initial_response_ok* 為真，則將首先呼叫 "
"``authobject()`` 而不帶參數。它可以回傳 :rfc:`4954`“初始響應”ASCII ``str``，"
"它將被編碼並與``AUTH``命令一起發送，如下所示。如果 ``authobject()`` 不支援初"
"始響應（例如，因為它需要挑戰），當使用 ``challenge=None`` 呼叫時，它應該回傳 "
"``None``。如果 *initial_response_ok* 為 false，則不會首先使用 ``None``呼"
"叫“authobject()”。"

#: ../../library/smtplib.rst:375
#, fuzzy
msgid ""
"If the initial response check returns ``None``, or if *initial_response_ok* "
"is false, ``authobject()`` will be called to process the server's challenge "
"response; the *challenge* argument it is passed will be a ``bytes``.  It "
"should return ASCII ``str`` *data* that will be base64 encoded and sent to "
"the server."
msgstr ""
"如果初始響應檢查回傳 ``None``，或者如果*initial_response_ok* 為假，則將呼"
"叫“authobject()”來處理伺服器的挑戰響應；它傳遞的 *challenge* 參數將是一個“位"
"元組”。它應該回傳將被 base64 編碼並發送到伺服器的 ASCII ``str`` *data*。"

#: ../../library/smtplib.rst:381
#, fuzzy
msgid ""
"The ``SMTP`` class provides ``authobjects`` for the ``CRAM-MD5``, ``PLAIN``, "
"and ``LOGIN`` mechanisms; they are named ``SMTP.auth_cram_md5``, ``SMTP."
"auth_plain``, and ``SMTP.auth_login`` respectively.  They all require that "
"the ``user`` and ``password`` properties of the ``SMTP`` instance are set to "
"appropriate values."
msgstr ""
"``SMTP`` 類為``CRAM-MD5``、``PLAIN`` 和``LOGIN`` 機制提供``authobjects``；它"
"們分別被命名為“SMTP.auth_cram_md5”、“SMTP.auth_plain”和“SMTP.auth_login”。它"
"們都要求將 SMTP 實例的 user 和 password 屬性設定為適當的值。"

#: ../../library/smtplib.rst:387
#, fuzzy
msgid ""
"User code does not normally need to call ``auth`` directly, but can instead "
"call the :meth:`login` method, which will try each of the above mechanisms "
"in turn, in the order listed.  ``auth`` is exposed to facilitate the "
"implementation of authentication methods not (or not yet) supported directly "
"by :mod:`smtplib`."
msgstr ""
"使用者程式碼通常不需要直接呼叫 ``auth``，而是可以呼叫 :meth:`login` 方法，該"
"方法將按列出的順序依次嘗試上述每種機制。 ``auth`` 被公開以促進 :mod:"
"`smtplib` 不直接支援（或尚未）支援的身份驗證方法的實作。"

#: ../../library/smtplib.rst:398
#, fuzzy
msgid ""
"Put the SMTP connection in TLS (Transport Layer Security) mode.  All SMTP "
"commands that follow will be encrypted.  You should then call :meth:`ehlo` "
"again."
msgstr ""
"將 SMTP 連接置於 TLS（傳輸層安全性）模式。隨後的所有 SMTP 命令都將被加密。然"
"後你應該再次呼叫 :meth:`ehlo` 。"

#: ../../library/smtplib.rst:402
#, fuzzy
msgid ""
"If *keyfile* and *certfile* are provided, they are used to create an :class:"
"`ssl.SSLContext`."
msgstr ""
"如果提供 *keyfile* 和 *certfile*，它們將用於建立 :class:`ssl.SSLContext`。"

#: ../../library/smtplib.rst:405
#, fuzzy
msgid ""
"Optional *context* parameter is an :class:`ssl.SSLContext` object; This is "
"an alternative to using a keyfile and a certfile and if specified both "
"*keyfile* and *certfile* should be ``None``."
msgstr ""
"可選的 *context* 參數是一個 ssl.SSLContext 物件；這是使用密鑰文件和證書文件的"
"替代方法，如果指定 *keyfile* 和 *certfile* 應該是 ``None`` 。"

#: ../../library/smtplib.rst:409
#, fuzzy
msgid ""
"If there has been no previous ``EHLO`` or ``HELO`` command this session, "
"this method tries ESMTP ``EHLO`` first."
msgstr ""
"如果此會話之前沒有 ``EHLO``或 ``HELO``命令，則此方法首先嘗試 ESMTP ``EHLO``。"

#: ../../library/smtplib.rst:423
msgid "The server does not support the STARTTLS extension."
msgstr "伺服器不支援 STARTTLS 擴充。"

#: ../../library/smtplib.rst:426
msgid ":exc:`RuntimeError`"
msgstr ":exc:`RuntimeError`"

#: ../../library/smtplib.rst:426
msgid "SSL/TLS support is not available to your Python interpreter."
msgstr "SSL/TLS 支援不適用於你的 Python 直譯器。"

#: ../../library/smtplib.rst:431
#, fuzzy
msgid ""
"The method now supports hostname check with :attr:`SSLContext."
"check_hostname` and *Server Name Indicator* (see :data:`~ssl.HAS_SNI`)."
msgstr ""
"該方法現在支援使用 :attr:`SSLContext.check_hostname` 和 *Server Name "
"Indicator* 進行主機名檢查（參見 :data:`~ssl.HAS_SNI`）。"

#: ../../library/smtplib.rst:436
#, fuzzy
msgid ""
"The error raised for lack of STARTTLS support is now the :exc:"
"`SMTPNotSupportedError` subclass instead of the base :exc:`SMTPException`."
msgstr ""
"由於缺少 STARTTLS 支援而引發的錯誤現在是 :exc:`SMTPNotSupportedError` 子類別"
"而不是基礎 :exc:`SMTPException`。"

#: ../../library/smtplib.rst:444
#, fuzzy
msgid ""
"Send mail.  The required arguments are an :rfc:`822` from-address string, a "
"list of :rfc:`822` to-address strings (a bare string will be treated as a "
"list with 1 address), and a message string.  The caller may pass a list of "
"ESMTP options (such as ``8bitmime``) to be used in ``MAIL FROM`` commands as "
"*mail_options*. ESMTP options (such as ``DSN`` commands) that should be used "
"with all ``RCPT`` commands can be passed as *rcpt_options*.  (If you need to "
"use different ESMTP options to different recipients you have to use the low-"
"level methods such as :meth:`mail`, :meth:`rcpt` and :meth:`data` to send "
"the message.)"
msgstr ""
"發送郵件。所需的參數是一個 :rfc:`822` 發件人地址字串、一個 :rfc:`822` 收件人"
"地址字串列表（一個裸字串將被視為具有 1 個地址的列表）和一個消息字串。呼叫者可"
"以傳遞一個 ESMTP 選項列表（例如 ``8bitmime``）以在 ``MAIL FROM`` 命令中作為 "
"*mail_options* 使用。應與所有 ``RCPT`` 命令一起使用的 ESMTP 選項（例如 "
"``DSN`` 命令）可以作為 *rcpt_options* 傳遞。 （如果您需要對不同的收件人使用不"
"同的 ESMTP 選項，您必須使用低階方法，例如 :meth:`mail`、:meth:`rcpt` 和 :"
"meth:`data` 來發送消息。）"

#: ../../library/smtplib.rst:455
#, fuzzy
msgid ""
"The *from_addr* and *to_addrs* parameters are used to construct the message "
"envelope used by the transport agents.  ``sendmail`` does not modify the "
"message headers in any way."
msgstr ""
"*from_addr* 和 *to_addrs* 參數用於構造傳輸代理使用的消息信封。 ``sendmail`` "
"不會以任何方式修改郵件標題。"

#: ../../library/smtplib.rst:459
#, fuzzy
msgid ""
"*msg* may be a string containing characters in the ASCII range, or a byte "
"string.  A string is encoded to bytes using the ascii codec, and lone "
"``\\r`` and ``\\n`` characters are converted to ``\\r\\n`` characters.  A "
"byte string is not modified."
msgstr ""
"*msg* 可以是包含 ASCII 範圍內字元的字串，也可以是位元組串。使用 ascii 編解碼"
"器將字串編碼為位元組，單獨的 ``\\r`` 和 ``\\n`` 字元將轉換為 ``\\r\\n`` 字"
"元。不修改位元組串。"

#: ../../library/smtplib.rst:464
#, fuzzy
msgid ""
"If there has been no previous ``EHLO`` or ``HELO`` command this session, "
"this method tries ESMTP ``EHLO`` first. If the server does ESMTP, message "
"size and each of the specified options will be passed to it (if the option "
"is in the feature set the server advertises).  If ``EHLO`` fails, ``HELO`` "
"will be tried and ESMTP options suppressed."
msgstr ""
"如果此會話之前沒有 ``EHLO``或 ``HELO``命令，則此方法首先嘗試 ESMTP ``EHLO``。"
"如果伺服器執行 ESMTP，消息大小和每個指定的選項都將傳遞給它（如果該選項在服務"
"器通告的功能集中）。如果 EHLO 失敗，將嘗試 HELO 並抑制 ESMTP 選項。"

#: ../../library/smtplib.rst:470
#, fuzzy
msgid ""
"This method will return normally if the mail is accepted for at least one "
"recipient. Otherwise it will raise an exception.  That is, if this method "
"does not raise an exception, then someone should get your mail. If this "
"method does not raise an exception, it returns a dictionary, with one entry "
"for each recipient that was refused.  Each entry contains a tuple of the "
"SMTP error code and the accompanying error message sent by the server."
msgstr ""
"如果郵件被至少一個收件人接受，此方法將正常回傳。否則會引發例外。也就是說，如"
"果此方法沒有引發例外，那麼應該有人收到您的郵件。如果此方法沒有引發例外，它會"
"回傳一個字典，每個被拒絕的收件人都有一個條目。每個條目都包含 SMTP 錯誤程式碼"
"的元組和伺服器發送的伴隨錯誤消息。"

#: ../../library/smtplib.rst:477
#, fuzzy
msgid ""
"If ``SMTPUTF8`` is included in *mail_options*, and the server supports it, "
"*from_addr* and *to_addrs* may contain non-ASCII characters."
msgstr ""
"如果 *mail_options* 中包含 ``SMTPUTF8``，並且伺服器支援它，*from_addr* 和 "
"*to_addrs* 可能包含非 ASCII 字元。"

#: ../../library/smtplib.rst:480
msgid "This method may raise the following exceptions:"
msgstr "此方法可能引發以下例外："

#: ../../library/smtplib.rst:486
msgid ":exc:`SMTPRecipientsRefused`"
msgstr ":exc:`SMTPRecipientsRefused`"

#: ../../library/smtplib.rst:483
#, fuzzy
msgid ""
"All recipients were refused.  Nobody got the mail.  The :attr:`recipients` "
"attribute of the exception object is a dictionary with information about the "
"refused recipients (like the one returned when at least one recipient was "
"accepted)."
msgstr ""
"所有收件人都被拒絕了。沒有人收到郵件。例外物件的 :attr:`recipients` 屬性是一"
"個字典，其中包含有關被拒絕的收件人的資訊（比如當至少一個收件人被接受時回傳的"
"資訊）。"

#: ../../library/smtplib.rst:492
msgid ":exc:`SMTPSenderRefused`"
msgstr ":exc:`SMTPSenderRefused`"

#: ../../library/smtplib.rst:492
msgid "The server didn't accept the *from_addr*."
msgstr "伺服器不接受 *from_addr*。"

#: ../../library/smtplib.rst:496
msgid ":exc:`SMTPDataError`"
msgstr ":exc:`SMTPDataError`"

#: ../../library/smtplib.rst:495
#, fuzzy
msgid ""
"The server replied with an unexpected error code (other than a refusal of a "
"recipient)."
msgstr "伺服器回覆了一個意外的錯誤程式碼（而不是收件人的拒絕）。"

#: ../../library/smtplib.rst:499
#, fuzzy
msgid ""
"``SMTPUTF8`` was given in the *mail_options* but is not supported by the "
"server."
msgstr "``SMTPUTF8`` 在 *mail_options* 中給出，但伺服器不支援。"

#: ../../library/smtplib.rst:502
#, fuzzy
msgid ""
"Unless otherwise noted, the connection will be open even after an exception "
"is raised."
msgstr "除非另有說明，否則即使在引發例外後連接也會打開。"

#: ../../library/smtplib.rst:505
msgid "*msg* may be a byte string."
msgstr "*msg* 可以是一個位元組字串。"

#: ../../library/smtplib.rst:508
#, fuzzy
msgid ""
"``SMTPUTF8`` support added, and :exc:`SMTPNotSupportedError` may be raised "
"if ``SMTPUTF8`` is specified but the server does not support it."
msgstr ""
"新增了``SMTPUTF8`` 支援，如果指定了``SMTPUTF8`` 但伺服器不支援，可能會引發 :"
"exec:`SMTPNotSupportedError`。"

#: ../../library/smtplib.rst:516
#, fuzzy
msgid ""
"This is a convenience method for calling :meth:`sendmail` with the message "
"represented by an :class:`email.message.Message` object.  The arguments have "
"the same meaning as for :meth:`sendmail`, except that *msg* is a ``Message`` "
"object."
msgstr ""
"這是一種使用由 email.message.Message 物件表示的消息呼叫 :meth:`sendmail` 的便"
"捷方法。參數與 sendmail 的含義相同，除了 *msg* 是一個 `Message`` 物件。"

#: ../../library/smtplib.rst:521
#, fuzzy
msgid ""
"If *from_addr* is ``None`` or *to_addrs* is ``None``, ``send_message`` fills "
"those arguments with addresses extracted from the headers of *msg* as "
"specified in :rfc:`5322`\\: *from_addr* is set to the :mailheader:`Sender` "
"field if it is present, and otherwise to the :mailheader:`From` field. "
"*to_addrs* combines the values (if any) of the :mailheader:`To`, :mailheader:"
"`Cc`, and :mailheader:`Bcc` fields from *msg*.  If exactly one set of :"
"mailheader:`Resent-*` headers appear in the message, the regular headers are "
"ignored and the :mailheader:`Resent-*` headers are used instead. If the "
"message contains more than one set of :mailheader:`Resent-*` headers, a :exc:"
"`ValueError` is raised, since there is no way to unambiguously detect the "
"most recent set of :mailheader:`Resent-` headers."
msgstr ""
"如果 *from_addr* 是 ``None`` 或 *to_addrs* 是 ``None``，``send_message`` 將使"
"用從 *msg* 的標頭中提取的地址填充這些參數，如 :rfc:`5322`\\: *from_addr* 設定"
"為 :mailheader:`Sender` 欄位（如果存在），否則設定為 :mailheader:`From` 欄"
"位。 *to_addrs* 結合了來自 *msg* 的 :mailheader:`To`、:mailheader:`Cc` 和 :"
"mailheader:`Bcc` 欄位的值（如果有的話）。如果郵件中只出現一組 :mailheader:"
"`Resent-*` 標頭，則常規標頭將被忽略，而使用 :mailheader:`Resent-*` 標頭。如果"
"郵件包含多於一組 :mailheader:`Resent-*` 標頭，則會引發 :exc:`ValueError`，因"
"為無法明確檢測到最新的一組 :mailheader:`Resent-` 標頭."

#: ../../library/smtplib.rst:533
#, fuzzy
msgid ""
"``send_message`` serializes *msg* using :class:`~email.generator."
"BytesGenerator` with ``\\r\\n`` as the *linesep*, and calls :meth:`sendmail` "
"to transmit the resulting message.  Regardless of the values of *from_addr* "
"and *to_addrs*, ``send_message`` does not transmit any :mailheader:`Bcc` or :"
"mailheader:`Resent-Bcc` headers that may appear in *msg*.  If any of the "
"addresses in *from_addr* and *to_addrs* contain non-ASCII characters and the "
"server does not advertise ``SMTPUTF8`` support, an :exc:`SMTPNotSupported` "
"error is raised.  Otherwise the ``Message`` is serialized with a clone of "
"its :mod:`~email.policy` with the :attr:`~email.policy.EmailPolicy.utf8` "
"attribute set to ``True``, and ``SMTPUTF8`` and ``BODY=8BITMIME`` are added "
"to *mail_options*."
msgstr ""
"``send_message`` 使用 :class:`~email.generator.BytesGenerator` 以 `\\r\\n`` "
"作為 *linesep* 序列化 *msg*，並呼叫 :meth:`sendmail` 來傳輸生成的消息。無論 "
"*from_addr* 和 *to_addrs* 的值如何，``send_message`` 都不會傳輸任何可能出現"
"在 *msg* 中的 :mailheader:`Bcc` 或 :mailheader:`Resent-Bcc` 標頭。如果 "
"*from_addr* 和 *to_addrs* 中的任何地址包含非 ASCII 字元，並且伺服器不宣傳 "
"``SMTPUTF8`` 支援，則會引發 :exc:`SMTPNotSupported` 錯誤。否則，``Message`` "
"將使用其 :mod:`~email.policy` 的克隆序列化，並將 :attr:`~email.policy."
"EmailPolicy.utf8` 屬性設定為 ``True``，並且 `` SMTPUTF8`` 和 "
"``BODY=8BITMIME`` 新增到 *mail_options*。"

#: ../../library/smtplib.rst:547
#, fuzzy
msgid "Support for internationalized addresses (``SMTPUTF8``)."
msgstr "支援國際化地址（``SMTPUTF8``）。"

#: ../../library/smtplib.rst:553
#, fuzzy
msgid ""
"Terminate the SMTP session and close the connection.  Return the result of "
"the SMTP ``QUIT`` command."
msgstr "終止 SMTP 會話並關閉連接。回傳 SMTP ``QUIT`` 命令的結果。"

#: ../../library/smtplib.rst:557
#, fuzzy
msgid ""
"Low-level methods corresponding to the standard SMTP/ESMTP commands "
"``HELP``, ``RSET``, ``NOOP``, ``MAIL``, ``RCPT``, and ``DATA`` are also "
"supported. Normally these do not need to be called directly, so they are not "
"documented here.  For details, consult the module code."
msgstr ""
"對應於標準 SMTP/ESMTP 命令``HELP``、``RSET``、``NOOP``、``MAIL``、``RCPT`` 和"
"``DATA`` 的底層方法也是支援的。通常這些不需要直接呼叫，所以這裡不記錄。詳情請"
"查閱模組程式碼。"

#: ../../library/smtplib.rst:566
msgid "SMTP Example"
msgstr "SMTP 範例"

#: ../../library/smtplib.rst:568
#, fuzzy
msgid ""
"This example prompts the user for addresses needed in the message envelope "
"('To' and 'From' addresses), and the message to be delivered.  Note that the "
"headers to be included with the message must be included in the message as "
"entered; this example doesn't do any processing of the :rfc:`822` headers.  "
"In particular, the 'To' and 'From' addresses must be included in the message "
"headers explicitly. ::"
msgstr ""
"此示例提示使用者輸入郵件信封中所需的地址（“收件人”和“發件人”地址）以及要傳遞"
"的郵件。請注意，要包含在消息中的標題必須包含在輸入的消息中；此示例不對 :rfc:"
"`822` 標頭進行任何處理。特別是，“收件人”和“發件人”地址必須明確包含在郵件標頭"
"中。 ::"

#: ../../library/smtplib.rst:604
#, fuzzy
msgid ""
"In general, you will want to use the :mod:`email` package's features to "
"construct an email message, which you can then send via :meth:`~smtplib.SMTP."
"send_message`; see :ref:`email-examples`."
msgstr ""
"通常，您會希望使用 :mod:`email` 包的功能來構造一封電子郵件，然後您可以通過 :"
"meth:`~smtplib.SMTP.send_message` 發送；參見 :ref:`email-examples`。"
