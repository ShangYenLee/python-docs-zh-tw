# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-23 00:17+0000\n"
"PO-Revision-Date: 2018-05-23 16:11+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/struct.rst:2
#, fuzzy
msgid ":mod:`struct` --- Interpret bytes as packed binary data"
msgstr ":mod:`struct` --- 將位元組直釋為打包的二進位資料"

#: ../../library/struct.rst:7
msgid "**Source code:** :source:`Lib/struct.py`"
msgstr "**原始碼：**\\ :source:`Lib/struct.py`"

#: ../../library/struct.rst:15
#, fuzzy
msgid ""
"This module converts between Python values and C structs represented as "
"Python :class:`bytes` objects.  Compact :ref:`format strings <struct-format-"
"strings>` describe the intended conversions to/from Python values. The "
"module's functions and objects can be used for two largely distinct "
"applications, data exchange with external sources (files or network "
"connections), or data transfer between the Python application and the C "
"layer."
msgstr ""
"該模組在 Python 值和表示為 Python :class:`bytes` 物件的 C 結構之間進行轉換。 "
"Compact :ref:`format strings <struct-format-strings>` 描述了與 Python 值之間"
"的預期轉換。該模組的功能和物件可用於兩個截然不同的應用程式，與外部源（文件或"
"網絡連接）的資料交換，或 Python 應用程式和 C 層之間的資料傳輸。"

#: ../../library/struct.rst:25
#, fuzzy
msgid ""
"When no prefix character is given, native mode is the default. It packs or "
"unpacks data based on the platform and compiler on which the Python "
"interpreter was built. The result of packing a given C struct includes pad "
"bytes which maintain proper alignment for the C types involved; similarly, "
"alignment is taken into account when unpacking.  In contrast, when "
"communicating data between external sources, the programmer is responsible "
"for defining byte ordering and padding between elements. See :ref:`struct-"
"alignment` for details."
msgstr ""
"如果沒有給出前綴字元，則預設為本機模式。它根據構建 Python "
"直譯器的平台和編譯器打包或解包資料。打包給定 C 結構的結果包括填充位元組，"
"這些位元組為所涉及的 C 型別保持正確對齊；同樣，拆包時也會考慮對齊。相反，當在"
"外部源之間傳遞資料時，程式員負責定義元素之間的位元組順序和填充。有關詳細資訊"
"，請參見 :ref:`struct-alignment`。"

#: ../../library/struct.rst:35
#, fuzzy
msgid ""
"Several :mod:`struct` functions (and methods of :class:`Struct`) take a "
"*buffer* argument.  This refers to objects that implement the :ref:"
"`bufferobjects` and provide either a readable or read-writable buffer.  The "
"most common types used for that purpose are :class:`bytes` and :class:"
"`bytearray`, but many other types that can be viewed as an array of bytes "
"implement the buffer protocol, so that they can be read/filled without "
"additional copying from a :class:`bytes` object."
msgstr ""
"幾個 :mod:`struct` 函式（和 :class:`Struct` 的方法）接受一個 *buffer* 參數。"
"這是指實作 :ref:`bufferobjects` 並提供可讀或可讀寫緩衝區的物件。"
"用於此目的的最常見型別是 :class:`bytes` 和 :class:`bytearray`，但許多其他型別"
"可以被視為位元組數組實作緩衝區協定，因此無需讀取/填充它們從 :class:`bytes` "
"物件額外複製。"

#: ../../library/struct.rst:44
msgid "Functions and Exceptions"
msgstr "函式與例外"

#: ../../library/struct.rst:46
#, fuzzy
msgid "The module defines the following exception and functions:"
msgstr "該模組定義了以下例外和函式："

#: ../../library/struct.rst:51
#, fuzzy
msgid ""
"Exception raised on various occasions; argument is a string describing what "
"is wrong."
msgstr "在各種場合引發的例外； argument 是描述錯誤的字串。"

#: ../../library/struct.rst:57
#, fuzzy
msgid ""
"Return a bytes object containing the values *v1*, *v2*, ... packed according "
"to the format string *format*.  The arguments must match the values required "
"by the format exactly."
msgstr "回傳一個位元組物件，其中包含根據格式字串 *format* 打包的值 "
"*v1*、*v2*、...。參數必須與格式所需的值完全匹配。"

#: ../../library/struct.rst:64
#, fuzzy
msgid ""
"Pack the values *v1*, *v2*, ... according to the format string *format* and "
"write the packed bytes into the writable buffer *buffer* starting at "
"position *offset*.  Note that *offset* is a required argument."
msgstr ""
"根據格式字串 *format* 打包值 *v1*, *v2*, ... 並將打包的位元組寫入可寫緩衝區 "
"*buffer* 從位置 *offset* 開始。請注意，*offset* 是必需的參數。"

#: ../../library/struct.rst:71
#, fuzzy
msgid ""
"Unpack from the buffer *buffer* (presumably packed by ``pack(format, ...)``) "
"according to the format string *format*.  The result is a tuple even if it "
"contains exactly one item.  The buffer's size in bytes must match the size "
"required by the format, as reflected by :func:`calcsize`."
msgstr ""
"根據格式字串 *format* 從緩衝區 *buffer* 中解壓（大概由 ``pack(format, ...)`` "
"打包）。結果是一個元組，即使它只包含一個項目。緩衝區的大小（以位元組為單位）"
"必須與格式所需的大小相匹配，如 calcsize 所反映的那樣。"

#: ../../library/struct.rst:79
#, fuzzy
msgid ""
"Unpack from *buffer* starting at position *offset*, according to the format "
"string *format*.  The result is a tuple even if it contains exactly one "
"item.  The buffer's size in bytes, starting at position *offset*, must be at "
"least the size required by the format, as reflected by :func:`calcsize`."
msgstr ""
"根據格式字串 *format*，從 *buffer* 開始，從位置 *offset* "
"解壓。結果是一個元組，即使它只包含一個項目。緩衝區的大小（以位元組為單位，"
"從位置 *offset* 開始）必須至少是格式所需的大小，如 :func:`calcsize` "
"所反映的那樣。"

#: ../../library/struct.rst:87
#, fuzzy
msgid ""
"Iteratively unpack from the buffer *buffer* according to the format string "
"*format*.  This function returns an iterator which will read equally sized "
"chunks from the buffer until all its contents have been consumed.  The "
"buffer's size in bytes must be a multiple of the size required by the "
"format, as reflected by :func:`calcsize`."
msgstr ""
"根據格式字串 *format* 從緩衝區 *buffer* 中疊代解包。此函式回傳一個疊代器，該"
"疊代器將從緩衝區中讀取相同大小的塊，直到其所有內容都被消耗為止。緩衝區的大小"
"（以位元組為單位）必須是格式所需大小的倍數，如 :func:`calcsize` 所示。"

#: ../../library/struct.rst:93
#, fuzzy
msgid "Each iteration yields a tuple as specified by the format string."
msgstr "每次疊代都會產生一個由格式字串指定的元組。"

#: ../../library/struct.rst:100
#, fuzzy
msgid ""
"Return the size of the struct (and hence of the bytes object produced by "
"``pack(format, ...)``) corresponding to the format string *format*."
msgstr "回傳對應於格式字串 *format* 的結構的大小（以及由 ``pack(format, ...)`` "
"生成的位元組物件的大小）。"

#: ../../library/struct.rst:107
#, fuzzy
msgid "Format Strings"
msgstr "格式化字串"

#: ../../library/struct.rst:109
#, fuzzy
msgid ""
"Format strings describe the data layout when packing and unpacking data.  "
"They are built up from :ref:`format characters<format-characters>`, which "
"specify the type of data being packed/unpacked.  In addition, special "
"characters control the :ref:`byte order, size and alignment<struct-"
"alignment>`. Each format string consists of an optional prefix character "
"which describes the overall properties of the data and one or more format "
"characters which describe the actual data values and padding."
msgstr ""
"格式字串描述了打包和解包資料時的資料佈局。它們由 :ref:`format characters"
"<format-characters>` 構建而成，指定要打包/解包的資料型別。此外，特殊字元控制:"
"ref:`位元組順序、大小和對齊方式<struct-alignment>`。每個格式字串都包含一個可"
"選的前綴字元（描述資料的整體屬性）和一個或多個格式字元（描述實際資料值和填充"
"）。"

#: ../../library/struct.rst:121
#, fuzzy
msgid "Byte Order, Size, and Alignment"
msgstr "位元組順序、大小和對齊"

#: ../../library/struct.rst:123
#, fuzzy
msgid ""
"By default, C types are represented in the machine's native format and byte "
"order, and properly aligned by skipping pad bytes if necessary (according to "
"the rules used by the C compiler). This behavior is chosen so that the bytes "
"of a packed struct correspond exactly to the memory layout of the "
"corresponding C struct. Whether to use native byte ordering and padding or "
"standard formats depends on the application."
msgstr ""
"預設情況下，C 型別以機器的本機格式和位元組順序表示，並在必要時通過跳過填充位"
"元組來正確對齊（根據 C 編譯器使用的規則）。"
"選擇此行為是為了使打包結構的位元組與相應 C 結構的記憶體佈局完全對應。是使用本"
"機位元組排序和填充還是標準格式取決於應用程式。"

#: ../../library/struct.rst:139
#, fuzzy
msgid ""
"Alternatively, the first character of the format string can be used to "
"indicate the byte order, size and alignment of the packed data, according to "
"the following table:"
msgstr "或者，格式字串的第一個字元可用於指示打包資料的位元組順序、大小和對齊方式，如"
"下表所示："

#: ../../library/struct.rst:144
#, fuzzy
msgid "Character"
msgstr "特點"

#: ../../library/struct.rst:144
#, fuzzy
msgid "Byte order"
msgstr "位元組順序"

#: ../../library/struct.rst:144
#, fuzzy
msgid "Size"
msgstr "尺寸"

#: ../../library/struct.rst:144
#, fuzzy
msgid "Alignment"
msgstr "結盟"

#: ../../library/struct.rst:146
msgid "``@``"
msgstr "``@``"

#: ../../library/struct.rst:146 ../../library/struct.rst:148
#, fuzzy
msgid "native"
msgstr "本國的"

#: ../../library/struct.rst:148
msgid "``=``"
msgstr "``=``"

#: ../../library/struct.rst:148 ../../library/struct.rst:150
#: ../../library/struct.rst:152 ../../library/struct.rst:154
#, fuzzy
msgid "standard"
msgstr "標準"

#: ../../library/struct.rst:148 ../../library/struct.rst:150
#: ../../library/struct.rst:152 ../../library/struct.rst:154
#, fuzzy
msgid "none"
msgstr "沒有任何"

#: ../../library/struct.rst:150
msgid "``<``"
msgstr "``<``"

#: ../../library/struct.rst:150
#, fuzzy
msgid "little-endian"
msgstr "小端"

#: ../../library/struct.rst:152
msgid "``>``"
msgstr "``>``"

#: ../../library/struct.rst:152
#, fuzzy
msgid "big-endian"
msgstr "大端"

#: ../../library/struct.rst:154
msgid "``!``"
msgstr "``!``"

#: ../../library/struct.rst:154
#, fuzzy
msgid "network (= big-endian)"
msgstr "網絡（=大端）"

#: ../../library/struct.rst:157
#, fuzzy
msgid "If the first character is not one of these, ``'@'`` is assumed."
msgstr "如果第一個字元不是其中之一，則假定為 ``@``。"

#: ../../library/struct.rst:159
#, fuzzy
msgid ""
"Native byte order is big-endian or little-endian, depending on the host "
"system. For example, Intel x86, AMD64 (x86-64), and Apple M1 are little-"
"endian; IBM z and many legacy architectures are big-endian. Use :data:`sys."
"byteorder` to check the endianness of your system."
msgstr ""
"本機位元組順序是 big-endian 或 little-endian，具體取決於主機系統。例如，"
"Intel x86、AMD64 (x86-64) 和 Apple M1 都是小端； IBM z "
"和許多遺留架構都是大端架構。使用 :data:`sys.byteorder` 檢查系統的位元組順序。"

#: ../../library/struct.rst:164
#, fuzzy
msgid ""
"Native size and alignment are determined using the C compiler's ``sizeof`` "
"expression.  This is always combined with native byte order."
msgstr "本機大小和對齊方式是使用 C "
"編譯器的 ``sizeof``表達式確定的。這始終與本機位元組順序相結合。"

#: ../../library/struct.rst:167
#, fuzzy
msgid ""
"Standard size depends only on the format character;  see the table in the :"
"ref:`format-characters` section."
msgstr "標準尺寸僅取決於格式字元；請參閱 :ref:`format-characters` 部分中的表格。"

#: ../../library/struct.rst:170
#, fuzzy
msgid ""
"Note the difference between ``'@'`` and ``'='``: both use native byte order, "
"but the size and alignment of the latter is standardized."
msgstr "注意``'@'`` 和``'='`` "
"之間的區別：兩者都使用本機位元組順序，但後者的大小和對齊方式是標準化的。"

#: ../../library/struct.rst:173
#, fuzzy
msgid ""
"The form ``'!'`` represents the network byte order which is always big-"
"endian as defined in `IETF RFC 1700 <IETF RFC 1700_>`_."
msgstr ""
"``'!'`` 表示網絡位元組順序，它始終是 IETF RFC 1700 <IETF RFC 1700_>`_ "
"中定義的 big-endian。"

#: ../../library/struct.rst:176
#, fuzzy
msgid ""
"There is no way to indicate non-native byte order (force byte-swapping); use "
"the appropriate choice of ``'<'`` or ``'>'``."
msgstr "無法指示非本機位元組順序（強製位元組交換）；使用適當的選擇 ``'<'`` 或 "
"``'>'``。"

#: ../../library/struct.rst:179 ../../library/struct.rst:258
msgid "Notes:"
msgstr "註解："

#: ../../library/struct.rst:181
#, fuzzy
msgid ""
"Padding is only automatically added between successive structure members. No "
"padding is added at the beginning or the end of the encoded struct."
msgstr "填充僅在連續的結構成員之間自動新增。在編碼結構的開頭或結尾不新增任何填充。"

#: ../../library/struct.rst:184
#, fuzzy
msgid ""
"No padding is added when using non-native size and alignment, e.g. with '<', "
"'>', '=', and '!'."
msgstr "使用非原生大小和對齊方式時不新增填充，例如使用 ``<``、 ``>``、 ``=``和 ``!``。"

#: ../../library/struct.rst:187
#, fuzzy
msgid ""
"To align the end of a structure to the alignment requirement of a particular "
"type, end the format with the code for that type with a repeat count of "
"zero.  See :ref:`struct-examples`."
msgstr "要使結構的結尾與特定型別的對齊要求對齊，請以重複計數為零的該型別的程式碼結束"
"格式。請參閱 :ref:`struct-examples`。"

#: ../../library/struct.rst:195
#, fuzzy
msgid "Format Characters"
msgstr "格式化字元"

#: ../../library/struct.rst:197
#, fuzzy
msgid ""
"Format characters have the following meaning; the conversion between C and "
"Python values should be obvious given their types.  The 'Standard size' "
"column refers to the size of the packed value in bytes when using standard "
"size; that is, when the format string starts with one of ``'<'``, ``'>'``, "
"``'!'`` or ``'='``.  When using native size, the size of the packed value is "
"platform-dependent."
msgstr ""
"格式字元具有以下含義；鑑於它們的型別，C 和 Python "
"值之間的轉換應該是顯而易見的。 'Standard size' "
"列是指使用標準大小時，以位元組為單位的打包值的大小；也就是說，當格式字串以 "
"``'<'``、``'>'``、``'!'`` 或 ``'='`` "
"之一開始時。使用本機大小時，打包值的大小取決於平台。"

#: ../../library/struct.rst:205
#, fuzzy
msgid "Format"
msgstr "格式"

#: ../../library/struct.rst:205
msgid "C Type"
msgstr "C Type"

#: ../../library/struct.rst:205
#, fuzzy
msgid "Python type"
msgstr "蟒蛇型別"

#: ../../library/struct.rst:205
#, fuzzy
msgid "Standard size"
msgstr "標準尺寸"

#: ../../library/struct.rst:205
msgid "Notes"
msgstr "註解"

#: ../../library/struct.rst:207
msgid "``x``"
msgstr "``x``"

#: ../../library/struct.rst:207
#, fuzzy
msgid "pad byte"
msgstr "填充位元組"

#: ../../library/struct.rst:207
#, fuzzy
msgid "no value"
msgstr "沒有價值"

#: ../../library/struct.rst:207
#, fuzzy
msgid "\\(7)"
msgstr "\\(7)"

#: ../../library/struct.rst:209
msgid "``c``"
msgstr "``c``"

#: ../../library/struct.rst:209
msgid ":c:expr:`char`"
msgstr ":c:expr:`char`"

#: ../../library/struct.rst:209
#, fuzzy
msgid "bytes of length 1"
msgstr "長度為 1 的位元組"

#: ../../library/struct.rst:209 ../../library/struct.rst:211
#: ../../library/struct.rst:213 ../../library/struct.rst:215
msgid "1"
msgstr "1"

#: ../../library/struct.rst:211
msgid "``b``"
msgstr "``b``"

#: ../../library/struct.rst:211
msgid ":c:expr:`signed char`"
msgstr ":c:expr:`signed char`"

#: ../../library/struct.rst:211 ../../library/struct.rst:213
#: ../../library/struct.rst:217 ../../library/struct.rst:219
#: ../../library/struct.rst:221 ../../library/struct.rst:223
#: ../../library/struct.rst:225 ../../library/struct.rst:227
#: ../../library/struct.rst:229 ../../library/struct.rst:231
#: ../../library/struct.rst:234 ../../library/struct.rst:236
#: ../../library/struct.rst:248
#, fuzzy
msgid "integer"
msgstr "整數"

#: ../../library/struct.rst:211
msgid "\\(1), \\(2)"
msgstr "\\(1), \\(2)"

#: ../../library/struct.rst:213
msgid "``B``"
msgstr "``B``"

#: ../../library/struct.rst:213
msgid ":c:expr:`unsigned char`"
msgstr ":c:expr:`unsigned char`"

#: ../../library/struct.rst:213 ../../library/struct.rst:217
#: ../../library/struct.rst:219 ../../library/struct.rst:221
#: ../../library/struct.rst:223 ../../library/struct.rst:225
#: ../../library/struct.rst:227 ../../library/struct.rst:229
#: ../../library/struct.rst:231
msgid "\\(2)"
msgstr "\\(2)"

#: ../../library/struct.rst:215
msgid "``?``"
msgstr "``?``"

#: ../../library/struct.rst:215
msgid ":c:expr:`_Bool`"
msgstr ":c:expr:`_Bool`"

#: ../../library/struct.rst:215
msgid "bool"
msgstr "bool"

#: ../../library/struct.rst:215
msgid "\\(1)"
msgstr "\\(1)"

#: ../../library/struct.rst:217
msgid "``h``"
msgstr "``h``"

#: ../../library/struct.rst:217
msgid ":c:expr:`short`"
msgstr ":c:expr:`short`"

#: ../../library/struct.rst:217 ../../library/struct.rst:219
#: ../../library/struct.rst:238
msgid "2"
msgstr "2"

#: ../../library/struct.rst:219
msgid "``H``"
msgstr "``H``"

#: ../../library/struct.rst:219
msgid ":c:expr:`unsigned short`"
msgstr ":c:expr:`unsigned short`"

#: ../../library/struct.rst:221
msgid "``i``"
msgstr "``i``"

#: ../../library/struct.rst:221
msgid ":c:expr:`int`"
msgstr ":c:expr:`int`"

#: ../../library/struct.rst:221 ../../library/struct.rst:223
#: ../../library/struct.rst:225 ../../library/struct.rst:227
#: ../../library/struct.rst:240
msgid "4"
msgstr "4"

#: ../../library/struct.rst:223
msgid "``I``"
msgstr "``I``"

#: ../../library/struct.rst:223
msgid ":c:expr:`unsigned int`"
msgstr ":c:expr:`unsigned int`"

#: ../../library/struct.rst:225
msgid "``l``"
msgstr "``l``"

#: ../../library/struct.rst:225
msgid ":c:expr:`long`"
msgstr ":c:expr:`long`"

#: ../../library/struct.rst:227
msgid "``L``"
msgstr "``L``"

#: ../../library/struct.rst:227
msgid ":c:expr:`unsigned long`"
msgstr ":c:expr:`unsigned long`"

#: ../../library/struct.rst:229
msgid "``q``"
msgstr "``q``"

#: ../../library/struct.rst:229
msgid ":c:expr:`long long`"
msgstr ":c:expr:`long long`"

#: ../../library/struct.rst:229 ../../library/struct.rst:231
#: ../../library/struct.rst:242
msgid "8"
msgstr "8"

#: ../../library/struct.rst:231
msgid "``Q``"
msgstr "``Q``"

#: ../../library/struct.rst:231
msgid ":c:expr:`unsigned long long`"
msgstr ":c:expr:`unsigned long long`"

#: ../../library/struct.rst:234
msgid "``n``"
msgstr "``n``"

#: ../../library/struct.rst:234
msgid ":c:expr:`ssize_t`"
msgstr ":c:expr:`ssize_t`"

#: ../../library/struct.rst:234 ../../library/struct.rst:236
msgid "\\(3)"
msgstr "\\(3)"

#: ../../library/struct.rst:236
msgid "``N``"
msgstr "``N``"

#: ../../library/struct.rst:236
msgid ":c:expr:`size_t`"
msgstr ":c:expr:`size_t`"

#: ../../library/struct.rst:238
msgid "``e``"
msgstr "``e``"

#: ../../library/struct.rst:238
msgid "\\(6)"
msgstr "\\(6)"

#: ../../library/struct.rst:238 ../../library/struct.rst:240
#: ../../library/struct.rst:242
msgid "float"
msgstr "float"

#: ../../library/struct.rst:238 ../../library/struct.rst:240
#: ../../library/struct.rst:242
msgid "\\(4)"
msgstr "\\(4)"

#: ../../library/struct.rst:240
msgid "``f``"
msgstr "``f``"

#: ../../library/struct.rst:240
msgid ":c:expr:`float`"
msgstr ":c:expr:`float`"

#: ../../library/struct.rst:242
msgid "``d``"
msgstr "``d``"

#: ../../library/struct.rst:242
msgid ":c:expr:`double`"
msgstr ":c:expr:`double`"

#: ../../library/struct.rst:244
msgid "``s``"
msgstr "``s``"

#: ../../library/struct.rst:244 ../../library/struct.rst:246
msgid ":c:expr:`char[]`"
msgstr ":c:expr:`char[]`"

#: ../../library/struct.rst:244 ../../library/struct.rst:246
#, fuzzy
msgid "bytes"
msgstr "位元組"

#: ../../library/struct.rst:244
#, fuzzy
msgid "\\(9)"
msgstr "\\(9)"

#: ../../library/struct.rst:246
msgid "``p``"
msgstr "``p``"

#: ../../library/struct.rst:246
#, fuzzy
msgid "\\(8)"
msgstr "\\(8)"

#: ../../library/struct.rst:248
msgid "``P``"
msgstr "``P``"

#: ../../library/struct.rst:248
msgid ":c:expr:`void \\*`"
msgstr ":c:expr:`void \\*`"

#: ../../library/struct.rst:248
msgid "\\(5)"
msgstr "\\(5)"

#: ../../library/struct.rst:251
msgid "Added support for the ``'n'`` and ``'N'`` formats."
msgstr "新增 ``'n'`` 與 ``'N'`` 格式的支援。"

#: ../../library/struct.rst:254
msgid "Added support for the ``'e'`` format."
msgstr "新增 ``'e'`` 格式的支援。"

#: ../../library/struct.rst:263
#, fuzzy
msgid ""
"The ``'?'`` conversion code corresponds to the :c:expr:`_Bool` type defined "
"by C99. If this type is not available, it is simulated using a :c:expr:"
"`char`. In standard mode, it is always represented by one byte."
msgstr ""
"``'?'`` 轉換程式碼對應於 C99 定義的 :c:expr:`_Bool` 型別。如果此型別不可用，"
"則使用 :c:expr:`char` 對其進行模擬。在標準模式下，它始終由一個位元組表示。"

#: ../../library/struct.rst:268
#, fuzzy
msgid ""
"When attempting to pack a non-integer using any of the integer conversion "
"codes, if the non-integer has a :meth:`__index__` method then that method is "
"called to convert the argument to an integer before packing."
msgstr "當嘗試使用任何整數轉換程式碼打包非整數時，如果非整數具有 :meth:`__index__` "
"方法，則呼叫該方法以在打包之前將參數轉換為整數。"

#: ../../library/struct.rst:272
#, fuzzy
msgid "Added use of the :meth:`__index__` method for non-integers."
msgstr "為非整數新增了 :meth:`__index__` 方法。"

#: ../../library/struct.rst:276
#, fuzzy
msgid ""
"The ``'n'`` and ``'N'`` conversion codes are only available for the native "
"size (selected as the default or with the ``'@'`` byte order character). For "
"the standard size, you can use whichever of the other integer formats fits "
"your application."
msgstr ""
"``'n'`` 和 ``'N'`` 轉換程式碼僅適用於本機大小（選擇為預設值或使用 ``'@'`` 位"
"元組順序字元）。對於標準大小，您可以使用適合您的應用程式的任何其他整數格式。"

#: ../../library/struct.rst:282
#, fuzzy
msgid ""
"For the ``'f'``, ``'d'`` and ``'e'`` conversion codes, the packed "
"representation uses the IEEE 754 binary32, binary64 or binary16 format (for "
"``'f'``, ``'d'`` or ``'e'`` respectively), regardless of the floating-point "
"format used by the platform."
msgstr ""
"對於 ``f``、 ``d``和 ``e``轉換程式碼，打包表示使用 IEEE 754 binary32、binary64 或 "
"binary16 格式（對於 ``f`` , ``'d'`` 或 ``'e'``），無論平台使用何種浮點格式。"

#: ../../library/struct.rst:288
#, fuzzy
msgid ""
"The ``'P'`` format character is only available for the native byte ordering "
"(selected as the default or with the ``'@'`` byte order character). The byte "
"order character ``'='`` chooses to use little- or big-endian ordering based "
"on the host system. The struct module does not interpret this as native "
"ordering, so the ``'P'`` format is not available."
msgstr ""
"``'P'`` 格式字元僅適用於本機位元組順序（選擇為預設值或使用 ``'@'`` "
"位元組順序字元）。位元組順序字元 ``'='`` 根據主機系統選擇使用小端或大端排序。"
" struct 模組不會將其解釋為本機排序，因此 ``P``格式不可用。"

#: ../../library/struct.rst:295
#, fuzzy
msgid ""
"The IEEE 754 binary16 \"half precision\" type was introduced in the 2008 "
"revision of the `IEEE 754 standard <ieee 754 standard_>`_. It has a sign "
"bit, a 5-bit exponent and 11-bit precision (with 10 bits explicitly stored), "
"and can represent numbers between approximately ``6.1e-05`` and ``6.5e+04`` "
"at full precision. This type is not widely supported by C compilers: on a "
"typical machine, an unsigned short can be used for storage, but not for math "
"operations. See the Wikipedia page on the `half-precision floating-point "
"format <half precision format_>`_ for more information."
msgstr ""
"IEEE 754 binary16“半精度”型別在 `IEEE 754 標準 <ieee 754 標準_>`_ 的 2008 "
"年修訂版中引入。它有一個符號位、一個 5 位指數和 11 位精度（顯式儲存 10 位），"
"並且可以以全精度表示大約 ``6.1e-05`` 和 ``6.5e+04`` 之間的數字. C "
"編譯器不廣泛支援此型別：在典型的機器上，unsigned short "
"可用於儲存，但不能用於數學運算。有關詳細資訊，請參閱有關`半精度浮點格式 "
"<半精度格式_>`_ 的維基百科頁面。"

#: ../../library/struct.rst:305
#, fuzzy
msgid "When packing, ``'x'`` inserts one NUL byte."
msgstr "打包時，``'x'`` 插入一個 NUL 位元組。"

#: ../../library/struct.rst:308
#, fuzzy
msgid ""
"The ``'p'`` format character encodes a \"Pascal string\", meaning a short "
"variable-length string stored in a *fixed number of bytes*, given by the "
"count. The first byte stored is the length of the string, or 255, whichever "
"is smaller.  The bytes of the string follow.  If the string passed in to :"
"func:`pack` is too long (longer than the count minus 1), only the leading "
"``count-1`` bytes of the string are stored.  If the string is shorter than "
"``count-1``, it is padded with null bytes so that exactly count bytes in all "
"are used.  Note that for :func:`unpack`, the ``'p'`` format character "
"consumes ``count`` bytes, but that the string returned can never contain "
"more than 255 bytes."
msgstr ""
"``'p'`` 格式字元對“Pascal 字串”進行編碼，這意味著儲存在*固定位元組數*中的短可"
"變長度字串，由計數給出。儲存的第一個位元組是字串的長度，或 "
"255，以較小者為準。字串的位元組如下。如果傳遞給 :func:`pack` 的字串太長（"
"長於計數減 1），則僅儲存字串的前導 ``count-1`` 位元組。如果字串短於 "
"``count-1``，它將用空位元組填充，以便使用 count 個位元組。請注意，對於 "
":func:`unpack`，``'p'`` 格式字元佔用 ``count`` 個位元組，"
"但回傳的字串永遠不會包含超過 255 個位元組。"

#: ../../library/struct.rst:320
#, fuzzy
msgid ""
"For the ``'s'`` format character, the count is interpreted as the length of "
"the bytes, not a repeat count like for the other format characters; for "
"example, ``'10s'`` means a single 10-byte string mapping to or from a single "
"Python byte string, while ``'10c'`` means 10 separate one byte character "
"elements (e.g., ``cccccccccc``) mapping to or from ten different Python byte "
"objects. (See :ref:`struct-examples` for a concrete demonstration of the "
"difference.) If a count is not given, it defaults to 1.  For packing, the "
"string is truncated or padded with null bytes as appropriate to make it fit. "
"For unpacking, the resulting bytes object always has exactly the specified "
"number of bytes.  As a special case, ``'0s'`` means a single, empty string "
"(while ``'0c'`` means 0 characters)."
msgstr ""
"對於 ``'s'`` 格式字元，計數被解釋為位元組的長度，而不是像其他格式字元那樣的重"
"複計數；例如，``'10s'`` 表示映射到單個 Python 位元組字串或從單個 Python "
"位元組字串映射的單個 10 位元組字串，而``'10c'`` 表示 10 "
"個單獨的單位元組字元元素（例如，``cccccccccc`` ) 映射到十個不同的 Python "
"位元組對像或從十個不同的 Python 位元組物件映射。 （有關差異的具體演示，"
"請參閱 :ref:`struct-examples`。）如果未給出計數，則預設為 1。為了打包，字串被"
"截斷或用空位元組適當填充以使其適合。對於解包，生成的位元組物件始終具有指定的"
"位元組數。作為一種特殊情況， ``0s``表示單個空字串（而 ``0c``表示 0 個字元）。"

#: ../../library/struct.rst:333
#, fuzzy
msgid ""
"A format character may be preceded by an integral repeat count.  For "
"example, the format string ``'4h'`` means exactly the same as ``'hhhh'``."
msgstr "格式字元前面可以有完整的重複計數。例如，格式字串 ``'4h'`` 與 ``'hhhh'`` "
"的含義完全相同。"

#: ../../library/struct.rst:336
#, fuzzy
msgid ""
"Whitespace characters between formats are ignored; a count and its format "
"must not contain whitespace though."
msgstr "忽略格式之間的空白字元；但是，計數及其格式不得包含空格。"

#: ../../library/struct.rst:339
#, fuzzy
msgid ""
"When packing a value ``x`` using one of the integer formats (``'b'``, "
"``'B'``, ``'h'``, ``'H'``, ``'i'``, ``'I'``, ``'l'``, ``'L'``, ``'q'``, "
"``'Q'``), if ``x`` is outside the valid range for that format then :exc:"
"`struct.error` is raised."
msgstr ""
"當使用其中一種整數格式（``'b'``、``'B'``、``'h'``、``'H'``、`` 'i'``, ``'I'``"
", ``'l'``, ``'L'``, ``'q'``, ``'Q'``), 如果`` x`` 超出該格式的有效範圍，"
"然後引發 :exc:`struct.error`。"

#: ../../library/struct.rst:344
#, fuzzy
msgid ""
"Previously, some of the integer formats wrapped out-of-range values and "
"raised :exc:`DeprecationWarning` instead of :exc:`struct.error`."
msgstr "以前，一些整數格式包含超出範圍的值並引發 :exec:`DeprecationWarning` 而不是 "
":exc:`struct.error`。"

#: ../../library/struct.rst:350
#, fuzzy
msgid ""
"For the ``'?'`` format character, the return value is either :const:`True` "
"or :const:`False`. When packing, the truth value of the argument object is "
"used. Either 0 or 1 in the native or standard bool representation will be "
"packed, and any non-zero value will be ``True`` when unpacking."
msgstr ""
"對於 ``'?'`` 格式字元，回傳值是 :const:`True` 或 "
":const:`False`。打包時，使用參數物件的真值。本機或標準 bool 表示形式中的 0 "
"或 1 將被打包，並且任何非零值在解包時都將為 ``True``。"

#: ../../library/struct.rst:360
msgid "Examples"
msgstr "範例"

#: ../../library/struct.rst:363
#, fuzzy
msgid ""
"Native byte order examples (designated by the ``'@'`` format prefix or lack "
"of any prefix character) may not match what the reader's machine produces as "
"that depends on the platform and compiler."
msgstr "本機位元組順序示例（由 ``@``格式前綴指定或缺少任何前綴字元）可能與讀者機器生成的"
"內容不匹配，因為這取決於平台和編譯器。"

#: ../../library/struct.rst:368
#, fuzzy
msgid ""
"Pack and unpack integers of three different sizes, using big endian "
"ordering::"
msgstr "使用大端順序打包和解包三種不同大小的整數::"

#: ../../library/struct.rst:379
#, fuzzy
msgid "Attempt to pack an integer which is too large for the defined field::"
msgstr "嘗試打包一個對於定義的欄位來說太大的整數::"

#: ../../library/struct.rst:386
#, fuzzy
msgid ""
"Demonstrate the difference between ``'s'`` and ``'c'`` format characters::"
msgstr "演示 ``'s'`` 和 ``'c'`` 格式字元之間的區別："

#: ../../library/struct.rst:394
#, fuzzy
msgid ""
"Unpacked fields can be named by assigning them to variables or by wrapping "
"the result in a named tuple::"
msgstr "解壓欄位可以通過將它們分配給變數或通過將結果包裝在命名元組中來命名："

#: ../../library/struct.rst:405
#, fuzzy
msgid ""
"The ordering of format characters may have an impact on size in native mode "
"since padding is implicit. In standard mode, the user is responsible for "
"inserting any desired padding. Note in the first ``pack`` call below that "
"three NUL bytes were added after the packed ``'#'`` to align the following "
"integer on a four-byte boundary. In this example, the output was produced on "
"a little endian machine::"
msgstr ""
"由於填充是隱式的，因此格式字元的順序可能會影響本機模式下的大小。在標準模式下"
"，使用者負責插入任何所需的填充。請注意，在下面的第一個 ``pack`` 呼叫中，"
"在打包的 ``'#'`` 之後新增了三個 NUL 位元組，以在四位元組邊界上對齊以下整數。"
"在此示例中，輸出是在小端機器上生成的："

#: ../../library/struct.rst:422
#, fuzzy
msgid ""
"The following format ``'llh0l'`` results in two pad bytes being added at the "
"end, assuming the platform's longs are aligned on 4-byte boundaries::"
msgstr "以下格式 ``'llh0l'`` 導致在末尾新增兩個填充位元組，假設平台的 longs 在 4 "
"位元組邊界上對齊："

#: ../../library/struct.rst:432
msgid "Module :mod:`array`"
msgstr ":mod:`array` 模組"

#: ../../library/struct.rst:432
#, fuzzy
msgid "Packed binary storage of homogeneous data."
msgstr "同類資料的打包二進位儲存。"

#: ../../library/struct.rst:435
msgid "Module :mod:`json`"
msgstr ":mod:`json` 模組"

#: ../../library/struct.rst:435
#, fuzzy
msgid "JSON encoder and decoder."
msgstr "JSON編碼器和解碼器。"

#: ../../library/struct.rst:437
msgid "Module :mod:`pickle`"
msgstr ":mod:`pickle` 模組"

#: ../../library/struct.rst:438
#, fuzzy
msgid "Python object serialization."
msgstr "Python 物件序列化。"

#: ../../library/struct.rst:444
#, fuzzy
msgid "Applications"
msgstr "應用"

#: ../../library/struct.rst:446
#, fuzzy
msgid ""
"Two main applications for the :mod:`struct` module exist, data interchange "
"between Python and C code within an application or another application "
"compiled using the same compiler (:ref:`native formats<struct-native-"
"formats>`), and data interchange between applications using agreed upon data "
"layout (:ref:`standard formats<struct-standard-formats>`).  Generally "
"speaking, the format strings constructed for these two domains are distinct."
msgstr ""
":mod:`struct` 模組存在兩個主要應用程式，"
"一個應用程式或使用相同編譯器編譯的另一個應用程式 (:ref:`native formats"
"<struct-native-formats>`) 中 Python 和 C "
"程式碼之間的資料交換，以及使用商定的資料佈局（:ref:`標準格式<struct-standard-"
"formats>`）在應用程式之間進行資料交換。一般來說，為這兩個域構造的格式字串是不"
"同的。"

#: ../../library/struct.rst:457
#, fuzzy
msgid "Native Formats"
msgstr "本機格式"

#: ../../library/struct.rst:459
#, fuzzy
msgid ""
"When constructing format strings which mimic native layouts, the compiler "
"and machine architecture determine byte ordering and padding. In such cases, "
"the ``@`` format character should be used to specify native byte ordering "
"and data sizes.  Internal pad bytes are normally inserted automatically.  It "
"is possible that a zero-repeat format code will be needed at the end of a "
"format string to round up to the correct byte boundary for proper alignment "
"of consective chunks of data."
msgstr ""
"在構造模仿本機佈局的格式字串時，編譯器和機器體系結構確定位元組順序和填充。在"
"這種情況下，應該使用 ``@``格式字元來指定本機位元組順序和資料大小。內部填充位元組"
"通常會自動插入。格式字串的末尾可能需要零重複格式程式碼以向上舍入到正確的位元"
"組邊界，以便正確對齊連續的資料塊。"

#: ../../library/struct.rst:467
#, fuzzy
msgid ""
"Consider these two simple examples (on a 64-bit, little-endian machine)::"
msgstr "考慮這兩個簡單的例子（在 64 位、小端機器上）："

#: ../../library/struct.rst:475
#, fuzzy
msgid ""
"Data is not padded to an 8-byte boundary at the end of the second format "
"string without the use of extra padding.  A zero-repeat format code solves "
"that problem::"
msgstr "在不使用額外填充的情況下，不會將資料填充到第二個格式字串末尾的 8 "
"位元組邊界。零重複格式程式碼解決了這個問題::"

#: ../../library/struct.rst:482
#, fuzzy
msgid ""
"The ``'x'`` format code can be used to specify the repeat, but for native "
"formats it is better to use a zero-repeat format like ``'0l'``."
msgstr "``'x'`` 格式程式碼可用於指定重複，但對於本機格式，最好使用零重複格式，如 "
"``'0l'``。"

#: ../../library/struct.rst:485
#, fuzzy
msgid ""
"By default, native byte ordering and alignment is used, but it is better to "
"be explicit and use the ``'@'`` prefix character."
msgstr "預設情況下，使用本機位元組排序和對齊方式，但最好是顯式使用 ``@``前綴字元。"

#: ../../library/struct.rst:492
#, fuzzy
msgid "Standard Formats"
msgstr "標準格式"

#: ../../library/struct.rst:494
#, fuzzy
msgid ""
"When exchanging data beyond your process such as networking or storage, be "
"precise.  Specify the exact byte order, size, and alignment.  Do not assume "
"they match the native order of a particular machine. For example, network "
"byte order is big-endian, while many popular CPUs are little-endian.  By "
"defining this explicitly, the user need not care about the specifics of the "
"platform their code is running on. The first character should typically be "
"``<`` or ``>`` (or ``!``).  Padding is the responsibility of the "
"programmer.  The zero-repeat format character won't work.  Instead, the user "
"must explicitly add ``'x'`` pad bytes where needed.  Revisiting the examples "
"from the previous section, we have::"
msgstr ""
"在交換網絡或儲存等過程之外的資料時，要精確。指定確切的位元組順序、大小和對齊"
"方式。不要假設它們匹配特定機器的本機順序。例如，網絡位元組順序是大端，"
"而許多流行的 CPU "
"是小端。通過明確定義，使用者無需關心其程式碼運行平台的具體細節。"
"第一個字元通常應該是 ``<`` 或 ``>``（或 "
"``!``）。填充是程式員的責任。零重複格式字元將不起作用。相反，"
"使用者必須在需要的地方顯式新增 ``'x'`` "
"填充位元組。回顧上一節中的示例，我們有："

#: ../../library/struct.rst:521
#, fuzzy
msgid ""
"The above results (executed on a 64-bit machine) aren't guaranteed to match "
"when executed on different machines.  For example, the examples below were "
"executed on a 32-bit machine::"
msgstr "以上結果（在 64 位機器上執行）在不同機器上執行時不能保證匹配。例如，"
"下面的例子是在 32 位機器上執行的："

#: ../../library/struct.rst:536
#, fuzzy
msgid "Classes"
msgstr "班級"

#: ../../library/struct.rst:538
#, fuzzy
msgid "The :mod:`struct` module also defines the following type:"
msgstr ":mod:`struct` 模組還定義了以下型別："

#: ../../library/struct.rst:543
#, fuzzy
msgid ""
"Return a new Struct object which writes and reads binary data according to "
"the format string *format*.  Creating a ``Struct`` object once and calling "
"its methods is more efficient than calling module-level functions with the "
"same format since the format string is only compiled once."
msgstr ""
"回傳一個新的 Struct 物件，它根據格式字串 *format* 寫入和讀取二進位資料。建立"
"一次 ``Struct``物件並呼叫其方法比呼叫具有相同格式的模組級函式更有效，因為格式字"
"串僅編譯一次。"

#: ../../library/struct.rst:550
#, fuzzy
msgid ""
"The compiled versions of the most recent format strings passed to :class:"
"`Struct` and the module-level functions are cached, so programs that use "
"only a few format strings needn't worry about reusing a single :class:"
"`Struct` instance."
msgstr "傳遞給 Struct 的最新格式字串的編譯版本和模組級函式被快取，"
"因此僅使用少數格式字串的程式不必擔心重用單個 Struct 實例."

#: ../../library/struct.rst:555
#, fuzzy
msgid "Compiled Struct objects support the following methods and attributes:"
msgstr "已編譯的 Struct 物件支援以下方法和屬性："

#: ../../library/struct.rst:559
#, fuzzy
msgid ""
"Identical to the :func:`pack` function, using the compiled format. "
"(``len(result)`` will equal :attr:`size`.)"
msgstr "與 :func:`pack` 函式相同，使用編譯後的格式。 （``len（結果）`` 將等於 "
":attr:`size`。）"

#: ../../library/struct.rst:565
#, fuzzy
msgid "Identical to the :func:`pack_into` function, using the compiled format."
msgstr "與 :func:`pack_into` 函式相同，使用編譯後的格式。"

#: ../../library/struct.rst:570
#, fuzzy
msgid ""
"Identical to the :func:`unpack` function, using the compiled format. The "
"buffer's size in bytes must equal :attr:`size`."
msgstr "與 :func:`unpack` 函式相同，使用編譯後的格式。緩衝區的大小（以位元組為單位）"
"必須等於 :attr:`size`。"

#: ../../library/struct.rst:576
#, fuzzy
msgid ""
"Identical to the :func:`unpack_from` function, using the compiled format. "
"The buffer's size in bytes, starting at position *offset*, must be at least :"
"attr:`size`."
msgstr ""
"與 :func:`unpack_from` "
"函式相同，使用編譯後的格式。緩衝區的大小（以位元組為單位）從位置 *offset* "
"開始，必須至少為 :attr:`size`。"

#: ../../library/struct.rst:583
#, fuzzy
msgid ""
"Identical to the :func:`iter_unpack` function, using the compiled format. "
"The buffer's size in bytes must be a multiple of :attr:`size`."
msgstr ""
"與 :func:`iter_unpack` "
"函式相同，使用編譯後的格式。緩衝區的大小（以位元組為單位）必須是 :attr:`size`"
" 的倍數。"

#: ../../library/struct.rst:590
#, fuzzy
msgid "The format string used to construct this Struct object."
msgstr "用於構造此 Struct 物件的格式字串。"

#: ../../library/struct.rst:592
#, fuzzy
msgid "The format string type is now :class:`str` instead of :class:`bytes`."
msgstr "格式字串型別現在是 :class:`str` 而不是 :class:`bytes`。"

#: ../../library/struct.rst:597
#, fuzzy
msgid ""
"The calculated size of the struct (and hence of the bytes object produced by "
"the :meth:`pack` method) corresponding to :attr:`format`."
msgstr "對應於 :attr:`format` 的結構（以及由 :meth:`pack` "
"方法生成的位元組物件）的計算大小。"
