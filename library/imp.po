# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-15 20:43+0000\n"
"PO-Revision-Date: 2018-05-23 16:04+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/imp.rst:2
msgid ":mod:`imp` --- Access the :ref:`import <importsystem>` internals"
msgstr ":mod:`imp` --- 存取 :ref:`import <importsystem>` 內部"

#: ../../library/imp.rst:8
msgid "**Source code:** :source:`Lib/imp.py`"
msgstr "**原始碼：**\\ :source:`Lib/imp.py`"

#: ../../library/imp.rst:12
msgid "The :mod:`imp` module is deprecated in favor of :mod:`importlib`."
msgstr ":mod:`imp` 模組已棄用，取而代之的是 :mod:`importlib`。"

#: ../../library/imp.rst:17
#, fuzzy
msgid ""
"This module provides an interface to the mechanisms used to implement the :"
"keyword:`import` statement.  It defines the following constants and "
"functions:"
msgstr "該模組為用於實作 :keyword:`import` "
"語句的機制提供了一個介面。它定義了以下常數和函式："

#: ../../library/imp.rst:25
#, fuzzy
msgid ""
"Return the magic string value used to recognize byte-compiled code files (:"
"file:`.pyc` files).  (This value may be different for each Python version.)"
msgstr "回傳用於識別位元組編譯程式碼文件（:file:`.pyc` 文件）的魔術字串值。 （每個 "
"Python 版本的這個值可能不同。）"

#: ../../library/imp.rst:28
msgid "Use :attr:`importlib.util.MAGIC_NUMBER` instead."
msgstr "使用 :attr:`importlib.util.MAGIC_NUMBER` 代替。"

#: ../../library/imp.rst:34
#, fuzzy
msgid ""
"Return a list of 3-element tuples, each describing a particular type of "
"module. Each triple has the form ``(suffix, mode, type)``, where *suffix* is "
"a string to be appended to the module name to form the filename to search "
"for, *mode* is the mode string to pass to the built-in :func:`open` function "
"to open the file (this can be ``'r'`` for text files or ``'rb'`` for binary "
"files), and *type* is the file type, which has one of the values :const:"
"`PY_SOURCE`, :const:`PY_COMPILED`, or :const:`C_EXTENSION`, described below."
msgstr ""
"回傳 3 元素元組的列表，每個元組描述一種特定型別的模組。每個三元組的形式為``("
"suffix, mode, type)``，其中 *suffix* "
"是要附加到模組名稱以形成要搜索的文件名的字串，*mode* 是要傳遞給內建 "
":func:`open` 函式打開文件（這可以是文本文件的 ``'r'`` 或二進位文件的 "
"``'rb'``），*type* "
"是文件型別，它具有以下值之一 :const:`PY_SOURCE`、:const:`PY_COMPILED` 或 "
":const:`C_EXTENSION`。"

#: ../../library/imp.rst:43
#, fuzzy
msgid "Use the constants defined on :mod:`importlib.machinery` instead."
msgstr "請改用 importlib.machinery 上定義的常數。"

#: ../../library/imp.rst:49
#, fuzzy
msgid ""
"Try to find the module *name*.  If *path* is omitted or ``None``, the list "
"of directory names given by ``sys.path`` is searched, but first a few "
"special places are searched: the function tries to find a built-in module "
"with the given name (:const:`C_BUILTIN`), then a frozen module (:const:"
"`PY_FROZEN`), and on some systems some other places are looked in as well "
"(on Windows, it looks in the registry which may point to a specific file)."
msgstr ""
"嘗試找到模組 *name*。如果省略 *path* 或 ``None``，則搜索 ``sys.path`` 給出的"
"目錄名稱列表，但首先搜索幾個特殊位置：該函式試圖找到一個內建模組給定名稱（:co"
"nst:`C_BUILTIN`），然後是凍結模組（:const:`PY_FROZEN`），在某些系統上還會查看"
"其他一些地方（在 Windows 上，它會在可能指向的註冊表中查找一個特定的文件）。"

#: ../../library/imp.rst:56
#, fuzzy
msgid ""
"Otherwise, *path* must be a list of directory names; each directory is "
"searched for files with any of the suffixes returned by :func:`get_suffixes` "
"above.  Invalid names in the list are silently ignored (but all list items "
"must be strings)."
msgstr ""
"否則，*path* 必須是目錄名列表；在每個目錄中搜索帶有上面 get_suffixes 回傳的任"
"何後綴的文件。列表中的無效名稱將被靜默忽略（但所有列表項都必須是字串）。"

#: ../../library/imp.rst:61
#, fuzzy
msgid ""
"If search is successful, the return value is a 3-element tuple ``(file, "
"pathname, description)``:"
msgstr "如果搜索成功，回傳值是一個 3 元素元組``(file, pathname, description)``："

#: ../../library/imp.rst:64
#, fuzzy
msgid ""
"*file* is an open :term:`file object` positioned at the beginning, "
"*pathname* is the pathname of the file found, and *description* is a 3-"
"element tuple as contained in the list returned by :func:`get_suffixes` "
"describing the kind of module found."
msgstr ""
"*file* 是一個打開的 :term:`file object`，位於開頭，*pathname* "
"是找到的文件的路徑名，*description* 是一個 3 元素元組，包含在 :func:` "
"回傳的列表中get_suffixes 描述找到的模組型別。"

#: ../../library/imp.rst:69
#, fuzzy
msgid ""
"If the module is built-in or frozen then *file* and *pathname* are both "
"``None`` and the *description* tuple contains empty strings for its suffix "
"and mode; the module type is indicated as given in parentheses above.  If "
"the search is unsuccessful, :exc:`ImportError` is raised.  Other exceptions "
"indicate problems with the arguments or environment."
msgstr ""
"如果模組是內建的或凍結的，則 *file* 和 *pathname* 都是 ``None``並且 "
"*description* 元組包含其後綴和模式的空字串；模組型別在上面的括號中給出。如果"
"搜索不成功，則會引發 :exec:`ImportError`。其他例外表示參數或環境有問題。"

#: ../../library/imp.rst:75
#, fuzzy
msgid ""
"If the module is a package, *file* is ``None``, *pathname* is the package "
"path and the last item in the *description* tuple is :const:`PKG_DIRECTORY`."
msgstr ""
"如果模組是一個包，*file* 是``None``，*pathname* 是包路徑，*description* "
"元組中的最後一項是 :const:`PKG_DIRECTORY`。"

#: ../../library/imp.rst:78
#, fuzzy
msgid ""
"This function does not handle hierarchical module names (names containing "
"dots).  In order to find *P.M*, that is, submodule *M* of package *P*, use :"
"func:`find_module` and :func:`load_module` to find and load package *P*, and "
"then use :func:`find_module` with the *path* argument set to ``P.__path__``. "
"When *P* itself has a dotted name, apply this recipe recursively."
msgstr ""
"此函式不處理分層模組名稱（包含點的名稱）。為了找到*P.M*，即包*P* "
"的子模組*M*，使用 :func:`find_module` 和 :func:`load_module` "
"找到並加載包*P*，然後使用:func: `find_module`，*path* 參數設定為 ``P."
"__path__``。當 *P* 本身有一個帶點的名字時，遞迴地應用這個方法。"

#: ../../library/imp.rst:84
#, fuzzy
msgid ""
"Use :func:`importlib.util.find_spec` instead unless Python 3.3 compatibility "
"is required, in which case use :func:`importlib.find_loader`. For example "
"usage of the former case, see the :ref:`importlib-examples` section of the :"
"mod:`importlib` documentation."
msgstr ""
"使用 :func:`importlib.util.find_spec` 除非需要 Python 3.3 相容性，"
"在這種情況下使用 :func:`importlib.find_loader`。對於前一種情況的示例用法，"
"請參閱 :ref:`importlib` 文檔的 :ref:`importlib-examples` 部分。"

#: ../../library/imp.rst:94
#, fuzzy
msgid ""
"Load a module that was previously found by :func:`find_module` (or by an "
"otherwise conducted search yielding compatible results).  This function does "
"more than importing the module: if the module was already imported, it will "
"reload the module!  The *name* argument indicates the full module name "
"(including the package name, if this is a submodule of a package).  The "
"*file* argument is an open file, and *pathname* is the corresponding file "
"name; these can be ``None`` and ``''``, respectively, when the module is a "
"package or not being loaded from a file.  The *description* argument is a "
"tuple, as would be returned by :func:`get_suffixes`, describing what kind of "
"module must be loaded."
msgstr ""
"加載之前由 :func:`find_module` 找到的模組（或通過其他方式進行的搜索產生相容的"
"結果）。這個函式不僅僅是導入模組：如果模組已經導入，它會重新加載模組！ *name*"
" 參數表示完整的模組名稱（包括包名稱，如果這是包的子模組）。 *file*參數是一個"
"打開的文件，*pathname*是對應的文件名；當模組是一個包或不是從文件加載時，它們"
"可以分別是 ``None``和 ``''`` 。 *description* 參數是一個元組，由 "
":func:`get_suffixes` 回傳，描述必須加載哪種模組。"

#: ../../library/imp.rst:105
#, fuzzy
msgid ""
"If the load is successful, the return value is the module object; otherwise, "
"an exception (usually :exc:`ImportError`) is raised."
msgstr "如果加載成功，回傳值為模組物件；否則，會引發例外（通常是 "
":exc:`ImportError`）。"

#: ../../library/imp.rst:108
#, fuzzy
msgid ""
"**Important:** the caller is responsible for closing the *file* argument, if "
"it was not ``None``, even when an exception is raised.  This is best done "
"using a :keyword:`try` ... :keyword:`finally` statement."
msgstr ""
"**重要：**呼叫者負責關閉 *file* 參數，如果它不是 ``None``，即使引發例外。"
"最好使用 :keyword:`try` ... :keyword:`finally` 語句來完成。"

#: ../../library/imp.rst:112
#, fuzzy
msgid ""
"If previously used in conjunction with :func:`imp.find_module` then consider "
"using :func:`importlib.import_module`, otherwise use the loader returned by "
"the replacement you chose for :func:`imp.find_module`. If you called :func:"
"`imp.load_module` and related functions directly with file path arguments "
"then use a combination of :func:`importlib.util.spec_from_file_location` "
"and :func:`importlib.util.module_from_spec`. See the :ref:`importlib-"
"examples` section of the :mod:`importlib` documentation for details of the "
"various approaches."
msgstr ""
"如果之前與 imp.find_module 一起使用，那麼考慮使用 importlib.import_module ，"
"否則使用您為 imp.find_module 選擇的替換回傳的加載器。"
"如果您直接使用文件路徑參數呼叫 :func:`imp.load_module` 和相關函式，則使用 "
":func:`importlib.util.spec_from_file_location` 和 :func:`importlib.util."
"module_from_spec` 的組合。有關各種方法的詳細資訊，請參閱 :ref:`importlib` "
"文檔的 :ref:`importlib-examples` 部分。"

#: ../../library/imp.rst:126
#, fuzzy
msgid ""
"Return a new empty module object called *name*.  This object is *not* "
"inserted in ``sys.modules``."
msgstr "回傳一個名為 *name* 的新空模組物件。此物件*未*插入“sys.modules”中。"

#: ../../library/imp.rst:129
#, fuzzy
msgid "Use :func:`importlib.util.module_from_spec` instead."
msgstr "使用 :func:`importlib.util.module_from_spec` 代替。"

#: ../../library/imp.rst:135
#, fuzzy
msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is useful "
"if you have edited the module source file using an external editor and want "
"to try out the new version without leaving the Python interpreter.  The "
"return value is the module object (the same as the *module* argument)."
msgstr ""
"重新加載以前導入的*模組*。參數必須是一個模組物件，所以它之前必須已經成功導入"
"。如果您使用外部編輯器編輯了模組源文件並且想在不離開 Python "
"直譯器的情況下試用新版本，這將很有用。回傳值是模組物件（與 *module* "
"參數相同）。"

#: ../../library/imp.rst:141
msgid "When ``reload(module)`` is executed:"
msgstr "當執行``reload(module)`` 時："

#: ../../library/imp.rst:143
#, fuzzy
msgid ""
"Python modules' code is recompiled and the module-level code reexecuted, "
"defining a new set of objects which are bound to names in the module's "
"dictionary.  The ``init`` function of extension modules is not called a "
"second time."
msgstr ""
"重新編譯 Python 模組的程式碼並重新執行模組級程式碼，定義一組新的物件，這些物"
"件綁定到模組字典中的名稱。擴充模組的 ``init`` 函式不會被第二次呼叫。"

#: ../../library/imp.rst:148
#, fuzzy
msgid ""
"As with all other objects in Python the old objects are only reclaimed after "
"their reference counts drop to zero."
msgstr "與 Python 中的所有其他對像一樣，舊物件僅在其引用計數降至零後才會被回收。"

#: ../../library/imp.rst:151
#, fuzzy
msgid ""
"The names in the module namespace are updated to point to any new or changed "
"objects."
msgstr "模組命名空間中的名稱被更新為指向任何新的或更改的物件。"

#: ../../library/imp.rst:154
#, fuzzy
msgid ""
"Other references to the old objects (such as names external to the module) "
"are not rebound to refer to the new objects and must be updated in each "
"namespace where they occur if that is desired."
msgstr "對舊物件的其他引用（例如模組外部的名稱）不會重新綁定以引用新物件，並且如果需"
"要，必須在它們出現的每個命名空間中進行更新。"

#: ../../library/imp.rst:158
#, fuzzy
msgid "There are a number of other caveats:"
msgstr "還有許多其他警告："

#: ../../library/imp.rst:160
#, fuzzy
msgid ""
"When a module is reloaded, its dictionary (containing the module's global "
"variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a "
"module does not define a name that was defined by the old version, the old "
"definition remains.  This feature can be used to the module's advantage if "
"it maintains a global table or cache of objects --- with a :keyword:`try` "
"statement it can test for the table's presence and skip its initialization "
"if desired::"
msgstr ""
"重新加載模組時，會保留其字典（包含模組的全局變數）。名稱的重新定義將覆蓋舊定"
"義，因此這通常不是問題。如果模組的新版本沒有定義舊版本定義的名稱，則保留舊定"
"義。如果維護全局表或物件快取，則此功能可用於模組的優勢---使用 :keyword:`try` "
"語句，它可以測試表的存在並在需要時跳過其初始化::"

#: ../../library/imp.rst:173
#, fuzzy
msgid ""
"It is legal though generally not very useful to reload built-in or "
"dynamically loaded modules, except for :mod:`sys`, :mod:`__main__` and :mod:"
"`builtins`. In many cases, however, extension modules are not designed to be "
"initialized more than once, and may fail in arbitrary ways when reloaded."
msgstr ""
"重新加載內建或動態加載的模組是合法的，但通常不是很有用，除了 "
":mod:`sys`、:mod:`__main__` 和 :mod:`builtins`。然而，在許多情況下，擴充模組"
"的設計不會被多次初始化，並且在重新加載時可能會以任意方式失敗。"

#: ../../library/imp.rst:178
#, fuzzy
msgid ""
"If a module imports objects from another module using :keyword:`from` ... :"
"keyword:`import` ..., calling :func:`reload` for the other module does not "
"redefine the objects imported from it --- one way around this is to re-"
"execute the :keyword:`!from` statement, another is to use :keyword:`!import` "
"and qualified names (*module*.*name*) instead."
msgstr ""
"如果一個模組使用 :keyword:`from` ... :keyword:`import` ... "
"從另一個模組導入物件，為另一個模組呼叫 :func:`reload` "
"不會重新定義從它導入的物件 ---解決這個問題的一種方法是重新執行 "
":keyword:`!from` 語句，另一種方法是使用 :keyword:`!import` 和限定名稱 "
"(*module*.*name*) 代替。"

#: ../../library/imp.rst:184
#, fuzzy
msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances "
"--- they continue to use the old class definition.  The same is true for "
"derived classes."
msgstr "如果一個模組實例化了一個類的實例，重新加載定義類的模組不會影響實例的方法定義—"
"—它們繼續使用舊的類定義。派生類也是如此。"

#: ../../library/imp.rst:188
#, fuzzy
msgid ""
"Relies on both ``__name__`` and ``__loader__`` being defined on the module "
"being reloaded instead of just ``__name__``."
msgstr "依賴於在重新加載的模組上定義的 ``__name__`` 和 ``__loader__`` 而不僅僅是 "
"``__name__``。"

#: ../../library/imp.rst:192
#, fuzzy
msgid "Use :func:`importlib.reload` instead."
msgstr "使用 :func:`importlib.reload` 代替。"

#: ../../library/imp.rst:196
#, fuzzy
msgid ""
"The following functions are conveniences for handling :pep:`3147` byte-"
"compiled file paths."
msgstr "以下函式方便處理 :pep:`3147` 位元組編譯文件路徑。"

#: ../../library/imp.rst:203
#, fuzzy
msgid ""
"Return the :pep:`3147` path to the byte-compiled file associated with the "
"source *path*.  For example, if *path* is ``/foo/bar/baz.py`` the return "
"value would be ``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python 3.2. "
"The ``cpython-32`` string comes from the current magic tag (see :func:"
"`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined then :exc:"
"`NotImplementedError` will be raised). By passing in ``True`` or ``False`` "
"for *debug_override* you can override the system's value for ``__debug__``, "
"leading to optimized bytecode."
msgstr ""
"將 :pep:`3147` 路徑回傳到與源 *path* 關聯的位元組編譯文件。例如，如果 *path* "
"是 ``/foo/bar/baz.py``，對於 Python 3.2，回傳值將是 ``/foo/bar/__pycache__/"
"baz.cpython-32.pyc``。 ``cpython-32`` "
"字串來自當前的魔術標籤（參見 :func:`get_tag`；如果未定義 :attr:`sys."
"implementation.cache_tag`，則將引發 :exec:`NotImplementedError`）。通過為 "
"*debug_override* 傳入 ``True`` 或 ``False``，您可以覆蓋 ``__debug__`` "
"的系統值，從而最佳化位元組碼。"

#: ../../library/imp.rst:212
#, fuzzy
msgid "*path* need not exist."
msgstr "*路徑* 不需要存在。"

#: ../../library/imp.rst:214
#, fuzzy
msgid ""
"If :attr:`sys.implementation.cache_tag` is ``None``, then :exc:"
"`NotImplementedError` is raised."
msgstr ""
"如果 :attr:`sys.implementation.cache_tag` 為 "
"``None``，則引發 :exec:`NotImplementedError`。"

#: ../../library/imp.rst:218
#, fuzzy
msgid "Use :func:`importlib.util.cache_from_source` instead."
msgstr "使用 :func:`importlib.util.cache_from_source` 代替。"

#: ../../library/imp.rst:221
#, fuzzy
msgid "The *debug_override* parameter no longer creates a ``.pyo`` file."
msgstr "*debug_override* 參數不再建立 ``.pyo`` 文件。"

#: ../../library/imp.rst:227
#, fuzzy
msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source "
"code file path.  For example, if *path* is ``/foo/bar/__pycache__/baz."
"cpython-32.pyc`` the returned path would be ``/foo/bar/baz.py``.  *path* "
"need not exist, however if it does not conform to :pep:`3147` format, a :exc:"
"`ValueError` is raised. If :attr:`sys.implementation.cache_tag` is not "
"defined, :exc:`NotImplementedError` is raised."
msgstr ""
"給定 :pep:`3147` 文件名的*路徑*，回傳關聯的源程式碼文件路徑。例如，如果 "
"*path* 是 ``/foo/bar/__pycache__/baz.cpython-32.pyc`` 回傳的路徑將是 ``/foo/"
"bar/baz.py``。 *path* 不需要存在，但是如果它不符合 :pep:`3147` 格式，"
"則會引發 :exc:`ValueError`。如果未定義 :attr:`sys.implementation."
"cache_tag`，則引發 :exec:`NotImplementedError`。"

#: ../../library/imp.rst:235
#, fuzzy
msgid ""
"Raise :exc:`NotImplementedError` when :attr:`sys.implementation.cache_tag` "
"is not defined."
msgstr ""
"當 :attr:`sys.implementation.cache_tag` "
"未定義時引發 :exec:`NotImplementedError`。"

#: ../../library/imp.rst:239
#, fuzzy
msgid "Use :func:`importlib.util.source_from_cache` instead."
msgstr "使用 :func:`importlib.util.source_from_cache` 代替。"

#: ../../library/imp.rst:245
#, fuzzy
msgid ""
"Return the :pep:`3147` magic tag string matching this version of Python's "
"magic number, as returned by :func:`get_magic`."
msgstr "回傳匹配此版本 Python 幻數的 :pep:`3147` 幻數標籤字串，由 :func:`get_magic` "
"回傳。"

#: ../../library/imp.rst:248
#, fuzzy
msgid ""
"Use :attr:`sys.implementation.cache_tag` directly starting in Python 3.3."
msgstr "從 Python 3.3 開始直接使用 :attr:`sys.implementation.cache_tag`。"

#: ../../library/imp.rst:253
#, fuzzy
msgid ""
"The following functions help interact with the import system's internal "
"locking mechanism.  Locking semantics of imports are an implementation "
"detail which may vary from release to release.  However, Python ensures that "
"circular imports work without any deadlocks."
msgstr "以下函式有助於與導入系統的內部鎖定機制進行交互。導入的鎖定語義是一個實作細節"
"，可能因版本而異。然而，Python 確保循環導入沒有任何死鎖。"

#: ../../library/imp.rst:261
#, fuzzy
msgid ""
"Return ``True`` if the global import lock is currently held, else ``False``. "
"On platforms without threads, always return ``False``."
msgstr "如果當前持有全局導入鎖，則回傳 ``True``，否則回傳 ``False``。在沒有執行緒的平台上，"
"總是回傳 ``False``。"

#: ../../library/imp.rst:264
#, fuzzy
msgid ""
"On platforms with threads, a thread executing an import first holds a global "
"import lock, then sets up a per-module lock for the rest of the import.  "
"This blocks other threads from importing the same module until the original "
"import completes, preventing other threads from seeing incomplete module "
"objects constructed by the original thread.  An exception is made for "
"circular imports, which by construction have to expose an incomplete module "
"object at some point."
msgstr ""
"在有執行緒的平台上，執行導入的執行緒首先持有一個全局導入鎖，然後為導入的其餘"
"部分設定一個每個模組的鎖。這會阻止其他執行緒導入同一模組，直到原始導入完成，"
"從而防止其他執行緒看到由原始執行緒構造的不完整模組物件。循環導入是一個例外，"
"循環導入必須在某些時候暴露不完整的模組物件。"

#: ../../library/imp.rst:272 ../../library/imp.rst:292
#: ../../library/imp.rst:305
#, fuzzy
msgid ""
"The locking scheme has changed to per-module locks for the most part.  A "
"global import lock is kept for some critical tasks, such as initializing the "
"per-module locks."
msgstr "在大多數情況下，鎖定方案已更改為按模組鎖定。為某些關鍵任務保留全局導入鎖，例"
"如初始化每個模組的鎖。"

#: ../../library/imp.rst:282
#, fuzzy
msgid ""
"Acquire the interpreter's global import lock for the current thread. This "
"lock should be used by import hooks to ensure thread-safety when importing "
"modules."
msgstr "為當前執行緒獲取直譯器的全局導入鎖。導入掛鉤應該使用此鎖以確保導入模組時的執"
"行緒安全。"

#: ../../library/imp.rst:286
#, fuzzy
msgid ""
"Once a thread has acquired the import lock, the same thread may acquire it "
"again without blocking; the thread must release it once for each time it has "
"acquired it."
msgstr "一旦一個執行緒獲得了導入鎖，同一個執行緒可以再次獲得它而不會阻塞；執行緒必須"
"在每次獲取它時釋放它一次。"

#: ../../library/imp.rst:290
#, fuzzy
msgid "On platforms without threads, this function does nothing."
msgstr "在沒有執行緒的平台上，這個函式什麼都不做。"

#: ../../library/imp.rst:302
#, fuzzy
msgid ""
"Release the interpreter's global import lock. On platforms without threads, "
"this function does nothing."
msgstr "釋放直譯器的全局導入鎖。在沒有執行緒的平台上，這個函式什麼都不做。"

#: ../../library/imp.rst:313
#, fuzzy
msgid ""
"The following constants with integer values, defined in this module, are "
"used to indicate the search result of :func:`find_module`."
msgstr "本模組中定義的以下具有整數值的常數用於指示 :func:`find_module` 的搜索結果。"

#: ../../library/imp.rst:319
#, fuzzy
msgid "The module was found as a source file."
msgstr "該模組被發現為源文件。"

#: ../../library/imp.rst:326
#, fuzzy
msgid "The module was found as a compiled code object file."
msgstr "該模組被發現為已編譯的程式碼目標文件。"

#: ../../library/imp.rst:333
#, fuzzy
msgid "The module was found as dynamically loadable shared library."
msgstr "該模組被發現為可動態加載的共享庫。"

#: ../../library/imp.rst:340
#, fuzzy
msgid "The module was found as a package directory."
msgstr "該模組被發現為包目錄。"

#: ../../library/imp.rst:347
#, fuzzy
msgid "The module was found as a built-in module."
msgstr "該模組被發現為內建模組。"

#: ../../library/imp.rst:354
#, fuzzy
msgid "The module was found as a frozen module."
msgstr "該模組被發現為凍結模組。"

#: ../../library/imp.rst:361
#, fuzzy
msgid ""
"The :class:`NullImporter` type is a :pep:`302` import hook that handles non-"
"directory path strings by failing to find any modules.  Calling this type "
"with an existing directory or empty string raises :exc:`ImportError`. "
"Otherwise, a :class:`NullImporter` instance is returned."
msgstr ""
":class:`NullImporter` 型別是一個 :pep:`302` "
"導入鉤子，它通過找不到任何模組來處理非目錄路徑字串。"
"使用現有目錄或空字串呼叫此型別會引發 :exc:`ImportError`。否則，回傳一個 "
"NullImporter 實例。"

#: ../../library/imp.rst:366
#, fuzzy
msgid "Instances have only one method:"
msgstr "實例只有一種方法："

#: ../../library/imp.rst:370
#, fuzzy
msgid ""
"This method always returns ``None``, indicating that the requested module "
"could not be found."
msgstr "這個方法總是回傳``None``，表示找不到請求的模組。"

#: ../../library/imp.rst:373
#, fuzzy
msgid ""
"``None`` is inserted into ``sys.path_importer_cache`` instead of an instance "
"of :class:`NullImporter`."
msgstr ""
"``None`` 被插入到 ``sys.path_importer_cache`` 而不是 :class:`NullImporter` "
"的實例。"

#: ../../library/imp.rst:377
#, fuzzy
msgid "Insert ``None`` into ``sys.path_importer_cache`` instead."
msgstr "而是將 ``None`` 插入“sys.path_importer_cache”。"

#: ../../library/imp.rst:384
msgid "Examples"
msgstr "範例"

#: ../../library/imp.rst:386
#, fuzzy
msgid ""
"The following function emulates what was the standard import statement up to "
"Python 1.4 (no hierarchical module names).  (This *implementation* wouldn't "
"work in that version, since :func:`find_module` has been extended and :func:"
"`load_module` has been added in 1.4.) ::"
msgstr ""
"以下函式模擬了 Python 1.4 之前的標準導入語句（沒有分層模組名稱）。 "
"（這個*實作*在那個版本中不起作用，因為 :func:`find_module` 已經擴充並且 "
":func:`load_module` 已經在 1.4 中新增。）::"
