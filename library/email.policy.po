# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-26 18:54+0800\n"
"PO-Revision-Date: 2018-05-23 16:01+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/email.policy.rst:2
#, fuzzy
msgid ":mod:`email.policy`: Policy Objects"
msgstr ":mod:`email.policy`: 策略物件"

#: ../../library/email.policy.rst:12
msgid "**Source code:** :source:`Lib/email/policy.py`"
msgstr "**原始碼：**\\ :source:`Lib/email/policy.py`"

#: ../../library/email.policy.rst:16
#, fuzzy
msgid ""
"The :mod:`email` package's prime focus is the handling of email messages as "
"described by the various email and MIME RFCs.  However, the general format "
"of email messages (a block of header fields each consisting of a name "
"followed by a colon followed by a value, the whole block followed by a blank "
"line and an arbitrary 'body'), is a format that has found utility outside of "
"the realm of email.  Some of these uses conform fairly closely to the main "
"email RFCs, some do not.  Even when working with email, there are times when "
"it is desirable to break strict compliance with the RFCs, such as generating "
"emails that interoperate with email servers that do not themselves follow "
"the standards, or that implement extensions you want to use in ways that "
"violate the standards."
msgstr ""
":mod:`email` 包的主要焦點是處理各種電子郵件和 MIME RFC 中描述的電子郵件消息。"
"然而，電子郵件消息的一般格式（一個標題欄位塊，每個標題欄位由一個名稱、一個冒"
"號和一個值組成，整個塊後跟一個空行和一個任意的“正文”），是一種已經發現的格式"
"電子郵件領域之外的實用程式。其中一些用途與主要電子郵件 RFC "
"相當接近，有些則不。即使在處理電子郵件時，有時也需要打破對 RFC 的嚴格遵守，例"
"如生成與本身不遵循標準的電子郵件伺服器互操作的電子郵件，或者以違反標準的方式"
"實作您想要使用的擴充標準。"

#: ../../library/email.policy.rst:28
#, fuzzy
msgid ""
"Policy objects give the email package the flexibility to handle all these "
"disparate use cases."
msgstr "策略物件為電子郵件包提供了處理所有這些不同用例的靈活性。"

#: ../../library/email.policy.rst:31
#, fuzzy
msgid ""
"A :class:`Policy` object encapsulates a set of attributes and methods that "
"control the behavior of various components of the email package during use. :"
"class:`Policy` instances can be passed to various classes and methods in the "
"email package to alter the default behavior.  The settable values and their "
"defaults are described below."
msgstr ""
":class:`Policy` 物件封裝了一組屬性和方法，這些屬性和方法控制電子郵件包的各個"
"組件在使用過程中的行為。 :class:`Policy` 實例可以傳遞給電子郵件包中的各種類和"
"方法，以改變預設行為。可設定的值及其預設值如下所述。"

#: ../../library/email.policy.rst:37
#, fuzzy
msgid ""
"There is a default policy used by all classes in the email package.  For all "
"of the :mod:`~email.parser` classes and the related convenience functions, "
"and for the :class:`~email.message.Message` class, this is the :class:"
"`Compat32` policy, via its corresponding pre-defined instance :const:"
"`compat32`.  This policy provides for complete backward compatibility (in "
"some cases, including bug compatibility) with the pre-Python3.3 version of "
"the email package."
msgstr ""
"電子郵件包中的所有類都使用預設策略。對於所有 :mod:`~email.parser` "
"類和相關的便利函式，以及 :class:`~email.message.Message` 類，這是 "
":class:`Compat32` 策略，通過其相應的預定義實例 :const:`compat32`。"
"此策略提供與電子郵件包的 pre-Python3.3 "
"版本的完全向後相容性（在某些情況下，包括錯誤相容性）。"

#: ../../library/email.policy.rst:44
#, fuzzy
msgid ""
"This default value for the *policy* keyword to :class:`~email.message."
"EmailMessage` is the :class:`EmailPolicy` policy, via its pre-defined "
"instance :data:`~default`."
msgstr ""
":class:`~email.message.EmailMessage` 的 *policy* "
"關鍵字的預設值是 :class:`EmailPolicy` "
"策略，通過其預定義實例 :data:`~default`。"

#: ../../library/email.policy.rst:48
#, fuzzy
msgid ""
"When a :class:`~email.message.Message` or :class:`~email.message."
"EmailMessage` object is created, it acquires a policy.  If the message is "
"created by a :mod:`~email.parser`, a policy passed to the parser will be the "
"policy used by the message it creates.  If the message is created by the "
"program, then the policy can be specified when it is created.  When a "
"message is passed to a :mod:`~email.generator`, the generator uses the "
"policy from the message by default, but you can also pass a specific policy "
"to the generator that will override the one stored on the message object."
msgstr ""
"當建立 :class:`~email.message.Message` 或 :class:`~email.message."
"EmailMessage` 物件時，它會獲取一個策略。如果消息是由 :mod:`~email.parser` 建"
"立的，傳遞給解析器的策略將是它建立的消息使用的策略。如果消息是由程式建立的，"
"則可以在建立消息時指定策略。當消息傳遞給 :mod:`~email.generator` 時，生成器預"
"設使用消息中的策略，但您也可以將特定策略傳遞給生成器，該策略將覆蓋儲存在消息"
"對像上的策略。"

#: ../../library/email.policy.rst:57
#, fuzzy
msgid ""
"The default value for the *policy* keyword for the :mod:`email.parser` "
"classes and the parser convenience functions **will be changing** in a "
"future version of Python.  Therefore you should **always specify explicitly "
"which policy you want to use** when calling any of the classes and functions "
"described in the :mod:`~email.parser` module."
msgstr ""
":mod:`email.parser` 類和解析器便利函式的 *policy* 關鍵字的預設值**將在未來的 "
"Python 版本中改變**。因此，在呼叫 :mod:`~email.parser` "
"模組中描述的任何類和函式時，您應該**始終明確指定要使用的策略**。"

#: ../../library/email.policy.rst:63
#, fuzzy
msgid ""
"The first part of this documentation covers the features of :class:`Policy`, "
"an :term:`abstract base class` that defines the features that are common to "
"all policy objects, including :const:`compat32`.  This includes certain hook "
"methods that are called internally by the email package, which a custom "
"policy could override to obtain different behavior.  The second part "
"describes the concrete classes :class:`EmailPolicy` and :class:`Compat32`, "
"which implement the hooks that provide the standard behavior and the "
"backward compatible behavior and features, respectively."
msgstr ""
"本文檔的第一部分介紹了 :class:`Policy` 的特性，這是一個 "
":term:`抽象基底類別`，它定義了所有策略物件共有的特性，包括 :const:`compat32`"
"。這包括由電子郵件包在內部呼叫的某些掛鉤方法，自定義策略可以覆蓋這些方法以獲"
"得不同的行為。第二部分描述了具體類 EmailPolicy 和 "
"Compat32，它們分別實作了提供標準行為和向後相容行為和特性的掛鉤。"

#: ../../library/email.policy.rst:72
#, fuzzy
msgid ""
":class:`Policy` instances are immutable, but they can be cloned, accepting "
"the same keyword arguments as the class constructor and returning a new :"
"class:`Policy` instance that is a copy of the original but with the "
"specified attributes values changed."
msgstr ""
":class:`Policy` 實例是不可變的，但它們可以被克隆，"
"接受與類構造函式相同的關鍵字參數並回傳一個新的 :class:`Policy` "
"實例，該實例是原始副本但指定的屬性值已更改."

#: ../../library/email.policy.rst:77
#, fuzzy
msgid ""
"As an example, the following code could be used to read an email message "
"from a file on disk and pass it to the system ``sendmail`` program on a Unix "
"system:"
msgstr "例如，以下程式碼可用於從磁盤上的文件中讀取電子郵件消息並將其傳遞給 Unix "
"系統上的系統 ``sendmail`` 程式："

#: ../../library/email.policy.rst:113
#, fuzzy
msgid ""
"Here we are telling :class:`~email.generator.BytesGenerator` to use the RFC "
"correct line separator characters when creating the binary string to feed "
"into ``sendmail's`` ``stdin``, where the default policy would use ``\\n`` "
"line separators."
msgstr ""
"在這裡，我們告訴 :class:`~email.generator.BytesGenerator` "
"在建立二進位字串以輸入到 ``sendmail`` ``stdin`` 時使用 RFC 正確的行分隔符，"
"預設策略將使用 `` \\n"
"`` 行分隔符。"

#: ../../library/email.policy.rst:118
#, fuzzy
msgid ""
"Some email package methods accept a *policy* keyword argument, allowing the "
"policy to be overridden for that method.  For example, the following code "
"uses the :meth:`~email.message.Message.as_bytes` method of the *msg* object "
"from the previous example and writes the message to a file using the native "
"line separators for the platform on which it is running::"
msgstr ""
"一些電子郵件包方法接受 *policy* 關鍵字參數，允許為該方法覆蓋策略。例如，"
"以下程式碼使用上一示例中 *msg* 物件的 :meth:`~email.message.Message.as_bytes`"
" 方法，並使用消息所在平台的本地行分隔符將消息寫入文件在跑：："

#: ../../library/email.policy.rst:129
#, fuzzy
msgid ""
"Policy objects can also be combined using the addition operator, producing a "
"policy object whose settings are a combination of the non-default values of "
"the summed objects::"
msgstr "策略對像也可以使用加法運算符組合，生成一個策略物件，其設定是求和物件的非預設"
"值的組合："

#: ../../library/email.policy.rst:137
#, fuzzy
msgid ""
"This operation is not commutative; that is, the order in which the objects "
"are added matters.  To illustrate::"
msgstr "此操作不可交換；也就是說，新增物件的順序很重要。為了顯示：："

#: ../../library/email.policy.rst:152
#, fuzzy
msgid ""
"This is the :term:`abstract base class` for all policy classes.  It provides "
"default implementations for a couple of trivial methods, as well as the "
"implementation of the immutability property, the :meth:`clone` method, and "
"the constructor semantics."
msgstr "這是所有策略類的抽象基底類別。它為幾個簡單的方法提供了預設實作，以及不變性屬"
"性、:meth:`clone` 方法和構造函式語義的實作。"

#: ../../library/email.policy.rst:157
#, fuzzy
msgid ""
"The constructor of a policy class can be passed various keyword arguments. "
"The arguments that may be specified are any non-method properties on this "
"class, plus any additional non-method properties on the concrete class.  A "
"value specified in the constructor will override the default value for the "
"corresponding attribute."
msgstr ""
"策略類的構造函式可以傳遞各種關鍵字參數。可以指定的參數是此類的任何非方法屬性"
"，加上具體類的任何其他非方法屬性。構造函式中指定的值將覆蓋相應屬性的預設值。"

#: ../../library/email.policy.rst:163
#, fuzzy
msgid ""
"This class defines the following properties, and thus values for the "
"following may be passed in the constructor of any policy class:"
msgstr "此類定義了以下屬性，因此可以在任何策略類的構造函式中傳遞以下值："

#: ../../library/email.policy.rst:169
#, fuzzy
msgid ""
"The maximum length of any line in the serialized output, not counting the "
"end of line character(s).  Default is 78, per :rfc:`5322`.  A value of ``0`` "
"or :const:`None` indicates that no line wrapping should be done at all."
msgstr ""
"序列化輸出中任何行的最大長度，不包括行尾字元。預設值為 78，根據 :rfc:`5322`。"
"值 ``0`` 或 :const:`None` 表示根本不應該換行。"

#: ../../library/email.policy.rst:177
#, fuzzy
msgid ""
"The string to be used to terminate lines in serialized output.  The default "
"is ``\\n`` because that's the internal end-of-line discipline used by "
"Python, though ``\\r\\n`` is required by the RFCs."
msgstr ""
"用於終止序列化輸出中行的字串。預設為 ``\\n"
"`` 因為這是 Python 使用的內部行尾規則，儘管 ``\\r\\n"
"`` 是 RFC 所要求的。"

#: ../../library/email.policy.rst:184
#, fuzzy
msgid ""
"Controls the type of Content Transfer Encodings that may be or are required "
"to be used.  The possible values are:"
msgstr "控制可能或需要使用的內容傳輸編碼的型別。可能的值是："

#: ../../library/email.policy.rst:190
msgid "``7bit``"
msgstr "``7bit``"

#: ../../library/email.policy.rst:190
#, fuzzy
msgid ""
"all data must be \"7 bit clean\" (ASCII-only).  This means that where "
"necessary data will be encoded using either quoted-printable or base64 "
"encoding."
msgstr "所有資料必須是“7 位乾淨”（僅限 ASCII）。這意味著必要的資料將使用 quoted-"
"printable 或 base64 編碼進行編碼。"

#: ../../library/email.policy.rst:194
msgid "``8bit``"
msgstr "``8bit``"

#: ../../library/email.policy.rst:194
#, fuzzy
msgid ""
"data is not constrained to be 7 bit clean.  Data in headers is still "
"required to be ASCII-only and so will be encoded (see :meth:`fold_binary` "
"and :attr:`~EmailPolicy.utf8` below for exceptions), but body parts may use "
"the ``8bit`` CTE."
msgstr ""
"資料不限於 7 位乾淨。標頭中的資料仍然需要僅使用 ASCII，因此將被編碼（"
"請參閱下面的 :meth:`fold_binary` 和 :attr:`~EmailPolicy.utf8` "
"以了解例外情況），但正文部分可以使用 ``8bit`` CTE。"

#: ../../library/email.policy.rst:200
#, fuzzy
msgid ""
"A ``cte_type`` value of ``8bit`` only works with ``BytesGenerator``, not "
"``Generator``, because strings cannot contain binary data.  If a "
"``Generator`` is operating under a policy that specifies ``cte_type=8bit``, "
"it will act as if ``cte_type`` is ``7bit``."
msgstr ""
"``8bit`` 的 ``cte_type`` 值僅適用於 ``BytesGenerator``，不適用於 "
"``Generator``，因為字串不能包含二進位資料。如果 ``Generator`` 在指定 "
"``cte_type=8bit`` 的策略下運行，它將像 ``cte_type`` 是 ``7bit`` 一樣工作。"

#: ../../library/email.policy.rst:208
#, fuzzy
msgid ""
"If :const:`True`, any defects encountered will be raised as errors.  If :"
"const:`False` (the default), defects will be passed to the :meth:"
"`register_defect` method."
msgstr ""
"如果 :const:`True`，遇到的任何缺陷都將作為錯誤引發。如果 "
":const:`False`（預設值），缺陷將傳遞給 :meth:`register_defect` 方法。"

#: ../../library/email.policy.rst:215
#, fuzzy
msgid ""
"If :const:`True`, lines starting with *\"From \"* in the body are escaped by "
"putting a ``>`` in front of them. This parameter is used when the message is "
"being serialized by a generator. Default: :const:`False`."
msgstr ""
"如果 :const:`True`，正文中以 *\"From\"* 開頭的行通過在它們前面放置 ``>`` "
"來轉義。當生成器序列化消息時使用此參數。預設值 :const:`False`。"

#: ../../library/email.policy.rst:220
msgid "The *mangle_from_* parameter."
msgstr "*mangle_from_* 參數。"

#: ../../library/email.policy.rst:226
#, fuzzy
msgid ""
"A factory function for constructing a new empty message object.  Used by the "
"parser when building messages.  Defaults to ``None``, in which case :class:"
"`~email.message.Message` is used."
msgstr ""
"用於構造新的空消息物件的工廠函式。由解析器在構建消息時使用。預設為 "
"``None``，在這種情況下使用 :class:`~email.message.Message`。"

#: ../../library/email.policy.rst:232
#, fuzzy
msgid ""
"The following :class:`Policy` method is intended to be called by code using "
"the email library to create policy instances with custom settings:"
msgstr "以下 :class:`Policy` "
"方法旨在由使用電子郵件庫的程式碼呼叫，以建立具有自定義設定的策略實例："

#: ../../library/email.policy.rst:238
#, fuzzy
msgid ""
"Return a new :class:`Policy` instance whose attributes have the same values "
"as the current instance, except where those attributes are given new values "
"by the keyword arguments."
msgstr "回傳一個新的 Policy "
"實例，其屬性具有與當前實例相同的值，除非這些屬性由關鍵字參數賦予新值。"

#: ../../library/email.policy.rst:243
#, fuzzy
msgid ""
"The remaining :class:`Policy` methods are called by the email package code, "
"and are not intended to be called by an application using the email package. "
"A custom policy must implement all of these methods."
msgstr "其餘的 :class:`Policy` 方法由電子郵件包程式碼呼叫，不打算由使用電子郵件包的應"
"用程式呼叫。自定義策略必須實作所有這些方法。"

#: ../../library/email.policy.rst:250
#, fuzzy
msgid ""
"Handle a *defect* found on *obj*.  When the email package calls this method, "
"*defect* will always be a subclass of :class:`~email.errors.Defect`."
msgstr ""
"處理在 *obj* 上發現的 *缺陷*。當電子郵件包呼叫此方法時，*defect* 將始終是 "
":class:`~email.errors.Defect` 的子類別。"

#: ../../library/email.policy.rst:254
#, fuzzy
msgid ""
"The default implementation checks the :attr:`raise_on_defect` flag.  If it "
"is ``True``, *defect* is raised as an exception.  If it is ``False`` (the "
"default), *obj* and *defect* are passed to :meth:`register_defect`."
msgstr ""
"預設實作檢查 :attr:`raise_on_defect` 旗標。如果它是 ``True``，*缺陷* "
"將作為例外引發。如果它是 ``False``（預設值），*obj* 和 *defect* 將傳遞給 "
":meth:`register_defect`。"

#: ../../library/email.policy.rst:261
#, fuzzy
msgid ""
"Register a *defect* on *obj*.  In the email package, *defect* will always be "
"a subclass of :class:`~email.errors.Defect`."
msgstr ""
"在 *obj* 上註冊一個 *defect*。在 email 包中，*defect* 將始終是 :class:`~email"
".errors.Defect` 的子類別。"

#: ../../library/email.policy.rst:264
#, fuzzy
msgid ""
"The default implementation calls the ``append`` method of the ``defects`` "
"attribute of *obj*.  When the email package calls :attr:`handle_defect`, "
"*obj* will normally have a ``defects`` attribute that has an ``append`` "
"method.  Custom object types used with the email package (for example, "
"custom ``Message`` objects) should also provide such an attribute, otherwise "
"defects in parsed messages will raise unexpected errors."
msgstr ""
"預設實作呼叫*obj* 的``defects`` 屬性的``append`` 方法。當電子郵件包呼叫 "
":attr:`handle_defect` 時，*obj* 通常會有一個帶有 ``append`` 方法的 "
"``defects`` 屬性。與電子郵件包一起使用的自定義對像型別（例如，自定義 ``Message`` "
"物件）也應該提供這樣的屬性，否則解析消息中的缺陷會引發意外錯誤。"

#: ../../library/email.policy.rst:274
#, fuzzy
msgid "Return the maximum allowed number of headers named *name*."
msgstr "回傳名為 *name* 的標頭的最大允許數量。"

#: ../../library/email.policy.rst:276
#, fuzzy
msgid ""
"Called when a header is added to an :class:`~email.message.EmailMessage` or :"
"class:`~email.message.Message` object.  If the returned value is not ``0`` "
"or ``None``, and there are already a number of headers with the name *name* "
"greater than or equal to the value returned, a :exc:`ValueError` is raised."
msgstr ""
"當標頭新增到 :class:`~email.message.EmailMessage` 或 :class:`~email.message."
"Message` 物件時呼叫。如果回傳值不是 ``0`` 或 ``None``，並且已經有多個標題 "
"*name* 大於或等於回傳值，則會引發 :exc:`ValueError` ."

#: ../../library/email.policy.rst:282
#, fuzzy
msgid ""
"Because the default behavior of ``Message.__setitem__`` is to append the "
"value to the list of headers, it is easy to create duplicate headers without "
"realizing it.  This method allows certain headers to be limited in the "
"number of instances of that header that may be added to a ``Message`` "
"programmatically.  (The limit is not observed by the parser, which will "
"faithfully produce as many headers as exist in the message being parsed.)"
msgstr ""
"因為 ``Message.__setitem__`` 的預設行為是將值附加到標題列表，所以很容易在沒有"
"意識到的情況下建立重複的標題。此方法允許某些標頭在可以以編程方式新增到“消息”"
"中的該標頭的實例數中受到限制。 "
"（解析器不會遵守該限制，它將忠實地生成與被解析的消息中存在的一樣多的標頭。）"

#: ../../library/email.policy.rst:290
#, fuzzy
msgid "The default implementation returns ``None`` for all header names."
msgstr "預設實作為所有標頭名稱回傳 ``None`` 。"

#: ../../library/email.policy.rst:295
#, fuzzy
msgid ""
"The email package calls this method with a list of strings, each string "
"ending with the line separation characters found in the source being "
"parsed.  The first line includes the field header name and separator. All "
"whitespace in the source is preserved.  The method should return the "
"``(name, value)`` tuple that is to be stored in the ``Message`` to represent "
"the parsed header."
msgstr ""
"電子郵件包使用字串列表呼叫此方法，每個字串以在被解析的源中找到的行分隔字元結"
"尾。第一行包括欄位標題名稱和分隔符。源中的所有空格都被保留。該方法應回傳要存"
"儲在“消息”中的“（名稱，值）”元組，以表示已解析的標頭。"

#: ../../library/email.policy.rst:302
#, fuzzy
msgid ""
"If an implementation wishes to retain compatibility with the existing email "
"package policies, *name* should be the case preserved name (all characters "
"up to the '``:``' separator), while *value* should be the unfolded value "
"(all line separator characters removed, but whitespace kept intact), "
"stripped of leading whitespace."
msgstr ""
"如果一個實作希望保持與現有電子郵件包策略的相容性，*name* "
"應該是保留大小寫的名稱（所有字元到 '``:``' 分隔符），而 *value* "
"應該是展開的值（所有行分隔符被刪除，但空格保持不變），去除了前導空格。"

#: ../../library/email.policy.rst:308
#, fuzzy
msgid "*sourcelines* may contain surrogateescaped binary data."
msgstr "*sourcelines* 可能包含代理轉義的二進位資料。"

#: ../../library/email.policy.rst:310 ../../library/email.policy.rst:326
#: ../../library/email.policy.rst:342
#, fuzzy
msgid "There is no default implementation"
msgstr "沒有預設實作"

#: ../../library/email.policy.rst:315
#, fuzzy
msgid ""
"The email package calls this method with the name and value provided by the "
"application program when the application program is modifying a ``Message`` "
"programmatically (as opposed to a ``Message`` created by a parser).  The "
"method should return the ``(name, value)`` tuple that is to be stored in the "
"``Message`` to represent the header."
msgstr ""
"當應用程式以編程方式修改“消息”（與解析器建立的“消息”相對）時，電子郵件包使用"
"應用程式提供的名稱和值呼叫此方法。該方法應回傳要儲存在“消息”中以表示標頭的“（"
"名稱，值）”元組。"

#: ../../library/email.policy.rst:321
#, fuzzy
msgid ""
"If an implementation wishes to retain compatibility with the existing email "
"package policies, the *name* and *value* should be strings or string "
"subclasses that do not change the content of the passed in arguments."
msgstr "如果一個實作希望保持與現有電子郵件包策略的相容性，*name* 和 *value* "
"應該是不更改傳入參數內容的字串或字串子類別。"

#: ../../library/email.policy.rst:331
#, fuzzy
msgid ""
"The email package calls this method with the *name* and *value* currently "
"stored in the ``Message`` when that header is requested by the application "
"program, and whatever the method returns is what is passed back to the "
"application as the value of the header being retrieved. Note that there may "
"be more than one header with the same name stored in the ``Message``; the "
"method is passed the specific name and value of the header destined to be "
"returned to the application."
msgstr ""
"當應用程式請求該標頭時，電子郵件包使用當前儲存在“消息”中的 *name* 和 *value* "
"呼叫此方法，無論該方法回傳什麼，都會作為值傳遞回應用程式正在檢索的標題。請注"
"意，在 ``Message`` 中可能儲存了多個具有相同名稱的標頭；該方法被傳遞給指定要回"
"傳給應用程式的標頭的特定名稱和值。"

#: ../../library/email.policy.rst:339
#, fuzzy
msgid ""
"*value* may contain surrogateescaped binary data.  There should be no "
"surrogateescaped binary data in the value returned by the method."
msgstr "*value* "
"可能包含代理轉義的二進位資料。該方法回傳的值中不應有代理轉義的二進位資料。"

#: ../../library/email.policy.rst:347
#, fuzzy
msgid ""
"The email package calls this method with the *name* and *value* currently "
"stored in the ``Message`` for a given header.  The method should return a "
"string that represents that header \"folded\" correctly (according to the "
"policy settings) by composing the *name* with the *value* and inserting :"
"attr:`linesep` characters at the appropriate places.  See :rfc:`5322` for a "
"discussion of the rules for folding email headers."
msgstr ""
"電子郵件包使用當前儲存在給定標頭的“消息”中的*名稱*和*值*呼叫此方法。"
"該方法應該通過將 *name* 與 *value* 組合併在適當的位置插入 :attr:`linesep` 字"
"元來回傳一個字串，該字串表示該標頭正確地“折疊”（根據策略設定）。有關折疊電子"
"郵件標頭規則的討論，請參閱 :rfc:`5322`。"

#: ../../library/email.policy.rst:354
#, fuzzy
msgid ""
"*value* may contain surrogateescaped binary data.  There should be no "
"surrogateescaped binary data in the string returned by the method."
msgstr "*value* "
"可能包含代理轉義的二進位資料。該方法回傳的字串中不應有代理轉義的二進位資料。"

#: ../../library/email.policy.rst:360
#, fuzzy
msgid ""
"The same as :meth:`fold`, except that the returned value should be a bytes "
"object rather than a string."
msgstr "與 :meth:`fold` 相同，除了回傳值應該是位元組物件而不是字串。"

#: ../../library/email.policy.rst:363
#, fuzzy
msgid ""
"*value* may contain surrogateescaped binary data.  These could be converted "
"back into binary data in the returned bytes object."
msgstr "*value* "
"可能包含代理轉義的二進位資料。這些可以在回傳的位元組對像中轉換回二進位資料。"

#: ../../library/email.policy.rst:370
#, fuzzy
msgid ""
"This concrete :class:`Policy` provides behavior that is intended to be fully "
"compliant with the current email RFCs.  These include (but are not limited "
"to) :rfc:`5322`, :rfc:`2047`, and the current MIME RFCs."
msgstr ""
"這個具體的 :class:`Policy` 提供了旨在完全符合當前電子郵件 RFC "
"的行為。這些包括（但不限於） :rfc:`5322`、:rfc:`2047` 和當前的 MIME RFC。"

#: ../../library/email.policy.rst:374
#, fuzzy
msgid ""
"This policy adds new header parsing and folding algorithms.  Instead of "
"simple strings, headers are ``str`` subclasses with attributes that depend "
"on the type of the field.  The parsing and folding algorithm fully "
"implement :rfc:`2047` and :rfc:`5322`."
msgstr ""
"此策略新增了新的標頭解析和折疊演算法。標題不是簡單的字串，而是 ``str`` "
"的子類別，其屬性取決於欄位的型別。解析和折疊演算法完全實作 :rfc:`2047` 和 "
":rfc:`5322`。"

#: ../../library/email.policy.rst:379
#, fuzzy
msgid ""
"The default value for the :attr:`~email.policy.Policy.message_factory` "
"attribute is :class:`~email.message.EmailMessage`."
msgstr ""
":attr:`~email.policy.Policy.message_factory` 屬性的預設值為 :class:`~email."
"message.EmailMessage`。"

#: ../../library/email.policy.rst:382
#, fuzzy
msgid ""
"In addition to the settable attributes listed above that apply to all "
"policies, this policy adds the following additional attributes:"
msgstr "除了上面列出的適用於所有策略的可設定屬性外，此策略還新增了以下附加屬性："

#: ../../library/email.policy.rst:385
#, fuzzy
msgid "[1]_"
msgstr "[1]_"

#: ../../library/email.policy.rst:390
#, fuzzy
msgid ""
"If ``False``, follow :rfc:`5322`, supporting non-ASCII characters in headers "
"by encoding them as \"encoded words\".  If ``True``, follow :rfc:`6532` and "
"use ``utf-8`` encoding for headers.  Messages formatted in this way may be "
"passed to SMTP servers that support the ``SMTPUTF8`` extension (:rfc:`6531`)."
msgstr ""
"如果 ``False``，遵循 :rfc:`5322`，通過將非 ASCII 字元編碼為“編碼字”"
"來支援標頭中的非 ASCII 字元。如果 ``True``，請遵循 :rfc:`6532` 並對標頭使用 "
"``utf-8`` "
"編碼。以這種方式格式化的消息可能會傳遞到支援 ``SMTPUTF8`` 擴充名（:rfc: ``6531``）"
"的 SMTP 伺服器。"

#: ../../library/email.policy.rst:399
#, fuzzy
msgid ""
"If the value for a header in the ``Message`` object originated from a :mod:"
"`~email.parser` (as opposed to being set by a program), this attribute "
"indicates whether or not a generator should refold that value when "
"transforming the message back into serialized form.  The possible values are:"
msgstr ""
"如果 ``Message`` 對像中的標頭值源自 :mod:`~email.parser`（而不是由程式設定）"
"，則此屬性指示生成器是否應在以下情況下重新折疊該值將消息轉換回序列化形式。可"
"能的值是："

#: ../../library/email.policy.rst:406
msgid "``none``"
msgstr "``none``"

#: ../../library/email.policy.rst:406
#, fuzzy
msgid "all source values use original folding"
msgstr "所有源值都使用原始折疊"

#: ../../library/email.policy.rst:408
msgid "``long``"
msgstr "``long``"

#: ../../library/email.policy.rst:408
#, fuzzy
msgid ""
"source values that have any line that is longer than ``max_line_length`` "
"will be refolded"
msgstr "任何行長於 ``max_line_length`` 的源值將被重新折疊"

#: ../../library/email.policy.rst:411
msgid "``all``"
msgstr "``all``"

#: ../../library/email.policy.rst:411
#, fuzzy
msgid "all values are refolded."
msgstr "所有值都被重新折疊。"

#: ../../library/email.policy.rst:414
msgid "The default is ``long``."
msgstr "預設為 ``long``\\ 。"

#: ../../library/email.policy.rst:419
#, fuzzy
msgid ""
"A callable that takes two arguments, ``name`` and ``value``, where ``name`` "
"is a header field name and ``value`` is an unfolded header field value, and "
"returns a string subclass that represents that header.  A default "
"``header_factory`` (see :mod:`~email.headerregistry`) is provided that "
"supports custom parsing for the various address and date :RFC:`5322` header "
"field types, and the major MIME header field stypes.  Support for additional "
"custom parsing will be added in the future."
msgstr ""
"一個帶有兩個參數的可呼叫物件，``name`` 和 ``value``，其中 ``name`` "
"是頭欄位名稱，``value`` 是展開的頭欄位值，並回傳一個字串子類別，表示那個標題"
"。提供了一個預設的``header_factory``（參見 :mod:`~email."
"headerregistry`），它支援對各種地址和日期的自定義解析 :RFC:`5322` "
"頭欄位型別，以及主要的 MIME 頭欄位型別。將來會新增對其他自定義解析的支援。"

#: ../../library/email.policy.rst:430
#, fuzzy
msgid ""
"An object with at least two methods: get_content and set_content.  When the :"
"meth:`~email.message.EmailMessage.get_content` or :meth:`~email.message."
"EmailMessage.set_content` method of an :class:`~email.message.EmailMessage` "
"object is called, it calls the corresponding method of this object, passing "
"it the message object as its first argument, and any arguments or keywords "
"that were passed to it as additional arguments.  By default "
"``content_manager`` is set to :data:`~email.contentmanager.raw_data_manager`."
msgstr ""
"至少具有兩種方法的物件：get_content 和 set_content。當 :meth:`~email.message."
"EmailMessage.get_content` 或 :meth:`~email.message.EmailMessage.set_content` "
"物件的方法被呼叫時，它呼叫此物件的相應方法，將消息對像作為第一個參數傳遞給它"
"，以及作為附加參數傳遞給它的任何參數或關鍵字。預設情況下，``content_manager``"
" 設定為 :data:`~email.contentmanager.raw_data_manager`。"

#: ../../library/email.policy.rst:442 ../../library/email.policy.rst:600
#, fuzzy
msgid ""
"The class provides the following concrete implementations of the abstract "
"methods of :class:`Policy`:"
msgstr "該類提供了 :class:`Policy` 的抽象方法的以下具體實作："

#: ../../library/email.policy.rst:448
#, fuzzy
msgid ""
"Returns the value of the :attr:`~email.headerregistry.BaseHeader.max_count` "
"attribute of the specialized class used to represent the header with the "
"given name."
msgstr ""
"回傳用於表示具有給定名稱的標頭的專用類的 :attr:`~email.headerregistry."
"BaseHeader.max_count` 屬性的值。"

#: ../../library/email.policy.rst:456 ../../library/email.policy.rst:606
#, fuzzy
msgid ""
"The name is parsed as everything up to the '``:``' and returned unmodified.  "
"The value is determined by stripping leading whitespace off the remainder of "
"the first line, joining all subsequent lines together, and stripping any "
"trailing carriage return or linefeed characters."
msgstr ""
"名稱被解析為直到 '``:``' 的所有內容並回傳未修改的內容。該值是通過去除第一行剩"
"餘部分的前導空格、將所有後續行連接在一起並去除任何尾隨回車或換行符來確定的。"

#: ../../library/email.policy.rst:464
#, fuzzy
msgid ""
"The name is returned unchanged.  If the input value has a ``name`` attribute "
"and it matches *name* ignoring case, the value is returned unchanged.  "
"Otherwise the *name* and *value* are passed to ``header_factory``, and the "
"resulting header object is returned as the value.  In this case a "
"``ValueError`` is raised if the input value contains CR or LF characters."
msgstr ""
"回傳的名稱不變。如果輸入值具有 ``name`` 屬性並且匹配 *name* "
"忽略大小寫，則該值將原樣回傳。否則，*name* 和 *value* 被傳遞給 "
"``header_factory``，結果 header 對像作為值回傳。在這種情況下，如果輸入值包含 "
"CR 或 LF 字元，則會引發 ``ValueError``。"

#: ../../library/email.policy.rst:474
#, fuzzy
msgid ""
"If the value has a ``name`` attribute, it is returned to unmodified. "
"Otherwise the *name*, and the *value* with any CR or LF characters removed, "
"are passed to the ``header_factory``, and the resulting header object is "
"returned.  Any surrogateescaped bytes get turned into the unicode unknown-"
"character glyph."
msgstr ""
"如果該值具有 ``name`` 屬性，則回傳為未修改。否則，*name* 和刪除了任何 CR 或 "
"LF 字元的 *value* 將傳遞給 ``header_factory``，並回傳生成的 header 物件。"
"任何代理轉義的位元組都會變成 unicode 未知字元字形。"

#: ../../library/email.policy.rst:483
#, fuzzy
msgid ""
"Header folding is controlled by the :attr:`refold_source` policy setting. A "
"value is considered to be a 'source value' if and only if it does not have a "
"``name`` attribute (having a ``name`` attribute means it is a header object "
"of some sort).  If a source value needs to be refolded according to the "
"policy, it is converted into a header object by passing the *name* and the "
"*value* with any CR and LF characters removed to the ``header_factory``.  "
"Folding of a header object is done by calling its ``fold`` method with the "
"current policy."
msgstr ""
"標題折疊由 :attr:`refold_source` 策略設定控制。當且僅當一個值沒有 ``name`` "
"屬性（具有 ``name`` 屬性意味著它是某種頭物件）時，該值才被認為是“源值”。如果"
"源值需要根據策略重新折疊，則通過將 *name* 和 *value* 以及刪除的任何 CR 和 LF "
"字元傳遞給 ``header_factory`` 將其轉換為標頭物件。標題物件的折疊是通過使用當"
"前策略呼叫其 ``fold``方法來完成的。"

#: ../../library/email.policy.rst:492
#, fuzzy
msgid ""
"Source values are split into lines using :meth:`~str.splitlines`.  If the "
"value is not to be refolded, the lines are rejoined using the ``linesep`` "
"from the policy and returned.  The exception is lines containing non-ascii "
"binary data.  In that case the value is refolded regardless of the "
"``refold_source`` setting, which causes the binary data to be CTE encoded "
"using the ``unknown-8bit`` charset."
msgstr ""
"使用 :meth:`~str.splitlines` 將源值分成幾行。如果該值不被重新折疊，"
"則使用策略中的 linesep 重新連接這些行並回傳。例外是包含非 ascii "
"二進位資料的行。在這種情況下，無論 ``refold_source`` "
"設定如何，都會重新折疊該值，這會導致使用 ``unknown-8bit`` "
"字元集對二進位資料進行 CTE 編碼。"

#: ../../library/email.policy.rst:502
#, fuzzy
msgid ""
"The same as :meth:`fold` if :attr:`~Policy.cte_type` is ``7bit``, except "
"that the returned value is bytes."
msgstr "如果 :attr:`~Policy.cte_type` 為 ``7bit``，則與 :meth:`fold` "
"相同，只是回傳值是位元組。"

#: ../../library/email.policy.rst:505
#, fuzzy
msgid ""
"If :attr:`~Policy.cte_type` is ``8bit``, non-ASCII binary data is converted "
"back into bytes.  Headers with binary data are not refolded, regardless of "
"the ``refold_header`` setting, since there is no way to know whether the "
"binary data consists of single byte characters or multibyte characters."
msgstr ""
"如果 :attr:`~Policy.cte_type` 是 ``8bit``，非 ASCII "
"二進位資料被轉換回位元組。無論``refold_header`` 設定如何，都不會重新折疊帶有"
"二進位資料的標頭，因為無法知道二進位資料是由單位元組字元還是多位元組字元組成"
"。"

#: ../../library/email.policy.rst:512
#, fuzzy
msgid ""
"The following instances of :class:`EmailPolicy` provide defaults suitable "
"for specific application domains.  Note that in the future the behavior of "
"these instances (in particular the ``HTTP`` instance) may be adjusted to "
"conform even more closely to the RFCs relevant to their domains."
msgstr ""
"EmailPolicy "
"的以下實例提供適用於特定應用程式域的預設值。請注意，將來可能會調整這些實例（"
"特別是 ``HTTP`` 實例）的行為，以更加符合與其域相關的 RFC。"

#: ../../library/email.policy.rst:520
#, fuzzy
msgid ""
"An instance of ``EmailPolicy`` with all defaults unchanged.  This policy "
"uses the standard Python ``\\n`` line endings rather than the RFC-correct ``"
"\\r\\n``."
msgstr ""
"所有預設值均未更改的 ``EmailPolicy`` 實例。此策略使用標準的 Python ``\\n"
"`` 行結尾而不是 RFC 正確的``\\r\\n"
"``。"

#: ../../library/email.policy.rst:527
#, fuzzy
msgid ""
"Suitable for serializing messages in conformance with the email RFCs. Like "
"``default``, but with ``linesep`` set to ``\\r\\n``, which is RFC compliant."
msgstr ""
"適用於按照電子郵件 RFC 序列化消息。類似於 ``default``，但 ``linesep`` 設定為 "
"``\\r\\n"
"``，這是符合 RFC 的。"

#: ../../library/email.policy.rst:534
#, fuzzy
msgid ""
"The same as ``SMTP`` except that :attr:`~EmailPolicy.utf8` is ``True``. "
"Useful for serializing messages to a message store without using encoded "
"words in the headers.  Should only be used for SMTP transmission if the "
"sender or recipient addresses have non-ASCII characters (the :meth:`smtplib."
"SMTP.send_message` method handles this automatically)."
msgstr ""
"除了 :attr:`~EmailPolicy.utf8` 為 ``True`` 之外，與 ``SMTP`` "
"相同。用於將消息序列化到消息儲存而不使用標頭中的編碼字。"
"如果發件人或收件人地址具有非 ASCII 字元（:meth:`smtplib.SMTP.send_message` "
"方法自動處理此問題），則應僅用於 SMTP 傳輸。"

#: ../../library/email.policy.rst:543
#, fuzzy
msgid ""
"Suitable for serializing headers with for use in HTTP traffic.  Like "
"``SMTP`` except that ``max_line_length`` is set to ``None`` (unlimited)."
msgstr ""
"適用於序列化標頭以用於 HTTP 流量。與 ``SMTP`` 類似，除了 ``max_line_length`` "
"設定為 ``None``（無限制）。"

#: ../../library/email.policy.rst:549
#, fuzzy
msgid ""
"Convenience instance.  The same as ``default`` except that "
"``raise_on_defect`` is set to ``True``.  This allows any policy to be made "
"strict by writing::"
msgstr "便利實例。除了將 raise_on_defect 設定為 True 之外，與 default "
"相同。這允許通過編寫來使任何策略變得嚴格："

#: ../../library/email.policy.rst:556
#, fuzzy
msgid ""
"With all of these :class:`EmailPolicies <.EmailPolicy>`, the effective API "
"of the email package is changed from the Python 3.2 API in the following "
"ways:"
msgstr ""
"對於所有這些 :class:`EmailPolicies <.EmailPolicy>`，電子郵件包的有效 API 從 "
"Python 3.2 API 以下列方式更改："

#: ../../library/email.policy.rst:559
#, fuzzy
msgid ""
"Setting a header on a :class:`~email.message.Message` results in that header "
"being parsed and a header object created."
msgstr "在 :class:`~email.message.Message` 上設定標題會導致解析該標題並建立標題物件。"

#: ../../library/email.policy.rst:562
#, fuzzy
msgid ""
"Fetching a header value from a :class:`~email.message.Message` results in "
"that header being parsed and a header object created and returned."
msgstr "從 :class:`~email.message.Message` "
"獲取標頭值會導致解析該標頭並建立並回傳標頭物件。"

#: ../../library/email.policy.rst:566
#, fuzzy
msgid ""
"Any header object, or any header that is refolded due to the policy "
"settings, is folded using an algorithm that fully implements the RFC folding "
"algorithms, including knowing where encoded words are required and allowed."
msgstr "任何標頭對像或由於策略設定而重新折疊的任何標頭都使用完全實作 RFC "
"折疊演算法的演算法折疊，包括了解需要和允許編碼字的位置。"

#: ../../library/email.policy.rst:571
#, fuzzy
msgid ""
"From the application view, this means that any header obtained through the :"
"class:`~email.message.EmailMessage` is a header object with extra "
"attributes, whose string value is the fully decoded unicode value of the "
"header.  Likewise, a header may be assigned a new value, or a new header "
"created, using a unicode string, and the policy will take care of converting "
"the unicode string into the correct RFC encoded form."
msgstr ""
"從應用程式的角度來看，這意味著通過 :class:`~email.message.EmailMessage` "
"獲得的任何標頭都是具有額外屬性的標頭物件，其字串值是標頭的完全解碼的 unicode "
"值。同樣，可以使用 unicode 字串為標頭分配新值或建立新標頭，並且策略將負責將 "
"unicode 字串轉換為正確的 RFC 編碼形式。"

#: ../../library/email.policy.rst:578
#, fuzzy
msgid ""
"The header objects and their attributes are described in :mod:`~email."
"headerregistry`."
msgstr "標頭物件及其屬性在 :mod:`~email.headerregistry` 中描述。"

#: ../../library/email.policy.rst:585
#, fuzzy
msgid ""
"This concrete :class:`Policy` is the backward compatibility policy.  It "
"replicates the behavior of the email package in Python 3.2.  The :mod:"
"`~email.policy` module also defines an instance of this class, :const:"
"`compat32`, that is used as the default policy.  Thus the default behavior "
"of the email package is to maintain compatibility with Python 3.2."
msgstr ""
"這個具體的 :class:`Policy` 是向後相容策略。它複製了 Python 3.2 "
"中電子郵件包的行為。 :mod:`~email.policy` "
"模組還定義了此類的一個實例，:const:`compat32`，用作預設策略。因此，"
"電子郵件包的預設行為是保持與 Python 3.2 的相容性。"

#: ../../library/email.policy.rst:591
#, fuzzy
msgid ""
"The following attributes have values that are different from the :class:"
"`Policy` default:"
msgstr "以下屬性的值不同於 :class:`Policy` 預設值："

#: ../../library/email.policy.rst:597
#, fuzzy
msgid "The default is ``True``."
msgstr "預設值為 ``True``。"

#: ../../library/email.policy.rst:614
#, fuzzy
msgid "The name and value are returned unmodified."
msgstr "名稱和值原封不動地回傳。"

#: ../../library/email.policy.rst:619
#, fuzzy
msgid ""
"If the value contains binary data, it is converted into a :class:`~email."
"header.Header` object using the ``unknown-8bit`` charset. Otherwise it is "
"returned unmodified."
msgstr ""
"如果該值包含二進位資料，則使用 ``unknown-8bit`` 字元集將其轉換為 "
":class:`~email.header.Header` 物件。否則回傳原樣。"

#: ../../library/email.policy.rst:626
#, fuzzy
msgid ""
"Headers are folded using the :class:`~email.header.Header` folding "
"algorithm, which preserves existing line breaks in the value, and wraps each "
"resulting line to the ``max_line_length``.  Non-ASCII binary data are CTE "
"encoded using the ``unknown-8bit`` charset."
msgstr ""
"使用 :class:`~email.header.Header` "
"折疊演算法折疊標題，該演算法保留值中現有的換行符，並將每個結果行包裝到 "
"``max_line_length``。非 ASCII 二進位資料使用 ``unknown-8bit`` 字元集進行 CTE "
"編碼。"

#: ../../library/email.policy.rst:634
#, fuzzy
msgid ""
"Headers are folded using the :class:`~email.header.Header` folding "
"algorithm, which preserves existing line breaks in the value, and wraps each "
"resulting line to the ``max_line_length``.  If ``cte_type`` is ``7bit``, non-"
"ascii binary data is CTE encoded using the ``unknown-8bit`` charset.  "
"Otherwise the original source header is used, with its existing line breaks "
"and any (RFC invalid) binary data it may contain."
msgstr ""
"使用 :class:`~email.header.Header` "
"折疊演算法折疊標題，該演算法保留值中現有的換行符，並將每個結果行包裝到 "
"``max_line_length``。如果 ``cte_type`` 是 ``7bit``，非 ascii 二進位資料使用 "
"``unknown-8bit`` 字元集進行 CTE "
"編碼。否則將使用原始源頭，以及它現有的換行符和它可能包含的任何（RFC "
"無效的）二進位資料。"

#: ../../library/email.policy.rst:644
#, fuzzy
msgid ""
"An instance of :class:`Compat32`, providing  backward compatibility with the "
"behavior of the email package in Python 3.2."
msgstr ":class:`Compat32` 的實例，提供與 Python 3.2 中電子郵件包行為的向後相容性。"

#: ../../library/email.policy.rst:649
msgid "Footnotes"
msgstr "註解"

#: ../../library/email.policy.rst:650
#, fuzzy
msgid ""
"Originally added in 3.3 as a :term:`provisional feature <provisional "
"package>`."
msgstr "最初在 3.3 中新增為 :term:`臨時功能 <provisional package>`。"
