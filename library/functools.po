# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-23 00:17+0000\n"
"PO-Revision-Date: 2018-05-23 16:02+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/functools.rst:2
msgid ""
":mod:`functools` --- Higher-order functions and operations on callable "
"objects"
msgstr ":mod:`functools` --- 可呼叫物件的高階函式和操作"

#: ../../library/functools.rst:14
msgid "**Source code:** :source:`Lib/functools.py`"
msgstr "**原始碼：**\\ :source:`Lib/functools.py`"

#: ../../library/functools.rst:23
#, fuzzy
msgid ""
"The :mod:`functools` module is for higher-order functions: functions that "
"act on or return other functions. In general, any callable object can be "
"treated as a function for the purposes of this module."
msgstr ":mod:`functools` 模組用於高階函式：作用於或回傳其他函式的函式。通常，出於此模"
"組的目的，任何可呼叫對像都可以視為函式。"

#: ../../library/functools.rst:27
#, fuzzy
msgid "The :mod:`functools` module defines the following functions:"
msgstr ":mod:`functools` 模組定義了以下函式："

#: ../../library/functools.rst:31
#, fuzzy
msgid ""
"Simple lightweight unbounded function cache.  Sometimes called `\"memoize\" "
"<https://en.wikipedia.org/wiki/Memoization>`_."
msgstr ""
"簡單的輕量級無界函式快取。有時稱為 ``memoize`` <https://en.wikipedia.org/wiki/"
"Memoization>`_。"

#: ../../library/functools.rst:34
#, fuzzy
msgid ""
"Returns the same as ``lru_cache(maxsize=None)``, creating a thin wrapper "
"around a dictionary lookup for the function arguments.  Because it never "
"needs to evict old values, this is smaller and faster than :func:"
"`lru_cache()` with a size limit."
msgstr ""
"回傳與 ``lru_cache(maxsize=None)`` "
"相同，為函式參數的字典查找建立一個薄包裝。因為它永遠不需要驅逐舊值，"
"所以它比具有大小限制的 lru_cache() 更小更快。"

#: ../../library/functools.rst:39 ../../library/functools.rst:283
msgid "For example::"
msgstr ""
"舉例來說：\n"
"\n"
"::"

#: ../../library/functools.rst:52 ../../library/functools.rst:151
#, fuzzy
msgid ""
"The cache is threadsafe so that the wrapped function can be used in multiple "
"threads.  This means that the underlying data structure will remain coherent "
"during concurrent updates."
msgstr "快取是執行緒安全的，因此包裝函式可以在多個執行緒中使用。這意味著底層資料結構"
"將在並發更新期間保持一致。"

#: ../../library/functools.rst:56 ../../library/functools.rst:155
#, fuzzy
msgid ""
"It is possible for the wrapped function to be called more than once if "
"another thread makes an additional call before the initial call has been "
"completed and cached."
msgstr "如果另一個執行緒在初始呼叫完成並快取之前進行額外呼叫，則包裝函式可能會被多次"
"呼叫。"

#: ../../library/functools.rst:65
#, fuzzy
msgid ""
"Transform a method of a class into a property whose value is computed once "
"and then cached as a normal attribute for the life of the instance. Similar "
"to :func:`property`, with the addition of caching. Useful for expensive "
"computed properties of instances that are otherwise effectively immutable."
msgstr ""
"將類的方法轉換為屬性，其值計算一次，然後在實例的生命週期內作為普通屬性快取。"
"類似於 :func:`property`，增加了快取。對於實例的昂貴計算屬性很有用，否則這些屬"
"性實際上是不可變的。"

#: ../../library/functools.rst:70 ../../library/functools.rst:135
#: ../../library/functools.rst:375
msgid "Example::"
msgstr ""
"範例：\n"
"\n"
"::"

#: ../../library/functools.rst:81
#, fuzzy
msgid ""
"The mechanics of :func:`cached_property` are somewhat different from :func:"
"`property`.  A regular property blocks attribute writes unless a setter is "
"defined. In contrast, a *cached_property* allows writes."
msgstr ""
":func:`cached_property` 的機制與 :func:`property` 有所不同。除非定義了 "
"setter，否則常規屬性會阻止屬性寫入。相反，*cached_property* 允許寫入。"

#: ../../library/functools.rst:85
#, fuzzy
msgid ""
"The *cached_property* decorator only runs on lookups and only when an "
"attribute of the same name doesn't exist.  When it does run, the "
"*cached_property* writes to the attribute with the same name. Subsequent "
"attribute reads and writes take precedence over the *cached_property* method "
"and it works like a normal attribute."
msgstr ""
"*cached_property* 裝飾器僅在查找時運行，並且僅在不存在同名屬性時運行。當它運"
"行時，*cached_property* 會寫入具有相同名稱的屬性。隨後的屬性讀取和寫入優先於 "
"*cached_property* 方法，它像普通屬性一樣工作。"

#: ../../library/functools.rst:91
#, fuzzy
msgid ""
"The cached value can be cleared by deleting the attribute.  This allows the "
"*cached_property* method to run again."
msgstr "可以通過刪除屬性來清除快取的值。這允許 *cached_property* 方法再次運行。"

#: ../../library/functools.rst:94
#, fuzzy
msgid ""
"Note, this decorator interferes with the operation of :pep:`412` key-sharing "
"dictionaries.  This means that instance dictionaries can take more space "
"than usual."
msgstr "請注意，此裝飾器會干擾 :pep:`412` "
"密鑰共享字典的操作。這意味著實例字典可以佔用比平時更多的空間。"

#: ../../library/functools.rst:98
#, fuzzy
msgid ""
"Also, this decorator requires that the ``__dict__`` attribute on each "
"instance be a mutable mapping. This means it will not work with some types, "
"such as metaclasses (since the ``__dict__`` attributes on type instances are "
"read-only proxies for the class namespace), and those that specify "
"``__slots__`` without including ``__dict__`` as one of the defined slots (as "
"such classes don't provide a ``__dict__`` attribute at all)."
msgstr ""
"此外，這個裝飾器要求每個實例上的 ``__dict__`` "
"屬性是一個可變映射。這意味著它不適用於某些型別，例如元類（因為型別實例上的 "
"__dict__ 屬性是類命名空間的只讀代理），以及那些指定 __slots__ 而不包括 "
"__dict__ 的型別`` 作為定義的插槽之一（因為此類根本不提供 ``__dict__`` "
"屬性）。"

#: ../../library/functools.rst:105
#, fuzzy
msgid ""
"If a mutable mapping is not available or if space-efficient key sharing is "
"desired, an effect similar to :func:`cached_property` can be achieved by a "
"stacking :func:`property` on top of :func:`cache`::"
msgstr ""
"如果可變映射不可用，或者如果需要節省空間的密鑰共享，則可以通過在 "
":func:`cache` 之上堆疊 :func:`property` 來實作類似於 :func:`cached_property` "
"的效果："

#: ../../library/functools.rst:123
#, fuzzy
msgid ""
"Transform an old-style comparison function to a :term:`key function`.  Used "
"with tools that accept key functions (such as :func:`sorted`, :func:`min`, :"
"func:`max`, :func:`heapq.nlargest`, :func:`heapq.nsmallest`, :func:"
"`itertools.groupby`).  This function is primarily used as a transition tool "
"for programs being converted from Python 2 which supported the use of "
"comparison functions."
msgstr ""
"將舊式比較函式轉換為 :term:`key function`。與接受鍵函式的工具一起使用（例如："
"func:`sorted`、:func:`min`、:func:`max`、:func:`heapq.nlargest`、:func:`heapq"
".nsmallest`、 :func:`itertools.groupby`）。"
"此函式主要用作從支援使用比較函式的 Python 2 轉換的程式的轉換工具。"

#: ../../library/functools.rst:130
#, fuzzy
msgid ""
"A comparison function is any callable that accepts two arguments, compares "
"them, and returns a negative number for less-than, zero for equality, or a "
"positive number for greater-than.  A key function is a callable that accepts "
"one argument and returns another value to be used as the sort key."
msgstr ""
"比較函式是任何可呼叫的，它接受兩個參數，比較它們，並回傳負數表示小於，零表示"
"相等，或正數表示大於。鍵函式是一個可呼叫函式，它接受一個參數並回傳另一個值以"
"用作排序鍵。"

#: ../../library/functools.rst:139
#, fuzzy
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr "有關排序示例和簡短的排序教程，請參閱 :ref:`sortinghowto`。"

#: ../../library/functools.rst:147
#, fuzzy
msgid ""
"Decorator to wrap a function with a memoizing callable that saves up to the "
"*maxsize* most recent calls.  It can save time when an expensive or I/O "
"bound function is periodically called with the same arguments."
msgstr "裝飾器用可保存最多 *maxsize* 最近呼叫的可記憶呼叫來包裝函式。"
"當使用相同參數定期呼叫昂貴或 I/O 綁定函式時，它可以節省時間。"

#: ../../library/functools.rst:159
#, fuzzy
msgid ""
"Since a dictionary is used to cache results, the positional and keyword "
"arguments to the function must be :term:`hashable`."
msgstr "由於字典用於快取結果，因此函式的位置參數和關鍵字參數必須是 :term:`hashable`。"

#: ../../library/functools.rst:162
#, fuzzy
msgid ""
"Distinct argument patterns may be considered to be distinct calls with "
"separate cache entries.  For example, ``f(a=1, b=2)`` and ``f(b=2, a=1)`` "
"differ in their keyword argument order and may have two separate cache "
"entries."
msgstr ""
"不同的參數模式可以被認為是具有單獨快取條目的不同呼叫。例如，``f(a=1, b=2)`` "
"和 ``f(b=2, a=1)`` 的關鍵字參數順序不同，可能有兩個單獨的快取條目。"

#: ../../library/functools.rst:167
#, fuzzy
msgid ""
"If *user_function* is specified, it must be a callable. This allows the "
"*lru_cache* decorator to be applied directly to a user function, leaving the "
"*maxsize* at its default value of 128::"
msgstr ""
"如果指定了 *user_function*，則它必須是可呼叫的。這允許 *lru_cache* "
"裝飾器直接應用於使用者函式，將 *maxsize* 保留為預設值 128::"

#: ../../library/functools.rst:175
#, fuzzy
msgid ""
"If *maxsize* is set to ``None``, the LRU feature is disabled and the cache "
"can grow without bound."
msgstr "如果 *maxsize* 設定為 ``None``，LRU 功能將被禁用，快取可以無限制地增長。"

#: ../../library/functools.rst:178
#, fuzzy
msgid ""
"If *typed* is set to true, function arguments of different types will be "
"cached separately.  If *typed* is false, the implementation will usually "
"regard them as equivalent calls and only cache a single result. (Some types "
"such as *str* and *int* may be cached separately even when *typed* is false.)"
msgstr ""
"如果 *typed* 設定為 true，不同型別的函式參數將被單獨快取。如果 *typed* 為 "
"false，實作通常會將它們視為等效呼叫並且只快取單個結果。 （某些型別如 *str* "
"和 *int* 可能會單獨快取，即使 *typed* 為 false。）"

#: ../../library/functools.rst:184
#, fuzzy
msgid ""
"Note, type specificity applies only to the function's immediate arguments "
"rather than their contents.  The scalar arguments, ``Decimal(42)`` and "
"``Fraction(42)`` are be treated as distinct calls with distinct results. In "
"contrast, the tuple arguments ``('answer', Decimal(42))`` and ``('answer', "
"Fraction(42))`` are treated as equivalent."
msgstr ""
"請注意，型別特異性僅適用於函式的直接參數而不是它們的內容。標量參數“Decimal(42"
")”和“Fraction(42)”被視為具有不同結果的不同呼叫。相反，元組參數``('answer', "
"Decimal(42))`` 和``('answer', Fraction(42))`` 被視為等價的。"

#: ../../library/functools.rst:190
#, fuzzy
msgid ""
"The wrapped function is instrumented with a :func:`cache_parameters` "
"function that returns a new :class:`dict` showing the values for *maxsize* "
"and *typed*.  This is for information purposes only.  Mutating the values "
"has no effect."
msgstr ""
"包裝函式使用 :func:`cache_parameters` 函式進行檢測，該函式回傳一個新的 "
":class:`dict` 顯示 *maxsize* 和 *typed* 的值。這僅供參考。改變值沒有效果。"

#: ../../library/functools.rst:195
#, fuzzy
msgid ""
"To help measure the effectiveness of the cache and tune the *maxsize* "
"parameter, the wrapped function is instrumented with a :func:`cache_info` "
"function that returns a :term:`named tuple` showing *hits*, *misses*, "
"*maxsize* and *currsize*."
msgstr ""
"為了幫助衡量快取的有效性並調整 *maxsize* 參數，包裝函式使用 cache_info "
"函式進行檢測，該函式回傳一個 named tuple 顯示*hits*、*misses*、*最大尺寸* 和 "
"*currsize*。"

#: ../../library/functools.rst:200
#, fuzzy
msgid ""
"The decorator also provides a :func:`cache_clear` function for clearing or "
"invalidating the cache."
msgstr "裝飾器還提供了一個 :func:`cache_clear` 函式來清除或使快取無效。"

#: ../../library/functools.rst:203
#, fuzzy
msgid ""
"The original underlying function is accessible through the :attr:"
"`__wrapped__` attribute.  This is useful for introspection, for bypassing "
"the cache, or for rewrapping the function with a different cache."
msgstr "可以通過 :attr:`__wrapped__` 屬性訪問原始底層函式。這對於內省、繞過快取或使用"
"不同的快取重新包裝函式很有用。"

#: ../../library/functools.rst:207
#, fuzzy
msgid ""
"The cache keeps references to the arguments and return values until they age "
"out of the cache or until the cache is cleared."
msgstr "快取保留對參數和回傳值的引用，直到它們從快取中老化或快取被清除。"

#: ../../library/functools.rst:210
#, fuzzy
msgid ""
"If a method is cached, the ``self`` instance argument is included in the "
"cache.  See :ref:`faq-cache-method-calls`"
msgstr "如果一個方法被快取，``self`` 實例參數被包含在快取中。請參閱 :ref:`faq-cache-"
"method-calls`"

#: ../../library/functools.rst:213
#, fuzzy
msgid ""
"An `LRU (least recently used) cache <https://en.wikipedia.org/wiki/"
"Cache_replacement_policies#Least_recently_used_(LRU)>`_ works best when the "
"most recent calls are the best predictors of upcoming calls (for example, "
"the most popular articles on a news server tend to change each day).  The "
"cache's size limit assures that the cache does not grow without bound on "
"long-running processes such as web servers."
msgstr ""
"`LRU（最近最少使用）快取<https://en.wikipedia.org/wiki/Cache_replacement_poli"
"cies#Least_recently_used_(LRU)>`當最近的呼叫是即將到來的呼叫的最佳預測因子時"
"（例如，新聞伺服器上最受歡迎的文章往往每天都在變化）。快取的大小限制確保快取"
"不會隨著長時間運行的行程（如 Web 伺服器）的限製而增長。"

#: ../../library/functools.rst:220
#, fuzzy
msgid ""
"In general, the LRU cache should only be used when you want to reuse "
"previously computed values.  Accordingly, it doesn't make sense to cache "
"functions with side-effects, functions that need to create distinct mutable "
"objects on each call, or impure functions such as time() or random()."
msgstr ""
"一般來說，LRU "
"快取應該只在你想重用以前計算的值時使用。因此，快取有副作用的函式、"
"需要在每次呼叫時建立不同的可變物件的函式或諸如 time() 或 random() "
"之類的不純函式是沒有意義的。"

#: ../../library/functools.rst:225
#, fuzzy
msgid "Example of an LRU cache for static web content::"
msgstr "靜態網頁內容的 LRU 快取示例："

#: ../../library/functools.rst:244
#, fuzzy
msgid ""
"Example of efficiently computing `Fibonacci numbers <https://en.wikipedia."
"org/wiki/Fibonacci_number>`_ using a cache to implement a `dynamic "
"programming <https://en.wikipedia.org/wiki/Dynamic_programming>`_ technique::"
msgstr ""
"高效計算`Fibonacci 數 <https://en.wikipedia.org/wiki/Fibonacci_number>`_ "
"使用快取實作`動態編程 <https://en.wikipedia.org/wiki/"
"Dynamic_programming>`_技術：："

#: ../../library/functools.rst:264
msgid "Added the *typed* option."
msgstr "新增 *typed* 選項。"

#: ../../library/functools.rst:267
msgid "Added the *user_function* option."
msgstr "新增 *user_function* 選項。"

#: ../../library/functools.rst:270
msgid "Added the function :func:`cache_parameters`"
msgstr "新增 :func:`cache_parameters` 函式。"

#: ../../library/functools.rst:275
#, fuzzy
msgid ""
"Given a class defining one or more rich comparison ordering methods, this "
"class decorator supplies the rest.  This simplifies the effort involved in "
"specifying all of the possible rich comparison operations:"
msgstr "給定一個定義了一個或多個豐富的比較排序方法的類，該類裝飾器提供其餘部分。這簡"
"化了指定所有可能的豐富比較操作所涉及的工作："

#: ../../library/functools.rst:279
#, fuzzy
msgid ""
"The class must define one of :meth:`__lt__`, :meth:`__le__`, :meth:`__gt__`, "
"or :meth:`__ge__`. In addition, the class should supply an :meth:`__eq__` "
"method."
msgstr ""
"該類必須定義 :meth:`__lt__`、:meth:`__le__`、:meth:`__gt__` 或 :meth:`__ge__`"
" 之一。此外，該類應提供一個 :meth:`__eq__` 方法。"

#: ../../library/functools.rst:303
#, fuzzy
msgid ""
"While this decorator makes it easy to create well behaved totally ordered "
"types, it *does* come at the cost of slower execution and more complex stack "
"traces for the derived comparison methods. If performance benchmarking "
"indicates this is a bottleneck for a given application, implementing all six "
"rich comparison methods instead is likely to provide an easy speed boost."
msgstr ""
"雖然這個裝飾器使得建立行為良好的完全有序型別變得容易，但它*確實*以更慢的執行"
"速度和更複雜的派生比較方法的堆疊跟踪為代價。如果性能基準測試表明這是給定應用"
"程式的瓶頸，那麼實施所有六種豐富的比較方法可能會提供輕鬆的速度提升。"

#: ../../library/functools.rst:312
#, fuzzy
msgid ""
"This decorator makes no attempt to override methods that have been declared "
"in the class *or its superclasses*. Meaning that if a superclass defines a "
"comparison operator, *total_ordering* will not implement it again, even if "
"the original method is abstract."
msgstr ""
"此裝飾器不會嘗試覆蓋已在類 * 或其超類 * "
"中聲明的方法。這意味著如果超類定義了比較運算符，*total_ordering* "
"將不會再次實作它，即使原始方法是抽象的。"

#: ../../library/functools.rst:319
#, fuzzy
msgid ""
"Returning NotImplemented from the underlying comparison function for "
"unrecognised types is now supported."
msgstr "現在支援從無法識別的型別的底層比較函式回傳 NotImplemented。"

#: ../../library/functools.rst:325
#, fuzzy
msgid ""
"Return a new :ref:`partial object<partial-objects>` which when called will "
"behave like *func* called with the positional arguments *args* and keyword "
"arguments *keywords*. If more arguments are supplied to the call, they are "
"appended to *args*. If additional keyword arguments are supplied, they "
"extend and override *keywords*. Roughly equivalent to::"
msgstr ""
"回傳一個新的 :ref:`partial object<partial-objects>` ，"
"它在被呼叫時的行為類似於 *func* ，使用位置參數 *args* 和關鍵字參數 *keywords*"
" 呼叫。如果向呼叫提供了更多參數，它們將附加到 "
"*args*。如果提供了額外的關鍵字參數，它們將擴充並覆蓋 *keywords*。大致相當於::"

#: ../../library/functools.rst:341
#, fuzzy
msgid ""
"The :func:`partial` is used for partial function application which "
"\"freezes\" some portion of a function's arguments and/or keywords resulting "
"in a new object with a simplified signature.  For example, :func:`partial` "
"can be used to create a callable that behaves like the :func:`int` function "
"where the *base* argument defaults to two:"
msgstr ""
":func:`partial` 用於部分函式應用程式，它“凍結”函式參數和/或關鍵字的某些部分，"
"從而生成具有簡化簽名的新物件。例如，:func:`partial` 可用於建立一個行為類似於 "
":func:`int` 函式的可呼叫函式，其中 *base* 參數預設為兩個："

#: ../../library/functools.rst:356
#, fuzzy
msgid ""
"Return a new :class:`partialmethod` descriptor which behaves like :class:"
"`partial` except that it is designed to be used as a method definition "
"rather than being directly callable."
msgstr ""
"回傳一個新的 :class:`partialmethod` 描述器，其行為類似於 :class:`partial` "
"除了它被設計為用作方法定義而不是直接可呼叫。"

#: ../../library/functools.rst:360
#, fuzzy
msgid ""
"*func* must be a :term:`descriptor` or a callable (objects which are both, "
"like normal functions, are handled as descriptors)."
msgstr "*func* 必須是一個 :term:`descriptor` "
"或一個可呼叫物件（兩者都是的物件，就像普通函式一樣，被作為描述器處理）。"

#: ../../library/functools.rst:363
#, fuzzy
msgid ""
"When *func* is a descriptor (such as a normal Python function, :func:"
"`classmethod`, :func:`staticmethod`, :func:`abstractmethod` or another "
"instance of :class:`partialmethod`), calls to ``__get__`` are delegated to "
"the underlying descriptor, and an appropriate :ref:`partial object<partial-"
"objects>` returned as the result."
msgstr ""
"當 *func* 是描述器時（例如普通的 Python "
"函式、:func:`classmethod`、:func:`staticmethod`、:func:`abstractmethod` 或 "
":class:`partialmethod` 的另一個實例），呼叫 ` `__get__`` 被委託給底層描述器，"
"並回傳一個適當的 :ref:`partial object<partial-objects>` 作為結果。"

#: ../../library/functools.rst:369
#, fuzzy
msgid ""
"When *func* is a non-descriptor callable, an appropriate bound method is "
"created dynamically. This behaves like a normal Python function when used as "
"a method: the *self* argument will be inserted as the first positional "
"argument, even before the *args* and *keywords* supplied to the :class:"
"`partialmethod` constructor."
msgstr ""
"當 *func* 是非描述器可呼叫時，將動態建立適當的綁定方法。當用作方法時，"
"它的行為類似於普通的 Python 函式：*self* 參數將作為第一個位置參數插入，"
"甚至在提供給 :class:`partialmethod` 構造函式的 *args* 和 *keywords* 之前。"

#: ../../library/functools.rst:400
#, fuzzy
msgid ""
"Apply *function* of two arguments cumulatively to the items of *iterable*, "
"from left to right, so as to reduce the iterable to a single value.  For "
"example, ``reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])`` calculates "
"``((((1+2)+3)+4)+5)``. The left argument, *x*, is the accumulated value and "
"the right argument, *y*, is the update value from the *iterable*.  If the "
"optional *initializer* is present, it is placed before the items of the "
"iterable in the calculation, and serves as a default when the iterable is "
"empty.  If *initializer* is not given and *iterable* contains only one item, "
"the first item is returned."
msgstr ""
"從左到右將兩個參數的 *function* 累積應用於 *iterable* 的項目，以將 iterable "
"減少為單個值。例如，``reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])`` "
"計算``((((1+2)+3)+4)+5) ``。左邊的參數 *x* 是累加值，右邊的參數 *y* 是來自 "
"*iterable* 的更新值。如果可選的 *initializer* "
"存在，它在計算中被放置在可疊代的項目之前，並在可疊代為空時作為預設值。"
"如果未給出 *initializer* 且 *iterable* 僅包含一個項目，則回傳第一個項目。"

#: ../../library/functools.rst:409
#, fuzzy
msgid "Roughly equivalent to::"
msgstr "大致相當於::"

#: ../../library/functools.rst:421
#, fuzzy
msgid ""
"See :func:`itertools.accumulate` for an iterator that yields all "
"intermediate values."
msgstr "見 :func:`itertools.accumulate` 一個產生所有中間值的疊代器。"

#: ../../library/functools.rst:426
#, fuzzy
msgid ""
"Transform a function into a :term:`single-dispatch <single dispatch>` :term:"
"`generic function`."
msgstr ""
"將函式轉換為 :term:`single-dispatch <single dispatch>` :term:`generic "
"function`。"

#: ../../library/functools.rst:429
#, fuzzy
msgid ""
"To define a generic function, decorate it with the ``@singledispatch`` "
"decorator. When defining a function using ``@singledispatch``, note that the "
"dispatch happens on the type of the first argument::"
msgstr ""
"要定義通用函式，請使用 @singledispatch 裝飾器對其進行裝飾。使用“@singledispat"
"ch”定義函式時，請注意分派發生在第一個參數的型別上："

#: ../../library/functools.rst:440
#, fuzzy
msgid ""
"To add overloaded implementations to the function, use the :func:`register` "
"attribute of the generic function, which can be used as a decorator.  For "
"functions annotated with types, the decorator will infer the type of the "
"first argument automatically::"
msgstr ""
"要向函式新增重載實作，請使用通用函式的 :func:`register` 屬性，它可以用作裝飾"
"器。對於用型別註釋的函式，裝飾器將自動推斷第一個參數的型別::"

#: ../../library/functools.rst:458
#, fuzzy
msgid ":data:`types.UnionType` and :data:`typing.Union` can also be used::"
msgstr ":data:`types.UnionType` 和 :data:`typing.Union` 也可以使用::"

#: ../../library/functools.rst:475
#, fuzzy
msgid ""
"For code which doesn't use type annotations, the appropriate type argument "
"can be passed explicitly to the decorator itself::"
msgstr "對於不使用型別註釋的程式碼，可以將適當的型別參數顯式傳遞給裝飾器本身::"

#: ../../library/functools.rst:486
#, fuzzy
msgid ""
"To enable registering :term:`lambdas<lambda>` and pre-existing functions, "
"the :func:`register` attribute can also be used in a functional form::"
msgstr "要啟用註冊 :term:`lambdas<lambda>` 和預先存在的函式，:func:`register` "
"屬性也可以以函式形式使用::"

#: ../../library/functools.rst:494
#, fuzzy
msgid ""
"The :func:`register` attribute returns the undecorated function. This "
"enables decorator stacking, :mod:`pickling<pickle>`, and the creation of "
"unit tests for each variant independently::"
msgstr ""
":func:`register` "
"屬性回傳未修飾的函式。這使得裝飾器堆疊、:mod:`pickling<pickle>` "
"和獨立地為每個變體建立單元測試::"

#: ../../library/functools.rst:508
#, fuzzy
msgid ""
"When called, the generic function dispatches on the type of the first "
"argument::"
msgstr "呼叫時，通用函式會根據第一個參數的型別進行調度："

#: ../../library/functools.rst:528
#, fuzzy
msgid ""
"Where there is no registered implementation for a specific type, its method "
"resolution order is used to find a more generic implementation. The original "
"function decorated with ``@singledispatch`` is registered for the base :"
"class:`object` type, which means it is used if no better implementation is "
"found."
msgstr ""
"如果沒有針對特定型別的註冊實作，則使用其方法解析順序來查找更通用的實作。用``@"
"singledispatch`` 修飾的原始函式註冊為基本 :class:`object` "
"型別，這意味著如果找不到更好的實作則使用它。"

#: ../../library/functools.rst:534
#, fuzzy
msgid ""
"If an implementation is registered to an :term:`abstract base class`, "
"virtual subclasses of the base class will be dispatched to that "
"implementation::"
msgstr "如果一個實作註冊到抽象基底類別，基底類別的虛擬子類別將被分派到該實作::"

#: ../../library/functools.rst:549
#, fuzzy
msgid ""
"To check which implementation the generic function will choose for a given "
"type, use the ``dispatch()`` attribute::"
msgstr "要檢查通用函式將為給定型別選擇哪個實作，請使用 ``dispatch()`` 屬性："

#: ../../library/functools.rst:557
#, fuzzy
msgid ""
"To access all registered implementations, use the read-only ``registry`` "
"attribute::"
msgstr "要訪問所有已註冊的實作，請使用只讀的 ``registry`` 屬性::"

#: ../../library/functools.rst:571
#, fuzzy
msgid "The :func:`register` attribute now supports using type annotations."
msgstr ":func:`register` 屬性現在支援使用型別註釋。"

#: ../../library/functools.rst:574
#, fuzzy
msgid ""
"The :func:`register` attribute now supports :data:`types.UnionType` and :"
"data:`typing.Union` as type annotations."
msgstr ""
":func:`register` 屬性現在支援 :data:`types.UnionType` 和 :data:`typing.Union`"
" 作為型別註釋。"

#: ../../library/functools.rst:581
#, fuzzy
msgid ""
"Transform a method into a :term:`single-dispatch <single dispatch>` :term:"
"`generic function`."
msgstr ""
"將方法轉換為 :term:`single-dispatch <single dispatch>` :term:`generic "
"function`。"

#: ../../library/functools.rst:584
#, fuzzy
msgid ""
"To define a generic method, decorate it with the ``@singledispatchmethod`` "
"decorator. When defining a function using ``@singledispatchmethod``, note "
"that the dispatch happens on the type of the first non-*self* or non-*cls* "
"argument::"
msgstr ""
"要定義泛型方法，請使用 @singledispatchmethod 裝飾器對其進行裝飾。當使用“@sing"
"ledispatchmethod”定義函式時，請注意分派發生在第一個非*self* 或非*cls* "
"參數的型別上："

#: ../../library/functools.rst:602
#, fuzzy
msgid ""
"``@singledispatchmethod`` supports nesting with other decorators such as :"
"func:`@classmethod<classmethod>`. Note that to allow for ``dispatcher."
"register``, ``singledispatchmethod`` must be the *outer most* decorator. "
"Here is the ``Negator`` class with the ``neg`` methods bound to the class, "
"rather than an instance of the class::"
msgstr ""
"``@singledispatchmethod`` "
"支援與其他裝飾器嵌套，例如 :func:`@classmethod<classmethod>`。請注意，要允許 "
"``dispatcher.register``，``singledispatchmethod`` 必須是*最外層*裝飾器。"
"這是帶有綁定到該類的 ``neg`` 方法的 ``Negator`` 類，而不是該類的實例::"

#: ../../library/functools.rst:624
#, fuzzy
msgid ""
"The same pattern can be used for other similar decorators: :func:"
"`@staticmethod<staticmethod>`, :func:`@abstractmethod<abc.abstractmethod>`, "
"and others."
msgstr ""
"相同的模式可用於其他類似的裝飾器：:func:`@staticmethod<staticmethod>`、:func:"
"`@abstractmethod<abc.abstractmethod>` 等。"

#: ../../library/functools.rst:633
#, fuzzy
msgid ""
"Update a *wrapper* function to look like the *wrapped* function. The "
"optional arguments are tuples to specify which attributes of the original "
"function are assigned directly to the matching attributes on the wrapper "
"function and which attributes of the wrapper function are updated with the "
"corresponding attributes from the original function. The default values for "
"these arguments are the module level constants ``WRAPPER_ASSIGNMENTS`` "
"(which assigns to the wrapper function's ``__module__``, ``__name__``, "
"``__qualname__``, ``__annotations__`` and ``__doc__``, the documentation "
"string) and ``WRAPPER_UPDATES`` (which updates the wrapper function's "
"``__dict__``, i.e. the instance dictionary)."
msgstr ""
"更新 *wrapper* 函式使其看起來像 *wrapped* 函式。可選參數是元組，用於指定原始"
"函式的哪些屬性直接分配給包裝函式上的匹配屬性，以及包裝函式的哪些屬性使用原始"
"函式的相應屬性進行更新。這些參數的預設值是模組級常數``WRAPPER_ASSIGNMENTS``（"
"分配給包裝函式的``__module__``，``__name__``，``__qualname__``，``__annotatio"
"ns__`` 和``__doc__ ``，文檔字串）和``WRAPPER_UPDATES``（更新包裝函式的``__dic"
"t__``，即實例字典）。"

#: ../../library/functools.rst:643
#, fuzzy
msgid ""
"To allow access to the original function for introspection and other "
"purposes (e.g. bypassing a caching decorator such as :func:`lru_cache`), "
"this function automatically adds a ``__wrapped__`` attribute to the wrapper "
"that refers to the function being wrapped."
msgstr ""
"為了允許訪問原始函式以進行內省和其他目的（例如，繞過快取裝飾器，如 "
":func:`lru_cache`），此函式會自動向包裝器新增一個 ``__wrapped__`` "
"屬性，以引用被包裝的函式。"

#: ../../library/functools.rst:648
#, fuzzy
msgid ""
"The main intended use for this function is in :term:`decorator` functions "
"which wrap the decorated function and return the wrapper. If the wrapper "
"function is not updated, the metadata of the returned function will reflect "
"the wrapper definition rather than the original function definition, which "
"is typically less than helpful."
msgstr ""
"這個函式的主要用途是在 decorator 函式中，它包裝裝飾函式並回傳包裝器。如果包裝"
"函式未更新，則回傳函式的元資料將反映包裝定義而不是原始函式定義，這通常沒有幫"
"助。"

#: ../../library/functools.rst:654
#, fuzzy
msgid ""
":func:`update_wrapper` may be used with callables other than functions. Any "
"attributes named in *assigned* or *updated* that are missing from the object "
"being wrapped are ignored (i.e. this function will not attempt to set them "
"on the wrapper function). :exc:`AttributeError` is still raised if the "
"wrapper function itself is missing any attributes named in *updated*."
msgstr ""
":func:`update_wrapper` 可以與函式以外的可呼叫對像一起使用。"
"被包裝的對像中缺少的任何在 *assigned* 或 *updated* "
"中命名的屬性都將被忽略（即，此函式不會嘗試在包裝函式上設定它們）。 "
":exc:`AttributeError` 如果包裝函式本身缺少 *updated* "
"中命名的任何屬性，仍然會引發。"

#: ../../library/functools.rst:660
#, fuzzy
msgid "Automatic addition of the ``__wrapped__`` attribute."
msgstr "自動新增 ``__wrapped__`` 屬性。"

#: ../../library/functools.rst:663
#, fuzzy
msgid "Copying of the ``__annotations__`` attribute by default."
msgstr "預設情況下複製 ``__annotations__`` 屬性。"

#: ../../library/functools.rst:666
#, fuzzy
msgid "Missing attributes no longer trigger an :exc:`AttributeError`."
msgstr "缺少的屬性不再觸發 :exc:`AttributeError`。"

#: ../../library/functools.rst:669
#, fuzzy
msgid ""
"The ``__wrapped__`` attribute now always refers to the wrapped function, "
"even if that function defined a ``__wrapped__`` attribute. (see :issue:"
"`17482`)"
msgstr ""
"``__wrapped__`` 屬性現在始終引用包裝函式，即使該函式定義了 ``__wrapped__`` "
"屬性。 （參見 :issue:`17482`）"

#: ../../library/functools.rst:677
#, fuzzy
msgid ""
"This is a convenience function for invoking :func:`update_wrapper` as a "
"function decorator when defining a wrapper function.  It is equivalent to "
"``partial(update_wrapper, wrapped=wrapped, assigned=assigned, "
"updated=updated)``. For example::"
msgstr ""
"這是一個方便的函式，用於在定義包裝器函式時呼叫 update_wrapper "
"作為函式裝飾器。它相當於``partial(update_wrapper, wrapped=wrapped, "
"assigned=assigned, updated=updated)``。例如：："

#: ../../library/functools.rst:703
#, fuzzy
msgid ""
"Without the use of this decorator factory, the name of the example function "
"would have been ``'wrapper'``, and the docstring of the original :func:"
"`example` would have been lost."
msgstr "如果不使用這個裝飾器工廠，示例函式的名稱將是 ``'wrapper'``，原始 "
":func:`example` 的文檔字串將會丟失。"

#: ../../library/functools.rst:711
msgid ":class:`partial` Objects"
msgstr ":class:`partial` 物件"

#: ../../library/functools.rst:713
#, fuzzy
msgid ""
":class:`partial` objects are callable objects created by :func:`partial`. "
"They have three read-only attributes:"
msgstr ":class:`partial` 對像是由 :func:`partial` "
"建立的可呼叫物件。它們具有三個只讀屬性："

#: ../../library/functools.rst:719
#, fuzzy
msgid ""
"A callable object or function.  Calls to the :class:`partial` object will be "
"forwarded to :attr:`func` with new arguments and keywords."
msgstr "可呼叫對像或函式。對 :class:`partial` 物件的呼叫將被轉發到 :attr:`func` "
"並帶有新的參數和關鍵字。"

#: ../../library/functools.rst:725
#, fuzzy
msgid ""
"The leftmost positional arguments that will be prepended to the positional "
"arguments provided to a :class:`partial` object call."
msgstr "最左邊的位置參數將被新增到提供給 :class:`partial` 物件呼叫的位置參數之前。"

#: ../../library/functools.rst:731
#, fuzzy
msgid ""
"The keyword arguments that will be supplied when the :class:`partial` object "
"is called."
msgstr "呼叫 :class:`partial` 物件時將提供的關鍵字參數。"

#: ../../library/functools.rst:734
#, fuzzy
msgid ""
":class:`partial` objects are like :class:`function` objects in that they are "
"callable, weak referencable, and can have attributes.  There are some "
"important differences.  For instance, the :attr:`~definition.__name__` and :"
"attr:`__doc__` attributes are not created automatically.  Also, :class:"
"`partial` objects defined in classes behave like static methods and do not "
"transform into bound methods during instance attribute look-up."
msgstr ""
":class:`partial` 對像類似於 :class:`function` 物件，因為它們是可呼叫的、弱可"
"引用的並且可以具有屬性。有一些重要的區別。例如，不會自動建立 "
":attr:`~definition.__name__` 和 :attr:`__doc__` 屬性。此外，在類中定義的 "
":class:`partial` "
"物件的行為類似於靜態方法，並且在實例屬性查找期間不會轉換為綁定方法。"
