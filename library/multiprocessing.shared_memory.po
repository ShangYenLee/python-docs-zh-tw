# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-09-26 00:21+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../library/multiprocessing.shared_memory.rst:2
msgid ""
":mod:`multiprocessing.shared_memory` --- Shared memory for direct access "
"across processes"
msgstr ":mod:`multiprocessing.shared_memory` --- 跨行程直接存取的共享記憶體"

#: ../../library/multiprocessing.shared_memory.rst:7
msgid "**Source code:** :source:`Lib/multiprocessing/shared_memory.py`"
msgstr "**原始碼：**\\ :source:`Lib/multiprocessing/shared_memory.py`"

#: ../../library/multiprocessing.shared_memory.rst:18
#, fuzzy
msgid ""
"This module provides a class, :class:`SharedMemory`, for the allocation and "
"management of shared memory to be accessed by one or more processes on a "
"multicore or symmetric multiprocessor (SMP) machine.  To assist with the "
"life-cycle management of shared memory especially across distinct processes, "
"a :class:`~multiprocessing.managers.BaseManager` subclass, :class:"
"`SharedMemoryManager`, is also provided in the ``multiprocessing.managers`` "
"module."
msgstr ""
"該模組提供了一個類 :class:`SharedMemory`，用於分配和管理多核或對稱多處理器 "
"(SMP) 機器上一個或多個行程存取的共享記憶體。為了協助共享記憶體的生命週期管理"
"，尤其是跨不同行程，``multiprocessing.managers`` 模組中還提供了一個 "
"SharedMemoryManager 子類別 :class:`~multiprocessing.managers.BaseManager` ."

#: ../../library/multiprocessing.shared_memory.rst:26
#, fuzzy
msgid ""
"In this module, shared memory refers to \"System V style\" shared memory "
"blocks (though is not necessarily implemented explicitly as such) and does "
"not refer to \"distributed shared memory\".  This style of shared memory "
"permits distinct processes to potentially read and write to a common (or "
"shared) region of volatile memory.  Processes are conventionally limited to "
"only have access to their own process memory space but shared memory permits "
"the sharing of data between processes, avoiding the need to instead send "
"messages between processes containing that data.  Sharing data directly via "
"memory can provide significant performance benefits compared to sharing data "
"via disk or socket or other communications requiring the serialization/"
"deserialization and copying of data."
msgstr ""
"在這個模組中，共享記憶體指的是“System V 風格”的共享記憶體塊（雖然不一定是這樣"
"明確實作的）而不是指“分佈式共享記憶體”。這種型別的共享記憶體允許不同的行程潛"
"在地讀取和寫入易失性記憶體的公開（或共享）區域。行程通常被限制為只能存取它們"
"自己的行程記憶體空間，但共享記憶體允許行程之間共享資料，避免需要在包含該資料"
"的行程之間發送消息。與通過磁盤或 socket 或其他需要序列化/反序列化和復制資料的通"
"信共享資料相比，直接通過記憶體共享資料可以提供顯著的性能優勢。"

#: ../../library/multiprocessing.shared_memory.rst:41
#, fuzzy
msgid ""
"Creates a new shared memory block or attaches to an existing shared memory "
"block.  Each shared memory block is assigned a unique name. In this way, one "
"process can create a shared memory block with a particular name and a "
"different process can attach to that same shared memory block using that "
"same name."
msgstr ""
"建立一個新的共享記憶體塊或附加到現有的共享記憶體塊。每個共享記憶體塊都被分配"
"了一個唯一的名稱。通過這種方式，一個行程可以建立一個具有特定名稱的共享記憶體"
"塊，而另一個行程可以使用相同的名稱附加到同一個共享記憶體塊。"

#: ../../library/multiprocessing.shared_memory.rst:47
#, fuzzy
msgid ""
"As a resource for sharing data across processes, shared memory blocks may "
"outlive the original process that created them.  When one process no longer "
"needs access to a shared memory block that might still be needed by other "
"processes, the :meth:`close()` method should be called. When a shared memory "
"block is no longer needed by any process, the :meth:`unlink()` method should "
"be called to ensure proper cleanup."
msgstr ""
"作為跨行程共享資料的資源，共享記憶體塊的壽命可能比建立它們的原始行程長。當一"
"個行程不再需要存取其他行程可能仍需要的共享記憶體塊時，應呼叫 :meth:`close()` "
"方法。當任何行程不再需要共享記憶體塊時，應呼叫 :meth:`unlink()` "
"方法以確保正確清理。"

#: ../../library/multiprocessing.shared_memory.rst:54
#, fuzzy
msgid ""
"*name* is the unique name for the requested shared memory, specified as a "
"string.  When creating a new shared memory block, if ``None`` (the default) "
"is supplied for the name, a novel name will be generated."
msgstr "*name* 是請求的共享記憶體的唯一名稱，指定為字串。建立新的共享記憶體塊時，如果"
"為名稱提供 ``None`` （預設值），則會生成一個新名稱。"

#: ../../library/multiprocessing.shared_memory.rst:58
#, fuzzy
msgid ""
"*create* controls whether a new shared memory block is created (``True``) or "
"an existing shared memory block is attached (``False``)."
msgstr "*create* 控制是建立新的共享記憶體塊（``True``）還是附加現有的共享記憶體塊（``"
"False``）。"

#: ../../library/multiprocessing.shared_memory.rst:61
#, fuzzy
msgid ""
"*size* specifies the requested number of bytes when creating a new shared "
"memory block.  Because some platforms choose to allocate chunks of memory "
"based upon that platform's memory page size, the exact size of the shared "
"memory block may be larger or equal to the size requested.  When attaching "
"to an existing shared memory block, the ``size`` parameter is ignored."
msgstr ""
"*size* 指定建立新共享記憶體塊時請求的位元組數。由於某些平台選擇根據該平台的記"
"憶體頁面大小分配記憶體塊，因此共享記憶體塊的確切大小可能大於或等於請求的大小"
"。當附加到現有的共享記憶體塊時，“大小”參數將被忽略。"

#: ../../library/multiprocessing.shared_memory.rst:69
#, fuzzy
msgid ""
"Closes access to the shared memory from this instance.  In order to ensure "
"proper cleanup of resources, all instances should call ``close()`` once the "
"instance is no longer needed.  Note that calling ``close()`` does not cause "
"the shared memory block itself to be destroyed."
msgstr ""
"關閉從此實例對共享記憶體的存取。為了確保正確清理資源，一旦實例不再需要，所有"
"實例都應呼叫“close()”。請注意，呼叫 ``close()`` "
"不會導致共享記憶體塊本身被銷毀。"

#: ../../library/multiprocessing.shared_memory.rst:77
#, fuzzy
msgid ""
"Requests that the underlying shared memory block be destroyed.  In order to "
"ensure proper cleanup of resources, ``unlink()`` should be called once (and "
"only once) across all processes which have need for the shared memory "
"block.  After requesting its destruction, a shared memory block may or may "
"not be immediately destroyed and this behavior may differ across platforms.  "
"Attempts to access data inside the shared memory block after ``unlink()`` "
"has been called may result in memory access errors.  Note: the last process "
"relinquishing its hold on a shared memory block may call ``unlink()`` and :"
"meth:`close()` in either order."
msgstr ""
"請求銷毀底層共享記憶體塊。為了確保正確清理資源，“unlink()”應該在所有需要共享"
"記憶體塊的行程中呼叫一次（且僅呼叫一次）。請求銷毀後，共享記憶體塊可能會或可"
"能不會立即銷毀，並且此行為可能因平台而異。在呼叫 unlink() "
"之後嘗試存取共享記憶體塊內的資料可能會導致記憶體存取錯誤。注意："
"最後一個放棄共享記憶體塊的行程可能會以任意順序呼叫 ``unlink()`` 和 "
":meth:`close()`。"

#: ../../library/multiprocessing.shared_memory.rst:90
#, fuzzy
msgid "A memoryview of contents of the shared memory block."
msgstr "共享記憶體塊內容的記憶體視圖。"

#: ../../library/multiprocessing.shared_memory.rst:94
#, fuzzy
msgid "Read-only access to the unique name of the shared memory block."
msgstr "只讀存取共享記憶體塊的唯一名稱。"

#: ../../library/multiprocessing.shared_memory.rst:98
#, fuzzy
msgid "Read-only access to size in bytes of the shared memory block."
msgstr "只讀存取共享記憶體塊的大小（以位元組為單位）。"

#: ../../library/multiprocessing.shared_memory.rst:101
#, fuzzy
msgid ""
"The following example demonstrates low-level use of :class:`SharedMemory` "
"instances::"
msgstr "以下示例演示了 SharedMemory 實例的低階使用："

#: ../../library/multiprocessing.shared_memory.rst:127
#, fuzzy
msgid ""
"The following example demonstrates a practical use of the :class:"
"`SharedMemory` class with `NumPy arrays <https://numpy.org/>`_, accessing "
"the same ``numpy.ndarray`` from two distinct Python shells:"
msgstr ""
"以下示例演示了 :class:`SharedMemory` 類與 `NumPy 數組 <https://numpy.org/>`_ "
"的實際使用，從兩個不同的 Python shell 存取相同的 ``numpy.ndarray``："

#: ../../library/multiprocessing.shared_memory.rst:181
#, fuzzy
msgid ""
"A subclass of :class:`~multiprocessing.managers.BaseManager` which can be "
"used for the management of shared memory blocks across processes."
msgstr ":class:`~multiprocessing.managers.BaseManager` "
"的子類別，可用於跨行程管理共享記憶體塊。"

#: ../../library/multiprocessing.shared_memory.rst:184
#, fuzzy
msgid ""
"A call to :meth:`~multiprocessing.managers.BaseManager.start` on a :class:"
"`SharedMemoryManager` instance causes a new process to be started. This new "
"process's sole purpose is to manage the life cycle of all shared memory "
"blocks created through it.  To trigger the release of all shared memory "
"blocks managed by that process, call :meth:`~multiprocessing.managers."
"BaseManager.shutdown()` on the instance. This triggers a :meth:`SharedMemory."
"unlink()` call on all of the :class:`SharedMemory` objects managed by that "
"process and then stops the process itself.  By creating ``SharedMemory`` "
"instances through a ``SharedMemoryManager``, we avoid the need to manually "
"track and trigger the freeing of shared memory resources."
msgstr ""
"在 SharedMemoryManager 實例上呼叫 :meth:`~multiprocessing.managers."
"BaseManager.start` 會啟動一個新行程。這個新行程的唯一目的是管理通過它建立的所"
"有共享記憶體塊的生命週期。要觸發該行程管理的所有共享記憶體塊的釋放，"
"請在實例上呼叫 :meth:`~multiprocessing.managers.BaseManager.shutdown()`。"
"這會觸發對該行程管理的所有 SharedMemory 物件的 :meth:`SharedMemory.unlink()` "
"呼叫，然後停止行程本身。通過 ``SharedMemoryManager`` 建立 ``SharedMemory`` "
"實例，我們避免了手動跟踪和触發共享記憶體資源釋放的需要。"

#: ../../library/multiprocessing.shared_memory.rst:196
#, fuzzy
msgid ""
"This class provides methods for creating and returning :class:`SharedMemory` "
"instances and for creating a list-like object (:class:`ShareableList`) "
"backed by shared memory."
msgstr "此類提供用於建立和回傳 SharedMemory 實例以及建立由共享記憶體支援的類列表物件 "
"(ShareableList) 的方法。"

#: ../../library/multiprocessing.shared_memory.rst:200
#, fuzzy
msgid ""
"Refer to :class:`multiprocessing.managers.BaseManager` for a description of "
"the inherited *address* and *authkey* optional input arguments and how they "
"may be used to connect to an existing ``SharedMemoryManager`` service from "
"other processes."
msgstr ""
"請參閱 :class:`multiprocessing.managers.BaseManager` 以獲取對繼承的 *address* "
"和 *authkey* 可選輸入參數的描述，以及如何使用它們從其他行程連接到現有的 "
"``SharedMemoryManager`` 服務。"

#: ../../library/multiprocessing.shared_memory.rst:207
#, fuzzy
msgid ""
"Create and return a new :class:`SharedMemory` object with the specified "
"``size`` in bytes."
msgstr "建立並回傳一個新的 :class:`SharedMemory` 物件，它具有指定的 "
"``size``（以位元組為單位）。"

#: ../../library/multiprocessing.shared_memory.rst:212
#, fuzzy
msgid ""
"Create and return a new :class:`ShareableList` object, initialized by the "
"values from the input ``sequence``."
msgstr "建立並回傳一個新的 :class:`ShareableList` 物件，由輸入``sequence`` "
"中的值初始化。"

#: ../../library/multiprocessing.shared_memory.rst:216
#, fuzzy
msgid ""
"The following example demonstrates the basic mechanisms of a :class:"
"`SharedMemoryManager`:"
msgstr "以下示例演示了 :class:`SharedMemoryManager` 的基本機制："

#: ../../library/multiprocessing.shared_memory.rst:234
#, fuzzy
msgid ""
"The following example depicts a potentially more convenient pattern for "
"using :class:`SharedMemoryManager` objects via the :keyword:`with` statement "
"to ensure that all shared memory blocks are released after they are no "
"longer needed:"
msgstr ""
"以下示例描述了一種可能更方便的模式，通過 :keyword:`with` 語句使用 "
":class:`SharedMemoryManager` 物件，以確保所有共享記憶體塊在不再需要後被釋放："

#: ../../library/multiprocessing.shared_memory.rst:253
#, fuzzy
msgid ""
"When using a :class:`SharedMemoryManager` in a :keyword:`with` statement, "
"the shared memory blocks created using that manager are all released when "
"the :keyword:`with` statement's code block finishes execution."
msgstr ""
"在 :keyword:`with` 語句中使用 :class:`SharedMemoryManager` 時，當 "
":keyword:`with` "
"語句的程式碼塊執行完畢時，使用該管理器建立的共享記憶體塊將全部釋放。"

#: ../../library/multiprocessing.shared_memory.rst:260
#, fuzzy
msgid ""
"Provides a mutable list-like object where all values stored within are "
"stored in a shared memory block.  This constrains storable values to only "
"the ``int``, ``float``, ``bool``, ``str`` (less than 10M bytes each), "
"``bytes`` (less than 10M bytes each), and ``None`` built-in data types. It "
"also notably differs from the built-in ``list`` type in that these lists can "
"not change their overall length (i.e. no append, insert, etc.) and do not "
"support the dynamic creation of new :class:`ShareableList` instances via "
"slicing."
msgstr ""
"提供一個可變的類似列表的物件，其中儲存的所有值都儲存在共享記憶體塊中。這將可"
"儲存值限制為僅 ``int``、 ``float``、 ``bool``、 ``str``（每個小於 10M 位元組）、 ``bytes``（"
"每個小於 10M 位元組） , 和 ``None`` 內建資料型別。它還與內建的 ``list`` "
"型別明顯不同，因為這些列表不能改變它們的總長度（即沒有追加、插入等）"
"並且不支援動態建立新的 ShareableList`通過切片的實例。"

#: ../../library/multiprocessing.shared_memory.rst:269
#, fuzzy
msgid ""
"*sequence* is used in populating a new ``ShareableList`` full of values. Set "
"to ``None`` to instead attach to an already existing ``ShareableList`` by "
"its unique shared memory name."
msgstr ""
"*sequence* 用於填充充滿值的新 ``ShareableList`` 。設定為 ``None`` "
"以通過其唯一的共享記憶體名稱附加到已經存在的 ``ShareableList``。"

#: ../../library/multiprocessing.shared_memory.rst:273
#, fuzzy
msgid ""
"*name* is the unique name for the requested shared memory, as described in "
"the definition for :class:`SharedMemory`.  When attaching to an existing "
"``ShareableList``, specify its shared memory block's unique name while "
"leaving ``sequence`` set to ``None``."
msgstr ""
"*name* 是請求的共享記憶體的唯一名稱，如 :class:`SharedMemory` 的定義中所述。"
"附加到現有的 ``ShareableList`` 時，指定其共享記憶體塊的唯一名稱，同時將 ``sequence`` "
"設定為 ``None``。"

#: ../../library/multiprocessing.shared_memory.rst:280
#, fuzzy
msgid "Returns the number of occurrences of ``value``."
msgstr "回傳 ``value`` 的出現次數。"

#: ../../library/multiprocessing.shared_memory.rst:284
#, fuzzy
msgid ""
"Returns first index position of ``value``.  Raises :exc:`ValueError` if "
"``value`` is not present."
msgstr "回傳 ``value`` 的第一個索引位置。如果 ``value`` 不存在，則引發 "
":exc:`ValueError`。"

#: ../../library/multiprocessing.shared_memory.rst:289
#, fuzzy
msgid ""
"Read-only attribute containing the :mod:`struct` packing format used by all "
"currently stored values."
msgstr "包含所有當前儲存值使用的 :mod:`struct` 打包格式的只讀屬性。"

#: ../../library/multiprocessing.shared_memory.rst:294
#, fuzzy
msgid "The :class:`SharedMemory` instance where the values are stored."
msgstr "儲存值的 :class:`SharedMemory` 實例。"

#: ../../library/multiprocessing.shared_memory.rst:297
#, fuzzy
msgid ""
"The following example demonstrates basic use of a :class:`ShareableList` "
"instance:"
msgstr "以下示例演示了 ShareableList 實例的基本用法："

#: ../../library/multiprocessing.shared_memory.rst:330
#, fuzzy
msgid ""
"The following example depicts how one, two, or many processes may access the "
"same :class:`ShareableList` by supplying the name of the shared memory block "
"behind it:"
msgstr "以下示例描述了一個、兩個或多個行程如何通過提供其背後的共享記憶體塊的名稱來訪"
"問同一個 :class:`ShareableList`："

#: ../../library/multiprocessing.shared_memory.rst:345
#, fuzzy
msgid ""
"The following examples demonstrates that ``ShareableList`` (and underlying "
"``SharedMemory``) objects can be pickled and unpickled if needed. Note, that "
"it will still be the same shared object. This happens, because the "
"deserialized object has the same unique name and is just attached to an "
"existing object with the same name (if the object is still alive):"
msgstr ""
"以下示例演示瞭如果需要，可以對``ShareableList``（和底層的``SharedMemory``）物"
"件進行pickled和unpickled。請注意，它仍然是同一個共享物件。發生這種情況是因為"
"反序列化的物件具有相同的唯一名稱並且只是附加到具有相同名稱的現有物件（如果該"
"物件仍然存在）："
