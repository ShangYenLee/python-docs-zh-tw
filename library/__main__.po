# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-15 00:17+0000\n"
"PO-Revision-Date: 2015-12-09 17:51+0000\n"
"Last-Translator: Liang-Bo Wang <me@liang2.tw>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/__main__.rst:2
msgid ":mod:`__main__` --- Top-level code environment"
msgstr ":mod:`__main__` --- 頂層程式碼環境"

#: ../../library/__main__.rst:10
#, fuzzy
msgid ""
"In Python, the special name ``__main__`` is used for two important "
"constructs:"
msgstr "在 Python 中，特殊名稱 ``__main__`` 用於兩個重要的結構："

#: ../../library/__main__.rst:12
#, fuzzy
msgid ""
"the name of the top-level environment of the program, which can be checked "
"using the ``__name__ == '__main__'`` expression; and"
msgstr "程式頂層環境的名稱，可以使用 ``__name__ == '__main__'`` 表達式檢查；和"

#: ../../library/__main__.rst:14
msgid "the ``__main__.py`` file in Python packages."
msgstr "Python 套件中的 ``__main__.py`` 檔案。"

#: ../../library/__main__.rst:16
#, fuzzy
msgid ""
"Both of these mechanisms are related to Python modules; how users interact "
"with them and how they interact with each other.  They are explained in "
"detail below.  If you're new to Python modules, see the tutorial section :"
"ref:`tut-modules` for an introduction."
msgstr ""
"這兩種機制都與 Python "
"模組有關；使用者如何與他們互動以及他們如何與彼此互動。它們在下面詳細解釋。"
"如果您不熟悉 Python 模組，請參閱教程部分 :ref:`tut-modules` 了解介紹。"

#: ../../library/__main__.rst:25
msgid "``__name__ == '__main__'``"
msgstr "``__name__ == '__main__'``"

#: ../../library/__main__.rst:27
#, fuzzy
msgid ""
"When a Python module or package is imported, ``__name__`` is set to the "
"module's name.  Usually, this is the name of the Python file itself without "
"the ``.py`` extension::"
msgstr ""
"當導入 Python 模組或包時，``__name__`` 被設定為模組的名稱。通常，這是沒有 ``."
"py`` 擴充名的 Python 文件本身的名稱::"

#: ../../library/__main__.rst:35
#, fuzzy
msgid ""
"If the file is part of a package, ``__name__`` will also include the parent "
"package's path::"
msgstr "如果文件是包的一部分，``__name__`` 還將包括父包的路徑::"

#: ../../library/__main__.rst:42
#, fuzzy
msgid ""
"However, if the module is executed in the top-level code environment, its "
"``__name__`` is set to the string ``'__main__'``."
msgstr "然而，如果模組在頂層程式碼環境中執行，它的``__name__`` "
"被設定為字串``'__main__'``。"

#: ../../library/__main__.rst:46
#, fuzzy
msgid "What is the \"top-level code environment\"?"
msgstr "什麼是“頂級程式碼環境”？"

#: ../../library/__main__.rst:48
#, fuzzy
msgid ""
"``__main__`` is the name of the environment where top-level code is run. "
"\"Top-level code\" is the first user-specified Python module that starts "
"running. It's \"top-level\" because it imports all other modules that the "
"program needs. Sometimes \"top-level code\" is called an *entry point* to "
"the application."
msgstr ""
"``__main__`` 是運行頂級程式碼的環境名稱。 “頂級程式碼”"
"是第一個開始運行的使用者指定的 Python 模組。它是“頂級”的，因為它導入了程式需"
"要的所有其他模組。有時“頂級程式碼”被稱為應用程式的*入口點*。"

#: ../../library/__main__.rst:53
#, fuzzy
msgid "The top-level code environment can be:"
msgstr "頂層程式碼環境可以是："

#: ../../library/__main__.rst:55
#, fuzzy
msgid "the scope of an interactive prompt::"
msgstr "交互式提示的範圍::"

#: ../../library/__main__.rst:60
#, fuzzy
msgid "the Python module passed to the Python interpreter as a file argument:"
msgstr "作為文件參數傳遞給 Python 直譯器的 Python 模組："

#: ../../library/__main__.rst:67
#, fuzzy
msgid ""
"the Python module or package passed to the Python interpreter with the :"
"option:`-m` argument:"
msgstr "使用 :option:`-m` 參數傳遞給 Python 直譯器的 Python 模組或包："

#: ../../library/__main__.rst:75
#, fuzzy
msgid "Python code read by the Python interpreter from standard input:"
msgstr "Python 直譯器從標準輸入讀取的 Python 程式碼："

#: ../../library/__main__.rst:86
#, fuzzy
msgid ""
"Python code passed to the Python interpreter with the :option:`-c` argument:"
msgstr "使用 :option:`-c` 參數傳遞給 Python 直譯器的 Python 程式碼："

#: ../../library/__main__.rst:97
#, fuzzy
msgid ""
"In each of these situations, the top-level module's ``__name__`` is set to "
"``'__main__'``."
msgstr "在每一種情況下，頂級模組的 ``__name__`` 都設定為 ``'__main__'``。"

#: ../../library/__main__.rst:100
#, fuzzy
msgid ""
"As a result, a module can discover whether or not it is running in the top-"
"level environment by checking its own ``__name__``, which allows a common "
"idiom for conditionally executing code when the module is not initialized "
"from an import statement::"
msgstr ""
"因此，模組可以通過檢查自己的 __name__ 來發現它是否在頂層環境中運行，"
"這允許在模組未從 import 語句初始化時有條件地執行程式碼的常見習慣用法： :"

#: ../../library/__main__.rst:111
#, fuzzy
msgid ""
"For a more detailed look at how ``__name__`` is set in all situations, see "
"the tutorial section :ref:`tut-modules`."
msgstr "有關如何在所有情況下設定 ``__name__`` 的更詳細資訊，請參閱教程部分 :ref:`tut-"
"modules`。"

#: ../../library/__main__.rst:116 ../../library/__main__.rst:239
#, fuzzy
msgid "Idiomatic Usage"
msgstr "慣用用法"

#: ../../library/__main__.rst:118
#, fuzzy
msgid ""
"Some modules contain code that is intended for script use only, like parsing "
"command-line arguments or fetching data from standard input.  If a module "
"like this was imported from a different module, for example to unit test it, "
"the script code would unintentionally execute as well."
msgstr ""
"一些模組包含僅供腳本使用的程式碼，例如解析命令列參數或從標準輸入中獲取資料。"
"如果像這樣的模組是從另一個模組導入的，例如對它進行單元測試，腳本程式碼也會無"
"意中執行。"

#: ../../library/__main__.rst:123
#, fuzzy
msgid ""
"This is where using the ``if __name__ == '__main__'`` code block comes in "
"handy. Code within this block won't run unless the module is executed in the "
"top-level environment."
msgstr ""
"這是使用 ``if __name__ == '__main__'`` 程式碼塊派上用場的地方。除非模組在頂層"
"環境中執行，否則此塊中的程式碼不會運行。"

#: ../../library/__main__.rst:127
#, fuzzy
msgid ""
"Putting as few statements as possible in the block below ``if __name___ == "
"'__main__'`` can improve code clarity and correctness. Most often, a "
"function named ``main`` encapsulates the program's primary behavior::"
msgstr ""
"在``if __name___ == '__main__'`` 下方的塊中放置盡可能少的語句可以提高程式碼的"
"清晰度和正確性。大多數情況下，名為 ``main``的函式封裝了程式的主要行為："

#: ../../library/__main__.rst:151
#, fuzzy
msgid ""
"Note that if the module didn't encapsulate code inside the ``main`` function "
"but instead put it directly within the ``if __name__ == '__main__'`` block, "
"the ``phrase`` variable would be global to the entire module.  This is error-"
"prone as other functions within the module could be unintentionally using "
"the global variable instead of a local name.  A ``main`` function solves "
"this problem."
msgstr ""
"請注意，如果模組沒有將程式碼封裝在 ``main`` 函式中，而是直接將其放在 ``if "
"__name__ == '__main__'`` 塊中，則 ``phrase`` 變數將是全局變數整個模組。這很容"
"易出錯，因為模組中的其他函式可能會無意中使用全局變數而不是局部名稱。 ``main``"
" 函式解決了這個問題。"

#: ../../library/__main__.rst:158
#, fuzzy
msgid ""
"Using a ``main`` function has the added benefit of the ``echo`` function "
"itself being isolated and importable elsewhere. When ``echo.py`` is "
"imported, the ``echo`` and ``main`` functions will be defined, but neither "
"of them will be called, because ``__name__ != '__main__'``."
msgstr ""
"使用 ``main`` 函式還有一個額外的好處，即 ``echo`` "
"函式本身被隔離並且可以在別處導入。導入``echo.py`` 時，將定義``echo`` "
"和``main`` 函式，但不會呼叫它們，因為``__name__ != '__main__'``。"

#: ../../library/__main__.rst:165
#, fuzzy
msgid "Packaging Considerations"
msgstr "包裝注意事項"

#: ../../library/__main__.rst:167
#, fuzzy
msgid ""
"``main`` functions are often used to create command-line tools by specifying "
"them as entry points for console scripts.  When this is done, `pip <https://"
"pip.pypa.io/>`_ inserts the function call into a template script, where the "
"return value of ``main`` is passed into :func:`sys.exit`. For example::"
msgstr ""
"``main`` "
"函式通常用於通過將它們指定為控制台腳本的入口點來建立命令列工具。完成後，`pip "
"<https://pip.pypa.io/>`_ 將函式呼叫插入到模板腳本中，其中``main`` "
"的回傳值被傳遞到 :func:`sys.exit `。例如：："

#: ../../library/__main__.rst:175
#, fuzzy
msgid ""
"Since the call to ``main`` is wrapped in :func:`sys.exit`, the expectation "
"is that your function will return some value acceptable as an input to :func:"
"`sys.exit`; typically, an integer or ``None`` (which is implicitly returned "
"if your function does not have a return statement)."
msgstr ""
"由於對 ``main`` 的呼叫包含在 :func:`sys.exit` 中，"
"因此期望您的函式將回傳一些可接受的值作為 :func:`sys.exit` "
"的輸入；通常，一個整數或 ``None`` （如果您的函式沒有回傳語句，則隱式回傳）。"

#: ../../library/__main__.rst:180
#, fuzzy
msgid ""
"By proactively following this convention ourselves, our module will have the "
"same behavior when run directly (i.e. ``python3 echo.py``) as it will have "
"if we later package it as a console script entry-point in a pip-installable "
"package."
msgstr ""
"通過我們自己主動遵循這個約定，我們的模組在直接運行時（即 ``python3 echo."
"py``）將具有相同的行為，如果我們稍後將其打包為 pip-installable "
"包中的控制台腳本入口點，它將具有相同的行為."

#: ../../library/__main__.rst:185
#, fuzzy
msgid ""
"In particular, be careful about returning strings from your ``main`` "
"function. :func:`sys.exit` will interpret a string argument as a failure "
"message, so your program will have an exit code of ``1``, indicating "
"failure, and the string will be written to :data:`sys.stderr`.  The ``echo."
"py`` example from earlier exemplifies using the ``sys.exit(main())`` "
"convention."
msgstr ""
"特別要注意從 ``main`` 函式回傳字串。 :func:`sys.exit` "
"會將字串參數解釋為失敗消息，因此您的程式將有一個退出程式碼 ``1``，表示失敗，"
"並且該字串將寫入 :data:`sys.stderr `。前面的 ``echo.py`` 示例使用 ``sys."
"exit(main())`` 約定來舉例說明。"

#: ../../library/__main__.rst:193
#, fuzzy
msgid ""
"`Python Packaging User Guide <https://packaging.python.org/>`_ contains a "
"collection of tutorials and references on how to distribute and install "
"Python packages with modern tools."
msgstr ""
"`Python 打包使用者指南 <https://packaging.python.org/>`_ "
"包含一系列關於如何使用現代工具分發和安裝 Python 包的教程和參考資料。"

#: ../../library/__main__.rst:199
#, fuzzy
msgid "``__main__.py`` in Python Packages"
msgstr "Python 包中的``__main__.py``"

#: ../../library/__main__.rst:201
#, fuzzy
msgid ""
"If you are not familiar with Python packages, see section :ref:`tut-"
"packages` of the tutorial.  Most commonly, the ``__main__.py`` file is used "
"to provide a command-line interface for a package. Consider the following "
"hypothetical package, \"bandclass\":"
msgstr ""
"如果您不熟悉 Python 包，請參閱本教程的 :ref:`tut-packages` "
"部分。最常見的是，``__main__.py`` "
"文件用於為包提供命令列界面。考慮以下假設的包， ``bandclass`` ："

#: ../../library/__main__.rst:213
#, fuzzy
msgid ""
"``__main__.py`` will be executed when the package itself is invoked directly "
"from the command line using the :option:`-m` flag. For example:"
msgstr "``__main__.py`` 將在使用 :option:`-m` "
"旗標從命令列直接呼叫包本身時執行。例如："

#: ../../library/__main__.rst:220
#, fuzzy
msgid ""
"This command will cause ``__main__.py`` to run. How you utilize this "
"mechanism will depend on the nature of the package you are writing, but in "
"this hypothetical case, it might make sense to allow the teacher to search "
"for students::"
msgstr ""
"此命令將導致 __main__.py 運行。你如何利用這個機制將取決於你正在編寫的包的性質"
"，但在這個假設的情況下，允許教師搜索學生可能是有意義的::"

#: ../../library/__main__.rst:233
#, fuzzy
msgid ""
"Note that ``from .student import search_students`` is an example of a "
"relative import.  This import style can be used when referencing modules "
"within a package.  For more details, see :ref:`intra-package-references` in "
"the :ref:`tut-modules` section of the tutorial."
msgstr ""
"請注意，``from .student import search_students`` 是相對導入的示例。在引用包中"
"的模組時可以使用此導入樣式。有關詳細資訊，請參閱本教程的 :ref:`tut-modules` "
"部分中的 :ref:`intra-package-references`。"

#: ../../library/__main__.rst:241
#, fuzzy
msgid ""
"The contents of ``__main__.py`` typically isn't fenced with ``if __name__ == "
"'__main__'`` blocks.  Instead, those files are kept short, functions to "
"execute from other modules.  Those other modules can then be easily unit-"
"tested and are properly reusable."
msgstr ""
"``__main__.py`` 的內容通常不會被``if __name__ == '__main__'`` 塊圍起來。相反"
"，這些文件保持簡短，功能從其他模組執行。然後可以輕鬆地對這些其他模組進行單元"
"測試，並且可以正確地重用它們。"

#: ../../library/__main__.rst:246
#, fuzzy
msgid ""
"If used, an ``if __name__ == '__main__'`` block will still work as expected "
"for a ``__main__.py`` file within a package, because its ``__name__`` "
"attribute will include the package's path if imported::"
msgstr ""
"如果使用，``if __name__ == '__main__'`` 塊對於包中的 ``__main__.py`` "
"文件仍將按預期工作，因為它的 ``__name__`` 屬性將包括導入包的路徑::"

#: ../../library/__main__.rst:254
#, fuzzy
msgid ""
"This won't work for ``__main__.py`` files in the root directory of a .zip "
"file though.  Hence, for consistency, minimal ``__main__.py`` like the :mod:"
"`venv` one mentioned below are preferred."
msgstr ""
"不過，這不適用於 .zip 文件根目錄中的 ``__main__.py`` "
"文件。因此，為了保持一致性，最小的 ``__main__.py`` 像下面提到的 :mod:`venv` "
"是首選。"

#: ../../library/__main__.rst:260
#, fuzzy
msgid ""
"See :mod:`venv` for an example of a package with a minimal ``__main__.py`` "
"in the standard library. It doesn't contain a ``if __name__ == '__main__'`` "
"block. You can invoke it with ``python -m venv [directory]``."
msgstr ""
"有關標準庫中帶有最小 __main__.py 的包的示例，請參閱 :mod:`venv`。它不包含 ``"
"if __name__ == '__main__'`` 塊。您可以使用“python -m venv [目錄]”呼叫它。"

#: ../../library/__main__.rst:264
#, fuzzy
msgid ""
"See :mod:`runpy` for more details on the :option:`-m` flag to the "
"interpreter executable."
msgstr "有關直譯器可執行文件的 :option:`-m` 旗標的更多詳細資訊，請參閱 :mod:`runpy`。"

#: ../../library/__main__.rst:267
#, fuzzy
msgid ""
"See :mod:`zipapp` for how to run applications packaged as *.zip* files. In "
"this case Python looks for a ``__main__.py`` file in the root directory of "
"the archive."
msgstr ""
"有關如何運行打包為 *.zip* 文件的應用程式，請參閱 "
":mod:`zipapp`。在這種情況下，Python 在存檔的根目錄中查找 ``__main__.py`` "
"文件。"

#: ../../library/__main__.rst:274
msgid "``import __main__``"
msgstr "``import __main__``"

#: ../../library/__main__.rst:276
#, fuzzy
msgid ""
"Regardless of which module a Python program was started with, other modules "
"running within that same program can import the top-level environment's "
"scope (:term:`namespace`) by importing the ``__main__`` module.  This "
"doesn't import a ``__main__.py`` file but rather whichever module that "
"received the special name ``'__main__'``."
msgstr ""
"無論 Python 程式是從哪個模組開始的，在同一程式中運行的其他模組都可以通過導入 "
"``__main__`` 模組來導入頂級環境的範圍（ :term:`namespace`）。這不會導入 "
"``__main__.py`` 文件，而是導入任何接收到特殊名稱 ``'__main__'`` 的模組。"

#: ../../library/__main__.rst:282
#, fuzzy
msgid "Here is an example module that consumes the ``__main__`` namespace::"
msgstr "這是一個使用 ``__main__`` 命名空間的示例模組::"

#: ../../library/__main__.rst:300
#, fuzzy
msgid "Example usage of this module could be as follows::"
msgstr "該模組的示例用法如下："

#: ../../library/__main__.rst:319
#, fuzzy
msgid "Now, if we started our program, the result would look like this:"
msgstr "現在，如果我們啟動我們的程式，結果將如下所示："

#: ../../library/__main__.rst:326
#, fuzzy
msgid ""
"The exit code of the program would be 1, indicating an error. Uncommenting "
"the line with ``my_name = \"Dinsdale\"`` fixes the program and now it exits "
"with status code 0, indicating success:"
msgstr ""
"程式的退出程式碼將為 1，表示出現錯誤。取消註釋帶有 ``my_name = \"Dinsdale\"``"
" 的行修復程式，現在它以狀態程式碼 0 退出，表示成功："

#: ../../library/__main__.rst:335
#, fuzzy
msgid ""
"Note that importing ``__main__`` doesn't cause any issues with "
"unintentionally running top-level code meant for script use which is put in "
"the ``if __name__ == \"__main__\"`` block of the ``start`` module. Why does "
"this work?"
msgstr ""
"請注意，導入 ``__main__`` 不會導致無意中運行用於腳本使用的頂級程式碼，"
"這些程式碼放在 ``start`` 模組的 ``if __name__ == \"__main__\"`` 塊中."
"為什麼這行得通？"

#: ../../library/__main__.rst:339
#, fuzzy
msgid ""
"Python inserts an empty ``__main__`` module in :attr:`sys.modules` at "
"interpreter startup, and populates it by running top-level code. In our "
"example this is the ``start`` module which runs line by line and imports "
"``namely``. In turn, ``namely`` imports ``__main__`` (which is really "
"``start``). That's an import cycle! Fortunately, since the partially "
"populated ``__main__`` module is present in :attr:`sys.modules`, Python "
"passes that to ``namely``. See :ref:`Special considerations for __main__ "
"<import-dunder-main>` in the import system's reference for details on how "
"this works."
msgstr ""
"Python 在直譯器啟動時在 :attr:`sys.modules` 中插入一個空的 ``__main__`` "
"模組，並通過運行頂級程式碼來填充它。在我們的示例中，這是 ``start`` 模組，"
"它逐行運行並導入 ``namely``。反過來，``即``導入``__main__``（實際上是``開始``"
"）。那是一個進口周期！幸運的是，由於部分填充的``__main__`` "
"模組存在於 :attr:`sys.modules` 中，Python "
"將其傳遞給``namely``。有關其工作原理的詳細資訊，請參閱導入系統參考中的 :ref:`"
"Special considerations for __main__ <import-dunder-main>`。"

#: ../../library/__main__.rst:348
#, fuzzy
msgid ""
"The Python REPL is another example of a \"top-level environment\", so "
"anything defined in the REPL becomes part of the ``__main__`` scope::"
msgstr "Python REPL 是“頂級環境”的另一個示例，因此 REPL 中定義的任何內容都成為 "
"``__main__`` 範圍的一部分::"

#: ../../library/__main__.rst:364
#, fuzzy
msgid ""
"Note that in this case the ``__main__`` scope doesn't contain a ``__file__`` "
"attribute as it's interactive."
msgstr "請注意，在這種情況下，``__main__`` 範圍不包含 ``__file__`` "
"屬性，因為它是交互式的。"

#: ../../library/__main__.rst:367
#, fuzzy
msgid ""
"The ``__main__`` scope is used in the implementation of :mod:`pdb` and :mod:"
"`rlcompleter`."
msgstr "``__main__`` 作用域用於 :mod:`pdb` 和 :mod:`rlcompleter` 的實作。"
