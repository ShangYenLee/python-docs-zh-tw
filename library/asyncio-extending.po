# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-15 20:43+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../library/asyncio-extending.rst:6
#, fuzzy
msgid "Extending"
msgstr "延伸"

#: ../../library/asyncio-extending.rst:8
#, fuzzy
msgid ""
"The main direction for :mod:`asyncio` extending is writing custom *event "
"loop* classes. Asyncio has helpers that could be used to simplify this task."
msgstr ":mod:`asyncio` 擴充的主要方向是編寫自定義 *event loop* 類。 Asyncio "
"具有可用於簡化此任務的助手。"

#: ../../library/asyncio-extending.rst:13
#, fuzzy
msgid ""
"Third-parties should reuse existing asyncio code with caution, a new Python "
"version is free to break backward compatibility in *internal* part of API."
msgstr "第三方應謹慎重用現有的 asyncio 程式碼，新的 Python 版本可以免費破壞 API "
"*內部*部分的向後相容性。"

#: ../../library/asyncio-extending.rst:19
#, fuzzy
msgid "Writing a Custom Event Loop"
msgstr "編寫自定義事件循環"

#: ../../library/asyncio-extending.rst:21
#, fuzzy
msgid ""
":class:`asyncio.AbstractEventLoop` declares very many methods.  Implementing "
"all them from scratch is a tedious job."
msgstr ":class:`asyncio.AbstractEventLoop` "
"聲明了很多方法。從頭開始實施所有這些是一項乏味的工作。"

#: ../../library/asyncio-extending.rst:24
#, fuzzy
msgid ""
"A loop can get many common methods implementation for free by inheriting "
"from :class:`asyncio.BaseEventLoop`."
msgstr "一個循環可以通過繼承 :class:`asyncio.BaseEventLoop` "
"來免費獲得很多常用方法的實作。"

#: ../../library/asyncio-extending.rst:27
#, fuzzy
msgid ""
"In turn, the successor should implement a bunch of *private* methods "
"declared but not implemented in :class:`asyncio.BaseEventLoop`."
msgstr "反過來，繼任者應該實作一堆在 :class:`asyncio.BaseEventLoop` 中聲明但未實作的 "
"*private* 方法。"

#: ../../library/asyncio-extending.rst:30
#, fuzzy
msgid ""
"For example, ``loop.create_connection()`` checks arguments, resolves DNS "
"addresses, and calls ``loop._make_socket_transport()`` that should be "
"implemented by inherited class. The ``_make_socket_transport()`` method is "
"not documented and is considered as an *internal* API."
msgstr ""
"例如，``loop.create_connection()`` 檢查參數，解析 DNS 地址，並呼叫 ``loop."
"_make_socket_transport()`` 應該由繼承類實作。 ``_make_socket_transport()`` "
"方法沒有記錄，被視為*內部* API。"

#: ../../library/asyncio-extending.rst:38
#, fuzzy
msgid "Future and Task private constructors"
msgstr "Future 和 Task 私有構造函式"

#: ../../library/asyncio-extending.rst:40
#, fuzzy
msgid ""
":class:`asyncio.Future` and :class:`asyncio.Task` should be never created "
"directly, please use corresponding :meth:`loop.create_future` and :meth:"
"`loop.create_task`, or :func:`asyncio.create_task` factories instead."
msgstr ""
":class:`asyncio.Future` 和 :class:`asyncio.Task` "
"永遠不要直接建立，請使用相應的 :meth:`loop.create_future` 和 :meth:`loop."
"create_task`，或者 :func:`asyncio .create_task` 工廠代替。"

#: ../../library/asyncio-extending.rst:44
#, fuzzy
msgid ""
"However, third-party *event loops* may *reuse* built-in future and task "
"implementations for the sake of getting a complex and highly optimized code "
"for free."
msgstr "然而，第三方*事件循環*可能會*重用*內建的未來和任務實作，以便免費獲得複雜且高"
"度最佳化的程式碼。"

#: ../../library/asyncio-extending.rst:47
#, fuzzy
msgid "For this purpose the following, *private* constructors are listed:"
msgstr "為此，列出了以下 *private* 構造函式："

#: ../../library/asyncio-extending.rst:51
#, fuzzy
msgid "Create a built-in future instance."
msgstr "建立一個內建的未來實例。"

#: ../../library/asyncio-extending.rst:53
#, fuzzy
msgid "*loop* is an optional event loop instance."
msgstr "*loop* 是一個可選的事件循環實例。"

#: ../../library/asyncio-extending.rst:57
#, fuzzy
msgid "Create a built-in task instance."
msgstr "建立一個內建任務實例。"

#: ../../library/asyncio-extending.rst:59
#, fuzzy
msgid ""
"*loop* is an optional event loop instance. The rest of arguments are "
"described in :meth:`loop.create_task` description."
msgstr "*loop* 是一個可選的事件循環實例。其餘參數在 :meth:`loop.create_task` "
"描述中描述。"

#: ../../library/asyncio-extending.rst:64
#, fuzzy
msgid "*context* argument is added."
msgstr "*context* 參數被新增。"

#: ../../library/asyncio-extending.rst:69
#, fuzzy
msgid "Task lifetime support"
msgstr "任務生命週期支援"

#: ../../library/asyncio-extending.rst:71
#, fuzzy
msgid ""
"A third party task implementation should call the following functions to "
"keep a task visible by :func:`asyncio.get_tasks` and :func:`asyncio."
"current_task`:"
msgstr "第三方任務實作應呼叫以下函式以保持任務對 asyncio.get_tasks 和 "
"asyncio.current_task 可見："

#: ../../library/asyncio-extending.rst:76
#, fuzzy
msgid "Register a new *task* as managed by *asyncio*."
msgstr "註冊一個由 *asyncio* 管理的新 *task*。"

#: ../../library/asyncio-extending.rst:78
#, fuzzy
msgid "Call the function from a task constructor."
msgstr "從任務構造函式呼叫函式。"

#: ../../library/asyncio-extending.rst:82
#, fuzzy
msgid "Unregister a *task* from *asyncio* internal structures."
msgstr "從 *asyncio* 內部結構中取消註冊一個 *task*。"

#: ../../library/asyncio-extending.rst:84
#, fuzzy
msgid "The function should be called when a task is about to finish."
msgstr "該函式應在任務即將完成時呼叫。"

#: ../../library/asyncio-extending.rst:88
#, fuzzy
msgid "Switch the current task to the *task* argument."
msgstr "將當前任務切換到 *task* 參數。"

#: ../../library/asyncio-extending.rst:90
#, fuzzy
msgid ""
"Call the function just before executing a portion of embedded *coroutine* (:"
"meth:`coroutine.send` or :meth:`coroutine.throw`)."
msgstr ""
"在執行嵌入式 *coroutine* 的一部分之前呼叫該函式（:meth:`coroutine.send` 或 "
":meth:`coroutine.throw`）。"

#: ../../library/asyncio-extending.rst:95
#, fuzzy
msgid "Switch the current task back from *task* to ``None``."
msgstr "將當前任務從 *task* 切換回 ``None``。"

#: ../../library/asyncio-extending.rst:97
#, fuzzy
msgid ""
"Call the function just after :meth:`coroutine.send` or :meth:`coroutine."
"throw` execution."
msgstr "在 :meth:`coroutine.send` 或 :meth:`coroutine.throw` 執行後立即呼叫該函式。"
