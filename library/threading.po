# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-10 12:39+0000\n"
"PO-Revision-Date: 2018-05-23 16:12+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/threading.rst:2
msgid ":mod:`threading` --- Thread-based parallelism"
msgstr ":mod:`threading` --- 基於執行緒的平行性"

#: ../../library/threading.rst:7
msgid "**Source code:** :source:`Lib/threading.py`"
msgstr "**原始碼：**\\ :source:`Lib/threading.py`"

#: ../../library/threading.rst:11
#, fuzzy
msgid ""
"This module constructs higher-level threading interfaces on top of the lower "
"level :mod:`_thread` module."
msgstr "該模組在較低階別 :mod:`_thread` 模組之上構建較高階別的執行緒介面。"

#: ../../library/threading.rst:14
#, fuzzy
msgid "This module used to be optional, it is now always available."
msgstr "這個模組以前是可選的，現在總是可用的。"

#: ../../library/threading.rst:19
#, fuzzy
msgid ""
":class:`concurrent.futures.ThreadPoolExecutor` offers a higher level "
"interface to push tasks to a background thread without blocking execution of "
"the calling thread, while still being able to retrieve their results when "
"needed."
msgstr ""
":class:`concurrent.futures.ThreadPoolExecutor` 提供了一個更高階別的介面來將任"
"務推送到後台執行緒而不阻塞呼叫執行緒的執行，同時仍然能夠在需要時檢索它們的結"
"果。"

#: ../../library/threading.rst:23
#, fuzzy
msgid ""
":mod:`queue` provides a thread-safe interface for exchanging data between "
"running threads."
msgstr ":mod:`queue` 提供了一個執行緒安全的介面，用於在運行的執行緒之間交換資料。"

#: ../../library/threading.rst:26
#, fuzzy
msgid ""
":mod:`asyncio` offers an alternative approach to achieving task level "
"concurrency without requiring the use of multiple operating system threads."
msgstr ":mod:`asyncio` "
"提供了一種替代方法來實作任務級並發，而無需使用多個操作系統執行緒。"

#: ../../library/threading.rst:31
#, fuzzy
msgid ""
"In the Python 2.x series, this module contained ``camelCase`` names for some "
"methods and functions. These are deprecated as of Python 3.10, but they are "
"still supported for compatibility with Python 2.5 and lower."
msgstr ""
"在 Python 2.x 系列中，該模組包含一些方法和函式的 ``camelCase`` 名稱。從 "
"Python 3.10 開始，這些已被棄用，但仍然支援與 Python 2.5 及更低版本的相容性。"

#: ../../library/threading.rst:38
#, fuzzy
msgid ""
"In CPython, due to the :term:`Global Interpreter Lock <global interpreter "
"lock>`, only one thread can execute Python code at once (even though certain "
"performance-oriented libraries might overcome this limitation). If you want "
"your application to make better use of the computational resources of multi-"
"core machines, you are advised to use :mod:`multiprocessing` or :class:"
"`concurrent.futures.ProcessPoolExecutor`. However, threading is still an "
"appropriate model if you want to run multiple I/O-bound tasks simultaneously."
msgstr ""
"在 CPython 中，由於 :term:`Global Interpreter Lock <global interpreter "
"lock>`，一次只能有一個執行緒執行 Python 程式碼（即使某些面向性能的庫可能會克"
"服這一限制）。如果您希望您的應用程式更好地利用多核機器的計算資源，建議您使用:"
"mod:`multiprocessing` 或 :class:`concurrent.futures."
"ProcessPoolExecutor`。但是，如果您想同時運行多個 I/O "
"綁定任務，執行緒仍然是一個合適的模型。"

#: ../../includes/wasm-notavail.rst:3
#, fuzzy
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ":ref:`Availability <availability>`：不是 Emscripten，不是 WASI。"

#: ../../includes/wasm-notavail.rst:5
#, fuzzy
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"此模組在 WebAssembly 平台 ``wasm32-emscripten`` 和 ``wasm32-wasi`` 上不起作用或不可用"
"。有關更多資訊，請參閱 :ref:`wasm-availability`。"

#: ../../library/threading.rst:50
#, fuzzy
msgid "This module defines the following functions:"
msgstr "該模組定義了以下函式："

#: ../../library/threading.rst:55
#, fuzzy
msgid ""
"Return the number of :class:`Thread` objects currently alive.  The returned "
"count is equal to the length of the list returned by :func:`.enumerate`."
msgstr "回傳當前存在的 :class:`Thread` 物件的數量。回傳的計數等於 :func:`.enumerate` "
"回傳的列表的長度。"

#: ../../library/threading.rst:58
#, fuzzy
msgid "The function ``activeCount`` is a deprecated alias for this function."
msgstr "函式 ``activeCount`` 是此函式的已棄用別名。"

#: ../../library/threading.rst:63
#, fuzzy
msgid ""
"Return the current :class:`Thread` object, corresponding to the caller's "
"thread of control.  If the caller's thread of control was not created "
"through the :mod:`threading` module, a dummy thread object with limited "
"functionality is returned."
msgstr ""
"回傳當前 :class:`Thread` 物件，對應於呼叫者的控制執行緒。"
"如果呼叫者的控制執行緒不是通過 :mod:`threading` "
"模組建立的，則回傳一個功能有限的虛擬執行緒物件。"

#: ../../library/threading.rst:68
#, fuzzy
msgid "The function ``currentThread`` is a deprecated alias for this function."
msgstr "函式 ``currentThread`` 是這個函式的棄用別名。"

#: ../../library/threading.rst:73
#, fuzzy
msgid "Handle uncaught exception raised by :func:`Thread.run`."
msgstr "處理由 :func:`Thread.run` 引發的未捕獲例外。"

#: ../../library/threading.rst:75
#, fuzzy
msgid "The *args* argument has the following attributes:"
msgstr "*args* 參數具有以下屬性："

#: ../../library/threading.rst:77
#, fuzzy
msgid "*exc_type*: Exception type."
msgstr "*exc_type*：例外型別。"

#: ../../library/threading.rst:78
#, fuzzy
msgid "*exc_value*: Exception value, can be ``None``."
msgstr "*exc_value*：例外值，可以是``None``。"

#: ../../library/threading.rst:79
#, fuzzy
msgid "*exc_traceback*: Exception traceback, can be ``None``."
msgstr "*exc_traceback*：例外回溯，可以是 ``None``。"

#: ../../library/threading.rst:80
msgid "*thread*: Thread which raised the exception, can be ``None``."
msgstr "*thread*：引發例外的執行緒，可以是 ``None``。"

#: ../../library/threading.rst:82
#, fuzzy
msgid ""
"If *exc_type* is :exc:`SystemExit`, the exception is silently ignored. "
"Otherwise, the exception is printed out on :data:`sys.stderr`."
msgstr ""
"如果 *exc_type* 是 :exc:`SystemExit`，例外會被忽略。否則，例外會印出在 "
":data:`sys.stderr` 上。"

#: ../../library/threading.rst:85
#, fuzzy
msgid ""
"If  this function raises an exception, :func:`sys.excepthook` is called to "
"handle it."
msgstr "如果此函式引發例外，則會呼叫 :func:`sys.excepthook` 來處理它。"

#: ../../library/threading.rst:88
#, fuzzy
msgid ""
":func:`threading.excepthook` can be overridden to control how uncaught "
"exceptions raised by :func:`Thread.run` are handled."
msgstr ":func:`threading.excepthook` 可以被覆蓋以控制如何處理 :func:`Thread.run` "
"引發的未捕獲例外。"

#: ../../library/threading.rst:91
#, fuzzy
msgid ""
"Storing *exc_value* using a custom hook can create a reference cycle. It "
"should be cleared explicitly to break the reference cycle when the exception "
"is no longer needed."
msgstr "使用自定義掛鉤儲存 *exc_value* "
"可以建立引用循環。當不再需要例外時，應該明確地清除它以打破引用循環。"

#: ../../library/threading.rst:95
#, fuzzy
msgid ""
"Storing *thread* using a custom hook can resurrect it if it is set to an "
"object which is being finalized. Avoid storing *thread* after the custom "
"hook completes to avoid resurrecting objects."
msgstr ""
"如果將 *thread* 設定為正在完成的物件，則使用自定義掛鉤儲存 *thread* "
"可以使它復活。避免在自定義掛鉤完成後儲存 *thread* 以避免復活物件。"

#: ../../library/threading.rst:100
msgid ":func:`sys.excepthook` handles uncaught exceptions."
msgstr ":func:`sys.excepthook` 處理未捕獲的例外。"

#: ../../library/threading.rst:106
#, fuzzy
msgid ""
"Holds the original value of :func:`threading.excepthook`. It is saved so "
"that the original value can be restored in case they happen to get replaced "
"with broken or alternative objects."
msgstr "保留 :func:`threading.excepthook` "
"的原始值。它被保存，以便在它們碰巧被損壞或替代物件替換時可以恢復原始值。"

#: ../../library/threading.rst:114
#, fuzzy
msgid ""
"Return the 'thread identifier' of the current thread.  This is a nonzero "
"integer.  Its value has no direct meaning; it is intended as a magic cookie "
"to be used e.g. to index a dictionary of thread-specific data.  Thread "
"identifiers may be recycled when a thread exits and another thread is "
"created."
msgstr ""
"回傳當前執行緒的“執行緒標識符”。這是一個非零整數。它的值沒有直接意義；它的目"
"的是作為一個神奇的餅乾來使用，例如。索引執行緒特定資料的字典。當一個執行緒退"
"出並建立另一個執行緒時，執行緒標識符可能會被回收。"

#: ../../library/threading.rst:125
#, fuzzy
msgid ""
"Return the native integral Thread ID of the current thread assigned by the "
"kernel. This is a non-negative integer. Its value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"回傳內核分配的當前執行緒的本機整數執行緒 ID。這是一個非負整數。它的值可用於在"
"系統範圍內唯一標識此特定執行緒（直到執行緒終止，之後該值可能會被操作系統回收"
"）。"

#: ../../library/threading.rst:130
#, fuzzy
msgid ""
":ref:`Availability <availability>`: Windows, FreeBSD, Linux, macOS, OpenBSD, "
"NetBSD, AIX."
msgstr ":ref:`可用性 "
"<可用性>`：Windows、FreeBSD、Linux、macOS、OpenBSD、NetBSD、AIX。"

#: ../../library/threading.rst:137
#, fuzzy
msgid ""
"Return a list of all :class:`Thread` objects currently active.  The list "
"includes daemonic threads and dummy thread objects created by :func:"
"`current_thread`.  It excludes terminated threads and threads that have not "
"yet been started.  However, the main thread is always part of the result, "
"even when terminated."
msgstr ""
"回傳當前活動的所有 :class:`Thread` 物件的列表。該列表包括由 "
":func:`current_thread` 建立的守護執行緒和虛擬執行緒物件。它不包括已終止的執行"
"緒和尚未啟動的執行緒。但是，主執行緒始終是結果的一部分，即使在終止時也是如此"
"。"

#: ../../library/threading.rst:146
#, fuzzy
msgid ""
"Return the main :class:`Thread` object.  In normal conditions, the main "
"thread is the thread from which the Python interpreter was started."
msgstr "回傳主要的 :class:`Thread` 物件。在正常情況下，主執行緒是啟動 Python "
"直譯器的執行緒。"

#: ../../library/threading.rst:157
#, fuzzy
msgid ""
"Set a trace function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.settrace` for each thread, "
"before its :meth:`~Thread.run` method is called."
msgstr ""
"為從 :mod:`threading` 模組啟動的所有執行緒設定跟踪函式。 *func* "
"將被傳遞給每個執行緒的 :func:`sys.settrace`，然後再呼叫其 :meth:`~Thread.run`"
" 方法。"

#: ../../library/threading.rst:168
#, fuzzy
msgid "Get the trace function as set by :func:`settrace`."
msgstr "獲取由 :func:`settrace` 設定的跟踪函式。"

#: ../../library/threading.rst:177
#, fuzzy
msgid ""
"Set a profile function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.setprofile` for each "
"thread, before its :meth:`~Thread.run` method is called."
msgstr ""
"為從 :mod:`threading` 模組啟動的所有執行緒設定配置文件函式。 *func* "
"將被傳遞給每個執行緒的 :func:`sys.setprofile`，然後再呼叫其 :meth:`~Thread."
"run` 方法。"

#: ../../library/threading.rst:186
#, fuzzy
msgid "Get the profiler function as set by :func:`setprofile`."
msgstr "獲取由 :func:`setprofile` 設定的分析器函式。"

#: ../../library/threading.rst:193
#, fuzzy
msgid ""
"Return the thread stack size used when creating new threads.  The optional "
"*size* argument specifies the stack size to be used for subsequently created "
"threads, and must be 0 (use platform or configured default) or a positive "
"integer value of at least 32,768 (32 KiB). If *size* is not specified, 0 is "
"used.  If changing the thread stack size is unsupported, a :exc:"
"`RuntimeError` is raised.  If the specified stack size is invalid, a :exc:"
"`ValueError` is raised and the stack size is unmodified.  32 KiB is "
"currently the minimum supported stack size value to guarantee sufficient "
"stack space for the interpreter itself.  Note that some platforms may have "
"particular restrictions on values for the stack size, such as requiring a "
"minimum stack size > 32 KiB or requiring allocation in multiples of the "
"system memory page size - platform documentation should be referred to for "
"more information (4 KiB pages are common; using multiples of 4096 for the "
"stack size is the suggested approach in the absence of more specific "
"information)."
msgstr ""
"回傳建立新執行緒時使用的執行緒堆疊大小。可選的 *size* "
"參數指定用於後續建立的執行緒的堆疊大小，並且必須為 "
"0（使用平台或配置的預設值）或至少為 32,768 (32 KiB) 的正整數值。如果未指定 "
"*size*，則使用 0。如果不支援更改執行緒堆疊大小，則會引發 "
":exc:`RuntimeError`。如果指定的堆疊大小無效，則會引發 :exc:`ValueError` "
"並且堆疊大小不變。 32 KiB 是當前支援的最小堆疊大小值，以保證直譯器本身有足夠"
"的堆疊空間。請注意，某些平台可能對堆疊大小的值有特殊限制，"
"例如要求最小堆疊大小 > 32 KiB 或要求分配系統記憶體頁面大小的倍數 - "
"應參考平台文檔以獲取更多資訊（4 KiB 頁面很常見；在沒有更具體資訊的情況下，"
"建議使用 4096 的倍數作為堆疊大小）。"

#: ../../library/threading.rst:208
msgid ":ref:`Availability <availability>`: Windows, pthreads."
msgstr ":ref:`適用 <availability>`：Windows, pthreads。"

#: ../../library/threading.rst:210
msgid "Unix platforms with POSIX threads support."
msgstr "支援 POSIX 執行緒的 Unix 平台。"

#: ../../library/threading.rst:213
msgid "This module also defines the following constant:"
msgstr "該模組還定義了以下常數："

#: ../../library/threading.rst:217
#, fuzzy
msgid ""
"The maximum value allowed for the *timeout* parameter of blocking functions "
"(:meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition.wait`, etc.). "
"Specifying a timeout greater than this value will raise an :exc:"
"`OverflowError`."
msgstr ""
"阻塞函式的 *timeout* 參數允許的最大值（:meth:`Lock.acquire`、:meth:`RLock."
"acquire`、:meth:`Condition.wait` 等）。指定大於此值的超時將引發 "
":exc:`OverflowError`。"

#: ../../library/threading.rst:225
#, fuzzy
msgid ""
"This module defines a number of classes, which are detailed in the sections "
"below."
msgstr "該模組定義了許多類，這些類在下面的部分中有詳細說明。"

#: ../../library/threading.rst:228
#, fuzzy
msgid ""
"The design of this module is loosely based on Java's threading model. "
"However, where Java makes locks and condition variables basic behavior of "
"every object, they are separate objects in Python.  Python's :class:`Thread` "
"class supports a subset of the behavior of Java's Thread class; currently, "
"there are no priorities, no thread groups, and threads cannot be destroyed, "
"stopped, suspended, resumed, or interrupted.  The static methods of Java's "
"Thread class, when implemented, are mapped to module-level functions."
msgstr ""
"該模組的設計大致基於 Java 的執行緒模型。然而，在 Java "
"使鎖和條件變數成為每個物件的基本行為的地方，它們在 Python 中是獨立的物件。 "
"Python 的 Thread 類支援 Java 的 Thread 類行為的一個子集；目前，沒有優先級，沒"
"有執行緒組，執行緒不能被銷毀、停止、掛起、恢復或中斷。 Java 的 Thread "
"類的靜態方法在實作時被映射到模組級函式。"

#: ../../library/threading.rst:236
#, fuzzy
msgid "All of the methods described below are executed atomically."
msgstr "下面描述的所有方法都是原子執行的。"

#: ../../library/threading.rst:240
#, fuzzy
msgid "Thread-Local Data"
msgstr "執行緒局部資料"

#: ../../library/threading.rst:242
#, fuzzy
msgid ""
"Thread-local data is data whose values are thread specific.  To manage "
"thread-local data, just create an instance of :class:`local` (or a subclass) "
"and store attributes on it::"
msgstr "執行緒本地資料是其值特定於執行緒的資料。要管理執行緒本地資料，只需建立 "
":class:`local`（或子類別）的實例並在其上儲存屬性::"

#: ../../library/threading.rst:249
#, fuzzy
msgid "The instance's values will be different for separate threads."
msgstr "對於單獨的執行緒，實例的值將不同。"

#: ../../library/threading.rst:254
#, fuzzy
msgid "A class that represents thread-local data."
msgstr "表示執行緒本地資料的類。"

#: ../../library/threading.rst:256
#, fuzzy
msgid ""
"For more details and extensive examples, see the documentation string of "
"the :mod:`_threading_local` module: :source:`Lib/_threading_local.py`."
msgstr ""
"有關更多詳細資訊和廣泛示例，請參閱 :mod:`_threading_local` "
"模組的文檔字串：:source:`Lib/_threading_local.py`。"

#: ../../library/threading.rst:263
#, fuzzy
msgid "Thread Objects"
msgstr "執行緒物件"

#: ../../library/threading.rst:265
#, fuzzy
msgid ""
"The :class:`Thread` class represents an activity that is run in a separate "
"thread of control.  There are two ways to specify the activity: by passing a "
"callable object to the constructor, or by overriding the :meth:`~Thread.run` "
"method in a subclass.  No other methods (except for the constructor) should "
"be overridden in a subclass.  In other words, *only*  override the :meth:"
"`~Thread.__init__` and :meth:`~Thread.run` methods of this class."
msgstr ""
":class:`Thread` 類表示在單獨的控制執行緒中運行的活動。有兩種方法可以指定活動"
"：通過將可呼叫對像傳遞給構造函式，或者通過覆蓋子類別中的 :meth:`~Thread.run` "
"方法。不應在子類別中覆蓋其他方法（構造函式除外）。換句話說，*僅*覆蓋此類的 "
":meth:`~Thread.__init__` 和 :meth:`~Thread.run` 方法。"

#: ../../library/threading.rst:272
#, fuzzy
msgid ""
"Once a thread object is created, its activity must be started by calling the "
"thread's :meth:`~Thread.start` method.  This invokes the :meth:`~Thread.run` "
"method in a separate thread of control."
msgstr ""
"建立執行緒對像後，必須通過呼叫執行緒的 :meth:`~Thread.start` "
"方法來啟動其活動。這會在單獨的控制執行緒中呼叫 :meth:`~Thread.run` 方法。"

#: ../../library/threading.rst:276
#, fuzzy
msgid ""
"Once the thread's activity is started, the thread is considered 'alive'. It "
"stops being alive when its :meth:`~Thread.run` method terminates -- either "
"normally, or by raising an unhandled exception.  The :meth:`~Thread."
"is_alive` method tests whether the thread is alive."
msgstr ""
"一旦執行緒的活動開始，執行緒就被認為是“活躍的”。當它的 :meth:`~Thread.run` "
"方法終止時，它就停止活動——正常終止，或者引發未處理的例外。 :meth:`~Thread."
"is_alive` 方法測試執行緒是否存活。"

#: ../../library/threading.rst:281
#, fuzzy
msgid ""
"Other threads can call a thread's :meth:`~Thread.join` method.  This blocks "
"the calling thread until the thread whose :meth:`~Thread.join` method is "
"called is terminated."
msgstr ""
"其他執行緒可以呼叫執行緒的 :meth:`~Thread.join` 方法。這會阻塞呼叫執行緒，"
"直到呼叫 :meth:`~Thread.join` 方法的執行緒終止。"

#: ../../library/threading.rst:285
#, fuzzy
msgid ""
"A thread has a name.  The name can be passed to the constructor, and read or "
"changed through the :attr:`~Thread.name` attribute."
msgstr "一個執行緒有一個名字。該名稱可以傳遞給構造函式，並通過 :attr:`~Thread.name` "
"屬性讀取或更改。"

#: ../../library/threading.rst:288
#, fuzzy
msgid ""
"If the :meth:`~Thread.run` method raises an exception, :func:`threading."
"excepthook` is called to handle it. By default, :func:`threading.excepthook` "
"ignores silently :exc:`SystemExit`."
msgstr ""
"如果 :meth:`~Thread.run` 方法引發例外，則呼叫 :func:`threading.excepthook` "
"來處理它。預設情況下，:func:`threading.excepthook` "
"靜默忽略 :exc:`SystemExit`。"

#: ../../library/threading.rst:292
#, fuzzy
msgid ""
"A thread can be flagged as a \"daemon thread\".  The significance of this "
"flag is that the entire Python program exits when only daemon threads are "
"left.  The initial value is inherited from the creating thread.  The flag "
"can be set through the :attr:`~Thread.daemon` property or the *daemon* "
"constructor argument."
msgstr ""
"一個執行緒可以被標記為“守護執行緒”。這個旗標的意義在於，當只剩下守護執行緒時"
"，整個Python程式就退出了。初始值繼承自建立執行緒。該旗標可以通過 "
":attr:`~Thread.daemon` 屬性或 *daemon* 構造函式參數設定。"

#: ../../library/threading.rst:299
#, fuzzy
msgid ""
"Daemon threads are abruptly stopped at shutdown.  Their resources (such as "
"open files, database transactions, etc.) may not be released properly. If "
"you want your threads to stop gracefully, make them non-daemonic and use a "
"suitable signalling mechanism such as an :class:`Event`."
msgstr ""
"守護執行緒在關閉時突然停止。它們的資源（如打開的文件、資料庫事務等）可能無法"
"正常釋放。如果你想讓你的執行緒優雅地停止，讓它們成為非守護行程並使用合適的信"
"號機制，比如 Event。"

#: ../../library/threading.rst:304
#, fuzzy
msgid ""
"There is a \"main thread\" object; this corresponds to the initial thread of "
"control in the Python program.  It is not a daemon thread."
msgstr "有一個“主執行緒”物件；這對應於 Python "
"程式中的初始控制執行緒。它不是守護執行緒。"

#: ../../library/threading.rst:307
#, fuzzy
msgid ""
"There is the possibility that \"dummy thread objects\" are created. These "
"are thread objects corresponding to \"alien threads\", which are threads of "
"control started outside the threading module, such as directly from C code.  "
"Dummy thread objects have limited functionality; they are always considered "
"alive and daemonic, and cannot be :ref:`joined <meth-thread-join>`.  They "
"are never deleted, since it is impossible to detect the termination of alien "
"threads."
msgstr ""
"有可能建立“虛擬執行緒物件”。這些是與“外來執行緒”相對應的執行緒物件，它們是在"
"執行緒模組之外啟動的控制執行緒，例如直接從 C "
"程式碼啟動。虛擬執行緒物件的功能有限；它們總是被認為是活躍的和守護行程的，"
"並且不能 :ref:`joined <meth-thread-"
"join>`。它們永遠不會被刪除，因為不可能檢測到外來執行緒的終止。"

#: ../../library/threading.rst:318
#, fuzzy
msgid ""
"This constructor should always be called with keyword arguments.  Arguments "
"are:"
msgstr "應始終使用關鍵字參數呼叫此構造函式。參數是："

#: ../../library/threading.rst:321
#, fuzzy
msgid ""
"*group* should be ``None``; reserved for future extension when a :class:"
"`ThreadGroup` class is implemented."
msgstr "*group* 應該是``None``；為實作 ThreadGroup 類時的未來擴充保留。"

#: ../../library/threading.rst:324
#, fuzzy
msgid ""
"*target* is the callable object to be invoked by the :meth:`run` method. "
"Defaults to ``None``, meaning nothing is called."
msgstr "*target* 是被 :meth:`run` 方法呼叫的可呼叫物件。預設為 "
"``None``，意味著什麼都不會被呼叫。"

#: ../../library/threading.rst:327
#, fuzzy
msgid ""
"*name* is the thread name. By default, a unique name is constructed of the "
"form \"Thread-*N*\" where *N* is a small decimal number, or \"Thread-*N* "
"(target)\" where \"target\" is ``target.__name__`` if the *target* argument "
"is specified."
msgstr ""
"*name* 是執行緒名稱。預設情況下，唯一名稱的構造形式為“Thread-*N*”，其中 *N* "
"是一個小的十進位數，或“Thread-*N* (target)”，其中 ``target``是 ``target."
"__name__` ` 如果指定了 *target* 參數。"

#: ../../library/threading.rst:332
#, fuzzy
msgid ""
"*args* is a list or tuple of arguments for the target invocation.  Defaults "
"to ``()``."
msgstr "*args* 是目標呼叫的參數列表或元組。預設為``()``。"

#: ../../library/threading.rst:334
#, fuzzy
msgid ""
"*kwargs* is a dictionary of keyword arguments for the target invocation. "
"Defaults to ``{}``."
msgstr "*kwargs* 是目標呼叫的關鍵字參數字典。預設為``{}``。"

#: ../../library/threading.rst:337
#, fuzzy
msgid ""
"If not ``None``, *daemon* explicitly sets whether the thread is daemonic. If "
"``None`` (the default), the daemonic property is inherited from the current "
"thread."
msgstr "如果不是 ``None``，*daemon* 明確設定執行緒是否是守護行程。如果為 ``None`` （預設值），"
"則守護程式屬性將從當前執行緒繼承。"

#: ../../library/threading.rst:341
#, fuzzy
msgid ""
"If the subclass overrides the constructor, it must make sure to invoke the "
"base class constructor (``Thread.__init__()``) before doing anything else to "
"the thread."
msgstr "如果子類別覆蓋構造函式，它必須確保在對執行緒執行任何其他操作之前呼叫基底類別"
"構造函式（``Thread.__init__()``）。"

#: ../../library/threading.rst:345
#, fuzzy
msgid "Use the *target* name if *name* argument is omitted."
msgstr "如果省略 *name* 參數，則使用 *target* 名稱。"

#: ../../library/threading.rst:348
msgid "Added the *daemon* argument."
msgstr "新增 *daemon* 引數。"

#: ../../library/threading.rst:353
#, fuzzy
msgid "Start the thread's activity."
msgstr "啟動執行緒的活動。"

#: ../../library/threading.rst:355
#, fuzzy
msgid ""
"It must be called at most once per thread object.  It arranges for the "
"object's :meth:`~Thread.run` method to be invoked in a separate thread of "
"control."
msgstr "每個執行緒物件最多只能呼叫一次。它安排物件的 :meth:`~Thread.run` "
"方法在單獨的控制執行緒中呼叫。"

#: ../../library/threading.rst:359
#, fuzzy
msgid ""
"This method will raise a :exc:`RuntimeError` if called more than once on the "
"same thread object."
msgstr "如果在同一執行緒對像上呼叫多次，此方法將引發 :exc:`RuntimeError`。"

#: ../../library/threading.rst:364
#, fuzzy
msgid "Method representing the thread's activity."
msgstr "表示執行緒活動的方法。"

#: ../../library/threading.rst:366
#, fuzzy
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the "
"*target* argument, if any, with positional and keyword arguments taken from "
"the *args* and *kwargs* arguments, respectively."
msgstr ""
"您可以在子類別中覆蓋此方法。標準的 :meth:`run` "
"方法呼叫傳遞給物件構造函式的可呼叫對像作為 *target* 參數，如果有的話，"
"位置參數和關鍵字參數分別取自 *args* 和 *kwargs* 參數。"

#: ../../library/threading.rst:371
#, fuzzy
msgid ""
"Using list or tuple as the *args* argument which passed to the :class:"
"`Thread` could achieve the same effect."
msgstr "使用列表或元組作為傳遞給 Thread 的 *args* 參數可以達到相同的效果。"

#: ../../library/threading.rst:374
msgid "Example::"
msgstr ""
"舉例來說：\n"
"\n"
"::"

#: ../../library/threading.rst:388
#, fuzzy
msgid ""
"Wait until the thread terminates. This blocks the calling thread until the "
"thread whose :meth:`~Thread.join` method is called terminates -- either "
"normally or through an unhandled exception -- or until the optional timeout "
"occurs."
msgstr ""
"等到執行緒終止。這會阻塞呼叫執行緒，直到其 :meth:`~Thread.join` 方法被呼叫的"
"執行緒終止——正常終止或通過未處理的例外終止——或者直到發生可選的超時。"

#: ../../library/threading.rst:393
#, fuzzy
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof). As :meth:`~Thread.join` always returns ``None``, you "
"must call :meth:`~Thread.is_alive` after :meth:`~Thread.join` to decide "
"whether a timeout happened -- if the thread is still alive, the :meth:"
"`~Thread.join` call timed out."
msgstr ""
"當 *timeout* 參數存在而不是 ``None``時，它應該是一個浮點數，指定以秒（或其分數）"
"為單位的操作超時。由於 :meth:`~Thread.join` 總是回傳 ``None``，您必須在 "
":meth:`~Thread.join` 之後呼叫 :meth:`~Thread.is_alive` "
"來決定是否發生超時——如果執行緒仍然存在，:meth:`~Thread.join` 呼叫超時。"

#: ../../library/threading.rst:400
#, fuzzy
msgid ""
"When the *timeout* argument is not present or ``None``, the operation will "
"block until the thread terminates."
msgstr "當 *timeout* 參數不存在或 ``None`` 時，操作將阻塞，直到執行緒終止。"

#: ../../library/threading.rst:403
#, fuzzy
msgid "A thread can be joined many times."
msgstr "一個執行緒可以加入多次。"

#: ../../library/threading.rst:405
#, fuzzy
msgid ""
":meth:`~Thread.join` raises a :exc:`RuntimeError` if an attempt is made to "
"join the current thread as that would cause a deadlock. It is also an error "
"to :meth:`~Thread.join` a thread before it has been started and attempts to "
"do so raise the same exception."
msgstr ""
":meth:`~Thread.join` 在嘗試加入當前執行緒時引發 "
":exc:`RuntimeError`，因為這會導致死鎖。 :meth:`~Thread.join` "
"在一個執行緒啟動之前加入它也是一個錯誤，並試圖這樣做會引發相同的例外。"

#: ../../library/threading.rst:412
#, fuzzy
msgid ""
"A string used for identification purposes only. It has no semantics. "
"Multiple threads may be given the same name.  The initial name is set by the "
"constructor."
msgstr "僅用於識別目的的字串。它沒有語義。多個執行緒可以被賦予相同的名稱。初始名稱由"
"構造函式設定。"

#: ../../library/threading.rst:419
#, fuzzy
msgid ""
"Deprecated getter/setter API for :attr:`~Thread.name`; use it directly as a "
"property instead."
msgstr "棄用的 getter/setter API 為 :attr:`~Thread.name`；直接將其用作屬性。"

#: ../../library/threading.rst:426
#, fuzzy
msgid ""
"The 'thread identifier' of this thread or ``None`` if the thread has not "
"been started.  This is a nonzero integer.  See the :func:`get_ident` "
"function.  Thread identifiers may be recycled when a thread exits and "
"another thread is created.  The identifier is available even after the "
"thread has exited."
msgstr ""
"此執行緒的“執行緒標識符”或 ``None`` （如果執行緒尚未啟動）。這是一個非零整數。"
"請參閱 :func:`get_ident` 函式。當一個執行緒退出並建立另一個執行緒時，執行緒標"
"識符可能會被回收。即使在執行緒退出後，標識符仍然可用。"

#: ../../library/threading.rst:434
#, fuzzy
msgid ""
"The Thread ID (``TID``) of this thread, as assigned by the OS (kernel). This "
"is a non-negative integer, or ``None`` if the thread has not been started. "
"See the :func:`get_native_id` function. This value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"此執行緒的執行緒 ID (``TID``)，由操作系統（內核）分配。這是一個非負整數，如果"
"執行緒尚未啟動，則為 ``None``。請參閱 :func:`get_native_id` 函式。此值可用於在系"
"統範圍內唯一標識此特定執行緒（直到執行緒終止，之後該值可能會被操作系統回收）"
"。"

#: ../../library/threading.rst:443
#, fuzzy
msgid ""
"Similar to Process IDs, Thread IDs are only valid (guaranteed unique system-"
"wide) from the time the thread is created until the thread has been "
"terminated."
msgstr "與行程 ID 類似，執行緒 ID "
"僅在執行緒建立到執行緒終止期間有效（保證在系統範圍內唯一）。"

#: ../../library/threading.rst:447
#, fuzzy
msgid ""
":ref:`Availability <availability>`: Windows, FreeBSD, Linux, macOS, OpenBSD, "
"NetBSD, AIX, DragonFlyBSD."
msgstr ""
":ref:`可用性 <可用性>`：Windows、FreeBSD、Linux、macOS、OpenBSD、NetBSD、AIX"
"、DragonFlyBSD。"

#: ../../library/threading.rst:453
#, fuzzy
msgid "Return whether the thread is alive."
msgstr "回傳執行緒是否存活。"

#: ../../library/threading.rst:455
#, fuzzy
msgid ""
"This method returns ``True`` just before the :meth:`~Thread.run` method "
"starts until just after the :meth:`~Thread.run` method terminates.  The "
"module function :func:`.enumerate` returns a list of all alive threads."
msgstr ""
"此方法在 :meth:`~Thread.run` 方法開始之前回傳 ``True`` 直到 :meth:`~Thread."
"run` 方法終止之後。模組函式 :func:`.enumerate` 回傳所有活動執行緒的列表。"

#: ../../library/threading.rst:461
#, fuzzy
msgid ""
"A boolean value indicating whether this thread is a daemon thread (``True``) "
"or not (``False``).  This must be set before :meth:`~Thread.start` is "
"called, otherwise :exc:`RuntimeError` is raised.  Its initial value is "
"inherited from the creating thread; the main thread is not a daemon thread "
"and therefore all threads created in the main thread default to :attr:"
"`~Thread.daemon` = ``False``."
msgstr ""
"一個布爾值，指示此執行緒是守護執行緒（ ``True``）還是不是（ ``False``）。這必須在呼叫 "
":meth:`~Thread.start` 之前設定，否則會引發 :exc:`RuntimeError`。它的初始值繼"
"承自建立執行緒；主執行緒不是守護執行緒，因此在主執行緒中建立的所有執行緒預設"
"為 :attr:`~Thread.daemon` = ``False``。"

#: ../../library/threading.rst:468
#, fuzzy
msgid ""
"The entire Python program exits when no alive non-daemon threads are left."
msgstr "當沒有留下任何活動的非守護執行緒時，整個 Python 程式就會退出。"

#: ../../library/threading.rst:473
#, fuzzy
msgid ""
"Deprecated getter/setter API for :attr:`~Thread.daemon`; use it directly as "
"a property instead."
msgstr "已棄用的 getter/setter API 用於 :attr:`~Thread.daemon`；直接將其用作屬性。"

#: ../../library/threading.rst:482
#, fuzzy
msgid "Lock Objects"
msgstr "鎖定物件"

#: ../../library/threading.rst:484
#, fuzzy
msgid ""
"A primitive lock is a synchronization primitive that is not owned by a "
"particular thread when locked.  In Python, it is currently the lowest level "
"synchronization primitive available, implemented directly by the :mod:"
"`_thread` extension module."
msgstr ""
"原語鎖是一種同步原語，在鎖定時不屬於特定執行緒。在 Python "
"中，它是目前可用的最低階別同步原語，直接由 :mod:`_thread` 擴充模組實作。"

#: ../../library/threading.rst:489
#, fuzzy
msgid ""
"A primitive lock is in one of two states, \"locked\" or \"unlocked\". It is "
"created in the unlocked state.  It has two basic methods, :meth:`~Lock."
"acquire` and :meth:`~Lock.release`.  When the state is unlocked, :meth:"
"`~Lock.acquire` changes the state to locked and returns immediately.  When "
"the state is locked, :meth:`~Lock.acquire` blocks until a call to :meth:"
"`~Lock.release` in another thread changes it to unlocked, then the :meth:"
"`~Lock.acquire` call resets it to locked and returns.  The :meth:`~Lock."
"release` method should only be called in the locked state; it changes the "
"state to unlocked and returns immediately. If an attempt is made to release "
"an unlocked lock, a :exc:`RuntimeError` will be raised."
msgstr ""
"原始鎖處於兩種狀態之一，“鎖定”或“解鎖”。它是在解鎖狀態下建立的。它有兩個基本"
"方法，:meth:`~Lock.acquire` 和 :meth:`~Lock."
"release`。當狀態解鎖時，:meth:`~Lock.acquire` "
"將狀態更改為鎖定並立即回傳。當狀態被鎖定時，:meth:`~Lock.acquire` "
"會阻塞，直到在另一個執行緒中呼叫 :meth:`~Lock.release` "
"將其更改為解鎖狀態，然後 :meth:`~Lock.acquire` 呼叫會重置它鎖定並回傳。 "
":meth:`~Lock.release` 方法只能在鎖定狀態下呼叫；它將狀態更改為解鎖並立即回傳"
"。如果嘗試釋放未鎖定的鎖，則會引發 :exc:`RuntimeError`。"

#: ../../library/threading.rst:500
#, fuzzy
msgid "Locks also support the :ref:`context management protocol <with-locks>`."
msgstr "鎖還支援 :ref:`上下文管理協定 <with-locks>`。"

#: ../../library/threading.rst:502
#, fuzzy
msgid ""
"When more than one thread is blocked in :meth:`~Lock.acquire` waiting for "
"the state to turn to unlocked, only one thread proceeds when a :meth:`~Lock."
"release` call resets the state to unlocked; which one of the waiting threads "
"proceeds is not defined, and may vary across implementations."
msgstr ""
"當多個執行緒在 :meth:`~Lock.acquire` 中阻塞等待狀態變為解鎖時，"
"只有一個執行緒在 :meth:`~Lock.release` 呼叫將狀態重置為解鎖時繼續進行；等待執"
"行緒中的哪一個未定義，並且可能因實作而異。"

#: ../../library/threading.rst:507
#, fuzzy
msgid "All methods are executed atomically."
msgstr "所有方法都是原子執行的。"

#: ../../library/threading.rst:512
#, fuzzy
msgid ""
"The class implementing primitive lock objects.  Once a thread has acquired a "
"lock, subsequent attempts to acquire it block, until it is released; any "
"thread may release it."
msgstr "實作原始鎖物件的類。一旦一個執行緒獲得了一個鎖，後續的獲取它的嘗試就會阻塞，"
"直到它被釋放；任何執行緒都可以釋放它。"

#: ../../library/threading.rst:516
#, fuzzy
msgid ""
"Note that ``Lock`` is actually a factory function which returns an instance "
"of the most efficient version of the concrete Lock class that is supported "
"by the platform."
msgstr "請注意，``Lock`` 實際上是一個工廠函式，它回傳平台支援的具體 Lock "
"類的最有效版本的實例。"

#: ../../library/threading.rst:523 ../../library/threading.rst:603
#, fuzzy
msgid "Acquire a lock, blocking or non-blocking."
msgstr "獲取鎖，阻塞或非阻塞。"

#: ../../library/threading.rst:525
#, fuzzy
msgid ""
"When invoked with the *blocking* argument set to ``True`` (the default), "
"block until the lock is unlocked, then set it to locked and return ``True``."
msgstr "當 *blocking* 參數設定為 ``True``（預設值）時，阻塞直到鎖被解鎖，"
"然後將其設定為鎖定並回傳 ``True``。"

#: ../../library/threading.rst:528
#, fuzzy
msgid ""
"When invoked with the *blocking* argument set to ``False``, do not block. If "
"a call with *blocking* set to ``True`` would block, return ``False`` "
"immediately; otherwise, set the lock to locked and return ``True``."
msgstr ""
"當呼叫 *blocking* 參數設定為 ``False`` 時，不要阻塞。如果 *blocking* 設定為 "
"``True`` 的呼叫會阻塞，則立即回傳 "
"``False``；否則，將鎖設定為已鎖定並回傳 ``True``。"

#: ../../library/threading.rst:532
#, fuzzy
msgid ""
"When invoked with the floating-point *timeout* argument set to a positive "
"value, block for at most the number of seconds specified by *timeout* and as "
"long as the lock cannot be acquired.  A *timeout* argument of ``-1`` "
"specifies an unbounded wait.  It is forbidden to specify a *timeout* when "
"*blocking* is ``False``."
msgstr ""
"當在浮點 *timeout* 參數設定為正值的情況下呼叫時，最多阻塞 *timeout* "
"指定的秒數並且只要無法獲取鎖。 ``-1`` 的 *timeout* 參數指定無限等待。當 "
"*blocking* 為 ``False`` 時，禁止指定 *timeout*。"

#: ../../library/threading.rst:538
#, fuzzy
msgid ""
"The return value is ``True`` if the lock is acquired successfully, ``False`` "
"if not (for example if the *timeout* expired)."
msgstr "如果成功獲取鎖，則回傳值為 ``True``，否則為 ``False``（例如，如果 *timeout* "
"已過期）。"

#: ../../library/threading.rst:541 ../../library/threading.rst:625
#: ../../library/threading.rst:872
#, fuzzy
msgid "The *timeout* parameter is new."
msgstr "*timeout* 參數是新的。"

#: ../../library/threading.rst:544
#, fuzzy
msgid ""
"Lock acquisition can now be interrupted by signals on POSIX if the "
"underlying threading implementation supports it."
msgstr "如果底層執行緒實作支援，鎖定獲取現在可以被 POSIX 上的信號中斷。"

#: ../../library/threading.rst:551
#, fuzzy
msgid ""
"Release a lock.  This can be called from any thread, not only the thread "
"which has acquired the lock."
msgstr "釋放一個鎖。這可以從任何執行緒呼叫，而不僅僅是獲得鎖的執行緒。"

#: ../../library/threading.rst:554
#, fuzzy
msgid ""
"When the lock is locked, reset it to unlocked, and return.  If any other "
"threads are blocked waiting for the lock to become unlocked, allow exactly "
"one of them to proceed."
msgstr "當鎖被鎖定時，將其重置為解鎖，然後回傳。如果任何其他執行緒在等待鎖解鎖時被阻"
"塞，則只允許其中一個執行緒繼續執行。"

#: ../../library/threading.rst:558
#, fuzzy
msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr "在未鎖定的鎖上呼叫時，會引發 :exc:`RuntimeError`。"

#: ../../library/threading.rst:560 ../../library/threading.rst:641
#, fuzzy
msgid "There is no return value."
msgstr "沒有回傳值。"

#: ../../library/threading.rst:564
#, fuzzy
msgid "Return ``True`` if the lock is acquired."
msgstr "如果獲取了鎖，則回傳 ``True``。"

#: ../../library/threading.rst:571
msgid "RLock Objects"
msgstr "RLock 物件"

#: ../../library/threading.rst:573
#, fuzzy
msgid ""
"A reentrant lock is a synchronization primitive that may be acquired "
"multiple times by the same thread.  Internally, it uses the concepts of "
"\"owning thread\" and \"recursion level\" in addition to the locked/unlocked "
"state used by primitive locks.  In the locked state, some thread owns the "
"lock; in the unlocked state, no thread owns it."
msgstr ""
"可重入鎖是一種同步原語，可以由同一個執行緒多次獲取。在內部，除了原始鎖使用的"
"鎖定/解鎖狀態之外，它還使用“擁有執行緒”和“遞迴級別”的概念。在鎖定狀態下，某個"
"執行緒擁有鎖；在解鎖狀態下，沒有執行緒擁有它。"

#: ../../library/threading.rst:579
#, fuzzy
msgid ""
"To lock the lock, a thread calls its :meth:`~RLock.acquire` method; this "
"returns once the thread owns the lock.  To unlock the lock, a thread calls "
"its :meth:`~Lock.release` method. :meth:`~Lock.acquire`/:meth:`~Lock."
"release` call pairs may be nested; only the final :meth:`~Lock.release` "
"(the :meth:`~Lock.release` of the outermost pair) resets the lock to "
"unlocked and allows another thread blocked in :meth:`~Lock.acquire` to "
"proceed."
msgstr ""
"要鎖定鎖，一個執行緒呼叫它的 :meth:`~RLock.acquire` "
"方法；一旦執行緒擁有鎖，它就會回傳。要解鎖鎖，執行緒呼叫其 :meth:`~Lock."
"release` 方法。 :meth:`~Lock.acquire`/:meth:`~Lock.release` 呼叫對可以嵌套；"
"只有最後的 :meth:`~Lock.release`（最外層對的 :meth:`~Lock."
"release`）將鎖重置為解鎖狀態，並允許阻塞在 :meth:`~Lock.acquire` "
"中的另一個執行緒繼續進行."

#: ../../library/threading.rst:586
#, fuzzy
msgid ""
"Reentrant locks also support the :ref:`context management protocol <with-"
"locks>`."
msgstr "可重入鎖還支援 :ref:`上下文管理協定 <with-locks>`。"

#: ../../library/threading.rst:591
#, fuzzy
msgid ""
"This class implements reentrant lock objects.  A reentrant lock must be "
"released by the thread that acquired it.  Once a thread has acquired a "
"reentrant lock, the same thread may acquire it again without blocking; the "
"thread must release it once for each time it has acquired it."
msgstr ""
"此類實作可重入鎖物件。可重入鎖必須由獲得它的執行緒釋放。一旦一個執行緒獲得了"
"可重入鎖，同一個執行緒可以再次獲得它而不會阻塞；執行緒必須在每次獲取它時釋放"
"它一次。"

#: ../../library/threading.rst:596
#, fuzzy
msgid ""
"Note that ``RLock`` is actually a factory function which returns an instance "
"of the most efficient version of the concrete RLock class that is supported "
"by the platform."
msgstr "請注意，``RLock`` 實際上是一個工廠函式，它回傳平台支援的具體 RLock "
"類的最有效版本的實例。"

#: ../../library/threading.rst:605
#, fuzzy
msgid ""
"When invoked without arguments: if this thread already owns the lock, "
"increment the recursion level by one, and return immediately.  Otherwise, if "
"another thread owns the lock, block until the lock is unlocked.  Once the "
"lock is unlocked (not owned by any thread), then grab ownership, set the "
"recursion level to one, and return.  If more than one thread is blocked "
"waiting until the lock is unlocked, only one at a time will be able to grab "
"ownership of the lock. There is no return value in this case."
msgstr ""
"當不帶參數呼叫時：如果此執行緒已經擁有鎖，則將遞迴級別遞增 1，並立即回傳。否"
"則，如果另一個執行緒擁有鎖，則阻塞直到鎖被解鎖。一旦鎖被解鎖（不屬於任何執行"
"緒），然後獲取所有權，將遞迴級別設定為 1，然後回傳。如果在鎖解鎖之前有多個執"
"行緒被阻塞，則一次只有一個執行緒能夠獲取鎖的所有權。在這種情況下沒有回傳值。"

#: ../../library/threading.rst:613
#, fuzzy
msgid ""
"When invoked with the *blocking* argument set to ``True``, do the same thing "
"as when called without arguments, and return ``True``."
msgstr "當 *blocking* 參數設定為 ``True`` 時呼叫時，執行與不帶參數呼叫時相同的操作，"
"並回傳 ``True``。"

#: ../../library/threading.rst:616
#, fuzzy
msgid ""
"When invoked with the *blocking* argument set to ``False``, do not block.  "
"If a call without an argument would block, return ``False`` immediately; "
"otherwise, do the same thing as when called without arguments, and return "
"``True``."
msgstr ""
"當呼叫 *blocking* 參數設定為 ``False`` 時，不要阻塞。如果沒有參數的呼叫會阻塞"
"，立即回傳 ``False``；否則，執行與不帶參數呼叫時相同的操作，並回傳 ``True``。"

#: ../../library/threading.rst:620
#, fuzzy
msgid ""
"When invoked with the floating-point *timeout* argument set to a positive "
"value, block for at most the number of seconds specified by *timeout* and as "
"long as the lock cannot be acquired.  Return ``True`` if the lock has been "
"acquired, ``False`` if the timeout has elapsed."
msgstr ""
"當在浮點 *timeout* 參數設定為正值的情況下呼叫時，最多阻塞 *timeout* 指定的秒"
"數並且只要無法獲取鎖。如果已獲取鎖，則回傳 ``True``，如果超時已過，則回傳 ``False``"
"。"

#: ../../library/threading.rst:631
#, fuzzy
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement it "
"is zero, reset the lock to unlocked (not owned by any thread), and if any "
"other threads are blocked waiting for the lock to become unlocked, allow "
"exactly one of them to proceed.  If after the decrement the recursion level "
"is still nonzero, the lock remains locked and owned by the calling thread."
msgstr ""
"釋放鎖，遞減遞迴級別。如果在遞減後它為零，則將鎖重置為解鎖（不屬於任何執行緒"
"），並且如果任何其他執行緒被阻塞等待鎖解鎖，則只允許其中一個繼續進行。如果遞"
"減後遞迴級別仍然不為零，則鎖保持鎖定狀態並由呼叫執行緒擁有。"

#: ../../library/threading.rst:637
#, fuzzy
msgid ""
"Only call this method when the calling thread owns the lock. A :exc:"
"`RuntimeError` is raised if this method is called when the lock is unlocked."
msgstr "僅當呼叫執行緒擁有鎖時才呼叫此方法。如果在解鎖鎖時呼叫此方法，則會引發 "
":exc:`RuntimeError`。"

#: ../../library/threading.rst:647
#, fuzzy
msgid "Condition Objects"
msgstr "條件物件"

#: ../../library/threading.rst:649
#, fuzzy
msgid ""
"A condition variable is always associated with some kind of lock; this can "
"be passed in or one will be created by default.  Passing one in is useful "
"when several condition variables must share the same lock.  The lock is part "
"of the condition object: you don't have to track it separately."
msgstr ""
"條件變數總是與某種鎖相關聯；這可以傳入或預設建立一個。當多個條件變數必須共享"
"同一個鎖時，傳入一個很有用。鎖是條件物件的一部分：您不必單獨跟踪它。"

#: ../../library/threading.rst:654
#, fuzzy
msgid ""
"A condition variable obeys the :ref:`context management protocol <with-"
"locks>`: using the ``with`` statement acquires the associated lock for the "
"duration of the enclosed block.  The :meth:`~Condition.acquire` and :meth:"
"`~Condition.release` methods also call the corresponding methods of the "
"associated lock."
msgstr ""
"條件變數遵守 :ref:`上下文管理協定 <with-locks>`：使用``with`` "
"語句在封閉塊的持續時間內獲取關聯的鎖。 :meth:`~Condition.acquire` 和 "
":meth:`~Condition.release` 方法也會呼叫關聯鎖的相應方法。"

#: ../../library/threading.rst:660
#, fuzzy
msgid ""
"Other methods must be called with the associated lock held.  The :meth:"
"`~Condition.wait` method releases the lock, and then blocks until another "
"thread awakens it by calling :meth:`~Condition.notify` or :meth:`~Condition."
"notify_all`.  Once awakened, :meth:`~Condition.wait` re-acquires the lock "
"and returns.  It is also possible to specify a timeout."
msgstr ""
"必須在持有關聯鎖的情況下呼叫其他方法。 :meth:`~Condition.wait` "
"方法釋放鎖，然後阻塞，直到另一個執行緒通過呼叫 :meth:`~Condition.notify` 或 "
":meth:`~Condition.notify_all` 喚醒它。一旦被喚醒，:meth:`~Condition.wait` "
"重新獲取鎖並回傳。也可以指定超時。"

#: ../../library/threading.rst:666
#, fuzzy
msgid ""
"The :meth:`~Condition.notify` method wakes up one of the threads waiting for "
"the condition variable, if any are waiting.  The :meth:`~Condition."
"notify_all` method wakes up all threads waiting for the condition variable."
msgstr ""
":meth:`~Condition.notify` 方法喚醒等待條件變數的執行緒之一，如果有的話。 "
":meth:`~Condition.notify_all` 方法喚醒所有等待條件變數的執行緒。"

#: ../../library/threading.rst:670
#, fuzzy
msgid ""
"Note: the :meth:`~Condition.notify` and :meth:`~Condition.notify_all` "
"methods don't release the lock; this means that the thread or threads "
"awakened will not return from their :meth:`~Condition.wait` call "
"immediately, but only when the thread that called :meth:`~Condition.notify` "
"or :meth:`~Condition.notify_all` finally relinquishes ownership of the lock."
msgstr ""
"注意：:meth:`~Condition.notify` 和 :meth:`~Condition.notify_all` "
"方法不會釋放鎖；這意味著被喚醒的執行緒不會立即從它們的 :meth:`~Condition."
"wait` 呼叫中回傳，只有當呼叫 :meth:`~Condition.notify` 或 :meth:`~"
"Condition.notify_all 的執行緒回傳時` 最後放棄鎖的所有權。"

#: ../../library/threading.rst:676
#, fuzzy
msgid ""
"The typical programming style using condition variables uses the lock to "
"synchronize access to some shared state; threads that are interested in a "
"particular change of state call :meth:`~Condition.wait` repeatedly until "
"they see the desired state, while threads that modify the state call :meth:"
"`~Condition.notify` or :meth:`~Condition.notify_all` when they change the "
"state in such a way that it could possibly be a desired state for one of the "
"waiters.  For example, the following code is a generic producer-consumer "
"situation with unlimited buffer capacity::"
msgstr ""
"使用條件變數的典型編程風格使用鎖來同步訪問某些共享狀態；"
"對狀態的特定變化感興趣的執行緒重複呼叫 :meth:`~Condition.wait` "
"直到它們看到所需的狀態，而修改狀態的執行緒呼叫 :meth:`~Condition.notify` 或 "
":meth:`~ Condition.notify_all` 當他們以這樣一種方式改變狀態時，它可能是其中一"
"個服務員的理想狀態。例如，下面的程式碼是一個具有無限緩衝容量的通用生產者-消費"
"者情況："

#: ../../library/threading.rst:696
#, fuzzy
msgid ""
"The ``while`` loop checking for the application's condition is necessary "
"because :meth:`~Condition.wait` can return after an arbitrary long time, and "
"the condition which prompted the :meth:`~Condition.notify` call may no "
"longer hold true.  This is inherent to multi-threaded programming.  The :"
"meth:`~Condition.wait_for` method can be used to automate the condition "
"checking, and eases the computation of timeouts::"
msgstr ""
"``while`` 循環檢查應用程式的條件是必要的，因為 :meth:`~Condition.wait` "
"可以在任意長時間後回傳，而提示 :meth:`~Condition.notify` "
"呼叫的條件可能沒有不再適用。這是多執行緒編程所固有的。 :meth:`~Condition."
"wait_for` 方法可用於自動執行條件檢查，並簡化超時計算："

#: ../../library/threading.rst:708
#, fuzzy
msgid ""
"To choose between :meth:`~Condition.notify` and :meth:`~Condition."
"notify_all`, consider whether one state change can be interesting for only "
"one or several waiting threads.  E.g. in a typical producer-consumer "
"situation, adding one item to the buffer only needs to wake up one consumer "
"thread."
msgstr ""
"要在 :meth:`~Condition.notify` 和 :meth:`~Condition.notify_all` 之間進行選擇"
"，請考慮一個狀態更改是否只對一個或多個等待執行緒感興趣。例如。在典型的生產者-"
"消費者情況下，向緩衝區新增一項只需要喚醒一個消費者執行緒。"

#: ../../library/threading.rst:716
#, fuzzy
msgid ""
"This class implements condition variable objects.  A condition variable "
"allows one or more threads to wait until they are notified by another thread."
msgstr "此類實作條件變數物件。條件變數允許一個或多個執行緒等待，直到它們被另一個執行"
"緒通知。"

#: ../../library/threading.rst:719
#, fuzzy
msgid ""
"If the *lock* argument is given and not ``None``, it must be a :class:`Lock` "
"or :class:`RLock` object, and it is used as the underlying lock.  Otherwise, "
"a new :class:`RLock` object is created and used as the underlying lock."
msgstr ""
"如果給出 *lock* 參數而不是 ``None``，它必須是一個 :class:`Lock` 或 "
":class:`RLock` 物件，並且它被用作底層鎖。否則，將建立一個新的 :class:`RLock` "
"物件並將其用作底層鎖。"

#: ../../library/threading.rst:723 ../../library/threading.rst:847
#: ../../library/threading.rst:893 ../../library/threading.rst:945
#: ../../library/threading.rst:1016
#, fuzzy
msgid "changed from a factory function to a class."
msgstr "從工廠函式更改為類。"

#: ../../library/threading.rst:728
#, fuzzy
msgid ""
"Acquire the underlying lock. This method calls the corresponding method on "
"the underlying lock; the return value is whatever that method returns."
msgstr "獲取底層鎖。該方法呼叫底層鎖上相應的方法；回傳值是該方法回傳的任何值。"

#: ../../library/threading.rst:733
#, fuzzy
msgid ""
"Release the underlying lock. This method calls the corresponding method on "
"the underlying lock; there is no return value."
msgstr "釋放底層鎖。該方法呼叫底層鎖上相應的方法；沒有回傳值。"

#: ../../library/threading.rst:738
#, fuzzy
msgid ""
"Wait until notified or until a timeout occurs. If the calling thread has not "
"acquired the lock when this method is called, a :exc:`RuntimeError` is "
"raised."
msgstr "等待直到收到通知或直到發生超時。如果在呼叫此方法時呼叫執行緒尚未獲取鎖，"
"則會引發 :exc:`RuntimeError`。"

#: ../../library/threading.rst:742
#, fuzzy
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call for the same "
"condition variable in another thread, or until the optional timeout occurs.  "
"Once awakened or timed out, it re-acquires the lock and returns."
msgstr ""
"此方法釋放底層鎖，然後阻塞，直到它被另一個執行緒中對相同條件變數的 notify 或 "
"notify_all "
"呼叫喚醒，或者直到發生可選的超時。一旦被喚醒或超時，它會重新獲取鎖並回傳。"

#: ../../library/threading.rst:747
#, fuzzy
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr "當 *timeout* 參數存在而不是 ``None``時，它應該是一個浮點數，指定以秒（或其分數）"
"為單位的操作超時。"

#: ../../library/threading.rst:751
#, fuzzy
msgid ""
"When the underlying lock is an :class:`RLock`, it is not released using its :"
"meth:`release` method, since this may not actually unlock the lock when it "
"was acquired multiple times recursively.  Instead, an internal interface of "
"the :class:`RLock` class is used, which really unlocks it even when it has "
"been recursively acquired several times. Another internal interface is then "
"used to restore the recursion level when the lock is reacquired."
msgstr ""
"當底層鎖是 :class:`RLock` 時，它不會使用其 :meth:`release` "
"方法釋放，因為當它被遞迴多次獲取時，這可能不會真正解鎖鎖。相反，使用了 "
":class:`RLock` 類的內部介面，即使它已被多次遞迴獲取，它也會真正解鎖它。另一個"
"內部介面隨後用於在重新獲取鎖時恢復遞迴級別。"

#: ../../library/threading.rst:759
#, fuzzy
msgid ""
"The return value is ``True`` unless a given *timeout* expired, in which case "
"it is ``False``."
msgstr "除非給定的 *timeout* 已過期，否則回傳值為 ``True``，在這種情況下回傳值為 "
"``False``。"

#: ../../library/threading.rst:762 ../../library/threading.rst:981
#, fuzzy
msgid "Previously, the method always returned ``None``."
msgstr "以前，該方法總是回傳 ``None`` 。"

#: ../../library/threading.rst:767
#, fuzzy
msgid ""
"Wait until a condition evaluates to true.  *predicate* should be a callable "
"which result will be interpreted as a boolean value. A *timeout* may be "
"provided giving the maximum time to wait."
msgstr "等到條件評估為真。 *predicate* "
"應該是可呼叫的，其結果將被解釋為布爾值。可以提供*超時*，給出等待的最長時間。"

#: ../../library/threading.rst:771
#, fuzzy
msgid ""
"This utility method may call :meth:`wait` repeatedly until the predicate is "
"satisfied, or until a timeout occurs. The return value is the last return "
"value of the predicate and will evaluate to ``False`` if the method timed "
"out."
msgstr ""
"此實用程式方法可能會重複呼叫 :meth:`wait` 直到滿足謂詞，或直到發生超時。回傳"
"值是謂詞的最後一個回傳值，如果方法超時，它將評估為 ``False``。"

#: ../../library/threading.rst:776
#, fuzzy
msgid ""
"Ignoring the timeout feature, calling this method is roughly equivalent to "
"writing::"
msgstr "忽略超時特性，呼叫這個方法大致等同於這樣寫："

#: ../../library/threading.rst:782
#, fuzzy
msgid ""
"Therefore, the same rules apply as with :meth:`wait`: The lock must be held "
"when called and is re-acquired on return.  The predicate is evaluated with "
"the lock held."
msgstr "因此，適用與 :meth:`wait` 相同的規則：呼叫時必須持有鎖，並在回傳時重新獲取鎖"
"。在持有鎖的情況下評估謂詞。"

#: ../../library/threading.rst:790
#, fuzzy
msgid ""
"By default, wake up one thread waiting on this condition, if any.  If the "
"calling thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""
"預設情況下，喚醒一個在此條件下等待的執行緒（如果有）。如果在呼叫此方法時呼叫"
"執行緒尚未獲取鎖，則會引發 :exc:`RuntimeError`。"

#: ../../library/threading.rst:794
#, fuzzy
msgid ""
"This method wakes up at most *n* of the threads waiting for the condition "
"variable; it is a no-op if no threads are waiting."
msgstr "該方法最多喚醒*n*個等待條件變數的執行緒；如果沒有執行緒在等待，它就是空操作。"

#: ../../library/threading.rst:797
#, fuzzy
msgid ""
"The current implementation wakes up exactly *n* threads, if at least *n* "
"threads are waiting.  However, it's not safe to rely on this behavior. A "
"future, optimized implementation may occasionally wake up more than *n* "
"threads."
msgstr ""
"如果至少有 *n* 個執行緒在等待，當前的實作恰好喚醒 *n* "
"個執行緒。但是，依賴此行為並不安全。未來的最佳化實作可能偶爾會喚醒超過 *n* "
"個執行緒。"

#: ../../library/threading.rst:802
#, fuzzy
msgid ""
"Note: an awakened thread does not actually return from its :meth:`wait` call "
"until it can reacquire the lock.  Since :meth:`notify` does not release the "
"lock, its caller should."
msgstr ""
"注意：一個被喚醒的執行緒實際上並沒有從它的 :meth:`wait` "
"呼叫中回傳，直到它可以重新獲取鎖。由於 :meth:`notify` "
"不釋放鎖，它的呼叫者應該。"

#: ../../library/threading.rst:808
#, fuzzy
msgid ""
"Wake up all threads waiting on this condition.  This method acts like :meth:"
"`notify`, but wakes up all waiting threads instead of one. If the calling "
"thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""
"喚醒所有在此條件下等待的執行緒。此方法的作用類似於 :meth:`notify`，但會喚醒所"
"有等待的執行緒而不是一個。如果在呼叫此方法時呼叫執行緒尚未獲取鎖，則會引發 "
":exc:`RuntimeError`。"

#: ../../library/threading.rst:813
#, fuzzy
msgid "The method ``notifyAll`` is a deprecated alias for this method."
msgstr "方法 ``notifyAll`` 是這個方法的棄用別名。"

#: ../../library/threading.rst:819
#, fuzzy
msgid "Semaphore Objects"
msgstr "信號量物件"

#: ../../library/threading.rst:821
#, fuzzy
msgid ""
"This is one of the oldest synchronization primitives in the history of "
"computer science, invented by the early Dutch computer scientist Edsger W. "
"Dijkstra (he used the names ``P()`` and ``V()`` instead of :meth:`~Semaphore."
"acquire` and :meth:`~Semaphore.release`)."
msgstr ""
"這是計算機科學史上最古老的同步原語之一，由早期的荷蘭計算機科學家 Edsger W. "
"Dijkstra 發明（他使用名稱 ``P()`` 和 ``V()`` 而不是 :meth :`~Semaphore."
"acquire` 和 :meth:`~Semaphore.release`)。"

#: ../../library/threading.rst:826
#, fuzzy
msgid ""
"A semaphore manages an internal counter which is decremented by each :meth:"
"`~Semaphore.acquire` call and incremented by each :meth:`~Semaphore.release` "
"call.  The counter can never go below zero; when :meth:`~Semaphore.acquire` "
"finds that it is zero, it blocks, waiting until some other thread calls :"
"meth:`~Semaphore.release`."
msgstr ""
"信號量管理一個內部計數器，該計數器在每次呼叫 :meth:`~Semaphore.acquire` "
"時遞減，並在每次呼叫 :meth:`~Semaphore.release` 時遞增。計數器永遠不會低於零；"
"當 :meth:`~Semaphore.acquire` 發現它為零時，它會阻塞，等待其他執行緒呼叫 "
":meth:`~Semaphore.release`。"

#: ../../library/threading.rst:832
#, fuzzy
msgid ""
"Semaphores also support the :ref:`context management protocol <with-locks>`."
msgstr "信號量還支援 :ref:`上下文管理協定 <with-locks>`。"

#: ../../library/threading.rst:837
#, fuzzy
msgid ""
"This class implements semaphore objects.  A semaphore manages an atomic "
"counter representing the number of :meth:`release` calls minus the number "
"of :meth:`acquire` calls, plus an initial value.  The :meth:`acquire` method "
"blocks if necessary until it can return without making the counter negative. "
"If not given, *value* defaults to 1."
msgstr ""
"此類實作信號量物件。信號量管理一個原子計數器，表示 release 呼叫的次數減去 "
"acquire 呼叫的次數，再加上一個初始值。 :meth:`acquire` "
"方法會在必要時阻塞，直到它可以回傳而不會使計數器為負。如果未給出，*value* "
"預設為 1。"

#: ../../library/threading.rst:843
#, fuzzy
msgid ""
"The optional argument gives the initial *value* for the internal counter; it "
"defaults to ``1``. If the *value* given is less than 0, :exc:`ValueError` is "
"raised."
msgstr "可選參數給出內部計數器的初始*值*；它預設為 ``1``。如果給定的 *value* 小於 0，"
"則會引發 :exc:`ValueError`。"

#: ../../library/threading.rst:852
#, fuzzy
msgid "Acquire a semaphore."
msgstr "獲取信號量。"

#: ../../library/threading.rst:854
#, fuzzy
msgid "When invoked without arguments:"
msgstr "不帶參數呼叫時："

#: ../../library/threading.rst:856
#, fuzzy
msgid ""
"If the internal counter is larger than zero on entry, decrement it by one "
"and return ``True`` immediately."
msgstr "如果內部計數器在輸入時大於零，則將其減 1 並立即回傳 ``True``。"

#: ../../library/threading.rst:858
#, fuzzy
msgid ""
"If the internal counter is zero on entry, block until awoken by a call to :"
"meth:`~Semaphore.release`.  Once awoken (and the counter is greater than 0), "
"decrement the counter by 1 and return ``True``.  Exactly one thread will be "
"awoken by each call to :meth:`~Semaphore.release`.  The order in which "
"threads are awoken should not be relied on."
msgstr ""
"如果入口時內部計數器為零，則阻塞直到呼叫 :meth:`~Semaphore.release` "
"喚醒。一旦喚醒（並且計數器大於 0），將計數器減 1 並回傳 ``True``。每次呼叫 "
":meth:`~Semaphore.release` 都會喚醒一個執行緒。不應依賴執行緒被喚醒的順序。"

#: ../../library/threading.rst:864
#, fuzzy
msgid ""
"When invoked with *blocking* set to ``False``, do not block.  If a call "
"without an argument would block, return ``False`` immediately; otherwise, do "
"the same thing as when called without arguments, and return ``True``."
msgstr ""
"當呼叫 *blocking* 設定為 ``False`` 時，不要阻塞。如果沒有參數的呼叫會阻塞，立"
"即回傳 ``False``；否則，執行與不帶參數呼叫時相同的操作，並回傳 ``True``。"

#: ../../library/threading.rst:868
#, fuzzy
msgid ""
"When invoked with a *timeout* other than ``None``, it will block for at most "
"*timeout* seconds.  If acquire does not complete successfully in that "
"interval, return ``False``.  Return ``True`` otherwise."
msgstr ""
"當使用 ``None`` 以外的 *timeout* 呼叫時，它最多會阻塞 *timeout* "
"秒。如果獲取在該時間間隔內未成功完成，則回傳 ``False``。否則回傳 ``True``。"

#: ../../library/threading.rst:877
#, fuzzy
msgid ""
"Release a semaphore, incrementing the internal counter by *n*.  When it was "
"zero on entry and other threads are waiting for it to become larger than "
"zero again, wake up *n* of those threads."
msgstr "釋放信號量，將內部計數器遞增 "
"*n*。當它在入口時為零並且其他執行緒正在等待它再次變得大於零時，喚醒 *n* "
"個執行緒。"

#: ../../library/threading.rst:881
#, fuzzy
msgid "Added the *n* parameter to release multiple waiting threads at once."
msgstr "新增了 *n* 參數以一次釋放多個等待執行緒。"

#: ../../library/threading.rst:887
#, fuzzy
msgid ""
"Class implementing bounded semaphore objects.  A bounded semaphore checks to "
"make sure its current value doesn't exceed its initial value.  If it does, :"
"exc:`ValueError` is raised. In most situations semaphores are used to guard "
"resources with limited capacity.  If the semaphore is released too many "
"times it's a sign of a bug.  If not given, *value* defaults to 1."
msgstr ""
"實作有界信號量物件的類。有界信號量會檢查以確保其當前值不超過其初始值。如果是"
"，則會引發 :exc:`ValueError`。在大多數情況下，信號量用於保護容量有限的資源。"
"如果信號量被釋放太多次，則表明存在錯誤。如果未給出，*value* 預設為 1。"

#: ../../library/threading.rst:900
msgid ":class:`Semaphore` Example"
msgstr ":class:`Semaphore` 範例"

#: ../../library/threading.rst:902
#, fuzzy
msgid ""
"Semaphores are often used to guard resources with limited capacity, for "
"example, a database server.  In any situation where the size of the resource "
"is fixed, you should use a bounded semaphore.  Before spawning any worker "
"threads, your main thread would initialize the semaphore::"
msgstr ""
"信號量通常用於保護容量有限的資源，例如資料庫伺服器。在資源大小固定的任何情況"
"下，都應該使用有界信號量。在生成任何工作執行緒之前，您的主執行緒將初始化信號"
"量::"

#: ../../library/threading.rst:911
#, fuzzy
msgid ""
"Once spawned, worker threads call the semaphore's acquire and release "
"methods when they need to connect to the server::"
msgstr "一旦產生，工作執行緒在需要連接到伺服器時呼叫信號量的獲取和釋放方法::"

#: ../../library/threading.rst:921
#, fuzzy
msgid ""
"The use of a bounded semaphore reduces the chance that a programming error "
"which causes the semaphore to be released more than it's acquired will go "
"undetected."
msgstr "有界信號量的使用減少了導致信號量釋放多於獲取信號量的編程錯誤未被檢測到的機會"
"。"

#: ../../library/threading.rst:928
#, fuzzy
msgid "Event Objects"
msgstr "事件物件"

#: ../../library/threading.rst:930
#, fuzzy
msgid ""
"This is one of the simplest mechanisms for communication between threads: "
"one thread signals an event and other threads wait for it."
msgstr "這是執行緒間最簡單的通信機制之一：一個執行緒發出事件信號，其他執行緒等待它。"

#: ../../library/threading.rst:933
#, fuzzy
msgid ""
"An event object manages an internal flag that can be set to true with the :"
"meth:`~Event.set` method and reset to false with the :meth:`~Event.clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is true."
msgstr ""
"事件對像管理一個內部旗標，可以使用 :meth:`~Event.set` 方法將其設定為 true，"
"並使用 :meth:`~Event.clear` 方法重置為 false。 :meth:`~Event.wait` "
"方法會阻塞，直到旗標為真。"

#: ../../library/threading.rst:940
#, fuzzy
msgid ""
"Class implementing event objects.  An event manages a flag that can be set "
"to true with the :meth:`~Event.set` method and reset to false with the :meth:"
"`clear` method.  The :meth:`wait` method blocks until the flag is true. The "
"flag is initially false."
msgstr ""
"實作事件物件的類。事件管理一個旗標，可以使用 :meth:`~Event.set` "
"方法將其設定為 true，並使用 :meth:`clear` 方法重置為 false。 :meth:`wait` "
"方法會阻塞，直到旗標為真。該旗標最初是錯誤的。"

#: ../../library/threading.rst:950
#, fuzzy
msgid "Return ``True`` if and only if the internal flag is true."
msgstr "當且僅當內部旗標為真時才回傳 ``True``。"

#: ../../library/threading.rst:952
#, fuzzy
msgid "The method ``isSet`` is a deprecated alias for this method."
msgstr "方法 ``isSet`` 是此方法的已棄用別名。"

#: ../../library/threading.rst:956
#, fuzzy
msgid ""
"Set the internal flag to true. All threads waiting for it to become true are "
"awakened. Threads that call :meth:`wait` once the flag is true will not "
"block at all."
msgstr "將內部旗標設定為 true。所有等待它變為真的執行緒都被喚醒。一旦旗標為真，呼叫 "
":meth:`wait` 的執行緒將完全不會阻塞。"

#: ../../library/threading.rst:962
#, fuzzy
msgid ""
"Reset the internal flag to false. Subsequently, threads calling :meth:`wait` "
"will block until :meth:`.set` is called to set the internal flag to true "
"again."
msgstr ""
"將內部旗標重置為 false。隨後，呼叫 :meth:`wait` 的執行緒將阻塞，直到呼叫 "
":meth:`.set` 再次將內部旗標設定為 true。"

#: ../../library/threading.rst:968
#, fuzzy
msgid ""
"Block until the internal flag is true.  If the internal flag is true on "
"entry, return immediately.  Otherwise, block until another thread calls :"
"meth:`.set` to set the flag to true, or until the optional timeout occurs."
msgstr ""
"阻塞直到內部旗標為真。如果入口時內部旗標為真，則立即回傳。否則，"
"阻塞直到另一個執行緒呼叫 :meth:`.set` 將旗標設定為 "
"true，或者直到發生可選的超時。"

#: ../../library/threading.rst:972
#, fuzzy
msgid ""
"When the timeout argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr "當存在超時參數而不是 ``None`` 時，它應該是一個浮點數，指定以秒（或其分數）為單位的"
"操作超時。"

#: ../../library/threading.rst:976
#, fuzzy
msgid ""
"This method returns ``True`` if and only if the internal flag has been set "
"to true, either before the wait call or after the wait starts, so it will "
"always return ``True`` except if a timeout is given and the operation times "
"out."
msgstr ""
"當且僅當內部旗標已設定為 true 時，此方法在等待呼叫之前或等待開始後回傳 "
"``True``，因此它將始終回傳 ``True`` 除非給出超時並且操作超時。"

#: ../../library/threading.rst:988
#, fuzzy
msgid "Timer Objects"
msgstr "計時器物件"

#: ../../library/threading.rst:990
#, fuzzy
msgid ""
"This class represents an action that should be run only after a certain "
"amount of time has passed --- a timer.  :class:`Timer` is a subclass of :"
"class:`Thread` and as such also functions as an example of creating custom "
"threads."
msgstr ""
"此類表示僅在經過一定時間後才應運行的操作 --- 計時器。 :class:`Timer` 是 "
":class:`Thread` 的子類別，因此也可以作為建立自定義執行緒的示例。"

#: ../../library/threading.rst:994
#, fuzzy
msgid ""
"Timers are started, as with threads, by calling their :meth:`~Timer.start` "
"method.  The timer can be stopped (before its action has begun) by calling "
"the :meth:`~Timer.cancel` method.  The interval the timer will wait before "
"executing its action may not be exactly the same as the interval specified "
"by the user."
msgstr ""
"與執行緒一樣，定時器通過呼叫它們的 :meth:`~Timer.start` 方法啟動。"
"可以通過呼叫 :meth:`~Timer.cancel` 方法停止計時器（在其動作開始之前）。計時器"
"在執行其操作之前等待的時間間隔可能與使用者指定的時間間隔不完全相同。"

#: ../../library/threading.rst:1000
msgid "For example::"
msgstr ""
"舉例來說：\n"
"\n"
"::"

#: ../../library/threading.rst:1011
#, fuzzy
msgid ""
"Create a timer that will run *function* with arguments *args* and  keyword "
"arguments *kwargs*, after *interval* seconds have passed. If *args* is "
"``None`` (the default) then an empty list will be used. If *kwargs* is "
"``None`` (the default) then an empty dict will be used."
msgstr ""
"建立一個計時器，它將在 *interval* 秒後運行帶有參數 *args* 和關鍵字參數 "
"*kwargs* 的 *function*。如果 *args* 是 "
"``None``（預設值），那麼將使用一個空列表。如果 *kwargs* 是 "
"``None``（預設值），那麼將使用一個空的字典。"

#: ../../library/threading.rst:1021
#, fuzzy
msgid ""
"Stop the timer, and cancel the execution of the timer's action.  This will "
"only work if the timer is still in its waiting stage."
msgstr "停止定時器，取消定時器動作的執行。這僅在計時器仍處於等待階段時才有效。"

#: ../../library/threading.rst:1026
#, fuzzy
msgid "Barrier Objects"
msgstr "障礙物"

#: ../../library/threading.rst:1030
#, fuzzy
msgid ""
"This class provides a simple synchronization primitive for use by a fixed "
"number of threads that need to wait for each other.  Each of the threads "
"tries to pass the barrier by calling the :meth:`~Barrier.wait` method and "
"will block until all of the threads have made their :meth:`~Barrier.wait` "
"calls. At this point, the threads are released simultaneously."
msgstr ""
"此類提供了一個簡單的同步原語，供需要相互等待的固定數量的執行緒使用。"
"每個執行緒都試圖通過呼叫 :meth:`~Barrier.wait` 方法來通過屏障，"
"並將阻塞直到所有執行緒都進行了它們的 :meth:`~Barrier.wait` "
"呼叫。此時，執行緒被同時釋放。"

#: ../../library/threading.rst:1036
#, fuzzy
msgid ""
"The barrier can be reused any number of times for the same number of threads."
msgstr "對於相同數量的執行緒，屏障可以重複使用任意次數。"

#: ../../library/threading.rst:1038
#, fuzzy
msgid ""
"As an example, here is a simple way to synchronize a client and server "
"thread::"
msgstr "例如，這裡有一個同步客戶端和伺服器執行緒的簡單方法："

#: ../../library/threading.rst:1058
#, fuzzy
msgid ""
"Create a barrier object for *parties* number of threads.  An *action*, when "
"provided, is a callable to be called by one of the threads when they are "
"released.  *timeout* is the default timeout value if none is specified for "
"the :meth:`wait` method."
msgstr ""
"為 *parties* 執行緒數建立屏障物件。一個*action*，當提供時，是一個可呼叫的，當"
"它們被釋放時，由其中一個執行緒呼叫。 *timeout* 是預設超時值，如果沒有為 "
":meth:`wait` 方法指定。"

#: ../../library/threading.rst:1065
#, fuzzy
msgid ""
"Pass the barrier.  When all the threads party to the barrier have called "
"this function, they are all released simultaneously.  If a *timeout* is "
"provided, it is used in preference to any that was supplied to the class "
"constructor."
msgstr "通過障礙。當屏障的所有執行緒都呼叫了這個函式時，它們都被同時釋放了。如果提供 "
"*timeout*，則優先使用提供給類構造函式的任何超時。"

#: ../../library/threading.rst:1070
#, fuzzy
msgid ""
"The return value is an integer in the range 0 to *parties* -- 1, different "
"for each thread.  This can be used to select a thread to do some special "
"housekeeping, e.g.::"
msgstr "回傳值是 0 到 *parties* -- 1 範圍內的整數，每個執行緒都不同。這可以用來選擇一"
"個執行緒來做一些特殊的內務處理，例如："

#: ../../library/threading.rst:1079
#, fuzzy
msgid ""
"If an *action* was provided to the constructor, one of the threads will have "
"called it prior to being released.  Should this call raise an error, the "
"barrier is put into the broken state."
msgstr "如果一個 *action* "
"被提供給構造函式，其中一個執行緒將在被釋放之前呼叫它。如果此呼叫引發錯誤，"
"則屏障將進入 broken 狀態。"

#: ../../library/threading.rst:1083
#, fuzzy
msgid "If the call times out, the barrier is put into the broken state."
msgstr "如果呼叫超時，屏障將進入 broken 狀態。"

#: ../../library/threading.rst:1085
#, fuzzy
msgid ""
"This method may raise a :class:`BrokenBarrierError` exception if the barrier "
"is broken or reset while a thread is waiting."
msgstr "如果屏障在執行緒等待時被破壞或重置，此方法可能會引發 BrokenBarrierError "
"例外。"

#: ../../library/threading.rst:1090
#, fuzzy
msgid ""
"Return the barrier to the default, empty state.  Any threads waiting on it "
"will receive the :class:`BrokenBarrierError` exception."
msgstr "將屏障恢復為預設的空狀態。任何等待它的執行緒都會收到 "
":class:`BrokenBarrierError` 例外。"

#: ../../library/threading.rst:1093
#, fuzzy
msgid ""
"Note that using this function may require some external synchronization if "
"there are other threads whose state is unknown.  If a barrier is broken it "
"may be better to just leave it and create a new one."
msgstr "請注意，如果存在其他狀態未知的執行緒，則使用此函式可能需要一些外部同步。如果"
"障礙被打破，最好離開它並建立一個新障礙。"

#: ../../library/threading.rst:1099
#, fuzzy
msgid ""
"Put the barrier into a broken state.  This causes any active or future calls "
"to :meth:`wait` to fail with the :class:`BrokenBarrierError`.  Use this for "
"example if one of the threads needs to abort, to avoid deadlocking the "
"application."
msgstr ""
"將結界置於破碎狀態。這會導致對 :meth:`wait` 的任何活動或未來呼叫失敗並回傳 :c"
"lass:`BrokenBarrierError`。例如，如果其中一個執行緒需要中止，請使用此方法以避"
"免應用程式死鎖。"

#: ../../library/threading.rst:1104
#, fuzzy
msgid ""
"It may be preferable to simply create the barrier with a sensible *timeout* "
"value to automatically guard against one of the threads going awry."
msgstr "最好簡單地建立具有合理 *timeout* 值的屏障，以自動防止其中一個執行緒出錯。"

#: ../../library/threading.rst:1110
#, fuzzy
msgid "The number of threads required to pass the barrier."
msgstr "通過屏障所需的執行緒數。"

#: ../../library/threading.rst:1114
#, fuzzy
msgid "The number of threads currently waiting in the barrier."
msgstr "當前在屏障中等待的執行緒數。"

#: ../../library/threading.rst:1118
#, fuzzy
msgid "A boolean that is ``True`` if the barrier is in the broken state."
msgstr "如果屏障處於損壞狀態，則為 ``True``的布爾值。"

#: ../../library/threading.rst:1123
#, fuzzy
msgid ""
"This exception, a subclass of :exc:`RuntimeError`, is raised when the :class:"
"`Barrier` object is reset or broken."
msgstr "此例外是 :exc:`RuntimeError` 的子類別，在 :class:`Barrier` "
"對像被重置或損壞時引發。"

#: ../../library/threading.rst:1130
#, fuzzy
msgid ""
"Using locks, conditions, and semaphores in the :keyword:`!with` statement"
msgstr "在 :keyword:`!with` 語句中使用鎖、條件和信號量"

#: ../../library/threading.rst:1132
#, fuzzy
msgid ""
"All of the objects provided by this module that have :meth:`acquire` and :"
"meth:`release` methods can be used as context managers for a :keyword:`with` "
"statement.  The :meth:`acquire` method will be called when the block is "
"entered, and :meth:`release` will be called when the block is exited.  "
"Hence, the following snippet::"
msgstr ""
"此模組提供的所有具有 :meth:`acquire` 和 :meth:`release` 方法的對像都可以用作 "
":keyword:`with` 語句的上下文管理器。 :meth:`acquire` 方法將在進入塊時呼叫，"
"而 :meth:`release` 將在退出塊時呼叫。因此，以下程式碼段::"

#: ../../library/threading.rst:1141
#, fuzzy
msgid "is equivalent to::"
msgstr "相當於：："

#: ../../library/threading.rst:1149
#, fuzzy
msgid ""
"Currently, :class:`Lock`, :class:`RLock`, :class:`Condition`, :class:"
"`Semaphore`, and :class:`BoundedSemaphore` objects may be used as :keyword:"
"`with` statement context managers."
msgstr ""
"目前，:class:`Lock`、:class:`RLock`、:class:`Condition`、:class:`Semaphore` "
"和 :class:`BoundedSemaphore` 物件可以用作 :keyword:`with` 語句上下文管理人員。"
