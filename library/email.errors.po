# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-10-26 16:47+0000\n"
"PO-Revision-Date: 2018-05-23 14:44+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/email.errors.rst:2
msgid ":mod:`email.errors`: Exception and Defect classes"
msgstr ":mod:`email.errors`: 例外和缺陷類別"

#: ../../library/email.errors.rst:7
msgid "**Source code:** :source:`Lib/email/errors.py`"
msgstr "**原始碼：**\\ :source:`Lib/email/errors.py`"

#: ../../library/email.errors.rst:11
#, fuzzy
msgid ""
"The following exception classes are defined in the :mod:`email.errors` "
"module:"
msgstr "以下例外類定義在 :mod:`email.errors` 模組中："

#: ../../library/email.errors.rst:16
#, fuzzy
msgid ""
"This is the base class for all exceptions that the :mod:`email` package can "
"raise.  It is derived from the standard :exc:`Exception` class and defines "
"no additional methods."
msgstr "這是 :mod:`email` 包可以引發的所有例外的基底類別。它派生自標準的 "
":exc:`Exception` 類並且沒有定義額外的方法。"

#: ../../library/email.errors.rst:23
#, fuzzy
msgid ""
"This is the base class for exceptions raised by the :class:`~email.parser."
"Parser` class.  It is derived from :exc:`MessageError`.  This class is also "
"used internally by the parser used by :mod:`~email.headerregistry`."
msgstr ""
"這是 :class:`~email.parser.Parser` 類引發的例外的基底類別。它源自 "
":exc:`MessageError`。此類也由 :mod:`~email.headerregistry` "
"使用的解析器在內部使用。"

#: ../../library/email.errors.rst:31
#, fuzzy
msgid ""
"Raised under some error conditions when parsing the :rfc:`5322` headers of a "
"message, this class is derived from :exc:`MessageParseError`.  The :meth:"
"`~email.message.EmailMessage.set_boundary` method will raise this error if "
"the content type is unknown when the method is called. :class:`~email.header."
"Header` may raise this error for certain base64 decoding errors, and when an "
"attempt is made to create a header that appears to contain an embedded "
"header (that is, there is what is supposed to be a continuation line that "
"has no leading whitespace and looks like a header)."
msgstr ""
"在解析消息的 :rfc:`5322` 標頭時在某些錯誤情況下引發，此類派生自 "
":exc:`MessageParseError`。如果呼叫該方法時內容型別未知，則 :meth:`~email."
"message.EmailMessage.set_boundary` 方法將引發此錯誤。 :class:`~email.header."
"Header` 可能會針對某些 base64 解碼錯誤引發此錯誤，並且當嘗試建立一個似乎包含"
"嵌入式標頭的標頭時（也就是說，應該是一個沒有前導空格且看起來像標題的續行）。"

#: ../../library/email.errors.rst:43
msgid "Deprecated and no longer used."
msgstr "已棄用且不再使用。"

#: ../../library/email.errors.rst:48
#, fuzzy
msgid ""
"Raised when a payload is added to a :class:`~email.message.Message` object "
"using :meth:`add_payload`, but the payload is already a scalar and the "
"message's :mailheader:`Content-Type` main type is not either :mimetype:"
"`multipart` or missing.  :exc:`MultipartConversionError` multiply inherits "
"from :exc:`MessageError` and the built-in :exc:`TypeError`."
msgstr ""
"當使用 add_payload 將有效負載新增到 :class:`~email.message.Message` "
"物件時引發，但有效負載已經是標量並且消息的 :mailheader:`Content-Type` "
"主要型別不是:mimetype:`multipart` 或缺失。 :exc:`MultipartConversionError` "
"多重繼承自 :exc:`MessageError` 和內建的 :exc:`TypeError`。"

#: ../../library/email.errors.rst:54
#, fuzzy
msgid ""
"Since :meth:`Message.add_payload` is deprecated, this exception is rarely "
"raised in practice.  However the exception may also be raised if the :meth:"
"`~email.message.Message.attach` method is called on an instance of a class "
"derived from :class:`~email.mime.nonmultipart.MIMENonMultipart` (e.g. :class:"
"`~email.mime.image.MIMEImage`)."
msgstr ""
"由於 :meth:`Message.add_payload` 已棄用，因此在實踐中很少引發此例外。但是，"
"如果在從 :class:`~email.mime.nonmultipart.MIMENonMultipart` "
"派生的類的實例上呼叫 :meth:`~email.message.Message.attach` "
"方法也可能引發例外（例如：class :`~email.mime.image.MIMEImage`)。"

#: ../../library/email.errors.rst:62
#, fuzzy
msgid ""
"Here is the list of the defects that the :class:`~email.parser.FeedParser` "
"can find while parsing messages.  Note that the defects are added to the "
"message where the problem was found, so for example, if a message nested "
"inside a :mimetype:`multipart/alternative` had a malformed header, that "
"nested message object would have a defect, but the containing messages would "
"not."
msgstr ""
"以下是 :class:`~email.parser.FeedParser` "
"在解析消息時可以發現的缺陷列表。請注意，缺陷會新增到發現問題的消息中，例如，"
"如果嵌套在 :mimetype:`multipart/alternative` "
"中的消息具有格式錯誤的標頭，則該嵌套消息物件將存在缺陷，但包含消息不會。"

#: ../../library/email.errors.rst:68
#, fuzzy
msgid ""
"All defect classes are subclassed from :class:`email.errors.MessageDefect`."
msgstr "所有缺陷類都是 email.errors.MessageDefect 的子類別。"

#: ../../library/email.errors.rst:70
#, fuzzy
msgid ""
":class:`NoBoundaryInMultipartDefect` -- A message claimed to be a multipart, "
"but had no :mimetype:`boundary` parameter."
msgstr ""
":class:`NoBoundaryInMultipartDefect` -- 消息聲稱是多部分，但沒有 "
":mimetype:`boundary` 參數。"

#: ../../library/email.errors.rst:73
#, fuzzy
msgid ""
":class:`StartBoundaryNotFoundDefect` -- The start boundary claimed in the :"
"mailheader:`Content-Type` header was never found."
msgstr ""
":class:`StartBoundaryNotFoundDefect` -- 從未找到 :mailheader:`Content-Type` "
"標頭中聲明的起始邊界。"

#: ../../library/email.errors.rst:76
#, fuzzy
msgid ""
":class:`CloseBoundaryNotFoundDefect` -- A start boundary was found, but no "
"corresponding close boundary was ever found."
msgstr ":class:`CloseBoundaryNotFoundDefect` -- "
"找到了起始邊界，但從未找到相應的閉合邊界。"

#: ../../library/email.errors.rst:81
#, fuzzy
msgid ""
":class:`FirstHeaderLineIsContinuationDefect` -- The message had a "
"continuation line as its first header line."
msgstr ":class:`FirstHeaderLineIsContinuationDefect` -- "
"該消息有一個續行作為其第一個標題行。"

#: ../../library/email.errors.rst:84
#, fuzzy
msgid ""
":class:`MisplacedEnvelopeHeaderDefect` - A \"Unix From\" header was found in "
"the middle of a header block."
msgstr ":class:`MisplacedEnvelopeHeaderDefect` - 在標頭塊中間發現“Unix From”標頭。"

#: ../../library/email.errors.rst:87
#, fuzzy
msgid ""
":class:`MissingHeaderBodySeparatorDefect` - A line was found while parsing "
"headers that had no leading white space but contained no ':'.  Parsing "
"continues assuming that the line represents the first line of the body."
msgstr ""
":class:`MissingHeaderBodySeparatorDefect` - 在解析沒有前導空格但不包含 ``:``的標"
"頭時發現一行。假設該行代表正文的第一行，繼續解析。"

#: ../../library/email.errors.rst:93
#, fuzzy
msgid ""
":class:`MalformedHeaderDefect` -- A header was found that was missing a "
"colon, or was otherwise malformed."
msgstr ":class:`MalformedHeaderDefect` -- 發現缺少冒號或格式錯誤的標頭。"

#: ../../library/email.errors.rst:96
#, fuzzy
msgid "This defect has not been used for several Python versions."
msgstr "此缺陷尚未用於多個 Python 版本。"

#: ../../library/email.errors.rst:99
#, fuzzy
msgid ""
":class:`MultipartInvariantViolationDefect` -- A message claimed to be a :"
"mimetype:`multipart`, but no subparts were found.  Note that when a message "
"has this defect, its :meth:`~email.message.Message.is_multipart` method may "
"return ``False`` even though its content type claims to be :mimetype:"
"`multipart`."
msgstr ""
":class:`MultipartInvariantViolationDefect` -- 聲稱是 :mimetype:`multipart` "
"的消息，但未找到任何子部分。請注意，當消息存在此缺陷時，其 :meth:`~email."
"message.Message.is_multipart` 方法可能會回傳 ``False``，即使其內容型別聲稱為 "
":mimetype:`multipart`。"

#: ../../library/email.errors.rst:104
#, fuzzy
msgid ""
":class:`InvalidBase64PaddingDefect` -- When decoding a block of base64 "
"encoded bytes, the padding was not correct.  Enough padding is added to "
"perform the decode, but the resulting decoded bytes may be invalid."
msgstr ""
":class:`InvalidBase64PaddingDefect` -- 在解碼 base64 編碼位元組塊時，填充不正"
"確。新增了足夠的填充以執行解碼，但生成的解碼位元組可能無效。"

#: ../../library/email.errors.rst:108
#, fuzzy
msgid ""
":class:`InvalidBase64CharactersDefect` -- When decoding a block of base64 "
"encoded bytes, characters outside the base64 alphabet were encountered. The "
"characters are ignored, but the resulting decoded bytes may be invalid."
msgstr ""
":class:`InvalidBase64CharactersDefect` -- 在解碼 base64 編碼位元組塊時，"
"遇到了 base64 字母表之外的字元。字元被忽略，但生成的解碼位元組可能無效。"

#: ../../library/email.errors.rst:112
#, fuzzy
msgid ""
":class:`InvalidBase64LengthDefect` -- When decoding a block of base64 "
"encoded bytes, the number of non-padding base64 characters was invalid (1 "
"more than a multiple of 4).  The encoded block was kept as-is."
msgstr ""
":class:`InvalidBase64LengthDefect` -- 在解碼 base64 編碼位元組塊時，非填充 "
"base64 字元的數量無效（1 大於 4 的倍數）。編碼塊保持原樣。"

#: ../../library/email.errors.rst:116
#, fuzzy
msgid ""
":class:`InvalidDateDefect` -- When decoding an invalid or unparsable date "
"field. The original value is kept as-is."
msgstr ":class:`InvalidDateDefect` -- "
"解碼無效或無法解析的日期欄位時。原始值保持原樣。"
