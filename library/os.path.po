# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-13 00:17+0000\n"
"PO-Revision-Date: 2018-05-23 16:07+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/os.path.rst:2
msgid ":mod:`os.path` --- Common pathname manipulations"
msgstr ":mod:`os.path` --- 常見的路徑名稱操作"

#: ../../library/os.path.rst:7
msgid ""
"**Source code:** :source:`Lib/posixpath.py` (for POSIX) and :source:`Lib/"
"ntpath.py` (for Windows)."
msgstr ""
"**原始碼：**\\ :source:`Lib/posixpath.py`\\ （對於 POSIX）與 :source:`Lib/"
"ntpath.py`\\（對於 Windows）。"

#: ../../library/os.path.rst:14
#, fuzzy
msgid ""
"This module implements some useful functions on pathnames. To read or write "
"files see :func:`open`, and for accessing the filesystem see the :mod:`os` "
"module. The path parameters can be passed as strings, or bytes, or any "
"object implementing the :class:`os.PathLike` protocol."
msgstr ""
"該模組在路徑名上實作了一些有用的功能。要讀取或寫入文件，請參閱 "
":func:`open`，要訪問文件系統，請參閱 :mod:`os` 模組。路徑參數可以作為字串、"
"位元組或任何實作 os.PathLike 協定的對像傳遞。"

#: ../../library/os.path.rst:19
#, fuzzy
msgid ""
"Unlike a Unix shell, Python does not do any *automatic* path expansions. "
"Functions such as :func:`expanduser` and :func:`expandvars` can be invoked "
"explicitly when an application desires shell-like path expansion.  (See also "
"the :mod:`glob` module.)"
msgstr ""
"與 Unix shell 不同，Python 不進行任何*自動*路徑擴充。當應用程式需要類似 "
"shell 的路徑擴充時，可以顯式呼叫 :func:`expanduser` 和 :func:`expandvars` "
"等函式。 （另請參閱 :mod:`glob` 模組。）"

#: ../../library/os.path.rst:26
#, fuzzy
msgid "The :mod:`pathlib` module offers high-level path objects."
msgstr ":mod:`pathlib` 模組提供高階路徑物件。"

#: ../../library/os.path.rst:31
#, fuzzy
msgid ""
"All of these functions accept either only bytes or only string objects as "
"their parameters.  The result is an object of the same type, if a path or "
"file name is returned."
msgstr "所有這些函式都只接受位元組或字串對像作為它們的參數。如果回傳路徑或文件名，則"
"結果是相同型別的物件。"

#: ../../library/os.path.rst:37
#, fuzzy
msgid ""
"Since different operating systems have different path name conventions, "
"there are several versions of this module in the standard library.  The :mod:"
"`os.path` module is always the path module suitable for the operating system "
"Python is running on, and therefore usable for local paths.  However, you "
"can also import and use the individual modules if you want to manipulate a "
"path that is *always* in one of the different formats.  They all have the "
"same interface:"
msgstr ""
"由於不同的操作系統有不同的路徑名約定，因此標準庫中有該模組的多個版本。 "
":mod:`os.path` 模組始終是適合運行 Python 的操作系統的路徑模組，因此可用於本地"
"路徑。但是，如果您想要操作*始終*採用不同格式之一的路徑，您也可以導入和使用各"
"個模組。它們都有相同的界面："

#: ../../library/os.path.rst:45
#, fuzzy
msgid ":mod:`posixpath` for UNIX-style paths"
msgstr ":mod:`posixpath` 用於 UNIX 風格的路徑"

#: ../../library/os.path.rst:46
#, fuzzy
msgid ":mod:`ntpath` for Windows paths"
msgstr "Windows 路徑的 :mod:`ntpath`"

#: ../../library/os.path.rst:51
#, fuzzy
msgid ""
":func:`exists`, :func:`lexists`, :func:`isdir`, :func:`isfile`, :func:"
"`islink`, and :func:`ismount` now return ``False`` instead of raising an "
"exception for paths that contain characters or bytes unrepresentable at the "
"OS level."
msgstr ""
":func:`exists`、:func:`lexists`、:func:`isdir`、:func:`isfile`、:func:`islink"
"` 和 :func:`ismount` 現在回傳 "
"``False``為包含在操作系統級別無法表示的字元或位元組的路徑引發例外。"

#: ../../library/os.path.rst:59
#, fuzzy
msgid ""
"Return a normalized absolutized version of the pathname *path*. On most "
"platforms, this is equivalent to calling the function :func:`normpath` as "
"follows: ``normpath(join(os.getcwd(), path))``."
msgstr ""
"回傳路徑名 *path* 的規範化絕對化版本。在大多數平台上，這相當於呼叫函式 "
":func:`normpath` 如下：``normpath(join(os.getcwd(), path))``。"

#: ../../library/os.path.rst:63 ../../library/os.path.rst:76
#: ../../library/os.path.rst:116 ../../library/os.path.rst:125
#: ../../library/os.path.rst:141 ../../library/os.path.rst:151
#: ../../library/os.path.rst:177 ../../library/os.path.rst:197
#: ../../library/os.path.rst:214 ../../library/os.path.rst:226
#: ../../library/os.path.rst:235 ../../library/os.path.rst:245
#: ../../library/os.path.rst:255 ../../library/os.path.rst:265
#: ../../library/os.path.rst:275 ../../library/os.path.rst:294
#: ../../library/os.path.rst:325 ../../library/os.path.rst:345
#: ../../library/os.path.rst:368 ../../library/os.path.rst:390
#: ../../library/os.path.rst:408 ../../library/os.path.rst:421
#: ../../library/os.path.rst:437 ../../library/os.path.rst:453
#: ../../library/os.path.rst:478 ../../library/os.path.rst:509
#, fuzzy
msgid "Accepts a :term:`path-like object`."
msgstr "接受一個 :term:`path-like object`。"

#: ../../library/os.path.rst:69
#, fuzzy
msgid ""
"Return the base name of pathname *path*.  This is the second element of the "
"pair returned by passing *path* to the function :func:`split`.  Note that "
"the result of this function is different from the Unix :program:`basename` "
"program; where :program:`basename` for ``'/foo/bar/'`` returns ``'bar'``, "
"the :func:`basename` function returns an empty string (``''``)."
msgstr ""
"回傳路徑名 *path* 的基本名稱。這是通過將 *path* 傳遞給函式 :func:`split` "
"回傳的對中的第二個元素。請注意，此函式的結果與 Unix :program:`basename` "
"程式不同；其中 :program:`basename` for ``'/foo/bar/'`` 回傳 "
"``'bar'``，:func:`basename` 函式回傳一個空字串 (``''``)。"

#: ../../library/os.path.rst:82
#, fuzzy
msgid ""
"Return the longest common sub-path of each pathname in the sequence "
"*paths*.  Raise :exc:`ValueError` if *paths* contain both absolute and "
"relative pathnames, the *paths* are on the different drives or if *paths* is "
"empty.  Unlike :func:`commonprefix`, this returns a valid path."
msgstr ""
"回傳序列 *paths* 中每個路徑名的最長公開子路徑。如果 *paths* "
"包含絕對路徑名和相對路徑名，*paths* 在不同的驅動器上，或者 *paths* 為空，"
"則引發 :exc:`ValueError`。與 :func:`commonprefix` "
"不同，這會回傳一個有效路徑。"

#: ../../library/os.path.rst:88 ../../library/os.path.rst:388
#: ../../library/os.path.rst:400 ../../library/os.path.rst:416
#: ../../library/os.path.rst:432
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`適用 <availability>`：Unix、Windows。"

#: ../../library/os.path.rst:92
#, fuzzy
msgid "Accepts a sequence of :term:`path-like objects <path-like object>`."
msgstr "接受一系列 :term:`path-like objects <path-like object>`。"

#: ../../library/os.path.rst:98
#, fuzzy
msgid ""
"Return the longest path prefix (taken character-by-character) that is a "
"prefix of all paths in  *list*.  If *list* is empty, return the empty string "
"(``''``)."
msgstr "回傳最長的路徑前綴（逐個字元獲取），它是 *list* 中所有路徑的前綴。如果 *list*"
" 為空，則回傳空字串 (``''``)。"

#: ../../library/os.path.rst:104
#, fuzzy
msgid ""
"This function may return invalid paths because it works a character at a "
"time.  To obtain a valid path, see :func:`commonpath`."
msgstr "此函式可能會回傳無效路徑，因為它一次處理一個字元。要獲取有效路徑，請參閱 "
":func:`commonpath`。"

#: ../../library/os.path.rst:122
#, fuzzy
msgid ""
"Return the directory name of pathname *path*.  This is the first element of "
"the pair returned by passing *path* to the function :func:`split`."
msgstr "回傳路徑名 *path* 的目錄名。這是通過將 *path* 傳遞給函式 :func:`split` "
"回傳的對中的第一個元素。"

#: ../../library/os.path.rst:131
#, fuzzy
msgid ""
"Return ``True`` if *path* refers to an existing path or an open file "
"descriptor.  Returns ``False`` for broken symbolic links.  On some "
"platforms, this function may return ``False`` if permission is not granted "
"to execute :func:`os.stat` on the requested file, even if the *path* "
"physically exists."
msgstr ""
"如果 *path* 指的是現有路徑或打開的文件描述器，則回傳 "
"``True``。對於損壞的符號鏈接回傳 ``False``。在某些平台上，"
"如果未授予在請求的文件上執行 os.stat 的權限，此函式可能會回傳 ``False``，即使 "
"*path* 實際存在。"

#: ../../library/os.path.rst:137
#, fuzzy
msgid ""
"*path* can now be an integer: ``True`` is returned if it is an  open file "
"descriptor, ``False`` otherwise."
msgstr "*path* 現在可以是一個整數：如果它是一個打開的文件描述器，則回傳 ``True``，"
"否則回傳 ``False``。"

#: ../../library/os.path.rst:147
#, fuzzy
msgid ""
"Return ``True`` if *path* refers to an existing path. Returns ``True`` for "
"broken symbolic links.   Equivalent to :func:`exists` on platforms lacking :"
"func:`os.lstat`."
msgstr ""
"如果 *path* 指的是現有路徑，則回傳 ``True``。為損壞的符號鏈接回傳 ``True``。"
"在缺少 :func:`os.lstat` 的平台上等同於 :func:`exists`。"

#: ../../library/os.path.rst:159
#, fuzzy
msgid ""
"On Unix and Windows, return the argument with an initial component of ``~`` "
"or ``~user`` replaced by that *user*'s home directory."
msgstr "在 Unix 和 Windows 上，回傳帶有 ``~`` 或 ``~user`` 的初始組件的參數，"
"替換為該 *user* 的主目錄。"

#: ../../library/os.path.rst:164
#, fuzzy
msgid ""
"On Unix, an initial ``~`` is replaced by the environment variable :envvar:"
"`HOME` if it is set; otherwise the current user's home directory is looked "
"up in the password directory through the built-in module :mod:`pwd`. An "
"initial ``~user`` is looked up directly in the password directory."
msgstr ""
"在 Unix 上，初始的 ``~`` 被環境變數 :envvar:`HOME` 替換（如果已設定）；否則，"
"通過內建模組 :mod:`pwd` 在密碼目錄中查找當前使用者的主目錄。初始的 ``~user`` "
"直接在密碼目錄中查找。"

#: ../../library/os.path.rst:169
#, fuzzy
msgid ""
"On Windows, :envvar:`USERPROFILE` will be used if set, otherwise a "
"combination of :envvar:`HOMEPATH` and :envvar:`HOMEDRIVE` will be used.  An "
"initial ``~user`` is handled by checking that the last directory component "
"of the current user's home directory matches :envvar:`USERNAME`, and "
"replacing it if so."
msgstr ""
"在 Windows 上，如果設定 :envvar:`USERPROFILE` "
"將被使用，否則將使用 :envvar:`HOMEPATH` 和 :envvar:`HOMEDRIVE` 的組合。"
"通過檢查當前使用者主目錄的最後一個目錄組件是否匹配 :envvar:`USERNAME "
"來處理初始的 ~user ，如果匹配則替換它。"

#: ../../library/os.path.rst:174
#, fuzzy
msgid ""
"If the expansion fails or if the path does not begin with a tilde, the path "
"is returned unchanged."
msgstr "如果擴充失敗或者路徑不以波浪號開頭，則回傳路徑不變。"

#: ../../library/os.path.rst:180
#, fuzzy
msgid "No longer uses :envvar:`HOME` on Windows."
msgstr "不再在 Windows 上使用 :envvar:`HOME`。"

#: ../../library/os.path.rst:189
#, fuzzy
msgid ""
"Return the argument with environment variables expanded.  Substrings of the "
"form ``$name`` or ``${name}`` are replaced by the value of environment "
"variable *name*.  Malformed variable names and references to non-existing "
"variables are left unchanged."
msgstr ""
"回傳擴充了環境變數的參數。 ``$name`` 或 ``${name}`` 形式的子字串被環境變數 "
"*name* 的值替換。格式錯誤的變數名稱和對不存在變數的引用保持不變。"

#: ../../library/os.path.rst:194
#, fuzzy
msgid ""
"On Windows, ``%name%`` expansions are supported in addition to ``$name`` and "
"``${name}``."
msgstr "在 Windows 上，除了 ``$name`` 和 ``${name}`` 之外，還支援 ``%name%`` 擴充。"

#: ../../library/os.path.rst:203
#, fuzzy
msgid ""
"Return the time of last access of *path*.  The return value is a floating "
"point number giving the number of seconds since the epoch (see the  :mod:"
"`time` module).  Raise :exc:`OSError` if the file does not exist or is "
"inaccessible."
msgstr ""
"回傳上次訪問 *path* 的時間。回傳值是一個浮點數，給出自紀元以來的秒數（參見 "
":mod:`time` 模組）。如果文件不存在或不可訪問，則引發 :exc:`OSError`。"

#: ../../library/os.path.rst:210
#, fuzzy
msgid ""
"Return the time of last modification of *path*.  The return value is a "
"floating point number giving the number of seconds since the epoch (see "
"the  :mod:`time` module). Raise :exc:`OSError` if the file does not exist or "
"is inaccessible."
msgstr ""
"回傳 *path* 的最後修改時間。回傳值是一個浮點數，給出自紀元以來的秒數（參見 "
":mod:`time` 模組）。如果文件不存在或不可訪問，則引發 :exc:`OSError`。"

#: ../../library/os.path.rst:220
#, fuzzy
msgid ""
"Return the system's ctime which, on some systems (like Unix) is the time of "
"the last metadata change, and, on others (like Windows), is the creation "
"time for *path*. The return value is a number giving the number of seconds "
"since the epoch (see the  :mod:`time` module).  Raise :exc:`OSError` if the "
"file does not exist or is inaccessible."
msgstr ""
"回傳系統的 ctime，在某些系統（如 "
"Unix）上，它是最後一次元資料更改的時間，而在其他系統（如 Windows）上，它是 "
"*path* 的建立時間。回傳值是一個數字，表示自紀元以來的秒數（請參閱 :mod:`time`"
" 模組）。如果文件不存在或不可訪問，則引發 :exc:`OSError`。"

#: ../../library/os.path.rst:232
#, fuzzy
msgid ""
"Return the size, in bytes, of *path*.  Raise :exc:`OSError` if the file does "
"not exist or is inaccessible."
msgstr "回傳 *path* 的大小（以位元組為單位）。如果文件不存在或不可訪問，則引發 "
":exc:`OSError`。"

#: ../../library/os.path.rst:241
#, fuzzy
msgid ""
"Return ``True`` if *path* is an absolute pathname.  On Unix, that means it "
"begins with a slash, on Windows that it begins with a (back)slash after "
"chopping off a potential drive letter."
msgstr ""
"如果 *path* 是絕對路徑名，則回傳 ``True``。在 Unix 上，這意味著它以斜杠開頭，"
"在 Windows 上，它在切斷潛在的驅動器號後以（反）斜杠開頭。"

#: ../../library/os.path.rst:251
#, fuzzy
msgid ""
"Return ``True`` if *path* is an :func:`existing <exists>` regular file. This "
"follows symbolic links, so both :func:`islink` and :func:`isfile` can be "
"true for the same path."
msgstr ""
"如果 *path* 是一個 :func:`existing <exists>` 常規文件，則回傳 "
"``True``。這遵循符號鏈接，因此 :func:`islink` 和 :func:`isfile` "
"對於同一路徑都可以為真。"

#: ../../library/os.path.rst:261
#, fuzzy
msgid ""
"Return ``True`` if *path* is an :func:`existing <exists>` directory.  This "
"follows symbolic links, so both :func:`islink` and :func:`isdir` can be true "
"for the same path."
msgstr ""
"如果 *path* 是一個存在的 <exists> 目錄，則回傳 ``True``。這遵循符號鏈接，"
"因此 :func:`islink` 和 :func:`isdir` 對於同一路徑都可以為真。"

#: ../../library/os.path.rst:271
#, fuzzy
msgid ""
"Return ``True`` if *path* refers to an :func:`existing <exists>` directory "
"entry that is a symbolic link.  Always ``False`` if symbolic links are not "
"supported by the Python runtime."
msgstr ""
"如果 *path* 指的是作為符號鏈接的現有 <exists> 目錄條目，則回傳 ``True``。"
"如果 Python 運行時不支援符號鏈接，則始終為 ``False``。"

#: ../../library/os.path.rst:281
#, fuzzy
msgid ""
"Return ``True`` if pathname *path* is a :dfn:`mount point`: a point in a "
"file system where a different file system has been mounted.  On POSIX, the "
"function checks whether *path*'s parent, :file:`{path}/..`, is on a "
"different device than *path*, or whether :file:`{path}/..` and *path* point "
"to the same i-node on the same device --- this should detect mount points "
"for all Unix and POSIX variants.  It is not able to reliably detect bind "
"mounts on the same filesystem.  On Windows, a drive letter root and a share "
"UNC are always mount points, and for any other path ``GetVolumePathName`` is "
"called to see if it is different from the input path."
msgstr ""
"如果路徑名 *path* 是 :dfn:`mount point` 則回傳 "
"``True``：文件系統中已安裝不同文件系統的點。在 POSIX 上，該函式檢查 *path* "
"的父級 :file:`{path}/..` 是否在與 *path* 不同的設備上，或者 :file:`{path}/..`"
" 和*path* 指向同一設備上的同一 i-node --- 這應該檢測所有 Unix 和 POSIX "
"變體的安裝點。它無法可靠地檢測同一文件系統上的綁定掛載。在 Windows 上，"
"根驅動器盤符和共享 UNC 始終是掛載點，對於任何其他路徑，呼叫 "
"``GetVolumePathName`` 以查看它是否與輸入路徑不同。"

#: ../../library/os.path.rst:291
#, fuzzy
msgid "Support for detecting non-root mount points on Windows."
msgstr "支援檢測 Windows 上的非根安裝點。"

#: ../../library/os.path.rst:300
#, fuzzy
msgid ""
"Join one or more path segments intelligently.  The return value is the "
"concatenation of *path* and all members of *\\*paths*, with exactly one "
"directory separator following each non-empty part, except the last. That is, "
"the result will only end in a separator if the last part is either empty or "
"ends in a separator. If a segment is an absolute path (which on Windows "
"requires both a drive and a root), then all previous segments are ignored "
"and joining continues from the absolute path segment."
msgstr ""
"智能地加入一個或多個路徑段。回傳值是 *path* 和 *\\*paths* 的所有成員的串聯，"
"每個非空部分後面只有一個目錄分隔符，最後一個除外。也就是說，如果最後一部分為"
"空或以分隔符結尾，結果將僅以分隔符結尾。如果段是絕對路徑（在 Windows "
"上需要驅動器和根目錄），則忽略所有先前的段，並從絕對路徑段繼續連接。"

#: ../../library/os.path.rst:308
#, fuzzy
msgid ""
"On Windows, the drive is not reset when a rooted path segment (e.g., "
"``r'\\foo'``) is encountered. If a segment is on a different drive or is an "
"absolute path, all previous segments are ignored and the drive is reset. "
"Note that since there is a current directory for each drive, ``os.path."
"join(\"c:\", \"foo\")`` represents a path relative to the current directory "
"on drive :file:`C:` (:file:`c:foo`), not :file:`c:\\\\foo`."
msgstr ""
"在 Windows 上，當遇到根路徑段（例如，``r\\'\\foo\\'``）時，驅動器不會重置。如"
"果一個段位於不同的驅動器上或者是絕對路徑，則忽略所有先前的段並且驅動器被重置"
"。請注意，由於每個驅動器都有一個當前目錄，``os.path.join(\"c:\", \"foo\")`` "
"表示相對於驅動器上當前目錄的路徑 :file:`C:` (: file:`c:foo`)，而不是 "
":file:`c:\\\\foo`。"

#: ../../library/os.path.rst:315
#, fuzzy
msgid "Accepts a :term:`path-like object` for *path* and *paths*."
msgstr "接受 *path* 和 *paths* 的 :term:`path-like object`。"

#: ../../library/os.path.rst:321
#, fuzzy
msgid ""
"Normalize the case of a pathname.  On Windows, convert all characters in the "
"pathname to lowercase, and also convert forward slashes to backward slashes. "
"On other operating systems, return the path unchanged."
msgstr "規範化路徑名的大小寫。在 Windows 上，將路徑名中的所有字元轉換為小寫，並將正斜"
"杠轉換為反斜杠。在其他操作系統上，回傳路徑不變。"

#: ../../library/os.path.rst:331
#, fuzzy
msgid ""
"Normalize a pathname by collapsing redundant separators and up-level "
"references so that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all "
"become ``A/B``.  This string manipulation may change the meaning of a path "
"that contains symbolic links.  On Windows, it converts forward slashes to "
"backward slashes. To normalize case, use :func:`normcase`."
msgstr ""
"通過折疊冗餘分隔符和上層引用來規範化路徑名，以便 ``A//B``、``A/"
"B/``、``A/./B`` 和 ``A/foo/.. /B`` 全部變為 ``A/"
"B``。此字串操作可能會更改包含符號鏈接的路徑的含義。在 Windows "
"上，它將正斜杠轉換為反斜杠。要標準化大小寫，請使用 :func:`normcase`。"

#: ../../library/os.path.rst:338
#, fuzzy
msgid ""
"On POSIX systems, in accordance with `IEEE Std 1003.1 2013 Edition; 4.13 "
"Pathname Resolution <https://pubs.opengroup.org/onlinepubs/9699919799/"
"basedefs/V1_chap04.html#tag_04_13>`_, if a pathname begins with exactly two "
"slashes, the first component following the leading characters may be "
"interpreted in an implementation-defined manner, although more than two "
"leading characters shall be treated as a single character."
msgstr ""
"在 POSIX 系統上，符合 `IEEE Std 1003.1 2013 版； 4.13 路徑名解析 "
"<https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag"
"_04_13>`_，如果路徑名恰好以兩個斜杠開頭，則前導字元後面的第一個組件可能會被解"
"釋為實作定義的方式，儘管兩個以上的前導字元應被視為單個字元。"

#: ../../library/os.path.rst:351
#, fuzzy
msgid ""
"Return the canonical path of the specified filename, eliminating any "
"symbolic links encountered in the path (if they are supported by the "
"operating system)."
msgstr "回傳指定文件名的規範路徑，消除路徑中遇到的任何符號鏈接（如果操作系統支援它們"
"）。"

#: ../../library/os.path.rst:355
#, fuzzy
msgid ""
"If a path doesn't exist or a symlink loop is encountered, and *strict* is "
"``True``, :exc:`OSError` is raised. If *strict* is ``False``, the path is "
"resolved as far as possible and any remainder is appended without checking "
"whether it exists."
msgstr ""
"如果路徑不存在或遇到符號鏈接循環，並且 *strict* 為 ``True``，則會引發 "
":exc:`OSError`。如果 *strict* 為 "
"``False``，則盡可能解析路徑並附加任何餘數而不檢查它是否存在。"

#: ../../library/os.path.rst:361
#, fuzzy
msgid ""
"This function emulates the operating system's procedure for making a path "
"canonical, which differs slightly between Windows and UNIX with respect to "
"how links and subsequent path components interact."
msgstr "此函式模擬操作系統使路徑規範化的過程，Windows 和 UNIX "
"在鏈接和後續路徑組件如何交互方面略有不同。"

#: ../../library/os.path.rst:365
#, fuzzy
msgid ""
"Operating system APIs make paths canonical as needed, so it's not normally "
"necessary to call this function."
msgstr "操作系統 API 根據需要使路徑規範化，因此通常不需要呼叫此函式。"

#: ../../library/os.path.rst:371
#, fuzzy
msgid "Symbolic links and junctions are now resolved on Windows."
msgstr "符號鏈接和聯結現在在 Windows 上解析。"

#: ../../library/os.path.rst:374
msgid "The *strict* parameter was added."
msgstr "新增 *strict* 參數。"

#: ../../library/os.path.rst:380
#, fuzzy
msgid ""
"Return a relative filepath to *path* either from the current directory or "
"from an optional *start* directory.  This is a path computation:  the "
"filesystem is not accessed to confirm the existence or nature of *path* or "
"*start*.  On Windows, :exc:`ValueError` is raised when *path* and *start* "
"are on different drives."
msgstr ""
"從當前目錄或可選的 *start* 目錄回傳到 *path* 的相對文件路徑。這是路徑計算："
"不訪問文件系統以確認 *path* 或 *start* 的存在或性質。在 Windows 上，當 *path*"
" 和 *start* 在不同的驅動器上時會引發 :exc:`ValueError`。"

#: ../../library/os.path.rst:386
#, fuzzy
msgid "*start* defaults to :attr:`os.curdir`."
msgstr "*start* 預設為 :attr:`os.curdir`。"

#: ../../library/os.path.rst:396
#, fuzzy
msgid ""
"Return ``True`` if both pathname arguments refer to the same file or "
"directory. This is determined by the device number and i-node number and "
"raises an exception if an :func:`os.stat` call on either pathname fails."
msgstr ""
"如果兩個路徑名參數引用相同的文件或目錄，則回傳 True。這由設備號和 i-node "
"號決定，如果對任一路徑名的 os.stat 呼叫失敗，則會引發例外。"

#: ../../library/os.path.rst:402 ../../library/os.path.rst:418
#: ../../library/os.path.rst:434
msgid "Added Windows support."
msgstr "新增對 Windows 的支援。"

#: ../../library/os.path.rst:405
#, fuzzy
msgid "Windows now uses the same implementation as all other platforms."
msgstr "Windows 現在使用與所有其他平台相同的實作。"

#: ../../library/os.path.rst:414
#, fuzzy
msgid ""
"Return ``True`` if the file descriptors *fp1* and *fp2* refer to the same "
"file."
msgstr "如果文件描述器 *fp1* 和 *fp2* 引用同一個文件，則回傳 True。"

#: ../../library/os.path.rst:427
#, fuzzy
msgid ""
"Return ``True`` if the stat tuples *stat1* and *stat2* refer to the same "
"file. These structures may have been returned by :func:`os.fstat`, :func:`os."
"lstat`, or :func:`os.stat`.  This function implements the underlying "
"comparison used by :func:`samefile` and :func:`sameopenfile`."
msgstr ""
"如果統計元組 *stat1* 和 *stat2* 引用同一個文件，則回傳 ``True``。"
"這些結構可能已由 :func:`os.fstat`、:func:`os.lstat` 或 :func:`os.stat` 回傳。"
"此函式實作了 :func:`samefile` 和 :func:`sameopenfile` 使用的底層比較。"

#: ../../library/os.path.rst:443
#, fuzzy
msgid ""
"Split the pathname *path* into a pair, ``(head, tail)`` where *tail* is the "
"last pathname component and *head* is everything leading up to that.  The "
"*tail* part will never contain a slash; if *path* ends in a slash, *tail* "
"will be empty.  If there is no slash in *path*, *head* will be empty.  If "
"*path* is empty, both *head* and *tail* are empty.  Trailing slashes are "
"stripped from *head* unless it is the root (one or more slashes only).  In "
"all cases, ``join(head, tail)`` returns a path to the same location as "
"*path* (but the strings may differ).  Also see the functions :func:`dirname` "
"and :func:`basename`."
msgstr ""
"將路徑名 *path* 分成一對，``(head, tail)`` 其中 *tail* "
"是最後一個路徑名組件，*head* 是導致它的所有內容。 *tail* "
"部分永遠不會包含斜杠；如果 *path* 以斜杠結尾，*tail* 將為空。如果*path* "
"中沒有斜杠，*head* 將為空。如果 *path* 為空，則 *head* 和 *tail* 均為空。"
"尾部斜杠從 *head* "
"中刪除，除非它是根（僅一個或多個斜杠）。在所有情況下，``join(head, tail)`` "
"回傳與 *path* 相同位置的路徑（但字串可能不同）。另請參閱函式 :func:`dirname` "
"和 :func:`basename`。"

#: ../../library/os.path.rst:459
#, fuzzy
msgid ""
"Split the pathname *path* into a pair ``(drive, tail)`` where *drive* is "
"either a mount point or the empty string.  On systems which do not use drive "
"specifications, *drive* will always be the empty string.  In all cases, "
"``drive + tail`` will be the same as *path*."
msgstr ""
"將路徑名 *path* 拆分為一對 ``(drive, tail)``，其中 *drive* "
"是掛載點或空字串。在不使用驅動器規範的系統上，*drive* "
"將始終為空字串。在所有情況下，``drive + tail`` 將與 *path* 相同。"

#: ../../library/os.path.rst:464
#, fuzzy
msgid ""
"On Windows, splits a pathname into drive/UNC sharepoint and relative path."
msgstr "在 Windows 上，將路徑名拆分為驅動器/UNC 共享點和相對路徑。"

#: ../../library/os.path.rst:466
#, fuzzy
msgid ""
"If the path contains a drive letter, drive will contain everything up to and "
"including the colon::"
msgstr "如果路徑包含驅動器號，則驅動器將包含冒號之前的所有內容：："

#: ../../library/os.path.rst:472
#, fuzzy
msgid ""
"If the path contains a UNC path, drive will contain the host name and share, "
"up to but not including the fourth separator::"
msgstr "如果路徑包含 UNC 路徑，驅動器將包含主機名和共享，直到但不包括第四個分隔符::"

#: ../../library/os.path.rst:484
#, fuzzy
msgid ""
"Split the pathname *path* into a pair ``(root, ext)``  such that ``root + "
"ext == path``, and the extension, *ext*, is empty or begins with a period "
"and contains at most one period."
msgstr ""
"將路徑名 *path* 拆分為一對 ``(root, ext)`` 使得 ``root + ext == path`` "
"和擴充名 *ext* 為空或以句點開頭且最多包含一個時期。"

#: ../../library/os.path.rst:488
#, fuzzy
msgid "If the path contains no extension, *ext* will be ``''``::"
msgstr "如果路徑不包含擴充名，*ext* 將是 ``''``::"

#: ../../library/os.path.rst:493
#, fuzzy
msgid ""
"If the path contains an extension, then *ext* will be set to this extension, "
"including the leading period. Note that previous periods will be ignored::"
msgstr "如果路徑包含擴充名，則 *ext* "
"將設定為此擴充名，包括前導句點。請注意，以前的期間將被忽略::"

#: ../../library/os.path.rst:501
#, fuzzy
msgid ""
"Leading periods of the last component of the path are considered to be part "
"of the root::"
msgstr "路徑最後一個組成部分的前導句點被認為是根的一部分::"

#: ../../library/os.path.rst:515
#, fuzzy
msgid ""
"``True`` if arbitrary Unicode strings can be used as file names (within "
"limitations imposed by the file system)."
msgstr "``True`` 如果任意 Unicode 字串可以用作文件名（在文件系統強加的限制內）。"
