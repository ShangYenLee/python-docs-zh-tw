# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-03 00:16+0000\n"
"PO-Revision-Date: 2018-05-23 16:08+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/profile.rst:5
#, fuzzy
msgid "The Python Profilers"
msgstr "Python 分析器"

#: ../../library/profile.rst:7
msgid "**Source code:** :source:`Lib/profile.py` and :source:`Lib/pstats.py`"
msgstr "**原始碼：**\\ :source:`Lib/profile.py` 與 :source:`Lib/pstats.py`"

#: ../../library/profile.rst:14
#, fuzzy
msgid "Introduction to the profilers"
msgstr "剖析器簡介"

#: ../../library/profile.rst:20
#, fuzzy
msgid ""
":mod:`cProfile` and :mod:`profile` provide :dfn:`deterministic profiling` of "
"Python programs. A :dfn:`profile` is a set of statistics that describes how "
"often and for how long various parts of the program executed. These "
"statistics can be formatted into reports via the :mod:`pstats` module."
msgstr ""
":mod:`cProfile` 和 :mod:`profile` 提供 Python 程式的 :dfn:`deterministic "
"profiling`。 :dfn:`profile` "
"是一組統計資訊，描述了程式各個部分執行的頻率和時長。這些統計資料可以通過 "
"pstats 模組格式化為報告。"

#: ../../library/profile.rst:25
#, fuzzy
msgid ""
"The Python standard library provides two different implementations of the "
"same profiling interface:"
msgstr "Python 標準庫提供了同一分析介面的兩種不同實作："

#: ../../library/profile.rst:28
#, fuzzy
msgid ""
":mod:`cProfile` is recommended for most users; it's a C extension with "
"reasonable overhead that makes it suitable for profiling long-running "
"programs.  Based on :mod:`lsprof`, contributed by Brett Rosen and Ted "
"Czotter."
msgstr ""
":mod:`cProfile` 推薦給大多數使用者；它是一個具有合理開銷的 C "
"擴充，適合分析長時間運行的程式。基於 :mod:`lsprof`，由 Brett Rosen 和 Ted "
"Czotter 貢獻。"

#: ../../library/profile.rst:33
#, fuzzy
msgid ""
":mod:`profile`, a pure Python module whose interface is imitated by :mod:"
"`cProfile`, but which adds significant overhead to profiled programs. If "
"you're trying to extend the profiler in some way, the task might be easier "
"with this module.  Originally designed and written by Jim Roskind."
msgstr ""
":mod:`profile`，一個純 Python 模組，其介面由 :mod:`cProfile` 模仿，但它會顯著"
"增加分析程式的開銷。如果您嘗試以某種方式擴充探查器，使用此模組可能會更容易完"
"成任務。最初由 Jim Roskind 設計和編寫。"

#: ../../library/profile.rst:40
#, fuzzy
msgid ""
"The profiler modules are designed to provide an execution profile for a "
"given program, not for benchmarking purposes (for that, there is :mod:"
"`timeit` for reasonably accurate results).  This particularly applies to "
"benchmarking Python code against C code: the profilers introduce overhead "
"for Python code, but not for C-level functions, and so the C code would seem "
"faster than any Python one."
msgstr ""
"分析器模組旨在為給定程式提供執行分析，而不是用於基準測試目的（為此，有 "
":mod:`timeit` 以獲得相當準確的結果）。這尤其適用於針對 C 程式碼對 Python "
"程式碼進行基準測試：探查器會為 Python 程式碼引入開銷，但不會為 C "
"級函式引入開銷，因此 C 程式碼看起來比任何 Python 程式碼都快。"

#: ../../library/profile.rst:51
#, fuzzy
msgid "Instant User's Manual"
msgstr "即時使用者手冊"

#: ../../library/profile.rst:53
#, fuzzy
msgid ""
"This section is provided for users that \"don't want to read the manual.\" "
"It provides a very brief overview, and allows a user to rapidly perform "
"profiling on an existing application."
msgstr "此部分是為“不想閱讀手冊”的使用者提供的。它提供了一個非常簡短的概述，並允許使"
"用者快速對現有應用程式執行分析。"

#: ../../library/profile.rst:57
#, fuzzy
msgid "To profile a function that takes a single argument, you can do::"
msgstr "要分析採用單個參數的函式，您可以執行以下操作："

#: ../../library/profile.rst:63
#, fuzzy
msgid ""
"(Use :mod:`profile` instead of :mod:`cProfile` if the latter is not "
"available on your system.)"
msgstr "（如果後者在您的系統上不可用，請使用 :mod:`profile` 而不是 "
":mod:`cProfile`。）"

#: ../../library/profile.rst:66
#, fuzzy
msgid ""
"The above action would run :func:`re.compile` and print profile results like "
"the following::"
msgstr "上述操作將運行 :func:`re.compile` 並印出配置文件結果，如下所示："

#: ../../library/profile.rst:83
#, fuzzy
msgid ""
"The first line indicates that 214 calls were monitored.  Of those calls, 207 "
"were :dfn:`primitive`, meaning that the call was not induced via recursion. "
"The next line: ``Ordered by: cumulative time``, indicates that the text "
"string in the far right column was used to sort the output. The column "
"headings include:"
msgstr ""
"第一行表示監聽了 214 個呼叫。在這些呼叫中，有 207 個是 "
":dfn:`primitive`，這意味著呼叫不是通過遞迴引發的。下一行：``Ordered by: "
"cumulative time``，表示最右列中的文本字串用於對輸出進行排序。列標題包括："

#: ../../library/profile.rst:89
msgid "ncalls"
msgstr "ncalls"

#: ../../library/profile.rst:89
#, fuzzy
msgid "for the number of calls."
msgstr "對於通話次數。"

#: ../../library/profile.rst:93
msgid "tottime"
msgstr "tottime"

#: ../../library/profile.rst:92
#, fuzzy
msgid ""
"for the total time spent in the given function (and excluding time made in "
"calls to sub-functions)"
msgstr "在給定函式中花費的總時間（不包括呼叫子函式的時間）"

#: ../../library/profile.rst:96 ../../library/profile.rst:103
msgid "percall"
msgstr "percall"

#: ../../library/profile.rst:96
#, fuzzy
msgid "is the quotient of ``tottime`` divided by ``ncalls``"
msgstr "是``tottime``除以``ncalls``的商"

#: ../../library/profile.rst:100
msgid "cumtime"
msgstr "cumtime"

#: ../../library/profile.rst:99
#, fuzzy
msgid ""
"is the cumulative time spent in this and all subfunctions (from invocation "
"till exit). This figure is accurate *even* for recursive functions."
msgstr "是在此子函式和所有子函式中花費的累計時間（從呼叫到退出）。這個數字對於遞迴函"
"式是準確的*甚至*。"

#: ../../library/profile.rst:103
#, fuzzy
msgid "is the quotient of ``cumtime`` divided by primitive calls"
msgstr "是 ``cumtime`` 除以原始呼叫的商"

#: ../../library/profile.rst:106
#, fuzzy
msgid "filename:lineno(function)"
msgstr "文件名：lineno（函式）"

#: ../../library/profile.rst:106
#, fuzzy
msgid "provides the respective data of each function"
msgstr "提供每個函式各自的資料"

#: ../../library/profile.rst:108
#, fuzzy
msgid ""
"When there are two numbers in the first column (for example ``3/1``), it "
"means that the function recursed.  The second value is the number of "
"primitive calls and the former is the total number of calls.  Note that when "
"the function does not recurse, these two values are the same, and only the "
"single figure is printed."
msgstr ""
"當第一列有兩個數字時（例如 ``3/1``），表示函式遞迴。第二個值是原語呼叫的次數"
"，前者是呼叫的總數。請注意，當函式不遞迴時，這兩個值是相同的，並且只印出單個"
"數字。"

#: ../../library/profile.rst:114
#, fuzzy
msgid ""
"Instead of printing the output at the end of the profile run, you can save "
"the results to a file by specifying a filename to the :func:`run` function::"
msgstr "您可以通過為 :func:`run` "
"函式指定文件名來將結果保存到文件中，而不是在配置文件運行結束時印出輸出："

#: ../../library/profile.rst:121
#, fuzzy
msgid ""
"The :class:`pstats.Stats` class reads profile results from a file and "
"formats them in various ways."
msgstr ":class:`pstats.Stats` 類從文件中讀取配置文件結果並以各種方式格式化它們。"

#: ../../library/profile.rst:124
#, fuzzy
msgid ""
"The files :mod:`cProfile` and :mod:`profile` can also be invoked as a script "
"to profile another script.  For example::"
msgstr "文件 :mod:`cProfile` 和 :mod:`profile` "
"也可以作為腳本呼叫以分析另一個腳本。例如：："

#: ../../library/profile.rst:129
#, fuzzy
msgid "``-o`` writes the profile results to a file instead of to stdout"
msgstr "``-o`` 將配置文件結果寫入文件而不是標準輸出"

#: ../../library/profile.rst:131
#, fuzzy
msgid ""
"``-s`` specifies one of the :func:`~pstats.Stats.sort_stats` sort values to "
"sort the output by. This only applies when ``-o`` is not supplied."
msgstr ""
"``-s`` 指定 :func:`~pstats.Stats.sort_stats` "
"排序值之一以對輸出進行排序。這僅適用於未提供 ``-o``的情況。"

#: ../../library/profile.rst:134
#, fuzzy
msgid "``-m`` specifies that a module is being profiled instead of a script."
msgstr "``-m`` 指定正在分析模組而不是腳本。"

#: ../../library/profile.rst:136
#, fuzzy
msgid "Added the ``-m`` option to :mod:`cProfile`."
msgstr "新增了 ``-m`` 選項到 :mod:`cProfile`。"

#: ../../library/profile.rst:139
#, fuzzy
msgid "Added the ``-m`` option to :mod:`profile`."
msgstr "新增了 ``-m`` 選項到 :mod:`profile`。"

#: ../../library/profile.rst:142
#, fuzzy
msgid ""
"The :mod:`pstats` module's :class:`~pstats.Stats` class has a variety of "
"methods for manipulating and printing the data saved into a profile results "
"file::"
msgstr ":mod:`pstats` 模組的 :class:`~pstats.Stats` "
"類有多種方法用於操作和印出保存到分析結果文件中的資料："

#: ../../library/profile.rst:150
#, fuzzy
msgid ""
"The :meth:`~pstats.Stats.strip_dirs` method removed the extraneous path from "
"all the module names. The :meth:`~pstats.Stats.sort_stats` method sorted all "
"the entries according to the standard module/line/name string that is "
"printed. The :meth:`~pstats.Stats.print_stats` method printed out all the "
"statistics.  You might try the following sort calls::"
msgstr ""
":meth:`~pstats.Stats.strip_dirs` 方法從所有模組名稱中刪除了無關的路徑。 "
":meth:`~pstats.Stats.sort_stats` "
"方法根據印出的標準模組/行/名稱字串對所有條目進行排序。 :meth:`~pstats.Stats."
"print_stats` 方法印出出所有統計資料。您可以嘗試以下排序呼叫："

#: ../../library/profile.rst:159
#, fuzzy
msgid ""
"The first call will actually sort the list by function name, and the second "
"call will print out the statistics.  The following are some interesting "
"calls to experiment with::"
msgstr "第一次呼叫實際上會按函式名對列表進行排序，第二次呼叫會印出出統計資訊。以下是"
"一些有趣的試驗呼叫："

#: ../../library/profile.rst:165
#, fuzzy
msgid ""
"This sorts the profile by cumulative time in a function, and then only "
"prints the ten most significant lines.  If you want to understand what "
"algorithms are taking time, the above line is what you would use."
msgstr "這在函式中按累積時間對配置文件進行排序，然後僅印出十個最重要的行。如果您想了"
"解哪些演算法需要時間，您可以使用上面這行程式碼。"

#: ../../library/profile.rst:169
#, fuzzy
msgid ""
"If you were looking to see what functions were looping a lot, and taking a "
"lot of time, you would do::"
msgstr "如果你想看看哪些函式循環了很多，並且花費了很多時間，你會這樣做："

#: ../../library/profile.rst:174
#, fuzzy
msgid ""
"to sort according to time spent within each function, and then print the "
"statistics for the top ten functions."
msgstr "根據在每個函式中花費的時間進行排序，然後印出前十個函式的統計資訊。"

#: ../../library/profile.rst:177
#, fuzzy
msgid "You might also try::"
msgstr "您也可以嘗試："

#: ../../library/profile.rst:181
#, fuzzy
msgid ""
"This will sort all the statistics by file name, and then print out "
"statistics for only the class init methods (since they are spelled with "
"``__init__`` in them).  As one final example, you could try::"
msgstr ""
"這將按文件名對所有統計資訊進行排序，然後僅印出出類初始化方法的統計資訊（"
"因為它們在其中拼寫為 ``__init__``）。作為最後一個示例，您可以嘗試："

#: ../../library/profile.rst:187
#, fuzzy
msgid ""
"This line sorts statistics with a primary key of time, and a secondary key "
"of cumulative time, and then prints out some of the statistics. To be "
"specific, the list is first culled down to 50% (re: ``.5``) of its original "
"size, then only lines containing ``init`` are maintained, and that sub-sub-"
"list is printed."
msgstr ""
"此行使用時間主鍵和累計時間輔助鍵對統計資訊進行排序，然後印出出部分統計資訊。"
"具體來說，列表首先被剔除到其原始大小的 50%（re：``.5``），然後僅保留包含 "
"``init`` 的行，並印出該子列表。"

#: ../../library/profile.rst:192
#, fuzzy
msgid ""
"If you wondered what functions called the above functions, you could now "
"(``p`` is still sorted according to the last criteria) do::"
msgstr "如果您想知道哪些函式呼叫了上述函式，您現在可以（``p`` "
"仍然根據最後一個標準排序）："

#: ../../library/profile.rst:197
#, fuzzy
msgid "and you would get a list of callers for each of the listed functions."
msgstr "你會得到每個列出的函式的呼叫者列表。"

#: ../../library/profile.rst:199
#, fuzzy
msgid ""
"If you want more functionality, you're going to have to read the manual, or "
"guess what the following functions do::"
msgstr "如果你想要更多的功能，你將不得不閱讀手冊，或者猜測以下功能的作用::"

#: ../../library/profile.rst:205
#, fuzzy
msgid ""
"Invoked as a script, the :mod:`pstats` module is a statistics browser for "
"reading and examining profile dumps.  It has a simple line-oriented "
"interface (implemented using :mod:`cmd`) and interactive help."
msgstr ""
"作為腳本呼叫，:mod:`pstats` 模組是一個統計瀏覽器，用於讀取和檢查配置文件轉儲"
"。它有一個簡單的面向行的界面（使用 :mod:`cmd` 實作）和交互式幫助。"

#: ../../library/profile.rst:210
#, fuzzy
msgid ":mod:`profile` and :mod:`cProfile` Module Reference"
msgstr ":mod:`profile` 和 :mod:`cProfile` 模組參考"

#: ../../library/profile.rst:216
#, fuzzy
msgid ""
"Both the :mod:`profile` and :mod:`cProfile` modules provide the following "
"functions:"
msgstr ":mod:`profile` 和 :mod:`cProfile` 模組都提供以下功能："

#: ../../library/profile.rst:221
#, fuzzy
msgid ""
"This function takes a single argument that can be passed to the :func:`exec` "
"function, and an optional file name.  In all cases this routine executes::"
msgstr "這個函式有一個可以傳遞給 :func:`exec` "
"函式的參數，以及一個可選的文件名。在所有情況下，此例程都會執行："

#: ../../library/profile.rst:226
#, fuzzy
msgid ""
"and gathers profiling statistics from the execution. If no file name is "
"present, then this function automatically creates a :class:`~pstats.Stats` "
"instance and prints a simple profiling report. If the sort value is "
"specified, it is passed to this :class:`~pstats.Stats` instance to control "
"how the results are sorted."
msgstr ""
"並從執行中收集分析統計資料。如果沒有文件名，那麼這個函式會自動建立一個:class:"
"`~pstats.Stats` 實例並印出一個簡單的分析報告。如果指定了排序值，"
"則會將其傳遞給此 :class:`~pstats.Stats` 實例以控制結果的排序方式。"

#: ../../library/profile.rst:234
#, fuzzy
msgid ""
"This function is similar to :func:`run`, with added arguments to supply the "
"globals and locals dictionaries for the *command* string. This routine "
"executes::"
msgstr "這個函式類似於 :func:`run`，增加了參數來為 *command* "
"字串提供全局和局部字典。這個例程執行："

#: ../../library/profile.rst:240
#, fuzzy
msgid "and gathers profiling statistics as in the :func:`run` function above."
msgstr "並像上面的 :func:`run` 函式一樣收集分析統計資料。"

#: ../../library/profile.rst:244
#, fuzzy
msgid ""
"This class is normally only used if more precise control over profiling is "
"needed than what the :func:`cProfile.run` function provides."
msgstr "此類通常僅在需要比 :func:`cProfile.run` 函式提供的更精確的分析控制時才使用。"

#: ../../library/profile.rst:247
#, fuzzy
msgid ""
"A custom timer can be supplied for measuring how long code takes to run via "
"the *timer* argument. This must be a function that returns a single number "
"representing the current time. If the number is an integer, the *timeunit* "
"specifies a multiplier that specifies the duration of each unit of time. For "
"example, if the timer returns times measured in thousands of seconds, the "
"time unit would be ``.001``."
msgstr ""
"可以提供一個自定義計時器，用於測量通過 *timer* 參數運行程式碼所需的時間。這必"
"須是一個回傳表示當前時間的單個數字的函式。如果數字是整數，則 *timeunit* 指定"
"一個乘數，該乘數指定每個時間單位的持續時間。例如，如果計時器回傳以千秒為單位"
"的時間，則時間單位將為“.001”。"

#: ../../library/profile.rst:254
#, fuzzy
msgid ""
"Directly using the :class:`Profile` class allows formatting profile results "
"without writing the profile data to a file::"
msgstr "直接使用 :class:`Profile` "
"類允許在不將配置文件資料寫入文件的情況下格式化配置文件結果::"

#: ../../library/profile.rst:269
#, fuzzy
msgid ""
"The :class:`Profile` class can also be used as a context manager (supported "
"only in :mod:`cProfile` module. see :ref:`typecontextmanager`)::"
msgstr ""
":class:`Profile` 類也可以用作上下文管理器（僅在 :mod:`cProfile` "
"模組中受支援。請參閱 :ref:`typecontextmanager`）::"

#: ../../library/profile.rst:279
#, fuzzy
msgid "Added context manager support."
msgstr "新增了上下文管理器支援。"

#: ../../library/profile.rst:284
#, fuzzy
msgid "Start collecting profiling data. Only in :mod:`cProfile`."
msgstr "開始收集分析資料。僅在 :mod:`cProfile` 中。"

#: ../../library/profile.rst:288
#, fuzzy
msgid "Stop collecting profiling data. Only in :mod:`cProfile`."
msgstr "停止收集分析資料。僅在 :mod:`cProfile` 中。"

#: ../../library/profile.rst:292
#, fuzzy
msgid ""
"Stop collecting profiling data and record the results internally as the "
"current profile."
msgstr "停止收集分析資料並將結果記錄在內部作為當前配置文件。"

#: ../../library/profile.rst:297
#, fuzzy
msgid ""
"Create a :class:`~pstats.Stats` object based on the current profile and "
"print the results to stdout."
msgstr "根據當前配置文件建立一個 :class:`~pstats.Stats` 物件並將結果印出到標準輸出。"

#: ../../library/profile.rst:302
#, fuzzy
msgid "Write the results of the current profile to *filename*."
msgstr "將當前配置文件的結果寫入 *filename*。"

#: ../../library/profile.rst:306
#, fuzzy
msgid "Profile the cmd via :func:`exec`."
msgstr "通過 :func:`exec` 配置 cmd。"

#: ../../library/profile.rst:310
#, fuzzy
msgid ""
"Profile the cmd via :func:`exec` with the specified global and local "
"environment."
msgstr "使用指定的全局和本地環境通過 :func:`exec` 分析 cmd。"

#: ../../library/profile.rst:315
#, fuzzy
msgid "Profile ``func(*args, **kwargs)``"
msgstr "配置文件``func(*args, **kwargs)``"

#: ../../library/profile.rst:317
#, fuzzy
msgid ""
"Note that profiling will only work if the called command/function actually "
"returns.  If the interpreter is terminated (e.g. via a :func:`sys.exit` call "
"during the called command/function execution) no profiling results will be "
"printed."
msgstr ""
"請注意，分析僅在呼叫的命令/函式實際回傳時才有效。如果直譯器終止（例如，在被呼"
"叫的命令/函式執行期間通過 :func:`sys.exit` 呼叫），則不會印出分析結果。"

#: ../../library/profile.rst:325
#, fuzzy
msgid "The :class:`Stats` Class"
msgstr ":class:`Stats` 類"

#: ../../library/profile.rst:327
#, fuzzy
msgid ""
"Analysis of the profiler data is done using the :class:`~pstats.Stats` class."
msgstr "使用 :class:`~pstats.Stats` 類完成探查器資料的分析。"

#: ../../library/profile.rst:334
#, fuzzy
msgid ""
"This class constructor creates an instance of a \"statistics object\" from a "
"*filename* (or list of filenames) or from a :class:`Profile` instance. "
"Output will be printed to the stream specified by *stream*."
msgstr ""
"此類構造函式從 *filename*（或文件名列表）或 Profile "
"實例建立“統計物件”的實例。輸出將印出到 *stream* 指定的流中。"

#: ../../library/profile.rst:338
#, fuzzy
msgid ""
"The file selected by the above constructor must have been created by the "
"corresponding version of :mod:`profile` or :mod:`cProfile`.  To be specific, "
"there is *no* file compatibility guaranteed with future versions of this "
"profiler, and there is no compatibility with files produced by other "
"profilers, or the same profiler run on a different operating system.  If "
"several files are provided, all the statistics for identical functions will "
"be coalesced, so that an overall view of several processes can be considered "
"in a single report.  If additional files need to be combined with data in an "
"existing :class:`~pstats.Stats` object, the :meth:`~pstats.Stats.add` method "
"can be used."
msgstr ""
"上述構造函式選擇的文件必須由相應版本的 :mod:`profile` 或 :mod:`cProfile` 建立"
"。具體來說，*不*保證此探查器的未來版本具有文件相容性，並且與其他探查器生成的"
"文件或在不同操作系統上運行的相同探查器不相容。如果提供了多個文件，相同功能的"
"所有統計資料將被合併，以便在單個報告中考慮多個過程的整體視圖。如果需要將其他"
"文件與現有 :class:`~pstats.Stats` 對像中的資料組合，可以使用 :meth:`~pstats."
"Stats.add` 方法。"

#: ../../library/profile.rst:349
#, fuzzy
msgid ""
"Instead of reading the profile data from a file, a :class:`cProfile.Profile` "
"or :class:`profile.Profile` object can be used as the profile data source."
msgstr "除了從文件中讀取配置文件資料，還可以使用 cProfile.Profile 或 profile.Profile "
"對像作為配置文件資料源。"

#: ../../library/profile.rst:352
#, fuzzy
msgid ":class:`Stats` objects have the following methods:"
msgstr ":class:`Stats` 物件具有以下方法："

#: ../../library/profile.rst:356
#, fuzzy
msgid ""
"This method for the :class:`Stats` class removes all leading path "
"information from file names.  It is very useful in reducing the size of the "
"printout to fit within (close to) 80 columns.  This method modifies the "
"object, and the stripped information is lost.  After performing a strip "
"operation, the object is considered to have its entries in a \"random\" "
"order, as it was just after object initialization and loading. If :meth:"
"`~pstats.Stats.strip_dirs` causes two function names to be indistinguishable "
"(they are on the same line of the same filename, and have the same function "
"name), then the statistics for these two entries are accumulated into a "
"single entry."
msgstr ""
":class:`Stats` 類的此方法從文件名中刪除所有前導路徑資訊。這對於減小印出輸出的"
"大小以適應（接近）80 列非常有用。該方法修改物件，剝離的資訊丟失。執行剝離操作"
"後，對像被認為具有“隨機”順序的條目，因為它剛好在對像初始化和加載之後。如果 "
":meth:`~pstats.Stats.strip_dirs` 導致兩個函式名無法區分（它們在同一文件名的同"
"一行，並且具有相同的函式名），那麼這兩個條目的統計資訊將累積到一個單項。"

#: ../../library/profile.rst:370
#, fuzzy
msgid ""
"This method of the :class:`Stats` class accumulates additional profiling "
"information into the current profiling object.  Its arguments should refer "
"to filenames created by the corresponding version of :func:`profile.run` or :"
"func:`cProfile.run`. Statistics for identically named (re: file, line, name) "
"functions are automatically accumulated into single function statistics."
msgstr ""
":class:`Stats` 類的此方法將額外的分析資訊累積到當前分析對像中。"
"它的參數應該引用相應版本的 :func:`profile.run` 或 :func:`cProfile.run` 建立的"
"文件名。同名（重新：文件、行、名稱）函式的統計資訊會自動累積到單個函式統計資"
"訊中。"

#: ../../library/profile.rst:380
#, fuzzy
msgid ""
"Save the data loaded into the :class:`Stats` object to a file named "
"*filename*.  The file is created if it does not exist, and is overwritten if "
"it already exists.  This is equivalent to the method of the same name on "
"the :class:`profile.Profile` and :class:`cProfile.Profile` classes."
msgstr ""
"將加載到 Stats 對像中的資料保存到名為 *filename* "
"的文件中。如果文件不存在則建立該文件，如果已存在則覆蓋該文件。這等同於 "
":class:`profile.Profile` 和 :class:`cProfile.Profile` 類中的同名方法。"

#: ../../library/profile.rst:388
#, fuzzy
msgid ""
"This method modifies the :class:`Stats` object by sorting it according to "
"the supplied criteria.  The argument can be either a string or a SortKey "
"enum identifying the basis of a sort (example: ``'time'``, ``'name'``, "
"``SortKey.TIME`` or ``SortKey.NAME``). The SortKey enums argument have "
"advantage over the string argument in that it is more robust and less error "
"prone."
msgstr ""
"此方法通過根據提供的條件對其進行排序來修改 Stats 物件。參數可以是字串或 "
"SortKey 枚舉，用於標識排序的基礎（例如：``'time'``、``'name'``、``SortKey."
"TIME`` 或 ``SortKey.NAME` `）。 SortKey "
"枚舉參數優於字串參數，因為它更健壯且不易出錯。"

#: ../../library/profile.rst:395
#, fuzzy
msgid ""
"When more than one key is provided, then additional keys are used as "
"secondary criteria when there is equality in all keys selected before them.  "
"For example, ``sort_stats(SortKey.NAME, SortKey.FILE)`` will sort all the "
"entries according to their function name, and resolve all ties (identical "
"function names) by sorting by file name."
msgstr ""
"當提供了多個鍵時，當在它們之前選擇的所有鍵都相等時，其他鍵將用作次要標準。例"
"如，``sort_stats(SortKey.NAME, SortKey.FILE)`` 將根據它們的函式名對所有條目進"
"行排序，並通過按文件名排序來解決所有關係（相同的函式名）。"

#: ../../library/profile.rst:401
#, fuzzy
msgid ""
"For the string argument, abbreviations can be used for any key names, as "
"long as the abbreviation is unambiguous."
msgstr "對於字串參數，縮寫可以用於任何鍵名，只要縮寫沒有歧義即可。"

#: ../../library/profile.rst:404
#, fuzzy
msgid "The following are the valid string and SortKey:"
msgstr "以下是有效的字串和 SortKey："

#: ../../library/profile.rst:407
#, fuzzy
msgid "Valid String Arg"
msgstr "有效字串參數"

#: ../../library/profile.rst:407
#, fuzzy
msgid "Valid enum Arg"
msgstr "有效枚舉參數"

#: ../../library/profile.rst:407
#, fuzzy
msgid "Meaning"
msgstr "意義"

#: ../../library/profile.rst:409
msgid "``'calls'``"
msgstr "``'calls'``"

#: ../../library/profile.rst:409
msgid "SortKey.CALLS"
msgstr "SortKey.CALLS"

#: ../../library/profile.rst:409 ../../library/profile.rst:421
#, fuzzy
msgid "call count"
msgstr "通話次數"

#: ../../library/profile.rst:411
msgid "``'cumulative'``"
msgstr "``'cumulative'``"

#: ../../library/profile.rst:411
msgid "SortKey.CUMULATIVE"
msgstr "SortKey.CUMULATIVE"

#: ../../library/profile.rst:411 ../../library/profile.rst:413
#, fuzzy
msgid "cumulative time"
msgstr "累計時間"

#: ../../library/profile.rst:413
msgid "``'cumtime'``"
msgstr "``'cumtime'``"

#: ../../library/profile.rst:413 ../../library/profile.rst:415
#: ../../library/profile.rst:419 ../../library/profile.rst:421
#: ../../library/profile.rst:435
msgid "N/A"
msgstr "N/A"

#: ../../library/profile.rst:415
msgid "``'file'``"
msgstr "``'file'``"

#: ../../library/profile.rst:415 ../../library/profile.rst:417
#: ../../library/profile.rst:419
#, fuzzy
msgid "file name"
msgstr "文件名"

#: ../../library/profile.rst:417
msgid "``'filename'``"
msgstr "``'filename'``"

#: ../../library/profile.rst:417
msgid "SortKey.FILENAME"
msgstr "SortKey.FILENAME"

#: ../../library/profile.rst:419
msgid "``'module'``"
msgstr "``'module'``"

#: ../../library/profile.rst:421
msgid "``'ncalls'``"
msgstr "``'ncalls'``"

#: ../../library/profile.rst:423
msgid "``'pcalls'``"
msgstr "``'pcalls'``"

#: ../../library/profile.rst:423
msgid "SortKey.PCALLS"
msgstr "SortKey.PCALLS"

#: ../../library/profile.rst:423
#, fuzzy
msgid "primitive call count"
msgstr "原始呼叫計數"

#: ../../library/profile.rst:425
msgid "``'line'``"
msgstr "``'line'``"

#: ../../library/profile.rst:425
msgid "SortKey.LINE"
msgstr "SortKey.LINE"

#: ../../library/profile.rst:425
#, fuzzy
msgid "line number"
msgstr "電話號碼"

#: ../../library/profile.rst:427
msgid "``'name'``"
msgstr "``'name'``"

#: ../../library/profile.rst:427
msgid "SortKey.NAME"
msgstr "SortKey.NAME"

#: ../../library/profile.rst:427
#, fuzzy
msgid "function name"
msgstr "函式名"

#: ../../library/profile.rst:429
msgid "``'nfl'``"
msgstr "``'nfl'``"

#: ../../library/profile.rst:429
msgid "SortKey.NFL"
msgstr "SortKey.NFL"

#: ../../library/profile.rst:429
#, fuzzy
msgid "name/file/line"
msgstr "名稱/文件/行"

#: ../../library/profile.rst:431
msgid "``'stdname'``"
msgstr "``'stdname'``"

#: ../../library/profile.rst:431
msgid "SortKey.STDNAME"
msgstr "SortKey.STDNAME"

#: ../../library/profile.rst:431
#, fuzzy
msgid "standard name"
msgstr "標準名稱"

#: ../../library/profile.rst:433
msgid "``'time'``"
msgstr "``'time'``"

#: ../../library/profile.rst:433
msgid "SortKey.TIME"
msgstr "SortKey.TIME"

#: ../../library/profile.rst:433 ../../library/profile.rst:435
#, fuzzy
msgid "internal time"
msgstr "內部時間"

#: ../../library/profile.rst:435
msgid "``'tottime'``"
msgstr "``'tottime'``"

#: ../../library/profile.rst:438
#, fuzzy
msgid ""
"Note that all sorts on statistics are in descending order (placing most time "
"consuming items first), where as name, file, and line number searches are in "
"ascending order (alphabetical). The subtle distinction between ``SortKey."
"NFL`` and ``SortKey.STDNAME`` is that the standard name is a sort of the "
"name as printed, which means that the embedded line numbers get compared in "
"an odd way.  For example, lines 3, 20, and 40 would (if the file names were "
"the same) appear in the string order 20, 3 and 40. In contrast, ``SortKey."
"NFL`` does a numeric compare of the line numbers. In fact, "
"``sort_stats(SortKey.NFL)`` is the same as ``sort_stats(SortKey.NAME, "
"SortKey.FILENAME, SortKey.LINE)``."
msgstr ""
"請注意，統計資訊的所有排序均按降序排列（將最耗時的項目放在首位），而名稱、文"
"件和行號搜索按升序排列（按字母順序）。 ``SortKey.NFL`` 和 ``SortKey.STDNAME``"
" 之間的微妙區別在於標準名稱是一種印出名稱，這意味著嵌入的行號以一種奇怪的方式"
"進行比較。例如，第 3、20 和 40 行（如果文件名相同）將以 20、3 和 40 "
"的字串順序出現。相比之下，``SortKey.NFL`` "
"對行號進行數字比較。事實上，``sort_stats(SortKey.NFL)`` 與 ``sort_stats("
"SortKey.NAME, SortKey.FILENAME, SortKey.LINE)`` 是一樣的。"

#: ../../library/profile.rst:449
#, fuzzy
msgid ""
"For backward-compatibility reasons, the numeric arguments ``-1``, ``0``, "
"``1``, and ``2`` are permitted.  They are interpreted as ``'stdname'``, "
"``'calls'``, ``'time'``, and ``'cumulative'`` respectively.  If this old "
"style format (numeric) is used, only one sort key (the numeric key) will be "
"used, and additional arguments will be silently ignored."
msgstr ""
"出於向後相容的原因，數字參數 ``-1``、 ``0``、 ``1``和 ``2``是允許的。它們分別被解釋為“std"
"name”、 ``calls``、 ``time``和 ``cumulative``。如果使用這種舊式格式（數字），則只會使"
"用一個排序鍵（數字鍵），其他參數將被靜默忽略。"

#: ../../library/profile.rst:457
#, fuzzy
msgid "Added the SortKey enum."
msgstr "新增了 SortKey 枚舉。"

#: ../../library/profile.rst:462
#, fuzzy
msgid ""
"This method for the :class:`Stats` class reverses the ordering of the basic "
"list within the object.  Note that by default ascending vs descending order "
"is properly selected based on the sort key of choice."
msgstr ":class:`Stats` 類的此方法反轉物件內基本列表的順序。請注意，預設情況下，升序與"
"降序是根據所選的排序鍵正確選擇的。"

#: ../../library/profile.rst:472
#, fuzzy
msgid ""
"This method for the :class:`Stats` class prints out a report as described in "
"the :func:`profile.run` definition."
msgstr ":class:`Stats` 類的此方法印出出一份報告，如 :func:`profile.run` 定義中所述。"

#: ../../library/profile.rst:475
#, fuzzy
msgid ""
"The order of the printing is based on the last :meth:`~pstats.Stats."
"sort_stats` operation done on the object (subject to caveats in :meth:"
"`~pstats.Stats.add` and :meth:`~pstats.Stats.strip_dirs`)."
msgstr ""
"印出的順序基於對物件執行的最後一個 :meth:`~pstats.Stats.sort_stats` 操作（受 "
":meth:`~pstats.Stats.add` 和 :meth:`~pstats. Stats.strip_dirs`）。"

#: ../../library/profile.rst:480
#, fuzzy
msgid ""
"The arguments provided (if any) can be used to limit the list down to the "
"significant entries.  Initially, the list is taken to be the complete set of "
"profiled functions.  Each restriction is either an integer (to select a "
"count of lines), or a decimal fraction between 0.0 and 1.0 inclusive (to "
"select a percentage of lines), or a string that will interpreted as a "
"regular expression (to pattern match the standard name that is printed). If "
"several restrictions are provided, then they are applied sequentially. For "
"example::"
msgstr ""
"提供的參數（如果有）可用於將列表限制為重要條目。最初，該列表被認為是完整的配"
"置函式集。每個限制都是一個整數（用於選擇行數），或者是介於 0.0 和 1.0 之間的"
"小數部分（用於選擇行的百分比），或者是一個將被解釋為正則表達式的字串（用於模"
"式匹配標準名稱即印出）。如果提供了多個限制，則它們會按順序應用。例如：："

#: ../../library/profile.rst:491
#, fuzzy
msgid ""
"would first limit the printing to first 10% of list, and then only print "
"functions that were part of filename :file:`.\\*foo:`.  In contrast, the "
"command::"
msgstr "將首先將印出限制為列表的前 10%，然後僅印出屬於文件名 :file:`.\\*foo:` "
"的函式。相反，命令::"

#: ../../library/profile.rst:497
#, fuzzy
msgid ""
"would limit the list to all functions having file names :file:`.\\*foo:`, "
"and then proceed to only print the first 10% of them."
msgstr "會將列表限制為文件名為 :file:`.\\*foo:` 的所有函式，然後繼續只印出其中的前 "
"10%。"

#: ../../library/profile.rst:503
#, fuzzy
msgid ""
"This method for the :class:`Stats` class prints a list of all functions that "
"called each function in the profiled database.  The ordering is identical to "
"that provided by :meth:`~pstats.Stats.print_stats`, and the definition of "
"the restricting argument is also identical.  Each caller is reported on its "
"own line.  The format differs slightly depending on the profiler that "
"produced the stats:"
msgstr ""
":class:`Stats` "
"類的此方法印出所有函式的列表，這些函式呼叫了分析資料庫中的每個函式。順序與 "
":meth:`~pstats.Stats.print_stats` 提供的順序相同，限制參數的定義也相同。每個"
"呼叫者都在自己的線路上報告。格式略有不同，具體取決於生成統計資訊的分析器："

#: ../../library/profile.rst:510
#, fuzzy
msgid ""
"With :mod:`profile`, a number is shown in parentheses after each caller to "
"show how many times this specific call was made.  For convenience, a second "
"non-parenthesized number repeats the cumulative time spent in the function "
"at the right."
msgstr ""
"使用 :mod:`profile`，每個呼叫者後面的括號中會顯示一個數字，以顯示此特定呼叫進"
"行了多少次。為方便起見，第二個未加括號的數字重複在右側函式中花費的累計時間。"

#: ../../library/profile.rst:515
#, fuzzy
msgid ""
"With :mod:`cProfile`, each caller is preceded by three numbers: the number "
"of times this specific call was made, and the total and cumulative times "
"spent in the current function while it was invoked by this specific caller."
msgstr ""
"使用 :mod:`cProfile`，每個呼叫者前面都有三個數字：進行此特定呼叫的次數，以及"
"當前函式被此特定呼叫者呼叫時花費的總時間和累計時間。"

#: ../../library/profile.rst:523
#, fuzzy
msgid ""
"This method for the :class:`Stats` class prints a list of all function that "
"were called by the indicated function.  Aside from this reversal of "
"direction of calls (re: called vs was called by), the arguments and ordering "
"are identical to the :meth:`~pstats.Stats.print_callers` method."
msgstr ""
":class:`Stats` "
"類的此方法印出指定函式呼叫的所有函式的列表。除了這種呼叫方向的反轉（re: "
"called vs was called by），參數和順序與 :meth:`~pstats.Stats.print_callers` "
"方法相同。"

#: ../../library/profile.rst:531
#, fuzzy
msgid ""
"This method returns an instance of StatsProfile, which contains a mapping of "
"function names to instances of FunctionProfile. Each FunctionProfile "
"instance holds information related to the function's profile such as how "
"long the function took to run, how many times it was called, etc..."
msgstr ""
"此方法回傳 StatsProfile 的實例，其中包含函式名稱到 FunctionProfile "
"實例的映射。每個 FunctionProfile "
"實例都包含與函式配置文件相關的資訊，例如函式運行了多長時間、呼叫了多少次等..."

#: ../../library/profile.rst:536
#, fuzzy
msgid ""
"Added the following dataclasses: StatsProfile, FunctionProfile. Added the "
"following function: get_stats_profile."
msgstr "新增了以下資料類：StatsProfile、FunctionProfile。新增了以下功能：get_stats_pr"
"ofile。"

#: ../../library/profile.rst:543
#, fuzzy
msgid "What Is Deterministic Profiling?"
msgstr "什麼是確定性分析？"

#: ../../library/profile.rst:545
#, fuzzy
msgid ""
":dfn:`Deterministic profiling` is meant to reflect the fact that all "
"*function call*, *function return*, and *exception* events are monitored, "
"and precise timings are made for the intervals between these events (during "
"which time the user's code is executing).  In contrast, :dfn:`statistical "
"profiling` (which is not done by this module) randomly samples the effective "
"instruction pointer, and deduces where time is being spent.  The latter "
"technique traditionally involves less overhead (as the code does not need to "
"be instrumented), but provides only relative indications of where time is "
"being spent."
msgstr ""
":dfn:`Deterministic profiling` 旨在反映以下事實：所有 *function call*、*"
"function return* 和 *exception* 事件都受到監控，並且對這些事件之間的間隔進行"
"精確計時（在此期間使用者的程式碼正在執行）。相比之下，:dfn:`statistical profi"
"ling`（不是由該模組完成的）隨機採樣有效指令指標，並推斷出時間花在了哪裡。後一"
"種技術傳統上涉及較少的開銷（因為不需要檢測程式碼），但僅提供時間花費在哪裡的"
"相對指示。"

#: ../../library/profile.rst:554
#, fuzzy
msgid ""
"In Python, since there is an interpreter active during execution, the "
"presence of instrumented code is not required in order to do deterministic "
"profiling. Python automatically provides a :dfn:`hook` (optional callback) "
"for each event. In addition, the interpreted nature of Python tends to add "
"so much overhead to execution, that deterministic profiling tends to only "
"add small processing overhead in typical applications.  The result is that "
"deterministic profiling is not that expensive, yet provides extensive run "
"time statistics about the execution of a Python program."
msgstr ""
"在 Python 中，由於在執行期間有一個直譯器處於活動狀態，因此不需要存在檢測程式"
"碼來進行確定性分析。 Python 自動為每個事件提供一個 "
":dfn:`hook`（可選回呼）。此外，Python 的解釋性質往往會增加很多執行開銷，因此"
"確定性分析往往只會在典型應用程式中增加少量處理開銷。結果是確定性分析並不那麼"
"昂貴，但卻提供了有關 Python 程式執行的大量運行時統計資訊。"

#: ../../library/profile.rst:563
#, fuzzy
msgid ""
"Call count statistics can be used to identify bugs in code (surprising "
"counts), and to identify possible inline-expansion points (high call "
"counts).  Internal time statistics can be used to identify \"hot loops\" "
"that should be carefully optimized.  Cumulative time statistics should be "
"used to identify high level errors in the selection of algorithms.  Note "
"that the unusual handling of cumulative times in this profiler allows "
"statistics for recursive implementations of algorithms to be directly "
"compared to iterative implementations."
msgstr ""
"呼叫計數統計資訊可用於識別程式碼中的錯誤（令人驚訝的計數），並識別可能的內聯"
"擴充點（高呼叫計數）。內部時間統計可用於識別應仔細最佳化的“熱循環”。應該使用"
"累積時間統計來識別演算法選擇中的高階錯誤。請注意，此探查器中對累積時間的不尋"
"常處理允許將演算法的遞迴實作的統計資料直接與疊代實作進行比較。"

#: ../../library/profile.rst:576
msgid "Limitations"
msgstr "限制"

#: ../../library/profile.rst:578
#, fuzzy
msgid ""
"One limitation has to do with accuracy of timing information. There is a "
"fundamental problem with deterministic profilers involving accuracy.  The "
"most obvious restriction is that the underlying \"clock\" is only ticking at "
"a rate (typically) of about .001 seconds.  Hence no measurements will be "
"more accurate than the underlying clock.  If enough measurements are taken, "
"then the \"error\" will tend to average out. Unfortunately, removing this "
"first error induces a second source of error."
msgstr ""
"一種限制與計時資訊的準確性有關。確定性分析器存在一個涉及準確性的基本問題。最"
"明顯的限制是底層“時鐘”僅以大約 0.001 秒的速率（通常）滴答作響。因此，沒有任何"
"測量會比底層時鐘更準確。如果進行了足夠多的測量，那麼“誤差”將趨於平均。不幸的"
"是，消除第一個錯誤會導致第二個錯誤來源。"

#: ../../library/profile.rst:586
#, fuzzy
msgid ""
"The second problem is that it \"takes a while\" from when an event is "
"dispatched until the profiler's call to get the time actually *gets* the "
"state of the clock.  Similarly, there is a certain lag when exiting the "
"profiler event handler from the time that the clock's value was obtained "
"(and then squirreled away), until the user's code is once again executing.  "
"As a result, functions that are called many times, or call many functions, "
"will typically accumulate this error. The error that accumulates in this "
"fashion is typically less than the accuracy of the clock (less than one "
"clock tick), but it *can* accumulate and become very significant."
msgstr ""
"第二個問題是，從派發事件到分析器呼叫以實際*獲取*時鐘狀態“需要一段時間”。類似"
"地，從獲取時鐘值（然後儲存起來）到使用者程式碼再次執行，退出探查器事件處理程"
"序時存在一定的滯後。因此，多次呼叫或呼叫許多函式的函式通常會累積此錯誤。以這"
"種方式累積的誤差通常小於時鐘的精度（小於一個時鐘滴答），但它*可以*累積並變得"
"非常重要。"

#: ../../library/profile.rst:596
#, fuzzy
msgid ""
"The problem is more important with :mod:`profile` than with the lower-"
"overhead :mod:`cProfile`.  For this reason, :mod:`profile` provides a means "
"of calibrating itself for a given platform so that this error can be "
"probabilistically (on the average) removed. After the profiler is "
"calibrated, it will be more accurate (in a least square sense), but it will "
"sometimes produce negative numbers (when call counts are exceptionally low, "
"and the gods of probability work against you :-). )  Do *not* be alarmed by "
"negative numbers in the profile.  They should *only* appear if you have "
"calibrated your profiler, and the results are actually better than without "
"calibration."
msgstr ""
":mod:`profile` 的問題比低開銷的 :mod:`cProfile` "
"更重要。出於這個原因，:mod:`profile` 提供了一種針對給定平台進行自我校準的方法"
"，以便可以（平均）概率地消除此錯誤。校準分析器後，它會更準確（在最小二乘意義"
"上），但有時會產生負數（當呼叫計數非常低時，概率之神對你不利:-)。 ) 不要 "
"*不要* 被配置文件中的負數嚇到。它們應該*僅*在您校準了您的分析器時出現，並且結"
"果實際上比沒有校準更好。"

#: ../../library/profile.rst:610
msgid "Calibration"
msgstr "校正"

#: ../../library/profile.rst:612
#, fuzzy
msgid ""
"The profiler of the :mod:`profile` module subtracts a constant from each "
"event handling time to compensate for the overhead of calling the time "
"function, and socking away the results.  By default, the constant is 0. The "
"following procedure can be used to obtain a better constant for a given "
"platform (see :ref:`profile-limitations`). ::"
msgstr ""
":mod:`profile` 模組的分析器從每個事件處理時間中減去一個常數，以補償呼叫時間函"
"式和儲存結果的開銷。預設情況下，常數為 "
"0。可以使用以下過程為給定平台獲取更好的常數（請參閱 :ref:`profile-"
"limitations`）。 ::"

#: ../../library/profile.rst:623
#, fuzzy
msgid ""
"The method executes the number of Python calls given by the argument, "
"directly and again under the profiler, measuring the time for both. It then "
"computes the hidden overhead per profiler event, and returns that as a "
"float.  For example, on a 1.8Ghz Intel Core i5 running macOS, and using "
"Python's time.process_time() as the timer, the magical number is about "
"4.04e-6."
msgstr ""
"該方法直接執行參數給定的 Python 呼叫次數，並在分析器下再次執行，測量兩者的時"
"間。然後它計算每個分析器事件的隱藏開銷，並將其作為浮點數回傳。例如，在運行 "
"macOS 的 1.8Ghz Intel Core i5 上，並使用 Python 的 time.process_time() "
"作為計時器，神奇的數字約為 4.04e-6。"

#: ../../library/profile.rst:629
#, fuzzy
msgid ""
"The object of this exercise is to get a fairly consistent result. If your "
"computer is *very* fast, or your timer function has poor resolution, you "
"might have to pass 100000, or even 1000000, to get consistent results."
msgstr ""
"本練習的目的是獲得相當一致的結果。如果您的計算機*非常*快，或者您的計時器功能"
"的分辨率很差，您可能必須傳遞 100000，甚至 1000000，才能獲得一致的結果。"

#: ../../library/profile.rst:633
#, fuzzy
msgid ""
"When you have a consistent answer, there are three ways you can use it::"
msgstr "當你有一個一致的答案時，你可以通過三種方式使用它::"

#: ../../library/profile.rst:647
#, fuzzy
msgid ""
"If you have a choice, you are better off choosing a smaller constant, and "
"then your results will \"less often\" show up as negative in profile "
"statistics."
msgstr "如果您有選擇，最好選擇一個較小的常數，然後您的結果將“不太經常”在配置文件統計"
"資訊中顯示為負數。"

#: ../../library/profile.rst:653
#, fuzzy
msgid "Using a custom timer"
msgstr "使用自定義計時器"

#: ../../library/profile.rst:655
#, fuzzy
msgid ""
"If you want to change how current time is determined (for example, to force "
"use of wall-clock time or elapsed process time), pass the timing function "
"you want to the :class:`Profile` class constructor::"
msgstr "如果你想改變當前時間的確定方式（例如，強制使用掛鐘時間或經過的過程時間），"
"將你想要的計時函式傳遞給 Profile 類構造函式::"

#: ../../library/profile.rst:661
#, fuzzy
msgid ""
"The resulting profiler will then call ``your_time_func``. Depending on "
"whether you are using :class:`profile.Profile` or :class:`cProfile.Profile`, "
"``your_time_func``'s return value will be interpreted differently:"
msgstr ""
"然後生成的分析器將呼叫“your_time_func”。根據您使用的是 :class:`profile."
"Profile` 還是 :class:`cProfile.Profile`，``your_time_func`` "
"的回傳值將被不同地解釋："

#: ../../library/profile.rst:679
msgid ":class:`profile.Profile`"
msgstr ":class:`profile.Profile`"

#: ../../library/profile.rst:666
#, fuzzy
msgid ""
"``your_time_func`` should return a single number, or a list of numbers whose "
"sum is the current time (like what :func:`os.times` returns).  If the "
"function returns a single time number, or the list of returned numbers has "
"length 2, then you will get an especially fast version of the dispatch "
"routine."
msgstr ""
"``your_time_func`` 應該回傳一個數字，或者一個總和為當前時間的數字列表（比如 "
"os.times 回傳的）。如果該函式回傳單個時間數字，或者回傳數字列表的長度為 "
"2，那麼您將獲得一個特別快速的調度例程版本。"

#: ../../library/profile.rst:672
#, fuzzy
msgid ""
"Be warned that you should calibrate the profiler class for the timer "
"function that you choose (see :ref:`profile-calibration`).  For most "
"machines, a timer that returns a lone integer value will provide the best "
"results in terms of low overhead during profiling.  (:func:`os.times` is "
"*pretty* bad, as it returns a tuple of floating point values).  If you want "
"to substitute a better timer in the cleanest fashion, derive a class and "
"hardwire a replacement dispatch method that best handles your timer call, "
"along with the appropriate calibration constant."
msgstr ""
"請注意，您應該為您選擇的計時器功能校準分析器類（請參閱 :ref:`profile-calibra"
"tion`）。對於大多數機器，回傳一個單獨整數值的計時器將在分析期間的低開銷方面提"
"供最佳結果。 （:func:`os.times` *相當*糟糕，因為它回傳一個浮點值元組）。如果"
"您想以最簡潔的方式替換更好的計時器，請派生一個類並硬連接一個最能處理您的計時"
"器呼叫的替換調度方法，以及適當的校準常數。"

#: ../../library/profile.rst:693
msgid ":class:`cProfile.Profile`"
msgstr ":class:`cProfile.Profile`"

#: ../../library/profile.rst:682
#, fuzzy
msgid ""
"``your_time_func`` should return a single number.  If it returns integers, "
"you can also invoke the class constructor with a second argument specifying "
"the real duration of one unit of time.  For example, if "
"``your_integer_time_func`` returns times measured in thousands of seconds, "
"you would construct the :class:`Profile` instance as follows::"
msgstr ""
"``your_time_func`` 應該回傳一個數字。如果它回傳整數，您還可以使用指定一個時間"
"單位的實際持續時間的第二個參數來呼叫類構造函式。例如，如果 "
"``your_integer_time_func`` 回傳以千秒為單位測量的時間，您將構造 Profile "
"實例如下："

#: ../../library/profile.rst:690
#, fuzzy
msgid ""
"As the :class:`cProfile.Profile` class cannot be calibrated, custom timer "
"functions should be used with care and should be as fast as possible.  For "
"the best results with a custom timer, it might be necessary to hard-code it "
"in the C source of the internal :mod:`_lsprof` module."
msgstr ""
"由於 :class:`cProfile.Profile` 類無法校準，因此應謹慎使用自定義計時器函式，並"
"應盡可能快。為了使用自定義計時器獲得最佳結果，可能需要在內部 :mod:`_lsprof` "
"模組的 C 源程式碼中對其進行硬編碼。"

#: ../../library/profile.rst:695
#, fuzzy
msgid ""
"Python 3.3 adds several new functions in :mod:`time` that can be used to "
"make precise measurements of process or wall-clock time. For example, see :"
"func:`time.perf_counter`."
msgstr ""
"Python 3.3 在 :mod:`time` "
"中新增了幾個新函式，可用於精確測量行程或掛鐘時間。例如，參見 :func:`time."
"perf_counter`。"
