# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-23 00:17+0000\n"
"PO-Revision-Date: 2018-05-23 16:06+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/multiprocessing.rst:2
#, fuzzy
msgid ":mod:`multiprocessing` --- Process-based parallelism"
msgstr ":mod:`multiprocessing` --- 基於行程的並行性"

#: ../../library/multiprocessing.rst:7
msgid "**Source code:** :source:`Lib/multiprocessing/`"
msgstr "**原始碼：**\\ :source:`Lib/multiprocessing/`"

#: ../../includes/wasm-notavail.rst:3
#, fuzzy
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ":ref:`Availability <availability>`：不是 Emscripten，不是 WASI。"

#: ../../includes/wasm-notavail.rst:5
#, fuzzy
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"此模組在 WebAssembly 平台 ``wasm32-emscripten`` 和 ``wasm32-wasi`` 上不起作用或不可用"
"。有關更多資訊，請參閱 :ref:`wasm-availability`。"

#: ../../library/multiprocessing.rst:14
msgid "Introduction"
msgstr "簡介"

#: ../../library/multiprocessing.rst:16
#, fuzzy
msgid ""
":mod:`multiprocessing` is a package that supports spawning processes using "
"an API similar to the :mod:`threading` module.  The :mod:`multiprocessing` "
"package offers both local and remote concurrency, effectively side-stepping "
"the :term:`Global Interpreter Lock <global interpreter lock>` by using "
"subprocesses instead of threads.  Due to this, the :mod:`multiprocessing` "
"module allows the programmer to fully leverage multiple processors on a "
"given machine.  It runs on both Unix and Windows."
msgstr ""
":mod:`multiprocessing` 是一個使用類似於 :mod:`threading` 模組的 API "
"支援生成行程的包。 :mod:`multiprocessing` "
"包提供本地和遠程並發，通過使用子行程而不是執行緒有效地避開了 :term:`Global "
"Interpreter Lock <global interpreter lock>`。因此，:mod:`multiprocessing` "
"模組允許程式員在給定機器上充分利用多個處理器。它在 Unix 和 Windows 上運行。"

#: ../../library/multiprocessing.rst:25
#, fuzzy
msgid ""
"The :mod:`multiprocessing` module also introduces APIs which do not have "
"analogs in the :mod:`threading` module.  A prime example of this is the :"
"class:`~multiprocessing.pool.Pool` object which offers a convenient means of "
"parallelizing the execution of a function across multiple input values, "
"distributing the input data across processes (data parallelism).  The "
"following example demonstrates the common practice of defining such "
"functions in a module so that child processes can successfully import that "
"module.  This basic example of data parallelism using :class:"
"`~multiprocessing.pool.Pool`, ::"
msgstr ""
":mod:`multiprocessing` 模組還引入了在 :mod:`threading` 模組中沒有類似物的 "
"API。一個典型的例子是 :class:`~multiprocessing.pool.Pool` 物件，它提供了一種"
"方便的方法來跨多個輸入值並行執行函式，跨行程分佈輸入資料（資料並行性）。以下"
"示例演示了在模組中定義此類函式的常見做法，以便子行程可以成功導入該模組。"
"這個使用 :class:`~multiprocessing.pool.Pool` 的資料並行性的基本示例，::"

#: ../../library/multiprocessing.rst:43
#, fuzzy
msgid "will print to standard output ::"
msgstr "將印出到標準輸出::"

#: ../../library/multiprocessing.rst:50
#, fuzzy
msgid ""
":class:`concurrent.futures.ProcessPoolExecutor` offers a higher level "
"interface to push tasks to a background process without blocking execution "
"of the calling process. Compared to using the :class:`~multiprocessing.pool."
"Pool` interface directly, the :mod:`concurrent.futures` API more readily "
"allows the submission of work to the underlying process pool to be separated "
"from waiting for the results."
msgstr ""
":class:`concurrent.futures.ProcessPoolExecutor` "
"提供了一個更高階別的介面來將任務推送到後台行程，而不會阻止呼叫行程的執行。"
"與直接使用 :class:`~multiprocessing.pool.Pool` 介面相比，:mod:`concurrent."
"futures` API 更容易將工作提交到底層行程池與等待結果分開。"

#: ../../library/multiprocessing.rst:59
#, fuzzy
msgid "The :class:`Process` class"
msgstr ":class:`Process` 類"

#: ../../library/multiprocessing.rst:61
#, fuzzy
msgid ""
"In :mod:`multiprocessing`, processes are spawned by creating a :class:"
"`Process` object and then calling its :meth:`~Process.start` method.  :class:"
"`Process` follows the API of :class:`threading.Thread`.  A trivial example "
"of a multiprocess program is ::"
msgstr ""
"在 :mod:`multiprocessing` 中，通過建立一個 :class:`Process` 物件然後呼叫它的 "
":meth:`~Process.start` 方法來生成行程。 :class:`Process` 遵循 "
":class:`threading.Thread` 的 API。多行程程式的一個簡單示例是 ::"

#: ../../library/multiprocessing.rst:76
#, fuzzy
msgid ""
"To show the individual process IDs involved, here is an expanded example::"
msgstr "為了顯示所涉及的各個行程 ID，這裡是一個擴充示例："

#: ../../library/multiprocessing.rst:97
#, fuzzy
msgid ""
"For an explanation of why the ``if __name__ == '__main__'`` part is "
"necessary, see :ref:`multiprocessing-programming`."
msgstr ""
"有關為什麼 ``if __name__ == '__main__'`` 部分是必需的解釋，請參閱：ref"
"：`multiprocessing-programming`。"

#: ../../library/multiprocessing.rst:103
#, fuzzy
msgid "Contexts and start methods"
msgstr "上下文和啟動方法"

#: ../../library/multiprocessing.rst:107
#, fuzzy
msgid ""
"Depending on the platform, :mod:`multiprocessing` supports three ways to "
"start a process.  These *start methods* are"
msgstr "根據平台的不同，:mod:`multiprocessing` "
"支援三種啟動行程的方式。這些*啟動方法*是"

#: ../../library/multiprocessing.rst:118
#, fuzzy
msgid "*spawn*"
msgstr "*產卵*"

#: ../../library/multiprocessing.rst:111
#, fuzzy
msgid ""
"The parent process starts a fresh Python interpreter process.  The child "
"process will only inherit those resources necessary to run the process "
"object's :meth:`~Process.run` method.  In particular, unnecessary file "
"descriptors and handles from the parent process will not be inherited.  "
"Starting a process using this method is rather slow compared to using *fork* "
"or *forkserver*."
msgstr ""
"父行程啟動一個新的 Python 直譯器行程。子行程只會繼承運行行程物件的 "
":meth:`~Process.run` "
"方法所需的那些資源。特別是，不會從父行程繼承不必要的文件描述器和句柄。與使用 "
"*fork* 或 *forkserver* 相比，使用此方法啟動行程相當慢。"

#: ../../library/multiprocessing.rst:118
#, fuzzy
msgid "Available on Unix and Windows.  The default on Windows and macOS."
msgstr "在 Unix 和 Windows 上可用。 Windows 和 macOS 上的預設設定。"

#: ../../library/multiprocessing.rst:127
#, fuzzy
msgid "*fork*"
msgstr "*叉*"

#: ../../library/multiprocessing.rst:121
#, fuzzy
msgid ""
"The parent process uses :func:`os.fork` to fork the Python interpreter.  The "
"child process, when it begins, is effectively identical to the parent "
"process.  All resources of the parent are inherited by the child process.  "
"Note that safely forking a multithreaded process is problematic."
msgstr ""
"父行程使用 :func:`os.fork` 來派生 Python 直譯器。子行程在開始時實際上與父行程"
"相同。父行程的所有資源都由子行程繼承。請注意，安全地分叉多執行緒行程是有問題"
"的。"

#: ../../library/multiprocessing.rst:127
#, fuzzy
msgid "Available on Unix only.  The default on Unix."
msgstr "僅在 Unix 上可用。 Unix 上的預設值。"

#: ../../library/multiprocessing.rst:138
#, fuzzy
msgid "*forkserver*"
msgstr "*分叉伺服器*"

#: ../../library/multiprocessing.rst:130
#, fuzzy
msgid ""
"When the program starts and selects the *forkserver* start method, a server "
"process is started.  From then on, whenever a new process is needed, the "
"parent process connects to the server and requests that it fork a new "
"process.  The fork server process is single threaded so it is safe for it to "
"use :func:`os.fork`.  No unnecessary resources are inherited."
msgstr ""
"當程式啟動並選擇 *forkserver* 啟動方法時，將啟動一個伺服器行程。從那時起，每"
"當需要一個新行程時，父行程就會連接到伺服器並請求它派生一個新行程。 fork "
"伺服器行程是單執行緒的，因此使用它是安全的 :func:`os."
"fork`。沒有不必要的資源被繼承。"

#: ../../library/multiprocessing.rst:137
#, fuzzy
msgid ""
"Available on Unix platforms which support passing file descriptors over Unix "
"pipes."
msgstr "在支援通過 Unix 管道傳遞文件描述器的 Unix 平台上可用。"

#: ../../library/multiprocessing.rst:142 ../../library/multiprocessing.rst:1070
#, fuzzy
msgid ""
"On macOS, the *spawn* start method is now the default.  The *fork* start "
"method should be considered unsafe as it can lead to crashes of the "
"subprocess. See :issue:`33725`."
msgstr ""
"在 macOS 上，*spawn* 啟動方法現在是預設方法。 *fork* start "
"方法應該被認為是不安全的，因為它會導致子行程崩潰。請參閱 :issue:`33725`。"

#: ../../library/multiprocessing.rst:146
#, fuzzy
msgid ""
"*spawn* added on all Unix platforms, and *forkserver* added for some Unix "
"platforms. Child processes no longer inherit all of the parents inheritable "
"handles on Windows."
msgstr ""
"*spawn* 新增到所有 Unix 平台，*forkserver* 新增到某些 Unix 平台。"
"子行程不再繼承 Windows 上的所有父行程可繼承句柄。"

#: ../../library/multiprocessing.rst:152
#, fuzzy
msgid ""
"On Unix using the *spawn* or *forkserver* start methods will also start a "
"*resource tracker* process which tracks the unlinked named system resources "
"(such as named semaphores or :class:`~multiprocessing.shared_memory."
"SharedMemory` objects) created by processes of the program.  When all "
"processes have exited the resource tracker unlinks any remaining tracked "
"object. Usually there should be none, but if a process was killed by a "
"signal there may be some \"leaked\" resources.  (Neither leaked semaphores "
"nor shared memory segments will be automatically unlinked until the next "
"reboot. This is problematic for both objects because the system allows only "
"a limited number of named semaphores, and shared memory segments occupy some "
"space in the main memory.)"
msgstr ""
"在 Unix 上，使用 *spawn* 或 *forkserver* start 方法還將啟動一個 *resource "
"tracker* 行程，該行程跟踪由程式的過程。當所有行程都退出時，資源跟踪器取消鏈接"
"任何剩餘的跟踪物件。通常應該沒有，但如果行程被信號殺死，則可能存在一些“洩漏”"
"資源。 （洩漏的信號量和共享記憶體段都不會自動取消鏈接，直到下一次重新啟動。這"
"對兩個對像都是有問題的，因為系統只允許有限數量的命名信號量，並且共享記憶體段"
"佔用主記憶體中的一些空間。）"

#: ../../library/multiprocessing.rst:165
#, fuzzy
msgid ""
"To select a start method you use the :func:`set_start_method` in the ``if "
"__name__ == '__main__'`` clause of the main module.  For example::"
msgstr ""
"要選擇啟動方法，您可以在主模組的 ``if __name__ == '__main__'`` 子句中使用 "
":func:`set_start_method`。例如：："

#: ../../library/multiprocessing.rst:182
#, fuzzy
msgid ""
":func:`set_start_method` should not be used more than once in the program."
msgstr ":func:`set_start_method` 不應在程式中多次使用。"

#: ../../library/multiprocessing.rst:185
#, fuzzy
msgid ""
"Alternatively, you can use :func:`get_context` to obtain a context object.  "
"Context objects have the same API as the multiprocessing module, and allow "
"one to use multiple start methods in the same program. ::"
msgstr ""
"或者，您可以使用 :func:`get_context` 獲取上下文物件。"
"上下文物件具有與多處理模組相同的 API，並允許在同一程式中使用多個啟動方法。 ::"

#: ../../library/multiprocessing.rst:203
#, fuzzy
msgid ""
"Note that objects related to one context may not be compatible with "
"processes for a different context.  In particular, locks created using the "
"*fork* context cannot be passed to processes started using the *spawn* or "
"*forkserver* start methods."
msgstr ""
"請注意，與一個上下文相關的物件可能與不同上下文的行程不相容。特別是，使用 "
"*fork* 上下文建立的鎖不能傳遞給使用 *spawn* 或 *forkserver* "
"啟動方法啟動的行程。"

#: ../../library/multiprocessing.rst:208
#, fuzzy
msgid ""
"A library which wants to use a particular start method should probably use :"
"func:`get_context` to avoid interfering with the choice of the library user."
msgstr "想要使用特定啟動方法的庫可能應該使用 :func:`get_context` "
"以避免干擾庫使用者的選擇。"

#: ../../library/multiprocessing.rst:214
#, fuzzy
msgid ""
"The ``'spawn'`` and ``'forkserver'`` start methods cannot currently be used "
"with \"frozen\" executables (i.e., binaries produced by packages like "
"**PyInstaller** and **cx_Freeze**) on Unix. The ``'fork'`` start method does "
"work."
msgstr ""
"``'spawn'`` 和 ``'forkserver'`` 啟動方法目前不能用於 Unix "
"上的“凍結”可執行文件（即由 **PyInstaller** 和 **cx_Freeze** "
"等包生成的二進位文件）。 ``'fork'`` 啟動方法確實有效。"

#: ../../library/multiprocessing.rst:221
#, fuzzy
msgid "Exchanging objects between processes"
msgstr "在行程之間交換物件"

#: ../../library/multiprocessing.rst:223
#, fuzzy
msgid ""
":mod:`multiprocessing` supports two types of communication channel between "
"processes:"
msgstr ":mod:`multiprocessing` 支援兩種型別的行程間通信通道："

#: ../../library/multiprocessing.rst:226
#, fuzzy
msgid "**Queues**"
msgstr "**隊列**"

#: ../../library/multiprocessing.rst:228
#, fuzzy
msgid ""
"The :class:`Queue` class is a near clone of :class:`queue.Queue`.  For "
"example::"
msgstr ":class:`Queue` 類是 :class:`queue.Queue` 的近似克隆。例如：："

#: ../../library/multiprocessing.rst:243
#, fuzzy
msgid "Queues are thread and process safe."
msgstr "隊列是執行緒和行程安全的。"

#: ../../library/multiprocessing.rst:245
#, fuzzy
msgid "**Pipes**"
msgstr "**管道**"

#: ../../library/multiprocessing.rst:247
#, fuzzy
msgid ""
"The :func:`Pipe` function returns a pair of connection objects connected by "
"a pipe which by default is duplex (two-way).  For example::"
msgstr ":func:`Pipe` "
"函式回傳一對由管道連接的連接物件，管道預設為雙工（雙向）。例如：："

#: ../../library/multiprocessing.rst:263
#, fuzzy
msgid ""
"The two connection objects returned by :func:`Pipe` represent the two ends "
"of the pipe.  Each connection object has :meth:`~Connection.send` and :meth:"
"`~Connection.recv` methods (among others).  Note that data in a pipe may "
"become corrupted if two processes (or threads) try to read from or write to "
"the *same* end of the pipe at the same time.  Of course there is no risk of "
"corruption from processes using different ends of the pipe at the same time."
msgstr ""
":func:`Pipe` 回傳的兩個連接物件代表管道的兩端。每個連接對像都有 "
":meth:`~Connection.send` 和 :meth:`~Connection.recv` 方法（以及其他方法）。請"
"注意，如果兩個行程（或執行緒）試圖同時讀取或寫入管道的*同一*端，則管道中的資"
"料可能會損壞。當然，同時使用管道不同端的行程不會有損壞的風險。"

#: ../../library/multiprocessing.rst:273
#, fuzzy
msgid "Synchronization between processes"
msgstr "行程間同步"

#: ../../library/multiprocessing.rst:275
#, fuzzy
msgid ""
":mod:`multiprocessing` contains equivalents of all the synchronization "
"primitives from :mod:`threading`.  For instance one can use a lock to ensure "
"that only one process prints to standard output at a time::"
msgstr ""
":mod:`multiprocessing` 包含來自 :mod:`threading` 的所有同步原語的等價物。例如"
"，可以使用鎖來確保一次只有一個行程印出到標準輸出："

#: ../../library/multiprocessing.rst:294
#, fuzzy
msgid ""
"Without using the lock output from the different processes is liable to get "
"all mixed up."
msgstr "如果不使用鎖，不同行程的輸出很容易混淆。"

#: ../../library/multiprocessing.rst:299
#, fuzzy
msgid "Sharing state between processes"
msgstr "在行程之間共享狀態"

#: ../../library/multiprocessing.rst:301
#, fuzzy
msgid ""
"As mentioned above, when doing concurrent programming it is usually best to "
"avoid using shared state as far as possible.  This is particularly true when "
"using multiple processes."
msgstr "如上所述，在進行並發編程時，通常最好盡可能避免使用共享狀態。使用多個行程時尤"
"其如此。"

#: ../../library/multiprocessing.rst:305
#, fuzzy
msgid ""
"However, if you really do need to use some shared data then :mod:"
"`multiprocessing` provides a couple of ways of doing so."
msgstr "但是，如果您確實需要使用一些共享資料，那麼 :mod:`multiprocessing` "
"提供了幾種方法。"

#: ../../library/multiprocessing.rst:308
#, fuzzy
msgid "**Shared memory**"
msgstr "**共享記憶體**"

#: ../../library/multiprocessing.rst:310
#, fuzzy
msgid ""
"Data can be stored in a shared memory map using :class:`Value` or :class:"
"`Array`.  For example, the following code ::"
msgstr "可以使用 :class:`Value` 或 :class:`Array` "
"將資料儲存在共享記憶體映射中。例如，下面的程式碼::"

#: ../../library/multiprocessing.rst:331 ../../library/multiprocessing.rst:377
#, fuzzy
msgid "will print ::"
msgstr "將印出 ::"

#: ../../library/multiprocessing.rst:336
#, fuzzy
msgid ""
"The ``'d'`` and ``'i'`` arguments used when creating ``num`` and ``arr`` are "
"typecodes of the kind used by the :mod:`array` module: ``'d'`` indicates a "
"double precision float and ``'i'`` indicates a signed integer.  These shared "
"objects will be process and thread-safe."
msgstr ""
"建立 ``num`` 和 ``arr`` 時使用的 ``'d'`` 和 ``'i'`` 參數是 :mod:`array` "
"模組使用的那種型別程式碼：``' d'`` 表示雙精度浮點數，``'i'`` "
"表示有符號整數。這些共享物件將是行程和執行緒安全的。"

#: ../../library/multiprocessing.rst:341
#, fuzzy
msgid ""
"For more flexibility in using shared memory one can use the :mod:"
"`multiprocessing.sharedctypes` module which supports the creation of "
"arbitrary ctypes objects allocated from shared memory."
msgstr ""
"為了更靈活地使用共享記憶體，可以使用 multiprocessing.sharedctypes 模組，"
"該模組支援建立從共享記憶體分配的任意 ctypes 物件。"

#: ../../library/multiprocessing.rst:345
#, fuzzy
msgid "**Server process**"
msgstr "**伺服器行程**"

#: ../../library/multiprocessing.rst:347
#, fuzzy
msgid ""
"A manager object returned by :func:`Manager` controls a server process which "
"holds Python objects and allows other processes to manipulate them using "
"proxies."
msgstr ":func:`Manager` 回傳的管理器物件控制一個伺服器行程，該行程包含 Python "
"物件並允許其他行程使用代理來操作它們。"

#: ../../library/multiprocessing.rst:351
#, fuzzy
msgid ""
"A manager returned by :func:`Manager` will support types :class:`list`, :"
"class:`dict`, :class:`~managers.Namespace`, :class:`Lock`, :class:`RLock`, :"
"class:`Semaphore`, :class:`BoundedSemaphore`, :class:`Condition`, :class:"
"`Event`, :class:`Barrier`, :class:`Queue`, :class:`Value` and :class:"
"`Array`.  For example, ::"
msgstr ""
":func:`Manager` 回傳的管理器將支援型別 :class:`list`, :class:`dict`, "
":class:`~managers.Namespace`, :class:`Lock`, :class:`RLock` , "
":class:`Semaphore`, :class:`BoundedSemaphore`, :class:`Condition`, "
":class:`Event`, :class:`Barrier`, :class:`Queue`, :class:`Value` "
"和 :class:`數組`。例如， ：："

#: ../../library/multiprocessing.rst:382
#, fuzzy
msgid ""
"Server process managers are more flexible than using shared memory objects "
"because they can be made to support arbitrary object types.  Also, a single "
"manager can be shared by processes on different computers over a network. "
"They are, however, slower than using shared memory."
msgstr ""
"伺服器行程管理器比使用共享記憶體物件更靈活，因為它們可以支援任意對像型別。此"
"外，單個管理器可以由網絡上不同計算機上的行程共享。然而，它們比使用共享記憶體"
"慢。"

#: ../../library/multiprocessing.rst:389
#, fuzzy
msgid "Using a pool of workers"
msgstr "使用工人池"

#: ../../library/multiprocessing.rst:391
#, fuzzy
msgid ""
"The :class:`~multiprocessing.pool.Pool` class represents a pool of worker "
"processes.  It has methods which allows tasks to be offloaded to the worker "
"processes in a few different ways."
msgstr ":class:`~multiprocessing.pool.Pool` "
"類表示工作行程池。它具有允許以幾種不同方式將任務卸載到工作行程的方法。"

#: ../../library/multiprocessing.rst:395
msgid "For example::"
msgstr ""
"舉例來說：\n"
"\n"
"::"

#: ../../library/multiprocessing.rst:439
#, fuzzy
msgid ""
"Note that the methods of a pool should only ever be used by the process "
"which created it."
msgstr "請注意，池的方法只能由建立它的行程使用。"

#: ../../library/multiprocessing.rst:444
#, fuzzy
msgid ""
"Functionality within this package requires that the ``__main__`` module be "
"importable by the children. This is covered in :ref:`multiprocessing-"
"programming` however it is worth pointing out here. This means that some "
"examples, such as the :class:`multiprocessing.pool.Pool` examples will not "
"work in the interactive interpreter. For example::"
msgstr ""
"此包中的功能要求 ``__main__`` 模組可由子項導入。這在 :ref:`multiprocessing-"
"programming` 中有所介紹，但值得在這裡指出。這意味著一些示例，例如 "
"multiprocessing.pool.Pool 示例將無法在交互式直譯器中運行。例如：："

#: ../../library/multiprocessing.rst:467
#, fuzzy
msgid ""
"(If you try this it will actually output three full tracebacks interleaved "
"in a semi-random fashion, and then you may have to stop the parent process "
"somehow.)"
msgstr "（如果你嘗試這樣做，它實際上會輸出三個以半隨機方式交錯的完整回溯，然後你可能"
"不得不以某種方式停止父行程。）"

#: ../../library/multiprocessing.rst:473
#, fuzzy
msgid "Reference"
msgstr "參考"

#: ../../library/multiprocessing.rst:475
#, fuzzy
msgid ""
"The :mod:`multiprocessing` package mostly replicates the API of the :mod:"
"`threading` module."
msgstr ":mod:`multiprocessing` 包主要復制 :mod:`threading` 模組的 API。"

#: ../../library/multiprocessing.rst:480
msgid ":class:`Process` and exceptions"
msgstr ":class:`Process` 與例外"

#: ../../library/multiprocessing.rst:485
#, fuzzy
msgid ""
"Process objects represent activity that is run in a separate process. The :"
"class:`Process` class has equivalents of all the methods of :class:"
"`threading.Thread`."
msgstr ""
"流程物件表示在單獨流程中運行的活動。 :class:`Process` 類具有 "
":class:`threading.Thread` 的所有方法的等價物。"

#: ../../library/multiprocessing.rst:489
#, fuzzy
msgid ""
"The constructor should always be called with keyword arguments. *group* "
"should always be ``None``; it exists solely for compatibility with :class:"
"`threading.Thread`.  *target* is the callable object to be invoked by the :"
"meth:`run()` method.  It defaults to ``None``, meaning nothing is called. "
"*name* is the process name (see :attr:`name` for more details). *args* is "
"the argument tuple for the target invocation.  *kwargs* is a dictionary of "
"keyword arguments for the target invocation.  If provided, the keyword-only "
"*daemon* argument sets the process :attr:`daemon` flag to ``True`` or "
"``False``.  If ``None`` (the default), this flag will be inherited from the "
"creating process."
msgstr ""
"應始終使用關鍵字參數呼叫構造函式。 *group* 應該總是 ``None``；"
"它的存在僅僅是為了與 :class:`threading.Thread` 相容。 *target* 是被 "
":meth:`run()` 方法呼叫的可呼叫物件。它預設為 "
"``None``，意味著什麼都不會被呼叫。 *name* 是行程名稱（有關詳細資訊，請參閱 "
":attr:`name`）。 *args* 是目標呼叫的參數元組。 *kwargs* "
"是目標呼叫的關鍵字參數字典。如果提供，僅關鍵字 *daemon* "
"參數將行程 :attr:`daemon` 旗標設定為 ``True`` 或 "
"``False``。如果為 ``None`` （預設值），則此旗標將從建立過程中繼承。"

#: ../../library/multiprocessing.rst:500
#, fuzzy
msgid ""
"By default, no arguments are passed to *target*. The *args* argument, which "
"defaults to ``()``, can be used to specify a list or tuple of the arguments "
"to pass to *target*."
msgstr ""
"預設情況下，沒有參數傳遞給 *target*。 *args* 參數，預設為 ``()``，"
"可用於指定要傳遞給 *target* 的參數列表或元組。"

#: ../../library/multiprocessing.rst:504
#, fuzzy
msgid ""
"If a subclass overrides the constructor, it must make sure it invokes the "
"base class constructor (:meth:`Process.__init__`) before doing anything else "
"to the process."
msgstr "如果子類別重寫構造函式，"
"它必須確保在對行程執行任何其他操作之前呼叫基底類別構造函式 (:meth:`Process."
"__init__`)。"

#: ../../library/multiprocessing.rst:508
msgid "Added the *daemon* argument."
msgstr "新增 *daemon* 引數。"

#: ../../library/multiprocessing.rst:513
#, fuzzy
msgid "Method representing the process's activity."
msgstr "表示流程活動的方法。"

#: ../../library/multiprocessing.rst:515
#, fuzzy
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the target "
"argument, if any, with sequential and keyword arguments taken from the "
"*args* and *kwargs* arguments, respectively."
msgstr ""
"您可以在子類別中覆蓋此方法。標準的 :meth:`run` "
"方法呼叫傳遞給物件構造函式的可呼叫對像作為目標參數（如果有的話），"
"順序參數和關鍵字參數分別取自 *args* 和 *kwargs* 參數。"

#: ../../library/multiprocessing.rst:520
#, fuzzy
msgid ""
"Using a list or tuple as the *args* argument passed to :class:`Process` "
"achieves the same effect."
msgstr "使用列表或元組作為傳遞給 Process 的 *args* 參數可以達到相同的效果。"

#: ../../library/multiprocessing.rst:523
msgid "Example::"
msgstr ""
"範例：\n"
"\n"
"::"

#: ../../library/multiprocessing.rst:535
#, fuzzy
msgid "Start the process's activity."
msgstr "啟動行程的活動。"

#: ../../library/multiprocessing.rst:537
#, fuzzy
msgid ""
"This must be called at most once per process object.  It arranges for the "
"object's :meth:`run` method to be invoked in a separate process."
msgstr "每個行程物件最多只能呼叫一次。它安排在單獨的行程中呼叫物件的 :meth:`run` "
"方法。"

#: ../../library/multiprocessing.rst:542
#, fuzzy
msgid ""
"If the optional argument *timeout* is ``None`` (the default), the method "
"blocks until the process whose :meth:`join` method is called terminates. If "
"*timeout* is a positive number, it blocks at most *timeout* seconds. Note "
"that the method returns ``None`` if its process terminates or if the method "
"times out.  Check the process's :attr:`exitcode` to determine if it "
"terminated."
msgstr ""
"如果可選參數 *timeout* 為 ``None``（預設值），則該方法會阻塞，直到其 join "
"方法被呼叫的行程終止。如果 *timeout* 是一個正數，它最多阻塞 *timeout* "
"秒。請注意，如果其行程終止或方法超時，該方法將回傳 ``None`` 。檢查行程的 "
":attr:`exitcode` 以確定它是否終止。"

#: ../../library/multiprocessing.rst:549
#, fuzzy
msgid "A process can be joined many times."
msgstr "一個行程可以加入多次。"

#: ../../library/multiprocessing.rst:551
#, fuzzy
msgid ""
"A process cannot join itself because this would cause a deadlock.  It is an "
"error to attempt to join a process before it has been started."
msgstr "行程無法加入自身，因為這會導致死鎖。在行程啟動之前嘗試加入行程是錯誤的。"

#: ../../library/multiprocessing.rst:556
#, fuzzy
msgid ""
"The process's name.  The name is a string used for identification purposes "
"only.  It has no semantics.  Multiple processes may be given the same name."
msgstr "行程的名稱。該名稱是僅用於識別目的的字串。它沒有語義。多個行程可以被賦予相同"
"的名稱。"

#: ../../library/multiprocessing.rst:560
#, fuzzy
msgid ""
"The initial name is set by the constructor.  If no explicit name is provided "
"to the constructor, a name of the form 'Process-N\\ :sub:`1`:N\\ :sub:"
"`2`:...:N\\ :sub:`k`' is constructed, where each N\\ :sub:`k` is the N-th "
"child of its parent."
msgstr ""
"初始名稱由構造函式設定。如果沒有為構造函式提供顯式名稱，則形式為 'Process-N\\"
" :sub:`1`:N\\ :sub:`2`:...:N\\ :sub:`k`' 的名稱是構造，其中每個 N\\ :sub:`k` "
"是其父節點的第 N 個子節點。"

#: ../../library/multiprocessing.rst:567
#, fuzzy
msgid "Return whether the process is alive."
msgstr "回傳行程是否存活。"

#: ../../library/multiprocessing.rst:569
#, fuzzy
msgid ""
"Roughly, a process object is alive from the moment the :meth:`start` method "
"returns until the child process terminates."
msgstr "粗略地說，從 start 方法回傳到子行程終止，行程對像一直處於活動狀態。"

#: ../../library/multiprocessing.rst:574
#, fuzzy
msgid ""
"The process's daemon flag, a Boolean value.  This must be set before :meth:"
"`start` is called."
msgstr "行程的守護行程旗標，一個布爾值。這必須在呼叫 :meth:`start` 之前設定。"

#: ../../library/multiprocessing.rst:577
#, fuzzy
msgid "The initial value is inherited from the creating process."
msgstr "初始值繼承自建立過程。"

#: ../../library/multiprocessing.rst:579
#, fuzzy
msgid ""
"When a process exits, it attempts to terminate all of its daemonic child "
"processes."
msgstr "當行程退出時，它會嘗試終止其所有守護行程的子行程。"

#: ../../library/multiprocessing.rst:582
#, fuzzy
msgid ""
"Note that a daemonic process is not allowed to create child processes. "
"Otherwise a daemonic process would leave its children orphaned if it gets "
"terminated when its parent process exits. Additionally, these are **not** "
"Unix daemons or services, they are normal processes that will be terminated "
"(and not joined) if non-daemonic processes have exited."
msgstr ""
"請注意，不允許守護行程建立子行程。否則，如果守護行程在其父行程退出時被終止，"
"它將使其子行程成為孤兒。此外，這些**不是** Unix 守護行程或服務，它們是正常行"
"程，如果非守護行程退出，它們將被終止（而不是加入）。"

#: ../../library/multiprocessing.rst:588
#, fuzzy
msgid ""
"In addition to the  :class:`threading.Thread` API, :class:`Process` objects "
"also support the following attributes and methods:"
msgstr "除了 :class:`threading.Thread` API，:class:`Process` "
"對像還支援以下屬性和方法："

#: ../../library/multiprocessing.rst:593
#, fuzzy
msgid ""
"Return the process ID.  Before the process is spawned, this will be ``None``."
msgstr "回傳行程 ID。在生成行程之前，這將是 ``None`` 。"

#: ../../library/multiprocessing.rst:598
#, fuzzy
msgid ""
"The child's exit code.  This will be ``None`` if the process has not yet "
"terminated."
msgstr "孩子的退出程式碼。如果行程尚未終止，這將是 ``None`` 。"

#: ../../library/multiprocessing.rst:601
#, fuzzy
msgid ""
"If the child's :meth:`run` method returned normally, the exit code will be "
"0.  If it terminated via :func:`sys.exit` with an integer argument *N*, the "
"exit code will be *N*."
msgstr ""
"如果孩子的 :meth:`run` 方法正常回傳，退出程式碼將為 0。如果通過帶整數參數 *N*"
" 的 :func:`sys.exit` 終止，退出程式碼將為 *N*。"

#: ../../library/multiprocessing.rst:605
#, fuzzy
msgid ""
"If the child terminated due to an exception not caught within :meth:`run`, "
"the exit code will be 1.  If it was terminated by signal *N*, the exit code "
"will be the negative value *-N*."
msgstr ""
"如果子行程由於未在 :meth:`run` 中捕獲的例外而終止，則退出程式碼將為 1。"
"如果它被信號 *N* 終止，則退出程式碼將為負值 *-N*。"

#: ../../library/multiprocessing.rst:611
#, fuzzy
msgid "The process's authentication key (a byte string)."
msgstr "行程的身份驗證密鑰（位元組字串）。"

#: ../../library/multiprocessing.rst:613
#, fuzzy
msgid ""
"When :mod:`multiprocessing` is initialized the main process is assigned a "
"random string using :func:`os.urandom`."
msgstr "當 :mod:`multiprocessing` 初始化時，主行程使用 :func:`os.urandom` "
"分配一個隨機字串。"

#: ../../library/multiprocessing.rst:616
#, fuzzy
msgid ""
"When a :class:`Process` object is created, it will inherit the "
"authentication key of its parent process, although this may be changed by "
"setting :attr:`authkey` to another byte string."
msgstr ""
"建立 :class:`Process` "
"物件時，它將繼承其父行程的身份驗證密鑰，儘管這可以通過將 :attr:`authkey` "
"設定為另一個位元組字串來更改。"

#: ../../library/multiprocessing.rst:620
msgid "See :ref:`multiprocessing-auth-keys`."
msgstr "參閱 :ref:`multiprocessing-auth-keys`\\ 。"

#: ../../library/multiprocessing.rst:624
#, fuzzy
msgid ""
"A numeric handle of a system object which will become \"ready\" when the "
"process ends."
msgstr "行程結束時將變為“就緒”的系統物件的數字句柄。"

#: ../../library/multiprocessing.rst:627
#, fuzzy
msgid ""
"You can use this value if you want to wait on several events at once using :"
"func:`multiprocessing.connection.wait`.  Otherwise calling :meth:`join()` is "
"simpler."
msgstr ""
"如果你想使用 multiprocessing.connection.wait "
"一次等待多個事件，你可以使用這個值。否則呼叫 :meth:`join()` 會更簡單。"

#: ../../library/multiprocessing.rst:631
#, fuzzy
msgid ""
"On Windows, this is an OS handle usable with the ``WaitForSingleObject`` and "
"``WaitForMultipleObjects`` family of API calls.  On Unix, this is a file "
"descriptor usable with primitives from the :mod:`select` module."
msgstr ""
"在 Windows 上，這是一個操作系統句柄，可用於 API "
"呼叫的 ``WaitForSingleObject``和 ``WaitForMultipleObjects`` 系列。在 Unix "
"上，這是一個文件描述器，可與 :mod:`select` 模組中的原語一起使用。"

#: ../../library/multiprocessing.rst:639
#, fuzzy
msgid ""
"Terminate the process.  On Unix this is done using the ``SIGTERM`` signal; "
"on Windows :c:func:`TerminateProcess` is used.  Note that exit handlers and "
"finally clauses, etc., will not be executed."
msgstr ""
"終止行程。在 Unix 上，這是使用 ``SIGTERM`` 信號完成的；在 Windows 上使用 "
":c:func:`TerminateProcess`。請注意，不會執行退出處理程式和 finally 子句等。"

#: ../../library/multiprocessing.rst:643
#, fuzzy
msgid ""
"Note that descendant processes of the process will *not* be terminated -- "
"they will simply become orphaned."
msgstr "請注意，該行程的後代行程*不會*被終止——它們只會變成孤立的。"

#: ../../library/multiprocessing.rst:648
#, fuzzy
msgid ""
"If this method is used when the associated process is using a pipe or queue "
"then the pipe or queue is liable to become corrupted and may become unusable "
"by other process.  Similarly, if the process has acquired a lock or "
"semaphore etc. then terminating it is liable to cause other processes to "
"deadlock."
msgstr ""
"如果在關聯行程正在使用管道或隊列時使用此方法，則管道或隊列可能會損壞，並且可"
"能無法被其他行程使用。類似地，如果行程已獲得鎖或信號量等，則終止它可能會導致"
"其他行程死鎖。"

#: ../../library/multiprocessing.rst:656
#, fuzzy
msgid "Same as :meth:`terminate()` but using the ``SIGKILL`` signal on Unix."
msgstr "與 :meth:`terminate()` 相同，但在 Unix 上使用 ``SIGKILL`` 信號。"

#: ../../library/multiprocessing.rst:662
#, fuzzy
msgid ""
"Close the :class:`Process` object, releasing all resources associated with "
"it.  :exc:`ValueError` is raised if the underlying process is still "
"running.  Once :meth:`close` returns successfully, most other methods and "
"attributes of the :class:`Process` object will raise :exc:`ValueError`."
msgstr ""
"關閉 :class:`Process` 物件，釋放與其關聯的所有資源。如果底層行程仍在運行，"
"則會引發 :exc:`ValueError`。一旦 :meth:`close` 成功回傳，:class:`Process` "
"物件的大多數其他方法和屬性將引發 :exc:`ValueError`。"

#: ../../library/multiprocessing.rst:670
#, fuzzy
msgid ""
"Note that the :meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:"
"`terminate` and :attr:`exitcode` methods should only be called by the "
"process that created the process object."
msgstr ""
"請注意 :meth:`start`、:meth:`join`、:meth:`is_alive`、:meth:`terminate` 和 "
":attr:`exitcode` 方法只能由建立行程物件的行程呼叫."

#: ../../library/multiprocessing.rst:674
#, fuzzy
msgid "Example usage of some of the methods of :class:`Process`:"
msgstr ":class:`Process` 的一些方法的示例用法："

#: ../../library/multiprocessing.rst:694
#, fuzzy
msgid "The base class of all :mod:`multiprocessing` exceptions."
msgstr "所有 :mod:`multiprocessing` 例外的基底類別。"

#: ../../library/multiprocessing.rst:698
#, fuzzy
msgid ""
"Exception raised by :meth:`Connection.recv_bytes_into()` when the supplied "
"buffer object is too small for the message read."
msgstr "當提供的緩衝區對像對於讀取的消息來說太小時，Connection.recv_bytes_into() "
"引發例外。"

#: ../../library/multiprocessing.rst:701
#, fuzzy
msgid ""
"If ``e`` is an instance of :exc:`BufferTooShort` then ``e.args[0]`` will "
"give the message as a byte string."
msgstr "如果 ``e`` 是 :exc:`BufferTooShort` 的實例，則 ``e.args[0]`` "
"將以位元組字串的形式給出消息。"

#: ../../library/multiprocessing.rst:706
#, fuzzy
msgid "Raised when there is an authentication error."
msgstr "存在身份驗證錯誤時引發。"

#: ../../library/multiprocessing.rst:710
#, fuzzy
msgid "Raised by methods with a timeout when the timeout expires."
msgstr "當超時到期時由具有超時的方法引發。"

#: ../../library/multiprocessing.rst:713
#, fuzzy
msgid "Pipes and Queues"
msgstr "管道和隊列"

#: ../../library/multiprocessing.rst:715
#, fuzzy
msgid ""
"When using multiple processes, one generally uses message passing for "
"communication between processes and avoids having to use any synchronization "
"primitives like locks."
msgstr "當使用多個行程時，通常使用消息傳遞在行程之間進行通信，避免使用任何同步原語，"
"如鎖。"

#: ../../library/multiprocessing.rst:719
#, fuzzy
msgid ""
"For passing messages one can use :func:`Pipe` (for a connection between two "
"processes) or a queue (which allows multiple producers and consumers)."
msgstr "對於傳遞消息，可以使用 "
":func:`Pipe`（用於兩個行程之間的連接）或隊列（允許多個生產者和消費者）。"

#: ../../library/multiprocessing.rst:722
#, fuzzy
msgid ""
"The :class:`Queue`, :class:`SimpleQueue` and :class:`JoinableQueue` types "
"are multi-producer, multi-consumer :abbr:`FIFO (first-in, first-out)` queues "
"modelled on the :class:`queue.Queue` class in the standard library.  They "
"differ in that :class:`Queue` lacks the :meth:`~queue.Queue.task_done` and :"
"meth:`~queue.Queue.join` methods introduced into Python 2.5's :class:`queue."
"Queue` class."
msgstr ""
":class:`Queue`、:class:`SimpleQueue` 和 :class:`JoinableQueue` "
"型別是多生產者、多消費者 :abbr:`FIFO（先進先出）` 隊列模型： class: "
"標準庫中的`queue.Queue`類。它們的區別在於 :class:`Queue` 缺少 Python 2.5 "
"中引入的 :meth:`~queue.Queue.task_done` 和 :meth:`~queue.Queue.join` "
"方法 :class:`queue.Queue`班級。"

#: ../../library/multiprocessing.rst:729
#, fuzzy
msgid ""
"If you use :class:`JoinableQueue` then you **must** call :meth:"
"`JoinableQueue.task_done` for each task removed from the queue or else the "
"semaphore used to count the number of unfinished tasks may eventually "
"overflow, raising an exception."
msgstr ""
"如果你使用 :class:`JoinableQueue` 那麼你**必須**為從隊列中移除的每個任務呼叫 "
":meth:`JoinableQueue.task_done` "
"否則用於計算未完成任務數量的信號量可能最終溢出，引發例外。"

#: ../../library/multiprocessing.rst:734
#, fuzzy
msgid ""
"Note that one can also create a shared queue by using a manager object -- "
"see :ref:`multiprocessing-managers`."
msgstr "請注意，還可以使用管理器物件建立共享隊列——請參閱 :ref:`multiprocessing-"
"managers`。"

#: ../../library/multiprocessing.rst:739
#, fuzzy
msgid ""
":mod:`multiprocessing` uses the usual :exc:`queue.Empty` and :exc:`queue."
"Full` exceptions to signal a timeout.  They are not available in the :mod:"
"`multiprocessing` namespace so you need to import them from :mod:`queue`."
msgstr ""
":mod:`multiprocessing` 使用通常的 :exc:`queue.Empty` 和 :exc:`queue.Full` "
"例外來發出超時信號。它們在 :mod:`multiprocessing` 命名空間中不可用，"
"因此您需要從 :mod:`queue` 導入它們。"

#: ../../library/multiprocessing.rst:746
#, fuzzy
msgid ""
"When an object is put on a queue, the object is pickled and a background "
"thread later flushes the pickled data to an underlying pipe.  This has some "
"consequences which are a little surprising, but should not cause any "
"practical difficulties -- if they really bother you then you can instead use "
"a queue created with a :ref:`manager <multiprocessing-managers>`."
msgstr ""
"當一個對像被放入隊列時，該對像被醃製，然後後台執行緒將醃製資料刷新到底層管道"
"。這會產生一些令人驚訝的後果，但不會造成任何實際困難——如果它們真的困擾您，"
"那麼您可以改用使用 :ref:`manager <multiprocessing-managers>` 建立的隊列。"

#: ../../library/multiprocessing.rst:753
#, fuzzy
msgid ""
"After putting an object on an empty queue there may be an infinitesimal "
"delay before the queue's :meth:`~Queue.empty` method returns :const:`False` "
"and :meth:`~Queue.get_nowait` can return without raising :exc:`queue.Empty`."
msgstr ""
"將物件放入空隊列後，在隊列的 :meth:`~Queue.empty` 方法回傳 :const:`False` 和 "
":meth:`~Queue.get_nowait` 可以在不引發 :exc "
"的情況下回傳之前可能會有無限小的延遲:`queue.Empty`。"

#: ../../library/multiprocessing.rst:758
#, fuzzy
msgid ""
"If multiple processes are enqueuing objects, it is possible for the objects "
"to be received at the other end out-of-order. However, objects enqueued by "
"the same process will always be in the expected order with respect to each "
"other."
msgstr "如果多個行程正在排隊物件，則物件可能會在另一端亂序接收。但是，由同一行程排隊"
"的物件將始終按照彼此的預期順序排列。"

#: ../../library/multiprocessing.rst:765
#, fuzzy
msgid ""
"If a process is killed using :meth:`Process.terminate` or :func:`os.kill` "
"while it is trying to use a :class:`Queue`, then the data in the queue is "
"likely to become corrupted.  This may cause any other process to get an "
"exception when it tries to use the queue later on."
msgstr ""
"如果行程在嘗試使用 Queue 時使用 :meth:`Process.terminate` 或 :func:`os.kill` "
"被終止，則隊列中的資料可能會損壞。這可能會導致任何其他行程在稍後嘗試使用隊列"
"時出現例外。"

#: ../../library/multiprocessing.rst:772
#, fuzzy
msgid ""
"As mentioned above, if a child process has put items on a queue (and it has "
"not used :meth:`JoinableQueue.cancel_join_thread <multiprocessing.Queue."
"cancel_join_thread>`), then that process will not terminate until all "
"buffered items have been flushed to the pipe."
msgstr ""
"如上所述，如果子行程將項目放入隊列（並且它沒有使用 :meth:`"
"JoinableQueue.cancel_join_thread <multiprocessing.Queue.cancel_join_thread>`"
"），那麼該行程將不會終止，直到所有緩衝的項目都被刷新到管道。"

#: ../../library/multiprocessing.rst:777
#, fuzzy
msgid ""
"This means that if you try joining that process you may get a deadlock "
"unless you are sure that all items which have been put on the queue have "
"been consumed.  Similarly, if the child process is non-daemonic then the "
"parent process may hang on exit when it tries to join all its non-daemonic "
"children."
msgstr ""
"這意味著，如果您嘗試加入該行程，您可能會遇到死鎖，除非您確定所有已放入隊列的"
"項目都已被消耗。類似地，如果子行程是非守護行程，那麼當父行程試圖加入其所有非"
"守護行程時，它可能會在退出時掛起。"

#: ../../library/multiprocessing.rst:782
#, fuzzy
msgid ""
"Note that a queue created using a manager does not have this issue.  See :"
"ref:`multiprocessing-programming`."
msgstr "請注意，使用管理器建立的隊列沒有此問題。請參閱 :ref:`多處理編程`。"

#: ../../library/multiprocessing.rst:785
#, fuzzy
msgid ""
"For an example of the usage of queues for interprocess communication see :"
"ref:`multiprocessing-examples`."
msgstr "有關使用隊列進行行程間通信的示例，請參閱 :ref:`multiprocessing-examples`。"

#: ../../library/multiprocessing.rst:791
#, fuzzy
msgid ""
"Returns a pair ``(conn1, conn2)`` of :class:`~multiprocessing.connection."
"Connection` objects representing the ends of a pipe."
msgstr ""
"回傳一對 ``(conn1, conn2)`` 的 :class:`~multiprocessing.connection."
"Connection` 物件表示管道的末端。"

#: ../../library/multiprocessing.rst:795
#, fuzzy
msgid ""
"If *duplex* is ``True`` (the default) then the pipe is bidirectional.  If "
"*duplex* is ``False`` then the pipe is unidirectional: ``conn1`` can only be "
"used for receiving messages and ``conn2`` can only be used for sending "
"messages."
msgstr ""
"如果 *duplex* 為 ``True``（預設值），則管道是雙向的。如果 *duplex* "
"為 ``False``，則管道是單向的： ``conn1``只能用於接收消息， ``conn2``只能用於發送消息。"

#: ../../library/multiprocessing.rst:803
#, fuzzy
msgid ""
"Returns a process shared queue implemented using a pipe and a few locks/"
"semaphores.  When a process first puts an item on the queue a feeder thread "
"is started which transfers objects from a buffer into the pipe."
msgstr "回傳使用管道和一些鎖/信號量實作的行程共享隊列。當行程首先將一個項目放入隊列時"
"，將啟動一個供給執行緒，該執行緒將對像從緩衝區傳輸到管道中。"

#: ../../library/multiprocessing.rst:807
#, fuzzy
msgid ""
"The usual :exc:`queue.Empty` and :exc:`queue.Full` exceptions from the "
"standard library's :mod:`queue` module are raised to signal timeouts."
msgstr "標準庫的 queue 模組中常見的 :exc:`queue.Empty` 和 :exc:`queue.Full` "
"例外會引發超時信號。"

#: ../../library/multiprocessing.rst:810
#, fuzzy
msgid ""
":class:`Queue` implements all the methods of :class:`queue.Queue` except "
"for :meth:`~queue.Queue.task_done` and :meth:`~queue.Queue.join`."
msgstr ""
":class:`Queue` 實作了 :class:`queue.Queue` 的所有方法，除了 :meth:`~queue."
"Queue.task_done` 和 :meth:`~queue.Queue.join`。"

#: ../../library/multiprocessing.rst:815
#, fuzzy
msgid ""
"Return the approximate size of the queue.  Because of multithreading/"
"multiprocessing semantics, this number is not reliable."
msgstr "回傳隊列的近似大小。由於多執行緒/多處理語義，這個數字不可靠。"

#: ../../library/multiprocessing.rst:818
#, fuzzy
msgid ""
"Note that this may raise :exc:`NotImplementedError` on Unix platforms like "
"macOS where ``sem_getvalue()`` is not implemented."
msgstr ""
"請注意，這可能會在未實作 ``sem_getvalue()`` 的 Unix 平台（如 "
"macOS）上引發 :exec:`NotImplementedError`。"

#: ../../library/multiprocessing.rst:823
#, fuzzy
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr "如果隊列為空，則回傳 ``True``，否則回傳 ``False``。由於多執行緒/多處理語義，這是不"
"可靠的。"

#: ../../library/multiprocessing.rst:828
#, fuzzy
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr "如果隊列已滿，則回傳 ``True``，否則回傳 ``False``。由於多執行緒/多處理語義，這是不"
"可靠的。"

#: ../../library/multiprocessing.rst:833
#, fuzzy
msgid ""
"Put obj into the queue.  If the optional argument *block* is ``True`` (the "
"default) and *timeout* is ``None`` (the default), block if necessary until a "
"free slot is available.  If *timeout* is a positive number, it blocks at "
"most *timeout* seconds and raises the :exc:`queue.Full` exception if no free "
"slot was available within that time.  Otherwise (*block* is ``False``), put "
"an item on the queue if a free slot is immediately available, else raise "
"the :exc:`queue.Full` exception (*timeout* is ignored in that case)."
msgstr ""
"將 obj 放入隊列。如果可選參數 *block* 是 ``True``（預設值）並且 *timeout* 是 "
"``None``（預設值），則在必要時阻塞，直到有空閒插槽可用。如果 *timeout* "
"是一個正數，它最多阻塞 *timeout* 秒，如果在該時間內沒有可用的空閒槽，則引發 "
":exc:`queue.Full` 例外。否則（*block* 為 "
"``False``），如果空閒插槽立即可用，則將項目放入隊列，否則引發 :exc:`queue."
"Full` 例外（*timeout* 在這種情況下被忽略）。"

#: ../../library/multiprocessing.rst:842
#, fuzzy
msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of :exc:"
"`AssertionError`."
msgstr "如果隊列關閉，則會引發 :exc:`ValueError` 而不是 :exc:`AssertionError`。"

#: ../../library/multiprocessing.rst:848
#, fuzzy
msgid "Equivalent to ``put(obj, False)``."
msgstr "等同於``put(obj, False)``。"

#: ../../library/multiprocessing.rst:852
#, fuzzy
msgid ""
"Remove and return an item from the queue.  If optional args *block* is "
"``True`` (the default) and *timeout* is ``None`` (the default), block if "
"necessary until an item is available.  If *timeout* is a positive number, it "
"blocks at most *timeout* seconds and raises the :exc:`queue.Empty` exception "
"if no item was available within that time.  Otherwise (block is ``False``), "
"return an item if one is immediately available, else raise the :exc:`queue."
"Empty` exception (*timeout* is ignored in that case)."
msgstr ""
"從隊列中刪除並回傳一個項目。如果可選參數 *block* 是 ``True``（預設值）並且 "
"*timeout* 是 ``None``（預設值），則在必要時阻止直到項目可用。如果 *timeout* "
"是一個正數，它最多阻塞 *timeout* 秒，如果在該時間內沒有項目可用，則引發 "
":exc:`queue.Empty` 例外。否則（塊為 "
"``False``），如果一個項目立即可用，則回傳一個項目，否則引發 :exc:`queue."
"Empty` 例外（*timeout* 在這種情況下被忽略）。"

#: ../../library/multiprocessing.rst:860
#, fuzzy
msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of :exc:"
"`OSError`."
msgstr "如果隊列關閉，則會引發 :exc:`ValueError` 而不是 :exc:`OSError`。"

#: ../../library/multiprocessing.rst:866
#, fuzzy
msgid "Equivalent to ``get(False)``."
msgstr "等同於``get(False)``。"

#: ../../library/multiprocessing.rst:868
#, fuzzy
msgid ""
":class:`multiprocessing.Queue` has a few additional methods not found in :"
"class:`queue.Queue`.  These methods are usually unnecessary for most code:"
msgstr ""
":class:`multiprocessing.Queue` 有一些在 :class:`queue.Queue` "
"中沒有的額外方法。大多數程式碼通常不需要這些方法："

#: ../../library/multiprocessing.rst:874
#, fuzzy
msgid ""
"Indicate that no more data will be put on this queue by the current "
"process.  The background thread will quit once it has flushed all buffered "
"data to the pipe.  This is called automatically when the queue is garbage "
"collected."
msgstr "指示當前行程不會再將資料放入此隊列。一旦將所有緩衝資料刷新到管道，後台執行緒"
"將退出。當隊列被垃圾回收時，會自動呼叫它。"

#: ../../library/multiprocessing.rst:881
#, fuzzy
msgid ""
"Join the background thread.  This can only be used after :meth:`close` has "
"been called.  It blocks until the background thread exits, ensuring that all "
"data in the buffer has been flushed to the pipe."
msgstr "加入後台執行緒。這只能在 :meth:`close` 被呼叫後使用。它阻塞直到後台執行緒退出"
"，確保緩衝區中的所有資料都已刷新到管道。"

#: ../../library/multiprocessing.rst:885
#, fuzzy
msgid ""
"By default if a process is not the creator of the queue then on exit it will "
"attempt to join the queue's background thread.  The process can call :meth:"
"`cancel_join_thread` to make :meth:`join_thread` do nothing."
msgstr ""
"預設情況下，如果行程不是隊列的建立者，那麼在退出時它將嘗試加入隊列的後台執行"
"緒。該行程可以呼叫 :meth:`cancel_join_thread` 讓 :meth:`join_thread` "
"什麼都不做。"

#: ../../library/multiprocessing.rst:891
#, fuzzy
msgid ""
"Prevent :meth:`join_thread` from blocking.  In particular, this prevents the "
"background thread from being joined automatically when the process exits -- "
"see :meth:`join_thread`."
msgstr "防止 join_thread 阻塞。特別是，這可以防止後台執行緒在行程退出時自動加入——"
"參見 :meth:`join_thread`。"

#: ../../library/multiprocessing.rst:895
#, fuzzy
msgid ""
"A better name for this method might be ``allow_exit_without_flush()``.  It "
"is likely to cause enqueued data to be lost, and you almost certainly will "
"not need to use it. It is really only there if you need the current process "
"to exit immediately without waiting to flush enqueued data to the underlying "
"pipe, and you don't care about lost data."
msgstr ""
"此方法的更好名稱可能是 ``allow_exit_without_flush()``。它很可能會導致入隊資料"
"丟失，而且您幾乎肯定不需要使用它。只有當您需要當前行程立即退出而不等待將排隊"
"的資料刷新到底層管道並且您不關心丟失的資料時，它才真正存在。"

#: ../../library/multiprocessing.rst:904
#, fuzzy
msgid ""
"This class's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the functionality "
"in this class will be disabled, and attempts to instantiate a :class:`Queue` "
"will result in an :exc:`ImportError`. See :issue:`3770` for additional "
"information.  The same holds true for any of the specialized queue types "
"listed below."
msgstr ""
"此類的功能需要主機操作系統上的功能共享信號量實作。如果沒有，此類中的功能將被"
"禁用，並且嘗試實例化 Queue 將導致 ImportError。有關更多資訊，請參閱 :issue:`3"
"770`。這同樣適用於下面列出的任何專用隊列型別。"

#: ../../library/multiprocessing.rst:913
#, fuzzy
msgid ""
"It is a simplified :class:`Queue` type, very close to a locked :class:`Pipe`."
msgstr "它是一種簡化的 :class:`Queue` 型別，非常接近於鎖定的 :class:`Pipe`。"

#: ../../library/multiprocessing.rst:917
#, fuzzy
msgid "Close the queue: release internal resources."
msgstr "關閉隊列：釋放內部資源。"

#: ../../library/multiprocessing.rst:919
#, fuzzy
msgid ""
"A queue must not be used anymore after it is closed. For example, :meth:"
"`get`, :meth:`put` and :meth:`empty` methods must no longer be called."
msgstr "隊列關閉後不能再使用。例如，不得再呼叫 :meth:`get`、:meth:`put` 和 "
":meth:`empty` 方法。"

#: ../../library/multiprocessing.rst:927
#, fuzzy
msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "如果隊列為空，則回傳 ``True``，否則回傳 ``False``。"

#: ../../library/multiprocessing.rst:931
#, fuzzy
msgid "Remove and return an item from the queue."
msgstr "從隊列中刪除並回傳一個項目。"

#: ../../library/multiprocessing.rst:935
#, fuzzy
msgid "Put *item* into the queue."
msgstr "將 *item* 放入隊列。"

#: ../../library/multiprocessing.rst:940
#, fuzzy
msgid ""
":class:`JoinableQueue`, a :class:`Queue` subclass, is a queue which "
"additionally has :meth:`task_done` and :meth:`join` methods."
msgstr ""
":class:`JoinableQueue` 是一個 :class:`Queue` 子類別，是一個隊列，另外還有 "
":meth:`task_done` 和 :meth:`join` 方法。"

#: ../../library/multiprocessing.rst:945
#, fuzzy
msgid ""
"Indicate that a formerly enqueued task is complete. Used by queue "
"consumers.  For each :meth:`~Queue.get` used to fetch a task, a subsequent "
"call to :meth:`task_done` tells the queue that the processing on the task is "
"complete."
msgstr ""
"指示先前排隊的任務已完成。由隊列消費者使用。對於用於獲取任務的每個 "
":meth:`~Queue.get`，後續呼叫 :meth:`task_done` 會告訴隊列任務處理已完成。"

#: ../../library/multiprocessing.rst:950
#, fuzzy
msgid ""
"If a :meth:`~queue.Queue.join` is currently blocking, it will resume when "
"all items have been processed (meaning that a :meth:`task_done` call was "
"received for every item that had been :meth:`~Queue.put` into the queue)."
msgstr ""
"如果 :meth:`~queue.Queue.join` 當前處於阻塞狀態，它將在處理完所有項目後恢復（"
"這意味著收到了一個 :meth:`task_done` 呼叫，用於處理過的每個項目 :meth:`~ "
"Queue.put` 進入隊列）。"

#: ../../library/multiprocessing.rst:954
#, fuzzy
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr "如果被呼叫的次數多於隊列中放置的項目，則引發 :exc:`ValueError`。"

#: ../../library/multiprocessing.rst:960
#, fuzzy
msgid "Block until all items in the queue have been gotten and processed."
msgstr "阻塞直到隊列中的所有項目都被獲取和處理。"

#: ../../library/multiprocessing.rst:962
#, fuzzy
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue.  The count goes down whenever a consumer calls :meth:`task_done` to "
"indicate that the item was retrieved and all work on it is complete.  When "
"the count of unfinished tasks drops to zero, :meth:`~queue.Queue.join` "
"unblocks."
msgstr ""
"每當將項目新增到隊列中時，未完成任務的數量就會增加。每當消費者呼叫 "
":meth:`task_done` 以指示該項目已被檢索並且所有工作已完成時，計數就會下降。當"
"未完成任務的數量下降到零時，:meth:`~queue.Queue.join` 解除阻塞。"

#: ../../library/multiprocessing.rst:970
#, fuzzy
msgid "Miscellaneous"
msgstr "各種各樣的"

#: ../../library/multiprocessing.rst:974
#, fuzzy
msgid "Return list of all live children of the current process."
msgstr "回傳當前行程所有存活子行程的列表。"

#: ../../library/multiprocessing.rst:976
#, fuzzy
msgid ""
"Calling this has the side effect of \"joining\" any processes which have "
"already finished."
msgstr "呼叫它具有“加入”任何已經完成的行程的副作用。"

#: ../../library/multiprocessing.rst:981
#, fuzzy
msgid "Return the number of CPUs in the system."
msgstr "回傳系統中的 CPU 數量。"

#: ../../library/multiprocessing.rst:983
#, fuzzy
msgid ""
"This number is not equivalent to the number of CPUs the current process can "
"use.  The number of usable CPUs can be obtained with ``len(os."
"sched_getaffinity(0))``"
msgstr ""
"此數量不等於當前行程可以使用的 CPU 數量。可以使用 ``len(os."
"sched_getaffinity(0))`` 獲得可用 CPU 的數量"

#: ../../library/multiprocessing.rst:987
#, fuzzy
msgid ""
"When the number of CPUs cannot be determined a :exc:`NotImplementedError` is "
"raised."
msgstr "當無法確定 CPU 的數量時，會引發 :exec:`NotImplementedError`。"

#: ../../library/multiprocessing.rst:991
msgid ":func:`os.cpu_count`"
msgstr ":func:`os.cpu_count`"

#: ../../library/multiprocessing.rst:995
#, fuzzy
msgid ""
"Return the :class:`Process` object corresponding to the current process."
msgstr "回傳當前行程對應的 :class:`Process` 物件。"

#: ../../library/multiprocessing.rst:997
#, fuzzy
msgid "An analogue of :func:`threading.current_thread`."
msgstr ":func:`threading.current_thread` 的模擬。"

#: ../../library/multiprocessing.rst:1001
#, fuzzy
msgid ""
"Return the :class:`Process` object corresponding to the parent process of "
"the :func:`current_process`. For the main process, ``parent_process`` will "
"be ``None``."
msgstr ""
"回傳對應於 current_process 的父行程的 :class:`Process` "
"物件。對於主行程，``parent_process`` 將為``None``。"

#: ../../library/multiprocessing.rst:1009
#, fuzzy
msgid ""
"Add support for when a program which uses :mod:`multiprocessing` has been "
"frozen to produce a Windows executable.  (Has been tested with **py2exe**, "
"**PyInstaller** and **cx_Freeze**.)"
msgstr ""
"新增對使用 :mod:`multiprocessing` 的程式被凍結以生成 Windows "
"可執行文件時的支援。 （已使用 **py2exe**、**PyInstaller** 和 **cx_Freeze** "
"進行測試。）"

#: ../../library/multiprocessing.rst:1013
#, fuzzy
msgid ""
"One needs to call this function straight after the ``if __name__ == "
"'__main__'`` line of the main module.  For example::"
msgstr "需要在主模組的 ``if __name__ == '__main__'`` 行之後直接呼叫此函式。例如：："

#: ../../library/multiprocessing.rst:1025
#, fuzzy
msgid ""
"If the ``freeze_support()`` line is omitted then trying to run the frozen "
"executable will raise :exc:`RuntimeError`."
msgstr "如果省略 ``freeze_support()`` 行，則嘗試運行凍結的可執行文件將引發 "
":exc:`RuntimeError`。"

#: ../../library/multiprocessing.rst:1028
#, fuzzy
msgid ""
"Calling ``freeze_support()`` has no effect when invoked on any operating "
"system other than Windows.  In addition, if the module is being run normally "
"by the Python interpreter on Windows (the program has not been frozen), then "
"``freeze_support()`` has no effect."
msgstr ""
"在除 Windows 以外的任何操作系統上呼叫時，呼叫“freeze_support()”無效。此外，"
"如果模組在 Windows 上由 Python 直譯器正常運行（程式未被凍結），則 "
"freeze_support() 無效。"

#: ../../library/multiprocessing.rst:1035
#, fuzzy
msgid ""
"Returns a list of the supported start methods, the first of which is the "
"default.  The possible start methods are ``'fork'``, ``'spawn'`` and "
"``'forkserver'``.  On Windows only ``'spawn'`` is available.  On Unix "
"``'fork'`` and ``'spawn'`` are always supported, with ``'fork'`` being the "
"default."
msgstr ""
"回傳支援的啟動方法列表，第一個是預設方法。可能的啟動方法是 ``fork``、 ``spawn``和“f"
"orkserver”。在 Windows 上只有 ``'spawn'`` 可用。在 Unix 上，``'fork'`` 和 "
"``'spawn'`` 總是被支援的，``'fork'`` 是預設的。"

#: ../../library/multiprocessing.rst:1045
#, fuzzy
msgid ""
"Return a context object which has the same attributes as the :mod:"
"`multiprocessing` module."
msgstr "回傳一個與 multiprocessing 模組具有相同屬性的上下文物件。"

#: ../../library/multiprocessing.rst:1048
#, fuzzy
msgid ""
"If *method* is ``None`` then the default context is returned. Otherwise "
"*method* should be ``'fork'``, ``'spawn'``, ``'forkserver'``.  :exc:"
"`ValueError` is raised if the specified start method is not available."
msgstr ""
"如果 *method* 是 ``None`` 則回傳預設上下文。否則 *method* 應該是``'fork'``, "
"``'spawn'``, ``'forkserver'``。如果指定的啟動方法不可用，則會引發 "
":exc:`ValueError`。"

#: ../../library/multiprocessing.rst:1057
#, fuzzy
msgid "Return the name of start method used for starting processes."
msgstr "回傳用於啟動行程的啟動方法的名稱。"

#: ../../library/multiprocessing.rst:1059
#, fuzzy
msgid ""
"If the start method has not been fixed and *allow_none* is false, then the "
"start method is fixed to the default and the name is returned.  If the start "
"method has not been fixed and *allow_none* is true then ``None`` is returned."
msgstr ""
"如果啟動方法尚未固定且*allow_none* 為 "
"false，則啟動方法固定為預設值並回傳名稱。如果啟動方法尚未修復且 *allow_none* "
"為真，則回傳 ``None`` 。"

#: ../../library/multiprocessing.rst:1064
#, fuzzy
msgid ""
"The return value can be ``'fork'``, ``'spawn'``, ``'forkserver'`` or "
"``None``.  ``'fork'`` is the default on Unix, while ``'spawn'`` is the "
"default on Windows and macOS."
msgstr ""
"回傳值可以是 ``fork``、 ``spawn``、 ``forkserver``或 ``None``。 ``'fork'`` 是 Unix "
"上的預設設定，而 ``'spawn'`` 是 Windows 和 macOS 上的預設設定。"

#: ../../library/multiprocessing.rst:1078
#, fuzzy
msgid ""
"Set the path of the Python interpreter to use when starting a child process. "
"(By default :data:`sys.executable` is used).  Embedders will probably need "
"to do some thing like ::"
msgstr ""
"設定啟動子行程時要使用的 Python 直譯器的路徑。 （預設使用 :data:`sys."
"executable`）。嵌入器可能需要做一些像 ::"

#: ../../library/multiprocessing.rst:1084
#, fuzzy
msgid "before they can create child processes."
msgstr "在他們可以建立子行程之前。"

#: ../../library/multiprocessing.rst:1086
#, fuzzy
msgid "Now supported on Unix when the ``'spawn'`` start method is used."
msgstr "當使用 ``'spawn'`` 啟動方法時，現在在 Unix 上支援。"

#: ../../library/multiprocessing.rst:1089
#, fuzzy
msgid "Accepts a :term:`path-like object`."
msgstr "接受一個 :term:`path-like object`。"

#: ../../library/multiprocessing.rst:1094
#, fuzzy
msgid ""
"Set the method which should be used to start child processes. The *method* "
"argument can be ``'fork'``, ``'spawn'`` or ``'forkserver'``. Raises :exc:"
"`RuntimeError` if the start method has already been set and *force* is not "
"``True``.  If *method* is ``None`` and *force* is ``True`` then the start "
"method is set to ``None``.  If *method* is ``None`` and *force* is ``False`` "
"then the context is set to the default context."
msgstr ""
"設定應該用於啟動子行程的方法。 *method* "
"參數可以是 ``fork``、 ``spawn``或 ``forkserver``。如果已經設定了啟動方法並且 *force* "
"不是 ``True``，則引發 :exc:`RuntimeError`。如果*method* 為 ``None``且*force* "
"為 ``True``，則啟動方法設定為 ``None``。如果*method* 為 ``None``且*force* "
"為 ``False``，則上下文設定為預設上下文。"

#: ../../library/multiprocessing.rst:1101
#, fuzzy
msgid ""
"Note that this should be called at most once, and it should be protected "
"inside the ``if __name__ == '__main__'`` clause of the main module."
msgstr "請注意，這應該最多被呼叫一次，並且應該在主模組的 ``if __name__ == "
"'__main__'`` 子句中受到保護。"

#: ../../library/multiprocessing.rst:1109
#, fuzzy
msgid ""
":mod:`multiprocessing` contains no analogues of :func:`threading."
"active_count`, :func:`threading.enumerate`, :func:`threading.settrace`, :"
"func:`threading.setprofile`, :class:`threading.Timer`, or :class:`threading."
"local`."
msgstr ""
":mod:`multiprocessing` 不包含 :func:`threading.active_count`, :func:`threading"
".enumerate`, :func:`threading.settrace`, :func:`threading.setprofile`, "
":class:` threading.Timer` 或 :class:`threading.local`。"

#: ../../library/multiprocessing.rst:1116
#, fuzzy
msgid "Connection Objects"
msgstr "連接物件"

#: ../../library/multiprocessing.rst:1120
#, fuzzy
msgid ""
"Connection objects allow the sending and receiving of picklable objects or "
"strings.  They can be thought of as message oriented connected sockets."
msgstr "連接物件允許發送和接收可挑選的對像或字串。它們可以被認為是面向消息的連接套接"
"字。"

#: ../../library/multiprocessing.rst:1123
#, fuzzy
msgid ""
"Connection objects are usually created using :func:`Pipe <multiprocessing."
"Pipe>` -- see also :ref:`multiprocessing-listeners-clients`."
msgstr ""
"連接物件通常使用 :func:`Pipe <multiprocessing.Pipe>` 建立——另見 :ref"
":`multiprocessing-listeners-clients`。"

#: ../../library/multiprocessing.rst:1131
#, fuzzy
msgid ""
"Send an object to the other end of the connection which should be read "
"using :meth:`recv`."
msgstr "將物件發送到連接的另一端，應該使用 recv 讀取該物件。"

#: ../../library/multiprocessing.rst:1134
#, fuzzy
msgid ""
"The object must be picklable.  Very large pickles (approximately 32 MiB+, "
"though it depends on the OS) may raise a :exc:`ValueError` exception."
msgstr "該物件必須是可醃製的。非常大的泡菜（大約 32 MiB+，儘管它取決於操作系統）"
"可能會引發 :exc:`ValueError` 例外。"

#: ../../library/multiprocessing.rst:1139
#, fuzzy
msgid ""
"Return an object sent from the other end of the connection using :meth:"
"`send`.  Blocks until there is something to receive.  Raises :exc:`EOFError` "
"if there is nothing left to receive and the other end was closed."
msgstr ""
"使用 :meth:`send` 回傳從連接的另一端發送的物件。阻塞直到有東西可以接收。如果"
"沒有任何東西可以接收並且另一端已關閉，則引發 :exc:`EOFError`。"

#: ../../library/multiprocessing.rst:1146
#, fuzzy
msgid "Return the file descriptor or handle used by the connection."
msgstr "回傳連接使用的文件描述器或句柄。"

#: ../../library/multiprocessing.rst:1150
#, fuzzy
msgid "Close the connection."
msgstr "關閉連接。"

#: ../../library/multiprocessing.rst:1152
#, fuzzy
msgid "This is called automatically when the connection is garbage collected."
msgstr "當連接被垃圾收集時會自動呼叫它。"

#: ../../library/multiprocessing.rst:1156
#, fuzzy
msgid "Return whether there is any data available to be read."
msgstr "回傳是否有資料可供讀取。"

#: ../../library/multiprocessing.rst:1158
#, fuzzy
msgid ""
"If *timeout* is not specified then it will return immediately.  If *timeout* "
"is a number then this specifies the maximum time in seconds to block.  If "
"*timeout* is ``None`` then an infinite timeout is used."
msgstr ""
"如果未指定 *timeout* 則它將立即回傳。如果 *timeout* "
"是一個數字，那麼這指定了阻塞的最長時間（以秒為單位）。如果 *timeout* "
"為 ``None``，則使用無限超時。"

#: ../../library/multiprocessing.rst:1162
#, fuzzy
msgid ""
"Note that multiple connection objects may be polled at once by using :func:"
"`multiprocessing.connection.wait`."
msgstr "請注意，可以使用 multiprocessing.connection.wait 一次輪詢多個連接物件。"

#: ../../library/multiprocessing.rst:1167
#, fuzzy
msgid "Send byte data from a :term:`bytes-like object` as a complete message."
msgstr "從 :term:`bytes-like object` 發送位元組資料作為完整消息。"

#: ../../library/multiprocessing.rst:1169
#, fuzzy
msgid ""
"If *offset* is given then data is read from that position in *buffer*.  If "
"*size* is given then that many bytes will be read from buffer.  Very large "
"buffers (approximately 32 MiB+, though it depends on the OS) may raise a :"
"exc:`ValueError` exception"
msgstr ""
"如果給出了 *offset*，則從 *buffer* 中的那個位置讀取資料。如果給出 *size* "
"則將從緩衝區中讀取那麼多位元組。非常大的緩衝區（大約 32 "
"MiB+，儘管它取決於操作系統）可能會引發 :exc:`ValueError` 例外"

#: ../../library/multiprocessing.rst:1176
#, fuzzy
msgid ""
"Return a complete message of byte data sent from the other end of the "
"connection as a string.  Blocks until there is something to receive. Raises :"
"exc:`EOFError` if there is nothing left to receive and the other end has "
"closed."
msgstr ""
"回傳從連接的另一端作為字串發送的位元組資料的完整消息。阻塞直到有東西可以接收"
"。如果沒有任何東西可以接收並且另一端已關閉，則引發 :exc:`EOFError`。"

#: ../../library/multiprocessing.rst:1181
#, fuzzy
msgid ""
"If *maxlength* is specified and the message is longer than *maxlength* then :"
"exc:`OSError` is raised and the connection will no longer be readable."
msgstr "如果指定了 *maxlength* 並且消息比 *maxlength* 長，則會引發 :exc:`OSError` "
"並且連接將不再可讀。"

#: ../../library/multiprocessing.rst:1185
#, fuzzy
msgid ""
"This function used to raise :exc:`IOError`, which is now an alias of :exc:"
"`OSError`."
msgstr "此函式用於引發 :exc:`IOError`，它現在是 :exc:`OSError` 的別名。"

#: ../../library/multiprocessing.rst:1192
#, fuzzy
msgid ""
"Read into *buffer* a complete message of byte data sent from the other end "
"of the connection and return the number of bytes in the message.  Blocks "
"until there is something to receive.  Raises :exc:`EOFError` if there is "
"nothing left to receive and the other end was closed."
msgstr ""
"將連接另一端發送的位元組資料的完整消息讀入 *buffer* 並回傳消息中的位元組數。"
"阻塞直到有東西可以接收。如果沒有任何東西可以接收並且另一端已關閉，則引發 "
":exc:`EOFError`。"

#: ../../library/multiprocessing.rst:1198
#, fuzzy
msgid ""
"*buffer* must be a writable :term:`bytes-like object`.  If *offset* is given "
"then the message will be written into the buffer from that position.  Offset "
"must be a non-negative integer less than the length of *buffer* (in bytes)."
msgstr ""
"*buffer* 必須是可寫的 :term:`bytes-like object`。如果給出 *offset* "
"則消息將從該位置寫入緩衝區。偏移量必須是小於 *buffer* "
"長度（以位元組為單位）的非負整數。"

#: ../../library/multiprocessing.rst:1203
#, fuzzy
msgid ""
"If the buffer is too short then a :exc:`BufferTooShort` exception is raised "
"and the complete message is available as ``e.args[0]`` where ``e`` is the "
"exception instance."
msgstr ""
"如果緩衝區太短，則會引發 :exc:`BufferTooShort` 例外，並且完整的消息可作為 ``e"
".args[0]`` 獲得，其中 ``e`` 是例外實例。"

#: ../../library/multiprocessing.rst:1207
#, fuzzy
msgid ""
"Connection objects themselves can now be transferred between processes "
"using :meth:`Connection.send` and :meth:`Connection.recv`."
msgstr "連接物件本身現在可以使用 Connection.send 和 Connection.recv 在行程之間傳輸。"

#: ../../library/multiprocessing.rst:1211
#, fuzzy
msgid ""
"Connection objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"connection object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"連接物件現在支援上下文管理協定——請參閱 :ref:`typecontextmanager`。 "
":meth:`~contextmanager.__enter__` 回傳連接物件，並且 :meth:`~contextmanager."
"__exit__` 呼叫 :meth:`close`。"

#: ../../library/multiprocessing.rst:1216
#, fuzzy
msgid "For example:"
msgstr "例如："

#: ../../library/multiprocessing.rst:1241
#, fuzzy
msgid ""
"The :meth:`Connection.recv` method automatically unpickles the data it "
"receives, which can be a security risk unless you can trust the process "
"which sent the message."
msgstr ":meth:`Connection.recv` 方法會自動解開它接收到的資料，這可能會帶來安全風險，"
"除非您可以信任發送消息的行程。"

#: ../../library/multiprocessing.rst:1245
#, fuzzy
msgid ""
"Therefore, unless the connection object was produced using :func:`Pipe` you "
"should only use the :meth:`~Connection.recv` and :meth:`~Connection.send` "
"methods after performing some sort of authentication.  See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""
"因此，除非連接對像是使用 :func:`Pipe` 生成的，"
"否則您應該只在執行某種身份驗證後使用 :meth:`~Connection.recv` 和 "
":meth:`~Connection.send` 方法。請參閱 :ref:`multiprocessing-auth-keys`。"

#: ../../library/multiprocessing.rst:1252
#, fuzzy
msgid ""
"If a process is killed while it is trying to read or write to a pipe then "
"the data in the pipe is likely to become corrupted, because it may become "
"impossible to be sure where the message boundaries lie."
msgstr "如果行程在嘗試讀取或寫入管道時被終止，則管道中的資料可能會損壞，因為可能無法"
"確定消息邊界位於何處。"

#: ../../library/multiprocessing.rst:1258
#, fuzzy
msgid "Synchronization primitives"
msgstr "同步原語"

#: ../../library/multiprocessing.rst:1262
#, fuzzy
msgid ""
"Generally synchronization primitives are not as necessary in a multiprocess "
"program as they are in a multithreaded program.  See the documentation for :"
"mod:`threading` module."
msgstr "通常同步原語在多行程程式中不像在多執行緒程式中那樣必要。請參閱 "
":mod:`threading` 模組的文檔。"

#: ../../library/multiprocessing.rst:1266
#, fuzzy
msgid ""
"Note that one can also create synchronization primitives by using a manager "
"object -- see :ref:`multiprocessing-managers`."
msgstr "請注意，還可以使用管理器物件建立同步原語——請參閱 :ref:`multiprocessing-"
"managers`。"

#: ../../library/multiprocessing.rst:1271
#, fuzzy
msgid "A barrier object: a clone of :class:`threading.Barrier`."
msgstr "屏障物件：threading.Barrier 的克隆。"

#: ../../library/multiprocessing.rst:1277
#, fuzzy
msgid ""
"A bounded semaphore object: a close analog of :class:`threading."
"BoundedSemaphore`."
msgstr "有界信號量物件：類似於 threading.BoundedSemaphore 。"

#: ../../library/multiprocessing.rst:1280
#: ../../library/multiprocessing.rst:1418
#, fuzzy
msgid ""
"A solitary difference from its close analog exists: its ``acquire`` method's "
"first argument is named *block*, as is consistent with :meth:`Lock.acquire`."
msgstr "與它的相似類比存在一個單獨的區別：它的 ``acquire`` 方法的第一個參數被命名為 "
"*block*，與 Lock.acquire 一致。"

#: ../../library/multiprocessing.rst:1284
#, fuzzy
msgid ""
"On macOS, this is indistinguishable from :class:`Semaphore` because "
"``sem_getvalue()`` is not implemented on that platform."
msgstr "在 macOS 上，這與 :class:`Semaphore` 沒有區別，因為 ``sem_getvalue()`` "
"沒有在該平台上實作。"

#: ../../library/multiprocessing.rst:1289
#, fuzzy
msgid "A condition variable: an alias for :class:`threading.Condition`."
msgstr "條件變數：threading.Condition 的別名。"

#: ../../library/multiprocessing.rst:1291
#, fuzzy
msgid ""
"If *lock* is specified then it should be a :class:`Lock` or :class:`RLock` "
"object from :mod:`multiprocessing`."
msgstr ""
"如果指定了*lock*，那麼它應該是來自 :mod:`multiprocessing` 的 :class:`Lock` "
"或 :class:`RLock` 物件。"

#: ../../library/multiprocessing.rst:1294
#: ../../library/multiprocessing.rst:1843
#, fuzzy
msgid "The :meth:`~threading.Condition.wait_for` method was added."
msgstr "新增了 :meth:`~threading.Condition.wait_for` 方法。"

#: ../../library/multiprocessing.rst:1299
#, fuzzy
msgid "A clone of :class:`threading.Event`."
msgstr ":class:`threading.Event` 的克隆。"

#: ../../library/multiprocessing.rst:1304
#, fuzzy
msgid ""
"A non-recursive lock object: a close analog of :class:`threading.Lock`. Once "
"a process or thread has acquired a lock, subsequent attempts to acquire it "
"from any process or thread will block until it is released; any process or "
"thread may release it.  The concepts and behaviors of :class:`threading."
"Lock` as it applies to threads are replicated here in :class:"
"`multiprocessing.Lock` as it applies to either processes or threads, except "
"as noted."
msgstr ""
"非遞迴鎖物件：與 threading.Lock 的近似模擬。一旦一個行程或執行緒獲得了鎖，後"
"續從任何行程或執行緒獲取它的嘗試將被阻塞，直到它被釋放；任何行程或執行緒都可"
"以釋放它。 :class:`threading.Lock` 應用於執行緒的概念和行為在 "
":class:`multiprocessing.Lock` "
"中復制，因為它應用於行程或執行緒，除非另有說明。"

#: ../../library/multiprocessing.rst:1312
#, fuzzy
msgid ""
"Note that :class:`Lock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.Lock`` initialized with a default "
"context."
msgstr ""
"請注意 :class:`Lock` "
"實際上是一個工廠函式，它回傳使用預設上下文初始化的``multiprocessing."
"synchronize.Lock`` 的實例。"

#: ../../library/multiprocessing.rst:1316
#, fuzzy
msgid ""
":class:`Lock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
":class:`Lock` 支援 :term:`context manager` 協定，因此可以在 :keyword:`with` "
"語句中使用。"

#: ../../library/multiprocessing.rst:1321
#: ../../library/multiprocessing.rst:1372
#, fuzzy
msgid "Acquire a lock, blocking or non-blocking."
msgstr "獲取鎖，阻塞或非阻塞。"

#: ../../library/multiprocessing.rst:1323
#, fuzzy
msgid ""
"With the *block* argument set to ``True`` (the default), the method call "
"will block until the lock is in an unlocked state, then set it to locked and "
"return ``True``.  Note that the name of this first argument differs from "
"that in :meth:`threading.Lock.acquire`."
msgstr ""
"當 *block* 參數設定為 "
"``True``（預設值）時，方法呼叫將阻塞，直到鎖處於解鎖狀態，"
"然後將其設定為鎖定並回傳 ``True``。請注意，第一個參數的名稱與 "
":meth:`threading.Lock.acquire` 中的名稱不同。"

#: ../../library/multiprocessing.rst:1328
#, fuzzy
msgid ""
"With the *block* argument set to ``False``, the method call does not block.  "
"If the lock is currently in a locked state, return ``False``; otherwise set "
"the lock to a locked state and return ``True``."
msgstr ""
"當 *block* 參數設定為 ``False``時，方法呼叫不會阻塞。如果鎖當前處於鎖定狀態，則"
"回傳``False``；否則將鎖設定為鎖定狀態並回傳 ``True``。"

#: ../../library/multiprocessing.rst:1332
#, fuzzy
msgid ""
"When invoked with a positive, floating-point value for *timeout*, block for "
"at most the number of seconds specified by *timeout* as long as the lock can "
"not be acquired.  Invocations with a negative value for *timeout* are "
"equivalent to a *timeout* of zero.  Invocations with a *timeout* value of "
"``None`` (the default) set the timeout period to infinite.  Note that the "
"treatment of negative or ``None`` values for *timeout* differs from the "
"implemented behavior in :meth:`threading.Lock.acquire`.  The *timeout* "
"argument has no practical implications if the *block* argument is set to "
"``False`` and is thus ignored.  Returns ``True`` if the lock has been "
"acquired or ``False`` if the timeout period has elapsed."
msgstr ""
"當使用 *timeout* 的正浮點值呼叫時，只要無法獲取鎖，最多阻塞 *timeout* "
"指定的秒數。 *timeout* 為負值的呼叫等同於 *timeout* 為零。 *timeout* 值為 "
"``None``（預設值）的呼叫將超時期限設定為無限期。請注意，*timeout* 的負值或 "
"``None`` 值的處理不同於 threading.Lock.acquire 中實作的行為。如果 *block* "
"參數設定為 ``False``並因此被忽略，*timeout* 參數沒有實際意義。如果已獲取鎖，則回"
"傳 ``True``；如果超時期限已過，則回傳 ``False``。"

#: ../../library/multiprocessing.rst:1347
#, fuzzy
msgid ""
"Release a lock.  This can be called from any process or thread, not only the "
"process or thread which originally acquired the lock."
msgstr "釋放一個鎖。這可以從任何行程或執行緒呼叫，而不僅僅是最初獲取鎖的行程或執行緒"
"。"

#: ../../library/multiprocessing.rst:1350
#, fuzzy
msgid ""
"Behavior is the same as in :meth:`threading.Lock.release` except that when "
"invoked on an unlocked lock, a :exc:`ValueError` is raised."
msgstr ""
"行為與 :meth:`threading.Lock.release` "
"中的行為相同，除了在未鎖定的鎖上呼叫時，會引發 :exc:`ValueError`。"

#: ../../library/multiprocessing.rst:1356
#, fuzzy
msgid ""
"A recursive lock object: a close analog of :class:`threading.RLock`.  A "
"recursive lock must be released by the process or thread that acquired it. "
"Once a process or thread has acquired a recursive lock, the same process or "
"thread may acquire it again without blocking; that process or thread must "
"release it once for each time it has been acquired."
msgstr ""
"遞迴鎖物件：類似於 threading.RLock 。遞迴鎖必須由獲取它的行程或執行緒釋放。一"
"旦一個行程或執行緒獲得了遞迴鎖，同一個行程或執行緒可以再次獲得它而不會阻塞；"
"該行程或執行緒必須在每次獲取它時釋放一次。"

#: ../../library/multiprocessing.rst:1362
#, fuzzy
msgid ""
"Note that :class:`RLock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.RLock`` initialized with a default "
"context."
msgstr ""
"請注意 :class:`RLock` "
"實際上是一個工廠函式，它回傳使用預設上下文初始化的``multiprocessing."
"synchronize.RLock`` 的實例。"

#: ../../library/multiprocessing.rst:1366
#, fuzzy
msgid ""
":class:`RLock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ":class:`RLock` 支援 :term:`context manager` 協定，因此可以在 :keyword:`with` "
"語句中使用。"

#: ../../library/multiprocessing.rst:1374
#, fuzzy
msgid ""
"When invoked with the *block* argument set to ``True``, block until the lock "
"is in an unlocked state (not owned by any process or thread) unless the lock "
"is already owned by the current process or thread.  The current process or "
"thread then takes ownership of the lock (if it does not already have "
"ownership) and the recursion level inside the lock increments by one, "
"resulting in a return value of ``True``.  Note that there are several "
"differences in this first argument's behavior compared to the implementation "
"of :meth:`threading.RLock.acquire`, starting with the name of the argument "
"itself."
msgstr ""
"當 *block* 參數設定為 ``True`` 時，阻塞直到鎖處於解鎖狀態（不被任何行程或執行"
"緒擁有），除非鎖已經被當前行程或執行緒擁有。當前行程或執行緒然後取得鎖的所有"
"權（如果它還沒有所有權）並且鎖內的遞迴級別遞增 1，導致回傳值 "
"``True``。請注意，與 :meth:`threading.RLock.acquire` "
"的實作相比，第一個參數的行為存在一些差異，從參數本身的名稱開始。"

#: ../../library/multiprocessing.rst:1384
#, fuzzy
msgid ""
"When invoked with the *block* argument set to ``False``, do not block. If "
"the lock has already been acquired (and thus is owned) by another process or "
"thread, the current process or thread does not take ownership and the "
"recursion level within the lock is not changed, resulting in a return value "
"of ``False``.  If the lock is in an unlocked state, the current process or "
"thread takes ownership and the recursion level is incremented, resulting in "
"a return value of ``True``."
msgstr ""
"當 *block* 參數設定為 ``False`` 時，不要阻塞。如果鎖已經被另一個行程或執行緒"
"獲取（並因此擁有），則當前行程或執行緒不會獲得所有權並且鎖內的遞迴級別不會更"
"改，從而導致回傳值 ``False`` .如果鎖處於解鎖狀態，則當前行程或執行緒獲得所有權並"
"且遞迴級別遞增，從而導致回傳值 ``True``。"

#: ../../library/multiprocessing.rst:1392
#, fuzzy
msgid ""
"Use and behaviors of the *timeout* argument are the same as in :meth:`Lock."
"acquire`.  Note that some of these behaviors of *timeout* differ from the "
"implemented behaviors in :meth:`threading.RLock.acquire`."
msgstr ""
"*timeout* 參數的使用和行為與 Lock.acquire 中的相同。請注意，*timeout* "
"的某些行為與 threading.RLock.acquire 中實作的行為不同。"

#: ../../library/multiprocessing.rst:1399
#, fuzzy
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement "
"the recursion level is zero, reset the lock to unlocked (not owned by any "
"process or thread) and if any other processes or threads are blocked waiting "
"for the lock to become unlocked, allow exactly one of them to proceed.  If "
"after the decrement the recursion level is still nonzero, the lock remains "
"locked and owned by the calling process or thread."
msgstr ""
"釋放鎖，遞減遞迴級別。如果在遞減後遞迴級別為零，則將鎖重置為解鎖（不屬於任何"
"行程或執行緒），如果任何其他行程或執行緒被阻塞等待鎖解鎖，則只允許其中之一繼"
"續。如果在遞減之後遞迴級別仍然不為零，則鎖保持鎖定狀態並由呼叫行程或執行緒擁"
"有。"

#: ../../library/multiprocessing.rst:1407
#, fuzzy
msgid ""
"Only call this method when the calling process or thread owns the lock. An :"
"exc:`AssertionError` is raised if this method is called by a process or "
"thread other than the owner or if the lock is in an unlocked (unowned) "
"state.  Note that the type of exception raised in this situation differs "
"from the implemented behavior in :meth:`threading.RLock.release`."
msgstr ""
"僅當呼叫行程或執行緒擁有鎖時才呼叫此方法。如果此方法由所有者以外的行程或執行"
"緒呼叫，或者鎖處於解鎖（無主）狀態，則會引發 :exc:`AssertionError`。請注意，"
"在這種情況下引發的例外型別不同於 threading.RLock.release 中實作的行為。"

#: ../../library/multiprocessing.rst:1416
#, fuzzy
msgid "A semaphore object: a close analog of :class:`threading.Semaphore`."
msgstr "信號量物件：類似於 threading.Semaphore 。"

#: ../../library/multiprocessing.rst:1423
#, fuzzy
msgid ""
"On macOS, ``sem_timedwait`` is unsupported, so calling ``acquire()`` with a "
"timeout will emulate that function's behavior using a sleeping loop."
msgstr "在 macOS 上，不支援 ``sem_timedwait``，因此使用超時呼叫 ``acquire()`` "
"將使用休眠循環模擬該函式的行為。"

#: ../../library/multiprocessing.rst:1428
#, fuzzy
msgid ""
"If the SIGINT signal generated by :kbd:`Ctrl-C` arrives while the main "
"thread is blocked by a call to :meth:`BoundedSemaphore.acquire`, :meth:`Lock."
"acquire`, :meth:`RLock.acquire`, :meth:`Semaphore.acquire`, :meth:`Condition."
"acquire` or :meth:`Condition.wait` then the call will be immediately "
"interrupted and :exc:`KeyboardInterrupt` will be raised."
msgstr ""
"如果 Ctrl-C 生成的 SIGINT 信號到達時主執行緒被呼叫阻塞`, :meth:`Semaphore."
"acquire`, :meth:`Condition.acquire` 或 :meth:`Condition.wait` "
"然後呼叫將立即中斷並引發 :exc:`KeyboardInterrupt`。"

#: ../../library/multiprocessing.rst:1434
#, fuzzy
msgid ""
"This differs from the behaviour of :mod:`threading` where SIGINT will be "
"ignored while the equivalent blocking calls are in progress."
msgstr "這不同於 :mod:`threading` 的行為，其中 SIGINT "
"將在等效的阻塞呼叫進行時被忽略。"

#: ../../library/multiprocessing.rst:1439
#, fuzzy
msgid ""
"Some of this package's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the :mod:"
"`multiprocessing.synchronize` module will be disabled, and attempts to "
"import it will result in an :exc:`ImportError`. See :issue:`3770` for "
"additional information."
msgstr ""
"該軟件包的某些功能需要在主機操作系統上實作一個有效的共享信號量。沒有一個，:mo"
"d:`multiprocessing.synchronize` 模組將被禁用，並且嘗試導入它會導致 "
":exc:`ImportError`。有關更多資訊，請參閱 :issue:`3770`。"

#: ../../library/multiprocessing.rst:1447
#, fuzzy
msgid "Shared :mod:`ctypes` Objects"
msgstr "共享 :mod:`ctypes` 物件"

#: ../../library/multiprocessing.rst:1449
#, fuzzy
msgid ""
"It is possible to create shared objects using shared memory which can be "
"inherited by child processes."
msgstr "可以使用可由子行程繼承的共享記憶體建立共享物件。"

#: ../../library/multiprocessing.rst:1454
#, fuzzy
msgid ""
"Return a :mod:`ctypes` object allocated from shared memory.  By default the "
"return value is actually a synchronized wrapper for the object.  The object "
"itself can be accessed via the *value* attribute of a :class:`Value`."
msgstr ""
"回傳從共享記憶體分配的 :mod:`ctypes` "
"物件。預設情況下，回傳值實際上是物件的同步包裝器。可以通過 Value 的 *value* "
"屬性訪問物件本身。"

#: ../../library/multiprocessing.rst:1458
#: ../../library/multiprocessing.rst:1545
#, fuzzy
msgid ""
"*typecode_or_type* determines the type of the returned object: it is either "
"a ctypes type or a one character typecode of the kind used by the :mod:"
"`array` module.  *\\*args* is passed on to the constructor for the type."
msgstr ""
"*typecode_or_type* 確定回傳物件的型別：它是 ctypes 型別或 :mod:`array` "
"模組使用的那種單字元型別程式碼。 *\\*args* 傳遞給該型別的構造函式。"

#: ../../library/multiprocessing.rst:1462
#, fuzzy
msgid ""
"If *lock* is ``True`` (the default) then a new recursive lock object is "
"created to synchronize access to the value.  If *lock* is a :class:`Lock` "
"or :class:`RLock` object then that will be used to synchronize access to the "
"value.  If *lock* is ``False`` then access to the returned object will not "
"be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr ""
"如果 *lock* 為 ``True``（預設值），則建立一個新的遞迴鎖對像以同步對值的訪問。"
"如果 *lock* 是 Lock 或 RLock 物件，那麼它將用於同步對值的訪問。如果 *lock* "
"為 ``False`` "
"則對回傳物件的訪問將不會自動受到鎖的保護，因此它不一定是“行程安全的”。"

#: ../../library/multiprocessing.rst:1469
#, fuzzy
msgid ""
"Operations like ``+=`` which involve a read and write are not atomic.  So "
"if, for instance, you want to atomically increment a shared value it is "
"insufficient to just do ::"
msgstr "像``+=`` "
"這樣涉及讀寫的操作不是原子的。因此，例如，如果您想以原子方式遞增共享值，"
"僅執行 :: 是不夠的"

#: ../../library/multiprocessing.rst:1475
#, fuzzy
msgid ""
"Assuming the associated lock is recursive (which it is by default) you can "
"instead do ::"
msgstr "假設關聯的鎖是遞迴的（預設情況下是），您可以改為執行 ::"

#: ../../library/multiprocessing.rst:1481
#: ../../library/multiprocessing.rst:1571
#: ../../library/multiprocessing.rst:1586
#, fuzzy
msgid "Note that *lock* is a keyword-only argument."
msgstr "請注意，*lock* 是一個僅限關鍵字的參數。"

#: ../../library/multiprocessing.rst:1485
#, fuzzy
msgid ""
"Return a ctypes array allocated from shared memory.  By default the return "
"value is actually a synchronized wrapper for the array."
msgstr "回傳從共享記憶體分配的 ctypes "
"數組。預設情況下，回傳值實際上是數組的同步包裝器。"

#: ../../library/multiprocessing.rst:1488
#, fuzzy
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer, "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise, *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* 確定回傳數組元素的型別：它是 ctypes 型別或 :mod:`array` "
"模組使用的那種單字元型別程式碼。如果 *size_or_initializer* 是一個整數，那麼它"
"決定了數組的長度，並且數組將被初始化為零。否則，*size_or_initializer* "
"是一個用於初始化數組的序列，其長度決定了數組的長度。"

#: ../../library/multiprocessing.rst:1495
#, fuzzy
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`Lock` or :class:"
"`RLock` object then that will be used to synchronize access to the value.  "
"If *lock* is ``False`` then access to the returned object will not be "
"automatically protected by a lock, so it will not necessarily be \"process-"
"safe\"."
msgstr ""
"如果 *lock* 為 ``True``（預設值），則會建立一個新的鎖物件來同步對值的訪問。"
"如果 *lock* 是 Lock 或 RLock 物件，那麼它將用於同步對值的訪問。如果 *lock* "
"為 ``False`` "
"則對回傳物件的訪問將不會自動受到鎖的保護，因此它不一定是“行程安全的”。"

#: ../../library/multiprocessing.rst:1502
#, fuzzy
msgid "Note that *lock* is a keyword only argument."
msgstr "請注意，*lock* 是僅關鍵字參數。"

#: ../../library/multiprocessing.rst:1504
#, fuzzy
msgid ""
"Note that an array of :data:`ctypes.c_char` has *value* and *raw* attributes "
"which allow one to use it to store and retrieve strings."
msgstr "請注意，一組 :data:`ctypes.c_char` 具有 *value* 和 *raw* "
"屬性，允許使用它來儲存和檢索字串。"

#: ../../library/multiprocessing.rst:1509
#, fuzzy
msgid "The :mod:`multiprocessing.sharedctypes` module"
msgstr ":mod:`multiprocessing.sharedctypes` 模組"

#: ../../library/multiprocessing.rst:1514
#, fuzzy
msgid ""
"The :mod:`multiprocessing.sharedctypes` module provides functions for "
"allocating :mod:`ctypes` objects from shared memory which can be inherited "
"by child processes."
msgstr ""
":mod:`multiprocessing.sharedctypes` 模組提供了從共享記憶體中分配 "
":mod:`ctypes` 物件的函式，這些物件可以被子行程繼承。"

#: ../../library/multiprocessing.rst:1520
#, fuzzy
msgid ""
"Although it is possible to store a pointer in shared memory remember that "
"this will refer to a location in the address space of a specific process. "
"However, the pointer is quite likely to be invalid in the context of a "
"second process and trying to dereference the pointer from the second process "
"may cause a crash."
msgstr ""
"儘管可以在共享記憶體中儲存一個指標，但請記住，這將指向特定行程地址空間中的一"
"個位置。但是，指標很可能在第二個行程的上下文中無效，並且嘗試從第二個行程取消"
"引用指標可能會導致崩潰。"

#: ../../library/multiprocessing.rst:1528
#, fuzzy
msgid "Return a ctypes array allocated from shared memory."
msgstr "回傳從共享記憶體分配的 ctypes 數組。"

#: ../../library/multiprocessing.rst:1530
#, fuzzy
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* 確定回傳數組元素的型別：它是 ctypes 型別或 :mod:`array` "
"模組使用的那種單字元型別程式碼。如果 *size_or_initializer* "
"是一個整數，那麼它確定數組的長度，並且數組將被初始置零。否則 "
"*size_or_initializer* 是一個用於初始化數組的序列，其長度決定了數組的長度。"

#: ../../library/multiprocessing.rst:1537
#, fuzzy
msgid ""
"Note that setting and getting an element is potentially non-atomic -- use :"
"func:`Array` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr "請注意，設定和獲取元素可能是非原子的——請改用 Array 來確保使用鎖自動同步訪問。"

#: ../../library/multiprocessing.rst:1543
#, fuzzy
msgid "Return a ctypes object allocated from shared memory."
msgstr "回傳從共享記憶體分配的 ctypes 物件。"

#: ../../library/multiprocessing.rst:1549
#, fuzzy
msgid ""
"Note that setting and getting the value is potentially non-atomic -- use :"
"func:`Value` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr "請注意，設定和獲取值可能是非原子的——使用 :func:`Value` "
"來確保使用鎖自動同步訪問。"

#: ../../library/multiprocessing.rst:1553
#, fuzzy
msgid ""
"Note that an array of :data:`ctypes.c_char` has ``value`` and ``raw`` "
"attributes which allow one to use it to store and retrieve strings -- see "
"documentation for :mod:`ctypes`."
msgstr ""
"請注意 :data:`ctypes.c_char` 數組具有 ``value`` 和 ``raw`` "
"屬性，允許使用它來儲存和檢索字串——請參閱 :mod:`ctypes` 的文檔。"

#: ../../library/multiprocessing.rst:1559
#, fuzzy
msgid ""
"The same as :func:`RawArray` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"array."
msgstr "與 :func:`RawArray` 相同，除了根據 *lock* 的值，"
"可能會回傳行程安全的同步包裝器而不是原始 ctypes 數組。"

#: ../../library/multiprocessing.rst:1563
#: ../../library/multiprocessing.rst:1579
#, fuzzy
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`~multiprocessing."
"Lock` or :class:`~multiprocessing.RLock` object then that will be used to "
"synchronize access to the value.  If *lock* is ``False`` then access to the "
"returned object will not be automatically protected by a lock, so it will "
"not necessarily be \"process-safe\"."
msgstr ""
"如果 *lock* 為 ``True``（預設值），則會建立一個新的鎖物件來同步對值的訪問。"
"如果 *lock* 是 :class:`~multiprocessing.Lock` 或 :class:`~multiprocessing."
"RLock` 物件，那麼它將用於同步對值的訪問。如果 *lock* 為 ``False`` "
"則對回傳物件的訪問將不會自動受到鎖的保護，因此它不一定是“行程安全的”。"

#: ../../library/multiprocessing.rst:1575
#, fuzzy
msgid ""
"The same as :func:`RawValue` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"object."
msgstr "與 :func:`RawValue` 相同，除了根據 *lock* 的值，"
"可能會回傳行程安全的同步包裝器而不是原始 ctypes 物件。"

#: ../../library/multiprocessing.rst:1590
#, fuzzy
msgid ""
"Return a ctypes object allocated from shared memory which is a copy of the "
"ctypes object *obj*."
msgstr "回傳從共享記憶體分配的 ctypes 物件，它是 ctypes 物件 *obj* 的副本。"

#: ../../library/multiprocessing.rst:1595
#, fuzzy
msgid ""
"Return a process-safe wrapper object for a ctypes object which uses *lock* "
"to synchronize access.  If *lock* is ``None`` (the default) then a :class:"
"`multiprocessing.RLock` object is created automatically."
msgstr ""
"為使用 *lock* 同步訪問的 ctypes 物件回傳行程安全的包裝器物件。如果 *lock* 是 "
"``None``（預設值），則會自動建立一個 :class:`multiprocessing.RLock` 物件。"

#: ../../library/multiprocessing.rst:1599
#, fuzzy
msgid ""
"A synchronized wrapper will have two methods in addition to those of the "
"object it wraps: :meth:`get_obj` returns the wrapped object and :meth:"
"`get_lock` returns the lock object used for synchronization."
msgstr "同步包裝器除了它包裝的物件之外還有兩個方法：get_obj 回傳包裝的物件，get_lock "
"回傳用於同步的鎖物件。"

#: ../../library/multiprocessing.rst:1603
#, fuzzy
msgid ""
"Note that accessing the ctypes object through the wrapper can be a lot "
"slower than accessing the raw ctypes object."
msgstr "請注意，通過包裝器訪問 ctypes 物件可能比訪問原始 ctypes 物件慢很多。"

#: ../../library/multiprocessing.rst:1606
#, fuzzy
msgid "Synchronized objects support the :term:`context manager` protocol."
msgstr "同步物件支援上下文管理器協定。"

#: ../../library/multiprocessing.rst:1610
#, fuzzy
msgid ""
"The table below compares the syntax for creating shared ctypes objects from "
"shared memory with the normal ctypes syntax.  (In the table ``MyStruct`` is "
"some subclass of :class:`ctypes.Structure`.)"
msgstr ""
"下表比較了從共享記憶體建立共享 ctypes 物件的語法與普通 ctypes 語法。 （在表 "
"``MyStruct`` 中是 :class:`ctypes.Structure` 的一些子類別。）"

#: ../../library/multiprocessing.rst:1615
msgid "ctypes"
msgstr "ctypes"

#: ../../library/multiprocessing.rst:1615
#, fuzzy
msgid "sharedctypes using type"
msgstr "使用型別的共享型別"

#: ../../library/multiprocessing.rst:1615
#, fuzzy
msgid "sharedctypes using typecode"
msgstr "使用型別程式碼的 sharedctypes"

#: ../../library/multiprocessing.rst:1617
msgid "c_double(2.4)"
msgstr "c_double(2.4)"

#: ../../library/multiprocessing.rst:1617
msgid "RawValue(c_double, 2.4)"
msgstr "RawValue(c_double, 2.4)"

#: ../../library/multiprocessing.rst:1617
msgid "RawValue('d', 2.4)"
msgstr "RawValue('d', 2.4)"

#: ../../library/multiprocessing.rst:1618
msgid "MyStruct(4, 6)"
msgstr "MyStruct(4, 6)"

#: ../../library/multiprocessing.rst:1618
msgid "RawValue(MyStruct, 4, 6)"
msgstr "RawValue(MyStruct, 4, 6)"

#: ../../library/multiprocessing.rst:1619
msgid "(c_short * 7)()"
msgstr "(c_short * 7)()"

#: ../../library/multiprocessing.rst:1619
msgid "RawArray(c_short, 7)"
msgstr "RawArray(c_short, 7)"

#: ../../library/multiprocessing.rst:1619
msgid "RawArray('h', 7)"
msgstr "RawArray('h', 7)"

#: ../../library/multiprocessing.rst:1620
msgid "(c_int * 3)(9, 2, 8)"
msgstr "(c_int * 3)(9, 2, 8)"

#: ../../library/multiprocessing.rst:1620
msgid "RawArray(c_int, (9, 2, 8))"
msgstr "RawArray(c_int, (9, 2, 8))"

#: ../../library/multiprocessing.rst:1620
msgid "RawArray('i', (9, 2, 8))"
msgstr "RawArray('i', (9, 2, 8))"

#: ../../library/multiprocessing.rst:1624
#, fuzzy
msgid ""
"Below is an example where a number of ctypes objects are modified by a child "
"process::"
msgstr "下面是一個示例，其中多個 ctypes 對像被子行程修改："

#: ../../library/multiprocessing.rst:1662
#, fuzzy
msgid "The results printed are ::"
msgstr "印出出來的結果是::"

#: ../../library/multiprocessing.rst:1675
#, fuzzy
msgid "Managers"
msgstr "管理人員"

#: ../../library/multiprocessing.rst:1677
#, fuzzy
msgid ""
"Managers provide a way to create data which can be shared between different "
"processes, including sharing over a network between processes running on "
"different machines. A manager object controls a server process which manages "
"*shared objects*.  Other processes can access the shared objects by using "
"proxies."
msgstr ""
"管理器提供了一種方法來建立可以在不同行程之間共享的資料，包括在不同機器上運行"
"的行程之間通過網絡共享。管理器物件控制管理*共享物件*的伺服器行程。其他行程可"
"以使用代理訪問共享物件。"

#: ../../library/multiprocessing.rst:1686
#, fuzzy
msgid ""
"Returns a started :class:`~multiprocessing.managers.SyncManager` object "
"which can be used for sharing objects between processes.  The returned "
"manager object corresponds to a spawned child process and has methods which "
"will create shared objects and return corresponding proxies."
msgstr ""
"回傳一個啟動的 :class:`~multiprocessing.managers.SyncManager` 物件，可用於在"
"行程之間共享物件。回傳的管理器對像對應於一個派生的子行程，並具有建立共享物件"
"並回傳相應代理的方法。"

#: ../../library/multiprocessing.rst:1694
#, fuzzy
msgid ""
"Manager processes will be shutdown as soon as they are garbage collected or "
"their parent process exits.  The manager classes are defined in the :mod:"
"`multiprocessing.managers` module:"
msgstr "管理器行程一旦被垃圾回收或它們的父行程退出，它們就會被關閉。管理器類在 "
"multiprocessing.managers 模組中定義："

#: ../../library/multiprocessing.rst:1700
#, fuzzy
msgid "Create a BaseManager object."
msgstr "建立一個 BaseManager 物件。"

#: ../../library/multiprocessing.rst:1702
#, fuzzy
msgid ""
"Once created one should call :meth:`start` or ``get_server()."
"serve_forever()`` to ensure that the manager object refers to a started "
"manager process."
msgstr ""
"一旦建立，應呼叫 :meth:`start` 或 ``get_server().serve_forever()`` "
"以確保管理器物件引用已啟動的管理器行程。"

#: ../../library/multiprocessing.rst:1705
#, fuzzy
msgid ""
"*address* is the address on which the manager process listens for new "
"connections.  If *address* is ``None`` then an arbitrary one is chosen."
msgstr "*address* 是管理器行程偵聽新連接的地址。如果 *address* 是 ``None`` "
"則選擇任意一個。"

#: ../../library/multiprocessing.rst:1708
#, fuzzy
msgid ""
"*authkey* is the authentication key which will be used to check the validity "
"of incoming connections to the server process.  If *authkey* is ``None`` "
"then ``current_process().authkey`` is used. Otherwise *authkey* is used and "
"it must be a byte string."
msgstr ""
"*authkey* 是身份驗證密鑰，用於檢查傳入連接到伺服器行程的有效性。如果*authkey*"
" 為 ``None``，則使用“current_process().authkey”。否則使用 *authkey* "
"並且它必須是一個位元組串。"

#: ../../library/multiprocessing.rst:1713
#, fuzzy
msgid ""
"*serializer* must be ``'pickle'`` (use :mod:`pickle` serialization) or "
"``'xmlrpclib'`` (use :mod:`xmlrpc.client` serialization)."
msgstr ""
"*serializer* 必須是``'pickle'``（使用 :mod:`pickle` "
"序列化）或``'xmlrpclib'``（使用 :mod:`xmlrpc.client` 序列化）。"

#: ../../library/multiprocessing.rst:1716
#, fuzzy
msgid ""
"*ctx* is a context object, or ``None`` (use the current context). See the :"
"func:`get_context` function."
msgstr "*ctx* 是一個上下文物件，或者 ``None`` （使用當前上下文）。請參閱 "
":func:`get_context` 函式。"

#: ../../library/multiprocessing.rst:1719
#, fuzzy
msgid ""
"*shutdown_timeout* is a timeout in seconds used to wait until the process "
"used by the manager completes in the :meth:`shutdown` method. If the "
"shutdown times out, the process is terminated. If terminating the process "
"also times out, the process is killed."
msgstr ""
"*shutdown_timeout* 是以秒為單位的超時時間，用於等待管理器使用的行程在 "
":meth:`shutdown` "
"方法中完成。如果關閉超時，行程終止。如果終止行程也超時，則行程被殺死。"

#: ../../library/multiprocessing.rst:1724
msgid "Added the *shutdown_timeout* parameter."
msgstr "新增 *shutdown_timeout* 參數。"

#: ../../library/multiprocessing.rst:1729
#, fuzzy
msgid ""
"Start a subprocess to start the manager.  If *initializer* is not ``None`` "
"then the subprocess will call ``initializer(*initargs)`` when it starts."
msgstr ""
"啟動子行程以啟動管理器。如果 *initializer* "
"不是 ``None``，那麼子行程將在啟動時呼叫“initializer(*initargs)”。"

#: ../../library/multiprocessing.rst:1734
#, fuzzy
msgid ""
"Returns a :class:`Server` object which represents the actual server under "
"the control of the Manager. The :class:`Server` object supports the :meth:"
"`serve_forever` method::"
msgstr ""
"回傳一個 :class:`Server` 物件，它表示在管理器控制下的實際伺服器。 "
":class:`Server` 物件支援 :meth:`serve_forever` 方法::"

#: ../../library/multiprocessing.rst:1743
#, fuzzy
msgid ":class:`Server` additionally has an :attr:`address` attribute."
msgstr ":class:`Server` 另外還有一個 :attr:`address` 屬性。"

#: ../../library/multiprocessing.rst:1747
#, fuzzy
msgid "Connect a local manager object to a remote manager process::"
msgstr "將本地管理器物件連接到遠程管理器行程::"

#: ../../library/multiprocessing.rst:1755
#, fuzzy
msgid ""
"Stop the process used by the manager.  This is only available if :meth:"
"`start` has been used to start the server process."
msgstr "停止管理器使用的行程。這僅在 :meth:`start` 已用於啟動伺服器行程時可用。"

#: ../../library/multiprocessing.rst:1758
#, fuzzy
msgid "This can be called multiple times."
msgstr "這可以被多次呼叫。"

#: ../../library/multiprocessing.rst:1762
#, fuzzy
msgid ""
"A classmethod which can be used for registering a type or callable with the "
"manager class."
msgstr "可用於註冊型別或可呼叫管理器類的類方法。"

#: ../../library/multiprocessing.rst:1765
#, fuzzy
msgid ""
"*typeid* is a \"type identifier\" which is used to identify a particular "
"type of shared object.  This must be a string."
msgstr "*typeid* 是一個“型別標識符”，用於標識特定型別的共享物件。這必須是一個字串。"

#: ../../library/multiprocessing.rst:1768
#, fuzzy
msgid ""
"*callable* is a callable used for creating objects for this type "
"identifier.  If a manager instance will be connected to the server using "
"the :meth:`connect` method, or if the *create_method* argument is ``False`` "
"then this can be left as ``None``."
msgstr ""
"*callable* 是用於為此型別標識符建立物件的可呼叫物件。如果管理器實例將使用 "
":meth:`connect` 方法連接到伺服器，或者如果 *create_method* 參數為 ``False`` "
"那麼這可以保留為 ``None``。"

#: ../../library/multiprocessing.rst:1774
#, fuzzy
msgid ""
"*proxytype* is a subclass of :class:`BaseProxy` which is used to create "
"proxies for shared objects with this *typeid*.  If ``None`` then a proxy "
"class is created automatically."
msgstr ""
"*proxytype* 是 :class:`BaseProxy` 的子類別，用於為具有此 *typeid* "
"的共享物件建立代理。如果 ``None`` ，則會自動建立一個代理類。"

#: ../../library/multiprocessing.rst:1778
#, fuzzy
msgid ""
"*exposed* is used to specify a sequence of method names which proxies for "
"this typeid should be allowed to access using :meth:`BaseProxy."
"_callmethod`.  (If *exposed* is ``None`` then :attr:`proxytype._exposed_` is "
"used instead if it exists.)  In the case where no exposed list is specified, "
"all \"public methods\" of the shared object will be accessible.  (Here a "
"\"public method\" means any attribute which has a :meth:`~object.__call__` "
"method and whose name does not begin with ``'_'``.)"
msgstr ""
"*exposed* 用於指定一系列方法名稱，應該允許此 typeid 的代理使用 "
":meth:`BaseProxy._callmethod` 進行訪問。 （如果 *exposed* 是 ``None`` 然後 "
":attr:`proxytype._exposed_` 被使用，如果它存在的話。）在沒有指定暴露列表的情"
"況下，共享物件的所有“公開方法”都可以訪問. （這裡的“公開方法”是指任何具有 "
":meth:`~object.__call__` 方法且名稱不以 ``'_'`` 開頭的屬性。）"

#: ../../library/multiprocessing.rst:1787
#, fuzzy
msgid ""
"*method_to_typeid* is a mapping used to specify the return type of those "
"exposed methods which should return a proxy.  It maps method names to typeid "
"strings.  (If *method_to_typeid* is ``None`` then :attr:`proxytype."
"_method_to_typeid_` is used instead if it exists.)  If a method's name is "
"not a key of this mapping or if the mapping is ``None`` then the object "
"returned by the method will be copied by value."
msgstr ""
"*method_to_typeid* 是一個映射，用於指定那些應該回傳代理的公開方法的回傳型別。"
"它將方法名稱映射到 typeid 字串。 （如果 *method_to_typeid* 是 ``None`` 然後 "
":attr:`proxytype._method_to_typeid_` 被使用，如果它存在的話。）"
"如果一個方法的名字不是這個映射的鍵或者如果映射是 ``None`` "
"那麼該方法回傳的物件將按值複製。"

#: ../../library/multiprocessing.rst:1794
#, fuzzy
msgid ""
"*create_method* determines whether a method should be created with name "
"*typeid* which can be used to tell the server process to create a new shared "
"object and return a proxy for it.  By default it is ``True``."
msgstr ""
"*create_method* 確定是否應該建立一個名為 *typeid* "
"的方法，它可以用來告訴伺服器行程建立一個新的共享物件並為其回傳一個代理。"
"預設情況下它是 ``True``。"

#: ../../library/multiprocessing.rst:1798
#, fuzzy
msgid ":class:`BaseManager` instances also have one read-only property:"
msgstr ":class:`BaseManager` 實例還有一個只讀屬性："

#: ../../library/multiprocessing.rst:1802
#, fuzzy
msgid "The address used by the manager."
msgstr "經理使用的地址。"

#: ../../library/multiprocessing.rst:1804
#, fuzzy
msgid ""
"Manager objects support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` starts the server "
"process (if it has not already started) and then returns the manager "
"object.  :meth:`~contextmanager.__exit__` calls :meth:`shutdown`."
msgstr ""
"管理器物件支援上下文管理協定——參見 :ref:`typecontextmanager`。 "
":meth:`~contextmanager.__enter__` "
"啟動伺服器行程（如果尚未啟動），然後回傳管理器物件。 :meth:`~contextmanager."
"__exit__` 呼叫 :meth:`shutdown`。"

#: ../../library/multiprocessing.rst:1810
#, fuzzy
msgid ""
"In previous versions :meth:`~contextmanager.__enter__` did not start the "
"manager's server process if it was not already started."
msgstr "在以前的版本中 :meth:`~contextmanager.__enter__` "
"如果尚未啟動，則不會啟動管理器的伺服器行程。"

#: ../../library/multiprocessing.rst:1815
#, fuzzy
msgid ""
"A subclass of :class:`BaseManager` which can be used for the synchronization "
"of processes.  Objects of this type are returned by :func:`multiprocessing."
"Manager`."
msgstr "BaseManager 的子類別，可用於行程同步。這種型別的物件由 :func:`multiprocessing"
".Manager` 回傳。"

#: ../../library/multiprocessing.rst:1819
#, fuzzy
msgid ""
"Its methods create and return :ref:`multiprocessing-proxy_objects` for a "
"number of commonly used data types to be synchronized across processes. This "
"notably includes shared lists and dictionaries."
msgstr ""
"它的方法建立並回傳 :ref:`multiprocessing-proxy_objects` "
"用於跨行程同步的許多常用資料型別。這尤其包括共享列表和字典。"

#: ../../library/multiprocessing.rst:1825
#, fuzzy
msgid ""
"Create a shared :class:`threading.Barrier` object and return a proxy for it."
msgstr "建立一個共享的 :class:`threading.Barrier` 物件並為其回傳一個代理。"

#: ../../library/multiprocessing.rst:1832
#, fuzzy
msgid ""
"Create a shared :class:`threading.BoundedSemaphore` object and return a "
"proxy for it."
msgstr "建立一個共享的 :class:`threading.BoundedSemaphore` 物件並回傳它的代理。"

#: ../../library/multiprocessing.rst:1837
#, fuzzy
msgid ""
"Create a shared :class:`threading.Condition` object and return a proxy for "
"it."
msgstr "建立一個共享的 :class:`threading.Condition` 物件並回傳它的代理。"

#: ../../library/multiprocessing.rst:1840
#, fuzzy
msgid ""
"If *lock* is supplied then it should be a proxy for a :class:`threading."
"Lock` or :class:`threading.RLock` object."
msgstr ""
"如果提供 *lock* 那麼它應該是 :class:`threading.Lock` 或 :class:`threading."
"RLock` 物件的代理。"

#: ../../library/multiprocessing.rst:1848
#, fuzzy
msgid ""
"Create a shared :class:`threading.Event` object and return a proxy for it."
msgstr "建立一個共享的 :class:`threading.Event` 物件並為其回傳一個代理。"

#: ../../library/multiprocessing.rst:1852
#, fuzzy
msgid ""
"Create a shared :class:`threading.Lock` object and return a proxy for it."
msgstr "建立一個共享的 :class:`threading.Lock` 物件並為其回傳一個代理。"

#: ../../library/multiprocessing.rst:1856
#, fuzzy
msgid "Create a shared :class:`Namespace` object and return a proxy for it."
msgstr "建立一個共享的 :class:`Namespace` 物件並為其回傳一個代理。"

#: ../../library/multiprocessing.rst:1860
#, fuzzy
msgid "Create a shared :class:`queue.Queue` object and return a proxy for it."
msgstr "建立一個共享的 :class:`queue.Queue` 物件並回傳它的代理。"

#: ../../library/multiprocessing.rst:1864
#, fuzzy
msgid ""
"Create a shared :class:`threading.RLock` object and return a proxy for it."
msgstr "建立一個共享的 :class:`threading.RLock` 物件並為它回傳一個代理。"

#: ../../library/multiprocessing.rst:1868
#, fuzzy
msgid ""
"Create a shared :class:`threading.Semaphore` object and return a proxy for "
"it."
msgstr "建立一個共享的 :class:`threading.Semaphore` 物件並回傳它的代理。"

#: ../../library/multiprocessing.rst:1873
#, fuzzy
msgid "Create an array and return a proxy for it."
msgstr "建立一個數組並為其回傳一個代理。"

#: ../../library/multiprocessing.rst:1877
#, fuzzy
msgid ""
"Create an object with a writable ``value`` attribute and return a proxy for "
"it."
msgstr "建立一個具有可寫 ``value``屬性的物件並為其回傳一個代理。"

#: ../../library/multiprocessing.rst:1884
#, fuzzy
msgid "Create a shared :class:`dict` object and return a proxy for it."
msgstr "建立一個共享的 :class:`dict` 物件並回傳它的代理。"

#: ../../library/multiprocessing.rst:1889
#, fuzzy
msgid "Create a shared :class:`list` object and return a proxy for it."
msgstr "建立一個共享的 :class:`list` 物件並回傳它的代理。"

#: ../../library/multiprocessing.rst:1891
#, fuzzy
msgid ""
"Shared objects are capable of being nested.  For example, a shared container "
"object such as a shared list can contain other shared objects which will all "
"be managed and synchronized by the :class:`SyncManager`."
msgstr "共享物件可以嵌套。例如，共享容器物件（如共享列表）可以包含其他共享物件，"
"這些對像都將由 SyncManager 管理和同步。"

#: ../../library/multiprocessing.rst:1898
#, fuzzy
msgid "A type that can register with :class:`SyncManager`."
msgstr "一種可以註冊到 SyncManager 的型別。"

#: ../../library/multiprocessing.rst:1900
#, fuzzy
msgid ""
"A namespace object has no public methods, but does have writable attributes. "
"Its representation shows the values of its attributes."
msgstr "命名空間對像沒有公開方法，但具有可寫屬性。它的表示顯示其屬性的值。"

#: ../../library/multiprocessing.rst:1903
#, fuzzy
msgid ""
"However, when using a proxy for a namespace object, an attribute beginning "
"with ``'_'`` will be an attribute of the proxy and not an attribute of the "
"referent:"
msgstr "但是，當對命名空間物件使用代理時，以 ``_``開頭的屬性將是代理的屬性，而不是引用物"
"件的屬性："

#: ../../library/multiprocessing.rst:1919
#, fuzzy
msgid "Customized managers"
msgstr "定制經理"

#: ../../library/multiprocessing.rst:1921
#, fuzzy
msgid ""
"To create one's own manager, one creates a subclass of :class:`BaseManager` "
"and uses the :meth:`~BaseManager.register` classmethod to register new types "
"or callables with the manager class.  For example::"
msgstr ""
"要建立自己的管理器，可以建立 :class:`BaseManager` 的子類別並使用 "
":meth:`~BaseManager.register` "
"類方法向管理器類註冊新型別或可呼叫物件。例如：："

#: ../../library/multiprocessing.rst:1946
#, fuzzy
msgid "Using a remote manager"
msgstr "使用遠程管理器"

#: ../../library/multiprocessing.rst:1948
#, fuzzy
msgid ""
"It is possible to run a manager server on one machine and have clients use "
"it from other machines (assuming that the firewalls involved allow it)."
msgstr "可以在一台機器上運行管理器伺服器並讓客戶端從其他機器上使用它（假設所涉及的防"
"火牆允許它）。"

#: ../../library/multiprocessing.rst:1951
#, fuzzy
msgid ""
"Running the following commands creates a server for a single shared queue "
"which remote clients can access::"
msgstr "運行以下命令為遠程客戶端可以訪問的單個共享隊列建立一個伺服器："

#: ../../library/multiprocessing.rst:1963
#, fuzzy
msgid "One client can access the server as follows::"
msgstr "一個客戶端可以訪問伺服器如下："

#: ../../library/multiprocessing.rst:1973
#, fuzzy
msgid "Another client can also use it::"
msgstr "另一個客戶端也可以使用它::"

#: ../../library/multiprocessing.rst:1984
#, fuzzy
msgid ""
"Local processes can also access that queue, using the code from above on the "
"client to access it remotely::"
msgstr "本地行程也可以訪問該隊列，使用客戶端上面的程式碼遠程訪問它："

#: ../../library/multiprocessing.rst:2009
#, fuzzy
msgid "Proxy Objects"
msgstr "代理物件"

#: ../../library/multiprocessing.rst:2011
#, fuzzy
msgid ""
"A proxy is an object which *refers* to a shared object which lives "
"(presumably) in a different process.  The shared object is said to be the "
"*referent* of the proxy.  Multiple proxy objects may have the same referent."
msgstr ""
"代理是一個物件，它*引用*到一個共享物件，它（大概）存在於不同的行程中。共享對"
"像被稱為代理的*referent*。多個代理物件可能具有相同的引用物件。"

#: ../../library/multiprocessing.rst:2015
#, fuzzy
msgid ""
"A proxy object has methods which invoke corresponding methods of its "
"referent (although not every method of the referent will necessarily be "
"available through the proxy).  In this way, a proxy can be used just like "
"its referent can:"
msgstr "代理物件具有呼叫其指示物件的相應方法的方法（儘管並非指示物件的每個方法都必須"
"通過代理可用）。通過這種方式，可以像使用代理一樣使用代理："

#: ../../library/multiprocessing.rst:2033
#, fuzzy
msgid ""
"Notice that applying :func:`str` to a proxy will return the representation "
"of the referent, whereas applying :func:`repr` will return the "
"representation of the proxy."
msgstr "請注意，將 :func:`str` 應用於代理將回傳所指物件的表示，而應用 :func:`repr` "
"將回傳代理的表示。"

#: ../../library/multiprocessing.rst:2037
#, fuzzy
msgid ""
"An important feature of proxy objects is that they are picklable so they can "
"be passed between processes.  As such, a referent can contain :ref:"
"`multiprocessing-proxy_objects`.  This permits nesting of these managed "
"lists, dicts, and other :ref:`multiprocessing-proxy_objects`:"
msgstr ""
"代理物件的一個重要特徵是它們是可挑選的，因此它們可以在行程之間傳遞。因此，一"
"個引用物件可以包含 :ref:`multiprocessing-"
"proxy_objects`。這允許嵌套這些託管列表、字典和其他 :ref:`multiprocessing-"
"proxy_objects`："

#: ../../library/multiprocessing.rst:2053
#, fuzzy
msgid "Similarly, dict and list proxies may be nested inside one another::"
msgstr "類似地，dict 和 list 代理可以相互嵌套::"

#: ../../library/multiprocessing.rst:2066
#, fuzzy
msgid ""
"If standard (non-proxy) :class:`list` or :class:`dict` objects are contained "
"in a referent, modifications to those mutable values will not be propagated "
"through the manager because the proxy has no way of knowing when the values "
"contained within are modified.  However, storing a value in a container "
"proxy (which triggers a ``__setitem__`` on the proxy object) does propagate "
"through the manager and so to effectively modify such an item, one could re-"
"assign the modified value to the container proxy::"
msgstr ""
"如果標準（非代理） :class:`list` 或 :class:`dict` 物件包含在引用對像中，則對這"
"些可變值的修改將不會通過管理器傳播，因為代理無法知道值何時包含在被修改。然而"
"，在容器代理中儲存一個值（在代理對像上觸發 ``__setitem__``）確實通過管理器傳"
"播，因此為了有效地修改這樣的項目，可以將修改後的值重新分配給容器代理： :"

#: ../../library/multiprocessing.rst:2085
#, fuzzy
msgid ""
"This approach is perhaps less convenient than employing nested :ref:"
"`multiprocessing-proxy_objects` for most use cases but also demonstrates a "
"level of control over the synchronization."
msgstr ""
"對於大多數用例，這種方法可能不如使用嵌套的 :ref:`multiprocessing-"
"proxy_objects` 方便，但也展示了對同步的一定程度的控制。"

#: ../../library/multiprocessing.rst:2091
#, fuzzy
msgid ""
"The proxy types in :mod:`multiprocessing` do nothing to support comparisons "
"by value.  So, for instance, we have:"
msgstr ":mod:`multiprocessing` 中的代理型別不支援按值比較。因此，例如，我們有："

#: ../../library/multiprocessing.rst:2099
#, fuzzy
msgid ""
"One should just use a copy of the referent instead when making comparisons."
msgstr "在進行比較時，應該只使用所指物件的副本。"

#: ../../library/multiprocessing.rst:2103
#, fuzzy
msgid "Proxy objects are instances of subclasses of :class:`BaseProxy`."
msgstr "代理對像是 :class:`BaseProxy` 子類別的實例。"

#: ../../library/multiprocessing.rst:2107
#, fuzzy
msgid "Call and return the result of a method of the proxy's referent."
msgstr "呼叫並回傳代理的指示物件的方法的結果。"

#: ../../library/multiprocessing.rst:2109
#, fuzzy
msgid ""
"If ``proxy`` is a proxy whose referent is ``obj`` then the expression ::"
msgstr "如果 ``proxy`` 是一個代理，其引用對像是 ``obj`` 那麼表達式 ::"

#: ../../library/multiprocessing.rst:2113
#, fuzzy
msgid "will evaluate the expression ::"
msgstr "將計算表達式 ::"

#: ../../library/multiprocessing.rst:2117
#, fuzzy
msgid "in the manager's process."
msgstr "在經理的過程中。"

#: ../../library/multiprocessing.rst:2119
#, fuzzy
msgid ""
"The returned value will be a copy of the result of the call or a proxy to a "
"new shared object -- see documentation for the *method_to_typeid* argument "
"of :meth:`BaseManager.register`."
msgstr ""
"回傳值將是呼叫結果的副本或新共享物件的代理——請參閱 BaseManager.register 的 "
"*method_to_typeid* 參數的文檔。"

#: ../../library/multiprocessing.rst:2123
#, fuzzy
msgid ""
"If an exception is raised by the call, then is re-raised by :meth:"
"`_callmethod`.  If some other exception is raised in the manager's process "
"then this is converted into a :exc:`RemoteError` exception and is raised by :"
"meth:`_callmethod`."
msgstr ""
"如果呼叫引發例外，則由 :meth:`_callmethod` "
"重新引發。如果在管理器的行程中引發了一些其他例外，那麼這將轉換為 RemoteError "
"例外並由 :meth:`_callmethod` 引發。"

#: ../../library/multiprocessing.rst:2128
#, fuzzy
msgid ""
"Note in particular that an exception will be raised if *methodname* has not "
"been *exposed*."
msgstr "請特別注意，如果 *methodname* 未被 *exposed*，則會引發例外。"

#: ../../library/multiprocessing.rst:2131
#, fuzzy
msgid "An example of the usage of :meth:`_callmethod`:"
msgstr ":meth:`_callmethod` 的用法示例："

#: ../../library/multiprocessing.rst:2147
#, fuzzy
msgid "Return a copy of the referent."
msgstr "回傳引用物件的副本。"

#: ../../library/multiprocessing.rst:2149
#, fuzzy
msgid "If the referent is unpicklable then this will raise an exception."
msgstr "如果所指對像是 unpicklable 那麼這將引發例外。"

#: ../../library/multiprocessing.rst:2153
#, fuzzy
msgid "Return a representation of the proxy object."
msgstr "回傳代理物件的表示。"

#: ../../library/multiprocessing.rst:2157
#, fuzzy
msgid "Return the representation of the referent."
msgstr "回傳所指物件的表示。"

#: ../../library/multiprocessing.rst:2161
#, fuzzy
msgid "Cleanup"
msgstr "清理"

#: ../../library/multiprocessing.rst:2163
#, fuzzy
msgid ""
"A proxy object uses a weakref callback so that when it gets garbage "
"collected it deregisters itself from the manager which owns its referent."
msgstr "代理物件使用 weakref "
"回呼，因此當它被垃圾收集時，它會從擁有其所指物件的管理器中註銷自己。"

#: ../../library/multiprocessing.rst:2166
#, fuzzy
msgid ""
"A shared object gets deleted from the manager process when there are no "
"longer any proxies referring to it."
msgstr "當不再有任何代理引用共享物件時，共享物件將從管理器行程中刪除。"

#: ../../library/multiprocessing.rst:2171
#, fuzzy
msgid "Process Pools"
msgstr "行程池"

#: ../../library/multiprocessing.rst:2176
#, fuzzy
msgid ""
"One can create a pool of processes which will carry out tasks submitted to "
"it with the :class:`Pool` class."
msgstr "可以建立一個行程池，這些行程將執行使用 Pool 類提交給它的任務。"

#: ../../library/multiprocessing.rst:2181
#, fuzzy
msgid ""
"A process pool object which controls a pool of worker processes to which "
"jobs can be submitted.  It supports asynchronous results with timeouts and "
"callbacks and has a parallel map implementation."
msgstr "一個行程池物件，它控制可以提交作業的工作行程池。它支援帶有超時和回呼的非同步"
"結果，並具有並行映射實作。"

#: ../../library/multiprocessing.rst:2185
#, fuzzy
msgid ""
"*processes* is the number of worker processes to use.  If *processes* is "
"``None`` then the number returned by :func:`os.cpu_count` is used."
msgstr "*processes* 是要使用的工作行程數。如果 *processes* 為 ``None``，則使用 "
"os.cpu_count 回傳的數字。"

#: ../../library/multiprocessing.rst:2188
#: ../../library/multiprocessing.rst:2749
#, fuzzy
msgid ""
"If *initializer* is not ``None`` then each worker process will call "
"``initializer(*initargs)`` when it starts."
msgstr "如果 *initializer* "
"不是 ``None``，那麼每個工作行程在啟動時都會呼叫“initializer(*initargs)”。"

#: ../../library/multiprocessing.rst:2191
#, fuzzy
msgid ""
"*maxtasksperchild* is the number of tasks a worker process can complete "
"before it will exit and be replaced with a fresh worker process, to enable "
"unused resources to be freed. The default *maxtasksperchild* is ``None``, "
"which means worker processes will live as long as the pool."
msgstr ""
"*maxtasksperchild* 是工作行程在退出並被新的工作行程替換之前可以完成的任務數，"
"以釋放未使用的資源。預設的 *maxtasksperchild* "
"是``None``，這意味著工作行程將與池一樣長。"

#: ../../library/multiprocessing.rst:2196
#, fuzzy
msgid ""
"*context* can be used to specify the context used for starting the worker "
"processes.  Usually a pool is created using the function :func:"
"`multiprocessing.Pool` or the :meth:`Pool` method of a context object.  In "
"both cases *context* is set appropriately."
msgstr ""
"*context* 可用於指定用於啟動工作行程的上下文。通常使用上下文物件的函式 :func:`"
"multiprocessing.Pool` 或 :meth:`Pool` 方法建立池。在這兩種情況下，*context* "
"都已適當設定。"

#: ../../library/multiprocessing.rst:2202
#, fuzzy
msgid ""
"Note that the methods of the pool object should only be called by the "
"process which created the pool."
msgstr "請注意，池物件的方法只能由建立池的行程呼叫。"

#: ../../library/multiprocessing.rst:2206
#, fuzzy
msgid ""
":class:`multiprocessing.pool` objects have internal resources that need to "
"be properly managed (like any other resource) by using the pool as a context "
"manager or by calling :meth:`close` and :meth:`terminate` manually. Failure "
"to do this can lead to the process hanging on finalization."
msgstr ""
":class:`multiprocessing.pool` 物件具有內部資源，"
"需要通過將池用作上下文管理器或通過手動呼叫 :meth:`close` 和 :meth:`terminate`"
" 來正確管理（與任何其他資源一樣）。如果不這樣做，可能會導致流程停滯不前。"

#: ../../library/multiprocessing.rst:2211
#, fuzzy
msgid ""
"Note that it is **not correct** to rely on the garbage collector to destroy "
"the pool as CPython does not assure that the finalizer of the pool will be "
"called (see :meth:`object.__del__` for more information)."
msgstr ""
"請注意，依賴垃圾收集器來銷毀池是**不正確的**，因為 CPython "
"不保證池的終結器將被呼叫（有關更多資訊，請參閱 object.__del__）。"

#: ../../library/multiprocessing.rst:2215
#, fuzzy
msgid "*maxtasksperchild*"
msgstr "*每個孩子的最大任務*"

#: ../../library/multiprocessing.rst:2218
#, fuzzy
msgid "*context*"
msgstr "*語境*"

#: ../../library/multiprocessing.rst:2223
#, fuzzy
msgid ""
"Worker processes within a :class:`Pool` typically live for the complete "
"duration of the Pool's work queue. A frequent pattern found in other systems "
"(such as Apache, mod_wsgi, etc) to free resources held by workers is to "
"allow a worker within a pool to complete only a set amount of work before "
"being exiting, being cleaned up and a new process spawned to replace the old "
"one. The *maxtasksperchild* argument to the :class:`Pool` exposes this "
"ability to the end user."
msgstr ""
":class:`Pool` 中的工作行程通常在 Pool "
"的工作隊列的整個持續時間內都存在。在其他系統（如 Apache、mod_wsgi 等）中發現"
"的一種常見的釋放工作人員持有的資源的模式是允許池中的工作人員在退出、清理和生"
"成新行程之前僅完成一定數量的工作更換舊的。 :class:`Pool` 的 "
"*maxtasksperchild* 參數向最終使用者公開了這種能力。"

#: ../../library/multiprocessing.rst:2233
#, fuzzy
msgid ""
"Call *func* with arguments *args* and keyword arguments *kwds*.  It blocks "
"until the result is ready. Given this blocks, :meth:`apply_async` is better "
"suited for performing work in parallel. Additionally, *func* is only "
"executed in one of the workers of the pool."
msgstr ""
"使用參數 *args* 和關鍵字參數 *kwds* 呼叫 "
"*func*。它會阻塞，直到結果準備就緒。鑑於此塊，:meth:`apply_async` "
"更適合併行執行工作。此外，*func* 僅在池中的一名工作人員中執行。"

#: ../../library/multiprocessing.rst:2240
#, fuzzy
msgid ""
"A variant of the :meth:`apply` method which returns a :class:"
"`~multiprocessing.pool.AsyncResult` object."
msgstr ":meth:`apply` 方法的變體，它回傳一個 :class:`~multiprocessing.pool."
"AsyncResult` 物件。"

#: ../../library/multiprocessing.rst:2243
#: ../../library/multiprocessing.rst:2274
#, fuzzy
msgid ""
"If *callback* is specified then it should be a callable which accepts a "
"single argument.  When the result becomes ready *callback* is applied to it, "
"that is unless the call failed, in which case the *error_callback* is "
"applied instead."
msgstr ""
"如果指定了 *callback* "
"那麼它應該是一個接受單個參數的可呼叫物件。當結果準備就緒時，*callback* "
"將應用於它，除非呼叫失敗，在這種情況下，*error_callback* 將被應用。"

#: ../../library/multiprocessing.rst:2248
#: ../../library/multiprocessing.rst:2279
#, fuzzy
msgid ""
"If *error_callback* is specified then it should be a callable which accepts "
"a single argument.  If the target function fails, then the *error_callback* "
"is called with the exception instance."
msgstr ""
"如果指定了 *error_callback* "
"那麼它應該是一個接受單個參數的可呼叫物件。如果目標函式失敗，則呼叫 "
"*error_callback* 例外實例。"

#: ../../library/multiprocessing.rst:2252
#: ../../library/multiprocessing.rst:2283
#, fuzzy
msgid ""
"Callbacks should complete immediately since otherwise the thread which "
"handles the results will get blocked."
msgstr "回呼應該立即完成，否則處理結果的執行緒將被阻塞。"

#: ../../library/multiprocessing.rst:2257
#, fuzzy
msgid ""
"A parallel equivalent of the :func:`map` built-in function (it supports only "
"one *iterable* argument though, for multiple iterables see :meth:`starmap`). "
"It blocks until the result is ready."
msgstr ""
":func:`map` 內建函式的並行等價物（儘管它僅支援一個 *iterable* "
"參數，對於多個可疊代物件，請參閱 "
":meth:`starmap`）。它會阻塞，直到結果準備就緒。"

#: ../../library/multiprocessing.rst:2261
#, fuzzy
msgid ""
"This method chops the iterable into a number of chunks which it submits to "
"the process pool as separate tasks.  The (approximate) size of these chunks "
"can be specified by setting *chunksize* to a positive integer."
msgstr "此方法將可疊代物件分成許多塊，並將其作為單獨的任務提交給行程池。這些塊的（近"
"似）大小可以通過將 *chunksize* 設定為正整數來指定。"

#: ../../library/multiprocessing.rst:2265
#, fuzzy
msgid ""
"Note that it may cause high memory usage for very long iterables. Consider "
"using :meth:`imap` or :meth:`imap_unordered` with explicit *chunksize* "
"option for better efficiency."
msgstr ""
"請注意，它可能會導致非常長的可疊代物件佔用大量記憶體。考慮使用帶有顯式 "
"*chunksize* 選項的 imap 或 imap_unordered 以獲得更高的效率。"

#: ../../library/multiprocessing.rst:2271
#, fuzzy
msgid ""
"A variant of the :meth:`.map` method which returns a :class:"
"`~multiprocessing.pool.AsyncResult` object."
msgstr ":meth:`.map` 方法的變體，它回傳一個 :class:`~multiprocessing.pool.AsyncResult`"
" 物件。"

#: ../../library/multiprocessing.rst:2288
#, fuzzy
msgid "A lazier version of :meth:`.map`."
msgstr ":meth:`.map` 的懶惰版本。"

#: ../../library/multiprocessing.rst:2290
#, fuzzy
msgid ""
"The *chunksize* argument is the same as the one used by the :meth:`.map` "
"method.  For very long iterables using a large value for *chunksize* can "
"make the job complete **much** faster than using the default value of ``1``."
msgstr ""
"*chunksize* 參數與 :meth:`.map` 方法使用的參數相同。對於非常長的疊代器，"
"使用較大的 *chunksize* 值可以使作業完成**比使用預設值 ``1``快得多**。"

#: ../../library/multiprocessing.rst:2295
#, fuzzy
msgid ""
"Also if *chunksize* is ``1`` then the :meth:`!next` method of the iterator "
"returned by the :meth:`imap` method has an optional *timeout* parameter: "
"``next(timeout)`` will raise :exc:`multiprocessing.TimeoutError` if the "
"result cannot be returned within *timeout* seconds."
msgstr ""
"此外，如果 *chunksize* 為 ``1``，則 imap` 方法回傳的疊代器的 :meth:`!next` "
"方法有一個可選的 *timeout* 參數：``next(timeout)``如果無法在 *timeout* "
"秒內回傳結果，將引發 :exc:`multiprocessing.TimeoutError`。"

#: ../../library/multiprocessing.rst:2302
#, fuzzy
msgid ""
"The same as :meth:`imap` except that the ordering of the results from the "
"returned iterator should be considered arbitrary.  (Only when there is only "
"one worker process is the order guaranteed to be \"correct\".)"
msgstr "與 :meth:`imap` 相同，只是回傳的疊代器的結果順序應該被認為是任意的。 "
"（只有當只有一個工作行程時，才能保證順序是“正確的”。）"

#: ../../library/multiprocessing.rst:2308
#, fuzzy
msgid ""
"Like :meth:`~multiprocessing.pool.Pool.map` except that the elements of the "
"*iterable* are expected to be iterables that are unpacked as arguments."
msgstr ""
"類似於 :meth:`~multiprocessing.pool.Pool.map` 除了 *iterable* "
"的元素應該是解包為參數的可疊代物件。"

#: ../../library/multiprocessing.rst:2312
#, fuzzy
msgid ""
"Hence an *iterable* of ``[(1,2), (3, 4)]`` results in ``[func(1,2), "
"func(3,4)]``."
msgstr "因此，``[(1,2), (3, 4)]`` 的 *iterable* 導致``[func(1,2), func(3,4)]``。"

#: ../../library/multiprocessing.rst:2319
#, fuzzy
msgid ""
"A combination of :meth:`starmap` and :meth:`map_async` that iterates over "
"*iterable* of iterables and calls *func* with the iterables unpacked. "
"Returns a result object."
msgstr ""
":meth:`starmap` 和 :meth:`map_async` 的組合，疊代可疊代物件的 *iterable* "
"並呼叫 *func* 並解壓可疊代物件。回傳結果物件。"

#: ../../library/multiprocessing.rst:2327
#, fuzzy
msgid ""
"Prevents any more tasks from being submitted to the pool.  Once all the "
"tasks have been completed the worker processes will exit."
msgstr "防止將更多任務提交到池中。一旦完成所有任務，工作行程將退出。"

#: ../../library/multiprocessing.rst:2332
#, fuzzy
msgid ""
"Stops the worker processes immediately without completing outstanding work.  "
"When the pool object is garbage collected :meth:`terminate` will be called "
"immediately."
msgstr "在未完成未完成工作的情況下立即停止工作行程。當池對像被垃圾回收時，將立即呼叫 "
":meth:`terminate`。"

#: ../../library/multiprocessing.rst:2338
#, fuzzy
msgid ""
"Wait for the worker processes to exit.  One must call :meth:`close` or :meth:"
"`terminate` before using :meth:`join`."
msgstr "等待工作行程退出。在使用 :meth:`join` 之前必須呼叫 :meth:`close` 或 "
":meth:`terminate`。"

#: ../../library/multiprocessing.rst:2341
#, fuzzy
msgid ""
"Pool objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the pool "
"object, and :meth:`~contextmanager.__exit__` calls :meth:`terminate`."
msgstr ""
"池物件現在支援上下文管理協定——請參閱 :ref:`typecontextmanager`。 "
":meth:`~contextmanager.__enter__` 回傳池物件，並且 :meth:`~contextmanager."
"__exit__` 呼叫 :meth:`terminate`。"

#: ../../library/multiprocessing.rst:2349
#, fuzzy
msgid ""
"The class of the result returned by :meth:`Pool.apply_async` and :meth:`Pool."
"map_async`."
msgstr ":meth:`Pool.apply_async` 和 :meth:`Pool.map_async` 回傳的結果類。"

#: ../../library/multiprocessing.rst:2354
#, fuzzy
msgid ""
"Return the result when it arrives.  If *timeout* is not ``None`` and the "
"result does not arrive within *timeout* seconds then :exc:`multiprocessing."
"TimeoutError` is raised.  If the remote call raised an exception then that "
"exception will be reraised by :meth:`get`."
msgstr ""
"到達時回傳結果。如果 *timeout* 不是 ``None`` 並且結果沒有在 *timeout* "
"秒內到達，則引發 :exec:`multiprocessing.TimeoutError`。如果遠程呼叫引發例外，"
"則該例外將由 :meth:`get` 重新引發。"

#: ../../library/multiprocessing.rst:2361
#, fuzzy
msgid "Wait until the result is available or until *timeout* seconds pass."
msgstr "等到結果可用或直到 *timeout* 秒過去。"

#: ../../library/multiprocessing.rst:2365
#, fuzzy
msgid "Return whether the call has completed."
msgstr "回傳呼叫是否完成。"

#: ../../library/multiprocessing.rst:2369
#, fuzzy
msgid ""
"Return whether the call completed without raising an exception.  Will raise :"
"exc:`ValueError` if the result is not ready."
msgstr "回傳呼叫是否完成且未引發例外。如果結果未準備好，將引發 :exc:`ValueError`。"

#: ../../library/multiprocessing.rst:2372
#, fuzzy
msgid ""
"If the result is not ready, :exc:`ValueError` is raised instead of :exc:"
"`AssertionError`."
msgstr "如果結果未準備好，將引發 :exc:`ValueError` 而不是 :exc:`AssertionError`。"

#: ../../library/multiprocessing.rst:2376
#, fuzzy
msgid "The following example demonstrates the use of a pool::"
msgstr "以下示例演示了池的使用："

#: ../../library/multiprocessing.rst:2403
#, fuzzy
msgid "Listeners and Clients"
msgstr "聽眾和客戶"

#: ../../library/multiprocessing.rst:2408
#, fuzzy
msgid ""
"Usually message passing between processes is done using queues or by using :"
"class:`~Connection` objects returned by :func:`~multiprocessing.Pipe`."
msgstr ""
"通常，行程之間的消息傳遞是使用隊列或使用由 :func:`~multiprocessing.Pipe` "
"回傳的 :class:`~Connection` 物件完成的。"

#: ../../library/multiprocessing.rst:2412
#, fuzzy
msgid ""
"However, the :mod:`multiprocessing.connection` module allows some extra "
"flexibility.  It basically gives a high level message oriented API for "
"dealing with sockets or Windows named pipes.  It also has support for "
"*digest authentication* using the :mod:`hmac` module, and for polling "
"multiple connections at the same time."
msgstr ""
"然而，:mod:`multiprocessing.connection` 模組允許一些額外的靈活性。"
"它基本上提供了一個高階的面向消息的 API，用於處理 socket 或 Windows 命名管道。"
"它還支援使用 :mod:`hmac` 模組的*摘要身份驗證*，並支援同時輪詢多個連接。"

#: ../../library/multiprocessing.rst:2421
#, fuzzy
msgid ""
"Send a randomly generated message to the other end of the connection and "
"wait for a reply."
msgstr "將隨機生成的消息發送到連接的另一端並等待回覆。"

#: ../../library/multiprocessing.rst:2424
#, fuzzy
msgid ""
"If the reply matches the digest of the message using *authkey* as the key "
"then a welcome message is sent to the other end of the connection.  "
"Otherwise :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"如果回復與使用 *authkey* "
"作為密鑰的消息摘要匹配，則歡迎消息將發送到連接的另一端。否則會引發 "
":exc:`~multiprocessing.AuthenticationError`。"

#: ../../library/multiprocessing.rst:2430
#, fuzzy
msgid ""
"Receive a message, calculate the digest of the message using *authkey* as "
"the key, and then send the digest back."
msgstr "接收一條消息，使用*authkey*作為密鑰計算消息的摘要，然後將摘要發回。"

#: ../../library/multiprocessing.rst:2433
#, fuzzy
msgid ""
"If a welcome message is not received, then :exc:`~multiprocessing."
"AuthenticationError` is raised."
msgstr "如果未收到歡迎消息，則會引發 :exec:`~multiprocessing.AuthenticationError`。"

#: ../../library/multiprocessing.rst:2438
#, fuzzy
msgid ""
"Attempt to set up a connection to the listener which is using address "
"*address*, returning a :class:`~Connection`."
msgstr "嘗試建立與使用地址 *address* 的偵聽器的連接，回傳 :class:`~Connection`。"

#: ../../library/multiprocessing.rst:2441
#, fuzzy
msgid ""
"The type of the connection is determined by *family* argument, but this can "
"generally be omitted since it can usually be inferred from the format of "
"*address*. (See :ref:`multiprocessing-address-formats`)"
msgstr ""
"連接的型別由 *family* 參數確定，但通常可以省略，因為它通常可以從 *address* "
"的格式中推斷出來。 （參見 :ref:`多處理地址格式`）"

#: ../../library/multiprocessing.rst:2445
#: ../../library/multiprocessing.rst:2480
#, fuzzy
msgid ""
"If *authkey* is given and not None, it should be a byte string and will be "
"used as the secret key for an HMAC-based authentication challenge. No "
"authentication is done if *authkey* is None. :exc:`~multiprocessing."
"AuthenticationError` is raised if authentication fails. See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""
"如果給出 *authkey* 而不是 None，它應該是一個位元組字串，並將用作基於 HMAC "
"的身份驗證質詢的密鑰。如果 *authkey* 為 None，則不進行身份驗證。 "
":exc:`~multiprocessing.AuthenticationError` "
"如果身份驗證失敗則引發。請參閱 :ref:`multiprocessing-auth-keys`。"

#: ../../library/multiprocessing.rst:2453
#, fuzzy
msgid ""
"A wrapper for a bound socket or Windows named pipe which is 'listening' for "
"connections."
msgstr "“偵聽”連接的綁定 socket 或 Windows 命名管道的包裝器。"

#: ../../library/multiprocessing.rst:2456
#, fuzzy
msgid ""
"*address* is the address to be used by the bound socket or named pipe of the "
"listener object."
msgstr "*address* 是偵聽器物件的綁定 socket 或命名管道使用的地址。"

#: ../../library/multiprocessing.rst:2461
#, fuzzy
msgid ""
"If an address of '0.0.0.0' is used, the address will not be a connectable "
"end point on Windows. If you require a connectable end-point, you should use "
"'127.0.0.1'."
msgstr "如果使用地址“0.0.0.0”，則該地址將不是 Windows "
"上的可連接端點。如果您需要可連接的端點，則應使用“127.0.0.1”。"

#: ../../library/multiprocessing.rst:2465
#, fuzzy
msgid ""
"*family* is the type of socket (or named pipe) to use.  This can be one of "
"the strings ``'AF_INET'`` (for a TCP socket), ``'AF_UNIX'`` (for a Unix "
"domain socket) or ``'AF_PIPE'`` (for a Windows named pipe).  Of these only "
"the first is guaranteed to be available.  If *family* is ``None`` then the "
"family is inferred from the format of *address*.  If *address* is also "
"``None`` then a default is chosen.  This default is the family which is "
"assumed to be the fastest available.  See :ref:`multiprocessing-address-"
"formats`.  Note that if *family* is ``'AF_UNIX'`` and address is ``None`` "
"then the socket will be created in a private temporary directory created "
"using :func:`tempfile.mkstemp`."
msgstr ""
"*family* 是要使用的 socket （或命名管道）的型別。這可以是字串“AF_INET”（對於 "
"TCP  socket ）、“AF_UNIX”（對於 Unix 域 socket ）或“AF_PIPE”（對於 Windows "
"命名管道）之一.其中只有第一個保證可用。如果*family* 是``None`` "
"那麼這個系列是從*address* 的格式中推斷出來的。如果 *address* 也是 ``None`` 則"
"選擇預設值。此預設值是假定最快的系列。請參閱 :ref:`多處理地址格式`。請注意，"
"如果 *family* 是 ``'AF_UNIX'`` 並且地址是 ``None`` 那麼 socket 將在使用 "
":func:`tempfile.mkstemp` 建立的私有臨時目錄中建立。"

#: ../../library/multiprocessing.rst:2476
#, fuzzy
msgid ""
"If the listener object uses a socket then *backlog* (1 by default) is passed "
"to the :meth:`~socket.socket.listen` method of the socket once it has been "
"bound."
msgstr ""
"如果偵聽器物件使用 socket ，則 *backlog*（預設為 1）在綁定後傳遞給 socket 的 "
":meth:`~socket.socket.listen` 方法。"

#: ../../library/multiprocessing.rst:2488
#, fuzzy
msgid ""
"Accept a connection on the bound socket or named pipe of the listener object "
"and return a :class:`~Connection` object. If authentication is attempted and "
"fails, then :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"在偵聽器物件的綁定 socket 或命名管道上接受連接並回傳一個 :class:`~Connection` "
"物件。如果嘗試身份驗證失敗，則會引發 :exec:`~multiprocessing."
"AuthenticationError`。"

#: ../../library/multiprocessing.rst:2495
#, fuzzy
msgid ""
"Close the bound socket or named pipe of the listener object.  This is called "
"automatically when the listener is garbage collected.  However it is "
"advisable to call it explicitly."
msgstr "關閉偵聽器物件的綁定 socket 或命名管道。當偵聽器被垃圾回收時，會自動呼叫它。但"
"是，建議明確呼叫它。"

#: ../../library/multiprocessing.rst:2499
#, fuzzy
msgid "Listener objects have the following read-only properties:"
msgstr "偵聽器物件具有以下只讀屬性："

#: ../../library/multiprocessing.rst:2503
#, fuzzy
msgid "The address which is being used by the Listener object."
msgstr "Listener 物件正在使用的地址。"

#: ../../library/multiprocessing.rst:2507
#, fuzzy
msgid ""
"The address from which the last accepted connection came.  If this is "
"unavailable then it is ``None``."
msgstr "最後接受的連接來自的地址。如果這不可用，則為 ``None`` 。"

#: ../../library/multiprocessing.rst:2510
#, fuzzy
msgid ""
"Listener objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"listener object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"偵聽器物件現在支援上下文管理協定——請參閱 :ref:`typecontextmanager`。 "
":meth:`~contextmanager.__enter__` 回傳偵聽器物件，並且 :meth:`~contextmanager"
".__exit__` 呼叫 :meth:`close`。"

#: ../../library/multiprocessing.rst:2517
#, fuzzy
msgid ""
"Wait till an object in *object_list* is ready.  Returns the list of those "
"objects in *object_list* which are ready.  If *timeout* is a float then the "
"call blocks for at most that many seconds.  If *timeout* is ``None`` then it "
"will block for an unlimited period. A negative timeout is equivalent to a "
"zero timeout."
msgstr ""
"等待 *object_list* 中的物件準備就緒。回傳 *object_list* "
"中準備好的那些物件的列表。如果 *timeout* "
"是一個浮點數，那麼呼叫最多會阻塞那麼多秒。如果 *timeout* 是 ``None`` "
"那麼它將無限期阻塞。負超時相當於零超時。"

#: ../../library/multiprocessing.rst:2523
#, fuzzy
msgid ""
"For both Unix and Windows, an object can appear in *object_list* if it is"
msgstr "對於 Unix 和 Windows，一個物件可以出現在 *object_list* 中，如果它是"

#: ../../library/multiprocessing.rst:2526
#, fuzzy
msgid "a readable :class:`~multiprocessing.connection.Connection` object;"
msgstr "一個可讀的 :class:`~multiprocessing.connection.Connection` 物件；"

#: ../../library/multiprocessing.rst:2527
#, fuzzy
msgid "a connected and readable :class:`socket.socket` object; or"
msgstr "一個連接且可讀的 :class:`socket.socket` 物件；或者"

#: ../../library/multiprocessing.rst:2528
#, fuzzy
msgid ""
"the :attr:`~multiprocessing.Process.sentinel` attribute of a :class:"
"`~multiprocessing.Process` object."
msgstr ""
":class:`~multiprocessing.Process` 物件的 :attr:`~multiprocessing.Process."
"sentinel` 屬性。"

#: ../../library/multiprocessing.rst:2531
#, fuzzy
msgid ""
"A connection or socket object is ready when there is data available to be "
"read from it, or the other end has been closed."
msgstr "當有資料可供讀取或另一端已關閉時，連接或 socket 物件就緒。"

#: ../../library/multiprocessing.rst:2534
#, fuzzy
msgid ""
"**Unix**: ``wait(object_list, timeout)`` almost equivalent ``select."
"select(object_list, [], [], timeout)``.  The difference is that, if :func:"
"`select.select` is interrupted by a signal, it can raise :exc:`OSError` with "
"an error number of ``EINTR``, whereas :func:`wait` will not."
msgstr ""
"**Unix**：``wait(object_list, timeout)`` 幾乎等價於 ``select.select("
"object_list, [], [], timeout)``。不同之處在於，如果 :func:`select.select` "
"被信號中斷，它可以引發 :exc:`OSError` 錯誤號為 ``EINTR``，而 :func:`wait` "
"則不會。"

#: ../../library/multiprocessing.rst:2540
#, fuzzy
msgid ""
"**Windows**: An item in *object_list* must either be an integer handle which "
"is waitable (according to the definition used by the documentation of the "
"Win32 function ``WaitForMultipleObjects()``) or it can be an object with a :"
"meth:`fileno` method which returns a socket handle or pipe handle.  (Note "
"that pipe handles and socket handles are **not** waitable handles.)"
msgstr ""
"**Windows**：*object_list* 中的項目必須是可等待的整數句柄（根據 Win32 函式 "
"``WaitForMultipleObjects()`` 的文檔使用的定義）或者它可以是具有 :meth:`fileno`"
" 方法回傳 socket 句柄或管道句柄。 "
"（請注意，管道句柄和 socket 句柄**不是**可等待的句柄。）"

#: ../../library/multiprocessing.rst:2550
#, fuzzy
msgid "**Examples**"
msgstr "**例子**"

#: ../../library/multiprocessing.rst:2552
#, fuzzy
msgid ""
"The following server code creates a listener which uses ``'secret "
"password'`` as an authentication key.  It then waits for a connection and "
"sends some data to the client::"
msgstr "以下伺服器程式碼建立一個偵聽器，它使用“秘密密碼”作為身份驗證密鑰。然後它等待"
"連接並向客戶端發送一些資料::"

#: ../../library/multiprocessing.rst:2571
#, fuzzy
msgid ""
"The following code connects to the server and receives some data from the "
"server::"
msgstr "以下程式碼連接到伺服器並從伺服器接收一些資料："

#: ../../library/multiprocessing.rst:2588
#, fuzzy
msgid ""
"The following code uses :func:`~multiprocessing.connection.wait` to wait for "
"messages from multiple processes at once::"
msgstr "以下程式碼使用 :func:`~multiprocessing.connection.wait` "
"一次等待來自多個行程的消息::"

#: ../../library/multiprocessing.rst:2627
#, fuzzy
msgid "Address Formats"
msgstr "地址格式"

#: ../../library/multiprocessing.rst:2629
#, fuzzy
msgid ""
"An ``'AF_INET'`` address is a tuple of the form ``(hostname, port)`` where "
"*hostname* is a string and *port* is an integer."
msgstr ""
"``'AF_INET'`` 地址是形式為 ``(hostname, port)`` 的元組，其中 *hostname* "
"是一個字串，*port* 是一個整數。"

#: ../../library/multiprocessing.rst:2632
#, fuzzy
msgid ""
"An ``'AF_UNIX'`` address is a string representing a filename on the "
"filesystem."
msgstr "``'AF_UNIX'`` 地址是代表文件系統上文件名的字串。"

#: ../../library/multiprocessing.rst:2635
#, fuzzy
msgid ""
"An ``'AF_PIPE'`` address is a string of the form :samp:`r'\\\\\\\\\\\\.\\"
"\\pipe\\\\\\\\{PipeName}'`.  To use :func:`Client` to connect to a named "
"pipe on a remote computer called *ServerName* one should use an address of "
"the form :samp:`r'\\\\\\\\\\\\\\\\{ServerName}\\\\pipe\\\\\\\\{PipeName}'` "
"instead."
msgstr ""
"``'AF_PIPE'`` 地址是以下形式的字串 :samp:`r'\\\\\\\\\\\\.\\\\pipe\\\\\\\\"
"{PipeName}'`。要使用 :func:`Client` 連接到名為 *ServerName* "
"的遠程計算機上的命名管道，應該使用以下形式的地址 :samp:`r'\\\\\\\\\\\\\\\\"
"{ServerName}\\\\pipe \\\\\\\\{PipeName}'` 代替。"

#: ../../library/multiprocessing.rst:2640
#, fuzzy
msgid ""
"Note that any string beginning with two backslashes is assumed by default to "
"be an ``'AF_PIPE'`` address rather than an ``'AF_UNIX'`` address."
msgstr "請注意，任何以兩個反斜杠開頭的字串在預設情況下都被假定為“AF_PIPE”地址而不是“A"
"F_UNIX”地址。"

#: ../../library/multiprocessing.rst:2647
#, fuzzy
msgid "Authentication keys"
msgstr "身份驗證密鑰"

#: ../../library/multiprocessing.rst:2649
#, fuzzy
msgid ""
"When one uses :meth:`Connection.recv <Connection.recv>`, the data received "
"is automatically unpickled. Unfortunately unpickling data from an untrusted "
"source is a security risk. Therefore :class:`Listener` and :func:`Client` "
"use the :mod:`hmac` module to provide digest authentication."
msgstr ""
"當使用 :meth:`Connection.recv <Connection.recv>` 時，接收到的資料會自動解封。"
"不幸的是，從不受信任的來源中提取資料存在安全風險。因此 :class:`Listener` 和 "
":func:`Client` 使用 :mod:`hmac` 模組提供摘要認證。"

#: ../../library/multiprocessing.rst:2655
#, fuzzy
msgid ""
"An authentication key is a byte string which can be thought of as a "
"password: once a connection is established both ends will demand proof that "
"the other knows the authentication key.  (Demonstrating that both ends are "
"using the same key does **not** involve sending the key over the connection.)"
msgstr ""
"身份驗證密鑰是一個位元組串，可以將其視為密碼：一旦建立連接，兩端都將要求證明"
"對方知道身份驗證密鑰。 "
"（證明兩端都使用相同的密鑰不**不**涉及通過連接發送密鑰。）"

#: ../../library/multiprocessing.rst:2661
#, fuzzy
msgid ""
"If authentication is requested but no authentication key is specified then "
"the return value of ``current_process().authkey`` is used (see :class:"
"`~multiprocessing.Process`).  This value will be automatically inherited by "
"any :class:`~multiprocessing.Process` object that the current process "
"creates. This means that (by default) all processes of a multi-process "
"program will share a single authentication key which can be used when "
"setting up connections between themselves."
msgstr ""
"如果請求身份驗證但未指定身份驗證密鑰，則使用 ``current_process().authkey`` "
"的回傳值（參見 :class:`~multiprocessing.Process`）。該值將被當前行程建立的任何 "
":class:`~multiprocessing.Process` 物件自動繼承。這意味著（預設情況下）多行程"
"程式的所有行程將共享一個身份驗證密鑰，可以在它們之間建立連接時使用。"

#: ../../library/multiprocessing.rst:2669
#, fuzzy
msgid ""
"Suitable authentication keys can also be generated by using :func:`os."
"urandom`."
msgstr "也可以使用 os.urandom 生成合適的身份驗證密鑰。"

#: ../../library/multiprocessing.rst:2673
#, fuzzy
msgid "Logging"
msgstr "記錄"

#: ../../library/multiprocessing.rst:2675
#, fuzzy
msgid ""
"Some support for logging is available.  Note, however, that the :mod:"
"`logging` package does not use process shared locks so it is possible "
"(depending on the handler type) for messages from different processes to get "
"mixed up."
msgstr ""
"一些對日誌記錄的支援是可用的。但是請注意，:mod:`logging` "
"包不使用行程共享鎖，因此（取決於處理程式型別）來自不同行程的消息可能會混淆。"

#: ../../library/multiprocessing.rst:2682
#, fuzzy
msgid ""
"Returns the logger used by :mod:`multiprocessing`.  If necessary, a new one "
"will be created."
msgstr "回傳 :mod:`multiprocessing` 使用的記錄器。如有必要，將建立一個新的。"

#: ../../library/multiprocessing.rst:2685
#, fuzzy
msgid ""
"When first created the logger has level :data:`logging.NOTSET` and no "
"default handler. Messages sent to this logger will not by default propagate "
"to the root logger."
msgstr ""
"首次建立時，記錄器具有級別 :data:`logging.NOTSET` "
"並且沒有預設處理程式。預設情況下，發送到此記錄器的消息不會傳播到根記錄器。"

#: ../../library/multiprocessing.rst:2689
#, fuzzy
msgid ""
"Note that on Windows child processes will only inherit the level of the "
"parent process's logger -- any other customization of the logger will not be "
"inherited."
msgstr "請注意，在 Windows "
"上，子行程只會繼承父行程記錄器的級別——記錄器的任何其他自定義都不會被繼承。"

#: ../../library/multiprocessing.rst:2696
#, fuzzy
msgid ""
"This function performs a call to :func:`get_logger` but in addition to "
"returning the logger created by get_logger, it adds a handler which sends "
"output to :data:`sys.stderr` using format ``'[%(levelname)s/%(processName)s] "
"%(message)s'``. You can modify ``levelname`` of the logger by passing a "
"``level`` argument."
msgstr ""
"此函式執行對 get_logger 的呼叫，但除了回傳由 get_logger "
"建立的記錄器外，它還新增了一個處理程式，該處理程式使用格式 ``'[%(levelname)s "
"將輸出發送到 :data:`sys.stderr` /%(processName)s] %(message)s'``."
"您可以通過傳遞 ``level``參數來修改記錄器的 ``levelname`` 。"

#: ../../library/multiprocessing.rst:2702
#, fuzzy
msgid "Below is an example session with logging turned on::"
msgstr "下面是一個啟用了日誌記錄的示例會話："

#: ../../library/multiprocessing.rst:2717
#, fuzzy
msgid "For a full table of logging levels, see the :mod:`logging` module."
msgstr "有關日誌記錄級別的完整表格，請參閱 :mod:`logging` 模組。"

#: ../../library/multiprocessing.rst:2721
#, fuzzy
msgid "The :mod:`multiprocessing.dummy` module"
msgstr ":mod:`multiprocessing.dummy` 模組"

#: ../../library/multiprocessing.rst:2726
#, fuzzy
msgid ""
":mod:`multiprocessing.dummy` replicates the API of :mod:`multiprocessing` "
"but is no more than a wrapper around the :mod:`threading` module."
msgstr ""
":mod:`multiprocessing.dummy` 複製了 :mod:`multiprocessing` 的 API，"
"但只不過是 :mod:`threading` 模組的包裝器。"

#: ../../library/multiprocessing.rst:2731
#, fuzzy
msgid ""
"In particular, the ``Pool`` function provided by :mod:`multiprocessing."
"dummy` returns an instance of :class:`ThreadPool`, which is a subclass of :"
"class:`Pool` that supports all the same method calls but uses a pool of "
"worker threads rather than worker processes."
msgstr ""
"特別是，由 :mod:`multiprocessing.dummy` 提供的 ``Pool`` 函式回傳 "
":class:`ThreadPool` 的實例，它是 :class:`Pool` "
"的子類別，支援所有相同的方法呼叫，但使用工作執行緒池而不是工作行程。"

#: ../../library/multiprocessing.rst:2739
#, fuzzy
msgid ""
"A thread pool object which controls a pool of worker threads to which jobs "
"can be submitted.  :class:`ThreadPool` instances are fully interface "
"compatible with :class:`Pool` instances, and their resources must also be "
"properly managed, either by using the pool as a context manager or by "
"calling :meth:`~multiprocessing.pool.Pool.close` and :meth:`~multiprocessing."
"pool.Pool.terminate` manually."
msgstr ""
"一個執行緒池物件，它控制可以提交作業的工作執行緒池。 :class:`ThreadPool` "
"實例與 :class:`Pool` 實例的介面完全相容，它們的資源也必須得到適當的管理，可以"
"通過使用池作為上下文管理器或呼叫 :meth:`~multiprocessing.pool。 Pool.close` "
"和 :meth:`~multiprocessing.pool.Pool.terminate` 手動。"

#: ../../library/multiprocessing.rst:2746
#, fuzzy
msgid ""
"*processes* is the number of worker threads to use.  If *processes* is "
"``None`` then the number returned by :func:`os.cpu_count` is used."
msgstr "*processes* 是要使用的工作執行緒數。如果 *processes* 為 ``None``，則使用 "
"os.cpu_count 回傳的數字。"

#: ../../library/multiprocessing.rst:2752
#, fuzzy
msgid ""
"Unlike :class:`Pool`, *maxtasksperchild* and *context* cannot be provided."
msgstr "與 :class:`Pool` 不同，無法提供 *maxtasksperchild* 和 *context*。"

#: ../../library/multiprocessing.rst:2756
#, fuzzy
msgid ""
"A :class:`ThreadPool` shares the same interface as :class:`Pool`, which is "
"designed around a pool of processes and predates the introduction of the :"
"class:`concurrent.futures` module.  As such, it inherits some operations "
"that don't make sense for a pool backed by threads, and it has its own type "
"for representing the status of asynchronous jobs, :class:`AsyncResult`, that "
"is not understood by any other libraries."
msgstr ""
":class:`ThreadPool` 與 :class:`Pool` 共享相同的介面，它是圍繞行程池設計的，"
"早於 :class:`concurrent.futures` 模組的引入。因此，它繼承了一些對於執行緒支援"
"的池沒有意義的操作，並且它有自己的型別來表示非同步作業的狀態，AsyncResult，這"
"是任何其他庫都無法理解的。"

#: ../../library/multiprocessing.rst:2763
#, fuzzy
msgid ""
"Users should generally prefer to use :class:`concurrent.futures."
"ThreadPoolExecutor`, which has a simpler interface that was designed around "
"threads from the start, and which returns :class:`concurrent.futures.Future` "
"instances that are compatible with many other libraries, including :mod:"
"`asyncio`."
msgstr ""
"使用者通常應該更喜歡使用 :class:`concurrent.futures.ThreadPoolExecutor`，它有"
"一個更簡單的介面，從一開始就圍繞執行緒設計，並回傳與許多相容的 :class:`concurr"
"ent.futures.Future` 實例其他庫，包括 :mod:`asyncio`。"

#: ../../library/multiprocessing.rst:2773
#, fuzzy
msgid "Programming guidelines"
msgstr "編程指南"

#: ../../library/multiprocessing.rst:2775
#, fuzzy
msgid ""
"There are certain guidelines and idioms which should be adhered to when "
"using :mod:`multiprocessing`."
msgstr "使用 :mod:`multiprocessing` 時應遵守某些準則和習慣用法。"

#: ../../library/multiprocessing.rst:2780
#, fuzzy
msgid "All start methods"
msgstr "所有啟動方式"

#: ../../library/multiprocessing.rst:2782
#, fuzzy
msgid "The following applies to all start methods."
msgstr "以下適用於所有啟動方法。"

#: ../../library/multiprocessing.rst:2784
#, fuzzy
msgid "Avoid shared state"
msgstr "避免共享狀態"

#: ../../library/multiprocessing.rst:2786
#, fuzzy
msgid ""
"As far as possible one should try to avoid shifting large amounts of data "
"between processes."
msgstr "應盡可能避免在行程之間轉移大量資料。"

#: ../../library/multiprocessing.rst:2789
#, fuzzy
msgid ""
"It is probably best to stick to using queues or pipes for communication "
"between processes rather than using the lower level synchronization "
"primitives."
msgstr "最好堅持使用隊列或管道在行程之間進行通信，而不是使用較低階別的同步原語。"

#: ../../library/multiprocessing.rst:2793
#, fuzzy
msgid "Picklability"
msgstr "可醃製性"

#: ../../library/multiprocessing.rst:2795
#, fuzzy
msgid "Ensure that the arguments to the methods of proxies are picklable."
msgstr "確保代理方法的參數是可挑選的。"

#: ../../library/multiprocessing.rst:2797
#, fuzzy
msgid "Thread safety of proxies"
msgstr "代理的執行緒安全"

#: ../../library/multiprocessing.rst:2799
#, fuzzy
msgid ""
"Do not use a proxy object from more than one thread unless you protect it "
"with a lock."
msgstr "不要使用來自多個執行緒的代理物件，除非你用鎖保護它。"

#: ../../library/multiprocessing.rst:2802
#, fuzzy
msgid ""
"(There is never a problem with different processes using the *same* proxy.)"
msgstr "（使用*相同*代理的不同行程永遠不會有問題。）"

#: ../../library/multiprocessing.rst:2804
#, fuzzy
msgid "Joining zombie processes"
msgstr "加入殭屍行程"

#: ../../library/multiprocessing.rst:2806
#, fuzzy
msgid ""
"On Unix when a process finishes but has not been joined it becomes a zombie. "
"There should never be very many because each time a new process starts (or :"
"func:`~multiprocessing.active_children` is called) all completed processes "
"which have not yet been joined will be joined.  Also calling a finished "
"process's :meth:`Process.is_alive <multiprocessing.Process.is_alive>` will "
"join the process.  Even so it is probably good practice to explicitly join "
"all the processes that you start."
msgstr ""
"在 Unix 上，當行程完成但尚未加入時，它會變成殭屍。永遠不應該有很多，因為每次"
"啟動新行程（或呼叫 :func:`~multiprocessing."
"active_children`）時，所有尚未加入的已完成行程都將加入。同樣呼叫已完成行程的 "
"Process.is_alive <multiprocessing.Process.is_alive> "
"將加入行程。即便如此，顯式加入您啟動的所有行程可能是一種很好的做法。"

#: ../../library/multiprocessing.rst:2814
#, fuzzy
msgid "Better to inherit than pickle/unpickle"
msgstr "比 pickle/unpickle 更好地繼承"

#: ../../library/multiprocessing.rst:2816
#, fuzzy
msgid ""
"When using the *spawn* or *forkserver* start methods many types from :mod:"
"`multiprocessing` need to be picklable so that child processes can use "
"them.  However, one should generally avoid sending shared objects to other "
"processes using pipes or queues. Instead you should arrange the program so "
"that a process which needs access to a shared resource created elsewhere can "
"inherit it from an ancestor process."
msgstr ""
"當使用 *spawn* 或 *forkserver* 啟動方法時，來自 :mod:`multiprocessing` 的許多"
"型別需要被挑選，以便子行程可以使用它們。但是，通常應該避免使用管道或隊列將共"
"享物件發送到其他行程。相反，您應該安排程式，以便需要訪問在別處建立的共享資源"
"的行程可以從祖先行程繼承它。"

#: ../../library/multiprocessing.rst:2824
#, fuzzy
msgid "Avoid terminating processes"
msgstr "避免終止行程"

#: ../../library/multiprocessing.rst:2826
#, fuzzy
msgid ""
"Using the :meth:`Process.terminate <multiprocessing.Process.terminate>` "
"method to stop a process is liable to cause any shared resources (such as "
"locks, semaphores, pipes and queues) currently being used by the process to "
"become broken or unavailable to other processes."
msgstr ""
"使用 :meth:`Process.terminate <multiprocessing.Process.terminate>` 方法停止行"
"程可能會導致行程當前使用的任何共享資源（如鎖、信號量、管道和隊列）被破壞或對"
"其他行程不可用。"

#: ../../library/multiprocessing.rst:2832
#, fuzzy
msgid ""
"Therefore it is probably best to only consider using :meth:`Process."
"terminate <multiprocessing.Process.terminate>` on processes which never use "
"any shared resources."
msgstr ""
"因此，最好只考慮在從不使用任何共享資源的行程上使用 Process.terminate "
"<multiprocessing.Process.terminate>。"

#: ../../library/multiprocessing.rst:2836
#, fuzzy
msgid "Joining processes that use queues"
msgstr "加入使用隊列的行程"

#: ../../library/multiprocessing.rst:2838
#, fuzzy
msgid ""
"Bear in mind that a process that has put items in a queue will wait before "
"terminating until all the buffered items are fed by the \"feeder\" thread to "
"the underlying pipe.  (The child process can call the :meth:`Queue."
"cancel_join_thread <multiprocessing.Queue.cancel_join_thread>` method of the "
"queue to avoid this behaviour.)"
msgstr ""
"請記住，將項目放入隊列的行程將在終止之前等待，直到所有緩衝的項目都被“供給器”"
"執行緒供給到底層管道。 （子行程可以呼叫隊列的 Queue.cancel_join_thread "
"<multiprocessing.Queue.cancel_join_thread>` 方法來避免這種行為。）"

#: ../../library/multiprocessing.rst:2844
#, fuzzy
msgid ""
"This means that whenever you use a queue you need to make sure that all "
"items which have been put on the queue will eventually be removed before the "
"process is joined.  Otherwise you cannot be sure that processes which have "
"put items on the queue will terminate.  Remember also that non-daemonic "
"processes will be joined automatically."
msgstr ""
"這意味著無論何時使用隊列，您都需要確保在加入行程之前最終刪除所有已放入隊列的"
"項目。否則，您無法確定將項目放入隊列的行程是否會終止。還請記住，非守護行程將"
"自動加入。"

#: ../../library/multiprocessing.rst:2850
#, fuzzy
msgid "An example which will deadlock is the following::"
msgstr "一個會死鎖的例子如下："

#: ../../library/multiprocessing.rst:2864
#, fuzzy
msgid ""
"A fix here would be to swap the last two lines (or simply remove the ``p."
"join()`` line)."
msgstr "此處的解決方法是交換最後兩行（或簡單地刪除 ``p.join()`` 行）。"

#: ../../library/multiprocessing.rst:2867
#, fuzzy
msgid "Explicitly pass resources to child processes"
msgstr "顯式地將資源傳遞給子行程"

#: ../../library/multiprocessing.rst:2869
#, fuzzy
msgid ""
"On Unix using the *fork* start method, a child process can make use of a "
"shared resource created in a parent process using a global resource.  "
"However, it is better to pass the object as an argument to the constructor "
"for the child process."
msgstr ""
"在使用 *fork* 啟動方法的 Unix 上，子行程可以使用在使用全局資源的父行程中建立"
"的共享資源。但是，最好將該對像作為參數傳遞給子行程的構造函式。"

#: ../../library/multiprocessing.rst:2874
#, fuzzy
msgid ""
"Apart from making the code (potentially) compatible with Windows and the "
"other start methods this also ensures that as long as the child process is "
"still alive the object will not be garbage collected in the parent process.  "
"This might be important if some resource is freed when the object is garbage "
"collected in the parent process."
msgstr ""
"除了使程式碼（可能）與 Windows 和其他啟動方法相容之外，這還確保只要子行程仍然"
"存在，物件就不會在父行程中被垃圾回收。如果在父行程中對物件進行垃圾回收時釋放"
"了某些資源，這可能很重要。"

#: ../../library/multiprocessing.rst:2881
#, fuzzy
msgid "So for instance ::"
msgstr "所以例如::"

#: ../../library/multiprocessing.rst:2893
#, fuzzy
msgid "should be rewritten as ::"
msgstr "應該重寫為 ::"

#: ../../library/multiprocessing.rst:2905
#, fuzzy
msgid "Beware of replacing :data:`sys.stdin` with a \"file like object\""
msgstr "謹防用“類似物件的文件”替換 :data:`sys.stdin`"

#: ../../library/multiprocessing.rst:2907
#, fuzzy
msgid ":mod:`multiprocessing` originally unconditionally called::"
msgstr ":mod:`multiprocessing` 最初無條件呼叫::"

#: ../../library/multiprocessing.rst:2911
#, fuzzy
msgid ""
"in the :meth:`multiprocessing.Process._bootstrap` method --- this resulted "
"in issues with processes-in-processes. This has been changed to::"
msgstr "在 :meth:`multiprocessing.Process._bootstrap` "
"方法中——這導致了行程中行程的問題。這已更改為::"

#: ../../library/multiprocessing.rst:2917
#, fuzzy
msgid ""
"Which solves the fundamental issue of processes colliding with each other "
"resulting in a bad file descriptor error, but introduces a potential danger "
"to applications which replace :func:`sys.stdin` with a \"file-like object\" "
"with output buffering.  This danger is that if multiple processes call :meth:"
"`~io.IOBase.close()` on this file-like object, it could result in the same "
"data being flushed to the object multiple times, resulting in corruption."
msgstr ""
"這解決了行程相互衝突導致錯誤文件描述器錯誤的基本問題，但給應用程式帶來了潛在"
"危險，這些應用程式將 :func:`sys.stdin` "
"替換為具有輸出緩衝的“類文件物件”。這種危險在於，"
"如果多個行程在此類文件對像上呼叫 :meth:`~io.IOBase."
"close()`，可能會導致相同的資料多次刷新到物件，從而導致損壞。"

#: ../../library/multiprocessing.rst:2924
#, fuzzy
msgid ""
"If you write a file-like object and implement your own caching, you can make "
"it fork-safe by storing the pid whenever you append to the cache, and "
"discarding the cache when the pid changes. For example::"
msgstr ""
"如果您編寫一個類似文件的物件並實作自己的快取，"
"則可以通過在每次附加到快取時儲存 pid 並在 pid "
"更改時丟棄快取來使其成為分叉安全的。例如：："

#: ../../library/multiprocessing.rst:2936
#, fuzzy
msgid ""
"For more information, see :issue:`5155`, :issue:`5313` and :issue:`5331`"
msgstr "有關詳細資訊，請參閱 :issue:`5155`、 :issue:`5313` 和 :issue:`5331`"

#: ../../library/multiprocessing.rst:2939
#, fuzzy
msgid "The *spawn* and *forkserver* start methods"
msgstr "*spawn* 和 *forkserver* 啟動方法"

#: ../../library/multiprocessing.rst:2941
#, fuzzy
msgid ""
"There are a few extra restriction which don't apply to the *fork* start "
"method."
msgstr "有一些額外的限制不適用於 *fork* 啟動方法。"

#: ../../library/multiprocessing.rst:2944
#, fuzzy
msgid "More picklability"
msgstr "更易醃製"

#: ../../library/multiprocessing.rst:2946
#, fuzzy
msgid ""
"Ensure that all arguments to :meth:`Process.__init__` are picklable. Also, "
"if you subclass :class:`~multiprocessing.Process` then make sure that "
"instances will be picklable when the :meth:`Process.start <multiprocessing."
"Process.start>` method is called."
msgstr ""
"確保 :meth:`Process.__init__` 的所有參數都是可挑選的。此外，如果您將 "
":class:`~multiprocessing.Process` 子類別化，那麼請確保在呼叫 :meth:`"
"Process.start <multiprocessing.Process.start>` 方法時實例是可挑選的。"

#: ../../library/multiprocessing.rst:2951
#, fuzzy
msgid "Global variables"
msgstr "全局變數"

#: ../../library/multiprocessing.rst:2953
#, fuzzy
msgid ""
"Bear in mind that if code run in a child process tries to access a global "
"variable, then the value it sees (if any) may not be the same as the value "
"in the parent process at the time that :meth:`Process.start <multiprocessing."
"Process.start>` was called."
msgstr ""
"請記住，如果在子行程中運行的程式碼試圖訪問全局變數，那麼它看到的值（如果有的"
"話）可能與 :meth:`Process.start 時父行程中的值不同<multiprocessing.Process."
"start>` 被呼叫。"

#: ../../library/multiprocessing.rst:2958
#, fuzzy
msgid ""
"However, global variables which are just module level constants cause no "
"problems."
msgstr "但是，只是模組級常數的全局變數不會造成問題。"

#: ../../library/multiprocessing.rst:2963
#, fuzzy
msgid "Safe importing of main module"
msgstr "主模組的安全導入"

#: ../../library/multiprocessing.rst:2965
#, fuzzy
msgid ""
"Make sure that the main module can be safely imported by a new Python "
"interpreter without causing unintended side effects (such a starting a new "
"process)."
msgstr "確保新的 Python "
"直譯器可以安全地導入主模組，而不會導致意外的副作用（例如啟動新行程）。"

#: ../../library/multiprocessing.rst:2969
#, fuzzy
msgid ""
"For example, using the *spawn* or *forkserver* start method running the "
"following module would fail with a :exc:`RuntimeError`::"
msgstr "例如，使用 *spawn* 或 *forkserver* 啟動方法運行以下模組將失敗並出現 "
":exc:`RuntimeError`::"

#: ../../library/multiprocessing.rst:2981
#, fuzzy
msgid ""
"Instead one should protect the \"entry point\" of the program by using ``if "
"__name__ == '__main__':`` as follows::"
msgstr "相反，應該通過使用 ``if __name__ == '__main__':`` "
"來保護程式的“入口點”，如下所示："

#: ../../library/multiprocessing.rst:2995
#, fuzzy
msgid ""
"(The ``freeze_support()`` line can be omitted if the program will be run "
"normally instead of frozen.)"
msgstr "（如果程式將正常運行而不是凍結，則可以省略 ``freeze_support()`` 行。）"

#: ../../library/multiprocessing.rst:2998
#, fuzzy
msgid ""
"This allows the newly spawned Python interpreter to safely import the module "
"and then run the module's ``foo()`` function."
msgstr "這允許新生成的 Python 直譯器安全地導入模組，然後運行模組的“foo()”函式。"

#: ../../library/multiprocessing.rst:3001
#, fuzzy
msgid ""
"Similar restrictions apply if a pool or manager is created in the main "
"module."
msgstr "如果在主模組中建立池或管理器，則適用類似的限制。"

#: ../../library/multiprocessing.rst:3008
msgid "Examples"
msgstr "範例"

#: ../../library/multiprocessing.rst:3010
#, fuzzy
msgid "Demonstration of how to create and use customized managers and proxies:"
msgstr "演示如何建立和使用自定義管理器和代理："

#: ../../library/multiprocessing.rst:3016
#, fuzzy
msgid "Using :class:`~multiprocessing.pool.Pool`:"
msgstr "使用 :class:`~multiprocessing.pool.Pool`:"

#: ../../library/multiprocessing.rst:3022
#, fuzzy
msgid ""
"An example showing how to use queues to feed tasks to a collection of worker "
"processes and collect the results:"
msgstr "顯示如何使用隊列將任務提供給工作行程集合併收集結果的示例："
