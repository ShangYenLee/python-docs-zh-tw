# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-13 00:17+0000\n"
"PO-Revision-Date: 2022-10-16 04:57+0800\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.1.1\n"

#: ../../library/asyncore.rst:2
msgid ":mod:`asyncore` --- Asynchronous socket handler"
msgstr ":mod:`asyncore` --- 非同步 socket 處理函式"

#: ../../library/asyncore.rst:14
msgid "**Source code:** :source:`Lib/asyncore.py`"
msgstr "**原始碼：**\\ :source:`Lib/asyncore.py`"

#: ../../library/asyncore.rst:20
msgid ""
"The :mod:`asyncore` module is deprecated (see :pep:`PEP 594 <594#asyncore>` "
"for details). Please use :mod:`asyncio` instead."
msgstr ""
":mod:`asyncore` 已被棄用（詳情請見 :pep:`PEP 594 <594#asyncore>`\\ ）。請改"
"用 :mod:`asyncio`\\ 。"

#: ../../library/asyncore.rst:25
#, fuzzy
msgid ""
"This module exists for backwards compatibility only.  For new code we "
"recommend using :mod:`asyncio`."
msgstr "該模組的存在只是為了向後相容。對於新程式碼，我們建議使用 :mod:`asyncio`。"

#: ../../library/asyncore.rst:28
#, fuzzy
msgid ""
"This module provides the basic infrastructure for writing asynchronous  "
"socket service clients and servers."
msgstr "該模組為編寫非同步 socket 服務客戶端和伺服器提供了基本的基礎結構。"

#: ../../includes/wasm-notavail.rst:3
#, fuzzy
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ":ref:`Availability <availability>`：不是 Emscripten，不是 WASI。"

#: ../../includes/wasm-notavail.rst:5
#, fuzzy
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"此模組在 WebAssembly 平台 ``wasm32-emscripten`` 和 ``wasm32-wasi`` 上不起作用或不可用"
"。有關更多資訊，請參閱 :ref:`wasm-availability`。"

#: ../../library/asyncore.rst:33
#, fuzzy
msgid ""
"There are only two ways to have a program on a single processor do  \"more "
"than one thing at a time.\" Multi-threaded programming is the  simplest and "
"most popular way to do it, but there is another very different technique, "
"that lets you have nearly all the advantages of  multi-threading, without "
"actually using multiple threads.  It's really  only practical if your "
"program is largely I/O bound.  If your program is processor bound, then pre-"
"emptive scheduled threads are probably what you really need.  Network "
"servers are rarely processor bound, however."
msgstr ""
"只有兩種方法可以讓單個處理器上的程式“一次做不止一件事”。多執行緒編程是最簡單"
"和最流行的方法，但還有另一種非常不同的技術，它可以讓您擁有多執行緒的幾乎所有"
"優點，而無需實際使用多執行緒。只有當您的程式主要受 I/O 限制時，它才真正實用。"
"如果您的程式受處理器限制，那麼搶占式調度執行緒可能是您真正需要的。然而，網絡"
"伺服器很少受處理器限制。"

#: ../../library/asyncore.rst:42
#, fuzzy
msgid ""
"If your operating system supports the :c:func:`select` system call in its I/"
"O library (and nearly all do), then you can use it to juggle multiple "
"communication channels at once; doing other work while your I/O is taking "
"place in the \"background.\"  Although this strategy can seem strange and "
"complex, especially at first, it is in many ways easier to understand and "
"control than multi-threaded programming.  The :mod:`asyncore` module solves "
"many of the difficult problems for you, making the task of building "
"sophisticated high-performance network servers and clients a snap.  For "
"\"conversational\" applications and protocols the companion :mod:`asynchat` "
"module is invaluable."
msgstr ""
"如果您的操作系統在其 I/O 庫中支援 :c:func:`select` "
"系統呼叫（幾乎所有支援），那麼您可以使用它同時處理多個通信通道；當 I/O 在“後"
"台”進行時做其他工作。儘管這種策略看起來很奇怪而且很複雜，尤其是剛開始時，但它"
"在很多方面都比多執行緒編程更容易理解和控制。 :mod:`asyncore` 模組為您解決了許"
"多難題，使構建複雜的高性能網絡伺服器和客戶端的任務變得輕而易舉。對於“對話式”"
"應用程式和協定，配套的 :mod:`asynchat` 模組是無價的。"

#: ../../library/asyncore.rst:53
#, fuzzy
msgid ""
"The basic idea behind both modules is to create one or more network "
"*channels*, instances of class :class:`asyncore.dispatcher` and :class:"
"`asynchat.async_chat`.  Creating the channels adds them to a global map, "
"used by the :func:`loop` function if you do not provide it with your own "
"*map*."
msgstr ""
"這兩個模組背後的基本思想是建立一個或多個網絡*通道*，類 :class:`asyncore."
"dispatcher` 和 :class:`asynchat.async_chat` "
"的實例。建立通道會將它們新增到全局地圖中，如果您沒有為它提供自己的*地圖*，"
"則由 :func:`loop` 函式使用。"

#: ../../library/asyncore.rst:59
#, fuzzy
msgid ""
"Once the initial channel(s) is(are) created, calling the :func:`loop` "
"function activates channel service, which continues until the last channel "
"(including any that have been added to the map during asynchronous service) "
"is closed."
msgstr "一旦建立了初始通道，呼叫 :func:`loop` 函式將激活通道服務，直到最後一個通道（"
"包括在非同步服務期間新增到地圖的任何通道）關閉。"

#: ../../library/asyncore.rst:66
#, fuzzy
msgid ""
"Enter a polling loop that terminates after count passes or all open channels "
"have been closed.  All arguments are optional.  The *count* parameter "
"defaults to ``None``, resulting in the loop terminating only when all "
"channels have been closed.  The *timeout* argument sets the timeout "
"parameter for the appropriate :func:`~select.select` or :func:`~select.poll` "
"call, measured in seconds; the default is 30 seconds.  The *use_poll* "
"parameter, if true, indicates that :func:`~select.poll` should be used in "
"preference to :func:`~select.select` (the default is ``False``)."
msgstr ""
"輸入一個輪詢循環，該循環在計數通過或所有打開的通道都已關閉後終止。所有參數都"
"是可選的。 *count* 參數預設為 ``None``，導致循環僅在所有通道都已關閉時終止。 "
"*timeout* 參數為適當的 :func:`~select.select` 或 :func:`~select.poll` "
"呼叫設定超時參數，以秒為單位；預設值為 30 秒。 *use_poll* 參數，如果為 true，"
"則表示應該優先使用 :func:`~select.poll` 而不是 :func:`~select.select` （"
"預設為 ``False``）。"

#: ../../library/asyncore.rst:75
#, fuzzy
msgid ""
"The *map* parameter is a dictionary whose items are the channels to watch. "
"As channels are closed they are deleted from their map.  If *map* is "
"omitted, a global map is used. Channels (instances of :class:`asyncore."
"dispatcher`, :class:`asynchat.async_chat` and subclasses thereof) can freely "
"be mixed in the map."
msgstr ""
"*map* 參數是一個字典，其項是要觀看的頻道。當通道關閉時，它們將從地圖中刪除。"
"如果省略 *map*，則使用全局映射。頻道（asyncore.dispatcher、"
"asynchat.async_chat 及其子類別的實例）可以在地圖中自由混合。"

#: ../../library/asyncore.rst:84
#, fuzzy
msgid ""
"The :class:`dispatcher` class is a thin wrapper around a low-level socket "
"object. To make it more useful, it has a few methods for event-handling "
"which are called from the asynchronous loop.   Otherwise, it can be treated "
"as a normal non-blocking socket object."
msgstr ""
":class:`dispatcher` 類是低階 socket 物件的薄包裝器。為了使它更有用，它有一些從"
"非同步循環呼叫的事件處理方法。否則，它可以被視為一個普通的非阻塞 socket 物件。"

#: ../../library/asyncore.rst:89
#, fuzzy
msgid ""
"The firing of low-level events at certain times or in certain connection "
"states tells the asynchronous loop that certain higher-level events have "
"taken place.  For example, if we have asked for a socket to connect to "
"another host, we know that the connection has been made when the socket "
"becomes writable for the first time (at this point you know that you may "
"write to it with the expectation of success).  The implied higher-level "
"events are:"
msgstr ""
"在特定時間或在特定連接狀態下觸發低階別事件會告訴非同步循環某些更高階別的事件"
"已經發生。例如，如果我們請求一個 socket 連接到另一台主機，當 socket 第一次變為可"
"寫時，我們知道連接已經建立（此時您知道您可以期望成功寫入它)."
"隱含的更高階別事件是："

#: ../../library/asyncore.rst:98
#, fuzzy
msgid "Event"
msgstr "事件"

#: ../../library/asyncore.rst:98
msgid "Description"
msgstr "描述"

#: ../../library/asyncore.rst:100
msgid "``handle_connect()``"
msgstr "``handle_connect()``"

#: ../../library/asyncore.rst:100
#, fuzzy
msgid "Implied by the first read or write event"
msgstr "由第一個讀或寫事件暗示"

#: ../../library/asyncore.rst:103
msgid "``handle_close()``"
msgstr "``handle_close()``"

#: ../../library/asyncore.rst:103
#, fuzzy
msgid "Implied by a read event with no data available"
msgstr "由沒有可用資料的讀取事件暗示"

#: ../../library/asyncore.rst:106
msgid "``handle_accepted()``"
msgstr "``handle_accepted()``"

#: ../../library/asyncore.rst:106
#, fuzzy
msgid "Implied by a read event on a listening socket"
msgstr "由偵聽 socket 上的讀取事件暗示"

#: ../../library/asyncore.rst:110
#, fuzzy
msgid ""
"During asynchronous processing, each mapped channel's :meth:`readable` and :"
"meth:`writable` methods are used to determine whether the channel's socket "
"should be added to the list of channels :c:func:`select`\\ ed or :c:func:"
"`poll`\\ ed for read and write events."
msgstr ""
"在非同步處理期間，每個映射通道的 :meth:`readable` 和 :meth:`writable` "
"方法用於確定是否應將通道的 socket 新增到通道列表中 :c:func:`select`\\ ed 或 :c "
":func:`poll`\\ 用於讀取和寫入事件。"

#: ../../library/asyncore.rst:115
#, fuzzy
msgid ""
"Thus, the set of channel events is larger than the basic socket events.  The "
"full set of methods that can be overridden in your subclass follows:"
msgstr "因此，通道事件集大於基本 socket 事件。可以在子類別中覆蓋的完整方法集如下："

#: ../../library/asyncore.rst:121
#, fuzzy
msgid ""
"Called when the asynchronous loop detects that a :meth:`read` call on the "
"channel's socket will succeed."
msgstr "當非同步循環檢測到通道 socket 上的 read 呼叫將成功時呼叫。"

#: ../../library/asyncore.rst:127
#, fuzzy
msgid ""
"Called when the asynchronous loop detects that a writable socket can be "
"written.  Often this method will implement the necessary buffering for "
"performance.  For example::"
msgstr "當非同步循環檢測到可以寫入可寫 socket 時呼叫。通常這種方法會實作必要的性能緩衝"
"。例如：："

#: ../../library/asyncore.rst:138
#, fuzzy
msgid ""
"Called when there is out of band (OOB) data for a socket connection.  This "
"will almost never happen, as OOB is tenuously supported and rarely used."
msgstr "當存在 socket 連接的帶外 (OOB) 資料時呼叫。這幾乎永遠不會發生，因為 OOB "
"很少得到支援並且很少使用。"

#: ../../library/asyncore.rst:144
#, fuzzy
msgid ""
"Called when the active opener's socket actually makes a connection.  Might "
"send a \"welcome\" banner, or initiate a protocol negotiation with the "
"remote endpoint, for example."
msgstr "當活動開啟者的 socket 實際建立連接時呼叫。例如，可能會發送“歡迎”橫幅，或啟動與"
"遠程端點的協定協商。"

#: ../../library/asyncore.rst:151
#, fuzzy
msgid "Called when the socket is closed."
msgstr "當 socket 關閉時呼叫。"

#: ../../library/asyncore.rst:156
#, fuzzy
msgid ""
"Called when an exception is raised and not otherwise handled.  The default "
"version prints a condensed traceback."
msgstr "在引發例外且未以其他方式處理時呼叫。預設版本印出一個壓縮回溯。"

#: ../../library/asyncore.rst:162
#, fuzzy
msgid ""
"Called on listening channels (passive openers) when a connection can be "
"established with a new remote endpoint that has issued a :meth:`connect` "
"call for the local endpoint. Deprecated in version 3.2; use :meth:"
"`handle_accepted` instead."
msgstr ""
"當可以與已為本地端點發出 connect "
"呼叫的新遠程端點建立連接時，在偵聽通道（被動打開器）上呼叫。在 3.2 版中棄用；"
"使用 :meth:`handle_accepted` 代替。"

#: ../../library/asyncore.rst:172
#, fuzzy
msgid ""
"Called on listening channels (passive openers) when a connection has been "
"established with a new remote endpoint that has issued a :meth:`connect` "
"call for the local endpoint.  *sock* is a *new* socket object usable to send "
"and receive data on the connection, and *addr* is the address bound to the "
"socket on the other end of the connection."
msgstr ""
"當與新的遠程端點建立連接時呼叫偵聽通道（被動打開器），"
"該遠程端點已為本地端點發出 :meth:`connect` 呼叫。 *sock* 是一個 *new* "
" socket 物件，可用於在連接上發送和接收資料，而 *addr* "
"是綁定到連接另一端 socket 的地址。"

#: ../../library/asyncore.rst:183
#, fuzzy
msgid ""
"Called each time around the asynchronous loop to determine whether a "
"channel's socket should be added to the list on which read events can "
"occur.  The default method simply returns ``True``, indicating that by "
"default, all channels will be interested in read events."
msgstr ""
"每次圍繞非同步循環呼叫以確定是否應將通道的 socket 新增到可以發生讀取事件的列表"
"中。預設方法只回傳 ``True``，表示預設情況下，所有通道都會對讀取事件感興趣。"

#: ../../library/asyncore.rst:191
#, fuzzy
msgid ""
"Called each time around the asynchronous loop to determine whether a "
"channel's socket should be added to the list on which write events can "
"occur.  The default method simply returns ``True``, indicating that by "
"default, all channels will be interested in write events."
msgstr ""
"每次圍繞非同步循環呼叫以確定是否應將通道的 socket 新增到可以發生寫入事件的列表"
"中。預設方法只回傳 ``True``，表示預設情況下，所有通道都會對寫入事件感興趣。"

#: ../../library/asyncore.rst:197
#, fuzzy
msgid ""
"In addition, each channel delegates or extends many of the socket methods. "
"Most of these are nearly identical to their socket partners."
msgstr "此外，每個通道都委託或擴充了許多 socket 方法。其中大部分與它們的 socket 夥伴幾乎"
"相同。"

#: ../../library/asyncore.rst:203
#, fuzzy
msgid ""
"This is identical to the creation of a normal socket, and will use the same "
"options for creation.  Refer to the :mod:`socket` documentation for "
"information on creating sockets."
msgstr "這與建立普通 socket 相同，並將使用相同的選項進行建立。有關建立 socket 的資訊，"
"請參閱 :mod:`socket` 文檔。"

#: ../../library/asyncore.rst:207
#, fuzzy
msgid "*family* and *type* arguments can be omitted."
msgstr "*family* 和 *type* 參數可以省略。"

#: ../../library/asyncore.rst:213
#, fuzzy
msgid ""
"As with the normal socket object, *address* is a tuple with the first "
"element the host to connect to, and the second the port number."
msgstr "與普通 socket 對像一樣，*address* "
"是一個元組，第一個元素是要連接的主機，第二個元素是端口號。"

#: ../../library/asyncore.rst:219
#, fuzzy
msgid "Send *data* to the remote end-point of the socket."
msgstr "將 *data* 發送到 socket 的遠程端點。"

#: ../../library/asyncore.rst:224
#, fuzzy
msgid ""
"Read at most *buffer_size* bytes from the socket's remote end-point.  An "
"empty bytes object implies that the channel has been closed from the other "
"end."
msgstr "從 socket 的遠程端點最多讀取 *buffer_size* "
"位元組。空位元組物件意味著通道已從另一端關閉。"

#: ../../library/asyncore.rst:228
#, fuzzy
msgid ""
"Note that :meth:`recv` may raise :exc:`BlockingIOError` , even though :func:"
"`select.select` or :func:`select.poll` has reported the socket ready for "
"reading."
msgstr ""
"請注意 :meth:`recv` 可能會引發 :exc:`BlockingIOError` ，即使 :func:`select."
"select` 或 :func:`select.poll` 已報告 socket 已準備好讀取。"

#: ../../library/asyncore.rst:235
#, fuzzy
msgid ""
"Listen for connections made to the socket.  The *backlog* argument specifies "
"the maximum number of queued connections and should be at least 1; the "
"maximum value is system-dependent (usually 5)."
msgstr "偵聽與 socket 建立的連接。 *backlog* 參數指定排隊連接的最大數量並且應該至少為 "
"1；最大值取決於系統（通常為 5）。"

#: ../../library/asyncore.rst:242
#, fuzzy
msgid ""
"Bind the socket to *address*.  The socket must not already be bound.  (The "
"format of *address* depends on the address family --- refer to the :mod:"
"`socket` documentation for more information.)  To mark the socket as re-"
"usable (setting the :const:`SO_REUSEADDR` option), call the :class:"
"`dispatcher` object's :meth:`set_reuse_addr` method."
msgstr ""
"將 socket 綁定到 *address*。 socket 必須尚未綁定。 （*address* "
"的格式取決於地址族——更多資訊請參考 :mod:`socket` "
"文檔。）要將 socket 標記為可重用（設定 :const:`SO_REUSEADDR` 選項），呼叫 "
":class:`dispatcher` 物件的 :meth:`set_reuse_addr` 方法。"

#: ../../library/asyncore.rst:251
#, fuzzy
msgid ""
"Accept a connection.  The socket must be bound to an address and listening "
"for connections.  The return value can be either ``None`` or a pair ``(conn, "
"address)`` where *conn* is a *new* socket object usable to send and receive "
"data on the connection, and *address* is the address bound to the socket on "
"the other end of the connection. When ``None`` is returned it means the "
"connection didn't take place, in which case the server should just ignore "
"this event and keep listening for further incoming connections."
msgstr ""
"接受連接。 socket 必須綁定到一個地址並偵聽連接。回傳值可以是 ``None``或一對“("
"conn, address)”，其中 *conn* 是一個 *new* "
" socket 物件，可用於在連接上發送和接收資料，而 *address* 是地址綁定到連接另一端"
"的 socket 。當回傳 ``None``時，這意味著連接沒有發生，在這種情況下，伺服器應該忽略"
"這個事件並繼續監聽進一步的傳入連接。"

#: ../../library/asyncore.rst:263
#, fuzzy
msgid ""
"Close the socket.  All future operations on the socket object will fail. The "
"remote end-point will receive no more data (after queued data is flushed).  "
"Sockets are automatically closed when they are garbage-collected."
msgstr "關閉插座。以後對 socket 物件的所有操作都將失敗。遠程端點將不再接收資料（刷新排"
"隊的資料後）。 socket 在垃圾回收時自動關閉。"

#: ../../library/asyncore.rst:271
#, fuzzy
msgid ""
"A :class:`dispatcher` subclass which adds simple buffered output capability, "
"useful for simple clients. For more sophisticated usage use :class:`asynchat."
"async_chat`."
msgstr ""
"一個 :class:`dispatcher` "
"子類別，它新增了簡單的緩衝輸出功能，對簡單的客戶端很有用。對於更複雜的用法，"
"請使用 :class:`asynchat.async_chat`。"

#: ../../library/asyncore.rst:277
#, fuzzy
msgid ""
"A file_dispatcher takes a file descriptor or :term:`file object` along with "
"an optional map argument and wraps it for use with the :c:func:`poll` or :c:"
"func:`loop` functions.  If provided a file object or anything with a :c:func:"
"`fileno` method, that method will be called and passed to the :class:"
"`file_wrapper` constructor."
msgstr ""
"file_dispatcher 接受一個文件描述器或 :term:`file object` 以及一個可選的 map "
"參數，並將其包裝起來用於 :c:func:`poll` 或 :c:func:`loop` 函式。"
"如果提供一個文件對像或任何帶有 :c:func:`fileno` 方法的物件，"
"該方法將被呼叫並傳遞給 :class:`file_wrapper` 構造函式。"

#: ../../library/asyncore.rst:283 ../../library/asyncore.rst:292
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`適用 <availability>`：Unix。"

#: ../../library/asyncore.rst:287
#, fuzzy
msgid ""
"A file_wrapper takes an integer file descriptor and calls :func:`os.dup` to "
"duplicate the handle so that the original handle may be closed independently "
"of the file_wrapper.  This class implements sufficient methods to emulate a "
"socket for use by the :class:`file_dispatcher` class."
msgstr ""
"file_wrapper 採用整數文件描述器並呼叫 os.dup 來複製句柄，以便可以獨立於 "
"file_wrapper 關閉原始句柄。此類實作了足夠的方法來模擬供 file_dispatcher "
"類使用的 socket 。"

#: ../../library/asyncore.rst:298
#, fuzzy
msgid "asyncore Example basic HTTP client"
msgstr "asyncore 示例基本 HTTP 客戶端"

#: ../../library/asyncore.rst:300
#, fuzzy
msgid ""
"Here is a very basic HTTP client that uses the :class:`dispatcher` class to "
"implement its socket handling::"
msgstr "這是一個非常基本的 HTTP 客戶端，它使用 :class:`dispatcher` "
"類來實作其 socket 處理："

#: ../../library/asyncore.rst:337
#, fuzzy
msgid "asyncore Example basic echo server"
msgstr "asyncore 示例基本回顯伺服器"

#: ../../library/asyncore.rst:339
#, fuzzy
msgid ""
"Here is a basic echo server that uses the :class:`dispatcher` class to "
"accept connections and dispatches the incoming connections to a handler::"
msgstr "這是一個基本的回顯伺服器，它使用 :class:`dispatcher` "
"類來接受連接並將傳入的連接分派給處理程式::"
