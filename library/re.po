# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-05 00:20+0000\n"
"PO-Revision-Date: 2018-05-23 16:09+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/re.rst:2
#, fuzzy
msgid ":mod:`re` --- Regular expression operations"
msgstr ":mod:`re` --- 正則表達式操作"

#: ../../library/re.rst:10
msgid "**Source code:** :source:`Lib/re/`"
msgstr "**原始碼：**\\ :source:`Lib/re/`"

#: ../../library/re.rst:14
#, fuzzy
msgid ""
"This module provides regular expression matching operations similar to those "
"found in Perl."
msgstr "該模組提供類似於 Perl 中的正則表達式匹配操作。"

#: ../../library/re.rst:17
#, fuzzy
msgid ""
"Both patterns and strings to be searched can be Unicode strings (:class:"
"`str`) as well as 8-bit strings (:class:`bytes`). However, Unicode strings "
"and 8-bit strings cannot be mixed: that is, you cannot match a Unicode "
"string with a byte pattern or vice-versa; similarly, when asking for a "
"substitution, the replacement string must be of the same type as both the "
"pattern and the search string."
msgstr ""
"要搜索的模式和字串都可以是 Unicode 字串 (:class:`str`) 以及 8 位字串 "
"(:class:`bytes`)。但是，Unicode 字串和 8 位字串不能混合使用：也就是說，"
"您不能將 Unicode 字串與位元組模式匹配，反之亦然；類似地，當請求替換時，替換字"
"串必須與模式和搜索字串的型別相同。"

#: ../../library/re.rst:24
#, fuzzy
msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match a "
"literal backslash, one might have to write ``'\\\\\\\\'`` as the pattern "
"string, because the regular expression must be ``\\\\``, and each backslash "
"must be expressed as ``\\\\`` inside a regular Python string literal. Also, "
"please note that any invalid escape sequences in Python's usage of the "
"backslash in string literals now generate a :exc:`DeprecationWarning` and in "
"the future this will become a :exc:`SyntaxError`. This behaviour will happen "
"even if it is a valid escape sequence for a regular expression."
msgstr ""
"正則表達式使用反斜杠字元 (``'\\'``) "
"來指示特殊形式或允許使用特殊字元而不呼叫它們的特殊含義。這與 Python "
"在字串文字中出於相同目的使用相同字元相衝突；例如，要匹配文字反斜杠，"
"可能必須將 ``'\\\\\\\\'`` 寫為模式字串，因為正則表達式必須是 ``\\\\``，"
"並且每個反斜杠必須表示為 ` `\\\\`` 在常規 Python 字串文字中。另外，請注意，"
"Python 在字串文字中使用反斜杠時，任何無效的轉義序列現在都會生成一個 "
"DeprecationWarning，將來這將變成一個 "
"SyntaxError。即使它是正則表達式的有效轉義序列，也會發生此行為。"

#: ../../library/re.rst:36
#, fuzzy
msgid ""
"The solution is to use Python's raw string notation for regular expression "
"patterns; backslashes are not handled in any special way in a string literal "
"prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character string containing "
"``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character string containing "
"a newline.  Usually patterns will be expressed in Python code using this raw "
"string notation."
msgstr ""
"解決方案是對正則表達式模式使用 Python 的原始字串表示法；在以 ``\\'r\\'`` "
"為前綴的字串文字中，反斜杠沒有以任何特殊方式處理。所以 ``r\"\\n"
"\"`` 是一個包含 ``\\'\\\\'`` 和 ``\\'n\\'`` 的雙字元字串，而 ``\"\\n"
"\"`` 是一個包含新隊。通常模式將使用這種原始字串表示法在 Python 程式碼中表示。"

#: ../../library/re.rst:43
#, fuzzy
msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and methods on :ref:`compiled regular "
"expressions <re-objects>`.  The functions are shortcuts that don't require "
"you to compile a regex object first, but miss some fine-tuning parameters."
msgstr ""
"重要的是要注意，大多數正則表達式操作都可以作為模組級函式和方法在 :ref:`"
"compiled regular expressions <re-objects>` 上使用。這些函式是不需要您先編譯 "
"regex 物件的快捷方式，但會遺漏一些微調參數。"

#: ../../library/re.rst:51
#, fuzzy
msgid ""
"The third-party `regex <https://pypi.org/project/regex/>`_ module, which has "
"an API compatible with the standard library :mod:`re` module, but offers "
"additional functionality and a more thorough Unicode support."
msgstr ""
"第三方 `regex <https://pypi.org/project/regex/>`_ 模組，其 API 與標準庫 "
":mod:`re` 模組相容，但提供額外的功能和更全面的 Unicode支援。"

#: ../../library/re.rst:59
#, fuzzy
msgid "Regular Expression Syntax"
msgstr "正則表達式語法"

#: ../../library/re.rst:61
#, fuzzy
msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; the "
"functions in this module let you check if a particular string matches a "
"given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""
"正則表達式（或 RE）指定一組匹配它的字串；該模組中的函式允許您檢查特定字串是否"
"與給定的正則表達式匹配（或者給定的正則表達式是否與特定字串匹配，這歸結為同一"
"件事）。"

#: ../../library/re.rst:66
#, fuzzy
msgid ""
"Regular expressions can be concatenated to form new regular expressions; if "
"*A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string *q* "
"matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* "
"contain low precedence operations; boundary conditions between *A* and *B*; "
"or have numbered group references.  Thus, complex expressions can easily be "
"constructed from simpler primitive expressions like the ones described "
"here.  For details of the theory and implementation of regular expressions, "
"consult the Friedl book [Frie09]_, or almost any textbook about compiler "
"construction."
msgstr ""
"可以連接正則表達式以形成新的正則表達式；如果 *A* 和 *B* 都是正則表達式，那麼 "
"*AB* 也是正則表達式。通常，如果字串 *p* 匹配 *A* 而另一個字串 *q* 匹配 *B*，"
"則字串 *pq* 將匹配 AB。這成立，除非 *A* 或 *B* 包含低優先級操作； *A* 和 *B* "
"之間的邊界條件；或有編號的組參考。因此，複雜的表達式可以很容易地從更簡單的原"
"始表達式構造，就像這裡描述的那樣。有關正則表達式的理論和實作的詳細資訊，"
"請參閱 Friedl 書 [Frie09]_，或幾乎任何有關編譯器構造的教科書。"

#: ../../library/re.rst:76
#, fuzzy
msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr "下面簡要說明正則表達式的格式。如需更多資訊和更溫和的介紹，請參閱 :ref:`regex-"
"howto`。"

#: ../../library/re.rst:79
#, fuzzy
msgid ""
"Regular expressions can contain both special and ordinary characters. Most "
"ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the simplest "
"regular expressions; they simply match themselves.  You can concatenate "
"ordinary characters, so ``last`` matches the string ``'last'``.  (In the "
"rest of this section, we'll write RE's in ``this special style``, usually "
"without quotes, and strings to be matched ``'in single quotes'``.)"
msgstr ""
"正則表達式可以包含特殊字元和普通字元。大多數普通字元，如 ``A``、 ``a``或 ``0``，都是最"
"簡單的正則表達式；他們只是匹配自己。您可以連接普通字元，因此 ``last`` "
"匹配字串 ``'last'``。 （在本節的其餘部分，我們將以“這種特殊風格”編寫 "
"RE，通常不帶引號，而要匹配的字串“在單引號中”。）"

#: ../../library/re.rst:86
#, fuzzy
msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters "
"either stand for classes of ordinary characters, or affect how the regular "
"expressions around them are interpreted."
msgstr "一些字元，如``'|'`` 或``'('``，是特殊的。特殊字元要么代表普通字元的類，要么影"
"響它們周圍的正則表達式的解釋方式。"

#: ../../library/re.rst:90
#, fuzzy
msgid ""
"Repetition operators or quantifiers (``*``, ``+``, ``?``, ``{m,n}``, etc) "
"cannot be directly nested. This avoids ambiguity with the non-greedy "
"modifier suffix ``?``, and with other modifiers in other implementations. To "
"apply a second repetition to an inner repetition, parentheses may be used. "
"For example, the expression ``(?:a{6})*`` matches any multiple of six "
"``'a'`` characters."
msgstr ""
"重複運算符或量詞（``*``、``+``、``?``、``{m,n}`` 等）不能直接嵌套。這避免了與"
"非貪婪修飾符後綴 ``?``以及其他實作中的其他修飾符的歧義。要將第二次重複應用於內部"
"重複，可以使用括號。例如，表達式 ``(?:a{6})*`` 匹配任意六個字元 ``'a'`` "
"的倍數。"

#: ../../library/re.rst:97
#, fuzzy
msgid "The special characters are:"
msgstr "特殊字元是："

#: ../../library/re.rst:104 ../../library/re.rst:1530
msgid "``.``"
msgstr "``.``"

#: ../../library/re.rst:102
#, fuzzy
msgid ""
"(Dot.)  In the default mode, this matches any character except a newline.  "
"If the :const:`DOTALL` flag has been specified, this matches any character "
"including a newline."
msgstr "（點。）在預設模式下，這匹配除換行符之外的任何字元。如果指定了 "
":const:`DOTALL` 旗標，這將匹配任何字元，包括換行符。"

#: ../../library/re.rst:110
msgid "``^``"
msgstr "``^``"

#: ../../library/re.rst:109
#, fuzzy
msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode "
"also matches immediately after each newline."
msgstr "（插入符號。）匹配字串的開頭，並且在 :const:`MULTILINE` "
"模式下也匹配每個換行符之後的緊接位置。"

#: ../../library/re.rst:121
msgid "``$``"
msgstr "``$``"

#: ../../library/re.rst:115
#, fuzzy
msgid ""
"Matches the end of the string or just before the newline at the end of the "
"string, and in :const:`MULTILINE` mode also matches before a newline.  "
"``foo`` matches both 'foo' and 'foobar', while the regular expression "
"``foo$`` matches only 'foo'.  More interestingly, searching for ``foo.$`` in "
"``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in :const:"
"`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` will find two "
"(empty) matches: one just before the newline, and one at the end of the "
"string."
msgstr ""
"匹配字串的末尾或字串末尾的換行符之前，並且在 :const:`MULTILINE` "
"模式下也匹配換行符之前。 ``foo`` 匹配'foo' 和'foobar'，而正則表達式``foo$`` "
"只匹配'foo'。更有趣的是，在 ``'foo1\\n"
"foo2\\n"
"'`` 中搜索 ``foo.$`` 通常匹配 'foo2'，但在 :const:`MULTILINE` 模式下搜索 "
"'foo1'；在 ``'foo\\n"
"'`` 中搜索單個 ``$`` "
"將找到兩個（空）匹配項：一個就在換行符之前，一個在字串的末尾。"

#: ../../library/re.rst:128
msgid "``*``"
msgstr "``*``"

#: ../../library/re.rst:126
#, fuzzy
msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding RE, "
"as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', or 'a' "
"followed by any number of 'b's."
msgstr ""
"導致生成的 RE 匹配前面 RE 的 0 次或多次重複，盡可能多的重複。 ``ab*`` 將匹配 "
"'a'、'ab' 或 'a' 後跟任意數量的 'b'。"

#: ../../library/re.rst:135
msgid "``+``"
msgstr "``+``"

#: ../../library/re.rst:133
#, fuzzy
msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding RE. "
"``ab+`` will match 'a' followed by any non-zero number of 'b's; it will not "
"match just 'a'."
msgstr "導致生成的 RE 匹配前面 RE 的 1 次或多次重複。 ``ab+`` 將匹配 'a' "
"後跟任何非零數量的 'b'；它不會只匹配 ``a``。"

#: ../../library/re.rst:141
msgid "``?``"
msgstr "``?``"

#: ../../library/re.rst:140
#, fuzzy
msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr "導致生成的 RE 匹配前面 RE 的 0 次或 1 次重複。 ``ab?`` 將匹配 'a' 或 'ab'。"

#: ../../library/re.rst:155
msgid "``*?``, ``+?``, ``??``"
msgstr "``*?``, ``+?``, ``??``"

#: ../../library/re.rst:149
#, fuzzy
msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` quantifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; if "
"the RE ``<.*>`` is matched against ``'<a> b <c>'``, it will match the entire "
"string, and not just ``'<a>'``.  Adding ``?`` after the quantifier makes it "
"perform the match in :dfn:`non-greedy` or :dfn:`minimal` fashion; as *few* "
"characters as possible will be matched.  Using the RE ``<.*?>`` will match "
"only ``'<a>'``."
msgstr ""
"``'*'``、``'+'`` 和 ``'?'`` 量詞都是 "
":dfn:`greedy`；它們匹配盡可能多的文本。有時這種行為是不希望的；如果 RE "
"``<.*>`` 與 ``'<a> b <c>'`` 匹配，它將匹配整個字串，而不僅僅是 ``'<a>'``。"
"在量詞後新增 ``?`` 使其以 :dfn:`non-greedy` 或 :dfn:`minimal` "
"方式執行匹配；將匹配盡可能少的字元。使用 RE ``<.*?>`` 將只匹配 ``'<a>'``。"

#: ../../library/re.rst:179
msgid "``*+``, ``++``, ``?+``"
msgstr "``*+``, ``++``, ``?+``"

#: ../../library/re.rst:163
#, fuzzy
msgid ""
"Like the ``'*'``, ``'+'``, and ``'?'`` quantifiers, those where ``'+'`` is "
"appended also match as many times as possible. However, unlike the true "
"greedy quantifiers, these do not allow back-tracking when the expression "
"following it fails to match. These are known as :dfn:`possessive` "
"quantifiers. For example, ``a*a`` will match ``'aaaa'`` because the ``a*`` "
"will match all 4 ``'a'``\\ s, but, when the final ``'a'`` is encountered, "
"the expression is backtracked so that in the end the ``a*`` ends up matching "
"3 ``'a'``\\ s total, and the fourth ``'a'`` is matched by the final ``'a'``. "
"However, when ``a*+a`` is used to match ``'aaaa'``, the ``a*+`` will match "
"all 4 ``'a'``, but when the final ``'a'`` fails to find any more characters "
"to match, the expression cannot be backtracked and will thus fail to match. "
"``x*+``, ``x++`` and ``x?+`` are equivalent to ``(?>x*)``, ``(?>x+)`` and "
"``(?>x?)`` correspondingly."
msgstr ""
"像``'*'``、``'+'`` 和``'?'`` 量詞一樣，附加了``'+'`` 的量詞也盡可能多地匹配。"
"然而，與真正的貪婪量詞不同，當它後面的表達式無法匹配時，這些量詞不允許回溯。"
"這些被稱為 :dfn:`possessive` 量詞。例如，``a*a`` 將匹配 ``'aaaa'`` 因為 "
"``a*`` 將匹配所有 4 個 ``'a'``\\ s，但是，當最後的 "
"``'a遇到'``，表達式被回溯，所以最後``a*``最終匹配3個``'a'``\\ s，第四個``'a'`"
"`匹配最後的``'a'``。但是，當使用``a*+a``來匹配``'aaaa'``時，``a*+``會匹配所有"
"4個``'a'``，但是當最後的``' a'`` "
"找不到更多的字元來匹配，表達式無法回溯，因此匹配失敗。 ``x*+``、``x++`` 和 "
"``x?+`` 等價於 ``(?>x*)``、``(?>x+)`` 和 ``(?> x?)`` 相應地。"

#: ../../library/re.rst:187
msgid "``{m}``"
msgstr "``{m}``"

#: ../../library/re.rst:185
#, fuzzy
msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` will "
"match exactly six ``'a'`` characters, but not five."
msgstr ""
"指定應匹配前一個 RE 的 *m* 個副本；更少的匹配導致整個 RE "
"不匹配。例如，``a{6}`` 將恰好匹配六個 ``'a'`` 字元，而不是五個。"

#: ../../library/re.rst:196
msgid "``{m,n}``"
msgstr "``{m,n}``"

#: ../../library/re.rst:190
#, fuzzy
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting *m* "
"specifies a lower bound of zero,  and omitting *n* specifies an infinite "
"upper bound.  As an example, ``a{4,}b`` will match ``'aaaab'`` or a thousand "
"``'a'`` characters followed by a ``'b'``, but not ``'aaab'``. The comma may "
"not be omitted or the modifier would be confused with the previously "
"described form."
msgstr ""
"導致生成的 RE 匹配前面 RE 的 *m* 到 *n* "
"次重複，嘗試匹配盡可能多的重複。例如，``a{3,5}`` 將匹配 3 到 5 個 ``'a'`` "
"字元。省略 *m* 指定零下限，省略 *n* 指定無限上限。例如，``a{4,}b`` "
"將匹配``'aaaab'`` 或一千個``'a'`` 字元後跟``'b'``，但不匹配``' "
"aaab'``。逗號不能省略，否則修飾符會與前面描述的形式混淆。"

#: ../../library/re.rst:203
msgid "``{m,n}?``"
msgstr "``{m,n}?``"

#: ../../library/re.rst:199
#, fuzzy
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This is "
"the non-greedy version of the previous quantifier.  For example, on the 6-"
"character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` characters, "
"while ``a{3,5}?`` will only match 3 characters."
msgstr ""
"導致生成的 RE 匹配前面 RE 的 *m* 到 *n* 次重複，嘗試匹配盡可能少的 * "
"次重複。這是前一個量詞的非貪婪版本。例如，對於 6 個字元的字串 "
"``'aaaaaa'``，``a{3,5}`` 將匹配 5 個 ``'a'`` 字元，而 ``a{3,5}?` ` 只會匹配 "
"3 個字元。"

#: ../../library/re.rst:218
msgid "``{m,n}+``"
msgstr "``{m,n}+``"

#: ../../library/re.rst:206
#, fuzzy
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible *without* "
"establishing any backtracking points. This is the possessive version of the "
"quantifier above. For example, on the 6-character string ``'aaaaaa'``, "
"``a{3,5}+aa`` attempt to match 5 ``'a'`` characters, then, requiring 2 more "
"``'a'``\\ s, will need more characters than available and thus fail, while "
"``a{3,5}aa`` will match with ``a{3,5}`` capturing 5, then 4 ``'a'``\\ s by "
"backtracking and then the final 2 ``'a'``\\ s are matched by the final "
"``aa`` in the pattern. ``x{m,n}+`` is equivalent to ``(?>x{m,n})``."
msgstr ""
"導致生成的 RE 匹配前面 RE 的 *m* 到 *n* 次重複，嘗試匹配盡可能多的重複 *而不*"
" 建立任何回溯點。這是上面量詞的所有格版本。例如，在 6 個字元的字串 "
"``'aaaaaa'`` 上，``a{3,5}+aa`` 嘗試匹配 5 個 ``'a'`` 字元，然後，需要再匹配 "
"2 個 ``' a'``\\ s，將需要比可用字元更多的字元，因此失敗，而 ``a{3,5}aa`` "
"將匹配 ``a{3,5}`` 捕獲 5，然後 4 ``' a'``\\ s 通過回溯，然後最後的 2 個 "
"``'a'``\\ s 與模式中的最後一個 ``aa`` 匹配。 ``x{m,n}+`` 等價於 "
"``(?>x{m,n})``。"

#: ../../library/re.rst:233
msgid "``\\``"
msgstr "``\\``"

#: ../../library/re.rst:223
#, fuzzy
msgid ""
"Either escapes special characters (permitting you to match characters like "
"``'*'``, ``'?'``, and so forth), or signals a special sequence; special "
"sequences are discussed below."
msgstr "要么轉義特殊字元（允許你匹配像``'*'``、``'?'`` "
"等字元），要么發出一個特殊序列；特殊序列在下面討論。"

#: ../../library/re.rst:227
#, fuzzy
msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; if "
"the escape sequence isn't recognized by Python's parser, the backslash and "
"subsequent character are included in the resulting string.  However, if "
"Python would recognize the resulting sequence, the backslash should be "
"repeated twice.  This is complicated and hard to understand, so it's highly "
"recommended that you use raw strings for all but the simplest expressions."
msgstr ""
"如果您不使用原始字串來表達模式，請記住 Python "
"還在字串文字中使用反斜杠作為轉義序列；如果 Python "
"的剖析器無法識別轉義序列，則反斜杠和後續字元將包含在結果字串中。但是，如果 "
"Python 能夠識別結果序列，反斜杠應該重複兩次。這很複雜且難以理解，因此強烈建議"
"您對除了最簡單的表達式以外的所有表達式都使用原始字串。"

#: ../../library/re.rst:294
msgid "``[]``"
msgstr "``[]``"

#: ../../library/re.rst:239
#, fuzzy
msgid "Used to indicate a set of characters.  In a set:"
msgstr "用於表示一組字元。在一個集合中："

#: ../../library/re.rst:241
#, fuzzy
msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``, "
"``'m'``, or ``'k'``."
msgstr "字元可以單獨列出，例如``[amk]`` 將匹配 ``'a'``、``'m'`` 或 ``'k'``。"

#: ../../library/re.rst:246
#, fuzzy
msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any lowercase "
"ASCII letter, ``[0-5][0-9]`` will match all the two-digits numbers from "
"``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any hexadecimal digit.  If "
"``-`` is escaped (e.g. ``[a\\-z]``) or if it's placed as the first or last "
"character (e.g. ``[-a]`` or ``[a-]``), it will match a literal ``'-'``."
msgstr ""
"字元範圍可以通過給定兩個字元並用 ``-``分隔它們來表示，例如“[a-z]”將匹配任何小寫 "
"ASCII 字母，“[0-5][0-9” ]`` 將匹配從 ``00`` 到 ``59`` 的所有兩位數字，而 ``[0"
"-9A-Fa-f]`` 將匹配任何十六進位數字。如果 ``-`` 被轉義（例如 ``[a\\"
"-z]``）或者它被放置為第一個或最後一個字元（例如 ``[-a]`` 或 ``[a-]`` ), "
"它將匹配一個字面的``'-'``。"

#: ../../library/re.rst:253
#, fuzzy
msgid ""
"Special characters lose their special meaning inside sets.  For example, "
"``[(+*)]`` will match any of the literal characters ``'('``, ``'+'``, "
"``'*'``, or ``')'``."
msgstr ""
"特殊字元在集合中失去了它們的特殊含義。例如，``[(+*)]`` 將匹配任何文字字元 "
"``'('``、``'+'``、``'*'`` 或 ``')' ``。"

#: ../../library/re.rst:259
#, fuzzy
msgid ""
"Character classes such as ``\\w`` or ``\\S`` (defined below) are also "
"accepted inside a set, although the characters they match depends on "
"whether :const:`ASCII` or :const:`LOCALE` mode is in force."
msgstr ""
"字元類如 ``\\w`` 或 ``\\S``（定義如下）也被接受在一個集合中，"
"儘管它們匹配的字元取決於是 :const:`ASCII` 還是 :const:`LOCALE` 模式生效。"

#: ../../library/re.rst:265
#, fuzzy
msgid ""
"Characters that are not within a range can be matched by :dfn:"
"`complementing` the set.  If the first character of the set is ``'^'``, all "
"the characters that are *not* in the set will be matched.  For example, "
"``[^5]`` will match any character except ``'5'``, and ``[^^]`` will match "
"any character except ``'^'``.  ``^`` has no special meaning if it's not the "
"first character in the set."
msgstr ""
"不在範圍內的字元可以通過 :dfn:`complementing` 集合來匹配。"
"如果集合的第一個字元是 ``'^'``，則匹配集合中*不*的所有字元。例如，``[^5]`` "
"將匹配除 ``'5'`` 之外的任何字元，``[^^]`` 將匹配除 ``'^'`` 之外的任何字元。 "
"``^`` 如果不是集合中的第一個字元，則沒有特殊含義。"

#: ../../library/re.rst:272
#, fuzzy
msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` and "
"``[]()[{}]`` will match a right bracket, as well as left bracket, braces, "
"and parentheses."
msgstr ""
"要匹配集合中的文字“']'”，請在其前面加上反斜杠，或將其放在集合的開頭。例如，``"
"[()[\\]{}]`` 和 ``[]()[{}]`` 都將匹配右括號、左括號、大括號和圓括號。"

#: ../../library/re.rst:282
#, fuzzy
msgid ""
"Support of nested sets and set operations as in `Unicode Technical Standard "
"#18`_ might be added in the future.  This would change the syntax, so to "
"facilitate this change a :exc:`FutureWarning` will be raised in ambiguous "
"cases for the time being. That includes sets starting with a literal ``'['`` "
"or containing literal character sequences ``'--'``, ``'&&'``, ``'~~'``, and "
"``'||'``.  To avoid a warning escape them with a backslash."
msgstr ""
"將來可能會新增對“Unicode 技術標準 "
"#18”中的嵌套集和集操作的支援。這將更改語法，因此為了促進此更改，"
"暫時將在不明確的情況下引發 :exc:`FutureWarning`。這包括以文字 ``[``開頭或包含文"
"字字元序列 ``--``、“&&”、“~~”和 ``|``的集合。 "
"|'``。為了避免警告，請使用反斜杠轉義它們。"

#: ../../library/re.rst:292
#, fuzzy
msgid ""
":exc:`FutureWarning` is raised if a character set contains constructs that "
"will change semantically in the future."
msgstr ":exc:`FutureWarning` 如果字元集包含將來會發生語義變化的構造，則會引發。"

#: ../../library/re.rst:307
msgid "``|``"
msgstr "``|``"

#: ../../library/re.rst:299
#, fuzzy
msgid ""
"``A|B``, where *A* and *B* can be arbitrary REs, creates a regular "
"expression that will match either *A* or *B*.  An arbitrary number of REs "
"can be separated by the ``'|'`` in this way.  This can be used inside groups "
"(see below) as well.  As the target string is scanned, REs separated by "
"``'|'`` are tried from left to right. When one pattern completely matches, "
"that branch is accepted. This means that once *A* matches, *B* will not be "
"tested further, even if it would produce a longer overall match.  In other "
"words, the ``'|'`` operator is never greedy.  To match a literal ``'|'``, "
"use ``\\|``, or enclose it inside a character class, as in ``[|]``."
msgstr ""
"``A|B``，其中 *A* 和 *B* 可以是任意 RE，建立一個匹配 *A* 或 *B* "
"的正則表達式。任意數量的 RE 都可以用這種方式用``'|'`` "
"分隔。這也可以在組內使用（見下文）。在掃描目標字串時，從左到右嘗試用 ``|``"
"分隔的 RE。當一個模式完全匹配時，該分支被接受。這意味著一旦 *A* 匹配，*B* "
"將不會被進一步測試，即使它會產生更長的整體匹配。換句話說，``'|'`` "
"運算符永遠不會貪婪。要匹配文字 ``|``，請使用“\\"
"|”，或將其包含在字元類中，如“[|]”。"

#: ../../library/re.rst:317
msgid "``(...)``"
msgstr "``(...)``"

#: ../../library/re.rst:313
#, fuzzy
msgid ""
"Matches whatever regular expression is inside the parentheses, and indicates "
"the start and end of a group; the contents of a group can be retrieved after "
"a match has been performed, and can be matched later in the string with the "
"``\\number`` special sequence, described below.  To match the literals "
"``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose them inside a "
"character class: ``[(]``, ``[)]``."
msgstr ""
"匹配括號內的任何正則表達式，並指示組的開始和結束；執行匹配後可以檢索組的內容"
"，並且稍後可以在字串中使用 ``\\n"
"umber`` 特殊序列進行匹配，如下所述。要匹配文字 ``'('`` 或 ``')'``，請使用 ``"
"\\(`` 或 ``\\)``，或將它們包含在字元類中：``[(]`` ,``[)]``。"

#: ../../library/re.rst:326
msgid "``(?...)``"
msgstr "``(?...)``"

#: ../../library/re.rst:322
#, fuzzy
msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions usually "
"do not create a new group; ``(?P<name>...)`` is the only exception to this "
"rule. Following are the currently supported extensions."
msgstr ""
"這是一個擴充符號（一個 ``'?'`` 跟在一個 ``'（'`` 否則沒有意義）。``'?'`` 之後"
"的第一個字元決定了它的含義和進一步的語法構造是。擴充通常不會建立新組；``(?P<n"
"ame>...)`` 是此規則的唯一例外。以下是當前支援的擴充。"

#: ../../library/re.rst:343
msgid "``(?aiLmsux)``"
msgstr "``(?aiLmsux)``"

#: ../../library/re.rst:329
#, fuzzy
msgid ""
"(One or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.)  The group matches the empty string; the letters "
"set the corresponding flags: :const:`re.A` (ASCII-only matching), :const:`re."
"I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M` (multi-"
"line), :const:`re.S` (dot matches all), :const:`re.U` (Unicode matching), "
"and :const:`re.X` (verbose), for the entire regular expression. (The flags "
"are described in :ref:`contents-of-module-re`.) This is useful if you wish "
"to include the flags as part of the regular expression, instead of passing a "
"*flag* argument to the :func:`re.compile` function.  Flags should be used "
"first in the expression string."
msgstr ""
"（來自集合``'a'``, ``'i'``, ``'L'``, ``'m'``, ``'s'``, `` 'u'``, ``'x'``.) "
"組匹配空串；這些字母設定相應的旗標：:const:`re.A`（僅 ASCII "
"匹配）、:const:`re.I`（忽略大小寫）、:const:`re.L`（取決於區域設定）、:const "
":`re.M`（多行）、:const:`re.S`（點匹配所有）、:const:`re.U`（Unicode 匹配）"
"和 :const:`re.X`（詳細), 對於整個正則表達式。 （旗標在 :ref:`contents-of-"
"module-re` 中描述。）如果您希望將旗標作為正則表達式的一部分包含，而不是將 "
"*flag* 參數傳遞給 :func： `re.compile` 函式。應首先在表達式字串中使用旗標。"

#: ../../library/re.rst:342
#, fuzzy
msgid "This construction can only be used at the start of the expression."
msgstr "此結構只能用在表達式的開頭。"

#: ../../library/re.rst:351
msgid "``(?:...)``"
msgstr "``(?:...)``"

#: ../../library/re.rst:348
#, fuzzy
msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular "
"expression is inside the parentheses, but the substring matched by the group "
"*cannot* be retrieved after performing a match or referenced later in the "
"pattern."
msgstr "常規括號的非捕獲版本。匹配括號內的任何正則表達式，但匹配組匹配的子字串*不能*"
"在執行匹配後檢索或稍後在模式中引用。"

#: ../../library/re.rst:377
msgid "``(?aiLmsux-imsx:...)``"
msgstr "``(?aiLmsux-imsx:...)``"

#: ../../library/re.rst:354
#, fuzzy
msgid ""
"(Zero or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``, optionally followed by ``'-'`` followed by one or "
"more letters from the ``'i'``, ``'m'``, ``'s'``, ``'x'``.) The letters set "
"or remove the corresponding flags: :const:`re.A` (ASCII-only matching), :"
"const:`re.I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M` "
"(multi-line), :const:`re.S` (dot matches all), :const:`re.U` (Unicode "
"matching), and :const:`re.X` (verbose), for the part of the expression. (The "
"flags are described in :ref:`contents-of-module-re`.)"
msgstr ""
"（來自集合``'a'``, ``'i'``, ``'L'``, ``'m'``, ``'s'``, `` 'u'``, ``'x'``，"
"可選地後跟 ``'-'`` 後跟來自 ``'i'``, ``'m'``, `` 的一個或多個字母's'``, "
"``'x'``.) 字母設定或刪除相應的旗標：:const:`re.A`（僅 ASCII "
"匹配），:const:`re.I`（忽略大小寫), :const:`re."
"L`（取決於語言環境），:const:`re.M`（多行），:const:`re."
"S`（點匹配所有），:const:`re.U `（Unicode 匹配）和 :const:`re."
"X`（詳細），用於表達式的一部分。 （這些旗標在 :ref:`contents-of-module-re` "
"中描述。）"

#: ../../library/re.rst:364
#, fuzzy
msgid ""
"The letters ``'a'``, ``'L'`` and ``'u'`` are mutually exclusive when used as "
"inline flags, so they can't be combined or follow ``'-'``.  Instead, when "
"one of them appears in an inline group, it overrides the matching mode in "
"the enclosing group.  In Unicode patterns ``(?a:...)`` switches to ASCII-"
"only matching, and ``(?u:...)`` switches to Unicode matching (default).  In "
"byte pattern ``(?L:...)`` switches to locale depending matching, and ``(?"
"a:...)`` switches to ASCII-only matching (default). This override is only in "
"effect for the narrow inline group, and the original matching mode is "
"restored outside of the group."
msgstr ""
"字母 ``'a'``、``'L'`` 和 ``'u'`` 在用作內聯旗標時是互斥的，"
"因此它們不能組合或跟在 ``'-'`` 之後."
"相反，當其中一個出現在內聯組中時，它會覆蓋封閉組中的匹配模式。在 Unicode "
"模式中，``(?a:...)`` 切換到僅 ASCII 匹配，``(?u:...)`` 切換到 Unicode "
"匹配（預設）。在位元組模式中，``(?L:...)`` "
"根據匹配切換到語言環境，``(?a:...)`` 切換到僅 ASCII "
"匹配（預設）。此覆蓋僅對窄內聯組有效，在組外恢復原來的匹配方式。"

#: ../../library/re.rst:376
#, fuzzy
msgid "The letters ``'a'``, ``'L'`` and ``'u'`` also can be used in a group."
msgstr "字母``'a'``、``'L'`` 和``'u'`` 也可以在組中使用。"

#: ../../library/re.rst:392
msgid "``(?>...)``"
msgstr "``(?>...)``"

#: ../../library/re.rst:380
#, fuzzy
msgid ""
"Attempts to match ``...`` as if it was a separate regular expression, and if "
"successful, continues to match the rest of the pattern following it. If the "
"subsequent pattern fails to match, the stack can only be unwound to a point "
"*before* the ``(?>...)`` because once exited, the expression, known as an :"
"dfn:`atomic group`, has thrown away all stack points within itself. Thus, "
"``(?>.*).`` would never match anything because first the ``.*`` would match "
"all characters possible, then, having nothing left to match, the final ``.`` "
"would fail to match. Since there are no stack points saved in the Atomic "
"Group, and there is no stack point before it, the entire expression would "
"thus fail to match."
msgstr ""
"嘗試匹配 ``...`` 就好像它是一個單獨的正則表達式一樣，如果成功，則繼續匹配它後"
"面的模式的其餘部分。如果後續模式不匹配，堆疊只能展開到 *之前* ``(?>...)`` "
"的點，因為一旦退出，表達式，稱為 :dfn:`atomic "
"group`，已經丟棄了其自身內的所有堆疊點。因此，``(?>.*).`` "
"永遠不會匹配任何東西，因為首先 ``.*`` "
"會匹配所有可能的字元，然後，沒有任何東西可以匹配，最後的 ``.`` "
"將無法匹配匹配。由於 Atomic Group "
"中沒有保存堆疊點，並且在它之前也沒有堆疊點，因此整個表達式將無法匹配。"

#: ../../library/re.rst:423
msgid "``(?P<name>...)``"
msgstr "``(?P<name>...)``"

#: ../../library/re.rst:397
#, fuzzy
msgid ""
"Similar to regular parentheses, but the substring matched by the group is "
"accessible via the symbolic group name *name*.  Group names must be valid "
"Python identifiers, and each group name must be defined only once within a "
"regular expression.  A symbolic group is also a numbered group, just as if "
"the group were not named."
msgstr ""
"與常規括號類似，但組匹配的子字串可以通過符號組名 *name* 訪問。"
"組名必須是有效的 Python 標識符，並且每個組名必須在正則表達式中只定義一次。符"
"號組也是編號組，就好像該組沒有命名一樣。"

#: ../../library/re.rst:403
#, fuzzy
msgid ""
"Named groups can be referenced in three contexts.  If the pattern is ``(?"
"P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with either "
"single or double quotes):"
msgstr ""
"可以在三種上下文中引用命名組。如果模式是 ``(?P<quote>[\\'\""
"]).*?(?P=quote)``（即匹配用單引號或雙引號引用的字串）："

#: ../../library/re.rst:408
#, fuzzy
msgid "Context of reference to group \"quote\""
msgstr "引用組 ``quote``的上下文"

#: ../../library/re.rst:408
#, fuzzy
msgid "Ways to reference it"
msgstr "參考方法"

#: ../../library/re.rst:410
#, fuzzy
msgid "in the same pattern itself"
msgstr "以相同的模式本身"

#: ../../library/re.rst:410
#, fuzzy
msgid "``(?P=quote)`` (as shown)"
msgstr "``(?P=quote)``（如圖）"

#: ../../library/re.rst:411 ../../library/re.rst:418
msgid "``\\1``"
msgstr "``\\1``"

#: ../../library/re.rst:413
#, fuzzy
msgid "when processing match object *m*"
msgstr "處理匹配物件時 *m*"

#: ../../library/re.rst:413
msgid "``m.group('quote')``"
msgstr "``m.group('quote')``"

#: ../../library/re.rst:414
#, fuzzy
msgid "``m.end('quote')`` (etc.)"
msgstr "``m.end('quote')``（等）"

#: ../../library/re.rst:416
#, fuzzy
msgid "in a string passed to the *repl* argument of ``re.sub()``"
msgstr "在傳遞給 ``re.sub()`` 的 *repl* 參數的字串中"

#: ../../library/re.rst:416
msgid "``\\g<quote>``"
msgstr "``\\g<quote>``"

#: ../../library/re.rst:417
msgid "``\\g<1>``"
msgstr "``\\g<1>``"

#: ../../library/re.rst:421
#, fuzzy
msgid ""
"Group *name* containing characters outside the ASCII range (``b'\\x00'``-"
"``b'\\x7f'``) in :class:`bytes` patterns."
msgstr ""
"組 *name* 包含 ASCII 範圍之外的字元（``b'\\x00'``-``b'\\x7f'``）在 "
":class:`bytes` 模式中。"

#: ../../library/re.rst:429
msgid "``(?P=name)``"
msgstr "``(?P=name)``"

#: ../../library/re.rst:428
#, fuzzy
msgid ""
"A backreference to a named group; it matches whatever text was matched by "
"the earlier group named *name*."
msgstr "對命名組的反向引用；它與之前名為 *name* 的組匹配的任何文本相匹配。"

#: ../../library/re.rst:434
msgid "``(?#...)``"
msgstr "``(?#...)``"

#: ../../library/re.rst:434
#, fuzzy
msgid "A comment; the contents of the parentheses are simply ignored."
msgstr "一條評論;括號中的內容將被忽略。"

#: ../../library/re.rst:441
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../library/re.rst:439
#, fuzzy
msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a :dfn:`lookahead assertion`.  For example, ``Isaac (?"
"=Asimov)`` will match ``'Isaac '`` only if it's followed by ``'Asimov'``."
msgstr ""
"如果 ``...`` 下一個匹配則匹配，但不消耗任何字串。這稱為 :dfn:`lookahead "
"assertion`。例如，``Isaac (?=Asimov)`` 將匹配 ``'Isaac'`` 僅當其後跟 "
"``'Asimov'`` 時。"

#: ../../library/re.rst:448
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../library/re.rst:446
#, fuzzy
msgid ""
"Matches if ``...`` doesn't match next.  This is a :dfn:`negative lookahead "
"assertion`. For example, ``Isaac (?!Asimov)`` will match ``'Isaac '`` only "
"if it's *not* followed by ``'Asimov'``."
msgstr ""
"如果 ``...`` 下一個不匹配則匹配。這是一個 :dfn:`negative lookahead "
"assertion`。例如，``Isaac (?!Asimov)`` 將匹配 ``'Isaac '`` 僅當 *not* 後跟 "
"``'Asimov'`` 時。"

#: ../../library/re.rst:475
msgid "``(?<=...)``"
msgstr "``(?<=...)``"

#: ../../library/re.rst:453
#, fuzzy
msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a :dfn:`positive "
"lookbehind assertion`. ``(?<=abc)def`` will find a match in ``'abcdef'``, "
"since the lookbehind will back up 3 characters and check if the contained "
"pattern matches. The contained pattern must only match strings of some fixed "
"length, meaning that ``abc`` or ``a|b`` are allowed, but ``a*`` and ``a{3,4}"
"`` are not.  Note that patterns which start with positive lookbehind "
"assertions will not match at the beginning of the string being searched; you "
"will most likely want to use the :func:`search` function rather than the :"
"func:`match` function:"
msgstr ""
"如果字串中的當前位置前面有以當前位置結束的 ``...`` 的匹配項，則匹配。這稱為 "
":dfn:`positive lookbehind assertion`。 ``(?<=abc)def`` 將在 ``'abcdef'`` "
"中找到一個匹配項，因為 lookbehind 將備份 3 "
"個字元並檢查包含的模式是否匹配。包含的模式必須只匹配一些固定長度的字串，"
"這意味著允許使用 abc 或 a|b，但不允許使用 a* 和 a{3,4} ."
"請注意，以正後向斷言開頭的模式將不會匹配正在搜索的字串的開頭；你很可能想使用 "
":func:`search` 函式而不是 :func:`match` 函式："

#: ../../library/re.rst:468
#, fuzzy
msgid "This example looks for a word following a hyphen:"
msgstr "此示例查找連字元後的單詞："

#: ../../library/re.rst:474
#, fuzzy
msgid "Added support for group references of fixed length."
msgstr "新增了對固定長度的組引用的支援。"

#: ../../library/re.rst:484
msgid "``(?<!...)``"
msgstr "``(?<!...)``"

#: ../../library/re.rst:480
#, fuzzy
msgid ""
"Matches if the current position in the string is not preceded by a match for "
"``...``.  This is called a :dfn:`negative lookbehind assertion`.  Similar to "
"positive lookbehind assertions, the contained pattern must only match "
"strings of some fixed length.  Patterns which start with negative lookbehind "
"assertions may match at the beginning of the string being searched."
msgstr ""
"如果字串中的當前位置前面沒有匹配“...”，則匹配。這稱為 :dfn:`negative "
"lookbehind assertion`。與積極的回顧斷言類似，包含的模式必須只匹配一些固定長度"
"的字串。以否定後向斷言開頭的模式可能會匹配正在搜索的字串的開頭。"

#: ../../library/re.rst:501
msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr "``(?(id/name)yes-pattern|no-pattern)``"

#: ../../library/re.rst:490
#, fuzzy
msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example, ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?"
"(1)>|$)`` is a poor email matching pattern, which will match with "
"``'<user@host.com>'`` as well as ``'user@host.com'``, but not with "
"``'<user@host.com'`` nor ``'user@host.com>'``."
msgstr ""
"如果具有給定 *id* 或 *name* 的組存在，將嘗試與 ``yes-pattern`` 匹配，"
"如果不存在則與 ``no-pattern`` 匹配。 ``no-pattern`` "
"是可選的，可以省略。例如，``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$)`` "
"是一個糟糕的電子郵件匹配模式，它將與 ``' <user@host.com>'`` 以及 ``'user@host"
".com'``，但不包括 ``'<user@host.com'`` 或 ``'user@host.com> '``。"

#: ../../library/re.rst:497 ../../library/re.rst:1020
#, fuzzy
msgid ""
"Group *id* containing anything except ASCII digits. Group *name* containing "
"characters outside the ASCII range (``b'\\x00'``-``b'\\x7f'``) in :class:"
"`bytes` replacement strings."
msgstr ""
"組 *id* 包含除 ASCII 數字以外的任何內容。組 *name* 包含 ASCII "
"範圍之外的字元（``b'\\x00'``-``b'\\x7f'``）在 :class:`bytes` 替換字串中。"

#: ../../library/re.rst:503
#, fuzzy
msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not an ASCII digit or an ASCII letter, "
"then the resulting RE will match the second character.  For example, ``\\$`` "
"matches the character ``'$'``."
msgstr ""
"特殊序列由 ``'\\'`` 和下表中的一個字元組成。如果普通字元不是 ASCII 數字或 "
"ASCII 字母，則生成的 RE 將匹配第二個字元。例如，``\\$`` 匹配字元 ``'$'``。"

#: ../../library/re.rst:518
msgid "``\\number``"
msgstr "``\\number``"

#: ../../library/re.rst:511
#, fuzzy
msgid ""
"Matches the contents of the group of the same number.  Groups are numbered "
"starting from 1.  For example, ``(.+) \\1`` matches ``'the the'`` or ``'55 "
"55'``, but not ``'thethe'`` (note the space after the group).  This special "
"sequence can only be used to match one of the first 99 groups.  If the first "
"digit of *number* is 0, or *number* is 3 octal digits long, it will not be "
"interpreted as a group match, but as the character with octal value "
"*number*. Inside the ``'['`` and ``']'`` of a character class, all numeric "
"escapes are treated as characters."
msgstr ""
"匹配相同編號組的內容。組從 1 開始編號。例如，``(.+) \\1`` 匹配 ``'the'`` 或 "
"``'55 55'``，但不匹配 ``'thethe'``（注意組後的空格）。"
"此特殊序列只能用於匹配前 99 個組中的一個。如果*number*的第一個數字是0，或者*n"
"umber*是3個八進位數字，則不會被解釋為組匹配，而是被解釋為八進位值為*number*的"
"字元。在字元類的 ``'['`` 和 ``']'`` 中，所有數字轉義都被視為字元。"

#: ../../library/re.rst:523
msgid "``\\A``"
msgstr "``\\A``"

#: ../../library/re.rst:523
#, fuzzy
msgid "Matches only at the start of the string."
msgstr "僅匹配字串的開頭。"

#: ../../library/re.rst:539
msgid "``\\b``"
msgstr "``\\b``"

#: ../../library/re.rst:528
#, fuzzy
msgid ""
"Matches the empty string, but only at the beginning or end of a word. A word "
"is defined as a sequence of word characters.  Note that formally, ``\\b`` is "
"defined as the boundary between a ``\\w`` and a ``\\W`` character (or vice "
"versa), or between ``\\w`` and the beginning/end of the string. This means "
"that ``r'\\bfoo\\b'`` matches ``'foo'``, ``'foo.'``, ``'(foo)'``, ``'bar foo "
"baz'`` but not ``'foobar'`` or ``'foo3'``."
msgstr ""
"匹配空字串，但僅在單詞的開頭或結尾。單詞被定義為單詞字元的序列。請注意，形式"
"上，``\\b`` 被定義為``\\w`` 和``\\W`` 字元之間的邊界（反之亦然），或者``\\w``"
" 和開頭/字串的結尾。這意味著 ``r'\\bfoo\\b'`` 匹配``'foo'``, ``'foo.'``, "
"``'(foo)'``, ``'bar foo baz'` ` 但不是 ``'foobar'`` 或 ``'foo3'``。"

#: ../../library/re.rst:535
#, fuzzy
msgid ""
"By default Unicode alphanumerics are the ones used in Unicode patterns, but "
"this can be changed by using the :const:`ASCII` flag.  Word boundaries are "
"determined by the current locale if the :const:`LOCALE` flag is used. Inside "
"a character range, ``\\b`` represents the backspace character, for "
"compatibility with Python's string literals."
msgstr ""
"預設情況下，Unicode 字母數字是 Unicode 模式中使用的，但這可以通過使用 ASCII "
"旗標來更改。如果使用 :const:`LOCALE` "
"旗標，則單詞邊界由當前語言環境決定。在字元範圍內，“\\b”表示退格字元，以與 "
"Python 的字串文字相容。"

#: ../../library/re.rst:550
msgid "``\\B``"
msgstr "``\\B``"

#: ../../library/re.rst:544
#, fuzzy
msgid ""
"Matches the empty string, but only when it is *not* at the beginning or end "
"of a word.  This means that ``r'py\\B'`` matches ``'python'``, ``'py3'``, "
"``'py2'``, but not ``'py'``, ``'py.'``, or ``'py!'``. ``\\B`` is just the "
"opposite of ``\\b``, so word characters in Unicode patterns are Unicode "
"alphanumerics or the underscore, although this can be changed by using the :"
"const:`ASCII` flag.  Word boundaries are determined by the current locale if "
"the :const:`LOCALE` flag is used."
msgstr ""
"匹配空字串，但僅當它 *不* 在單詞的開頭或結尾時。這意味著``r'py\\B"
"'``匹配``'python'``、``'py3'``、``'py2'``，但不匹配``'py'``、`` 'py.'`` 或 "
"``'py!'``。 ``\\B`` 與``\\b`` 相反，所以 Unicode 模式中的單詞字元是 Unicode "
"字母數字或底線，儘管這可以通過使用 ASCII 旗標來更改。如果使用 "
":const:`LOCALE` 旗標，則單詞邊界由當前語言環境決定。"

#: ../../library/re.rst:562
msgid "``\\d``"
msgstr "``\\d``"

#: ../../library/re.rst:559 ../../library/re.rst:579 ../../library/re.rst:598
#, fuzzy
msgid "For Unicode (str) patterns:"
msgstr "對於 Unicode (str) 模式："

#: ../../library/re.rst:556
#, fuzzy
msgid ""
"Matches any Unicode decimal digit (that is, any character in Unicode "
"character category [Nd]).  This includes ``[0-9]``, and also many other "
"digit characters.  If the :const:`ASCII` flag is used only ``[0-9]`` is "
"matched."
msgstr ""
"匹配任何 Unicode 十進位數字（即 Unicode 字元類別 [Nd] "
"中的任何字元）。這包括“[0-9]”以及許多其他數字字元。如果使用 :const:`ASCII` "
"旗標，則僅匹配 ``[0-9]``。"

#: ../../library/re.rst:562 ../../library/re.rst:583 ../../library/re.rst:604
#, fuzzy
msgid "For 8-bit (bytes) patterns:"
msgstr "對於 8 位（位元組）模式："

#: ../../library/re.rst:562
#, fuzzy
msgid "Matches any decimal digit; this is equivalent to ``[0-9]``."
msgstr "匹配任何十進位數字；這相當於``[0-9]``。"

#: ../../library/re.rst:569
msgid "``\\D``"
msgstr "``\\D``"

#: ../../library/re.rst:567
#, fuzzy
msgid ""
"Matches any character which is not a decimal digit. This is the opposite of "
"``\\d``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^0-9]``."
msgstr "匹配任何非十進位數字的字元。這與 ``\\d`` 相反。如果使用 :const:`ASCII` 旗標，"
"這將等同於 ``[^0-9]``。"

#: ../../library/re.rst:583
msgid "``\\s``"
msgstr "``\\s``"

#: ../../library/re.rst:575
#, fuzzy
msgid ""
"Matches Unicode whitespace characters (which includes "
"``[ \\t\\n\\r\\f\\v]``, and also many other characters, for example the non-"
"breaking spaces mandated by typography rules in many languages). If the :"
"const:`ASCII` flag is used, only ``[ \\t\\n\\r\\f\\v]`` is matched."
msgstr ""
"匹配 Unicode 空白字元（包括 ``[ \\t\\n"
"\\r\\f\\v]`` 以及許多其他字元，例如許多語言中排版規則規定的不間斷空格）。"
"如果使用 :const:`ASCII` 旗標，則僅匹配 ``[ \\t\\n"
"\\r\\f\\v]``。"

#: ../../library/re.rst:582
#, fuzzy
msgid ""
"Matches characters considered whitespace in the ASCII character set; this is "
"equivalent to ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"匹配 ASCII 字元集中被視為空白的字元；這相當於``[ \\t\\n"
"\\r\\f\\v]``。"

#: ../../library/re.rst:590
msgid "``\\S``"
msgstr "``\\S``"

#: ../../library/re.rst:588
#, fuzzy
msgid ""
"Matches any character which is not a whitespace character. This is the "
"opposite of ``\\s``. If the :const:`ASCII` flag is used this becomes the "
"equivalent of ``[^ \\t\\n\\r\\f\\v]``."
msgstr ""
"匹配任何不是空白字元的字元。這與 ``\\s`` 相反。如果使用 :const:`ASCII` 旗標，"
"這將等同於 ``[^ \\t\\n"
"\\r\\f\\v]``。"

#: ../../library/re.rst:604
msgid "``\\w``"
msgstr "``\\w``"

#: ../../library/re.rst:596
#, fuzzy
msgid ""
"Matches Unicode word characters; this includes alphanumeric characters (as "
"defined by :meth:`str.isalnum`) as well as the underscore (``_``). If the :"
"const:`ASCII` flag is used, only ``[a-zA-Z0-9_]`` is matched."
msgstr ""
"匹配 Unicode 單詞字元；這包括字母數字字元（由 :meth:`str.isalnum` 定義）"
"以及底線 (``_``)。如果使用 :const:`ASCII` 旗標，則僅匹配``[a-zA-Z0-9_]``。"

#: ../../library/re.rst:601
#, fuzzy
msgid ""
"Matches characters considered alphanumeric in the ASCII character set; this "
"is equivalent to ``[a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, "
"matches characters considered alphanumeric in the current locale and the "
"underscore."
msgstr ""
"匹配 ASCII 字元集中被視為字母數字的字元；這相當於``[a-zA-Z0-9_]``。如果使用 "
":const:`LOCALE` 旗標，則匹配在當前語言環境中被視為字母數字的字元和底線。"

#: ../../library/re.rst:613
msgid "``\\W``"
msgstr "``\\W``"

#: ../../library/re.rst:609
#, fuzzy
msgid ""
"Matches any character which is not a word character. This is the opposite of "
"``\\w``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, matches characters "
"which are neither alphanumeric in the current locale nor the underscore."
msgstr ""
"匹配任何不是單詞字元的字元。這與 ``\\w`` 相反。如果使用 :const:`ASCII` 旗標，"
"這將等同於 ``[^a-zA-Z0-9_]``。如果使用 :const:`LOCALE` "
"旗標，則匹配在當前語言環境中既不是字母數字也不是底線的字元。"

#: ../../library/re.rst:618
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../library/re.rst:618
#, fuzzy
msgid "Matches only at the end of the string."
msgstr "僅匹配字串的末尾。"

#: ../../library/re.rst:634
#, fuzzy
msgid ""
"Most of the standard escapes supported by Python string literals are also "
"accepted by the regular expression parser::"
msgstr "Python 字串文字支援的大多數標準轉義也被正則表達式剖析器接受："

#: ../../library/re.rst:641
#, fuzzy
msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr "（請注意，``\\b`` 用於表示單詞邊界，並且僅在字元類中表示“退格”。）"

#: ../../library/re.rst:644
#, fuzzy
msgid ""
"``'\\u'``, ``'\\U'``, and ``'\\N'`` escape sequences are only recognized in "
"Unicode patterns.  In bytes patterns they are errors.  Unknown escapes of "
"ASCII letters are reserved for future use and treated as errors."
msgstr ""
"``'\\u'``、``'\\U'`` 和 ``'\\N'`` 轉義序列只能在 Unicode "
"模式中識別。在位元組模式中，它們是錯誤。未知的 ASCII "
"字母轉義保留供將來使用並被視為錯誤。"

#: ../../library/re.rst:648
#, fuzzy
msgid ""
"Octal escapes are included in a limited form.  If the first digit is a 0, or "
"if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal escapes "
"are always at most three digits in length."
msgstr ""
"八進位轉義符以有限的形式包含在內。如果第一個數字是 0，或者如果有三個八進位數"
"字，則認為是八進位轉義。否則，它是一個組引用。至於字串文字，八進位轉義符的長"
"度始終最多為三位數字。"

#: ../../library/re.rst:653
#, fuzzy
msgid "The ``'\\u'`` and ``'\\U'`` escape sequences have been added."
msgstr "新增了``'\\u'`` 和``'\\U'`` 轉義序列。"

#: ../../library/re.rst:656
#, fuzzy
msgid ""
"Unknown escapes consisting of ``'\\'`` and an ASCII letter now are errors."
msgstr "由 ``'\\'`` 和 ASCII 字母組成的未知轉義現在是錯誤。"

#: ../../library/re.rst:659
#, fuzzy
msgid ""
"The ``'\\N{name}'`` escape sequence has been added. As in string literals, "
"it expands to the named Unicode character (e.g. ``'\\N{EM DASH}'``)."
msgstr ""
"新增了``'\\N{name}'`` 轉義序列。與字串文字一樣，它擴充為指定的 Unicode 字元（"
"例如 ``'\\N{EM DASH}'``）。"

#: ../../library/re.rst:667
msgid "Module Contents"
msgstr "模組內容"

#: ../../library/re.rst:669
#, fuzzy
msgid ""
"The module defines several functions, constants, and an exception. Some of "
"the functions are simplified versions of the full featured methods for "
"compiled regular expressions.  Most non-trivial applications always use the "
"compiled form."
msgstr "該模組定義了幾個函式、常數和一個例外。一些函式是用於編譯正則表達式的全功能方"
"法的簡化版本。大多數重要的應用程式總是使用編譯形式。"

#: ../../library/re.rst:676
#, fuzzy
msgid "Flags"
msgstr "旗幟"

#: ../../library/re.rst:678
#, fuzzy
msgid ""
"Flag constants are now instances of :class:`RegexFlag`, which is a subclass "
"of :class:`enum.IntFlag`."
msgstr "旗標常數現在是 RegexFlag 的實例，它是 enum.IntFlag 的子類別。"

#: ../../library/re.rst:685
#, fuzzy
msgid ""
"An :class:`enum.IntFlag` class containing the regex options listed below."
msgstr "一個 :class:`enum.IntFlag` 類，包含下面列出的正則表達式選項。"

#: ../../library/re.rst:687
#, fuzzy
msgid "- added to ``__all__``"
msgstr "- 新增到``__all__``"

#: ../../library/re.rst:692
#, fuzzy
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and "
"``\\S`` perform ASCII-only matching instead of full Unicode matching.  This "
"is only meaningful for Unicode patterns, and is ignored for byte patterns. "
"Corresponds to the inline flag ``(?a)``."
msgstr ""
"製作``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` 和``\\S`` "
"執行僅 ASCII 匹配而不是完整的 Unicode 匹配。這僅對 Unicode "
"模式有意義，對位元組模式將被忽略。對應於內聯旗標 ``(?a)``。"

#: ../../library/re.rst:697
#, fuzzy
msgid ""
"Note that for backward compatibility, the :const:`re.U` flag still exists "
"(as well as its synonym :const:`re.UNICODE` and its embedded counterpart ``(?"
"u)``), but these are redundant in Python 3 since matches are Unicode by "
"default for strings (and Unicode matching isn't allowed for bytes)."
msgstr ""
"請注意，為了向後相容，:const:`re.U` 旗標仍然存在（以及它的同義詞 :const:`re."
"UNICODE` 及其嵌入式對應物 ``(?u)``），但這些都是多餘的在 Python 3 中，"
"因為預設情況下字串匹配是 Unicode（位元組不允許匹配 Unicode）。"

#: ../../library/re.rst:706
#, fuzzy
msgid ""
"Display debug information about compiled expression. No corresponding inline "
"flag."
msgstr "顯示有關已編譯表達式的除錯資訊。沒有相應的內聯旗標。"

#: ../../library/re.rst:713
#, fuzzy
msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will also "
"match lowercase letters.  Full Unicode matching (such as ``Ü`` matching "
"``ü``) also works unless the :const:`re.ASCII` flag is used to disable non-"
"ASCII matches.  The current locale does not change the effect of this flag "
"unless the :const:`re.LOCALE` flag is also used. Corresponds to the inline "
"flag ``(?i)``."
msgstr ""
"執行不區分大小寫的匹配；像“[A-Z]”這樣的表達式也將匹配小寫字母。完整的 "
"Unicode 匹配（例如 ``Ü`` 匹配 ``ü``）也可以工作，除非使用 :const:`re.ASCII` "
"旗標來禁用非 ASCII "
"匹配。當前語言環境不會更改此旗標的效果，除非還使用了 :const:`re.LOCALE` "
"旗標。對應於內聯旗標``(?i)``。"

#: ../../library/re.rst:720
#, fuzzy
msgid ""
"Note that when the Unicode patterns ``[a-z]`` or ``[A-Z]`` are used in "
"combination with the :const:`IGNORECASE` flag, they will match the 52 ASCII "
"letters and 4 additional non-ASCII letters: 'İ' (U+0130, Latin capital "
"letter I with dot above), 'ı' (U+0131, Latin small letter dotless i), "
"'ſ' (U+017F, Latin small letter long s) and 'K' (U+212A, Kelvin sign). If "
"the :const:`ASCII` flag is used, only letters 'a' to 'z' and 'A' to 'Z' are "
"matched."
msgstr ""
"請注意，當 Unicode 模式``[a-z]`` 或``[A-Z]`` 與 :const:`IGNORECASE` "
"旗標結合使用時，它們將匹配 52 個 ASCII 字母和 4 個額外的非 ASCII 字母： "
"'İ'（U+0130，上面帶點的拉丁文大寫字母 I）、'ı'（U+0131，拉丁文小寫字母無點 "
"i）、'ſ'（U+017F，拉丁文小寫字母長 s）和 'K' （U+212A，開爾文符號）。"
"如果使用 :const:`ASCII` 旗標，則僅匹配字母 ``a``到 ``z``和 ``A``到 ``Z``。"

#: ../../library/re.rst:731
#, fuzzy
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale.  This flag can be used only with bytes "
"patterns.  The use of this flag is discouraged as the locale mechanism is "
"very unreliable, it only handles one \"culture\" at a time, and it only "
"works with 8-bit locales.  Unicode matching is already enabled by default in "
"Python 3 for Unicode (str) patterns, and it is able to handle different "
"locales/languages. Corresponds to the inline flag ``(?L)``."
msgstr ""
"使 ``\\w``、``\\W``、``\\b``、``\\B`` 和不區分大小寫的匹配依賴於當前的語言環"
"境。此旗標只能與位元組模式一起使用。不鼓勵使用此旗標，因為語言環境機制非常不"
"可靠，它一次只能處理一種“文化”，並且只適用於 8 位語言環境。對於 Unicode (str)"
" 模式，Python 3 中已經預設啟用了 Unicode "
"匹配，並且它能夠處理不同的區域設定/語言。對應於內聯旗標``(?L)``。"

#: ../../library/re.rst:740
#, fuzzy
msgid ""
":const:`re.LOCALE` can be used only with bytes patterns and is not "
"compatible with :const:`re.ASCII`."
msgstr ":const:`re.LOCALE` 只能與位元組模式一起使用，並且與 :const:`re.ASCII` "
"不相容。"

#: ../../library/re.rst:744
#, fuzzy
msgid ""
"Compiled regular expression objects with the :const:`re.LOCALE` flag no "
"longer depend on the locale at compile time.  Only the locale at matching "
"time affects the result of matching."
msgstr "使用 :const:`re.LOCALE` 旗標編譯的正則表達式對像在編譯時不再依賴於語言環境。"
"只有匹配時的語言環境會影響匹配結果。"

#: ../../library/re.rst:753
#, fuzzy
msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of "
"the string and at the beginning of each line (immediately following each "
"newline); and the pattern character ``'$'`` matches at the end of the string "
"and at the end of each line (immediately preceding each newline).  By "
"default, ``'^'`` matches only at the beginning of the string, and ``'$'`` "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string. Corresponds to the inline flag ``(?m)``."
msgstr ""
"指定時，模式字元 ``'^'`` 匹配字串的開頭和每行的開頭（緊跟在每個換行符之後）；"
"模式字元 ``'$'`` "
"匹配字串的末尾和每行的末尾（緊接在每個換行符之前）。預設情況下，``'^'`` "
"僅匹配字串的開頭，``'$'`` 僅匹配字串的末尾和緊接在字串末尾的換行符（如果有）"
"之前。對應於內聯旗標``(?m)``。"

#: ../../library/re.rst:763
#, fuzzy
msgid ""
"Indicates no flag being applied, the value is ``0``.  This flag may be used "
"as a default value for a function keyword argument or as a base value that "
"will be conditionally ORed with other flags.  Example of use as a default "
"value::"
msgstr "表示沒有應用旗標，值為 ``0``。此旗標可用作函式關鍵字參數的預設值，或用作將與其他"
"旗標進行條件或運算的基值。用作預設值的示例::"

#: ../../library/re.rst:776
#, fuzzy
msgid ""
"Make the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline. "
"Corresponds to the inline flag ``(?s)``."
msgstr ""
"使 ``'.'`` 特殊字元完全匹配任何字元，包括換行符；沒有這個旗標，``'.'`` "
"將匹配任何 * 除了 * 換行符。對應於內聯旗標 ``(?s)``。"

#: ../../library/re.rst:786
#, fuzzy
msgid ""
"This flag allows you to write regular expressions that look nicer and are "
"more readable by allowing you to visually separate logical sections of the "
"pattern and add comments. Whitespace within the pattern is ignored, except "
"when in a character class, or when preceded by an unescaped backslash, or "
"within tokens like ``*?``, ``(?:`` or ``(?P<...>``. For example, ``(? :`` "
"and ``* ?`` are not allowed. When a line contains a ``#`` that is not in a "
"character class and is not preceded by an unescaped backslash, all "
"characters from the leftmost such ``#`` through the end of the line are "
"ignored."
msgstr ""
"這個旗標允許您通過允許您在視覺上分隔模式的邏輯部分並新增註釋來編寫看起來更好"
"、更易讀的正則表達式。模式中的空格將被忽略，除非在字元類中，或者前面有未轉義"
"的反斜杠，或者在像``*?``、``(?:`` 或``(?P<... >``。例如，``(? :`` 和 ``* ?`` "
"是不允許的。當一行包含不在字元類中且前面沒有未轉義的反斜杠的 ``#`` "
"時，從最左邊的 ``#``到行尾的所有字元都將被忽略。"

#: ../../library/re.rst:796
#, fuzzy
msgid ""
"This means that the two following regular expression objects that match a "
"decimal number are functionally equal::"
msgstr "這意味著以下兩個匹配十進位數的正則表達式對像在功能上是相等的："

#: ../../library/re.rst:804
#, fuzzy
msgid "Corresponds to the inline flag ``(?x)``."
msgstr "對應於內聯旗標``(?x)``。"

#: ../../library/re.rst:808
#, fuzzy
msgid "Functions"
msgstr "功能"

#: ../../library/re.rst:812
#, fuzzy
msgid ""
"Compile a regular expression pattern into a :ref:`regular expression object "
"<re-objects>`, which can be used for matching using its :func:`~Pattern."
"match`, :func:`~Pattern.search` and other methods, described below."
msgstr ""
"將一個正則表達式模式編譯成一個正則表達式物件<re-"
"objects>`，可以使用它的 :func:`~Pattern.match`, :func:`~Pattern.search` "
"和其他的進行匹配方法，詳見下文。"

#: ../../library/re.rst:817
#, fuzzy
msgid ""
"The expression's behaviour can be modified by specifying a *flags* value. "
"Values can be any of the following variables, combined using bitwise OR (the "
"``|`` operator)."
msgstr "可以通過指定 *flags* "
"值來修改表達式的行為。值可以是以下任何變數，使用按位或（``|`` 運算符）組合。"

#: ../../library/re.rst:821
#, fuzzy
msgid "The sequence ::"
msgstr "序列 ：："

#: ../../library/re.rst:826
msgid "is equivalent to ::"
msgstr ""
"等價於：\n"
"\n"
"::"

#: ../../library/re.rst:830
#, fuzzy
msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used several "
"times in a single program."
msgstr "但是當表達式將在單個程式中多次使用時，使用 :func:`re.compile` "
"並保存生成的正則表達式對像以供重用會更有效。"

#: ../../library/re.rst:836
#, fuzzy
msgid ""
"The compiled versions of the most recent patterns passed to :func:`re."
"compile` and the module-level matching functions are cached, so programs "
"that use only a few regular expressions at a time needn't worry about "
"compiling regular expressions."
msgstr ""
"傳遞給 :func:`re.compile` 的最新模式的編譯版本和模組級匹配函式被快取，因此一"
"次只使用幾個正則表達式的程式不必擔心編譯正則表達式。"

#: ../../library/re.rst:844
#, fuzzy
msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a corresponding :ref:"
"`match object <match-objects>`.  Return ``None`` if no position in the "
"string matches the pattern; note that this is different from finding a zero-"
"length match at some point in the string."
msgstr ""
"掃描 *string* 尋找正則表達式 *pattern* 產生匹配的第一個位置，並回傳相應的 "
":ref:`match object <match-objects>`。如果字串中沒有位置與模式匹配，則回傳“Non"
"e”；請注意，這與在字串中的某個點查找零長度匹配不同。"

#: ../../library/re.rst:853
#, fuzzy
msgid ""
"If zero or more characters at the beginning of *string* match the regular "
"expression *pattern*, return a corresponding :ref:`match object <match-"
"objects>`.  Return ``None`` if the string does not match the pattern; note "
"that this is different from a zero-length match."
msgstr ""
"如果 *string* 開頭的零個或多個字元與正則表達式 *pattern* 匹配，則回傳相應的 "
":ref:`match object <match-objects>`。如果字串與模式不匹配，則回傳 "
"``None``；請注意，這與零長度匹配不同。"

#: ../../library/re.rst:858
#, fuzzy
msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only match "
"at the beginning of the string and not at the beginning of each line."
msgstr "請注意，即使在 :const:`MULTILINE` 模式下，:func:`re.match` "
"也只會匹配字串的開頭，而不是每行的開頭。"

#: ../../library/re.rst:861
#, fuzzy
msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr ""
"如果你想在 *string* 中的任何地方找到匹配項，請改用 :func:`search`（另請參閱 "
":ref:`search-vs-match`）。"

#: ../../library/re.rst:867
#, fuzzy
msgid ""
"If the whole *string* matches the regular expression *pattern*, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""
"如果整個 *string* 與正則表達式 *pattern* 匹配，則回傳相應的 :ref:`match "
"object <match-objects>`。如果字串與模式不匹配，則回傳 "
"``None``；請注意，這與零長度匹配不同。"

#: ../../library/re.rst:877
#, fuzzy
msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses "
"are used in *pattern*, then the text of all groups in the pattern are also "
"returned as part of the resulting list. If *maxsplit* is nonzero, at most "
"*maxsplit* splits occur, and the remainder of the string is returned as the "
"final element of the list. ::"
msgstr ""
"根據 *pattern* 的出現拆分 *string*。如果在 *pattern* "
"中使用捕獲括號，則模式中所有組的文本也作為結果列表的一部分回傳。如果 "
"*maxsplit* 不為零，則最多發生 *maxsplit* "
"拆分，字串的其餘部分作為列表的最後一個元素回傳。 ::"

#: ../../library/re.rst:892
#, fuzzy
msgid ""
"If there are capturing groups in the separator and it matches at the start "
"of the string, the result will start with an empty string.  The same holds "
"for the end of the string::"
msgstr "如果分隔符中有捕獲組並且它在字串的開頭匹配，則結果將以空字串開頭。這同樣適用"
"於字串的結尾::"

#: ../../library/re.rst:899
#, fuzzy
msgid ""
"That way, separator components are always found at the same relative indices "
"within the result list."
msgstr "這樣，分隔符組件總是在結果列表中的相同相對索引處找到。"

#: ../../library/re.rst:902
#, fuzzy
msgid ""
"Empty matches for the pattern split the string only when not adjacent to a "
"previous empty match."
msgstr "模式的空匹配僅在不與前一個空匹配相鄰時才拆分字串。"

#: ../../library/re.rst:912 ../../library/re.rst:1002 ../../library/re.rst:1031
#, fuzzy
msgid "Added the optional flags argument."
msgstr "新增了可選的旗標參數。"

#: ../../library/re.rst:915
#, fuzzy
msgid ""
"Added support of splitting on a pattern that could match an empty string."
msgstr "新增了對可以匹配空字串的模式拆分的支援。"

#: ../../library/re.rst:921
#, fuzzy
msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of "
"strings or tuples.  The *string* is scanned left-to-right, and matches are "
"returned in the order found.  Empty matches are included in the result."
msgstr ""
"回傳 *string* 中 *pattern* 的所有非重疊匹配項，作為字串列表或元組。 *string* "
"從左到右掃描，並按找到的順序回傳匹配項。結果中包含空匹配項。"

#: ../../library/re.rst:925
#, fuzzy
msgid ""
"The result depends on the number of capturing groups in the pattern. If "
"there are no groups, return a list of strings matching the whole pattern.  "
"If there is exactly one group, return a list of strings matching that "
"group.  If multiple groups are present, return a list of tuples of strings "
"matching the groups.  Non-capturing groups do not affect the form of the "
"result."
msgstr ""
"結果取決於模式中捕獲組的數量。如果沒有組，則回傳匹配整個模式的字串列表。如果"
"只有一個組，則回傳匹配該組的字串列表。如果存在多個組，則回傳與組匹配的字串元"
"組列表。非捕獲組不影響結果的形式。"

#: ../../library/re.rst:937 ../../library/re.rst:948
#, fuzzy
msgid "Non-empty matches can now start just after a previous empty match."
msgstr "非空匹配現在可以在上一個空匹配之後開始。"

#: ../../library/re.rst:943
#, fuzzy
msgid ""
"Return an :term:`iterator` yielding :ref:`match objects <match-objects>` "
"over all non-overlapping matches for the RE *pattern* in *string*.  The "
"*string* is scanned left-to-right, and matches are returned in the order "
"found.  Empty matches are included in the result."
msgstr ""
"在 *string* 中的 RE *pattern* 的所有非重疊匹配上回傳一個疊代器產生匹配物件 "
"<match-objects>`。 *string* "
"從左到右掃描，並按找到的順序回傳匹配項。結果中包含空匹配項。"

#: ../../library/re.rst:954
#, fuzzy
msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a string "
"or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, "
"``\\r`` is converted to a carriage return, and so forth.  Unknown escapes of "
"ASCII letters are reserved for future use and treated as errors.  Other "
"unknown escapes such as ``\\&`` are left alone. Backreferences, such as "
"``\\6``, are replaced with the substring matched by group 6 in the pattern. "
"For example::"
msgstr ""
"回傳通過替換 *repl* 替換 *string* 中最左邊不重疊的 *pattern* "
"獲得的字串。如果未找到模式，則回傳 *string* 不變。 *repl* "
"可以是字串或函式；如果它是一個字串，則處理其中的任何反斜杠轉義。也就是說，``"
"\\n"
"`` 被轉換為單個換行符，``\\r`` 被轉換為回車符，等等。未知的 ASCII "
"字母轉義保留供將來使用並被視為錯誤。其他未知的轉義符，如 ``\\&`` "
"被單獨留下。反向引用，例如 ``\\6``，被模式中第 6 組匹配的子字串替換。例如：："

#: ../../library/re.rst:970
#, fuzzy
msgid ""
"If *repl* is a function, it is called for every non-overlapping occurrence "
"of *pattern*.  The function takes a single :ref:`match object <match-"
"objects>` argument, and returns the replacement string.  For example::"
msgstr ""
"如果 *repl* 是一個函式，它會在每個非重疊的 *pattern* 出現時被呼叫。"
"該函式採用單個 :ref:`match object <match-objects>` "
"參數，並回傳替換字串。例如：："

#: ../../library/re.rst:982
#, fuzzy
msgid "The pattern may be a string or a :ref:`pattern object <re-objects>`."
msgstr "模式可以是字串或 :ref:`pattern object <re-objects>`。"

#: ../../library/re.rst:984
#, fuzzy
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  If omitted or zero, "
"all occurrences will be replaced. Empty matches for the pattern are replaced "
"only when not adjacent to a previous empty match, so ``sub('x*', '-', "
"'abxd')`` returns ``'-a-b--d-'``."
msgstr ""
"可選參數 *count* 是要替換的模式出現的最大次數； *count* 必須是"
"非負整數。如果省略或為零，所有出現的地方都將被替換。該模式的空匹配僅在與前一"
"個空匹配不相鄰時才被替換，因此 ``sub('x*', '-', 'abxd')`` 回傳 ``'-a-b--d-'``"
" ."

#: ../../library/re.rst:992
#, fuzzy
msgid ""
"In string-type *repl* arguments, in addition to the character escapes and "
"backreferences described above, ``\\g<name>`` will use the substring matched "
"by the group named ``name``, as defined by the ``(?P<name>...)`` syntax. "
"``\\g<number>`` uses the corresponding group number; ``\\g<2>`` is therefore "
"equivalent to ``\\2``, but isn't ambiguous in a replacement such as "
"``\\g<2>0``.  ``\\20`` would be interpreted as a reference to group 20, not "
"a reference to group 2 followed by the literal character ``'0'``.  The "
"backreference ``\\g<0>`` substitutes in the entire substring matched by the "
"RE."
msgstr ""
"在字串型別 *repl* 參數中，除了上述字元轉義和反向引用之外，``\\g<name>`` "
"將使用與名為 ``name`` 的組匹配的子字串，如 `` (?P<name>...)`` 語法。 ``\\g"
"<number>`` 使用相應的組號；因此，``\\g<2>`` 等同於``\\2``，但在諸如``\\g"
"<2>0`` 的替換中並沒有歧義。 ``\\20`` 將被解釋為對組 20 的引用，"
"而不是對後跟文字字元 ``'0'`` 的組 2 的引用。反向引用 ``\\g<0>`` 替換 RE "
"匹配的整個子字串。"

#: ../../library/re.rst:1005 ../../library/re.rst:1034
#: ../../library/re.rst:1268
#, fuzzy
msgid "Unmatched groups are replaced with an empty string."
msgstr "不匹配的組將替換為空字串。"

#: ../../library/re.rst:1008
#, fuzzy
msgid ""
"Unknown escapes in *pattern* consisting of ``'\\'`` and an ASCII letter now "
"are errors."
msgstr "由``'\\'`` 和 ASCII 字母組成的 *pattern* 中的未知轉義現在是錯誤。"

#: ../../library/re.rst:1012
#, fuzzy
msgid ""
"Unknown escapes in *repl* consisting of ``'\\'`` and an ASCII letter now are "
"errors."
msgstr "*repl* 中由 ``'\\'`` 和 ASCII 字母組成的未知轉義現在是錯誤。"

#: ../../library/re.rst:1016
#, fuzzy
msgid ""
"Empty matches for the pattern are replaced when adjacent to a previous non-"
"empty match."
msgstr "當與先前的非空匹配相鄰時，模式的空匹配將被替換。"

#: ../../library/re.rst:1028
#, fuzzy
msgid ""
"Perform the same operation as :func:`sub`, but return a tuple ``(new_string, "
"number_of_subs_made)``."
msgstr "執行與 :func:`sub` 相同的操作，但回傳一個元組 ``(new_string, "
"number_of_subs_made)``。"

#: ../../library/re.rst:1040
#, fuzzy
msgid ""
"Escape special characters in *pattern*. This is useful if you want to match "
"an arbitrary literal string that may have regular expression metacharacters "
"in it.  For example::"
msgstr "轉義 *pattern* 中的特殊字元。如果您想匹配其中可能包含正則表達式元字元的任意文"
"字字串，這將很有用。例如：："

#: ../../library/re.rst:1055
#, fuzzy
msgid ""
"This function must not be used for the replacement string in :func:`sub` "
"and :func:`subn`, only backslashes should be escaped.  For example::"
msgstr "此函式不得用於 :func:`sub` 和 :func:`subn` "
"中的替換字串，只能轉義反斜杠。例如：："

#: ../../library/re.rst:1063
#, fuzzy
msgid "The ``'_'`` character is no longer escaped."
msgstr "``'_'`` 字元不再被轉義。"

#: ../../library/re.rst:1066
#, fuzzy
msgid ""
"Only characters that can have special meaning in a regular expression are "
"escaped. As a result, ``'!'``, ``'\"'``, ``'%'``, ``\"'\"``, ``','``, "
"``'/'``, ``':'``, ``';'``, ``'<'``, ``'='``, ``'>'``, ``'@'``, and ``\"`\"`` "
"are no longer escaped."
msgstr ""
"只有在正則表達式中具有特殊含義的字元才會被轉義。結果，``\\'!\\'``, ``\\'\"\\"
"'``, ``\\'%\\'``, ``\"\\'\"``, ``\\',\\'``, ``\\'/\\'` `, ``\\':\\'``, ``\\';"
"\\'``, ``\\'<\\'``, ``\\'=\\'``, ``\\'>\\'``, ``\\'@\\'``,和 ``\"`\"`` "
"不再轉義。"

#: ../../library/re.rst:1075
#, fuzzy
msgid "Clear the regular expression cache."
msgstr "清除正則表達式快取。"

#: ../../library/re.rst:1079
#, fuzzy
msgid "Exceptions"
msgstr "例外情況"

#: ../../library/re.rst:1083
#, fuzzy
msgid ""
"Exception raised when a string passed to one of the functions here is not a "
"valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or "
"matching.  It is never an error if a string contains no match for a "
"pattern.  The error instance has the following additional attributes:"
msgstr ""
"當傳遞給此處函式之一的字串不是有效的正則表達式（例如，它可能包含不匹配的括號"
"）或在編譯或匹配期間發生其他錯誤時引發例外。如果字串不包含模式的匹配項，則永"
"遠不會出錯。錯誤實例具有以下附加屬性："

#: ../../library/re.rst:1091
#, fuzzy
msgid "The unformatted error message."
msgstr "未格式化的錯誤消息。"

#: ../../library/re.rst:1095
#, fuzzy
msgid "The regular expression pattern."
msgstr "正則表達式模式。"

#: ../../library/re.rst:1099
#, fuzzy
msgid "The index in *pattern* where compilation failed (may be ``None``)."
msgstr "*pattern* 中編譯失敗的索引（可能是 ``None``）。"

#: ../../library/re.rst:1103
#, fuzzy
msgid "The line corresponding to *pos* (may be ``None``)."
msgstr "*pos*對應的行（可能是``None``）。"

#: ../../library/re.rst:1107
#, fuzzy
msgid "The column corresponding to *pos* (may be ``None``)."
msgstr "*pos*對應的列（可能是``None``）。"

#: ../../library/re.rst:1109
msgid "Added additional attributes."
msgstr "新增額外屬性。"

#: ../../library/re.rst:1115
#, fuzzy
msgid "Regular Expression Objects"
msgstr "正則表達式物件"

#: ../../library/re.rst:1117
#, fuzzy
msgid ""
"Compiled regular expression objects support the following methods and "
"attributes:"
msgstr "已編譯的正則表達式物件支援以下方法和屬性："

#: ../../library/re.rst:1122
#, fuzzy
msgid ""
"Scan through *string* looking for the first location where this regular "
"expression produces a match, and return a corresponding :ref:`match object "
"<match-objects>`.  Return ``None`` if no position in the string matches the "
"pattern; note that this is different from finding a zero-length match at "
"some point in the string."
msgstr ""
"掃描 *string* 尋找此正則表達式產生匹配的第一個位置，並回傳相應的 :ref:`match "
"object <match-objects>`。如果字串中沒有位置與模式匹配，則回傳 ``None``；請注意，"
"這與在字串中的某個點查找零長度匹配不同。"

#: ../../library/re.rst:1128
#, fuzzy
msgid ""
"The optional second parameter *pos* gives an index in the string where the "
"search is to start; it defaults to ``0``.  This is not completely equivalent "
"to slicing the string; the ``'^'`` pattern character matches at the real "
"beginning of the string and at positions just after a newline, but not "
"necessarily at the index where the search is to start."
msgstr ""
"可選的第二個參數 *pos* "
"給出字串中搜索開始的索引；它預設為 ``0``。這並不完全等同於對字串進行切片； "
"``'^'`` "
"模式字元在字串的真正開頭和換行符之後的位置匹配，但不一定在搜索開始的索引處。"

#: ../../library/re.rst:1134
#, fuzzy
msgid ""
"The optional parameter *endpos* limits how far the string will be searched; "
"it will be as if the string is *endpos* characters long, so only the "
"characters from *pos* to ``endpos - 1`` will be searched for a match.  If "
"*endpos* is less than *pos*, no match will be found; otherwise, if *rx* is a "
"compiled regular expression object, ``rx.search(string, 0, 50)`` is "
"equivalent to ``rx.search(string[:50], 0)``. ::"
msgstr ""
"可選參數 *endpos* 限制搜索字串的距離；就好像字串是 *endpos* 個字元一樣長，"
"因此只會搜索從 *pos* 到 ``endpos - 1`` 的字元以進行匹配。如果*endpos* "
"小於*pos*，將找不到匹配項；否則，如果 *rx* 是編譯的正則表達式物件，``rx."
"search(string, 0, 50)`` 等價於 ``rx.search(string[:50], 0)``。 ::"

#: ../../library/re.rst:1149
#, fuzzy
msgid ""
"If zero or more characters at the *beginning* of *string* match this regular "
"expression, return a corresponding :ref:`match object <match-objects>`. "
"Return ``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""
"如果 *string* 的 *beginning* 處有零個或多個字元匹配此正則表達式，"
"則回傳相應的匹配物件 <match-objects>`。如果字串與模式不匹配，則回傳 "
"``None``；請注意，這與零長度匹配不同。"

#: ../../library/re.rst:1154 ../../library/re.rst:1172
#, fuzzy
msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for the :"
"meth:`~Pattern.search` method. ::"
msgstr "可選的 *pos* 和 *endpos* 參數與 :meth:`~Pattern.search` 方法具有相同的含義。 "
"::"

#: ../../library/re.rst:1162
#, fuzzy
msgid ""
"If you want to locate a match anywhere in *string*, use :meth:`~Pattern."
"search` instead (see also :ref:`search-vs-match`)."
msgstr ""
"如果你想在 *string* 中的任何地方找到匹配項，請改用 :meth:`~Pattern.search`（"
"另請參閱 :ref:`search-vs-match`）。"

#: ../../library/re.rst:1168
#, fuzzy
msgid ""
"If the whole *string* matches this regular expression, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""
"如果整個 *string* 匹配此正則表達式，則回傳相應的 :ref:`match object <match-"
"objects>`。如果字串與模式不匹配，則回傳 "
"``None``；請注意，這與零長度匹配不同。"

#: ../../library/re.rst:1186
#, fuzzy
msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr "與 :func:`split` 函式相同，使用編譯模式。"

#: ../../library/re.rst:1191
#, fuzzy
msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
"類似於 :func:`findall` 函式，使用編譯模式，但也接受可選的 *pos* 和 *endpos* "
"參數來限制搜索區域，如 :meth:`search`。"

#: ../../library/re.rst:1198
#, fuzzy
msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
"類似於 :func:`finditer` 函式，使用編譯模式，但也接受可選的 *pos* 和 *endpos* "
"參數來限制搜索區域，如 :meth:`search`。"

#: ../../library/re.rst:1205
#, fuzzy
msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr "與 :func:`sub` 函式相同，使用編譯模式。"

#: ../../library/re.rst:1210
#, fuzzy
msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr "與 :func:`subn` 函式相同，使用編譯模式。"

#: ../../library/re.rst:1215
#, fuzzy
msgid ""
"The regex matching flags.  This is a combination of the flags given to :func:"
"`.compile`, any ``(?...)`` inline flags in the pattern, and implicit flags "
"such as :data:`UNICODE` if the pattern is a Unicode string."
msgstr ""
"正則表達式匹配旗標。這是給 :func:`.compile` 的旗標的組合，模式中的任何 "
"``(?...)`` 內聯旗標，如果模式是一個隱式旗標，例如 :data:`UNICODE` Unicode "
"字串。"

#: ../../library/re.rst:1222
#, fuzzy
msgid "The number of capturing groups in the pattern."
msgstr "模式中捕獲組的數量。"

#: ../../library/re.rst:1227
#, fuzzy
msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used in "
"the pattern."
msgstr "將由``(?P<id>)`` 定義的任何符號組名稱映射到組編號的字典。如果模式中沒有使用符"
"號組，則字典為空。"

#: ../../library/re.rst:1234
#, fuzzy
msgid "The pattern string from which the pattern object was compiled."
msgstr "從中編譯模式物件的模式字串。"

#: ../../library/re.rst:1237
#, fuzzy
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Compiled "
"regular expression objects are considered atomic."
msgstr "新增了對 :func:`copy.copy` 和 :func:`copy.deepcopy` "
"的支援。編譯的正則表達式對像被認為是原子的。"

#: ../../library/re.rst:1245
#, fuzzy
msgid "Match Objects"
msgstr "匹配物件"

#: ../../library/re.rst:1247
#, fuzzy
msgid ""
"Match objects always have a boolean value of ``True``. Since :meth:`~Pattern."
"match` and :meth:`~Pattern.search` return ``None`` when there is no match, "
"you can test whether there was a match with a simple ``if`` statement::"
msgstr ""
"匹配物件的布爾值始終為 ``True``。由於 :meth:`~Pattern.match` 和 :meth:`~Pattern."
"search` 在沒有匹配時回傳 ``None``，您可以使用簡單的 ``if`` "
"語句測試是否有匹配： :"

#: ../../library/re.rst:1256
#, fuzzy
msgid "Match objects support the following methods and attributes:"
msgstr "匹配物件支援以下方法和屬性："

#: ../../library/re.rst:1261
#, fuzzy
msgid ""
"Return the string obtained by doing backslash substitution on the template "
"string *template*, as done by the :meth:`~Pattern.sub` method. Escapes such "
"as ``\\n`` are converted to the appropriate characters, and numeric "
"backreferences (``\\1``, ``\\2``) and named backreferences (``\\g<1>``, "
"``\\g<name>``) are replaced by the contents of the corresponding group."
msgstr ""
"回傳通過對模板字串 *template* 進行反斜杠替換而獲得的字串，如 :meth:`~Pattern."
"sub` 方法所做的那樣。諸如``\\n"
"`` 之類的轉義符被轉換為適當的字元，數字反向引用（``\\1``、``\\2"
"``）和命名反向引用（``\\g<1>``、`` \\g<name>``) 被相應組的內容替換。"

#: ../../library/re.rst:1273
#, fuzzy
msgid ""
"Returns one or more subgroups of the match.  If there is a single argument, "
"the result is a single string; if there are multiple arguments, the result "
"is a tuple with one item per argument. Without arguments, *group1* defaults "
"to zero (the whole match is returned). If a *groupN* argument is zero, the "
"corresponding return value is the entire matching string; if it is in the "
"inclusive range [1..99], it is the string matching the corresponding "
"parenthesized group.  If a group number is negative or larger than the "
"number of groups defined in the pattern, an :exc:`IndexError` exception is "
"raised. If a group is contained in a part of the pattern that did not match, "
"the corresponding result is ``None``. If a group is contained in a part of "
"the pattern that matched multiple times, the last match is returned. ::"
msgstr ""
"回傳匹配的一個或多個子組。如果只有一個參數，則結果是一個字串；如果有多個參數"
"，則結果是一個元組，每個參數一個項目。沒有參數，*group1* "
"預設為零（回傳整個匹配項）。如果 *groupN* "
"參數為零，則相應的回傳值是整個匹配字串；如果在 [1..99] "
"範圍內，則為對應括號組匹配的字串。如果組號為負數或大於模式中定義的組數，"
"則會引發 IndexError 例外。如果組包含在不匹配的模式部分中，則相應的結果為 ``None`` "
"。如果某個組包含在多次匹配的模式部分中，則回傳最後一個匹配項。 ::"

#: ../../library/re.rst:1295
#, fuzzy
msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN* "
"arguments may also be strings identifying groups by their group name.  If a "
"string argument is not used as a group name in the pattern, an :exc:"
"`IndexError` exception is raised."
msgstr ""
"如果正則表達式使用 ``(?P<name>...)`` 語法，*groupN* "
"參數也可以是通過組名標識組的字串。如果字串參數未用作模式中的組名，則會引發 "
":exc:`IndexError` 例外。"

#: ../../library/re.rst:1300
#, fuzzy
msgid "A moderately complicated example::"
msgstr "一個中等複雜的例子::"

#: ../../library/re.rst:1308
#, fuzzy
msgid "Named groups can also be referred to by their index::"
msgstr "命名組也可以通過它們的索引來引用::"

#: ../../library/re.rst:1315
#, fuzzy
msgid "If a group matches multiple times, only the last match is accessible::"
msgstr "如果一個組匹配多次，則只有最後一個匹配是可訪問的::"

#: ../../library/re.rst:1324
#, fuzzy
msgid ""
"This is identical to ``m.group(g)``.  This allows easier access to an "
"individual group from a match::"
msgstr "這與“m.group(g)”相同。這樣可以更輕鬆地從匹配中訪問單個組::"

#: ../../library/re.rst:1335
#, fuzzy
msgid "Named groups are supported as well::"
msgstr "也支援命名組::"

#: ../../library/re.rst:1348
#, fuzzy
msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used for "
"groups that did not participate in the match; it defaults to ``None``."
msgstr "回傳一個包含匹配的所有子組的元組，從 1 到模式中有多少組。 *default* "
"參數用於未參加比賽的組；它預設為 ``None`` 。"

#: ../../library/re.rst:1352 ../../library/re.rst:1577
msgid "For example::"
msgstr ""
"舉例來說：\n"
"\n"
"::"

#: ../../library/re.rst:1358
#, fuzzy
msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given::"
msgstr "如果我們將小數位及其後的所有內容設為可選，則並非所有組都可以參加比賽。"
"除非給出 *default* 參數，否則這些組將預設為 ``None`` ："

#: ../../library/re.rst:1371
#, fuzzy
msgid ""
"Return a dictionary containing all the *named* subgroups of the match, keyed "
"by the subgroup name.  The *default* argument is used for groups that did "
"not participate in the match; it defaults to ``None``.  For example::"
msgstr "回傳包含匹配的所有*命名*子組的字典，以子組名稱為鍵。 *default* "
"參數用於未參加比賽的組；它預設為 ``None`` 。例如：："

#: ../../library/re.rst:1383
#, fuzzy
msgid ""
"Return the indices of the start and end of the substring matched by *group*; "
"*group* defaults to zero (meaning the whole matched substring). Return "
"``-1`` if *group* exists but did not contribute to the match.  For a match "
"object *m*, and a group *g* that did contribute to the match, the substring "
"matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""
"回傳與 *group* 匹配的子串的開始和結束的索引； *group* "
"預設為零（表示整個匹配的子字串）。如果 *group* 存在但沒有參與匹配，則回傳 "
"``-1``。對於一個匹配物件 *m* 和一個對匹配有貢獻的組 *g* ，由組 *g* "
"匹配的子串（等價於``m.group(g)``）是::"

#: ../../library/re.rst:1391
#, fuzzy
msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched "
"a null string.  For example, after ``m = re.search('b(c?)', 'cba')``, ``m."
"start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are both "
"2, and ``m.start(2)`` raises an :exc:`IndexError` exception."
msgstr ""
"請注意，如果 *group* 匹配空字串，``m.start(group)`` 將等於 ``m."
"end(group)``。例如，在``m = re.search('b(c?)', 'cba')`` 之後，``m.start(0)`` "
"為 1，``m.end(0)``是 2，``m.start(1)`` 和 ``m.end(1)`` 都是 2，並且 ``m."
"start(2)`` 引發了一個 :exc:`IndexError` 例外。"

#: ../../library/re.rst:1396
#, fuzzy
msgid "An example that will remove *remove_this* from email addresses::"
msgstr "一個將從電子郵件地址中刪除 *remove_this* 的示例::"

#: ../../library/re.rst:1406
#, fuzzy
msgid ""
"For a match *m*, return the 2-tuple ``(m.start(group), m.end(group))``. Note "
"that if *group* did not contribute to the match, this is ``(-1, -1)``. "
"*group* defaults to zero, the entire match."
msgstr ""
"對於匹配*m*，回傳二元組``(m.start(group), m.end(group))``。請注意，如果 "
"*group* 對匹配沒有貢獻，則為 ``(-1, -1)``。 *group* 預設為零，整個匹配。"

#: ../../library/re.rst:1413
#, fuzzy
msgid ""
"The value of *pos* which was passed to the :meth:`~Pattern.search` or :meth:"
"`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This is the "
"index into the string at which the RE engine started looking for a match."
msgstr ""
"*pos* 的值傳遞給正則表達式物件 <re-objects> 的 :meth:`~Pattern.search` 或 "
":meth:`~Pattern.match` 方法。這是 RE 引擎開始尋找匹配項的字串的索引。"

#: ../../library/re.rst:1420
#, fuzzy
msgid ""
"The value of *endpos* which was passed to the :meth:`~Pattern.search` or :"
"meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This is "
"the index into the string beyond which the RE engine will not go."
msgstr ""
"*endpos* 的值傳遞給正則表達式物件 <re-objects> 的 :meth:`~Pattern.search` 或 "
":meth:`~Pattern.match` 方法。這是字串的索引，RE 引擎不會超出該索引。"

#: ../../library/re.rst:1427
#, fuzzy
msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, ``((a)"
"(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to the string "
"``'ab'``, while the expression ``(a)(b)`` will have ``lastindex == 2``, if "
"applied to the same string."
msgstr ""
"最後匹配的捕獲組的整數索引，如果根本沒有匹配的組，則為 ``None``。例如，表達式``("
"a)b``、``((a)(b))`` 和``((ab))`` 將具有``lastindex == 1`` 如果應用於字串 "
"``'ab'``，而表達式 ``(a)(b)`` 將具有 ``lastindex == "
"2``，如果應用於相同的字串。"

#: ../../library/re.rst:1436
#, fuzzy
msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr "最後匹配的捕獲組的名稱，如果該組沒有名稱，或者根本沒有匹配的組，則為 "
"``None``。"

#: ../../library/re.rst:1442
#, fuzzy
msgid ""
"The :ref:`regular expression object <re-objects>` whose :meth:`~Pattern."
"match` or :meth:`~Pattern.search` method produced this match instance."
msgstr ""
":ref:`正則表達式物件 <re-objects>` 的 :meth:`~Pattern.match` 或 "
":meth:`~Pattern.search` 方法產生了這個匹配實例。"

#: ../../library/re.rst:1448
#, fuzzy
msgid "The string passed to :meth:`~Pattern.match` or :meth:`~Pattern.search`."
msgstr "傳遞給 :meth:`~Pattern.match` 或 :meth:`~Pattern.search` 的字串。"

#: ../../library/re.rst:1451
#, fuzzy
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Match objects "
"are considered atomic."
msgstr "新增了對 :func:`copy.copy` 和 :func:`copy.deepcopy` "
"的支援。匹配對像被認為是原子的。"

#: ../../library/re.rst:1459
#, fuzzy
msgid "Regular Expression Examples"
msgstr "正則表達式示例"

#: ../../library/re.rst:1463
#, fuzzy
msgid "Checking for a Pair"
msgstr "檢查一對"

#: ../../library/re.rst:1465
#, fuzzy
msgid ""
"In this example, we'll use the following helper function to display match "
"objects a little more gracefully::"
msgstr "在此示例中，我們將使用以下輔助函式來更優雅地顯示匹配物件："

#: ../../library/re.rst:1473
#, fuzzy
msgid ""
"Suppose you are writing a poker program where a player's hand is represented "
"as a 5-character string with each character representing a card, \"a\" for "
"ace, \"k\" for king, \"q\" for queen, \"j\" for jack, \"t\" for 10, and "
"\"2\" through \"9\" representing the card with that value."
msgstr ""
"假設您正在編寫一個撲克程式，其中玩家的手牌表示為 5 "
"個字元的字串，每個字元代表一張牌， ``a``代表 A， ``k``代表 K， ``q``代表 Q， ``j``代表 "
"J，  ``t``代表 10， ``2``到 ``9``代表具有該值的牌。"

#: ../../library/re.rst:1478
#, fuzzy
msgid "To see if a given string is a valid hand, one could do the following::"
msgstr "要查看給定字串是否有效，可以執行以下操作："

#: ../../library/re.rst:1488
#, fuzzy
msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same valued "
"cards. To match this with a regular expression, one could use backreferences "
"as such::"
msgstr "最後一手牌， ``727ak``，包含一對或兩張相同價值的牌。要將其與正則表達式相匹配，可"
"以像這樣使用反向引用::"

#: ../../library/re.rst:1498
#, fuzzy
msgid ""
"To find out what card the pair consists of, one could use the :meth:`~Match."
"group` method of the match object in the following manner::"
msgstr "要找出這對由哪張牌組成，可以按以下方式使用匹配物件的 :meth:`~Match.group` "
"方法："

#: ../../library/re.rst:1517
#, fuzzy
msgid "Simulating scanf()"
msgstr "模擬 scanf()"

#: ../../library/re.rst:1521
#, fuzzy
msgid ""
"Python does not currently have an equivalent to :c:func:`scanf`.  Regular "
"expressions are generally more powerful, though also more verbose, than :c:"
"func:`scanf` format strings.  The table below offers some more-or-less "
"equivalent mappings between :c:func:`scanf` format tokens and regular "
"expressions."
msgstr ""
"Python 目前沒有與 :c:func:`scanf` 的等價物。正則表達式通常比 :c:func:`scanf` "
"格式字串更強大，但也更冗長。下表提供了 :c:func:`scanf` "
"格式標記和正則表達式之間的一些或多或少的等效映射。"

#: ../../library/re.rst:1528
#, fuzzy
msgid ":c:func:`scanf` Token"
msgstr ":c:func:`scanf` 令牌"

#: ../../library/re.rst:1528
#, fuzzy
msgid "Regular Expression"
msgstr "正則表達式"

#: ../../library/re.rst:1530
msgid "``%c``"
msgstr "``%c``"

#: ../../library/re.rst:1532
msgid "``%5c``"
msgstr "``%5c``"

#: ../../library/re.rst:1532
msgid "``.{5}``"
msgstr "``.{5}``"

#: ../../library/re.rst:1534
msgid "``%d``"
msgstr "``%d``"

#: ../../library/re.rst:1534
msgid "``[-+]?\\d+``"
msgstr "``[-+]?\\d+``"

#: ../../library/re.rst:1536
msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr "``%e``, ``%E``, ``%f``, ``%g``"

#: ../../library/re.rst:1536
msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"

#: ../../library/re.rst:1538
msgid "``%i``"
msgstr "``%i``"

#: ../../library/re.rst:1538
msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"

#: ../../library/re.rst:1540
msgid "``%o``"
msgstr "``%o``"

#: ../../library/re.rst:1540
msgid "``[-+]?[0-7]+``"
msgstr "``[-+]?[0-7]+``"

#: ../../library/re.rst:1542
msgid "``%s``"
msgstr "``%s``"

#: ../../library/re.rst:1542
msgid "``\\S+``"
msgstr "``\\S+``"

#: ../../library/re.rst:1544
msgid "``%u``"
msgstr "``%u``"

#: ../../library/re.rst:1544
msgid "``\\d+``"
msgstr "``\\d+``"

#: ../../library/re.rst:1546
msgid "``%x``, ``%X``"
msgstr "``%x``\\ 、\\ ``%X``"

#: ../../library/re.rst:1546
msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr "``[-+]?(0[xX])?[\\dA-Fa-f]+``"

#: ../../library/re.rst:1549
#, fuzzy
msgid "To extract the filename and numbers from a string like ::"
msgstr "從像 :: 這樣的字串中提取文件名和數字"

#: ../../library/re.rst:1553
#, fuzzy
msgid "you would use a :c:func:`scanf` format like ::"
msgstr "您將使用 :c:func:`scanf` 格式，例如 ::"

#: ../../library/re.rst:1557
#, fuzzy
msgid "The equivalent regular expression would be ::"
msgstr "等效的正則表達式是 ::"

#: ../../library/re.rst:1565
#, fuzzy
msgid "search() vs. match()"
msgstr "search() 與 match()"

#: ../../library/re.rst:1569
#, fuzzy
msgid ""
"Python offers different primitive operations based on regular expressions:"
msgstr "Python 提供了基於正則表達式的不同原始操作："

#: ../../library/re.rst:1571
#, fuzzy
msgid ":func:`re.match` checks for a match only at the beginning of the string"
msgstr ":func:`re.match` 僅檢查字串開頭的匹配項"

#: ../../library/re.rst:1572
#, fuzzy
msgid ""
":func:`re.search` checks for a match anywhere in the string (this is what "
"Perl does by default)"
msgstr ":func:`re.search` 檢查字串中任何位置的匹配項（這是 Perl 預設執行的操作）"

#: ../../library/re.rst:1574
#, fuzzy
msgid ":func:`re.fullmatch` checks for entire string to be a match"
msgstr ":func:`re.fullmatch` 檢查整個字串是否匹配"

#: ../../library/re.rst:1586
#, fuzzy
msgid ""
"Regular expressions beginning with ``'^'`` can be used with :func:`search` "
"to restrict the match at the beginning of the string::"
msgstr "以 ``'^'`` 開頭的正則表達式可以與 :func:`search` "
"一起使用來限製字串開頭的匹配::"

#: ../../library/re.rst:1594
#, fuzzy
msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches at "
"the beginning of the string, whereas using :func:`search` with a regular "
"expression beginning with ``'^'`` will match at the beginning of each "
"line. ::"
msgstr ""
"但是請注意，在 :const:`MULTILINE` 模式下，:func:`match` 僅匹配字串的開頭，"
"而使用 :func:`search` 和以 ``'^'`` 開頭的正則表達式將匹配於每行的開頭。 ::"

#: ../../library/re.rst:1604
#, fuzzy
msgid "Making a Phonebook"
msgstr "製作電話簿"

#: ../../library/re.rst:1606
#, fuzzy
msgid ""
":func:`split` splits a string into a list delimited by the passed pattern.  "
"The method is invaluable for converting textual data into data structures "
"that can be easily read and modified by Python as demonstrated in the "
"following example that creates a phonebook."
msgstr ""
":func:`split` 將字串拆分為由傳遞的模式分隔的列表。"
"該方法對於將文本資料轉換為可由 Python 輕鬆讀取和修改的資料結構非常有用，"
"如以下建立電話簿的示例所示。"

#: ../../library/re.rst:1611
#, fuzzy
msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax"
msgstr "首先，這是輸入。通常它可能來自文件，這裡我們使用三引號字串語法"

#: ../../library/re.rst:1624
#, fuzzy
msgid ""
"The entries are separated by one or more newlines. Now we convert the string "
"into a list with each nonempty line having its own entry:"
msgstr "這些條目由一個或多個換行符分隔。現在我們將字串轉換為一個列表，每個非空行都有"
"自己的條目："

#: ../../library/re.rst:1637
#, fuzzy
msgid ""
"Finally, split each entry into a list with first name, last name, telephone "
"number, and address.  We use the ``maxsplit`` parameter of :func:`split` "
"because the address has spaces, our splitting pattern, in it:"
msgstr ""
"最後，將每個條目分成一個列表，其中包含名字、姓氏、電話號碼和地址。我們使用 "
":func:`split` 的 ``maxsplit`` 參數，因為地址中有空格，即我們的拆分模式："

#: ../../library/re.rst:1650
#, fuzzy
msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does "
"not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""
"``:?`` 模式匹配姓氏後面的冒號，因此它不會出現在結果列表中。使用 ``4`` 的 "
"``maxsplit``，我們可以將門牌號與街道名稱分開："

#: ../../library/re.rst:1665
#, fuzzy
msgid "Text Munging"
msgstr "文本修改"

#: ../../library/re.rst:1667
#, fuzzy
msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a "
"function to \"munge\" text, or randomize the order of all the characters in "
"each word of a sentence except for the first and last characters::"
msgstr ""
":func:`sub` 用字串或函式的結果替換每次出現的模式。這個例子演示了使用 "
":func:`sub` 和一個函式來 ``munge``文本，或者隨機化句子中每個單詞中除第一個和最後"
"一個字元之外的所有字元的順序::"

#: ../../library/re.rst:1684
#, fuzzy
msgid "Finding all Adverbs"
msgstr "查找所有副詞"

#: ../../library/re.rst:1686
#, fuzzy
msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the first "
"one as :func:`search` does.  For example, if a writer wanted to find all of "
"the adverbs in some text, they might use :func:`findall` in the following "
"manner::"
msgstr ""
":func:`findall` 匹配*所有*出現的模式，而不是像 :func:`search` "
"那樣只匹配第一個。例如，如果作者想在某些文本中找到所有副詞，"
"他們可能會按以下方式使用 :func:`findall`::"

#: ../../library/re.rst:1697
#, fuzzy
msgid "Finding all Adverbs and their Positions"
msgstr "查找所有副詞及其位置"

#: ../../library/re.rst:1699
#, fuzzy
msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides :ref:`match objects "
"<match-objects>` instead of strings.  Continuing with the previous example, "
"if a writer wanted to find all of the adverbs *and their positions* in some "
"text, they would use :func:`finditer` in the following manner::"
msgstr ""
"如果需要有關模式的所有匹配項的更多資訊而不是匹配的文本，finditer 會很有用，"
"因為它提供了匹配物件 <match-objects> 而不是字串。繼續前面的示例，"
"如果作者想在某些文本中找到所有副詞*及其位置*，"
"他們將按以下方式使用 :func:`finditer`::"

#: ../../library/re.rst:1713
#, fuzzy
msgid "Raw String Notation"
msgstr "原始字串表示法"

#: ../../library/re.rst:1715
#, fuzzy
msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  Without "
"it, every backslash (``'\\'``) in a regular expression would have to be "
"prefixed with another one to escape it.  For example, the two following "
"lines of code are functionally identical::"
msgstr ""
"原始字串符號 (``r\"text\"``) 使正則表達式保持正常。沒有它，"
"正則表達式中的每個反斜杠 (``\\'\\\\'``) "
"都必須加上另一個前綴才能轉義。例如，以下兩行程式碼在功能上是相同的："

#: ../../library/re.rst:1725
#, fuzzy
msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``.  "
"Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical::"
msgstr ""
"當想要匹配文字反斜杠時，必須在正則表達式中對其進行轉義。使用原始字串表示法，"
"這意味著 ``r\"\\\\\"``。如果沒有原始字串表示法，則必須使用 ``\"\\\\\\\\\""
"``，使以下程式碼行在功能上完全相同："

#: ../../library/re.rst:1737
#, fuzzy
msgid "Writing a Tokenizer"
msgstr "編寫分詞器"

#: ../../library/re.rst:1739
#, fuzzy
msgid ""
"A `tokenizer or scanner <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"analyzes a string to categorize groups of characters.  This is a useful "
"first step in writing a compiler or interpreter."
msgstr ""
"`分詞器或掃描器 <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"分析字串以對字元組進行分類。這是編寫編譯器或直譯器的有用的第一步。"

#: ../../library/re.rst:1743
#, fuzzy
msgid ""
"The text categories are specified with regular expressions.  The technique "
"is to combine those into a single master regular expression and to loop over "
"successive matches::"
msgstr "文本類別使用正則表達式指定。該技術是將它們組合成一個主正則表達式並循環連續匹"
"配::"

#: ../../library/re.rst:1799
#, fuzzy
msgid "The tokenizer produces the following output::"
msgstr "分詞器產生以下輸出："

#: ../../library/re.rst:1822
#, fuzzy
msgid ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. The third edition of the book no longer covers Python at all, but the "
"first edition covered writing good regular expression patterns in great "
"detail."
msgstr ""
"弗里德爾，杰弗裡。掌握正則表達式。第 3 版，O'Reilly Media，2009 年。"
"本書的第三版不再涵蓋 "
"Python，但第一版非常詳細地介紹了編寫良好的正則表達式模式。"
