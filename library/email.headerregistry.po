# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-31 08:13+0000\n"
"PO-Revision-Date: 2018-05-23 14:44+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/email.headerregistry.rst:2
msgid ":mod:`email.headerregistry`: Custom Header Objects"
msgstr ":mod:`email.headerregistry`: 自訂標頭物件"

#: ../../library/email.headerregistry.rst:10
msgid "**Source code:** :source:`Lib/email/headerregistry.py`"
msgstr "**原始碼：**\\ :source:`Lib/email/headerregistry.py`"

#: ../../library/email.headerregistry.rst:14
msgid "[1]_"
msgstr "[1]_"

#: ../../library/email.headerregistry.rst:16
#, fuzzy
msgid ""
"Headers are represented by customized subclasses of :class:`str`.  The "
"particular class used to represent a given header is determined by the :attr:"
"`~email.policy.EmailPolicy.header_factory` of the :mod:`~email.policy` in "
"effect when the headers are created.  This section documents the particular "
"``header_factory`` implemented by the email package for handling :RFC:`5322` "
"compliant email messages, which not only provides customized header objects "
"for various header types, but also provides an extension mechanism for "
"applications to add their own custom header types."
msgstr ""
"標頭由 :class:`str` "
"的自定義子類別表示。用於表示給定標頭的特定類由建立標頭時生效的 :attr:`~email."
"policy.EmailPolicy.header_factory` 確定。"
"本節記錄了由電子郵件包實作的用於處理符合 :RFC:`5322` "
"標準的電子郵件消息的特定 ``header_factory``，它不僅為各種標頭型別提供自定義標"
"頭物件，而且還為應用程式提供擴充機制以新增它們的自己的自定義標頭型別。"

#: ../../library/email.headerregistry.rst:25
#, fuzzy
msgid ""
"When using any of the policy objects derived from :data:`~email.policy."
"EmailPolicy`, all headers are produced by :class:`.HeaderRegistry` and have :"
"class:`.BaseHeader` as their last base class.  Each header class has an "
"additional base class that is determined by the type of the header.  For "
"example, many headers have the class :class:`.UnstructuredHeader` as their "
"other base class.  The specialized second class for a header is determined "
"by the name of the header, using a lookup table stored in the :class:`."
"HeaderRegistry`.  All of this is managed transparently for the typical "
"application program, but interfaces are provided for modifying the default "
"behavior for use by more complex applications."
msgstr ""
"當使用從 :data:`~email.policy.EmailPolicy` 派生的任何策略物件時，"
"所有標頭都由 :class:`.HeaderRegistry` 生成，並以 :class:`.BaseHeader` 作為它"
"們的最後一個基底類別。每個標頭類都有一個附加的基底類別，該基底類別由標頭的型"
"別決定。例如，許多標頭都將類 :class:`.UnstructuredHeader` "
"作為它們的其他基底類別。標頭的專用第二類由標頭的名稱確定，使用儲存在 :class:`"
".HeaderRegistry` 中的查找表。所有這些對於典型的應用程式都是透明管理的，但是提"
"供了介面來修改預設行為以供更複雜的應用程式使用。"

#: ../../library/email.headerregistry.rst:36
#, fuzzy
msgid ""
"The sections below first document the header base classes and their "
"attributes, followed by the API for modifying the behavior of :class:`."
"HeaderRegistry`, and finally the support classes used to represent the data "
"parsed from structured headers."
msgstr ""
"下面的部分首先記錄標頭基底類別及其屬性，然後是用於修改 :class:`."
"HeaderRegistry` 行為的 API，最後是用於表示從結構化標頭解析的資料的支援類。"

#: ../../library/email.headerregistry.rst:44
#, fuzzy
msgid ""
"*name* and *value* are passed to ``BaseHeader`` from the :attr:`~email."
"policy.EmailPolicy.header_factory` call.  The string value of any header "
"object is the *value* fully decoded to unicode."
msgstr ""
"*name* 和 *value* 從 :attr:`~email.policy.EmailPolicy.header_factory` "
"呼叫傳遞給 ``BaseHeader``。任何標頭物件的字串值都是完全解碼為 unicode 的 "
"*value*。"

#: ../../library/email.headerregistry.rst:48
#, fuzzy
msgid "This base class defines the following read-only properties:"
msgstr "該基底類別定義了以下只讀屬性："

#: ../../library/email.headerregistry.rst:53
#, fuzzy
msgid ""
"The name of the header (the portion of the field before the ':').  This is "
"exactly the value passed in the :attr:`~email.policy.EmailPolicy."
"header_factory` call for *name*; that is, case is preserved."
msgstr ""
"標頭的名稱（ ``:``之前的欄位部分）。這正是在 :attr:`~email.policy.EmailPolicy."
"header_factory` 呼叫 *name* 時傳遞的值；也就是說，保留大小寫。"

#: ../../library/email.headerregistry.rst:61
#, fuzzy
msgid ""
"A tuple of :exc:`~email.errors.HeaderDefect` instances reporting any RFC "
"compliance problems found during parsing.  The email package tries to be "
"complete about detecting compliance issues.  See the :mod:`~email.errors` "
"module for a discussion of the types of defects that may be reported."
msgstr ""
"一組 :exc:`~email.errors.HeaderDefect` 實例報告解析期間發現的任何 RFC "
"合規性問題。電子郵件包試圖完成檢測合規性問題。有關可能報告的缺陷型別的討論，"
"請參閱 :mod:`~email.errors` 模組。"

#: ../../library/email.headerregistry.rst:69
#, fuzzy
msgid ""
"The maximum number of headers of this type that can have the same ``name``.  "
"A value of ``None`` means unlimited.  The ``BaseHeader`` value for this "
"attribute is ``None``; it is expected that specialized header classes will "
"override this value as needed."
msgstr ""
"可以具有相同“名稱”的此類標頭的最大數量。值 ``None`` 表示無限制。此屬性的 "
"``BaseHeader`` 值為 ``None``；預計專用頭類將根據需要覆蓋此值。"

#: ../../library/email.headerregistry.rst:74
#, fuzzy
msgid ""
"``BaseHeader`` also provides the following method, which is called by the "
"email library code and should not in general be called by application "
"programs:"
msgstr "``BaseHeader`` "
"還提供了以下方法，由電子郵件庫程式碼呼叫，一般不應由應用程式呼叫："

#: ../../library/email.headerregistry.rst:80
#, fuzzy
msgid ""
"Return a string containing :attr:`~email.policy.Policy.linesep` characters "
"as required to correctly fold the header according to *policy*.  A :attr:"
"`~email.policy.Policy.cte_type` of ``8bit`` will be treated as if it were "
"``7bit``, since headers may not contain arbitrary binary data.  If :attr:"
"`~email.policy.EmailPolicy.utf8` is ``False``, non-ASCII data will be :rfc:"
"`2047` encoded."
msgstr ""
"回傳包含 :attr:`~email.policy.Policy.linesep` 字元的字串，以根據 *policy* "
"正確折疊標題。 ``8bit`` 的 :attr:`~email.policy.Policy.cte_type` 將被視為 "
"``7bit``，因為標頭可能不包含任意二進位資料。如果 :attr:`~email.policy."
"EmailPolicy.utf8` 為 ``False``，非 ASCII 資料將被 :rfc:`2047` 編碼。"

#: ../../library/email.headerregistry.rst:88
#, fuzzy
msgid ""
"``BaseHeader`` by itself cannot be used to create a header object.  It "
"defines a protocol that each specialized header cooperates with in order to "
"produce the header object.  Specifically, ``BaseHeader`` requires that the "
"specialized class provide a :func:`classmethod` named ``parse``.  This "
"method is called as follows::"
msgstr ""
"``BaseHeader`` 本身不能用於建立標題物件。它定義了一個協定，每個專門的標頭都與"
"之合作以生成標頭物件。具體來說，``BaseHeader`` 要求專門的類提供一個名為 "
"``parse`` 的 :func:`classmethod`。此方法呼叫如下："

#: ../../library/email.headerregistry.rst:96
#, fuzzy
msgid ""
"``kwds`` is a dictionary containing one pre-initialized key, ``defects``. "
"``defects`` is an empty list.  The parse method should append any detected "
"defects to this list.  On return, the ``kwds`` dictionary *must* contain "
"values for at least the keys ``decoded`` and ``defects``.  ``decoded`` "
"should be the string value for the header (that is, the header value fully "
"decoded to unicode).  The parse method should assume that *string* may "
"contain content-transfer-encoded parts, but should correctly handle all "
"valid unicode characters as well so that it can parse un-encoded header "
"values."
msgstr ""
"``kwds`` 是一本包含一個預初始化鍵的字典，``defects``。 ``defects`` "
"是一個空列表。 parse "
"方法應該將任何檢測到的缺陷附加到這個列表中。回傳時，``kwds`` "
"字典*必須*至少包含鍵``decoded`` 和``defects`` 的值。 ``decoded`` "
"應該是標頭的字串值（即，標頭值完全解碼為 unicode）。 parse 方法應該假定 "
"*string* 可能包含內容傳輸編碼的部分，但也應該正確處理所有有效的 unicode "
"字元，以便它可以解析未編碼的標頭值。"

#: ../../library/email.headerregistry.rst:105
#, fuzzy
msgid ""
"``BaseHeader``'s ``__new__`` then creates the header instance, and calls its "
"``init`` method.  The specialized class only needs to provide an ``init`` "
"method if it wishes to set additional attributes beyond those provided by "
"``BaseHeader`` itself.  Such an ``init`` method should look like this::"
msgstr ""
"``BaseHeader`` 的 `__new__`` 然後建立標頭實例，並呼叫它的 ``init`` 方法。"
"專用類只需要提供一個 init 方法，如果它希望設定超出 BaseHeader "
"本身提供的屬性的附加屬性。這樣的 ``init`` 方法應該如下所示："

#: ../../library/email.headerregistry.rst:114
#, fuzzy
msgid ""
"That is, anything extra that the specialized class puts in to the ``kwds`` "
"dictionary should be removed and handled, and the remaining contents of "
"``kw`` (and ``args``) passed to the ``BaseHeader`` ``init`` method."
msgstr ""
"也就是說，應該刪除和處理專用類放入``kwds``字典的任何額外內容，並將``kw``（和`"
"`args``）的剩餘內容傳遞給``BaseHeader` ```init`` 方法。"

#: ../../library/email.headerregistry.rst:121
#, fuzzy
msgid ""
"An \"unstructured\" header is the default type of header in :rfc:`5322`. Any "
"header that does not have a specified syntax is treated as unstructured.  "
"The classic example of an unstructured header is the :mailheader:`Subject` "
"header."
msgstr ""
"“非結構化”標頭是 :rfc:`5322` "
"中的預設標頭型別。任何沒有指定語法的標頭都被視為非結構化的。"
"非結構化標頭的典型示例是 :mailheader:`Subject` 標頭。"

#: ../../library/email.headerregistry.rst:126
#, fuzzy
msgid ""
"In :rfc:`5322`, an unstructured header is a run of arbitrary text in the "
"ASCII character set.  :rfc:`2047`, however, has an :rfc:`5322` compatible "
"mechanism for encoding non-ASCII text as ASCII characters within a header "
"value.  When a *value* containing encoded words is passed to the "
"constructor, the ``UnstructuredHeader`` parser converts such encoded words "
"into unicode, following the :rfc:`2047` rules for unstructured text.  The "
"parser uses heuristics to attempt to decode certain non-compliant encoded "
"words.  Defects are registered in such cases, as well as defects for issues "
"such as invalid characters within the encoded words or the non-encoded text."
msgstr ""
"在 :rfc:`5322` 中，非結構化標頭是 ASCII "
"字元集中任意文本的運行。然而，:rfc:`2047` 有一個與 :rfc:`5322` 相容的機制，"
"用於將非 ASCII 文本編碼為標頭值中的 ASCII 字元。當包含編碼詞的 *value* "
"傳遞給構造函式時，``UnstructuredHeader`` 解析器將此類編碼詞轉換為 unicode，"
"遵循非結構化文本的 :rfc:`2047` 規則。解析器使用試探法來嘗試解碼某些不相容的編"
"碼字。在這種情況下會記錄缺陷，以及編碼字或非編碼文本中的無效字元等問題的缺陷"
"。"

#: ../../library/email.headerregistry.rst:136
#, fuzzy
msgid "This header type provides no additional attributes."
msgstr "此標頭型別不提供其他屬性。"

#: ../../library/email.headerregistry.rst:141
#, fuzzy
msgid ""
":rfc:`5322` specifies a very specific format for dates within email headers. "
"The ``DateHeader`` parser recognizes that date format, as well as "
"recognizing a number of variant forms that are sometimes found \"in the wild"
"\"."
msgstr ""
":rfc:`5322` 為電子郵件標頭中的日期指定了一種非常具體的格式。 ``DateHeader`` "
"解析器識別該日期格式，以及識別有時在“野外”發現的許多變體形式。"

#: ../../library/email.headerregistry.rst:146
#: ../../library/email.headerregistry.rst:188
#, fuzzy
msgid "This header type provides the following additional attributes:"
msgstr "此標頭型別提供以下附加屬性："

#: ../../library/email.headerregistry.rst:150
#, fuzzy
msgid ""
"If the header value can be recognized as a valid date of one form or "
"another, this attribute will contain a :class:`~datetime.datetime` instance "
"representing that date.  If the timezone of the input date is specified as "
"``-0000`` (indicating it is in UTC but contains no information about the "
"source timezone), then :attr:`.datetime` will be a naive :class:`~datetime."
"datetime`.  If a specific timezone offset is found (including ``+0000``), "
"then :attr:`.datetime` will contain an aware ``datetime`` that uses :class:"
"`datetime.timezone` to record the timezone offset."
msgstr ""
"如果標頭值可以被識別為一種或另一種形式的有效日期，"
"則此屬性將包含一個表示該日期的 :class:`~datetime.datetime` 實例。"
"如果輸入日期的時區指定為 ``-0000``（表明它是 UTC 但不包含有關源時區的資訊），"
"那麼 :attr:`.datetime` 將是一個天真的 :class:`~datetime ."
"日期時間`。如果找到特定的時區偏移量（包括 ``+0000``），則 :attr:`.datetime` "
"將包含一個已知的 ``datetime``，它使用 :class:`datetime.timezone` "
"來記錄時區偏移量。"

#: ../../library/email.headerregistry.rst:160
#, fuzzy
msgid ""
"The ``decoded`` value of the header is determined by formatting the "
"``datetime`` according to the :rfc:`5322` rules; that is, it is set to::"
msgstr "根據 :rfc:`5322` 規則，通過格式化 ``datetime`` 來確定標頭的 ``decoded`` "
"值；也就是說，它被設定為::"

#: ../../library/email.headerregistry.rst:165
#, fuzzy
msgid ""
"When creating a ``DateHeader``, *value* may be :class:`~datetime.datetime` "
"instance.  This means, for example, that the following code is valid and "
"does what one would expect::"
msgstr ""
"建立``DateHeader`` 時，*value* 可能是 :class:`~datetime.datetime` "
"實例。這意味著，例如，以下程式碼是有效的，並且可以滿足人們的期望："

#: ../../library/email.headerregistry.rst:171
#, fuzzy
msgid ""
"Because this is a naive ``datetime`` it will be interpreted as a UTC "
"timestamp, and the resulting value will have a timezone of ``-0000``.  Much "
"more useful is to use the :func:`~email.utils.localtime` function from the :"
"mod:`~email.utils` module::"
msgstr ""
"因為這是一個天真的“日期時間”，它將被解釋為 UTC "
"時間戳，並且結果值的時區為 ``-0000``。更有用的是使用 :mod:`~email.utils` "
"模組中的 :func:`~email.utils.localtime` 函式::"

#: ../../library/email.headerregistry.rst:178
#, fuzzy
msgid ""
"This example sets the date header to the current time and date using the "
"current timezone offset."
msgstr "此示例使用當前時區偏移量將日期標頭設定為當前時間和日期。"

#: ../../library/email.headerregistry.rst:184
#, fuzzy
msgid ""
"Address headers are one of the most complex structured header types. The "
"``AddressHeader`` class provides a generic interface to any address header."
msgstr "地址標頭是最複雜的結構化標頭型別之一。 ``AddressHeader`` "
"類為任何地址標頭提供通用介面。"

#: ../../library/email.headerregistry.rst:193
#, fuzzy
msgid ""
"A tuple of :class:`.Group` objects encoding the addresses and groups found "
"in the header value.  Addresses that are not part of a group are represented "
"in this list as single-address ``Groups`` whose :attr:`~.Group.display_name` "
"is ``None``."
msgstr ""
":class:`.Group` 物件的元組，對標頭值中找到的地址和組進行編碼。不屬於組的地址"
"在此列表中表示為單地址 ``組``，其 :attr:`~.Group.display_name` 為 ``None`` 。"

#: ../../library/email.headerregistry.rst:201
#, fuzzy
msgid ""
"A tuple of :class:`.Address` objects encoding all of the individual "
"addresses from the header value.  If the header value contains any groups, "
"the individual addresses from the group are included in the list at the "
"point where the group occurs in the value (that is, the list of addresses is "
"\"flattened\" into a one dimensional list)."
msgstr ""
":class:`.Address` 物件的元組，對標頭值中的所有單個地址進行編碼。如果標頭值包"
"含任何組，則組中的各個地址將包含在列表中該組出現在值中的位置（即，地址列表被“"
"展平”為一維列表）。"

#: ../../library/email.headerregistry.rst:207
#, fuzzy
msgid ""
"The ``decoded`` value of the header will have all encoded words decoded to "
"unicode.  :class:`~encodings.idna` encoded domain names are also decoded to "
"unicode.  The ``decoded`` value is set by :ref:`joining <meth-str-join>` "
"the :class:`str` value of the elements of the ``groups`` attribute with ``', "
"'``."
msgstr ""
"header 的 ``decoded`` 值會將所有編碼字解碼為 unicode。 :class:`~encodings."
"idna` 編碼的域名也被解碼為 unicode。 ``decoded`` 值由 :ref:`joining <meth-"
"str-join>` ``groups`` 屬性的元素的 :class:`str` 值與 ``', '`` 設定."

#: ../../library/email.headerregistry.rst:213
#, fuzzy
msgid ""
"A list of :class:`.Address` and :class:`.Group` objects in any combination "
"may be used to set the value of an address header.  ``Group`` objects whose "
"``display_name`` is ``None`` will be interpreted as single addresses, which "
"allows an address list to be copied with groups intact by using the list "
"obtained from the ``groups`` attribute of the source header."
msgstr ""
"任意組合的 :class:`.Address` 和 :class:`.Group` "
"物件列表可用於設定地址標頭的值。 ``display_name`` 為``None`` 的``Group`` "
"物件將被解釋為單個地址，這允許使用從源標題。"

#: ../../library/email.headerregistry.rst:222
#, fuzzy
msgid ""
"A subclass of :class:`.AddressHeader` that adds one additional attribute:"
msgstr "新增一個附加屬性的 :class:`.AddressHeader` 的子類別："

#: ../../library/email.headerregistry.rst:228
#, fuzzy
msgid ""
"The single address encoded by the header value.  If the header value "
"actually contains more than one address (which would be a violation of the "
"RFC under the default :mod:`~email.policy`), accessing this attribute will "
"result in a :exc:`ValueError`."
msgstr ""
"由標頭值編碼的單個地址。如果標頭值實際上包含多個地址（這將違反預設 "
":mod:`~email.policy` 下的 RFC），訪問此屬性將導致 :exc:`ValueError`。"

#: ../../library/email.headerregistry.rst:234
#, fuzzy
msgid ""
"Many of the above classes also have a ``Unique`` variant (for example, "
"``UniqueUnstructuredHeader``).  The only difference is that in the "
"``Unique`` variant, :attr:`~.BaseHeader.max_count` is set to 1."
msgstr ""
"上面的許多類也有一個 ``Unique`` 變體（例如，``UniqueUnstructuredHeader``）。"
"唯一的區別是在 ``Unique`` 變體中，:attr:`~.BaseHeader.max_count` 設定為 1。"

#: ../../library/email.headerregistry.rst:241
#, fuzzy
msgid ""
"There is really only one valid value for the :mailheader:`MIME-Version` "
"header, and that is ``1.0``.  For future proofing, this header class "
"supports other valid version numbers.  If a version number has a valid value "
"per :rfc:`2045`, then the header object will have non-``None`` values for "
"the following attributes:"
msgstr ""
":mailheader:`MIME-Version` 標頭實際上只有一個有效值，那就是 ``1."
"0``。為了將來驗證，此標頭類支援其他有效版本號。如果版本號根據 :rfc:`2045` "
"具有有效值，則標頭物件將具有以下屬性的非 ``None`` 值："

#: ../../library/email.headerregistry.rst:249
#, fuzzy
msgid ""
"The version number as a string, with any whitespace and/or comments removed."
msgstr "作為字串的版本號，刪除了任何空格和/或註釋。"

#: ../../library/email.headerregistry.rst:254
#, fuzzy
msgid "The major version number as an integer"
msgstr "整數形式的主版本號"

#: ../../library/email.headerregistry.rst:258
#, fuzzy
msgid "The minor version number as an integer"
msgstr "整數形式的次要版本號"

#: ../../library/email.headerregistry.rst:263
#, fuzzy
msgid ""
"MIME headers all start with the prefix 'Content-'.  Each specific header has "
"a certain value, described under the class for that header.  Some can also "
"take a list of supplemental parameters, which have a common format. This "
"class serves as a base for all the MIME headers that take parameters."
msgstr ""
"MIME 標頭都以前綴 ``Content-`` 開頭。每個特定的標頭都有特定的值，在該標頭的類下進"
"行了描述。有些還可以採用具有通用格式的補充參數列表。此類用作所有帶參數的 "
"MIME 標頭的基礎。"

#: ../../library/email.headerregistry.rst:270
#, fuzzy
msgid "A dictionary mapping parameter names to parameter values."
msgstr "將參數名稱映射到參數值的字典。"

#: ../../library/email.headerregistry.rst:275
#, fuzzy
msgid ""
"A :class:`ParameterizedMIMEHeader` class that handles the :mailheader:"
"`Content-Type` header."
msgstr "處理 :mailheader:`Content-Type` 標頭的 :class:`ParameterizedMIMEHeader` 類。"

#: ../../library/email.headerregistry.rst:280
#, fuzzy
msgid "The content type string, in the form ``maintype/subtype``."
msgstr "內容型別字串，格式為“maintype/subtype”。"

#: ../../library/email.headerregistry.rst:289
#, fuzzy
msgid ""
"A :class:`ParameterizedMIMEHeader` class that handles the :mailheader:"
"`Content-Disposition` header."
msgstr ""
"處理 :mailheader:`Content-Disposition` 標頭的 "
":class:`ParameterizedMIMEHeader` 類。"

#: ../../library/email.headerregistry.rst:294
#, fuzzy
msgid "``inline`` and ``attachment`` are the only valid values in common use."
msgstr "``inline`` 和 ``attachment`` 是常用的唯一有效值。"

#: ../../library/email.headerregistry.rst:299
#, fuzzy
msgid "Handles the :mailheader:`Content-Transfer-Encoding` header."
msgstr "處理 :mailheader:`Content-Transfer-Encoding` 標頭。"

#: ../../library/email.headerregistry.rst:303
#, fuzzy
msgid ""
"Valid values are ``7bit``, ``8bit``, ``base64``, and ``quoted-printable``.  "
"See :rfc:`2045` for more information."
msgstr "有效值為 ``7bit``、 ``8bit``、 ``base64``和“quoted-"
"printable”。有關更多資訊，請參見 :rfc:`2045`。"

#: ../../library/email.headerregistry.rst:312
#, fuzzy
msgid ""
"This is the factory used by :class:`~email.policy.EmailPolicy` by default. "
"``HeaderRegistry`` builds the class used to create a header instance "
"dynamically, using *base_class* and a specialized class retrieved from a "
"registry that it holds.  When a given header name does not appear in the "
"registry, the class specified by *default_class* is used as the specialized "
"class.  When *use_default_map* is ``True`` (the default), the standard "
"mapping of header names to classes is copied in to the registry during "
"initialization.  *base_class* is always the last class in the generated "
"class's ``__bases__`` list."
msgstr ""
"這是 :class:`~email.policy.EmailPolicy` 預設使用的工廠。 ``HeaderRegistry`` "
"使用 *base_class* 和從它持有的註冊表中檢索的專用類構建用於動態建立標頭實例的"
"類。當給定的標頭名稱未出現在註冊表中時，*default_class* "
"指定的類將用作專用類。當 *use_default_map* "
"為 ``True``（預設值）時，標頭名稱到類的標準映射會在初始化期間複製到註冊表中。 "
"*base_class* 始終是生成類的“__bases__”列表中的最後一個類。"

#: ../../library/email.headerregistry.rst:322
#, fuzzy
msgid "The default mappings are:"
msgstr "預設映射是："

#: ../../library/email.headerregistry.rst:0
msgid "subject"
msgstr "subject"

#: ../../library/email.headerregistry.rst:324
msgid "UniqueUnstructuredHeader"
msgstr "UniqueUnstructuredHeader"

#: ../../library/email.headerregistry.rst:0
msgid "date"
msgstr "date"

#: ../../library/email.headerregistry.rst:325
#: ../../library/email.headerregistry.rst:327
msgid "UniqueDateHeader"
msgstr "UniqueDateHeader"

#: ../../library/email.headerregistry.rst:0
msgid "resent-date"
msgstr "resent-date"

#: ../../library/email.headerregistry.rst:326
msgid "DateHeader"
msgstr "DateHeader"

#: ../../library/email.headerregistry.rst:0
msgid "orig-date"
msgstr "orig-date"

#: ../../library/email.headerregistry.rst:0
msgid "sender"
msgstr "sender"

#: ../../library/email.headerregistry.rst:328
msgid "UniqueSingleAddressHeader"
msgstr "UniqueSingleAddressHeader"

#: ../../library/email.headerregistry.rst:0
msgid "resent-sender"
msgstr "resent-sender"

#: ../../library/email.headerregistry.rst:329
msgid "SingleAddressHeader"
msgstr "SingleAddressHeader"

#: ../../library/email.headerregistry.rst:0
msgid "to"
msgstr "to"

#: ../../library/email.headerregistry.rst:330
#: ../../library/email.headerregistry.rst:332
#: ../../library/email.headerregistry.rst:334
#: ../../library/email.headerregistry.rst:336
#: ../../library/email.headerregistry.rst:338
msgid "UniqueAddressHeader"
msgstr "UniqueAddressHeader"

#: ../../library/email.headerregistry.rst:0
msgid "resent-to"
msgstr "resent-to"

#: ../../library/email.headerregistry.rst:331
#: ../../library/email.headerregistry.rst:333
#: ../../library/email.headerregistry.rst:335
#: ../../library/email.headerregistry.rst:337
msgid "AddressHeader"
msgstr "AddressHeader"

#: ../../library/email.headerregistry.rst:0
msgid "cc"
msgstr "cc"

#: ../../library/email.headerregistry.rst:0
msgid "resent-cc"
msgstr "resent-cc"

#: ../../library/email.headerregistry.rst:0
msgid "bcc"
msgstr "bcc"

#: ../../library/email.headerregistry.rst:0
msgid "resent-bcc"
msgstr "resent-bcc"

#: ../../library/email.headerregistry.rst:0
msgid "from"
msgstr "from"

#: ../../library/email.headerregistry.rst:0
msgid "resent-from"
msgstr "resent-from"

#: ../../library/email.headerregistry.rst:0
msgid "reply-to"
msgstr "reply-to"

#: ../../library/email.headerregistry.rst:0
msgid "mime-version"
msgstr "mime-version"

#: ../../library/email.headerregistry.rst:339
msgid "MIMEVersionHeader"
msgstr "MIMEVersionHeader"

#: ../../library/email.headerregistry.rst:0
msgid "content-type"
msgstr "content-type"

#: ../../library/email.headerregistry.rst:340
msgid "ContentTypeHeader"
msgstr "ContentTypeHeader"

#: ../../library/email.headerregistry.rst:0
msgid "content-disposition"
msgstr "content-disposition"

#: ../../library/email.headerregistry.rst:341
msgid "ContentDispositionHeader"
msgstr "ContentDispositionHeader"

#: ../../library/email.headerregistry.rst:0
msgid "content-transfer-encoding"
msgstr "content-transfer-encoding"

#: ../../library/email.headerregistry.rst:342
msgid "ContentTransferEncodingHeader"
msgstr "ContentTransferEncodingHeader"

#: ../../library/email.headerregistry.rst:0
msgid "message-id"
msgstr "message-id"

#: ../../library/email.headerregistry.rst:343
msgid "MessageIDHeader"
msgstr "MessageIDHeader"

#: ../../library/email.headerregistry.rst:345
#, fuzzy
msgid "``HeaderRegistry`` has the following methods:"
msgstr "``HeaderRegistry`` 有以下方法："

#: ../../library/email.headerregistry.rst:350
#, fuzzy
msgid ""
"*name* is the name of the header to be mapped.  It will be converted to "
"lower case in the registry.  *cls* is the specialized class to be used, "
"along with *base_class*, to create the class used to instantiate headers "
"that match *name*."
msgstr ""
"*name* 是要映射的標頭的名稱。它將在註冊表中轉換為小寫。 *cls* 是要與 "
"*base_class* 一起使用的專用類，用於建立用於實例化與 *name* 匹配的標頭的類。"

#: ../../library/email.headerregistry.rst:358
#, fuzzy
msgid "Construct and return a class to handle creating a *name* header."
msgstr "構造並回傳一個類來處理建立 *name* 標頭。"

#: ../../library/email.headerregistry.rst:363
#, fuzzy
msgid ""
"Retrieves the specialized header associated with *name* from the registry "
"(using *default_class* if *name* does not appear in the registry) and "
"composes it with *base_class* to produce a class, calls the constructed "
"class's constructor, passing it the same argument list, and finally returns "
"the class instance created thereby."
msgstr ""
"從註冊表中檢索與 *name* 關聯的專用標頭（如果 *name* 未出現在註冊表中，則使用 "
"*default_class* ）並將其與 *base_class* 組合以生成類，呼叫構造類的構造函式，"
"將其傳遞給相同的參數列表，最後回傳由此建立的類實例。"

#: ../../library/email.headerregistry.rst:370
#, fuzzy
msgid ""
"The following classes are the classes used to represent data parsed from "
"structured headers and can, in general, be used by an application program to "
"construct structured values to assign to specific headers."
msgstr "以下類是用於表示從結構化標頭解析的資料的類，通常，應用程式可以使用這些類來構"
"造結構化值以分配給特定標頭。"

#: ../../library/email.headerregistry.rst:377
#, fuzzy
msgid ""
"The class used to represent an email address.  The general form of an "
"address is::"
msgstr "用於表示電子郵件地址的類。地址的一般形式是："

#: ../../library/email.headerregistry.rst:382
msgid "or::"
msgstr ""
"或是：\n"
"\n"
"::"

#: ../../library/email.headerregistry.rst:386
#, fuzzy
msgid ""
"where each part must conform to specific syntax rules spelled out in :rfc:"
"`5322`."
msgstr "其中每個部分都必須符合 :rfc:`5322` 中闡明的特定語法規則。"

#: ../../library/email.headerregistry.rst:389
#, fuzzy
msgid ""
"As a convenience *addr_spec* can be specified instead of *username* and "
"*domain*, in which case *username* and *domain* will be parsed from the "
"*addr_spec*.  An *addr_spec* must be a properly RFC quoted string; if it is "
"not ``Address`` will raise an error.  Unicode characters are allowed and "
"will be property encoded when serialized.  However, per the RFCs, unicode is "
"*not* allowed in the username portion of the address."
msgstr ""
"為方便起見，可以指定 *addr_spec* 而不是 *username* 和 "
"*domain*，在這種情況下，將從 *addr_spec* 中解析 *username* 和 *domain*。 "
"*addr_spec* 必須是正確的 RFC 引用字串；如果不是 ``Address`` 將引發錯誤。"
"允許使用 Unicode 字元，並且在序列化時將進行屬性編碼。但是，根據 "
"RFC，地址的使用者名部分*不允許*使用 unicode。"

#: ../../library/email.headerregistry.rst:398
#, fuzzy
msgid ""
"The display name portion of the address, if any, with all quoting removed.  "
"If the address does not have a display name, this attribute will be an empty "
"string."
msgstr "地址的顯示名稱部分（如果有）已刪除所有引號。如果地址沒有顯示名稱，則此屬性將"
"為空字串。"

#: ../../library/email.headerregistry.rst:404
#, fuzzy
msgid "The ``username`` portion of the address, with all quoting removed."
msgstr "地址的“使用者名”部分，所有引號都被刪除。"

#: ../../library/email.headerregistry.rst:408
#, fuzzy
msgid "The ``domain`` portion of the address."
msgstr "地址的 ``域``部分。"

#: ../../library/email.headerregistry.rst:412
#, fuzzy
msgid ""
"The ``username@domain`` portion of the address, correctly quoted for use as "
"a bare address (the second form shown above).  This attribute is not mutable."
msgstr "地址的“username@domain”部分，正確引用用作裸地址（上面顯示的第二種形式）。這個"
"屬性是不可變的。"

#: ../../library/email.headerregistry.rst:418
#, fuzzy
msgid ""
"The ``str`` value of the object is the address quoted according to :rfc:"
"`5322` rules, but with no Content Transfer Encoding of any non-ASCII "
"characters."
msgstr "物件的 ``str`` 值是根據 :rfc:`5322` 規則引用的地址，但沒有任何非 ASCII "
"字元的內容傳輸編碼。"

#: ../../library/email.headerregistry.rst:422
#, fuzzy
msgid ""
"To support SMTP (:rfc:`5321`), ``Address`` handles one special case: if "
"``username`` and ``domain`` are both the empty string (or ``None``), then "
"the string value of the ``Address`` is ``<>``."
msgstr ""
"為了支援 SMTP (:rfc:`5321`)，``Address`` 處理一種特殊情況：如果 ``username`` "
"和 ``domain`` 都是空字串（或 ``None``），那麼``Address`` 的字串值為``<>``。"

#: ../../library/email.headerregistry.rst:429
#, fuzzy
msgid ""
"The class used to represent an address group.  The general form of an "
"address group is::"
msgstr "用於表示地址組的類。地址組的一般形式是："

#: ../../library/email.headerregistry.rst:434
#, fuzzy
msgid ""
"As a convenience for processing lists of addresses that consist of a mixture "
"of groups and single addresses, a ``Group`` may also be used to represent "
"single addresses that are not part of a group by setting *display_name* to "
"``None`` and providing a list of the single address as *addresses*."
msgstr ""
"為了方便處理由組和單個地址混合組成的地址列表， ``組``也可用於表示不屬於組的單個"
"地址，方法是將 *display_name* 設定為 ``None``  ` 並提供單個地址的列表作為 "
"*addresses*。"

#: ../../library/email.headerregistry.rst:441
#, fuzzy
msgid ""
"The ``display_name`` of the group.  If it is ``None`` and there is exactly "
"one ``Address`` in ``addresses``, then the ``Group`` represents a single "
"address that is not in a group."
msgstr ""
"組的 ``display_name``。如果是``None`` 並且``addresses`` "
"中恰好有一個``Address``，那麼``Group`` 表示不在組中的單個地址。"

#: ../../library/email.headerregistry.rst:447
#, fuzzy
msgid ""
"A possibly empty tuple of :class:`.Address` objects representing the "
"addresses in the group."
msgstr "表示組中地址的 :class:`.Address` 物件的可能為空的元組。"

#: ../../library/email.headerregistry.rst:452
#, fuzzy
msgid ""
"The ``str`` value of a ``Group`` is formatted according to :rfc:`5322`, but "
"with no Content Transfer Encoding of any non-ASCII characters.  If "
"``display_name`` is none and there is a single ``Address`` in the "
"``addresses`` list, the ``str`` value will be the same as the ``str`` of "
"that single ``Address``."
msgstr ""
"``Group`` 的``str`` 值根據 :rfc:`5322` 格式化，但沒有任何非 ASCII "
"字元的內容傳輸編碼。如果 ``display_name`` 為 none 且 ``addresses`` "
"列表中只有一個 ``Address``，則 ``str`` 值將與該單個 `` 的 ``str`` "
"相同地址``。"

#: ../../library/email.headerregistry.rst:460
msgid "Footnotes"
msgstr "註解"

#: ../../library/email.headerregistry.rst:461
#, fuzzy
msgid ""
"Originally added in 3.3 as a :term:`provisional module <provisional package>`"
msgstr "最初在 3.3 中新增為 :term:`臨時模組 <臨時包>`"
