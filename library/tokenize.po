# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-06-20 18:08+0800\n"
"PO-Revision-Date: 2018-05-23 16:13+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/tokenize.rst:2
#, fuzzy
msgid ":mod:`tokenize` --- Tokenizer for Python source"
msgstr ":mod:`tokenize` --- Python 原始碼的分詞器"

#: ../../library/tokenize.rst:10
msgid "**Source code:** :source:`Lib/tokenize.py`"
msgstr "**原始碼：**\\ :source:`Lib/tokenize.py`"

#: ../../library/tokenize.rst:14
#, fuzzy
msgid ""
"The :mod:`tokenize` module provides a lexical scanner for Python source "
"code, implemented in Python.  The scanner in this module returns comments as "
"tokens as well, making it useful for implementing \"pretty-printers\", "
"including colorizers for on-screen displays."
msgstr ""
":mod:`tokenize` 模組為 Python 源程式碼提供了一個詞法掃描器，用 Python 實作。"
"該模組中的掃描儀也將評論作為標記回傳，這使其可用於實作“漂亮印出機”，包括用於"
"屏幕顯示的著色器。"

#: ../../library/tokenize.rst:19
#, fuzzy
msgid ""
"To simplify token stream handling, all :ref:`operator <operators>` and :ref:"
"`delimiter <delimiters>` tokens and :data:`Ellipsis` are returned using the "
"generic :data:`~token.OP` token type.  The exact type can be determined by "
"checking the ``exact_type`` property on the :term:`named tuple` returned "
"from :func:`tokenize.tokenize`."
msgstr ""
"為了簡化令牌流處理，所有 :ref:`operator <operators>` 和 :ref:`delimiter "
"<delimiters>` 令牌和 :data:`Ellipsis` 都使用通用的 :data:`~token.OP` "
"令牌型別回傳.確切的型別可以通過檢查從 :func:`tokenize.tokenize` 回傳的 "
":term:`named tuple` 上的 ``exact_type`` 屬性來確定。"

#: ../../library/tokenize.rst:26
#, fuzzy
msgid "Tokenizing Input"
msgstr "分詞輸入"

#: ../../library/tokenize.rst:28
#, fuzzy
msgid "The primary entry point is a :term:`generator`:"
msgstr "主要入口點是 :term:`generator`："

#: ../../library/tokenize.rst:32
#, fuzzy
msgid ""
"The :func:`.tokenize` generator requires one argument, *readline*, which "
"must be a callable object which provides the same interface as the :meth:`io."
"IOBase.readline` method of file objects.  Each call to the function should "
"return one line of input as bytes."
msgstr ""
":func:`.tokenize` 生成器需要一個參數 *readline*，它必須是一個可呼叫物件，"
"它提供與文件物件的 :meth:`io.IOBase.readline` "
"方法相同的介面。對該函式的每次呼叫都應以位元組形式回傳一行輸入。"

#: ../../library/tokenize.rst:37
#, fuzzy
msgid ""
"The generator produces 5-tuples with these members: the token type; the "
"token string; a 2-tuple ``(srow, scol)`` of ints specifying the row and "
"column where the token begins in the source; a 2-tuple ``(erow, ecol)`` of "
"ints specifying the row and column where the token ends in the source; and "
"the line on which the token was found. The line passed (the last tuple item) "
"is the *physical* line.  The 5 tuple is returned as a :term:`named tuple` "
"with the field names: ``type string start end line``."
msgstr ""
"生成器生成具有這些成員的 5 元組：令牌型別；令牌字串；整數的 2 元組“(srow, "
"scol)”，指定標記在源中開始的行和列；整數的二元組“(erow, ecol)”，指定標記在源"
"中結束的行和列；以及找到令牌的行。傳遞的行（最後一個元組項）是 *physical* "
"行。 5 元組作為命名元組回傳，欄位名稱為：“型別字串開始結束行”。"

#: ../../library/tokenize.rst:46
#, fuzzy
msgid ""
"The returned :term:`named tuple` has an additional property named "
"``exact_type`` that contains the exact operator type for :data:`~token.OP` "
"tokens.  For all other token types ``exact_type`` equals the named tuple "
"``type`` field."
msgstr ""
"回傳的 :term:`named tuple` 有一個名為 ``exact_type`` 的附加屬性，其中包含 "
":data:`~token.OP` 標記的確切運算符型別。對於所有其他標記型別，``exact_type`` "
"等於命名的元組``type`` 欄位。"

#: ../../library/tokenize.rst:51
#, fuzzy
msgid "Added support for named tuples."
msgstr "新增了對命名元組的支援。"

#: ../../library/tokenize.rst:54
#, fuzzy
msgid "Added support for ``exact_type``."
msgstr "新增了對 ``exact_type`` 的支援。"

#: ../../library/tokenize.rst:57
#, fuzzy
msgid ""
":func:`.tokenize` determines the source encoding of the file by looking for "
"a UTF-8 BOM or encoding cookie, according to :pep:`263`."
msgstr ":func:`.tokenize` 通過查找 UTF-8 BOM 或編碼 cookie 來確定文件的源編碼，根據 "
":pep:`263`。"

#: ../../library/tokenize.rst:62
#, fuzzy
msgid "Tokenize a source reading unicode strings instead of bytes."
msgstr "標記讀取 unicode 字串而不是位元組的源。"

#: ../../library/tokenize.rst:64
#, fuzzy
msgid ""
"Like :func:`.tokenize`, the *readline* argument is a callable returning a "
"single line of input. However, :func:`generate_tokens` expects *readline* to "
"return a str object rather than bytes."
msgstr ""
"與 :func:`.tokenize` 一樣，*readline* "
"參數是可呼叫的，回傳單行輸入。但是，:func:`generate_tokens` 期望 *readline* "
"回傳一個 str 物件而不是位元組。"

#: ../../library/tokenize.rst:68
#, fuzzy
msgid ""
"The result is an iterator yielding named tuples, exactly like :func:`."
"tokenize`. It does not yield an :data:`~token.ENCODING` token."
msgstr ""
"結果是一個產生命名元組的疊代器，就像 :func:`.tokenize` 一樣。它不會產生 "
":data:`~token.ENCODING` 標記。"

#: ../../library/tokenize.rst:71
#, fuzzy
msgid ""
"All constants from the :mod:`token` module are also exported from :mod:"
"`tokenize`."
msgstr ":mod:`token` 模組中的所有常數也從 :mod:`tokenize` 導出。"

#: ../../library/tokenize.rst:74
#, fuzzy
msgid ""
"Another function is provided to reverse the tokenization process. This is "
"useful for creating tools that tokenize a script, modify the token stream, "
"and write back the modified script."
msgstr "提供了另一個功能來反轉令牌化過程。這對於建立標記化腳本、修改標記流和寫回修改"
"後的腳本的工具很有用。"

#: ../../library/tokenize.rst:81
#, fuzzy
msgid ""
"Converts tokens back into Python source code.  The *iterable* must return "
"sequences with at least two elements, the token type and the token string. "
"Any additional sequence elements are ignored."
msgstr "將標記轉換回 Python 源程式碼。 *iterable* "
"必須回傳至少包含兩個元素的序列，標記型別和標記字串。忽略任何其他序列元素。"

#: ../../library/tokenize.rst:85
#, fuzzy
msgid ""
"The reconstructed script is returned as a single string.  The result is "
"guaranteed to tokenize back to match the input so that the conversion is "
"lossless and round-trips are assured.  The guarantee applies only to the "
"token type and token string as the spacing between tokens (column positions) "
"may change."
msgstr ""
"重建的腳本作為單個字串回傳。保證將結果標記回匹配輸入，以便轉換是無損的並且保"
"證往返。該保證僅適用於令牌型別和令牌字串，因為令牌之間的間距（列位置）可能會"
"發生變化。"

#: ../../library/tokenize.rst:91
#, fuzzy
msgid ""
"It returns bytes, encoded using the :data:`~token.ENCODING` token, which is "
"the first token sequence output by :func:`.tokenize`. If there is no "
"encoding token in the input, it returns a str instead."
msgstr ""
"它回傳位元組，使用 :data:`~token.ENCODING` 標記編碼，這是 :func:`.tokenize` "
"輸出的第一個標記序列。如果輸入中沒有編碼標記，它會回傳一個 str。"

#: ../../library/tokenize.rst:96
#, fuzzy
msgid ""
":func:`.tokenize` needs to detect the encoding of source files it tokenizes. "
"The function it uses to do this is available:"
msgstr ":func:`.tokenize` "
"需要檢測它標記化的源文件的編碼。它用於執行此操作的功能可用："

#: ../../library/tokenize.rst:101
#, fuzzy
msgid ""
"The :func:`detect_encoding` function is used to detect the encoding that "
"should be used to decode a Python source file. It requires one argument, "
"readline, in the same way as the :func:`.tokenize` generator."
msgstr ""
":func:`detect_encoding` 函式用於檢測應該用於解碼 Python 源文件的編碼。"
"它需要一個參數 readline，與 :func:`.tokenize` 生成器的方式相同。"

#: ../../library/tokenize.rst:105
#, fuzzy
msgid ""
"It will call readline a maximum of twice, and return the encoding used (as a "
"string) and a list of any lines (not decoded from bytes) it has read in."
msgstr "它將最多呼叫 readline 兩次，並回傳使用的編碼（作為字串）和它已讀入的任何行（"
"未從位元組解碼）的列表。"

#: ../../library/tokenize.rst:109
#, fuzzy
msgid ""
"It detects the encoding from the presence of a UTF-8 BOM or an encoding "
"cookie as specified in :pep:`263`. If both a BOM and a cookie are present, "
"but disagree, a :exc:`SyntaxError` will be raised. Note that if the BOM is "
"found, ``'utf-8-sig'`` will be returned as an encoding."
msgstr ""
"它根據 :pep:`263` 中指定的 UTF-8 BOM 或編碼 cookie 的存在檢測編碼。如果 BOM "
"和 cookie 都存在，但不一致，則會引發 SyntaxError。請注意，如果找到 "
"BOM， ``'utf-8-sig'`` 將作為編碼回傳。"

#: ../../library/tokenize.rst:114
#, fuzzy
msgid ""
"If no encoding is specified, then the default of ``'utf-8'`` will be "
"returned."
msgstr "如果未指定編碼，則將回傳預設的 ``'utf-8'``。"

#: ../../library/tokenize.rst:117
#, fuzzy
msgid ""
"Use :func:`.open` to open Python source files: it uses :func:"
"`detect_encoding` to detect the file encoding."
msgstr "使用 :func:`.open` 打開 Python 源文件：它使用 :func:`detect_encoding` "
"檢測文件編碼。"

#: ../../library/tokenize.rst:123
#, fuzzy
msgid ""
"Open a file in read only mode using the encoding detected by :func:"
"`detect_encoding`."
msgstr "使用 :func:`detect_encoding` 檢測到的編碼以只讀模式打開文件。"

#: ../../library/tokenize.rst:130
#, fuzzy
msgid ""
"Raised when either a docstring or expression that may be split over several "
"lines is not completed anywhere in the file, for example::"
msgstr "當文件中的任何地方都沒有完成可能分為多行的文檔字串或表達式時引發，例如："

#: ../../library/tokenize.rst:136
msgid "or::"
msgstr ""
"或是：\n"
"\n"
"::"

#: ../../library/tokenize.rst:142
#, fuzzy
msgid ""
"Note that unclosed single-quoted strings do not cause an error to be raised. "
"They are tokenized as :data:`~token.ERRORTOKEN`, followed by the "
"tokenization of their contents."
msgstr "請注意，未閉合的單引號字串不會導致引發錯誤。它們被標記為 :data:`~token."
"ERRORTOKEN`，然後對其內容進行標記化。"

#: ../../library/tokenize.rst:150
#, fuzzy
msgid "Command-Line Usage"
msgstr "命令列用法"

#: ../../library/tokenize.rst:154
#, fuzzy
msgid ""
"The :mod:`tokenize` module can be executed as a script from the command "
"line. It is as simple as:"
msgstr ":mod:`tokenize` 模組可以作為腳本從命令列執行。很簡單："

#: ../../library/tokenize.rst:161
#, fuzzy
msgid "The following options are accepted:"
msgstr "接受以下選項："

#: ../../library/tokenize.rst:167
#, fuzzy
msgid "show this help message and exit"
msgstr "顯示此幫助資訊並退出"

#: ../../library/tokenize.rst:171
#, fuzzy
msgid "display token names using the exact type"
msgstr "使用確切型別顯示令牌名稱"

#: ../../library/tokenize.rst:173
#, fuzzy
msgid ""
"If :file:`filename.py` is specified its contents are tokenized to stdout. "
"Otherwise, tokenization is performed on stdin."
msgstr "如果 :file:`filename.py` "
"被指定，其內容被標記為標準輸出。否則，在標準輸入上執行標記化。"

#: ../../library/tokenize.rst:177
msgid "Examples"
msgstr "範例"

#: ../../library/tokenize.rst:179
#, fuzzy
msgid ""
"Example of a script rewriter that transforms float literals into Decimal "
"objects::"
msgstr "將浮點文字轉換為 Decimal 物件的腳本重寫器示例："

#: ../../library/tokenize.rst:221
#, fuzzy
msgid "Example of tokenizing from the command line.  The script::"
msgstr "從命令列標記化的示例。劇本：："

#: ../../library/tokenize.rst:228
#, fuzzy
msgid ""
"will be tokenized to the following output where the first column is the "
"range of the line/column coordinates where the token is found, the second "
"column is the name of the token, and the final column is the value of the "
"token (if any)"
msgstr "將被標記為以下輸出，其中第一列是找到標記的行/列坐標的範圍，第二列是標記的名稱"
"，最後一列是標記的值（如果有）"

#: ../../library/tokenize.rst:256
#, fuzzy
msgid ""
"The exact token type names can be displayed using the :option:`-e` option:"
msgstr "可以使用 :option:`-e` 選項顯示確切的令牌型別名稱："

#: ../../library/tokenize.rst:282
#, fuzzy
msgid ""
"Example of tokenizing a file programmatically, reading unicode strings "
"instead of bytes with :func:`generate_tokens`::"
msgstr "以編程方式標記文件的示例，使用 :func:`generate_tokens`:: 讀取 unicode "
"字串而不是位元組："

#: ../../library/tokenize.rst:292
#, fuzzy
msgid "Or reading bytes directly with :func:`.tokenize`::"
msgstr "或者直接使用 :func:`.tokenize`:: 讀取位元組："
