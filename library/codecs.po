# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-13 00:17+0000\n"
"PO-Revision-Date: 2018-05-23 14:40+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/codecs.rst:2
msgid ":mod:`codecs` --- Codec registry and base classes"
msgstr ":mod:`codecs` --- 編解碼器註冊和基底類別"

#: ../../library/codecs.rst:11
msgid "**Source code:** :source:`Lib/codecs.py`"
msgstr "**原始碼：**\\ :source:`Lib/codecs.py`"

#: ../../library/codecs.rst:23
#, fuzzy
msgid ""
"This module defines base classes for standard Python codecs (encoders and "
"decoders) and provides access to the internal Python codec registry, which "
"manages the codec and error handling lookup process. Most standard codecs "
"are :term:`text encodings <text encoding>`, which encode text to bytes (and "
"decode bytes to text), but there are also codecs provided that encode text "
"to text, and bytes to bytes. Custom codecs may encode and decode between "
"arbitrary types, but some module features are restricted to be used "
"specifically with :term:`text encodings <text encoding>` or with codecs that "
"encode to :class:`bytes`."
msgstr ""
"此模組定義標準 Python 編解碼器（編碼器和解碼器）的基底類別，並提供對內部 "
"Python 編解碼器註冊表的訪問，該註冊表管理編解碼器和錯誤處理查找過程。"
"大多數標準編解碼器是 :term:`text encodings <text encoding>`，它將文本編碼為位"
"元組（並將位元組解碼為文本），但也提供了將文本編碼為文本以及將位元組編碼為位"
"元組的編解碼器。自定義編解碼器可以在任意型別之間進行編碼和解碼，"
"但某些模組功能僅限於專門用於 :term:`text encodings <text encoding>` 或編碼為 "
":class:`bytes` 的編解碼器。"

#: ../../library/codecs.rst:33
#, fuzzy
msgid ""
"The module defines the following functions for encoding and decoding with "
"any codec:"
msgstr "該模組定義了以下用於使用任何編解碼器進行編碼和解碼的函式："

#: ../../library/codecs.rst:38
#, fuzzy
msgid "Encodes *obj* using the codec registered for *encoding*."
msgstr "使用為 *encoding* 註冊的編解碼器對 *obj* 進行編碼。"

#: ../../library/codecs.rst:40
#, fuzzy
msgid ""
"*Errors* may be given to set the desired error handling scheme. The default "
"error handler is ``'strict'`` meaning that encoding errors raise :exc:"
"`ValueError` (or a more codec specific subclass, such as :exc:"
"`UnicodeEncodeError`). Refer to :ref:`codec-base-classes` for more "
"information on codec error handling."
msgstr ""
"*錯誤* 可以給出設定所需的錯誤處理方案。預設錯誤處理程式是 ``'strict'`` "
"意味著編碼錯誤會引發 :exc:`ValueError`（或更特定於編解碼器的子類別，例如 "
":exc:`UnicodeEncodeError`）。有關編解碼器錯誤處理的更多資訊，請參閱：ref"
"：`codec-base-classes`。"

#: ../../library/codecs.rst:48
#, fuzzy
msgid "Decodes *obj* using the codec registered for *encoding*."
msgstr "使用為 *encoding* 註冊的編解碼器解碼 *obj*。"

#: ../../library/codecs.rst:50
#, fuzzy
msgid ""
"*Errors* may be given to set the desired error handling scheme. The default "
"error handler is ``'strict'`` meaning that decoding errors raise :exc:"
"`ValueError` (or a more codec specific subclass, such as :exc:"
"`UnicodeDecodeError`). Refer to :ref:`codec-base-classes` for more "
"information on codec error handling."
msgstr ""
"*錯誤* 可以給出設定所需的錯誤處理方案。預設錯誤處理程式是 ``'strict'`` "
"意味著解碼錯誤會引發 :exc:`ValueError`（或更特定於編解碼器的子類別，例如 "
":exc:`UnicodeDecodeError`）。有關編解碼器錯誤處理的更多資訊，請參閱：ref"
"：`codec-base-classes`。"

#: ../../library/codecs.rst:56
#, fuzzy
msgid "The full details for each codec can also be looked up directly:"
msgstr "還可以直接查找每個編解碼器的完整詳細資訊："

#: ../../library/codecs.rst:60
#, fuzzy
msgid ""
"Looks up the codec info in the Python codec registry and returns a :class:"
"`CodecInfo` object as defined below."
msgstr "在 Python 編解碼器註冊表中查找編解碼器資訊並回傳如下定義的 :class:`CodecInfo`"
" 物件。"

#: ../../library/codecs.rst:63
#, fuzzy
msgid ""
"Encodings are first looked up in the registry's cache. If not found, the "
"list of registered search functions is scanned. If no :class:`CodecInfo` "
"object is found, a :exc:`LookupError` is raised. Otherwise, the :class:"
"`CodecInfo` object is stored in the cache and returned to the caller."
msgstr ""
"首先在註冊表的快取中查找編碼。如果未找到，則掃描已註冊的搜索功能列表。"
"如果未找到 :class:`CodecInfo` 物件，則會引發 :exc:`LookupError`。否則，"
"CodecInfo 物件將儲存在快取中並回傳給呼叫者。"

#: ../../library/codecs.rst:70
#, fuzzy
msgid ""
"Codec details when looking up the codec registry. The constructor arguments "
"are stored in attributes of the same name:"
msgstr "查找編解碼器註冊表時的編解碼器詳細資訊。構造函式參數儲存在同名屬性中："

#: ../../library/codecs.rst:76
#, fuzzy
msgid "The name of the encoding."
msgstr "編碼的名稱。"

#: ../../library/codecs.rst:82
#, fuzzy
msgid ""
"The stateless encoding and decoding functions. These must be functions or "
"methods which have the same interface as the :meth:`~Codec.encode` and :meth:"
"`~Codec.decode` methods of Codec instances (see :ref:`Codec Interface <codec-"
"objects>`). The functions or methods are expected to work in a stateless "
"mode."
msgstr ""
"無狀態編解碼功能。這些必須是與 Codec 實例的 :meth:`~Codec.encode` 和 "
":meth:`~Codec.decode` 方法具有相同介面的函式或方法（參見 :ref:`Codec "
"Interface <codec-objects>` ).函式或方法應在無狀態模式下工作。"

#: ../../library/codecs.rst:92
#, fuzzy
msgid ""
"Incremental encoder and decoder classes or factory functions. These have to "
"provide the interface defined by the base classes :class:"
"`IncrementalEncoder` and :class:`IncrementalDecoder`, respectively. "
"Incremental codecs can maintain state."
msgstr ""
"增量編碼器和解碼器類或工廠函式。它們必須分別提供由基底類別 "
":class:`IncrementalEncoder` 和 :class:`IncrementalDecoder` "
"定義的介面。增量編解碼器可以保持狀態。"

#: ../../library/codecs.rst:101
#, fuzzy
msgid ""
"Stream writer and reader classes or factory functions. These have to provide "
"the interface defined by the base classes :class:`StreamWriter` and :class:"
"`StreamReader`, respectively. Stream codecs can maintain state."
msgstr ""
"流寫入器和讀取器類或工廠函式。它們必須分別提供由基底類別 "
":class:`StreamWriter` 和 :class:`StreamReader` "
"定義的介面。流編解碼器可以保持狀態。"

#: ../../library/codecs.rst:106
#, fuzzy
msgid ""
"To simplify access to the various codec components, the module provides "
"these additional functions which use :func:`lookup` for the codec lookup:"
msgstr "為了簡化對各種編解碼器組件的訪問，該模組提供了這些使用 :func:`lookup` "
"進行編解碼器查找的附加函式："

#: ../../library/codecs.rst:111
#, fuzzy
msgid ""
"Look up the codec for the given encoding and return its encoder function."
msgstr "查找給定編碼的編解碼器並回傳其編碼器函式。"

#: ../../library/codecs.rst:113 ../../library/codecs.rst:120
#: ../../library/codecs.rst:146 ../../library/codecs.rst:154
#, fuzzy
msgid "Raises a :exc:`LookupError` in case the encoding cannot be found."
msgstr "在找不到編碼的情況下引發 :exc:`LookupError`。"

#: ../../library/codecs.rst:118
#, fuzzy
msgid ""
"Look up the codec for the given encoding and return its decoder function."
msgstr "查找給定編碼的編解碼器並回傳其解碼器函式。"

#: ../../library/codecs.rst:125
#, fuzzy
msgid ""
"Look up the codec for the given encoding and return its incremental encoder "
"class or factory function."
msgstr "查找給定編碼的編解碼器並回傳其增量編碼器類或工廠函式。"

#: ../../library/codecs.rst:128
#, fuzzy
msgid ""
"Raises a :exc:`LookupError` in case the encoding cannot be found or the "
"codec doesn't support an incremental encoder."
msgstr "在找不到編碼或編解碼器不支援增量編碼器的情況下引發 :exc:`LookupError`。"

#: ../../library/codecs.rst:134
#, fuzzy
msgid ""
"Look up the codec for the given encoding and return its incremental decoder "
"class or factory function."
msgstr "查找給定編碼的編解碼器並回傳其增量解碼器類或工廠函式。"

#: ../../library/codecs.rst:137
#, fuzzy
msgid ""
"Raises a :exc:`LookupError` in case the encoding cannot be found or the "
"codec doesn't support an incremental decoder."
msgstr "在找不到編碼或編解碼器不支援增量解碼器的情況下引發 :exc:`LookupError`。"

#: ../../library/codecs.rst:143
#, fuzzy
msgid ""
"Look up the codec for the given encoding and return its :class:"
"`StreamReader` class or factory function."
msgstr "查找給定編碼的編解碼器並回傳其 StreamReader 類或工廠函式。"

#: ../../library/codecs.rst:151
#, fuzzy
msgid ""
"Look up the codec for the given encoding and return its :class:"
"`StreamWriter` class or factory function."
msgstr "查找給定編碼的編解碼器並回傳其 StreamWriter 類或工廠函式。"

#: ../../library/codecs.rst:156
#, fuzzy
msgid ""
"Custom codecs are made available by registering a suitable codec search "
"function:"
msgstr "通過註冊合適的編解碼器搜索功能，可以使用自定義編解碼器："

#: ../../library/codecs.rst:161
#, fuzzy
msgid ""
"Register a codec search function. Search functions are expected to take one "
"argument, being the encoding name in all lower case letters with hyphens and "
"spaces converted to underscores, and return a :class:`CodecInfo` object. In "
"case a search function cannot find a given encoding, it should return "
"``None``."
msgstr ""
"註冊編解碼器搜索功能。搜索函式應採用一個參數，即所有小寫字母的編碼名稱，連字"
"元和空格轉換為底線，並回傳一個 CodecInfo "
"物件。如果搜索函式找不到給定的編碼，它應該回傳 ``None`` 。"

#: ../../library/codecs.rst:167
#, fuzzy
msgid "Hyphens and spaces are converted to underscore."
msgstr "連字元和空格轉換為底線。"

#: ../../library/codecs.rst:173
#, fuzzy
msgid ""
"Unregister a codec search function and clear the registry's cache. If the "
"search function is not registered, do nothing."
msgstr "註銷編解碼器搜索功能並清除註冊表的快取。如果未註冊搜索功能，則什麼也不做。"

#: ../../library/codecs.rst:179
#, fuzzy
msgid ""
"While the builtin :func:`open` and the associated :mod:`io` module are the "
"recommended approach for working with encoded text files, this module "
"provides additional utility functions and classes that allow the use of a "
"wider range of codecs when working with binary files:"
msgstr ""
"雖然內建的 :func:`open` 和關聯的 :mod:`io` 模組是處理編碼文本文件的推薦方法，"
"但該模組提供了額外的實用函式和類，允許在工作時使用更廣泛的編解碼器使用二進位"
"文件："

#: ../../library/codecs.rst:186
#, fuzzy
msgid ""
"Open an encoded file using the given *mode* and return an instance of :class:"
"`StreamReaderWriter`, providing transparent encoding/decoding. The default "
"file mode is ``'r'``, meaning to open the file in read mode."
msgstr ""
"使用給定的 *mode* 打開一個編碼文件並回傳一個 StreamReaderWriter "
"的實例，提供透明的編碼/解碼。預設的文件模式是``'r'``，表示以讀模式打開文件。"

#: ../../library/codecs.rst:192
#, fuzzy
msgid ""
"If *encoding* is not ``None``, then the underlying encoded files are always "
"opened in binary mode. No automatic conversion of ``'\\n'`` is done on "
"reading and writing. The *mode* argument may be any binary mode acceptable "
"to the built-in :func:`open` function; the ``'b'`` is automatically added."
msgstr ""
"如果 *encoding* "
"不是``None``，那麼底層編碼文件總是以二進位模式打開。讀寫時不會自動轉換``'\\n"
"'``。 *mode* 參數可以是內建 :func:`open` 函式可接受的任何二進位模式； ``'b'``"
" 是自動新增的。"

#: ../../library/codecs.rst:198
#, fuzzy
msgid ""
"*encoding* specifies the encoding which is to be used for the file. Any "
"encoding that encodes to and decodes from bytes is allowed, and the data "
"types supported by the file methods depend on the codec used."
msgstr "*encoding* 指定要用於文件的編碼。允許對位元組進行編碼和解碼的任何編碼，文件方"
"法支援的資料型別取決於所使用的編解碼器。"

#: ../../library/codecs.rst:202
#, fuzzy
msgid ""
"*errors* may be given to define the error handling. It defaults to "
"``'strict'`` which causes a :exc:`ValueError` to be raised in case an "
"encoding error occurs."
msgstr "可以給出 *errors* 來定義錯誤處理。它預設為 ``'strict'``，"
"這會在發生編碼錯誤時引發 :exc:`ValueError`。"

#: ../../library/codecs.rst:205
#, fuzzy
msgid ""
"*buffering* has the same meaning as for the built-in :func:`open` function. "
"It defaults to -1 which means that the default buffer size will be used."
msgstr "*buffering* 與內建 :func:`open` 函式的含義相同。它預設為 "
"-1，這意味著將使用預設緩衝區大小。"

#: ../../library/codecs.rst:208
#, fuzzy
msgid "The ``'U'`` mode has been removed."
msgstr "``'U'`` 模式已被移除。"

#: ../../library/codecs.rst:214
#, fuzzy
msgid ""
"Return a :class:`StreamRecoder` instance, a wrapped version of *file* which "
"provides transparent transcoding. The original file is closed when the "
"wrapped version is closed."
msgstr "回傳一個 StreamRecoder 實例，一個提供透明轉碼的 *file* "
"的包裝版本。關閉包裝版本時，原始文件也將關閉。"

#: ../../library/codecs.rst:218
#, fuzzy
msgid ""
"Data written to the wrapped file is decoded according to the given "
"*data_encoding* and then written to the original file as bytes using "
"*file_encoding*. Bytes read from the original file are decoded according to "
"*file_encoding*, and the result is encoded using *data_encoding*."
msgstr ""
"寫入包裝文件的資料根據給定的 *data_encoding* 解碼，然後使用 *file_encoding* "
"作為位元組寫入原始文件。從原始文件讀取的位元組根據*file_encoding* "
"解碼，結果使用*data_encoding* 編碼。"

#: ../../library/codecs.rst:224
#, fuzzy
msgid "If *file_encoding* is not given, it defaults to *data_encoding*."
msgstr "如果未給出 *file_encoding*，則預設為 *data_encoding*。"

#: ../../library/codecs.rst:226
#, fuzzy
msgid ""
"*errors* may be given to define the error handling. It defaults to "
"``'strict'``, which causes :exc:`ValueError` to be raised in case an "
"encoding error occurs."
msgstr ""
"可以給出 *errors* 來定義錯誤處理。它預設為 ``'strict'``，"
"這會導致在發生編碼錯誤時引發 :exc:`ValueError`。"

#: ../../library/codecs.rst:233
#, fuzzy
msgid ""
"Uses an incremental encoder to iteratively encode the input provided by "
"*iterator*. This function is a :term:`generator`. The *errors* argument (as "
"well as any other keyword argument) is passed through to the incremental "
"encoder."
msgstr ""
"使用增量編碼器對 *iterator* 提供的輸入進行疊代編碼。這個函式是一個 "
":term:`generator`。 *errors* "
"參數（以及任何其他關鍵字參數）被傳遞給增量編碼器。"

#: ../../library/codecs.rst:238
#, fuzzy
msgid ""
"This function requires that the codec accept text :class:`str` objects to "
"encode. Therefore it does not support bytes-to-bytes encoders such as "
"``base64_codec``."
msgstr ""
"此函式要求編解碼器接受文本 :class:`str` "
"物件進行編碼。因此它不支援位元組到位元組的編碼器，例如 ``base64_codec``。"

#: ../../library/codecs.rst:245
#, fuzzy
msgid ""
"Uses an incremental decoder to iteratively decode the input provided by "
"*iterator*. This function is a :term:`generator`. The *errors* argument (as "
"well as any other keyword argument) is passed through to the incremental "
"decoder."
msgstr ""
"使用增量解碼器疊代解碼 *iterator* 提供的輸入。這個函式是一個 "
":term:`generator`。 *errors* "
"參數（以及任何其他關鍵字參數）被傳遞到增量解碼器。"

#: ../../library/codecs.rst:250
#, fuzzy
msgid ""
"This function requires that the codec accept :class:`bytes` objects to "
"decode. Therefore it does not support text-to-text encoders such as "
"``rot_13``, although ``rot_13`` may be used equivalently with :func:"
"`iterencode`."
msgstr ""
"此函式要求編解碼器接受 :class:`bytes` 物件進行解碼。因此它不支援諸如 "
"``rot_13`` 的文本到文本編碼器，儘管 ``rot_13`` 可以與 :func:`iterencode` "
"等價使用。"

#: ../../library/codecs.rst:256
#, fuzzy
msgid ""
"The module also provides the following constants which are useful for "
"reading and writing to platform dependent files:"
msgstr "該模組還提供了以下常數，這些常數對於讀取和寫入平台相關文件很有用："

#: ../../library/codecs.rst:271
#, fuzzy
msgid ""
"These constants define various byte sequences, being Unicode byte order "
"marks (BOMs) for several encodings. They are used in UTF-16 and UTF-32 data "
"streams to indicate the byte order used, and in UTF-8 as a Unicode "
"signature. :const:`BOM_UTF16` is either :const:`BOM_UTF16_BE` or :const:"
"`BOM_UTF16_LE` depending on the platform's native byte order, :const:`BOM` "
"is an alias for :const:`BOM_UTF16`, :const:`BOM_LE` for :const:"
"`BOM_UTF16_LE` and :const:`BOM_BE` for :const:`BOM_UTF16_BE`. The others "
"represent the BOM in UTF-8 and UTF-32 encodings."
msgstr ""
"這些常數定義了各種位元組序列，是幾種編碼的 Unicode 位元組順序標記 (BOM)。"
"它們在 UTF-16 和 UTF-32 資料流中用於指示使用的位元組順序，在 UTF-8 中用作 "
"Unicode 簽名。 :const:`BOM_UTF16` 是 :const:`BOM_UTF16_BE` 或 "
":const:`BOM_UTF16_LE` 取決於平台的本機位元組順序，:const:`BOM` 是 "
":const:`BOM_UTF16` 的別名，:const:` BOM_LE` 用於 :const:`BOM_UTF16_LE` "
"和 :const:`BOM_BE` 用於 :const:`BOM_UTF16_BE`。其他代表 UTF-8 和 UTF-32 "
"編碼的 BOM。"

#: ../../library/codecs.rst:285
#, fuzzy
msgid "Codec Base Classes"
msgstr "編解碼器基底類別"

#: ../../library/codecs.rst:287
#, fuzzy
msgid ""
"The :mod:`codecs` module defines a set of base classes which define the "
"interfaces for working with codec objects, and can also be used as the basis "
"for custom codec implementations."
msgstr ":mod:`codecs` 模組定義了一組基底類別，這些基底類別定義了使用編解碼器物件的接"
"口，也可以用作自定義編解碼器實作的基礎。"

#: ../../library/codecs.rst:291
#, fuzzy
msgid ""
"Each codec has to define four interfaces to make it usable as codec in "
"Python: stateless encoder, stateless decoder, stream reader and stream "
"writer. The stream reader and writers typically reuse the stateless encoder/"
"decoder to implement the file protocols. Codec authors also need to define "
"how the codec will handle encoding and decoding errors."
msgstr ""
"每個編解碼器都必須定義四個介面才能在 Python 中用作編解碼器：無狀態編碼器、無"
"狀態解碼器、流讀取器和流寫入器。流讀取器和寫入器通常重用無狀態編碼器/解碼器來"
"實作文件協定。編解碼器作者還需要定義編解碼器將如何處理編碼和解碼錯誤。"

#: ../../library/codecs.rst:302
#, fuzzy
msgid "Error Handlers"
msgstr "錯誤處理程式"

#: ../../library/codecs.rst:304
#, fuzzy
msgid ""
"To simplify and standardize error handling, codecs may implement different "
"error handling schemes by accepting the *errors* string argument:"
msgstr "為了簡化和標準化錯誤處理，編解碼器可以通過接受 *errors* "
"字串參數來實作不同的錯誤處理方案："

#: ../../library/codecs.rst:324
#, fuzzy
msgid ""
"The following error handlers can be used with all Python :ref:`standard-"
"encodings` codecs:"
msgstr "以下錯誤處理程式可用於所有 Python :ref:`standard-encodings` 編解碼器："

#: ../../library/codecs.rst:330 ../../library/codecs.rst:372
#: ../../library/codecs.rst:391
#, fuzzy
msgid "Value"
msgstr "價值"

#: ../../library/codecs.rst:330 ../../library/codecs.rst:372
#: ../../library/codecs.rst:391 ../../library/codecs.rst:1324
#: ../../library/codecs.rst:1391 ../../library/codecs.rst:1446
#, fuzzy
msgid "Meaning"
msgstr "意義"

#: ../../library/codecs.rst:332
msgid "``'strict'``"
msgstr "``'strict'``"

#: ../../library/codecs.rst:332
#, fuzzy
msgid ""
"Raise :exc:`UnicodeError` (or a subclass), this is the default. Implemented "
"in :func:`strict_errors`."
msgstr "引發 :exc:`UnicodeError`（或子類別），這是預設設定。在 :func:`strict_errors` "
"中實作。"

#: ../../library/codecs.rst:336
msgid "``'ignore'``"
msgstr "``'ignore'``"

#: ../../library/codecs.rst:336
#, fuzzy
msgid ""
"Ignore the malformed data and continue without further notice. Implemented "
"in :func:`ignore_errors`."
msgstr "忽略格式錯誤的資料並繼續，恕不另行通知。在 :func:`ignore_errors` 中實作。"

#: ../../library/codecs.rst:340
msgid "``'replace'``"
msgstr "``'replace'``"

#: ../../library/codecs.rst:340
#, fuzzy
msgid ""
"Replace with a replacement marker. On encoding, use ``?`` (ASCII character). "
"On decoding, use ``�`` (U+FFFD, the official REPLACEMENT CHARACTER). "
"Implemented in :func:`replace_errors`."
msgstr ""
"用替換標記替換。在編碼時，使用 ``?``（ASCII "
"字元）。在解碼時，使用````（U+FFFD，官方的替換字元）。在 "
":func:`replace_errors` 中實作。"

#: ../../library/codecs.rst:346
msgid "``'backslashreplace'``"
msgstr "``'backslashreplace'``"

#: ../../library/codecs.rst:346
#, fuzzy
msgid ""
"Replace with backslashed escape sequences. On encoding, use hexadecimal form "
"of Unicode code point with formats ``\\xhh`` ``\\uxxxx`` ``\\Uxxxxxxxx``. On "
"decoding, use hexadecimal form of byte value with format ``\\xhh``. "
"Implemented in :func:`backslashreplace_errors`."
msgstr ""
"替換為反斜杠轉義序列。在編碼時，使用 Unicode 程式碼點的十六進位形式，格式為 "
"``\\xhh`` ``\\uxxxx`` ``\\Uxxxxxxxx``。在解碼時，使用格式為“\\xhh"
"”的位元組值的十六進位形式。在 :func:`backslashreplace_errors` 中實作。"

#: ../../library/codecs.rst:354
msgid "``'surrogateescape'``"
msgstr "``'surrogateescape'``"

#: ../../library/codecs.rst:354
#, fuzzy
msgid ""
"On decoding, replace byte with individual surrogate code ranging from "
"``U+DC80`` to ``U+DCFF``. This code will then be turned back into the same "
"byte when the ``'surrogateescape'`` error handler is used when encoding the "
"data. (See :pep:`383` for more.)"
msgstr ""
"在解碼時，將位元組替換為從 ``U+DC80``到 ``U+DCFF``的單個代理程式碼。"
"當在編碼資料時使用 ``'surrogateescape'`` "
"錯誤處理程式時，此程式碼將轉回相同的位元組。 （有關更多資訊，請參閱 "
":pep:`383`。）"

#: ../../library/codecs.rst:368
#, fuzzy
msgid ""
"The following error handlers are only applicable to encoding (within :term:"
"`text encodings <text encoding>`):"
msgstr "以下錯誤處理程式僅適用於編碼（在 :term:`text encodings <text encoding>` "
"中）："

#: ../../library/codecs.rst:374
msgid "``'xmlcharrefreplace'``"
msgstr "``'xmlcharrefreplace'``"

#: ../../library/codecs.rst:374
#, fuzzy
msgid ""
"Replace with XML/HTML numeric character reference, which is a decimal form "
"of Unicode code point with format ``&#num;`` Implemented in :func:"
"`xmlcharrefreplace_errors`."
msgstr ""
"替換為 XML/HTML 數字字元引用，它是 Unicode 程式碼點的十進位形式，格式為 "
"``#num;`` 在 :func:`xmlcharrefreplace_errors` 中實作。"

#: ../../library/codecs.rst:379
msgid "``'namereplace'``"
msgstr "``'namereplace'``"

#: ../../library/codecs.rst:379
#, fuzzy
msgid ""
"Replace with ``\\N{...}`` escape sequences, what appears in the braces is "
"the Name property from Unicode Character Database. Implemented in :func:"
"`namereplace_errors`."
msgstr ""
"用``\\N{...}``轉義序列替換，大括號中出現的是來自Unicode字元資料庫的Name屬性。"
"在 :func:`namereplace_errors` 中實作。"

#: ../../library/codecs.rst:388
#, fuzzy
msgid ""
"In addition, the following error handler is specific to the given codecs:"
msgstr "此外，以下錯誤處理程式特定於給定的編解碼器："

#: ../../library/codecs.rst:391
#, fuzzy
msgid "Codecs"
msgstr "編解碼器"

#: ../../library/codecs.rst:393
msgid "``'surrogatepass'``"
msgstr "``'surrogatepass'``"

#: ../../library/codecs.rst:393
msgid "utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le"
msgstr "utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le"

#: ../../library/codecs.rst:393
#, fuzzy
msgid ""
"Allow encoding and decoding surrogate code point (``U+D800`` - ``U+DFFF``) "
"as normal code point. Otherwise these codecs treat the presence of surrogate "
"code point in :class:`str` as an error."
msgstr ""
"允許編碼和解碼代理程式碼點（``U+D800`` - ``U+DFFF``）作為普通程式碼點。否則，"
"這些編解碼器將 :class:`str` 中代理程式碼點的存在視為錯誤。"

#: ../../library/codecs.rst:400
#, fuzzy
msgid "The ``'surrogateescape'`` and ``'surrogatepass'`` error handlers."
msgstr "``'surrogateescape'`` 和 ``'surrogatepass'`` 錯誤處理程式。"

#: ../../library/codecs.rst:403
#, fuzzy
msgid ""
"The ``'surrogatepass'`` error handler now works with utf-16\\* and utf-32\\* "
"codecs."
msgstr "``'surrogatepass'`` 錯誤處理程式現在適用於 utf-16\\* 和 utf-32\\* 編解碼器。"

#: ../../library/codecs.rst:407
#, fuzzy
msgid "The ``'namereplace'`` error handler."
msgstr "``'namereplace'`` 錯誤處理程式。"

#: ../../library/codecs.rst:410
#, fuzzy
msgid ""
"The ``'backslashreplace'`` error handler now works with decoding and "
"translating."
msgstr "``'backslashreplace'`` 錯誤處理程式現在可用於解碼和翻譯。"

#: ../../library/codecs.rst:414
#, fuzzy
msgid ""
"The set of allowed values can be extended by registering a new named error "
"handler:"
msgstr "可以通過註冊一個新的命名錯誤處理程式來擴充允許值集："

#: ../../library/codecs.rst:419
#, fuzzy
msgid ""
"Register the error handling function *error_handler* under the name *name*. "
"The *error_handler* argument will be called during encoding and decoding in "
"case of an error, when *name* is specified as the errors parameter."
msgstr ""
"在名稱 *name* 下註冊錯誤處理函式 *error_handler*。 *error_handler* "
"參數將在編碼和解碼期間呼叫，以防出現錯誤，當 *name* 被指定為 errors 參數時。"

#: ../../library/codecs.rst:423
#, fuzzy
msgid ""
"For encoding, *error_handler* will be called with a :exc:"
"`UnicodeEncodeError` instance, which contains information about the location "
"of the error. The error handler must either raise this or a different "
"exception, or return a tuple with a replacement for the unencodable part of "
"the input and a position where encoding should continue. The replacement may "
"be either :class:`str` or :class:`bytes`. If the replacement is bytes, the "
"encoder will simply copy them into the output buffer. If the replacement is "
"a string, the encoder will encode the replacement. Encoding continues on "
"original input at the specified position. Negative position values will be "
"treated as being relative to the end of the input string. If the resulting "
"position is out of bound an :exc:`IndexError` will be raised."
msgstr ""
"對於編碼，*error_handler* 將使用 :exc:`UnicodeEncodeError` 實例呼叫，其中包含"
"有關錯誤位置的資訊。錯誤處理程式必須引發此例外或其他例外，或者回傳一個元組，"
"其中包含輸入的不可編碼部分的替換以及編碼應繼續的位置。替換可以是 :class:`str`"
" 或 :class:`bytes`。如果替換是位元組，編碼器將簡單地將它們複製到輸出緩衝區中"
"。如果替換為字串，編碼器將對替換進行編碼。在指定位置的原始輸入上繼續編碼。負"
"位置值將被視為相對於輸入字串的末尾。如果結果位置超出範圍，將引發 "
":exc:`IndexError`。"

#: ../../library/codecs.rst:435
#, fuzzy
msgid ""
"Decoding and translating works similarly, except :exc:`UnicodeDecodeError` "
"or :exc:`UnicodeTranslateError` will be passed to the handler and that the "
"replacement from the error handler will be put into the output directly."
msgstr ""
"解碼和翻譯的工作方式類似，除了 :exc:`UnicodeDecodeError` 或 "
":exc:`UnicodeTranslateError` "
"將傳遞給處理程式，並且錯誤處理程式的替換將直接放入輸出中。"

#: ../../library/codecs.rst:440
#, fuzzy
msgid ""
"Previously registered error handlers (including the standard error handlers) "
"can be looked up by name:"
msgstr "可以按名稱查找以前註冊的錯誤處理程式（包括標準錯誤處理程式）："

#: ../../library/codecs.rst:445
#, fuzzy
msgid "Return the error handler previously registered under the name *name*."
msgstr "回傳先前以名稱 *name* 註冊的錯誤處理程式。"

#: ../../library/codecs.rst:447
#, fuzzy
msgid "Raises a :exc:`LookupError` in case the handler cannot be found."
msgstr "在找不到處理程式的情況下引發 :exc:`LookupError`。"

#: ../../library/codecs.rst:449
#, fuzzy
msgid ""
"The following standard error handlers are also made available as module "
"level functions:"
msgstr "以下標準錯誤處理程式也可用作模組級函式："

#: ../../library/codecs.rst:454
#, fuzzy
msgid "Implements the ``'strict'`` error handling."
msgstr "實作“嚴格”錯誤處理。"

#: ../../library/codecs.rst:456
#, fuzzy
msgid "Each encoding or decoding error raises a :exc:`UnicodeError`."
msgstr "每個編碼或解碼錯誤都會引發 :exc:`UnicodeError`。"

#: ../../library/codecs.rst:461
#, fuzzy
msgid "Implements the ``'ignore'`` error handling."
msgstr "實作“忽略”錯誤處理。"

#: ../../library/codecs.rst:463
#, fuzzy
msgid ""
"Malformed data is ignored; encoding or decoding is continued without further "
"notice."
msgstr "格式錯誤的資料將被忽略；編碼或解碼繼續進行，恕不另行通知。"

#: ../../library/codecs.rst:469
#, fuzzy
msgid "Implements the ``'replace'`` error handling."
msgstr "實作“替換”錯誤處理。"

#: ../../library/codecs.rst:471
#, fuzzy
msgid ""
"Substitutes ``?`` (ASCII character) for encoding errors or ``�`` (U+FFFD, "
"the official REPLACEMENT CHARACTER) for decoding errors."
msgstr "用 ``?``（ASCII 字元）代替編碼錯誤，或用 "
"``��``（U+FFFD，官方替換字元）代替解碼錯誤。"

#: ../../library/codecs.rst:477
#, fuzzy
msgid "Implements the ``'backslashreplace'`` error handling."
msgstr "實作 ``'backslashreplace'`` 錯誤處理。"

#: ../../library/codecs.rst:479
#, fuzzy
msgid ""
"Malformed data is replaced by a backslashed escape sequence. On encoding, "
"use the hexadecimal form of Unicode code point with formats ``\\xhh`` "
"``\\uxxxx`` ``\\Uxxxxxxxx``. On decoding, use the hexadecimal form of byte "
"value with format ``\\xhh``."
msgstr ""
"格式錯誤的資料由反斜杠轉義序列替換。在編碼時，使用 Unicode "
"程式碼點的十六進位形式，格式為 ``\\xhh`` ``\\uxxxx`` ``\\Uxxxxxxxx"
"``。在解碼時，使用格式為“\\xhh”的位元組值的十六進位形式。"

#: ../../library/codecs.rst:484
#, fuzzy
msgid "Works with decoding and translating."
msgstr "適用於解碼和翻譯。"

#: ../../library/codecs.rst:490
#, fuzzy
msgid ""
"Implements the ``'xmlcharrefreplace'`` error handling (for encoding within :"
"term:`text encoding` only)."
msgstr "實作 ``'xmlcharrefreplace'`` 錯誤處理（僅用於在 :term:`text encoding` "
"中編碼）。"

#: ../../library/codecs.rst:493
#, fuzzy
msgid ""
"The unencodable character is replaced by an appropriate XML/HTML numeric "
"character reference, which is a decimal form of Unicode code point with "
"format ``&#num;`` ."
msgstr "不可編碼的字元被適當的 XML/HTML 數字字元引用替換，它是 Unicode "
"程式碼點的十進位形式，格式為“##num;”。"

#: ../../library/codecs.rst:500
#, fuzzy
msgid ""
"Implements the ``'namereplace'`` error handling (for encoding within :term:"
"`text encoding` only)."
msgstr "實作 ``'namereplace'`` 錯誤處理（僅用於在 :term:`text encoding` 中編碼）。"

#: ../../library/codecs.rst:503
#, fuzzy
msgid ""
"The unencodable character is replaced by a ``\\N{...}`` escape sequence. The "
"set of characters that appear in the braces is the Name property from "
"Unicode Character Database. For example, the German lowercase letter ``'ß'`` "
"will be converted to byte sequence ``\\N{LATIN SMALL LETTER SHARP S}`` ."
msgstr ""
"不可編碼的字元被替換為 ``\\N{...}`` 轉義序列。大括號中出現的字元集是 Unicode "
"字元資料庫中的名稱屬性。例如，德語小寫字母 ``'ß'`` 將被轉換為位元組序列 ``\\N"
"{LATIN SMALL LETTER SHARP S}`` 。"

#: ../../library/codecs.rst:514
#, fuzzy
msgid "Stateless Encoding and Decoding"
msgstr "無狀態編解碼"

#: ../../library/codecs.rst:516
#, fuzzy
msgid ""
"The base :class:`Codec` class defines these methods which also define the "
"function interfaces of the stateless encoder and decoder:"
msgstr "基底類別：`Codec` "
"類定義了這些方法，這些方法還定義了無狀態編碼器和解碼器的函式介面："

#: ../../library/codecs.rst:522
#, fuzzy
msgid ""
"Encodes the object *input* and returns a tuple (output object, length "
"consumed). For instance, :term:`text encoding` converts a string object to a "
"bytes object using a particular character set encoding (e.g., ``cp1252`` or "
"``iso-8859-1``)."
msgstr ""
"對物件 *input* 進行編碼並回傳一個元組（輸出物件，消耗的長度）。例如，:term:`"
"text encoding` 使用特定的字元集編碼（例如，``cp1252`` 或 "
"``iso-8859-1``）將字串物件轉換為位元組物件。"

#: ../../library/codecs.rst:527 ../../library/codecs.rst:549
#, fuzzy
msgid ""
"The *errors* argument defines the error handling to apply. It defaults to "
"``'strict'`` handling."
msgstr "*errors* 參數定義要應用的錯誤處理。它預設為“嚴格”處理。"

#: ../../library/codecs.rst:530
#, fuzzy
msgid ""
"The method may not store state in the :class:`Codec` instance. Use :class:"
"`StreamWriter` for codecs which have to keep state in order to make encoding "
"efficient."
msgstr "該方法可能不會將狀態儲存在 Codec 實例中。將 StreamWriter "
"用於必須保持狀態以使編碼高效的編解碼器。"

#: ../../library/codecs.rst:534
#, fuzzy
msgid ""
"The encoder must be able to handle zero length input and return an empty "
"object of the output object type in this situation."
msgstr "在這種情況下，編碼器必須能夠處理零長度輸入並回傳輸出對像型別的空物件。"

#: ../../library/codecs.rst:540
#, fuzzy
msgid ""
"Decodes the object *input* and returns a tuple (output object, length "
"consumed). For instance, for a :term:`text encoding`, decoding converts a "
"bytes object encoded using a particular character set encoding to a string "
"object."
msgstr ""
"解碼物件 *input* 並回傳一個元組（輸出物件，消耗的長度）。例如，對於 :term:`"
"text encoding`，解碼將使用特定字元集編碼編碼的位元組物件轉換為字串物件。"

#: ../../library/codecs.rst:545
#, fuzzy
msgid ""
"For text encodings and bytes-to-bytes codecs, *input* must be a bytes object "
"or one which provides the read-only buffer interface -- for example, buffer "
"objects and memory mapped files."
msgstr "對於文本編碼和位元組到位元組的編解碼器，*input* 必須是位元組對像或提供只讀緩"
"衝區介面的物件——例如，緩衝區物件和記憶體映射文件。"

#: ../../library/codecs.rst:552
#, fuzzy
msgid ""
"The method may not store state in the :class:`Codec` instance. Use :class:"
"`StreamReader` for codecs which have to keep state in order to make decoding "
"efficient."
msgstr "該方法可能不會將狀態儲存在 Codec 實例中。將 StreamReader "
"用於必須保持狀態以提高解碼效率的編解碼器。"

#: ../../library/codecs.rst:556
#, fuzzy
msgid ""
"The decoder must be able to handle zero length input and return an empty "
"object of the output object type in this situation."
msgstr "在這種情況下，解碼器必須能夠處理零長度輸入並回傳輸出對像型別的空物件。"

#: ../../library/codecs.rst:561
#, fuzzy
msgid "Incremental Encoding and Decoding"
msgstr "增量編解碼"

#: ../../library/codecs.rst:563
#, fuzzy
msgid ""
"The :class:`IncrementalEncoder` and :class:`IncrementalDecoder` classes "
"provide the basic interface for incremental encoding and decoding. Encoding/"
"decoding the input isn't done with one call to the stateless encoder/decoder "
"function, but with multiple calls to the :meth:`~IncrementalEncoder.encode`/:"
"meth:`~IncrementalDecoder.decode` method of the incremental encoder/decoder. "
"The incremental encoder/decoder keeps track of the encoding/decoding process "
"during method calls."
msgstr ""
":class:`IncrementalEncoder` 和 :class:`IncrementalDecoder` 類提供增量編碼和解"
"碼的基本介面。編碼/解碼輸入不是通過一次呼叫無狀態編碼器/解碼器函式完成的，"
"而是通過多次呼叫增量編碼器的 :meth:`~IncrementalEncoder."
"encode`/:meth:`~IncrementalDecoder.decode` "
"方法完成的/解碼器。增量編碼器/解碼器在方法呼叫期間跟踪編碼/解碼過程。"

#: ../../library/codecs.rst:571
#, fuzzy
msgid ""
"The joined output of calls to the :meth:`~IncrementalEncoder.encode`/:meth:"
"`~IncrementalDecoder.decode` method is the same as if all the single inputs "
"were joined into one, and this input was encoded/decoded with the stateless "
"encoder/decoder."
msgstr ""
"呼叫 :meth:`~IncrementalEncoder.encode`/:meth:`~IncrementalDecoder.decode` 方"
"法的聯合輸出與所有單個輸入合併為一個相同，並且此輸入使用無狀態編碼器/解碼器。"

#: ../../library/codecs.rst:580
msgid "IncrementalEncoder Objects"
msgstr "IncrementalEncoder 物件"

#: ../../library/codecs.rst:582
#, fuzzy
msgid ""
"The :class:`IncrementalEncoder` class is used for encoding an input in "
"multiple steps. It defines the following methods which every incremental "
"encoder must define in order to be compatible with the Python codec registry."
msgstr ""
":class:`IncrementalEncoder` "
"類用於在多個步驟中對輸入進行編碼。它定義了以下每個增量編碼器必須定義的方法，"
"以便與 Python 編解碼器註冊表相容。"

#: ../../library/codecs.rst:589
#, fuzzy
msgid "Constructor for an :class:`IncrementalEncoder` instance."
msgstr ":class:`IncrementalEncoder` 實例的構造函式。"

#: ../../library/codecs.rst:591
#, fuzzy
msgid ""
"All incremental encoders must provide this constructor interface. They are "
"free to add additional keyword arguments, but only the ones defined here are "
"used by the Python codec registry."
msgstr "所有增量編碼器都必須提供此構造函式介面。他們可以自由新增額外的關鍵字參數，"
"但只有此處定義的參數才會被 Python 編解碼器註冊表使用。"

#: ../../library/codecs.rst:595
#, fuzzy
msgid ""
"The :class:`IncrementalEncoder` may implement different error handling "
"schemes by providing the *errors* keyword argument. See :ref:`error-"
"handlers` for possible values."
msgstr ""
":class:`IncrementalEncoder` 可以通過提供 *errors* "
"關鍵字參數來實作不同的錯誤處理方案。有關可能的值，請參閱 :ref:`error-"
"handlers`。"

#: ../../library/codecs.rst:599
#, fuzzy
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:"
"`IncrementalEncoder` object."
msgstr ""
"*errors* 參數將分配給同名的屬性。分配給此屬性可以在 IncrementalEncoder "
"物件的生命週期內在不同的錯誤處理策略之間切換。"

#: ../../library/codecs.rst:607
#, fuzzy
msgid ""
"Encodes *object* (taking the current state of the encoder into account) and "
"returns the resulting encoded object. If this is the last call to :meth:"
"`encode` *final* must be true (the default is false)."
msgstr ""
"編碼 *object* （考慮編碼器的當前狀態）並回傳生成的編碼物件。"
"如果這是最後一次呼叫 :meth:`encode` *final* 必須為真（預設為假）。"

#: ../../library/codecs.rst:614
#, fuzzy
msgid ""
"Reset the encoder to the initial state. The output is discarded: call ``."
"encode(object, final=True)``, passing an empty byte or text string if "
"necessary, to reset the encoder and to get the output."
msgstr ""
"將編碼器重置為初始狀態。輸出被丟棄：呼叫``.encode(object, "
"final=True)``，必要時傳遞一個空位元組或文本字串，以重置編碼器並獲得輸出。"

#: ../../library/codecs.rst:621
#, fuzzy
msgid ""
"Return the current state of the encoder which must be an integer. The "
"implementation should make sure that ``0`` is the most common state. (States "
"that are more complicated than integers can be converted into an integer by "
"marshaling/pickling the state and encoding the bytes of the resulting string "
"into an integer.)"
msgstr ""
"回傳編碼器的當前狀態，它必須是一個整數。實作應確保 ``0``是最常見的狀態。 （比整"
"數更複雜的狀態可以通過編組/酸洗狀態並將結果字串的位元組編碼為整數來轉換為整數"
"。）"

#: ../../library/codecs.rst:630
#, fuzzy
msgid ""
"Set the state of the encoder to *state*. *state* must be an encoder state "
"returned by :meth:`getstate`."
msgstr "將編碼器的狀態設定為*state*。 *state* 必須是 getstate 回傳的編碼器狀態。"

#: ../../library/codecs.rst:637
msgid "IncrementalDecoder Objects"
msgstr "IncrementalDecoder 物件"

#: ../../library/codecs.rst:639
#, fuzzy
msgid ""
"The :class:`IncrementalDecoder` class is used for decoding an input in "
"multiple steps. It defines the following methods which every incremental "
"decoder must define in order to be compatible with the Python codec registry."
msgstr ""
":class:`IncrementalDecoder` "
"類用於在多個步驟中解碼輸入。它定義了以下每個增量解碼器必須定義的方法，以便與 "
"Python 編解碼器註冊表相容。"

#: ../../library/codecs.rst:646
#, fuzzy
msgid "Constructor for an :class:`IncrementalDecoder` instance."
msgstr ":class:`IncrementalDecoder` 實例的構造函式。"

#: ../../library/codecs.rst:648
#, fuzzy
msgid ""
"All incremental decoders must provide this constructor interface. They are "
"free to add additional keyword arguments, but only the ones defined here are "
"used by the Python codec registry."
msgstr "所有增量解碼器都必須提供這個構造函式介面。他們可以自由新增額外的關鍵字參數，"
"但只有此處定義的參數才會被 Python 編解碼器註冊表使用。"

#: ../../library/codecs.rst:652
#, fuzzy
msgid ""
"The :class:`IncrementalDecoder` may implement different error handling "
"schemes by providing the *errors* keyword argument. See :ref:`error-"
"handlers` for possible values."
msgstr ""
":class:`IncrementalDecoder` 可以通過提供 *errors* "
"關鍵字參數來實作不同的錯誤處理方案。有關可能的值，請參閱 :ref:`error-"
"handlers`。"

#: ../../library/codecs.rst:656
#, fuzzy
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:"
"`IncrementalDecoder` object."
msgstr ""
"*errors* 參數將分配給同名的屬性。分配給此屬性可以在 IncrementalDecoder "
"物件的生命週期內在不同的錯誤處理策略之間切換。"

#: ../../library/codecs.rst:664
#, fuzzy
msgid ""
"Decodes *object* (taking the current state of the decoder into account) and "
"returns the resulting decoded object. If this is the last call to :meth:"
"`decode` *final* must be true (the default is false). If *final* is true the "
"decoder must decode the input completely and must flush all buffers. If this "
"isn't possible (e.g. because of incomplete byte sequences at the end of the "
"input) it must initiate error handling just like in the stateless case "
"(which might raise an exception)."
msgstr ""
"解碼 *object*（考慮解碼器的當前狀態）並回傳生成的解碼物件。如果這是對 "
":meth:`decode` 的最後一次呼叫，*final* 必須為真（預設為假）。如果 *final* 為"
"真，則解碼器必須完全解碼輸入並且必須刷新所有緩衝區。如果這是不可能的（例如，"
"由於輸入末尾的位元組序列不完整），它必須啟動錯誤處理，就像在無狀態情況下一樣"
"（這可能會引發例外）。"

#: ../../library/codecs.rst:675
#, fuzzy
msgid "Reset the decoder to the initial state."
msgstr "將解碼器重置為初始狀態。"

#: ../../library/codecs.rst:680
#, fuzzy
msgid ""
"Return the current state of the decoder. This must be a tuple with two "
"items, the first must be the buffer containing the still undecoded input. "
"The second must be an integer and can be additional state info. (The "
"implementation should make sure that ``0`` is the most common additional "
"state info.) If this additional state info is ``0`` it must be possible to "
"set the decoder to the state which has no input buffered and ``0`` as the "
"additional state info, so that feeding the previously buffered input to the "
"decoder returns it to the previous state without producing any output. "
"(Additional state info that is more complicated than integers can be "
"converted into an integer by marshaling/pickling the info and encoding the "
"bytes of the resulting string into an integer.)"
msgstr ""
"回傳解碼器的當前狀態。這必須是一個包含兩項的元組，第一項必須是包含仍未解碼的"
"輸入的緩衝區。第二個必須是整數，可以是附加狀態資訊。 （實作應確保 ``0``是最常見"
"的附加狀態資訊。）如果此附加狀態資訊為 ``0``，則必須可以將解碼器設定為沒有輸入緩"
"沖和“ `0`` 作為附加狀態資訊，以便將先前緩衝的輸入提供給解碼器將其回傳到先前狀"
"態而不產生任何輸出。 （比整數更複雜的附加狀態資訊可以通過編組/醃製資訊並將結"
"果字串的位元組編碼為整數來轉換為整數。）"

#: ../../library/codecs.rst:695
#, fuzzy
msgid ""
"Set the state of the decoder to *state*. *state* must be a decoder state "
"returned by :meth:`getstate`."
msgstr "將解碼器的狀態設定為*state*。 *state* 必須是 getstate 回傳的解碼器狀態。"

#: ../../library/codecs.rst:700
#, fuzzy
msgid "Stream Encoding and Decoding"
msgstr "流編解碼"

#: ../../library/codecs.rst:703
#, fuzzy
msgid ""
"The :class:`StreamWriter` and :class:`StreamReader` classes provide generic "
"working interfaces which can be used to implement new encoding submodules "
"very easily. See :mod:`encodings.utf_8` for an example of how this is done."
msgstr ""
":class:`StreamWriter` 和 :class:`StreamReader` 類提供通用工作介面，可用於非常"
"輕鬆地實作新的編碼子模組。有關如何完成此操作的示例，請參見 :mod:`encodings."
"utf_8`。"

#: ../../library/codecs.rst:711
msgid "StreamWriter Objects"
msgstr "StreamWriter 物件"

#: ../../library/codecs.rst:713
#, fuzzy
msgid ""
"The :class:`StreamWriter` class is a subclass of :class:`Codec` and defines "
"the following methods which every stream writer must define in order to be "
"compatible with the Python codec registry."
msgstr ""
":class:`StreamWriter` 類是 :class:`Codec` 的子類別並定義了以下方法，"
"每個流編寫器都必須定義這些方法才能與 Python 編解碼器註冊表相容。"

#: ../../library/codecs.rst:720
#, fuzzy
msgid "Constructor for a :class:`StreamWriter` instance."
msgstr ":class:`StreamWriter` 實例的構造函式。"

#: ../../library/codecs.rst:722
#, fuzzy
msgid ""
"All stream writers must provide this constructor interface. They are free to "
"add additional keyword arguments, but only the ones defined here are used by "
"the Python codec registry."
msgstr "所有流編寫器都必須提供此構造函式介面。他們可以自由新增額外的關鍵字參數，"
"但只有此處定義的參數才會被 Python 編解碼器註冊表使用。"

#: ../../library/codecs.rst:726
#, fuzzy
msgid ""
"The *stream* argument must be a file-like object open for writing text or "
"binary data, as appropriate for the specific codec."
msgstr "*stream* "
"參數必須是為寫入文本或二進位資料而打開的類文件物件，適用於特定的編解碼器。"

#: ../../library/codecs.rst:729
#, fuzzy
msgid ""
"The :class:`StreamWriter` may implement different error handling schemes by "
"providing the *errors* keyword argument. See :ref:`error-handlers` for the "
"standard error handlers the underlying stream codec may support."
msgstr ""
"StreamWriter 可以通過提供 *errors* 關鍵字參數來實作不同的錯誤處理方案。有關底"
"層流編解碼器可能支援的標準錯誤處理程式，請參閱 :ref:`error-handlers`。"

#: ../../library/codecs.rst:733
#, fuzzy
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:`StreamWriter` "
"object."
msgstr "*errors* 參數將分配給同名的屬性。分配給此屬性可以在 StreamWriter "
"物件的生命週期內在不同的錯誤處理策略之間切換。"

#: ../../library/codecs.rst:739
#, fuzzy
msgid "Writes the object's contents encoded to the stream."
msgstr "將物件的編碼內容寫入流。"

#: ../../library/codecs.rst:744
#, fuzzy
msgid ""
"Writes the concatenated iterable of strings to the stream (possibly by "
"reusing the :meth:`write` method). Infinite or very large iterables are not "
"supported. The standard bytes-to-bytes codecs do not support this method."
msgstr "將串接的可疊代字串寫入流（可能通過重用 write "
"方法）。不支援無限或非常大的疊代。標準位元組到位元組編解碼器不支援此方法。"

#: ../../library/codecs.rst:752 ../../library/codecs.rst:847
#, fuzzy
msgid "Resets the codec buffers used for keeping internal state."
msgstr "重置用於保持內部狀態的編解碼器緩衝區。"

#: ../../library/codecs.rst:754
#, fuzzy
msgid ""
"Calling this method should ensure that the data on the output is put into a "
"clean state that allows appending of new fresh data without having to rescan "
"the whole stream to recover state."
msgstr "呼叫此方法應確保輸出上的資料處於乾淨狀態，允許附加新資料而無需重新掃描整個流"
"以恢復狀態。"

#: ../../library/codecs.rst:759
#, fuzzy
msgid ""
"In addition to the above methods, the :class:`StreamWriter` must also "
"inherit all other methods and attributes from the underlying stream."
msgstr "除了上述方法之外，StreamWriter 還必須繼承底層流的所有其他方法和屬性。"

#: ../../library/codecs.rst:766
msgid "StreamReader Objects"
msgstr "StreamReader 物件"

#: ../../library/codecs.rst:768
#, fuzzy
msgid ""
"The :class:`StreamReader` class is a subclass of :class:`Codec` and defines "
"the following methods which every stream reader must define in order to be "
"compatible with the Python codec registry."
msgstr ""
":class:`StreamReader` 類是 :class:`Codec` 的子類別，並定義了以下方法，"
"每個流閱讀器都必須定義這些方法才能與 Python 編解碼器註冊表相容。"

#: ../../library/codecs.rst:775
#, fuzzy
msgid "Constructor for a :class:`StreamReader` instance."
msgstr ":class:`StreamReader` 實例的構造函式。"

#: ../../library/codecs.rst:777
#, fuzzy
msgid ""
"All stream readers must provide this constructor interface. They are free to "
"add additional keyword arguments, but only the ones defined here are used by "
"the Python codec registry."
msgstr "所有的流閱讀器都必須提供這個構造函式介面。他們可以自由新增額外的關鍵字參數，"
"但只有此處定義的參數才會被 Python 編解碼器註冊表使用。"

#: ../../library/codecs.rst:781
#, fuzzy
msgid ""
"The *stream* argument must be a file-like object open for reading text or "
"binary data, as appropriate for the specific codec."
msgstr "*stream* "
"參數必須是為讀取文本或二進位資料而打開的類文件物件，適用於特定的編解碼器。"

#: ../../library/codecs.rst:784
#, fuzzy
msgid ""
"The :class:`StreamReader` may implement different error handling schemes by "
"providing the *errors* keyword argument. See :ref:`error-handlers` for the "
"standard error handlers the underlying stream codec may support."
msgstr ""
"StreamReader 可以通過提供 *errors* 關鍵字參數來實作不同的錯誤處理方案。有關底"
"層流編解碼器可能支援的標準錯誤處理程式，請參閱 :ref:`error-handlers`。"

#: ../../library/codecs.rst:788
#, fuzzy
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:`StreamReader` "
"object."
msgstr "*errors* 參數將分配給同名的屬性。分配給此屬性可以在 StreamReader "
"物件的生命週期內在不同的錯誤處理策略之間切換。"

#: ../../library/codecs.rst:792
#, fuzzy
msgid ""
"The set of allowed values for the *errors* argument can be extended with :"
"func:`register_error`."
msgstr "*errors* 參數的允許值集可以用 :func:`register_error` 擴充。"

#: ../../library/codecs.rst:798
#, fuzzy
msgid "Decodes data from the stream and returns the resulting object."
msgstr "從流中解碼資料並回傳結果物件。"

#: ../../library/codecs.rst:800
#, fuzzy
msgid ""
"The *chars* argument indicates the number of decoded code points or bytes to "
"return. The :func:`read` method will never return more data than requested, "
"but it might return less, if there is not enough available."
msgstr ""
"*chars* 參數指示要回傳的解碼程式碼點或位元組數。 :func:`read` 方法永遠不會回"
"傳比請求更多的資料，但如果沒有足夠的可用資料，它可能會回傳更少的資料。"

#: ../../library/codecs.rst:805
#, fuzzy
msgid ""
"The *size* argument indicates the approximate maximum number of encoded "
"bytes or code points to read for decoding. The decoder can modify this "
"setting as appropriate. The default value -1 indicates to read and decode as "
"much as possible. This parameter is intended to prevent having to decode "
"huge files in one step."
msgstr ""
"*size* 參數指示要為解碼讀取的編碼位元組或程式碼點的近似最大數量。解碼器可以適"
"當修改此設定。預設值-1表示盡可能讀取和解碼。此參數旨在防止必須在一個步驟中解"
"碼大文件。"

#: ../../library/codecs.rst:812
#, fuzzy
msgid ""
"The *firstline* flag indicates that it would be sufficient to only return "
"the first line, if there are decoding errors on later lines."
msgstr "*firstline* 旗標表示如果後面的行有解碼錯誤，只回傳第一行就足夠了。"

#: ../../library/codecs.rst:816
#, fuzzy
msgid ""
"The method should use a greedy read strategy meaning that it should read as "
"much data as is allowed within the definition of the encoding and the given "
"size, e.g.  if optional encoding endings or state markers are available on "
"the stream, these should be read too."
msgstr ""
"該方法應該使用貪婪讀取策略，這意味著它應該讀取編碼定義和給定大小內允許的盡可"
"能多的資料，例如如果流上有可選的編碼結尾或狀態標記，則也應讀取這些內容。"

#: ../../library/codecs.rst:824
#, fuzzy
msgid "Read one line from the input stream and return the decoded data."
msgstr "從輸入流中讀取一行並回傳解碼後的資料。"

#: ../../library/codecs.rst:826
#, fuzzy
msgid ""
"*size*, if given, is passed as size argument to the stream's :meth:`read` "
"method."
msgstr "*size*，如果給定，作為大小參數傳遞給流的 read 方法。"

#: ../../library/codecs.rst:829
#, fuzzy
msgid ""
"If *keepends* is false line-endings will be stripped from the lines returned."
msgstr "如果 *keepends* 為 false，行尾將從回傳的行中刪除。"

#: ../../library/codecs.rst:835
#, fuzzy
msgid ""
"Read all lines available on the input stream and return them as a list of "
"lines."
msgstr "讀取輸入流中可用的所有行並將它們作為行列表回傳。"

#: ../../library/codecs.rst:838
#, fuzzy
msgid ""
"Line-endings are implemented using the codec's :meth:`decode` method and are "
"included in the list entries if *keepends* is true."
msgstr "行尾是使用編解碼器的 decode 方法實作的，如果 *keepends* "
"為真，則行尾包含在列表條目中。"

#: ../../library/codecs.rst:841
#, fuzzy
msgid ""
"*sizehint*, if given, is passed as the *size* argument to the stream's :meth:"
"`read` method."
msgstr "*sizehint*，如果給定，作為 *size* 參數傳遞給流的 read 方法。"

#: ../../library/codecs.rst:849
#, fuzzy
msgid ""
"Note that no stream repositioning should take place. This method is "
"primarily intended to be able to recover from decoding errors."
msgstr "請注意，不應發生流重新定位。此方法主要旨在能夠從解碼錯誤中恢復。"

#: ../../library/codecs.rst:853
#, fuzzy
msgid ""
"In addition to the above methods, the :class:`StreamReader` must also "
"inherit all other methods and attributes from the underlying stream."
msgstr "除了上述方法之外，StreamReader 還必須繼承底層流的所有其他方法和屬性。"

#: ../../library/codecs.rst:859
msgid "StreamReaderWriter Objects"
msgstr "StreamReaderWriter 物件"

#: ../../library/codecs.rst:861
#, fuzzy
msgid ""
"The :class:`StreamReaderWriter` is a convenience class that allows wrapping "
"streams which work in both read and write modes."
msgstr ":class:`StreamReaderWriter` "
"是一個方便的類，它允許包裝在讀取和寫入模式下工作的流。"

#: ../../library/codecs.rst:864 ../../library/codecs.rst:888
#, fuzzy
msgid ""
"The design is such that one can use the factory functions returned by the :"
"func:`lookup` function to construct the instance."
msgstr "設計是這樣的，可以使用 :func:`lookup` 函式回傳的工廠函式來構造實例。"

#: ../../library/codecs.rst:870
#, fuzzy
msgid ""
"Creates a :class:`StreamReaderWriter` instance. *stream* must be a file-like "
"object. *Reader* and *Writer* must be factory functions or classes providing "
"the :class:`StreamReader` and :class:`StreamWriter` interface resp. Error "
"handling is done in the same way as defined for the stream readers and "
"writers."
msgstr ""
"建立一個 StreamReaderWriter 實例。 *stream* 必須是類文件物件。 *Reader* 和 "
"*Writer* 必須是提供 StreamReader 和 StreamWriter "
"介面的工廠函式或類。錯誤處理的方式與為流讀取器和寫入器定義的方式相同。"

#: ../../library/codecs.rst:875
#, fuzzy
msgid ""
":class:`StreamReaderWriter` instances define the combined interfaces of :"
"class:`StreamReader` and :class:`StreamWriter` classes. They inherit all "
"other methods and attributes from the underlying stream."
msgstr ""
":class:`StreamReaderWriter` 實例定義了 :class:`StreamReader` 和 "
":class:`StreamWriter` 類的組合介面。它們從底層流繼承所有其他方法和屬性。"

#: ../../library/codecs.rst:883
msgid "StreamRecoder Objects"
msgstr "StreamRecoder 物件"

#: ../../library/codecs.rst:885
#, fuzzy
msgid ""
"The :class:`StreamRecoder` translates data from one encoding to another, "
"which is sometimes useful when dealing with different encoding environments."
msgstr "StreamRecoder "
"將資料從一種編碼轉換為另一種編碼，這在處理不同的編碼環境時有時很有用。"

#: ../../library/codecs.rst:894
msgid ""
"Creates a :class:`StreamRecoder` instance which implements a two-way "
"conversion: *encode* and *decode* work on the frontend — the data visible to "
"code calling :meth:`read` and :meth:`write`, while *Reader* and *Writer* "
"work on the backend — the data in *stream*."
msgstr ""

#: ../../library/codecs.rst:899
#, fuzzy
msgid ""
"You can use these objects to do transparent transcodings, e.g., from Latin-1 "
"to UTF-8 and back."
msgstr "您可以使用這些物件進行透明轉碼，例如，從 Latin-1 到 UTF-8 並回傳。"

#: ../../library/codecs.rst:902
#, fuzzy
msgid "The *stream* argument must be a file-like object."
msgstr "*stream* 參數必須是類文件物件。"

#: ../../library/codecs.rst:904
#, fuzzy
msgid ""
"The *encode* and *decode* arguments must adhere to the :class:`Codec` "
"interface. *Reader* and *Writer* must be factory functions or classes "
"providing objects of the :class:`StreamReader` and :class:`StreamWriter` "
"interface respectively."
msgstr ""
"*encode* 和 *decode* 參數必須遵守 Codec 介面。 *Reader* 和 *Writer* "
"必須是分別提供 StreamReader 和 StreamWriter 介面物件的工廠函式或類。"

#: ../../library/codecs.rst:909
#, fuzzy
msgid ""
"Error handling is done in the same way as defined for the stream readers and "
"writers."
msgstr "錯誤處理的方式與為流讀取器和寫入器定義的方式相同。"

#: ../../library/codecs.rst:913
#, fuzzy
msgid ""
":class:`StreamRecoder` instances define the combined interfaces of :class:"
"`StreamReader` and :class:`StreamWriter` classes. They inherit all other "
"methods and attributes from the underlying stream."
msgstr ""
":class:`StreamRecoder` 實例定義了 :class:`StreamReader` 和 "
":class:`StreamWriter` 類的組合介面。它們從底層流繼承所有其他方法和屬性。"

#: ../../library/codecs.rst:921
#, fuzzy
msgid "Encodings and Unicode"
msgstr "編碼和 Unicode"

#: ../../library/codecs.rst:923
#, fuzzy
msgid ""
"Strings are stored internally as sequences of code points in range "
"``U+0000``--``U+10FFFF``. (See :pep:`393` for more details about the "
"implementation.) Once a string object is used outside of CPU and memory, "
"endianness and how these arrays are stored as bytes become an issue. As with "
"other codecs, serialising a string into a sequence of bytes is known as "
"*encoding*, and recreating the string from the sequence of bytes is known as "
"*decoding*. There are a variety of different text serialisation codecs, "
"which are collectivity referred to as :term:`text encodings <text encoding>`."
msgstr ""
"字串在內部儲存為 ``U+0000``--``U+10FFFF`` 範圍內的程式碼點序列。 "
"（有關實作的更多詳細資訊，請參閱 :pep:`393`。）一旦在 CPU 和記憶體之外使用字"
"串物件，位元組順序以及這些數組如何儲存為位元組就成為問題。與其他編解碼器一樣"
"，將字串序列化為位元組序列稱為*編碼*，而從位元組序列重新建立字串稱為*解碼*。"
"有多種不同的文本序列化編解碼器，統稱為 :term:`text encodings <text "
"encoding>`。"

#: ../../library/codecs.rst:933
#, fuzzy
msgid ""
"The simplest text encoding (called ``'latin-1'`` or ``'iso-8859-1'``) maps "
"the code points 0--255 to the bytes ``0x0``--``0xff``, which means that a "
"string object that contains code points above ``U+00FF`` can't be encoded "
"with this codec. Doing so will raise a :exc:`UnicodeEncodeError` that looks "
"like the following (although the details of the error message may differ): "
"``UnicodeEncodeError: 'latin-1' codec can't encode character '\\u1234' in "
"position 3: ordinal not in range(256)``."
msgstr ""
"最簡單的文本編碼（稱為 ``'latin-1'`` 或 ``'iso-8859-1'``）將程式碼點 0--255 "
"映射到位元組 ``0x0``--``0xff` `，這意味著包含程式碼點高於 ``U+00FF`` "
"的字串對像不能使用此編解碼器進行編碼。這樣做會引發如下所示的 :exc:`UnicodeEnc"
"odeError`（儘管錯誤消息的詳細資訊可能不同）：``UnicodeEncodeError: 'latin-1' "
"codec can't encode character '\\u1234' in position 3 "
"：序號不在範圍內（256）``。"

#: ../../library/codecs.rst:941
#, fuzzy
msgid ""
"There's another group of encodings (the so called charmap encodings) that "
"choose a different subset of all Unicode code points and how these code "
"points are mapped to the bytes ``0x0``--``0xff``. To see how this is done "
"simply open e.g. :file:`encodings/cp1252.py` (which is an encoding that is "
"used primarily on Windows). There's a string constant with 256 characters "
"that shows you which character is mapped to which byte value."
msgstr ""
"還有另一組編碼（所謂的 charmap 編碼）選擇所有 Unicode "
"程式碼點的不同子集以及這些程式碼點如何映射到位元組 "
"``0x0``--``0xff``。要查看這是如何完成的，只需打開例如 :file:`encodings/cp1252."
"py`（這是一種主要用於 Windows 的編碼）。有一個包含 256 "
"個字元的字串常數，它向您顯示哪個字元映射到哪個位元組值。"

#: ../../library/codecs.rst:948
#, fuzzy
msgid ""
"All of these encodings can only encode 256 of the 1114112 code points "
"defined in Unicode. A simple and straightforward way that can store each "
"Unicode code point, is to store each code point as four consecutive bytes. "
"There are two possibilities: store the bytes in big endian or in little "
"endian order. These two encodings are called ``UTF-32-BE`` and ``UTF-32-LE`` "
"respectively. Their disadvantage is that if e.g. you use ``UTF-32-BE`` on a "
"little endian machine you will always have to swap bytes on encoding and "
"decoding. ``UTF-32`` avoids this problem: bytes will always be in natural "
"endianness. When these bytes are read by a CPU with a different endianness, "
"then bytes have to be swapped though. To be able to detect the endianness of "
"a ``UTF-16`` or ``UTF-32`` byte sequence, there's the so called BOM (\"Byte "
"Order Mark\"). This is the Unicode character ``U+FEFF``. This character can "
"be prepended to every ``UTF-16`` or ``UTF-32`` byte sequence. The byte "
"swapped version of this character (``0xFFFE``) is an illegal character that "
"may not appear in a Unicode text. So when the first character in a "
"``UTF-16`` or ``UTF-32`` byte sequence appears to be a ``U+FFFE`` the bytes "
"have to be swapped on decoding. Unfortunately the character ``U+FEFF`` had a "
"second purpose as a ``ZERO WIDTH NO-BREAK SPACE``: a character that has no "
"width and doesn't allow a word to be split. It can e.g. be used to give "
"hints to a ligature algorithm. With Unicode 4.0 using ``U+FEFF`` as a ``ZERO "
"WIDTH NO-BREAK SPACE`` has been deprecated (with ``U+2060`` (``WORD "
"JOINER``) assuming this role). Nevertheless Unicode software still must be "
"able to handle ``U+FEFF`` in both roles: as a BOM it's a device to determine "
"the storage layout of the encoded bytes, and vanishes once the byte sequence "
"has been decoded into a string; as a ``ZERO WIDTH NO-BREAK SPACE`` it's a "
"normal character that will be decoded like any other."
msgstr ""
"所有這些編碼只能編碼 Unicode 中定義的 1114112 個程式碼點中的 256 個。"
"可以儲存每個 Unicode 程式碼點的一種簡單直接的方法是將每個程式碼點儲存為四個連"
"續位元組。有兩種可能性：以大端或小端順序儲存位元組。這兩種編碼分別稱為“UTF-32"
"-BE”和 ``UTF-32-LE`` 。他們的缺點是，如果例如。你在小端機器上使用 ``UTF-32-BE`` "
"你總是必須在編碼和解碼時交換位元組。 ``UTF-32`` "
"避免了這個問題：位元組將始終處於自然位元組順序。"
"當這些位元組被具有不同位元組順序的 CPU 讀取時，則必須交換位元組。"
"為了能夠檢測 ``UTF-16`` 或 ``UTF-32`` 位元組序列的位元組序，有所謂的 "
"BOM（“位元組順序標記”）。這是 Unicode "
"字元 ``U+FEFF``。該字元可以新增到每個 ``UTF-16``或 ``UTF-32``位元組序列之前。"
"此字元的位元組交換版本 (``0xFFFE``) 是一個非法字元，可能不會出現在 Unicode 文"
"本中。因此，當 ``UTF-16``或 ``UTF-32``位元組序列中的第一個字元出現為 ``U+FFFE``時，必"
"須在解碼時交換位元組。不幸的是，字元 ``U+FEFF``還有另一個用途，即“零寬度不間斷空"
"格”：一個沒有寬度且不允許拆分單詞的字元。它可以例如用於提示連字演算法。在 "
"Unicode 4.0 中，使用 ``U+FEFF`` 作為 ``ZERO WIDTH NO-BREAK SPACE`` 已被棄用（"
"使用 ``U+2060`` (``WORD JOINER``) 承擔了這個角色）。儘管如此，Unicode "
"軟件仍然必須能夠處理兩種角色的 ``U+FEFF``：作為 BOM，它是一種確定編碼位元組儲存"
"佈局的設備，一旦位元組序列被解碼為字串，它就會消失；作為“零寬度不間斷空格”，"
"它是一個普通字元，將像其他任何字元一樣被解碼。"

#: ../../library/codecs.rst:974
#, fuzzy
msgid ""
"There's another encoding that is able to encode the full range of Unicode "
"characters: UTF-8. UTF-8 is an 8-bit encoding, which means there are no "
"issues with byte order in UTF-8. Each byte in a UTF-8 byte sequence consists "
"of two parts: marker bits (the most significant bits) and payload bits. The "
"marker bits are a sequence of zero to four ``1`` bits followed by a ``0`` "
"bit. Unicode characters are encoded like this (with x being payload bits, "
"which when concatenated give the Unicode character):"
msgstr ""
"還有另一種編碼能夠對所有 Unicode 字元進行編碼：UTF-8。 UTF-8 是一種 8 "
"位編碼，這意味著 UTF-8 中的位元組順序沒有問題。 UTF-8 位元組序列中的每個位元"
"組由兩部分組成：標記位（最高有效位）和有效載荷位。標記位是零到四個 ``1``位後跟一"
"個 ``0``位的序列。 Unicode 字元編碼如下（x 是有效負載位，連接時給出 Unicode "
"字元）："

#: ../../library/codecs.rst:983
#, fuzzy
msgid "Range"
msgstr "範圍"

#: ../../library/codecs.rst:983
#, fuzzy
msgid "Encoding"
msgstr "編碼"

#: ../../library/codecs.rst:985
msgid "``U-00000000`` ... ``U-0000007F``"
msgstr "``U-00000000`` ... ``U-0000007F``"

#: ../../library/codecs.rst:985
msgid "0xxxxxxx"
msgstr "0xxxxxxx"

#: ../../library/codecs.rst:987
msgid "``U-00000080`` ... ``U-000007FF``"
msgstr "``U-00000080`` ... ``U-000007FF``"

#: ../../library/codecs.rst:987
msgid "110xxxxx 10xxxxxx"
msgstr "110xxxxx 10xxxxxx"

#: ../../library/codecs.rst:989
msgid "``U-00000800`` ... ``U-0000FFFF``"
msgstr "``U-00000800`` ... ``U-0000FFFF``"

#: ../../library/codecs.rst:989
msgid "1110xxxx 10xxxxxx 10xxxxxx"
msgstr "1110xxxx 10xxxxxx 10xxxxxx"

#: ../../library/codecs.rst:991
msgid "``U-00010000`` ... ``U-0010FFFF``"
msgstr "``U-00010000`` ... ``U-0010FFFF``"

#: ../../library/codecs.rst:991
msgid "11110xxx 10xxxxxx 10xxxxxx 10xxxxxx"
msgstr "11110xxx 10xxxxxx 10xxxxxx 10xxxxxx"

#: ../../library/codecs.rst:994
#, fuzzy
msgid ""
"The least significant bit of the Unicode character is the rightmost x bit."
msgstr "Unicode 字元的最低有效位是最右邊的 x 位。"

#: ../../library/codecs.rst:996
#, fuzzy
msgid ""
"As UTF-8 is an 8-bit encoding no BOM is required and any ``U+FEFF`` "
"character in the decoded string (even if it's the first character) is "
"treated as a ``ZERO WIDTH NO-BREAK SPACE``."
msgstr ""
"由於 UTF-8 是一種 8 位編碼，因此不需要 BOM，並且解碼字串中的任何 ``U+FEFF``字元"
"（即使它是第一個字元）都被視為“零寬度不間斷空格” ."

#: ../../library/codecs.rst:1000
#, fuzzy
msgid ""
"Without external information it's impossible to reliably determine which "
"encoding was used for encoding a string. Each charmap encoding can decode "
"any random byte sequence. However that's not possible with UTF-8, as UTF-8 "
"byte sequences have a structure that doesn't allow arbitrary byte sequences. "
"To increase the reliability with which a UTF-8 encoding can be detected, "
"Microsoft invented a variant of UTF-8 (that Python calls ``\"utf-8-sig\"``) "
"for its Notepad program: Before any of the Unicode characters is written to "
"the file, a UTF-8 encoded BOM (which looks like this as a byte sequence: "
"``0xef``, ``0xbb``, ``0xbf``) is written. As it's rather improbable that any "
"charmap encoded file starts with these byte values (which would e.g. map to"
msgstr ""
"如果沒有外部資訊，就不可能可靠地確定使用了哪種編碼來對字串進行編碼。每個 "
"charmap 編碼都可以解碼任何隨機位元組序列。然而，這對於 UTF-8 是不可能的，"
"因為 UTF-8 位元組序列的結構不允許任意位元組序列。為了提高檢測 UTF-8 "
"編碼的可靠性，Microsoft 為其記事本程式發明了 UTF-8 的變體（Python "
"稱為 ``utf-8-sig`` ）：在任何 Unicode 字元之前寫入文件時，將寫入 UTF-8 編碼的 "
"BOM（看起來像這樣的位元組序列：``0xef``、``0xbb``、``0xbf``）。因為任何 "
"charmap 編碼文件都不太可能以這些位元組值開頭（例如映射到"

#: ../../library/codecs.rst:0
#, fuzzy
msgid "LATIN SMALL LETTER I WITH DIAERESIS"
msgstr "帶分音符的拉丁文小寫字母 I"

#: ../../library/codecs.rst:0
#, fuzzy
msgid "RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK"
msgstr "右指雙角引號"

#: ../../library/codecs.rst:0
#, fuzzy
msgid "INVERTED QUESTION MARK"
msgstr "倒問號"

#: ../../library/codecs.rst:1016
#, fuzzy
msgid ""
"in iso-8859-1), this increases the probability that a ``utf-8-sig`` encoding "
"can be correctly guessed from the byte sequence. So here the BOM is not used "
"to be able to determine the byte order used for generating the byte "
"sequence, but as a signature that helps in guessing the encoding. On "
"encoding the utf-8-sig codec will write ``0xef``, ``0xbb``, ``0xbf`` as the "
"first three bytes to the file. On decoding ``utf-8-sig`` will skip those "
"three bytes if they appear as the first three bytes in the file. In UTF-8, "
"the use of the BOM is discouraged and should generally be avoided."
msgstr ""
"在 iso-8859-1) 中，這增加了從位元組序列中正確猜出 ``utf-8-sig`` 編碼的可能性"
"。所以這裡的BOM並不是用來確定生成位元組序列所用的位元組順序，而是作為一個幫助"
"猜測編碼的簽名。在編碼時，utf-8-sig "
"編解碼器會將 ``0xef``、 ``0xbb``、 ``0xbf``作為文件的前三個位元組寫入。在解碼 "
"``utf-8-sig`` 時，如果它們出現在文件的前三個位元組中，將跳過這三個位元組。在 "
"UTF-8 中，不鼓勵使用 BOM，通常應避免使用。"

#: ../../library/codecs.rst:1029
#, fuzzy
msgid "Standard Encodings"
msgstr "標準編碼"

#: ../../library/codecs.rst:1031
#, fuzzy
msgid ""
"Python comes with a number of codecs built-in, either implemented as C "
"functions or with dictionaries as mapping tables. The following table lists "
"the codecs by name, together with a few common aliases, and the languages "
"for which the encoding is likely used. Neither the list of aliases nor the "
"list of languages is meant to be exhaustive. Notice that spelling "
"alternatives that only differ in case or use a hyphen instead of an "
"underscore are also valid aliases; therefore, e.g. ``'utf-8'`` is a valid "
"alias for the ``'utf_8'`` codec."
msgstr ""
"Python 帶有許多內建的編解碼器，或者以 C 函式的形式實作，或者以字典作為映射表"
"。下表按名稱列出了編解碼器，以及一些常見的別名，以及可能使用編碼的語言。別名"
"列表和語言列表都不是詳盡無遺的。請注意，僅大小寫不同或使用連字元而不是底線"
"的拼寫替代方案也是有效的別名；因此，例如``'utf-8'`` 是 ``'utf_8'`` "
"編解碼器的有效別名。"

#: ../../library/codecs.rst:1041
#, fuzzy
msgid ""
"Some common encodings can bypass the codecs lookup machinery to improve "
"performance. These optimization opportunities are only recognized by CPython "
"for a limited set of (case insensitive) aliases: utf-8, utf8, latin-1, "
"latin1, iso-8859-1, iso8859-1, mbcs (Windows only), ascii, us-ascii, utf-16, "
"utf16, utf-32, utf32, and the same using underscores instead of dashes. "
"Using alternative aliases for these encodings may result in slower execution."
msgstr ""
"一些常見的編碼可以繞過編解碼器查找機制以提高性能。這些最佳化機會僅被 CPython "
"識別為一組有限的（不區分大小寫）別名：utf-8、utf8、latin-1、latin1、iso-8859-"
"1、iso8859-1、mbcs（僅限 Windows）、ascii、us -ascii、utf-16、utf16、utf-32、"
"utf32 等使用底線代替破折號。為這些編碼使用替代別名可能會導致執行速度變慢。"

#: ../../library/codecs.rst:1049
#, fuzzy
msgid "Optimization opportunity recognized for us-ascii."
msgstr "us-ascii 公認的最佳化機會。"

#: ../../library/codecs.rst:1052
#, fuzzy
msgid ""
"Many of the character sets support the same languages. They vary in "
"individual characters (e.g. whether the EURO SIGN is supported or not), and "
"in the assignment of characters to code positions. For the European "
"languages in particular, the following variants typically exist:"
msgstr ""
"許多字元集支援相同的語言。它們在各個字元（例如，是否支援歐元符號）以及字元到"
"程式碼位置的分配方面各不相同。特別是對於歐洲語言，通常存在以下變體："

#: ../../library/codecs.rst:1057
#, fuzzy
msgid "an ISO 8859 codeset"
msgstr "ISO 8859 程式碼集"

#: ../../library/codecs.rst:1059
#, fuzzy
msgid ""
"a Microsoft Windows code page, which is typically derived from an 8859 "
"codeset, but replaces control characters with additional graphic characters"
msgstr "Microsoft Windows 程式碼頁，通常派生自 8859 "
"程式碼集，但用其他圖形字元替換控制字元"

#: ../../library/codecs.rst:1062
#, fuzzy
msgid "an IBM EBCDIC code page"
msgstr "IBM EBCDIC 程式碼頁"

#: ../../library/codecs.rst:1064
#, fuzzy
msgid "an IBM PC code page, which is ASCII compatible"
msgstr "與 ASCII 相容的 IBM PC 程式碼頁"

#: ../../library/codecs.rst:1069 ../../library/codecs.rst:1324
#: ../../library/codecs.rst:1391 ../../library/codecs.rst:1446
#, fuzzy
msgid "Codec"
msgstr "編解碼器"

#: ../../library/codecs.rst:1069 ../../library/codecs.rst:1324
#: ../../library/codecs.rst:1391 ../../library/codecs.rst:1446
#, fuzzy
msgid "Aliases"
msgstr "別名"

#: ../../library/codecs.rst:1069
msgid "Languages"
msgstr "語言"

#: ../../library/codecs.rst:1071
msgid "ascii"
msgstr "ascii"

#: ../../library/codecs.rst:1071
msgid "646, us-ascii"
msgstr "646, us-ascii"

#: ../../library/codecs.rst:1071 ../../library/codecs.rst:1077
#: ../../library/codecs.rst:1085
msgid "English"
msgstr "英文"

#: ../../library/codecs.rst:1073
msgid "big5"
msgstr "big5"

#: ../../library/codecs.rst:1073
msgid "big5-tw, csbig5"
msgstr "big5-tw, csbig5"

#: ../../library/codecs.rst:1073 ../../library/codecs.rst:1075
#: ../../library/codecs.rst:1133
msgid "Traditional Chinese"
msgstr "繁體中文"

#: ../../library/codecs.rst:1075
msgid "big5hkscs"
msgstr "big5hkscs"

#: ../../library/codecs.rst:1075
msgid "big5-hkscs, hkscs"
msgstr "big5-hkscs, hkscs"

#: ../../library/codecs.rst:1077
msgid "cp037"
msgstr "cp037"

#: ../../library/codecs.rst:1077
msgid "IBM037, IBM039"
msgstr "IBM037, IBM039"

#: ../../library/codecs.rst:1079
msgid "cp273"
msgstr "cp273"

#: ../../library/codecs.rst:1079
msgid "273, IBM273, csIBM273"
msgstr "273, IBM273, csIBM273"

#: ../../library/codecs.rst:1079
msgid "German"
msgstr "德文"

#: ../../library/codecs.rst:1083
msgid "cp424"
msgstr "cp424"

#: ../../library/codecs.rst:1083
msgid "EBCDIC-CP-HE, IBM424"
msgstr "EBCDIC-CP-HE, IBM424"

#: ../../library/codecs.rst:1083 ../../library/codecs.rst:1103
#: ../../library/codecs.rst:1113 ../../library/codecs.rst:1156
#: ../../library/codecs.rst:1219
msgid "Hebrew"
msgstr "希伯來文"

#: ../../library/codecs.rst:1085
msgid "cp437"
msgstr "cp437"

#: ../../library/codecs.rst:1085
msgid "437, IBM437"
msgstr "437, IBM437"

#: ../../library/codecs.rst:1087
msgid "cp500"
msgstr "cp500"

#: ../../library/codecs.rst:1087
msgid "EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500"
msgstr "EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500"

#: ../../library/codecs.rst:1087 ../../library/codecs.rst:1096
#: ../../library/codecs.rst:1107 ../../library/codecs.rst:1143
#: ../../library/codecs.rst:1150 ../../library/codecs.rst:1203
#: ../../library/codecs.rst:1231 ../../library/codecs.rst:1259
#, fuzzy
msgid "Western Europe"
msgstr "西歐"

#: ../../library/codecs.rst:1090
msgid "cp720"
msgstr "cp720"

#: ../../library/codecs.rst:1090 ../../library/codecs.rst:1117
#: ../../library/codecs.rst:1158 ../../library/codecs.rst:1215
msgid "Arabic"
msgstr "阿拉伯文"

#: ../../library/codecs.rst:1092
msgid "cp737"
msgstr "cp737"

#: ../../library/codecs.rst:1092 ../../library/codecs.rst:1123
#: ../../library/codecs.rst:1127 ../../library/codecs.rst:1152
#: ../../library/codecs.rst:1217 ../../library/codecs.rst:1252
msgid "Greek"
msgstr "希臘文"

#: ../../library/codecs.rst:1094
msgid "cp775"
msgstr "cp775"

#: ../../library/codecs.rst:1094
msgid "IBM775"
msgstr "IBM775"

#: ../../library/codecs.rst:1094 ../../library/codecs.rst:1160
#: ../../library/codecs.rst:1210 ../../library/codecs.rst:1227
#, fuzzy
msgid "Baltic languages"
msgstr "波羅的海語言"

#: ../../library/codecs.rst:1096
msgid "cp850"
msgstr "cp850"

#: ../../library/codecs.rst:1096
msgid "850, IBM850"
msgstr "850, IBM850"

#: ../../library/codecs.rst:1098
msgid "cp852"
msgstr "cp852"

#: ../../library/codecs.rst:1098
msgid "852, IBM852"
msgstr "852, IBM852"

#: ../../library/codecs.rst:1098 ../../library/codecs.rst:1145
#: ../../library/codecs.rst:1206 ../../library/codecs.rst:1256
#, fuzzy
msgid "Central and Eastern Europe"
msgstr "中東歐"

#: ../../library/codecs.rst:1100
msgid "cp855"
msgstr "cp855"

#: ../../library/codecs.rst:1100
msgid "855, IBM855"
msgstr "855, IBM855"

#: ../../library/codecs.rst:1100 ../../library/codecs.rst:1147
#: ../../library/codecs.rst:1212 ../../library/codecs.rst:1249
#, fuzzy
msgid "Bulgarian, Byelorussian, Macedonian, Russian, Serbian"
msgstr "保加利亞語、白俄羅斯語、馬其頓語、俄語、塞爾維亞語"

#: ../../library/codecs.rst:1103
msgid "cp856"
msgstr "cp856"

#: ../../library/codecs.rst:1105
msgid "cp857"
msgstr "cp857"

#: ../../library/codecs.rst:1105
msgid "857, IBM857"
msgstr "857, IBM857"

#: ../../library/codecs.rst:1105 ../../library/codecs.rst:1137
#: ../../library/codecs.rst:1154 ../../library/codecs.rst:1221
#: ../../library/codecs.rst:1261
msgid "Turkish"
msgstr "土耳其文"

#: ../../library/codecs.rst:1107
msgid "cp858"
msgstr "cp858"

#: ../../library/codecs.rst:1107
msgid "858, IBM858"
msgstr "858, IBM858"

#: ../../library/codecs.rst:1109
msgid "cp860"
msgstr "cp860"

#: ../../library/codecs.rst:1109
msgid "860, IBM860"
msgstr "860, IBM860"

#: ../../library/codecs.rst:1109
#, fuzzy
msgid "Portuguese"
msgstr "葡萄牙語"

#: ../../library/codecs.rst:1111
msgid "cp861"
msgstr "cp861"

#: ../../library/codecs.rst:1111
msgid "861, CP-IS, IBM861"
msgstr "861, CP-IS, IBM861"

#: ../../library/codecs.rst:1111 ../../library/codecs.rst:1254
#, fuzzy
msgid "Icelandic"
msgstr "冰島的"

#: ../../library/codecs.rst:1113
msgid "cp862"
msgstr "cp862"

#: ../../library/codecs.rst:1113
msgid "862, IBM862"
msgstr "862, IBM862"

#: ../../library/codecs.rst:1115
msgid "cp863"
msgstr "cp863"

#: ../../library/codecs.rst:1115
msgid "863, IBM863"
msgstr "863, IBM863"

#: ../../library/codecs.rst:1115
#, fuzzy
msgid "Canadian"
msgstr "加拿大人"

#: ../../library/codecs.rst:1117
msgid "cp864"
msgstr "cp864"

#: ../../library/codecs.rst:1117
msgid "IBM864"
msgstr "IBM864"

#: ../../library/codecs.rst:1119
msgid "cp865"
msgstr "cp865"

#: ../../library/codecs.rst:1119
msgid "865, IBM865"
msgstr "865, IBM865"

#: ../../library/codecs.rst:1119
#, fuzzy
msgid "Danish, Norwegian"
msgstr "丹麥語、挪威語"

#: ../../library/codecs.rst:1121
msgid "cp866"
msgstr "cp866"

#: ../../library/codecs.rst:1121
msgid "866, IBM866"
msgstr "866, IBM866"

#: ../../library/codecs.rst:1121 ../../library/codecs.rst:1237
msgid "Russian"
msgstr "俄羅斯文"

#: ../../library/codecs.rst:1123
msgid "cp869"
msgstr "cp869"

#: ../../library/codecs.rst:1123
msgid "869, CP-GR, IBM869"
msgstr "869, CP-GR, IBM869"

#: ../../library/codecs.rst:1125
msgid "cp874"
msgstr "cp874"

#: ../../library/codecs.rst:1125
msgid "Thai"
msgstr "泰文"

#: ../../library/codecs.rst:1127
msgid "cp875"
msgstr "cp875"

#: ../../library/codecs.rst:1129
msgid "cp932"
msgstr "cp932"

#: ../../library/codecs.rst:1129
msgid "932, ms932, mskanji, ms-kanji"
msgstr "932, ms932, mskanji, ms-kanji"

#: ../../library/codecs.rst:1129 ../../library/codecs.rst:1164
#: ../../library/codecs.rst:1166 ../../library/codecs.rst:1168
#: ../../library/codecs.rst:1185 ../../library/codecs.rst:1188
#: ../../library/codecs.rst:1193 ../../library/codecs.rst:1196
#: ../../library/codecs.rst:1198 ../../library/codecs.rst:1266
#: ../../library/codecs.rst:1269 ../../library/codecs.rst:1272
msgid "Japanese"
msgstr "日文"

#: ../../library/codecs.rst:1131
msgid "cp949"
msgstr "cp949"

#: ../../library/codecs.rst:1131
msgid "949, ms949, uhc"
msgstr "949, ms949, uhc"

#: ../../library/codecs.rst:1131 ../../library/codecs.rst:1170
#: ../../library/codecs.rst:1200 ../../library/codecs.rst:1235
msgid "Korean"
msgstr "韓文"

#: ../../library/codecs.rst:1133
msgid "cp950"
msgstr "cp950"

#: ../../library/codecs.rst:1133
msgid "950, ms950"
msgstr "950, ms950"

#: ../../library/codecs.rst:1135
msgid "cp1006"
msgstr "cp1006"

#: ../../library/codecs.rst:1135
#, fuzzy
msgid "Urdu"
msgstr "烏爾都語"

#: ../../library/codecs.rst:1137
msgid "cp1026"
msgstr "cp1026"

#: ../../library/codecs.rst:1137
msgid "ibm1026"
msgstr "ibm1026"

#: ../../library/codecs.rst:1139
msgid "cp1125"
msgstr "cp1125"

#: ../../library/codecs.rst:1139
msgid "1125, ibm1125, cp866u, ruscii"
msgstr "1125, ibm1125, cp866u, ruscii"

#: ../../library/codecs.rst:1139 ../../library/codecs.rst:1243
msgid "Ukrainian"
msgstr "烏克蘭文"

#: ../../library/codecs.rst:1143
msgid "cp1140"
msgstr "cp1140"

#: ../../library/codecs.rst:1143
msgid "ibm1140"
msgstr "ibm1140"

#: ../../library/codecs.rst:1145
msgid "cp1250"
msgstr "cp1250"

#: ../../library/codecs.rst:1145
msgid "windows-1250"
msgstr "windows-1250"

#: ../../library/codecs.rst:1147
msgid "cp1251"
msgstr "cp1251"

#: ../../library/codecs.rst:1147
msgid "windows-1251"
msgstr "windows-1251"

#: ../../library/codecs.rst:1150
msgid "cp1252"
msgstr "cp1252"

#: ../../library/codecs.rst:1150
msgid "windows-1252"
msgstr "windows-1252"

#: ../../library/codecs.rst:1152
msgid "cp1253"
msgstr "cp1253"

#: ../../library/codecs.rst:1152
msgid "windows-1253"
msgstr "windows-1253"

#: ../../library/codecs.rst:1154
msgid "cp1254"
msgstr "cp1254"

#: ../../library/codecs.rst:1154
msgid "windows-1254"
msgstr "windows-1254"

#: ../../library/codecs.rst:1156
msgid "cp1255"
msgstr "cp1255"

#: ../../library/codecs.rst:1156
msgid "windows-1255"
msgstr "windows-1255"

#: ../../library/codecs.rst:1158
msgid "cp1256"
msgstr "cp1256"

#: ../../library/codecs.rst:1158
msgid "windows-1256"
msgstr "windows-1256"

#: ../../library/codecs.rst:1160
msgid "cp1257"
msgstr "cp1257"

#: ../../library/codecs.rst:1160
msgid "windows-1257"
msgstr "windows-1257"

#: ../../library/codecs.rst:1162
msgid "cp1258"
msgstr "cp1258"

#: ../../library/codecs.rst:1162
msgid "windows-1258"
msgstr "windows-1258"

#: ../../library/codecs.rst:1162
msgid "Vietnamese"
msgstr "越南文"

#: ../../library/codecs.rst:1164
msgid "euc_jp"
msgstr "euc_jp"

#: ../../library/codecs.rst:1164
msgid "eucjp, ujis, u-jis"
msgstr "eucjp, ujis, u-jis"

#: ../../library/codecs.rst:1166
msgid "euc_jis_2004"
msgstr "euc_jis_2004"

#: ../../library/codecs.rst:1166
msgid "jisx0213, eucjis2004"
msgstr "jisx0213, eucjis2004"

#: ../../library/codecs.rst:1168
msgid "euc_jisx0213"
msgstr "euc_jisx0213"

#: ../../library/codecs.rst:1168
msgid "eucjisx0213"
msgstr "eucjisx0213"

#: ../../library/codecs.rst:1170
msgid "euc_kr"
msgstr "euc_kr"

#: ../../library/codecs.rst:1170
msgid "euckr, korean, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001"
msgstr "euckr, korean, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001"

#: ../../library/codecs.rst:1174
msgid "gb2312"
msgstr "gb2312"

#: ../../library/codecs.rst:1174
msgid ""
"chinese, csiso58gb231280, euc-cn, euccn, eucgb2312-cn, gb2312-1980, "
"gb2312-80, iso-ir-58"
msgstr ""
"chinese, csiso58gb231280, euc-cn, euccn, eucgb2312-cn, gb2312-1980, "
"gb2312-80, iso-ir-58"

#: ../../library/codecs.rst:1174 ../../library/codecs.rst:1183
msgid "Simplified Chinese"
msgstr "簡體中文"

#: ../../library/codecs.rst:1179
msgid "gbk"
msgstr "gbk"

#: ../../library/codecs.rst:1179
msgid "936, cp936, ms936"
msgstr "936, cp936, ms936"

#: ../../library/codecs.rst:1179 ../../library/codecs.rst:1181
#, fuzzy
msgid "Unified Chinese"
msgstr "統一中文"

#: ../../library/codecs.rst:1181
msgid "gb18030"
msgstr "gb18030"

#: ../../library/codecs.rst:1181
msgid "gb18030-2000"
msgstr "gb18030-2000"

#: ../../library/codecs.rst:1183
msgid "hz"
msgstr "hz"

#: ../../library/codecs.rst:1183
msgid "hzgb, hz-gb, hz-gb-2312"
msgstr "hzgb, hz-gb, hz-gb-2312"

#: ../../library/codecs.rst:1185
msgid "iso2022_jp"
msgstr "iso2022_jp"

#: ../../library/codecs.rst:1185
msgid "csiso2022jp, iso2022jp, iso-2022-jp"
msgstr "csiso2022jp, iso2022jp, iso-2022-jp"

#: ../../library/codecs.rst:1188
msgid "iso2022_jp_1"
msgstr "iso2022_jp_1"

#: ../../library/codecs.rst:1188
msgid "iso2022jp-1, iso-2022-jp-1"
msgstr "iso2022jp-1, iso-2022-jp-1"

#: ../../library/codecs.rst:1190
msgid "iso2022_jp_2"
msgstr "iso2022_jp_2"

#: ../../library/codecs.rst:1190
msgid "iso2022jp-2, iso-2022-jp-2"
msgstr "iso2022jp-2, iso-2022-jp-2"

#: ../../library/codecs.rst:1190
#, fuzzy
msgid "Japanese, Korean, Simplified Chinese, Western Europe, Greek"
msgstr "日語、韓語、簡體中文、西歐、希臘語"

#: ../../library/codecs.rst:1193
msgid "iso2022_jp_2004"
msgstr "iso2022_jp_2004"

#: ../../library/codecs.rst:1193
msgid "iso2022jp-2004, iso-2022-jp-2004"
msgstr "iso2022jp-2004, iso-2022-jp-2004"

#: ../../library/codecs.rst:1196
msgid "iso2022_jp_3"
msgstr "iso2022_jp_3"

#: ../../library/codecs.rst:1196
msgid "iso2022jp-3, iso-2022-jp-3"
msgstr "iso2022jp-3, iso-2022-jp-3"

#: ../../library/codecs.rst:1198
msgid "iso2022_jp_ext"
msgstr "iso2022_jp_ext"

#: ../../library/codecs.rst:1198
msgid "iso2022jp-ext, iso-2022-jp-ext"
msgstr "iso2022jp-ext, iso-2022-jp-ext"

#: ../../library/codecs.rst:1200
msgid "iso2022_kr"
msgstr "iso2022_kr"

#: ../../library/codecs.rst:1200
msgid "csiso2022kr, iso2022kr, iso-2022-kr"
msgstr "csiso2022kr, iso2022kr, iso-2022-kr"

#: ../../library/codecs.rst:1203
msgid "latin_1"
msgstr "latin_1"

#: ../../library/codecs.rst:1203
msgid "iso-8859-1, iso8859-1, 8859, cp819, latin, latin1, L1"
msgstr "iso-8859-1, iso8859-1, 8859, cp819, latin, latin1, L1"

#: ../../library/codecs.rst:1206
msgid "iso8859_2"
msgstr "iso8859_2"

#: ../../library/codecs.rst:1206
msgid "iso-8859-2, latin2, L2"
msgstr "iso-8859-2, latin2, L2"

#: ../../library/codecs.rst:1208
msgid "iso8859_3"
msgstr "iso8859_3"

#: ../../library/codecs.rst:1208
msgid "iso-8859-3, latin3, L3"
msgstr "iso-8859-3, latin3, L3"

#: ../../library/codecs.rst:1208
#, fuzzy
msgid "Esperanto, Maltese"
msgstr "世界語、馬耳他語"

#: ../../library/codecs.rst:1210
msgid "iso8859_4"
msgstr "iso8859_4"

#: ../../library/codecs.rst:1210
msgid "iso-8859-4, latin4, L4"
msgstr "iso-8859-4, latin4, L4"

#: ../../library/codecs.rst:1212
msgid "iso8859_5"
msgstr "iso8859_5"

#: ../../library/codecs.rst:1212
msgid "iso-8859-5, cyrillic"
msgstr "iso-8859-5, cyrillic"

#: ../../library/codecs.rst:1215
msgid "iso8859_6"
msgstr "iso8859_6"

#: ../../library/codecs.rst:1215
msgid "iso-8859-6, arabic"
msgstr "iso-8859-6, arabic"

#: ../../library/codecs.rst:1217
msgid "iso8859_7"
msgstr "iso8859_7"

#: ../../library/codecs.rst:1217
msgid "iso-8859-7, greek, greek8"
msgstr "iso-8859-7, greek, greek8"

#: ../../library/codecs.rst:1219
msgid "iso8859_8"
msgstr "iso8859_8"

#: ../../library/codecs.rst:1219
msgid "iso-8859-8, hebrew"
msgstr "iso-8859-8, hebrew"

#: ../../library/codecs.rst:1221
msgid "iso8859_9"
msgstr "iso8859_9"

#: ../../library/codecs.rst:1221
msgid "iso-8859-9, latin5, L5"
msgstr "iso-8859-9, latin5, L5"

#: ../../library/codecs.rst:1223
msgid "iso8859_10"
msgstr "iso8859_10"

#: ../../library/codecs.rst:1223
msgid "iso-8859-10, latin6, L6"
msgstr "iso-8859-10, latin6, L6"

#: ../../library/codecs.rst:1223
#, fuzzy
msgid "Nordic languages"
msgstr "北歐語言"

#: ../../library/codecs.rst:1225
msgid "iso8859_11"
msgstr "iso8859_11"

#: ../../library/codecs.rst:1225
msgid "iso-8859-11, thai"
msgstr "iso-8859-11, thai"

#: ../../library/codecs.rst:1225
#, fuzzy
msgid "Thai languages"
msgstr "泰語"

#: ../../library/codecs.rst:1227
msgid "iso8859_13"
msgstr "iso8859_13"

#: ../../library/codecs.rst:1227
msgid "iso-8859-13, latin7, L7"
msgstr "iso-8859-13, latin7, L7"

#: ../../library/codecs.rst:1229
msgid "iso8859_14"
msgstr "iso8859_14"

#: ../../library/codecs.rst:1229
msgid "iso-8859-14, latin8, L8"
msgstr "iso-8859-14, latin8, L8"

#: ../../library/codecs.rst:1229
#, fuzzy
msgid "Celtic languages"
msgstr "凱爾特語"

#: ../../library/codecs.rst:1231
msgid "iso8859_15"
msgstr "iso8859_15"

#: ../../library/codecs.rst:1231
msgid "iso-8859-15, latin9, L9"
msgstr "iso-8859-15, latin9, L9"

#: ../../library/codecs.rst:1233
msgid "iso8859_16"
msgstr "iso8859_16"

#: ../../library/codecs.rst:1233
msgid "iso-8859-16, latin10, L10"
msgstr "iso-8859-16, latin10, L10"

#: ../../library/codecs.rst:1233
#, fuzzy
msgid "South-Eastern Europe"
msgstr "東南歐"

#: ../../library/codecs.rst:1235
#, fuzzy
msgid "johab"
msgstr "約哈布"

#: ../../library/codecs.rst:1235
msgid "cp1361, ms1361"
msgstr "cp1361, ms1361"

#: ../../library/codecs.rst:1237
msgid "koi8_r"
msgstr "koi8_r"

#: ../../library/codecs.rst:1239
msgid "koi8_t"
msgstr "koi8_t"

#: ../../library/codecs.rst:1239
#, fuzzy
msgid "Tajik"
msgstr "塔吉克"

#: ../../library/codecs.rst:1243
msgid "koi8_u"
msgstr "koi8_u"

#: ../../library/codecs.rst:1245
msgid "kz1048"
msgstr "kz1048"

#: ../../library/codecs.rst:1245
msgid "kz_1048, strk1048_2002, rk1048"
msgstr "kz_1048, strk1048_2002, rk1048"

#: ../../library/codecs.rst:1245 ../../library/codecs.rst:1263
#, fuzzy
msgid "Kazakh"
msgstr "哈薩克語"

#: ../../library/codecs.rst:1249
msgid "mac_cyrillic"
msgstr "mac_cyrillic"

#: ../../library/codecs.rst:1249
#, fuzzy
msgid "maccyrillic"
msgstr "花哨的"

#: ../../library/codecs.rst:1252
msgid "mac_greek"
msgstr "mac_greek"

#: ../../library/codecs.rst:1252
#, fuzzy
msgid "macgreek"
msgstr "麥克希臘語"

#: ../../library/codecs.rst:1254
msgid "mac_iceland"
msgstr "mac_iceland"

#: ../../library/codecs.rst:1254
#, fuzzy
msgid "maciceland"
msgstr "麥克斯蘭"

#: ../../library/codecs.rst:1256
msgid "mac_latin2"
msgstr "mac_latin2"

#: ../../library/codecs.rst:1256
msgid "maclatin2, maccentraleurope, mac_centeuro"
msgstr "maclatin2, maccentraleurope, mac_centeuro"

#: ../../library/codecs.rst:1259
msgid "mac_roman"
msgstr "mac_roman"

#: ../../library/codecs.rst:1259
msgid "macroman, macintosh"
msgstr "macroman, macintosh"

#: ../../library/codecs.rst:1261
msgid "mac_turkish"
msgstr "mac_turkish"

#: ../../library/codecs.rst:1261
#, fuzzy
msgid "macturkish"
msgstr "Macturkish 的"

#: ../../library/codecs.rst:1263
msgid "ptcp154"
msgstr "ptcp154"

#: ../../library/codecs.rst:1263
msgid "csptcp154, pt154, cp154, cyrillic-asian"
msgstr "csptcp154, pt154, cp154, cyrillic-asian"

#: ../../library/codecs.rst:1266
msgid "shift_jis"
msgstr "shift_jis"

#: ../../library/codecs.rst:1266
msgid "csshiftjis, shiftjis, sjis, s_jis"
msgstr "csshiftjis, shiftjis, sjis, s_jis"

#: ../../library/codecs.rst:1269
msgid "shift_jis_2004"
msgstr "shift_jis_2004"

#: ../../library/codecs.rst:1269
msgid "shiftjis2004, sjis_2004, sjis2004"
msgstr "shiftjis2004, sjis_2004, sjis2004"

#: ../../library/codecs.rst:1272
msgid "shift_jisx0213"
msgstr "shift_jisx0213"

#: ../../library/codecs.rst:1272
msgid "shiftjisx0213, sjisx0213, s_jisx0213"
msgstr "shiftjisx0213, sjisx0213, s_jisx0213"

#: ../../library/codecs.rst:1275
msgid "utf_32"
msgstr "utf_32"

#: ../../library/codecs.rst:1275
msgid "U32, utf32"
msgstr "U32, utf32"

#: ../../library/codecs.rst:1275 ../../library/codecs.rst:1277
#: ../../library/codecs.rst:1279 ../../library/codecs.rst:1281
#: ../../library/codecs.rst:1283 ../../library/codecs.rst:1285
#: ../../library/codecs.rst:1287 ../../library/codecs.rst:1289
#: ../../library/codecs.rst:1291
#, fuzzy
msgid "all languages"
msgstr "所有語言"

#: ../../library/codecs.rst:1277
msgid "utf_32_be"
msgstr "utf_32_be"

#: ../../library/codecs.rst:1277
msgid "UTF-32BE"
msgstr "UTF-32BE"

#: ../../library/codecs.rst:1279
msgid "utf_32_le"
msgstr "utf_32_le"

#: ../../library/codecs.rst:1279
msgid "UTF-32LE"
msgstr "UTF-32LE"

#: ../../library/codecs.rst:1281
msgid "utf_16"
msgstr "utf_16"

#: ../../library/codecs.rst:1281
msgid "U16, utf16"
msgstr "U16, utf16"

#: ../../library/codecs.rst:1283
msgid "utf_16_be"
msgstr "utf_16_be"

#: ../../library/codecs.rst:1283
msgid "UTF-16BE"
msgstr "UTF-16BE"

#: ../../library/codecs.rst:1285
msgid "utf_16_le"
msgstr "utf_16_le"

#: ../../library/codecs.rst:1285
msgid "UTF-16LE"
msgstr "UTF-16LE"

#: ../../library/codecs.rst:1287
msgid "utf_7"
msgstr "utf_7"

#: ../../library/codecs.rst:1287
msgid "U7, unicode-1-1-utf-7"
msgstr "U7, unicode-1-1-utf-7"

#: ../../library/codecs.rst:1289
msgid "utf_8"
msgstr "utf_8"

#: ../../library/codecs.rst:1289
msgid "U8, UTF, utf8, cp65001"
msgstr "U8, UTF, utf8, cp65001"

#: ../../library/codecs.rst:1291
msgid "utf_8_sig"
msgstr "utf_8_sig"

#: ../../library/codecs.rst:1294
#, fuzzy
msgid ""
"The utf-16\\* and utf-32\\* encoders no longer allow surrogate code points "
"(``U+D800``--``U+DFFF``) to be encoded. The utf-32\\* decoders no longer "
"decode byte sequences that correspond to surrogate code points."
msgstr ""
"utf-16\\* 和 utf-32\\* 編碼器不再允許對代理程式碼點 (``U+D800``--``U+DFFF``) "
"進行編碼。 utf-32\\* 解碼器不再解碼對應於代理程式碼點的位元組序列。"

#: ../../library/codecs.rst:1300
#, fuzzy
msgid "``cp65001`` is now an alias to ``utf_8``."
msgstr "``cp65001`` 現在是 ``utf_8`` 的別名。"

#: ../../library/codecs.rst:1305
#, fuzzy
msgid "Python Specific Encodings"
msgstr "Python 特定編碼"

#: ../../library/codecs.rst:1307
#, fuzzy
msgid ""
"A number of predefined codecs are specific to Python, so their codec names "
"have no meaning outside Python. These are listed in the tables below based "
"on the expected input and output types (note that while text encodings are "
"the most common use case for codecs, the underlying codec infrastructure "
"supports arbitrary data transforms rather than just text encodings). For "
"asymmetric codecs, the stated meaning describes the encoding direction."
msgstr ""
"許多預定義的編解碼器是特定於 Python 的，因此它們的編解碼器名稱在 Python 之外"
"沒有任何意義。這些根據預期的輸入和輸出型別列在下表中（請注意，雖然文本編碼是"
"編解碼器最常見的用例，但底層編解碼器基礎設施支援任意資料轉換，而不僅僅是文本"
"編碼）。對於非對稱編解碼器，聲明的含義描述了編碼方向。"

#: ../../library/codecs.rst:1315
#, fuzzy
msgid "Text Encodings"
msgstr "文本編碼"

#: ../../library/codecs.rst:1317
#, fuzzy
msgid ""
"The following codecs provide :class:`str` to :class:`bytes` encoding and :"
"term:`bytes-like object` to :class:`str` decoding, similar to the Unicode "
"text encodings."
msgstr ""
"以下編解碼器提供 :class:`str` 到 :class:`bytes` 編碼和 :term:`bytes-like "
"object` 到 :class:`str` 解碼，類似於 Unicode 文本編碼。"

#: ../../library/codecs.rst:1326
msgid "idna"
msgstr "idna"

#: ../../library/codecs.rst:1326
#, fuzzy
msgid ""
"Implement :rfc:`3490`, see also :mod:`encodings.idna`. Only "
"``errors='strict'`` is supported."
msgstr "實施 :rfc:`3490`，另見 :mod:`encodings.idna`。僅支援 ``errors='strict'``。"

#: ../../library/codecs.rst:1332
msgid "mbcs"
msgstr "mbcs"

#: ../../library/codecs.rst:1332
msgid "ansi, dbcs"
msgstr "ansi, dbcs"

#: ../../library/codecs.rst:1332
#, fuzzy
msgid ""
"Windows only: Encode the operand according to the ANSI codepage (CP_ACP)."
msgstr "僅限 Windows：根據 ANSI 程式碼頁 (CP_ACP) 對操作數進行編碼。"

#: ../../library/codecs.rst:1336
msgid "oem"
msgstr "oem"

#: ../../library/codecs.rst:1336
#, fuzzy
msgid ""
"Windows only: Encode the operand according to the OEM codepage (CP_OEMCP)."
msgstr "僅限 Windows：根據 OEM 程式碼頁 (CP_OEMCP) 對操作數進行編碼。"

#: ../../library/codecs.rst:1342
#, fuzzy
msgid "palmos"
msgstr "棕櫚樹"

#: ../../library/codecs.rst:1342
#, fuzzy
msgid "Encoding of PalmOS 3.5."
msgstr "PalmOS 3.5 的編碼。"

#: ../../library/codecs.rst:1344
#, fuzzy
msgid "punycode"
msgstr "密碼"

#: ../../library/codecs.rst:1344
#, fuzzy
msgid "Implement :rfc:`3492`. Stateful codecs are not supported."
msgstr "實施 :rfc:`3492`。不支援狀態編解碼器。"

#: ../../library/codecs.rst:1348
msgid "raw_unicode_escape"
msgstr "raw_unicode_escape"

#: ../../library/codecs.rst:1348
#, fuzzy
msgid ""
"Latin-1 encoding with ``\\uXXXX`` and ``\\UXXXXXXXX`` for other code points. "
"Existing backslashes are not escaped in any way. It is used in the Python "
"pickle protocol."
msgstr ""
"Latin-1 編碼與 ``\\uXXXX`` 和 ``\\UXXXXXXXX`` "
"用於其他程式碼點。現有的反斜杠不會以任何方式轉義。它用於 Python pickle 協定。"

#: ../../library/codecs.rst:1357
#, fuzzy
msgid "undefined"
msgstr "不明確的"

#: ../../library/codecs.rst:1357
#, fuzzy
msgid ""
"Raise an exception for all conversions, even empty strings. The error "
"handler is ignored."
msgstr "為所有轉換引發例外，甚至是空字串。錯誤處理程式被忽略。"

#: ../../library/codecs.rst:1362
msgid "unicode_escape"
msgstr "unicode_escape"

#: ../../library/codecs.rst:1362
#, fuzzy
msgid ""
"Encoding suitable as the contents of a Unicode literal in ASCII-encoded "
"Python source code, except that quotes are not escaped. Decode from Latin-1 "
"source code. Beware that Python source code actually uses UTF-8 by default."
msgstr ""
"編碼適合作為 ASCII 編碼的 Python 源程式碼中 Unicode "
"文字的內容，除了不轉義引號。從 Latin-1 源程式碼解碼。請注意，Python "
"源程式碼實際上預設使用 UTF-8。"

#: ../../library/codecs.rst:1374
#, fuzzy
msgid "\"unicode_internal\" codec is removed."
msgstr "“unicode_internal”編解碼器已刪除。"

#: ../../library/codecs.rst:1381
#, fuzzy
msgid "Binary Transforms"
msgstr "二進位轉換"

#: ../../library/codecs.rst:1383
#, fuzzy
msgid ""
"The following codecs provide binary transforms: :term:`bytes-like object` "
"to :class:`bytes` mappings. They are not supported by :meth:`bytes.decode` "
"(which only produces :class:`str` output)."
msgstr ""
"以下編解碼器提供二進位轉換：:term:`bytes-like object` 到 :class:`bytes` 映射。"
" :meth:`bytes.decode` 不支援它們（它只產生 :class:`str` 輸出）。"

#: ../../library/codecs.rst:1391
#, fuzzy
msgid "Encoder / decoder"
msgstr "編碼器/解碼器"

#: ../../library/codecs.rst:1393
msgid "base64_codec [#b64]_"
msgstr "base64_codec [#b64]_"

#: ../../library/codecs.rst:1393
msgid "base64, base_64"
msgstr "base64, base_64"

#: ../../library/codecs.rst:1393
#, fuzzy
msgid ""
"Convert the operand to multiline MIME base64 (the result always includes a "
"trailing ``'\\n'``)."
msgstr ""
"將操作數轉換為多行 MIME base64（結果始終包含尾隨的“\\n"
"”）。"

#: ../../library/codecs.rst:1398
#, fuzzy
msgid ""
"accepts any :term:`bytes-like object` as input for encoding and decoding"
msgstr "接受任何 :term:`bytes-like object` 作為編碼和解碼的輸入"

#: ../../library/codecs.rst:1393
msgid ":meth:`base64.encodebytes` / :meth:`base64.decodebytes`"
msgstr ":meth:`base64.encodebytes` / :meth:`base64.decodebytes`"

#: ../../library/codecs.rst:1404
msgid "bz2_codec"
msgstr "bz2_codec"

#: ../../library/codecs.rst:1404
msgid "bz2"
msgstr "bz2"

#: ../../library/codecs.rst:1404
#, fuzzy
msgid "Compress the operand using bz2."
msgstr "使用 bz2 壓縮操作數。"

#: ../../library/codecs.rst:1404
msgid ":meth:`bz2.compress` / :meth:`bz2.decompress`"
msgstr ":meth:`bz2.compress` / :meth:`bz2.decompress`"

#: ../../library/codecs.rst:1407
msgid "hex_codec"
msgstr "hex_codec"

#: ../../library/codecs.rst:1407
msgid "hex"
msgstr "hex"

#: ../../library/codecs.rst:1407
#, fuzzy
msgid ""
"Convert the operand to hexadecimal representation, with two digits per byte."
msgstr "將操作數轉換為十六進位表示，每個位元組兩位數。"

#: ../../library/codecs.rst:1407
msgid ":meth:`binascii.b2a_hex` / :meth:`binascii.a2b_hex`"
msgstr ":meth:`binascii.b2a_hex` / :meth:`binascii.a2b_hex`"

#: ../../library/codecs.rst:1412
msgid "quopri_codec"
msgstr "quopri_codec"

#: ../../library/codecs.rst:1412
msgid "quopri, quotedprintable, quoted_printable"
msgstr "quopri, quotedprintable, quoted_printable"

#: ../../library/codecs.rst:1412
#, fuzzy
msgid "Convert the operand to MIME quoted printable."
msgstr "將操作數轉換為 MIME quoted printable。"

#: ../../library/codecs.rst:1412
msgid ":meth:`quopri.encode` with ``quotetabs=True`` / :meth:`quopri.decode`"
msgstr ":meth:`quopri.encode` with ``quotetabs=True`` / :meth:`quopri.decode`"

#: ../../library/codecs.rst:1416
msgid "uu_codec"
msgstr "uu_codec"

#: ../../library/codecs.rst:1416
msgid "uu"
msgstr "uu"

#: ../../library/codecs.rst:1416
#, fuzzy
msgid "Convert the operand using uuencode."
msgstr "使用 uuencode 轉換操作數。"

#: ../../library/codecs.rst:1416
msgid ":meth:`uu.encode` / :meth:`uu.decode`"
msgstr ":meth:`uu.encode` / :meth:`uu.decode`"

#: ../../library/codecs.rst:1419
msgid "zlib_codec"
msgstr "zlib_codec"

#: ../../library/codecs.rst:1419
msgid "zip, zlib"
msgstr "zip, zlib"

#: ../../library/codecs.rst:1419
#, fuzzy
msgid "Compress the operand using gzip."
msgstr "使用 gzip 壓縮操作數。"

#: ../../library/codecs.rst:1419
msgid ":meth:`zlib.compress` / :meth:`zlib.decompress`"
msgstr ":meth:`zlib.compress` / :meth:`zlib.decompress`"

#: ../../library/codecs.rst:1423
#, fuzzy
msgid ""
"In addition to :term:`bytes-like objects <bytes-like object>`, "
"``'base64_codec'`` also accepts ASCII-only instances of :class:`str` for "
"decoding"
msgstr ""
"除了 :term:`bytes-like objects <bytes-like object>`，``'base64_codec'`` "
"也接受 :class:`str` 的 ASCII-only 實例進行解碼"

#: ../../library/codecs.rst:1427
#, fuzzy
msgid "Restoration of the binary transforms."
msgstr "二進位變換的恢復。"

#: ../../library/codecs.rst:1430
#, fuzzy
msgid "Restoration of the aliases for the binary transforms."
msgstr "恢復二進位轉換的別名。"

#: ../../library/codecs.rst:1437
#, fuzzy
msgid "Text Transforms"
msgstr "文本轉換"

#: ../../library/codecs.rst:1439
#, fuzzy
msgid ""
"The following codec provides a text transform: a :class:`str` to :class:"
"`str` mapping. It is not supported by :meth:`str.encode` (which only "
"produces :class:`bytes` output)."
msgstr ""
"下面的編解碼器提供了一個文本轉換：一個 :class:`str` 到 :class:`str` 的映射。 "
":meth:`str.encode` 不支援它（它只產生 :class:`bytes` 輸出）。"

#: ../../library/codecs.rst:1448
msgid "rot_13"
msgstr "rot_13"

#: ../../library/codecs.rst:1448
#, fuzzy
msgid "rot13"
msgstr "腐爛13"

#: ../../library/codecs.rst:1448
#, fuzzy
msgid "Return the Caesar-cypher encryption of the operand."
msgstr "回傳操作數的凱撒密碼加密。"

#: ../../library/codecs.rst:1453
#, fuzzy
msgid "Restoration of the ``rot_13`` text transform."
msgstr "恢復 ``rot_13`` 文本轉換。"

#: ../../library/codecs.rst:1456
#, fuzzy
msgid "Restoration of the ``rot13`` alias."
msgstr "恢復 ``rot13`` 別名。"

#: ../../library/codecs.rst:1461
#, fuzzy
msgid ""
":mod:`encodings.idna` --- Internationalized Domain Names in Applications"
msgstr ":mod:`encodings.idna` --- 應用程式中的國際化域名"

#: ../../library/codecs.rst:1467
#, fuzzy
msgid ""
"This module implements :rfc:`3490` (Internationalized Domain Names in "
"Applications) and :rfc:`3492` (Nameprep: A Stringprep Profile for "
"Internationalized Domain Names (IDN)). It builds upon the ``punycode`` "
"encoding and :mod:`stringprep`."
msgstr ""
"此模組實作 :rfc:`3490`（應用程式中的國際化域名）和 :rfc:`3492`（Nameprep："
"國際化域名 (IDN) 的 Stringprep 配置文件）。它建立在``punycode`` "
"編碼和 :mod:`stringprep` 之上。"

#: ../../library/codecs.rst:1472
#, fuzzy
msgid ""
"If you need the IDNA 2008 standard from :rfc:`5891` and :rfc:`5895`, use the "
"third-party `idna module <https://pypi.org/project/idna/>`_."
msgstr ""
"如果您需要來自 :rfc:`5891` 和 :rfc:`5895` 的 IDNA 2008 標準，請使用第三方 `"
"idna 模組 <https://pypi.org/project/idna/>`_。"

#: ../../library/codecs.rst:1475
#, fuzzy
msgid ""
"These RFCs together define a protocol to support non-ASCII characters in "
"domain names. A domain name containing non-ASCII characters (such as ``www."
"Alliancefrançaise.nu``) is converted into an ASCII-compatible encoding (ACE, "
"such as ``www.xn--alliancefranaise-npb.nu``). The ACE form of the domain "
"name is then used in all places where arbitrary characters are not allowed "
"by the protocol, such as DNS queries, HTTP :mailheader:`Host` fields, and so "
"on. This conversion is carried out in the application; if possible invisible "
"to the user: The application should transparently convert Unicode domain "
"labels to IDNA on the wire, and convert back ACE labels to Unicode before "
"presenting them to the user."
msgstr ""
"這些 RFC 一起定義了一個協定來支援域名中的非 ASCII 字元。包含非 "
"ASCII 字元的域名（例如 ``www.Alliancefrançaise.nu``）被轉換為 ASCII "
"相容編碼（ACE，例如 ``www.xn--alliancefranaise-npb.nu``）。"
"然後在協定不允許任意字元的所有地方使用域名的 ACE 形式，例如 DNS 查詢、HTTP "
":mailheader:`Host` "
"欄位等。這種轉換是在應用程式中進行的；如果可能對使用者不可見："
"應用程式應透明地將 Unicode 域標籤在線路上轉換為 IDNA，"
"並在將它們呈現給使用者之前將 ACE 標籤轉換回 Unicode。"

#: ../../library/codecs.rst:1486
#, fuzzy
msgid ""
"Python supports this conversion in several ways:  the ``idna`` codec "
"performs conversion between Unicode and ACE, separating an input string into "
"labels based on the separator characters defined in :rfc:`section 3.1 of RFC "
"3490 <3490#section-3.1>` and converting each label to ACE as required, and "
"conversely separating an input byte string into labels based on the ``.`` "
"separator and converting any ACE labels found into unicode. Furthermore, "
"the :mod:`socket` module transparently converts Unicode host names to ACE, "
"so that applications need not be concerned about converting host names "
"themselves when they pass them to the socket module. On top of that, modules "
"that have host names as function parameters, such as :mod:`http.client` and :"
"mod:`ftplib`, accept Unicode host names (:mod:`http.client` then also "
"transparently sends an IDNA hostname in the :mailheader:`Host` field if it "
"sends that field at all)."
msgstr ""
"Python 以多種方式支援這種轉換：``idna`` 編解碼器執行 Unicode 和 ACE "
"之間的轉換，根據 RFC 3490 <3490#section-3.1 的 :rfc:`section 3.1 "
"中定義的分隔符將輸入字串分成標籤>` 並根據需要將每個標籤轉換為 ACE，然後根據 "
"``.`` 分隔符將輸入位元組字串相反地分成多個標籤，並將找到的任何 ACE "
"標籤轉換為 unicode。此外，:mod:`socket` 模組透明地將 Unicode 主機名轉換為 "
"ACE，因此應用程式在將主機名傳遞給 socket "
"模組時無需擔心自己轉換主機名。最重要的是，將主機名作為函式參數的模組，例如 "
":mod:`http.client` 和 :mod:`ftplib`，接受 Unicode 主機名（:mod:`http.client` "
"然後也透明地發送一個:mailheader:`Host` 欄位中的 IDNA "
"主機名（如果它發送該欄位）。"

#: ../../library/codecs.rst:1499
#, fuzzy
msgid ""
"When receiving host names from the wire (such as in reverse name lookup), no "
"automatic conversion to Unicode is performed: applications wishing to "
"present such host names to the user should decode them to Unicode."
msgstr ""
"當從線路接收主機名時（例如在反向名稱查找中），不會執行到 Unicode 的自動轉換："
"希望將此類主機名呈現給使用者的應用程式應該將它們解碼為 Unicode。"

#: ../../library/codecs.rst:1503
#, fuzzy
msgid ""
"The module :mod:`encodings.idna` also implements the nameprep procedure, "
"which performs certain normalizations on host names, to achieve case-"
"insensitivity of international domain names, and to unify similar "
"characters. The nameprep functions can be used directly if desired."
msgstr ""
":mod:`encodings.idna`模組還實作了nameprep過程，對主機名進行一定的規範化，實作"
"國際域名的大小寫不敏感，統一相似字元。如果需要，可以直接使用 nameprep 函式。"

#: ../../library/codecs.rst:1511
#, fuzzy
msgid ""
"Return the nameprepped version of *label*. The implementation currently "
"assumes query strings, so ``AllowUnassigned`` is true."
msgstr "回傳 *label* "
"的名稱准備版本。該實作當前假定查詢字串，因此 ``AllowUnassigned`` 為真。"

#: ../../library/codecs.rst:1517
#, fuzzy
msgid ""
"Convert a label to ASCII, as specified in :rfc:`3490`. ``UseSTD3ASCIIRules`` "
"is assumed to be false."
msgstr "將標籤轉換為 ASCII，如 :rfc:`3490` 中所指定。 ``UseSTD3ASCIIRules`` "
"假定為假。"

#: ../../library/codecs.rst:1523
#, fuzzy
msgid "Convert a label to Unicode, as specified in :rfc:`3490`."
msgstr "將標籤轉換為 Unicode，如 :rfc:`3490` 中所指定。"

#: ../../library/codecs.rst:1527
#, fuzzy
msgid ":mod:`encodings.mbcs` --- Windows ANSI codepage"
msgstr ":mod:`encodings.mbcs` --- Windows ANSI 程式碼頁"

#: ../../library/codecs.rst:1532
#, fuzzy
msgid "This module implements the ANSI codepage (CP_ACP)."
msgstr "該模組實作了 ANSI 程式碼頁 (CP_ACP)。"

#: ../../library/codecs.rst:1534
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`適用 <availability>`：Windows。"

#: ../../library/codecs.rst:1536
#, fuzzy
msgid "Support any error handler."
msgstr "支援任何錯誤處理程式。"

#: ../../library/codecs.rst:1539
#, fuzzy
msgid ""
"Before 3.2, the *errors* argument was ignored; ``'replace'`` was always used "
"to encode, and ``'ignore'`` to decode."
msgstr "在 3.2 之前，*errors* 參數被忽略； ``'replace'`` 總是用於編碼，而 "
"``'ignore'`` 用於解碼。"

#: ../../library/codecs.rst:1545
#, fuzzy
msgid ":mod:`encodings.utf_8_sig` --- UTF-8 codec with BOM signature"
msgstr ":mod:`encodings.utf_8_sig` --- 帶有 BOM 簽名的 UTF-8 編解碼器"

#: ../../library/codecs.rst:1551
#, fuzzy
msgid ""
"This module implements a variant of the UTF-8 codec. On encoding, a UTF-8 "
"encoded BOM will be prepended to the UTF-8 encoded bytes. For the stateful "
"encoder this is only done once (on the first write to the byte stream). On "
"decoding, an optional UTF-8 encoded BOM at the start of the data will be "
"skipped."
msgstr ""
"該模組實作了 UTF-8 編解碼器的變體。在編碼時，UTF-8 編碼的 BOM 將被新增到 UTF-"
"8 編碼的位元組之前。對於有狀態編碼器，這只完成一次（在第一次寫入位元組流時）"
"。解碼時，將跳過資料開頭的可選 UTF-8 編碼 BOM。"
