# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Asoul Yang <azx754@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-15 20:43+0000\n"
"PO-Revision-Date: 2018-05-23 16:04+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/json.rst:2
msgid ":mod:`json` --- JSON encoder and decoder"
msgstr ":mod:`json` --- JSON 編碼器和解碼器"

#: ../../library/json.rst:10
msgid "**Source code:** :source:`Lib/json/__init__.py`"
msgstr "**原始碼：**\\ :source:`Lib/json/__init__.py`"

#: ../../library/json.rst:14
#, fuzzy
msgid ""
"`JSON (JavaScript Object Notation) <https://json.org>`_, specified by :rfc:"
"`7159` (which obsoletes :rfc:`4627`) and by `ECMA-404 <https://www.ecma-"
"international.org/publications-and-standards/standards/ecma-404/>`_, is a "
"lightweight data interchange format inspired by `JavaScript <https://en."
"wikipedia.org/wiki/JavaScript>`_ object literal syntax (although it is not a "
"strict subset of JavaScript [#rfc-errata]_ )."
msgstr ""
"`JSON（JavaScript 物件表示法）<https://json.org>`_，由 :rfc:`7159`（廢棄 "
":rfc:`4627`）和 `ECMA-404 <https://www. ecma-international.org/"
"publications-and-standards/standards/ecma-404/>`_，是一種受`JavaScript "
"<https://en.wikipedia.org/wiki/"
"JavaScript>`_物件啟發的輕量級資料交換格式文字語法（儘管它不是 JavaScript "
"[#rfc-errata]_ 的嚴格子集）。"

#: ../../library/json.rst:22
#, fuzzy
msgid ""
"Be cautious when parsing JSON data from untrusted sources. A malicious JSON "
"string may cause the decoder to consume considerable CPU and memory "
"resources. Limiting the size of data to be parsed is recommended."
msgstr ""
"解析來自不受信任來源的 JSON 資料時要小心。惡意的 JSON "
"字串可能會導致解碼器消耗大量 CPU 和記憶體資源。建議限制要解析的資料的大小。"

#: ../../library/json.rst:26
#, fuzzy
msgid ""
":mod:`json` exposes an API familiar to users of the standard library :mod:"
"`marshal` and :mod:`pickle` modules."
msgstr ":mod:`json` 公開標準庫 :mod:`marshal` 和 :mod:`pickle` 模組的使用者熟悉的 "
"API。"

#: ../../library/json.rst:29
#, fuzzy
msgid "Encoding basic Python object hierarchies::"
msgstr "編碼基本的 Python 物件層次結構::"

#: ../../library/json.rst:48
#, fuzzy
msgid "Compact encoding::"
msgstr "緊湊編碼::"

#: ../../library/json.rst:54
msgid "Pretty printing::"
msgstr "美化輸出："

#: ../../library/json.rst:63
#, fuzzy
msgid "Decoding JSON::"
msgstr "解碼 JSON::"

#: ../../library/json.rst:75
#, fuzzy
msgid "Specializing JSON object decoding::"
msgstr "專注於 JSON 物件解碼::"

#: ../../library/json.rst:90
#, fuzzy
msgid "Extending :class:`JSONEncoder`::"
msgstr "擴充 :class:`JSONEncoder`::"

#: ../../library/json.rst:108
#, fuzzy
msgid "Using :mod:`json.tool` from the shell to validate and pretty-print:"
msgstr "使用 shell 中的 :mod:`json.tool` 來驗證和漂亮印出："

#: ../../library/json.rst:119
msgid "See :ref:`json-commandline` for detailed documentation."
msgstr "更詳盡的文件請見 :ref:`json-commandline`\\ 。"

#: ../../library/json.rst:123
#, fuzzy
msgid ""
"JSON is a subset of `YAML <https://yaml.org/>`_ 1.2.  The JSON produced by "
"this module's default settings (in particular, the default *separators* "
"value) is also a subset of YAML 1.0 and 1.1.  This module can thus also be "
"used as a YAML serializer."
msgstr ""
"JSON 是`YAML <https://yaml.org/>`_ 1.2 的子集。此模組的預設設定（特別是預設 "
"*separators* 值）生成的 JSON 也是 YAML 1.0 和 1.1 的子集。因此，"
"該模組也可以用作 YAML 序列化程式。"

#: ../../library/json.rst:130
#, fuzzy
msgid ""
"This module's encoders and decoders preserve input and output order by "
"default.  Order is only lost if the underlying containers are unordered."
msgstr "該模組的編碼器和解碼器預設保留輸入和輸出順序。僅當底層容器無序時，訂單才會丟"
"失。"

#: ../../library/json.rst:135
msgid "Basic Usage"
msgstr "基本用法"

#: ../../library/json.rst:142
#, fuzzy
msgid ""
"Serialize *obj* as a JSON formatted stream to *fp* (a ``.write()``-"
"supporting :term:`file-like object`) using this :ref:`conversion table <py-"
"to-json-table>`."
msgstr "使用此轉換錶 <py-to-json-表>`。"

#: ../../library/json.rst:146
#, fuzzy
msgid ""
"If *skipkeys* is true (default: ``False``), then dict keys that are not of a "
"basic type (:class:`str`, :class:`int`, :class:`float`, :class:`bool`, "
"``None``) will be skipped instead of raising a :exc:`TypeError`."
msgstr ""
"如果 *skipkeys* "
"為真（預設值：``False``），則不是基本型別的字典鍵（:class:`str`, :class:`int`"
", :class:`float`, :class :`bool`, ``None``) 將被跳過而不是引發 "
":exc:`TypeError`。"

#: ../../library/json.rst:150
#, fuzzy
msgid ""
"The :mod:`json` module always produces :class:`str` objects, not :class:"
"`bytes` objects. Therefore, ``fp.write()`` must support :class:`str` input."
msgstr ""
":mod:`json` 模組總是生成 :class:`str` 物件，而不是 :class:`bytes` "
"物件。因此，``fp.write()`` 必須支援 :class:`str` 輸入。"

#: ../../library/json.rst:154 ../../library/json.rst:433
#, fuzzy
msgid ""
"If *ensure_ascii* is true (the default), the output is guaranteed to have "
"all incoming non-ASCII characters escaped.  If *ensure_ascii* is false, "
"these characters will be output as-is."
msgstr ""
"如果 *ensure_ascii* 為 true（預設值），則輸出保證所有傳入的非 ASCII "
"字元都已轉義。如果 *ensure_ascii* 為假，這些字元將按原樣輸出。"

#: ../../library/json.rst:158
#, fuzzy
msgid ""
"If *check_circular* is false (default: ``True``), then the circular "
"reference check for container types will be skipped and a circular reference "
"will result in a :exc:`RecursionError` (or worse)."
msgstr ""
"如果 *check_circular* 為 "
"false（預設值：``True``），則將跳過容器型別的循環引用檢查，"
"並且循環引用將導致 RecursionError（或更糟）。"

#: ../../library/json.rst:162
#, fuzzy
msgid ""
"If *allow_nan* is false (default: ``True``), then it will be a :exc:"
"`ValueError` to serialize out of range :class:`float` values (``nan``, "
"``inf``, ``-inf``) in strict compliance of the JSON specification. If "
"*allow_nan* is true, their JavaScript equivalents (``NaN``, ``Infinity``, ``-"
"Infinity``) will be used."
msgstr ""
"如果 *allow_nan* 為 "
"false（預設值：``True``），那麼它將是一個 :exc:`ValueError` "
"以序列化超出範圍 :class:`float` 值（``nan``，``inf` `, ``-inf``) 嚴格遵守 "
"JSON 規範。如果 *allow_nan* 為真，則將使用它們的 JavaScript "
"等效項（``NaN``、``Infinity``、``-Infinity``）。"

#: ../../library/json.rst:168 ../../library/json.rst:452
#, fuzzy
msgid ""
"If *indent* is a non-negative integer or string, then JSON array elements "
"and object members will be pretty-printed with that indent level.  An indent "
"level of 0, negative, or ``\"\"`` will only insert newlines.  ``None`` (the "
"default) selects the most compact representation. Using a positive integer "
"indent indents that many spaces per level.  If *indent* is a string (such as "
"``\"\\t\"``), that string is used to indent each level."
msgstr ""
"如果 *indent* 是非負整數或字串，則 JSON "
"數組元素和物件成員將使用該縮進級別進行漂亮印出。縮進級別為 0、負數或 ``\"\"``"
" 只會插入換行符。 ``None``（預設值）選擇最緊湊的表示。使用正整數縮進會在每個"
"級別縮進多少個空格。如果 *indent* 是一個字串（例如 ``\"\\t\""
"``），該字串用於縮進每個級別。"

#: ../../library/json.rst:175 ../../library/json.rst:459
#, fuzzy
msgid "Allow strings for *indent* in addition to integers."
msgstr "除了整數之外，還允許 *indent* 的字串。"

#: ../../library/json.rst:178 ../../library/json.rst:462
#, fuzzy
msgid ""
"If specified, *separators* should be an ``(item_separator, key_separator)`` "
"tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and ``(',', "
"': ')`` otherwise.  To get the most compact JSON representation, you should "
"specify ``(',', ':')`` to eliminate whitespace."
msgstr ""
"如果指定，*separators* 應該是一個 ``(item_separator, key_separator)`` "
"元組。預設是``(', ', ': ')`` 如果 *indent* 是``None`` 否則預設是``(',', ': "
"')``。要獲得最緊湊的 JSON 表示，您應該指定 ``(',', ':')`` 以消除空格。"

#: ../../library/json.rst:183 ../../library/json.rst:467
#, fuzzy
msgid "Use ``(',', ': ')`` as default if *indent* is not ``None``."
msgstr "如果 *indent* 不是 ``None``，則使用 ``(',', ': ')`` 作為預設值。"

#: ../../library/json.rst:186 ../../library/json.rst:470
#, fuzzy
msgid ""
"If specified, *default* should be a function that gets called for objects "
"that can't otherwise be serialized.  It should return a JSON encodable "
"version of the object or raise a :exc:`TypeError`.  If not specified, :exc:"
"`TypeError` is raised."
msgstr ""
"如果指定，*default* 應該是為無法序列化的物件呼叫的函式。它應該回傳物件的 "
"JSON 可編碼版本或引發 :exc:`TypeError`。如果未指定，則會引發 "
":exc:`TypeError`。"

#: ../../library/json.rst:191
#, fuzzy
msgid ""
"If *sort_keys* is true (default: ``False``), then the output of dictionaries "
"will be sorted by key."
msgstr "如果 *sort_keys* 為 true（預設值：``False``），則字典的輸出將按鍵排序。"

#: ../../library/json.rst:194
#, fuzzy
msgid ""
"To use a custom :class:`JSONEncoder` subclass (e.g. one that overrides the :"
"meth:`default` method to serialize additional types), specify it with the "
"*cls* kwarg; otherwise :class:`JSONEncoder` is used."
msgstr ""
"要使用自定義 :class:`JSONEncoder` 子類別（例如，覆蓋 :meth:`default` "
"方法以序列化其他型別的子類別），請使用 *cls* kwarg 指定它；否則使用 "
":class:`JSONEncoder`。"

#: ../../library/json.rst:198 ../../library/json.rst:277
#, fuzzy
msgid ""
"All optional parameters are now :ref:`keyword-only <keyword-only_parameter>`."
msgstr "所有可選參數現在都是 :ref:`keyword-only <keyword-only_parameter>`。"

#: ../../library/json.rst:203
#, fuzzy
msgid ""
"Unlike :mod:`pickle` and :mod:`marshal`, JSON is not a framed protocol, so "
"trying to serialize multiple objects with repeated calls to :func:`dump` "
"using the same *fp* will result in an invalid JSON file."
msgstr ""
"與 :mod:`pickle` 和 :mod:`marshal` 不同，JSON 不是框架協定，"
"因此嘗試使用相同的 *fp* 重複呼叫 :func:`dump` 來序列化多個物件將導致無效的 "
"JSON文件。"

#: ../../library/json.rst:212
#, fuzzy
msgid ""
"Serialize *obj* to a JSON formatted :class:`str` using this :ref:`conversion "
"table <py-to-json-table>`.  The arguments have the same meaning as in :func:"
"`dump`."
msgstr ""
"使用此轉換錶 <py-to-json-table>` 將 *obj* 序列化為 JSON 格式的 :class:`str`。"
"參數與 :func:`dump` 中的含義相同。"

#: ../../library/json.rst:218
#, fuzzy
msgid ""
"Keys in key/value pairs of JSON are always of the type :class:`str`. When a "
"dictionary is converted into JSON, all the keys of the dictionary are "
"coerced to strings. As a result of this, if a dictionary is converted into "
"JSON and then back into a dictionary, the dictionary may not equal the "
"original one. That is, ``loads(dumps(x)) != x`` if x has non-string keys."
msgstr ""
"JSON 的鍵/值對中的鍵始終是 :class:`str` 型別。當字典轉換為 JSON "
"時，字典的所有鍵都被強制轉換為字串。因此，如果將字典轉換為 JSON "
"然後再轉換回字典，則該字典可能與原始字典不同。也就是說，如果 x 具有非字串鍵，"
"則 ``loads(dumps(x)) != x``。"

#: ../../library/json.rst:227
#, fuzzy
msgid ""
"Deserialize *fp* (a ``.read()``-supporting :term:`text file` or :term:"
"`binary file` containing a JSON document) to a Python object using this :ref:"
"`conversion table <json-to-py-table>`."
msgstr "使用這個轉換錶 <json -to-py-table>`。"

#: ../../library/json.rst:231
#, fuzzy
msgid ""
"*object_hook* is an optional function that will be called with the result of "
"any object literal decoded (a :class:`dict`).  The return value of "
"*object_hook* will be used instead of the :class:`dict`.  This feature can "
"be used to implement custom decoders (e.g. `JSON-RPC <https://www.jsonrpc."
"org>`_ class hinting)."
msgstr ""
"*object_hook* 是一個可選函式，將使用任何物件文字解碼的結果（a "
":class:`dict`）呼叫。 *object_hook* 的回傳值將被用來代替 "
":class:`dict`。此功能可用於實作自定義解碼器（例如 `JSON-RPC <https://www."
"jsonrpc.org>`_ 類提示）。"

#: ../../library/json.rst:237
#, fuzzy
msgid ""
"*object_pairs_hook* is an optional function that will be called with the "
"result of any object literal decoded with an ordered list of pairs.  The "
"return value of *object_pairs_hook* will be used instead of the :class:"
"`dict`.  This feature can be used to implement custom decoders. If "
"*object_hook* is also defined, the *object_pairs_hook* takes priority."
msgstr ""
"*object_pairs_hook* "
"是一個可選函式，它將使用任何物件文字的結果呼叫，並使用有序的對列表進行解碼。 "
"*object_pairs_hook* 的回傳值將被用來代替 "
":class:`dict`。此功能可用於實作自定義解碼器。如果還定義了 *object_hook*，則 "
"*object_pairs_hook* 優先。"

#: ../../library/json.rst:243 ../../library/json.rst:348
msgid "Added support for *object_pairs_hook*."
msgstr "新增對於 *object_pairs_hook* 的支援。"

#: ../../library/json.rst:246 ../../library/json.rst:351
#, fuzzy
msgid ""
"*parse_float*, if specified, will be called with the string of every JSON "
"float to be decoded.  By default, this is equivalent to ``float(num_str)``. "
"This can be used to use another datatype or parser for JSON floats (e.g. :"
"class:`decimal.Decimal`)."
msgstr ""
"*parse_float*，如果指定，將使用要解碼的每個 JSON "
"浮點數的字串呼叫。預設情況下，這相當於 ``float(num_str)``。"
"這可用於將另一種資料型別或解析器用於 JSON 浮點數（例如 :class:`decimal."
"Decimal`）。"

#: ../../library/json.rst:251 ../../library/json.rst:356
#, fuzzy
msgid ""
"*parse_int*, if specified, will be called with the string of every JSON int "
"to be decoded.  By default, this is equivalent to ``int(num_str)``.  This "
"can be used to use another datatype or parser for JSON integers (e.g. :class:"
"`float`)."
msgstr ""
"*parse_int*，如果指定，將使用要解碼的每個 JSON int 的字串呼叫。預設情況下，"
"這等同於 ``int(num_str)``。這可用於為 JSON "
"整數使用另一種資料型別或解析器（例如 :class:`float`）。"

#: ../../library/json.rst:256
#, fuzzy
msgid ""
"The default *parse_int* of :func:`int` now limits the maximum length of the "
"integer string via the interpreter's :ref:`integer string conversion length "
"limitation <int_max_str_digits>` to help avoid denial of service attacks."
msgstr ""
":func:`int` 的預設 *parse_int* 現在通過直譯器的 :ref:`integer string "
"conversion length limitation <int_max_str_digits>` "
"限制整數字串的最大長度，以幫助避免拒絕服務攻擊。"

#: ../../library/json.rst:262 ../../library/json.rst:361
#, fuzzy
msgid ""
"*parse_constant*, if specified, will be called with one of the following "
"strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``. This can be used to "
"raise an exception if invalid JSON numbers are encountered."
msgstr ""
"*parse_constant*，如果指定，將使用以下字串之一呼叫：``'-Infinity'``、``'Infin"
"ity'``、``'NaN'``。如果遇到無效的 JSON 數字，這可用於引發例外。"

#: ../../library/json.rst:267
#, fuzzy
msgid "*parse_constant* doesn't get called on 'null', 'true', 'false' anymore."
msgstr "*parse_constant* 不再在 ``null``、 ``true``、 ``false``上被呼叫。"

#: ../../library/json.rst:270
#, fuzzy
msgid ""
"To use a custom :class:`JSONDecoder` subclass, specify it with the ``cls`` "
"kwarg; otherwise :class:`JSONDecoder` is used.  Additional keyword arguments "
"will be passed to the constructor of the class."
msgstr ""
"要使用自定義 :class:`JSONDecoder` 子類別，請使用 ``cls`` kwarg "
"指定它；否則使用 :class:`JSONDecoder`。附加關鍵字參數將傳遞給類的構造函式。"

#: ../../library/json.rst:274 ../../library/json.rst:292
#: ../../library/json.rst:371
#, fuzzy
msgid ""
"If the data being deserialized is not a valid JSON document, a :exc:"
"`JSONDecodeError` will be raised."
msgstr "如果被反序列化的資料不是有效的 JSON 文檔，則會引發 :exc:`JSONDecodeError`。"

#: ../../library/json.rst:280
#, fuzzy
msgid ""
"*fp* can now be a :term:`binary file`. The input encoding should be UTF-8, "
"UTF-16 or UTF-32."
msgstr "*fp* 現在可以是一個 :term:`binary file`。輸入編碼應為 UTF-8、UTF-16 或 "
"UTF-32。"

#: ../../library/json.rst:286
#, fuzzy
msgid ""
"Deserialize *s* (a :class:`str`, :class:`bytes` or :class:`bytearray` "
"instance containing a JSON document) to a Python object using this :ref:"
"`conversion table <json-to-py-table>`."
msgstr "使用這個轉換錶 <json-to-py -表>`。"

#: ../../library/json.rst:290
#, fuzzy
msgid "The other arguments have the same meaning as in :func:`load`."
msgstr "其他參數與 :func:`load` 中的含義相同。"

#: ../../library/json.rst:295
#, fuzzy
msgid ""
"*s* can now be of type :class:`bytes` or :class:`bytearray`. The input "
"encoding should be UTF-8, UTF-16 or UTF-32."
msgstr ""
"*s* 現在可以是 :class:`bytes` 或 :class:`bytearray` 型別。輸入編碼應為 "
"UTF-8、UTF-16 或 UTF-32。"

#: ../../library/json.rst:299
#, fuzzy
msgid "The keyword argument *encoding* has been removed."
msgstr "關鍵字參數 *encoding* 已被刪除。"

#: ../../library/json.rst:304
#, fuzzy
msgid "Encoders and Decoders"
msgstr "編碼器和解碼器"

#: ../../library/json.rst:308
#, fuzzy
msgid "Simple JSON decoder."
msgstr "簡單的 JSON 解碼器。"

#: ../../library/json.rst:310
#, fuzzy
msgid "Performs the following translations in decoding by default:"
msgstr "預設情況下在解碼中執行以下翻譯："

#: ../../library/json.rst:315 ../../library/json.rst:404
msgid "JSON"
msgstr "JSON"

#: ../../library/json.rst:315 ../../library/json.rst:404
msgid "Python"
msgstr "Python"

#: ../../library/json.rst:317 ../../library/json.rst:406
msgid "object"
msgstr "object"

#: ../../library/json.rst:317 ../../library/json.rst:406
msgid "dict"
msgstr "dict"

#: ../../library/json.rst:319 ../../library/json.rst:408
msgid "array"
msgstr "array"

#: ../../library/json.rst:319
msgid "list"
msgstr "list"

#: ../../library/json.rst:321 ../../library/json.rst:410
msgid "string"
msgstr "string"

#: ../../library/json.rst:321 ../../library/json.rst:410
msgid "str"
msgstr "str"

#: ../../library/json.rst:323
msgid "number (int)"
msgstr "number (int)"

#: ../../library/json.rst:323
msgid "int"
msgstr "int"

#: ../../library/json.rst:325
#, fuzzy
msgid "number (real)"
msgstr "數（真實）"

#: ../../library/json.rst:325
msgid "float"
msgstr "float"

#: ../../library/json.rst:327 ../../library/json.rst:414
msgid "true"
msgstr "true"

#: ../../library/json.rst:327 ../../library/json.rst:414
msgid "True"
msgstr "True"

#: ../../library/json.rst:329 ../../library/json.rst:416
msgid "false"
msgstr "false"

#: ../../library/json.rst:329 ../../library/json.rst:416
msgid "False"
msgstr "False"

#: ../../library/json.rst:331 ../../library/json.rst:418
msgid "null"
msgstr "null"

#: ../../library/json.rst:331 ../../library/json.rst:418
msgid "None"
msgstr "None"

#: ../../library/json.rst:334
#, fuzzy
msgid ""
"It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as their "
"corresponding ``float`` values, which is outside the JSON spec."
msgstr ""
"它還將 ``NaN``、``Infinity`` 和 ``-Infinity`` 理解為它們對應的 ``float`` 值，"
"這在 JSON 規範之外。"

#: ../../library/json.rst:337
#, fuzzy
msgid ""
"*object_hook*, if specified, will be called with the result of every JSON "
"object decoded and its return value will be used in place of the given :"
"class:`dict`.  This can be used to provide custom deserializations (e.g. to "
"support `JSON-RPC <https://www.jsonrpc.org>`_ class hinting)."
msgstr ""
"*object_hook*，如果指定，將使用每個解碼的 JSON 物件的結果呼叫，"
"其回傳值將用於代替給定的 :class:`dict`。這可用於提供自定義反序列化（例如，"
"支援 `JSON-RPC <https://www.jsonrpc.org>`_ 類提示）。"

#: ../../library/json.rst:342
#, fuzzy
msgid ""
"*object_pairs_hook*, if specified will be called with the result of every "
"JSON object decoded with an ordered list of pairs.  The return value of "
"*object_pairs_hook* will be used instead of the :class:`dict`.  This feature "
"can be used to implement custom decoders.  If *object_hook* is also defined, "
"the *object_pairs_hook* takes priority."
msgstr ""
"*object_pairs_hook*，如果指定，將使用使用有序對列表解碼的每個 JSON "
"物件的結果呼叫。 *object_pairs_hook* 的回傳值將被用來代替 "
":class:`dict`。此功能可用於實作自定義解碼器。如果還定義了 *object_hook*，則 "
"*object_pairs_hook* 優先。"

#: ../../library/json.rst:366
#, fuzzy
msgid ""
"If *strict* is false (``True`` is the default), then control characters will "
"be allowed inside strings.  Control characters in this context are those "
"with character codes in the 0--31 range, including ``'\\t'`` (tab), "
"``'\\n'``, ``'\\r'`` and ``'\\0'``."
msgstr ""
"如果 *strict* 為 false（預設為 "
"``True``），則允許在字串中使用控制字元。本上下文中的控制字元是字元編碼在0--"
"31範圍內的字元，包括``'\\t'``（製表符）、``'\\n"
"'``、``'\\r'``和` `'\\0'``。"

#: ../../library/json.rst:374 ../../library/json.rst:475
#, fuzzy
msgid "All parameters are now :ref:`keyword-only <keyword-only_parameter>`."
msgstr "所有參數現在都是 :ref:`keyword-only <keyword-only_parameter>`。"

#: ../../library/json.rst:379
#, fuzzy
msgid ""
"Return the Python representation of *s* (a :class:`str` instance containing "
"a JSON document)."
msgstr "回傳 *s* 的 Python 表示（一個包含 JSON 文檔的 str 實例）。"

#: ../../library/json.rst:382
#, fuzzy
msgid ""
":exc:`JSONDecodeError` will be raised if the given JSON document is not "
"valid."
msgstr "如果給定的 JSON 文檔無效，將引發 :exc:`JSONDecodeError`。"

#: ../../library/json.rst:387
#, fuzzy
msgid ""
"Decode a JSON document from *s* (a :class:`str` beginning with a JSON "
"document) and return a 2-tuple of the Python representation and the index in "
"*s* where the document ended."
msgstr ""
"從 *s*（以 JSON 文檔開頭的 :class:`str`）解碼 JSON 文檔，並回傳 Python "
"表示的二元組和 *s* 中文檔結束處的索引。"

#: ../../library/json.rst:391
#, fuzzy
msgid ""
"This can be used to decode a JSON document from a string that may have "
"extraneous data at the end."
msgstr "這可用於從末尾可能包含無關資料的字串解碼 JSON 文檔。"

#: ../../library/json.rst:397
#, fuzzy
msgid "Extensible JSON encoder for Python data structures."
msgstr "用於 Python 資料結構的可擴充 JSON 編碼器。"

#: ../../library/json.rst:399
#, fuzzy
msgid "Supports the following objects and types by default:"
msgstr "預設支援以下物件和型別："

#: ../../library/json.rst:408
msgid "list, tuple"
msgstr "list, tuple"

#: ../../library/json.rst:412
#, fuzzy
msgid "int, float, int- & float-derived Enums"
msgstr "int, float, int- & float-derived 枚舉"

#: ../../library/json.rst:412
#, fuzzy
msgid "number"
msgstr "數字"

#: ../../library/json.rst:421
#, fuzzy
msgid "Added support for int- and float-derived Enum classes."
msgstr "新增了對 int 和 float 派生的 Enum 類的支援。"

#: ../../library/json.rst:424
#, fuzzy
msgid ""
"To extend this to recognize other objects, subclass and implement a :meth:"
"`default` method with another method that returns a serializable object for "
"``o`` if possible, otherwise it should call the superclass implementation "
"(to raise :exc:`TypeError`)."
msgstr ""
"要擴充它以識別其他物件，子類別化並實作一個 default 方法，如果可能的話，"
"使用另一個回傳 o "
"的可序列化物件的方法，否則它應該呼叫超類實作（引發：exc:型別錯誤`）。"

#: ../../library/json.rst:429
#, fuzzy
msgid ""
"If *skipkeys* is false (the default), a :exc:`TypeError` will be raised when "
"trying to encode keys that are not :class:`str`, :class:`int`, :class:"
"`float` or ``None``.  If *skipkeys* is true, such items are simply skipped."
msgstr ""
"如果 *skipkeys* 為 false（預設值），則在嘗試對不是 "
":class:`str`、:class:`int`、:class:`float` 或``沒有``。如果*skipkeys* "
"為真，則這些項目將被簡單地跳過。"

#: ../../library/json.rst:437
#, fuzzy
msgid ""
"If *check_circular* is true (the default), then lists, dicts, and custom "
"encoded objects will be checked for circular references during encoding to "
"prevent an infinite recursion (which would cause a :exc:`RecursionError`). "
"Otherwise, no such check takes place."
msgstr ""
"如果 *check_circular* 為 true（預設值），則將在編碼期間檢查列表、字典和自定義"
"編碼物件的循環引用，以防止無限遞迴（這會導致 "
"RecursionError）。否則，不會進行此類檢查。"

#: ../../library/json.rst:442
#, fuzzy
msgid ""
"If *allow_nan* is true (the default), then ``NaN``, ``Infinity``, and ``-"
"Infinity`` will be encoded as such.  This behavior is not JSON specification "
"compliant, but is consistent with most JavaScript based encoders and "
"decoders.  Otherwise, it will be a :exc:`ValueError` to encode such floats."
msgstr ""
"如果 *allow_nan* 為 true（預設值），則 ``NaN``、``Infinity`` 和 ``-Infinity``"
" 將被這樣編碼。此行為不符合 JSON 規範，但與大多數基於 JavaScript "
"的編碼器和解碼器一致。否則，編碼此類浮點數將是一個 :exc:`ValueError`。"

#: ../../library/json.rst:448
#, fuzzy
msgid ""
"If *sort_keys* is true (default: ``False``), then the output of dictionaries "
"will be sorted by key; this is useful for regression tests to ensure that "
"JSON serializations can be compared on a day-to-day basis."
msgstr ""
"如果 *sort_keys* 為 "
"true（預設值：``False``），則字典的輸出將按鍵排序；這對於回歸測試很有用，"
"以確保可以在日常基礎上比較 JSON 序列化。"

#: ../../library/json.rst:481
#, fuzzy
msgid ""
"Implement this method in a subclass such that it returns a serializable "
"object for *o*, or calls the base implementation (to raise a :exc:"
"`TypeError`)."
msgstr "在子類別中實作此方法，使其回傳 *o* 的可序列化物件，或呼叫基本實作（引發 "
":exc:`TypeError`）。"

#: ../../library/json.rst:485
#, fuzzy
msgid ""
"For example, to support arbitrary iterators, you could implement :meth:"
"`default` like this::"
msgstr "例如，要支援任意疊代器，您可以像這樣實作 :meth:`default`::"

#: ../../library/json.rst:501
#, fuzzy
msgid ""
"Return a JSON string representation of a Python data structure, *o*.  For "
"example::"
msgstr "回傳 Python 資料結構 *o* 的 JSON 字串表示。例如：："

#: ../../library/json.rst:510
#, fuzzy
msgid ""
"Encode the given object, *o*, and yield each string representation as "
"available.  For example::"
msgstr "對給定物件 *o* 進行編碼，並生成每個可用的字串表示形式。例如：："

#: ../../library/json.rst:518
msgid "Exceptions"
msgstr "例外"

#: ../../library/json.rst:522
#, fuzzy
msgid "Subclass of :exc:`ValueError` with the following additional attributes:"
msgstr "具有以下附加屬性的 :exc:`ValueError` 的子類別："

#: ../../library/json.rst:526
#, fuzzy
msgid "The unformatted error message."
msgstr "未格式化的錯誤消息。"

#: ../../library/json.rst:530
#, fuzzy
msgid "The JSON document being parsed."
msgstr "正在解析的 JSON 文檔。"

#: ../../library/json.rst:534
#, fuzzy
msgid "The start index of *doc* where parsing failed."
msgstr "解析失敗的 *doc* 的起始索引。"

#: ../../library/json.rst:538
#, fuzzy
msgid "The line corresponding to *pos*."
msgstr "*pos*對應的行。"

#: ../../library/json.rst:542
#, fuzzy
msgid "The column corresponding to *pos*."
msgstr "*pos*對應的列。"

#: ../../library/json.rst:548
#, fuzzy
msgid "Standard Compliance and Interoperability"
msgstr "標準合規性和互操作性"

#: ../../library/json.rst:550
#, fuzzy
msgid ""
"The JSON format is specified by :rfc:`7159` and by `ECMA-404 <https://www."
"ecma-international.org/publications-and-standards/standards/ecma-404/>`_. "
"This section details this module's level of compliance with the RFC. For "
"simplicity, :class:`JSONEncoder` and :class:`JSONDecoder` subclasses, and "
"parameters other than those explicitly mentioned, are not considered."
msgstr ""
"JSON 格式由 :rfc:`7159` 和 `ECMA-404 <https://www.ecma-international.org/"
"publications-and-standards/standards/ecma-404/>`_ 指定。"
"本節詳細介紹了此模組與 RFC 的合規性級別。為簡單起見，不考慮 "
":class:`JSONEncoder` 和 :class:`JSONDecoder` 子類別以及未明確提及的參數。"

#: ../../library/json.rst:556
#, fuzzy
msgid ""
"This module does not comply with the RFC in a strict fashion, implementing "
"some extensions that are valid JavaScript but not valid JSON.  In particular:"
msgstr "該模組不嚴格遵守 RFC，實作了一些有效 JavaScript 但不是有效 JSON "
"的擴充。尤其："

#: ../../library/json.rst:559
#, fuzzy
msgid "Infinite and NaN number values are accepted and output;"
msgstr "接受並輸出無限和 NaN 數值；"

#: ../../library/json.rst:560
#, fuzzy
msgid ""
"Repeated names within an object are accepted, and only the value of the last "
"name-value pair is used."
msgstr "接受對像中的重複名稱，並且只使用最後一個名稱-值對的值。"

#: ../../library/json.rst:563
#, fuzzy
msgid ""
"Since the RFC permits RFC-compliant parsers to accept input texts that are "
"not RFC-compliant, this module's deserializer is technically RFC-compliant "
"under default settings."
msgstr "由於 RFC 允許符合 RFC 的解析器接受不符合 RFC 的輸入文本，"
"因此該模組的反序列化器在預設設定下在技術上符合 RFC。"

#: ../../library/json.rst:568
#, fuzzy
msgid "Character Encodings"
msgstr "字元編碼"

#: ../../library/json.rst:570
#, fuzzy
msgid ""
"The RFC requires that JSON be represented using either UTF-8, UTF-16, or "
"UTF-32, with UTF-8 being the recommended default for maximum "
"interoperability."
msgstr "RFC 要求使用 UTF-8、UTF-16 或 UTF-32 表示 JSON，其中 UTF-8 "
"是最大互操作性的推薦預設值。"

#: ../../library/json.rst:573
#, fuzzy
msgid ""
"As permitted, though not required, by the RFC, this module's serializer sets "
"*ensure_ascii=True* by default, thus escaping the output so that the "
"resulting strings only contain ASCII characters."
msgstr ""
"根據 RFC 的允許，但不是必需的，此模組的序列化程式預設設定 "
"*ensure_ascii=True*，從而轉義輸出，以便生成的字串僅包含 ASCII 字元。"

#: ../../library/json.rst:577
#, fuzzy
msgid ""
"Other than the *ensure_ascii* parameter, this module is defined strictly in "
"terms of conversion between Python objects and :class:`Unicode strings "
"<str>`, and thus does not otherwise directly address the issue of character "
"encodings."
msgstr ""
"除了 *ensure_ascii* 參數，此模組嚴格按照 Python 物件和 :class:`Unicode "
"strings <str>` 之間的轉換定義，因此不會直接解決字元編碼問題。"

#: ../../library/json.rst:582
#, fuzzy
msgid ""
"The RFC prohibits adding a byte order mark (BOM) to the start of a JSON "
"text, and this module's serializer does not add a BOM to its output. The RFC "
"permits, but does not require, JSON deserializers to ignore an initial BOM "
"in their input.  This module's deserializer raises a :exc:`ValueError` when "
"an initial BOM is present."
msgstr ""
"RFC 禁止在 JSON 文本的開頭新增位元組順序標記 (BOM)，"
"並且此模組的序列化程式不會在其輸出中新增 BOM。 RFC 允許但不要求 JSON "
"反序列化器忽略其輸入中的初始 BOM。當存在初始 BOM 時，"
"此模組的反序列化器會引發 :exc:`ValueError`。"

#: ../../library/json.rst:588
#, fuzzy
msgid ""
"The RFC does not explicitly forbid JSON strings which contain byte sequences "
"that don't correspond to valid Unicode characters (e.g. unpaired UTF-16 "
"surrogates), but it does note that they may cause interoperability problems. "
"By default, this module accepts and outputs (when present in the original :"
"class:`str`) code points for such sequences."
msgstr ""
"RFC 沒有明確禁止包含與有效 Unicode 字元不對應的位元組序列的 JSON 字串（"
"例如未配對的 UTF-16 代理項），但它確實指出它們可能會導致互操作性問題。預設情"
"況下，此模組接受並輸出（當存在於原始 :class:`str` 中時）此類序列的程式碼點。"

#: ../../library/json.rst:596
#, fuzzy
msgid "Infinite and NaN Number Values"
msgstr "無限和 NaN 數值"

#: ../../library/json.rst:598
#, fuzzy
msgid ""
"The RFC does not permit the representation of infinite or NaN number values. "
"Despite that, by default, this module accepts and outputs ``Infinity``, ``-"
"Infinity``, and ``NaN`` as if they were valid JSON number literal values::"
msgstr ""
"RFC 不允許表示無限或 NaN "
"數值。儘管如此，預設情況下，此模組接受並輸出 ``Infinity`` 、 ``-Infinity`` 和 ``NaN``，"
"就好像它們是有效的 JSON 數字文字值一樣："

#: ../../library/json.rst:613
#, fuzzy
msgid ""
"In the serializer, the *allow_nan* parameter can be used to alter this "
"behavior.  In the deserializer, the *parse_constant* parameter can be used "
"to alter this behavior."
msgstr "在序列化程式中，*allow_nan* "
"參數可用於改變此行為。在反序列化器中，*parse_constant* 參數可用於改變此行為。"

#: ../../library/json.rst:619
#, fuzzy
msgid "Repeated Names Within an Object"
msgstr "對像中的重複名稱"

#: ../../library/json.rst:621
#, fuzzy
msgid ""
"The RFC specifies that the names within a JSON object should be unique, but "
"does not mandate how repeated names in JSON objects should be handled.  By "
"default, this module does not raise an exception; instead, it ignores all "
"but the last name-value pair for a given name::"
msgstr ""
"RFC 指定 JSON 對像中的名稱應該是唯一的，但沒有規定應該如何處理 JSON 對像中的"
"重複名稱。預設情況下，此模組不會引發例外；相反，它會忽略給定名稱的最後一個名"
"稱-值對以外的所有名稱::"

#: ../../library/json.rst:630
#, fuzzy
msgid "The *object_pairs_hook* parameter can be used to alter this behavior."
msgstr "*object_pairs_hook* 參數可用於改變此行為。"

#: ../../library/json.rst:634
#, fuzzy
msgid "Top-level Non-Object, Non-Array Values"
msgstr "頂級非物件、非數組值"

#: ../../library/json.rst:636
#, fuzzy
msgid ""
"The old version of JSON specified by the obsolete :rfc:`4627` required that "
"the top-level value of a JSON text must be either a JSON object or array "
"(Python :class:`dict` or :class:`list`), and could not be a JSON null, "
"boolean, number, or string value.  :rfc:`7159` removed that restriction, and "
"this module does not and has never implemented that restriction in either "
"its serializer or its deserializer."
msgstr ""
"過時的 :rfc:`4627` 指定的舊版本 JSON 要求 JSON 文本的頂級值必須是 JSON "
"對像或數組（Python :class:`dict` 或 :class:`list`） ，並且不能是 JSON "
"空值、布爾值、數字或字串值。 :rfc:`7159` "
"刪除了該限制，並且該模組沒有也從未在其序列化器或反序列化器中實作該限制。"

#: ../../library/json.rst:643
#, fuzzy
msgid ""
"Regardless, for maximum interoperability, you may wish to voluntarily adhere "
"to the restriction yourself."
msgstr "無論如何，為了獲得最大的互操作性，您可能希望自己自願遵守限制。"

#: ../../library/json.rst:648
#, fuzzy
msgid "Implementation Limitations"
msgstr "實施限制"

#: ../../library/json.rst:650
#, fuzzy
msgid "Some JSON deserializer implementations may set limits on:"
msgstr "一些 JSON 反序列化器實作可能會限制："

#: ../../library/json.rst:652
#, fuzzy
msgid "the size of accepted JSON texts"
msgstr "接受的 JSON 文本的大小"

#: ../../library/json.rst:653
#, fuzzy
msgid "the maximum level of nesting of JSON objects and arrays"
msgstr "JSON 物件和數組的最大嵌套級別"

#: ../../library/json.rst:654
#, fuzzy
msgid "the range and precision of JSON numbers"
msgstr "JSON 數字的範圍和精度"

#: ../../library/json.rst:655
#, fuzzy
msgid "the content and maximum length of JSON strings"
msgstr "JSON字串的內容和最大長度"

#: ../../library/json.rst:657
#, fuzzy
msgid ""
"This module does not impose any such limits beyond those of the relevant "
"Python datatypes themselves or the Python interpreter itself."
msgstr "除了相關的 Python 資料型別本身或 Python "
"直譯器本身之外，該模組不會施加任何此類限制。"

#: ../../library/json.rst:660
#, fuzzy
msgid ""
"When serializing to JSON, beware any such limitations in applications that "
"may consume your JSON.  In particular, it is common for JSON numbers to be "
"deserialized into IEEE 754 double precision numbers and thus subject to that "
"representation's range and precision limitations.  This is especially "
"relevant when serializing Python :class:`int` values of extremely large "
"magnitude, or when serializing instances of \"exotic\" numerical types such "
"as :class:`decimal.Decimal`."
msgstr ""
"序列化為 JSON 時，請注意可能使用 JSON 的應用程式中的任何此類限制。特別是，將 "
"JSON 數字反序列化為 IEEE 754 "
"雙精度數字並因此受到該表示的範圍和精度限制的情況很常見。這在序列化極大的 "
"Python int 值或序列化“奇異”數字型別的實例（例如 decimal.Decimal）時尤為重要。"

#: ../../library/json.rst:673
#, fuzzy
msgid "Command Line Interface"
msgstr "命令列界面"

#: ../../library/json.rst:678
msgid "**Source code:** :source:`Lib/json/tool.py`"
msgstr "**原始碼：**\\ :source:`Lib/json/tool.py`"

#: ../../library/json.rst:682
#, fuzzy
msgid ""
"The :mod:`json.tool` module provides a simple command line interface to "
"validate and pretty-print JSON objects."
msgstr ":mod:`json.tool` 模組提供了一個簡單的命令列界面來驗證和漂亮地印出 JSON 物件。"

#: ../../library/json.rst:685
#, fuzzy
msgid ""
"If the optional ``infile`` and ``outfile`` arguments are not specified, :"
"attr:`sys.stdin` and :attr:`sys.stdout` will be used respectively:"
msgstr ""
"如果未指定可選的 ``infile`` 和 ``outfile`` 參數，將分別使用 :attr:`sys.stdin`"
" 和 :attr:`sys.stdout`："

#: ../../library/json.rst:697
#, fuzzy
msgid ""
"The output is now in the same order as the input. Use the :option:`--sort-"
"keys` option to sort the output of dictionaries alphabetically by key."
msgstr "輸出現在與輸入的順序相同。使用 :option:`--sort-keys` "
"選項按鍵按字母順序對字典的輸出進行排序。"

#: ../../library/json.rst:704
#, fuzzy
msgid "Command line options"
msgstr "命令列選項"

#: ../../library/json.rst:708
#, fuzzy
msgid "The JSON file to be validated or pretty-printed:"
msgstr "要驗證或漂亮印出的 JSON 文件："

#: ../../library/json.rst:724
#, fuzzy
msgid "If *infile* is not specified, read from :attr:`sys.stdin`."
msgstr "如果未指定 *infile*，請從 :attr:`sys.stdin` 讀取。"

#: ../../library/json.rst:728
#, fuzzy
msgid ""
"Write the output of the *infile* to the given *outfile*. Otherwise, write it "
"to :attr:`sys.stdout`."
msgstr "將 *infile* 的輸出寫入給定的 *outfile*。否則，將其寫入 :attr:`sys.stdout`。"

#: ../../library/json.rst:733
#, fuzzy
msgid "Sort the output of dictionaries alphabetically by key."
msgstr "按鍵按字母順序對字典的輸出進行排序。"

#: ../../library/json.rst:739
#, fuzzy
msgid ""
"Disable escaping of non-ascii characters, see :func:`json.dumps` for more "
"information."
msgstr "禁用非 ascii 字元的轉義，請參閱 :func:`json.dumps` 了解更多資訊。"

#: ../../library/json.rst:745
#, fuzzy
msgid "Parse every input line as separate JSON object."
msgstr "將每個輸入行解析為單獨的 JSON 物件。"

#: ../../library/json.rst:751
#, fuzzy
msgid "Mutually exclusive options for whitespace control."
msgstr "空白控制的互斥選項。"

#: ../../library/json.rst:757
#, fuzzy
msgid "Show the help message."
msgstr "顯示幫助資訊。"

#: ../../library/json.rst:761
msgid "Footnotes"
msgstr "註解"

#: ../../library/json.rst:762
#, fuzzy
msgid ""
"As noted in `the errata for RFC 7159 <https://www.rfc-editor.org/"
"errata_search.php?rfc=7159>`_, JSON permits literal U+2028 (LINE SEPARATOR) "
"and U+2029 (PARAGRAPH SEPARATOR) characters in strings, whereas JavaScript "
"(as of ECMAScript Edition 5.1) does not."
msgstr ""
"正如`RFC 7159 勘誤表 <https://www.rfc-editor.org/errata_search.php?rfc=7159>`"
"_ 中所述，JSON 允許文字 U+2028（行分隔符）和 U+2029（段落分隔符) "
"字串中的字元，而 JavaScript（從 ECMAScript 版本 5.1 開始）沒有。"
