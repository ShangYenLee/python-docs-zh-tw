# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-24 00:16+0000\n"
"PO-Revision-Date: 2018-05-23 16:07+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/pdb.rst:4
#, fuzzy
msgid ":mod:`pdb` --- The Python Debugger"
msgstr ":mod:`pdb` --- Python 除錯器"

#: ../../library/pdb.rst:9
msgid "**Source code:** :source:`Lib/pdb.py`"
msgstr "**原始碼：**\\ :source:`Lib/pdb.py`"

#: ../../library/pdb.rst:15
#, fuzzy
msgid ""
"The module :mod:`pdb` defines an interactive source code debugger for Python "
"programs.  It supports setting (conditional) breakpoints and single stepping "
"at the source line level, inspection of stack frames, source code listing, "
"and evaluation of arbitrary Python code in the context of any stack frame.  "
"It also supports post-mortem debugging and can be called under program "
"control."
msgstr ""
":mod:`pdb` 模組為 Python 程式定義了一個交互式源程式碼除錯器。它支援在源程式碼"
"行級別設定（條件）斷點和單步執行、檢查堆疊幀、"
"源程式碼列表以及在任何堆疊幀的上下文中評估任意 Python "
"程式碼。它還支援事後除錯，可以在程式控制下呼叫。"

#: ../../library/pdb.rst:26
#, fuzzy
msgid ""
"The debugger is extensible -- it is actually defined as the class :class:"
"`Pdb`. This is currently undocumented but easily understood by reading the "
"source.  The extension interface uses the modules :mod:`bdb` and :mod:`cmd`."
msgstr ""
"除錯器是可擴充的——它實際上被定義為類 :class:`Pdb`。這目前沒有記錄，但通過閱讀"
"源程式碼很容易理解。擴充介面使用模組 :mod:`bdb` 和 :mod:`cmd`。"

#: ../../library/pdb.rst:34
#, fuzzy
msgid "Module :mod:`faulthandler`"
msgstr "模組 :mod:`faulthandler`"

#: ../../library/pdb.rst:33
#, fuzzy
msgid ""
"Used to dump Python tracebacks explicitly, on a fault, after a timeout, or "
"on a user signal."
msgstr "用於在出現故障、超時後或使用者信號時顯式轉儲 Python 回溯。"

#: ../../library/pdb.rst:36
#, fuzzy
msgid "Module :mod:`traceback`"
msgstr "模組 :mod:`回溯`"

#: ../../library/pdb.rst:37
#, fuzzy
msgid ""
"Standard interface to extract, format and print stack traces of Python "
"programs."
msgstr "用於提取、格式化和印出 Python 程式堆疊跟踪的標準介面。"

#: ../../library/pdb.rst:39
#, fuzzy
msgid "The typical usage to break into the debugger is to insert::"
msgstr "進入除錯器的典型用法是插入："

#: ../../library/pdb.rst:43
#, fuzzy
msgid "Or::"
msgstr "或者：："

#: ../../library/pdb.rst:47
#, fuzzy
msgid ""
"at the location you want to break into the debugger, and then run the "
"program. You can then step through the code following this statement, and "
"continue running without the debugger using the :pdbcmd:`continue` command."
msgstr ""
"在您要進入除錯器的位置，然後運行該程式。然後，您可以單步執行此語句後的程式碼"
"，並使用 :pdbcmd:`continue` 命令在沒有除錯器的情況下繼續運行。"

#: ../../library/pdb.rst:51
#, fuzzy
msgid ""
"The built-in :func:`breakpoint()`, when called with defaults, can be used "
"instead of ``import pdb; pdb.set_trace()``."
msgstr ""
"內建的 :func:`breakpoint()`，當使用預設值呼叫時，可以用來代替 ``import pdb; "
"pdb.set_trace()``。"

#: ../../library/pdb.rst:63
#, fuzzy
msgid ""
"The debugger's prompt is ``(Pdb)``, which is the indicator that you are in "
"debug mode::"
msgstr "除錯器的提示符是``(Pdb)``，這表明您處於除錯模式::"

#: ../../library/pdb.rst:72
#, fuzzy
msgid ""
"Tab-completion via the :mod:`readline` module is available for commands and "
"command arguments, e.g. the current global and local names are offered as "
"arguments of the ``p`` command."
msgstr "通過 :mod:`readline` 模組的 Tab 補全可用於命令和命令參數，"
"例如當前的全局和局部名稱作為 ``p`` 命令的參數提供。"

#: ../../library/pdb.rst:78
#, fuzzy
msgid ""
"You can also invoke :mod:`pdb` from the command line to debug other "
"scripts.  For example::"
msgstr "您還可以從命令列呼叫 :mod:`pdb` 來除錯其他腳本。例如：："

#: ../../library/pdb.rst:83
#, fuzzy
msgid ""
"When invoked as a module, pdb will automatically enter post-mortem debugging "
"if the program being debugged exits abnormally.  After post-mortem debugging "
"(or after normal exit of the program), pdb will restart the program.  "
"Automatic restarting preserves pdb's state (such as breakpoints) and in most "
"cases is more useful than quitting the debugger upon program's exit."
msgstr ""
"作為模組呼叫時，如果被除錯程式例外退出，pdb會自動進入事後除錯。"
"事後除錯後（或程式正常退出後），pdb會重啟程式。自動重新啟動會保留 pdb "
"的狀態（例如斷點），並且在大多數情況下比在程式退出時退出除錯器更有用。"

#: ../../library/pdb.rst:89
#, fuzzy
msgid ""
"``-c`` option is introduced to execute commands as if given in a :file:`."
"pdbrc` file, see :ref:`debugger-commands`."
msgstr ""
"``-c`` 選項被引入來執行命令，就像在 :file:`.pdbrc` "
"文件中給出的一樣，請參閱 :ref:`debugger-commands`。"

#: ../../library/pdb.rst:93
#, fuzzy
msgid ""
"``-m`` option is introduced to execute modules similar to the way ``python -"
"m`` does. As with a script, the debugger will pause execution just before "
"the first line of the module."
msgstr "``-m`` 選項被引入來執行類似於 ``python -m`` "
"的模組。與腳本一樣，除錯器將在模組的第一行之前暫停執行。"

#: ../../library/pdb.rst:98
#, fuzzy
msgid "Typical usage to execute a statement under control of the debugger is::"
msgstr "在除錯器的控制下執行語句的典型用法是："

#: ../../library/pdb.rst:109
#, fuzzy
msgid "The typical usage to inspect a crashed program is::"
msgstr "檢查崩潰程式的典型用法是："

#: ../../library/pdb.rst:127
#, fuzzy
msgid ""
"The module defines the following functions; each enters the debugger in a "
"slightly different way:"
msgstr "該模組定義了以下功能；每個進入除錯器的方式都略有不同："

#: ../../library/pdb.rst:132
#, fuzzy
msgid ""
"Execute the *statement* (given as a string or a code object) under debugger "
"control.  The debugger prompt appears before any code is executed; you can "
"set breakpoints and type :pdbcmd:`continue`, or you can step through the "
"statement using :pdbcmd:`step` or :pdbcmd:`next` (all these commands are "
"explained below).  The optional *globals* and *locals* arguments specify the "
"environment in which the code is executed; by default the dictionary of the "
"module :mod:`__main__` is used.  (See the explanation of the built-in :func:"
"`exec` or :func:`eval` functions.)"
msgstr ""
"在除錯器控制下執行 *statement*（以字串或程式碼物件形式給出）。除錯器提示出現"
"在任何程式碼執行之前；您可以設定斷點並鍵入 :pdbcmd:`continue`，"
"或者您可以使用 :pdbcmd:`step` 或 :pdbcmd:`next` "
"單步執行語句（所有這些命令都在下面解釋）。可選的 *globals* 和 *locals* "
"參數指定程式碼執行的環境；預設使用模組 :mod:`__main__` 的字典。 （參見內建 "
":func:`exec` 或 :func:`eval` 函式的解釋。）"

#: ../../library/pdb.rst:144
#, fuzzy
msgid ""
"Evaluate the *expression* (given as a string or a code object) under "
"debugger control.  When :func:`runeval` returns, it returns the value of the "
"*expression*.  Otherwise this function is similar to :func:`run`."
msgstr ""
"在除錯器控制下評估 *expression*（以字串或程式碼物件形式給出）。當 "
":func:`runeval` 回傳時，它回傳 *expression* 的值。否則此函式類似於 "
":func:`run`。"

#: ../../library/pdb.rst:151
#, fuzzy
msgid ""
"Call the *function* (a function or method object, not a string) with the "
"given arguments.  When :func:`runcall` returns, it returns whatever the "
"function call returned.  The debugger prompt appears as soon as the function "
"is entered."
msgstr ""
"使用給定的參數呼叫 *function*（函式或方法物件，而不是字串）。當 "
":func:`runcall` "
"回傳時，它回傳函式呼叫回傳的任何內容。一旦輸入函式，就會出現除錯器提示。"

#: ../../library/pdb.rst:159
#, fuzzy
msgid ""
"Enter the debugger at the calling stack frame.  This is useful to hard-code "
"a breakpoint at a given point in a program, even if the code is not "
"otherwise being debugged (e.g. when an assertion fails).  If given, *header* "
"is printed to the console just before debugging begins."
msgstr ""
"在呼叫堆疊幀處輸入除錯器。這對於在程式中的給定點處硬編碼斷點很有用，即使程式"
"碼沒有以其他方式被除錯（例如，當斷言失敗時）。如果給定，*header* "
"會在除錯開始前印出到控制台。"

#: ../../library/pdb.rst:164
#, fuzzy
msgid "The keyword-only argument *header*."
msgstr "僅關鍵字參數 *header*。"

#: ../../library/pdb.rst:170
#, fuzzy
msgid ""
"Enter post-mortem debugging of the given *traceback* object.  If no "
"*traceback* is given, it uses the one of the exception that is currently "
"being handled (an exception must be being handled if the default is to be "
"used)."
msgstr ""
"輸入給定 *traceback* 物件的事後除錯。如果沒有給出 *traceback*，它使用當前正在"
"處理的例外之一（如果要使用預設值，則必須處理例外）。"

#: ../../library/pdb.rst:178
#, fuzzy
msgid ""
"Enter post-mortem debugging of the traceback found in :data:`sys."
"last_traceback`."
msgstr "輸入在 sys.last_traceback 中找到的回溯的事後除錯。"

#: ../../library/pdb.rst:182
#, fuzzy
msgid ""
"The ``run*`` functions and :func:`set_trace` are aliases for instantiating "
"the :class:`Pdb` class and calling the method of the same name.  If you want "
"to access further features, you have to do this yourself:"
msgstr ""
"``run*`` 函式和 :func:`set_trace` 是實例化 Pdb "
"類和呼叫同名方法的別名。如果您想訪問更多功能，您必須自己執行此操作："

#: ../../library/pdb.rst:189
#, fuzzy
msgid ":class:`Pdb` is the debugger class."
msgstr ":class:`Pdb` 是除錯器類。"

#: ../../library/pdb.rst:191
#, fuzzy
msgid ""
"The *completekey*, *stdin* and *stdout* arguments are passed to the "
"underlying :class:`cmd.Cmd` class; see the description there."
msgstr "*completekey*、*stdin* 和 *stdout* 參數傳遞給底層 :class:`cmd.Cmd` "
"類；看那裡的描述。"

#: ../../library/pdb.rst:194
#, fuzzy
msgid ""
"The *skip* argument, if given, must be an iterable of glob-style module name "
"patterns.  The debugger will not step into frames that originate in a module "
"that matches one of these patterns. [1]_"
msgstr "*skip* 參數（如果給定）必須是可疊代的 glob "
"樣式模組名稱模式。除錯器不會進入源自與這些模式之一匹配的模組的幀。 [1]_"

#: ../../library/pdb.rst:198
#, fuzzy
msgid ""
"By default, Pdb sets a handler for the SIGINT signal (which is sent when the "
"user presses :kbd:`Ctrl-C` on the console) when you give a :pdbcmd:"
"`continue` command. This allows you to break into the debugger again by "
"pressing :kbd:`Ctrl-C`.  If you want Pdb not to touch the SIGINT handler, "
"set *nosigint* to true."
msgstr ""
"預設情況下，當您發出 :pdbcmd:`continue` 命令時，Pdb 會為 SIGINT 信號（"
"當使用者在控制台上按下 Ctrl-C 時發送）設定一個處理程式。這允許您通過按 "
":kbd:`Ctrl-C` 再次進入除錯器。如果您希望 Pdb 不接觸 SIGINT 處理程式，請將 "
"*nosigint* 設定為 true。"

#: ../../library/pdb.rst:203
#, fuzzy
msgid ""
"The *readrc* argument defaults to true and controls whether Pdb will load ."
"pdbrc files from the filesystem."
msgstr "*readrc* 參數預設為 true 並控制 Pdb 是否從文件系統加載 .pdbrc 文件。"

#: ../../library/pdb.rst:206
#, fuzzy
msgid "Example call to enable tracing with *skip*::"
msgstr "使用 *skip*:: 啟用跟踪的示例呼叫"

#: ../../library/pdb.rst:210
msgid ""
"Raises an :ref:`auditing event <auditing>` ``pdb.Pdb`` with no arguments."
msgstr ""
"引發一個不附帶引數的\\ :ref:`稽核事件 <auditing>` ``pdb.Pdb``。"

#: ../../library/pdb.rst:212
#, fuzzy
msgid "The *skip* argument."
msgstr "*skip* 參數。"

#: ../../library/pdb.rst:215
#, fuzzy
msgid ""
"The *nosigint* argument.  Previously, a SIGINT handler was never set by Pdb."
msgstr "*nosigint* 參數。以前，SIGINT 處理程式從未由 Pdb 設定。"

#: ../../library/pdb.rst:219
#, fuzzy
msgid "The *readrc* argument."
msgstr "*readrc* 參數。"

#: ../../library/pdb.rst:227
#, fuzzy
msgid "See the documentation for the functions explained above."
msgstr "有關上述功能的說明，請參閱文檔。"

#: ../../library/pdb.rst:233
#, fuzzy
msgid "Debugger Commands"
msgstr "除錯器命令"

#: ../../library/pdb.rst:235
#, fuzzy
msgid ""
"The commands recognized by the debugger are listed below.  Most commands can "
"be abbreviated to one or two letters as indicated; e.g. ``h(elp)`` means "
"that either ``h`` or ``help`` can be used to enter the help command (but not "
"``he`` or ``hel``, nor ``H`` or ``Help`` or ``HELP``).  Arguments to "
"commands must be separated by whitespace (spaces or tabs).  Optional "
"arguments are enclosed in square brackets (``[]``) in the command syntax; "
"the square brackets must not be typed.  Alternatives in the command syntax "
"are separated by a vertical bar (``|``)."
msgstr ""
"下面列出了除錯器識別的命令。大多數命令都可以縮寫為一個或兩個字母，如下所示；"
"例如``h(elp)`` 表示可以使用 ``h`` 或 ``help`` 來輸入幫助命令（但不能使用 "
"``he`` 或 ``hel``，也不能使用 ``H` `或``幫助``或``幫助``）。命令的參數必須用"
"空格（空格或製表符）分隔。在命令語法中，可選參數括在方括號 (``[]``) "
"中；不得鍵入方括號。命令語法中的替代項由豎線 (``|``) 分隔。"

#: ../../library/pdb.rst:244
#, fuzzy
msgid ""
"Entering a blank line repeats the last command entered.  Exception: if the "
"last command was a :pdbcmd:`list` command, the next 11 lines are listed."
msgstr "輸入空行會重複輸入的最後一個命令。例外：如果最後一個命令是 :pdbcmd:`list` "
"命令，則列出接下來的 11 行。"

#: ../../library/pdb.rst:247
#, fuzzy
msgid ""
"Commands that the debugger doesn't recognize are assumed to be Python "
"statements and are executed in the context of the program being debugged.  "
"Python statements can also be prefixed with an exclamation point (``!``).  "
"This is a powerful way to inspect the program being debugged; it is even "
"possible to change a variable or call a function.  When an exception occurs "
"in such a statement, the exception name is printed but the debugger's state "
"is not changed."
msgstr ""
"除錯器無法識別的命令被假定為 Python 語句，並在被除錯程式的上下文中執行。 "
"Python 語句也可以以感嘆號 (``!``) 為前綴。這是一種檢查正在除錯的程式的強大方"
"法；甚至可以更改變數或呼叫函式。當在這樣的語句中發生例外時，將印出例外名稱但"
"不會更改除錯器的狀態。"

#: ../../library/pdb.rst:255
#, fuzzy
msgid ""
"The debugger supports :ref:`aliases <debugger-aliases>`.  Aliases can have "
"parameters which allows one a certain level of adaptability to the context "
"under examination."
msgstr "除錯器支援 :ref:`aliases <debugger-"
"aliases>`。別名可以有參數，允許一個人對所檢查的上下文有一定程度的適應性。"

#: ../../library/pdb.rst:259
#, fuzzy
msgid ""
"Multiple commands may be entered on a single line, separated by ``;;``.  (A "
"single ``;`` is not used as it is the separator for multiple commands in a "
"line that is passed to the Python parser.)  No intelligence is applied to "
"separating the commands; the input is split at the first ``;;`` pair, even "
"if it is in the middle of a quoted string. A workaround for strings with "
"double semicolons is to use implicit string concatenation ``';'';'`` or ``\";"
"\"\";\"``."
msgstr ""
"可以在一行中輸入多個命令，以 ``;;`` 分隔。 （不使用單個 ``;``，"
"因為它是傳遞給 Python "
"解析器的一行中多個命令的分隔符。）沒有應用智能來分隔命令；輸入在第一個 ``;;``"
" 對處被拆分，即使它位於帶引號的字串的中間。"
"帶有雙分號的字串的解決方法是使用隱式字串連接 ``\\';\\'\\';\\'`` 或 ``\";\"\";"
"\"``。"

#: ../../library/pdb.rst:270
#, fuzzy
msgid ""
"If a file :file:`.pdbrc` exists in the user's home directory or in the "
"current directory, it is read with ``'utf-8'`` encoding and executed as if "
"it had been typed at the debugger prompt.  This is particularly useful for "
"aliases.  If both files exist, the one in the home directory is read first "
"and aliases defined there can be overridden by the local file."
msgstr ""
"如果文件 :file:`.pdbrc` 存在於使用者的主目錄或當前目錄中，它將使用 "
"``'utf-8'`` 編碼讀取並執行，就好像它是在除錯器提示符下鍵入的一樣。這對於別名"
"特別有用。如果這兩個文件都存在，則首先讀取主目錄中的文件，然後本地文件可以覆"
"蓋定義的別名。"

#: ../../library/pdb.rst:276
#, fuzzy
msgid ""
":file:`.pdbrc` is now read with ``'utf-8'`` encoding. Previously, it was "
"read with the system locale encoding."
msgstr ":file:`.pdbrc` 現在使用 ``'utf-8'`` "
"編碼讀取。以前，它是使用系統區域設定編碼讀取的。"

#: ../../library/pdb.rst:280
#, fuzzy
msgid ""
":file:`.pdbrc` can now contain commands that continue debugging, such as :"
"pdbcmd:`continue` or :pdbcmd:`next`.  Previously, these commands had no "
"effect."
msgstr ""
":file:`.pdbrc` 現在可以包含繼續除錯的命令，例如 :pdbcmd:`continue` 或 "
":pdbcmd:`next`。以前，這些命令沒有任何效果。"

#: ../../library/pdb.rst:288
#, fuzzy
msgid ""
"Without argument, print the list of available commands.  With a *command* as "
"argument, print help about that command.  ``help pdb`` displays the full "
"documentation (the docstring of the :mod:`pdb` module).  Since the *command* "
"argument must be an identifier, ``help exec`` must be entered to get help on "
"the ``!`` command."
msgstr ""
"不帶參數，印出可用命令列表。使用 *command* 作為參數，印出有關該命令的幫助。 "
"``help pdb`` 顯示完整文檔（:mod:`pdb` 模組的文檔字串）。由於 *command* "
"參數必須是標識符，因此必須輸入 ``help exec`` 以獲取有關 ``!`` 命令的幫助。"

#: ../../library/pdb.rst:296
#, fuzzy
msgid ""
"Print a stack trace, with the most recent frame at the bottom.  An arrow "
"(``>``) indicates the current frame, which determines the context of most "
"commands."
msgstr "印出堆疊跟踪，最近的幀在底部。箭頭 (``>``) "
"表示當前幀，它決定了大多數命令的上下文。"

#: ../../library/pdb.rst:301
#, fuzzy
msgid ""
"Move the current frame *count* (default one) levels down in the stack trace "
"(to a newer frame)."
msgstr "在堆疊跟踪中將當前幀*計數*（預設一個）級別向下移動（到較新的幀）。"

#: ../../library/pdb.rst:306
#, fuzzy
msgid ""
"Move the current frame *count* (default one) levels up in the stack trace "
"(to an older frame)."
msgstr "將當前幀*計數*（預設一個）在堆疊跟踪中向上移動（到較舊的幀）。"

#: ../../library/pdb.rst:311
#, fuzzy
msgid ""
"With a *lineno* argument, set a break there in the current file.  With a "
"*function* argument, set a break at the first executable statement within "
"that function.  The line number may be prefixed with a filename and a colon, "
"to specify a breakpoint in another file (probably one that hasn't been "
"loaded yet).  The file is searched on :data:`sys.path`.  Note that each "
"breakpoint is assigned a number to which all the other breakpoint commands "
"refer."
msgstr ""
"使用 *lineno* 參數，在當前文件中設定一個中斷。使用 *function* 參數，在該函式"
"內的第一個可執行語句處設定一個中斷。行號可以以文件名和冒號為前綴，以指定另一"
"個文件（可能尚未加載的文件）中的斷點。該文件在 :data:`sys.path` "
"上搜索。請注意，每個斷點都分配有一個編號，所有其他斷點命令都引用該編號。"

#: ../../library/pdb.rst:318
#, fuzzy
msgid ""
"If a second argument is present, it is an expression which must evaluate to "
"true before the breakpoint is honored."
msgstr "如果存在第二個參數，則它是一個表達式，在斷點生效之前必須計算為真。"

#: ../../library/pdb.rst:321
#, fuzzy
msgid ""
"Without argument, list all breaks, including for each breakpoint, the number "
"of times that breakpoint has been hit, the current ignore count, and the "
"associated condition if any."
msgstr "不帶參數，列出所有斷點，包括每個斷點、斷點被擊中的次數、當前忽略計數以及相關"
"條件（如果有）。"

#: ../../library/pdb.rst:327
#, fuzzy
msgid ""
"Temporary breakpoint, which is removed automatically when it is first hit. "
"The arguments are the same as for :pdbcmd:`break`."
msgstr "臨時斷點，第一次命中時自動移除。參數與 :pdbcmd:`break` 相同。"

#: ../../library/pdb.rst:332
#, fuzzy
msgid ""
"With a *filename:lineno* argument, clear all the breakpoints at this line. "
"With a space separated list of breakpoint numbers, clear those breakpoints. "
"Without argument, clear all breaks (but first ask confirmation)."
msgstr ""
"使用 *filename:lineno* 參數，清除該行的所有斷點。使用空格分隔的斷點編號列表，"
"清除這些斷點。沒有爭論，清除所有中斷（但首先要求確認）。"

#: ../../library/pdb.rst:338
#, fuzzy
msgid ""
"Disable the breakpoints given as a space separated list of breakpoint "
"numbers.  Disabling a breakpoint means it cannot cause the program to stop "
"execution, but unlike clearing a breakpoint, it remains in the list of "
"breakpoints and can be (re-)enabled."
msgstr "禁用以空格分隔的斷點編號列表給出的斷點。禁用斷點意味著它不會導致程式停止執行"
"，但與清除斷點不同的是，它保留在斷點列表中並且可以（重新）啟用。"

#: ../../library/pdb.rst:345
#, fuzzy
msgid "Enable the breakpoints specified."
msgstr "啟用指定的斷點。"

#: ../../library/pdb.rst:349
#, fuzzy
msgid ""
"Set the ignore count for the given breakpoint number.  If *count* is "
"omitted, the ignore count is set to 0.  A breakpoint becomes active when the "
"ignore count is zero.  When non-zero, the *count* is decremented each time "
"the breakpoint is reached and the breakpoint is not disabled and any "
"associated condition evaluates to true."
msgstr ""
"為給定的斷點號設定忽略計數。如果省略 *count*，則忽略計數設定為 0。當忽略計數"
"為零時，斷點變為活動狀態。當非零時，每次到達斷點並且斷點未被禁用且任何關聯條"
"件評估為真時，*count* 都會遞減。"

#: ../../library/pdb.rst:357
#, fuzzy
msgid ""
"Set a new *condition* for the breakpoint, an expression which must evaluate "
"to true before the breakpoint is honored.  If *condition* is absent, any "
"existing condition is removed; i.e., the breakpoint is made unconditional."
msgstr ""
"為斷點設定一個新的*條件*，一個在斷點生效之前必須計算為真的表達式。如果 "
"*condition* 不存在，則刪除任何現有條件；即，斷點是無條件的。"

#: ../../library/pdb.rst:363
#, fuzzy
msgid ""
"Specify a list of commands for breakpoint number *bpnumber*.  The commands "
"themselves appear on the following lines.  Type a line containing just "
"``end`` to terminate the commands. An example::"
msgstr "指定斷點號 *bpnumber* 的命令列表。命令本身出現在以下幾行中。鍵入僅包含 "
"``end`` 的行以終止命令。一個例子：："

#: ../../library/pdb.rst:372
#, fuzzy
msgid ""
"To remove all commands from a breakpoint, type ``commands`` and follow it "
"immediately with ``end``; that is, give no commands."
msgstr "要從斷點中刪除所有命令，請鍵入 ``commands`` 並緊跟其後的 "
"``end``；也就是說，不發出任何命令。"

#: ../../library/pdb.rst:375
#, fuzzy
msgid ""
"With no *bpnumber* argument, ``commands`` refers to the last breakpoint set."
msgstr "如果沒有 *bpnumber* 參數，``commands`` 指的是最後一個斷點集。"

#: ../../library/pdb.rst:377
#, fuzzy
msgid ""
"You can use breakpoint commands to start your program up again.  Simply use "
"the :pdbcmd:`continue` command, or :pdbcmd:`step`, or any other command that "
"resumes execution."
msgstr ""
"您可以使用斷點命令重新啟動程式。只需使用 :pdbcmd:`continue` 命令或 "
":pdbcmd:`step` 或任何其他恢復執行的命令。"

#: ../../library/pdb.rst:381
#, fuzzy
msgid ""
"Specifying any command resuming execution (currently :pdbcmd:`continue`, :"
"pdbcmd:`step`, :pdbcmd:`next`, :pdbcmd:`return`, :pdbcmd:`jump`, :pdbcmd:"
"`quit` and their abbreviations) terminates the command list (as if that "
"command was immediately followed by end). This is because any time you "
"resume execution (even with a simple next or step), you may encounter "
"another breakpoint—which could have its own command list, leading to "
"ambiguities about which list to execute."
msgstr ""
"指定恢復執行的任何命令（當前：:pdbcmd:`continue`、:pdbcmd:`step`、:pdbcmd:`ne"
"xt`、:pdbcmd:`return`、:pdbcmd:`jump`、:pdbcmd:`quit` 及其縮寫) "
"終止命令列表（就好像該命令後面緊跟著 end）。這是因為任何時候您恢復執行（"
"即使是簡單的 next 或 step），您都可能會遇到另一個斷點——它可能有自己的命令列表"
"，從而導致不清楚要執行哪個列表。"

#: ../../library/pdb.rst:390
#, fuzzy
msgid ""
"If you use the ``silent`` command in the command list, the usual message "
"about stopping at a breakpoint is not printed.  This may be desirable for "
"breakpoints that are to print a specific message and then continue.  If none "
"of the other commands print anything, you see no sign that the breakpoint "
"was reached."
msgstr ""
"如果您在命令列表中使用 ``silent`` 命令，則不會印出關於在斷點處停止的常用消息"
"。這對於要印出特定消息然後繼續的斷點可能是理想的。如果其他命令均未印出任何內"
"容，則您看不到已到達斷點的跡象。"

#: ../../library/pdb.rst:397
#, fuzzy
msgid ""
"Execute the current line, stop at the first possible occasion (either in a "
"function that is called or on the next line in the current function)."
msgstr "執行當前行，在第一個可能的情況下停止（在呼叫的函式中或在當前函式的下一行）。"

#: ../../library/pdb.rst:402
#, fuzzy
msgid ""
"Continue execution until the next line in the current function is reached or "
"it returns.  (The difference between :pdbcmd:`next` and :pdbcmd:`step` is "
"that :pdbcmd:`step` stops inside a called function, while :pdbcmd:`next` "
"executes called functions at (nearly) full speed, only stopping at the next "
"line in the current function.)"
msgstr ""
"繼續執行直到到達當前函式的下一行或它回傳。 （:pdbcmd:`next` 和 :pdbcmd:`step`"
" 之間的區別在於 :pdbcmd:`step` 在被呼叫函式內停止，而 :pdbcmd:`next` "
"以（幾乎）全速執行被呼叫函式，僅停止在當前函式的下一行。）"

#: ../../library/pdb.rst:410
#, fuzzy
msgid ""
"Without argument, continue execution until the line with a number greater "
"than the current one is reached."
msgstr "不帶參數，繼續執行，直到到達編號大於當前行的行。"

#: ../../library/pdb.rst:413
#, fuzzy
msgid ""
"With *lineno*, continue execution until a line with a number greater or "
"equal to *lineno* is reached.  In both cases, also stop when the current "
"frame returns."
msgstr "使用 *lineno*，繼續執行直到到達編號大於或等於 *lineno* "
"的行。在這兩種情況下，噹噹前幀回傳時也停止。"

#: ../../library/pdb.rst:417
#, fuzzy
msgid "Allow giving an explicit line number."
msgstr "允許給出明確的行號。"

#: ../../library/pdb.rst:422
#, fuzzy
msgid "Continue execution until the current function returns."
msgstr "繼續執行直到當前函式回傳。"

#: ../../library/pdb.rst:426
#, fuzzy
msgid "Continue execution, only stop when a breakpoint is encountered."
msgstr "繼續執行，只有遇到斷點才停止。"

#: ../../library/pdb.rst:430
#, fuzzy
msgid ""
"Set the next line that will be executed.  Only available in the bottom-most "
"frame.  This lets you jump back and execute code again, or jump forward to "
"skip code that you don't want to run."
msgstr "設定將要執行的下一行。僅在最底部的框架中可用。這使您可以向後跳轉並再次執行程"
"式碼，或者向前跳轉以跳過您不想運行的程式碼。"

#: ../../library/pdb.rst:434
#, fuzzy
msgid ""
"It should be noted that not all jumps are allowed -- for instance it is not "
"possible to jump into the middle of a :keyword:`for` loop or out of a :"
"keyword:`finally` clause."
msgstr ""
"應該注意的是，並不是所有的跳轉都是允許的——例如，不可能跳到一個 :keyword:`for`"
" 循環的中間或跳出一個 :keyword:`finally` 子句。"

#: ../../library/pdb.rst:440
#, fuzzy
msgid ""
"List source code for the current file.  Without arguments, list 11 lines "
"around the current line or continue the previous listing.  With ``.`` as "
"argument, list 11 lines around the current line.  With one argument, list 11 "
"lines around at that line.  With two arguments, list the given range; if the "
"second argument is less than the first, it is interpreted as a count."
msgstr ""
"列出當前文件的源程式碼。在沒有參數的情況下，在當前行周圍列出 11 "
"行或繼續上一個列表。以 ``.`` 作為參數，列出當前行周圍的 11 行。使用一個參數，"
"列出該行周圍的 11 行。使用兩個參數，列出給定的範圍；如果第二個參數小於第一個"
"，則將其解釋為計數。"

#: ../../library/pdb.rst:446
#, fuzzy
msgid ""
"The current line in the current frame is indicated by ``->``.  If an "
"exception is being debugged, the line where the exception was originally "
"raised or propagated is indicated by ``>>``, if it differs from the current "
"line."
msgstr "當前幀中的當前行由“->”指示。如果正在除錯例外，則最初引發或傳播例外的行由``>>`"
"`指示，如果它與當前行不同。"

#: ../../library/pdb.rst:451
#, fuzzy
msgid "The ``>>`` marker."
msgstr "``>>`` 標記。"

#: ../../library/pdb.rst:456
#, fuzzy
msgid ""
"List all source code for the current function or frame.  Interesting lines "
"are marked as for :pdbcmd:`list`."
msgstr "列出當前函式或框架的所有源程式碼。有趣的行被標記為 :pdbcmd:`list`。"

#: ../../library/pdb.rst:463
#, fuzzy
msgid "Print the arguments of the current function and their current values."
msgstr "印出當前函式的參數及其當前值。"

#: ../../library/pdb.rst:467
#, fuzzy
msgid "Evaluate *expression* in the current context and print its value."
msgstr "在當前上下文中計算 *expression* 並印出它的值。"

#: ../../library/pdb.rst:471
#, fuzzy
msgid ""
"``print()`` can also be used, but is not a debugger command --- this "
"executes the Python :func:`print` function."
msgstr "``print()`` 也可以使用，但不是除錯器命令——這會執行 Python :func:`print` "
"函式。"

#: ../../library/pdb.rst:477
#, fuzzy
msgid ""
"Like the :pdbcmd:`p` command, except the value of *expression* is pretty-"
"printed using the :mod:`pprint` module."
msgstr "與 :pdbcmd:`p` 命令一樣，除了 *expression* 的值是使用 :mod:`pprint` "
"模組漂亮印出的。"

#: ../../library/pdb.rst:482
#, fuzzy
msgid "Print the type of *expression*."
msgstr "印出 *expression* 的型別。"

#: ../../library/pdb.rst:486
#, fuzzy
msgid "Try to get source code of *expression* and display it."
msgstr "嘗試獲取 *expression* 的源程式碼並顯示它。"

#: ../../library/pdb.rst:492
#, fuzzy
msgid ""
"Display the value of *expression* if it changed, each time execution stops "
"in the current frame."
msgstr "顯示 *expression* 的值（如果它發生變化），每次執行都在當前幀停止。"

#: ../../library/pdb.rst:495
#, fuzzy
msgid ""
"Without *expression*, list all display expressions for the current frame."
msgstr "如果沒有 *expression*，則列出當前幀的所有顯示表達式。"

#: ../../library/pdb.rst:499
#, fuzzy
msgid ""
"Display evaluates *expression* and compares to the result of the previous "
"evaluation of *expression*, so when the result is mutable, display may not "
"be able to pick up the changes."
msgstr ""
"Display 評估 *expression* 並與先前評估 *expression* "
"的結果進行比較，因此當結果可變時，display 可能無法獲取更改。"

#: ../../library/pdb.rst:503
#, fuzzy
msgid "Example::"
msgstr "例子：："

#: ../../library/pdb.rst:511
#, fuzzy
msgid ""
"Display won't realize ``lst`` has been changed because the result of "
"evaluation is modified in place by ``lst.append(1)`` before being compared::"
msgstr "顯示不會意識到 ``lst`` 已經改變，因為評估結果在比較之前被 ``lst.append(1)`` "
"就地修改::"

#: ../../library/pdb.rst:526
#, fuzzy
msgid "You can do some tricks with copy mechanism to make it work::"
msgstr "您可以使用複制機製做一些技巧以使其工作::"

#: ../../library/pdb.rst:545
#, fuzzy
msgid ""
"Do not display *expression* anymore in the current frame.  Without "
"*expression*, clear all display expressions for the current frame."
msgstr "不再在當前幀中顯示 *expression*。如果沒有 "
"*expression*，清除當前幀的所有顯示表達式。"

#: ../../library/pdb.rst:552
#, fuzzy
msgid ""
"Start an interactive interpreter (using the :mod:`code` module) whose global "
"namespace contains all the (global and local) names found in the current "
"scope."
msgstr "啟動一個交互式直譯器（使用 :mod:`code` "
"模組），其全局命名空間包含在當前範圍內找到的所有（全局和本地）名稱。"

#: ../../library/pdb.rst:562
#, fuzzy
msgid ""
"Create an alias called *name* that executes *command*.  The *command* must "
"*not* be enclosed in quotes.  Replaceable parameters can be indicated by "
"``%1``, ``%2``, and so on, while ``%*`` is replaced by all the parameters. "
"If *command* is omitted, the current alias for *name* is shown. If no "
"arguments are given, all aliases are listed."
msgstr ""
"建立一個名為 *name* 的別名來執行 *command*。 *命令* 必須 *不* "
"用引號引起來。可替換的參數可以用``%1``、``%2``等表示，而``%*``表示所有參數。"
"如果省略 *command*，則顯示 *name* "
"的當前別名。如果沒有給出參數，則列出所有別名。"

#: ../../library/pdb.rst:568
#, fuzzy
msgid ""
"Aliases may be nested and can contain anything that can be legally typed at "
"the pdb prompt.  Note that internal pdb commands *can* be overridden by "
"aliases.  Such a command is then hidden until the alias is removed.  "
"Aliasing is recursively applied to the first word of the command line; all "
"other words in the line are left alone."
msgstr ""
"別名可以嵌套，並且可以包含任何可以在 pdb 提示符下合法鍵入的內容。請注意，"
"內部 pdb 命令*可以*被別名覆蓋。然後隱藏這樣的命令，直到刪除別名。別名遞迴地應"
"用於命令列的第一個單詞；該行中的所有其他詞都被保留。"

#: ../../library/pdb.rst:574
#, fuzzy
msgid ""
"As an example, here are two useful aliases (especially when placed in the :"
"file:`.pdbrc` file)::"
msgstr "例如，這裡有兩個有用的別名（尤其是放在 :file:`.pdbrc` 文件中時）："

#: ../../library/pdb.rst:584
#, fuzzy
msgid "Delete the specified alias *name*."
msgstr "刪除指定的別名 *name*。"

#: ../../library/pdb.rst:588
#, fuzzy
msgid ""
"Execute the (one-line) *statement* in the context of the current stack "
"frame. The exclamation point can be omitted unless the first word of the "
"statement resembles a debugger command.  To set a global variable, you can "
"prefix the assignment command with a :keyword:`global` statement on the same "
"line, e.g.::"
msgstr ""
"在當前堆疊幀的上下文中執行（單行）*語句*。感嘆號可以省略，除非語句的第一個詞"
"類似於除錯器命令。要設定全局變數，您可以在同一行的賦值命令前加上 "
":keyword:`global` 語句，例如："

#: ../../library/pdb.rst:600
#, fuzzy
msgid ""
"Restart the debugged Python program.  If *args* is supplied, it is split "
"with :mod:`shlex` and the result is used as the new :data:`sys.argv`. "
"History, breakpoints, actions and debugger options are preserved. :pdbcmd:"
"`restart` is an alias for :pdbcmd:`run`."
msgstr ""
"重啟除錯好的Python程式。如果提供了 *args*，它將與 :mod:`shlex` 分開，"
"結果用作新的 :data:`sys.argv`。歷史記錄、斷點、操作和除錯器選項都被保留下來。"
" :pdbcmd:`restart` 是 :pdbcmd:`run` 的別名。"

#: ../../library/pdb.rst:607
#, fuzzy
msgid "Quit from the debugger.  The program being executed is aborted."
msgstr "退出除錯器。正在執行的程式被中止。"

#: ../../library/pdb.rst:611
#, fuzzy
msgid ""
"Enter a recursive debugger that steps through *code* (which is an arbitrary "
"expression or statement to be executed in the current environment)."
msgstr "輸入遞迴除錯器，逐步執行 *code*（這是要在當前環境中執行的任意表達式或語句）。"

#: ../../library/pdb.rst:617
#, fuzzy
msgid "Print the return value for the last return of the current function."
msgstr "印出當前函式最後一次回傳的回傳值。"

#: ../../library/pdb.rst:620
msgid "Footnotes"
msgstr "註解"

#: ../../library/pdb.rst:621
#, fuzzy
msgid ""
"Whether a frame is considered to originate in a certain module is determined "
"by the ``__name__`` in the frame globals."
msgstr "一個框架是否被認為起源於某個模組是由框架全局變數中的“__name__”決定的。"
