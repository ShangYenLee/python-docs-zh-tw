# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-09 00:17+0000\n"
"PO-Revision-Date: 2018-05-23 16:16+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/zipapp.rst:2
#, fuzzy
msgid ":mod:`zipapp` --- Manage executable Python zip archives"
msgstr ":mod:`zipapp` --- 管理可執行的 Python zip 檔案"

#: ../../library/zipapp.rst:9
msgid "**Source code:** :source:`Lib/zipapp.py`"
msgstr "**原始碼：**\\ :source:`Lib/zipapp.py`"

#: ../../library/zipapp.rst:16
#, fuzzy
msgid ""
"This module provides tools to manage the creation of zip files containing "
"Python code, which can be  :ref:`executed directly by the Python interpreter "
"<using-on-interface-options>`.  The module provides both a :ref:`zipapp-"
"command-line-interface` and a :ref:`zipapp-python-api`."
msgstr ""
"此模組提供工具來管理包含 Python 程式碼的 zip 文件的建立，這些程式碼可以 "
":ref:`由 Python 直譯器 <using-on-interface-options>` 直接執行。"
"該模組同時提供 :ref:`zipapp-command-line-interface` 和 :ref:`zipapp-python-"
"api`。"

#: ../../library/zipapp.rst:23
msgid "Basic Example"
msgstr "基本範例"

#: ../../library/zipapp.rst:25
#, fuzzy
msgid ""
"The following example shows how the :ref:`zipapp-command-line-interface` can "
"be used to create an executable archive from a directory containing Python "
"code.  When run, the archive will execute the ``main`` function from the "
"module ``myapp`` in the archive."
msgstr ""
"以下示例顯示瞭如何使用 :ref:`zipapp-command-line-interface` 從包含 Python 程"
"式碼的目錄建立可執行存檔。運行時，存檔將執行存檔中模組 ``myapp``中的 ``main``函式。"

#: ../../library/zipapp.rst:40
msgid "Command-Line Interface"
msgstr "命令執行列介面"

#: ../../library/zipapp.rst:42
#, fuzzy
msgid ""
"When called as a program from the command line, the following form is used:"
msgstr "當從命令列作為程式呼叫時，使用以下形式："

#: ../../library/zipapp.rst:48
#, fuzzy
msgid ""
"If *source* is a directory, this will create an archive from the contents of "
"*source*.  If *source* is a file, it should be an archive, and it will be "
"copied to the target archive (or the contents of its shebang line will be "
"displayed if the --info option is specified)."
msgstr ""
"如果 *source* 是一個目錄，這將從 *source* 的內容建立一個存檔。如果 *source* "
"是一個文件，它應該是一個存檔，它將被複製到目標存檔（或者如果指定了 --info "
"選項，將顯示其 shebang 行的內容）。"

#: ../../library/zipapp.rst:53
#, fuzzy
msgid "The following options are understood:"
msgstr "理解以下選項："

#: ../../library/zipapp.rst:59
#, fuzzy
msgid ""
"Write the output to a file named *output*.  If this option is not specified, "
"the output filename will be the same as the input *source*, with the "
"extension ``.pyz`` added.  If an explicit filename is given, it is used as "
"is (so a ``.pyz`` extension should be included if required)."
msgstr ""
"將輸出寫入名為 *output* 的文件。如果未指定此選項，則輸出文件名將與輸入 "
"*source* 相同，並新增擴充名 ``."
"pyz``。如果給出了明確的文件名，則按原樣使用（因此如果需要，應包括 ``.pyz`` "
"擴充名）。"

#: ../../library/zipapp.rst:64
#, fuzzy
msgid ""
"An output filename must be specified if the *source* is an archive (and in "
"that case, *output* must not be the same as *source*)."
msgstr "如果 *source* 是存檔，則必須指定輸出文件名（在這種情況下，*output* 不得與 "
"*source* 相同）。"

#: ../../library/zipapp.rst:69
#, fuzzy
msgid ""
"Add a ``#!`` line to the archive specifying *interpreter* as the command to "
"run.  Also, on POSIX, make the archive executable.  The default is to write "
"no ``#!`` line, and not make the file executable."
msgstr ""
"新增一個 ``#!`` 行到指定 *interpreter* 作為要運行的命令的存檔。此外，在 "
"POSIX 上，使存檔可執行。預設是不寫 ``#!`` 行，並且不使文件可執行。"

#: ../../library/zipapp.rst:75
#, fuzzy
msgid ""
"Write a ``__main__.py`` file to the archive that executes *mainfn*.  The "
"*mainfn* argument should have the form \"pkg.mod:fn\", where \"pkg.mod\" is "
"a package/module in the archive, and \"fn\" is a callable in the given "
"module. The ``__main__.py`` file will execute that callable."
msgstr ""
"將 ``__main__.py`` 文件寫入執行 *mainfn* 的存檔。 *mainfn* 參數應採用“pkg."
"mod:fn”形式，其中“pkg.mod”是存檔中的包/模組， ``fn``是給定模組中的可呼叫項。 "
"``__main__.py`` 文件將執行該可呼叫文件。"

#: ../../library/zipapp.rst:80
#, fuzzy
msgid ":option:`--main` cannot be specified when copying an archive."
msgstr ":option:`--main` 複製存檔時不能指定。"

#: ../../library/zipapp.rst:84
#, fuzzy
msgid ""
"Compress files with the deflate method, reducing the size of the output "
"file. By default, files are stored uncompressed in the archive."
msgstr "使用 deflate 方法壓縮文件，減少輸出文件的大小。預設情況下，文件以未壓縮的形式"
"儲存在存檔中。"

#: ../../library/zipapp.rst:87
#, fuzzy
msgid ":option:`--compress` has no effect when copying an archive."
msgstr ":option:`--compress` 在復制存檔時無效。"

#: ../../library/zipapp.rst:93
#, fuzzy
msgid ""
"Display the interpreter embedded in the archive, for diagnostic purposes.  "
"In this case, any other options are ignored and SOURCE must be an archive, "
"not a directory."
msgstr "顯示存檔中嵌入的直譯器，用於診斷目的。在這種情況下，將忽略任何其他選項，並且 "
"SOURCE 必須是存檔，而不是目錄。"

#: ../../library/zipapp.rst:99
#, fuzzy
msgid "Print a short usage message and exit."
msgstr "印出一條簡短的使用資訊並退出。"

#: ../../library/zipapp.rst:105
#, fuzzy
msgid "Python API"
msgstr "Python API"

#: ../../library/zipapp.rst:107
#, fuzzy
msgid "The module defines two convenience functions:"
msgstr "該模組定義了兩個方便的功能："

#: ../../library/zipapp.rst:112
#, fuzzy
msgid ""
"Create an application archive from *source*.  The source can be any of the "
"following:"
msgstr "從 *source* 建立一個應用程式存檔。來源可以是以下任何一項："

#: ../../library/zipapp.rst:115
#, fuzzy
msgid ""
"The name of a directory, or a :term:`path-like object` referring to a "
"directory, in which case a new application archive will be created from the "
"content of that directory."
msgstr "目錄的名稱，或引用目錄的類似路徑的物件，在這種情況下，將從該目錄的內容建立一"
"個新的應用程式存檔。"

#: ../../library/zipapp.rst:118
#, fuzzy
msgid ""
"The name of an existing application archive file, or a :term:`path-like "
"object` referring to such a file, in which case the file is copied to the "
"target (modifying it to reflect the value given for the *interpreter* "
"argument).  The file name should include the ``.pyz`` extension, if required."
msgstr ""
"現有應用程式存檔文件的名稱，或引用此類文件的類似路徑的物件，在這種情況下，文"
"件將復製到目標（修改它以反映為 *interpreter* 參數提供的值)."
"如果需要，文件名應包含“.pyz”擴充名。"

#: ../../library/zipapp.rst:122
#, fuzzy
msgid ""
"A file object open for reading in bytes mode.  The content of the file "
"should be an application archive, and the file object is assumed to be "
"positioned at the start of the archive."
msgstr "以位元組模式打開以供讀取的文件物件。文件的內容應該是一個應用程式存檔，文件物"
"件假定位於存檔的開頭。"

#: ../../library/zipapp.rst:126
#, fuzzy
msgid ""
"The *target* argument determines where the resulting archive will be written:"
msgstr "*target* 參數確定生成的存檔將被寫入的位置："

#: ../../library/zipapp.rst:129
#, fuzzy
msgid ""
"If it is the name of a file, or a :term:`path-like object`, the archive will "
"be written to that file."
msgstr "如果它是一個文件的名稱，或者一個 :term:`path-like "
"object`，存檔將被寫入該文件。"

#: ../../library/zipapp.rst:131
#, fuzzy
msgid ""
"If it is an open file object, the archive will be written to that file "
"object, which must be open for writing in bytes mode."
msgstr "如果它是一個打開的文件物件，則存檔將寫入該文件物件，該文件物件必須以位元組模"
"式打開才能寫入。"

#: ../../library/zipapp.rst:133
#, fuzzy
msgid ""
"If the target is omitted (or ``None``), the source must be a directory and "
"the target will be a file with the same name as the source, with a ``.pyz`` "
"extension added."
msgstr "如果省略目標（或 ``None`` ），則源必須是一個目錄，目標將是一個與源同名的文件，並新"
"增“.pyz”擴充名。"

#: ../../library/zipapp.rst:137
#, fuzzy
msgid ""
"The *interpreter* argument specifies the name of the Python interpreter with "
"which the archive will be executed.  It is written as a \"shebang\" line at "
"the start of the archive.  On POSIX, this will be interpreted by the OS, and "
"on Windows it will be handled by the Python launcher.  Omitting the "
"*interpreter* results in no shebang line being written.  If an interpreter "
"is specified, and the target is a filename, the executable bit of the target "
"file will be set."
msgstr ""
"*interpreter* 參數指定將執行存檔的 Python "
"直譯器的名稱。它在存檔的開頭寫為 ``shebang`` 行。在 POSIX "
"上，這將由操作系統解釋，而在 Windows 上，它將由 Python 啟動器處理。省略 "
"*interpreter* 會導致不寫入任何 shebang "
"行。如果指定了直譯器，並且目標是文件名，則將設定目標文件的可執行位。"

#: ../../library/zipapp.rst:145
#, fuzzy
msgid ""
"The *main* argument specifies the name of a callable which will be used as "
"the main program for the archive.  It can only be specified if the source is "
"a directory, and the source does not already contain a ``__main__.py`` "
"file.  The *main* argument should take the form \"pkg.module:callable\" and "
"the archive will be run by importing \"pkg.module\" and executing the given "
"callable with no arguments.  It is an error to omit *main* if the source is "
"a directory and does not contain a ``__main__.py`` file, as otherwise the "
"resulting archive would not be executable."
msgstr ""
"*main* 參數指定將用作存檔主程式的可呼叫文件的名稱。只有當源是一個目錄，"
"並且源不包含 ``__main__.py`` 文件時才可以指定。 *main* 參數應採用“pkg."
"module:callable”形式，存檔將通過導入“pkg."
"module”並執行不帶參數的給定可呼叫文件來運行。如果源是目錄且不包含 ``__main__."
"py`` 文件，則省略 *main* 是錯誤的，否則生成的存檔將不可執行。"

#: ../../library/zipapp.rst:155
#, fuzzy
msgid ""
"The optional *filter* argument specifies a callback function that is passed "
"a Path object representing the path to the file being added (relative to the "
"source directory).  It should return ``True`` if the file is to be added."
msgstr ""
"可選的 *filter* 參數指定一個回呼函式，該函式傳遞一個 Path "
"物件，表示要新增的文件的路徑（相對於源目錄）。如果要新增文件，它應該回傳 "
"``True``。"

#: ../../library/zipapp.rst:160
#, fuzzy
msgid ""
"The optional *compressed* argument determines whether files are compressed.  "
"If set to ``True``, files in the archive are compressed with the deflate "
"method; otherwise, files are stored uncompressed. This argument has no "
"effect when copying an existing archive."
msgstr ""
"可選的 *compressed* 參數確定文件是否被壓縮。如果設定為 ``True``，"
"存檔中的文件將使用 deflate "
"方法壓縮；否則，文件將以未壓縮的形式儲存。複製現有存檔時，此參數無效。"

#: ../../library/zipapp.rst:165
#, fuzzy
msgid ""
"If a file object is specified for *source* or *target*, it is the caller's "
"responsibility to close it after calling create_archive."
msgstr "如果為 *source* 或 *target* 指定了文件物件，呼叫者有責任在呼叫 "
"create_archive 後關閉它。"

#: ../../library/zipapp.rst:168
#, fuzzy
msgid ""
"When copying an existing archive, file objects supplied only need ``read`` "
"and ``readline``, or ``write`` methods.  When creating an archive from a "
"directory, if the target is a file object it will be passed to the ``zipfile."
"ZipFile`` class, and must supply the methods needed by that class."
msgstr ""
"複製現有存檔時，提供的文件對像只需要 ``read`` 和 ``readline`` 或 ``write`` "
"方法。從目錄建立存檔時，如果目標是文件物件，它將被傳遞給 ``zipfile.ZipFile`` "
"類，並且必須提供該類所需的方法。"

#: ../../library/zipapp.rst:174
msgid "Added the *filter* and *compressed* arguments."
msgstr "新增 *filter* 與 *compressed* 引數。"

#: ../../library/zipapp.rst:179
#, fuzzy
msgid ""
"Return the interpreter specified in the ``#!`` line at the start of the "
"archive.  If there is no ``#!`` line, return :const:`None`. The *archive* "
"argument can be a filename or a file-like object open for reading in bytes "
"mode.  It is assumed to be at the start of the archive."
msgstr ""
"回傳存檔開頭的 ``#!`` 行中指定的直譯器。如果沒有 ``#!`` 行，回傳 "
":const:`None`。 *archive* 參數可以是文件名或以位元組模式打開以供讀取的類文件"
"物件。假定它位於存檔的開頭。"

#: ../../library/zipapp.rst:188
msgid "Examples"
msgstr "範例"

#: ../../library/zipapp.rst:190
#, fuzzy
msgid "Pack up a directory into an archive, and run it."
msgstr "將目錄打包到存檔中，然後運行它。"

#: ../../library/zipapp.rst:198
#, fuzzy
msgid "The same can be done using the :func:`create_archive` function::"
msgstr "使用 :func:`create_archive` 函式也可以完成同樣的操作："

#: ../../library/zipapp.rst:203
#, fuzzy
msgid ""
"To make the application directly executable on POSIX, specify an interpreter "
"to use."
msgstr "要使應用程式在 POSIX 上直接可執行，請指定要使用的直譯器。"

#: ../../library/zipapp.rst:212
#, fuzzy
msgid ""
"To replace the shebang line on an existing archive, create a modified "
"archive using the :func:`create_archive` function::"
msgstr "要替換現有存檔中的 shebang 行，請使用 create_archive 函式建立修改後的存檔："

#: ../../library/zipapp.rst:218
#, fuzzy
msgid ""
"To update the file in place, do the replacement in memory using a :class:"
"`~io.BytesIO` object, and then overwrite the source afterwards.  Note that "
"there is a risk when overwriting a file in place that an error will result "
"in the loss of the original file.  This code does not protect against such "
"errors, but production code should do so.  Also, this method will only work "
"if the archive fits in memory::"
msgstr ""
"要就地更新文件，使用 :class:`~io.BytesIO` 對像在記憶體中進行替換，然後覆蓋源"
"文件。請注意，在原地覆蓋文件時存在錯誤會導致原始文件丟失的風險。此程式碼不能"
"防止此類錯誤，但生產程式碼應該這樣做。此外，此方法僅在存檔適合記憶體時才有效:"
":"

#: ../../library/zipapp.rst:236
#, fuzzy
msgid "Specifying the Interpreter"
msgstr "指定直譯器"

#: ../../library/zipapp.rst:238
#, fuzzy
msgid ""
"Note that if you specify an interpreter and then distribute your application "
"archive, you need to ensure that the interpreter used is portable.  The "
"Python launcher for Windows supports most common forms of POSIX ``#!`` line, "
"but there are other issues to consider:"
msgstr ""
"請注意，如果您指定一個直譯器然後分發您的應用程式存檔，您需要確保所使用的直譯"
"器是可移植的。適用於 Windows 的 Python 啟動器支援大多數常見形式的 POSIX "
"``#!`` 行，但還有其他問題需要考慮："

#: ../../library/zipapp.rst:243
#, fuzzy
msgid ""
"If you use \"/usr/bin/env python\" (or other forms of the \"python\" "
"command, such as \"/usr/bin/python\"), you need to consider that your users "
"may have either Python 2 or Python 3 as their default, and write your code "
"to work under both versions."
msgstr ""
"如果您使用“/usr/bin/env python”（或其他形式的 ``python``命令，例如“/usr/bin/"
"python”），您需要考慮您的使用者可能擁有 Python 2 或 Python "
"3作為他們的預設值，並編寫程式碼以在兩個版本下工作。"

#: ../../library/zipapp.rst:247
#, fuzzy
msgid ""
"If you use an explicit version, for example \"/usr/bin/env python3\" your "
"application will not work for users who do not have that version.  (This may "
"be what you want if you have not made your code Python 2 compatible)."
msgstr ""
"如果您使用顯式版本，例如“/usr/bin/env "
"python3”，您的應用程式將無法為沒有該版本的使用者工作。 （"
"如果您的程式碼沒有與 Python 2 相容，這可能就是您想要的）。"

#: ../../library/zipapp.rst:250
#, fuzzy
msgid ""
"There is no way to say \"python X.Y or later\", so be careful of using an "
"exact version like \"/usr/bin/env python3.4\" as you will need to change "
"your shebang line for users of Python 3.5, for example."
msgstr ""
"沒有辦法說“python X.Y 或更高版本”，因此請小心使用像“/usr/bin/env python3."
"4”這樣的確切版本，因為您需要為 Python 3.5 的使用者更改 shebang 行，例如."

#: ../../library/zipapp.rst:254
#, fuzzy
msgid ""
"Typically, you should use an \"/usr/bin/env python2\" or \"/usr/bin/env "
"python3\", depending on whether your code is written for Python 2 or 3."
msgstr ""
"通常，您應該使用“/usr/bin/env python2”或“/usr/bin/env python3”，"
"具體取決於您的程式碼是為 Python 2 還是 3 編寫的。"

#: ../../library/zipapp.rst:259
#, fuzzy
msgid "Creating Standalone Applications with zipapp"
msgstr "使用 zipapp 建立獨立應用程式"

#: ../../library/zipapp.rst:261
#, fuzzy
msgid ""
"Using the :mod:`zipapp` module, it is possible to create self-contained "
"Python programs, which can be distributed to end users who only need to have "
"a suitable version of Python installed on their system.  The key to doing "
"this is to bundle all of the application's dependencies into the archive, "
"along with the application code."
msgstr ""
"使用 :mod:`zipapp` 模組，可以建立獨立的 Python 程式，"
"這些程式可以分發給只需要在系統上安裝合適版本的 Python 的最終使用者。這樣做的"
"關鍵是將應用程式的所有依賴項連同應用程式程式碼捆綁到存檔中。"

#: ../../library/zipapp.rst:267
#, fuzzy
msgid "The steps to create a standalone archive are as follows:"
msgstr "建立獨立存檔的步驟如下："

#: ../../library/zipapp.rst:269
#, fuzzy
msgid ""
"Create your application in a directory as normal, so you have a ``myapp`` "
"directory containing a ``__main__.py`` file, and any supporting application "
"code."
msgstr ""
"像往常一樣在一個目錄中建立您的應用程式，因此您有一個 ``myapp`` 目錄，"
"其中包含一個 ``__main__.py`` 文件和任何支援的應用程式程式碼。"

#: ../../library/zipapp.rst:273
#, fuzzy
msgid ""
"Install all of your application's dependencies into the ``myapp`` directory, "
"using pip:"
msgstr "使用 pip 將應用程式的所有依賴項安裝到 ``myapp`` 目錄中："

#: ../../library/zipapp.rst:280
#, fuzzy
msgid ""
"(this assumes you have your project requirements in a ``requirements.txt`` "
"file - if not, you can just list the dependencies manually on the pip "
"command line)."
msgstr "（這假設您在 ``requirements.txt`` 文件中有您的項目需求——如果沒有，您可以在 "
"pip 命令列上手動列出依賴項）。"

#: ../../library/zipapp.rst:284
#, fuzzy
msgid ""
"Optionally, delete the ``.dist-info`` directories created by pip in the "
"``myapp`` directory. These hold metadata for pip to manage the packages, and "
"as you won't be making any further use of pip they aren't required - "
"although it won't do any harm if you leave them."
msgstr ""
"（可選）刪除由 pip 在 ``myapp`` 目錄中建立的 ``.dist-info`` 目錄。這些保存 "
"pip 的元資料來管理包，並且由於您不會進一步使用 pip，因此不需要它們 - "
"儘管如果您離開它們不會造成任何傷害。"

#: ../../library/zipapp.rst:289
#, fuzzy
msgid "Package the application using:"
msgstr "使用以下方式打包應用程式："

#: ../../library/zipapp.rst:295
#, fuzzy
msgid ""
"This will produce a standalone executable, which can be run on any machine "
"with the appropriate interpreter available. See :ref:`zipapp-specifying-the-"
"interpreter` for details. It can be shipped to users as a single file."
msgstr ""
"這將生成一個獨立的可執行文件，它可以在任何具有可用的適當直譯器的機器上運行。"
"有關詳細資訊，請參閱 :ref:`zipapp-specifying-the-"
"interpreter`。它可以作為單個文件發送給使用者。"

#: ../../library/zipapp.rst:299
#, fuzzy
msgid ""
"On Unix, the ``myapp.pyz`` file is executable as it stands.  You can rename "
"the file to remove the ``.pyz`` extension if you prefer a \"plain\" command "
"name.  On Windows, the ``myapp.pyz[w]`` file is executable by virtue of the "
"fact that the Python interpreter registers the ``.pyz`` and ``.pyzw`` file "
"extensions when installed."
msgstr ""
"在 Unix 上，``myapp.pyz`` 文件是可執行的。如果您更喜歡“普通”命令名稱，"
"則可以重命名該文件以刪除 ``.pyz`` 擴充名。在 Windows 上，``myapp.pyz[w]`` "
"文件是可執行的，因為 Python 直譯器在安裝時註冊了``.pyz`` 和``.pyzw`` "
"文件擴充名。"

#: ../../library/zipapp.rst:307
#, fuzzy
msgid "Making a Windows executable"
msgstr "製作 Windows 可執行文件"

#: ../../library/zipapp.rst:309
#, fuzzy
msgid ""
"On Windows, registration of the ``.pyz`` extension is optional, and "
"furthermore, there are certain places that don't recognise registered "
"extensions \"transparently\" (the simplest example is that ``subprocess."
"run(['myapp'])`` won't find your application - you need to explicitly "
"specify the extension)."
msgstr ""
"在 Windows 上，``.pyz`` "
"擴充名的註冊是可選的，此外，有些地方不能“透明地”識別已註冊的擴充名（"
"最簡單的例子是 ``subprocess.run(['myapp'] )`` 找不到您的應用程式 - "
"您需要明確指定擴充名）。"

#: ../../library/zipapp.rst:315
#, fuzzy
msgid ""
"On Windows, therefore, it is often preferable to create an executable from "
"the zipapp.  This is relatively easy, although it does require a C "
"compiler.  The basic approach relies on the fact that zipfiles can have "
"arbitrary data prepended, and Windows exe files can have arbitrary data "
"appended.  So by creating a suitable launcher and tacking the ``.pyz`` file "
"onto the end of it, you end up with a single-file executable that runs your "
"application."
msgstr ""
"因此，在 Windows 上，通常最好從 zipapp 建立可執行文件。這相對容易，"
"儘管它確實需要 C 編譯器。基本方法依賴於這樣一個事實，即 zipfiles "
"可以預先新增任意資料，Windows exe 文件可以附加任意資料。因此，"
"通過建立一個合適的啟動器並將 ``.pyz`` "
"文件附加到它的末尾，您最終會得到一個運行您的應用程式的單文件可執行文件。"

#: ../../library/zipapp.rst:322
#, fuzzy
msgid "A suitable launcher can be as simple as the following::"
msgstr "合適的啟動器可以像下面這樣簡單："

#: ../../library/zipapp.rst:347
#, fuzzy
msgid ""
"If you define the ``WINDOWS`` preprocessor symbol, this will generate a GUI "
"executable, and without it, a console executable."
msgstr "如果您定義 ``WINDOWS`` 預處理器符號，這將生成一個 GUI "
"可執行文件，如果沒有它，將生成一個控制台可執行文件。"

#: ../../library/zipapp.rst:350
#, fuzzy
msgid ""
"To compile the executable, you can either just use the standard MSVC command "
"line tools, or you can take advantage of the fact that distutils knows how "
"to compile Python source::"
msgstr "要編譯可執行文件，您可以只使用標準的 MSVC 命令列工具，也可以利用 distutils "
"知道如何編譯 Python 源程式碼這一事實："

#: ../../library/zipapp.rst:377
#, fuzzy
msgid ""
"The resulting launcher uses the \"Limited ABI\", so it will run unchanged "
"with any version of Python 3.x.  All it needs is for Python (``python3."
"dll``) to be on the user's ``PATH``."
msgstr ""
"生成的啟動器使用“受限 ABI”，因此它可以在任何版本的 Python 3.x "
"上不加改變地運行。它所需要的只是讓 Python (``python3.dll``) "
"位於使用者的``PATH`` 中。"

#: ../../library/zipapp.rst:381
#, fuzzy
msgid ""
"For a fully standalone distribution, you can distribute the launcher with "
"your application appended, bundled with the Python \"embedded\" "
"distribution.  This will run on any PC with the appropriate architecture (32 "
"bit or 64 bit)."
msgstr ""
"對於完全獨立的分發版，您可以分髮帶有附加應用程式的啟動器，並與 "
"Python“嵌入式”分發版捆綁在一起。這將在具有適當架構（32 位或 64 位）的任何 PC "
"上運行。"

#: ../../library/zipapp.rst:387
#, fuzzy
msgid "Caveats"
msgstr "注意事項"

#: ../../library/zipapp.rst:389
#, fuzzy
msgid ""
"There are some limitations to the process of bundling your application into "
"a single file.  In most, if not all, cases they can be addressed without "
"needing major changes to your application."
msgstr "將應用程式捆綁到單個文件的過程有一些限制。在大多數（如果不是全部）情況下，無"
"需對您的應用程式進行重大更改即可解決這些問題。"

#: ../../library/zipapp.rst:393
#, fuzzy
msgid ""
"If your application depends on a package that includes a C extension, that "
"package cannot be run from a zip file (this is an OS limitation, as "
"executable code must be present in the filesystem for the OS loader to load "
"it). In this case, you can exclude that dependency from the zipfile, and "
"either require your users to have it installed, or ship it alongside your "
"zipfile and add code to your ``__main__.py`` to include the directory "
"containing the unzipped module in ``sys.path``. In this case, you will need "
"to make sure to ship appropriate binaries for your target architecture(s) "
"(and potentially pick the correct version to add to ``sys.path`` at runtime, "
"based on the user's machine)."
msgstr ""
"如果您的應用程式依賴於包含 C 擴充的包，則無法從 zip 文件運行該包（這是操作系"
"統限制，因為可執行程式碼必須存在於文件系統中，操作系統加載程式才能加載它）。"
"在這種情況下，您可以從 zip 文件中排除該依賴項，並要求您的使用者安裝它，"
"或者將它與您的 zip 文件一起發送並將程式碼新增到您的 ``__main__.py`` 以包含包"
"含解壓縮模組的目錄``系統路徑``。在這種情況下，您將需要確保為您的目標架構提供"
"適當的二進位文件（並可能根據使用者的機器選擇正確的版本在運行時新增到“sys."
"path”）。"

#: ../../library/zipapp.rst:403
#, fuzzy
msgid ""
"If you are shipping a Windows executable as described above, you either need "
"to ensure that your users have ``python3.dll`` on their PATH (which is not "
"the default behaviour of the installer) or you should bundle your "
"application with the embedded distribution."
msgstr ""
"如果您按上述方式發布 Windows 可執行文件，您要么需要確保您的使用者在他們的 "
"PATH 中有“python3."
"dll”（這不是安裝程式的預設行為），要么您應該將您的應用程式與嵌入式分配。"

#: ../../library/zipapp.rst:408
#, fuzzy
msgid ""
"The suggested launcher above uses the Python embedding API.  This means that "
"in your application, ``sys.executable`` will be your application, and *not* "
"a conventional Python interpreter.  Your code and its dependencies need to "
"be prepared for this possibility.  For example, if your application uses "
"the :mod:`multiprocessing` module, it will need to call :func:"
"`multiprocessing.set_executable` to let the module know where to find the "
"standard Python interpreter."
msgstr ""
"上面建議的啟動器使用 Python 嵌入 API。這意味著在您的應用程式中，``sys."
"executable`` 將是您的應用程式，*不是*傳統的 Python "
"直譯器。您的程式碼及其依賴項需要為這種可能性做好準備。例如，"
"如果您的應用程式使用 :mod:`multiprocessing` 模組，則需要呼叫 "
":func:`multiprocessing.set_executable` 讓模組知道在哪裡可以找到標準的 Python "
"直譯器。"

#: ../../library/zipapp.rst:418
#, fuzzy
msgid "The Python Zip Application Archive Format"
msgstr "Python Zip 應用程式存檔格式"

#: ../../library/zipapp.rst:420
#, fuzzy
msgid ""
"Python has been able to execute zip files which contain a ``__main__.py`` "
"file since version 2.6.  In order to be executed by Python, an application "
"archive simply has to be a standard zip file containing a ``__main__.py`` "
"file which will be run as the entry point for the application.  As usual for "
"any Python script, the parent of the script (in this case the zip file) will "
"be placed on :data:`sys.path` and thus further modules can be imported from "
"the zip file."
msgstr ""
"自 2.6 版以來，Python 已經能夠執行包含 ``__main__.py`` 文件的 zip 文件。"
"為了由 Python 執行，應用程式存檔只需是一個標準的 zip 文件，其中包含一個 "
"``__main__.py`` 文件，該文件將作為應用程式的入口點運行。與任何 Python "
"腳本一樣，腳本的父級（在本例中為 zip 文件）將放置在 :data:`sys.path` 中，"
"因此可以從 zip 文件中導入更多模組。"

#: ../../library/zipapp.rst:427
#, fuzzy
msgid ""
"The zip file format allows arbitrary data to be prepended to a zip file.  "
"The zip application format uses this ability to prepend a standard POSIX "
"\"shebang\" line to the file (``#!/path/to/interpreter``)."
msgstr ""
"zip 文件格式允許將任意資料新增到 zip 文件中。 zip "
"應用程式格式使用此功能將標準 POSIX ``shebang`` 行新增到文件 (``#!/path/to/"
"interpreter``)。"

#: ../../library/zipapp.rst:431
#, fuzzy
msgid "Formally, the Python zip application format is therefore:"
msgstr "因此，正式地，Python zip 應用程式格式是："

#: ../../library/zipapp.rst:433
#, fuzzy
msgid ""
"An optional shebang line, containing the characters ``b'#!'`` followed by an "
"interpreter name, and then a newline (``b'\\n'``) character.  The "
"interpreter name can be anything acceptable to the OS \"shebang\" "
"processing, or the Python launcher on Windows.  The interpreter should be "
"encoded in UTF-8 on Windows, and in :func:`sys.getfilesystemencoding()` on "
"POSIX."
msgstr ""
"可選的 shebang 行，包含字元 ``b'#!'`` 後跟直譯器名稱，然後是換行符（``b'\\n"
"'``）。直譯器名稱可以是操作系統 ``shebang`` 處理或 Windows 上的 Python "
"啟動器可接受的任何名稱。直譯器應該在 Windows 上以 UTF-8 編碼，在 POSIX 上以 "
":func:`sys.getfilesystemencoding()` 編碼。"

#: ../../library/zipapp.rst:438
#, fuzzy
msgid ""
"Standard zipfile data, as generated by the :mod:`zipfile` module.  The "
"zipfile content *must* include a file called ``__main__.py`` (which must be "
"in the \"root\" of the zipfile - i.e., it cannot be in a subdirectory).  The "
"zipfile data can be compressed or uncompressed."
msgstr ""
"標準壓縮文件資料，由 :mod:`zipfile` 模組生成。 zip 文件內容*必須*"
"包括一個名為 ``__main__.py`` 的文件（它必須位於 zip "
"文件的“根目錄”中——即，它不能位於子目錄中）。 zipfile 資料可以被壓縮或解壓縮。"

#: ../../library/zipapp.rst:443
#, fuzzy
msgid ""
"If an application archive has a shebang line, it may have the executable bit "
"set on POSIX systems, to allow it to be executed directly."
msgstr "如果一個應用程式存檔有一個 shebang 行，它可能在 POSIX "
"系統上設定了可執行位，以允許它直接執行。"

#: ../../library/zipapp.rst:446
#, fuzzy
msgid ""
"There is no requirement that the tools in this module are used to create "
"application archives - the module is a convenience, but archives in the "
"above format created by any means are acceptable to Python."
msgstr "不要求使用此模組中的工具來建立應用程式存檔 - 該模組很方便，但 Python "
"可以接受以任何方式建立的上述格式的存檔。"
