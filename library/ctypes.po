# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-26 04:11+0800\n"
"PO-Revision-Date: 2023-04-26 02:59+0800\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../library/ctypes.rst:2
msgid ":mod:`ctypes` --- A foreign function library for Python"
msgstr ":mod:`ctypes` --- Python 的外部函式庫"

#: ../../library/ctypes.rst:9
msgid "**Source code:** :source:`Lib/ctypes`"
msgstr "**原始碼：**\\ :source:`Lib/ctypes`"

#: ../../library/ctypes.rst:13
#, fuzzy
msgid ""
":mod:`ctypes` is a foreign function library for Python.  It provides C "
"compatible data types, and allows calling functions in DLLs or shared "
"libraries.  It can be used to wrap these libraries in pure Python."
msgstr ""
":mod:`ctypes` 是 Python 的外部函式庫。它提供與 C 相容的資料型別，並允許呼叫 "
"DLL 或共享庫中的函式。它可用於將這些庫包裝在純 Python 中。"

#: ../../library/ctypes.rst:21
#, fuzzy
msgid "ctypes tutorial"
msgstr "ctypes教程"

#: ../../library/ctypes.rst:23
#, fuzzy
msgid ""
"Note: The code samples in this tutorial use :mod:`doctest` to make sure that "
"they actually work.  Since some code samples behave differently under Linux, "
"Windows, or macOS, they contain doctest directives in comments."
msgstr ""
"注意：本教程中的程式碼示例使用 :mod:`doctest` 來確保它們確實有效。由於某些程"
"式碼示例在 Linux、Windows 或 macOS 下的行為不同，因此它們在註釋中包含 "
"doctest 指令。"

#: ../../library/ctypes.rst:27
#, fuzzy
msgid ""
"Note: Some code samples reference the ctypes :class:`c_int` type.  On "
"platforms where ``sizeof(long) == sizeof(int)`` it is an alias to :class:"
"`c_long`. So, you should not be confused if :class:`c_long` is printed if "
"you would expect :class:`c_int` --- they are actually the same type."
msgstr ""
"注意：一些程式碼示例引用 ctypes :class:`c_int` 型別。在 ``sizeof(long) == "
"sizeof(int)`` 的平台上，它是 :class:`c_long` 的別名。所以，如果印出了 :class:"
"`c_long` 如果您期望 :class:`c_int` ，您不應該感到困惑——它們實際上是相同的型"
"別。"

#: ../../library/ctypes.rst:35
#, fuzzy
msgid "Loading dynamic link libraries"
msgstr "加載動態鏈接庫"

#: ../../library/ctypes.rst:37
#, fuzzy
msgid ""
":mod:`ctypes` exports the *cdll*, and on Windows *windll* and *oledll* "
"objects, for loading dynamic link libraries."
msgstr ""
":mod:`ctypes` 導出 *cdll*，以及 Windows 上的 *windll* 和 *oledll* 物件，用於"
"加載動態鏈接庫。"

#: ../../library/ctypes.rst:40
#, fuzzy
msgid ""
"You load libraries by accessing them as attributes of these objects. *cdll* "
"loads libraries which export functions using the standard ``cdecl`` calling "
"convention, while *windll* libraries call functions using the ``stdcall`` "
"calling convention. *oledll* also uses the ``stdcall`` calling convention, "
"and assumes the functions return a Windows :c:type:`HRESULT` error code. The "
"error code is used to automatically raise an :class:`OSError` exception when "
"the function call fails."
msgstr ""
"您通過將庫作為這些物件的屬性進行訪問來加載它們。 *cdll* 加載使用標準 ``cdecl``呼"
"叫約定導出函式的庫，而 *windll* 庫使用 ``stdcall`` 呼叫約定呼叫函式。 *oledll* 還"
"使用 ``stdcall`` 呼叫約定，並假定函式回傳 Windows:c:type:`HRESULT` 錯誤程式"
"碼。錯誤程式碼用於在函式呼叫失敗時自動引發 :class:`OSError` 例外。"

#: ../../library/ctypes.rst:48
#, fuzzy
msgid ""
"Windows errors used to raise :exc:`WindowsError`, which is now an alias of :"
"exc:`OSError`."
msgstr ""
"Windows 錯誤用於引發 :exc:`WindowsError`，現在是 :exc:`OSError` 的別名。"

#: ../../library/ctypes.rst:53
#, fuzzy
msgid ""
"Here are some examples for Windows. Note that ``msvcrt`` is the MS standard "
"C library containing most standard C functions, and uses the cdecl calling "
"convention::"
msgstr ""
"以下是 Windows 的一些示例。請注意，``msvcrt`` 是包含大多數標準 C 函式的 MS 標"
"準 C 庫，並使用 cdecl 呼叫約定："

#: ../../library/ctypes.rst:65
#, fuzzy
msgid "Windows appends the usual ``.dll`` file suffix automatically."
msgstr "Windows 會自動附加通常的 ``.dll`` 文件後綴。"

#: ../../library/ctypes.rst:68
#, fuzzy
msgid ""
"Accessing the standard C library through ``cdll.msvcrt`` will use an "
"outdated version of the library that may be incompatible with the one being "
"used by Python. Where possible, use native Python functionality, or else "
"import and use the ``msvcrt`` module."
msgstr ""
"通過 ``cdll.msvcrt`` 訪問標準 C 庫將使用該庫的過時版本，該版本可能與 Python "
"使用的版本不相容。在可能的情況下，使用本機 Python 功能，或者導入並使用 "
"``msvcrt`` 模組。"

#: ../../library/ctypes.rst:73
#, fuzzy
msgid ""
"On Linux, it is required to specify the filename *including* the extension "
"to load a library, so attribute access can not be used to load libraries. "
"Either the :meth:`LoadLibrary` method of the dll loaders should be used, or "
"you should load the library by creating an instance of CDLL by calling the "
"constructor::"
msgstr ""
"在 Linux 上，需要指定文件名*包括*擴充名才能加載庫，因此不能使用屬性訪問來加載"
"庫。應該使用 dll 加載器的 LoadLibrary 方法，或者您應該通過呼叫構造函式建立 "
"CDLL 實例來加載庫："

#: ../../library/ctypes.rst:91
#, fuzzy
msgid "Accessing functions from loaded dlls"
msgstr "從加載的 dll 訪問函式"

#: ../../library/ctypes.rst:93
#, fuzzy
msgid "Functions are accessed as attributes of dll objects::"
msgstr "函式作為 dll 物件的屬性訪問："

#: ../../library/ctypes.rst:108
#, fuzzy
msgid ""
"Note that win32 system dlls like ``kernel32`` and ``user32`` often export "
"ANSI as well as UNICODE versions of a function. The UNICODE version is "
"exported with an ``W`` appended to the name, while the ANSI version is "
"exported with an ``A`` appended to the name. The win32 ``GetModuleHandle`` "
"function, which returns a *module handle* for a given module name, has the "
"following C prototype, and a macro is used to expose one of them as "
"``GetModuleHandle`` depending on whether UNICODE is defined or not::"
msgstr ""
"請注意，像``kernel32`` 和``user32`` 這樣的win32 系統dll 通常導出函式的ANSI 和"
"UNICODE 版本。 UNICODE 版本在導出時在名稱後附加一個 ``W``，而在導出 ANSI 版本時"
"在名稱後附加一個 ``A``。 win32 ``GetModuleHandle`` 函式回傳給定模組名稱的*模組句"
"柄*，具有以下 C 原型，並且根據是否定義了 UNICODE，巨集用於將其中之一公開為 "
"``GetModuleHandle``或不：："

#: ../../library/ctypes.rst:121
#, fuzzy
msgid ""
"*windll* does not try to select one of them by magic, you must access the "
"version you need by specifying ``GetModuleHandleA`` or ``GetModuleHandleW`` "
"explicitly, and then call it with bytes or string objects respectively."
msgstr ""
"*windll* 不會嘗試通過魔法選擇其中之一，您必須通過明確指定 "
"``GetModuleHandleA`` 或 ``GetModuleHandleW`` 來訪問您需要的版本，然後分別使用"
"位元組或字串物件呼叫它。"

#: ../../library/ctypes.rst:125
#, fuzzy
msgid ""
"Sometimes, dlls export functions with names which aren't valid Python "
"identifiers, like ``\"??2@YAPAXI@Z\"``. In this case you have to use :func:"
"`getattr` to retrieve the function::"
msgstr ""
"有時，dll 導出的函式名稱不是有效的 Python 標識符，例如 ``\"??2@YAPAXI@Z\"``。"
"在這種情況下，您必須使用 :func:`getattr` 來檢索函式::"

#: ../../library/ctypes.rst:133
#, fuzzy
msgid ""
"On Windows, some dlls export functions not by name but by ordinal. These "
"functions can be accessed by indexing the dll object with the ordinal "
"number::"
msgstr ""
"在 Windows 上，一些 dll 導出函式不是按名稱而是按序號。可以通過使用序號索引 "
"dll 物件來訪問這些函式："

#: ../../library/ctypes.rst:150
#, fuzzy
msgid "Calling functions"
msgstr "呼叫函式"

#: ../../library/ctypes.rst:152
#, fuzzy
msgid ""
"You can call these functions like any other Python callable. This example "
"uses the ``time()`` function, which returns system time in seconds since the "
"Unix epoch, and the ``GetModuleHandleA()`` function, which returns a win32 "
"module handle."
msgstr ""
"您可以像呼叫任何其他 Python 可呼叫函式一樣呼叫這些函式。此示例使用 "
"``time()`` 函式，它回傳自 Unix 紀元以來的系統時間（以秒為單位），以及 "
"``GetModuleHandleA()`` 函式，它回傳一個 win32 模組句柄。"

#: ../../library/ctypes.rst:157
#, fuzzy
msgid ""
"This example calls both functions with a ``NULL`` pointer (``None`` should "
"be used as the ``NULL`` pointer)::"
msgstr "此示例使用 ``NULL`` 指標呼叫這兩個函式（ ``None``應用作 ``NULL`` 指標）："

#: ../../library/ctypes.rst:166
#, fuzzy
msgid ""
":exc:`ValueError` is raised when you call an ``stdcall`` function with the "
"``cdecl`` calling convention, or vice versa::"
msgstr ""
"當您使用 ``cdecl`` 呼叫約定呼叫 ``stdcall`` 函式時，會引發：exc:"
"`ValueError`，反之亦然::"

#: ../../library/ctypes.rst:181
#, fuzzy
msgid ""
"To find out the correct calling convention you have to look into the C "
"header file or the documentation for the function you want to call."
msgstr "要找出正確的呼叫約定，您必須查看 C 標頭檔或您要呼叫的函式的文檔。"

#: ../../library/ctypes.rst:184
#, fuzzy
msgid ""
"On Windows, :mod:`ctypes` uses win32 structured exception handling to "
"prevent crashes from general protection faults when functions are called "
"with invalid argument values::"
msgstr ""
"在 Windows 上，:mod:`ctypes` 使用 win32 結構化例外處理來防止在使用無效參數值"
"呼叫函式時因一般保護錯誤而導致崩潰："

#: ../../library/ctypes.rst:194
#, fuzzy
msgid ""
"There are, however, enough ways to crash Python with :mod:`ctypes`, so you "
"should be careful anyway.  The :mod:`faulthandler` module can be helpful in "
"debugging crashes (e.g. from segmentation faults produced by erroneous C "
"library calls)."
msgstr ""
"但是，有足夠多的方法可以使用 :mod:`ctypes` 使 Python 崩潰，因此無論如何您都應"
"該小心。 :mod:`faulthandler` 模組有助於除錯崩潰（例如，由錯誤的 C 庫呼叫產生"
"的分段錯誤）。"

#: ../../library/ctypes.rst:199
#, fuzzy
msgid ""
"``None``, integers, bytes objects and (unicode) strings are the only native "
"Python objects that can directly be used as parameters in these function "
"calls. ``None`` is passed as a C ``NULL`` pointer, bytes objects and strings "
"are passed as pointer to the memory block that contains their data (:c:expr:"
"`char *` or :c:expr:`wchar_t *`).  Python integers are passed as the "
"platforms default C :c:expr:`int` type, their value is masked to fit into "
"the C type."
msgstr ""
" ``None`` 、整數、位元組物件和 (unicode) 字串是唯一可以在這些函式呼叫中直接用作參數"
"的本機 Python 物件。 ``None`` 作為 C ``NULL`` 指標傳遞，位元組物件和字串作為"
"指向包含其資料的記憶體塊的指標傳遞（:c:expr:`char *` 或 :c:expr:` wchar_t "
"*`）。 Python 整數作為平台預設 C:c:expr:`int` 型別傳遞，它們的值被屏蔽以適合 "
"C 型別。"

#: ../../library/ctypes.rst:206
#, fuzzy
msgid ""
"Before we move on calling functions with other parameter types, we have to "
"learn more about :mod:`ctypes` data types."
msgstr ""
"在我們繼續使用其他參數型別呼叫函式之前，我們必須了解更多關於 :mod:`ctypes` 資"
"料型別的知識。"

#: ../../library/ctypes.rst:213 ../../library/ctypes.rst:2159
#, fuzzy
msgid "Fundamental data types"
msgstr "基本資料型別"

#: ../../library/ctypes.rst:215
#, fuzzy
msgid ":mod:`ctypes` defines a number of primitive C compatible data types:"
msgstr ":mod:`ctypes` 定義了一些原始的 C 相容資料型別："

#: ../../library/ctypes.rst:218
#, fuzzy
msgid "ctypes type"
msgstr "ctypes型別"

#: ../../library/ctypes.rst:218
#, fuzzy
msgid "C type"
msgstr "C型"

#: ../../library/ctypes.rst:218
#, fuzzy
msgid "Python type"
msgstr "蟒蛇型別"

#: ../../library/ctypes.rst:220
msgid ":class:`c_bool`"
msgstr ":class:`c_bool`"

#: ../../library/ctypes.rst:220
msgid ":c:expr:`_Bool`"
msgstr ":c:expr:`_Bool`"

#: ../../library/ctypes.rst:220
msgid "bool (1)"
msgstr "bool (1)"

#: ../../library/ctypes.rst:222
msgid ":class:`c_char`"
msgstr ":class:`c_char`"

#: ../../library/ctypes.rst:222 ../../library/ctypes.rst:226
msgid ":c:expr:`char`"
msgstr ":c:expr:`char`"

#: ../../library/ctypes.rst:222
#, fuzzy
msgid "1-character bytes object"
msgstr "1 個字元的位元組物件"

#: ../../library/ctypes.rst:224
msgid ":class:`c_wchar`"
msgstr ":class:`c_wchar`"

#: ../../library/ctypes.rst:224
msgid ":c:expr:`wchar_t`"
msgstr ":c:expr:`wchar_t`"

#: ../../library/ctypes.rst:224
#, fuzzy
msgid "1-character string"
msgstr "1個字元的字串"

#: ../../library/ctypes.rst:226
msgid ":class:`c_byte`"
msgstr ":class:`c_byte`"

#: ../../library/ctypes.rst:226 ../../library/ctypes.rst:228
#: ../../library/ctypes.rst:230 ../../library/ctypes.rst:232
#: ../../library/ctypes.rst:234 ../../library/ctypes.rst:236
#: ../../library/ctypes.rst:238 ../../library/ctypes.rst:240
#: ../../library/ctypes.rst:242 ../../library/ctypes.rst:244
#: ../../library/ctypes.rst:247 ../../library/ctypes.rst:249
msgid "int"
msgstr "int"

#: ../../library/ctypes.rst:228
msgid ":class:`c_ubyte`"
msgstr ":class:`c_ubyte`"

#: ../../library/ctypes.rst:228
msgid ":c:expr:`unsigned char`"
msgstr ":c:expr:`unsigned char`"

#: ../../library/ctypes.rst:230
msgid ":class:`c_short`"
msgstr ":class:`c_short`"

#: ../../library/ctypes.rst:230
msgid ":c:expr:`short`"
msgstr ":c:expr:`short`"

#: ../../library/ctypes.rst:232
msgid ":class:`c_ushort`"
msgstr ":class:`c_ushort`"

#: ../../library/ctypes.rst:232
msgid ":c:expr:`unsigned short`"
msgstr ":c:expr:`unsigned short`"

#: ../../library/ctypes.rst:234
msgid ":class:`c_int`"
msgstr ":class:`c_int`"

#: ../../library/ctypes.rst:234
msgid ":c:expr:`int`"
msgstr ":c:expr:`int`"

#: ../../library/ctypes.rst:236
msgid ":class:`c_uint`"
msgstr ":class:`c_uint`"

#: ../../library/ctypes.rst:236
msgid ":c:expr:`unsigned int`"
msgstr ":c:expr:`unsigned int`"

#: ../../library/ctypes.rst:238
msgid ":class:`c_long`"
msgstr ":class:`c_long`"

#: ../../library/ctypes.rst:238
msgid ":c:expr:`long`"
msgstr ":c:expr:`long`"

#: ../../library/ctypes.rst:240
msgid ":class:`c_ulong`"
msgstr ":class:`c_ulong`"

#: ../../library/ctypes.rst:240
msgid ":c:expr:`unsigned long`"
msgstr ":c:expr:`unsigned long`"

#: ../../library/ctypes.rst:242
msgid ":class:`c_longlong`"
msgstr ":class:`c_longlong`"

#: ../../library/ctypes.rst:242
msgid ":c:expr:`__int64` or :c:expr:`long long`"
msgstr ":c:expr:`__int64` 或 :c:expr:`long long`"

#: ../../library/ctypes.rst:244
msgid ":class:`c_ulonglong`"
msgstr ":class:`c_ulonglong`"

#: ../../library/ctypes.rst:244
msgid ":c:expr:`unsigned __int64` or :c:expr:`unsigned long long`"
msgstr ":c:expr:`unsigned __int64` 或 :c:expr:`unsigned long long`"

#: ../../library/ctypes.rst:247
msgid ":class:`c_size_t`"
msgstr ":class:`c_size_t`"

#: ../../library/ctypes.rst:247
msgid ":c:expr:`size_t`"
msgstr ":c:expr:`size_t`"

#: ../../library/ctypes.rst:249
msgid ":class:`c_ssize_t`"
msgstr ":class:`c_ssize_t`"

#: ../../library/ctypes.rst:249
msgid ":c:expr:`ssize_t` or :c:expr:`Py_ssize_t`"
msgstr ":c:expr:`ssize_t` 或 :c:expr:`Py_ssize_t`"

#: ../../library/ctypes.rst:252
msgid ":class:`c_float`"
msgstr ":class:`c_float`"

#: ../../library/ctypes.rst:252
msgid ":c:expr:`float`"
msgstr ":c:expr:`float`"

#: ../../library/ctypes.rst:252 ../../library/ctypes.rst:254
#: ../../library/ctypes.rst:256
msgid "float"
msgstr "float"

#: ../../library/ctypes.rst:254
msgid ":class:`c_double`"
msgstr ":class:`c_double`"

#: ../../library/ctypes.rst:254
msgid ":c:expr:`double`"
msgstr ":c:expr:`double`"

#: ../../library/ctypes.rst:256
msgid ":class:`c_longdouble`"
msgstr ":class:`c_longdouble`"

#: ../../library/ctypes.rst:256
msgid ":c:expr:`long double`"
msgstr ":c:expr:`long double`"

#: ../../library/ctypes.rst:258
msgid ":class:`c_char_p`"
msgstr ":class:`c_char_p`"

#: ../../library/ctypes.rst:258
#, fuzzy
msgid ":c:expr:`char *` (NUL terminated)"
msgstr ":c:expr:`char *`（NUL 終止）"

#: ../../library/ctypes.rst:258
#, fuzzy
msgid "bytes object or ``None``"
msgstr "位元組對像或``無``"

#: ../../library/ctypes.rst:260
msgid ":class:`c_wchar_p`"
msgstr ":class:`c_wchar_p`"

#: ../../library/ctypes.rst:260
#, fuzzy
msgid ":c:expr:`wchar_t *` (NUL terminated)"
msgstr ":c:expr:`wchar_t *`（NUL 終止）"

#: ../../library/ctypes.rst:260
msgid "string or ``None``"
msgstr "字串或 ``None``"

#: ../../library/ctypes.rst:262
msgid ":class:`c_void_p`"
msgstr ":class:`c_void_p`"

#: ../../library/ctypes.rst:262
msgid ":c:expr:`void *`"
msgstr ":c:expr:`void *`"

#: ../../library/ctypes.rst:262
#, fuzzy
msgid "int or ``None``"
msgstr "整數或``無``"

#: ../../library/ctypes.rst:266
#, fuzzy
msgid "The constructor accepts any object with a truth value."
msgstr "構造函式接受任何具有真值的物件。"

#: ../../library/ctypes.rst:268
#, fuzzy
msgid ""
"All these types can be created by calling them with an optional initializer "
"of the correct type and value::"
msgstr "所有這些型別都可以通過使用正確型別和值的可選初始化程式呼叫它們來建立："

#: ../../library/ctypes.rst:279
#, fuzzy
msgid ""
"Since these types are mutable, their value can also be changed afterwards::"
msgstr "由於這些型別是可變的，因此它們的值也可以在之後更改::"

#: ../../library/ctypes.rst:291
#, fuzzy
msgid ""
"Assigning a new value to instances of the pointer types :class:`c_char_p`, :"
"class:`c_wchar_p`, and :class:`c_void_p` changes the *memory location* they "
"point to, *not the contents* of the memory block (of course not, because "
"Python bytes objects are immutable)::"
msgstr ""
"為指標型別 :class:`c_char_p`、:class:`c_wchar_p` 和 :class:`c_void_p` 的實例"
"分配新值會更改它們指向的*記憶體位置*，*不是記憶體塊的內容* （當然不是，因為 "
"Python 位元組對像是不可變的）::"

#: ../../library/ctypes.rst:311
#, fuzzy
msgid ""
"You should be careful, however, not to pass them to functions expecting "
"pointers to mutable memory. If you need mutable memory blocks, ctypes has a :"
"func:`create_string_buffer` function which creates these in various ways.  "
"The current memory block contents can be accessed (or changed) with the "
"``raw`` property; if you want to access it as NUL terminated string, use the "
"``value`` property::"
msgstr ""
"但是，您應該小心，不要將它們傳遞給需要指向可變記憶體的指標的函式。如果您需要"
"可變記憶體塊，ctypes 有一個 :func:`create_string_buffer` 函式，它以各種方式建"
"立它們。可以使用 ``raw`` 屬性訪問（或更改）當前記憶體塊內容；如果你想以 NUL "
"結尾的字串訪問它，請使用 ``value`` 屬性::"

#: ../../library/ctypes.rst:335
#, fuzzy
msgid ""
"The :func:`create_string_buffer` function replaces the old :func:`c_buffer` "
"function (which is still available as an alias).  To create a mutable memory "
"block containing unicode characters of the C type :c:expr:`wchar_t`, use "
"the :func:`create_unicode_buffer` function."
msgstr ""
":func:`create_string_buffer` 函式取代了舊的 :func:`c_buffer` 函式（它仍然可以"
"作為別名使用）。要建立包含 C 型別 unicode 字元的可變記憶體塊 :c:expr:"
"`wchar_t`，請使用 :func:`create_unicode_buffer` 函式。"

#: ../../library/ctypes.rst:344
#, fuzzy
msgid "Calling functions, continued"
msgstr "呼叫函式，續"

#: ../../library/ctypes.rst:346
#, fuzzy
msgid ""
"Note that printf prints to the real standard output channel, *not* to :data:"
"`sys.stdout`, so these examples will only work at the console prompt, not "
"from within *IDLE* or *PythonWin*::"
msgstr ""
"請注意，printf 印出到真正的標準輸出通道，*不是*到 :data:`sys.stdout`，因此這"
"些示例只能在控制台提示符下工作，而不是在 *IDLE* 或 *PythonWin*::"

#: ../../library/ctypes.rst:366
#, fuzzy
msgid ""
"As has been mentioned before, all Python types except integers, strings, and "
"bytes objects have to be wrapped in their corresponding :mod:`ctypes` type, "
"so that they can be converted to the required C data type::"
msgstr ""
"如前所述，除了整數、字串和位元組物件之外的所有 Python 型別都必須包裝在它們對"
"應的 ctypes 型別中，以便它們可以轉換為所需的 C 資料型別::"

#: ../../library/ctypes.rst:378
#, fuzzy
msgid "Calling variadic functions"
msgstr "呼叫可變函式"

#: ../../library/ctypes.rst:380
#, fuzzy
msgid ""
"On a lot of platforms calling variadic functions through ctypes is exactly "
"the same as calling functions with a fixed number of parameters. On some "
"platforms, and in particular ARM64 for Apple Platforms, the calling "
"convention for variadic functions is different than that for regular "
"functions."
msgstr ""
"在許多平台上，通過 ctypes 呼叫可變參數函式與呼叫具有固定數量參數的函式完全相"
"同。在某些平台上，特別是 Apple 平台的 ARM64，可變參數函式的呼叫約定與常規函式"
"的呼叫約定不同。"

#: ../../library/ctypes.rst:385
#, fuzzy
msgid ""
"On those platforms it is required to specify the *argtypes* attribute for "
"the regular, non-variadic, function arguments:"
msgstr "在這些平台上，需要為常規的非可變函式參數指定 *argtypes* 屬性："

#: ../../library/ctypes.rst:392
#, fuzzy
msgid ""
"Because specifying the attribute does not inhibit portability it is advised "
"to always specify ``argtypes`` for all variadic functions."
msgstr ""
"因為指定屬性確實會抑制可移植性，所以建議始終為所有可變參數函式指"
"定 ``argtypes`` 。"

#: ../../library/ctypes.rst:399
#, fuzzy
msgid "Calling functions with your own custom data types"
msgstr "使用您自己的自定義資料型別呼叫函式"

#: ../../library/ctypes.rst:401
#, fuzzy
msgid ""
"You can also customize :mod:`ctypes` argument conversion to allow instances "
"of your own classes be used as function arguments.  :mod:`ctypes` looks for "
"an :attr:`_as_parameter_` attribute and uses this as the function argument.  "
"Of course, it must be one of integer, string, or bytes::"
msgstr ""
"您還可以自定義 :mod:`ctypes` 參數轉換，以允許將您自己的類的實例用作函式參"
"數。 :mod:`ctypes` 查找 :attr:`_as_parameter_` 屬性並將其用作函式參數。當然，"
"它必須是整數、字串或位元組之一："

#: ../../library/ctypes.rst:416
#, fuzzy
msgid ""
"If you don't want to store the instance's data in the :attr:`_as_parameter_` "
"instance variable, you could define a :class:`property` which makes the "
"attribute available on request."
msgstr ""
"如果您不想將實例的資料儲存在 :attr:`_as_parameter_` 實例變數中，您可以定義一"
"個 :class:`property` 使屬性在請求時可用。"

#: ../../library/ctypes.rst:424
#, fuzzy
msgid "Specifying the required argument types (function prototypes)"
msgstr "指定所需的參數型別（函式原型）"

#: ../../library/ctypes.rst:426
#, fuzzy
msgid ""
"It is possible to specify the required argument types of functions exported "
"from DLLs by setting the :attr:`argtypes` attribute."
msgstr ""
"可以通過設定 :attr:`argtypes` 屬性指定從 DLL 導出的函式所需的參數型別。"

#: ../../library/ctypes.rst:429
#, fuzzy
msgid ""
":attr:`argtypes` must be a sequence of C data types (the ``printf`` function "
"is probably not a good example here, because it takes a variable number and "
"different types of parameters depending on the format string, on the other "
"hand this is quite handy to experiment with this feature)::"
msgstr ""
":attr:`argtypes` 必須是 C 資料型別的序列（``printf`` 函式在這裡可能不是一個很"
"好的例子，因為它根據格式字串採用可變數量和不同型別的參數，另一方面手這很方便"
"試驗這個功能：："

#: ../../library/ctypes.rst:440
#, fuzzy
msgid ""
"Specifying a format protects against incompatible argument types (just as a "
"prototype for a C function), and tries to convert the arguments to valid "
"types::"
msgstr ""
"指定格式可防止不相容的參數型別（就像 C 函式的原型一樣），並嘗試將參數轉換為有"
"效型別::"

#: ../../library/ctypes.rst:452
#, fuzzy
msgid ""
"If you have defined your own classes which you pass to function calls, you "
"have to implement a :meth:`from_param` class method for them to be able to "
"use them in the :attr:`argtypes` sequence. The :meth:`from_param` class "
"method receives the Python object passed to the function call, it should do "
"a typecheck or whatever is needed to make sure this object is acceptable, "
"and then return the object itself, its :attr:`_as_parameter_` attribute, or "
"whatever you want to pass as the C function argument in this case. Again, "
"the result should be an integer, string, bytes, a :mod:`ctypes` instance, or "
"an object with an :attr:`_as_parameter_` attribute."
msgstr ""
"如果你已經定義了你自己的傳遞給函式呼叫的類，你必須實作一個 :meth:`from_param` "
"類方法，以便它們能夠在 :attr:`argtypes` 序列中使用它們。 :meth:`from_param` 類"
"方法接收傳遞給函式呼叫的 Python 物件，它應該進行型別檢查或任何需要確保此物件"
"可接受的操作，然後回傳物件本身，它的 :attr:`_as_parameter_`屬性，或者在這種情"
"況下您想要作為 C 函式參數傳遞的任何內容。同樣，結果應該是整數、字串、位元"
"組、:mod:`ctypes` 實例或具有 :attr:`_as_parameter_` 屬性的物件。"

#: ../../library/ctypes.rst:466
#, fuzzy
msgid "Return types"
msgstr "回傳型別"

#: ../../library/ctypes.rst:468
#, fuzzy
msgid ""
"By default functions are assumed to return the C :c:expr:`int` type.  Other "
"return types can be specified by setting the :attr:`restype` attribute of "
"the function object."
msgstr ""
"預設情況下，假定函式回傳 C:c:expr:`int` 型別。可以通過設定函式物件的 :attr:"
"`restype` 屬性來指定其他回傳型別。"

#: ../../library/ctypes.rst:472
#, fuzzy
msgid ""
"Here is a more advanced example, it uses the ``strchr`` function, which "
"expects a string pointer and a char, and returns a pointer to a string::"
msgstr ""
"這是一個更高階的示例，它使用 ``strchr`` 函式，它需要一個字串指標和一個字元，"
"並回傳一個指向字串的指標::"

#: ../../library/ctypes.rst:485
#, fuzzy
msgid ""
"If you want to avoid the ``ord(\"x\")`` calls above, you can set the :attr:"
"`argtypes` attribute, and the second argument will be converted from a "
"single character Python bytes object into a C char::"
msgstr ""
"如果你想避免上面的 ``ord(\"x\")`` 呼叫，您可以設定 :attr:`argtypes` 屬性，第"
"二個參數將從單個字元 Python 位元組物件轉換為 C 字元： :"

#: ../../library/ctypes.rst:503
#, fuzzy
msgid ""
"You can also use a callable Python object (a function or a class for "
"example) as the :attr:`restype` attribute, if the foreign function returns "
"an integer.  The callable will be called with the *integer* the C function "
"returns, and the result of this call will be used as the result of your "
"function call. This is useful to check for error return values and "
"automatically raise an exception::"
msgstr ""
"如果外部函式回傳整數，您還可以使用可呼叫的 Python 物件（例如函式或類）作為 "
"restype 屬性。可呼叫物件將使用 C 函式回傳的 *integer* 進行呼叫，此呼叫的結果"
"將用作函式呼叫的結果。這對於檢查錯誤回傳值並自動引發例外很有用::"

#: ../../library/ctypes.rst:526
#, fuzzy
msgid ""
"``WinError`` is a function which will call Windows ``FormatMessage()`` api "
"to get the string representation of an error code, and *returns* an "
"exception. ``WinError`` takes an optional error code parameter, if no one is "
"used, it calls :func:`GetLastError` to retrieve it."
msgstr ""
"``WinError`` 是一個函式，它將呼叫 Windows ``FormatMessage()`` api 來獲取錯誤"
"程式碼的字串表示，並*回傳*一個例外。 ``WinError`` 接受一個可選的錯誤程式碼參"
"數，如果沒有使用，它呼叫 :func:`GetLastError` 來檢索它。"

#: ../../library/ctypes.rst:531
#, fuzzy
msgid ""
"Please note that a much more powerful error checking mechanism is available "
"through the :attr:`errcheck` attribute; see the reference manual for details."
msgstr ""
"請注意，通過 :attr:`errcheck` 屬性可以使用更強大的錯誤檢查機制；詳情請參閱參"
"考手冊。"

#: ../../library/ctypes.rst:538
#, fuzzy
msgid "Passing pointers (or: passing parameters by reference)"
msgstr "傳遞指標（或：通過引用傳遞參數）"

#: ../../library/ctypes.rst:540
#, fuzzy
msgid ""
"Sometimes a C api function expects a *pointer* to a data type as parameter, "
"probably to write into the corresponding location, or if the data is too "
"large to be passed by value. This is also known as *passing parameters by "
"reference*."
msgstr ""
"有時 C api 函式需要一個指向資料型別的 *pointer* 作為參數，可能寫入相應的位"
"置，或者如果資料太大而無法按值傳遞。這也稱為*通過引用傳遞參數*。"

#: ../../library/ctypes.rst:544
#, fuzzy
msgid ""
":mod:`ctypes` exports the :func:`byref` function which is used to pass "
"parameters by reference.  The same effect can be achieved with the :func:"
"`pointer` function, although :func:`pointer` does a lot more work since it "
"constructs a real pointer object, so it is faster to use :func:`byref` if "
"you don't need the pointer object in Python itself::"
msgstr ""
":mod:`ctypes` 導出 :func:`byref` 函式，該函式用於通過引用傳遞參數。使用 :"
"func:`pointer` 函式可以達到同樣的效果，雖然 :func:`pointer` 做了更多的工作，"
"因為它構造了一個真正的指標物件，所以使用 :func:`byref` 更快，如果你不需要 "
"Python 本身的指標物件::"

#: ../../library/ctypes.rst:566
#, fuzzy
msgid "Structures and unions"
msgstr "結構和工會"

#: ../../library/ctypes.rst:568
#, fuzzy
msgid ""
"Structures and unions must derive from the :class:`Structure` and :class:"
"`Union` base classes which are defined in the :mod:`ctypes` module. Each "
"subclass must define a :attr:`_fields_` attribute.  :attr:`_fields_` must be "
"a list of *2-tuples*, containing a *field name* and a *field type*."
msgstr ""
"結構和聯合必須派生自 :class:`Structure` 和 :class:`Union` 基底類別，它們在 :"
"mod:`ctypes` 模組中定義。每個子類別都必須定義一個 :attr:`_fields_` 屬性。 :"
"attr:`_fields_` 必須是 *2-tuples* 列表，包含 *field name* 和 *field type*。"

#: ../../library/ctypes.rst:573
#, fuzzy
msgid ""
"The field type must be a :mod:`ctypes` type like :class:`c_int`, or any "
"other derived :mod:`ctypes` type: structure, union, array, pointer."
msgstr ""
"欄位型別必須是 :mod:`ctypes` 型別，如 :class:`c_int`，或任何其他派生的 :mod:"
"`ctypes` 型別：結構、聯合、數組、指標。"

#: ../../library/ctypes.rst:576
#, fuzzy
msgid ""
"Here is a simple example of a POINT structure, which contains two integers "
"named *x* and *y*, and also shows how to initialize a structure in the "
"constructor::"
msgstr ""
"這是一個簡單的 POINT 結構示例，它包含兩個名為 *x* 和 *y* 的整數，還展示瞭如何"
"在構造函式中初始化結構："

#: ../../library/ctypes.rst:596
#, fuzzy
msgid ""
"You can, however, build much more complicated structures.  A structure can "
"itself contain other structures by using a structure as a field type."
msgstr ""
"但是，您可以構建更複雜的結構。通過將結構用作欄位型別，結構本身可以包含其他結"
"構。"

#: ../../library/ctypes.rst:599
#, fuzzy
msgid ""
"Here is a RECT structure which contains two POINTs named *upperleft* and "
"*lowerright*::"
msgstr ""
"這是一個 RECT 結構，它包含兩個名為 *upperleft* 和 *lowerright* 的 POINT::"

#: ../../library/ctypes.rst:613
#, fuzzy
msgid ""
"Nested structures can also be initialized in the constructor in several "
"ways::"
msgstr "嵌套結構也可以通過多種方式在構造函式中初始化："

#: ../../library/ctypes.rst:618
#, fuzzy
msgid ""
"Field :term:`descriptor`\\s can be retrieved from the *class*, they are "
"useful for debugging because they can provide useful information::"
msgstr ""
"欄位 :term:`descriptor`\\s 可以從 *class* 中檢索，它們對於除錯很有用，因為它"
"們可以提供有用的資訊::"

#: ../../library/ctypes.rst:632
#, fuzzy
msgid ""
":mod:`ctypes` does not support passing unions or structures with bit-fields "
"to functions by value.  While this may work on 32-bit x86, it's not "
"guaranteed by the library to work in the general case.  Unions and "
"structures with bit-fields should always be passed to functions by pointer."
msgstr ""
":mod:`ctypes` 不支援按值將帶有位欄位的聯合或結構傳遞給函式。雖然這可能適用於 "
"32 位 x86，但庫不保證在一般情況下也適用。帶有位欄位的聯合和結構應該始終通過指"
"標傳遞給函式。"

#: ../../library/ctypes.rst:638
#, fuzzy
msgid "Structure/union alignment and byte order"
msgstr "結構/聯合對齊和位元組順序"

#: ../../library/ctypes.rst:640
#, fuzzy
msgid ""
"By default, Structure and Union fields are aligned in the same way the C "
"compiler does it. It is possible to override this behavior by specifying a :"
"attr:`_pack_` class attribute in the subclass definition. This must be set "
"to a positive integer and specifies the maximum alignment for the fields. "
"This is what ``#pragma pack(n)`` also does in MSVC."
msgstr ""
"預設情況下，Structure 和 Union 欄位的對齊方式與 C 編譯器的對齊方式相同。可以"
"通過在子類別定義中指定 :attr:`_pack_` 類屬性來覆蓋此行為。這必須設定為正整數"
"並指定欄位的最大對齊方式。這也是 ``#pragma pack(n)`` 在 MSVC 中所做的。"

#: ../../library/ctypes.rst:646
#, fuzzy
msgid ""
":mod:`ctypes` uses the native byte order for Structures and Unions.  To "
"build structures with non-native byte order, you can use one of the :class:"
"`BigEndianStructure`, :class:`LittleEndianStructure`, :class:"
"`BigEndianUnion`, and :class:`LittleEndianUnion` base classes.  These "
"classes cannot contain pointer fields."
msgstr ""
":mod:`ctypes` 使用結構和聯合的本機位元組順序。要構建具有非本機位元組順序的結"
"構，您可以使用 :class:`BigEndianStructure`、:class:`LittleEndianStructure`、:"
"class:`BigEndianUnion` 和 :class:`LittleEndianUnion` 基底類別之一。這些類不能"
"包含指標欄位。"

#: ../../library/ctypes.rst:656
#, fuzzy
msgid "Bit fields in structures and unions"
msgstr "結構和聯合中的位域"

#: ../../library/ctypes.rst:658
#, fuzzy
msgid ""
"It is possible to create structures and unions containing bit fields. Bit "
"fields are only possible for integer fields, the bit width is specified as "
"the third item in the :attr:`_fields_` tuples::"
msgstr ""
"可以建立包含位欄位的結構和聯合。位欄位僅適用於整數欄位，位寬指定為 :attr:"
"`_fields_` 元組中的第三項::"

#: ../../library/ctypes.rst:676
#, fuzzy
msgid "Arrays"
msgstr "數組"

#: ../../library/ctypes.rst:678
#, fuzzy
msgid ""
"Arrays are sequences, containing a fixed number of instances of the same "
"type."
msgstr "數組是序列，包含固定數量的相同型別的實例。"

#: ../../library/ctypes.rst:680
#, fuzzy
msgid ""
"The recommended way to create array types is by multiplying a data type with "
"a positive integer::"
msgstr "建立數組型別的推薦方法是將資料型別與正整數相乘::"

#: ../../library/ctypes.rst:685
#, fuzzy
msgid ""
"Here is an example of a somewhat artificial data type, a structure "
"containing 4 POINTs among other stuff::"
msgstr "這是一個有點人工資料型別的例子，一個包含 4 個 POINT 和其他東西的結構："

#: ../../library/ctypes.rst:701
#, fuzzy
msgid "Instances are created in the usual way, by calling the class::"
msgstr "實例以通常的方式建立，通過呼叫類::"

#: ../../library/ctypes.rst:707
#, fuzzy
msgid ""
"The above code print a series of ``0 0`` lines, because the array contents "
"is initialized to zeros."
msgstr "上面的程式碼印出了一系列“0 0”行，因為數組內容被初始化為零。"

#: ../../library/ctypes.rst:710
#, fuzzy
msgid "Initializers of the correct type can also be specified::"
msgstr "也可以指定正確型別的初始值設定項::"

#: ../../library/ctypes.rst:726
#, fuzzy
msgid "Pointers"
msgstr "指標"

#: ../../library/ctypes.rst:728
#, fuzzy
msgid ""
"Pointer instances are created by calling the :func:`pointer` function on a :"
"mod:`ctypes` type::"
msgstr ""
"指標實例是通過在 :mod:`ctypes` 型別上呼叫 :func:`pointer` 函式來建立的："

#: ../../library/ctypes.rst:736
#, fuzzy
msgid ""
"Pointer instances have a :attr:`~_Pointer.contents` attribute which returns "
"the object to which the pointer points, the ``i`` object above::"
msgstr ""
"指標實例有一個 :attr:`~_Pointer.contents` 屬性，它回傳指標指向的物件，即上面"
"的 ``i`` 物件::"

#: ../../library/ctypes.rst:743
#, fuzzy
msgid ""
"Note that :mod:`ctypes` does not have OOR (original object return), it "
"constructs a new, equivalent object each time you retrieve an attribute::"
msgstr ""
"請注意 :mod:`ctypes` 沒有 OOR（原始物件回傳），它會在您每次檢索屬性時構造一個"
"新的等效物件::"

#: ../../library/ctypes.rst:752
#, fuzzy
msgid ""
"Assigning another :class:`c_int` instance to the pointer's contents "
"attribute would cause the pointer to point to the memory location where this "
"is stored::"
msgstr ""
"將另一個 c_int 實例分配給指標的內容屬性將導致指標指向儲存它的記憶體位置::"

#: ../../library/ctypes.rst:764
#, fuzzy
msgid "Pointer instances can also be indexed with integers::"
msgstr "指標實例也可以用整數索引::"

#: ../../library/ctypes.rst:770
#, fuzzy
msgid "Assigning to an integer index changes the pointed to value::"
msgstr "分配給整數索引會更改指向的值::"

#: ../../library/ctypes.rst:779
#, fuzzy
msgid ""
"It is also possible to use indexes different from 0, but you must know what "
"you're doing, just as in C: You can access or change arbitrary memory "
"locations. Generally you only use this feature if you receive a pointer from "
"a C function, and you *know* that the pointer actually points to an array "
"instead of a single item."
msgstr ""
"也可以使用不同於 0 的索引，但您必須知道自己在做什麼，就像在 C 中一樣：您可以"
"訪問或更改任意記憶體位置。通常，如果您從 C 函式接收到指標，並且您*知道*該指標"
"實際上指向一個數組而不是單個項目，則通常只使用此功能。"

#: ../../library/ctypes.rst:785
#, fuzzy
msgid ""
"Behind the scenes, the :func:`pointer` function does more than simply create "
"pointer instances, it has to create pointer *types* first. This is done with "
"the :func:`POINTER` function, which accepts any :mod:`ctypes` type, and "
"returns a new type::"
msgstr ""
"在幕後，:func:`pointer` 函式不僅僅建立指標實例，它必須首先建立指標*型別*。這"
"是通過 :func:`POINTER` 函式完成的，它接受任何 :mod:`ctypes` 型別，並回傳一個"
"新型別::"

#: ../../library/ctypes.rst:801
#, fuzzy
msgid ""
"Calling the pointer type without an argument creates a ``NULL`` pointer. "
"``NULL`` pointers have a ``False`` boolean value::"
msgstr ""
"呼叫不帶參數的指標型別會建立一個 ``NULL`` 指標。 ``NULL`` 指標有一個 ``False`` 布"
"爾值::"

#: ../../library/ctypes.rst:809
#, fuzzy
msgid ""
":mod:`ctypes` checks for ``NULL`` when dereferencing pointers (but "
"dereferencing invalid non-\\ ``NULL`` pointers would crash Python)::"
msgstr ""
":mod:`ctypes` 在取消引用指標時檢查 ``NULL``（但取消引用無效的非\\``NULL`` 指"
"標會使 Python 崩潰）::"

#: ../../library/ctypes.rst:828
#, fuzzy
msgid "Type conversions"
msgstr "型別轉換"

#: ../../library/ctypes.rst:830
#, fuzzy
msgid ""
"Usually, ctypes does strict type checking.  This means, if you have "
"``POINTER(c_int)`` in the :attr:`argtypes` list of a function or as the type "
"of a member field in a structure definition, only instances of exactly the "
"same type are accepted.  There are some exceptions to this rule, where "
"ctypes accepts other objects.  For example, you can pass compatible array "
"instances instead of pointer types.  So, for ``POINTER(c_int)``, ctypes "
"accepts an array of c_int::"
msgstr ""
"通常，ctypes 會進行嚴格的型別檢查。這意味著，如果您在函式的 :attr:`argtypes` "
"列表中有 ``POINTER(c_int)`` 或作為結構定義中成員欄位的型別，則只接受完全相同"
"型別的實例。此規則有一些例外情況，其中 ctypes 接受其他物件。例如，您可以傳遞"
"相容的數組實例而不是指標型別。因此，對於 ``POINTER(c_int)``，ctypes 接受一個 "
"c_int:: 數組"

#: ../../library/ctypes.rst:851
#, fuzzy
msgid ""
"In addition, if a function argument is explicitly declared to be a pointer "
"type (such as ``POINTER(c_int)``) in :attr:`argtypes`, an object of the "
"pointed type (``c_int`` in this case) can be passed to the function.  ctypes "
"will apply the required :func:`byref` conversion in this case automatically."
msgstr ""
"此外，如果函式參數在 :attr:`argtypes` 中被顯式聲明為指標型別（例如 "
"``POINTER(c_int)``），則指向型別的物件（在這種情況下為 ``c_int`` ) 可以傳遞給"
"函式。在這種情況下，ctypes 將自動應用所需的 :func:`byref` 轉換。"

#: ../../library/ctypes.rst:856
#, fuzzy
msgid "To set a POINTER type field to ``NULL``, you can assign ``None``::"
msgstr "要將 POINTER 型別欄位設定為 ``NULL`` ，您可以分配 ``None``::"

#: ../../library/ctypes.rst:863
#, fuzzy
msgid ""
"Sometimes you have instances of incompatible types.  In C, you can cast one "
"type into another type.  :mod:`ctypes` provides a :func:`cast` function "
"which can be used in the same way.  The ``Bar`` structure defined above "
"accepts ``POINTER(c_int)`` pointers or :class:`c_int` arrays for its "
"``values`` field, but not instances of other types::"
msgstr ""
"有時您有不相容型別的實例。在 C 中，您可以將一種型別轉換為另一種型別。 :mod:"
"`ctypes` 提供了一個 :func:`cast` 函式，可以以相同的方式使用。上面定義的 "
"``Bar`` 結構接受 ``POINTER(c_int)`` 指標或 :class:`c_int` 數組作為其 "
"``values`` 欄位，但不接受其他型別的實例："

#: ../../library/ctypes.rst:875
#, fuzzy
msgid "For these cases, the :func:`cast` function is handy."
msgstr "對於這些情況，:func:`cast` 函式很方便。"

#: ../../library/ctypes.rst:877
#, fuzzy
msgid ""
"The :func:`cast` function can be used to cast a ctypes instance into a "
"pointer to a different ctypes data type.  :func:`cast` takes two parameters, "
"a ctypes object that is or can be converted to a pointer of some kind, and a "
"ctypes pointer type.  It returns an instance of the second argument, which "
"references the same memory block as the first argument::"
msgstr ""
":func:`cast` 函式可用於將 ctypes 實例轉換為指向不同 ctypes 資料型別的指標。 :"
"func:`cast` 有兩個參數，一個是或可以轉換為某種指標的 ctypes 物件，以及一個 "
"ctypes 指標型別。它回傳第二個參數的實例，它引用與第一個參數相同的記憶體塊::"

#: ../../library/ctypes.rst:888
#, fuzzy
msgid ""
"So, :func:`cast` can be used to assign to the ``values`` field of ``Bar`` "
"the structure::"
msgstr "因此，:func:`cast` 可用於將結構分配給 ``Bar`` 的 ``values`` 欄位："

#: ../../library/ctypes.rst:901
#, fuzzy
msgid "Incomplete Types"
msgstr "不完整型別"

#: ../../library/ctypes.rst:903
#, fuzzy
msgid ""
"*Incomplete Types* are structures, unions or arrays whose members are not "
"yet specified. In C, they are specified by forward declarations, which are "
"defined later::"
msgstr ""
"*不完整型別* 是其成員尚未指定的結構、聯合或數組。在 C 中，它們由前向聲明指"
"定，稍後定義："

#: ../../library/ctypes.rst:914
#, fuzzy
msgid ""
"The straightforward translation into ctypes code would be this, but it does "
"not work::"
msgstr "直接翻譯成 ctypes 程式碼就是這樣，但它不起作用::"

#: ../../library/ctypes.rst:927
#, fuzzy
msgid ""
"because the new ``class cell`` is not available in the class statement "
"itself. In :mod:`ctypes`, we can define the ``cell`` class and set the :attr:"
"`_fields_` attribute later, after the class statement::"
msgstr ""
"因為新的“類單元格”在類語句本身中不可用。在 :mod:`ctypes` 中，我們可以定義 "
"``cell`` 類並稍後在類語句之後設定 :attr:`_fields_` 屬性："

#: ../../library/ctypes.rst:939
#, fuzzy
msgid ""
"Let's try it. We create two instances of ``cell``, and let them point to "
"each other, and finally follow the pointer chain a few times::"
msgstr ""
"讓我們試試吧。我們建立了兩個 ``cell`` 的實例，並讓它們相互指向，最後沿著指標"
"鏈幾次::"

#: ../../library/ctypes.rst:960
#, fuzzy
msgid "Callback functions"
msgstr "回呼函式"

#: ../../library/ctypes.rst:962
#, fuzzy
msgid ""
":mod:`ctypes` allows creating C callable function pointers from Python "
"callables. These are sometimes called *callback functions*."
msgstr ""
":mod:`ctypes` 允許從 Python 可呼叫物件建立 C 可呼叫函式指標。這些有時被稱為*"
"回呼函式*。"

#: ../../library/ctypes.rst:965
#, fuzzy
msgid ""
"First, you must create a class for the callback function. The class knows "
"the calling convention, the return type, and the number and types of "
"arguments this function will receive."
msgstr ""
"首先，您必須為回呼函式建立一個類。該類知道呼叫約定、回傳型別以及此函式將接收"
"的參數的數量和型別。"

#: ../../library/ctypes.rst:969
#, fuzzy
msgid ""
"The :func:`CFUNCTYPE` factory function creates types for callback functions "
"using the ``cdecl`` calling convention. On Windows, the :func:`WINFUNCTYPE` "
"factory function creates types for callback functions using the ``stdcall`` "
"calling convention."
msgstr ""
":func:`CFUNCTYPE` 工廠函式使用 ``cdecl`` 呼叫約定為回呼函式建立型別。在 "
"Windows 上，:func:`WINFUNCTYPE` 工廠函式使用 ``stdcall`` 呼叫約定為回呼函式建"
"立型別。"

#: ../../library/ctypes.rst:974
#, fuzzy
msgid ""
"Both of these factory functions are called with the result type as first "
"argument, and the callback functions expected argument types as the "
"remaining arguments."
msgstr ""
"這兩個工廠函式都以結果型別作為第一個參數呼叫，回呼函式期望參數型別作為其餘參"
"數。"

#: ../../library/ctypes.rst:978
#, fuzzy
msgid ""
"I will present an example here which uses the standard C library's :c:func:"
"`qsort` function, that is used to sort items with the help of a callback "
"function.  :c:func:`qsort` will be used to sort an array of integers::"
msgstr ""
"我將在此處展示一個使用標準 C 庫的 :c:func:`qsort` 函式的示例，該函式用於在回"
"呼函式的幫助下對項目進行排序。 :c:func:`qsort` 將用於對整數數組進行排序::"

#: ../../library/ctypes.rst:988
#, fuzzy
msgid ""
":func:`qsort` must be called with a pointer to the data to sort, the number "
"of items in the data array, the size of one item, and a pointer to the "
"comparison function, the callback. The callback will then be called with two "
"pointers to items, and it must return a negative integer if the first item "
"is smaller than the second, a zero if they are equal, and a positive integer "
"otherwise."
msgstr ""
":func:`qsort` 必須使用指向要排序的資料的指標、資料數組中的項數、一項的大小以"
"及指向比較函式（回呼）的指標來呼叫。然後將使用兩個指向項目的指標呼叫回呼，如"
"果第一個項目小於第二個項目，則它必須回傳一個負整數，如果它們相等則回傳零，否"
"則回傳一個正整數。"

#: ../../library/ctypes.rst:994
#, fuzzy
msgid ""
"So our callback function receives pointers to integers, and must return an "
"integer. First we create the ``type`` for the callback function::"
msgstr ""
"所以我們的回呼函式接收指向整數的指標，並且必須回傳一個整數。首先我們為回呼函"
"式建立``type``::"

#: ../../library/ctypes.rst:1000
#, fuzzy
msgid ""
"To get started, here is a simple callback that shows the values it gets "
"passed::"
msgstr "首先，這是一個簡單的回呼，顯示它傳遞的值："

#: ../../library/ctypes.rst:1010
#, fuzzy
msgid "The result::"
msgstr "結果：："

#: ../../library/ctypes.rst:1020
#, fuzzy
msgid "Now we can actually compare the two items and return a useful result::"
msgstr "現在我們可以實際比較這兩個項目並回傳一個有用的結果::"

#: ../../library/ctypes.rst:1035
#, fuzzy
msgid "As we can easily check, our array is sorted now::"
msgstr "正如我們可以輕鬆檢查的那樣，我們的數組現在已排序::"

#: ../../library/ctypes.rst:1042
#, fuzzy
msgid ""
"The function factories can be used as decorator factories, so we may as well "
"write::"
msgstr "函式工廠可以用作裝飾器工廠，所以我們不妨這樣寫："

#: ../../library/ctypes.rst:1060
#, fuzzy
msgid ""
"Make sure you keep references to :func:`CFUNCTYPE` objects as long as they "
"are used from C code. :mod:`ctypes` doesn't, and if you don't, they may be "
"garbage collected, crashing your program when a callback is made."
msgstr ""
"確保在 C 程式碼中使用時保留對 :func:`CFUNCTYPE` 物件的引用。 :mod:`ctypes` 沒"
"有，如果你不這樣做，它們可能會被垃圾收集，在進行回呼時使你的程式崩潰。"

#: ../../library/ctypes.rst:1064
#, fuzzy
msgid ""
"Also, note that if the callback function is called in a thread created "
"outside of Python's control (e.g. by the foreign code that calls the "
"callback), ctypes creates a new dummy Python thread on every invocation. "
"This behavior is correct for most purposes, but it means that values stored "
"with :class:`threading.local` will *not* survive across different callbacks, "
"even when those calls are made from the same C thread."
msgstr ""
"另外，請注意，如果在 Python 控制之外建立的執行緒中呼叫回呼函式（例如，通過呼"
"叫回呼的外部程式碼），ctypes 會在每次呼叫時建立一個新的虛擬 Python 執行緒。這"
"種行為對於大多數用途都是正確的，但這意味著儲存在 :class:`threading.local` 中"
"的值*不會*在不同的回呼中存在，即使這些呼叫是從同一個 C 執行緒進行的。"

#: ../../library/ctypes.rst:1074
#, fuzzy
msgid "Accessing values exported from dlls"
msgstr "訪問從 dll 導出的值"

#: ../../library/ctypes.rst:1076
#, fuzzy
msgid ""
"Some shared libraries not only export functions, they also export variables. "
"An example in the Python library itself is the :c:data:`Py_OptimizeFlag`, an "
"integer set to 0, 1, or 2, depending on the :option:`-O` or :option:`-OO` "
"flag given on startup."
msgstr ""
"一些共享庫不僅導出函式，還導出變數。 Python 庫本身的一個例子是:c:data:"
"`Py_OptimizeFlag`，一個設定為 0、1 或 2 的整數，具體取決於給定的 :option:`-O` "
"或 :option:`-OO` 旗標啟動。"

#: ../../library/ctypes.rst:1081
#, fuzzy
msgid ""
":mod:`ctypes` can access values like this with the :meth:`in_dll` class "
"methods of the type.  *pythonapi* is a predefined symbol giving access to "
"the Python C api::"
msgstr ""
":mod:`ctypes` 可以使用該型別的 :meth:`in_dll` 類方法訪問這樣的值。 "
"*pythonapi* 是一個預定義的符號，可以訪問 Python C api::"

#: ../../library/ctypes.rst:1090
#, fuzzy
msgid ""
"If the interpreter would have been started with :option:`-O`, the sample "
"would have printed ``c_long(1)``, or ``c_long(2)`` if :option:`-OO` would "
"have been specified."
msgstr ""
"如果直譯器以 :option:`-O` 啟動，示例將印出 ``c_long(1)``，或者 ``c_long(2)`` "
"如果 :option:`-OO`指定的。"

#: ../../library/ctypes.rst:1094
#, fuzzy
msgid ""
"An extended example which also demonstrates the use of pointers accesses "
"the :c:data:`PyImport_FrozenModules` pointer exported by Python."
msgstr ""
"一個擴充示例也演示了指標的使用，它訪問 Python 導出的 PyImport_FrozenModules "
"指標。"

#: ../../library/ctypes.rst:1097
#, fuzzy
msgid "Quoting the docs for that value:"
msgstr "引用該值的文檔："

#: ../../library/ctypes.rst:1099
#, fuzzy
msgid ""
"This pointer is initialized to point to an array of :c:struct:`_frozen` "
"records, terminated by one whose members are all ``NULL`` or zero.  When a "
"frozen module is imported, it is searched in this table.  Third-party code "
"could play tricks with this to provide a dynamically created collection of "
"frozen modules."
msgstr ""
"該指標被初始化為指向 :c:struct:`_frozen` 記錄的數組，以其成員全部為 ``NULL`` 或零"
"的記錄終止。導入凍結模組時，會在該表中進行搜索。第三方程式碼可以利用它來提供"
"動態建立的凍結模組集合。"

#: ../../library/ctypes.rst:1104
#, fuzzy
msgid ""
"So manipulating this pointer could even prove useful. To restrict the "
"example size, we show only how this table can be read with :mod:`ctypes`::"
msgstr ""
"因此，操縱這個指標甚至可以證明是有用的。為了限制示例大小，我們僅展示如何使"
"用 :mod:`ctypes`:: 讀取此表："

#: ../../library/ctypes.rst:1118
#, fuzzy
msgid ""
"We have defined the :c:struct:`_frozen` data type, so we can get the pointer "
"to the table::"
msgstr ""
"我們已經定義了 :c:struct:`_frozen` 資料型別，所以我們可以獲得指向表的指標::"

#: ../../library/ctypes.rst:1125
#, fuzzy
msgid ""
"Since ``table`` is a ``pointer`` to the array of ``struct_frozen`` records, "
"we can iterate over it, but we just have to make sure that our loop "
"terminates, because pointers have no size. Sooner or later it would probably "
"crash with an access violation or whatever, so it's better to break out of "
"the loop when we hit the ``NULL`` entry::"
msgstr ""
"由於 ``table`` 是指向 ``struct_frozen`` 記錄數組的 ``pointer``，我們可以疊代"
"它，但我們只需要確保我們的循環終止，因為指標沒有大小。遲早它可能會因訪問衝突"
"或其他原因而崩潰，因此最好在我們點擊 ``NULL`` 條目時跳出循環::"

#: ../../library/ctypes.rst:1141
#, fuzzy
msgid ""
"The fact that standard Python has a frozen module and a frozen package "
"(indicated by the negative ``size`` member) is not well known, it is only "
"used for testing. Try it out with ``import __hello__`` for example."
msgstr ""
"標準 Python 有一個凍結模組和一個凍結包（由負 ``size`` 成員表示）這一事實並不"
"為人所知，它僅用於測試。例如，嘗試使用 ``import __hello__``。"

#: ../../library/ctypes.rst:1149
#, fuzzy
msgid "Surprises"
msgstr "驚喜"

#: ../../library/ctypes.rst:1151
#, fuzzy
msgid ""
"There are some edges in :mod:`ctypes` where you might expect something other "
"than what actually happens."
msgstr ""
"在 :mod:`ctypes` 中有一些邊緣，您可能會期望發生一些與實際發生的事情不同的事"
"情。"

#: ../../library/ctypes.rst:1154
#, fuzzy
msgid "Consider the following example::"
msgstr "考慮以下示例："

#: ../../library/ctypes.rst:1174
#, fuzzy
msgid ""
"Hm. We certainly expected the last statement to print ``3 4 1 2``. What "
"happened? Here are the steps of the ``rc.a, rc.b = rc.b, rc.a`` line above::"
msgstr ""
"嗯。我們當然希望最後一條語句印出 ``3 4 1 2``。發生了什麼？以下是上面 ``rc.a, "
"rc.b = rc.b, rc.a`` 行的步驟："

#: ../../library/ctypes.rst:1182
#, fuzzy
msgid ""
"Note that ``temp0`` and ``temp1`` are objects still using the internal "
"buffer of the ``rc`` object above. So executing ``rc.a = temp0`` copies the "
"buffer contents of ``temp0`` into ``rc`` 's buffer.  This, in turn, changes "
"the contents of ``temp1``. So, the last assignment ``rc.b = temp1``, doesn't "
"have the expected effect."
msgstr ""
"請注意， ``temp0``和 ``temp1``是仍在使用上面 ``rc``物件的內部緩衝區的物件。所以執行 "
"``rc.a = temp0`` 將 ``temp0`` 的緩衝區內容複製到 ``rc`` 的緩衝區中。反過來，"
"這會更改 ``temp1`` 的內容。所以，最後一個賦值 ``rc.b = temp1`` 沒有達到預期的"
"效果。"

#: ../../library/ctypes.rst:1188
#, fuzzy
msgid ""
"Keep in mind that retrieving sub-objects from Structure, Unions, and Arrays "
"doesn't *copy* the sub-object, instead it retrieves a wrapper object "
"accessing the root-object's underlying buffer."
msgstr ""
"請記住，從結構、聯合和數組中檢索子對像不會*複製*子物件，而是檢索訪問根物件底"
"層緩衝區的包裝物件。"

#: ../../library/ctypes.rst:1192
#, fuzzy
msgid ""
"Another example that may behave differently from what one would expect is "
"this::"
msgstr "另一個可能與人們預期的行為不同的例子是："

#: ../../library/ctypes.rst:1204
#, fuzzy
msgid ""
"Objects instantiated from :class:`c_char_p` can only have their value set to "
"bytes or integers."
msgstr "從 c_char_p 實例化的對像只能將其值設定為位元組或整數。"

#: ../../library/ctypes.rst:1207
#, fuzzy
msgid ""
"Why is it printing ``False``?  ctypes instances are objects containing a "
"memory block plus some :term:`descriptor`\\s accessing the contents of the "
"memory. Storing a Python object in the memory block does not store the "
"object itself, instead the ``contents`` of the object is stored.  Accessing "
"the contents again constructs a new Python object each time!"
msgstr ""
"為什麼印出 ``False``？ ctypes 實例是包含記憶體塊的物件，加上一些訪問記憶體內容的"
"描述器。在記憶體塊中儲存 Python 對像不會儲存物件本身，而是儲存物件的“內容”。"
"每次再次訪問內容都會構造一個新的 Python 物件！"

#: ../../library/ctypes.rst:1217
#, fuzzy
msgid "Variable-sized data types"
msgstr "可變大小的資料型別"

#: ../../library/ctypes.rst:1219
#, fuzzy
msgid ""
":mod:`ctypes` provides some support for variable-sized arrays and structures."
msgstr ":mod:`ctypes` 為可變大小的數組和結構提供了一些支援。"

#: ../../library/ctypes.rst:1221
#, fuzzy
msgid ""
"The :func:`resize` function can be used to resize the memory buffer of an "
"existing ctypes object.  The function takes the object as first argument, "
"and the requested size in bytes as the second argument.  The memory block "
"cannot be made smaller than the natural memory block specified by the "
"objects type, a :exc:`ValueError` is raised if this is tried::"
msgstr ""
":func:`resize` 函式可用於調整現有 ctypes 物件的記憶體緩衝區大小。該函式將對像"
"作為第一個參數，以位元組為單位的請求大小作為第二個參數。記憶體塊不能小於對像"
"型別指定的自然記憶體塊，如果嘗試這樣做會引發 :exc:`ValueError`::"

#: ../../library/ctypes.rst:1241
#, fuzzy
msgid ""
"This is nice and fine, but how would one access the additional elements "
"contained in this array?  Since the type still only knows about 4 elements, "
"we get errors accessing other elements::"
msgstr ""
"這很好，但是如何訪問該數組中包含的其他元素呢？由於該型別仍然只知道 4 個元素，"
"我們在訪問其他元素時會出錯::"

#: ../../library/ctypes.rst:1253
#, fuzzy
msgid ""
"Another way to use variable-sized data types with :mod:`ctypes` is to use "
"the dynamic nature of Python, and (re-)define the data type after the "
"required size is already known, on a case by case basis."
msgstr ""
"另一種使用 :mod:`ctypes` 的可變大小資料型別的方法是使用 Python 的動態特性，並"
"在已知所需大小後根據具體情況（重新）定義資料型別。"

#: ../../library/ctypes.rst:1261
#, fuzzy
msgid "ctypes reference"
msgstr "ctypes參考"

#: ../../library/ctypes.rst:1267
#, fuzzy
msgid "Finding shared libraries"
msgstr "查找共享庫"

#: ../../library/ctypes.rst:1269
#, fuzzy
msgid ""
"When programming in a compiled language, shared libraries are accessed when "
"compiling/linking a program, and when the program is run."
msgstr "當使用編譯語言編程時，在編譯/鏈接程式時以及程式運行時會訪問共享庫。"

#: ../../library/ctypes.rst:1272
#, fuzzy
msgid ""
"The purpose of the :func:`find_library` function is to locate a library in a "
"way similar to what the compiler or runtime loader does (on platforms with "
"several versions of a shared library the most recent should be loaded), "
"while the ctypes library loaders act like when a program is run, and call "
"the runtime loader directly."
msgstr ""
":func:`find_library` 函式的目的是以類似於編譯器或運行時加載器所做的方式定位庫"
"（在具有多個共享庫版本的平台上，應該加載最新版本），而 ctypes 庫加載器就像程"
"序運行時一樣，直接呼叫運行時加載器。"

#: ../../library/ctypes.rst:1278
#, fuzzy
msgid ""
"The :mod:`ctypes.util` module provides a function which can help to "
"determine the library to load."
msgstr ":mod:`ctypes.util` 模組提供了一個函式，可以幫助確定要加載的庫。"

#: ../../library/ctypes.rst:1286
#, fuzzy
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like *lib*, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""
"嘗試查找庫並回傳路徑名。 *name* 是庫名，不帶任何前綴如 *lib*、後綴如 ``."
"so``、``.dylib`` 或版本號（這是用於 posix 鏈接器選項的形式 :option:`！- "
"l`）。如果找不到庫，則回傳 ``None`` 。"

#: ../../library/ctypes.rst:1291 ../../library/ctypes.rst:1934
#, fuzzy
msgid "The exact functionality is system dependent."
msgstr "確切的功能取決於系統。"

#: ../../library/ctypes.rst:1293
#, fuzzy
msgid ""
"On Linux, :func:`find_library` tries to run external programs (``/sbin/"
"ldconfig``, ``gcc``, ``objdump`` and ``ld``) to find the library file. It "
"returns the filename of the library file."
msgstr ""
"在 Linux 上，:func:`find_library` 嘗試運行外部程式（``/sbin/ldconfig``、"
"``gcc``、``objdump`` 和 ``ld``）來查找庫文件。它回傳庫文件的文件名。"

#: ../../library/ctypes.rst:1297
#, fuzzy
msgid ""
"On Linux, the value of the environment variable ``LD_LIBRARY_PATH`` is used "
"when searching for libraries, if a library cannot be found by any other "
"means."
msgstr ""
"在 Linux 上，如果無法通過任何其他方式找到庫，則在搜索庫時會使用環境變數 "
"``LD_LIBRARY_PATH`` 的值。"

#: ../../library/ctypes.rst:1301
msgid "Here are some examples::"
msgstr ""
"以下是一些範例：\n"
"\n"
"::"

#: ../../library/ctypes.rst:1312
#, fuzzy
msgid ""
"On macOS, :func:`find_library` tries several predefined naming schemes and "
"paths to locate the library, and returns a full pathname if successful::"
msgstr ""
"在 macOS 上，:func:`find_library` 會嘗試幾種預定義的命名方案和路徑來定位庫，"
"如果成功則回傳完整路徑名::"

#: ../../library/ctypes.rst:1326
#, fuzzy
msgid ""
"On Windows, :func:`find_library` searches along the system search path, and "
"returns the full pathname, but since there is no predefined naming scheme a "
"call like ``find_library(\"c\")`` will fail and return ``None``."
msgstr ""
"在 Windows 上，:func:`find_library` 沿著系統搜索路徑搜索，並回傳完整的路徑"
"名，但由於沒有預定義的命名方案，像 ``find_library(\"c\")`` 這樣的呼叫將失敗並"
"回傳 ``None ``。"

#: ../../library/ctypes.rst:1330
#, fuzzy
msgid ""
"If wrapping a shared library with :mod:`ctypes`, it *may* be better to "
"determine the shared library name at development time, and hardcode that "
"into the wrapper module instead of using :func:`find_library` to locate the "
"library at runtime."
msgstr ""
"如果使用 :mod:`ctypes` 包裝共享庫，*可能*最好在開發時確定共享庫名稱，並將其硬"
"編碼到包裝器模組中，而不是使用 :func:`find_library` 將庫定位在運行。"

#: ../../library/ctypes.rst:1338
#, fuzzy
msgid "Loading shared libraries"
msgstr "加載共享庫"

#: ../../library/ctypes.rst:1340
#, fuzzy
msgid ""
"There are several ways to load shared libraries into the Python process.  "
"One way is to instantiate one of the following classes:"
msgstr ""
"有幾種方法可以將共享庫加載到 Python 行程中。一種方法是實例化以下類之一："

#: ../../library/ctypes.rst:1346
#, fuzzy
msgid ""
"Instances of this class represent loaded shared libraries. Functions in "
"these libraries use the standard C calling convention, and are assumed to "
"return :c:expr:`int`."
msgstr ""
"此類的實例表示加載的共享庫。這些庫中的函式使用標準 C 呼叫約定，並假定回傳 :c:"
"expr:`int`。"

#: ../../library/ctypes.rst:1350
#, fuzzy
msgid ""
"On Windows creating a :class:`CDLL` instance may fail even if the DLL name "
"exists. When a dependent DLL of the loaded DLL is not found, a :exc:"
"`OSError` error is raised with the message *\"[WinError 126] The specified "
"module could not be found\".* This error message does not contain the name "
"of the missing DLL because the Windows API does not return this information "
"making this error hard to diagnose. To resolve this error and determine "
"which DLL is not found, you need to find the list of dependent DLLs and "
"determine which one is not found using Windows debugging and tracing tools."
msgstr ""
"在 Windows 上建立 :class:`CDLL` 實例可能會失敗，即使 DLL 名稱存在也是如此。當"
"未找到加載的 DLL 的依賴 DLL 時，會引發 :exc:`OSError` 錯誤消息 *\"[WinError "
"126] 找不到指定的模組\"。* 此錯誤消息不包含名稱缺少 DLL，因為 Windows API 不"
"回傳此資訊，因此很難診斷此錯誤。要解決此錯誤並確定未找到哪個 DLL，您需要查找"
"依賴 DLL 的列表並使用 Windows 除錯和跟踪工具確定未找到哪個 DLL。"

#: ../../library/ctypes.rst:1362
#, fuzzy
msgid ""
"`Microsoft DUMPBIN tool <https://docs.microsoft.com/cpp/build/reference/"
"dependents>`_ -- A tool to find DLL dependents."
msgstr ""
"`Microsoft DUMPBIN 工具 <https://docs.microsoft.com/cpp/build/reference/"
"dependents>`_ -- 一種查找 DLL 依賴項的工具。"

#: ../../library/ctypes.rst:1368
#, fuzzy
msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and are "
"assumed to return the windows specific :class:`HRESULT` code.  :class:"
"`HRESULT` values contain information specifying whether the function call "
"failed or succeeded, together with additional error code.  If the return "
"value signals a failure, an :class:`OSError` is automatically raised."
msgstr ""
"僅限 Windows：此類的實例表示加載的共享庫，這些庫中的函式使用 ``stdcall`` 呼叫"
"約定，並假定回傳特定於 Windows 的 HRESULT 程式碼。 :class:`HRESULT` 值包含指"
"定函式呼叫是失敗還是成功的資訊，以及其他錯誤程式碼。如果回傳值表示失敗，則會"
"自動引發 :class:`OSError`。"

#: ../../library/ctypes.rst:1375
#, fuzzy
msgid ":exc:`WindowsError` used to be raised."
msgstr ":exc:`WindowsError` 曾經被提出。"

#: ../../library/ctypes.rst:1381
#, fuzzy
msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and are "
"assumed to return :c:expr:`int` by default."
msgstr ""
"僅限 Windows：此類的實例表示加載的共享庫，這些庫中的函式使用 ``stdcall`` 呼叫"
"約定，並假定預設回傳 :c:expr:`int`。"

#: ../../library/ctypes.rst:1385
#, fuzzy
msgid ""
"The Python :term:`global interpreter lock` is released before calling any "
"function exported by these libraries, and reacquired afterwards."
msgstr ""
"Python :term:`global interpreter lock` 在呼叫這些庫導出的任何函式之前釋放，然"
"後重新獲取。"

#: ../../library/ctypes.rst:1391
#, fuzzy
msgid ""
"Instances of this class behave like :class:`CDLL` instances, except that the "
"Python GIL is *not* released during the function call, and after the "
"function execution the Python error flag is checked. If the error flag is "
"set, a Python exception is raised."
msgstr ""
"此類實例的行為類似於 :class:`CDLL` 實例，除了在函式呼叫期間*不*釋放 Python "
"GIL，並且在函式執行後檢查 Python 錯誤旗標。如果設定了錯誤旗標，則會引發 "
"Python 例外。"

#: ../../library/ctypes.rst:1396
#, fuzzy
msgid "Thus, this is only useful to call Python C api functions directly."
msgstr "因此，這僅對直接呼叫 Python C api 函式有用。"

#: ../../library/ctypes.rst:1398
#, fuzzy
msgid ""
"All these classes can be instantiated by calling them with at least one "
"argument, the pathname of the shared library.  If you have an existing "
"handle to an already loaded shared library, it can be passed as the "
"``handle`` named parameter, otherwise the underlying platforms ``dlopen`` or "
"``LoadLibrary`` function is used to load the library into the process, and "
"to get a handle to it."
msgstr ""
"所有這些類都可以通過使用至少一個參數呼叫它們來實例化，即共享庫的路徑名。如果"
"你有一個已經加載的共享庫的現有句柄，它可以作為``handle``命名參數傳遞，否則底"
"層平台``dlopen``或``LoadLibrary``函式用於將庫加載到的過程，並得到它的句柄。"

#: ../../library/ctypes.rst:1405
#, fuzzy
msgid ""
"The *mode* parameter can be used to specify how the library is loaded.  For "
"details, consult the :manpage:`dlopen(3)` manpage.  On Windows, *mode* is "
"ignored.  On posix systems, RTLD_NOW is always added, and is not "
"configurable."
msgstr ""
"*mode* 參數可用於指定庫的加載方式。有關詳細資訊，請參閱 :manpage:`dlopen(3)` "
"聯機幫助頁。在 Windows 上，*mode* 被忽略。在 posix 系統上，始終新增 "
"RTLD_NOW，並且不可配置。"

#: ../../library/ctypes.rst:1410
#, fuzzy
msgid ""
"The *use_errno* parameter, when set to true, enables a ctypes mechanism that "
"allows accessing the system :data:`errno` error number in a safe way. :mod:"
"`ctypes` maintains a thread-local copy of the systems :data:`errno` "
"variable; if you call foreign functions created with ``use_errno=True`` then "
"the :data:`errno` value before the function call is swapped with the ctypes "
"private copy, the same happens immediately after the function call."
msgstr ""
"*use_errno* 參數設定為 true 時，啟用允許以安全方式訪問系統錯誤號的 ctypes 機"
"制。 :mod:`ctypes` 維護系統 :data:`errno` 變數的執行緒本地副本；如果您呼叫使"
"用 use_errno=True 建立的外部函式，則函式呼叫之前的 errno 值將與 ctypes 私有副"
"本交換，同樣的情況會在函式呼叫之後立即發生。"

#: ../../library/ctypes.rst:1417
#, fuzzy
msgid ""
"The function :func:`ctypes.get_errno` returns the value of the ctypes "
"private copy, and the function :func:`ctypes.set_errno` changes the ctypes "
"private copy to a new value and returns the former value."
msgstr ""
"函式 :func:`ctypes.get_errno` 回傳 ctypes 私有副本的值，函式 :func:`ctypes."
"set_errno` 將 ctypes 私有副本更改為新值並回傳之前的值。"

#: ../../library/ctypes.rst:1421
#, fuzzy
msgid ""
"The *use_last_error* parameter, when set to true, enables the same mechanism "
"for the Windows error code which is managed by the :func:`GetLastError` and :"
"func:`SetLastError` Windows API functions; :func:`ctypes.get_last_error` "
"and :func:`ctypes.set_last_error` are used to request and change the ctypes "
"private copy of the windows error code."
msgstr ""
"*use_last_error* 參數，當設定為 true 時，為 Windows 錯誤程式碼啟用相同的機"
"制，該機制由 :func:`GetLastError` 和 :func:`SetLastError` Windows API 函式管"
"理； :func:`ctypes.get_last_error` 和 :func:`ctypes.set_last_error` 用於請求"
"和更改 Windows 錯誤程式碼的 ctypes 私有副本。"

#: ../../library/ctypes.rst:1427
#, fuzzy
msgid ""
"The *winmode* parameter is used on Windows to specify how the library is "
"loaded (since *mode* is ignored). It takes any value that is valid for the "
"Win32 API ``LoadLibraryEx`` flags parameter. When omitted, the default is to "
"use the flags that result in the most secure DLL load to avoiding issues "
"such as DLL hijacking. Passing the full path to the DLL is the safest way to "
"ensure the correct library and dependencies are loaded."
msgstr ""
"*winmode* 參數在 Windows 上用於指定庫的加載方式（因為 *mode* 被忽略）。它採用"
"對 Win32 API ``LoadLibraryEx`` flags 參數有效的任何值。省略時，預設使用導致最"
"安全的 DLL 加載的旗標，以避免 DLL 劫持等問題。將完整路徑傳遞給 DLL 是確保加載"
"正確庫和依賴項的最安全方法。"

#: ../../library/ctypes.rst:1434
msgid "Added *winmode* parameter."
msgstr "新增 *winmode* 參數。"

#: ../../library/ctypes.rst:1441
#, fuzzy
msgid ""
"Flag to use as *mode* parameter.  On platforms where this flag is not "
"available, it is defined as the integer zero."
msgstr "用作 *mode* 參數的旗標。在該旗標不可用的平台上，它被定義為整數零。"

#: ../../library/ctypes.rst:1448
#, fuzzy
msgid ""
"Flag to use as *mode* parameter.  On platforms where this is not available, "
"it is the same as *RTLD_GLOBAL*."
msgstr "用作 *mode* 參數的旗標。在不可用的平台上，它與 *RTLD_GLOBAL* 相同。"

#: ../../library/ctypes.rst:1455
#, fuzzy
msgid ""
"The default mode which is used to load shared libraries.  On OSX 10.3, this "
"is *RTLD_GLOBAL*, otherwise it is the same as *RTLD_LOCAL*."
msgstr ""
"用於加載共享庫的預設模式。在 OSX 10.3 上，這是 *RTLD_GLOBAL*，否則它與 "
"*RTLD_LOCAL* 相同。"

#: ../../library/ctypes.rst:1458
#, fuzzy
msgid ""
"Instances of these classes have no public methods.  Functions exported by "
"the shared library can be accessed as attributes or by index.  Please note "
"that accessing the function through an attribute caches the result and "
"therefore accessing it repeatedly returns the same object each time.  On the "
"other hand, accessing it through an index returns a new object each time::"
msgstr ""
"這些類的實例沒有公開方法。共享庫導出的函式可以作為屬性或索引訪問。請注意，通"
"過屬性訪問函式會快取結果，因此重複訪問它每次都會回傳相同的物件。另一方面，通"
"過索引訪問它每次都會回傳一個新物件："

#: ../../library/ctypes.rst:1471
#, fuzzy
msgid ""
"The following public attributes are available, their name starts with an "
"underscore to not clash with exported function names:"
msgstr "以下公開屬性可用，它們的名稱以底線開頭，以免與導出的函式名稱衝突："

#: ../../library/ctypes.rst:1477
#, fuzzy
msgid "The system handle used to access the library."
msgstr "用於訪問庫的系統句柄。"

#: ../../library/ctypes.rst:1482
#, fuzzy
msgid "The name of the library passed in the constructor."
msgstr "在構造函式中傳遞的庫的名稱。"

#: ../../library/ctypes.rst:1484
#, fuzzy
msgid ""
"Shared libraries can also be loaded by using one of the prefabricated "
"objects, which are instances of the :class:`LibraryLoader` class, either by "
"calling the :meth:`LoadLibrary` method, or by retrieving the library as "
"attribute of the loader instance."
msgstr ""
"共享庫也可以通過使用預製物件之一來加載，這些預製對像是 LibraryLoader 類的實"
"例，可以通過呼叫 LoadLibrary 方法，或者通過檢索庫作為加載器實例的屬性."

#: ../../library/ctypes.rst:1492
#, fuzzy
msgid ""
"Class which loads shared libraries.  *dlltype* should be one of the :class:"
"`CDLL`, :class:`PyDLL`, :class:`WinDLL`, or :class:`OleDLL` types."
msgstr ""
"加載共享庫的類。 *dlltype* 應該是 :class:`CDLL`、:class:`PyDLL`、:class:"
"`WinDLL` 或 :class:`OleDLL` 型別之一。"

#: ../../library/ctypes.rst:1495
#, fuzzy
msgid ""
":meth:`__getattr__` has special behavior: It allows loading a shared library "
"by accessing it as attribute of a library loader instance.  The result is "
"cached, so repeated attribute accesses return the same library each time."
msgstr ""
":meth:`__getattr__` 具有特殊行為：它允許通過將共享庫作為庫加載器實例的屬性進"
"行訪問來加載共享庫。結果被快取，因此重複的屬性訪問每次都回傳相同的庫。"

#: ../../library/ctypes.rst:1501
#, fuzzy
msgid ""
"Load a shared library into the process and return it.  This method always "
"returns a new instance of the library."
msgstr "將共享庫加載到行程中並回傳它。此方法始終回傳庫的新實例。"

#: ../../library/ctypes.rst:1505
#, fuzzy
msgid "These prefabricated library loaders are available:"
msgstr "這些預製庫加載器可用："

#: ../../library/ctypes.rst:1510
#, fuzzy
msgid "Creates :class:`CDLL` instances."
msgstr "建立 :class:`CDLL` 實例。"

#: ../../library/ctypes.rst:1516
#, fuzzy
msgid "Windows only: Creates :class:`WinDLL` instances."
msgstr "僅限 Windows：建立 :class:`WinDLL` 實例。"

#: ../../library/ctypes.rst:1522
#, fuzzy
msgid "Windows only: Creates :class:`OleDLL` instances."
msgstr "僅限 Windows：建立 :class:`OleDLL` 實例。"

#: ../../library/ctypes.rst:1528
#, fuzzy
msgid "Creates :class:`PyDLL` instances."
msgstr "建立 :class:`PyDLL` 實例。"

#: ../../library/ctypes.rst:1531
#, fuzzy
msgid ""
"For accessing the C Python api directly, a ready-to-use Python shared "
"library object is available:"
msgstr "要直接訪問 C Python api，可以使用現成的 Python 共享庫物件："

#: ../../library/ctypes.rst:1537
#, fuzzy
msgid ""
"An instance of :class:`PyDLL` that exposes Python C API functions as "
"attributes.  Note that all these functions are assumed to return C :c:expr:"
"`int`, which is of course not always the truth, so you have to assign the "
"correct :attr:`restype` attribute to use these functions."
msgstr ""
"PyDLL 的一個實例，它將 Python C API 函式公開為屬性。請注意，所有這些函式都假"
"定回傳 C:c:expr:`int`，這當然不總是事實，因此您必須分配正確的:"
"attr:`restype` 屬性才能使用這些函式。"

#: ../../library/ctypes.rst:1542
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.dlopen`` with argument "
"``name``."
msgstr ""
"引發一個附帶引數 ``name`` 的\\ :ref:`稽核事件 <auditing>` ``ctypes.dlopen``。"

#: ../../library/ctypes.rst:1544
#, fuzzy
msgid ""
"Loading a library through any of these objects raises an :ref:`auditing "
"event <auditing>` ``ctypes.dlopen`` with string argument ``name``, the name "
"used to load the library."
msgstr ""
"通過這些對像中的任何一個加載庫都會引發 :ref:`auditing 事件 <auditing>` "
"``ctypes.dlopen`` 帶有字串參數 ``name``，用於加載庫的名稱。"

#: ../../library/ctypes.rst:1548
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.dlsym`` with arguments "
"``library``, ``name``."
msgstr ""
"引發一個附帶引數 ``library``、``name`` 的\\ :ref:`稽核事件 <auditing>` "
"``ctypes.dlsym``。"

#: ../../library/ctypes.rst:1550
#, fuzzy
msgid ""
"Accessing a function on a loaded library raises an auditing event ``ctypes."
"dlsym`` with arguments ``library`` (the library object) and ``name`` (the "
"symbol's name as a string or integer)."
msgstr ""
"訪問已加載庫上的函式會引發審計事件“ctypes.dlsym”，參數為 ``library`` （庫物件）"
"和 ``name``（符號名稱為字串或整數）。"

#: ../../library/ctypes.rst:1554
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.dlsym/handle`` with "
"arguments ``handle``, ``name``."
msgstr ""
"引發一個附帶引數 ``handle``、``name`` 的\\ :ref:`稽核事件 <auditing>` "
"``ctypes.dlsym/handle``。"

#: ../../library/ctypes.rst:1556
#, fuzzy
msgid ""
"In cases when only the library handle is available rather than the object, "
"accessing a function raises an auditing event ``ctypes.dlsym/handle`` with "
"arguments ``handle`` (the raw library handle) and ``name``."
msgstr ""
"在只有庫句柄而不是物件可用的情況下，訪問函式會引髮帶有參數 ``handle``（原始庫句"
"柄）和 ``name``的審計事件“ctypes.dlsym/handle”。"

#: ../../library/ctypes.rst:1563
#, fuzzy
msgid "Foreign functions"
msgstr "外部函式"

#: ../../library/ctypes.rst:1565
#, fuzzy
msgid ""
"As explained in the previous section, foreign functions can be accessed as "
"attributes of loaded shared libraries.  The function objects created in this "
"way by default accept any number of arguments, accept any ctypes data "
"instances as arguments, and return the default result type specified by the "
"library loader. They are instances of a private class:"
msgstr ""
"如前一節所述，外部函式可以作為加載的共享庫的屬性進行訪問。以這種方式建立的函"
"式物件預設接受任意數量的參數，接受任何 ctypes 資料實例作為參數，並回傳庫加載"
"程式指定的預設結果型別。它們是私有類的實例："

#: ../../library/ctypes.rst:1574
#, fuzzy
msgid "Base class for C callable foreign functions."
msgstr "C 可呼叫外部函式的基底類別。"

#: ../../library/ctypes.rst:1576
#, fuzzy
msgid ""
"Instances of foreign functions are also C compatible data types; they "
"represent C function pointers."
msgstr "外部函式的實例也是 C 相容的資料型別；它們代表 C 函式指標。"

#: ../../library/ctypes.rst:1579
#, fuzzy
msgid ""
"This behavior can be customized by assigning to special attributes of the "
"foreign function object."
msgstr "這種行為可以通過分配給外部函式物件的特殊屬性來定制。"

#: ../../library/ctypes.rst:1584
#, fuzzy
msgid ""
"Assign a ctypes type to specify the result type of the foreign function. Use "
"``None`` for :c:expr:`void`, a function not returning anything."
msgstr ""
"分配一個 ctypes 型別以指定外部函式的結果型別。將 ``None`` 用於 :c:expr:"
"`void`，一個不回傳任何內容的函式。"

#: ../../library/ctypes.rst:1587
#, fuzzy
msgid ""
"It is possible to assign a callable Python object that is not a ctypes type, "
"in this case the function is assumed to return a C :c:expr:`int`, and the "
"callable will be called with this integer, allowing further processing or "
"error checking.  Using this is deprecated, for more flexible post processing "
"or error checking use a ctypes data type as :attr:`restype` and assign a "
"callable to the :attr:`errcheck` attribute."
msgstr ""
"可以分配一個不是 ctypes 型別的可呼叫 Python 物件，在這種情況下，函式被假定回"
"傳一個 C:c:expr:`int`，並且將使用該整數呼叫可呼叫物件，從而允許進一步處理或錯"
"誤檢查。使用它已被棄用，為了更靈活的後處理或錯誤檢查，請使用 ctypes 資料型別"
"作為 :attr:`restype` 並將可呼叫物件分配給 :attr:`errcheck` 屬性。"

#: ../../library/ctypes.rst:1596
#, fuzzy
msgid ""
"Assign a tuple of ctypes types to specify the argument types that the "
"function accepts.  Functions using the ``stdcall`` calling convention can "
"only be called with the same number of arguments as the length of this "
"tuple; functions using the C calling convention accept additional, "
"unspecified arguments as well."
msgstr ""
"分配 ctypes 型別的元組以指定函式接受的參數型別。使用 ``stdcall`` 呼叫約定的函"
"式只能使用與該元組長度相同數量的參數呼叫；使用 C 呼叫約定的函式也接受額外的、"
"未指定的參數。"

#: ../../library/ctypes.rst:1602
#, fuzzy
msgid ""
"When a foreign function is called, each actual argument is passed to the :"
"meth:`from_param` class method of the items in the :attr:`argtypes` tuple, "
"this method allows adapting the actual argument to an object that the "
"foreign function accepts.  For example, a :class:`c_char_p` item in the :"
"attr:`argtypes` tuple will convert a string passed as argument into a bytes "
"object using ctypes conversion rules."
msgstr ""
"當呼叫外部函式時，每個實際參數都傳遞給 argtypes 元組中項的 :meth:"
"`from_param` 類方法，此方法允許將實際參數調整為外部函式接受的物件.例如，"
"argtypes 元組中的 c_char_p 項將使用 ctypes 轉換規則將作為參數傳遞的字串轉換為"
"位元組物件。"

#: ../../library/ctypes.rst:1609
#, fuzzy
msgid ""
"New: It is now possible to put items in argtypes which are not ctypes types, "
"but each item must have a :meth:`from_param` method which returns a value "
"usable as argument (integer, string, ctypes instance).  This allows defining "
"adapters that can adapt custom objects as function parameters."
msgstr ""
"新：現在可以將項目放入不是 ctypes 型別的 argtypes 中，但每個項目都必須有一個 "
"from_param 方法，該方法回傳一個可用作參數的值（整數、字串、ctypes 實例）。這"
"允許定義可以將自定義物件適配為函式參數的適配器。"

#: ../../library/ctypes.rst:1616
#, fuzzy
msgid ""
"Assign a Python function or another callable to this attribute. The callable "
"will be called with three or more arguments:"
msgstr ""
"為這個屬性分配一個 Python 函式或另一個可呼叫函式。將使用三個或更多參數呼叫可"
"呼叫物件："

#: ../../library/ctypes.rst:1623
#, fuzzy
msgid ""
"*result* is what the foreign function returns, as specified by the :attr:"
"`restype` attribute."
msgstr "*result* 是外部函式回傳的內容，由 :attr:`restype` 屬性指定。"

#: ../../library/ctypes.rst:1626
#, fuzzy
msgid ""
"*func* is the foreign function object itself, this allows reusing the same "
"callable object to check or post process the results of several functions."
msgstr ""
"*func* 是外部函式物件本身，這允許重複使用相同的可呼叫物件來檢查或後處理多個函"
"式的結果。"

#: ../../library/ctypes.rst:1630
#, fuzzy
msgid ""
"*arguments* is a tuple containing the parameters originally passed to the "
"function call, this allows specializing the behavior on the arguments used."
msgstr ""
"*arguments* 是一個包含最初傳遞給函式呼叫的參數的元組，這允許專門針對所使用的"
"參數的行為。"

#: ../../library/ctypes.rst:1634
#, fuzzy
msgid ""
"The object that this function returns will be returned from the foreign "
"function call, but it can also check the result value and raise an exception "
"if the foreign function call failed."
msgstr ""
"此函式回傳的物件將從外部函式呼叫回傳，但它也可以檢查結果值並在外部函式呼叫失"
"敗時引發例外。"

#: ../../library/ctypes.rst:1641
#, fuzzy
msgid ""
"This exception is raised when a foreign function call cannot convert one of "
"the passed arguments."
msgstr "當外部函式呼叫無法轉換傳遞的參數之一時，會引發此例外。"

#: ../../library/ctypes.rst:1645
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.seh_exception`` with "
"argument ``code``."
msgstr ""
"引發一個附帶引數 ``code`` 的\\ :ref:`稽核事件 <auditing>` ``ctypes."
"seh_exception``。"

#: ../../library/ctypes.rst:1647
#, fuzzy
msgid ""
"On Windows, when a foreign function call raises a system exception (for "
"example, due to an access violation), it will be captured and replaced with "
"a suitable Python exception. Further, an auditing event ``ctypes."
"seh_exception`` with argument ``code`` will be raised, allowing an audit "
"hook to replace the exception with its own."
msgstr ""
"在 Windows 上，當外部函式呼叫引發系統例外（例如，由於訪問衝突）時，它將被捕獲"
"並替換為合適的 Python 例外。此外，將引髮帶有參數 ``code``的審計事件“ctypes."
"seh_exception”，允許審計掛鉤用自己的例外替換例外。"

#: ../../library/ctypes.rst:1653
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.call_function`` with "
"arguments ``func_pointer``, ``arguments``."
msgstr ""
"引發一個附帶引數 ``func_pointer``、``arguments`` 的\\ :ref:`稽核事件 "
"<auditing>` ``ctypes.call_function``。"

#: ../../library/ctypes.rst:1655
#, fuzzy
msgid ""
"Some ways to invoke foreign function calls may raise an auditing event "
"``ctypes.call_function`` with arguments ``function pointer`` and "
"``arguments``."
msgstr ""
"某些呼叫外部函式呼叫的方法可能會引髮帶有參數“函式指標”和“參數”的審計事"
"件“ctypes.call_function”。"

#: ../../library/ctypes.rst:1661
#, fuzzy
msgid "Function prototypes"
msgstr "函式原型"

#: ../../library/ctypes.rst:1663
#, fuzzy
msgid ""
"Foreign functions can also be created by instantiating function prototypes. "
"Function prototypes are similar to function prototypes in C; they describe a "
"function (return type, argument types, calling convention) without defining "
"an implementation.  The factory functions must be called with the desired "
"result type and the argument types of the function, and can be used as "
"decorator factories, and as such, be applied to functions through the "
"``@wrapper`` syntax. See :ref:`ctypes-callback-functions` for examples."
msgstr ""
"也可以通過實例化函式原型來建立外部函式。函式原型類似於 C 中的函式原型；它們描"
"述了一個函式（回傳型別、參數型別、呼叫約定）而不定義實作。工廠函式必須使用所"
"需的結果型別和函式的參數型別來呼叫，並且可以用作裝飾器工廠，因此可以通"
"過“@wrapper”語法應用於函式。有關示例，請參見 :ref:`ctypes-callback-"
"functions`。"

#: ../../library/ctypes.rst:1674
#, fuzzy
msgid ""
"The returned function prototype creates functions that use the standard C "
"calling convention.  The function will release the GIL during the call.  If "
"*use_errno* is set to true, the ctypes private copy of the system :data:"
"`errno` variable is exchanged with the real :data:`errno` value before and "
"after the call; *use_last_error* does the same for the Windows error code."
msgstr ""
"回傳的函式原型建立使用標準 C 呼叫約定的函式。該函式將在呼叫期間釋放 GIL。如"
"果 *use_errno* 設定為 true，系統 :data:`errno` 變數的 ctypes 私有副本在呼叫前"
"後與真實的 :data:`errno` 值交換； *use_last_error* 對 Windows 錯誤程式碼執行"
"相同的操作。"

#: ../../library/ctypes.rst:1684
#, fuzzy
msgid ""
"Windows only: The returned function prototype creates functions that use the "
"``stdcall`` calling convention.  The function will release the GIL during "
"the call.  *use_errno* and *use_last_error* have the same meaning as above."
msgstr ""
"僅限 Windows：回傳的函式原型建立使用 ``stdcall`` 呼叫約定的函式。該函式將在呼"
"叫期間釋放 GIL。 *use_errno* 和 *use_last_error* 含義同上。"

#: ../../library/ctypes.rst:1692
#, fuzzy
msgid ""
"The returned function prototype creates functions that use the Python "
"calling convention.  The function will *not* release the GIL during the call."
msgstr ""
"回傳的函式原型建立使用 Python 呼叫約定的函式。該函式將*不會*在呼叫期間釋放 "
"GIL。"

#: ../../library/ctypes.rst:1695
#, fuzzy
msgid ""
"Function prototypes created by these factory functions can be instantiated "
"in different ways, depending on the type and number of the parameters in the "
"call:"
msgstr ""
"由這些工廠函式建立的函式原型可以以不同的方式實例化，具體取決於呼叫中參數的型"
"別和數量："

#: ../../library/ctypes.rst:1703
#, fuzzy
msgid ""
"Returns a foreign function at the specified address which must be an integer."
msgstr "回傳指定地址的外部函式，該地址必須是整數。"

#: ../../library/ctypes.rst:1710
#, fuzzy
msgid ""
"Create a C callable function (a callback function) from a Python *callable*."
msgstr "從 Python *callable* 建立 C 可呼叫函式（回呼函式）。"

#: ../../library/ctypes.rst:1717
#, fuzzy
msgid ""
"Returns a foreign function exported by a shared library. *func_spec* must be "
"a 2-tuple ``(name_or_ordinal, library)``. The first item is the name of the "
"exported function as string, or the ordinal of the exported function as "
"small integer.  The second item is the shared library instance."
msgstr ""
"回傳由共享庫導出的外部函式。 *func_spec* 必須是二元組``(name_or_ordinal, "
"library)``。第一項是導出函式的名稱（字串），或導出函式的序號（小整數）。第二"
"項是共享庫實例。"

#: ../../library/ctypes.rst:1727
#, fuzzy
msgid ""
"Returns a foreign function that will call a COM method. *vtbl_index* is the "
"index into the virtual function table, a small non-negative integer. *name* "
"is name of the COM method. *iid* is an optional pointer to the interface "
"identifier which is used in extended error reporting."
msgstr ""
"回傳將呼叫 COM 方法的外部函式。 *vtbl_index* 是虛函式表的索引，一個小的非負整"
"數。 *name* 是 COM 方法的名稱。 *iid* 是一個可選的指標，指向用於擴充錯誤報告"
"的介面標識符。"

#: ../../library/ctypes.rst:1732
#, fuzzy
msgid ""
"COM methods use a special calling convention: They require a pointer to the "
"COM interface as first argument, in addition to those parameters that are "
"specified in the :attr:`argtypes` tuple."
msgstr ""
"COM 方法使用特殊的呼叫約定：除了在 :attr:`argtypes` 元組中指定的那些參數之"
"外，它們還需要一個指向 COM 介面的指標作為第一個參數。"

#: ../../library/ctypes.rst:1736
#, fuzzy
msgid ""
"The optional *paramflags* parameter creates foreign function wrappers with "
"much more functionality than the features described above."
msgstr "可選的 *paramflags* 參數建立外部函式包裝器，其功能比上述功能多得多。"

#: ../../library/ctypes.rst:1739
#, fuzzy
msgid "*paramflags* must be a tuple of the same length as :attr:`argtypes`."
msgstr "*paramflags* 必須是與 :attr:`argtypes` 長度相同的元組。"

#: ../../library/ctypes.rst:1741
#, fuzzy
msgid ""
"Each item in this tuple contains further information about a parameter, it "
"must be a tuple containing one, two, or three items."
msgstr ""
"此元組中的每一項都包含有關參數的更多資訊，它必須是包含一項、兩項或三項的元"
"組。"

#: ../../library/ctypes.rst:1744
#, fuzzy
msgid ""
"The first item is an integer containing a combination of direction flags for "
"the parameter:"
msgstr "第一項是一個整數，包含參數的方向旗標組合："

#: ../../library/ctypes.rst:1748
msgid "1"
msgstr "1"

#: ../../library/ctypes.rst:1748
#, fuzzy
msgid "Specifies an input parameter to the function."
msgstr "指定函式的輸入參數。"

#: ../../library/ctypes.rst:1751
msgid "2"
msgstr "2"

#: ../../library/ctypes.rst:1751
#, fuzzy
msgid "Output parameter.  The foreign function fills in a value."
msgstr "輸出參數。外部函式填充一個值。"

#: ../../library/ctypes.rst:1754
msgid "4"
msgstr "4"

#: ../../library/ctypes.rst:1754
#, fuzzy
msgid "Input parameter which defaults to the integer zero."
msgstr "預設為整數零的輸入參數。"

#: ../../library/ctypes.rst:1756
#, fuzzy
msgid ""
"The optional second item is the parameter name as string.  If this is "
"specified, the foreign function can be called with named parameters."
msgstr ""
"可選的第二項是作為字串的參數名稱。如果指定，則可以使用命名參數呼叫外部函式。"

#: ../../library/ctypes.rst:1759
#, fuzzy
msgid "The optional third item is the default value for this parameter."
msgstr "可選的第三項是該參數的預設值。"

#: ../../library/ctypes.rst:1761
#, fuzzy
msgid ""
"This example demonstrates how to wrap the Windows ``MessageBoxW`` function "
"so that it supports default parameters and named arguments. The C "
"declaration from the windows header file is this::"
msgstr ""
"此示例演示如何包裝 Windows ``MessageBoxW`` 函式，使其支援預設參數和命名參"
"數。 Windows 標頭檔中的 C 聲明是這樣的："

#: ../../library/ctypes.rst:1772 ../../library/ctypes.rst:1795
#, fuzzy
msgid "Here is the wrapping with :mod:`ctypes`::"
msgstr "這是 :mod:`ctypes`:: 的包裝："

#: ../../library/ctypes.rst:1780
#, fuzzy
msgid "The ``MessageBox`` foreign function can now be called in these ways::"
msgstr "``MessageBox`` 外部函式現在可以通過以下方式呼叫："

#: ../../library/ctypes.rst:1786
#, fuzzy
msgid ""
"A second example demonstrates output parameters.  The win32 "
"``GetWindowRect`` function retrieves the dimensions of a specified window by "
"copying them into ``RECT`` structure that the caller has to supply.  Here is "
"the C declaration::"
msgstr ""
"第二個示例演示了輸出參數。 win32 ``GetWindowRect`` 函式通過將指定窗口的尺寸複"
"製到呼叫者必須提供的 ``RECT`` 結構中來檢索它們。這是 C 聲明::"

#: ../../library/ctypes.rst:1804
#, fuzzy
msgid ""
"Functions with output parameters will automatically return the output "
"parameter value if there is a single one, or a tuple containing the output "
"parameter values when there are more than one, so the GetWindowRect function "
"now returns a RECT instance, when called."
msgstr ""
"具有輸出參數的函式將自動回傳輸出參數值（如果有單個輸出參數值）或包含輸出參數"
"值的元組（當有多個時），因此 GetWindowRect 函式現在在呼叫時回傳一個 RECT 實"
"例。"

#: ../../library/ctypes.rst:1809
#, fuzzy
msgid ""
"Output parameters can be combined with the :attr:`errcheck` protocol to do "
"further output processing and error checking.  The win32 ``GetWindowRect`` "
"api function returns a ``BOOL`` to signal success or failure, so this "
"function could do the error checking, and raises an exception when the api "
"call failed::"
msgstr ""
"輸出參數可以結合 :attr:`errcheck` 協定做進一步的輸出處理和錯誤檢查。 win32 "
"``GetWindowRect`` api 函式回傳一個 ``BOOL`` 來表示成功或失敗，因此該函式可以"
"進行錯誤檢查，並在 api 呼叫失敗時引發例外："

#: ../../library/ctypes.rst:1822
#, fuzzy
msgid ""
"If the :attr:`errcheck` function returns the argument tuple it receives "
"unchanged, :mod:`ctypes` continues the normal processing it does on the "
"output parameters.  If you want to return a tuple of window coordinates "
"instead of a ``RECT`` instance, you can retrieve the fields in the function "
"and return them instead, the normal processing will no longer take place::"
msgstr ""
"如果 :attr:`errcheck` 函式回傳它接收到的參數元組不變，:mod:`ctypes` 繼續它對"
"輸出參數所做的正常處理。如果你想回傳一個窗口坐標元組而不是一個 RECT 實例，你"
"可以檢索函式中的欄位並回傳它們，正常處理將不再發生::"

#: ../../library/ctypes.rst:1841
#, fuzzy
msgid "Utility functions"
msgstr "效用函式"

#: ../../library/ctypes.rst:1845
#, fuzzy
msgid ""
"Returns the address of the memory buffer as integer.  *obj* must be an "
"instance of a ctypes type."
msgstr "以整數形式回傳記憶體緩衝區的地址。 *obj* 必須是 ctypes 型別的實例。"

#: ../../library/ctypes.rst:1848
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.addressof`` with "
"argument ``obj``."
msgstr ""
"引發一個附帶引數 ``obj`` 的\\ :ref:`稽核事件 <auditing>` ``ctypes."
"addressof``。"

#: ../../library/ctypes.rst:1853
#, fuzzy
msgid ""
"Returns the alignment requirements of a ctypes type. *obj_or_type* must be a "
"ctypes type or instance."
msgstr "回傳 ctypes 型別的對齊要求。 *obj_or_type* 必須是 ctypes 型別或實例。"

#: ../../library/ctypes.rst:1859
#, fuzzy
msgid ""
"Returns a light-weight pointer to *obj*, which must be an instance of a "
"ctypes type.  *offset* defaults to zero, and must be an integer that will be "
"added to the internal pointer value."
msgstr ""
"回傳指向 *obj* 的輕量級指標，它必須是 ctypes 型別的實例。 *offset* 預設為零，"
"並且必須是將新增到內部指標值的整數。"

#: ../../library/ctypes.rst:1863
#, fuzzy
msgid "``byref(obj, offset)`` corresponds to this C code::"
msgstr "``byref(obj, offset)`` 對應於這個 C 程式碼::"

#: ../../library/ctypes.rst:1867
#, fuzzy
msgid ""
"The returned object can only be used as a foreign function call parameter. "
"It behaves similar to ``pointer(obj)``, but the construction is a lot faster."
msgstr ""
"回傳的對像只能作為外部函式呼叫的參數。它的行為類似於``pointer(obj)``，但構造"
"要快得多。"

#: ../../library/ctypes.rst:1873
#, fuzzy
msgid ""
"This function is similar to the cast operator in C. It returns a new "
"instance of *type* which points to the same memory block as *obj*.  *type* "
"must be a pointer type, and *obj* must be an object that can be interpreted "
"as a pointer."
msgstr ""
"這個函式類似於 C 中的 cast 運算符。它回傳一個新的 *type* 實例，它指向與 "
"*obj* 相同的記憶體塊。 *type* 必須是指標型別，*obj* 必須是可以解釋為指標的物"
"件。"

#: ../../library/ctypes.rst:1881
#, fuzzy
msgid ""
"This function creates a mutable character buffer. The returned object is a "
"ctypes array of :class:`c_char`."
msgstr ""
"此函式建立一個可變字元緩衝區。回傳的對像是 :class:`c_char` 的 ctypes 數組。"

#: ../../library/ctypes.rst:1884
#, fuzzy
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, or "
"a bytes object which will be used to initialize the array items."
msgstr ""
"*init_or_size* 必須是指定數組大小的整數，或將用於初始化數組項的位元組物件。"

#: ../../library/ctypes.rst:1887
#, fuzzy
msgid ""
"If a bytes object is specified as first argument, the buffer is made one "
"item larger than its length so that the last element in the array is a NUL "
"termination character. An integer can be passed as second argument which "
"allows specifying the size of the array if the length of the bytes should "
"not be used."
msgstr ""
"如果將位元組物件指定為第一個參數，則緩衝區會比其長度大一個項目，以便數組中的"
"最後一個元素是 NUL 終止字元。一個整數可以作為第二個參數傳遞，如果不應該使用位"
"元組的長度，它允許指定數組的大小。"

#: ../../library/ctypes.rst:1892
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.create_string_buffer`` "
"with arguments ``init``, ``size``."
msgstr ""
"引發一個附帶引數 ``init`` 與 ``size`` 的\\ :ref:`稽核事件 <auditing>` "
"``ctypes.create_string_buffer``。"

#: ../../library/ctypes.rst:1897
#, fuzzy
msgid ""
"This function creates a mutable unicode character buffer. The returned "
"object is a ctypes array of :class:`c_wchar`."
msgstr ""
"此函式建立一個可變的 unicode 字元緩衝區。回傳的對像是 :class:`c_wchar` 的 "
"ctypes 數組。"

#: ../../library/ctypes.rst:1900
#, fuzzy
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, or "
"a string which will be used to initialize the array items."
msgstr ""
"*init_or_size* 必須是指定數組大小的整數，或者是將用於初始化數組項的字串。"

#: ../../library/ctypes.rst:1903
#, fuzzy
msgid ""
"If a string is specified as first argument, the buffer is made one item "
"larger than the length of the string so that the last element in the array "
"is a NUL termination character. An integer can be passed as second argument "
"which allows specifying the size of the array if the length of the string "
"should not be used."
msgstr ""
"如果將字串指定為第一個參數，則緩衝區中的一項比字串的長度大，以便數組中的最後"
"一個元素是 NUL 終止字元。如果不應使用字串的長度，則可以將整數作為第二個參數傳"
"遞，它允許指定數組的大小。"

#: ../../library/ctypes.rst:1909
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.create_unicode_buffer`` "
"with arguments ``init``, ``size``."
msgstr ""
"引發一個附帶引數 ``init`` 與 ``size`` 的\\ :ref:`稽核事件 <auditing>` "
"``ctypes.create_unicode_buffer``。"

#: ../../library/ctypes.rst:1914
#, fuzzy
msgid ""
"Windows only: This function is a hook which allows implementing in-process "
"COM servers with ctypes.  It is called from the DllCanUnloadNow function "
"that the _ctypes extension dll exports."
msgstr ""
"僅限 Windows：此函式是一個掛鉤，允許使用 ctypes 實作行程內 COM 伺服器。它是"
"從 _ctypes 擴充 dll 導出的 DllCanUnloadNow 函式呼叫的。"

#: ../../library/ctypes.rst:1921
#, fuzzy
msgid ""
"Windows only: This function is a hook which allows implementing in-process "
"COM servers with ctypes.  It is called from the DllGetClassObject function "
"that the ``_ctypes`` extension dll exports."
msgstr ""
"僅限 Windows：此函式是一個掛鉤，允許使用 ctypes 實作行程內 COM 伺服器。它是"
"從“_ctypes”擴充 dll 導出的 DllGetClassObject 函式呼叫的。"

#: ../../library/ctypes.rst:1929
#, fuzzy
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like ``lib``, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""
"嘗試查找庫並回傳路徑名。 *name* 是沒有任何前綴的庫名稱，如 ``lib``，後綴如 "
"``.so``，``.dylib`` 或版本號（這是用於 posix 鏈接器選項的形式 :option:` ！-"
"l`）。如果找不到庫，則回傳 ``None`` 。"

#: ../../library/ctypes.rst:1940
#, fuzzy
msgid ""
"Windows only: return the filename of the VC runtime library used by Python, "
"and by the extension modules.  If the name of the library cannot be "
"determined, ``None`` is returned."
msgstr ""
"僅限 Windows：回傳 Python 和擴充模組使用的 VC 運行時庫的文件名。如果無法確定"
"庫的名稱，則回傳 ``None`` 。"

#: ../../library/ctypes.rst:1944
#, fuzzy
msgid ""
"If you need to free memory, for example, allocated by an extension module "
"with a call to the ``free(void *)``, it is important that you use the "
"function in the same library that allocated the memory."
msgstr ""
"如果您需要釋放記憶體，例如，通過呼叫 ``free(void *)`` 的擴充模組分配的記憶"
"體，請務必在分配記憶體的同一庫中使用該函式。"

#: ../../library/ctypes.rst:1951
#, fuzzy
msgid ""
"Windows only: Returns a textual description of the error code *code*.  If no "
"error code is specified, the last error code is used by calling the Windows "
"api function GetLastError."
msgstr ""
"僅限 Windows：回傳錯誤程式碼 *code* 的文本描述。如果未指定錯誤程式碼，則通過"
"呼叫 Windows api 函式 GetLastError 使用最後一個錯誤程式碼。"

#: ../../library/ctypes.rst:1958
#, fuzzy
msgid ""
"Windows only: Returns the last error code set by Windows in the calling "
"thread. This function calls the Windows ``GetLastError()`` function "
"directly, it does not return the ctypes-private copy of the error code."
msgstr ""
"僅限 Windows：回傳 Windows 在呼叫執行緒中設定的最後一個錯誤程式碼。此函式直接"
"呼叫 Windows ``GetLastError()`` 函式，它不回傳錯誤程式碼的 ctypes-private 副"
"本。"

#: ../../library/ctypes.rst:1964
#, fuzzy
msgid ""
"Returns the current value of the ctypes-private copy of the system :data:"
"`errno` variable in the calling thread."
msgstr ""
"回傳呼叫執行緒中系統 :data:`errno` 變數的 ctypes-private 副本的當前值。"

#: ../../library/ctypes.rst:1967
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.get_errno`` with no "
"arguments."
msgstr ""
"引發一個不附帶引數的\\ :ref:`稽核事件 <auditing>` ``ctypes.get_errno``。"

#: ../../library/ctypes.rst:1971
#, fuzzy
msgid ""
"Windows only: returns the current value of the ctypes-private copy of the "
"system :data:`LastError` variable in the calling thread."
msgstr ""
"僅限 Windows：回傳呼叫執行緒中系統 :data:`LastError` 變數的 ctypes-private 副"
"本的當前值。"

#: ../../library/ctypes.rst:1974
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.get_last_error`` with no "
"arguments."
msgstr ""
"引發一個不附帶引數的\\ :ref:`稽核事件 <auditing>` ``ctypes.get_last_error``。"

#: ../../library/ctypes.rst:1978
#, fuzzy
msgid ""
"Same as the standard C memmove library function: copies *count* bytes from "
"*src* to *dst*. *dst* and *src* must be integers or ctypes instances that "
"can be converted to pointers."
msgstr ""
"與標準 C memmove 庫函式相同：將 *count* 個位元組從 *src* 複製到 *dst*。 "
"*dst* 和 *src* 必須是可以轉換為指標的整數或 ctypes 實例。"

#: ../../library/ctypes.rst:1985
#, fuzzy
msgid ""
"Same as the standard C memset library function: fills the memory block at "
"address *dst* with *count* bytes of value *c*. *dst* must be an integer "
"specifying an address, or a ctypes instance."
msgstr ""
"與標準 C memset 庫函式相同：用值 *c* 的 *count* 個位元組填充地址 *dst* 處的記"
"憶體塊。 *dst* 必須是指定地址的整數或 ctypes 實例。"

#: ../../library/ctypes.rst:1992
#, fuzzy
msgid ""
"This factory function creates and returns a new ctypes pointer type. Pointer "
"types are cached and reused internally, so calling this function repeatedly "
"is cheap. *type* must be a ctypes type."
msgstr ""
"這個工廠函式建立並回傳一個新的 ctypes 指標型別。指標型別在內部被快取和重用，"
"所以重複呼叫這個函式是很便宜的。 *type* 必須是 ctypes 型別。"

#: ../../library/ctypes.rst:1999
#, fuzzy
msgid ""
"This function creates a new pointer instance, pointing to *obj*. The "
"returned object is of the type ``POINTER(type(obj))``."
msgstr ""
"此函式建立一個新的指標實例，指向 *obj*。回傳的對像是 ``POINTER(type(obj))`` "
"型別。"

#: ../../library/ctypes.rst:2002
#, fuzzy
msgid ""
"Note: If you just want to pass a pointer to an object to a foreign function "
"call, you should use ``byref(obj)`` which is much faster."
msgstr ""
"注意：如果你只是想將一個指向物件的指標傳遞給外部函式呼叫，你應該使用更快的 "
"``byref(obj)``。"

#: ../../library/ctypes.rst:2008
#, fuzzy
msgid ""
"This function resizes the internal memory buffer of *obj*, which must be an "
"instance of a ctypes type.  It is not possible to make the buffer smaller "
"than the native size of the objects type, as given by ``sizeof(type(obj))``, "
"but it is possible to enlarge the buffer."
msgstr ""
"此函式調整 *obj* 的內部記憶體緩衝區的大小，它必須是 ctypes 型別的實例。不可能"
"使緩衝區小於對像型別的本機大小，如 ``sizeof(type(obj))`` 所給出的，但可以擴大"
"緩衝區。"

#: ../../library/ctypes.rst:2016
#, fuzzy
msgid ""
"Set the current value of the ctypes-private copy of the system :data:`errno` "
"variable in the calling thread to *value* and return the previous value."
msgstr ""
"將呼叫執行緒中系統 :data:`errno` 變數的 ctypes-private 副本的當前值設定為 "
"*value* 並回傳之前的值。"

#: ../../library/ctypes.rst:2019
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.set_errno`` with "
"argument ``errno``."
msgstr ""
"引發一個附帶引數 ``errno`` 的\\ :ref:`稽核事件 <auditing>` ``ctypes."
"set_errno``。"

#: ../../library/ctypes.rst:2024
#, fuzzy
msgid ""
"Windows only: set the current value of the ctypes-private copy of the "
"system :data:`LastError` variable in the calling thread to *value* and "
"return the previous value."
msgstr ""
"僅限 Windows：將呼叫執行緒中系統 :data:`LastError` 變數的 ctypes-private 副本"
"的當前值設定為 *value* 並回傳先前的值。"

#: ../../library/ctypes.rst:2028
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.set_last_error`` with "
"argument ``error``."
msgstr ""
"引發一個附帶引數 ``error`` 的\\ :ref:`稽核事件 <auditing>` ``ctypes."
"get_last_error``。"

#: ../../library/ctypes.rst:2033
#, fuzzy
msgid ""
"Returns the size in bytes of a ctypes type or instance memory buffer. Does "
"the same as the C ``sizeof`` operator."
msgstr ""
"回傳 ctypes 型別或實例記憶體緩衝區的位元組大小。與 C ``sizeof`` 運算符相同。"

#: ../../library/ctypes.rst:2039
#, fuzzy
msgid ""
"This function returns the C string starting at memory address *address* as a "
"bytes object. If size is specified, it is used as size, otherwise the string "
"is assumed to be zero-terminated."
msgstr ""
"此函式回傳從記憶體地址 *address* 開始的 C 字串作為位元組物件。如果指定了大"
"小，則將其用作大小，否則假定字串以零結尾。"

#: ../../library/ctypes.rst:2043
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.string_at`` with "
"arguments ``address``, ``size``."
msgstr ""
"引發一個附帶引數 ``error``、``size`` 的\\ :ref:`稽核事件 <auditing>` "
"``ctypes.string_at``。"

#: ../../library/ctypes.rst:2048
#, fuzzy
msgid ""
"Windows only: this function is probably the worst-named thing in ctypes. It "
"creates an instance of OSError.  If *code* is not specified, "
"``GetLastError`` is called to determine the error code. If *descr* is not "
"specified, :func:`FormatError` is called to get a textual description of the "
"error."
msgstr ""
"僅限 Windows：這個函式可能是 ctypes 中最糟糕的名字。它建立了一個 OSError 的實"
"例。如果未指定 *code*，則呼叫 ``GetLastError`` 以確定錯誤程式碼。如果未指定 "
"*descr*，則呼叫 :func:`FormatError` 以獲取錯誤的文本描述。"

#: ../../library/ctypes.rst:2054
#, fuzzy
msgid "An instance of :exc:`WindowsError` used to be created."
msgstr ":exc:`WindowsError` 的一個實例曾經被建立。"

#: ../../library/ctypes.rst:2060
#, fuzzy
msgid ""
"This function returns the wide character string starting at memory address "
"*address* as a string.  If *size* is specified, it is used as the number of "
"characters of the string, otherwise the string is assumed to be zero-"
"terminated."
msgstr ""
"此函式回傳從記憶體地址 *address* 開始的寬字串作為字串。如果指定了 *size*，它"
"將用作字串的字元數，否則假定字串以零結尾。"

#: ../../library/ctypes.rst:2065
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.wstring_at`` with "
"arguments ``address``, ``size``."
msgstr ""
"引發一個附帶引數 ``address``、``size`` 的\\ :ref:`稽核事件 <auditing>` "
"``ctypes.wstring_at``。"

#: ../../library/ctypes.rst:2071
#, fuzzy
msgid "Data types"
msgstr "資料型別"

#: ../../library/ctypes.rst:2076
#, fuzzy
msgid ""
"This non-public class is the common base class of all ctypes data types. "
"Among other things, all ctypes type instances contain a memory block that "
"hold C compatible data; the address of the memory block is returned by the :"
"func:`addressof` helper function. Another instance variable is exposed as :"
"attr:`_objects`; this contains other Python objects that need to be kept "
"alive in case the memory block contains pointers."
msgstr ""
"這個非公開類是所有 ctypes 資料型別的公開基底類別。除此之外，所有 ctypes 型別"
"實例都包含一個儲存 C 相容資料的記憶體塊；記憶體塊的地址由 :func:`addressof` "
"輔助函式回傳。另一個實例變數公開為 :attr:`_objects`;這包含其他需要保持活動狀"
"態的 Python 物件，以防記憶體塊包含指標。"

#: ../../library/ctypes.rst:2083
#, fuzzy
msgid ""
"Common methods of ctypes data types, these are all class methods (to be "
"exact, they are methods of the :term:`metaclass`):"
msgstr ""
"ctypes資料型別的常用方法，這些都是類方法（準確的說是 :term:`metaclass`的方"
"法）："

#: ../../library/ctypes.rst:2088
#, fuzzy
msgid ""
"This method returns a ctypes instance that shares the buffer of the *source* "
"object.  The *source* object must support the writeable buffer interface.  "
"The optional *offset* parameter specifies an offset into the source buffer "
"in bytes; the default is zero.  If the source buffer is not large enough a :"
"exc:`ValueError` is raised."
msgstr ""
"此方法回傳一個共享 *source* 物件緩衝區的 ctypes 實例。 *source* 物件必須支援"
"可寫緩衝區介面。可選的 *offset* 參數以位元組為單位指定源緩衝區的偏移量；預設"
"值為零。如果源緩衝區不夠大，則會引發 :exc:`ValueError`。"

#: ../../library/ctypes.rst:2094 ../../library/ctypes.rst:2104
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.cdata/buffer`` with "
"arguments ``pointer``, ``size``, ``offset``."
msgstr ""
"引發一個附帶引數 ``pointer``、``size``、``offset`` 的\\ :ref:`稽核事件 "
"<auditing>` ``ctypes.cdata/buffer``。"

#: ../../library/ctypes.rst:2098
#, fuzzy
msgid ""
"This method creates a ctypes instance, copying the buffer from the *source* "
"object buffer which must be readable.  The optional *offset* parameter "
"specifies an offset into the source buffer in bytes; the default is zero.  "
"If the source buffer is not large enough a :exc:`ValueError` is raised."
msgstr ""
"此方法建立一個 ctypes 實例，從必須可讀的 *source* 物件緩衝區復制緩衝區。可選"
"的 *offset* 參數以位元組為單位指定源緩衝區的偏移量；預設值為零。如果源緩衝區"
"不夠大，則會引發 :exc:`ValueError`。"

#: ../../library/ctypes.rst:2108
#, fuzzy
msgid ""
"This method returns a ctypes type instance using the memory specified by "
"*address* which must be an integer."
msgstr ""
"此方法使用 *address* 指定的記憶體回傳一個 ctypes 型別實例，它必須是一個整數。"

#: ../../library/ctypes.rst:2111
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.cdata`` with argument "
"``address``."
msgstr ""
"引發一個附帶引數 ``address`` 的\\ :ref:`稽核事件 <auditing>` ``ctypes."
"cdata``。"

#: ../../library/ctypes.rst:2113
#, fuzzy
msgid ""
"This method, and others that indirectly call this method, raises an :ref:"
"`auditing event <auditing>` ``ctypes.cdata`` with argument ``address``."
msgstr ""
"此方法和其他間接呼叫此方法的方法引發一個 :ref:`auditing 事件 <auditing>` "
"``ctypes.cdata`` 參數為 ``address``。"

#: ../../library/ctypes.rst:2119
#, fuzzy
msgid ""
"This method adapts *obj* to a ctypes type.  It is called with the actual "
"object used in a foreign function call when the type is present in the "
"foreign function's :attr:`argtypes` tuple; it must return an object that can "
"be used as a function call parameter."
msgstr ""
"此方法使 *obj* 適應 ctypes 型別。當外部函式的 :attr:`argtypes` 元組中存在型別"
"時，使用外部函式呼叫中使用的實際物件呼叫它；它必須回傳一個可以用作函式呼叫參"
"數的物件。"

#: ../../library/ctypes.rst:2124
#, fuzzy
msgid ""
"All ctypes data types have a default implementation of this classmethod that "
"normally returns *obj* if that is an instance of the type.  Some types "
"accept other objects as well."
msgstr ""
"所有 ctypes 資料型別都有此類方法的預設實作，如果它是該型別的實例，則通常回傳 "
"*obj* 。有些型別也接受其他物件。"

#: ../../library/ctypes.rst:2130
#, fuzzy
msgid ""
"This method returns a ctypes type instance exported by a shared library. "
"*name* is the name of the symbol that exports the data, *library* is the "
"loaded shared library."
msgstr ""
"此方法回傳共享庫導出的 ctypes 型別實例。 *name* 是導出資料的符號名稱，"
"*library* 是加載的共享庫。"

#: ../../library/ctypes.rst:2134
#, fuzzy
msgid "Common instance variables of ctypes data types:"
msgstr "ctypes資料型別的常用實例變數："

#: ../../library/ctypes.rst:2138
#, fuzzy
msgid ""
"Sometimes ctypes data instances do not own the memory block they contain, "
"instead they share part of the memory block of a base object.  The :attr:"
"`_b_base_` read-only member is the root ctypes object that owns the memory "
"block."
msgstr ""
"有時 ctypes 資料實例不擁有它們包含的記憶體塊，而是共享基礎物件的部分記憶體"
"塊。 :attr:`_b_base_` 只讀成員是擁有記憶體塊的根 ctypes 物件。"

#: ../../library/ctypes.rst:2145
#, fuzzy
msgid ""
"This read-only variable is true when the ctypes data instance has allocated "
"the memory block itself, false otherwise."
msgstr "當 ctypes 資料實例自己分配了記憶體塊時，此只讀變數為真，否則為假。"

#: ../../library/ctypes.rst:2150
#, fuzzy
msgid ""
"This member is either ``None`` or a dictionary containing Python objects "
"that need to be kept alive so that the memory block contents is kept valid.  "
"This object is only exposed for debugging; never modify the contents of this "
"dictionary."
msgstr ""
"該成員是 ``None`` 或包含需要保持活動狀態的 Python 物件的字典，以便記憶體塊內容保持"
"有效。該物件僅用於除錯；永遠不要修改這本詞典的內容。"

#: ../../library/ctypes.rst:2163
#, fuzzy
msgid ""
"This non-public class is the base class of all fundamental ctypes data "
"types. It is mentioned here because it contains the common attributes of the "
"fundamental ctypes data types.  :class:`_SimpleCData` is a subclass of :"
"class:`_CData`, so it inherits their methods and attributes. ctypes data "
"types that are not and do not contain pointers can now be pickled."
msgstr ""
"這個非公開類是所有基本 ctypes 資料型別的基底類別。這裡提到它是因為它包含基本 "
"ctypes 資料型別的公開屬性。 :class:`_SimpleCData` 是 :class:`_CData` 的子類"
"別，因此它繼承了它們的方法和屬性。現在可以 pickle 不包含也不包含指標的 "
"ctypes 資料型別。"

#: ../../library/ctypes.rst:2169
#, fuzzy
msgid "Instances have a single attribute:"
msgstr "實例有一個屬性："

#: ../../library/ctypes.rst:2173
#, fuzzy
msgid ""
"This attribute contains the actual value of the instance. For integer and "
"pointer types, it is an integer, for character types, it is a single "
"character bytes object or string, for character pointer types it is a Python "
"bytes object or string."
msgstr ""
"該屬性包含實例的實際值。對於整數和指標型別，它是一個整數，對於字元型別，它是"
"一個單字元位元組對像或字串，對於字元指標型別，它是一個 Python 位元組對像或字"
"串。"

#: ../../library/ctypes.rst:2178
#, fuzzy
msgid ""
"When the ``value`` attribute is retrieved from a ctypes instance, usually a "
"new object is returned each time.  :mod:`ctypes` does *not* implement "
"original object return, always a new object is constructed.  The same is "
"true for all other ctypes object instances."
msgstr ""
"當從 ctypes 實例中檢索 ``value`` 屬性時，通常每次都會回傳一個新物件。 :mod:"
"`ctypes` *不* 實作原始物件回傳，總是構造一個新物件。所有其他 ctypes 物件實例"
"也是如此。"

#: ../../library/ctypes.rst:2184
#, fuzzy
msgid ""
"Fundamental data types, when returned as foreign function call results, or, "
"for example, by retrieving structure field members or array items, are "
"transparently converted to native Python types.  In other words, if a "
"foreign function has a :attr:`restype` of :class:`c_char_p`, you will always "
"receive a Python bytes object, *not* a :class:`c_char_p` instance."
msgstr ""
"基本資料型別，當作為外部函式呼叫結果回傳時，或者，例如，通過檢索結構欄位成員"
"或數組項，被透明地轉換為本機 Python 型別。換句話說，如果外部函式的 :attr:"
"`restype` 為 :class:`c_char_p`，您將始終收到一個 Python 位元組物件，*不是* :"
"class:`c_char_p` 實例。"

#: ../../library/ctypes.rst:2192
#, fuzzy
msgid ""
"Subclasses of fundamental data types do *not* inherit this behavior. So, if "
"a foreign functions :attr:`restype` is a subclass of :class:`c_void_p`, you "
"will receive an instance of this subclass from the function call. Of course, "
"you can get the value of the pointer by accessing the ``value`` attribute."
msgstr ""
"基本資料型別的子類別 *不* 繼承此行為。因此，如果外部函式 :attr:`restype` 是 :"
"class:`c_void_p` 的子類別，您將從函式呼叫中接收到該子類別的實例。當然，您可以"
"通過訪問 ``value``屬性來獲取指標的值。"

#: ../../library/ctypes.rst:2197
#, fuzzy
msgid "These are the fundamental ctypes data types:"
msgstr "這些是基本的 ctypes 資料型別："

#: ../../library/ctypes.rst:2201
#, fuzzy
msgid ""
"Represents the C :c:expr:`signed char` datatype, and interprets the value as "
"small integer.  The constructor accepts an optional integer initializer; no "
"overflow checking is done."
msgstr ""
"表示 C:c:expr:`signed char` 資料型別，並將值解釋為小整數。構造函式接受一個可"
"選的整數初始值設定項；沒有進行溢出檢查。"

#: ../../library/ctypes.rst:2208
#, fuzzy
msgid ""
"Represents the C :c:expr:`char` datatype, and interprets the value as a "
"single character.  The constructor accepts an optional string initializer, "
"the length of the string must be exactly one character."
msgstr ""
"表示 C :c:expr:`char` 資料型別，並將值解釋為單個字元。構造函式接受一個可選的"
"字串初始值設定項，字串的長度必須正好是一個字元。"

#: ../../library/ctypes.rst:2215
#, fuzzy
msgid ""
"Represents the C :c:expr:`char *` datatype when it points to a zero-"
"terminated string.  For a general character pointer that may also point to "
"binary data, ``POINTER(c_char)`` must be used.  The constructor accepts an "
"integer address, or a bytes object."
msgstr ""
"當指向零終止字串時表示 C:c:expr:`char *` 資料型別。對於也可能指向二進位資料的"
"通用字元指標，必須使用 ``POINTER(c_char)``。構造函式接受整數地址或位元組物"
"件。"

#: ../../library/ctypes.rst:2223
#, fuzzy
msgid ""
"Represents the C :c:expr:`double` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""
"表示 C :c:expr:`double` 資料型別。構造函式接受一個可選的浮點初始值設定項。"

#: ../../library/ctypes.rst:2229
#, fuzzy
msgid ""
"Represents the C :c:expr:`long double` datatype.  The constructor accepts an "
"optional float initializer.  On platforms where ``sizeof(long double) == "
"sizeof(double)`` it is an alias to :class:`c_double`."
msgstr ""
"表示 C:c:expr:`long double` 資料型別。構造函式接受一個可選的浮點初始值設定"
"項。在 ``sizeof(long double) == sizeof(double)`` 的平台上，它是 :class:"
"`c_double` 的別名。"

#: ../../library/ctypes.rst:2235
#, fuzzy
msgid ""
"Represents the C :c:expr:`float` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""
"表示 C :c:expr:`float` 資料型別。構造函式接受一個可選的浮點初始值設定項。"

#: ../../library/ctypes.rst:2241
#, fuzzy
msgid ""
"Represents the C :c:expr:`signed int` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias to :class:`c_long`."
msgstr ""
"表示 C:c:expr:`signed int` 資料型別。構造函式接受一個可選的整數初始值設定項；"
"沒有進行溢出檢查。在 ``sizeof(int) == sizeof(long)`` 的平台上，它是 :class:"
"`c_long` 的別名。"

#: ../../library/ctypes.rst:2248
#, fuzzy
msgid ""
"Represents the C 8-bit :c:expr:`signed int` datatype.  Usually an alias for :"
"class:`c_byte`."
msgstr ""
"表示 C 8 位 :c:expr:`signed int` 資料型別。通常是 :class:`c_byte` 的別名。"

#: ../../library/ctypes.rst:2254
#, fuzzy
msgid ""
"Represents the C 16-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_short`."
msgstr ""
"表示 C 16 位 :c:expr:`signed int` 資料型別。通常是 :class:`c_short` 的別名。"

#: ../../library/ctypes.rst:2260
#, fuzzy
msgid ""
"Represents the C 32-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_int`."
msgstr ""
"表示 C 32 位 :c:expr:`signed int` 資料型別。通常是 :class:`c_int` 的別名。"

#: ../../library/ctypes.rst:2266
#, fuzzy
msgid ""
"Represents the C 64-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_longlong`."
msgstr ""
"表示 C 64 位 :c:expr:`signed int` 資料型別。通常是 :class:`c_longlong` 的別"
"名。"

#: ../../library/ctypes.rst:2272
#, fuzzy
msgid ""
"Represents the C :c:expr:`signed long` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done."
msgstr ""
"表示 C:c:expr:`signed long` 資料型別。構造函式接受一個可選的整數初始值設定"
"項；沒有進行溢出檢查。"

#: ../../library/ctypes.rst:2278
#, fuzzy
msgid ""
"Represents the C :c:expr:`signed long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"表示 C:c:expr:`signed long long` 資料型別。構造函式接受一個可選的整數初始值設"
"定項；沒有進行溢出檢查。"

#: ../../library/ctypes.rst:2284
#, fuzzy
msgid ""
"Represents the C :c:expr:`signed short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"表示 C:c:expr:`signed short` 資料型別。構造函式接受一個可選的整數初始值設定"
"項；沒有進行溢出檢查。"

#: ../../library/ctypes.rst:2290
#, fuzzy
msgid "Represents the C :c:type:`size_t` datatype."
msgstr "表示 C:c:type:`size_t` 資料型別。"

#: ../../library/ctypes.rst:2295
#, fuzzy
msgid "Represents the C :c:type:`ssize_t` datatype."
msgstr "表示 C:c:type:`ssize_t` 資料型別。"

#: ../../library/ctypes.rst:2302
#, fuzzy
msgid ""
"Represents the C :c:expr:`unsigned char` datatype, it interprets the value "
"as small integer.  The constructor accepts an optional integer initializer; "
"no overflow checking is done."
msgstr ""
"表示 C:c:expr:`unsigned char` 資料型別，它將值解釋為小整數。構造函式接受一個"
"可選的整數初始值設定項；沒有進行溢出檢查。"

#: ../../library/ctypes.rst:2309
#, fuzzy
msgid ""
"Represents the C :c:expr:`unsigned int` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias for :class:`c_ulong`."
msgstr ""
"表示 C:c:expr:`unsigned int` 資料型別。構造函式接受一個可選的整數初始值設定"
"項；沒有進行溢出檢查。在 ``sizeof(int) == sizeof(long)`` 的平台上，它是 :"
"class:`c_ulong` 的別名。"

#: ../../library/ctypes.rst:2316
#, fuzzy
msgid ""
"Represents the C 8-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ubyte`."
msgstr ""
"表示 C 8 位 :c:expr:`unsigned int` 資料型別。通常是 :class:`c_ubyte` 的別名。"

#: ../../library/ctypes.rst:2322
#, fuzzy
msgid ""
"Represents the C 16-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ushort`."
msgstr ""
"表示 C 16 位 :c:expr:`unsigned int` 資料型別。通常是 :class:`c_ushort` 的別"
"名。"

#: ../../library/ctypes.rst:2328
#, fuzzy
msgid ""
"Represents the C 32-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_uint`."
msgstr ""
"表示 C 32 位 :c:expr:`unsigned int` 資料型別。通常是 :class:`c_uint` 的別名。"

#: ../../library/ctypes.rst:2334
#, fuzzy
msgid ""
"Represents the C 64-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ulonglong`."
msgstr ""
"表示 C 64 位 :c:expr:`unsigned int` 資料型別。通常是 :class:`c_ulonglong` 的"
"別名。"

#: ../../library/ctypes.rst:2340
#, fuzzy
msgid ""
"Represents the C :c:expr:`unsigned long` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"表示 C:c:expr:`unsigned long` 資料型別。構造函式接受一個可選的整數初始值設定"
"項；沒有進行溢出檢查。"

#: ../../library/ctypes.rst:2346
#, fuzzy
msgid ""
"Represents the C :c:expr:`unsigned long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"表示 C:c:expr:`unsigned long long` 資料型別。構造函式接受一個可選的整數初始值"
"設定項；沒有進行溢出檢查。"

#: ../../library/ctypes.rst:2352
#, fuzzy
msgid ""
"Represents the C :c:expr:`unsigned short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"表示 C:c:expr:`unsigned short` 資料型別。構造函式接受一個可選的整數初始值設定"
"項；沒有進行溢出檢查。"

#: ../../library/ctypes.rst:2358
#, fuzzy
msgid ""
"Represents the C :c:expr:`void *` type.  The value is represented as "
"integer. The constructor accepts an optional integer initializer."
msgstr ""
"表示 C :c:expr:`void *` 型別。該值表示為整數。構造函式接受一個可選的整數初始"
"值設定項。"

#: ../../library/ctypes.rst:2364
#, fuzzy
msgid ""
"Represents the C :c:expr:`wchar_t` datatype, and interprets the value as a "
"single character unicode string.  The constructor accepts an optional string "
"initializer, the length of the string must be exactly one character."
msgstr ""
"表示 C:c:expr:`wchar_t` 資料型別，並將該值解釋為單個字元 unicode 字串。構造函"
"式接受一個可選的字串初始值設定項，字串的長度必須正好是一個字元。"

#: ../../library/ctypes.rst:2371
#, fuzzy
msgid ""
"Represents the C :c:expr:`wchar_t *` datatype, which must be a pointer to a "
"zero-terminated wide character string.  The constructor accepts an integer "
"address, or a string."
msgstr ""
"表示 C:c:expr:`wchar_t *` 資料型別，它必須是指向以零終止的寬字串的指標。構造"
"函式接受整數地址或字串。"

#: ../../library/ctypes.rst:2378
#, fuzzy
msgid ""
"Represent the C :c:expr:`bool` datatype (more accurately, :c:expr:`_Bool` "
"from C99).  Its value can be ``True`` or ``False``, and the constructor "
"accepts any object that has a truth value."
msgstr ""
"表示 C :c:expr:`bool` 資料型別（更準確地說，來自 C99 的 :c:expr:`_Bool`）。它"
"的值可以是 ``True``或 ``False``，構造函式接受任何具有真值的物件。"

#: ../../library/ctypes.rst:2385
#, fuzzy
msgid ""
"Windows only: Represents a :c:type:`HRESULT` value, which contains success "
"or error information for a function or method call."
msgstr ""
"僅限 Windows：表示 :c:type:`HRESULT` 值，其中包含函式或方法呼叫的成功或錯誤資"
"訊。"

#: ../../library/ctypes.rst:2391
#, fuzzy
msgid ""
"Represents the C :c:expr:`PyObject *` datatype.  Calling this without an "
"argument creates a ``NULL`` :c:expr:`PyObject *` pointer."
msgstr ""
"表示 C:c:expr:`PyObject *` 資料型別。在沒有參數的情況下呼叫它會建立一個 "
"``NULL`` :c:expr:`PyObject *` 指標。"

#: ../../library/ctypes.rst:2394
#, fuzzy
msgid ""
"The :mod:`ctypes.wintypes` module provides quite some other Windows specific "
"data types, for example :c:type:`HWND`, :c:type:`WPARAM`, or :c:type:"
"`DWORD`.  Some useful structures like :c:type:`MSG` or :c:type:`RECT` are "
"also defined."
msgstr ""
":mod:`ctypes.wintypes` 模組提供了相當多的其他 Windows 特定資料型別，例如 :c:"
"type:`HWND`、:c:type:`WPARAM` 或:c:type:`DWORD`。還定義了一些有用的結構，如 :"
"c:type:`MSG` 或 :c:type:`RECT`。"

#: ../../library/ctypes.rst:2402
#, fuzzy
msgid "Structured data types"
msgstr "結構化資料型別"

#: ../../library/ctypes.rst:2407
#, fuzzy
msgid "Abstract base class for unions in native byte order."
msgstr "以本機位元組順序聯合的抽象基底類別。"

#: ../../library/ctypes.rst:2412
#, fuzzy
msgid "Abstract base class for unions in *big endian* byte order."
msgstr "*big endian* 位元組順序聯合的抽象基底類別。"

#: ../../library/ctypes.rst:2418
#, fuzzy
msgid "Abstract base class for unions in *little endian* byte order."
msgstr "*little endian* 位元組順序聯合的抽象基底類別。"

#: ../../library/ctypes.rst:2424
#, fuzzy
msgid "Abstract base class for structures in *big endian* byte order."
msgstr "*big endian* 位元組順序結構的抽象基底類別。"

#: ../../library/ctypes.rst:2429
#, fuzzy
msgid "Abstract base class for structures in *little endian* byte order."
msgstr "*little endian* 位元組順序結構的抽象基底類別。"

#: ../../library/ctypes.rst:2431
#, fuzzy
msgid ""
"Structures and unions with non-native byte order cannot contain pointer type "
"fields, or any other data types containing pointer type fields."
msgstr ""
"具有非本機位元組順序的結構和聯合不能包含指標型別欄位，或包含指標型別欄位的任"
"何其他資料型別。"

#: ../../library/ctypes.rst:2437
#, fuzzy
msgid "Abstract base class for structures in *native* byte order."
msgstr "*本機*位元組順序結構的抽象基底類別。"

#: ../../library/ctypes.rst:2439
#, fuzzy
msgid ""
"Concrete structure and union types must be created by subclassing one of "
"these types, and at least define a :attr:`_fields_` class variable. :mod:"
"`ctypes` will create :term:`descriptor`\\s which allow reading and writing "
"the fields by direct attribute accesses.  These are the"
msgstr ""
"具體結構和聯合型別必須通過子類別化這些型別之一來建立，並且至少定義一個 :attr:"
"`_fields_` 類變數。 :mod:`ctypes` 將建立 :term:`descriptor`\\s，它允許通過直"
"接屬性訪問來讀寫欄位。這些是"

#: ../../library/ctypes.rst:2447
#, fuzzy
msgid ""
"A sequence defining the structure fields.  The items must be 2-tuples or 3-"
"tuples.  The first item is the name of the field, the second item specifies "
"the type of the field; it can be any ctypes data type."
msgstr ""
"定義結構欄位的序列。這些項目必須是 2 元組或 3 元組。第一項是欄位的名稱，第二"
"項指定欄位的型別；它可以是任何 ctypes 資料型別。"

#: ../../library/ctypes.rst:2451
#, fuzzy
msgid ""
"For integer type fields like :class:`c_int`, a third optional item can be "
"given.  It must be a small positive integer defining the bit width of the "
"field."
msgstr ""
"對於像 c_int 這樣的整數型別欄位，可以給出第三個可選項目。它必須是定義欄位位寬"
"的小正整數。"

#: ../../library/ctypes.rst:2455
#, fuzzy
msgid ""
"Field names must be unique within one structure or union.  This is not "
"checked, only one field can be accessed when names are repeated."
msgstr ""
"欄位名稱在一個結構或聯合中必須是唯一的。不勾選，名字重複時只能訪問一個欄位。"

#: ../../library/ctypes.rst:2458
#, fuzzy
msgid ""
"It is possible to define the :attr:`_fields_` class variable *after* the "
"class statement that defines the Structure subclass, this allows creating "
"data types that directly or indirectly reference themselves::"
msgstr ""
"可以在定義 Structure 子類別的類語句之後*定義 :attr:`_fields_` 類變數，這允許"
"建立直接或間接引用自身的資料型別::"

#: ../../library/ctypes.rst:2468
#, fuzzy
msgid ""
"The :attr:`_fields_` class variable must, however, be defined before the "
"type is first used (an instance is created, :func:`sizeof` is called on it, "
"and so on).  Later assignments to the :attr:`_fields_` class variable will "
"raise an AttributeError."
msgstr ""
":attr:`_fields_` 類變數必須在首次使用該型別之前定義（建立一個實例，對其呼叫 :"
"func:`sizeof`，等等）。稍後對 :attr:`_fields_` 類變數的賦值將引發 "
"AttributeError。"

#: ../../library/ctypes.rst:2473
#, fuzzy
msgid ""
"It is possible to define sub-subclasses of structure types, they inherit the "
"fields of the base class plus the :attr:`_fields_` defined in the sub-"
"subclass, if any."
msgstr ""
"可以定義結構型別的子子類別，它們繼承基底類別的欄位加上子子類別中定義的 :attr:"
"`_fields_`，如果有的話。"

#: ../../library/ctypes.rst:2480
#, fuzzy
msgid ""
"An optional small integer that allows overriding the alignment of structure "
"fields in the instance.  :attr:`_pack_` must already be defined when :attr:"
"`_fields_` is assigned, otherwise it will have no effect."
msgstr ""
"一個可選的小整數，允許覆蓋實例中結構欄位的對齊方式。 :attr:`_pack_` 必須在分"
"配 :attr:`_fields_` 時已經定義，否則將無效。"

#: ../../library/ctypes.rst:2487
#, fuzzy
msgid ""
"An optional sequence that lists the names of unnamed (anonymous) fields. :"
"attr:`_anonymous_` must be already defined when :attr:`_fields_` is "
"assigned, otherwise it will have no effect."
msgstr ""
"列出未命名（匿名）欄位名稱的可選序列。 :attr:`_anonymous_` 必須在分配 :attr:"
"`_fields_` 時已經定義，否則將無效。"

#: ../../library/ctypes.rst:2491
#, fuzzy
msgid ""
"The fields listed in this variable must be structure or union type fields. :"
"mod:`ctypes` will create descriptors in the structure type that allows "
"accessing the nested fields directly, without the need to create the "
"structure or union field."
msgstr ""
"此變數中列出的欄位必須是結構或聯合型別欄位。 :mod:`ctypes` 將在允許直接訪問嵌"
"套欄位的結構型別中建立描述器，而無需建立結構或聯合欄位。"

#: ../../library/ctypes.rst:2496
#, fuzzy
msgid "Here is an example type (Windows)::"
msgstr "這是一個示例型別 (Windows)::"

#: ../../library/ctypes.rst:2509
#, fuzzy
msgid ""
"The ``TYPEDESC`` structure describes a COM data type, the ``vt`` field "
"specifies which one of the union fields is valid.  Since the ``u`` field is "
"defined as anonymous field, it is now possible to access the members "
"directly off the TYPEDESC instance. ``td.lptdesc`` and ``td.u.lptdesc`` are "
"equivalent, but the former is faster since it does not need to create a "
"temporary union instance::"
msgstr ""
"``TYPEDESC`` 結構描述了一種 COM 資料型別，``vt`` 欄位指定了哪個聯合欄位是有效"
"的。由於 ``u`` 欄位被定義為匿名欄位，現在可以直接從 TYPEDESC 實例訪問成員。 "
"``td.lptdesc`` 和 ``td.u.lptdesc`` 是等價的，但前者更快，因為它不需要建立臨時"
"聯合實例::"

#: ../../library/ctypes.rst:2521
#, fuzzy
msgid ""
"It is possible to define sub-subclasses of structures, they inherit the "
"fields of the base class.  If the subclass definition has a separate :attr:"
"`_fields_` variable, the fields specified in this are appended to the fields "
"of the base class."
msgstr ""
"可以定義結構的子子類別，它們繼承基底類別的欄位。如果子類別定義有一個單獨的 :"
"attr:`_fields_` 變數，則在此指定的欄位將附加到基底類別的欄位。"

#: ../../library/ctypes.rst:2526
#, fuzzy
msgid ""
"Structure and union constructors accept both positional and keyword "
"arguments.  Positional arguments are used to initialize member fields in the "
"same order as they are appear in :attr:`_fields_`.  Keyword arguments in the "
"constructor are interpreted as attribute assignments, so they will "
"initialize :attr:`_fields_` with the same name, or create new attributes for "
"names not present in :attr:`_fields_`."
msgstr ""
"結構和聯合構造函式接受位置參數和關鍵字參數。位置參數用於按照它們在 :attr:"
"`_fields_` 中出現的相同順序初始化成員欄位。構造函式中的關鍵字參數被解釋為屬性"
"賦值，因此它們將使用相同的名稱初始化 :attr:`_fields_`，或者為 :attr:"
"`_fields_` 中不存在的名稱建立新屬性。"

#: ../../library/ctypes.rst:2537
#, fuzzy
msgid "Arrays and pointers"
msgstr "數組和指標"

#: ../../library/ctypes.rst:2541
#, fuzzy
msgid "Abstract base class for arrays."
msgstr "數組的抽象基底類別。"

#: ../../library/ctypes.rst:2543
#, fuzzy
msgid ""
"The recommended way to create concrete array types is by multiplying any :"
"mod:`ctypes` data type with a non-negative integer.  Alternatively, you can "
"subclass this type and define :attr:`_length_` and :attr:`_type_` class "
"variables. Array elements can be read and written using standard subscript "
"and slice accesses; for slice reads, the resulting object is *not* itself "
"an :class:`Array`."
msgstr ""
"建立具體數組型別的推薦方法是將任何 :mod:`ctypes` 資料型別乘以一個非負整數。或"
"者，您可以子類別化此型別並定義 :attr:`_length_` 和 :attr:`_type_` 類變數。可"
"以使用標準下標和切片訪問來讀取和寫入數組元素；對於切片讀取，生成的物件*不是*"
"本身是一個數組。"

#: ../../library/ctypes.rst:2553
#, fuzzy
msgid ""
"A positive integer specifying the number of elements in the array. Out-of-"
"range subscripts result in an :exc:`IndexError`. Will be returned by :func:"
"`len`."
msgstr ""
"一個正整數，指定數組中的元素數。超出範圍的下標會導致 :exc:`IndexError`。將"
"由 :func:`len` 回傳。"

#: ../../library/ctypes.rst:2560
#, fuzzy
msgid "Specifies the type of each element in the array."
msgstr "指定數組中每個元素的型別。"

#: ../../library/ctypes.rst:2563
#, fuzzy
msgid ""
"Array subclass constructors accept positional arguments, used to initialize "
"the elements in order."
msgstr "數組子類別構造函式接受位置參數，用於按順序初始化元素。"

#: ../../library/ctypes.rst:2569
#, fuzzy
msgid "Private, abstract base class for pointers."
msgstr "指標的私有抽象基底類別。"

#: ../../library/ctypes.rst:2571
#, fuzzy
msgid ""
"Concrete pointer types are created by calling :func:`POINTER` with the type "
"that will be pointed to; this is done automatically by :func:`pointer`."
msgstr ""
"具體的指標型別是通過使用將要指向的型別呼叫 :function:`POINTER` 來建立的；這是"
"由 :func:`pointer` 自動完成的。"

#: ../../library/ctypes.rst:2575
#, fuzzy
msgid ""
"If a pointer points to an array, its elements can be read and written using "
"standard subscript and slice accesses.  Pointer objects have no size, so :"
"func:`len` will raise :exc:`TypeError`.  Negative subscripts will read from "
"the memory *before* the pointer (as in C), and out-of-range subscripts will "
"probably crash with an access violation (if you're lucky)."
msgstr ""
"如果指標指向數組，則可以使用標準下標和切片訪問來讀取和寫入其元素。指標對像沒"
"有大小，所以 :func:`len` 會引發 :exc:`TypeError`。負下標將在指標*之前*從記憶"
"體中讀取（如在 C 中），超出範圍的下標可能會因訪問衝突而崩潰（如果幸運的話）。"

#: ../../library/ctypes.rst:2585
#, fuzzy
msgid "Specifies the type pointed to."
msgstr "指定指向的型別。"

#: ../../library/ctypes.rst:2589
#, fuzzy
msgid ""
"Returns the object to which to pointer points.  Assigning to this attribute "
"changes the pointer to point to the assigned object."
msgstr "回傳指標指向的物件。分配給該屬性會將指標更改為指向分配的物件。"
