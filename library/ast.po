# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-15 20:43+0000\n"
"PO-Revision-Date: 2018-05-23 14:38+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/ast.rst:2
msgid ":mod:`ast` --- Abstract Syntax Trees"
msgstr ":mod:`ast` --- 抽象語法樹"

#: ../../library/ast.rst:14
msgid "**Source code:** :source:`Lib/ast.py`"
msgstr "**原始碼：**\\ :source:`Lib/ast.py`"

#: ../../library/ast.rst:18
#, fuzzy
msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""
":mod:`ast` 模組幫助 Python 應用程式處理 Python 抽象語法樹。"
"抽象語法本身可能會隨著每個 Python "
"版本而改變；該模組有助於以編程方式找出當前語法的樣子。"

#: ../../library/ast.rst:23
#, fuzzy
msgid ""
"An abstract syntax tree can be generated by passing :data:`ast."
"PyCF_ONLY_AST` as a flag to the :func:`compile` built-in function, or using "
"the :func:`parse` helper provided in this module.  The result will be a tree "
"of objects whose classes all inherit from :class:`ast.AST`.  An abstract "
"syntax tree can be compiled into a Python code object using the built-in :"
"func:`compile` function."
msgstr ""
"可以通過將 :data:`ast.PyCF_ONLY_AST` 作為旗標傳遞給 :func:`compile` "
"內建函式，或使用此模組中提供的 :func:`parse` "
"幫助程式來生成抽象語法樹。結果將是一棵物件樹，其類都繼承自 ast.AST。"
"可以使用內建的 :func:`compile` 函式將抽象語法樹編譯成 Python 程式碼物件。"

#: ../../library/ast.rst:33
#, fuzzy
msgid "Abstract Grammar"
msgstr "抽象語法"

#: ../../library/ast.rst:35
#, fuzzy
msgid "The abstract grammar is currently defined as follows:"
msgstr "抽象語法目前定義如下："

#: ../../library/ast.rst:42
#, fuzzy
msgid "Node classes"
msgstr "節點類"

#: ../../library/ast.rst:46
#, fuzzy
msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced :ref:"
"`above <abstract-grammar>`.  They are defined in the :mod:`_ast` C module "
"and re-exported in :mod:`ast`."
msgstr ""
"這是所有 AST 節點類的基礎。實際節點類派生自 Parser/Python.asdl 文件，"
"該文件在 <abstract-grammar> 上方復制。它們在 :mod:`_ast` C 模組中定義，並在 "
":mod:`ast` 中重新導出。"

#: ../../library/ast.rst:51
#, fuzzy
msgid ""
"There is one class defined for each left-hand side symbol in the abstract "
"grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In addition, "
"there is one class defined for each constructor on the right-hand side; "
"these classes inherit from the classes for the left-hand side trees.  For "
"example, :class:`ast.BinOp` inherits from :class:`ast.expr`.  For production "
"rules with alternatives (aka \"sums\"), the left-hand side class is "
"abstract: only instances of specific constructor nodes are ever created."
msgstr ""
"為抽象語法中的每個左側符號定義了一個類（例如，:class:`ast.stmt` 或 :class:`ast"
".expr`）。此外，右側為每個構造函式定義了一個類；這些類繼承自左側樹的類。例如"
"，:class:`ast.BinOp` 繼承自 :class:`ast.expr`。對於具有替代項（又名 \"sums\"）的生"
"產規則，左側類是抽象的：僅建立特定構造函式節點的實例。"

#: ../../library/ast.rst:64
#, fuzzy
msgid ""
"Each concrete class has an attribute :attr:`_fields` which gives the names "
"of all child nodes."
msgstr "每個具體類都有一個屬性 :attr:`_fields`，它給出了所有子節點的名稱。"

#: ../../library/ast.rst:67
#, fuzzy
msgid ""
"Each instance of a concrete class has one attribute for each child node, of "
"the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""
"具體類的每個實例對於每個子節點都有一個屬性，其型別在語法中定義。例如，:class:"
"`ast.BinOp` 實例具有型別為 :class:`ast.expr` 的屬性 :attr:`left`。"

#: ../../library/ast.rst:71
#, fuzzy
msgid ""
"If these attributes are marked as optional in the grammar (using a question "
"mark), the value might be ``None``.  If the attributes can have zero-or-more "
"values (marked with an asterisk), the values are represented as Python "
"lists.  All possible attributes must be present and have valid values when "
"compiling an AST with :func:`compile`."
msgstr ""
"如果這些屬性在語法中標記為可選（使用問號），則值可能為 ``None`` 。如果屬性可以有零"
"個或多個值（標有星號），則這些值表示為 Python 列表。使用 :func:`compile` "
"編譯 AST 時，所有可能的屬性都必須存在並具有有效值。"

#: ../../library/ast.rst:82
#, fuzzy
msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have :attr:"
"`lineno`, :attr:`col_offset`, :attr:`end_lineno`, and :attr:`end_col_offset` "
"attributes.  The :attr:`lineno` and :attr:`end_lineno` are the first and "
"last line numbers of source text span (1-indexed so the first line is line "
"1) and the :attr:`col_offset` and :attr:`end_col_offset` are the "
"corresponding UTF-8 byte offsets of the first and last tokens that generated "
"the node. The UTF-8 offset is recorded because the parser uses UTF-8 "
"internally."
msgstr ""
"ast.expr 和 ast.stmt 子類別的實例具有 lineno、col_offset、end_lineno 和 "
"end_col_offset 屬性. :attr:`lineno` 和 :attr:`end_lineno` "
"是源文本跨度的首尾行號（1 索引，所以第一行是第 1 行）和 :attr:`col_offset` "
"和 :attr:` end_col_offset` 是生成節點的第一個和最後一個標記的相應 UTF-8 "
"位元組偏移量。記錄 UTF-8 偏移量是因為解析器內部使用 UTF-8。"

#: ../../library/ast.rst:91
#, fuzzy
msgid ""
"Note that the end positions are not required by the compiler and are "
"therefore optional. The end offset is *after* the last symbol, for example "
"one can get the source segment of a one-line expression node using "
"``source_line[node.col_offset : node.end_col_offset]``."
msgstr ""
"請注意，編譯器不需要結束位置，因此是可選的。結束偏移量在*最後一個符號之後，例"
"如，可以使用 ``source_line[node.col_offset : node.end_col_offset]`` "
"獲取單行表達式節點的源段。"

#: ../../library/ast.rst:96
#, fuzzy
msgid ""
"The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr "類 :class:`ast.T` 的構造函式解析其參數如下："

#: ../../library/ast.rst:98
#, fuzzy
msgid ""
"If there are positional arguments, there must be as many as there are items "
"in :attr:`T._fields`; they will be assigned as attributes of these names."
msgstr "如果有位置參數，則必須與 :attr:`T._fields` "
"中的項目一樣多；它們將被分配為這些名稱的屬性。"

#: ../../library/ast.rst:100
#, fuzzy
msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr "如果有關鍵字參數，它們會將相同名稱的屬性設定為給定值。"

#: ../../library/ast.rst:103
#, fuzzy
msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you could "
"use ::"
msgstr "例如，要建立和填充 :class:`ast.UnaryOp` 節點，您可以使用 ::"

#: ../../library/ast.rst:115
#, fuzzy
msgid "or the more compact ::"
msgstr "或更緊湊的 ::"

#: ../../library/ast.rst:122
#, fuzzy
msgid "Class :class:`ast.Constant` is now used for all constants."
msgstr "Class :class:`ast.Constant` 現在用於所有常數。"

#: ../../library/ast.rst:126
#, fuzzy
msgid ""
"Simple indices are represented by their value, extended slices are "
"represented as tuples."
msgstr "簡單索引由它們的值表示，擴充切片由元組表示。"

#: ../../library/ast.rst:131
#, fuzzy
msgid ""
"Old classes :class:`ast.Num`, :class:`ast.Str`, :class:`ast.Bytes`, :class:"
"`ast.NameConstant` and :class:`ast.Ellipsis` are still available, but they "
"will be removed in future Python releases.  In the meantime, instantiating "
"them will return an instance of a different class."
msgstr ""
"舊類 :class:`ast.Num`、:class:`ast.Str`、:class:`ast.Bytes`、:class:`ast."
"NameConstant` 和 :class:`ast.Ellipsis` 仍然可用，但它們將在未來的 Python "
"版本中被刪除。同時，實例化它們將回傳不同類的實例。"

#: ../../library/ast.rst:138
#, fuzzy
msgid ""
"Old classes :class:`ast.Index` and :class:`ast.ExtSlice` are still "
"available, but they will be removed in future Python releases. In the "
"meantime, instantiating them will return an instance of a different class."
msgstr ""
"舊類 :class:`ast.Index` 和 :class:`ast.ExtSlice` 仍然可用，但它們將在未來的 "
"Python 版本中刪除。同時，實例化它們將回傳不同類的實例。"

#: ../../library/ast.rst:144
#, fuzzy
msgid ""
"The descriptions of the specific node classes displayed here were initially "
"adapted from the fantastic `Green Tree Snakes <https://greentreesnakes."
"readthedocs.io/en/latest/>`__ project and all its contributors."
msgstr ""
"此處顯示的特定節點類的描述最初改編自奇妙的“綠樹蛇”<https://greentreesnakes."
"readthedocs.io/en/latest/>`__ 項目及其所有貢獻者。"

#: ../../library/ast.rst:150
#, fuzzy
msgid "Literals"
msgstr "文字"

#: ../../library/ast.rst:154
#, fuzzy
msgid ""
"A constant value. The ``value`` attribute of the ``Constant`` literal "
"contains the Python object it represents. The values represented can be "
"simple types such as a number, string or ``None``, but also immutable "
"container types (tuples and frozensets) if all of their elements are "
"constant."
msgstr ""
"一個常數值。 ``Constant`` 文字的 ``value`` 屬性包含它代表的 Python 物件。表示"
"的值可以是簡單型別，例如數字、字串或 ``None`` ，但也可以是不可變容器型別（元組和凍"
"結集），前提是它們的所有元素都是常數。"

#: ../../library/ast.rst:168
#, fuzzy
msgid ""
"Node representing a single formatting field in an f-string. If the string "
"contains a single formatting field and nothing else the node can be isolated "
"otherwise it appears in :class:`JoinedStr`."
msgstr "表示 f 字串中單個格式化欄位的節點。如果字串包含單個格式欄位並且沒有其他任何內"
"容，則節點可以被隔離，否則它會出現在 JoinedStr 中。"

#: ../../library/ast.rst:172
#, fuzzy
msgid ""
"``value`` is any expression node (such as a literal, a variable, or a "
"function call)."
msgstr "``value`` 是任何表達式節點（例如文字、變數或函式呼叫）。"

#: ../../library/ast.rst:174
#, fuzzy
msgid "``conversion`` is an integer:"
msgstr "``conversion`` 是一個整數："

#: ../../library/ast.rst:176
#, fuzzy
msgid "-1: no formatting"
msgstr "-1：無格式"

#: ../../library/ast.rst:177
#, fuzzy
msgid "115: ``!s`` string formatting"
msgstr "115: ``!s`` 字串格式"

#: ../../library/ast.rst:178
#, fuzzy
msgid "114: ``!r`` repr formatting"
msgstr "114: ``!r`` repr 格式化"

#: ../../library/ast.rst:179
#, fuzzy
msgid "97: ``!a`` ascii formatting"
msgstr "97: ``!a`` ascii 格式"

#: ../../library/ast.rst:181
#, fuzzy
msgid ""
"``format_spec`` is a :class:`JoinedStr` node representing the formatting of "
"the value, or ``None`` if no format was specified. Both ``conversion`` and "
"``format_spec`` can be set at the same time."
msgstr ""
"``format_spec`` 是一個 :class:`JoinedStr` "
"節點，表示值的格式，如果沒有指定格式，則為 ``None``。 ``conversion`` 和 "
"``format_spec`` 可以同時設定。"

#: ../../library/ast.rst:188
#, fuzzy
msgid ""
"An f-string, comprising a series of :class:`FormattedValue` and :class:"
"`Constant` nodes."
msgstr "一個 f 字串，包含一系列 :class:`FormattedValue` 和 :class:`Constant` 節點。"

#: ../../library/ast.rst:217
#, fuzzy
msgid ""
"A list or tuple. ``elts`` holds a list of nodes representing the elements. "
"``ctx`` is :class:`Store` if the container is an assignment target (i.e. "
"``(x,y)=something``), and :class:`Load` otherwise."
msgstr ""
"列表或元組。 ``elts`` 包含代表元素的節點列表。如果容器是賦值目標（即 "
"``(x,y)=something``），``ctx`` 是 :class:`Store`，否則是 :class:`Load`。"

#: ../../library/ast.rst:243
#, fuzzy
msgid "A set. ``elts`` holds a list of nodes representing the set's elements."
msgstr "一套。 ``elts`` 包含代表集合元素的節點列表。"

#: ../../library/ast.rst:258
#, fuzzy
msgid ""
"A dictionary. ``keys`` and ``values`` hold lists of nodes representing the "
"keys and the values respectively, in matching order (what would be returned "
"when calling :code:`dictionary.keys()` and :code:`dictionary.values()`)."
msgstr ""
"一本字典。 ``keys`` 和 ``values`` 分別以匹配順序保存表示鍵和值的節點列表（"
"呼叫 :code:`dictionary.keys()` 和 :code:`dictionary.值（）`）。"

#: ../../library/ast.rst:262
#, fuzzy
msgid ""
"When doing dictionary unpacking using dictionary literals the expression to "
"be expanded goes in the ``values`` list, with a ``None`` at the "
"corresponding position in ``keys``."
msgstr "當使用字典文字進行字典解包時，要擴充的表達式進入 ``值``列表，在 ``鍵``中的相應位置"
"有一個 ``None`` 。"

#: ../../library/ast.rst:280
#, fuzzy
msgid "Variables"
msgstr "變數"

#: ../../library/ast.rst:284
#, fuzzy
msgid ""
"A variable name. ``id`` holds the name as a string, and ``ctx`` is one of "
"the following types."
msgstr "一個變數名。 ``id`` 將名稱保存為字串，``ctx`` 是以下型別之一。"

#: ../../library/ast.rst:292
#, fuzzy
msgid ""
"Variable references can be used to load the value of a variable, to assign a "
"new value to it, or to delete it. Variable references are given a context to "
"distinguish these cases."
msgstr "變數引用可用於加載變數的值、為其分配新值或刪除它。變數引用被賦予上下文以區分"
"這些情況。"

#: ../../library/ast.rst:325
#, fuzzy
msgid ""
"A ``*var`` variable reference. ``value`` holds the variable, typically a :"
"class:`Name` node. This type must be used when building a :class:`Call` node "
"with ``*args``."
msgstr ""
"``*var`` 變數引用。 ``value`` 保存變數，通常是 :class:`Name` 節點。在使用 "
"``*args`` 構建 :class:`Call` 節點時必須使用此型別。"

#: ../../library/ast.rst:348
#, fuzzy
msgid "Expressions"
msgstr "表達式"

#: ../../library/ast.rst:352
#, fuzzy
msgid ""
"When an expression, such as a function call, appears as a statement by "
"itself with its return value not used or stored, it is wrapped in this "
"container. ``value`` holds one of the other nodes in this section, a :class:"
"`Constant`, a :class:`Name`, a :class:`Lambda`, a :class:`Yield` or :class:"
"`YieldFrom` node."
msgstr ""
"當表達式（例如函式呼叫）本身作為語句出現且其回傳值未被使用或儲存時，它將被包"
"裝在此容器中。 ``value`` 包含此部分中的其他節點之一，一個 :class:`Constant`"
"，一個 :class:`Name`，一個 :class:`Lambda`，一個 :class:`Yield` "
"或：class： `YieldFrom` 節點。"

#: ../../library/ast.rst:371
#, fuzzy
msgid ""
"A unary operation. ``op`` is the operator, and ``operand`` any expression "
"node."
msgstr "一元運算。 ``op`` 是運算符，``operand`` 是任何表達式節點。"

#: ../../library/ast.rst:380
#, fuzzy
msgid ""
"Unary operator tokens. :class:`Not` is the ``not`` keyword, :class:`Invert` "
"is the ``~`` operator."
msgstr "一元運算符標記。 :class:`Not` 是 ``not`` 關鍵字，:class:`Invert` 是 ``~`` "
"運算符。"

#: ../../library/ast.rst:394
#, fuzzy
msgid ""
"A binary operation (like addition or division). ``op`` is the operator, and "
"``left`` and ``right`` are any expression nodes."
msgstr "二元運算（如加法或除法）。 ``op`` 是運算符，``left`` 和 ``right`` "
"是任意表達式節點。"

#: ../../library/ast.rst:421
#, fuzzy
msgid "Binary operator tokens."
msgstr "二元運算符標記。"

#: ../../library/ast.rst:426
#, fuzzy
msgid ""
"A boolean operation, 'or' or 'and'. ``op`` is :class:`Or` or :class:`And`. "
"``values`` are the values involved. Consecutive operations with the same "
"operator, such as ``a or b or c``, are collapsed into one node with several "
"values."
msgstr ""
"布爾運算， ``或``或 ``與``。 ``op`` 是 :class:`Or` 或 :class:`And`。 ``values`` "
"是涉及的值。具有相同運算符的連續操作，例如“a 或 b 或 "
"c”，被折疊到一個具有多個值的節點中。"

#: ../../library/ast.rst:431
#, fuzzy
msgid "This doesn't include ``not``, which is a :class:`UnaryOp`."
msgstr "這不包括 ``not``，這是一個 :class:`UnaryOp`。"

#: ../../library/ast.rst:447
#, fuzzy
msgid "Boolean operator tokens."
msgstr "布爾運算符標記。"

#: ../../library/ast.rst:452
#, fuzzy
msgid ""
"A comparison of two or more values. ``left`` is the first value in the "
"comparison, ``ops`` the list of operators, and ``comparators`` the list of "
"values after the first element in the comparison."
msgstr ""
"兩個或多個值的比較。 ``left`` 是比較中的第一個值，``ops`` "
"是運算符列表，``comparators`` 是比較中第一個元素之後的值列表。"

#: ../../library/ast.rst:481
#, fuzzy
msgid "Comparison operator tokens."
msgstr "比較運算符標記。"

#: ../../library/ast.rst:486
#, fuzzy
msgid ""
"A function call. ``func`` is the function, which will often be a :class:"
"`Name` or :class:`Attribute` object. Of the arguments:"
msgstr "函式呼叫。 ``func`` 是函式，通常是 :class:`Name` 或 :class:`Attribute` "
"物件。論點："

#: ../../library/ast.rst:489
#, fuzzy
msgid "``args`` holds a list of the arguments passed by position."
msgstr "``args`` 包含按位置傳遞的參數列表。"

#: ../../library/ast.rst:490
#, fuzzy
msgid ""
"``keywords`` holds a list of :class:`keyword` objects representing arguments "
"passed by keyword."
msgstr "``keywords`` 包含一個 :class:`keyword` 物件列表，表示由關鍵字傳遞的參數。"

#: ../../library/ast.rst:493
#, fuzzy
msgid ""
"When creating a ``Call`` node, ``args`` and ``keywords`` are required, but "
"they can be empty lists. ``starargs`` and ``kwargs`` are optional."
msgstr ""
"建立``Call`` 節點時，``args`` 和``keywords`` 是必需的，但它們可以是空列表。 "
"``starargs`` 和 ``kwargs`` 是可選的。"

#: ../../library/ast.rst:517
#, fuzzy
msgid ""
"A keyword argument to a function call or class definition. ``arg`` is a raw "
"string of the parameter name, ``value`` is a node to pass in."
msgstr "函式呼叫或類定義的關鍵字參數。 ``arg`` 是參數名稱的原始字串，``value`` "
"是要傳入的節點。"

#: ../../library/ast.rst:523
#, fuzzy
msgid ""
"An expression such as ``a if b else c``. Each field holds a single node, so "
"in the following example, all three are :class:`Name` nodes."
msgstr "諸如“a if b else c”之類的表達式。每個欄位包含一個節點，因此在以下示例中，"
"所有三個都是 :class:`Name` 節點。"

#: ../../library/ast.rst:538
#, fuzzy
msgid ""
"Attribute access, e.g. ``d.keys``. ``value`` is a node, typically a :class:"
"`Name`. ``attr`` is a bare string giving the name of the attribute, and "
"``ctx`` is :class:`Load`, :class:`Store` or :class:`Del` according to how "
"the attribute is acted on."
msgstr ""
"屬性訪問，例如``d.keys``。 ``value`` 是一個節點，通常是一個 :class:`Name`。 "
"``attr`` 是給出屬性名稱的裸字串，``ctx`` 是 :class:`Load`、:class:`Store` 或 "
":class:`Del`，具體取決於屬性的作用方式在。"

#: ../../library/ast.rst:555
#, fuzzy
msgid ""
"A named expression. This AST node is produced by the assignment expressions "
"operator (also known as the walrus operator). As opposed to the :class:"
"`Assign` node in which the first argument can be multiple nodes, in this "
"case both ``target`` and ``value`` must be single nodes."
msgstr ""
"命名表達式。此 AST 節點由賦值表達式運算符（也稱為海象運算符）生成。"
"與第一個參數可以是多個節點的 :class:`Assign` "
"節點相反，在這種情況下，``target`` 和 ``value`` 都必須是單個節點。"

#: ../../library/ast.rst:570
#, fuzzy
msgid "Subscripting"
msgstr "訂閱"

#: ../../library/ast.rst:574
#, fuzzy
msgid ""
"A subscript, such as ``l[1]``. ``value`` is the subscripted object (usually "
"sequence or mapping). ``slice`` is an index, slice or key. It can be a :"
"class:`Tuple` and contain a :class:`Slice`. ``ctx`` is :class:`Load`, :class:"
"`Store` or :class:`Del` according to the action performed with the subscript."
msgstr ""
"下標，例如 ``l[1]``。 ``value`` 是下標物件（通常是序列或映射）。 ``slice`` "
"是索引、切片或鍵。它可以是一個 :class:`Tuple` 並包含一個 :class:`Slice`。 "
"``ctx`` 是 :class:`Load`、:class:`Store` 或 :class:`Del` "
"根據使用下標執行的操作。"

#: ../../library/ast.rst:598
#, fuzzy
msgid ""
"Regular slicing (on the form ``lower:upper`` or ``lower:upper:step``). Can "
"occur only inside the *slice* field of :class:`Subscript`, either directly "
"or as an element of :class:`Tuple`."
msgstr ""
"常規切片（形式為 ``lower:upper`` 或 ``lower:upper:step``）。只能出現在 "
":class:`Subscript` 的 *slice* 欄位內，直接出現或作為 :class:`Tuple` "
"的元素出現。"

#: ../../library/ast.rst:615
#, fuzzy
msgid "Comprehensions"
msgstr "感悟"

#: ../../library/ast.rst:622
#, fuzzy
msgid ""
"List and set comprehensions, generator expressions, and dictionary "
"comprehensions. ``elt`` (or ``key`` and ``value``) is a single node "
"representing the part that will be evaluated for each item."
msgstr "列表和集合推導式、生成器表達式和字典推導式。 ``elt``（或``key`` "
"和``value``）是一個節點，表示將為每個項目評估的部分。"

#: ../../library/ast.rst:626
#, fuzzy
msgid "``generators`` is a list of :class:`comprehension` nodes."
msgstr "``generators`` 是 :class:`comprehension` 節點的列表。"

#: ../../library/ast.rst:668
#, fuzzy
msgid ""
"One ``for`` clause in a comprehension. ``target`` is the reference to use "
"for each element - typically a :class:`Name` or :class:`Tuple` node. "
"``iter`` is the object to iterate over. ``ifs`` is a list of test "
"expressions: each ``for`` clause can have multiple ``ifs``."
msgstr ""
"理解中的一個 ``for``子句。 ``target`` 是用於每個元素的引用 - 通常是 "
":class:`Name` 或 :class:`Tuple` 節點。 ``iter`` 是要疊代的物件。 ``ifs`` "
"是一個測試表達式列表：每個 ``for`` 子句可以有多個 ``ifs``。"

#: ../../library/ast.rst:673
#, fuzzy
msgid ""
"``is_async`` indicates a comprehension is asynchronous (using an ``async "
"for`` instead of ``for``). The value is an integer (0 or 1)."
msgstr "``is_async`` 表示理解是非同步的（使用 ``async for`` 而不是 "
"``for``）。該值是一個整數（0 或 1）。"

#: ../../library/ast.rst:739
#, fuzzy
msgid "Statements"
msgstr "報表"

#: ../../library/ast.rst:743
#, fuzzy
msgid ""
"An assignment. ``targets`` is a list of nodes, and ``value`` is a single "
"node."
msgstr "一項任務。 ``targets`` 是節點列表，``value`` 是單個節點。"

#: ../../library/ast.rst:745
#, fuzzy
msgid ""
"Multiple nodes in ``targets`` represents assigning the same value to each. "
"Unpacking is represented by putting a :class:`Tuple` or :class:`List` within "
"``targets``."
msgstr ""
"``targets`` 中的多個節點表示為每個節點分配相同的值。解包是通過在 ``targets`` "
"中放置一個 Tuple 或 List 來表示的。"

#: ../../library/ast.rst:751 ../../library/ast.rst:1038
#: ../../library/ast.rst:1242 ../../library/ast.rst:1663
#, fuzzy
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment."
msgstr "``type_comment`` 是一個可選的字串，帶有型別註釋作為註釋。"

#: ../../library/ast.rst:781
#, fuzzy
msgid ""
"An assignment with a type annotation. ``target`` is a single node and can be "
"a :class:`Name`, a :class:`Attribute` or a :class:`Subscript`. "
"``annotation`` is the annotation, such as a :class:`Constant` or :class:"
"`Name` node. ``value`` is a single optional node. ``simple`` is a boolean "
"integer set to True for a :class:`Name` node in ``target`` that do not "
"appear in between parenthesis and are hence pure names and not expressions."
msgstr ""
"帶有型別註釋的賦值。 ``target`` 是單個節點，可以是 "
":class:`Name`、:class:`Attribute` 或 :class:`Subscript`。 ``annotation`` "
"是註釋，例如 :class:`Constant` 或 :class:`Name` 節點。 ``value`` "
"是單個可選節點。 ``simple`` 是一個布爾整數，為 ``target`` 中的 :class:`Name` "
"節點設定為 True，它沒有出現在括號之間，因此是純名稱而不是表達式。"

#: ../../library/ast.rst:836
#, fuzzy
msgid ""
"Augmented assignment, such as ``a += 1``. In the following example, "
"``target`` is a :class:`Name` node for ``x`` (with the :class:`Store` "
"context), ``op`` is :class:`Add`, and ``value`` is a :class:`Constant` with "
"value for 1."
msgstr ""
"增強賦值，例如 ``a += 1``。在下面的示例中，``target`` 是 ``x`` 的 "
":class:`Name` 節點（帶有 :class:`Store` 上下文），``op`` 是 :class:`Add`， "
"``value`` 是一個值為 1 的常數。"

#: ../../library/ast.rst:841
#, fuzzy
msgid ""
"The ``target`` attribute cannot be of class :class:`Tuple` or :class:`List`, "
"unlike the targets of :class:`Assign`."
msgstr ""
"``target`` 屬性不能屬於 :class:`Tuple` 或 :class:`List` 類，這與 "
":class:`Assign` 的目標不同。"

#: ../../library/ast.rst:858
#, fuzzy
msgid ""
"A ``raise`` statement. ``exc`` is the exception object to be raised, "
"normally a :class:`Call` or :class:`Name`, or ``None`` for a standalone "
"``raise``. ``cause`` is the optional part for ``y`` in ``raise x from y``."
msgstr ""
"一個 ``raise`` 語句。 ``exc`` 是要引發的例外物件，通常是一個 :class:`Call` "
"或 :class:`Name`，或者 ``None`` 用於獨立的 ``raise``。 ``cause`` 是``raise x "
"from y`` 中``y`` 的可選部分。"

#: ../../library/ast.rst:875
#, fuzzy
msgid ""
"An assertion. ``test`` holds the condition, such as a :class:`Compare` node. "
"``msg`` holds the failure message."
msgstr "一個斷言。 ``test`` 保存條件，例如 :class:`Compare` 節點。 ``msg`` "
"包含失敗消息。"

#: ../../library/ast.rst:891
#, fuzzy
msgid ""
"Represents a ``del`` statement. ``targets`` is a list of nodes, such as :"
"class:`Name`, :class:`Attribute` or :class:`Subscript` nodes."
msgstr ""
"表示一個 ``del`` 語句。 ``targets`` 是一個節點列表，例如 "
":class:`Name`、:class:`Attribute` 或 :class:`Subscript` 節點。"

#: ../../library/ast.rst:909
#, fuzzy
msgid "A ``pass`` statement."
msgstr "一個 ``pass`` 語句。"

#: ../../library/ast.rst:920
#, fuzzy
msgid ""
"Other statements which are only applicable inside functions or loops are "
"described in other sections."
msgstr "其他僅適用於函式或循環內部的語句在其他部分中進行了描述。"

#: ../../library/ast.rst:924
#, fuzzy
msgid "Imports"
msgstr "進口"

#: ../../library/ast.rst:928
#, fuzzy
msgid "An import statement. ``names`` is a list of :class:`alias` nodes."
msgstr "導入語句。 ``names`` 是 :class:`alias` 節點的列表。"

#: ../../library/ast.rst:945
#, fuzzy
msgid ""
"Represents ``from x import y``. ``module`` is a raw string of the 'from' "
"name, without any leading dots, or ``None`` for statements such as ``from . "
"import foo``. ``level`` is an integer holding the level of the relative "
"import (0 means absolute import)."
msgstr ""
"表示“從 x 導入 y”。 ``module`` 是 'from' 名稱的原始字串，沒有任何前導點，"
"或者對於諸如 ``from .導入 foo``。 ``level`` 是一個包含相對導入級別的整數（0 "
"表示絕對導入）。"

#: ../../library/ast.rst:967
#, fuzzy
msgid ""
"Both parameters are raw strings of the names. ``asname`` can be ``None`` if "
"the regular name is to be used."
msgstr "兩個參數都是名稱的原始字串。如果要使用常規名稱， ``asname``可以是 ``None``。"

#: ../../library/ast.rst:984
#, fuzzy
msgid "Control flow"
msgstr "控制流"

#: ../../library/ast.rst:987
#, fuzzy
msgid ""
"Optional clauses such as ``else`` are stored as an empty list if they're not "
"present."
msgstr "諸如 else 之類的可選子句如果不存在則儲存為空列表。"

#: ../../library/ast.rst:992
#, fuzzy
msgid ""
"An ``if`` statement. ``test`` holds a single node, such as a :class:"
"`Compare` node. ``body`` and ``orelse`` each hold a list of nodes."
msgstr ""
"``if`` 語句。 ``test`` 包含單個節點，例如 :class:`Compare` 節點。 ``body`` "
"和 ``orelse`` 每個都包含一個節點列表。"

#: ../../library/ast.rst:995
#, fuzzy
msgid ""
"``elif`` clauses don't have a special representation in the AST, but rather "
"appear as extra :class:`If` nodes within the ``orelse`` section of the "
"previous one."
msgstr "``elif`` 子句在 AST 中沒有特殊表示，而是在前一個的 ``orelse`` "
"部分中顯示為額外的 :class:`If` 節點。"

#: ../../library/ast.rst:1030
#, fuzzy
msgid ""
"A ``for`` loop. ``target`` holds the variable(s) the loop assigns to, as a "
"single :class:`Name`, :class:`Tuple` or :class:`List` node. ``iter`` holds "
"the item to be looped over, again as a single node. ``body`` and ``orelse`` "
"contain lists of nodes to execute. Those in ``orelse`` are executed if the "
"loop finishes normally, rather than via a ``break`` statement."
msgstr ""
"一個``for``循環。 ``target`` 保存循環分配給的變數，作為單個 "
":class:`Name`、:class:`Tuple` 或 :class:`List` 節點。 ``iter`` "
"保存要循環的項目，再次作為單個節點。 ``body`` 和 ``orelse`` 包含要執行的節點"
"列表。如果循環正常完成，而不是通過 ``break``語句，則執行 ``orelse``中的那些。"

#: ../../library/ast.rst:1064
#, fuzzy
msgid ""
"A ``while`` loop. ``test`` holds the condition, such as a :class:`Compare` "
"node."
msgstr "一個 ``while`` 循環。 ``test`` 保存條件，例如 :class:`Compare` 節點。"

#: ../../library/ast.rst:1091
#, fuzzy
msgid "The ``break`` and ``continue`` statements."
msgstr "``break`` 和 ``continue`` 語句。"

#: ../../library/ast.rst:1126
#, fuzzy
msgid ""
"``try`` blocks. All attributes are list of nodes to execute, except for "
"``handlers``, which is a list of :class:`ExceptHandler` nodes."
msgstr "``try`` 塊。所有屬性都是要執行的節點列表，除了 ``handlers`` 是一個 "
"ExceptHandler 節點列表。"

#: ../../library/ast.rst:1172
#, fuzzy
msgid ""
"``try`` blocks which are followed by ``except*`` clauses. The attributes are "
"the same as for :class:`Try` but the :class:`ExceptHandler` nodes in "
"``handlers`` are interpreted as ``except*`` blocks rather then ``except``."
msgstr ""
"``try`` 塊後跟``except*`` 子句。屬性與 :class:`Try` 相同，但 ``handlers`` "
"中的 :class:`ExceptHandler` 節點被解釋為 ``except*`` 塊而不是 ``except``。"

#: ../../library/ast.rst:1203
#, fuzzy
msgid ""
"A single ``except`` clause. ``type`` is the exception type it will match, "
"typically a :class:`Name` node (or ``None`` for a catch-all ``except:`` "
"clause). ``name`` is a raw string for the name to hold the exception, or "
"``None`` if the clause doesn't have ``as foo``. ``body`` is a list of nodes."
msgstr ""
"單個 ``except`` 子句。 ``type`` 是它將匹配的例外型別，通常是 :class:`Name` "
"節點（或 ``None`` 用於包羅萬象的 ``except:`` 子句）。 ``name`` "
"是保留例外的名稱的原始字串，如果子句沒有``as foo``，則為``None``。 ``body`` "
"是一個節點列表。"

#: ../../library/ast.rst:1237
#, fuzzy
msgid ""
"A ``with`` block. ``items`` is a list of :class:`withitem` nodes "
"representing the context managers, and ``body`` is the indented block inside "
"the context."
msgstr ""
"一個 ``with`` 塊。 ``items`` 是代表上下文管理器的 :class:`withitem` "
"節點列表，``body`` 是上下文中的縮進塊。"

#: ../../library/ast.rst:1247
#, fuzzy
msgid ""
"A single context manager in a ``with`` block. ``context_expr`` is the "
"context manager, often a :class:`Call` node. ``optional_vars`` is a :class:"
"`Name`, :class:`Tuple` or :class:`List` for the ``as foo`` part, or ``None`` "
"if that isn't used."
msgstr ""
"``with`` 塊中的單個上下文管理器。 ``context_expr`` 是上下文管理器，"
"通常是一個 Call 節點。 ``optional_vars`` 是 ``as foo`` 部分的 "
":class:`Name`、:class:`Tuple` 或 :class:`List`，如果未使用則為 ``None``。"

#: ../../library/ast.rst:1280
#, fuzzy
msgid "Pattern matching"
msgstr "模式匹配"

#: ../../library/ast.rst:1285
#, fuzzy
msgid ""
"A ``match`` statement. ``subject`` holds the subject of the match (the "
"object that is being matched against the cases) and ``cases`` contains an "
"iterable of :class:`match_case` nodes with the different cases."
msgstr ""
"一個``匹配``語句。 ``subject`` 包含匹配的主題（與案例匹配的物件），``cases`` "
"包含具有不同案例的可疊代的 :class:`match_case` 節點。"

#: ../../library/ast.rst:1291
#, fuzzy
msgid ""
"A single case pattern in a ``match`` statement. ``pattern`` contains the "
"match pattern that the subject will be matched against. Note that the :class:"
"`AST` nodes produced for patterns differ from those produced for "
"expressions, even when they share the same syntax."
msgstr ""
"``match`` 語句中的單個案例模式。 ``pattern`` 包含匹配主題的匹配模式。請注意，"
"為模式生成的 AST 節點與為表達式生成的節點不同，即使它們共享相同的語法。"

#: ../../library/ast.rst:1296
#, fuzzy
msgid ""
"The ``guard`` attribute contains an expression that will be evaluated if the "
"pattern matches the subject."
msgstr "``guard`` 屬性包含一個表達式，如果模式與主題匹配，該表達式將被評估。"

#: ../../library/ast.rst:1299
#, fuzzy
msgid ""
"``body`` contains a list of nodes to execute if the pattern matches and the "
"result of evaluating the guard expression is true."
msgstr "``body`` 包含一個節點列表，如果模式匹配並且評估保護表達式的結果為真，則執行。"

#: ../../library/ast.rst:1342
#, fuzzy
msgid ""
"A match literal or value pattern that compares by equality. ``value`` is an "
"expression node. Permitted value nodes are restricted as described in the "
"match statement documentation. This pattern succeeds if the match subject is "
"equal to the evaluated value."
msgstr ""
"按相等進行比較的匹配文字或值模式。 ``value`` 是一個表達式節點。如匹配語句文檔"
"中所述，允許值節點受到限制。如果匹配主題等於評估值，則此模式成功。"

#: ../../library/ast.rst:1369
#, fuzzy
msgid ""
"A match literal pattern that compares by identity. ``value`` is the "
"singleton to be compared against: ``None``, ``True``, or ``False``. This "
"pattern succeeds if the match subject is the given constant."
msgstr ""
"按標識進行比較的匹配文字模式。 ``value`` "
"是要與之比較的單例：``None``、``True`` "
"或``False``。如果匹配主題是給定常數，則此模式成功。"

#: ../../library/ast.rst:1394
#, fuzzy
msgid ""
"A match sequence pattern. ``patterns`` contains the patterns to be matched "
"against the subject elements if the subject is a sequence. Matches a "
"variable length sequence if one of the subpatterns is a ``MatchStar`` node, "
"otherwise matches a fixed length sequence."
msgstr ""
"匹配序列模式。如果主題是一個序列，``patterns`` 包含要與主題元素匹配的模式。如"
"果子模式之一是 ``MatchStar`` 節點，則匹配可變長度序列，否則匹配固定長度序列。"

#: ../../library/ast.rst:1425
#, fuzzy
msgid ""
"Matches the rest of the sequence in a variable length match sequence "
"pattern. If ``name`` is not ``None``, a list containing the remaining "
"sequence elements is bound to that name if the overall sequence pattern is "
"successful."
msgstr "在可變長度匹配序列模式中匹配序列的其餘部分。如果 ``name``不是 ``None``，如果整個序"
"列模式成功，則包含剩餘序列元素的列表將綁定到該名稱。"

#: ../../library/ast.rst:1465
#, fuzzy
msgid ""
"A match mapping pattern. ``keys`` is a sequence of expression nodes. "
"``patterns`` is a corresponding sequence of pattern nodes. ``rest`` is an "
"optional name that can be specified to capture the remaining mapping "
"elements. Permitted key expressions are restricted as described in the match "
"statement documentation."
msgstr ""
"匹配映射模式。 ``keys`` 是一系列表達式節點。 ``patterns`` "
"是相應的模式節點序列。 ``rest`` 是一個可選名稱，可以指定它來捕獲剩餘的映射元"
"素。如匹配語句文檔中所述，允許的鍵表達式受到限制。"

#: ../../library/ast.rst:1471
#, fuzzy
msgid ""
"This pattern succeeds if the subject is a mapping, all evaluated key "
"expressions are present in the mapping, and the value corresponding to each "
"key matches the corresponding subpattern. If ``rest`` is not ``None``, a "
"dict containing the remaining mapping elements is bound to that name if the "
"overall mapping pattern is successful."
msgstr ""
"如果主題是一個映射，則此模式成功，所有評估的鍵表達式都存在於映射中，並且與每"
"個鍵對應的值與相應的子模式匹配。如果 ``rest`` 不是 "
"``None``，如果整個映射模式成功，則包含剩餘映射元素的字典將綁定到該名稱。"

#: ../../library/ast.rst:1511
#, fuzzy
msgid ""
"A match class pattern. ``cls`` is an expression giving the nominal class to "
"be matched. ``patterns`` is a sequence of pattern nodes to be matched "
"against the class defined sequence of pattern matching attributes. "
"``kwd_attrs`` is a sequence of additional attributes to be matched "
"(specified as keyword arguments in the class pattern), ``kwd_patterns`` are "
"the corresponding patterns (specified as keyword values in the class "
"pattern)."
msgstr ""
"匹配類模式。 ``cls`` 是一個表達式，給出了要匹配的標稱類。 ``patterns`` "
"是一系列模式節點，要與類定義的模式匹配屬性序列相匹配。 ``kwd_attrs`` "
"是一系列要匹配的附加屬性（在類模式中指定為關鍵字參數），``kwd_patterns`` "
"是相應的模式（在類模式中指定為關鍵字值）。"

#: ../../library/ast.rst:1518
#, fuzzy
msgid ""
"This pattern succeeds if the subject is an instance of the nominated class, "
"all positional patterns match the corresponding class-defined attributes, "
"and any specified keyword attributes match their corresponding pattern."
msgstr "如果主題是指定類的實例，則此模式成功，所有位置模式都匹配相應的類定義屬性，並"
"且任何指定的關鍵字屬性匹配其相應的模式。"

#: ../../library/ast.rst:1522
#, fuzzy
msgid ""
"Note: classes may define a property that returns self in order to match a "
"pattern node against the instance being matched. Several builtin types are "
"also matched that way, as described in the match statement documentation."
msgstr "注意：類可以定義一個回傳 self 的屬性，以便將模式節點與被匹配的實例進行匹配。"
"一些內建型別也以這種方式匹配，如匹配語句文檔中所述。"

#: ../../library/ast.rst:1575
#, fuzzy
msgid ""
"A match \"as-pattern\", capture pattern or wildcard pattern. ``pattern`` "
"contains the match pattern that the subject will be matched against. If the "
"pattern is ``None``, the node represents a capture pattern (i.e a bare name) "
"and will always succeed."
msgstr ""
"匹配 ``as-pattern``、捕獲模式或通配符模式。 ``pattern`` 包含匹配主題的匹配模式。"
"如果模式為 ``None`` ，則該節點表示捕獲模式（即裸名）並且將始終成功。"

#: ../../library/ast.rst:1580
#, fuzzy
msgid ""
"The ``name`` attribute contains the name that will be bound if the pattern "
"is successful. If ``name`` is ``None``, ``pattern`` must also be ``None`` "
"and the node represents the wildcard pattern."
msgstr "``name`` 屬性包含模式成功時將綁定的名稱。如果 ``name``為 ``None``， ``pattern`` 也必須"
"為 ``None``，節點表示通配符模式。"

#: ../../library/ast.rst:1616
#, fuzzy
msgid ""
"A match \"or-pattern\". An or-pattern matches each of its subpatterns in "
"turn to the subject, until one succeeds. The or-pattern is then deemed to "
"succeed. If none of the subpatterns succeed the or-pattern fails. The "
"``patterns`` attribute contains a list of match pattern nodes that will be "
"matched against the subject."
msgstr ""
"匹配“或模式”。 or 模式依次將其每個子模式與主題匹配，直到成功為止。然後認為 "
"or 模式成功。如果沒有子模式成功，則 or-模式失敗。 ``patterns`` "
"屬性包含將與主題匹配的匹配模式節點列表。"

#: ../../library/ast.rst:1648
#, fuzzy
msgid "Function and class definitions"
msgstr "函式和類定義"

#: ../../library/ast.rst:1652
#, fuzzy
msgid "A function definition."
msgstr "函式定義。"

#: ../../library/ast.rst:1654
#, fuzzy
msgid "``name`` is a raw string of the function name."
msgstr "``name`` 是函式名稱的原始字串。"

#: ../../library/ast.rst:1655
#, fuzzy
msgid "``args`` is an :class:`arguments` node."
msgstr "``args`` 是一個 :class:`arguments` 節點。"

#: ../../library/ast.rst:1656
#, fuzzy
msgid "``body`` is the list of nodes inside the function."
msgstr "``body`` 是函式內部的節點列表。"

#: ../../library/ast.rst:1657
#, fuzzy
msgid ""
"``decorator_list`` is the list of decorators to be applied, stored outermost "
"first (i.e. the first in the list will be applied last)."
msgstr "``decorator_list`` "
"是要應用的裝飾器列表，首先儲存在最外層（即列表中的第一個將最後應用）。"

#: ../../library/ast.rst:1659
#, fuzzy
msgid "``returns`` is the return annotation."
msgstr "``returns`` 是回傳註解。"

#: ../../library/ast.rst:1668
#, fuzzy
msgid ""
"``lambda`` is a minimal function definition that can be used inside an "
"expression. Unlike :class:`FunctionDef`, ``body`` holds a single node."
msgstr "``lambda`` 是可以在表達式內部使用的最小函式定義。與 :class:`FunctionDef` "
"不同，``body`` 包含單個節點。"

#: ../../library/ast.rst:1692
#, fuzzy
msgid "The arguments for a function."
msgstr "函式的參數。"

#: ../../library/ast.rst:1694
#, fuzzy
msgid ""
"``posonlyargs``, ``args`` and ``kwonlyargs`` are lists of :class:`arg` nodes."
msgstr "``posonlyargs``、``args`` 和 ``kwonlyargs`` 是 :class:`arg` 節點的列表。"

#: ../../library/ast.rst:1695
#, fuzzy
msgid ""
"``vararg`` and ``kwarg`` are single :class:`arg` nodes, referring to the "
"``*args, **kwargs`` parameters."
msgstr "``vararg`` 和 ``kwarg`` 是單個 :class:`arg` 節點，指的是 ``*args, **kwargs`` "
"參數。"

#: ../../library/ast.rst:1697
#, fuzzy
msgid ""
"``kw_defaults`` is a list of default values for keyword-only arguments. If "
"one is ``None``, the corresponding argument is required."
msgstr "``kw_defaults`` "
"是僅關鍵字參數的預設值列表。如果一個是 ``None`` ，則需要相應的參數。"

#: ../../library/ast.rst:1699
#, fuzzy
msgid ""
"``defaults`` is a list of default values for arguments that can be passed "
"positionally. If there are fewer defaults, they correspond to the last n "
"arguments."
msgstr "``defaults`` 是可以按位置傳遞的參數的預設值列表。如果預設值較少，"
"則它們對應於最後 n 個參數。"

#: ../../library/ast.rst:1706
#, fuzzy
msgid ""
"A single argument in a list. ``arg`` is a raw string of the argument name, "
"``annotation`` is its annotation, such as a :class:`Str` or :class:`Name` "
"node."
msgstr ""
"列表中的單個參數。 ``arg`` 是參數名稱的原始字串，``annotation`` 是其註釋，"
"例如 :class:`Str` 或 :class:`Name` 節點。"

#: ../../library/ast.rst:1712
#, fuzzy
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment"
msgstr "``type_comment`` 是一個可選的字串，帶有型別註釋作為註釋"

#: ../../library/ast.rst:1756
#, fuzzy
msgid "A ``return`` statement."
msgstr "``return`` 語句。"

#: ../../library/ast.rst:1771
#, fuzzy
msgid ""
"A ``yield`` or ``yield from`` expression. Because these are expressions, "
"they must be wrapped in a :class:`Expr` node if the value sent back is not "
"used."
msgstr ""
"``yield`` 或 ``yield from`` "
"表達式。因為這些是表達式，所以如果不使用發回的值，則必須將它們包裝在 "
":class:`Expr` 節點中。"

#: ../../library/ast.rst:1796
#, fuzzy
msgid ""
"``global`` and ``nonlocal`` statements. ``names`` is a list of raw strings."
msgstr "``global`` 和 ``nonlocal`` 語句。 ``names`` 是原始字串的列表。"

#: ../../library/ast.rst:1823
#, fuzzy
msgid "A class definition."
msgstr "類定義。"

#: ../../library/ast.rst:1825
#, fuzzy
msgid "``name`` is a raw string for the class name"
msgstr "``name`` 是類名的原始字串"

#: ../../library/ast.rst:1826
#, fuzzy
msgid "``bases`` is a list of nodes for explicitly specified base classes."
msgstr "``bases`` 是明確指定的基底類別的節點列表。"

#: ../../library/ast.rst:1827
#, fuzzy
msgid ""
"``keywords`` is a list of :class:`keyword` nodes, principally for "
"'metaclass'. Other keywords will be passed to the metaclass, as per "
"`PEP-3115 <https://peps.python.org/pep-3115/>`_."
msgstr ""
"``keywords`` 是 :class:`keyword` 節點的列表，主要用於“元類”。根據`PEP-3115 "
"<https://peps.python.org/pep-3115/>`_，其他關鍵字將傳遞給元類。"

#: ../../library/ast.rst:1830
#, fuzzy
msgid ""
"``starargs`` and ``kwargs`` are each a single node, as in a function call. "
"starargs will be expanded to join the list of base classes, and kwargs will "
"be passed to the metaclass."
msgstr ""
"``starargs`` 和 ``kwargs`` 都是一個節點，就像在函式呼叫中一樣。 starargs "
"將被擴充以加入基底類別列表，並且 kwargs 將被傳遞給元類。"

#: ../../library/ast.rst:1833
#, fuzzy
msgid ""
"``body`` is a list of nodes representing the code within the class "
"definition."
msgstr "``body`` 是代表類定義中程式碼的節點列表。"

#: ../../library/ast.rst:1835
#, fuzzy
msgid "``decorator_list`` is a list of nodes, as in :class:`FunctionDef`."
msgstr "``decorator_list`` 是一個節點列表，如 :class:`FunctionDef`。"

#: ../../library/ast.rst:1864
#, fuzzy
msgid "Async and await"
msgstr "非同步和等待"

#: ../../library/ast.rst:1868
#, fuzzy
msgid ""
"An ``async def`` function definition. Has the same fields as :class:"
"`FunctionDef`."
msgstr "``async def`` 函式定義。與 FunctionDef 具有相同的欄位。"

#: ../../library/ast.rst:1874
#, fuzzy
msgid ""
"An ``await`` expression. ``value`` is what it waits for. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"一個 ``await`` 表達式。 ``value`` 是它等待的東西。僅在 "
":class:`AsyncFunctionDef` 的主體中有效。"

#: ../../library/ast.rst:1907
#, fuzzy
msgid ""
"``async for`` loops and ``async with`` context managers. They have the same "
"fields as :class:`For` and :class:`With`, respectively. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"``async for`` 循環和``async with`` 上下文管理器。它們分別具有與 :class:`For` "
"和 :class:`With` 相同的欄位。僅在 :class:`AsyncFunctionDef` 的主體中有效。"

#: ../../library/ast.rst:1912
#, fuzzy
msgid ""
"When a string is parsed by :func:`ast.parse`, operator nodes (subclasses of :"
"class:`ast.operator`, :class:`ast.unaryop`, :class:`ast.cmpop`, :class:`ast."
"boolop` and :class:`ast.expr_context`) on the returned tree will be "
"singletons. Changes to one will be reflected in all other occurrences of the "
"same value (e.g. :class:`ast.Add`)."
msgstr ""
"當字串被 ast.parse 解析時，運算符節點（ast.operator 的子類別、ast.unaryop、"
"ast.cmpop 的子類別、class： `ast.boolop` 和 :class:`ast.expr_context`) 在回傳"
"的樹上將是單例。對一個的更改將反映在所有其他出現的相同值中（例如 :class:`ast."
"Add`）。"

#: ../../library/ast.rst:1920
#, fuzzy
msgid ":mod:`ast` Helpers"
msgstr ":mod:`ast` 助手"

#: ../../library/ast.rst:1922
#, fuzzy
msgid ""
"Apart from the node classes, the :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr "除了節點類之外，:mod:`ast` 模組還定義了這些用於遍歷抽象語法樹的實用函式和類："

#: ../../library/ast.rst:1927
#, fuzzy
msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, ast.PyCF_ONLY_AST)``."
msgstr "將源解析為 AST 節點。相當於``compile(source, filename, mode, ast."
"PyCF_ONLY_AST)``。"

#: ../../library/ast.rst:1930
#, fuzzy
msgid ""
"If ``type_comments=True`` is given, the parser is modified to check and "
"return type comments as specified by :pep:`484` and :pep:`526`. This is "
"equivalent to adding :data:`ast.PyCF_TYPE_COMMENTS` to the flags passed to :"
"func:`compile()`.  This will report syntax errors for misplaced type "
"comments.  Without this flag, type comments will be ignored, and the "
"``type_comment`` field on selected AST nodes will always be ``None``.  In "
"addition, the locations of ``# type: ignore`` comments will be returned as "
"the ``type_ignores`` attribute of :class:`Module` (otherwise it is always an "
"empty list)."
msgstr ""
"如果給出 ``type_comments=True``，解析器將被修改為檢查並回傳 :pep:`484` 和 "
":pep:`526` 指定的型別註釋。這相當於將 :data:`ast.PyCF_TYPE_COMMENTS` "
"新增到傳遞給 :func:`compile()` 的旗標中。這將報告錯誤放置的型別註釋的語法錯誤"
"。如果沒有這個旗標，型別註釋將被忽略，並且所選 AST 節點上的 ``type_comment`` "
"欄位將始終為 ``None``。此外，``#type: ignore`` 註釋的位置將作為 "
":class:`Module` 的 ``type_ignores`` 屬性回傳（否則它始終是一個空列表）。"

#: ../../library/ast.rst:1940
#, fuzzy
msgid ""
"In addition, if ``mode`` is ``'func_type'``, the input syntax is modified to "
"correspond to :pep:`484` \"signature type comments\", e.g. ``(str, int) -> "
"List[str]``."
msgstr ""
"此外，如果 ``mode`` 是 "
"``'func_type'``，則修改輸入語法以對應於 :pep:`484`“簽名型別註釋”，例如``("
"str, int) -> List[str]``。"

#: ../../library/ast.rst:1944
#, fuzzy
msgid ""
"Also, setting ``feature_version`` to a tuple ``(major, minor)`` will attempt "
"to parse using that Python version's grammar. Currently ``major`` must equal "
"to ``3``.  For example, setting ``feature_version=(3, 4)`` will allow the "
"use of ``async`` and ``await`` as variable names.  The lowest supported "
"version is ``(3, 4)``; the highest is ``sys.version_info[0:2]``."
msgstr ""
"此外，將 ``feature_version`` 設定為元組 ``(major, minor)`` 將嘗試使用該 "
"Python 版本的語法進行解析。目前 ``major`` 必須等於 ``3``。例如，設定 "
"``feature_version=(3, 4)`` 將允許使用 ``async`` 和 ``await`` "
"作為變數名。支援的最低版本是``(3, 4)``；最高的是 ``sys.version_info[0:2]``。"

#: ../../library/ast.rst:1951
#, fuzzy
msgid ""
"If source contains a null character ('\\0'), :exc:`ValueError` is raised."
msgstr "如果 source 包含空字元 ('\\0')，則會引發 :exc:`ValueError`。"

#: ../../library/ast.rst:1954
#, fuzzy
msgid ""
"Note that successfully parsing source code into an AST object doesn't "
"guarantee that the source code provided is valid Python code that can be "
"executed as the compilation step can raise further :exc:`SyntaxError` "
"exceptions. For instance, the source ``return 42`` generates a valid AST "
"node for a return statement, but it cannot be compiled alone (it needs to be "
"inside a function node)."
msgstr ""
"請注意，成功將源程式碼解析為 AST "
"物件並不能保證提供的源程式碼是可以執行的有效 Python 程式碼，"
"因為編譯步驟可能會引發進一步的 :exc:`SyntaxError` 例外。例如，源“return 42”"
"為 return 語句生成一個有效的 AST "
"節點，但它不能單獨編譯（它需要在函式節點內）。"

#: ../../library/ast.rst:1961
#, fuzzy
msgid ""
"In particular, :func:`ast.parse` won't do any scoping checks, which the "
"compilation step does."
msgstr "特別是，:func:`ast.parse` 不會做任何範圍檢查，而編譯步驟會做。"

#: ../../library/ast.rst:1965
#, fuzzy
msgid ""
"It is possible to crash the Python interpreter with a sufficiently large/"
"complex string due to stack depth limitations in Python's AST compiler."
msgstr "由於 Python 的 AST 編譯器中的堆疊深度限制，使用足夠大/複雜的字串可能會使 "
"Python 直譯器崩潰。"

#: ../../library/ast.rst:1969
msgid "Added ``type_comments``, ``mode='func_type'`` and ``feature_version``."
msgstr ""
"新增 ``type_comments``\\ 、\\ ``mode='func_type'`` 與 ``feature_version``"
"\\ 。"

#: ../../library/ast.rst:1975
#, fuzzy
msgid ""
"Unparse an :class:`ast.AST` object and generate a string with code that "
"would produce an equivalent :class:`ast.AST` object if parsed back with :"
"func:`ast.parse`."
msgstr ""
"解析一個 :class:`ast.AST` 物件並生成一個字串，如果用 :func:`ast.parse` "
"解析回來，該字串將生成一個等效的 :class:`ast.AST` 物件。"

#: ../../library/ast.rst:1980
#, fuzzy
msgid ""
"The produced code string will not necessarily be equal to the original code "
"that generated the :class:`ast.AST` object (without any compiler "
"optimizations, such as constant tuples/frozensets)."
msgstr "生成的程式碼字串不一定與生成 ast.AST "
"物件的原始程式碼相同（沒有任何編譯器最佳化，例如常數元組/凍結集）。"

#: ../../library/ast.rst:1985
#, fuzzy
msgid ""
"Trying to unparse a highly complex expression would result with :exc:"
"`RecursionError`."
msgstr "嘗試解析一個高度複雜的表達式會導致 :exec:`RecursionError`。"

#: ../../library/ast.rst:1993
#, fuzzy
msgid ""
"Evaluate an expression node or a string containing only a Python literal or "
"container display.  The string or node provided may only consist of the "
"following Python literal structures: strings, bytes, numbers, tuples, lists, "
"dicts, sets, booleans, ``None`` and ``Ellipsis``."
msgstr ""
"評估僅包含 Python 文字或容器顯示的表達式節點或字串。"
"提供的字串或節點只能由以下 Python 文字結構組成：字串、位元組、數字、元組、列"
"表、字典、集合、布爾值、 ``None`` 和“省略號”。"

#: ../../library/ast.rst:1998
#, fuzzy
msgid ""
"This can be used for evaluating strings containing Python values without the "
"need to parse the values oneself.  It is not capable of evaluating "
"arbitrarily complex expressions, for example involving operators or indexing."
msgstr "這可用於評估包含 Python 值的字串，而無需自己解析值。它無法計算任意複雜的表達"
"式，例如涉及運算符或索引的表達式。"

#: ../../library/ast.rst:2003
#, fuzzy
msgid ""
"This function had been documented as \"safe\" in the past without defining "
"what that meant. That was misleading. This is specifically designed not to "
"execute Python code, unlike the more general :func:`eval`. There is no "
"namespace, no name lookups, or ability to call out. But it is not free from "
"attack: A relatively small input can lead to memory exhaustion or to C stack "
"exhaustion, crashing the process. There is also the possibility for "
"excessive CPU consumption denial of service on some inputs. Calling it on "
"untrusted data is thus not recommended."
msgstr ""
"此功能在過去被記錄為“安全”，但沒有定義其含義。那是誤導。與更通用的 "
":func:`eval` 不同，這是專門為不執行 Python 程式碼而設計的。沒有命名空間，沒有"
"名稱查找，也沒有呼叫的能力。但它並非沒有攻擊："
"相對較小的輸入可能導致記憶體耗盡或 C 堆疊耗盡，從而導致行程崩潰。"
"也有可能在某些輸入上出現過度 CPU "
"消耗拒絕服務。因此不建議在不受信任的資料上呼叫它。"

#: ../../library/ast.rst:2013
#, fuzzy
msgid ""
"It is possible to crash the Python interpreter due to stack depth "
"limitations in Python's AST compiler."
msgstr "由於 Python 的 AST 編譯器中的堆疊深度限制，Python 直譯器可能會崩潰。"

#: ../../library/ast.rst:2016
#, fuzzy
msgid ""
"It can raise :exc:`ValueError`, :exc:`TypeError`, :exc:`SyntaxError`, :exc:"
"`MemoryError` and :exc:`RecursionError` depending on the malformed input."
msgstr ""
"它可以引發 "
":exc:`ValueError`、:exc:`TypeError`、:exc:`SyntaxError`、:exc:`MemoryError` "
"和 :exc:`RecursionError`，具體取決於格式錯誤的輸入。"

#: ../../library/ast.rst:2020
#, fuzzy
msgid "Now allows bytes and set literals."
msgstr "現在允許位元組和設定文字。"

#: ../../library/ast.rst:2023
#, fuzzy
msgid "Now supports creating empty sets with ``'set()'``."
msgstr "現在支援使用 ``'set()'`` 建立空集。"

#: ../../library/ast.rst:2026
#, fuzzy
msgid "For string inputs, leading spaces and tabs are now stripped."
msgstr "對於字串輸入，前導空格和製表符現在被去除。"

#: ../../library/ast.rst:2032
#, fuzzy
msgid ""
"Return the docstring of the given *node* (which must be a :class:"
"`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, or :class:"
"`Module` node), or ``None`` if it has no docstring. If *clean* is true, "
"clean up the docstring's indentation with :func:`inspect.cleandoc`."
msgstr ""
"回傳給定 *node* 的文檔字串（必須是 FunctionDef、AsyncFunctionDef、ClassDef "
"或 Module 節點）或 None ` 如果它沒有文檔字串。如果 *clean* 為真，使用 "
"inspect.cleandoc 清理文檔字串的縮進。"

#: ../../library/ast.rst:2038
msgid ":class:`AsyncFunctionDef` is now supported."
msgstr "目前已支援 :class:`AsyncFunctionDef`\\ 。"

#: ../../library/ast.rst:2044
#, fuzzy
msgid ""
"Get source code segment of the *source* that generated *node*. If some "
"location information (:attr:`lineno`, :attr:`end_lineno`, :attr:"
"`col_offset`, or :attr:`end_col_offset`) is missing, return ``None``."
msgstr ""
"獲取生成 *node* 的 *source* 的源程式碼段。如果缺少某些位置資訊（:attr:`lineno"
"`、:attr:`end_lineno`、:attr:`col_offset` "
"或 :attr:`end_col_offset`），則回傳``None``。"

#: ../../library/ast.rst:2048
#, fuzzy
msgid ""
"If *padded* is ``True``, the first line of a multi-line statement will be "
"padded with spaces to match its original position."
msgstr "如果 *padded* 為 ``True``，多行語句的第一行將用空格填充以匹配其原始位置。"

#: ../../library/ast.rst:2056
#, fuzzy
msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects :"
"attr:`lineno` and :attr:`col_offset` attributes for every node that supports "
"them.  This is rather tedious to fill in for generated nodes, so this helper "
"adds these attributes recursively where not already set, by setting them to "
"the values of the parent node.  It works recursively starting at *node*."
msgstr ""
"當您使用 :func:`compile` 編譯節點樹時，編譯器期望每個支援它們的節點都有 "
":attr:`lineno` 和 :attr:`col_offset` 屬性。填充生成的節點相當乏味，因此此幫助"
"程式通過將這些屬性設定為父節點的值，遞迴地在尚未設定的地方新增這些屬性。它從 "
"*node* 開始遞迴工作。"

#: ../../library/ast.rst:2065
#, fuzzy
msgid ""
"Increment the line number and end line number of each node in the tree "
"starting at *node* by *n*. This is useful to \"move code\" to a different "
"location in a file."
msgstr "將樹中從 *node* 開始的每個節點的行號和結束行號增加 "
"*n*。這對於將程式碼“移動”到文件中的不同位置很有用。"

#: ../../library/ast.rst:2072
#, fuzzy
msgid ""
"Copy source location (:attr:`lineno`, :attr:`col_offset`, :attr:"
"`end_lineno`, and :attr:`end_col_offset`) from *old_node* to *new_node* if "
"possible, and return *new_node*."
msgstr ""
"如果可能，將源位置（:attr:`lineno`、:attr:`col_offset`、:attr:`end_lineno` "
"和 :attr:`end_col_offset`）從 *old_node* 複製到 *new_node*，並回傳 "
"*new_node*。"

#: ../../library/ast.rst:2079
#, fuzzy
msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields`` "
"that is present on *node*."
msgstr "為 *node* 上存在的 ``node._fields`` 中的每個欄位生成一個 ``(fieldname, "
"value)`` 的元組。"

#: ../../library/ast.rst:2085
#, fuzzy
msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are nodes "
"and all items of fields that are lists of nodes."
msgstr "產生 *node* "
"的所有直接子節點，即作為節點的所有欄位和作為節點列表的欄位的所有項。"

#: ../../library/ast.rst:2091
#, fuzzy
msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""
"遞迴地產生樹中從 *node* 開始的所有後代節點（包括 *node* "
"本身），沒有指定的順序。如果您只想就地修改節點而不關心上下文，這將很有用。"

#: ../../library/ast.rst:2098
#, fuzzy
msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a "
"visitor function for every node found.  This function may return a value "
"which is forwarded by the :meth:`visit` method."
msgstr "遍歷抽象語法樹並為找到的每個節點呼叫訪問者函式的節點訪問者基底類別。"
"此函式可能會回傳一個由 :meth:`visit` 方法轉發的值。"

#: ../../library/ast.rst:2102
#, fuzzy
msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr "此類旨在被子類別化，子類別新增訪問者方法。"

#: ../../library/ast.rst:2107
#, fuzzy
msgid ""
"Visit a node.  The default implementation calls the method called :samp:"
"`self.visit_{classname}` where *classname* is the name of the node class, "
"or :meth:`generic_visit` if that method doesn't exist."
msgstr ""
"訪問一個節點。預設實作呼叫名為 :samp:`self.visit_{classname}` 的方法，其中 "
"*classname* 是節點類的名稱，或者 :meth:`generic_visit` 如果該方法不存在。"

#: ../../library/ast.rst:2113
#, fuzzy
msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr "此訪問者對節點的所有子節點呼叫 :meth:`visit`。"

#: ../../library/ast.rst:2115
#, fuzzy
msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be "
"visited unless the visitor calls :meth:`generic_visit` or visits them itself."
msgstr "請注意，除非訪問者呼叫 :meth:`generic_visit` "
"或自己訪問它們，否則不會訪問具有自定義訪問者方法的節點的子節點。"

#: ../../library/ast.rst:2119
#, fuzzy
msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists (:class:"
"`NodeTransformer`) that allows modifications."
msgstr ""
"如果您想在遍歷期間對節點應用更改，請不要使用 NodeVisitor。為此，"
"存在允許修改的特殊訪問者 (:class:`NodeTransformer`)。"

#: ../../library/ast.rst:2125
#, fuzzy
msgid ""
"Methods :meth:`visit_Num`, :meth:`visit_Str`, :meth:`visit_Bytes`, :meth:"
"`visit_NameConstant` and :meth:`visit_Ellipsis` are deprecated now and will "
"not be called in future Python versions.  Add the :meth:`visit_Constant` "
"method to handle all constant nodes."
msgstr ""
"方法 :meth:`visit_Num`、:meth:`visit_Str`、:meth:`visit_Bytes`、:meth:`visit_"
"NameConstant` 和 :meth:`visit_Ellipsis` 現在已棄用，在未來的 Python "
"版本中不會被呼叫。新增 :meth:`visit_Constant` 方法來處理所有常數節點。"

#: ../../library/ast.rst:2133
#, fuzzy
msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr "遍歷抽象語法樹並允許修改節點的 :class:`NodeVisitor` 子類別。"

#: ../../library/ast.rst:2136
#, fuzzy
msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value of "
"the visitor methods to replace or remove the old node.  If the return value "
"of the visitor method is ``None``, the node will be removed from its "
"location, otherwise it is replaced with the return value.  The return value "
"may be the original node in which case no replacement takes place."
msgstr ""
":class:`NodeTransformer` 將遍歷 AST "
"並使用訪問者方法的回傳值來替換或刪除舊節點。如果 visitor 方法的回傳值為 ``None``"
"，節點將從其所在位置移除，否則用回傳值替換。回傳值可能是原始節點，在這種情況"
"下不會發生替換。"

#: ../../library/ast.rst:2142
#, fuzzy
msgid ""
"Here is an example transformer that rewrites all occurrences of name lookups "
"(``foo``) to ``data['foo']``::"
msgstr "這是一個示例轉換器，它將所有出現的名稱查找 (``foo``) 重寫為 ``data['foo']``::"

#: ../../library/ast.rst:2154
#, fuzzy
msgid ""
"Keep in mind that if the node you're operating on has child nodes you must "
"either transform the child nodes yourself or call the :meth:`generic_visit` "
"method for the node first."
msgstr "請記住，如果您正在操作的節點有子節點，您必須自己轉換子節點或先呼叫該節點的 "
":meth:`generic_visit` 方法。"

#: ../../library/ast.rst:2158
#, fuzzy
msgid ""
"For nodes that were part of a collection of statements (that applies to all "
"statement nodes), the visitor may also return a list of nodes rather than "
"just a single node."
msgstr "對於作為語句集合一部分的節點（適用於所有語句節點），訪問者還可以回傳一個節點"
"列表，而不僅僅是一個節點。"

#: ../../library/ast.rst:2162
#, fuzzy
msgid ""
"If :class:`NodeTransformer` introduces new nodes (that weren't part of "
"original tree) without giving them location information (such as :attr:"
"`lineno`), :func:`fix_missing_locations` should be called with the new sub-"
"tree to recalculate the location information::"
msgstr ""
"如果 :class:`NodeTransformer` "
"引入了新節點（不是原始樹的一部分）而不給它們位置資訊（例如 "
":attr:`lineno`），:func:`fix_missing_locations` "
"應該用新的子呼叫重新計算位置資訊的樹::"

#: ../../library/ast.rst:2170
#, fuzzy
msgid "Usually you use the transformer like this::"
msgstr "通常你像這樣使用變壓器::"

#: ../../library/ast.rst:2177
#, fuzzy
msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for "
"debugging purposes.  If *annotate_fields* is true (by default), the returned "
"string will show the names and the values for fields. If *annotate_fields* "
"is false, the result string will be more compact by omitting unambiguous "
"field names.  Attributes such as line numbers and column offsets are not "
"dumped by default.  If this is wanted, *include_attributes* can be set to "
"true."
msgstr ""
"回傳 *node* 中樹的格式化轉儲。這主要用於除錯目的。如果 *annotate_fields* 為 "
"true（預設情況下），則回傳的字串將顯示欄位的名稱和值。如果 *annotate_fields* "
"為 false，則通過省略明確的欄位名稱，結果字串將更加緊湊。預設情況下不會轉儲行"
"號和列偏移量等屬性。如果需要，*include_attributes* 可以設定為 true。"

#: ../../library/ast.rst:2185
#, fuzzy
msgid ""
"If *indent* is a non-negative integer or string, then the tree will be "
"pretty-printed with that indent level.  An indent level of 0, negative, or ``"
"\"\"`` will only insert newlines.  ``None`` (the default) selects the single "
"line representation. Using a positive integer indent indents that many "
"spaces per level.  If *indent* is a string (such as ``\"\\t\"``), that "
"string is used to indent each level."
msgstr ""
"如果 *indent* 是一個非負整數或字串，那麼樹將使用該縮進級別進行漂亮印出。"
"縮進級別為 0、負數或 ``\"\"`` 只會插入換行符。 "
"``None``（預設值）選擇單線表示。使用正整數縮進會在每個級別縮進多少個空格。"
"如果 *indent* 是一個字串（例如 ``\"\\t\"``），該字串用於縮進每個級別。"

#: ../../library/ast.rst:2192
msgid "Added the *indent* option."
msgstr "新增 *indent* 選項。"

#: ../../library/ast.rst:2199
#, fuzzy
msgid "Compiler Flags"
msgstr "編譯器旗標"

#: ../../library/ast.rst:2201
#, fuzzy
msgid ""
"The following flags may be passed to :func:`compile` in order to change "
"effects on the compilation of a program:"
msgstr "以下旗標可以傳遞給 :func:`compile` 以改變對程式編譯的影響："

#: ../../library/ast.rst:2206
#, fuzzy
msgid ""
"Enables support for top-level ``await``, ``async for``, ``async with`` and "
"async comprehensions."
msgstr "啟用對頂級 ``await``、``async for``、``async with`` 和非同步理解的支援。"

#: ../../library/ast.rst:2213
#, fuzzy
msgid ""
"Generates and returns an abstract syntax tree instead of returning a "
"compiled code object."
msgstr "生成並回傳抽象語法樹，而不是回傳編譯後的程式碼物件。"

#: ../../library/ast.rst:2218
#, fuzzy
msgid ""
"Enables support for :pep:`484` and :pep:`526` style type comments (``# type: "
"<type>``, ``# type: ignore <stuff>``)."
msgstr ""
"啟用對 :pep:`484` 和 :pep:`526` 樣式型別註釋的支援（``# type: <type>``、``# "
"type: ignore <stuff>``）。"

#: ../../library/ast.rst:2227
#, fuzzy
msgid "Command-Line Usage"
msgstr "命令列用法"

#: ../../library/ast.rst:2231
#, fuzzy
msgid ""
"The :mod:`ast` module can be executed as a script from the command line. It "
"is as simple as:"
msgstr ":mod:`ast` 模組可以作為腳本從命令列執行。很簡單："

#: ../../library/ast.rst:2238
#, fuzzy
msgid "The following options are accepted:"
msgstr "接受以下選項："

#: ../../library/ast.rst:2244
#, fuzzy
msgid "Show the help message and exit."
msgstr "顯示幫助資訊並退出。"

#: ../../library/ast.rst:2249
#, fuzzy
msgid ""
"Specify what kind of code must be compiled, like the *mode* argument in :"
"func:`parse`."
msgstr "指定必須編譯哪種程式碼，如 :func:`parse` 中的 *mode* 參數。"

#: ../../library/ast.rst:2254
#, fuzzy
msgid "Don't parse type comments."
msgstr "不要解析型別註釋。"

#: ../../library/ast.rst:2258
#, fuzzy
msgid "Include attributes such as line numbers and column offsets."
msgstr "包括行號和列偏移量等屬性。"

#: ../../library/ast.rst:2263
#, fuzzy
msgid "Indentation of nodes in AST (number of spaces)."
msgstr "AST 中節點的縮進（空格數）。"

#: ../../library/ast.rst:2265
#, fuzzy
msgid ""
"If :file:`infile` is specified its contents are parsed to AST and dumped to "
"stdout.  Otherwise, the content is read from stdin."
msgstr "如果 :file:`infile` 被指定，它的內容被解析為 AST "
"並轉儲到標準輸出。否則，內容從標準輸入讀取。"

#: ../../library/ast.rst:2271
#, fuzzy
msgid ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, an external "
"documentation resource, has good details on working with Python ASTs."
msgstr ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_ "
"是一個外部文檔資源，其中包含有關使用 Python AST 的詳細資訊。"

#: ../../library/ast.rst:2274
#, fuzzy
msgid ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"annotates Python ASTs with the positions of tokens and text in the source "
"code that generated them. This is helpful for tools that make source code "
"transformations."
msgstr ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"用生成它們的源程式碼中的標記和文本的位置註釋 Python "
"AST。這對於進行源程式碼轉換的工具很有幫助。"

#: ../../library/ast.rst:2279
#, fuzzy
msgid ""
"`leoAst.py <https://leoeditor.com/appendices.html#leoast-py>`_ unifies the "
"token-based and parse-tree-based views of python programs by inserting two-"
"way links between tokens and ast nodes."
msgstr ""
"`leoAst.py <https://leoeditor.com/appendices.html#leoast-py>`_ 通過在標記和 "
"ast 節點之間插入雙向鏈接，統一了 python 程式的基於標記和基於解析樹的視圖。"

#: ../../library/ast.rst:2283
#, fuzzy
msgid ""
"`LibCST <https://libcst.readthedocs.io/>`_ parses code as a Concrete Syntax "
"Tree that looks like an ast tree and keeps all formatting details. It's "
"useful for building automated refactoring (codemod) applications and linters."
msgstr ""
"`LibCST <https://libcst.readthedocs.io/>`_ "
"將程式碼解析為看起來像 ast 樹的具體語法樹，並保留所有格式細節。"
"它對於構建自動重構 (codemod) 應用程式和 linters 很有用。"

#: ../../library/ast.rst:2288
#, fuzzy
msgid ""
"`Parso <https://parso.readthedocs.io>`_ is a Python parser that supports "
"error recovery and round-trip parsing for different Python versions (in "
"multiple Python versions). Parso is also able to list multiple syntax errors "
"in your python file."
msgstr ""
"`Parso <https://parso.readthedocs.io>`_ 是一個 Python 解析器，支援針對不同 "
"Python 版本（在多個 Python 版本中）的錯誤恢復和往返解析。 Parso 還能夠列出 "
"python 文件中的多個語法錯誤。"
