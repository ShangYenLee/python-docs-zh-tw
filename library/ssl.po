# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-25 00:15+0000\n"
"PO-Revision-Date: 2018-05-23 16:10+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/ssl.rst:2
msgid ":mod:`ssl` --- TLS/SSL wrapper for socket objects"
msgstr ":mod:`ssl` ---  socket 物件的 TLS/SSL 包裝器"

#: ../../library/ssl.rst:10
msgid "**Source code:** :source:`Lib/ssl.py`"
msgstr "**原始碼：**\\ :source:`Lib/ssl.py`"

#: ../../library/ssl.rst:18
#, fuzzy
msgid ""
"This module provides access to Transport Layer Security (often known as "
"\"Secure Sockets Layer\") encryption and peer authentication facilities for "
"network sockets, both client-side and server-side.  This module uses the "
"OpenSSL library. It is available on all modern Unix systems, Windows, macOS, "
"and probably additional platforms, as long as OpenSSL is installed on that "
"platform."
msgstr ""
"該模組為客戶端和伺服器端的網絡 socket 提供對傳輸層安全（通常稱為“安全 socket 層”"
"）加密和對等身份驗證設施的訪問。該模組使用 OpenSSL 庫。它在所有現代 Unix "
"系統、Windows、macOS 和可能的其他平台上都可用，只要在該平台上安裝了 OpenSSL。"

#: ../../library/ssl.rst:26
#, fuzzy
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs.  The installed version of OpenSSL may also "
"cause variations in behavior. For example, TLSv1.3 with OpenSSL version "
"1.1.1."
msgstr ""
"某些行為可能取決於平台，因為呼叫是對操作系統 socket  API 進行的。安裝的 "
"OpenSSL 版本也可能導致行為發生變化。例如，帶有 OpenSSL 版本 1.1.1 的 TLSv1."
"3。"

#: ../../library/ssl.rst:32
#, fuzzy
msgid ""
"Don't use this module without reading the :ref:`ssl-security`.  Doing so may "
"lead to a false sense of security, as the default settings of the ssl module "
"are not necessarily appropriate for your application."
msgstr ""
"請勿在未閱讀 :ref:`ssl-security` "
"的情況下使用此模組。這樣做可能會導致錯誤的安全感，因為 ssl "
"模組的預設設定不一定適合您的應用程式。"

#: ../../includes/wasm-notavail.rst:3
#, fuzzy
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ":ref:`Availability <availability>`：不是 Emscripten，不是 WASI。"

#: ../../includes/wasm-notavail.rst:5
#, fuzzy
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"此模組在 WebAssembly 平台 ``wasm32-emscripten`` 和 ``wasm32-wasi`` 上不起作用或不可用"
"。有關更多資訊，請參閱 :ref:`wasm-availability`。"

#: ../../library/ssl.rst:38
#, fuzzy
msgid ""
"This section documents the objects and functions in the ``ssl`` module; for "
"more general information about TLS, SSL, and certificates, the reader is "
"referred to the documents in the \"See Also\" section at the bottom."
msgstr "本節記錄 ssl 模組中的物件和函式；有關 TLS、SSL "
"和證書的更多一般資訊，請讀者參閱底部“另請參閱”部分中的文檔。"

#: ../../library/ssl.rst:42
#, fuzzy
msgid ""
"This module provides a class, :class:`ssl.SSLSocket`, which is derived from "
"the :class:`socket.socket` type, and provides a socket-like wrapper that "
"also encrypts and decrypts the data going over the socket with SSL.  It "
"supports additional methods such as :meth:`getpeercert`, which retrieves the "
"certificate of the other side of the connection, and :meth:`cipher`, which "
"retrieves the cipher being used for the secure connection."
msgstr ""
"這個模組提供了一個類，ssl.SSLSocket，它派生自 socket.socket "
"型別，並提供了一個類似 socket 的包裝器，它也使用 SSL "
"加密和解密通過 socket 傳輸的資料.它支援其他方法，例如 :meth:`getpeercert`，它檢"
"索連接另一端的證書，以及 :meth:`cipher`，它檢索用於安全連接的密碼。"

#: ../../library/ssl.rst:49
#, fuzzy
msgid ""
"For more sophisticated applications, the :class:`ssl.SSLContext` class helps "
"manage settings and certificates, which can then be inherited by SSL sockets "
"created through the :meth:`SSLContext.wrap_socket` method."
msgstr ""
"對於更複雜的應用程式，:class:`ssl.SSLContext` 類有助於管理設定和證書，"
"然後可以通過 :meth:`SSLContext.wrap_socket` 方法建立的 SSL "
" socket 繼承這些設定和證書。"

#: ../../library/ssl.rst:53
#, fuzzy
msgid "Updated to support linking with OpenSSL 1.1.0"
msgstr "更新以支援與 OpenSSL 1.1.0 的鏈接"

#: ../../library/ssl.rst:58
#, fuzzy
msgid ""
"OpenSSL 0.9.8, 1.0.0 and 1.0.1 are deprecated and no longer supported. In "
"the future the ssl module will require at least OpenSSL 1.0.2 or 1.1.0."
msgstr ""
"OpenSSL 0.9.8、1.0.0 和 1.0.1 已棄用，不再受支援。將來 ssl 模組將至少需要 "
"OpenSSL 1.0.2 或 1.1.0。"

#: ../../library/ssl.rst:64
#, fuzzy
msgid ""
":pep:`644` has been implemented. The ssl module requires OpenSSL 1.1.1 or "
"newer."
msgstr ":pep:`644` 已經實作。 ssl 模組需要 OpenSSL 1.1.1 或更新版本。"

#: ../../library/ssl.rst:67
#, fuzzy
msgid ""
"Use of deprecated constants and functions result in deprecation warnings."
msgstr "使用棄用的常數和函式會導致棄用警告。"

#: ../../library/ssl.rst:71
msgid "Functions, Constants, and Exceptions"
msgstr "函式、常數與例外"

#: ../../library/ssl.rst:75
#, fuzzy
msgid "Socket creation"
msgstr " socket 建立"

#: ../../library/ssl.rst:77
#, fuzzy
msgid ""
"Since Python 3.2 and 2.7.9, it is recommended to use the :meth:`SSLContext."
"wrap_socket` of an :class:`SSLContext` instance to wrap sockets as :class:"
"`SSLSocket` objects. The helper functions :func:`create_default_context` "
"returns a new context with secure default settings. The old :func:"
"`wrap_socket` function is deprecated since it is both inefficient and has no "
"support for server name indication (SNI) and hostname matching."
msgstr ""
"從 Python 3.2 和 2.7.9 開始，建議使用 SSLContext 實例的 "
"SSLContext.wrap_socket 將 socket 包裝為 SSLSocket 物件。輔助函式 "
":func:`create_default_context` 回傳具有安全預設設定的新上下文。舊的 "
":func:`wrap_socket` 函式已被棄用，因為它既低效又不支援伺服器名稱指示 (SNI) "
"和主機名匹配。"

#: ../../library/ssl.rst:85
#, fuzzy
msgid "Client socket example with default context and IPv4/IPv6 dual stack::"
msgstr "具有預設上下文和 IPv4/IPv6 雙堆疊的客戶端 socket 示例::"

#: ../../library/ssl.rst:98
#, fuzzy
msgid "Client socket example with custom context and IPv4::"
msgstr "具有自定義上下文和 IPv4:: 的客戶端 socket 示例"

#: ../../library/ssl.rst:110
#, fuzzy
msgid "Server socket example listening on localhost IPv4::"
msgstr "伺服器 socket 示例監聽 localhost IPv4::"

#: ../../library/ssl.rst:124
#, fuzzy
msgid "Context creation"
msgstr "上下文建立"

#: ../../library/ssl.rst:126
#, fuzzy
msgid ""
"A convenience function helps create :class:`SSLContext` objects for common "
"purposes."
msgstr "一個方便的函式可以幫助建立 :class:`SSLContext` 對像用於常見目的。"

#: ../../library/ssl.rst:131
#, fuzzy
msgid ""
"Return a new :class:`SSLContext` object with default settings for the given "
"*purpose*.  The settings are chosen by the :mod:`ssl` module, and usually "
"represent a higher security level than when calling the :class:`SSLContext` "
"constructor directly."
msgstr ""
"回傳一個新的 :class:`SSLContext` 物件，它具有給定 *purpose* 的預設設定。"
"這些設定由 :mod:`ssl` 模組選擇，通常代表比直接呼叫 :class:`SSLContext` "
"構造函式時更高的安全級別。"

#: ../../library/ssl.rst:136
#, fuzzy
msgid ""
"*cafile*, *capath*, *cadata* represent optional CA certificates to trust for "
"certificate verification, as in :meth:`SSLContext.load_verify_locations`.  "
"If all three are :const:`None`, this function can choose to trust the "
"system's default CA certificates instead."
msgstr ""
"*cafile*、*capath*、*cadata* 表示可選的 CA 證書以信任證書驗證，如 "
"SSLContext.load_verify_locations 中所示。如果這三個都是 :const:`None`，"
"這個函式可以選擇信任系統預設的 CA 證書。"

#: ../../library/ssl.rst:142
#, fuzzy
msgid ""
"The settings are: :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER`, :data:`OP_NO_SSLv2`, and :data:`OP_NO_SSLv3` with "
"high encryption cipher suites without RC4 and without unauthenticated cipher "
"suites. Passing :data:`~Purpose.SERVER_AUTH` as *purpose* sets :data:"
"`~SSLContext.verify_mode` to :data:`CERT_REQUIRED` and either loads CA "
"certificates (when at least one of *cafile*, *capath* or *cadata* is given) "
"or uses :meth:`SSLContext.load_default_certs` to load default CA "
"certificates."
msgstr ""
"設定是：:data:`PROTOCOL_TLS_CLIENT` "
"或 :data:`PROTOCOL_TLS_SERVER`、:data:`OP_NO_SSLv2` "
"和 :data:`OP_NO_SSLv3` 具有高加密密碼套件，沒有 RC4 "
"和未經身份驗證的密碼套件。將 :data:`~Purpose.SERVER_AUTH` 作為 *purpose* "
"設定 :data:`~SSLContext.verify_mode` 為 :data:`CERT_REQUIRED` 並加載 CA "
"證書（當至少有一個 *cafile*、*capath* 或*cadata* 已給出）或使用 "
":meth:`SSLContext.load_default_certs` 加載預設 CA 證書。"

#: ../../library/ssl.rst:151
#, fuzzy
msgid ""
"When :attr:`~SSLContext.keylog_filename` is supported and the environment "
"variable :envvar:`SSLKEYLOGFILE` is set, :func:`create_default_context` "
"enables key logging."
msgstr ""
"當支援 :attr:`~SSLContext.keylog_filename` 並設定環境變數 "
":envvar:`SSLKEYLOGFILE` 時，:func:`create_default_context` 啟用按鍵記錄。"

#: ../../library/ssl.rst:156
#, fuzzy
msgid ""
"The protocol, options, cipher and other settings may change to more "
"restrictive values anytime without prior deprecation.  The values represent "
"a fair balance between compatibility and security."
msgstr "協定、選項、密碼和其他設定可能會隨時更改為更具限制性的值，而無需事先棄用。這"
"些值代表相容性和安全性之間的公平平衡。"

#: ../../library/ssl.rst:160
#, fuzzy
msgid ""
"If your application needs specific settings, you should create a :class:"
"`SSLContext` and apply the settings yourself."
msgstr "如果您的應用程式需要特定設定，您應該建立一個 :class:`SSLContext` "
"並自己應用這些設定。"

#: ../../library/ssl.rst:164
#, fuzzy
msgid ""
"If you find that when certain older clients or servers attempt to connect "
"with a :class:`SSLContext` created by this function that they get an error "
"stating \"Protocol or cipher suite mismatch\", it may be that they only "
"support SSL3.0 which this function excludes using the :data:`OP_NO_SSLv3`. "
"SSL3.0 is widely considered to be `completely broken <https://en.wikipedia."
"org/wiki/POODLE>`_. If you still wish to continue to use this function but "
"still allow SSL 3.0 connections you can re-enable them using::"
msgstr ""
"如果您發現某些較舊的客戶端或伺服器嘗試連接由此函式建立的 :class:`SSLContext` "
"時出現“協定或密碼套件不匹配”錯誤，則可能是它們僅支援 SSL3.0此函式不使用 "
":data:`OP_NO_SSLv3`。 SSL3.0 被廣泛認為是`完全破壞 <https://en.wikipedia.org/"
"wiki/POODLE>`_。如果您仍希望繼續使用此功能但仍允許 SSL 3.0 "
"連接，您可以使用以下方式重新啟用它們："

#: ../../library/ssl.rst:180
#, fuzzy
msgid "RC4 was dropped from the default cipher string."
msgstr "RC4 已從預設密碼字串中刪除。"

#: ../../library/ssl.rst:184
#, fuzzy
msgid "ChaCha20/Poly1305 was added to the default cipher string."
msgstr "ChaCha20/Poly1305 新增到預設密碼字串。"

#: ../../library/ssl.rst:186
#, fuzzy
msgid "3DES was dropped from the default cipher string."
msgstr "3DES 已從預設密碼字串中刪除。"

#: ../../library/ssl.rst:190
#, fuzzy
msgid "Support for key logging to :envvar:`SSLKEYLOGFILE` was added."
msgstr "新增了對鍵記錄到 SSLKEYLOGFILE 的支援。"

#: ../../library/ssl.rst:194
#, fuzzy
msgid ""
"The context now uses :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER` protocol instead of generic :data:`PROTOCOL_TLS`."
msgstr ""
"上下文現在使用 :data:`PROTOCOL_TLS_CLIENT` 或 :data:`PROTOCOL_TLS_SERVER` "
"協定，而不是通用的 :data:`PROTOCOL_TLS`。"

#: ../../library/ssl.rst:200
msgid "Exceptions"
msgstr "例外"

#: ../../library/ssl.rst:204
#, fuzzy
msgid ""
"Raised to signal an error from the underlying SSL implementation (currently "
"provided by the OpenSSL library).  This signifies some problem in the higher-"
"level encryption and authentication layer that's superimposed on the "
"underlying network connection.  This error is a subtype of :exc:`OSError`.  "
"The error code and message of :exc:`SSLError` instances are provided by the "
"OpenSSL library."
msgstr ""
"引發以表示來自底層 SSL 實作的錯誤（當前由 OpenSSL 庫提供）。這表示疊加在底層"
"網絡連接上的更高階別的加密和身份驗證層存在一些問題。此錯誤是 :exc:`OSError` "
"的子型別。 :exc:`SSLError` 實例的錯誤程式碼和消息由 OpenSSL 庫提供。"

#: ../../library/ssl.rst:211
#, fuzzy
msgid ":exc:`SSLError` used to be a subtype of :exc:`socket.error`."
msgstr ":exc:`SSLError` 曾經是 :exc:`socket.error` 的子型別。"

#: ../../library/ssl.rst:216
#, fuzzy
msgid ""
"A string mnemonic designating the OpenSSL submodule in which the error "
"occurred, such as ``SSL``, ``PEM`` or ``X509``.  The range of possible "
"values depends on the OpenSSL version."
msgstr ""
"指定發生錯誤的 OpenSSL 子模組的字串助記符，例如 ``SSL``、``PEM`` 或 "
"``X509``。可能值的範圍取決於 OpenSSL 版本。"

#: ../../library/ssl.rst:224
#, fuzzy
msgid ""
"A string mnemonic designating the reason this error occurred, for example "
"``CERTIFICATE_VERIFY_FAILED``.  The range of possible values depends on the "
"OpenSSL version."
msgstr "指定此錯誤發生原因的字串助記符，例如 ``CERTIFICATE_VERIFY_FAILED``。"
"可能值的範圍取決於 OpenSSL 版本。"

#: ../../library/ssl.rst:232
#, fuzzy
msgid ""
"A subclass of :exc:`SSLError` raised when trying to read or write and the "
"SSL connection has been closed cleanly.  Note that this doesn't mean that "
"the underlying transport (read TCP) has been closed."
msgstr ""
":exc:`SSLError` 的子類別在嘗試讀取或寫入時引發，並且 SSL "
"連接已完全關閉。請注意，這並不意味著底層傳輸（讀取 TCP）已關閉。"

#: ../../library/ssl.rst:240
#, fuzzy
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket <ssl-"
"nonblocking>` when trying to read or write data, but more data needs to be "
"received on the underlying TCP transport before the request can be fulfilled."
msgstr ""
"嘗試讀取或寫入資料時由非阻塞 SSL  socket  <ssl-nonblocking> 引發的 "
":exc:`SSLError` 的子類別，但在請求之前需要在底層 TCP "
"傳輸上接收更多資料可以實作。"

#: ../../library/ssl.rst:249
#, fuzzy
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket <ssl-"
"nonblocking>` when trying to read or write data, but more data needs to be "
"sent on the underlying TCP transport before the request can be fulfilled."
msgstr ""
"嘗試讀取或寫入資料時由非阻塞 SSL  socket  <ssl-nonblocking> 引發的 "
":exc:`SSLError` 的子類別，但在請求之前需要在底層 TCP "
"傳輸上發送更多資料可以實作。"

#: ../../library/ssl.rst:258
#, fuzzy
msgid ""
"A subclass of :exc:`SSLError` raised when a system error was encountered "
"while trying to fulfill an operation on a SSL socket.  Unfortunately, there "
"is no easy way to inspect the original errno number."
msgstr ":exc:`SSLError` 的子類別在嘗試完成 SSL  socket 上的操作時遇到系統錯誤時引發。不"
"幸的是，沒有簡單的方法來檢查原始錯誤號。"

#: ../../library/ssl.rst:266
#, fuzzy
msgid ""
"A subclass of :exc:`SSLError` raised when the SSL connection has been "
"terminated abruptly.  Generally, you shouldn't try to reuse the underlying "
"transport when this error is encountered."
msgstr ":exc:`SSLError` 的子類別在 SSL "
"連接突然終止時引發。通常，遇到此錯誤時，您不應嘗試重用底層傳輸。"

#: ../../library/ssl.rst:274
#, fuzzy
msgid ""
"A subclass of :exc:`SSLError` raised when certificate validation has failed."
msgstr ":exc:`SSLError` 的子類別在證書驗證失敗時引發。"

#: ../../library/ssl.rst:281
#, fuzzy
msgid "A numeric error number that denotes the verification error."
msgstr "表示驗證錯誤的數字錯誤編號。"

#: ../../library/ssl.rst:285
#, fuzzy
msgid "A human readable string of the verification error."
msgstr "驗證錯誤的人類可讀字串。"

#: ../../library/ssl.rst:289
#, fuzzy
msgid "An alias for :exc:`SSLCertVerificationError`."
msgstr ":exc:`SSLCertVerificationError` 的別名。"

#: ../../library/ssl.rst:291
#, fuzzy
msgid "The exception is now an alias for :exc:`SSLCertVerificationError`."
msgstr "該例外現在是 :exc:`SSLCertVerificationError` 的別名。"

#: ../../library/ssl.rst:296
#, fuzzy
msgid "Random generation"
msgstr "隨機生成"

#: ../../library/ssl.rst:300
#, fuzzy
msgid ""
"Return *num* cryptographically strong pseudo-random bytes. Raises an :class:"
"`SSLError` if the PRNG has not been seeded with enough data or if the "
"operation is not supported by the current RAND method. :func:`RAND_status` "
"can be used to check the status of the PRNG and :func:`RAND_add` can be used "
"to seed the PRNG."
msgstr ""
"回傳 *num* 個加密強度高的偽隨機位元組。如果 PRNG 沒有植入足夠的資料或者當前 "
"RAND 方法不支援該操作，則引發 SSLError。 :func:`RAND_status` 可用於檢查 PRNG "
"的狀態，而 :func:`RAND_add` 可用於為 PRNG 播種。"

#: ../../library/ssl.rst:306 ../../library/ssl.rst:327
#, fuzzy
msgid "For almost all applications :func:`os.urandom` is preferable."
msgstr "對於幾乎所有的應用程式， :func:`os.urandom` 是更可取的。"

#: ../../library/ssl.rst:308
#, fuzzy
msgid ""
"Read the Wikipedia article, `Cryptographically secure pseudorandom number "
"generator (CSPRNG) <https://en.wikipedia.org/wiki/"
"Cryptographically_secure_pseudorandom_number_generator>`_, to get the "
"requirements of a cryptographically strong generator."
msgstr ""
"閱讀維基百科文章，`加密安全偽隨機數生成器 (CSPRNG) <https://en.wikipedia.org/"
"wiki/Cryptographically_secure_pseudorandom_number_generator>`_，了解強大的加"
"密生成器的要求。"

#: ../../library/ssl.rst:317
#, fuzzy
msgid ""
"Return (bytes, is_cryptographic): bytes are *num* pseudo-random bytes, "
"is_cryptographic is ``True`` if the bytes generated are cryptographically "
"strong. Raises an :class:`SSLError` if the operation is not supported by the "
"current RAND method."
msgstr ""
"回傳（位元組，is_cryptographic）：位元組是*num*個偽隨機位元組，is_cryptograph"
"ic如果生成的位元組是加密強的，則為 ``True``。如果當前 RAND 方法不支援該操作，"
"則引發 SSLError。"

#: ../../library/ssl.rst:322
#, fuzzy
msgid ""
"Generated pseudo-random byte sequences will be unique if they are of "
"sufficient length, but are not necessarily unpredictable. They can be used "
"for non-cryptographic purposes and for certain purposes in cryptographic "
"protocols, but usually not for key generation etc."
msgstr "如果生成的偽隨機位元組序列足夠長，它們將是唯一的，但不一定是不可預測的。它們"
"可用於非加密目的和加密協定中的某些目的，但通常不用於密鑰生成等。"

#: ../../library/ssl.rst:333
#, fuzzy
msgid ""
"OpenSSL has deprecated :func:`ssl.RAND_pseudo_bytes`, use :func:`ssl."
"RAND_bytes` instead."
msgstr "OpenSSL 已棄用 :func:`ssl.RAND_pseudo_bytes`，改用 :func:`ssl.RAND_bytes`。"

#: ../../library/ssl.rst:338
#, fuzzy
msgid ""
"Return ``True`` if the SSL pseudo-random number generator has been seeded "
"with 'enough' randomness, and ``False`` otherwise.  You can use :func:`ssl."
"RAND_egd` and :func:`ssl.RAND_add` to increase the randomness of the pseudo-"
"random number generator."
msgstr ""
"如果 SSL "
"偽隨機數生成器已被“足夠”的隨機性播種，則回傳 ``True``，否則回傳 ``False``。"
"您可以使用 :func:`ssl.RAND_egd` 和 :func:`ssl.RAND_add` "
"來增加偽隨機數生成器的隨機性。"

#: ../../library/ssl.rst:345
#, fuzzy
msgid ""
"Mix the given *bytes* into the SSL pseudo-random number generator.  The "
"parameter *entropy* (a float) is a lower bound on the entropy contained in "
"string (so you can always use :const:`0.0`).  See :rfc:`1750` for more "
"information on sources of entropy."
msgstr ""
"將給定的 *bytes* 混合到 SSL 偽隨機數生成器中。參數 "
"*entropy*（浮點數）是字串中包含的熵的下限（因此您始終可以使用 :const:`0."
"0`）。有關熵源的更多資訊，請參閱 :rfc:`1750`。"

#: ../../library/ssl.rst:350
#, fuzzy
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "可寫 :term:`bytes-like object` 現在被接受。"

#: ../../library/ssl.rst:354
#, fuzzy
msgid "Certificate handling"
msgstr "證書辦理"

#: ../../library/ssl.rst:362
#, fuzzy
msgid ""
"Verify that *cert* (in decoded format as returned by :meth:`SSLSocket."
"getpeercert`) matches the given *hostname*.  The rules applied are those for "
"checking the identity of HTTPS servers as outlined in :rfc:`2818`, :rfc:"
"`5280` and :rfc:`6125`.  In addition to HTTPS, this function should be "
"suitable for checking the identity of servers in various SSL-based protocols "
"such as FTPS, IMAPS, POPS and others."
msgstr ""
"驗證 *cert*（由 :meth:`SSLSocket.getpeercert` 回傳的解碼格式）與給定的 "
"*hostname* 匹配。所應用的規則是用於檢查 HTTPS 伺服器身份的規則，如 "
":rfc:`2818`、:rfc:`5280` 和 :rfc:`6125` 中所述。除了 HTTPS 之外，"
"此功能還適用於檢查各種基於 SSL 的協定（如 FTPS、IMAPS、POPS "
"等）中的伺服器身份。"

#: ../../library/ssl.rst:369
#, fuzzy
msgid ""
":exc:`CertificateError` is raised on failure. On success, the function "
"returns nothing::"
msgstr ":exc:`CertificateError` 在失敗時引發。成功時，該函式不回傳任何內容::"

#: ../../library/ssl.rst:382
#, fuzzy
msgid ""
"The function now follows :rfc:`6125`, section 6.4.3 and does neither match "
"multiple wildcards (e.g. ``*.*.com`` or ``*a*.example.org``) nor a wildcard "
"inside an internationalized domain names (IDN) fragment. IDN A-labels such "
"as ``www*.xn--pthon-kva.org`` are still supported, but ``x*.python.org`` no "
"longer matches ``xn--tda.python.org``."
msgstr ""
"該函式現在遵循 :rfc:`6125`, section 6.4.3 並且既不匹配多個通配符（例如 ``*.*."
"com`` 或 ``*a*.example.org``）也不匹配一個通配符國際化域名 (IDN) 片段。 IDN "
"A 標籤，如 ``www*.xn--pthon-kva.org`` 仍然受支援，但 ``x*.python.org`` "
"不再匹配 ``xn--tda.python.org` `。"

#: ../../library/ssl.rst:389
#, fuzzy
msgid ""
"Matching of IP addresses, when present in the subjectAltName field of the "
"certificate, is now supported."
msgstr "現在支援 IP 地址匹配（如果出現在證書的 subjectAltName 欄位中）。"

#: ../../library/ssl.rst:393
#, fuzzy
msgid ""
"The function is no longer used to TLS connections. Hostname matching is now "
"performed by OpenSSL."
msgstr "該函式不再用於 TLS 連接。主機名匹配現在由 OpenSSL 執行。"

#: ../../library/ssl.rst:397
#, fuzzy
msgid ""
"Allow wildcard when it is the leftmost and the only character in that "
"segment. Partial wildcards like ``www*.example.com`` are no longer supported."
msgstr "當它是該段中最左邊和唯一的字元時允許通配符。不再支援 ``www*.example.com`` "
"等部分通配符。"

#: ../../library/ssl.rst:405
#, fuzzy
msgid ""
"Return the time in seconds since the Epoch, given the ``cert_time`` string "
"representing the \"notBefore\" or \"notAfter\" date from a certificate in "
"``\"%b %d %H:%M:%S %Y %Z\"`` strptime format (C locale)."
msgstr ""
"回傳自 Epoch 以來的秒數，給定 ``cert_time`` 字串表示來自 ``\"%b %d %H:%M:%S "
"%Y %Z 中證書的 ``notBefore`` 或 ``notAfter`` 日期\"`` strptime 格式（C 語言環境）。"

#: ../../library/ssl.rst:410
#, fuzzy
msgid "Here's an example:"
msgstr "這是一個例子："

#: ../../library/ssl.rst:422
#, fuzzy
msgid "\"notBefore\" or \"notAfter\" dates must use GMT (:rfc:`5280`)."
msgstr " ``notBefore`` 或 ``notAfter`` 日期必須使用 GMT (:rfc:`5280`)。"

#: ../../library/ssl.rst:424
#, fuzzy
msgid ""
"Interpret the input time as a time in UTC as specified by 'GMT' timezone in "
"the input string. Local timezone was used previously. Return an integer (no "
"fractions of a second in the input format)"
msgstr "將輸入時間解釋為輸入字串中 ``GMT``時區指定的 UTC "
"時間。以前使用本地時區。回傳一個整數（輸入格式中沒有秒的小數）"

#: ../../library/ssl.rst:433
#, fuzzy
msgid ""
"Given the address ``addr`` of an SSL-protected server, as a (*hostname*, "
"*port-number*) pair, fetches the server's certificate, and returns it as a "
"PEM-encoded string.  If ``ssl_version`` is specified, uses that version of "
"the SSL protocol to attempt to connect to the server.  If ``ca_certs`` is "
"specified, it should be a file containing a list of root certificates, the "
"same format as used for the same parameter in :meth:`SSLContext."
"wrap_socket`.  The call will attempt to validate the server certificate "
"against that set of root certificates, and will fail if the validation "
"attempt fails.  A timeout can be specified with the ``timeout`` parameter."
msgstr ""
"給定受 SSL "
"保護的伺服器的地址“地址”，作為（*主機名*，*端口號*）對，獲取伺服器的證書，"
"並將其作為 PEM 編碼字串回傳。如果指定了 ``ssl_version``，則使用該版本的 SSL "
"協定嘗試連接到伺服器。如果指定了 "
"``ca_certs``，它應該是一個包含根證書列表的文件，格式與 "
"SSLContext.wrap_socket "
"中用於相同參數的格式相同。該呼叫將嘗試根據該組根證書驗證伺服器證書，如"
"果驗證嘗試失敗，則該呼叫將失敗。可以使用 ``timeout`` 參數指定超時。"

#: ../../library/ssl.rst:444
#, fuzzy
msgid "This function is now IPv6-compatible."
msgstr "此函式現在與 IPv6 相容。"

#: ../../library/ssl.rst:447
#, fuzzy
msgid ""
"The default *ssl_version* is changed from :data:`PROTOCOL_SSLv3` to :data:"
"`PROTOCOL_TLS` for maximum compatibility with modern servers."
msgstr ""
"預設的 *ssl_version* 從 :data:`PROTOCOL_SSLv3` 更改為 :data:`PROTOCOL_TLS` "
"以最大程度地與現代伺服器相容。"

#: ../../library/ssl.rst:451
msgid "The *timeout* parameter was added."
msgstr "新增 *timeout* 參數。"

#: ../../library/ssl.rst:456
#, fuzzy
msgid ""
"Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded "
"string version of the same certificate."
msgstr "給定證書作為 DER 編碼的位元組 blob，回傳同一證書的 PEM 編碼字串版本。"

#: ../../library/ssl.rst:461
#, fuzzy
msgid ""
"Given a certificate as an ASCII PEM string, returns a DER-encoded sequence "
"of bytes for that same certificate."
msgstr "給定一個作為 ASCII PEM 字串的證書，回傳同一證書的 DER 編碼位元組序列。"

#: ../../library/ssl.rst:466
#, fuzzy
msgid ""
"Returns a named tuple with paths to OpenSSL's default cafile and capath. The "
"paths are the same as used by :meth:`SSLContext.set_default_verify_paths`. "
"The return value is a :term:`named tuple` ``DefaultVerifyPaths``:"
msgstr ""
"回傳一個命名的元組，其中包含 OpenSSL 的預設 cafile 和 capath 的路徑。"
"這些路徑與 :meth:`SSLContext.set_default_verify_paths` "
"使用的路徑相同。回傳值是 :term:`命名元組``DefaultVerifyPaths``："

#: ../../library/ssl.rst:471
#, fuzzy
msgid ""
":attr:`cafile` - resolved path to cafile or ``None`` if the file doesn't "
"exist,"
msgstr ":attr:`cafile` - cafile 的解析路徑，如果文件不存在則為 ``None``，"

#: ../../library/ssl.rst:472
#, fuzzy
msgid ""
":attr:`capath` - resolved path to capath or ``None`` if the directory "
"doesn't exist,"
msgstr ":attr:`capath` - capath 的解析路徑，如果目錄不存在則為 ``None``，"

#: ../../library/ssl.rst:473
#, fuzzy
msgid ""
":attr:`openssl_cafile_env` - OpenSSL's environment key that points to a "
"cafile,"
msgstr ":attr:`openssl_cafile_env` - 指向 cafile 的 OpenSSL 環境密鑰，"

#: ../../library/ssl.rst:474
#, fuzzy
msgid ":attr:`openssl_cafile` - hard coded path to a cafile,"
msgstr ":attr:`openssl_cafile` - cafile 的硬編碼路徑，"

#: ../../library/ssl.rst:475
#, fuzzy
msgid ""
":attr:`openssl_capath_env` - OpenSSL's environment key that points to a "
"capath,"
msgstr ":attr:`openssl_capath_env` - 指向 capath 的 OpenSSL 環境密鑰，"

#: ../../library/ssl.rst:476
#, fuzzy
msgid ":attr:`openssl_capath` - hard coded path to a capath directory"
msgstr ":attr:`openssl_capath` - capath 目錄的硬編碼路徑"

#: ../../library/ssl.rst:482
#, fuzzy
msgid ""
"Retrieve certificates from Windows' system cert store. *store_name* may be "
"one of ``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert "
"stores, too."
msgstr ""
"從 Windows 的系統證書庫中檢索證書。 *store_name* 可以是 ``CA``、``ROOT`` 或 "
"``MY`` 之一。 Windows 也可能提供額外的證書儲存。"

#: ../../library/ssl.rst:486
#, fuzzy
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either :const:"
"`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 ASN.1 "
"data. Trust specifies the purpose of the certificate as a set of OIDS or "
"exactly ``True`` if the certificate is trustworthy for all purposes."
msgstr ""
"該函式回傳 (cert_bytes, encoding_type, trust) 元組列表。 encoding_type 指定 "
"cert_bytes 的編碼。它是 X.509 ASN.1 資料的 :const:`x509_asn` 或 PKCS#7 ASN.1 "
"資料的 :const:`pkcs_7_asn`。 Trust 將證書的用途指定為一組 "
"OIDS，或者如果證書對於所有用途都是可信的，則恰好是 ``True``。"

#: ../../library/ssl.rst:493 ../../library/ssl.rst:1637
#: ../../library/ssl.rst:1932
msgid "Example::"
msgstr ""
"範例：\n"
"\n"
"::"

#: ../../library/ssl.rst:499 ../../library/ssl.rst:514
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`適用 <availability>`：只有 Windows。"

#: ../../library/ssl.rst:505
#, fuzzy
msgid ""
"Retrieve CRLs from Windows' system cert store. *store_name* may be one of "
"``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert stores, too."
msgstr ""
"從 Windows 的系統證書儲存中檢索 CRL。 *store_name* 可以是 ``CA``、``ROOT`` "
"或 ``MY`` 之一。 Windows 也可能提供額外的證書儲存。"

#: ../../library/ssl.rst:509
#, fuzzy
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either :const:"
"`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 ASN.1 data."
msgstr ""
"該函式回傳 (cert_bytes, encoding_type, trust) 元組列表。 encoding_type 指定 "
"cert_bytes 的編碼。它是 X.509 ASN.1 資料的 :const:`x509_asn` 或 PKCS#7 ASN.1 "
"資料的 :const:`pkcs_7_asn`。"

#: ../../library/ssl.rst:523
#, fuzzy
msgid ""
"Takes an instance ``sock`` of :class:`socket.socket`, and returns an "
"instance of :class:`ssl.SSLSocket`, a subtype of :class:`socket.socket`, "
"which wraps the underlying socket in an SSL context.  ``sock`` must be a :"
"data:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ""
"獲取 socket.socket 的一個 sock 實例，並回傳 ssl.SSLSocket 的一個實例，它是 "
"socket.socket 的一個子型別，它將底層 socket 包裝在一個 SSL 上下文。 ``sock`` "
"必須是 :data:`~socket.SOCK_STREAM`  socket ；不支援其他 socket 型別。"

#: ../../library/ssl.rst:528
#, fuzzy
msgid ""
"Internally, function creates a :class:`SSLContext` with protocol "
"*ssl_version* and :attr:`SSLContext.options` set to *cert_reqs*. If "
"parameters *keyfile*, *certfile*, *ca_certs* or *ciphers* are set, then the "
"values are passed to :meth:`SSLContext.load_cert_chain`, :meth:`SSLContext."
"load_verify_locations`, and :meth:`SSLContext.set_ciphers`."
msgstr ""
"在內部，函式建立一個 :class:`SSLContext` 協定 *ssl_version* 和 "
":attr:`SSLContext.options` 設定為 *cert_reqs*。如果設定了參數 "
"*keyfile*、*certfile*、*ca_certs* 或 *ciphers*，則值將傳遞給 "
":meth:`SSLContext.load_cert_chain`、:meth:`SSLContext.load_verify_locations` "
"和 :meth:`SSLContext .set_ciphers`。"

#: ../../library/ssl.rst:535
#, fuzzy
msgid ""
"The arguments *server_side*, *do_handshake_on_connect*, and "
"*suppress_ragged_eofs* have the same meaning as :meth:`SSLContext."
"wrap_socket`."
msgstr ""
"參數 *server_side*、*do_handshake_on_connect* 和 *suppress_ragged_eofs* 與 "
"SSLContext.wrap_socket 具有相同的含義。"

#: ../../library/ssl.rst:541
#, fuzzy
msgid ""
"Since Python 3.2 and 2.7.9, it is recommended to use the :meth:`SSLContext."
"wrap_socket` instead of :func:`wrap_socket`. The top-level function is "
"limited and creates an insecure client socket without server name indication "
"or hostname matching."
msgstr ""
"從 Python 3.2 和 2.7.9 開始，建議使用 :meth:`SSLContext.wrap_socket` 而不是 :"
"func:`wrap_socket`。頂層函式是有限的，它建立了一個不安全的客戶端 socket ，沒有"
"伺服器名稱指示或主機名匹配。"

#: ../../library/ssl.rst:547
msgid "Constants"
msgstr "常數"

#: ../../library/ssl.rst:549
#, fuzzy
msgid ""
"All constants are now :class:`enum.IntEnum` or :class:`enum.IntFlag` "
"collections."
msgstr "所有常數現在都是 :class:`enum.IntEnum` 或 :class:`enum.IntFlag` 集合。"

#: ../../library/ssl.rst:555
#, fuzzy
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  Except for :const:`PROTOCOL_TLS_CLIENT`, "
"it is the default mode.  With client-side sockets, just about any cert is "
"accepted.  Validation errors, such as untrusted or expired cert, are ignored "
"and do not abort the TLS/SSL handshake."
msgstr ""
":attr:`SSLContext.verify_mode` 的可能值，或 :func:`wrap_socket` 的 "
"``cert_reqs`` 參數。除了 :const:`PROTOCOL_TLS_CLIENT`，它是預設模式。使用客戶"
"端 socket ，幾乎可以接受任何證書。驗證錯誤（例如不受信任或過期的證書）將被忽略"
"，並且不會中止 TLS/SSL 握手。"

#: ../../library/ssl.rst:561
#, fuzzy
msgid ""
"In server mode, no certificate is requested from the client, so the client "
"does not send any for client cert authentication."
msgstr "在伺服器模式下，不向客戶端請求證書，因此客戶端不發送任何客戶端證書認證。"

#: ../../library/ssl.rst:564 ../../library/ssl.rst:2340
msgid "See the discussion of :ref:`ssl-security` below."
msgstr "參閱下方 :ref:`ssl-security` 的討論。"

#: ../../library/ssl.rst:568
#, fuzzy
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In client mode, :const:`CERT_OPTIONAL` "
"has the same meaning as :const:`CERT_REQUIRED`. It is recommended to use :"
"const:`CERT_REQUIRED` for client-side sockets instead."
msgstr ""
":attr:`SSLContext.verify_mode` 的可能值，或 :func:`wrap_socket` 的 "
"``cert_reqs`` 參數。在客戶端模式下，CERT_OPTIONAL 與 CERT_REQUIRED "
"具有相同的含義。建議改用 :const:`CERT_REQUIRED` 作為客戶端 socket 。"

#: ../../library/ssl.rst:573
#, fuzzy
msgid ""
"In server mode, a client certificate request is sent to the client.  The "
"client may either ignore the request or send a certificate in order perform "
"TLS client cert authentication.  If the client chooses to send a "
"certificate, it is verified.  Any verification error immediately aborts the "
"TLS handshake."
msgstr ""
"在伺服器模式下，客戶端證書請求被發送到客戶端。"
"客戶端可以忽略請求或發送證書以執行 TLS "
"客戶端證書身份驗證。如果客戶端選擇發送證書，則它被驗證。"
"任何驗證錯誤都會立即中止 TLS 握手。"

#: ../../library/ssl.rst:579 ../../library/ssl.rst:599
#, fuzzy
msgid ""
"Use of this setting requires a valid set of CA certificates to be passed, "
"either to :meth:`SSLContext.load_verify_locations` or as a value of the "
"``ca_certs`` parameter to :func:`wrap_socket`."
msgstr ""
"使用此設定需要將一組有效的 CA 證書傳遞給 :meth:`SSLContext."
"load_verify_locations` 或作為 ``ca_certs`` 參數的值傳遞給 "
":func:`wrap_socket`。"

#: ../../library/ssl.rst:585
#, fuzzy
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In this mode, certificates are required "
"from the other side of the socket connection; an :class:`SSLError` will be "
"raised if no certificate is provided, or if its validation fails. This mode "
"is **not** sufficient to verify a certificate in client mode as it does not "
"match hostnames.  :attr:`~SSLContext.check_hostname` must be enabled as well "
"to verify the authenticity of a cert. :const:`PROTOCOL_TLS_CLIENT` uses :"
"const:`CERT_REQUIRED` and enables :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""
":attr:`SSLContext.verify_mode` 的可能值，或 :func:`wrap_socket` 的 "
"``cert_reqs`` "
"參數。在這種模式下，需要 socket 連接另一端的證書；如果未提供證書或驗證失敗，"
"將引發 "
"SSLError。此模式**不足以**在客戶端模式下驗證證書，因為它與主機名不匹配。 "
":attr:`~SSLContext.check_hostname` 也必須啟用以驗證證書的真實性。 "
":const:`PROTOCOL_TLS_CLIENT` 使用 :const:`CERT_REQUIRED` 並預設啟用 "
":attr:`~SSLContext.check_hostname`。"

#: ../../library/ssl.rst:595
#, fuzzy
msgid ""
"With server socket, this mode provides mandatory TLS client cert "
"authentication.  A client certificate request is sent to the client and the "
"client must provide a valid and trusted certificate."
msgstr "對於伺服器 socket ，此模式提供強制性的 TLS 客戶端證書身份驗證。客戶端證書請求被"
"發送到客戶端，客戶端必須提供有效且受信任的證書。"

#: ../../library/ssl.rst:605
#, fuzzy
msgid ":class:`enum.IntEnum` collection of CERT_* constants."
msgstr ":class:`enum.IntEnum` CERT_* 常數的集合。"

#: ../../library/ssl.rst:611
#, fuzzy
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, "
"certificate revocation lists (CRLs) are not checked. By default OpenSSL does "
"neither require nor verify CRLs."
msgstr ""
":attr:`SSLContext.verify_flags` 的可能值。在此模式下，不檢查證書撤銷列表 "
"(CRL)。預設情況下，OpenSSL 既不需要也不驗證 CRL。"

#: ../../library/ssl.rst:619
#, fuzzy
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, only the "
"peer cert is checked but none of the intermediate CA certificates. The mode "
"requires a valid CRL that is signed by the peer cert's issuer (its direct "
"ancestor CA). If no proper CRL has been loaded with :attr:`SSLContext."
"load_verify_locations`, validation will fail."
msgstr ""
":attr:`SSLContext.verify_flags` 的可能值。在這種模式下，只檢查對等證書，"
"不檢查任何中間 CA 證書。該模式需要由對等證書的頒發者（其直接祖先 CA）"
"簽署的有效 CRL。如果沒有使用 :attr:`SSLContext.load_verify_locations` "
"加載正確的 CRL，驗證將失敗。"

#: ../../library/ssl.rst:629
#, fuzzy
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, CRLs of "
"all certificates in the peer cert chain are checked."
msgstr ":attr:`SSLContext.verify_flags` 的可能值。在這種模式下，"
"檢查對等證書鏈中所有證書的 CRL。"

#: ../../library/ssl.rst:636
#, fuzzy
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to disable workarounds "
"for broken X.509 certificates."
msgstr ":attr:`SSLContext.verify_flags` 的可能值禁用損壞的 X.509 證書的解決方法。"

#: ../../library/ssl.rst:643
#, fuzzy
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to enables proxy "
"certificate verification."
msgstr ":attr:`SSLContext.verify_flags` 的可能值啟用代理證書驗證。"

#: ../../library/ssl.rst:650
#, fuzzy
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"prefer trusted certificates when building the trust chain to validate a "
"certificate. This flag is enabled by default."
msgstr ""
":attr:`SSLContext.verify_flags` 的可能值。它指示 OpenSSL "
"在構建信任鏈以驗證證書時優先選擇受信任的證書。預設情況下啟用此旗標。"

#: ../../library/ssl.rst:658
#, fuzzy
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"accept intermediate CAs in the trust store to be treated as trust-anchors, "
"in the same way as the self-signed root CA certificates. This makes it "
"possible to trust certificates issued by an intermediate CA without having "
"to trust its ancestor root CA."
msgstr ""
":attr:`SSLContext.verify_flags` 的可能值。它指示 OpenSSL 以與自簽名根 CA "
"證書相同的方式接受信任庫中的中間 CA 作為信任錨。這使得信任中間 CA "
"頒發的證書成為可能，而不必信任其祖先根 CA。"

#: ../../library/ssl.rst:669
#, fuzzy
msgid ":class:`enum.IntFlag` collection of VERIFY_* constants."
msgstr ":class:`enum.IntFlag` VERIFY_* 常數的集合。"

#: ../../library/ssl.rst:675
#, fuzzy
msgid ""
"Selects the highest protocol version that both the client and server "
"support. Despite the name, this option can select both \"SSL\" and \"TLS\" "
"protocols."
msgstr "選擇客戶端和伺服器都支援的最高協定版本。儘管名稱如此，但此選項可以同時選擇“SS"
"L”和 ``TLS``協定。"

#: ../../library/ssl.rst:682
#, fuzzy
msgid ""
"TLS clients and servers require different default settings for secure "
"communication. The generic TLS protocol constant is deprecated in favor of :"
"data:`PROTOCOL_TLS_CLIENT` and :data:`PROTOCOL_TLS_SERVER`."
msgstr ""
"TLS 客戶端和伺服器需要不同的預設設定來進行安全通信。通用 TLS "
"協定常數已棄用，取而代之的是 :data:`PROTOCOL_TLS_CLIENT` 和 "
":data:`PROTOCOL_TLS_SERVER`。"

#: ../../library/ssl.rst:688
#, fuzzy
msgid ""
"Auto-negotiate the highest protocol version that both the client and server "
"support, and configure the context client-side connections. The protocol "
"enables :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""
"自動協商客戶端和伺服器都支援的最高協定版本，並配置上下文客戶端連接。"
"該協定預設啟用 :data:`CERT_REQUIRED` 和 :attr:`~SSLContext.check_hostname`。"

#: ../../library/ssl.rst:697
#, fuzzy
msgid ""
"Auto-negotiate the highest protocol version that both the client and server "
"support, and configure the context server-side connections."
msgstr "自動協商客戶端和伺服器都支援的最高協定版本，並配置上下文伺服器端連接。"

#: ../../library/ssl.rst:704
#, fuzzy
msgid "Alias for :data:`PROTOCOL_TLS`."
msgstr ":data:`PROTOCOL_TLS` 的別名。"

#: ../../library/ssl.rst:708
#, fuzzy
msgid "Use :data:`PROTOCOL_TLS` instead."
msgstr "請改用 :data:`PROTOCOL_TLS`。"

#: ../../library/ssl.rst:712
#, fuzzy
msgid "Selects SSL version 2 as the channel encryption protocol."
msgstr "選擇 SSL 版本 2 作為通道加密協定。"

#: ../../library/ssl.rst:714
#, fuzzy
msgid ""
"This protocol is not available if OpenSSL is compiled with the ``no-ssl2`` "
"option."
msgstr "如果使用 ``no-ssl2`` 選項編譯 OpenSSL，則此協定不可用。"

#: ../../library/ssl.rst:719
#, fuzzy
msgid "SSL version 2 is insecure.  Its use is highly discouraged."
msgstr "SSL 版本 2 不安全。強烈建議不要使用它。"

#: ../../library/ssl.rst:723
#, fuzzy
msgid "OpenSSL has removed support for SSLv2."
msgstr "OpenSSL 已刪除對 SSLv2 的支援。"

#: ../../library/ssl.rst:727
#, fuzzy
msgid "Selects SSL version 3 as the channel encryption protocol."
msgstr "選擇 SSL 版本 3 作為通道加密協定。"

#: ../../library/ssl.rst:729
#, fuzzy
msgid ""
"This protocol is not available if OpenSSL is compiled with the ``no-ssl3`` "
"option."
msgstr "如果使用 ``no-ssl3`` 選項編譯 OpenSSL，則此協定不可用。"

#: ../../library/ssl.rst:734
#, fuzzy
msgid "SSL version 3 is insecure.  Its use is highly discouraged."
msgstr "SSL 版本 3 不安全。強烈建議不要使用它。"

#: ../../library/ssl.rst:738
#, fuzzy
msgid ""
"OpenSSL has deprecated all version specific protocols. Use the default "
"protocol :data:`PROTOCOL_TLS_SERVER` or :data:`PROTOCOL_TLS_CLIENT` with :"
"attr:`SSLContext.minimum_version` and :attr:`SSLContext.maximum_version` "
"instead."
msgstr ""
"OpenSSL 已棄用所有特定於版本的協定。使用預設協定 :data:`PROTOCOL_TLS_SERVER` "
"或 :data:`PROTOCOL_TLS_CLIENT` 以及 :attr:`SSLContext.minimum_version` 和 "
":attr:`SSLContext.maximum_version` 代替。"

#: ../../library/ssl.rst:746
#, fuzzy
msgid "Selects TLS version 1.0 as the channel encryption protocol."
msgstr "選擇 TLS 版本 1.0 作為通道加密協定。"

#: ../../library/ssl.rst:750 ../../library/ssl.rst:761
#: ../../library/ssl.rst:772
#, fuzzy
msgid "OpenSSL has deprecated all version specific protocols."
msgstr "OpenSSL 已棄用所有特定於版本的協定。"

#: ../../library/ssl.rst:754
#, fuzzy
msgid ""
"Selects TLS version 1.1 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr "選擇 TLS 版本 1.1 作為通道加密協定。僅適用於 openssl 版本 1.0.1+。"

#: ../../library/ssl.rst:765
#, fuzzy
msgid ""
"Selects TLS version 1.2 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr "選擇 TLS 版本 1.2 作為通道加密協定。僅適用於 openssl 版本 1.0.1+。"

#: ../../library/ssl.rst:776
#, fuzzy
msgid ""
"Enables workarounds for various bugs present in other SSL implementations. "
"This option is set by default.  It does not necessarily set the same flags "
"as OpenSSL's ``SSL_OP_ALL`` constant."
msgstr ""
"為其他 SSL 實作中存在的各種錯誤啟用解決方法。預設情況下設定此選項。"
"它不一定設定與 OpenSSL 的“SSL_OP_ALL”常數相同的旗標。"

#: ../../library/ssl.rst:784
#, fuzzy
msgid ""
"Prevents an SSLv2 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv2 as "
"the protocol version."
msgstr "阻止 SSLv2 連接。此選項僅適用於與 :const:`PROTOCOL_TLS` 結合使用。"
"它防止對等點選擇 SSLv2 作為協定版本。"

#: ../../library/ssl.rst:792
#, fuzzy
msgid "SSLv2 is deprecated"
msgstr "SSLv2 已棄用"

#: ../../library/ssl.rst:796
#, fuzzy
msgid ""
"Prevents an SSLv3 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv3 as "
"the protocol version."
msgstr "阻止 SSLv3 連接。此選項僅適用於與 :const:`PROTOCOL_TLS` 結合使用。"
"它防止對等方選擇 SSLv3 作為協定版本。"

#: ../../library/ssl.rst:804
#, fuzzy
msgid "SSLv3 is deprecated"
msgstr "SSLv3 已棄用"

#: ../../library/ssl.rst:808
#, fuzzy
msgid ""
"Prevents a TLSv1 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing TLSv1 as "
"the protocol version."
msgstr "阻止 TLSv1 連接。此選項僅適用於與 :const:`PROTOCOL_TLS` 結合使用。"
"它防止對等方選擇 TLSv1 作為協定版本。"

#: ../../library/ssl.rst:814
#, fuzzy
msgid ""
"The option is deprecated since OpenSSL 1.1.0, use the new :attr:`SSLContext."
"minimum_version` and :attr:`SSLContext.maximum_version` instead."
msgstr ""
"該選項自 OpenSSL 1.1.0 起已棄用，請改用新的 :attr:`SSLContext."
"minimum_version` 和 :attr:`SSLContext.maximum_version`。"

#: ../../library/ssl.rst:821
#, fuzzy
msgid ""
"Prevents a TLSv1.1 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.1 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"阻止 TLSv1.1 連接。此選項僅適用於與 :const:`PROTOCOL_TLS` 結合使用。"
"它防止對等方選擇 TLSv1.1 作為協定版本。僅適用於 openssl 版本 1.0.1+。"

#: ../../library/ssl.rst:827 ../../library/ssl.rst:838
#, fuzzy
msgid "The option is deprecated since OpenSSL 1.1.0."
msgstr "該選項自 OpenSSL 1.1.0 起已棄用。"

#: ../../library/ssl.rst:832
#, fuzzy
msgid ""
"Prevents a TLSv1.2 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.2 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"阻止 TLSv1.2 連接。此選項僅適用於與 :const:`PROTOCOL_TLS` 結合使用。"
"它防止對等方選擇 TLSv1.2 作為協定版本。僅適用於 openssl 版本 1.0.1+。"

#: ../../library/ssl.rst:843
#, fuzzy
msgid ""
"Prevents a TLSv1.3 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.3 as "
"the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later. When "
"Python has been compiled against an older version of OpenSSL, the flag "
"defaults to *0*."
msgstr ""
"阻止 TLSv1.3 連接。此選項僅適用於與 :const:`PROTOCOL_TLS` 結合使用。"
"它防止對等方選擇 TLSv1.3 作為協定版本。 TLS 1.3 可用於 OpenSSL 1.1.1 "
"或更高版本。當針對舊版本的 OpenSSL 編譯 Python 時，該旗標預設為 *0*。"

#: ../../library/ssl.rst:851
#, fuzzy
msgid ""
"The option is deprecated since OpenSSL 1.1.0. It was added to 2.7.15, 3.6.3 "
"and 3.7.0 for backwards compatibility with OpenSSL 1.0.2."
msgstr "該選項自 OpenSSL 1.1.0 起已棄用。它被新增到 2.7.15、3.6.3 和 3.7.0 "
"以向後相容 OpenSSL 1.0.2。"

#: ../../library/ssl.rst:857
#, fuzzy
msgid ""
"Disable all renegotiation in TLSv1.2 and earlier. Do not send HelloRequest "
"messages, and ignore renegotiation requests via ClientHello."
msgstr ""
"在 TLSv1.2 及更早版本中禁用所有重新協商。不要發送 HelloRequest 消息，"
"並忽略通過 ClientHello 重新協商的請求。"

#: ../../library/ssl.rst:860
#, fuzzy
msgid "This option is only available with OpenSSL 1.1.0h and later."
msgstr "此選項僅適用於 OpenSSL 1.1.0h 及更高版本。"

#: ../../library/ssl.rst:866
#, fuzzy
msgid ""
"Use the server's cipher ordering preference, rather than the client's. This "
"option has no effect on client sockets and SSLv2 server sockets."
msgstr "使用伺服器的密碼排序首選項，而不是客戶端的。此選項對客戶端 socket 和 SSLv2 "
"伺服器 socket 沒有影響。"

#: ../../library/ssl.rst:873
#, fuzzy
msgid ""
"Prevents re-use of the same DH key for distinct SSL sessions.  This improves "
"forward secrecy but requires more computational resources. This option only "
"applies to server sockets."
msgstr "防止對不同的 SSL 會話重複使用相同的 DH "
"密鑰。這提高了前向保密性，但需要更多的計算資源。此選項僅適用於伺服器 socket 。"

#: ../../library/ssl.rst:881
#, fuzzy
msgid ""
"Prevents re-use of the same ECDH key for distinct SSL sessions.  This "
"improves forward secrecy but requires more computational resources. This "
"option only applies to server sockets."
msgstr "防止對不同的 SSL 會話重複使用相同的 ECDH "
"密鑰。這提高了前向保密性，但需要更多的計算資源。此選項僅適用於伺服器 socket 。"

#: ../../library/ssl.rst:889
#, fuzzy
msgid ""
"Send dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make a "
"TLS 1.3 connection look more like a TLS 1.2 connection."
msgstr "在 TLS 1.3 握手中發送虛擬更改密碼規範 (CCS) 消息，使 TLS 1.3 連接看起來更像 "
"TLS 1.2 連接。"

#: ../../library/ssl.rst:892
#, fuzzy
msgid "This option is only available with OpenSSL 1.1.1 and later."
msgstr "此選項僅適用於 OpenSSL 1.1.1 及更高版本。"

#: ../../library/ssl.rst:898
#, fuzzy
msgid ""
"Disable compression on the SSL channel.  This is useful if the application "
"protocol supports its own compression scheme."
msgstr "在 SSL 通道上禁用壓縮。如果應用程式協定支援自己的壓縮方案，這將很有用。"

#: ../../library/ssl.rst:905
#, fuzzy
msgid ":class:`enum.IntFlag` collection of OP_* constants."
msgstr ":class:`enum.IntFlag` OP_* 常數的集合。"

#: ../../library/ssl.rst:909
#, fuzzy
msgid "Prevent client side from requesting a session ticket."
msgstr "防止客戶端請求會話票證。"

#: ../../library/ssl.rst:915
#, fuzzy
msgid "Ignore unexpected shutdown of TLS connections."
msgstr "忽略 TLS 連接的意外關閉。"

#: ../../library/ssl.rst:917
#, fuzzy
msgid "This option is only available with OpenSSL 3.0.0 and later."
msgstr "此選項僅適用於 OpenSSL 3.0.0 及更高版本。"

#: ../../library/ssl.rst:923
#, fuzzy
msgid ""
"Whether the OpenSSL library has built-in support for the *Application-Layer "
"Protocol Negotiation* TLS extension as described in :rfc:`7301`."
msgstr ""
"OpenSSL 庫是否內建了對 *Application-Layer Protocol Negotiation* TLS "
"擴充的支援，如 :rfc:`7301` 中所述。"

#: ../../library/ssl.rst:930
#, fuzzy
msgid ""
"Whether the OpenSSL library has built-in support not checking subject common "
"name and :attr:`SSLContext.hostname_checks_common_name` is writeable."
msgstr ""
"OpenSSL 庫是否內建支援不檢查主題公用名和 :attr:`SSLContext."
"hostname_checks_common_name` 是否可寫。"

#: ../../library/ssl.rst:938
#, fuzzy
msgid ""
"Whether the OpenSSL library has built-in support for the Elliptic Curve-"
"based Diffie-Hellman key exchange.  This should be true unless the feature "
"was explicitly disabled by the distributor."
msgstr "OpenSSL 庫是否內建了對基於橢圓曲線的 Diffie-Hellman "
"密鑰交換的支援。這應該是正確的，除非該功能被分銷商明確禁用。"

#: ../../library/ssl.rst:946
#, fuzzy
msgid ""
"Whether the OpenSSL library has built-in support for the *Server Name "
"Indication* extension (as defined in :rfc:`6066`)."
msgstr "OpenSSL 庫是否具有對 *Server Name Indication* 擴充的內建支援（如 :rfc:`6066` "
"中所定義）。"

#: ../../library/ssl.rst:953
#, fuzzy
msgid ""
"Whether the OpenSSL library has built-in support for the *Next Protocol "
"Negotiation* as described in the `Application Layer Protocol Negotiation "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"When true, you can use the :meth:`SSLContext.set_npn_protocols` method to "
"advertise which protocols you want to support."
msgstr ""
"OpenSSL 庫是否內建了對 *Next Protocol Negotiation* 的支援，如`Application "
"Layer Protocol Negotiation <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_ 中所述。如果為真，您可以使用 :meth:`SSLContext."
"set_npn_protocols` 方法來公佈您想要支援的協定。"

#: ../../library/ssl.rst:963
#, fuzzy
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 2.0 protocol."
msgstr "OpenSSL 庫是否內建了對 SSL 2.0 協定的支援。"

#: ../../library/ssl.rst:969
#, fuzzy
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 3.0 protocol."
msgstr "OpenSSL 庫是否內建了對 SSL 3.0 協定的支援。"

#: ../../library/ssl.rst:975
#, fuzzy
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.0 protocol."
msgstr "OpenSSL 庫是否內建了對 TLS 1.0 協定的支援。"

#: ../../library/ssl.rst:981
#, fuzzy
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.1 protocol."
msgstr "OpenSSL 庫是否內建了對 TLS 1.1 協定的支援。"

#: ../../library/ssl.rst:987
#, fuzzy
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.2 protocol."
msgstr "OpenSSL 庫是否內建了對 TLS 1.2 協定的支援。"

#: ../../library/ssl.rst:993
#, fuzzy
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.3 protocol."
msgstr "OpenSSL 庫是否內建了對 TLS 1.3 協定的支援。"

#: ../../library/ssl.rst:999
#, fuzzy
msgid ""
"List of supported TLS channel binding types.  Strings in this list can be "
"used as arguments to :meth:`SSLSocket.get_channel_binding`."
msgstr "支援的 TLS 通道綁定型別列表。此列表中的字串可用作 "
"SSLSocket.get_channel_binding 的參數。"

#: ../../library/ssl.rst:1006
#, fuzzy
msgid "The version string of the OpenSSL library loaded by the interpreter::"
msgstr "直譯器加載的 OpenSSL 庫的版本字串::"

#: ../../library/ssl.rst:1015
#, fuzzy
msgid ""
"A tuple of five integers representing version information about the OpenSSL "
"library::"
msgstr "五個整數的元組，表示有關 OpenSSL 庫的版本資訊："

#: ../../library/ssl.rst:1025
#, fuzzy
msgid "The raw version number of the OpenSSL library, as a single integer::"
msgstr "OpenSSL 庫的原始版本號，作為單個整數::"

#: ../../library/ssl.rst:1038
#, fuzzy
msgid ""
"Alert Descriptions from :rfc:`5246` and others. The `IANA TLS Alert Registry "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ contains this list and references to the RFCs where their "
"meaning is defined."
msgstr ""
"來自 :rfc:`5246` 和其他人的警報說明。 `IANA TLS Alert Registry <https://www."
"iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-6>`_ "
"包含此列表和對定義其含義的 RFC 的引用."

#: ../../library/ssl.rst:1042
#, fuzzy
msgid ""
"Used as the return value of the callback function in :meth:`SSLContext."
"set_servername_callback`."
msgstr "在 :meth:`SSLContext.set_servername_callback` 中用作回呼函式的回傳值。"

#: ../../library/ssl.rst:1049
#, fuzzy
msgid ":class:`enum.IntEnum` collection of ALERT_DESCRIPTION_* constants."
msgstr ":class:`enum.IntEnum` ALERT_DESCRIPTION_* 常數的集合。"

#: ../../library/ssl.rst:1055
#, fuzzy
msgid ""
"Option for :func:`create_default_context` and :meth:`SSLContext."
"load_default_certs`.  This value indicates that the context may be used to "
"authenticate web servers (therefore, it will be used to create client-side "
"sockets)."
msgstr ""
":func:`create_default_context` 和 :meth:`SSLContext.load_default_certs` "
"的選項。該值表示上下文可用於驗證 Web "
"伺服器（因此，它將用於建立客戶端 socket ）。"

#: ../../library/ssl.rst:1064
#, fuzzy
msgid ""
"Option for :func:`create_default_context` and :meth:`SSLContext."
"load_default_certs`.  This value indicates that the context may be used to "
"authenticate web clients (therefore, it will be used to create server-side "
"sockets)."
msgstr ""
":func:`create_default_context` 和 :meth:`SSLContext.load_default_certs` "
"的選項。該值表示上下文可用於對 Web "
"客戶端進行身份驗證（因此，它將用於建立伺服器端 socket ）。"

#: ../../library/ssl.rst:1073
#, fuzzy
msgid ":class:`enum.IntEnum` collection of SSL_ERROR_* constants."
msgstr ":class:`enum.IntEnum` SSL_ERROR_* 常數的集合。"

#: ../../library/ssl.rst:1079
#, fuzzy
msgid ""
":class:`enum.IntEnum` collection of SSL and TLS versions for :attr:"
"`SSLContext.maximum_version` and :attr:`SSLContext.minimum_version`."
msgstr ""
":class:`enum.IntEnum` SSL 和 TLS 版本的集合 :attr:`SSLContext."
"maximum_version` 和 :attr:`SSLContext.minimum_version`。"

#: ../../library/ssl.rst:1087
#, fuzzy
msgid ""
"The minimum or maximum supported SSL or TLS version. These are magic "
"constants. Their values don't reflect the lowest and highest available TLS/"
"SSL versions."
msgstr "支援的最低或最高 SSL 或 TLS 版本。這些是魔法常數。"
"它們的值不反映最低和最高的可用 TLS/SSL 版本。"

#: ../../library/ssl.rst:1097
#, fuzzy
msgid "SSL 3.0 to TLS 1.3."
msgstr "SSL 3.0 到 TLS 1.3。"

#: ../../library/ssl.rst:1101
#, fuzzy
msgid ""
"All :class:`TLSVersion` members except :attr:`TLSVersion.TLSv1_2` and :attr:"
"`TLSVersion.TLSv1_3` are deprecated."
msgstr ""
"除 :attr:`TLSVersion.TLSv1_2` 和 :attr:`TLSVersion.TLSv1_3` 之外的所有 "
":class:`TLSVersion` 成員均已棄用。"

#: ../../library/ssl.rst:1106
#, fuzzy
msgid "SSL Sockets"
msgstr "SSL socket "

#: ../../library/ssl.rst:1110
#, fuzzy
msgid "SSL sockets provide the following methods of :ref:`socket-objects`:"
msgstr "SSL  socket 提供以下 :ref:`socket-objects` 方法："

#: ../../library/ssl.rst:1112
msgid ":meth:`~socket.socket.accept()`"
msgstr ":meth:`~socket.socket.accept()`"

#: ../../library/ssl.rst:1113
msgid ":meth:`~socket.socket.bind()`"
msgstr ":meth:`~socket.socket.bind()`"

#: ../../library/ssl.rst:1114
msgid ":meth:`~socket.socket.close()`"
msgstr ":meth:`~socket.socket.close()`"

#: ../../library/ssl.rst:1115
msgid ":meth:`~socket.socket.connect()`"
msgstr ":meth:`~socket.socket.connect()`"

#: ../../library/ssl.rst:1116
msgid ":meth:`~socket.socket.detach()`"
msgstr ":meth:`~socket.socket.detach()`"

#: ../../library/ssl.rst:1117
msgid ":meth:`~socket.socket.fileno()`"
msgstr ":meth:`~socket.socket.fileno()`"

#: ../../library/ssl.rst:1118
msgid ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"
msgstr ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"

#: ../../library/ssl.rst:1119
msgid ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"
msgstr ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"

#: ../../library/ssl.rst:1120
msgid ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, :"
"meth:`~socket.socket.setblocking()`"
msgstr ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, :"
"meth:`~socket.socket.setblocking()`"

#: ../../library/ssl.rst:1122
msgid ":meth:`~socket.socket.listen()`"
msgstr ":meth:`~socket.socket.listen()`"

#: ../../library/ssl.rst:1123
msgid ":meth:`~socket.socket.makefile()`"
msgstr ":meth:`~socket.socket.makefile()`"

#: ../../library/ssl.rst:1124
#, fuzzy
msgid ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (but "
"passing a non-zero ``flags`` argument is not allowed)"
msgstr ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` （"
"但不允許傳遞非零的 ``flags`` 參數）"

#: ../../library/ssl.rst:1126
#, fuzzy
msgid ""
":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (with the "
"same limitation)"
msgstr ""
":meth:`~socket.socket.send()`, :meth:`~socket.socket."
"sendall()`（具有相同的限制）"

#: ../../library/ssl.rst:1128
#, fuzzy
msgid ""
":meth:`~socket.socket.sendfile()` (but :mod:`os.sendfile` will be used for "
"plain-text sockets only, else :meth:`~socket.socket.send()` will be used)"
msgstr ""
":meth:`~socket.socket.sendfile()`（但 :mod:`os.sendfile` "
"將僅用於純文本 socket ，否則將使用 :meth:`~socket.socket.send()` )"

#: ../../library/ssl.rst:1130
msgid ":meth:`~socket.socket.shutdown()`"
msgstr ":meth:`~socket.socket.shutdown()`"

#: ../../library/ssl.rst:1132
#, fuzzy
msgid ""
"However, since the SSL (and TLS) protocol has its own framing atop of TCP, "
"the SSL sockets abstraction can, in certain respects, diverge from the "
"specification of normal, OS-level sockets.  See especially the :ref:`notes "
"on non-blocking sockets <ssl-nonblocking>`."
msgstr ""
"然而，由於 SSL（和 TLS）協定在 TCP 之上有自己的框架，SSL "
" socket 抽像在某些方面可能與正常的操作系統級 socket 規範不同。請特別參閱 :ref:`"
"關於非阻塞 socket 的註釋 <ssl-nonblocking>`。"

#: ../../library/ssl.rst:1137
#, fuzzy
msgid ""
"Instances of :class:`SSLSocket` must be created using the :meth:`SSLContext."
"wrap_socket` method."
msgstr ":class:`SSLSocket` 的實例必須使用 :meth:`SSLContext.wrap_socket` 方法建立。"

#: ../../library/ssl.rst:1140
#, fuzzy
msgid "The :meth:`sendfile` method was added."
msgstr "新增了 :meth:`sendfile` 方法。"

#: ../../library/ssl.rst:1143
#, fuzzy
msgid ""
"The :meth:`shutdown` does not reset the socket timeout each time bytes are "
"received or sent. The socket timeout is now the maximum total duration of "
"the shutdown."
msgstr ":meth:`shutdown` 不會在每次接收或發送位元組時重置 socket 超時。 socket 超時現在是"
"關閉的最大總持續時間。"

#: ../../library/ssl.rst:1148
#, fuzzy
msgid ""
"It is deprecated to create a :class:`SSLSocket` instance directly, use :meth:"
"`SSLContext.wrap_socket` to wrap a socket."
msgstr "不推薦直接建立 :class:`SSLSocket` 實例，使用 :meth:`SSLContext.wrap_socket` "
"包裝 socket 。"

#: ../../library/ssl.rst:1152
#, fuzzy
msgid ""
":class:`SSLSocket` instances must to created with :meth:`~SSLContext."
"wrap_socket`. In earlier versions, it was possible to create instances "
"directly. This was never documented or officially supported."
msgstr ""
":class:`SSLSocket` 實例必須使用 :meth:`~SSLContext.wrap_socket` "
"建立。在早期版本中，可以直接建立實例。這從未被記錄或正式支援。"

#: ../../library/ssl.rst:1158
#, fuzzy
msgid ""
"Python now uses ``SSL_read_ex`` and ``SSL_write_ex`` internally. The "
"functions support reading and writing of data larger than 2 GB. Writing zero-"
"length data no longer fails with a protocol violation error."
msgstr ""
"Python 現在在內部使用 ``SSL_read_ex`` 和 ``SSL_write_ex``。函式支援讀寫大於2G"
"B的資料。寫入零長度資料不再因違反協定錯誤而失敗。"

#: ../../library/ssl.rst:1163
#, fuzzy
msgid "SSL sockets also have the following additional methods and attributes:"
msgstr "SSL  socket 還具有以下附加方法和屬性："

#: ../../library/ssl.rst:1167
#, fuzzy
msgid ""
"Read up to *len* bytes of data from the SSL socket and return the result as "
"a ``bytes`` instance. If *buffer* is specified, then read into the buffer "
"instead, and return the number of bytes read."
msgstr ""
"從 SSL  socket 讀取最多 *len* 位元組的資料，並將結果作為“位元組”實例回傳。"
"如果指定了 *buffer*，則改為讀入緩衝區，並回傳讀取的位元組數。"

#: ../../library/ssl.rst:1171
#, fuzzy
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is :"
"ref:`non-blocking <ssl-nonblocking>` and the read would block."
msgstr ""
"如果 socket 是 :ref:`non-blocking <ssl-nonblocking>` 並且讀取會阻塞，則引發 "
":exc:`SSLWantReadError` 或 :exc:`SSLWantWriteError`。"

#: ../../library/ssl.rst:1174
#, fuzzy
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`read` can also "
"cause write operations."
msgstr "由於任何時候都可能重新協商，呼叫 read 也可能導致寫操作。"

#: ../../library/ssl.rst:1177
#, fuzzy
msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration to read up to *len* "
"bytes."
msgstr "每次接收或發送位元組時， socket 超時不再重置。 socket 超時現在是讀取最多 *len* "
"位元組的最大總持續時間。"

#: ../../library/ssl.rst:1182
#, fuzzy
msgid "Use :meth:`~SSLSocket.recv` instead of :meth:`~SSLSocket.read`."
msgstr "使用 :meth:`~SSLSocket.recv` 而不是 :meth:`~SSLSocket.read`。"

#: ../../library/ssl.rst:1187
#, fuzzy
msgid ""
"Write *buf* to the SSL socket and return the number of bytes written. The "
"*buf* argument must be an object supporting the buffer interface."
msgstr "將 *buf* 寫入 SSL  socket 並回傳寫入的位元組數。 *buf* "
"參數必須是支援緩衝區介面的物件。"

#: ../../library/ssl.rst:1190
#, fuzzy
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is :"
"ref:`non-blocking <ssl-nonblocking>` and the write would block."
msgstr ""
"如果 socket 是 :ref:`non-blocking <ssl-nonblocking>` 並且寫入會阻塞，則引發 "
":exc:`SSLWantReadError` 或 :exc:`SSLWantWriteError`。"

#: ../../library/ssl.rst:1193
#, fuzzy
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`write` can "
"also cause read operations."
msgstr "由於在任何時候都可能重新協商，呼叫 :meth:`write` 也可能導致讀取操作。"

#: ../../library/ssl.rst:1196
#, fuzzy
msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration to write *buf*."
msgstr "每次接收或發送位元組時， socket 超時不再重置。 socket 超時現在是寫入 *buf* "
"的最大總持續時間。"

#: ../../library/ssl.rst:1200
#, fuzzy
msgid "Use :meth:`~SSLSocket.send` instead of :meth:`~SSLSocket.write`."
msgstr "使用 :meth:`~SSLSocket.send` 而不是 :meth:`~SSLSocket.write`。"

#: ../../library/ssl.rst:1205
#, fuzzy
msgid ""
"The :meth:`~SSLSocket.read` and :meth:`~SSLSocket.write` methods are the low-"
"level methods that read and write unencrypted, application-level data and "
"decrypt/encrypt it to encrypted, wire-level data. These methods require an "
"active SSL connection, i.e. the handshake was completed and :meth:`SSLSocket."
"unwrap` was not called."
msgstr ""
":meth:`~SSLSocket.read` 和 :meth:`~SSLSocket.write` 方法是讀取和寫入未加密的"
"應用程式級資料並將其解密/加密為加密的線路級資料的低階方法。"
"這些方法需要有效的 SSL 連接，即握手已完成並且未呼叫 :meth:`SSLSocket."
"unwrap`。"

#: ../../library/ssl.rst:1211
#, fuzzy
msgid ""
"Normally you should use the socket API methods like :meth:`~socket.socket."
"recv` and :meth:`~socket.socket.send` instead of these methods."
msgstr ""
"通常你應該使用 socket  API 方法，如 :meth:`~socket.socket.recv` 和 "
":meth:`~socket.socket.send` 而不是這些方法。"

#: ../../library/ssl.rst:1217
#, fuzzy
msgid "Perform the SSL setup handshake."
msgstr "執行 SSL 設定握手。"

#: ../../library/ssl.rst:1219
#, fuzzy
msgid ""
"The handshake method also performs :func:`match_hostname` when the :attr:"
"`~SSLContext.check_hostname` attribute of the socket's :attr:`~SSLSocket."
"context` is true."
msgstr ""
"當 socket 的 :attr:`~SSLSocket.context` 的 :attr:`~SSLContext.check_hostname` "
"屬性為真時，握手方法也會執行 :func:`match_hostname`。"

#: ../../library/ssl.rst:1224
#, fuzzy
msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration of the handshake."
msgstr "每次接收或發送位元組時， socket 超時不再重置。 socket 超時現在是握手的最大總持續"
"時間。"

#: ../../library/ssl.rst:1228
#, fuzzy
msgid ""
"Hostname or IP address is matched by OpenSSL during handshake. The function :"
"func:`match_hostname` is no longer used. In case OpenSSL refuses a hostname "
"or IP address, the handshake is aborted early and a TLS alert message is "
"sent to the peer."
msgstr ""
"主機名或 IP 地址在握手期間由 OpenSSL 匹配。函式 :func:`match_hostname` "
"不再使用。如果 OpenSSL 拒絕主機名或 IP 地址，握手會提前中止，並向對等方發送 "
"TLS 警報消息。"

#: ../../library/ssl.rst:1236
#, fuzzy
msgid ""
"If there is no certificate for the peer on the other end of the connection, "
"return ``None``.  If the SSL handshake hasn't been done yet, raise :exc:"
"`ValueError`."
msgstr "如果連接的另一端沒有對等方的證書，則回傳 ``None`` 。如果 SSL 握手尚未完成，請引發 "
":exc:`ValueError`。"

#: ../../library/ssl.rst:1240
#, fuzzy
msgid ""
"If the ``binary_form`` parameter is :const:`False`, and a certificate was "
"received from the peer, this method returns a :class:`dict` instance.  If "
"the certificate was not validated, the dict is empty.  If the certificate "
"was validated, it returns a dict with several keys, amongst them ``subject`` "
"(the principal for which the certificate was issued) and ``issuer`` (the "
"principal issuing the certificate).  If a certificate contains an instance "
"of the *Subject Alternative Name* extension (see :rfc:`3280`), there will "
"also be a ``subjectAltName`` key in the dictionary."
msgstr ""
"如果 ``binary_form`` 參數為 :const:`False`，並且從對等方收到了證書，則此方法"
"回傳一個 :class:`dict` 實例。如果證書未通過驗證，則字典為空。如果證書通過驗"
"證，它會回傳一個包含多個鍵的字典，其中包括 ``subject`` （頒發證書的主體）和“issue"
"r”（頒發證書的主體）。如果證書包含 *Subject Alternative Name* 擴充的實例（"
"參見 :rfc:`3280`），字典中也會有一個 ``subjectAltName`` 鍵。"

#: ../../library/ssl.rst:1249
#, fuzzy
msgid ""
"The ``subject`` and ``issuer`` fields are tuples containing the sequence of "
"relative distinguished names (RDNs) given in the certificate's data "
"structure for the respective fields, and each RDN is a sequence of name-"
"value pairs.  Here is a real-world example::"
msgstr ""
"``subject`` 和 ``issuer`` 欄位是元組，"
"其中包含在證書的資料結構中為各個欄位給出的相對可分辨名稱 (RDN) 序列，每個 "
"RDN 都是名稱-值對的序列。這是一個真實世界的例子::"

#: ../../library/ssl.rst:1275
#, fuzzy
msgid ""
"To validate a certificate for a particular service, you can use the :func:"
"`match_hostname` function."
msgstr "要驗證特定服務的證書，您可以使用 match_hostname 函式。"

#: ../../library/ssl.rst:1278
#, fuzzy
msgid ""
"If the ``binary_form`` parameter is :const:`True`, and a certificate was "
"provided, this method returns the DER-encoded form of the entire certificate "
"as a sequence of bytes, or :const:`None` if the peer did not provide a "
"certificate.  Whether the peer provides a certificate depends on the SSL "
"socket's role:"
msgstr ""
"如果 ``binary_form`` 參數為 :const:`True`，並且提供了證書，"
"則此方法回傳整個證書的 DER 編碼形式作為位元組序列，或者 :const:`None` "
"如果對等沒有提供證書。對等方是否提供證書取決於 SSL  socket 的角色："

#: ../../library/ssl.rst:1284
#, fuzzy
msgid ""
"for a client SSL socket, the server will always provide a certificate, "
"regardless of whether validation was required;"
msgstr "對於客戶端 SSL  socket ，伺服器將始終提供證書，無論是否需要驗證；"

#: ../../library/ssl.rst:1287
#, fuzzy
msgid ""
"for a server SSL socket, the client will only provide a certificate when "
"requested by the server; therefore :meth:`getpeercert` will return :const:"
"`None` if you used :const:`CERT_NONE` (rather than :const:`CERT_OPTIONAL` "
"or :const:`CERT_REQUIRED`)."
msgstr ""
"對於伺服器 SSL  socket ，客戶端僅在伺服器請求時才提供證書；因此 "
":meth:`getpeercert` 將回傳 :const:`None` 如果您使用 :const:`CERT_NONE`（"
"而不是 :const:`CERT_OPTIONAL` 或 :const:`CERT_REQUIRED`）。"

#: ../../library/ssl.rst:1292
#, fuzzy
msgid ""
"The returned dictionary includes additional items such as ``issuer`` and "
"``notBefore``."
msgstr "回傳的字典包括附加項，例如 ``issuer`` 和 ``notBefore``。"

#: ../../library/ssl.rst:1296
#, fuzzy
msgid ""
":exc:`ValueError` is raised when the handshake isn't done. The returned "
"dictionary includes additional X509v3 extension items   such as "
"``crlDistributionPoints``, ``caIssuers`` and ``OCSP`` URIs."
msgstr ""
":exc:`ValueError` 在握手未完成時引發。回傳的字典包括額外的 X509v3 擴充項，"
"例如 ``crlDistributionPoints``、``caIssuers`` 和 ``OCSP`` URI。"

#: ../../library/ssl.rst:1301
#, fuzzy
msgid "IPv6 address strings no longer have a trailing new line."
msgstr "IPv6 地址字串不再有尾隨換行符。"

#: ../../library/ssl.rst:1306
#, fuzzy
msgid ""
"Returns a three-value tuple containing the name of the cipher being used, "
"the version of the SSL protocol that defines its use, and the number of "
"secret bits being used.  If no connection has been established, returns "
"``None``."
msgstr "回傳一個三值元組，其中包含正在使用的密碼的名稱、定義其用途的 SSL "
"協定版本以及正在使用的秘密位數。如果未建立連接，則回傳 ``None`` 。"

#: ../../library/ssl.rst:1312
#, fuzzy
msgid ""
"Return the list of ciphers available in both the client and server.  Each "
"entry of the returned list is a three-value tuple containing the name of the "
"cipher, the version of the SSL protocol that defines its use, and the number "
"of secret bits the cipher uses.  :meth:`~SSLSocket.shared_ciphers` returns "
"``None`` if no connection has been established or the socket is a client "
"socket."
msgstr ""
"回傳客戶端和伺服器中可用的密碼列表。回傳列表的每個條目都是一個三值元組，其中"
"包含密碼名稱、定義其用途的 SSL 協定版本以及密碼使用的秘密位數。 "
":meth:`~SSLSocket.shared_ciphers` 如果未建立連接或 socket 是客戶端 socket ，"
"則回傳 ``None``。"

#: ../../library/ssl.rst:1323
#, fuzzy
msgid ""
"Return the compression algorithm being used as a string, or ``None`` if the "
"connection isn't compressed."
msgstr "回傳作為字串使用的壓縮演算法，如果連接未壓縮，則回傳 ``None``。"

#: ../../library/ssl.rst:1326
#, fuzzy
msgid ""
"If the higher-level protocol supports its own compression mechanism, you can "
"use :data:`OP_NO_COMPRESSION` to disable SSL-level compression."
msgstr "如果更高階別的協定支援自己的壓縮機制，您可以使用 :data:`OP_NO_COMPRESSION` "
"來禁用 SSL 級別的壓縮。"

#: ../../library/ssl.rst:1333
#, fuzzy
msgid ""
"Get channel binding data for current connection, as a bytes object.  Returns "
"``None`` if not connected or the handshake has not been completed."
msgstr "獲取當前連接的通道綁定資料，作為位元組物件。如果未連接或握手尚未完成，則回傳“"
"None”。"

#: ../../library/ssl.rst:1336
#, fuzzy
msgid ""
"The *cb_type* parameter allow selection of the desired channel binding type. "
"Valid channel binding types are listed in the :data:`CHANNEL_BINDING_TYPES` "
"list.  Currently only the 'tls-unique' channel binding, defined by :rfc:"
"`5929`, is supported.  :exc:`ValueError` will be raised if an unsupported "
"channel binding type is requested."
msgstr ""
"*cb_type* 參數允許選擇所需的通道綁定型別。 CHANNEL_BINDING_TYPES "
"列表中列出了有效的通道綁定型別。目前僅支援由 :rfc:`5929` 定義的“tls-"
"unique”通道綁定。 :exc:`ValueError` "
"如果請求了不支援的通道綁定型別，將被引發。"

#: ../../library/ssl.rst:1346
#, fuzzy
msgid ""
"Return the protocol that was selected during the TLS handshake.  If :meth:"
"`SSLContext.set_alpn_protocols` was not called, if the other party does not "
"support ALPN, if this socket does not support any of the client's proposed "
"protocols, or if the handshake has not happened yet, ``None`` is returned."
msgstr ""
"回傳在 TLS 握手期間選擇的協定。如果 :meth:`SSLContext.set_alpn_protocols` "
"沒有被呼叫，如果對方不支援 ALPN，如果這個 socket 不支援任何客戶端提議的協定，或"
"者如果握手還沒有發生，``None`` 是回。"

#: ../../library/ssl.rst:1356
#, fuzzy
msgid ""
"Return the higher-level protocol that was selected during the TLS/SSL "
"handshake. If :meth:`SSLContext.set_npn_protocols` was not called, or if the "
"other party does not support NPN, or if the handshake has not yet happened, "
"this will return ``None``."
msgstr ""
"回傳在 TLS/SSL 握手期間選擇的更高階別的協定。如果 :meth:`SSLContext."
"set_npn_protocols` 沒有被呼叫，或者如果對方不支援 "
"NPN，或者如果握手還沒有發生，這將回傳 ``None``。"

#: ../../library/ssl.rst:1365 ../../library/ssl.rst:1725
#, fuzzy
msgid "NPN has been superseded by ALPN"
msgstr "NPN 已被 ALPN 取代"

#: ../../library/ssl.rst:1369
#, fuzzy
msgid ""
"Performs the SSL shutdown handshake, which removes the TLS layer from the "
"underlying socket, and returns the underlying socket object.  This can be "
"used to go from encrypted operation over a connection to unencrypted.  The "
"returned socket should always be used for further communication with the "
"other side of the connection, rather than the original socket."
msgstr ""
"執行 SSL 關閉握手，從底層 socket 中刪除 TLS 層，並回傳底層 socket 物件。這可用於"
"從連接上的加密操作變為未加密。回傳的 socket 應該始終用於與連接的另一端進行進一"
"步通信，而不是原始 socket 。"

#: ../../library/ssl.rst:1377
#, fuzzy
msgid ""
"Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA can "
"only be initiated for a TLS 1.3 connection from a server-side socket, after "
"the initial TLS handshake and with PHA enabled on both sides, see :attr:"
"`SSLContext.post_handshake_auth`."
msgstr ""
"從 TLS 1.3 客戶端請求握手後身份驗證 (PHA)。 PHA 只能從伺服器端 socket 啟動 TLS "
"1.3 連接，在初始 TLS 握手之後並且雙方都啟用 PHA，請參閱 :attr:`SSLContext."
"post_handshake_auth`。"

#: ../../library/ssl.rst:1382
#, fuzzy
msgid ""
"The method does not perform a cert exchange immediately. The server-side "
"sends a CertificateRequest during the next write event and expects the "
"client to respond with a certificate on the next read event."
msgstr ""
"該方法不會立即執行證書交換。伺服器端在下一次寫入事件期間發送 "
"CertificateRequest 並期望客戶端在下一次讀取事件時使用證書進行響應。"

#: ../../library/ssl.rst:1386
#, fuzzy
msgid ""
"If any precondition isn't met (e.g. not TLS 1.3, PHA not enabled), an :exc:"
"`SSLError` is raised."
msgstr "如果不滿足任何先決條件（例如，不滿足 TLS 1.3、未啟用 PHA），則會引發 "
":exc:`SSLError`。"

#: ../../library/ssl.rst:1390
#, fuzzy
msgid ""
"Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 "
"support, the method raises :exc:`NotImplementedError`."
msgstr ""
"僅在啟用 OpenSSL 1.1.1 和 TLS 1.3 時可用。如果沒有 TLS 1.3 "
"支援，該方法會引發 :exec:`NotImplementedError`。"

#: ../../library/ssl.rst:1397
#, fuzzy
msgid ""
"Return the actual SSL protocol version negotiated by the connection as a "
"string, or ``None`` if no secure connection is established. As of this "
"writing, possible return values include ``\"SSLv2\"``, ``\"SSLv3\"``, "
"``\"TLSv1\"``, ``\"TLSv1.1\"`` and ``\"TLSv1.2\"``. Recent OpenSSL versions "
"may define more return values."
msgstr ""
"將連接協商的實際 SSL 協定版本作為字串回傳，如果未建立安全連接，則回傳 ``None``。"
"在撰寫本文時，可能的回傳值包括``\"SSLv2\"``、``\"SSLv3\"``、``\"TLSv1\"``、``"
"\"TLSv1.1\"`` 和``\"TLSv1.2\" ``。最近的 OpenSSL 版本可能會定義更多的回傳值。"

#: ../../library/ssl.rst:1407
#, fuzzy
msgid ""
"Returns the number of already decrypted bytes available for read, pending on "
"the connection."
msgstr "回傳可用於讀取的已解密位元組數，等待連接。"

#: ../../library/ssl.rst:1412
#, fuzzy
msgid ""
"The :class:`SSLContext` object this SSL socket is tied to.  If the SSL "
"socket was created using the deprecated :func:`wrap_socket` function (rather "
"than :meth:`SSLContext.wrap_socket`), this is a custom context object "
"created for this SSL socket."
msgstr ""
"此 SSL  socket 綁定到的 :class:`SSLContext` 物件。如果 SSL "
" socket 是使用已棄用的 :func:`wrap_socket` 函式（而不是 :meth:`SSLContext."
"wrap_socket`）建立的，則這是為此 SSL  socket 建立的自定義上下文物件。"

#: ../../library/ssl.rst:1421
#, fuzzy
msgid ""
"A boolean which is ``True`` for server-side sockets and ``False`` for client-"
"side sockets."
msgstr "一個布爾值，對於伺服器端 socket 為 ``True``，對於客戶端 socket 為 ``False``。"

#: ../../library/ssl.rst:1428
#, fuzzy
msgid ""
"Hostname of the server: :class:`str` type, or ``None`` for server-side "
"socket or if the hostname was not specified in the constructor."
msgstr "伺服器的主機名：str 型別，或伺服器端 socket 的 "
"``None``，或者如果在構造函式中未指定主機名。"

#: ../../library/ssl.rst:1433
#, fuzzy
msgid ""
"The attribute is now always ASCII text. When ``server_hostname`` is an "
"internationalized domain name (IDN), this attribute now stores the A-label "
"form (``\"xn--pythn-mua.org\"``), rather than the U-label form (``\"pythön."
"org\"``)."
msgstr ""
"該屬性現在始終是 ASCII 文本。當 ``server_hostname`` 是國際化域名 (IDN) 時，"
"此屬性現在儲存 A 標籤形式（``\"xn--python-mua.org\"``），而不是 U 標籤形式（`"
" `“python.org”``）。"

#: ../../library/ssl.rst:1441
#, fuzzy
msgid ""
"The :class:`SSLSession` for this SSL connection. The session is available "
"for client and server side sockets after the TLS handshake has been "
"performed. For client sockets the session can be set before :meth:"
"`~SSLSocket.do_handshake` has been called to reuse a session."
msgstr ""
"此 SSL 連接的 :class:`SSLSession`。在執行 TLS "
"握手後，會話可用於客戶端和伺服器端 socket 。對於客戶端 socket ，可以在呼叫 "
":meth:`~SSLSocket.do_handshake` 之前設定會話以重用會話。"

#: ../../library/ssl.rst:1454
#, fuzzy
msgid "SSL Contexts"
msgstr "SSL 上下文"

#: ../../library/ssl.rst:1458
#, fuzzy
msgid ""
"An SSL context holds various data longer-lived than single SSL connections, "
"such as SSL configuration options, certificate(s) and private key(s). It "
"also manages a cache of SSL sessions for server-side sockets, in order to "
"speed up repeated connections from the same clients."
msgstr ""
"SSL 上下文保存各種資料，這些資料比單個 SSL 連接的壽命更長，例如 SSL "
"配置選項、證書和私鑰。它還管理伺服器端 socket 的 SSL "
"會話快取，以加速來自相同客戶端的重複連接。"

#: ../../library/ssl.rst:1465
#, fuzzy
msgid ""
"Create a new SSL context.  You may pass *protocol* which must be one of the "
"``PROTOCOL_*`` constants defined in this module.  The parameter specifies "
"which version of the SSL protocol to use.  Typically, the server chooses a "
"particular protocol version, and the client must adapt to the server's "
"choice.  Most of the versions are not interoperable with the other "
"versions.  If not specified, the default is :data:`PROTOCOL_TLS`; it "
"provides the most compatibility with other versions."
msgstr ""
"建立新的 SSL 上下文。您可以傳遞 *protocol*，它必須是此模組中定義的 "
"``PROTOCOL_*`` 常數之一。該參數指定要使用的 SSL 協定版本。通常，伺服器選擇特"
"定的協定版本，客戶端必須適應伺服器的選擇。大多數版本不能與其他版本互操作。如"
"果未指定，則預設為 :data:`PROTOCOL_TLS`；它提供了與其他版本的最大相容性。"

#: ../../library/ssl.rst:1474
#, fuzzy
msgid ""
"Here's a table showing which versions in a client (down the side) can "
"connect to which versions in a server (along the top):"
msgstr "這是一個表格，顯示客戶端中的哪些版本（下方）可以連接到伺服器中的哪些版本（頂"
"部）："

#: ../../library/ssl.rst:1480
#, fuzzy
msgid "*client* / **server**"
msgstr "*客戶端伺服器**"

#: ../../library/ssl.rst:1480
msgid "**SSLv2**"
msgstr "**SSLv2**"

#: ../../library/ssl.rst:1480
msgid "**SSLv3**"
msgstr "**SSLv3**"

#: ../../library/ssl.rst:1480
msgid "**TLS** [3]_"
msgstr "**TLS** [3]_"

#: ../../library/ssl.rst:1480
msgid "**TLSv1**"
msgstr "**TLSv1**"

#: ../../library/ssl.rst:1480
msgid "**TLSv1.1**"
msgstr "**TLSv1.1**"

#: ../../library/ssl.rst:1480
msgid "**TLSv1.2**"
msgstr "**TLSv1.2**"

#: ../../library/ssl.rst:1482
msgid "*SSLv2*"
msgstr "*SSLv2*"

#: ../../library/ssl.rst:1482 ../../library/ssl.rst:1483
#: ../../library/ssl.rst:1484 ../../library/ssl.rst:1485
#: ../../library/ssl.rst:1486 ../../library/ssl.rst:1487
msgid "yes"
msgstr "yes"

#: ../../library/ssl.rst:1482 ../../library/ssl.rst:1483
#: ../../library/ssl.rst:1485 ../../library/ssl.rst:1486
#: ../../library/ssl.rst:1487
msgid "no"
msgstr "no"

#: ../../library/ssl.rst:1482 ../../library/ssl.rst:1484
msgid "no [1]_"
msgstr "no [1]_"

#: ../../library/ssl.rst:1483
msgid "*SSLv3*"
msgstr "*SSLv3*"

#: ../../library/ssl.rst:1483 ../../library/ssl.rst:1484
msgid "no [2]_"
msgstr "no [2]_"

#: ../../library/ssl.rst:1484
msgid "*TLS* (*SSLv23*) [3]_"
msgstr "*TLS* (*SSLv23*) [3]_"

#: ../../library/ssl.rst:1485
msgid "*TLSv1*"
msgstr "*TLSv1*"

#: ../../library/ssl.rst:1486
msgid "*TLSv1.1*"
msgstr "*TLSv1.1*"

#: ../../library/ssl.rst:1487
msgid "*TLSv1.2*"
msgstr "*TLSv1.2*"

#: ../../library/ssl.rst:1490
msgid "Footnotes"
msgstr "註解"

#: ../../library/ssl.rst:1491
msgid ":class:`SSLContext` disables SSLv2 with :data:`OP_NO_SSLv2` by default."
msgstr ":class:`SSLContext` 預設禁用 SSLv2 :data:`OP_NO_SSLv2`。"

#: ../../library/ssl.rst:1492
msgid ":class:`SSLContext` disables SSLv3 with :data:`OP_NO_SSLv3` by default."
msgstr ":class:`SSLContext` 預設禁用 SSLv3 :data:`OP_NO_SSLv3`。"

#: ../../library/ssl.rst:1493
#, fuzzy
msgid ""
"TLS 1.3 protocol will be available with :data:`PROTOCOL_TLS` in OpenSSL >= "
"1.1.1. There is no dedicated PROTOCOL constant for just TLS 1.3."
msgstr ""
"TLS 1.3 協定將在 OpenSSL >= 1.1.1 中與 :data:`PROTOCOL_TLS` 一起使用。"
"沒有專用於 TLS 1.3 的專用 PROTOCOL 常數。"

#: ../../library/ssl.rst:1498
#, fuzzy
msgid ""
":func:`create_default_context` lets the :mod:`ssl` module choose security "
"settings for a given purpose."
msgstr ":func:`create_default_context` 讓 :mod:`ssl` 模組為給定目的選擇安全設定。"

#: ../../library/ssl.rst:1503
#, fuzzy
msgid ""
"The context is created with secure default values. The options :data:"
"`OP_NO_COMPRESSION`, :data:`OP_CIPHER_SERVER_PREFERENCE`, :data:"
"`OP_SINGLE_DH_USE`, :data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2` (except "
"for :data:`PROTOCOL_SSLv2`), and :data:`OP_NO_SSLv3` (except for :data:"
"`PROTOCOL_SSLv3`) are set by default. The initial cipher suite list contains "
"only ``HIGH`` ciphers, no ``NULL`` ciphers and no ``MD5`` ciphers (except "
"for :data:`PROTOCOL_SSLv2`)."
msgstr ""
"上下文是使用安全預設值建立的。選項 :data:`OP_NO_COMPRESSION`、:data:`OP_CI"
"PHER_SERVER_PREFERENCE`、:data:`OP_SINGLE_DH_USE`、:data:`OP_SINGLE_ECDH_"
"USE`、:data:`OP_NO_SSLv2`（除了 :data:`PROTOCOL_SSLv2`）和 :data:`OP_NO_SS"
"Lv3`（除了 :data:`PROTOCOL_SSLv3`）預設設定。初始密碼套件列表僅包含 ``HIGH``密碼"
"，沒有 ``NULL`` 密碼，也沒有 ``MD5``密碼（PROTOCOL_SSLv2 除外）。"

#: ../../library/ssl.rst:1514
#, fuzzy
msgid ""
":class:`SSLContext` without protocol argument is deprecated. The context "
"class will either require :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER` protocol in the future."
msgstr ""
":class:`SSLContext` 沒有協定參數已棄用。將來，上下文類將需要 "
":data:`PROTOCOL_TLS_CLIENT` 或 :data:`PROTOCOL_TLS_SERVER` 協定。"

#: ../../library/ssl.rst:1520
#, fuzzy
msgid ""
"The default cipher suites now include only secure AES and ChaCha20 ciphers "
"with forward secrecy and security level 2. RSA and DH keys with less than "
"2048 bits and ECC keys with less than 224 bits are prohibited. :data:"
"`PROTOCOL_TLS`, :data:`PROTOCOL_TLS_CLIENT`, and :data:`PROTOCOL_TLS_SERVER` "
"use TLS 1.2 as minimum TLS version."
msgstr ""
"預設密碼套件現在僅包括具有前向保密性和安全級別 2 的安全 AES 和 ChaCha20 "
"密碼。禁止使用少於 2048 位的 RSA 和 DH 密鑰以及少於 224 位的 ECC 密鑰。 "
":data:`PROTOCOL_TLS`、:data:`PROTOCOL_TLS_CLIENT` 和 "
":data:`PROTOCOL_TLS_SERVER` 使用 TLS 1.2 作為最低 TLS 版本。"

#: ../../library/ssl.rst:1527
#, fuzzy
msgid ":class:`SSLContext` objects have the following methods and attributes:"
msgstr ":class:`SSLContext` 物件具有以下方法和屬性："

#: ../../library/ssl.rst:1531
#, fuzzy
msgid ""
"Get statistics about quantities of loaded X.509 certificates, count of X.509 "
"certificates flagged as CA certificates and certificate revocation lists as "
"dictionary."
msgstr "獲取有關加載的 X.509 證書數量、標記為 CA 證書的 X.509 "
"證書計數以及作為字典的證書吊銷列表的統計資訊。"

#: ../../library/ssl.rst:1535
#, fuzzy
msgid "Example for a context with one CA cert and one other cert::"
msgstr "具有一個 CA 證書和另一個證書的上下文示例："

#: ../../library/ssl.rst:1545
#, fuzzy
msgid ""
"Load a private key and the corresponding certificate.  The *certfile* string "
"must be the path to a single file in PEM format containing the certificate "
"as well as any number of CA certificates needed to establish the "
"certificate's authenticity.  The *keyfile* string, if present, must point to "
"a file containing the private key.  Otherwise the private key will be taken "
"from *certfile* as well.  See the discussion of :ref:`ssl-certificates` for "
"more information on how the certificate is stored in the *certfile*."
msgstr ""
"加載私鑰和相應的證書。 *certfile* 字串必須是 PEM 格式的單個文件的路徑，"
"該文件包含證書以及建立證書真實性所需的任意數量的 CA 證書。 *keyfile* "
"字串（如果存在）必須指向包含私鑰的文件。否則私鑰也將從 *certfile* 中獲取。"
"有關證書如何儲存在 *certfile* 中的更多資訊，請參閱 :ref:`ssl-certificates` "
"的討論。"

#: ../../library/ssl.rst:1554
#, fuzzy
msgid ""
"The *password* argument may be a function to call to get the password for "
"decrypting the private key.  It will only be called if the private key is "
"encrypted and a password is necessary.  It will be called with no arguments, "
"and it should return a string, bytes, or bytearray.  If the return value is "
"a string it will be encoded as UTF-8 before using it to decrypt the key. "
"Alternatively a string, bytes, or bytearray value may be supplied directly "
"as the *password* argument.  It will be ignored if the private key is not "
"encrypted and no password is needed."
msgstr ""
"*password* 參數可以是呼叫以獲取用於解密私鑰的密碼的函式。只有在私鑰被加密並且"
"需要密碼時才會呼叫它。它將在沒有參數的情況下被呼叫，它應該回傳一個字串、位元"
"組或位元組數組。如果回傳值是一個字串，它將在使用它解密密鑰之前被編碼為 "
"UTF-8。或者，可以直接提供字串、位元組或位元組數組值作為 *password* "
"參數。如果私鑰未加密且不需要密碼，它將被忽略。"

#: ../../library/ssl.rst:1563
#, fuzzy
msgid ""
"If the *password* argument is not specified and a password is required, "
"OpenSSL's built-in password prompting mechanism will be used to "
"interactively prompt the user for a password."
msgstr "如果未指定 *password* 參數，但需要輸入密碼，OpenSSL "
"內建的密碼提示機制將以交互方式提示使用者輸入密碼。"

#: ../../library/ssl.rst:1567
#, fuzzy
msgid ""
"An :class:`SSLError` is raised if the private key doesn't match with the "
"certificate."
msgstr "如果私鑰與證書不匹配，則會引發 SSLError。"

#: ../../library/ssl.rst:1570
#, fuzzy
msgid "New optional argument *password*."
msgstr "新的可選參數 *密碼*。"

#: ../../library/ssl.rst:1575
#, fuzzy
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from "
"default locations. On Windows it loads CA certs from the ``CA`` and ``ROOT`` "
"system stores. On all systems it calls :meth:`SSLContext."
"set_default_verify_paths`. In the future the method may load CA certificates "
"from other locations, too."
msgstr ""
"從預設位置加載一組預設的“證書頒發機構”(CA) 證書。在 Windows 上，它從 ``CA`` "
"和 ``ROOT`` 系統儲存加載 CA 證書。在所有系統上，它呼叫 :meth:`SSLContext."
"set_default_verify_paths`。將來，該方法也可能從其他位置加載 CA 證書。"

#: ../../library/ssl.rst:1581
#, fuzzy
msgid ""
"The *purpose* flag specifies what kind of CA certificates are loaded. The "
"default settings :data:`Purpose.SERVER_AUTH` loads certificates, that are "
"flagged and trusted for TLS web server authentication (client side "
"sockets). :data:`Purpose.CLIENT_AUTH` loads CA certificates for client "
"certificate verification on the server side."
msgstr ""
"*purpose* 旗標指定加載哪種 CA 證書。預設設定 :data:`Purpose.SERVER_AUTH` "
"加載證書，這些證書被標記和信任用於 TLS Web 伺服器身份驗證（客戶端 socket ）。 "
":data:`Purpose.CLIENT_AUTH` 加載 CA 證書，用於伺服器端的客戶端證書驗證。"

#: ../../library/ssl.rst:1591
#, fuzzy
msgid ""
"Load a set of \"certification authority\" (CA) certificates used to validate "
"other peers' certificates when :data:`verify_mode` is other than :data:"
"`CERT_NONE`.  At least one of *cafile* or *capath* must be specified."
msgstr ""
"當 :data:`verify_mode` 不是 :data:`CERT_NONE` 時，加載一組“證書頒發機構”(CA) "
"證書，用於驗證其他對等方的證書。至少必須指定 *cafile* 或 *capath* 之一。"

#: ../../library/ssl.rst:1595
#, fuzzy
msgid ""
"This method can also load certification revocation lists (CRLs) in PEM or "
"DER format. In order to make use of CRLs, :attr:`SSLContext.verify_flags` "
"must be configured properly."
msgstr ""
"此方法還可以加載 PEM 或 DER 格式的證書撤銷列表 (CRL)。為了使用 CRL，"
"必須正確配置 SSLContext.verify_flags。"

#: ../../library/ssl.rst:1599
#, fuzzy
msgid ""
"The *cafile* string, if present, is the path to a file of concatenated CA "
"certificates in PEM format. See the discussion of :ref:`ssl-certificates` "
"for more information about how to arrange the certificates in this file."
msgstr ""
"*cafile* 字串（如果存在）是 PEM 格式的串聯 CA "
"證書文件的路徑。有關如何在此文件中排列證書的更多資訊，請參閱 :ref:`ssl-"
"certificates` 的討論。"

#: ../../library/ssl.rst:1604
#, fuzzy
msgid ""
"The *capath* string, if present, is the path to a directory containing "
"several CA certificates in PEM format, following an `OpenSSL specific layout "
"<https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations."
"html>`_."
msgstr ""
"*capath* 字串（如果存在）是包含多個 PEM 格式的 CA 證書的目錄的路徑，遵循“"
"OpenSSL 特定佈局 <https://www.openssl.org/docs/manmaster/man3/"
"SSL_CTX_load_verify_locations.html>” `_。"

#: ../../library/ssl.rst:1609
#, fuzzy
msgid ""
"The *cadata* object, if present, is either an ASCII string of one or more "
"PEM-encoded certificates or a :term:`bytes-like object` of DER-encoded "
"certificates. Like with *capath* extra lines around PEM-encoded certificates "
"are ignored but at least one certificate must be present."
msgstr ""
"*cadata* 物件（如果存在）是一個或多個 PEM 編碼證書的 ASCII 字串，或者是 DER "
"編碼證書的類似位元組的物件。與 *capath* 一樣，圍繞 PEM "
"編碼證書的額外行將被忽略，但至少必須存在一個證書。"

#: ../../library/ssl.rst:1614
#, fuzzy
msgid "New optional argument *cadata*"
msgstr "新的可選參數 *cadata*"

#: ../../library/ssl.rst:1619
#, fuzzy
msgid ""
"Get a list of loaded \"certification authority\" (CA) certificates. If the "
"``binary_form`` parameter is :const:`False` each list entry is a dict like "
"the output of :meth:`SSLSocket.getpeercert`. Otherwise the method returns a "
"list of DER-encoded certificates. The returned list does not contain "
"certificates from *capath* unless a certificate was requested and loaded by "
"a SSL connection."
msgstr ""
"獲取已加載的“證書頒發機構”(CA) 證書的列表。如果 ``binary_form`` 參數為 "
":const:`False`，則每個列表條目都是一個字典，類似於 :meth:`SSLSocket."
"getpeercert` 的輸出。否則，該方法回傳 DER 編碼證書的列表。"
"回傳的列表不包含來自 *capath* 的證書，除非證書是由 SSL 連接請求和加載的。"

#: ../../library/ssl.rst:1627
#, fuzzy
msgid ""
"Certificates in a capath directory aren't loaded unless they have been used "
"at least once."
msgstr "除非至少使用過一次，否則不會加載 capath 目錄中的證書。"

#: ../../library/ssl.rst:1634
#, fuzzy
msgid ""
"Get a list of enabled ciphers. The list is in order of cipher priority. See :"
"meth:`SSLContext.set_ciphers`."
msgstr "獲取已啟用密碼的列表。該列表按密碼優先級排序。請參閱 :meth:`SSLContext."
"set_ciphers`。"

#: ../../library/ssl.rst:1671
#, fuzzy
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from a "
"filesystem path defined when building the OpenSSL library.  Unfortunately, "
"there's no easy way to know whether this method succeeds: no error is "
"returned if no certificates are to be found.  When the OpenSSL library is "
"provided as part of the operating system, though, it is likely to be "
"configured properly."
msgstr ""
"從構建 OpenSSL 庫時定義的文件系統路徑加載一組預設的“證書頒發機構”(CA) 證書。"
"不幸的是，沒有簡單的方法可以知道此方法是否成功：如果找不到證書，則不會回傳任"
"何錯誤。但是，當 OpenSSL 庫作為操作系統的一部分提供時，它可能會被正確配置。"

#: ../../library/ssl.rst:1680
#, fuzzy
msgid ""
"Set the available ciphers for sockets created with this context. It should "
"be a string in the `OpenSSL cipher list format <https://www.openssl.org/docs/"
"manmaster/man1/ciphers.html>`_. If no cipher can be selected (because "
"compile-time options or other configuration forbids use of all the specified "
"ciphers), an :class:`SSLError` will be raised."
msgstr ""
"為使用此上下文建立的 socket 設定可用密碼。它應該是 `OpenSSL 密碼列表格式 "
"<https://www.openssl.org/docs/manmaster/man1/ciphers.html>`_ 中的字串。如果沒"
"有密碼可以選擇（因為編譯時選項或其他配置禁止使用所有指定的密碼），一個 "
":class:`SSLError` 將被引發。"

#: ../../library/ssl.rst:1688
#, fuzzy
msgid ""
"when connected, the :meth:`SSLSocket.cipher` method of SSL sockets will give "
"the currently selected cipher."
msgstr "連接後，SSL  socket 的 :meth:`SSLSocket.cipher` 方法將給出當前選擇的密碼。"

#: ../../library/ssl.rst:1691
#, fuzzy
msgid ""
"TLS 1.3 cipher suites cannot be disabled with :meth:`~SSLContext."
"set_ciphers`."
msgstr "無法使用 :meth:`~SSLContext.set_ciphers` 禁用 TLS 1.3 密碼套件。"

#: ../../library/ssl.rst:1696
#, fuzzy
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of ASCII strings, like ``['http/1.1', "
"'spdy/2']``, ordered by preference. The selection of a protocol will happen "
"during the handshake, and will play out according to :rfc:`7301`. After a "
"successful handshake, the :meth:`SSLSocket.selected_alpn_protocol` method "
"will return the agreed-upon protocol."
msgstr ""
"指定 socket 在 SSL/TLS 握手期間應通告哪些協定。它應該是一個 ASCII 字串列表，如 "
"``['http/1.1', 'spdy/2']``，按偏好排序。協定的選擇將在握手期間發生，並將根據 "
":rfc:`7301` 進行。成功握手後，:meth:`SSLSocket.selected_alpn_protocol` "
"方法將回傳商定的協定。"

#: ../../library/ssl.rst:1703
#, fuzzy
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_ALPN` is "
"``False``."
msgstr "如果 :data:`HAS_ALPN` 為 ``False``，此方法將引發 :exec:`NotImplementedError`。"

#: ../../library/ssl.rst:1710
#, fuzzy
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of strings, like ``['http/1.1', 'spdy/2']``, "
"ordered by preference. The selection of a protocol will happen during the "
"handshake, and will play out according to the `Application Layer Protocol "
"Negotiation <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_. After a successful handshake, the :meth:"
"`SSLSocket.selected_npn_protocol` method will return the agreed-upon "
"protocol."
msgstr ""
"指定 socket 在 SSL/TLS 握手期間應通告哪些協定。它應該是一個字串列表，如 ``['"
"http/1.1', 'spdy/2']``，按偏好排序。協定的選擇將在握手期間發生，並將根據“應用"
"層協定協商”<https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_ 進行。成功握手後，:meth:`SSLSocket."
"selected_npn_protocol` 方法將回傳商定的協定。"

#: ../../library/ssl.rst:1718
#, fuzzy
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_NPN` is "
"``False``."
msgstr "如果 HAS_NPN 為 False，此方法將引發 NotImplementedError。"

#: ../../library/ssl.rst:1729
#, fuzzy
msgid ""
"Register a callback function that will be called after the TLS Client Hello "
"handshake message has been received by the SSL/TLS server when the TLS "
"client specifies a server name indication. The server name indication "
"mechanism is specified in :rfc:`6066` section 3 - Server Name Indication."
msgstr ""
"註冊一個回呼函式，當 TLS 客戶端指定伺服器名稱指示時，將在 SSL/TLS 伺服器收到 "
"TLS 客戶端問候握手消息後呼叫該回呼函式。伺服器名稱指示機制在 :rfc:`6066` 第 "
"3 節 - 伺服器名稱指示中指定。"

#: ../../library/ssl.rst:1734
#, fuzzy
msgid ""
"Only one callback can be set per ``SSLContext``.  If *sni_callback* is set "
"to ``None`` then the callback is disabled. Calling this function a "
"subsequent time will disable the previously registered callback."
msgstr ""
"每個 ``SSLContext`` 只能設定一個回呼。如果 *sni_callback* 設定為 ``None`` "
"則回呼被禁用。後續呼叫此函式將禁用先前註冊的回呼。"

#: ../../library/ssl.rst:1738
#, fuzzy
msgid ""
"The callback function will be called with three arguments; the first being "
"the :class:`ssl.SSLSocket`, the second is a string that represents the "
"server name that the client is intending to communicate (or :const:`None` if "
"the TLS Client Hello does not contain a server name) and the third argument "
"is the original :class:`SSLContext`. The server name argument is text. For "
"internationalized domain name, the server name is an IDN A-label (``\"xn--"
"pythn-mua.org\"``)."
msgstr ""
"將使用三個參數呼叫回呼函式；第一個是 :class:`ssl."
"SSLSocket`，第二個是表示客戶端打算通信的伺服器名稱的字串（如果 TLS Client "
"Hello 不包含伺服器名稱，則為 :const:`None`）第三個參數是原始的 "
":class:`SSLContext`。伺服器名稱參數是文本。對於國際化域名，伺服器名稱是一個 "
"IDN A 標籤 (``\"xn--python-mua.org\"``)。"

#: ../../library/ssl.rst:1746
#, fuzzy
msgid ""
"A typical use of this callback is to change the :class:`ssl.SSLSocket`'s :"
"attr:`SSLSocket.context` attribute to a new object of type :class:"
"`SSLContext` representing a certificate chain that matches the server name."
msgstr ""
"此回呼的典型用途是將 :class:`ssl.SSLSocket` 的 :attr:`SSLSocket.context` "
"屬性更改為 :class:`SSLContext` 型別的新物件，表示與伺服器名稱匹配的證書鏈."

#: ../../library/ssl.rst:1751
#, fuzzy
msgid ""
"Due to the early negotiation phase of the TLS connection, only limited "
"methods and attributes are usable like :meth:`SSLSocket."
"selected_alpn_protocol` and :attr:`SSLSocket.context`. The :meth:`SSLSocket."
"getpeercert`, :meth:`SSLSocket.cipher` and :meth:`SSLSocket.compression` "
"methods require that the TLS connection has progressed beyond the TLS Client "
"Hello and therefore will not return meaningful values nor can they be called "
"safely."
msgstr ""
"由於 TLS 連接的早期協商階段，只有有限的方法和屬性可用，如 :meth:`SSLSocket."
"selected_alpn_protocol` 和 :attr:`SSLSocket.context`。 :meth:`SSLSocket."
"getpeercert`、:meth:`SSLSocket.cipher` 和 :meth:`SSLSocket.compression` "
"方法要求 TLS 連接已經超出 TLS Client "
"Hello，因此不會回傳有意義的值，它們也不會回傳有意義的值被安全呼叫。"

#: ../../library/ssl.rst:1759
#, fuzzy
msgid ""
"The *sni_callback* function must return ``None`` to allow the TLS "
"negotiation to continue.  If a TLS failure is required, a constant :const:"
"`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` can be returned.  "
"Other return values will result in a TLS fatal error with :const:"
"`ALERT_DESCRIPTION_INTERNAL_ERROR`."
msgstr ""
"*sni_callback* 函式必須回傳 ``None``以允許 TLS 協商繼續。如果需要 TLS "
"失敗，則可以回傳常數 :const:`ALERT_DESCRIPTION_* "
"<ALERT_DESCRIPTION_INTERNAL_ERROR>`。其他回傳值將導致 TLS "
"致命錯誤 :const:`ALERT_DESCRIPTION_INTERNAL_ERROR`。"

#: ../../library/ssl.rst:1765
#, fuzzy
msgid ""
"If an exception is raised from the *sni_callback* function the TLS "
"connection will terminate with a fatal TLS alert message :const:"
"`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."
msgstr ""
"如果 *sni_callback* 函式引發例外，則 TLS 連接將終止並顯示致命的 TLS "
"警報消息 :const:`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`。"

#: ../../library/ssl.rst:1769
#, fuzzy
msgid ""
"This method will raise :exc:`NotImplementedError` if the OpenSSL library had "
"OPENSSL_NO_TLSEXT defined when it was built."
msgstr ""
"如果 OpenSSL 庫在構建時定義了 "
"OPENSSL_NO_TLSEXT，則此方法將引發 :exec:`NotImplementedError`。"

#: ../../library/ssl.rst:1776
#, fuzzy
msgid ""
"This is a legacy API retained for backwards compatibility. When possible, "
"you should use :attr:`sni_callback` instead. The given "
"*server_name_callback* is similar to *sni_callback*, except that when the "
"server hostname is an IDN-encoded internationalized domain name, the "
"*server_name_callback* receives a decoded U-label (``\"pythön.org\"``)."
msgstr ""
"這是為向後相容而保留的遺留 API。如果可能，您應該改用 :attr:`sni_callback`。"
"給定的 *server_name_callback* 類似於 *sni_callback*，除了當伺服器主機名是 "
"IDN 編碼的國際化域名時，*server_name_callback* 接收解碼的 U 標籤（``\"python."
"org\"``）。"

#: ../../library/ssl.rst:1782
#, fuzzy
msgid ""
"If there is an decoding error on the server name, the TLS connection will "
"terminate with an :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` fatal TLS alert "
"message to the client."
msgstr ""
"如果伺服器名稱存在解碼錯誤，則 TLS 連接將終止，並向客戶端發送 "
"ALERT_DESCRIPTION_INTERNAL_ERROR 致命 TLS 警報消息。"

#: ../../library/ssl.rst:1790
#, fuzzy
msgid ""
"Load the key generation parameters for Diffie-Hellman (DH) key exchange. "
"Using DH key exchange improves forward secrecy at the expense of "
"computational resources (both on the server and on the client). The *dhfile* "
"parameter should be the path to a file containing DH parameters in PEM "
"format."
msgstr ""
"加載 Diffie-Hellman (DH) 密鑰交換的密鑰生成參數。使用 DH "
"密鑰交換以計算資源（伺服器和客戶端）為代價提高前向保密性。 *dhfile* "
"參數應該是包含 PEM 格式的 DH 參數的文件的路徑。"

#: ../../library/ssl.rst:1796
#, fuzzy
msgid ""
"This setting doesn't apply to client sockets.  You can also use the :data:"
"`OP_SINGLE_DH_USE` option to further improve security."
msgstr "此設定不適用於客戶端 socket 。您還可以使用 :data:`OP_SINGLE_DH_USE` "
"選項來進一步提高安全性。"

#: ../../library/ssl.rst:1803
#, fuzzy
msgid ""
"Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key "
"exchange.  ECDH is significantly faster than regular DH while arguably as "
"secure.  The *curve_name* parameter should be a string describing a well-"
"known elliptic curve, for example ``prime256v1`` for a widely supported "
"curve."
msgstr ""
"為基於橢圓曲線的 Diffie-Hellman (ECDH) 密鑰交換設定曲線名稱。 ECDH 比常規 DH "
"快得多，同時可以說同樣安全。 *curve_name* "
"參數應該是描述眾所周知的橢圓曲線的字串，例如 ``prime256v1`` "
"表示廣泛支援的曲線。"

#: ../../library/ssl.rst:1809
#, fuzzy
msgid ""
"This setting doesn't apply to client sockets.  You can also use the :data:"
"`OP_SINGLE_ECDH_USE` option to further improve security."
msgstr "此設定不適用於客戶端 socket 。您還可以使用 :data:`OP_SINGLE_ECDH_USE` "
"選項進一步提高安全性。"

#: ../../library/ssl.rst:1812
#, fuzzy
msgid "This method is not available if :data:`HAS_ECDH` is ``False``."
msgstr "如果 :data:`HAS_ECDH` 為``False``，則此方法不可用。"

#: ../../library/ssl.rst:1817
#, fuzzy
msgid ""
"`SSL/TLS & Perfect Forward Secrecy <https://vincent.bernat.im/en/blog/2011-"
"ssl-perfect-forward-secrecy>`_"
msgstr ""
"`SSL/TLS 和完美前向保密 <https://vincent.bernat.im/en/blog/2011-ssl-perfect-"
"forward-secrecy>`_"

#: ../../library/ssl.rst:1818
#, fuzzy
msgid "Vincent Bernat."
msgstr "文森特·伯納特。"

#: ../../library/ssl.rst:1824
#, fuzzy
msgid ""
"Wrap an existing Python socket *sock* and return an instance of :attr:"
"`SSLContext.sslsocket_class` (default :class:`SSLSocket`). The returned SSL "
"socket is tied to the context, its settings and certificates. *sock* must be "
"a :data:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ""
"包裝現有的 Python  socket  *sock* 並回傳 :attr:`SSLContext.sslsocket_class` "
"的實例（預設為 :class:`SSLSocket`）。回傳的 SSL "
" socket 與上下文、它的設定和證書相關聯。 *sock* 必須是 :data:`~socket."
"SOCK_STREAM`  socket ；不支援其他 socket 型別。"

#: ../../library/ssl.rst:1830
#, fuzzy
msgid ""
"The parameter ``server_side`` is a boolean which identifies whether server-"
"side or client-side behavior is desired from this socket."
msgstr "參數“server_side”是一個布爾值，用於標識此 socket 是否需要伺服器端或客戶端行為。"

#: ../../library/ssl.rst:1833
#, fuzzy
msgid ""
"For client-side sockets, the context construction is lazy; if the underlying "
"socket isn't connected yet, the context construction will be performed "
"after :meth:`connect` is called on the socket.  For server-side sockets, if "
"the socket has no remote peer, it is assumed to be a listening socket, and "
"the server-side SSL wrapping is automatically performed on client "
"connections accepted via the :meth:`accept` method. The method may raise :"
"exc:`SSLError`."
msgstr ""
"對於客戶端 socket ，上下文構造是惰性的；如果底層 socket 尚未連接，"
"則在 socket 上呼叫 :meth:`connect` 後將執行上下文構造。對於伺服器端 socket ，如果"
" socket 沒有遠程對等點，則假定它是一個監聽 socket ，並且伺服器端 SSL "
"包裝會自動對通過 :meth:`accept` 方法接受的客戶端連接執行。該方法可能會引發 "
":exc:`SSLError`。"

#: ../../library/ssl.rst:1841
#, fuzzy
msgid ""
"On client connections, the optional parameter *server_hostname* specifies "
"the hostname of the service which we are connecting to.  This allows a "
"single server to host multiple SSL-based services with distinct "
"certificates, quite similarly to HTTP virtual hosts. Specifying "
"*server_hostname* will raise a :exc:`ValueError` if *server_side* is true."
msgstr ""
"在客戶端連接上，可選參數 *server_hostname* 指定我們要連接的服務的主機名。"
"這允許單個伺服器託管多個具有不同證書的基於 SSL 的服務，這與 HTTP "
"虛擬主機非常相似。如果 *server_side* 為真，指定 *server_hostname* 將引發 "
":exc:`ValueError`。"

#: ../../library/ssl.rst:1847
#, fuzzy
msgid ""
"The parameter ``do_handshake_on_connect`` specifies whether to do the SSL "
"handshake automatically after doing a :meth:`socket.connect`, or whether the "
"application program will call it explicitly, by invoking the :meth:"
"`SSLSocket.do_handshake` method.  Calling :meth:`SSLSocket.do_handshake` "
"explicitly gives the program control over the blocking behavior of the "
"socket I/O involved in the handshake."
msgstr ""
"參數 ``do_handshake_on_connect`` 指定是在執行 :meth:`socket.connect` "
"後自動進行 SSL 握手，還是應用程式通過呼叫 :meth:`SSLSocket.do_handshake` "
"方法顯式呼叫它。呼叫 :meth:`SSLSocket.do_handshake` "
"顯式地讓程式控制握手中涉及的 socket  I/O 的阻塞行為。"

#: ../../library/ssl.rst:1854
#, fuzzy
msgid ""
"The parameter ``suppress_ragged_eofs`` specifies how the :meth:`SSLSocket."
"recv` method should signal unexpected EOF from the other end of the "
"connection.  If specified as :const:`True` (the default), it returns a "
"normal EOF (an empty bytes object) in response to unexpected EOF errors "
"raised from the underlying socket; if :const:`False`, it will raise the "
"exceptions back to the caller."
msgstr ""
"參數 ``suppress_ragged_eofs`` 指定 :meth:`SSLSocket.recv` "
"方法應該如何從連接的另一端發出意外的 EOF。如果指定為 "
":const:`True`（預設值），它會回傳一個正常的 EOF（一個空位元組物件）"
"以響應從底層 socket 引發的意外 EOF 錯誤；如果 "
":const:`False`，它會將例外回傳給呼叫者。"

#: ../../library/ssl.rst:1861
#, fuzzy
msgid "*session*, see :attr:`~SSLSocket.session`."
msgstr "*session*，見 :attr:`~SSLSocket.session`。"

#: ../../library/ssl.rst:1863
#, fuzzy
msgid ""
"Always allow a server_hostname to be passed, even if OpenSSL does not have "
"SNI."
msgstr "始終允許傳遞 server_hostname，即使 OpenSSL 沒有 SNI。"

#: ../../library/ssl.rst:1867 ../../library/ssl.rst:1893
msgid "*session* argument was added."
msgstr "新增 *session* 引數。"

#: ../../library/ssl.rst:1870
#, fuzzy
msgid ""
"The method returns an instance of :attr:`SSLContext.sslsocket_class` instead "
"of hard-coded :class:`SSLSocket`."
msgstr ""
"該方法回傳 :attr:`SSLContext.sslsocket_class` 的實例，而不是硬編碼的 "
":class:`SSLSocket`。"

#: ../../library/ssl.rst:1876
#, fuzzy
msgid ""
"The return type of :meth:`SSLContext.wrap_socket`, defaults to :class:"
"`SSLSocket`. The attribute can be overridden on instance of class in order "
"to return a custom subclass of :class:`SSLSocket`."
msgstr ""
":meth:`SSLContext.wrap_socket` 的回傳型別，預設為 "
":class:`SSLSocket`。可以在類的實例上覆蓋該屬性，以回傳 SSLSocket "
"的自定義子類別。"

#: ../../library/ssl.rst:1885
#, fuzzy
msgid ""
"Wrap the BIO objects *incoming* and *outgoing* and return an instance of :"
"attr:`SSLContext.sslobject_class` (default :class:`SSLObject`). The SSL "
"routines will read input data from the incoming BIO and write data to the "
"outgoing BIO."
msgstr ""
"包裝 BIO 物件 *incoming* 和 *outgoing* 並回傳一個實例 :attr:`SSLContext."
"sslobject_class`（預設 :class:`SSLObject`）。 SSL 例程將從傳入 BIO "
"讀取輸入資料並將資料寫入傳出 BIO。"

#: ../../library/ssl.rst:1890
#, fuzzy
msgid ""
"The *server_side*, *server_hostname* and *session* parameters have the same "
"meaning as in :meth:`SSLContext.wrap_socket`."
msgstr ""
"*server_side*、*server_hostname* 和 *session* 參數與 SSLContext.wrap_socket "
"中的含義相同。"

#: ../../library/ssl.rst:1896
#, fuzzy
msgid ""
"The method returns an instance of :attr:`SSLContext.sslobject_class` instead "
"of hard-coded :class:`SSLObject`."
msgstr ""
"該方法回傳 :attr:`SSLContext.sslobject_class` 的實例，而不是硬編碼的 "
":class:`SSLObject`。"

#: ../../library/ssl.rst:1902
#, fuzzy
msgid ""
"The return type of :meth:`SSLContext.wrap_bio`, defaults to :class:"
"`SSLObject`. The attribute can be overridden on instance of class in order "
"to return a custom subclass of :class:`SSLObject`."
msgstr ""
":meth:`SSLContext.wrap_bio` 的回傳型別，預設為 "
":class:`SSLObject`。可以在類的實例上覆蓋該屬性，以回傳 SSLObject "
"的自定義子類別。"

#: ../../library/ssl.rst:1910
#, fuzzy
msgid ""
"Get statistics about the SSL sessions created or managed by this context. A "
"dictionary is returned which maps the names of each `piece of information "
"<https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_sess_number.html>`_ to "
"their numeric values.  For example, here is the total number of hits and "
"misses in the session cache since the context was created::"
msgstr ""
"獲取有關由此上下文建立或管理的 SSL 會話的統計資訊。回傳一個字典，"
"它將每條資訊 <https://www.openssl.org/docs/man1.1.1/man3/"
"SSL_CTX_sess_number.html> 的名稱映射到它們的數值。例如，這是自建立上下文以來"
"會話快取中命中和未命中的總數："

#: ../../library/ssl.rst:1921
#, fuzzy
msgid ""
"Whether to match the peer cert's hostname in :meth:`SSLSocket.do_handshake`. "
"The context's :attr:`~SSLContext.verify_mode` must be set to :data:"
"`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, and you must pass "
"*server_hostname* to :meth:`~SSLContext.wrap_socket` in order to match the "
"hostname.  Enabling hostname checking automatically sets :attr:`~SSLContext."
"verify_mode` from :data:`CERT_NONE` to :data:`CERT_REQUIRED`.  It cannot be "
"set back to :data:`CERT_NONE` as long as hostname checking is enabled. The :"
"data:`PROTOCOL_TLS_CLIENT` protocol enables hostname checking by default. "
"With other protocols, hostname checking must be enabled explicitly."
msgstr ""
"是否在 :meth:`SSLSocket.do_handshake` 中匹配對等證書的主機名。上下文的 "
":attr:`~SSLContext.verify_mode` 必須設定為 :data:`CERT_OPTIONAL` 或 "
":data:`CERT_REQUIRED`，並且您必須將 *server_hostname* 傳遞給 "
":meth:`~SSLContext.wrap_socket` 才能匹配主機名。啟用主機名檢查會自動將 "
":attr:`~SSLContext.verify_mode` 從 :data:`CERT_NONE` 設定為 :data:`CERT_REQUI"
"RED`。只要啟用了主機名檢查，它就不能設定回 :data:`CERT_NONE`。 "
":data:`PROTOCOL_TLS_CLIENT` "
"協定預設啟用主機名檢查。對於其他協定，必須顯式啟用主機名檢查。"

#: ../../library/ssl.rst:1949
#, fuzzy
msgid ""
":attr:`~SSLContext.verify_mode` is now automatically changed to :data:"
"`CERT_REQUIRED`  when hostname checking is enabled and :attr:`~SSLContext."
"verify_mode` is :data:`CERT_NONE`. Previously the same operation would have "
"failed with a :exc:`ValueError`."
msgstr ""
":attr:`~SSLContext.verify_mode` 現在自動更改為 :data:`CERT_REQUIRED` "
"當啟用主機名檢查且 :attr:`~SSLContext.verify_mode` 為 :data:`CERT_NONE` 時。"
"以前相同的操作會因 :exc:`ValueError` 而失敗。"

#: ../../library/ssl.rst:1956
#, fuzzy
msgid ""
"Write TLS keys to a keylog file, whenever key material is generated or "
"received. The keylog file is designed for debugging purposes only. The file "
"format is specified by NSS and used by many traffic analyzers such as "
"Wireshark. The log file is opened in append-only mode. Writes are "
"synchronized between threads, but not between processes."
msgstr ""
"每當生成或收到密鑰材料時，將 TLS "
"密鑰寫入密鑰日誌文件。鍵盤記錄文件僅用於除錯目的。文件格式由 NSS "
"指定，並被許多流量分析器（如 Wireshark）使用。日誌文件以僅追加模式打開。寫入"
"在執行緒之間同步，但在行程之間不同步。"

#: ../../library/ssl.rst:1966
#, fuzzy
msgid ""
"A :class:`TLSVersion` enum member representing the highest supported TLS "
"version. The value defaults to :attr:`TLSVersion.MAXIMUM_SUPPORTED`. The "
"attribute is read-only for protocols other than :attr:`PROTOCOL_TLS`, :attr:"
"`PROTOCOL_TLS_CLIENT`, and :attr:`PROTOCOL_TLS_SERVER`."
msgstr ""
"代表支援的最高 TLS 版本的 :class:`TLSVersion` "
"枚舉成員。該值預設為 :attr:`TLSVersion.MAXIMUM_SUPPORTED`。該屬性對於協定以外"
"的協定是只讀的 :attr:`PROTOCOL_TLS`、:attr:`PROTOCOL_TLS_CLIENT` 和 "
":attr:`PROTOCOL_TLS_SERVER`。"

#: ../../library/ssl.rst:1971
#, fuzzy
msgid ""
"The attributes :attr:`~SSLContext.maximum_version`, :attr:`~SSLContext."
"minimum_version` and :attr:`SSLContext.options` all affect the supported SSL "
"and TLS versions of the context. The implementation does not prevent invalid "
"combination. For example a context with :attr:`OP_NO_TLSv1_2` in :attr:"
"`~SSLContext.options` and :attr:`~SSLContext.maximum_version` set to :attr:"
"`TLSVersion.TLSv1_2` will not be able to establish a TLS 1.2 connection."
msgstr ""
"屬性 :attr:`~SSLContext.maximum_version`、:attr:`~SSLContext.minimum_version`"
" 和 :attr:`SSLContext.options` 都會影響上下文支援的 SSL 和 TLS "
"版本。該實作不會阻止無效組合。例如 :attr:`~SSLContext.options` 中的 "
":attr:`OP_NO_TLSv1_2` 和 :attr:`~SSLContext.maximum_version` 設定為 "
":attr:`TLSVersion.TLSv1_2` 的上下文將無法建立 TLS 1.2聯繫。"

#: ../../library/ssl.rst:1984
#, fuzzy
msgid ""
"Like :attr:`SSLContext.maximum_version` except it is the lowest supported "
"version or :attr:`TLSVersion.MINIMUM_SUPPORTED`."
msgstr ""
"類似於 :attr:`SSLContext.maximum_version` 除了它是支援的最低版本或 "
":attr:`TLSVersion.MINIMUM_SUPPORTED`。"

#: ../../library/ssl.rst:1991
#, fuzzy
msgid ""
"Control the number of TLS 1.3 session tickets of a :attr:"
"`PROTOCOL_TLS_SERVER` context. The setting has no impact on TLS 1.0 to 1.2 "
"connections."
msgstr ""
"控制 :attr:`PROTOCOL_TLS_SERVER` 上下文的 TLS 1.3 會話票證的數量。該設定對 "
"TLS 1.0 到 1.2 連接沒有影響。"

#: ../../library/ssl.rst:1999
#, fuzzy
msgid ""
"An integer representing the set of SSL options enabled on this context. The "
"default value is :data:`OP_ALL`, but you can specify other options such as :"
"data:`OP_NO_SSLv2` by ORing them together."
msgstr ""
"表示在此上下文中啟用的 SSL 選項集的整數。預設值為 "
":data:`OP_ALL`，但您可以指定其他選項，例如 :data:`OP_NO_SSLv2` "
"通過將它們組合在一起。"

#: ../../library/ssl.rst:2003
#, fuzzy
msgid ":attr:`SSLContext.options` returns :class:`Options` flags:"
msgstr ":attr:`SSLContext.options` 回傳 :class:`Options` 旗標："

#: ../../library/ssl.rst:2011
#, fuzzy
msgid ""
"All ``OP_NO_SSL*`` and ``OP_NO_TLS*`` options have been deprecated since "
"Python 3.7. Use :attr:`SSLContext.minimum_version` and :attr:`SSLContext."
"maximum_version` instead."
msgstr ""
"自 Python 3.7 以來，所有 ``OP_NO_SSL*`` 和 ``OP_NO_TLS*`` 選項已被棄用。使用 "
":attr:`SSLContext.minimum_version` 和 :attr:`SSLContext.maximum_version` "
"代替。"

#: ../../library/ssl.rst:2017
#, fuzzy
msgid ""
"Enable TLS 1.3 post-handshake client authentication. Post-handshake auth is "
"disabled by default and a server can only request a TLS client certificate "
"during the initial handshake. When enabled, a server may request a TLS "
"client certificate at any time after the handshake."
msgstr ""
"啟用 TLS 1.3 握手後客戶端身份驗證。預設情況下禁用握手後身份驗證，"
"並且伺服器只能在初始握手期間請求 TLS 客戶端證書。啟用後，"
"伺服器可以在握手後的任何時間請求 TLS 客戶端證書。"

#: ../../library/ssl.rst:2022
#, fuzzy
msgid ""
"When enabled on client-side sockets, the client signals the server that it "
"supports post-handshake authentication."
msgstr "當在客戶端 socket 上啟用時，客戶端會向伺服器發出它支援握手後身份驗證的信號。"

#: ../../library/ssl.rst:2025
#, fuzzy
msgid ""
"When enabled on server-side sockets, :attr:`SSLContext.verify_mode` must be "
"set to :data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, too. The actual "
"client cert exchange is delayed until :meth:`SSLSocket."
"verify_client_post_handshake` is called and some I/O is performed."
msgstr ""
"在伺服器端 socket 上啟用時，:attr:`SSLContext.verify_mode` "
"也必須設定為 :data:`CERT_OPTIONAL` "
"或 :data:`CERT_REQUIRED`。實際的客戶端證書交換被延遲，直到呼叫 "
"SSLSocket.verify_client_post_handshake 並執行一些 I/O。"

#: ../../library/ssl.rst:2035
#, fuzzy
msgid ""
"The protocol version chosen when constructing the context.  This attribute "
"is read-only."
msgstr "構建上下文時選擇的協定版本。該屬性是只讀的。"

#: ../../library/ssl.rst:2040
#, fuzzy
msgid ""
"Whether :attr:`~SSLContext.check_hostname` falls back to verify the cert's "
"subject common name in the absence of a subject alternative name extension "
"(default: true)."
msgstr ""
":attr:`~SSLContext.check_hostname` 在沒有主題替代名稱擴充的情況下是否回退以驗"
"證證書的主題通用名稱（預設值：true）。"

#: ../../library/ssl.rst:2048
#, fuzzy
msgid ""
"The flag had no effect with OpenSSL before version 1.1.1k. Python 3.8.9, "
"3.9.3, and 3.10 include workarounds for previous versions."
msgstr "該旗標對 1.1.1k 版本之前的 OpenSSL 沒有影響。 Python 3.8.9、3.9.3 和 3.10 "
"包括以前版本的解決方法。"

#: ../../library/ssl.rst:2053
#, fuzzy
msgid ""
"An integer representing the `security level <https://www.openssl.org/docs/"
"manmaster/man3/SSL_CTX_get_security_level.html>`_ for the context. This "
"attribute is read-only."
msgstr ""
"表示上下文的`安全級別 <https://www.openssl.org/docs/manmaster/man3/"
"SSL_CTX_get_security_level.html>`_ 的整數。該屬性是只讀的。"

#: ../../library/ssl.rst:2061
#, fuzzy
msgid ""
"The flags for certificate verification operations. You can set flags like :"
"data:`VERIFY_CRL_CHECK_LEAF` by ORing them together. By default OpenSSL does "
"neither require nor verify certificate revocation lists (CRLs)."
msgstr ""
"證書驗證操作的旗標。您可以通過將它們組合在一起來設定旗標，例如 :data:`VERIFY_"
"CRL_CHECK_LEAF`。預設情況下，OpenSSL 既不需要也不驗證證書吊銷列表 (CRL)。"

#: ../../library/ssl.rst:2067
#, fuzzy
msgid ":attr:`SSLContext.verify_flags` returns :class:`VerifyFlags` flags:"
msgstr ":attr:`SSLContext.verify_flags` 回傳 :class:`VerifyFlags` 旗標："

#: ../../library/ssl.rst:2075
#, fuzzy
msgid ""
"Whether to try to verify other peers' certificates and how to behave if "
"verification fails.  This attribute must be one of :data:`CERT_NONE`, :data:"
"`CERT_OPTIONAL` or :data:`CERT_REQUIRED`."
msgstr ""
"是否嘗試驗證其他節點的證書以及驗證失敗時如何處理。此屬性必須是 "
":data:`CERT_NONE`、:data:`CERT_OPTIONAL` 或 :data:`CERT_REQUIRED` 之一。"

#: ../../library/ssl.rst:2079
#, fuzzy
msgid ":attr:`SSLContext.verify_mode` returns :class:`VerifyMode` enum:"
msgstr ":attr:`SSLContext.verify_mode` 回傳 :class:`VerifyMode` 枚舉："

#: ../../library/ssl.rst:2092
#, fuzzy
msgid "Certificates"
msgstr "證書"

#: ../../library/ssl.rst:2094
#, fuzzy
msgid ""
"Certificates in general are part of a public-key / private-key system.  In "
"this system, each *principal*, (which may be a machine, or a person, or an "
"organization) is assigned a unique two-part encryption key.  One part of the "
"key is public, and is called the *public key*; the other part is kept "
"secret, and is called the *private key*.  The two parts are related, in that "
"if you encrypt a message with one of the parts, you can decrypt it with the "
"other part, and **only** with the other part."
msgstr ""
"證書通常是公鑰/私鑰系統的一部分。在這個系統中，每個*委託人*（可能是一台機器、"
"一個人或一個組織）都被分配了一個唯一的兩部分加密密鑰。密鑰的一部分是公開的，"
"稱為*公鑰*；另一部分保密，稱為*私鑰*。這兩部分是相關的，因為如果你用其中一個"
"部分加密消息，你可以用另一部分解密它，而**只能**用另一部分。"

#: ../../library/ssl.rst:2102
#, fuzzy
msgid ""
"A certificate contains information about two principals.  It contains the "
"name of a *subject*, and the subject's public key.  It also contains a "
"statement by a second principal, the *issuer*, that the subject is who they "
"claim to be, and that this is indeed the subject's public key.  The issuer's "
"statement is signed with the issuer's private key, which only the issuer "
"knows.  However, anyone can verify the issuer's statement by finding the "
"issuer's public key, decrypting the statement with it, and comparing it to "
"the other information in the certificate. The certificate also contains "
"information about the time period over which it is valid.  This is expressed "
"as two fields, called \"notBefore\" and \"notAfter\"."
msgstr ""
"證書包含有關兩個委託人的資訊。它包含*主題*的名稱和主題的公鑰。它還包含第二個"
"委託人*發行人*的聲明，即主體是他們聲稱的身份，並且這確實是主體的公鑰。發行人"
"的聲明是用發行人的私鑰簽名的，只有發行人知道。但是，任何人都可以通過找到頒發"
"者的公鑰、用它解密聲明並將其與證書中的其他資訊進行比較來驗證頒發者的聲明。證"
"書還包含有關其有效時間段的資訊。這表示為兩個欄位，稱為 ``notBefore`` 和 ``notAfter`` "
"。"

#: ../../library/ssl.rst:2112
#, fuzzy
msgid ""
"In the Python use of certificates, a client or server can use a certificate "
"to prove who they are.  The other side of a network connection can also be "
"required to produce a certificate, and that certificate can be validated to "
"the satisfaction of the client or server that requires such validation.  The "
"connection attempt can be set to raise an exception if the validation fails. "
"Validation is done automatically, by the underlying OpenSSL framework; the "
"application need not concern itself with its mechanics.  But the application "
"does usually need to provide sets of certificates to allow this process to "
"take place."
msgstr ""
"在 Python 使用證書時，客戶端或伺服器可以使用證書來證明他們是誰。網絡連接的另"
"一端也可能需要生成證書，並且可以驗證該證書以滿足需要此類驗證的客戶端或伺服器"
"的要求。如果驗證失敗，可以將連接嘗試設定為引發例外。驗證由底層 OpenSSL 框架自"
"動完成；應用程式無需關注其機制。但應用程式通常確實需要提供證書集以允許此過程"
"發生。"

#: ../../library/ssl.rst:2122
#, fuzzy
msgid ""
"Python uses files to contain certificates.  They should be formatted as "
"\"PEM\" (see :rfc:`1422`), which is a base-64 encoded form wrapped with a "
"header line and a footer line::"
msgstr ""
"Python 使用文件來包含證書。它們的格式應為 ``PEM``（參見 :rfc:`1422`），這是一種 "
"base-64 編碼形式，包含一個標題行和一個頁腳行::"

#: ../../library/ssl.rst:2131
#, fuzzy
msgid "Certificate chains"
msgstr "證書鏈"

#: ../../library/ssl.rst:2133
#, fuzzy
msgid ""
"The Python files which contain certificates can contain a sequence of "
"certificates, sometimes called a *certificate chain*.  This chain should "
"start with the specific certificate for the principal who \"is\" the client "
"or server, and then the certificate for the issuer of that certificate, and "
"then the certificate for the issuer of *that* certificate, and so on up the "
"chain till you get to a certificate which is *self-signed*, that is, a "
"certificate which has the same subject and issuer, sometimes called a *root "
"certificate*.  The certificates should just be concatenated together in the "
"certificate file.  For example, suppose we had a three certificate chain, "
"from our server certificate to the certificate of the certification "
"authority that signed our server certificate, to the root certificate of the "
"agency which issued the certification authority's certificate::"
msgstr ""
"包含證書的 Python 文件可以包含一系列證書，有時稱為*證書鏈*。此鏈應從 ``是``客戶"
"端或伺服器的委託人的特定證書開始，然後是該證書頒發者的證書，然後是*那個*證書"
"頒發者的證書，依此類推鏈直到您獲得*自簽名*的證書，即具有相同主題和頒發者的證"
"書，有時稱為*根證書*。證書應該在證書文件中連接在一起。例如，假設我們有一個三"
"證書鏈，從我們的伺服器證書到簽署我們的伺服器證書的證書頒發機構的證書，再到頒"
"發證書頒發機構證書的機構的根證書::"

#: ../../library/ssl.rst:2157
#, fuzzy
msgid "CA certificates"
msgstr "證書"

#: ../../library/ssl.rst:2159
#, fuzzy
msgid ""
"If you are going to require validation of the other side of the connection's "
"certificate, you need to provide a \"CA certs\" file, filled with the "
"certificate chains for each issuer you are willing to trust.  Again, this "
"file just contains these chains concatenated together.  For validation, "
"Python will use the first chain it finds in the file which matches.  The "
"platform's certificates file can be used by calling :meth:`SSLContext."
"load_default_certs`, this is done automatically with :func:`."
"create_default_context`."
msgstr ""
"如果您需要驗證連接證書的另一端，則需要提供一個“CA 證書”文件，其中包含您願意信"
"任的每個頒發者的證書鏈。同樣，這個文件只包含這些連接在一起的鏈。為了進行驗證"
"，Python 將使用它在匹配的文件中找到的第一個鏈。可以通過呼叫 :meth:`SSLContext"
".load_default_certs` 使用平台的證書文件，這是通過 :func:`."
"create_default_context` 自動完成的。"

#: ../../library/ssl.rst:2168
#, fuzzy
msgid "Combined key and certificate"
msgstr "組合密鑰和證書"

#: ../../library/ssl.rst:2170
#, fuzzy
msgid ""
"Often the private key is stored in the same file as the certificate; in this "
"case, only the ``certfile`` parameter to :meth:`SSLContext.load_cert_chain` "
"and :func:`wrap_socket` needs to be passed.  If the private key is stored "
"with the certificate, it should come before the first certificate in the "
"certificate chain::"
msgstr ""
"通常私鑰與證書儲存在同一個文件中；在這種情況下，只需要將 ``certfile`` "
"參數傳遞給 :meth:`SSLContext.load_cert_chain` 和 :func:`wrap_socket`。如果私"
"鑰與證書一起儲存，它應該在證書鏈中的第一個證書之前::"

#: ../../library/ssl.rst:2184
#, fuzzy
msgid "Self-signed certificates"
msgstr "自簽名證書"

#: ../../library/ssl.rst:2186
#, fuzzy
msgid ""
"If you are going to create a server that provides SSL-encrypted connection "
"services, you will need to acquire a certificate for that service.  There "
"are many ways of acquiring appropriate certificates, such as buying one from "
"a certification authority.  Another common practice is to generate a self-"
"signed certificate.  The simplest way to do this is with the OpenSSL "
"package, using something like the following::"
msgstr ""
"如果您要建立提供 SSL 加密連接服務的伺服器，則需要為該服務獲取證書。有許多方法"
"可以獲得適當的證書，例如從證書頒發機構購買證書。另一種常見做法是生成自簽名證"
"書。最簡單的方法是使用 OpenSSL 包，使用如下內容："

#: ../../library/ssl.rst:2215
#, fuzzy
msgid ""
"The disadvantage of a self-signed certificate is that it is its own root "
"certificate, and no one else will have it in their cache of known (and "
"trusted) root certificates."
msgstr "自簽名證書的缺點是它是自己的根證書，其他人不會將它放在已知（和可信）根證書的"
"快取中。"

#: ../../library/ssl.rst:2221
msgid "Examples"
msgstr "範例"

#: ../../library/ssl.rst:2224
#, fuzzy
msgid "Testing for SSL support"
msgstr "測試 SSL 支援"

#: ../../library/ssl.rst:2226
#, fuzzy
msgid ""
"To test for the presence of SSL support in a Python installation, user code "
"should use the following idiom::"
msgstr "要測試 Python 安裝中是否存在 SSL 支援，使用者程式碼應使用以下習慣用法："

#: ../../library/ssl.rst:2237
#, fuzzy
msgid "Client-side operation"
msgstr "客戶端操作"

#: ../../library/ssl.rst:2239
#, fuzzy
msgid ""
"This example creates a SSL context with the recommended security settings "
"for client sockets, including automatic certificate verification::"
msgstr "此示例使用推薦的客戶端 socket 安全設定建立 SSL 上下文，包括自動證書驗證："

#: ../../library/ssl.rst:2244
#, fuzzy
msgid ""
"If you prefer to tune security settings yourself, you might create a context "
"from scratch (but beware that you might not get the settings right)::"
msgstr "如果你更喜歡自己調整安全設定，你可以從頭開始建立一個上下文（但要注意你可能無"
"法正確設定）::"

#: ../../library/ssl.rst:2251
#, fuzzy
msgid ""
"(this snippet assumes your operating system places a bundle of all CA "
"certificates in ``/etc/ssl/certs/ca-bundle.crt``; if not, you'll get an "
"error and have to adjust the location)"
msgstr ""
"（此片段假定您的操作系統將所有 CA 證書捆綁在“/etc/ssl/certs/ca-bundle."
"crt”中；否則，您將收到錯誤消息並必須調整位置）"

#: ../../library/ssl.rst:2255
#, fuzzy
msgid ""
"The :data:`PROTOCOL_TLS_CLIENT` protocol configures the context for cert "
"validation and hostname verification. :attr:`~SSLContext.verify_mode` is set "
"to :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` is set to "
"``True``. All other protocols create SSL contexts with insecure defaults."
msgstr ""
":data:`PROTOCOL_TLS_CLIENT` 協定配置證書驗證和主機名驗證的上下文。 "
":attr:`~SSLContext.verify_mode` 設定為 :data:`CERT_REQUIRED` 並且 "
":attr:`~SSLContext.check_hostname` 設定為 ``True``。"
"所有其他協定都使用不安全的預設值建立 SSL 上下文。"

#: ../../library/ssl.rst:2260
#, fuzzy
msgid ""
"When you use the context to connect to a server, :const:`CERT_REQUIRED` and :"
"attr:`~SSLContext.check_hostname` validate the server certificate: it "
"ensures that the server certificate was signed with one of the CA "
"certificates, checks the signature for correctness, and verifies other "
"properties like validity and identity of the hostname::"
msgstr ""
"當您使用上下文連接到伺服器時，:const:`CERT_REQUIRED` 和 :attr:`~SSLContext."
"check_hostname` 驗證伺服器證書：它確保伺服器證書是使用其中一個 CA "
"證書籤署的，檢查簽名為了正確性，並驗證其他屬性，如主機名的有效性和身份::"

#: ../../library/ssl.rst:2270
#, fuzzy
msgid "You may then fetch the certificate::"
msgstr "然後您可以獲取證書::"

#: ../../library/ssl.rst:2274
#, fuzzy
msgid ""
"Visual inspection shows that the certificate does identify the desired "
"service (that is, the HTTPS host ``www.python.org``)::"
msgstr "目視檢查顯示證書確實標識了所需的服務（即 HTTPS 主機 ``www.python.org``）::"

#: ../../library/ssl.rst:2317
#, fuzzy
msgid ""
"Now the SSL channel is established and the certificate verified, you can "
"proceed to talk with the server::"
msgstr "現在 SSL 通道已建立並驗證了證書，您可以繼續與伺服器對話："

#: ../../library/ssl.rst:2344
#, fuzzy
msgid "Server-side operation"
msgstr "伺服器端操作"

#: ../../library/ssl.rst:2346
#, fuzzy
msgid ""
"For server operation, typically you'll need to have a server certificate, "
"and private key, each in a file.  You'll first create a context holding the "
"key and the certificate, so that clients can check your authenticity.  Then "
"you'll open a socket, bind it to a port, call :meth:`listen` on it, and "
"start waiting for clients to connect::"
msgstr ""
"對於伺服器操作，通常您需要有一個伺服器證書和私鑰，每個都在一個文件中。您將首"
"先建立一個包含密鑰和證書的上下文，以便客戶端可以檢查您的真實性。然後您將打開"
"一個 socket ，將其綁定到一個端口，對其呼叫 "
":meth:`listen`，然後開始等待客戶端連接::"

#: ../../library/ssl.rst:2361
#, fuzzy
msgid ""
"When a client connects, you'll call :meth:`accept` on the socket to get the "
"new socket from the other end, and use the context's :meth:`SSLContext."
"wrap_socket` method to create a server-side SSL socket for the connection::"
msgstr ""
"當客戶端連接時，您將在 socket 上呼叫 :meth:`accept` 以從另一端獲取新 socket ，"
"並使用上下文的 :meth:`SSLContext.wrap_socket` 方法為建立伺服器端 SSL "
" socket 連接：："

#: ../../library/ssl.rst:2374
#, fuzzy
msgid ""
"Then you'll read data from the ``connstream`` and do something with it till "
"you are finished with the client (or the client is finished with you)::"
msgstr "然後你將從``connstream``讀取資料並用它做一些事情直到你完成客戶端（或者客戶端"
"完成你）::"

#: ../../library/ssl.rst:2388
#, fuzzy
msgid ""
"And go back to listening for new client connections (of course, a real "
"server would probably handle each client connection in a separate thread, or "
"put the sockets in :ref:`non-blocking mode <ssl-nonblocking>` and use an "
"event loop)."
msgstr ""
"並回傳監聽新的客戶端連接（當然，真實的伺服器可能會在單獨的執行緒中處理每個客"
"戶端連接，或者將 socket 置於 :ref:`non-blocking mode <ssl-nonblocking>` "
"並使用事件環形）。"

#: ../../library/ssl.rst:2396
#, fuzzy
msgid "Notes on non-blocking sockets"
msgstr "非阻塞 socket 注意事項"

#: ../../library/ssl.rst:2398
#, fuzzy
msgid ""
"SSL sockets behave slightly different than regular sockets in non-blocking "
"mode. When working with non-blocking sockets, there are thus several things "
"you need to be aware of:"
msgstr "SSL  socket 在非阻塞模式下的行為與常規 socket 略有不同。使用非阻塞 socket 時，您需"
"要注意以下幾點："

#: ../../library/ssl.rst:2402
#, fuzzy
msgid ""
"Most :class:`SSLSocket` methods will raise either :exc:`SSLWantWriteError` "
"or :exc:`SSLWantReadError` instead of :exc:`BlockingIOError` if an I/O "
"operation would block. :exc:`SSLWantReadError` will be raised if a read "
"operation on the underlying socket is necessary, and :exc:"
"`SSLWantWriteError` for a write operation on the underlying socket. Note "
"that attempts to *write* to an SSL socket may require *reading* from the "
"underlying socket first, and attempts to *read* from the SSL socket may "
"require a prior *write* to the underlying socket."
msgstr ""
"大多數 :class:`SSLSocket` 方法將引發 :exc:`SSLWantWriteError` 或 "
":exc:`SSLWantReadError` 而不是 :exc:`BlockingIOError` 如果 I/O "
"操作會阻塞。如果需要對底層 socket 進行讀操作，將引發 "
"SSLWantReadError，而對底層 socket 進行寫操作，將引發 "
"SSLWantWriteError。請注意，嘗試*寫入*到 SSL "
" socket 可能需要先從底層 socket *讀取*，而嘗試從 SSL "
" socket *讀取*可能需要先*寫入*到底層 socket 。"

#: ../../library/ssl.rst:2414
#, fuzzy
msgid ""
"In earlier Python versions, the :meth:`!SSLSocket.send` method returned zero "
"instead of raising :exc:`SSLWantWriteError` or :exc:`SSLWantReadError`."
msgstr ""
"在早期的 Python 版本中，:meth:`!SSLSocket.send` "
"方法回傳零而不是引發 :exc:`SSLWantWriteError` 或 :exc:`SSLWantReadError`。"

#: ../../library/ssl.rst:2418
#, fuzzy
msgid ""
"Calling :func:`~select.select` tells you that the OS-level socket can be "
"read from (or written to), but it does not imply that there is sufficient "
"data at the upper SSL layer.  For example, only part of an SSL frame might "
"have arrived.  Therefore, you must be ready to handle :meth:`SSLSocket.recv` "
"and :meth:`SSLSocket.send` failures, and retry after another call to :func:"
"`~select.select`."
msgstr ""
"呼叫 :func:`~select.select` 告訴您可以讀取（或寫入）操作系統級 socket ，"
"但這並不意味著在上層 SSL 層有足夠的資料。例如，可能只有部分 SSL "
"幀到達。因此，您必須準備好處理 :meth:`SSLSocket.recv` 和 :meth:`SSLSocket."
"send` 失敗，並在再次呼叫 :func:`~select.select` 後重試。"

#: ../../library/ssl.rst:2425
#, fuzzy
msgid ""
"Conversely, since the SSL layer has its own framing, a SSL socket may still "
"have data available for reading without :func:`~select.select` being aware "
"of it.  Therefore, you should first call :meth:`SSLSocket.recv` to drain any "
"potentially available data, and then only block on a :func:`~select.select` "
"call if still necessary."
msgstr ""
"相反，由於 SSL 層有自己的框架，SSL  socket 可能仍然有資料可供讀取，而 "
":func:`~select.select` 並不知道。因此，您應該首先呼叫 :meth:`SSLSocket.recv` "
"以耗盡任何可能可用的資料，然後僅在仍然需要時才阻塞 :func:`~select.select` "
"呼叫。"

#: ../../library/ssl.rst:2431
#, fuzzy
msgid ""
"(of course, similar provisions apply when using other primitives such as :"
"func:`~select.poll`, or those in the :mod:`selectors` module)"
msgstr "（當然，類似的規定適用於使用其他原語，例如 :func:`~select.poll` 或 "
":mod:`selectors` 模組中的原語）"

#: ../../library/ssl.rst:2434
#, fuzzy
msgid ""
"The SSL handshake itself will be non-blocking: the :meth:`SSLSocket."
"do_handshake` method has to be retried until it returns successfully.  Here "
"is a synopsis using :func:`~select.select` to wait for the socket's "
"readiness::"
msgstr ""
"SSL 握手本身將是非阻塞的：:meth:`SSLSocket.do_handshake` "
"方法必須重試，直到它成功回傳。這是一個使用 :func:`~select.select` "
"等待 socket 就緒的概要："

#: ../../library/ssl.rst:2450
#, fuzzy
msgid ""
"The :mod:`asyncio` module supports :ref:`non-blocking SSL sockets <ssl-"
"nonblocking>` and provides a higher level API. It polls for events using "
"the :mod:`selectors` module and handles :exc:`SSLWantWriteError`, :exc:"
"`SSLWantReadError` and :exc:`BlockingIOError` exceptions. It runs the SSL "
"handshake asynchronously as well."
msgstr ""
":mod:`asyncio` 模組支援 :ref:`非阻塞 SSL  socket  <ssl-nonblocking>` "
"並提供更高階別的 API。它使用 :mod:`selectors` 模組輪詢事件並處理 "
":exc:`SSLWantWriteError`、:exc:`SSLWantReadError` 和 :exc:`BlockingIOError` "
"例外。它還非同步運行 SSL 握手。"

#: ../../library/ssl.rst:2459
#, fuzzy
msgid "Memory BIO Support"
msgstr "記憶體 BIO 支援"

#: ../../library/ssl.rst:2463
#, fuzzy
msgid ""
"Ever since the SSL module was introduced in Python 2.6, the :class:"
"`SSLSocket` class has provided two related but distinct areas of "
"functionality:"
msgstr "自從在 Python 2.6 中引入 SSL 模組以來，SSLSocket "
"類提供了兩個相關但不同的功能領域："

#: ../../library/ssl.rst:2466
#, fuzzy
msgid "SSL protocol handling"
msgstr "SSL協定處理"

#: ../../library/ssl.rst:2467
#, fuzzy
msgid "Network IO"
msgstr "網絡輸入輸出"

#: ../../library/ssl.rst:2469
#, fuzzy
msgid ""
"The network IO API is identical to that provided by :class:`socket.socket`, "
"from which :class:`SSLSocket` also inherits. This allows an SSL socket to be "
"used as a drop-in replacement for a regular socket, making it very easy to "
"add SSL support to an existing application."
msgstr ""
"網絡 IO API 與 socket.socket 提供的 API 相同，SSLSocket 也繼承自後者。"
"這允許將 SSL  socket 用作常規 socket 的直接替代品，"
"從而非常容易地向現有應用程式新增 SSL 支援。"

#: ../../library/ssl.rst:2474
#, fuzzy
msgid ""
"Combining SSL protocol handling and network IO usually works well, but there "
"are some cases where it doesn't. An example is async IO frameworks that want "
"to use a different IO multiplexing model than the \"select/poll on a file "
"descriptor\" (readiness based) model that is assumed by :class:`socket."
"socket` and by the internal OpenSSL socket IO routines. This is mostly "
"relevant for platforms like Windows where this model is not efficient. For "
"this purpose, a reduced scope variant of :class:`SSLSocket` called :class:"
"`SSLObject` is provided."
msgstr ""
"結合 SSL 協定處理和網絡 IO 通常效果很好，但在某些情況下效果不佳。"
"一個例子是非同步 IO 框架，它希望使用與“選擇/輪詢文件描述器”（基於準備）"
"模型不同的 IO 多路復用模型，該模型由 socket.socket 和內部 OpenSSL  socket  IO "
"假定套路。這主要與此模型效率不高的 Windows 等平台相關。為此，"
"提供了一個縮小範圍的 SSLSocket 變體，稱為 SSLObject。"

#: ../../library/ssl.rst:2485
#, fuzzy
msgid ""
"A reduced-scope variant of :class:`SSLSocket` representing an SSL protocol "
"instance that does not contain any network IO methods. This class is "
"typically used by framework authors that want to implement asynchronous IO "
"for SSL through memory buffers."
msgstr ""
"SSLSocket 的縮減範圍變體，表示不包含任何網絡 IO 方法的 SSL 協定實例。"
"此類通常由希望通過記憶體緩衝區為 SSL 實作非同步 IO 的框架作者使用。"

#: ../../library/ssl.rst:2490
#, fuzzy
msgid ""
"This class implements an interface on top of a low-level SSL object as "
"implemented by OpenSSL. This object captures the state of an SSL connection "
"but does not provide any network IO itself. IO needs to be performed through "
"separate \"BIO\" objects which are OpenSSL's IO abstraction layer."
msgstr ""
"此類在由 OpenSSL 實作的低階 SSL 物件之上實作一個介面。該物件捕獲 SSL "
"連接的狀態，但本身不提供任何網絡 IO。 IO 需要通過單獨的 ``BIO``物件執行，"
"這些對像是 OpenSSL 的 IO 抽象層。"

#: ../../library/ssl.rst:2495
#, fuzzy
msgid ""
"This class has no public constructor.  An :class:`SSLObject` instance must "
"be created using the :meth:`~SSLContext.wrap_bio` method. This method will "
"create the :class:`SSLObject` instance and bind it to a pair of BIOs. The "
"*incoming* BIO is used to pass data from Python to the SSL protocol "
"instance, while the *outgoing* BIO is used to pass data the other way around."
msgstr ""
"此類沒有公開構造函式。 :class:`SSLObject` 實例必須使用 :meth:`~SSLContext."
"wrap_bio` 方法建立。此方法將建立 :class:`SSLObject` 實例並將其綁定到一對 "
"BIO。 *incoming* BIO 用於將資料從 Python 傳遞到 SSL 協定實例，而 *outgoing* "
"BIO 用於以相反的方式傳遞資料。"

#: ../../library/ssl.rst:2502
#, fuzzy
msgid "The following methods are available:"
msgstr "可以使用以下方法："

#: ../../library/ssl.rst:2504
msgid ":attr:`~SSLSocket.context`"
msgstr ":attr:`~SSLSocket.context`"

#: ../../library/ssl.rst:2505
msgid ":attr:`~SSLSocket.server_side`"
msgstr ":attr:`~SSLSocket.server_side`"

#: ../../library/ssl.rst:2506
msgid ":attr:`~SSLSocket.server_hostname`"
msgstr ":attr:`~SSLSocket.server_hostname`"

#: ../../library/ssl.rst:2507
msgid ":attr:`~SSLSocket.session`"
msgstr ":attr:`~SSLSocket.session`"

#: ../../library/ssl.rst:2508
msgid ":attr:`~SSLSocket.session_reused`"
msgstr ":attr:`~SSLSocket.session_reused`"

#: ../../library/ssl.rst:2509
msgid ":meth:`~SSLSocket.read`"
msgstr ":meth:`~SSLSocket.read`"

#: ../../library/ssl.rst:2510
msgid ":meth:`~SSLSocket.write`"
msgstr ":meth:`~SSLSocket.write`"

#: ../../library/ssl.rst:2511
msgid ":meth:`~SSLSocket.getpeercert`"
msgstr ":meth:`~SSLSocket.getpeercert`"

#: ../../library/ssl.rst:2512
msgid ":meth:`~SSLSocket.selected_alpn_protocol`"
msgstr ":meth:`~SSLSocket.selected_alpn_protocol`"

#: ../../library/ssl.rst:2513
msgid ":meth:`~SSLSocket.selected_npn_protocol`"
msgstr ":meth:`~SSLSocket.selected_npn_protocol`"

#: ../../library/ssl.rst:2514
msgid ":meth:`~SSLSocket.cipher`"
msgstr ":meth:`~SSLSocket.cipher`"

#: ../../library/ssl.rst:2515
msgid ":meth:`~SSLSocket.shared_ciphers`"
msgstr ":meth:`~SSLSocket.shared_ciphers`"

#: ../../library/ssl.rst:2516
msgid ":meth:`~SSLSocket.compression`"
msgstr ":meth:`~SSLSocket.compression`"

#: ../../library/ssl.rst:2517
msgid ":meth:`~SSLSocket.pending`"
msgstr ":meth:`~SSLSocket.pending`"

#: ../../library/ssl.rst:2518
msgid ":meth:`~SSLSocket.do_handshake`"
msgstr ":meth:`~SSLSocket.do_handshake`"

#: ../../library/ssl.rst:2519
msgid ":meth:`~SSLSocket.verify_client_post_handshake`"
msgstr ":meth:`~SSLSocket.verify_client_post_handshake`"

#: ../../library/ssl.rst:2520
msgid ":meth:`~SSLSocket.unwrap`"
msgstr ":meth:`~SSLSocket.unwrap`"

#: ../../library/ssl.rst:2521
msgid ":meth:`~SSLSocket.get_channel_binding`"
msgstr ":meth:`~SSLSocket.get_channel_binding`"

#: ../../library/ssl.rst:2522
msgid ":meth:`~SSLSocket.version`"
msgstr ":meth:`~SSLSocket.version`"

#: ../../library/ssl.rst:2524
#, fuzzy
msgid ""
"When compared to :class:`SSLSocket`, this object lacks the following "
"features:"
msgstr "與 :class:`SSLSocket` 相比，此物件缺少以下功能："

#: ../../library/ssl.rst:2527
#, fuzzy
msgid ""
"Any form of network IO; ``recv()`` and ``send()`` read and write only to the "
"underlying :class:`MemoryBIO` buffers."
msgstr "任何形式的網絡IO； ``recv()`` 和 ``send()`` 只讀寫底層的 MemoryBIO 緩衝區。"

#: ../../library/ssl.rst:2530
#, fuzzy
msgid ""
"There is no *do_handshake_on_connect* machinery. You must always manually "
"call :meth:`~SSLSocket.do_handshake` to start the handshake."
msgstr ""
"沒有 *do_handshake_on_connect* 機制。您必須始終手動呼叫 :meth:`~SSLSocket."
"do_handshake` 來啟動握手。"

#: ../../library/ssl.rst:2533
#, fuzzy
msgid ""
"There is no handling of *suppress_ragged_eofs*. All end-of-file conditions "
"that are in violation of the protocol are reported via the :exc:"
"`SSLEOFError` exception."
msgstr "沒有處理 *suppress_ragged_eofs*。所有違反協定的文件結束條件都通過 "
"SSLEOFError 例外報告。"

#: ../../library/ssl.rst:2537
#, fuzzy
msgid ""
"The method :meth:`~SSLSocket.unwrap` call does not return anything, unlike "
"for an SSL socket where it returns the underlying socket."
msgstr "方法 :meth:`~SSLSocket.unwrap` 呼叫不回傳任何內容，這與回傳底層 socket 的 SSL "
" socket 不同。"

#: ../../library/ssl.rst:2540
#, fuzzy
msgid ""
"The *server_name_callback* callback passed to :meth:`SSLContext."
"set_servername_callback` will get an :class:`SSLObject` instance instead of "
"a :class:`SSLSocket` instance as its first parameter."
msgstr ""
"傳遞給 :meth:`SSLContext.set_servername_callback` 的 *server_name_callback* "
"回呼將獲得一個 :class:`SSLObject` 實例而不是 :class:`SSLSocket` "
"實例作為其第一個參數。"

#: ../../library/ssl.rst:2544
#, fuzzy
msgid "Some notes related to the use of :class:`SSLObject`:"
msgstr "與使用 :class:`SSLObject` 相關的一些注意事項："

#: ../../library/ssl.rst:2546
#, fuzzy
msgid ""
"All IO on an :class:`SSLObject` is :ref:`non-blocking <ssl-nonblocking>`. "
"This means that for example :meth:`~SSLSocket.read` will raise an :exc:"
"`SSLWantReadError` if it needs more data than the incoming BIO has available."
msgstr ""
":class:`SSLObject` 上的所有 IO 都是 :ref:`non-blocking <ssl-"
"nonblocking>`。這意味著，例如 :meth:`~SSLSocket.read` 將引發 "
":exc:`SSLWantReadError` 如果它需要比傳入 BIO 可用的資料更多的資料。"

#: ../../library/ssl.rst:2551
#, fuzzy
msgid ""
"There is no module-level ``wrap_bio()`` call like there is for :meth:"
"`~SSLContext.wrap_socket`. An :class:`SSLObject` is always created via an :"
"class:`SSLContext`."
msgstr ""
"沒有像 :meth:`~SSLContext.wrap_socket` 那樣的模組級 ``wrap_bio()`` 呼叫。 "
":class:`SSLObject` 總是通過 :class:`SSLContext` 建立。"

#: ../../library/ssl.rst:2555
#, fuzzy
msgid ""
":class:`SSLObject` instances must to created with :meth:`~SSLContext."
"wrap_bio`. In earlier versions, it was possible to create instances "
"directly. This was never documented or officially supported."
msgstr ""
":class:`SSLObject` 實例必須使用 :meth:`~SSLContext.wrap_bio` "
"建立。在早期版本中，可以直接建立實例。這從未被記錄或正式支援。"

#: ../../library/ssl.rst:2561
#, fuzzy
msgid ""
"An SSLObject communicates with the outside world using memory buffers. The "
"class :class:`MemoryBIO` provides a memory buffer that can be used for this "
"purpose.  It wraps an OpenSSL memory BIO (Basic IO) object:"
msgstr ""
"SSLObject 使用記憶體緩衝區與外界通信。類 :class:`MemoryBIO` "
"提供了可用於此目的的記憶體緩衝區。它包裝了一個 OpenSSL 記憶體 BIO（基本 "
"IO）物件："

#: ../../library/ssl.rst:2567
#, fuzzy
msgid ""
"A memory buffer that can be used to pass data between Python and an SSL "
"protocol instance."
msgstr "可用於在 Python 和 SSL 協定實例之間傳遞資料的記憶體緩衝區。"

#: ../../library/ssl.rst:2572
#, fuzzy
msgid "Return the number of bytes currently in the memory buffer."
msgstr "回傳記憶體緩衝區中當前的位元組數。"

#: ../../library/ssl.rst:2576
#, fuzzy
msgid ""
"A boolean indicating whether the memory BIO is current at the end-of-file "
"position."
msgstr "一個布爾值，指示記憶體 BIO 是否當前位於文件末尾位置。"

#: ../../library/ssl.rst:2581
#, fuzzy
msgid ""
"Read up to *n* bytes from the memory buffer. If *n* is not specified or "
"negative, all bytes are returned."
msgstr "從記憶體緩衝區中讀取最多 *n* 個位元組。如果 *n* "
"未指定或為負數，則回傳所有位元組。"

#: ../../library/ssl.rst:2586
#, fuzzy
msgid ""
"Write the bytes from *buf* to the memory BIO. The *buf* argument must be an "
"object supporting the buffer protocol."
msgstr "將 *buf* 中的位元組寫入記憶體 BIO。 *buf* 參數必須是支援緩衝協定的物件。"

#: ../../library/ssl.rst:2589
#, fuzzy
msgid ""
"The return value is the number of bytes written, which is always equal to "
"the length of *buf*."
msgstr "回傳值是寫入的位元組數，總是等於*buf*的長度。"

#: ../../library/ssl.rst:2594
#, fuzzy
msgid ""
"Write an EOF marker to the memory BIO. After this method has been called, it "
"is illegal to call :meth:`~MemoryBIO.write`. The attribute :attr:`eof` will "
"become true after all data currently in the buffer has been read."
msgstr ""
"將 EOF 標記寫入記憶體 BIO。呼叫此方法後，呼叫 :meth:`~MemoryBIO.write` "
"是非法的。在讀取緩衝區中當前的所有資料後，屬性 :attr:`eof` 將變為真。"

#: ../../library/ssl.rst:2600
#, fuzzy
msgid "SSL session"
msgstr "SSL會話"

#: ../../library/ssl.rst:2606
#, fuzzy
msgid "Session object used by :attr:`~SSLSocket.session`."
msgstr ":attr:`~SSLSocket.session` 使用的會話物件。"

#: ../../library/ssl.rst:2618
#, fuzzy
msgid "Security considerations"
msgstr "安全考慮"

#: ../../library/ssl.rst:2621
#, fuzzy
msgid "Best defaults"
msgstr "最佳預設值"

#: ../../library/ssl.rst:2623
#, fuzzy
msgid ""
"For **client use**, if you don't have any special requirements for your "
"security policy, it is highly recommended that you use the :func:"
"`create_default_context` function to create your SSL context. It will load "
"the system's trusted CA certificates, enable certificate validation and "
"hostname checking, and try to choose reasonably secure protocol and cipher "
"settings."
msgstr ""
"對於**客戶端使用**，如果您對安全策略沒有任何特殊要求，強烈建議您使用 :func:`cr"
"eate_default_context` 函式來建立您的 SSL 上下文。它將加載系統的可信 CA "
"證書，啟用證書驗證和主機名檢查，並嘗試選擇合理的安全協定和密碼設定。"

#: ../../library/ssl.rst:2630
#, fuzzy
msgid ""
"For example, here is how you would use the :class:`smtplib.SMTP` class to "
"create a trusted, secure connection to a SMTP server::"
msgstr "例如，下面是如何使用 :class:`smtplib.SMTP` 類建立到 SMTP "
"伺服器的可信、安全連接："

#: ../../library/ssl.rst:2639
#, fuzzy
msgid ""
"If a client certificate is needed for the connection, it can be added with :"
"meth:`SSLContext.load_cert_chain`."
msgstr "如果連接需要客戶端證書，可以使用 :meth:`SSLContext.load_cert_chain` 新增。"

#: ../../library/ssl.rst:2642
#, fuzzy
msgid ""
"By contrast, if you create the SSL context by calling the :class:"
"`SSLContext` constructor yourself, it will not have certificate validation "
"nor hostname checking enabled by default.  If you do so, please read the "
"paragraphs below to achieve a good security level."
msgstr ""
"相比之下，如果您通過自己呼叫 SSLContext 構造函式來建立 SSL 上下文，則預設情況"
"下不會啟用證書驗證或主機名檢查。如果您這樣做，請閱讀以下段落以獲得良好的安全"
"級別。"

#: ../../library/ssl.rst:2648
#, fuzzy
msgid "Manual settings"
msgstr "手動設定"

#: ../../library/ssl.rst:2651
#, fuzzy
msgid "Verifying certificates"
msgstr "驗證證書"

#: ../../library/ssl.rst:2653
#, fuzzy
msgid ""
"When calling the :class:`SSLContext` constructor directly, :const:"
"`CERT_NONE` is the default.  Since it does not authenticate the other peer, "
"it can be insecure, especially in client mode where most of time you would "
"like to ensure the authenticity of the server you're talking to. Therefore, "
"when in client mode, it is highly recommended to use :const:"
"`CERT_REQUIRED`.  However, it is in itself not sufficient; you also have to "
"check that the server certificate, which can be obtained by calling :meth:"
"`SSLSocket.getpeercert`, matches the desired service.  For many protocols "
"and applications, the service can be identified by the hostname; in this "
"case, the :func:`match_hostname` function can be used.  This common check is "
"automatically performed when :attr:`SSLContext.check_hostname` is enabled."
msgstr ""
"直接呼叫 :class:`SSLContext` 構造函式時，:const:`CERT_NONE` 是預設值。由於它"
"不對其他對等點進行身份驗證，因此它可能不安全，尤其是在客戶端模式下，在大多數"
"情況下您希望確保與您交談的伺服器的真實性。因此，在客戶端模式下，強烈建議使用 "
":const:`CERT_REQUIRED`。然而，這本身還不夠；您還必須檢查伺服器證書（"
"可以通過呼叫 :meth:`SSLSocket.getpeercert` 獲得）是否與所需服務匹配。對於許多"
"協定和應用程式，可以通過主機名來標識服務；在這種情況下，可以使用 :func:`match_"
"hostname` 函式。當啟用 :attr:`SSLContext.check_hostname` "
"時，會自動執行此常見檢查。"

#: ../../library/ssl.rst:2666
#, fuzzy
msgid ""
"Hostname matchings is now performed by OpenSSL. Python no longer uses :func:"
"`match_hostname`."
msgstr "主機名匹配現在由 OpenSSL 執行。 Python 不再使用 :func:`match_hostname`。"

#: ../../library/ssl.rst:2670
#, fuzzy
msgid ""
"In server mode, if you want to authenticate your clients using the SSL layer "
"(rather than using a higher-level authentication mechanism), you'll also "
"have to specify :const:`CERT_REQUIRED` and similarly check the client "
"certificate."
msgstr ""
"在伺服器模式下，如果您想使用 SSL "
"層（而不是使用更高階別的身份驗證機制）對您的客戶端進行身份驗證，您還必須指定 "
":const:`CERT_REQUIRED` 並類似地檢查客戶端證書。"

#: ../../library/ssl.rst:2676
#, fuzzy
msgid "Protocol versions"
msgstr "協定版本"

#: ../../library/ssl.rst:2678
#, fuzzy
msgid ""
"SSL versions 2 and 3 are considered insecure and are therefore dangerous to "
"use.  If you want maximum compatibility between clients and servers, it is "
"recommended to use :const:`PROTOCOL_TLS_CLIENT` or :const:"
"`PROTOCOL_TLS_SERVER` as the protocol version. SSLv2 and SSLv3 are disabled "
"by default."
msgstr ""
"SSL 版本 2 和 3 被認為是不安全的，因此使用起來很危險。如果你想要客戶端和服務"
"器之間的最大相容性，建議使用 :const:`PROTOCOL_TLS_CLIENT` 或 "
":const:`PROTOCOL_TLS_SERVER` 作為協定版本。預設情況下禁用 SSLv2 和 SSLv3。"

#: ../../library/ssl.rst:2691
#, fuzzy
msgid ""
"The SSL context created above will only allow TLSv1.2 and later (if "
"supported by your system) connections to a server. :const:"
"`PROTOCOL_TLS_CLIENT` implies certificate validation and hostname checks by "
"default. You have to load certificates into the context."
msgstr ""
"上面建立的 SSL 上下文將只允許 TLSv1.2 "
"和更高版本（如果您的系統支援）連接到伺服器。 :const:`PROTOCOL_TLS_CLIENT` "
"預設情況下表示證書驗證和主機名檢查。您必須將證書加載到上下文中。"

#: ../../library/ssl.rst:2698
#, fuzzy
msgid "Cipher selection"
msgstr "密碼選擇"

#: ../../library/ssl.rst:2700
#, fuzzy
msgid ""
"If you have advanced security requirements, fine-tuning of the ciphers "
"enabled when negotiating a SSL session is possible through the :meth:"
"`SSLContext.set_ciphers` method.  Starting from Python 3.2.3, the ssl module "
"disables certain weak ciphers by default, but you may want to further "
"restrict the cipher choice. Be sure to read OpenSSL's documentation about "
"the `cipher list format <https://www.openssl.org/docs/man1.1.1/man1/ciphers."
"html#CIPHER-LIST-FORMAT>`_. If you want to check which ciphers are enabled "
"by a given cipher list, use :meth:`SSLContext.get_ciphers` or the ``openssl "
"ciphers`` command on your system."
msgstr ""
"如果您有高階安全要求，可以通過 :meth:`SSLContext.set_ciphers` 方法微調在協商 "
"SSL 會話時啟用的密碼。從 Python 3.2.3 開始，ssl "
"模組預設禁用某些弱密碼，但您可能希望進一步限制密碼選擇。請務必閱讀 OpenSSL "
"關於“密碼列表格式”的文檔 <https://www.openssl.org/docs/man1.1.1/man1/ciphers."
"html#CIPHER-LIST-FORMAT>`_。如果您想檢查給定密碼列表啟用了哪些密碼，"
"請在您的系統上使用 :meth:`SSLContext.get_ciphers` 或 ``openssl ciphers`` "
"命令。"

#: ../../library/ssl.rst:2711
#, fuzzy
msgid "Multi-processing"
msgstr "多重處理"

#: ../../library/ssl.rst:2713
#, fuzzy
msgid ""
"If using this module as part of a multi-processed application (using, for "
"example the :mod:`multiprocessing` or :mod:`concurrent.futures` modules), be "
"aware that OpenSSL's internal random number generator does not properly "
"handle forked processes.  Applications must change the PRNG state of the "
"parent process if they use any SSL feature with :func:`os.fork`.  Any "
"successful call of :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes` or :func:"
"`~ssl.RAND_pseudo_bytes` is sufficient."
msgstr ""
"如果將此模組用作多行程應用程式的一部分（例如使用 :mod:`multiprocessing` 或 "
":mod:`concurrent.futures` 模組），請注意 OpenSSL "
"的內部隨機數生成器無法正確處理分叉行程.如果應用程式將任何 SSL 功能與 os.fork "
"一起使用，則它們必須更改父行程的 PRNG 狀態。任何成功呼叫 :func:`~ssl."
"RAND_add`、:func:`~ssl.RAND_bytes` 或 :func:`~ssl.RAND_pseudo_bytes` "
"就足夠了。"

#: ../../library/ssl.rst:2725
msgid "TLS 1.3"
msgstr "TLS 1.3"

#: ../../library/ssl.rst:2729
#, fuzzy
msgid ""
"The TLS 1.3 protocol behaves slightly differently than previous version of "
"TLS/SSL. Some new TLS 1.3 features are not yet available."
msgstr "TLS 1.3 協定的行為與以前版本的 TLS/SSL 略有不同。一些新的 TLS 1.3 "
"功能尚不可用。"

#: ../../library/ssl.rst:2732
#, fuzzy
msgid ""
"TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and ChaCha20 "
"cipher suites are enabled by default.  The method :meth:`SSLContext."
"set_ciphers` cannot enable or disable any TLS 1.3 ciphers yet, but :meth:"
"`SSLContext.get_ciphers` returns them."
msgstr ""
"TLS 1.3 使用一組分離的密碼套件。預設情況下啟用所有 AES-GCM 和 ChaCha20 "
"密碼套件。方法 :meth:`SSLContext.set_ciphers` 還不能啟用或禁用任何 TLS 1.3 "
"密碼，但 :meth:`SSLContext.get_ciphers` 回傳它們。"

#: ../../library/ssl.rst:2736
#, fuzzy
msgid ""
"Session tickets are no longer sent as part of the initial handshake and are "
"handled differently.  :attr:`SSLSocket.session` and :class:`SSLSession` are "
"not compatible with TLS 1.3."
msgstr ""
"會話票證不再作為初始握手的一部分發送，並且處理方式不同。 :attr:`SSLSocket."
"session` 和 :class:`SSLSession` 與 TLS 1.3 不相容。"

#: ../../library/ssl.rst:2739
#, fuzzy
msgid ""
"Client-side certificates are also no longer verified during the initial "
"handshake.  A server can request a certificate at any time.  Clients process "
"certificate requests while they send or receive application data from the "
"server."
msgstr "在初始握手期間也不再驗證客戶端證書。伺服器可以隨時請求證書。客戶端在從伺服器"
"發送或接收應用程式資料時處理證書請求。"

#: ../../library/ssl.rst:2743
#, fuzzy
msgid ""
"TLS 1.3 features like early data, deferred TLS client cert request, "
"signature algorithm configuration, and rekeying are not supported yet."
msgstr "尚不支援早期資料、延遲的 TLS 客戶端證書請求、簽名演算法配置和重新加密等 TLS "
"1.3 功能。"

#: ../../library/ssl.rst:2750
#, fuzzy
msgid "Class :class:`socket.socket`"
msgstr "類 :class:`socket.socket`"

#: ../../library/ssl.rst:2750
#, fuzzy
msgid "Documentation of underlying :mod:`socket` class"
msgstr "底層 :mod:`socket` 類的文檔"

#: ../../library/ssl.rst:2753
#, fuzzy
msgid ""
"`SSL/TLS Strong Encryption: An Introduction <https://httpd.apache.org/docs/"
"trunk/en/ssl/ssl_intro.html>`_"
msgstr ""
"`SSL/TLS 強加密：簡介 <https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro."
"html>`_"

#: ../../library/ssl.rst:2753
#, fuzzy
msgid "Intro from the Apache HTTP Server documentation"
msgstr "來自 Apache HTTP Server 文檔的介紹"

#: ../../library/ssl.rst:2756
#, fuzzy
msgid ""
":rfc:`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <1422>`"
msgstr ":rfc:`RFC 1422：網際網路電子郵件隱私增強：第二部分：基於證書的密鑰管理 <1422>`"

#: ../../library/ssl.rst:2756
msgid "Steve Kent"
msgstr "Steve Kent"

#: ../../library/ssl.rst:2759
#, fuzzy
msgid ":rfc:`RFC 4086: Randomness Requirements for Security <4086>`"
msgstr ":rfc:`RFC 4086：安全性 <4086>` 的隨機性要求"

#: ../../library/ssl.rst:2759
msgid "Donald E., Jeffrey I. Schiller"
msgstr "Donald E., Jeffrey I. Schiller"

#: ../../library/ssl.rst:2762
#, fuzzy
msgid ""
":rfc:`RFC 5280: Internet X.509 Public Key Infrastructure Certificate and "
"Certificate Revocation List (CRL) Profile <5280>`"
msgstr ":rfc:`RFC 5280：網際網路 X.509 公鑰基礎設施證書和證書撤銷列表 (CRL) 配置文件 "
"<5280>`"

#: ../../library/ssl.rst:2762
msgid "D. Cooper"
msgstr "D. Cooper"

#: ../../library/ssl.rst:2765
#, fuzzy
msgid ""
":rfc:`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<5246>`"
msgstr ":rfc:`RFC 5246：傳輸層安全 (TLS) 協定版本 1.2 <5246>`"

#: ../../library/ssl.rst:2765
msgid "T. Dierks et. al."
msgstr "T. Dierks et. al."

#: ../../library/ssl.rst:2768
#, fuzzy
msgid ":rfc:`RFC 6066: Transport Layer Security (TLS) Extensions <6066>`"
msgstr ":rfc:`RFC 6066：傳輸層安全 (TLS) 擴充 <6066>`"

#: ../../library/ssl.rst:2768
msgid "D. Eastlake"
msgstr "D. Eastlake"

#: ../../library/ssl.rst:2771
#, fuzzy
msgid ""
"`IANA TLS: Transport Layer Security (TLS) Parameters <https://www.iana.org/"
"assignments/tls-parameters/tls-parameters.xml>`_"
msgstr ""
"`IANA TLS：傳輸層安全 (TLS) 參數 <https://www.iana.org/assignments/"
"tls-parameters/tls-parameters.xml>`_"

#: ../../library/ssl.rst:2771
msgid "IANA"
msgstr "IANA"

#: ../../library/ssl.rst:2774
#, fuzzy
msgid ""
":rfc:`RFC 7525: Recommendations for Secure Use of Transport Layer Security "
"(TLS) and Datagram Transport Layer Security (DTLS) <7525>`"
msgstr ":rfc:`RFC 7525：安全使用傳輸層安全 (TLS) 和資料報傳輸層安全 (DTLS) <7525> "
"的建議"

#: ../../library/ssl.rst:2774
msgid "IETF"
msgstr "IETF"

#: ../../library/ssl.rst:2776
#, fuzzy
msgid ""
"`Mozilla's Server Side TLS recommendations <https://wiki.mozilla.org/"
"Security/Server_Side_TLS>`_"
msgstr ""
"`Mozilla 的伺服器端 TLS 建議 <https://wiki.mozilla.org/Security/"
"Server_Side_TLS>`_"

#: ../../library/ssl.rst:2777
msgid "Mozilla"
msgstr "Mozilla"
