# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-15 20:43+0000\n"
"PO-Revision-Date: 2018-05-23 14:41+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/contextlib.rst:2
#, fuzzy
msgid ""
":mod:`!contextlib` --- Utilities for :keyword:`!with`\\ -statement contexts"
msgstr ":mod:`!contextlib` --- :keyword:`!with` 陳述式情境的工具函式"

#: ../../library/contextlib.rst:7
msgid "**Source code:** :source:`Lib/contextlib.py`"
msgstr "**原始碼：**\\ :source:`Lib/contextlib.py`"

#: ../../library/contextlib.rst:11
#, fuzzy
msgid ""
"This module provides utilities for common tasks involving the :keyword:"
"`with` statement. For more information see also :ref:`typecontextmanager` "
"and :ref:`context-managers`."
msgstr ""
"此模組為涉及 :keyword:`with` 語句的常見任務提供實用程式。有關更多資訊，"
"另請參閱 :ref:`typecontextmanager` 和 :ref:`context-managers`。"

#: ../../library/contextlib.rst:17
#, fuzzy
msgid "Utilities"
msgstr "工具函式"

#: ../../library/contextlib.rst:19
msgid "Functions and classes provided:"
msgstr "提供的函式和類別："

#: ../../library/contextlib.rst:23
#, fuzzy
msgid ""
"An :term:`abstract base class` for classes that implement :meth:`object."
"__enter__` and :meth:`object.__exit__`. A default implementation for :meth:"
"`object.__enter__` is provided which returns ``self`` while :meth:`object."
"__exit__` is an abstract method which by default returns ``None``. See also "
"the definition of :ref:`typecontextmanager`."
msgstr ""
"實作 object.__enter__ 和 object.__exit__ 的類的抽象基底類別。提供了 "
"object.__enter__ 的預設實作，它回傳 self，而 object.__exit__ 是一個抽象方法，"
"預設回傳 None。另見 :ref:`typecontextmanager` 的定義。"

#: ../../library/contextlib.rst:34
#, fuzzy
msgid ""
"An :term:`abstract base class` for classes that implement :meth:`object."
"__aenter__` and :meth:`object.__aexit__`. A default implementation for :meth:"
"`object.__aenter__` is provided which returns ``self`` while :meth:`object."
"__aexit__` is an abstract method which by default returns ``None``. See also "
"the definition of :ref:`async-context-managers`."
msgstr ""
"實作 object.__aenter__ 和 object.__aexit__ 的類的抽象基底類別。提供了 "
"object.__aenter__ 的預設實作，它回傳 self，而 object.__aexit__ "
"是一個抽象方法，預設回傳 None。另請參閱 :ref:`async-context-managers` "
"的定義。"

#: ../../library/contextlib.rst:46
#, fuzzy
msgid ""
"This function is a :term:`decorator` that can be used to define a factory "
"function for :keyword:`with` statement context managers, without needing to "
"create a class or separate :meth:`__enter__` and :meth:`__exit__` methods."
msgstr ""
"此函式是一個裝飾器，可用於為關鍵字：with "
"語句情境管理器定義工廠函式，無需建立類或單獨的 :meth:`__enter__` "
"和 :meth:`__exit__ ` 方法。"

#: ../../library/contextlib.rst:50
#, fuzzy
msgid ""
"While many objects natively support use in with statements, sometimes a "
"resource needs to be managed that isn't a context manager in its own right, "
"and doesn't implement a ``close()`` method for use with ``contextlib."
"closing``"
msgstr ""
"雖然許多物件本機支援在 with "
"語句中使用，但有時需要管理的資源本身不是情境管理器，並且沒有實作與 "
"contextlib 一起使用的 close() 方法。關閉``"

#: ../../library/contextlib.rst:54
#, fuzzy
msgid ""
"An abstract example would be the following to ensure correct resource "
"management::"
msgstr "一個抽象示例如下，以確保正確的資源管理："

#: ../../library/contextlib.rst:69
#, fuzzy
msgid "The function can then be used like this::"
msgstr "然後可以像這樣使用該函式::"

#: ../../library/contextlib.rst:75
#, fuzzy
msgid ""
"The function being decorated must return a :term:`generator`-iterator when "
"called. This iterator must yield exactly one value, which will be bound to "
"the targets in the :keyword:`with` statement's :keyword:`!as` clause, if any."
msgstr ""
"被修飾的函式在被呼叫時必須回傳一個 "
":term:`generator`-iterator。此疊代器必須恰好產生一個值，該值將綁定到 "
":keyword:`with` 語句的 :keyword:`!as` 子句中的目標（如果有的話）。"

#: ../../library/contextlib.rst:79
#, fuzzy
msgid ""
"At the point where the generator yields, the block nested in the :keyword:"
"`with` statement is executed.  The generator is then resumed after the block "
"is exited. If an unhandled exception occurs in the block, it is reraised "
"inside the generator at the point where the yield occurred.  Thus, you can "
"use a :keyword:`try`...\\ :keyword:`except`...\\ :keyword:`finally` "
"statement to trap the error (if any), or ensure that some cleanup takes "
"place. If an exception is trapped merely in order to log it or to perform "
"some action (rather than to suppress it entirely), the generator must "
"reraise that exception. Otherwise the generator context manager will "
"indicate to the :keyword:`!with` statement that the exception has been "
"handled, and execution will resume with the statement immediately following "
"the :keyword:`!with` statement."
msgstr ""
"在生成器產生的地方，嵌套在 :keyword:`with` "
"語句中的塊被執行。然後在退出塊後恢復生成器。如果塊中發生未處理的例外，"
"它會在生成器內部在 yield 發生的地方重新引發。因此，您可以使用 "
":keyword:`try`...\\ :keyword:`except`...\\ :keyword:`finally` 語句來捕獲錯誤"
"（如果有），或確保進行一些清理。如果捕獲例外只是為了記錄它或執行某些操作（而"
"不是完全抑制它），則生成器必須重新引發該例外。否則，生成器情境管理器將向:ke"
"yword:`!with` 語句指示例外已被處理，並且將繼續執行緊跟在 :keyword:`!with` "
"語句之後的語句。"

#: ../../library/contextlib.rst:91
#, fuzzy
msgid ""
":func:`contextmanager` uses :class:`ContextDecorator` so the context "
"managers it creates can be used as decorators as well as in :keyword:`with` "
"statements. When used as a decorator, a new generator instance is implicitly "
"created on each function call (this allows the otherwise \"one-shot\" "
"context managers created by :func:`contextmanager` to meet the requirement "
"that context managers support multiple invocations in order to be used as "
"decorators)."
msgstr ""
":func:`contextmanager` 使用 :class:`ContextDecorator` "
"因此它建立的情境管理器可以用作裝飾器以及在 :keyword:`with` "
"語句中。當用作裝飾器時，在每次函式呼叫時都會隱式建立一個新的生成器實例（"
"這允許 contextmanager 建立的“一次性”情境管理器滿足情境管理器支援多次呼叫"
"的要求，以便用作裝飾器）。"

#: ../../library/contextlib.rst:98
#, fuzzy
msgid "Use of :class:`ContextDecorator`."
msgstr "使用 :class:`ContextDecorator`。"

#: ../../library/contextlib.rst:104
#, fuzzy
msgid ""
"Similar to :func:`~contextlib.contextmanager`, but creates an :ref:"
"`asynchronous context manager <async-context-managers>`."
msgstr ""
"類似於 :func:`~contextlib.contextmanager`，但建立了一個 :ref:`"
"非同步情境管理器 <async-context-managers>`。"

#: ../../library/contextlib.rst:107
#, fuzzy
msgid ""
"This function is a :term:`decorator` that can be used to define a factory "
"function for :keyword:`async with` statement asynchronous context managers, "
"without needing to create a class or separate :meth:`__aenter__` and :meth:"
"`__aexit__` methods. It must be applied to an :term:`asynchronous generator` "
"function."
msgstr ""
"此函式是一個裝飾器，可用於為 async with 語句非同步情境管理器定義工廠函式，"
"無需建立類或單獨的 __aenter__ 和 meth： `__aexit__` 方法。它必須應用於 "
":term:`asynchronous generator` 函式。"

#: ../../library/contextlib.rst:113
msgid "A simple example::"
msgstr ""
"一個簡單範例：\n"
"\n"
"::"

#: ../../library/contextlib.rst:131
#, fuzzy
msgid ""
"Context managers defined with :func:`asynccontextmanager` can be used either "
"as decorators or with :keyword:`async with` statements::"
msgstr ""
"用 :func:`asynccontextmanager` 定義的情境管理器可以用作裝飾器或與 :keyword:`"
"async with` 語句一起使用::"

#: ../../library/contextlib.rst:149
#, fuzzy
msgid ""
"When used as a decorator, a new generator instance is implicitly created on "
"each function call. This allows the otherwise \"one-shot\" context managers "
"created by :func:`asynccontextmanager` to meet the requirement that context "
"managers support multiple invocations in order to be used as decorators."
msgstr ""
"當用作裝飾器時，在每次函式呼叫時都會隱式建立一個新的生成器實例。這允許由 "
":func:`asynccontextmanager` 建立的其他“一次性”情境管理器滿足情境管理器支"
"援多次呼叫以便用作裝飾器的要求。"

#: ../../library/contextlib.rst:154
#, fuzzy
msgid ""
"Async context managers created with :func:`asynccontextmanager` can be used "
"as decorators."
msgstr "使用 :func:`asynccontextmanager` 建立的非同步情境管理器可以用作裝飾器。"

#: ../../library/contextlib.rst:161
#, fuzzy
msgid ""
"Return a context manager that closes *thing* upon completion of the block.  "
"This is basically equivalent to::"
msgstr "回傳一個情境管理器，在塊完成時關閉 *thing*。這基本上等同於："

#: ../../library/contextlib.rst:173
#, fuzzy
msgid "And lets you write code like this::"
msgstr "並讓您編寫這樣的程式碼::"

#: ../../library/contextlib.rst:182
#, fuzzy
msgid ""
"without needing to explicitly close ``page``.  Even if an error occurs, "
"``page.close()`` will be called when the :keyword:`with` block is exited."
msgstr "無需顯式關閉“頁面”。即使發生錯誤，當 :keyword:`with` 塊退出時，``page."
"close()`` 也會被呼叫。"

#: ../../library/contextlib.rst:188
#, fuzzy
msgid ""
"Return an async context manager that calls the ``aclose()`` method of "
"*thing* upon completion of the block.  This is basically equivalent to::"
msgstr "回傳一個非同步情境管理器，它在塊完成時呼叫 *thing* 的 ``aclose()`` "
"方法。這基本上等同於："

#: ../../library/contextlib.rst:200
#, fuzzy
msgid ""
"Significantly, ``aclosing()`` supports deterministic cleanup of async "
"generators when they happen to exit early by :keyword:`break` or an "
"exception.  For example::"
msgstr "值得注意的是，``aclosing()`` 支援非同步生成器碰巧因 break "
"或例外提前退出時的確定性清理。例如：："

#: ../../library/contextlib.rst:211
#, fuzzy
msgid ""
"This pattern ensures that the generator's async exit code is executed in the "
"same context as its iterations (so that exceptions and context variables "
"work as expected, and the exit code isn't run after the lifetime of some "
"task it depends on)."
msgstr ""
"此模式確保生成器的非同步退出程式碼在與其疊代相同的情境中執行（以便例外和上"
"下文變數按預期工作，並且退出程式碼不會在它所依賴的某些任務的生命週期之後運行"
"）。"

#: ../../library/contextlib.rst:223
#, fuzzy
msgid ""
"Return a context manager that returns *enter_result* from ``__enter__``, but "
"otherwise does nothing. It is intended to be used as a stand-in for an "
"optional context manager, for example::"
msgstr ""
"回傳一個情境管理器，它從 ``__enter__`` 回傳 *enter_result*，但除此之外什麼"
"都不做。它旨在用作可選情境管理器的替代品，例如："

#: ../../library/contextlib.rst:237
msgid "An example using *enter_result*::"
msgstr ""
"一個使用 *enter_result* 的範例：\n"
"\n"
"::"

#: ../../library/contextlib.rst:250
#, fuzzy
msgid ""
"It can also be used as a stand-in for :ref:`asynchronous context managers "
"<async-context-managers>`::"
msgstr "它也可以用作 :ref:`非同步情境管理器 <async-context-managers>`:: 的替代品"

#: ../../library/contextlib.rst:266
#, fuzzy
msgid ":term:`asynchronous context manager` support was added."
msgstr ":term: 新增了非同步情境管理器支援。"

#: ../../library/contextlib.rst:273
#, fuzzy
msgid ""
"Return a context manager that suppresses any of the specified exceptions if "
"they occur in the body of a :keyword:`!with` statement and then resumes "
"execution with the first statement following the end of the :keyword:`!with` "
"statement."
msgstr ""
"回傳一個情境管理器，如果指定的例外發生在 :keyword:`!with` "
"語句的主體中，它會抑制任何指定的例外，然後使用 :keyword:`!with` "
"語句結束後的第一條語句恢復執行。"

#: ../../library/contextlib.rst:278
#, fuzzy
msgid ""
"As with any other mechanism that completely suppresses exceptions, this "
"context manager should be used only to cover very specific errors where "
"silently continuing with program execution is known to be the right thing to "
"do."
msgstr "與任何其他完全抑制例外的機制一樣，這個情境管理器應該只用於覆蓋非常具體的錯"
"誤，在這些錯誤中，靜默地繼續執行程式被認為是正確的做法。"

#: ../../library/contextlib.rst:283
msgid "For example::"
msgstr ""
"舉例來說：\n"
"\n"
"::"

#: ../../library/contextlib.rst:293
#, fuzzy
msgid "This code is equivalent to::"
msgstr "此程式碼等效於：："

#: ../../library/contextlib.rst:305 ../../library/contextlib.rst:345
#: ../../library/contextlib.rst:355 ../../library/contextlib.rst:372
#, fuzzy
msgid "This context manager is :ref:`reentrant <reentrant-cms>`."
msgstr "這個情境管理器是 :ref:`reentrant <reentrant-cms>`。"

#: ../../library/contextlib.rst:312
#, fuzzy
msgid ""
"Context manager for temporarily redirecting :data:`sys.stdout` to another "
"file or file-like object."
msgstr "用於臨時將 sys.stdout 重定向到另一個文件或類似文件的物件的情境管理器。"

#: ../../library/contextlib.rst:315
#, fuzzy
msgid ""
"This tool adds flexibility to existing functions or classes whose output is "
"hardwired to stdout."
msgstr "該工具為輸出硬連線到標準輸出的現有函式或類增加了靈活性。"

#: ../../library/contextlib.rst:318
#, fuzzy
msgid ""
"For example, the output of :func:`help` normally is sent to *sys.stdout*. "
"You can capture that output in a string by redirecting the output to an :"
"class:`io.StringIO` object. The replacement stream is returned from the "
"``__enter__`` method and so is available as the target of the :keyword:"
"`with` statement::"
msgstr ""
"例如，:func:`help` 的輸出通常會發送到 *sys.stdout*。您可以通過將輸出重定向到 "
"io.StringIO 物件來捕獲字串中的輸出。替換流從 ``__enter__`` 方法回傳，"
"因此可用作 :keyword:`with` 語句的目標::"

#: ../../library/contextlib.rst:328
#, fuzzy
msgid ""
"To send the output of :func:`help` to a file on disk, redirect the output to "
"a regular file::"
msgstr "要將 :func:`help` 的輸出發送到磁盤上的文件，請將輸出重定向到常規文件::"

#: ../../library/contextlib.rst:335
#, fuzzy
msgid "To send the output of :func:`help` to *sys.stderr*::"
msgstr "將 :func:`help` 的輸出發送到 *sys.stderr*::"

#: ../../library/contextlib.rst:340
#, fuzzy
msgid ""
"Note that the global side effect on :data:`sys.stdout` means that this "
"context manager is not suitable for use in library code and most threaded "
"applications. It also has no effect on the output of subprocesses. However, "
"it is still a useful approach for many utility scripts."
msgstr ""
"請注意，對 :data:`sys.stdout` 的全局副作用意味著此情境管理器不適合在庫程式"
"碼和大多數執行緒應用程式中使用。它對子行程的輸出也沒有影響。但是，對於許多實"
"用程式腳本來說，它仍然是一種有用的方法。"

#: ../../library/contextlib.rst:352
#, fuzzy
msgid ""
"Similar to :func:`~contextlib.redirect_stdout` but redirecting :data:`sys."
"stderr` to another file or file-like object."
msgstr ""
"類似於 :func:`~contextlib.redirect_stdout` 但將 :data:`sys.stderr` "
"重定向到另一個文件或類文件物件。"

#: ../../library/contextlib.rst:362
#, fuzzy
msgid ""
"Non parallel-safe context manager to change the current working directory. "
"As this changes a global state, the working directory, it is not suitable "
"for use in most threaded or async contexts. It is also not suitable for most "
"non-linear code execution, like generators, where the program execution is "
"temporarily relinquished -- unless explicitly desired, you should not yield "
"when this context manager is active."
msgstr ""
"用於更改當前工作目錄的非並行安全情境管理器。由於這改變了全局狀態，工作目錄"
"，它不適合在大多數執行緒或非同步情境中使用。它也不適合大多數非線性程式碼執"
"行，如生成器，程式執行暫時放棄——除非明確需要，否則當此情境管理器處於活動狀"
"態時，您不應讓步。"

#: ../../library/contextlib.rst:369
#, fuzzy
msgid ""
"This is a simple wrapper around :func:`~os.chdir`, it changes the current "
"working directory upon entering and restores the old one on exit."
msgstr "這是 :func:`~os.chdir` "
"的簡單包裝器，它在進入時更改當前工作目錄並在退出時恢復舊目錄。"

#: ../../library/contextlib.rst:379
#, fuzzy
msgid ""
"A base class that enables a context manager to also be used as a decorator."
msgstr "使情境管理器也可用作裝飾器的基底類別。"

#: ../../library/contextlib.rst:381
#, fuzzy
msgid ""
"Context managers inheriting from ``ContextDecorator`` have to implement "
"``__enter__`` and ``__exit__`` as normal. ``__exit__`` retains its optional "
"exception handling even when used as a decorator."
msgstr ""
"繼承自 ``ContextDecorator`` 的情境管理器必須照常實作 ``__enter__`` 和 "
"``__exit__``。 ``__exit__`` 保留其可選的例外處理，即使用作裝飾器也是如此。"

#: ../../library/contextlib.rst:385
#, fuzzy
msgid ""
"``ContextDecorator`` is used by :func:`contextmanager`, so you get this "
"functionality automatically."
msgstr "``ContextDecorator`` 由 :func:`contextmanager` 使用，因此您會自動獲得此功能。"

#: ../../library/contextlib.rst:388
msgid "Example of ``ContextDecorator``::"
msgstr ""
"``ContextDecorator`` 範例：\n"
"\n"
"::"

#: ../../library/contextlib.rst:401 ../../library/contextlib.rst:473
#, fuzzy
msgid "The class can then be used like this::"
msgstr "然後可以像這樣使用該類::"

#: ../../library/contextlib.rst:419
#, fuzzy
msgid ""
"This change is just syntactic sugar for any construct of the following form::"
msgstr "此更改只是以下形式的任何構造的語法糖："

#: ../../library/contextlib.rst:425
#, fuzzy
msgid "``ContextDecorator`` lets you instead write::"
msgstr "``ContextDecorator`` 讓你改為寫："

#: ../../library/contextlib.rst:431
#, fuzzy
msgid ""
"It makes it clear that the ``cm`` applies to the whole function, rather than "
"just a piece of it (and saving an indentation level is nice, too)."
msgstr "它清楚地表明 ``cm`` "
"適用於整個函式，而不僅僅是它的一部分（並且保存縮進級別也很好）。"

#: ../../library/contextlib.rst:434
#, fuzzy
msgid ""
"Existing context managers that already have a base class can be extended by "
"using ``ContextDecorator`` as a mixin class::"
msgstr "現有的已經有基底類別的情境管理器可以通過使用 ``ContextDecorator`` "
"作為混合類來擴充："

#: ../../library/contextlib.rst:447
#, fuzzy
msgid ""
"As the decorated function must be able to be called multiple times, the "
"underlying context manager must support use in multiple :keyword:`with` "
"statements. If this is not the case, then the original construct with the "
"explicit :keyword:`!with` statement inside the function should be used."
msgstr ""
"由於裝飾函式必須能夠被多次呼叫，底層情境管理器必須支援在多個 :keyword:`with`"
" 語句中使用。如果不是這種情況，則應使用函式內帶有顯式 :keyword:`!with` "
"語句的原始構造。"

#: ../../library/contextlib.rst:457
#, fuzzy
msgid ""
"Similar to :class:`ContextDecorator` but only for asynchronous functions."
msgstr "類似於 :class:`ContextDecorator` 但僅適用於非同步函式。"

#: ../../library/contextlib.rst:459
msgid "Example of ``AsyncContextDecorator``::"
msgstr ""
"``AsyncContextDecorator`` 範例：\n"
"\n"
"::"

#: ../../library/contextlib.rst:498
#, fuzzy
msgid ""
"A context manager that is designed to make it easy to programmatically "
"combine other context managers and cleanup functions, especially those that "
"are optional or otherwise driven by input data."
msgstr "一個情境管理器，旨在以編程方式輕鬆組合其他情境管理器和清理功能，尤其是那"
"些可選的或由輸入資料驅動的功能。"

#: ../../library/contextlib.rst:502
#, fuzzy
msgid ""
"For example, a set of files may easily be handled in a single with statement "
"as follows::"
msgstr "例如，一組文件可以很容易地在單個 with 語句中處理，如下所示："

#: ../../library/contextlib.rst:511
#, fuzzy
msgid ""
"The :meth:`__enter__` method returns the :class:`ExitStack` instance, and "
"performs no additional operations."
msgstr ":meth:`__enter__` 方法回傳 :class:`ExitStack` 實例，並且不執行其他操作。"

#: ../../library/contextlib.rst:514
#, fuzzy
msgid ""
"Each instance maintains a stack of registered callbacks that are called in "
"reverse order when the instance is closed (either explicitly or implicitly "
"at the end of a :keyword:`with` statement). Note that callbacks are *not* "
"invoked implicitly when the context stack instance is garbage collected."
msgstr ""
"每個實例都維護一個已註冊的回呼堆疊，當實例關閉時，這些回呼以相反的順序呼叫（"
"在 :keyword:`with` 語句的末尾顯式或隱式呼叫）。請注意，當情境堆疊實例被垃圾"
"回收時，回呼*不會*被隱式呼叫。"

#: ../../library/contextlib.rst:519
#, fuzzy
msgid ""
"This stack model is used so that context managers that acquire their "
"resources in their ``__init__`` method (such as file objects) can be handled "
"correctly."
msgstr "使用此堆疊模型以便可以正確處理在其 ``__init__`` "
"方法（例如文件物件）中獲取其資源的情境管理器。"

#: ../../library/contextlib.rst:523
#, fuzzy
msgid ""
"Since registered callbacks are invoked in the reverse order of registration, "
"this ends up behaving as if multiple nested :keyword:`with` statements had "
"been used with the registered set of callbacks. This even extends to "
"exception handling - if an inner callback suppresses or replaces an "
"exception, then outer callbacks will be passed arguments based on that "
"updated state."
msgstr ""
"由於已註冊的回呼以與註冊相反的順序呼叫，這最終表現得就像多個嵌套的 "
":keyword:`with` 語句已與已註冊的回呼集一起使用。這甚至擴充到例外處理——如果內"
"部回呼抑製或替換例外，則外部回呼將根據更新後的狀態傳遞參數。"

#: ../../library/contextlib.rst:530
#, fuzzy
msgid ""
"This is a relatively low level API that takes care of the details of "
"correctly unwinding the stack of exit callbacks. It provides a suitable "
"foundation for higher level context managers that manipulate the exit stack "
"in application specific ways."
msgstr ""
"這是一個相對較低階別的 API，負責處理正確展開退出回呼堆疊的細節。它為更高階別"
"的情境管理器提供了一個合適的基礎，這些情境管理器以特定於應用程式的方式操"
"縱退出堆疊。"

#: ../../library/contextlib.rst:539
#, fuzzy
msgid ""
"Enters a new context manager and adds its :meth:`__exit__` method to the "
"callback stack. The return value is the result of the context manager's own :"
"meth:`__enter__` method."
msgstr ""
"進入一個新的情境管理器並將其 :meth:`__exit__` 方法新增到回呼堆疊。"
"回傳值是情境管理器自己的 :meth:`__enter__` 方法的結果。"

#: ../../library/contextlib.rst:543
#, fuzzy
msgid ""
"These context managers may suppress exceptions just as they normally would "
"if used directly as part of a :keyword:`with` statement."
msgstr "如果直接用作 :keyword:`with` "
"語句的一部分，這些情境管理器可能會像通常那樣抑制例外。"

#: ../../library/contextlib.rst:546
#, fuzzy
msgid ""
"Raises :exc:`TypeError` instead of :exc:`AttributeError` if *cm* is not a "
"context manager."
msgstr "如果 *cm* 不是情境管理器，則引發 :exc:`TypeError` 而不是 "
":exc:`AttributeError`。"

#: ../../library/contextlib.rst:552
#, fuzzy
msgid "Adds a context manager's :meth:`__exit__` method to the callback stack."
msgstr "將情境管理器的 :meth:`__exit__` 方法新增到回呼堆疊。"

#: ../../library/contextlib.rst:554
#, fuzzy
msgid ""
"As ``__enter__`` is *not* invoked, this method can be used to cover part of "
"an :meth:`__enter__` implementation with a context manager's own :meth:"
"`__exit__` method."
msgstr ""
"由於``__enter__`` *未* 被呼叫，此方法可用於使用情境管理器自己的 "
":meth:`__exit__` 方法覆蓋部分 :meth:`__enter__` 實作。"

#: ../../library/contextlib.rst:558
#, fuzzy
msgid ""
"If passed an object that is not a context manager, this method assumes it is "
"a callback with the same signature as a context manager's :meth:`__exit__` "
"method and adds it directly to the callback stack."
msgstr ""
"如果傳遞的對像不是情境管理器，則此方法假定它是一個與情境管理器的 "
":meth:`__exit__` 方法具有相同簽名的回呼，並將其直接新增到回呼堆疊中。"

#: ../../library/contextlib.rst:562
#, fuzzy
msgid ""
"By returning true values, these callbacks can suppress exceptions the same "
"way context manager :meth:`__exit__` methods can."
msgstr "通過回傳真值，這些回呼可以像情境管理器 :meth:`__exit__` 方法一樣抑制例外。"

#: ../../library/contextlib.rst:565
#, fuzzy
msgid ""
"The passed in object is returned from the function, allowing this method to "
"be used as a function decorator."
msgstr "傳入的對像從函式回傳，允許將此方法用作函式裝飾器。"

#: ../../library/contextlib.rst:570
#, fuzzy
msgid ""
"Accepts an arbitrary callback function and arguments and adds it to the "
"callback stack."
msgstr "接受任意回呼函式和參數並將其新增到回呼堆疊。"

#: ../../library/contextlib.rst:573
#, fuzzy
msgid ""
"Unlike the other methods, callbacks added this way cannot suppress "
"exceptions (as they are never passed the exception details)."
msgstr "與其他方法不同，以這種方式新增的回呼無法抑制例外（因為它們永遠不會傳遞例外詳"
"細資訊）。"

#: ../../library/contextlib.rst:576
#, fuzzy
msgid ""
"The passed in callback is returned from the function, allowing this method "
"to be used as a function decorator."
msgstr "傳入的回呼從函式回傳，允許將此方法用作函式裝飾器。"

#: ../../library/contextlib.rst:581
#, fuzzy
msgid ""
"Transfers the callback stack to a fresh :class:`ExitStack` instance and "
"returns it. No callbacks are invoked by this operation - instead, they will "
"now be invoked when the new stack is closed (either explicitly or implicitly "
"at the end of a :keyword:`with` statement)."
msgstr ""
"將回呼堆疊傳輸到新的 ExitStack 實例並回傳它。此操作不會呼叫任何回呼 - "
"相反，它們現在將在新堆疊關閉時呼叫（在 :keyword:`with` "
"語句的末尾顯式或隱式呼叫）。"

#: ../../library/contextlib.rst:586
#, fuzzy
msgid ""
"For example, a group of files can be opened as an \"all or nothing\" "
"operation as follows::"
msgstr "例如，一組文件可以作為“全有或全無”操作打開，如下所示："

#: ../../library/contextlib.rst:600
#, fuzzy
msgid ""
"Immediately unwinds the callback stack, invoking callbacks in the reverse "
"order of registration. For any context managers and exit callbacks "
"registered, the arguments passed in will indicate that no exception occurred."
msgstr "立即展開回呼堆疊，以與註冊相反的順序呼叫回呼。對於註冊的任何情境管理器和退"
"出回呼，傳入的參數將指示沒有發生例外。"

#: ../../library/contextlib.rst:607
#, fuzzy
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>`, similar to :"
"class:`ExitStack`, that supports combining both synchronous and asynchronous "
"context managers, as well as having coroutines for cleanup logic."
msgstr ""
"一個 :ref:`非同步情境管理器 <async-context-managers>`，類似於 :class:`Exi"
"tStack`，它支援同步和非同步情境管理器的組合，以及具有用於清理邏輯的協程。"

#: ../../library/contextlib.rst:612
#, fuzzy
msgid ""
"The :meth:`close` method is not implemented, :meth:`aclose` must be used "
"instead."
msgstr ":meth:`close` 方法未實作，必須使用 :meth:`aclose` 代替。"

#: ../../library/contextlib.rst:617
#, fuzzy
msgid ""
"Similar to :meth:`enter_context` but expects an asynchronous context manager."
msgstr "類似於 :meth:`enter_context` 但需要一個非同步情境管理器。"

#: ../../library/contextlib.rst:620
#, fuzzy
msgid ""
"Raises :exc:`TypeError` instead of :exc:`AttributeError` if *cm* is not an "
"asynchronous context manager."
msgstr "如果 *cm* 不是非同步情境管理器，則引發 :exc:`TypeError` 而不是 "
":exc:`AttributeError`。"

#: ../../library/contextlib.rst:626
#, fuzzy
msgid ""
"Similar to :meth:`push` but expects either an asynchronous context manager "
"or a coroutine function."
msgstr "類似於 :meth:`push` 但需要非同步情境管理器或協程函式。"

#: ../../library/contextlib.rst:631
#, fuzzy
msgid "Similar to :meth:`callback` but expects a coroutine function."
msgstr "類似於 :meth:`callback` 但需要協程函式。"

#: ../../library/contextlib.rst:635
#, fuzzy
msgid "Similar to :meth:`close` but properly handles awaitables."
msgstr "與 :meth:`close` 類似，但可以正確處理可等待物件。"

#: ../../library/contextlib.rst:637
#, fuzzy
msgid "Continuing the example for :func:`asynccontextmanager`::"
msgstr "繼續 :func:`asynccontextmanager`:: 的示例："

#: ../../library/contextlib.rst:649
#, fuzzy
msgid "Examples and Recipes"
msgstr "例子和食譜"

#: ../../library/contextlib.rst:651
#, fuzzy
msgid ""
"This section describes some examples and recipes for making effective use of "
"the tools provided by :mod:`contextlib`."
msgstr "本節介紹一些示例和方法，以有效使用 :mod:`contextlib` 提供的工具。"

#: ../../library/contextlib.rst:656
#, fuzzy
msgid "Supporting a variable number of context managers"
msgstr "支援可變數量的情境管理器"

#: ../../library/contextlib.rst:658
#, fuzzy
msgid ""
"The primary use case for :class:`ExitStack` is the one given in the class "
"documentation: supporting a variable number of context managers and other "
"cleanup operations in a single :keyword:`with` statement. The variability "
"may come from the number of context managers needed being driven by user "
"input (such as opening a user specified collection of files), or from some "
"of the context managers being optional::"
msgstr ""
":class:`ExitStack` 的主要用例是類文檔中給出的：在單個 :keyword:`with` 語句中支"
"援可變數量的情境管理器和其他清理操作。可變性可能來自需要由使用者輸入驅動的"
"情境管理器的數量（例如打開使用者指定的文件集合），或者來自某些情境管理器"
"是可選的::"

#: ../../library/contextlib.rst:673
#, fuzzy
msgid ""
"As shown, :class:`ExitStack` also makes it quite easy to use :keyword:`with` "
"statements to manage arbitrary resources that don't natively support the "
"context management protocol."
msgstr ""
"如圖所示，:class:`ExitStack` 還使使用 :keyword:`with` "
"語句來管理本身不支援情境管理協定的任意資源變得非常容易。"

#: ../../library/contextlib.rst:679
#, fuzzy
msgid "Catching exceptions from ``__enter__`` methods"
msgstr "從 ``__enter__`` 方法中捕獲例外"

#: ../../library/contextlib.rst:681
#, fuzzy
msgid ""
"It is occasionally desirable to catch exceptions from an ``__enter__`` "
"method implementation, *without* inadvertently catching exceptions from the :"
"keyword:`with` statement body or the context manager's ``__exit__`` method. "
"By using :class:`ExitStack` the steps in the context management protocol can "
"be separated slightly in order to allow this::"
msgstr ""
"偶爾需要從 ``__enter__`` 方法實作中捕獲例外，*不要*無意中從 :keyword:`with` "
"語句主體或情境管理器的 ``__exit__`` 方法中捕獲例外。通過使用 "
":class:`ExitStack` 情境管理協定中的步驟可以稍微分開，以允許這個::"

#: ../../library/contextlib.rst:696
#, fuzzy
msgid ""
"Actually needing to do this is likely to indicate that the underlying API "
"should be providing a direct resource management interface for use with :"
"keyword:`try`/:keyword:`except`/:keyword:`finally` statements, but not all "
"APIs are well designed in that regard. When a context manager is the only "
"resource management API provided, then :class:`ExitStack` can make it easier "
"to handle various situations that can't be handled directly in a :keyword:"
"`with` statement."
msgstr ""
"實際上需要這樣做可能表明底層 API 應該提供一個直接的資源管理介面以用於 "
":keyword:`try`/:keyword:`except`/:keyword:`finally` 語句，但不是所有 "
"API在這方面設計得很好。當情境管理器是唯一提供的資源管理 API 時，ExitStack "
"可以更輕鬆地處理不能直接在 :keyword:`with` 語句中處理的各種情況。"

#: ../../library/contextlib.rst:706
#, fuzzy
msgid "Cleaning up in an ``__enter__`` implementation"
msgstr "在 ``__enter__`` 實作中清理"

#: ../../library/contextlib.rst:708
#, fuzzy
msgid ""
"As noted in the documentation of :meth:`ExitStack.push`, this method can be "
"useful in cleaning up an already allocated resource if later steps in the :"
"meth:`__enter__` implementation fail."
msgstr ""
"如 :meth:`ExitStack.push` 的文檔中所述，如果 :meth:`__enter__` "
"實作中的後續步驟失敗，此方法可用於清理已分配的資源。"

#: ../../library/contextlib.rst:712
#, fuzzy
msgid ""
"Here's an example of doing this for a context manager that accepts resource "
"acquisition and release functions, along with an optional validation "
"function, and maps them to the context management protocol::"
msgstr "下面是一個接受資源獲取和釋放功能的情境管理器的示例，以及可選的驗證功能，並"
"將它們映射到情境管理協定："

#: ../../library/contextlib.rst:752
#, fuzzy
msgid "Replacing any use of ``try-finally`` and flag variables"
msgstr "替換對 ``try-finally`` 和旗標變數的任何使用"

#: ../../library/contextlib.rst:754
#, fuzzy
msgid ""
"A pattern you will sometimes see is a ``try-finally`` statement with a flag "
"variable to indicate whether or not the body of the ``finally`` clause "
"should be executed. In its simplest form (that can't already be handled just "
"by using an ``except`` clause instead), it looks something like this::"
msgstr ""
"您有時會看到的一種模式是帶有旗標變數的 ``try-finally`` 語句，"
"以指示是否應執行 ``finally`` 子句的主體。在最簡單的形式中（"
"已經不能僅僅通過使用 ``except`` 子句來處理），它看起來像這樣："

#: ../../library/contextlib.rst:768
#, fuzzy
msgid ""
"As with any ``try`` statement based code, this can cause problems for "
"development and review, because the setup code and the cleanup code can end "
"up being separated by arbitrarily long sections of code."
msgstr "與任何基於 ``try``語句的程式碼一樣，這可能會導致開發和審查問題，因為設定程式碼和"
"清理程式碼最終可能被任意長的程式碼段分開。"

#: ../../library/contextlib.rst:772
#, fuzzy
msgid ""
":class:`ExitStack` makes it possible to instead register a callback for "
"execution at the end of a ``with`` statement, and then later decide to skip "
"executing that callback::"
msgstr ":class:`ExitStack` 可以在 ``with`` "
"語句的末尾註冊一個執行回呼，然後決定跳過執行該回呼::"

#: ../../library/contextlib.rst:784
#, fuzzy
msgid ""
"This allows the intended cleanup up behaviour to be made explicit up front, "
"rather than requiring a separate flag variable."
msgstr "這允許預先明確預期的清理行為，而不需要單獨的旗標變數。"

#: ../../library/contextlib.rst:787
#, fuzzy
msgid ""
"If a particular application uses this pattern a lot, it can be simplified "
"even further by means of a small helper class::"
msgstr "如果一個特定的應用程式經常使用這種模式，它可以通過一個小的幫助類來進一步簡化"
"："

#: ../../library/contextlib.rst:805
#, fuzzy
msgid ""
"If the resource cleanup isn't already neatly bundled into a standalone "
"function, then it is still possible to use the decorator form of :meth:"
"`ExitStack.callback` to declare the resource cleanup in advance::"
msgstr "如果資源清理還沒有整齊地捆綁到一個獨立的函式中，那麼仍然可以使用 "
"ExitStack.callback 的裝飾器形式提前聲明資源清理::"

#: ../../library/contextlib.rst:820
#, fuzzy
msgid ""
"Due to the way the decorator protocol works, a callback function declared "
"this way cannot take any parameters. Instead, any resources to be released "
"must be accessed as closure variables."
msgstr "由於裝飾器協定的工作方式，以這種方式聲明的回呼函式不能接受任何參數。相反，任"
"何要釋放的資源都必須作為閉包變數訪問。"

#: ../../library/contextlib.rst:826
#, fuzzy
msgid "Using a context manager as a function decorator"
msgstr "使用情境管理器作為函式裝飾器"

#: ../../library/contextlib.rst:828
#, fuzzy
msgid ""
":class:`ContextDecorator` makes it possible to use a context manager in both "
"an ordinary ``with`` statement and also as a function decorator."
msgstr ":class:`ContextDecorator` 可以在普通的 ``with`` "
"語句和函式裝飾器中使用情境管理器。"

#: ../../library/contextlib.rst:831
#, fuzzy
msgid ""
"For example, it is sometimes useful to wrap functions or groups of "
"statements with a logger that can track the time of entry and time of exit.  "
"Rather than writing both a function decorator and a context manager for the "
"task, inheriting from :class:`ContextDecorator` provides both capabilities "
"in a single definition::"
msgstr ""
"例如，有時使用可以跟踪進入時間和退出時間的記錄器來包裝函式或語句組很有用。與"
"其為任務同時編寫函式裝飾器和情境管理器，不如繼承自 ContextDecorator "
"在單個定義中提供這兩種功能::"

#: ../../library/contextlib.rst:852
#, fuzzy
msgid "Instances of this class can be used as both a context manager::"
msgstr "此類的實例既可以用作情境管理器::"

#: ../../library/contextlib.rst:858
#, fuzzy
msgid "And also as a function decorator::"
msgstr "並且還作為函式裝飾器::"

#: ../../library/contextlib.rst:865
#, fuzzy
msgid ""
"Note that there is one additional limitation when using context managers as "
"function decorators: there's no way to access the return value of :meth:"
"`__enter__`. If that value is needed, then it is still necessary to use an "
"explicit ``with`` statement."
msgstr ""
"請注意，將情境管理器用作函式裝飾器時還有一個額外的限制：無法訪問 "
":meth:`__enter__` 的回傳值。如果需要該值，則仍然需要使用顯式的 ``with``語句。"

#: ../../library/contextlib.rst:873
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" 陳述式"

#: ../../library/contextlib.rst:873
#, fuzzy
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Python :keyword:`with` 語句的規範、背景和示例。"

#: ../../library/contextlib.rst:879
#, fuzzy
msgid "Single use, reusable and reentrant context managers"
msgstr "一次性使用、可重用和可重入情境管理器"

#: ../../library/contextlib.rst:881
#, fuzzy
msgid ""
"Most context managers are written in a way that means they can only be used "
"effectively in a :keyword:`with` statement once. These single use context "
"managers must be created afresh each time they're used - attempting to use "
"them a second time will trigger an exception or otherwise not work correctly."
msgstr ""
"大多數情境管理器的編寫方式意味著它們只能在 :keyword:`with` 語句中有效使用一"
"次。這些一次性情境管理器必須在每次使用時重新建立——嘗試再次使用它們將觸發例"
"外或無法正常工作。"

#: ../../library/contextlib.rst:887
#, fuzzy
msgid ""
"This common limitation means that it is generally advisable to create "
"context managers directly in the header of the :keyword:`with` statement "
"where they are used (as shown in all of the usage examples above)."
msgstr "這種常見的限制意味著通常建議直接在使用它們的 :keyword:`with` "
"語句的標頭中建立情境管理器（如上面所有使用示例所示）。"

#: ../../library/contextlib.rst:891
#, fuzzy
msgid ""
"Files are an example of effectively single use context managers, since the "
"first :keyword:`with` statement will close the file, preventing any further "
"IO operations using that file object."
msgstr ""
"文件是有效的一次性情境管理器的示例，因為第一個 :keyword:`with` "
"語句將關閉文件，防止使用該文件物件進行任何進一步的 IO 操作。"

#: ../../library/contextlib.rst:895
#, fuzzy
msgid ""
"Context managers created using :func:`contextmanager` are also single use "
"context managers, and will complain about the underlying generator failing "
"to yield if an attempt is made to use them a second time::"
msgstr ""
"使用 :func:`contextmanager` 建立的情境管理器也是一次性情境管理器，如果再"
"次嘗試使用它們，將會抱怨底層生成器未能產生："

#: ../../library/contextlib.rst:923
#, fuzzy
msgid "Reentrant context managers"
msgstr "可重入情境管理器"

#: ../../library/contextlib.rst:925
#, fuzzy
msgid ""
"More sophisticated context managers may be \"reentrant\". These context "
"managers can not only be used in multiple :keyword:`with` statements, but "
"may also be used *inside* a :keyword:`!with` statement that is already using "
"the same context manager."
msgstr ""
"更複雜的情境管理器可能是“可重入的”。這些情境管理器不僅可以在多個:keyword:"
"`with` 語句中使用，還可以*在*內部*一個 :keyword:`!with` "
"語句中使用，該語句已經使用相同的情境管理器。"

#: ../../library/contextlib.rst:930
#, fuzzy
msgid ""
":class:`threading.RLock` is an example of a reentrant context manager, as "
"are :func:`suppress`, :func:`redirect_stdout`, and :func:`chdir`. Here's a "
"very simple example of reentrant use::"
msgstr ""
":class:`threading.RLock` "
"是可重入情境管理器的示例，:func:`suppress`、:func:`redirect_stdout` 和 "
":func:`chdir` 也是。這是一個非常簡單的可重入使用示例::"

#: ../../library/contextlib.rst:949
#, fuzzy
msgid ""
"Real world examples of reentrancy are more likely to involve multiple "
"functions calling each other and hence be far more complicated than this "
"example."
msgstr "現實世界中的重入示例更有可能涉及多個函式相互呼叫，因此比這個示例複雜得多。"

#: ../../library/contextlib.rst:953
#, fuzzy
msgid ""
"Note also that being reentrant is *not* the same thing as being thread "
"safe. :func:`redirect_stdout`, for example, is definitely not thread safe, "
"as it makes a global modification to the system state by binding :data:`sys."
"stdout` to a different stream."
msgstr ""
"另請注意，可重入與執行緒安全*不*相同。例如，redirect_stdout "
"絕對不是執行緒安全的，因為它通過將 sys.stdout "
"綁定到不同的流來對系統狀態進行全局修改。"

#: ../../library/contextlib.rst:962
#, fuzzy
msgid "Reusable context managers"
msgstr "可重用情境管理器"

#: ../../library/contextlib.rst:964
#, fuzzy
msgid ""
"Distinct from both single use and reentrant context managers are \"reusable"
"\" context managers (or, to be completely explicit, \"reusable, but not "
"reentrant\" context managers, since reentrant context managers are also "
"reusable). These context managers support being used multiple times, but "
"will fail (or otherwise not work correctly) if the specific context manager "
"instance has already been used in a containing with statement."
msgstr ""
"與單次使用和可重入情境管理器不同的是“可重用”情境管理器（或者，完全明確地"
"說，“可重用但不可重入”情境管理器，因為可重入情境管理器也是可重用的）。這"
"些情境管理器支援多次使用，但如果特定情境管理器實例已在包含 with "
"語句中使用，則會失敗（或無法正常工作）。"

#: ../../library/contextlib.rst:971
#, fuzzy
msgid ""
":class:`threading.Lock` is an example of a reusable, but not reentrant, "
"context manager (for a reentrant lock, it is necessary to use :class:"
"`threading.RLock` instead)."
msgstr ""
":class:`threading.Lock` "
"是一個可重用但不可重入的情境管理器示例（對於可重入鎖，有必要改用 "
":class:`threading.RLock`）。"

#: ../../library/contextlib.rst:975
#, fuzzy
msgid ""
"Another example of a reusable, but not reentrant, context manager is :class:"
"`ExitStack`, as it invokes *all* currently registered callbacks when leaving "
"any with statement, regardless of where those callbacks were added::"
msgstr ""
"另一個可重用但不可重入的情境管理器示例是 ExitStack，因為它在離開任何 with "
"語句時呼叫*所有*當前註冊的回呼，而不管這些回呼新增到哪裡::"

#: ../../library/contextlib.rst:1006
#, fuzzy
msgid ""
"As the output from the example shows, reusing a single stack object across "
"multiple with statements works correctly, but attempting to nest them will "
"cause the stack to be cleared at the end of the innermost with statement, "
"which is unlikely to be desirable behaviour."
msgstr ""
"如示例的輸出所示，跨多個 with 語句重用單個堆疊物件可以正常工作，"
"但嘗試嵌套它們將導致堆疊在最內層 with "
"語句的末尾被清除，這不太可能是理想的行為。"

#: ../../library/contextlib.rst:1011
#, fuzzy
msgid ""
"Using separate :class:`ExitStack` instances instead of reusing a single "
"instance avoids that problem::"
msgstr "使用單獨的 ExitStack 實例而不是重複使用單個實例可以避免該問題::"
