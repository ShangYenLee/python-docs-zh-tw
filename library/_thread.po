# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-13 00:17+0000\n"
"PO-Revision-Date: 2015-12-09 17:51+0000\n"
"Last-Translator: Liang-Bo Wang <me@liang2.tw>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/_thread.rst:2
msgid ":mod:`_thread` --- Low-level threading API"
msgstr ":mod:`_thread` --- 低階執行緒 API"

#: ../../library/_thread.rst:15
#, fuzzy
msgid ""
"This module provides low-level primitives for working with multiple threads "
"(also called :dfn:`light-weight processes` or :dfn:`tasks`) --- multiple "
"threads of control sharing their global data space.  For synchronization, "
"simple locks (also called :dfn:`mutexes` or :dfn:`binary semaphores`) are "
"provided. The :mod:`threading` module provides an easier to use and higher-"
"level threading API built on top of this module."
msgstr ""
"該模組提供用於處理多個執行緒（也稱為 :dfn:`輕量級行程` 或 :dfn:`tasks`）"
"的低階原語 --- "
"多個控制執行緒共享它們的全局資料空間。對於同步，提供了簡單的鎖（也稱為 "
"mutexes 或 binary semaphores ）。 :mod:`threading` "
"模組提供了一個更易於使用且構建在該模組之上的更高階別的執行緒 API。"

#: ../../library/_thread.rst:26
#, fuzzy
msgid "This module used to be optional, it is now always available."
msgstr "這個模組以前是可選的，現在總是可用的。"

#: ../../library/_thread.rst:29
#, fuzzy
msgid "This module defines the following constants and functions:"
msgstr "該模組定義了以下常數和函式："

#: ../../library/_thread.rst:33
#, fuzzy
msgid "Raised on thread-specific errors."
msgstr "引發特定於執行緒的錯誤。"

#: ../../library/_thread.rst:35
#, fuzzy
msgid "This is now a synonym of the built-in :exc:`RuntimeError`."
msgstr "這現在是內建 :exc:`RuntimeError` 的同義詞。"

#: ../../library/_thread.rst:41
#, fuzzy
msgid "This is the type of lock objects."
msgstr "這是鎖定物件的型別。"

#: ../../library/_thread.rst:46
#, fuzzy
msgid ""
"Start a new thread and return its identifier.  The thread executes the "
"function *function* with the argument list *args* (which must be a tuple). "
"The optional *kwargs* argument specifies a dictionary of keyword arguments."
msgstr ""
"啟動一個新執行緒並回傳其標識符。執行緒使用參數列表 *args*（必須是元組）"
"執行函式 *function*。可選的 *kwargs* 參數指定關鍵字參數的字典。"

#: ../../library/_thread.rst:50
#, fuzzy
msgid "When the function returns, the thread silently exits."
msgstr "當函式回傳時，執行緒靜默退出。"

#: ../../library/_thread.rst:52
#, fuzzy
msgid ""
"When the function terminates with an unhandled exception, :func:`sys."
"unraisablehook` is called to handle the exception. The *object* attribute of "
"the hook argument is *function*. By default, a stack trace is printed and "
"then the thread exits (but other threads continue to run)."
msgstr ""
"當函式因未處理的例外而終止時，將呼叫 :func:`sys.unraisablehook` 來處理例外。"
"鉤子參數的 *object* 屬性是 *function*。預設情況下，印出堆疊跟踪，然後執行緒退"
"出（但其他執行緒繼續運行）。"

#: ../../library/_thread.rst:57
#, fuzzy
msgid ""
"When the function raises a :exc:`SystemExit` exception, it is silently "
"ignored."
msgstr "當函式引發 :exc:`SystemExit` 例外時，它會被靜默忽略。"

#: ../../library/_thread.rst:60
#, fuzzy
msgid ":func:`sys.unraisablehook` is now used to handle unhandled exceptions."
msgstr ":func:`sys.unraisablehook` 現在用於處理未處理的例外。"

#: ../../library/_thread.rst:66
#, fuzzy
msgid ""
"Simulate the effect of a signal arriving in the main thread. A thread can "
"use this function to interrupt the main thread, though there is no guarantee "
"that the interruption will happen immediately."
msgstr "模擬信號到達主執行緒的效果。執行緒可以使用此函式來中斷主執行緒，但不能保證中"
"斷會立即發生。"

#: ../../library/_thread.rst:70
#, fuzzy
msgid ""
"If given, *signum* is the number of the signal to simulate. If *signum* is "
"not given, :data:`signal.SIGINT` is simulated."
msgstr "如果給定，*signum* 是要模擬的信號的編號。如果未給出 "
"*signum*，則模擬 :data:`signal.SIGINT`。"

#: ../../library/_thread.rst:73
#, fuzzy
msgid ""
"If the given signal isn't handled by Python (it was set to :data:`signal."
"SIG_DFL` or :data:`signal.SIG_IGN`), this function does nothing."
msgstr ""
"如果給定的信號不是由 Python 處理的（它被設定為 :data:`signal.SIG_DFL` 或 "
":data:`signal.SIG_IGN`），這個函式什麼都不做。"

#: ../../library/_thread.rst:77
#, fuzzy
msgid "The *signum* argument is added to customize the signal number."
msgstr "新增 *signum* 參數以自定義信號編號。"

#: ../../library/_thread.rst:81
#, fuzzy
msgid ""
"This does not emit the corresponding signal but schedules a call to the "
"associated handler (if it exists). If you want to truly emit the signal, "
"use :func:`signal.raise_signal`."
msgstr ""
"這不會發出相應的信號，但會安排呼叫關聯的處理程式（如果存在）。如果您想真正發"
"出信號，請使用 :func:`signal.raise_signal`。"

#: ../../library/_thread.rst:88
#, fuzzy
msgid ""
"Raise the :exc:`SystemExit` exception.  When not caught, this will cause the "
"thread to exit silently."
msgstr "引發 :exc:`SystemExit` 例外。如果沒有被捕獲，這將導致執行緒靜默退出。"

#: ../../library/_thread.rst:102
#, fuzzy
msgid ""
"Return a new lock object.  Methods of locks are described below.  The lock "
"is initially unlocked."
msgstr "回傳一個新的鎖物件。下面介紹鎖的方法。鎖最初是解鎖的。"

#: ../../library/_thread.rst:108
#, fuzzy
msgid ""
"Return the 'thread identifier' of the current thread.  This is a nonzero "
"integer.  Its value has no direct meaning; it is intended as a magic cookie "
"to be used e.g. to index a dictionary of thread-specific data.  Thread "
"identifiers may be recycled when a thread exits and another thread is "
"created."
msgstr ""
"回傳當前執行緒的“執行緒標識符”。這是一個非零整數。它的值沒有直接意義；它的目"
"的是作為一個神奇的餅乾來使用，例如。索引執行緒特定資料的字典。當一個執行緒退"
"出並建立另一個執行緒時，執行緒標識符可能會被回收。"

#: ../../library/_thread.rst:116
#, fuzzy
msgid ""
"Return the native integral Thread ID of the current thread assigned by the "
"kernel. This is a non-negative integer. Its value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"回傳內核分配的當前執行緒的本機整數執行緒 ID。這是一個非負整數。它的值可用於在"
"系統範圍內唯一標識此特定執行緒（直到執行緒終止，之後該值可能會被操作系統回收"
"）。"

#: ../../library/_thread.rst:121
#, fuzzy
msgid ""
":ref:`Availability <availability>`: Windows, FreeBSD, Linux, macOS, OpenBSD, "
"NetBSD, AIX."
msgstr ":ref:`可用性 "
"<可用性>`：Windows、FreeBSD、Linux、macOS、OpenBSD、NetBSD、AIX。"

#: ../../library/_thread.rst:128
#, fuzzy
msgid ""
"Return the thread stack size used when creating new threads.  The optional "
"*size* argument specifies the stack size to be used for subsequently created "
"threads, and must be 0 (use platform or configured default) or a positive "
"integer value of at least 32,768 (32 KiB). If *size* is not specified, 0 is "
"used.  If changing the thread stack size is unsupported, a :exc:"
"`RuntimeError` is raised.  If the specified stack size is invalid, a :exc:"
"`ValueError` is raised and the stack size is unmodified.  32 KiB is "
"currently the minimum supported stack size value to guarantee sufficient "
"stack space for the interpreter itself.  Note that some platforms may have "
"particular restrictions on values for the stack size, such as requiring a "
"minimum stack size > 32 KiB or requiring allocation in multiples of the "
"system memory page size - platform documentation should be referred to for "
"more information (4 KiB pages are common; using multiples of 4096 for the "
"stack size is the suggested approach in the absence of more specific "
"information)."
msgstr ""
"回傳建立新執行緒時使用的執行緒堆疊大小。可選的 *size* "
"參數指定用於後續建立的執行緒的堆疊大小，並且必須為 "
"0（使用平台或配置的預設值）或至少為 32,768 (32 KiB) 的正整數值。如果未指定 "
"*size*，則使用 0。如果不支援更改執行緒堆疊大小，則會引發 "
":exc:`RuntimeError`。如果指定的堆疊大小無效，則會引發 :exc:`ValueError` "
"並且堆疊大小不變。 32 KiB 是當前支援的最小堆疊大小值，以保證直譯器本身有足夠"
"的堆疊空間。請注意，某些平台可能對堆疊大小的值有特殊限制，"
"例如要求最小堆疊大小 > 32 KiB 或要求分配系統記憶體頁面大小的倍數 - "
"應參考平台文檔以獲取更多資訊（4 KiB 頁面很常見；在沒有更具體資訊的情況下，"
"建議使用 4096 的倍數作為堆疊大小）。"

#: ../../library/_thread.rst:143
msgid ":ref:`Availability <availability>`: Windows, pthreads."
msgstr ":ref:`適用 <availability>`：Windows, pthreads。"

#: ../../library/_thread.rst:145
#, fuzzy
msgid "Unix platforms with POSIX threads support."
msgstr "支援 POSIX 執行緒的 Unix 平台。"

#: ../../library/_thread.rst:150
#, fuzzy
msgid ""
"The maximum value allowed for the *timeout* parameter of :meth:`Lock."
"acquire`. Specifying a timeout greater than this value will raise an :exc:"
"`OverflowError`."
msgstr "Lock.acquire 的 *timeout* 參數允許的最大值。指定大於此值的超時將引發 "
":exc:`OverflowError`。"

#: ../../library/_thread.rst:157
#, fuzzy
msgid "Lock objects have the following methods:"
msgstr "鎖對像有以下方法："

#: ../../library/_thread.rst:162
#, fuzzy
msgid ""
"Without any optional argument, this method acquires the lock "
"unconditionally, if necessary waiting until it is released by another thread "
"(only one thread at a time can acquire a lock --- that's their reason for "
"existence)."
msgstr "在沒有任何可選參數的情況下，此方法無條件地獲取鎖，如有必要，等待它被另一個執"
"行緒釋放（一次只有一個執行緒可以獲得鎖——這就是它們存在的原因）。"

#: ../../library/_thread.rst:166
#, fuzzy
msgid ""
"If the *blocking* argument is present, the action depends on its value: if "
"it is False, the lock is only acquired if it can be acquired immediately "
"without waiting, while if it is True, the lock is acquired unconditionally "
"as above."
msgstr ""
"如果存在 *blocking* 參數，則動作取決於其值：如果為 "
"False，則只有在無需等待即可立即獲取鎖的情況下才獲取鎖，如果為 "
"True，則如上無條件獲取鎖。"

#: ../../library/_thread.rst:171
#, fuzzy
msgid ""
"If the floating-point *timeout* argument is present and positive, it "
"specifies the maximum wait time in seconds before returning.  A negative "
"*timeout* argument specifies an unbounded wait.  You cannot specify a "
"*timeout* if *blocking* is False."
msgstr ""
"如果浮點 *timeout* "
"參數存在且為正，則它指定回傳前的最長等待時間（以秒為單位）。負 *timeout* "
"參數指定無限等待。如果 *blocking* 為 False，則不能指定 *timeout*。"

#: ../../library/_thread.rst:176
#, fuzzy
msgid ""
"The return value is ``True`` if the lock is acquired successfully, ``False`` "
"if not."
msgstr "如果成功獲取鎖，則回傳值為 ``True``，否則為 ``False``。"

#: ../../library/_thread.rst:179
#, fuzzy
msgid "The *timeout* parameter is new."
msgstr "*timeout* 參數是新的。"

#: ../../library/_thread.rst:182
#, fuzzy
msgid "Lock acquires can now be interrupted by signals on POSIX."
msgstr "鎖定獲取現在可以被 POSIX 上的信號中斷。"

#: ../../library/_thread.rst:188
#, fuzzy
msgid ""
"Releases the lock.  The lock must have been acquired earlier, but not "
"necessarily by the same thread."
msgstr "釋放鎖。鎖一定是早先獲得的，但不一定是同一個執行緒。"

#: ../../library/_thread.rst:194
#, fuzzy
msgid ""
"Return the status of the lock: ``True`` if it has been acquired by some "
"thread, ``False`` if not."
msgstr "回傳鎖的狀態：如果它已被某個執行緒獲取，則為 ``True``，否則為 ``False``。"

#: ../../library/_thread.rst:197
#, fuzzy
msgid ""
"In addition to these methods, lock objects can also be used via the :keyword:"
"`with` statement, e.g.::"
msgstr "除了這些方法之外，還可以通過 :keyword:`with` 語句使用鎖定物件，例如："

#: ../../library/_thread.rst:207
#, fuzzy
msgid "**Caveats:**"
msgstr "**注意事項：**"

#: ../../library/_thread.rst:211
#, fuzzy
msgid ""
"Threads interact strangely with interrupts: the :exc:`KeyboardInterrupt` "
"exception will be received by an arbitrary thread.  (When the :mod:`signal` "
"module is available, interrupts always go to the main thread.)"
msgstr ""
"執行緒與中斷進行奇怪的交互：:exc:`KeyboardInterrupt` 例外將被任意執行緒接收。"
" （當 :mod:`signal` 模組可用時，中斷總是轉到主執行緒。）"

#: ../../library/_thread.rst:215
#, fuzzy
msgid ""
"Calling :func:`sys.exit` or raising the :exc:`SystemExit` exception is "
"equivalent to calling :func:`_thread.exit`."
msgstr "呼叫 :func:`sys.exit` 或引發 :exc:`SystemExit` 例外等同於呼叫 :func:`_thread."
"exit`。"

#: ../../library/_thread.rst:218
#, fuzzy
msgid ""
"It is not possible to interrupt the :meth:`acquire` method on a lock --- "
"the :exc:`KeyboardInterrupt` exception will happen after the lock has been "
"acquired."
msgstr "無法中斷鎖上的 :meth:`acquire` 方法 --- 獲取鎖後會發生 "
":exc:`KeyboardInterrupt` 例外。"

#: ../../library/_thread.rst:221
#, fuzzy
msgid ""
"When the main thread exits, it is system defined whether the other threads "
"survive.  On most systems, they are killed without executing :keyword:"
"`try` ... :keyword:`finally` clauses or executing object destructors."
msgstr ""
"當主執行緒退出時，其他執行緒是否存活是系統定義的。在大多數係統上，"
"它們在不執行 :keyword:`try` ... :keyword:`finally` "
"子句或執行物件析構函式的情況下被殺死。"

#: ../../library/_thread.rst:226
#, fuzzy
msgid ""
"When the main thread exits, it does not do any of its usual cleanup (except "
"that :keyword:`try` ... :keyword:`finally` clauses are honored), and the "
"standard I/O files are not flushed."
msgstr ""
"當主執行緒退出時，它不會執行任何常規清理（除了 :keyword:`try` ... "
":keyword:`finally` 子句被接受），並且標準 I/O 文件不會被刷新。"
