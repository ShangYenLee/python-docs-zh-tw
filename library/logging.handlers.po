# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-31 08:13+0000\n"
"PO-Revision-Date: 2018-05-23 16:05+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/logging.handlers.rst:2
msgid ":mod:`logging.handlers` --- Logging handlers"
msgstr ":mod:`logging.handlers` --- 記錄處理程式"

#: ../../library/logging.handlers.rst:10
msgid "**Source code:** :source:`Lib/logging/handlers.py`"
msgstr "**原始碼：**\\ :source:`Lib/logging/handlers.py`"

#: ../../library/logging.handlers.rst:14
#, fuzzy
msgid ""
"This page contains only reference information. For tutorials, please see"
msgstr "此頁面僅包含參考資訊。有關教程，請參閱"

#: ../../library/logging.handlers.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`基礎教學 <logging-basic-tutorial>`"

#: ../../library/logging.handlers.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`進階教學 <logging-advanced-tutorial>`"

#: ../../library/logging.handlers.rst:19
#, fuzzy
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`Logging Cookbook <logging-cookbook>`"

#: ../../library/logging.handlers.rst:25
#, fuzzy
msgid ""
"The following useful handlers are provided in the package. Note that three "
"of the handlers (:class:`StreamHandler`, :class:`FileHandler` and :class:"
"`NullHandler`) are actually defined in the :mod:`logging` module itself, but "
"have been documented here along with the other handlers."
msgstr ""
"包中提供了以下有用的處理程式。請注意，其中三個處理程式（:class:`StreamHandler"
"`、:class:`FileHandler` 和 :class:`NullHandler`）實際上是在 :mod:`logging` "
"模組本身中定義的，但已在此處與其他處理程式。"

#: ../../library/logging.handlers.rst:33
msgid "StreamHandler"
msgstr "StreamHandler"

#: ../../library/logging.handlers.rst:35
#, fuzzy
msgid ""
"The :class:`StreamHandler` class, located in the core :mod:`logging` "
"package, sends logging output to streams such as *sys.stdout*, *sys.stderr* "
"or any file-like object (or, more precisely, any object which supports :meth:"
"`write` and :meth:`flush` methods)."
msgstr ""
":class:`StreamHandler` 類位於核心 :mod:`logging` 包中，將日誌輸出發送到流，"
"例如 *sys.stdout*、*sys.stderr* 或任何類似文件的物件（或者更準確地說， ，"
"任何支援 :meth:`write` 和 :meth:`flush` 方法的物件）。"

#: ../../library/logging.handlers.rst:43
#, fuzzy
msgid ""
"Returns a new instance of the :class:`StreamHandler` class. If *stream* is "
"specified, the instance will use it for logging output; otherwise, *sys."
"stderr* will be used."
msgstr ""
"回傳 :class:`StreamHandler` 類的新實例。如果指定了 "
"*stream*，實例將使用它來記錄輸出；否則，將使用 *sys.stderr*。"

#: ../../library/logging.handlers.rst:50
#, fuzzy
msgid ""
"If a formatter is specified, it is used to format the record. The record is "
"then written to the stream followed by :attr:`terminator`. If exception "
"information is present, it is formatted using :func:`traceback."
"print_exception` and appended to the stream."
msgstr ""
"如果指定了格式化程式，則使用它來格式化記錄。然後將記錄寫入流，後跟 "
":attr:`terminator`。如果存在例外資訊，則使用 :func:`traceback."
"print_exception` 對其進行格式化並附加到流中。"

#: ../../library/logging.handlers.rst:58
#, fuzzy
msgid ""
"Flushes the stream by calling its :meth:`flush` method. Note that the :meth:"
"`close` method is inherited from :class:`~logging.Handler` and so does no "
"output, so an explicit :meth:`flush` call may be needed at times."
msgstr ""
"通過呼叫其 :meth:`flush` 方法刷新流。請注意 :meth:`close` 方法是從 "
":class:`~logging.Handler` 繼承的，因此沒有輸出，因此有時可能需要顯式的 "
":meth:`flush` 呼叫。"

#: ../../library/logging.handlers.rst:64
#, fuzzy
msgid ""
"Sets the instance's stream to the specified value, if it is different. The "
"old stream is flushed before the new stream is set."
msgstr "將實例的流設定為指定值（如果不同）。在設定新流之前刷新舊流。"

#: ../../library/logging.handlers.rst:0
#, fuzzy
msgid "Parameters"
msgstr "參數"

#: ../../library/logging.handlers.rst:67
#, fuzzy
msgid "The stream that the handler should use."
msgstr "處理程式應使用的流。"

#: ../../library/logging.handlers.rst:0
#, fuzzy
msgid "Returns"
msgstr "退貨"

#: ../../library/logging.handlers.rst:69
#, fuzzy
msgid "the old stream, if the stream was changed, or *None* if it wasn't."
msgstr "舊流，如果流被更改，或者 *None* 如果沒有。"

#: ../../library/logging.handlers.rst:75
#, fuzzy
msgid ""
"String used as the terminator when writing a formatted record to a stream. "
"Default value is ``'\\n'``."
msgstr ""
"將格式化記錄寫入流時用作終止符的字串。預設值為 ``'\\n"
"'``。"

#: ../../library/logging.handlers.rst:78
#, fuzzy
msgid ""
"If you don't want a newline termination, you can set the handler instance's "
"``terminator`` attribute to the empty string."
msgstr "如果你不想換行終止，你可以將處理程式實例的 ``terminator`` 屬性設定為空字串。"

#: ../../library/logging.handlers.rst:81
#, fuzzy
msgid "In earlier versions, the terminator was hardcoded as ``'\\n'``."
msgstr ""
"在早期版本中，終止符被硬編碼為 ``'\\n"
"'``。"

#: ../../library/logging.handlers.rst:89
msgid "FileHandler"
msgstr "FileHandler"

#: ../../library/logging.handlers.rst:91
#, fuzzy
msgid ""
"The :class:`FileHandler` class, located in the core :mod:`logging` package, "
"sends logging output to a disk file.  It inherits the output functionality "
"from :class:`StreamHandler`."
msgstr ""
":class:`FileHandler` 類位於核心 :mod:`logging` "
"包中，將日誌輸出發送到磁盤文件。它繼承了 StreamHandler 的輸出功能。"

#: ../../library/logging.handlers.rst:98
#, fuzzy
msgid ""
"Returns a new instance of the :class:`FileHandler` class. The specified file "
"is opened and used as the stream for logging. If *mode* is not specified, :"
"const:`'a'` is used.  If *encoding* is not ``None``, it is used to open the "
"file with that encoding.  If *delay* is true, then file opening is deferred "
"until the first call to :meth:`emit`. By default, the file grows "
"indefinitely. If *errors* is specified, it's used to determine how encoding "
"errors are handled."
msgstr ""
"回傳 :class:`FileHandler` 類的新實例。指定的文件被打開並用作日誌流。"
"如果未指定 *mode*，則使用 :const:`'a'`。如果 *encoding* "
"不是``None``，它用於打開具有該編碼的文件。如果 *delay* 為真，"
"則文件打開將延遲到第一次呼叫 :meth:`emit` 時。預設情況下，文件會無限增長。"
"如果指定了 *errors*，它用於確定如何處理編碼錯誤。"

#: ../../library/logging.handlers.rst:105
#: ../../library/logging.handlers.rst:190
#: ../../library/logging.handlers.rst:338
#: ../../library/logging.handlers.rst:444
#, fuzzy
msgid ""
"As well as string values, :class:`~pathlib.Path` objects are also accepted "
"for the *filename* argument."
msgstr "除了字串值，*filename* 參數也接受 :class:`~pathlib.Path` 物件。"

#: ../../library/logging.handlers.rst:109
#: ../../library/logging.handlers.rst:194
#: ../../library/logging.handlers.rst:342
#: ../../library/logging.handlers.rst:448
msgid "The *errors* parameter was added."
msgstr "新增 *errors* 參數。"

#: ../../library/logging.handlers.rst:114
#, fuzzy
msgid "Closes the file."
msgstr "關閉文件。"

#: ../../library/logging.handlers.rst:118
#, fuzzy
msgid "Outputs the record to the file."
msgstr "將記錄輸出到文件。"

#: ../../library/logging.handlers.rst:120
#, fuzzy
msgid ""
"Note that if the file was closed due to logging shutdown at exit and the "
"file mode is 'w', the record will not be emitted (see :issue:`42378`)."
msgstr "請注意，如果文件由於在退出時關閉日誌記錄而關閉並且文件模式為 ``w``，則不會發出記"
"錄（請參閱 :issue:`42378`）。"

#: ../../library/logging.handlers.rst:127
msgid "NullHandler"
msgstr "NullHandler"

#: ../../library/logging.handlers.rst:131
#, fuzzy
msgid ""
"The :class:`NullHandler` class, located in the core :mod:`logging` package, "
"does not do any formatting or output. It is essentially a 'no-op' handler "
"for use by library developers."
msgstr ""
":class:`NullHandler` 類位於核心 :mod:`logging` 包中，不進行任何格式化或輸出。"
"它本質上是一個供庫開發人員使用的“無操作”處理程式。"

#: ../../library/logging.handlers.rst:137
#, fuzzy
msgid "Returns a new instance of the :class:`NullHandler` class."
msgstr "回傳 NullHandler 類的新實例。"

#: ../../library/logging.handlers.rst:141
#: ../../library/logging.handlers.rst:145
#, fuzzy
msgid "This method does nothing."
msgstr "這個方法什麼都不做。"

#: ../../library/logging.handlers.rst:149
#, fuzzy
msgid ""
"This method returns ``None`` for the lock, since there is no underlying I/O "
"to which access needs to be serialized."
msgstr "此方法為鎖回傳 ``None``，因為沒有需要序列化訪問的底層 I/O。"

#: ../../library/logging.handlers.rst:153
#, fuzzy
msgid ""
"See :ref:`library-config` for more information on how to use :class:"
"`NullHandler`."
msgstr "有關如何使用 NullHandler 的更多資訊，請參閱 :ref:`library-config`。"

#: ../../library/logging.handlers.rst:159
msgid "WatchedFileHandler"
msgstr "WatchedFileHandler"

#: ../../library/logging.handlers.rst:163
#, fuzzy
msgid ""
"The :class:`WatchedFileHandler` class, located in the :mod:`logging."
"handlers` module, is a :class:`FileHandler` which watches the file it is "
"logging to. If the file changes, it is closed and reopened using the file "
"name."
msgstr ""
":class:`WatchedFileHandler` 類位於 :mod:`logging.handlers` 模組中，是一個 :cl"
"ass:`FileHandler`，它監視正在記錄的文件。如果文件發生更改，將使用文件名將其關"
"閉並重新打開。"

#: ../../library/logging.handlers.rst:167
#, fuzzy
msgid ""
"A file change can happen because of usage of programs such as *newsyslog* "
"and *logrotate* which perform log file rotation. This handler, intended for "
"use under Unix/Linux, watches the file to see if it has changed since the "
"last emit. (A file is deemed to have changed if its device or inode have "
"changed.) If the file has changed, the old file stream is closed, and the "
"file opened to get a new stream."
msgstr ""
"由於使用 *newsyslog* 和 *logrotate* "
"等執行日誌文件輪換的程式，可能會發生文件更改。此處理程式旨在在 Unix/Linux "
"下使用，它監視文件以查看自上次發出以來它是否發生了變化。 （如果文件的設備或 "
"inode 已更改，則認為文件已更改。）如果文件已更改，則關閉舊文件流，並打開文件"
"以獲取新流。"

#: ../../library/logging.handlers.rst:174
#, fuzzy
msgid ""
"This handler is not appropriate for use under Windows, because under Windows "
"open log files cannot be moved or renamed - logging opens the files with "
"exclusive locks - and so there is no need for such a handler. Furthermore, "
"*ST_INO* is not supported under Windows; :func:`~os.stat` always returns "
"zero for this value."
msgstr ""
"此處理程式不適合在 Windows 下使用，因為在 Windows "
"下打開的日誌文件無法移動或重命名 - 日誌記錄使用獨占鎖打開文件 - "
"因此不需要這樣的處理程式。此外，*ST_INO* 在 Windows 下不受支援； :func:`~os."
"stat` 始終為此值回傳零。"

#: ../../library/logging.handlers.rst:183
#, fuzzy
msgid ""
"Returns a new instance of the :class:`WatchedFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, :const:`'a'` is used.  If *encoding* is not ``None``, it is "
"used to open the file with that encoding.  If *delay* is true, then file "
"opening is deferred until the first call to :meth:`emit`.  By default, the "
"file grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
"回傳 WatchedFileHandler 類的新實例。指定的文件被打開並用作日誌流。如果未指定 "
"*mode*，則使用 :const:`'a'`。如果 *encoding* "
"不是``None``，它用於打開具有該編碼的文件。如果 *delay* 為真，"
"則文件打開將延遲到第一次呼叫 :meth:`emit` 時。預設情況下，文件會無限增長。"
"如果提供了 *errors*，它決定瞭如何處理編碼錯誤。"

#: ../../library/logging.handlers.rst:199
#, fuzzy
msgid ""
"Checks to see if the file has changed.  If it has, the existing stream is "
"flushed and closed and the file opened again, typically as a precursor to "
"outputting the record to the file."
msgstr "檢查文件是否已更改。如果有，則刷新並關閉現有流並再次打開文件，通常作為將記錄"
"輸出到文件的前奏。"

#: ../../library/logging.handlers.rst:208
#, fuzzy
msgid ""
"Outputs the record to the file, but first calls :meth:`reopenIfNeeded` to "
"reopen the file if it has changed."
msgstr "將記錄輸出到文件，但如果文件已更改，則首先呼叫 reopenIfNeeded 重新打開文件。"

#: ../../library/logging.handlers.rst:214
msgid "BaseRotatingHandler"
msgstr "BaseRotatingHandler"

#: ../../library/logging.handlers.rst:216
#, fuzzy
msgid ""
"The :class:`BaseRotatingHandler` class, located in the :mod:`logging."
"handlers` module, is the base class for the rotating file handlers, :class:"
"`RotatingFileHandler` and :class:`TimedRotatingFileHandler`. You should not "
"need to instantiate this class, but it has attributes and methods you may "
"need to override."
msgstr ""
":class:`BaseRotatingHandler` 類位於 :mod:`logging.handlers` "
"模組中，是旋轉文件處理程式、:class:`RotatingFileHandler` 和 "
":class:`TimedRotatingFileHandler` "
"的基底類別。您不需要實例化此類，但它具有您可能需要重寫的屬性和方法。"

#: ../../library/logging.handlers.rst:224
#, fuzzy
msgid "The parameters are as for :class:`FileHandler`. The attributes are:"
msgstr "參數與 :class:`FileHandler` 相同。屬性是："

#: ../../library/logging.handlers.rst:228
#, fuzzy
msgid ""
"If this attribute is set to a callable, the :meth:`rotation_filename` method "
"delegates to this callable. The parameters passed to the callable are those "
"passed to :meth:`rotation_filename`."
msgstr ""
"如果此屬性設定為可呼叫物件，則 :meth:`rotation_filename` "
"方法委託給此可呼叫物件。傳遞給可呼叫的參數是傳遞給 :meth:`rotation_filename` "
"的參數。"

#: ../../library/logging.handlers.rst:232
#, fuzzy
msgid ""
"The namer function is called quite a few times during rollover, so it should "
"be as simple and as fast as possible. It should also return the same output "
"every time for a given input, otherwise the rollover behaviour may not work "
"as expected."
msgstr ""
"namer 函式在翻轉期間被呼叫了很多次，因此它應該盡可能簡單和快速。對於給定的輸"
"入，它還應該每次都回傳相同的輸出，否則翻轉行為可能無法按預期工作。"

#: ../../library/logging.handlers.rst:237
#, fuzzy
msgid ""
"It's also worth noting that care should be taken when using a namer to "
"preserve certain attributes in the filename which are used during rotation. "
"For example, :class:`RotatingFileHandler` expects to have a set of log files "
"whose names contain successive integers, so that rotation works as expected, "
"and :class:`TimedRotatingFileHandler` deletes old log files (based on the "
"``backupCount`` parameter passed to the handler's initializer) by "
"determining the oldest files to delete. For this to happen, the filenames "
"should be sortable using the date/time portion of the filename, and a namer "
"needs to respect this. (If a namer is wanted that doesn't respect this "
"scheme, it will need to be used in a subclass of :class:"
"`TimedRotatingFileHandler` which overrides the :meth:"
"`~TimedRotatingFileHandler.getFilesToDelete` method to fit in with the "
"custom naming scheme.)"
msgstr ""
"還值得注意的是，在使用命名器以保留文件名中的某些屬性時應小心，這些屬性在輪換"
"期間使用。例如，:class:`RotatingFileHandler` 期望有一組名稱包含連續整數的日誌"
"文件，以便輪換按預期工作，並且 :class:`TimedRotatingFileHandler` "
"刪除舊日誌文件（基於 ``backupCount``通過確定要刪除的最舊文件來傳遞給處理程式"
"的初始化程式的參數）。為此，文件名應該可以使用文件名的日期/時間部分進行排序，"
"命名者需要尊重這一點。 （如果需要不遵守此方案的命名器，則需要在 "
"TimedRotatingFileHandler 的子類別中使用它，該子類別會覆蓋 "
":meth:`~TimedRotatingFileHandler.getFilesToDelete` "
"方法以適應自定義命名方案。）"

#: ../../library/logging.handlers.rst:255
#, fuzzy
msgid ""
"If this attribute is set to a callable, the :meth:`rotate` method delegates "
"to this callable.  The parameters passed to the callable are those passed "
"to :meth:`rotate`."
msgstr ""
"如果此屬性設定為可呼叫物件，則 :meth:`rotate` 方法將委託給此可呼叫物件。"
"傳遞給可呼叫的參數是傳遞給 :meth:`rotate` 的參數。"

#: ../../library/logging.handlers.rst:263
#, fuzzy
msgid "Modify the filename of a log file when rotating."
msgstr "旋轉時修改日誌文件的文件名。"

#: ../../library/logging.handlers.rst:265
#, fuzzy
msgid "This is provided so that a custom filename can be provided."
msgstr "提供此文件是為了提供自定義文件名。"

#: ../../library/logging.handlers.rst:267
#, fuzzy
msgid ""
"The default implementation calls the 'namer' attribute of the handler, if "
"it's callable, passing the default name to it. If the attribute isn't "
"callable (the default is ``None``), the name is returned unchanged."
msgstr "預設實作呼叫處理程式的 ``namer``屬性，如果它是可呼叫的，則將預設名稱傳遞給它。如"
"果屬性不可呼叫（預設為 ``None`` ），則回傳名稱不變。"

#: ../../library/logging.handlers.rst:271
#, fuzzy
msgid "The default name for the log file."
msgstr "日誌文件的預設名稱。"

#: ../../library/logging.handlers.rst:278
#, fuzzy
msgid "When rotating, rotate the current log."
msgstr "旋轉時，旋轉當前日誌。"

#: ../../library/logging.handlers.rst:280
#, fuzzy
msgid ""
"The default implementation calls the 'rotator' attribute of the handler, if "
"it's callable, passing the source and dest arguments to it. If the attribute "
"isn't callable (the default is ``None``), the source is simply renamed to "
"the destination."
msgstr ""
"預設實作呼叫處理程式的 'rotator' 屬性，如果它是可呼叫的，則將 source 和 dest "
"參數傳遞給它。如果該屬性不可呼叫（預設為 ``None`` ），源將簡單地重命名為目標。"

#: ../../library/logging.handlers.rst:285
#, fuzzy
msgid ""
"The source filename. This is normally the base filename, e.g. 'test.log'."
msgstr "源文件名。這通常是基本文件名，例如'測試.log'。"

#: ../../library/logging.handlers.rst:287
#, fuzzy
msgid ""
"The destination filename. This is normally what the source is rotated to, e."
"g. 'test.log.1'."
msgstr "目標文件名。這通常是源旋轉到的位置，例如'測試.log.1'。"

#: ../../library/logging.handlers.rst:292
#, fuzzy
msgid ""
"The reason the attributes exist is to save you having to subclass - you can "
"use the same callables for instances of :class:`RotatingFileHandler` and :"
"class:`TimedRotatingFileHandler`. If either the namer or rotator callable "
"raises an exception, this will be handled in the same way as any other "
"exception during an :meth:`emit` call, i.e. via the :meth:`handleError` "
"method of the handler."
msgstr ""
"屬性存在的原因是為了避免您必須進行子類別化 - 您可以對 "
":class:`RotatingFileHandler` 和 :class:`TimedRotatingFileHandler` "
"的實例使用相同的可呼叫物件。如果 namer 或 rotator callable 引發例外，這將在 "
"emit 呼叫期間以與任何其他例外相同的方式處理，即通過處理程式的 handleError "
"方法。"

#: ../../library/logging.handlers.rst:299
#, fuzzy
msgid ""
"If you need to make more significant changes to rotation processing, you can "
"override the methods."
msgstr "如果您需要對旋轉處理進行更重要的更改，您可以覆蓋這些方法。"

#: ../../library/logging.handlers.rst:302
#, fuzzy
msgid "For an example, see :ref:`cookbook-rotator-namer`."
msgstr "有關示例，請參閱 :ref:`cookbook-rotator-namer`。"

#: ../../library/logging.handlers.rst:308
msgid "RotatingFileHandler"
msgstr "RotatingFileHandler"

#: ../../library/logging.handlers.rst:310
#, fuzzy
msgid ""
"The :class:`RotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files."
msgstr ""
":class:`RotatingFileHandler` 類位於 :mod:`logging.handlers` "
"模組中，支援磁盤日誌文件的輪換。"

#: ../../library/logging.handlers.rst:316
#, fuzzy
msgid ""
"Returns a new instance of the :class:`RotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, ``'a'`` is used.  If *encoding* is not ``None``, it is used "
"to open the file with that encoding.  If *delay* is true, then file opening "
"is deferred until the first call to :meth:`emit`.  By default, the file "
"grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
"回傳 :class:`RotatingFileHandler` 類的新實例。指定的文件被打開並用作日誌流。"
"如果未指定 *mode*，則使用 ``'a'``。如果 *encoding* "
"不是``None``，它用於打開具有該編碼的文件。如果 *delay* 為真，"
"則文件打開將延遲到第一次呼叫 :meth:`emit` 時。預設情況下，文件會無限增長。"
"如果提供了 *errors*，它決定瞭如何處理編碼錯誤。"

#: ../../library/logging.handlers.rst:323
#, fuzzy
msgid ""
"You can use the *maxBytes* and *backupCount* values to allow the file to :"
"dfn:`rollover` at a predetermined size. When the size is about to be "
"exceeded, the file is closed and a new file is silently opened for output. "
"Rollover occurs whenever the current log file is nearly *maxBytes* in "
"length; but if either of *maxBytes* or *backupCount* is zero, rollover never "
"occurs, so you generally want to set *backupCount* to at least 1, and have a "
"non-zero *maxBytes*. When *backupCount* is non-zero, the system will save "
"old log files by appending the extensions '.1', '.2' etc., to the filename. "
"For example, with a *backupCount* of 5 and a base file name of :file:`app."
"log`, you would get :file:`app.log`, :file:`app.log.1`, :file:`app.log.2`, "
"up to :file:`app.log.5`. The file being written to is always :file:`app."
"log`.  When this file is filled, it is closed and renamed to :file:`app."
"log.1`, and if files :file:`app.log.1`, :file:`app.log.2`, etc. exist, then "
"they are renamed to :file:`app.log.2`, :file:`app.log.3` etc. respectively."
msgstr ""
"您可以使用 *maxBytes* 和 *backupCount* 值來允許文件以預先確定的大小 "
":dfn:`rollover`。當即將超過大小時，關閉文件並靜默打開一個新文件進行輸出。"
"只要當前日誌文件的長度接近 *maxBytes*，就會發生翻轉；但是如果 *maxBytes* 或 "
"*backupCount* 中的任何一個為零，則不會發生翻轉，因此您通常希望將 "
"*backupCount* 設定為至少 1，並且 *maxBytes* 不為零。當 *backupCount* "
"不為零時，系統將通過將擴充名“.1”、“."
"2”等附加到文件名來保存舊日誌文件。例如，*backupCount* 為 5 且基本文件名為 "
":file:`app.log`，您將得到 :file:`app.log`、:file:`app.log.1`、:file :`app.log"
".2`，最多 :file:`app.log.5`。寫入的文件始終是 :file:`app."
"log`。當這個文件被填滿時，它被關閉並重命名為 :file:`app.log."
"1`，如果文件是 :file:`app.log.1`、:file:`app.log.2` 等。存在，則分別重命名為 "
":file:`app.log.2`、:file:`app.log.3` 等。"

#: ../../library/logging.handlers.rst:347
#: ../../library/logging.handlers.rst:453
#, fuzzy
msgid "Does a rollover, as described above."
msgstr "如上所述進行翻轉。"

#: ../../library/logging.handlers.rst:352
#, fuzzy
msgid ""
"Outputs the record to the file, catering for rollover as described "
"previously."
msgstr "將記錄輸出到文件，以適應如前所述的翻轉。"

#: ../../library/logging.handlers.rst:358
msgid "TimedRotatingFileHandler"
msgstr "TimedRotatingFileHandler"

#: ../../library/logging.handlers.rst:360
#, fuzzy
msgid ""
"The :class:`TimedRotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files at certain timed "
"intervals."
msgstr ""
":class:`TimedRotatingFileHandler` 類位於 :mod:`logging.handlers` "
"模組中，支援按特定時間間隔輪換磁盤日誌文件。"

#: ../../library/logging.handlers.rst:367
#, fuzzy
msgid ""
"Returns a new instance of the :class:`TimedRotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. On rotating it "
"also sets the filename suffix. Rotating happens based on the product of "
"*when* and *interval*."
msgstr ""
"回傳 TimedRotatingFileHandler 類的新實例。指定的文件被打開並用作日誌流。在旋"
"轉時，它還會設定文件名後綴。旋轉基於*when* 和*interval* 的乘積。"

#: ../../library/logging.handlers.rst:372
#, fuzzy
msgid ""
"You can use the *when* to specify the type of *interval*. The list of "
"possible values is below.  Note that they are not case sensitive."
msgstr "您可以使用 *when* 來指定 *interval* "
"的型別。可能的值列表如下。請注意，它們不區分大小寫。"

#: ../../library/logging.handlers.rst:376
#, fuzzy
msgid "Value"
msgstr "價值"

#: ../../library/logging.handlers.rst:376
#, fuzzy
msgid "Type of interval"
msgstr "區間型別"

#: ../../library/logging.handlers.rst:376
#, fuzzy
msgid "If/how *atTime* is used"
msgstr "如果/如何使用 *atTime*"

#: ../../library/logging.handlers.rst:378
msgid "``'S'``"
msgstr "``'S'``"

#: ../../library/logging.handlers.rst:378
#, fuzzy
msgid "Seconds"
msgstr "秒"

#: ../../library/logging.handlers.rst:378
#: ../../library/logging.handlers.rst:380
#: ../../library/logging.handlers.rst:382
#: ../../library/logging.handlers.rst:384
#, fuzzy
msgid "Ignored"
msgstr "忽略"

#: ../../library/logging.handlers.rst:380
msgid "``'M'``"
msgstr "``'M'``"

#: ../../library/logging.handlers.rst:380
#, fuzzy
msgid "Minutes"
msgstr "分鐘"

#: ../../library/logging.handlers.rst:382
msgid "``'H'``"
msgstr "``'H'``"

#: ../../library/logging.handlers.rst:382
#, fuzzy
msgid "Hours"
msgstr "小時"

#: ../../library/logging.handlers.rst:384
msgid "``'D'``"
msgstr "``'D'``"

#: ../../library/logging.handlers.rst:384
#, fuzzy
msgid "Days"
msgstr "天"

#: ../../library/logging.handlers.rst:386
msgid "``'W0'-'W6'``"
msgstr "``'W0'-'W6'``"

#: ../../library/logging.handlers.rst:386
#, fuzzy
msgid "Weekday (0=Monday)"
msgstr "工作日（0=星期一）"

#: ../../library/logging.handlers.rst:386
#: ../../library/logging.handlers.rst:389
#, fuzzy
msgid "Used to compute initial rollover time"
msgstr "用於計算初始翻轉時間"

#: ../../library/logging.handlers.rst:389
msgid "``'midnight'``"
msgstr "``'midnight'``"

#: ../../library/logging.handlers.rst:389
#, fuzzy
msgid "Roll over at midnight, if *atTime* not specified, else at time *atTime*"
msgstr "如果未指定 *atTime*，則在午夜滾動，否則在 *atTime* 時間滾動"

#: ../../library/logging.handlers.rst:394
#, fuzzy
msgid ""
"When using weekday-based rotation, specify 'W0' for Monday, 'W1' for "
"Tuesday, and so on up to 'W6' for Sunday. In this case, the value passed for "
"*interval* isn't used."
msgstr ""
"使用基於工作日的輪換時，為星期一指定 ``W0``，為星期二指定 ``W1``，依此類推，直到星"
"期日為 ``W6``。在這種情況下，不使用為 *interval* 傳遞的值。"

#: ../../library/logging.handlers.rst:398
#, fuzzy
msgid ""
"The system will save old log files by appending extensions to the filename. "
"The extensions are date-and-time based, using the strftime format ``%Y-%m-%d_"
"%H-%M-%S`` or a leading portion thereof, depending on the rollover interval."
msgstr ""
"系統將通過向文件名附加擴充名來保存舊日誌文件。擴充基於日期和時間，使用 "
"strftime 格式“%Y-%m-%d_%H-%M-%S”或其前導部分，具體取決於翻轉間隔。"

#: ../../library/logging.handlers.rst:403
#, fuzzy
msgid ""
"When computing the next rollover time for the first time (when the handler "
"is created), the last modification time of an existing log file, or else the "
"current time, is used to compute when the next rotation will occur."
msgstr "第一次計算下一次輪換時間時（建立處理程式時），現有日誌文件的最後修改時間或當"
"前時間用於計算下一次輪換發生的時間。"

#: ../../library/logging.handlers.rst:407
#, fuzzy
msgid ""
"If the *utc* argument is true, times in UTC will be used; otherwise local "
"time is used."
msgstr "如果 *utc* 參數為真，將使用 UTC 時間；否則使用當地時間。"

#: ../../library/logging.handlers.rst:410
#, fuzzy
msgid ""
"If *backupCount* is nonzero, at most *backupCount* files will be kept, and "
"if more would be created when rollover occurs, the oldest one is deleted. "
"The deletion logic uses the interval to determine which files to delete, so "
"changing the interval may leave old files lying around."
msgstr ""
"如果 *backupCount* 不為零，則最多保留 *backupCount* 個文件，如果發生翻轉時會"
"建立更多文件，則刪除最舊的文件。刪除邏輯使用間隔來確定要刪除哪些文件，因此更"
"改間隔可能會留下舊文件。"

#: ../../library/logging.handlers.rst:415
#, fuzzy
msgid ""
"If *delay* is true, then file opening is deferred until the first call to :"
"meth:`emit`."
msgstr "如果 *delay* 為真，則文件打開將延遲到第一次呼叫 :meth:`emit` 時。"

#: ../../library/logging.handlers.rst:418
#, fuzzy
msgid ""
"If *atTime* is not ``None``, it must be a ``datetime.time`` instance which "
"specifies the time of day when rollover occurs, for the cases where rollover "
"is set to happen \"at midnight\" or \"on a particular weekday\". Note that "
"in these cases, the *atTime* value is effectively used to compute the "
"*initial* rollover, and subsequent rollovers would be calculated via the "
"normal interval calculation."
msgstr ""
"如果 *atTime* 不是 ``None``，它必須是一個 ``datetime.time`` 實例，它指定發生"
"翻轉的時間，對於翻轉設定為發生在“午夜”或 ``上``的情況一個特定的工作日”。請注意，"
"在這些情況下，*atTime* 值有效地用於計算*初始* "
"翻轉，後續翻轉將通過正常間隔計算來計算。"

#: ../../library/logging.handlers.rst:425
#, fuzzy
msgid ""
"If *errors* is specified, it's used to determine how encoding errors are "
"handled."
msgstr "如果指定了 *errors*，它用於確定如何處理編碼錯誤。"

#: ../../library/logging.handlers.rst:428
#, fuzzy
msgid ""
"Calculation of the initial rollover time is done when the handler is "
"initialised. Calculation of subsequent rollover times is done only when "
"rollover occurs, and rollover occurs only when emitting output. If this is "
"not kept in mind, it might lead to some confusion. For example, if an "
"interval of \"every minute\" is set, that does not mean you will always see "
"log files with times (in the filename) separated by a minute; if, during "
"application execution, logging output is generated more frequently than once "
"a minute, *then* you can expect to see log files with times separated by a "
"minute. If, on the other hand, logging messages are only output once every "
"five minutes (say), then there will be gaps in the file times corresponding "
"to the minutes where no output (and hence no rollover) occurred."
msgstr ""
"初始翻轉時間的計算在處理程式初始化時完成。僅在發生翻轉時才計算後續翻轉時間，"
"並且僅在發出輸出時發生翻轉。如果不牢記這一點，可能會導致一些混亂。例如，如果"
"設定了“每分鐘”的時間間隔，這並不意味著您將始終看到時間（在文件名中）以一分鐘"
"分隔的日誌文件；如果在應用程式執行過程中，日誌輸出的生成頻率超過一分鐘一次，*"
"那麼*您會看到時間間隔為一分鐘的日誌文件。另一方面，如果日誌消息僅每五分鐘輸出"
"一次（比方說），那麼文件時間中將存在與沒有輸出（因此沒有翻轉）發生的分鐘對應"
"的間隙。"

#: ../../library/logging.handlers.rst:441
msgid "*atTime* parameter was added."
msgstr "新增 *atTime* 參數。"

#: ../../library/logging.handlers.rst:457
#, fuzzy
msgid ""
"Outputs the record to the file, catering for rollover as described above."
msgstr "將記錄輸出到文件，以滿足如上所述的翻轉。"

#: ../../library/logging.handlers.rst:461
#, fuzzy
msgid ""
"Returns a list of filenames which should be deleted as part of rollover. "
"These are the absolute paths of the oldest backup log files written by the "
"handler."
msgstr "回傳應作為翻轉的一部分刪除的文件名列表。這些是處理程式寫入的最舊備份日誌文件"
"的絕對路徑。"

#: ../../library/logging.handlers.rst:467
msgid "SocketHandler"
msgstr "SocketHandler"

#: ../../library/logging.handlers.rst:469
#, fuzzy
msgid ""
"The :class:`SocketHandler` class, located in the :mod:`logging.handlers` "
"module, sends logging output to a network socket. The base class uses a TCP "
"socket."
msgstr ""
":class:`SocketHandler` 類位於 :mod:`logging.handlers` "
"模組中，將日誌輸出發送到網絡 socket 。基底類別使用 TCP  socket 。"

#: ../../library/logging.handlers.rst:475
#, fuzzy
msgid ""
"Returns a new instance of the :class:`SocketHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr "回傳 :class:`SocketHandler` 類的新實例，用於與地址由 *host* 和 *port* "
"給出的遠程機器通信。"

#: ../../library/logging.handlers.rst:478
#, fuzzy
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a TCP socket is created."
msgstr ""
"如果將 ``port`` 指定為 ``None``，則使用 ``host`` 中的值建立 Unix 域 socket  - "
"否則，將建立 TCP  socket 。"

#: ../../library/logging.handlers.rst:484
#, fuzzy
msgid "Closes the socket."
msgstr "關閉 socket 。"

#: ../../library/logging.handlers.rst:489
#, fuzzy
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. If the connection was previously lost, re-establishes the "
"connection. To unpickle the record at the receiving end into a :class:"
"`~logging.LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""
"醃製記錄的屬性字典並將其以二進位格式寫入 socket 。如果 socket 有錯誤，則靜默丟棄"
"資料包。如果之前連接丟失，則重新建立連接。要將接收端的記錄解封為 :class:`~logg"
"ing.LogRecord`，請使用 :func:`~logging.makeLogRecord` 函式。"

#: ../../library/logging.handlers.rst:499
#, fuzzy
msgid ""
"Handles an error which has occurred during :meth:`emit`. The most likely "
"cause is a lost connection. Closes the socket so that we can retry on the "
"next event."
msgstr "處理在 :meth:`emit` 期間發生的錯誤。最可能的原因是連接丟失。關閉 socket 以便我"
"們可以重試下一個事件。"

#: ../../library/logging.handlers.rst:506
#, fuzzy
msgid ""
"This is a factory method which allows subclasses to define the precise type "
"of socket they want. The default implementation creates a TCP socket (:const:"
"`socket.SOCK_STREAM`)."
msgstr ""
"這是一個工廠方法，它允許子類別定義他們想要的 socket 的精確型別。"
"預設實作建立一個 TCP  socket  (:const:`socket.SOCK_STREAM`)。"

#: ../../library/logging.handlers.rst:513
#, fuzzy
msgid ""
"Pickles the record's attribute dictionary in binary format with a length "
"prefix, and returns it ready for transmission across the socket. The details "
"of this operation are equivalent to::"
msgstr "以帶有長度前綴的二進位格式醃製記錄的屬性字典，並回傳它以準備通過 socket 傳輸。"
"這個操作的細節等同於："

#: ../../library/logging.handlers.rst:521
#, fuzzy
msgid ""
"Note that pickles aren't completely secure. If you are concerned about "
"security, you may want to override this method to implement a more secure "
"mechanism. For example, you can sign pickles using HMAC and then verify them "
"on the receiving end, or alternatively you can disable unpickling of global "
"objects on the receiving end."
msgstr ""
"請注意，泡菜並不完全安全。如果您擔心安全性，您可能希望覆蓋此方法以實作更安全"
"的機制。例如，您可以使用 HMAC 對 pickle 進行簽名，然後在接收端驗證它們，"
"或者您可以在接收端禁用全局物件的 unpickling。"

#: ../../library/logging.handlers.rst:530
#, fuzzy
msgid ""
"Send a pickled byte-string *packet* to the socket. The format of the sent "
"byte-string is as described in the documentation for :meth:`~SocketHandler."
"makePickle`."
msgstr ""
"將醃製的位元組串 *packet* 發送到 socket 。發送的位元組串的格式如 "
":meth:`~SocketHandler.makePickle` 的文檔中所述。"

#: ../../library/logging.handlers.rst:534
#, fuzzy
msgid ""
"This function allows for partial sends, which can happen when the network is "
"busy."
msgstr "此功能允許部分發送，這可能在網絡繁忙時發生。"

#: ../../library/logging.handlers.rst:540
#, fuzzy
msgid ""
"Tries to create a socket; on failure, uses an exponential back-off "
"algorithm.  On initial failure, the handler will drop the message it was "
"trying to send.  When subsequent messages are handled by the same instance, "
"it will not try connecting until some time has passed.  The default "
"parameters are such that the initial delay is one second, and if after that "
"delay the connection still can't be made, the handler will double the delay "
"each time up to a maximum of 30 seconds."
msgstr ""
"嘗試建立 socket ；失敗時，使用指數退避演算法。在初始失敗時，處理程式將丟棄它試"
"圖發送的消息。當後續消息由同一個實例處理時，它將在一段時間後才會嘗試連接。預"
"設參數是初始延遲為一秒，如果在延遲之後仍然無法建立連接，處理程式將每次延遲加"
"倍，最多 30 秒。"

#: ../../library/logging.handlers.rst:548
#, fuzzy
msgid "This behaviour is controlled by the following handler attributes:"
msgstr "此行為由以下處理程式屬性控制："

#: ../../library/logging.handlers.rst:550
#, fuzzy
msgid "``retryStart`` (initial delay, defaulting to 1.0 seconds)."
msgstr "``retryStart``（初始延遲，預設為 1.0 秒）。"

#: ../../library/logging.handlers.rst:551
#, fuzzy
msgid "``retryFactor`` (multiplier, defaulting to 2.0)."
msgstr "``retryFactor``（乘數，預設為 2.0）。"

#: ../../library/logging.handlers.rst:552
#, fuzzy
msgid "``retryMax`` (maximum delay, defaulting to 30.0 seconds)."
msgstr "``retryMax``（最大延遲，預設為 30.0 秒）。"

#: ../../library/logging.handlers.rst:554
#, fuzzy
msgid ""
"This means that if the remote listener starts up *after* the handler has "
"been used, you could lose messages (since the handler won't even attempt a "
"connection until the delay has elapsed, but just silently drop messages "
"during the delay period)."
msgstr ""
"這意味著如果遠程偵聽器*在*處理程式已被使用後啟動，您可能會丟失消息（因為處理"
"程式甚至不會在延遲結束之前嘗試連接，而只是在延遲期間靜默丟棄消息）。"

#: ../../library/logging.handlers.rst:563
msgid "DatagramHandler"
msgstr "DatagramHandler"

#: ../../library/logging.handlers.rst:565
#, fuzzy
msgid ""
"The :class:`DatagramHandler` class, located in the :mod:`logging.handlers` "
"module, inherits from :class:`SocketHandler` to support sending logging "
"messages over UDP sockets."
msgstr ""
":class:`DatagramHandler` 類位於 :mod:`logging.handlers` 模組中，繼承自 "
":class:`SocketHandler` 以支援通過 UDP  socket 發送日誌消息。"

#: ../../library/logging.handlers.rst:572
#, fuzzy
msgid ""
"Returns a new instance of the :class:`DatagramHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr "回傳 :class:`DatagramHandler` 類的新實例，用於與地址由 *host* 和 *port* "
"給出的遠程機器通信。"

#: ../../library/logging.handlers.rst:575
#, fuzzy
msgid ""
"As UDP is not a streaming protocol, there is no persistent connection "
"between an instance of this handler and *host*. For this reason, when using "
"a network socket, a DNS lookup might have to be made each time an event is "
"logged, which can introduce some latency into the system. If this affects "
"you, you can do a lookup yourself and initialize this handler using the "
"looked-up IP address rather than the hostname."
msgstr ""
"由於 UDP 不是流式傳輸協定，因此此處理程式的實例與 *host* "
"之間沒有持久連接。出於這個原因，在使用網絡 socket 時，"
"每次記錄事件時可能都必須進行 DNS "
"查找，這會給系統帶來一些延遲。如果這對您有影響，"
"您可以自己進行查找並使用查找到的 IP 地址而不是主機名來初始化此處理程式。"

#: ../../library/logging.handlers.rst:582
#, fuzzy
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a UDP socket is created."
msgstr ""
"如果將 ``port`` 指定為 ``None``，則使用 ``host`` 中的值建立一個 Unix "
"域 socket  - 否則，將建立一個 UDP  socket 。"

#: ../../library/logging.handlers.rst:588
#, fuzzy
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. To unpickle the record at the receiving end into a :class:`~logging."
"LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""
"醃製記錄的屬性字典並將其以二進位格式寫入 socket 。如果 socket 有錯誤，則靜默丟棄"
"資料包。要將接收端的記錄解封為 :class:`~logging."
"LogRecord`，請使用 :func:`~logging.makeLogRecord` 函式。"

#: ../../library/logging.handlers.rst:597
#, fuzzy
msgid ""
"The factory method of :class:`SocketHandler` is here overridden to create a "
"UDP socket (:const:`socket.SOCK_DGRAM`)."
msgstr ""
":class:`SocketHandler` 的工廠方法在這裡被覆蓋以建立 UDP  socket  "
"(:const:`socket.SOCK_DGRAM`)。"

#: ../../library/logging.handlers.rst:603
#, fuzzy
msgid ""
"Send a pickled byte-string to a socket. The format of the sent byte-string "
"is as described in the documentation for :meth:`SocketHandler.makePickle`."
msgstr "將醃製的位元組字串發送到 socket 。發送的位元組字串的格式如 :meth:`SocketHandler"
".makePickle` 的文檔中所述。"

#: ../../library/logging.handlers.rst:610
msgid "SysLogHandler"
msgstr "SysLogHandler"

#: ../../library/logging.handlers.rst:612
#, fuzzy
msgid ""
"The :class:`SysLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a remote or local Unix syslog."
msgstr ""
":class:`SysLogHandler` 類位於 :mod:`logging.handlers` 模組中，"
"支援將日誌消息發送到遠程或本地 Unix 系統日誌。"

#: ../../library/logging.handlers.rst:618
#, fuzzy
msgid ""
"Returns a new instance of the :class:`SysLogHandler` class intended to "
"communicate with a remote Unix machine whose address is given by *address* "
"in the form of a ``(host, port)`` tuple.  If *address* is not specified, "
"``('localhost', 514)`` is used.  The address is used to open a socket.  An "
"alternative to providing a ``(host, port)`` tuple is providing an address as "
"a string, for example '/dev/log'. In this case, a Unix domain socket is used "
"to send the message to the syslog. If *facility* is not specified, :const:"
"`LOG_USER` is used. The type of socket opened depends on the *socktype* "
"argument, which defaults to :const:`socket.SOCK_DGRAM` and thus opens a UDP "
"socket. To open a TCP socket (for use with the newer syslog daemons such as "
"rsyslog), specify a value of :const:`socket.SOCK_STREAM`."
msgstr ""
"回傳 SysLogHandler 類的一個新實例，用於與遠程 Unix 機器通信，該機器的地址由 "
"*address* 以 ``(host, port)`` 元組的形式給出。如果未指定 *address*，則使用 "
"``('localhost', 514)``。該地址用於打開 socket 。提供 ``(host, port)`` "
"元組的替代方法是提供字串形式的地址，例如“/dev/log”。在這種情況下，Unix "
"域 socket 用於將消息發送到系統日誌。如果未指定 *facility*，則使用 "
":const:`LOG_USER`。打開的 socket 型別取決於 *socktype* 參數，預設為 "
":const:`socket.SOCK_DGRAM` 並因此打開 UDP  socket 。要打開 TCP  socket （"
"用於較新的 syslog 守護程式，例如 rsyslog），請指定一個值 :const:`socket."
"SOCK_STREAM`。"

#: ../../library/logging.handlers.rst:630
#, fuzzy
msgid ""
"Note that if your server is not listening on UDP port 514, :class:"
"`SysLogHandler` may appear not to work. In that case, check what address you "
"should be using for a domain socket - it's system dependent. For example, on "
"Linux it's usually '/dev/log' but on OS/X it's '/var/run/syslog'. You'll "
"need to check your platform and use the appropriate address (you may need to "
"do this check at runtime if your application needs to run on several "
"platforms). On Windows, you pretty much have to use the UDP option."
msgstr ""
"請注意，如果您的伺服器未在 UDP 端口 514 上偵聽，則 SysLogHandler 可能無法正常"
"工作。在這種情況下，請檢查您應該為域 socket 使用的地址——它取決於系統。例如，在 "
"Linux 上它通常是“/dev/log”，但在 OS/X 上它是“/var/run/syslog”。您需要檢查您的"
"平台並使用適當的地址（如果您的應用程式需要在多個平台上運行，您可能需要在運行"
"時進行此檢查）。在 Windows 上，您幾乎必須使用 UDP 選項。"

#: ../../library/logging.handlers.rst:639
#, fuzzy
msgid ""
"On macOS 12.x (Monterey), Apple has changed the behaviour of their syslog "
"daemon - it no longer listens on a domain socket. Therefore, you cannot "
"expect :class:`SysLogHandler` to work on this system."
msgstr ""
"在 macOS 12.x (Monterey) 上，Apple 更改了其係統日誌守護程式的行為 - "
"它不再偵聽域 socket 。因此，您不能指望 :class:`SysLogHandler` "
"在這個系統上工作。"

#: ../../library/logging.handlers.rst:643
#, fuzzy
msgid "See :gh:`91070` for more information."
msgstr "有關詳細資訊，請參閱 :gh:`91070`。"

#: ../../library/logging.handlers.rst:645
msgid "*socktype* was added."
msgstr "新增 *socktype*\\ 。"

#: ../../library/logging.handlers.rst:651
#, fuzzy
msgid "Closes the socket to the remote host."
msgstr "關閉到遠程主機的 socket 。"

#: ../../library/logging.handlers.rst:655
#, fuzzy
msgid ""
"Tries to create a socket and, if it's not a datagram socket, connect it to "
"the other end. This method is called during handler initialization, but it's "
"not regarded as an error if the other end isn't listening at this point - "
"the method will be called again when emitting an event, if but it's not "
"regarded as an error if the other end isn't listening yet --- the method "
"will be called again when emitting an event, if there is no socket at that "
"point."
msgstr ""
"嘗試建立 socket ，如果不是資料報 socket ，則將其連接到另一端。此方法在處理程式初"
"始化期間呼叫，但如果此時另一端未偵聽，則不會將其視為錯誤 - "
"發出事件時將再次呼叫該方法，如果但如果另一端則不會將其視為錯誤尚未收聽---"
"如果此時沒有 socket ，則在發出事件時將再次呼叫該方法。"

#: ../../library/logging.handlers.rst:667
#, fuzzy
msgid ""
"The record is formatted, and then sent to the syslog server. If exception "
"information is present, it is *not* sent to the server."
msgstr "記錄被格式化，然後發送到系統日誌伺服器。如果存在例外資訊，則*不會*將其發送到"
"伺服器。"

#: ../../library/logging.handlers.rst:670
#, fuzzy
msgid ""
"(See: :issue:`12168`.) In earlier versions, the message sent to the syslog "
"daemons was always terminated with a NUL byte, because early versions of "
"these daemons expected a NUL terminated message - even though it's not in "
"the relevant specification (:rfc:`5424`). More recent versions of these "
"daemons don't expect the NUL byte but strip it off if it's there, and even "
"more recent daemons (which adhere more closely to RFC 5424) pass the NUL "
"byte on as part of the message."
msgstr ""
"（參見 :issue:`12168`。）在早期版本中，發送到 syslog 守護程式的消息總是以 "
"NUL 位元組終止，因為這些守護程式的早期版本需要 NUL "
"終止消息——即使它不在相關規範中(:rfc:`5424`)。這些守護程式的更新版本不期望 "
"NUL 位元組，但如果它存在則將其刪除，甚至更新的守護程式（更嚴格地遵守 RFC "
"5424）將 NUL 位元組作為消息的一部分傳遞。"

#: ../../library/logging.handlers.rst:679
#, fuzzy
msgid ""
"To enable easier handling of syslog messages in the face of all these "
"differing daemon behaviours, the appending of the NUL byte has been made "
"configurable, through the use of a class-level attribute, ``append_nul``. "
"This defaults to ``True`` (preserving the existing behaviour) but can be set "
"to ``False`` on a ``SysLogHandler`` instance in order for that instance to "
"*not* append the NUL terminator."
msgstr ""
"為了在面對所有這些不同的守護行程行為時能夠更輕鬆地處理 syslog "
"消息，通過使用類級屬性“append_nul”，可以配置新增 NUL 位元組。這預設為 ``True``（"
"保留現有行為），但可以在 ``SysLogHandler`` 實例上設定為 ``False``，以便該實例*不*"
"附加 NUL 終止符。"

#: ../../library/logging.handlers.rst:686
#, fuzzy
msgid ""
"(See: :issue:`12419`.) In earlier versions, there was no facility for an "
"\"ident\" or \"tag\" prefix to identify the source of the message. This can "
"now be specified using a class-level attribute, defaulting to ``\"\"`` to "
"preserve existing behaviour, but which can be overridden on a "
"``SysLogHandler`` instance in order for that instance to prepend the ident "
"to every message handled. Note that the provided ident must be text, not "
"bytes, and is prepended to the message exactly as is."
msgstr ""
"（參見 :issue:`12419`。）在早期版本中，沒有 \"ident\" 或 \"tag\" 前綴來標識消息源的工"
"具。現在可以使用類級別的屬性來指定，預設為 ``\"\"`` 以保留現有行為，但可以在“SysLogH"
"andler”實例上覆蓋它，以便該實例將標識新增到每條消息中處理。請注意，提供的標識"
"必須是文本，而不是位元組，並且完全按原樣新增到消息之前。"

#: ../../library/logging.handlers.rst:697
#, fuzzy
msgid ""
"Encodes the facility and priority into an integer. You can pass in strings "
"or integers - if strings are passed, internal mapping dictionaries are used "
"to convert them to integers."
msgstr "將設施和優先級編碼為整數。您可以傳入字串或整數 - "
"如果傳遞字串，則使用內部映射字典將它們轉換為整數。"

#: ../../library/logging.handlers.rst:701
#, fuzzy
msgid ""
"The symbolic ``LOG_`` values are defined in :class:`SysLogHandler` and "
"mirror the values defined in the ``sys/syslog.h`` header file."
msgstr "符號 ``LOG_`` 值在 SysLogHandler 中定義，並反映在 ``sys/syslog.h`` "
"標頭檔中定義的值。"

#: ../../library/logging.handlers.rst:704
#, fuzzy
msgid "**Priorities**"
msgstr "**優先事項**"

#: ../../library/logging.handlers.rst:707
#: ../../library/logging.handlers.rst:729
#, fuzzy
msgid "Name (string)"
msgstr "名稱（字串）"

#: ../../library/logging.handlers.rst:707
#: ../../library/logging.handlers.rst:729
#, fuzzy
msgid "Symbolic value"
msgstr "象徵價值"

#: ../../library/logging.handlers.rst:709
msgid "``alert``"
msgstr "``alert``"

#: ../../library/logging.handlers.rst:709
msgid "LOG_ALERT"
msgstr "LOG_ALERT"

#: ../../library/logging.handlers.rst:711
msgid "``crit`` or ``critical``"
msgstr "``crit`` 或 ``critical``"

#: ../../library/logging.handlers.rst:711
msgid "LOG_CRIT"
msgstr "LOG_CRIT"

#: ../../library/logging.handlers.rst:713
msgid "``debug``"
msgstr "``debug``"

#: ../../library/logging.handlers.rst:713
msgid "LOG_DEBUG"
msgstr "LOG_DEBUG"

#: ../../library/logging.handlers.rst:715
msgid "``emerg`` or ``panic``"
msgstr "``emerg`` 或 ``panic``"

#: ../../library/logging.handlers.rst:715
msgid "LOG_EMERG"
msgstr "LOG_EMERG"

#: ../../library/logging.handlers.rst:717
msgid "``err`` or ``error``"
msgstr "``err`` 或 ``error``"

#: ../../library/logging.handlers.rst:717
msgid "LOG_ERR"
msgstr "LOG_ERR"

#: ../../library/logging.handlers.rst:719
msgid "``info``"
msgstr "``info``"

#: ../../library/logging.handlers.rst:719
msgid "LOG_INFO"
msgstr "LOG_INFO"

#: ../../library/logging.handlers.rst:721
msgid "``notice``"
msgstr "``notice``"

#: ../../library/logging.handlers.rst:721
msgid "LOG_NOTICE"
msgstr "LOG_NOTICE"

#: ../../library/logging.handlers.rst:723
msgid "``warn`` or ``warning``"
msgstr "``warn`` 或 ``warning``"

#: ../../library/logging.handlers.rst:723
msgid "LOG_WARNING"
msgstr "LOG_WARNING"

#: ../../library/logging.handlers.rst:726
#, fuzzy
msgid "**Facilities**"
msgstr "**設施**"

#: ../../library/logging.handlers.rst:731
msgid "``auth``"
msgstr "``auth``"

#: ../../library/logging.handlers.rst:731
msgid "LOG_AUTH"
msgstr "LOG_AUTH"

#: ../../library/logging.handlers.rst:733
msgid "``authpriv``"
msgstr "``authpriv``"

#: ../../library/logging.handlers.rst:733
msgid "LOG_AUTHPRIV"
msgstr "LOG_AUTHPRIV"

#: ../../library/logging.handlers.rst:735
msgid "``cron``"
msgstr "``cron``"

#: ../../library/logging.handlers.rst:735
msgid "LOG_CRON"
msgstr "LOG_CRON"

#: ../../library/logging.handlers.rst:737
msgid "``daemon``"
msgstr "``daemon``"

#: ../../library/logging.handlers.rst:737
msgid "LOG_DAEMON"
msgstr "LOG_DAEMON"

#: ../../library/logging.handlers.rst:739
msgid "``ftp``"
msgstr "``ftp``"

#: ../../library/logging.handlers.rst:739
msgid "LOG_FTP"
msgstr "LOG_FTP"

#: ../../library/logging.handlers.rst:741
msgid "``kern``"
msgstr "``kern``"

#: ../../library/logging.handlers.rst:741
msgid "LOG_KERN"
msgstr "LOG_KERN"

#: ../../library/logging.handlers.rst:743
msgid "``lpr``"
msgstr "``lpr``"

#: ../../library/logging.handlers.rst:743
msgid "LOG_LPR"
msgstr "LOG_LPR"

#: ../../library/logging.handlers.rst:745
msgid "``mail``"
msgstr "``mail``"

#: ../../library/logging.handlers.rst:745
msgid "LOG_MAIL"
msgstr "LOG_MAIL"

#: ../../library/logging.handlers.rst:747
msgid "``news``"
msgstr "``news``"

#: ../../library/logging.handlers.rst:747
msgid "LOG_NEWS"
msgstr "LOG_NEWS"

#: ../../library/logging.handlers.rst:749
msgid "``syslog``"
msgstr "``syslog``"

#: ../../library/logging.handlers.rst:749
msgid "LOG_SYSLOG"
msgstr "LOG_SYSLOG"

#: ../../library/logging.handlers.rst:751
msgid "``user``"
msgstr "``user``"

#: ../../library/logging.handlers.rst:751
msgid "LOG_USER"
msgstr "LOG_USER"

#: ../../library/logging.handlers.rst:753
msgid "``uucp``"
msgstr "``uucp``"

#: ../../library/logging.handlers.rst:753
msgid "LOG_UUCP"
msgstr "LOG_UUCP"

#: ../../library/logging.handlers.rst:755
msgid "``local0``"
msgstr "``local0``"

#: ../../library/logging.handlers.rst:755
msgid "LOG_LOCAL0"
msgstr "LOG_LOCAL0"

#: ../../library/logging.handlers.rst:757
msgid "``local1``"
msgstr "``local1``"

#: ../../library/logging.handlers.rst:757
msgid "LOG_LOCAL1"
msgstr "LOG_LOCAL1"

#: ../../library/logging.handlers.rst:759
msgid "``local2``"
msgstr "``local2``"

#: ../../library/logging.handlers.rst:759
msgid "LOG_LOCAL2"
msgstr "LOG_LOCAL2"

#: ../../library/logging.handlers.rst:761
msgid "``local3``"
msgstr "``local3``"

#: ../../library/logging.handlers.rst:761
msgid "LOG_LOCAL3"
msgstr "LOG_LOCAL3"

#: ../../library/logging.handlers.rst:763
msgid "``local4``"
msgstr "``local4``"

#: ../../library/logging.handlers.rst:763
msgid "LOG_LOCAL4"
msgstr "LOG_LOCAL4"

#: ../../library/logging.handlers.rst:765
msgid "``local5``"
msgstr "``local5``"

#: ../../library/logging.handlers.rst:765
msgid "LOG_LOCAL5"
msgstr "LOG_LOCAL5"

#: ../../library/logging.handlers.rst:767
msgid "``local6``"
msgstr "``local6``"

#: ../../library/logging.handlers.rst:767
msgid "LOG_LOCAL6"
msgstr "LOG_LOCAL6"

#: ../../library/logging.handlers.rst:769
msgid "``local7``"
msgstr "``local7``"

#: ../../library/logging.handlers.rst:769
msgid "LOG_LOCAL7"
msgstr "LOG_LOCAL7"

#: ../../library/logging.handlers.rst:774
#, fuzzy
msgid ""
"Maps a logging level name to a syslog priority name. You may need to "
"override this if you are using custom levels, or if the default algorithm is "
"not suitable for your needs. The default algorithm maps ``DEBUG``, ``INFO``, "
"``WARNING``, ``ERROR`` and ``CRITICAL`` to the equivalent syslog names, and "
"all other level names to 'warning'."
msgstr ""
"將日誌記錄級別名稱映射到系統日誌優先級名稱。如果您使用自定義級別，或者如果預"
"設演算法不適合您的需要，您可能需要覆蓋它。預設演算法將 ``DEBUG``、 ``INFO``、“WARNI"
"NG”、 ``ERROR``和 ``CRITICAL`` 映射到等效的系統日誌名稱，並將所有其他級別名稱映射到“"
"警告”。"

#: ../../library/logging.handlers.rst:784
msgid "NTEventLogHandler"
msgstr "NTEventLogHandler"

#: ../../library/logging.handlers.rst:786
#, fuzzy
msgid ""
"The :class:`NTEventLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a local Windows NT, Windows "
"2000 or Windows XP event log. Before you can use it, you need Mark Hammond's "
"Win32 extensions for Python installed."
msgstr ""
":class:`NTEventLogHandler` 類位於 :mod:`logging.handlers` 模組中，"
"支援將日誌消息發送到本地 Windows NT、Windows 2000 或 Windows XP "
"事件日誌。在使用它之前，您需要安裝 Mark Hammond 的 Python Win32 擴充。"

#: ../../library/logging.handlers.rst:794
#, fuzzy
msgid ""
"Returns a new instance of the :class:`NTEventLogHandler` class. The "
"*appname* is used to define the application name as it appears in the event "
"log. An appropriate registry entry is created using this name. The *dllname* "
"should give the fully qualified pathname of a .dll or .exe which contains "
"message definitions to hold in the log (if not specified, ``'win32service."
"pyd'`` is used - this is installed with the Win32 extensions and contains "
"some basic placeholder message definitions. Note that use of these "
"placeholders will make your event logs big, as the entire message source is "
"held in the log. If you want slimmer logs, you have to pass in the name of "
"your own .dll or .exe which contains the message definitions you want to use "
"in the event log). The *logtype* is one of ``'Application'``, ``'System'`` "
"or ``'Security'``, and defaults to ``'Application'``."
msgstr ""
"回傳 NTEventLogHandler 類的新實例。 *appname* "
"用於定義出現在事件日誌中的應用程式名稱。使用此名稱建立適當的註冊表項。 "
"*dllname* 應該給出 .dll 或 .exe "
"的完全限定路徑名，其中包含要保存在日誌中的消息定義（如果未指定，則使用 "
"``'win32service.pyd'`` - 這是與 Win32 擴充一起安裝的並包含一些基本的佔位符消"
"息定義。請注意，使用這些佔位符會使您的事件日誌變大，因為整個消息源都保存在日"
"誌中。如果您想要更苗條的日誌，則必須傳入您自己的 .dll "
"的名稱或包含您要在事件日誌中使用的消息定義的 .exe）。 *logtype* "
"是“應用程式”、“系統”或“安全”之一，預設為“應用程式”。"

#: ../../library/logging.handlers.rst:810
#, fuzzy
msgid ""
"At this point, you can remove the application name from the registry as a "
"source of event log entries. However, if you do this, you will not be able "
"to see the events as you intended in the Event Log Viewer - it needs to be "
"able to access the registry to get the .dll name. The current version does "
"not do this."
msgstr ""
"此時，您可以從註冊表中刪除作為事件日誌條目來源的應用程式名稱。但是，如果您這"
"樣做，您將無法在事件日誌查看器中看到您想要的事件 - "
"它需要能夠訪問註冊表以獲取 .dll 名稱。當前版本不執行此操作。"

#: ../../library/logging.handlers.rst:819
#, fuzzy
msgid ""
"Determines the message ID, event category and event type, and then logs the "
"message in the NT event log."
msgstr "確定消息 ID、事件類別和事件型別，然後將消息記錄在 NT 事件日誌中。"

#: ../../library/logging.handlers.rst:825
#, fuzzy
msgid ""
"Returns the event category for the record. Override this if you want to "
"specify your own categories. This version returns 0."
msgstr "回傳記錄的事件類別。如果您想指定自己的類別，請覆蓋它。此版本回傳 0。"

#: ../../library/logging.handlers.rst:831
#, fuzzy
msgid ""
"Returns the event type for the record. Override this if you want to specify "
"your own types. This version does a mapping using the handler's typemap "
"attribute, which is set up in :meth:`__init__` to a dictionary which "
"contains mappings for :const:`DEBUG`, :const:`INFO`, :const:`WARNING`, :"
"const:`ERROR` and :const:`CRITICAL`. If you are using your own levels, you "
"will either need to override this method or place a suitable dictionary in "
"the handler's *typemap* attribute."
msgstr ""
"回傳記錄的事件型別。如果您想指定自己的型別，請覆蓋它。此版本使用處理程式的 "
"typemap 屬性進行映射，該屬性在 :meth:`__init__` "
"中設定為包含以下映射的字典 :const:`DEBUG`、:const:`INFO`、:const:`WARNING`、 "
":const:`ERROR` 和 :const:`CRITICAL`。如果您使用自己的關卡，"
"則需要覆蓋此方法或在處理程式的 *typemap* 屬性中放置一個合適的字典。"

#: ../../library/logging.handlers.rst:842
#, fuzzy
msgid ""
"Returns the message ID for the record. If you are using your own messages, "
"you could do this by having the *msg* passed to the logger being an ID "
"rather than a format string. Then, in here, you could use a dictionary "
"lookup to get the message ID. This version returns 1, which is the base "
"message ID in :file:`win32service.pyd`."
msgstr ""
"回傳記錄的消息 ID。如果您使用自己的消息，您可以通過將 *msg* 作為 ID "
"而不是格式字串傳遞給記錄器來實作。然後，在這裡，您可以使用字典查找來獲取消息 "
"ID。此版本回傳 1，這是 win32service.pyd 中的基本消息 ID。"

#: ../../library/logging.handlers.rst:851
msgid "SMTPHandler"
msgstr "SMTPHandler"

#: ../../library/logging.handlers.rst:853
#, fuzzy
msgid ""
"The :class:`SMTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to an email address via SMTP."
msgstr ""
":class:`SMTPHandler` 類位於 :mod:`logging.handlers` 模組中，支援通過 SMTP "
"將日誌消息發送到電子郵件地址。"

#: ../../library/logging.handlers.rst:859
#, fuzzy
msgid ""
"Returns a new instance of the :class:`SMTPHandler` class. The instance is "
"initialized with the from and to addresses and subject line of the email. "
"The *toaddrs* should be a list of strings. To specify a non-standard SMTP "
"port, use the (host, port) tuple format for the *mailhost* argument. If you "
"use a string, the standard SMTP port is used. If your SMTP server requires "
"authentication, you can specify a (username, password) tuple for the "
"*credentials* argument."
msgstr ""
"回傳 :class:`SMTPHandler` "
"類的新實例。該實例使用電子郵件的發件人和收件人地址以及主題行進行初始化。 "
"*toaddrs* 應該是一個字串列表。要指定非標準 SMTP 端口，請對 *mailhost* "
"參數使用 (host, port) 元組格式。如果您使用字串，則使用標準 SMTP 端口。"
"如果您的 SMTP 伺服器需要身份驗證，您可以為 *credentials* "
"參數指定一個（使用者名、密碼）元組。"

#: ../../library/logging.handlers.rst:866
#, fuzzy
msgid ""
"To specify the use of a secure protocol (TLS), pass in a tuple to the "
"*secure* argument. This will only be used when authentication credentials "
"are supplied. The tuple should be either an empty tuple, or a single-value "
"tuple with the name of a keyfile, or a 2-value tuple with the names of the "
"keyfile and certificate file. (This tuple is passed to the :meth:`smtplib."
"SMTP.starttls` method.)"
msgstr ""
"要指定使用安全協定 (TLS)，請將元組傳遞給 *secure* 參數。這將僅在提供身份驗證"
"憑據時使用。元組應該是一個空元組，或者是一個帶有密鑰文件名稱的單值元組，或者"
"是一個帶有密鑰文件和證書文件名稱的雙值元組。 （這個元組被傳遞給 "
"smtplib.SMTP.starttls 方法。）"

#: ../../library/logging.handlers.rst:873
#, fuzzy
msgid ""
"A timeout can be specified for communication with the SMTP server using the "
"*timeout* argument."
msgstr "可以使用 *timeout* 參數指定與 SMTP 伺服器通信的超時時間。"

#: ../../library/logging.handlers.rst:876
msgid "The *timeout* argument was added."
msgstr "新增 *timeout* 引數。"

#: ../../library/logging.handlers.rst:881
#, fuzzy
msgid "Formats the record and sends it to the specified addressees."
msgstr "格式化記錄並將其發送到指定的收件人。"

#: ../../library/logging.handlers.rst:886
#, fuzzy
msgid ""
"If you want to specify a subject line which is record-dependent, override "
"this method."
msgstr "如果要指定依賴於記錄的主題行，請重寫此方法。"

#: ../../library/logging.handlers.rst:892
msgid "MemoryHandler"
msgstr "MemoryHandler"

#: ../../library/logging.handlers.rst:894
#, fuzzy
msgid ""
"The :class:`MemoryHandler` class, located in the :mod:`logging.handlers` "
"module, supports buffering of logging records in memory, periodically "
"flushing them to a :dfn:`target` handler. Flushing occurs whenever the "
"buffer is full, or when an event of a certain severity or greater is seen."
msgstr ""
":class:`MemoryHandler` 類位於 :mod:`logging.handlers` "
"模組中，支援在記憶體中緩沖日志記錄，定期將它們刷新到 :dfn:`target` "
"處理程式。每當緩衝區已滿，或者出現特定嚴重性或更嚴重的事件時，就會發生刷新。"

#: ../../library/logging.handlers.rst:899
#, fuzzy
msgid ""
":class:`MemoryHandler` is a subclass of the more general :class:"
"`BufferingHandler`, which is an abstract class. This buffers logging records "
"in memory. Whenever each record is added to the buffer, a check is made by "
"calling :meth:`shouldFlush` to see if the buffer should be flushed.  If it "
"should, then :meth:`flush` is expected to do the flushing."
msgstr ""
":class:`MemoryHandler` 是更通用的 :class:`BufferingHandler` 的子類別，它是一"
"個抽像類。這會在記憶體中緩沖日志記錄。每當將每條記錄新增到緩衝區時，"
"都會通過呼叫 shouldFlush 來檢查是否應刷新緩衝區。如果應該，那麼 :meth:`flush`"
" 應該會進行沖洗。"

#: ../../library/logging.handlers.rst:908
#, fuzzy
msgid ""
"Initializes the handler with a buffer of the specified capacity. Here, "
"*capacity* means the number of logging records buffered."
msgstr "使用指定容量的緩衝區初始化處理程式。這裡，*capacity* 表示緩衝的日誌記錄數。"

#: ../../library/logging.handlers.rst:914
#, fuzzy
msgid ""
"Append the record to the buffer. If :meth:`shouldFlush` returns true, call :"
"meth:`flush` to process the buffer."
msgstr "將記錄附加到緩衝區。如果 :meth:`shouldFlush` 回傳 true，呼叫 :meth:`flush` "
"來處理緩衝區。"

#: ../../library/logging.handlers.rst:920
#, fuzzy
msgid ""
"You can override this to implement custom flushing behavior. This version "
"just zaps the buffer to empty."
msgstr "您可以覆蓋它以實作自定義刷新行為。這個版本只是將緩衝區清空。"

#: ../../library/logging.handlers.rst:926
#, fuzzy
msgid ""
"Return ``True`` if the buffer is up to capacity. This method can be "
"overridden to implement custom flushing strategies."
msgstr "如果緩衝區達到容量，則回傳 ``True``。可以覆蓋此方法以實作自定義刷新策略。"

#: ../../library/logging.handlers.rst:932
#, fuzzy
msgid ""
"Returns a new instance of the :class:`MemoryHandler` class. The instance is "
"initialized with a buffer size of *capacity* (number of records buffered). "
"If *flushLevel* is not specified, :const:`ERROR` is used. If no *target* is "
"specified, the target will need to be set using :meth:`setTarget` before "
"this handler does anything useful. If *flushOnClose* is specified as "
"``False``, then the buffer is *not* flushed when the handler is closed. If "
"not specified or specified as ``True``, the previous behaviour of flushing "
"the buffer will occur when the handler is closed."
msgstr ""
"回傳 MemoryHandler 類的新實例。該實例初始化為緩衝區大小 "
"*capacity*（緩衝的記錄數）。如果未指定 *flushLevel*，則使用 :const:`ERROR`。"
"如果未指定 *target*，則需要在該處理程式執行任何有用操作之前使用 "
":meth:`setTarget` 設定目標。如果 *flushOnClose* 被指定為 ``False``，那麼當處理程"
"序關閉時緩衝區*不會*刷新。如果未指定或指定為 ``True``，則關閉處理程式時將發生先"
"前刷新緩衝區的行為。"

#: ../../library/logging.handlers.rst:941
msgid "The *flushOnClose* parameter was added."
msgstr "新增 *flushOnClose* 參數。"

#: ../../library/logging.handlers.rst:947
#, fuzzy
msgid "Calls :meth:`flush`, sets the target to ``None`` and clears the buffer."
msgstr "呼叫 :meth:`flush`，將目標設定為 ``None`` 並清除緩衝區。"

#: ../../library/logging.handlers.rst:953
#, fuzzy
msgid ""
"For a :class:`MemoryHandler`, flushing means just sending the buffered "
"records to the target, if there is one. The buffer is also cleared when this "
"happens. Override if you want different behavior."
msgstr ""
"對於 MemoryHandler，刷新意味著僅將緩衝的記錄發送到目標（如果有）。發生這種情"
"況時，緩衝區也會被清除。如果您想要不同的行為，請覆蓋。"

#: ../../library/logging.handlers.rst:960
#, fuzzy
msgid "Sets the target handler for this handler."
msgstr "為此處理程式設定目標處理程式。"

#: ../../library/logging.handlers.rst:965
#, fuzzy
msgid "Checks for buffer full or a record at the *flushLevel* or higher."
msgstr "檢查緩衝區是否已滿或是否有 *flushLevel* 或更高階別的記錄。"

#: ../../library/logging.handlers.rst:971
msgid "HTTPHandler"
msgstr "HTTPHandler"

#: ../../library/logging.handlers.rst:973
#, fuzzy
msgid ""
"The :class:`HTTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a web server, using either "
"``GET`` or ``POST`` semantics."
msgstr ""
":class:`HTTPHandler` 類位於 :mod:`logging.handlers` 模組中，支援使用 ``GET`` "
"或 ``POST`` 語義將日誌消息發送到 Web 伺服器。"

#: ../../library/logging.handlers.rst:980
#, fuzzy
msgid ""
"Returns a new instance of the :class:`HTTPHandler` class. The *host* can be "
"of the form ``host:port``, should you need to use a specific port number.  "
"If no *method* is specified, ``GET`` is used. If *secure* is true, a HTTPS "
"connection will be used. The *context* parameter may be set to a :class:`ssl."
"SSLContext` instance to configure the SSL settings used for the HTTPS "
"connection. If *credentials* is specified, it should be a 2-tuple consisting "
"of userid and password, which will be placed in a HTTP 'Authorization' "
"header using Basic authentication. If you specify credentials, you should "
"also specify secure=True so that your userid and password are not passed in "
"cleartext across the wire."
msgstr ""
"回傳 :class:`HTTPHandler` 類的新實例。如果您需要使用特定的端口號，*host* "
"可以是 ``host:port`` 的形式。如果未指定 *method*，則使用``GET``。如果 "
"*secure* 為真，將使用 HTTPS 連接。 *context* 參數可以設定為 :class:`ssl."
"SSLContext` 實例來配置用於 HTTPS 連接的 SSL 設定。如果指定了 *credentials*，"
"它應該是一個由使用者 ID 和密碼組成的二元組，將使用基本身份驗證將其放置在 "
"HTTP“授權”標頭中。如果您指定憑據，您還應該指定 secure=True，這樣您的使用者 "
"ID 和密碼就不會以明文形式通過網絡傳遞。"

#: ../../library/logging.handlers.rst:991
msgid "The *context* parameter was added."
msgstr "新增 *context* 參數。"

#: ../../library/logging.handlers.rst:996
#, fuzzy
msgid ""
"Provides a dictionary, based on ``record``, which is to be URL-encoded and "
"sent to the web server. The default implementation just returns ``record."
"__dict__``. This method can be overridden if e.g. only a subset of :class:"
"`~logging.LogRecord` is to be sent to the web server, or if more specific "
"customization of what's sent to the server is required."
msgstr ""
"提供一個基於 ``record`` 的字典，它將被 URL 編碼並發送到 Web "
"伺服器。預設實作只回傳``record.__dict__``。如果例如，可以覆蓋此方法只有 "
":class:`~logging.LogRecord` 的一個子集被發送到 Web "
"伺服器，或者如果需要對發送到伺服器的內容進行更具體的定制。"

#: ../../library/logging.handlers.rst:1004
#, fuzzy
msgid ""
"Sends the record to the web server as a URL-encoded dictionary. The :meth:"
"`mapLogRecord` method is used to convert the record to the dictionary to be "
"sent."
msgstr "將記錄作為 URL 編碼字典發送到 Web 伺服器。 :meth:`mapLogRecord` "
"方法用於將記錄轉換為要發送的字典。"

#: ../../library/logging.handlers.rst:1008
#, fuzzy
msgid ""
"Since preparing a record for sending it to a web server is not the same as a "
"generic formatting operation, using :meth:`~logging.Handler.setFormatter` to "
"specify a :class:`~logging.Formatter` for a :class:`HTTPHandler` has no "
"effect. Instead of calling :meth:`~logging.Handler.format`, this handler "
"calls :meth:`mapLogRecord` and then :func:`urllib.parse.urlencode` to encode "
"the dictionary in a form suitable for sending to a web server."
msgstr ""
"由於準備記錄以將其發送到 Web 伺服器與一般格式化操作不同，因此使用 "
":meth:`~logging.Handler.setFormatter` 為 :class: 指定 :class:`~logging."
"Formatter`： `HTTPHandler` 無效。此處理程式不呼叫 :meth:`~logging.Handler."
"format`，而是呼叫 :meth:`mapLogRecord`，然後呼叫 :func:`urllib.parse."
"urlencode` 以適合發送到 Web 伺服器的形式對字典進行編碼."

#: ../../library/logging.handlers.rst:1021
msgid "QueueHandler"
msgstr "QueueHandler"

#: ../../library/logging.handlers.rst:1025
#, fuzzy
msgid ""
"The :class:`QueueHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules."
msgstr ""
":class:`QueueHandler` 類位於 :mod:`logging.handlers` "
"模組中，支援將日誌消息發送到隊列，例如在 :mod:`queue` 或 "
":mod:`multiprocessing` 模組中實作的那些."

#: ../../library/logging.handlers.rst:1029
#, fuzzy
msgid ""
"Along with the :class:`QueueListener` class, :class:`QueueHandler` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""
"與 :class:`QueueListener` 類一起，:class:`QueueHandler` "
"可用於讓處理程式在與執行日誌記錄的執行緒不同的執行緒上完成工作。這在 Web 應用"
"程式和其他服務應用程式中很重要，在這些應用程式中，為客戶端提供服務的執行緒需"
"要盡快響應，而任何可能較慢的操作（例如通過 SMTPHandler "
"發送電子郵件）都在單獨的執行緒上完成。"

#: ../../library/logging.handlers.rst:1038
#, fuzzy
msgid ""
"Returns a new instance of the :class:`QueueHandler` class. The instance is "
"initialized with the queue to send messages to. The *queue* can be any queue-"
"like object; it's used as-is by the :meth:`enqueue` method, which needs to "
"know how to send messages to it. The queue is not *required* to have the "
"task tracking API, which means that you can use :class:`~queue.SimpleQueue` "
"instances for *queue*."
msgstr ""
"回傳 :class:`QueueHandler` "
"類的新實例。該實例使用要將消息發送到的隊列進行初始化。 *queue* "
"可以是任何類似隊列的物件；它被 :meth:`enqueue` "
"方法按原樣使用，該方法需要知道如何向它發送消息。隊列*不需要*具有任務跟踪 "
"API，這意味著您可以使用 *queue* 的 :class:`~queue.SimpleQueue` 實例。"

#: ../../library/logging.handlers.rst:1045
#: ../../library/logging.handlers.rst:1128
#, fuzzy
msgid ""
"If you are using :mod:`multiprocessing`, you should avoid using :class:"
"`~queue.SimpleQueue` and instead use :class:`multiprocessing.Queue`."
msgstr ""
"如果您正在使用 :mod:`multiprocessing`，您應該避免使用 :class:`~queue."
"SimpleQueue` 而是使用 :class:`multiprocessing.Queue`。"

#: ../../library/logging.handlers.rst:1050
#, fuzzy
msgid ""
"Enqueues the result of preparing the LogRecord. Should an exception occur (e."
"g. because a bounded queue has filled up), the :meth:`~logging.Handler."
"handleError` method is called to handle the error. This can result in the "
"record silently being dropped (if :attr:`logging.raiseExceptions` is "
"``False``) or a message printed to ``sys.stderr`` (if :attr:`logging."
"raiseExceptions` is ``True``)."
msgstr ""
"將準備 LogRecord 的結果排入隊列。如果發生例外（例如，因為有界隊列已滿），"
"將呼叫 :meth:`~logging.Handler.handleError` "
"方法來處理錯誤。這可能會導致記錄被靜默刪除（如果 :attr:`logging."
"raiseExceptions` 為 ``False``）或將消息印出到 ``sys.stderr``（如果 "
":attr:`logging.raiseExceptions` 為 ` `真實``）。"

#: ../../library/logging.handlers.rst:1059
#, fuzzy
msgid ""
"Prepares a record for queuing. The object returned by this method is "
"enqueued."
msgstr "準備排隊記錄。此方法回傳的對像已入隊。"

#: ../../library/logging.handlers.rst:1062
#, fuzzy
msgid ""
"The base implementation formats the record to merge the message, arguments, "
"exception and stack information, if present.  It also removes unpickleable "
"items from the record in-place. Specifically, it overwrites the record's :"
"attr:`msg` and :attr:`message` attributes with the merged message (obtained "
"by calling the handler's :meth:`format` method), and sets the :attr:`args`, :"
"attr:`exc_info` and :attr:`exc_text` attributes to ``None``."
msgstr ""
"基本實作格式化記錄以合併消息、參數、例外和堆疊資訊（如果存在）。它還會就地從"
"記錄中刪除不可醃製的項目。具體來說，它用合併的消息（通過呼叫處理程式的 "
"format 方法獲得）覆蓋記錄的 :attr:`msg` 和 :attr:`message` 屬性，並設定 "
":attr:`args`： attr:`exc_info` 和 :attr:`exc_text` 屬性為 ``None``。"

#: ../../library/logging.handlers.rst:1070
#, fuzzy
msgid ""
"You might want to override this method if you want to convert the record to "
"a dict or JSON string, or send a modified copy of the record while leaving "
"the original intact."
msgstr "如果要將記錄轉換為字典或 JSON "
"字串，或者發送記錄的修改副本同時保持原始記錄不變，則可能需要重寫此方法。"

#: ../../library/logging.handlers.rst:1074
#, fuzzy
msgid ""
"The base implementation formats the message with arguments, sets the "
"``message`` and ``msg`` attributes to the formatted message and sets the "
"``args`` and ``exc_text`` attributes to ``None`` to allow pickling and to "
"prevent further attempts at formatting. This means that a handler on the :"
"class:`QueueListener` side won't have the information to do custom "
"formatting, e.g. of exceptions. You may wish to subclass ``QueueHandler`` "
"and override this method to e.g. avoid setting ``exc_text`` to ``None``. "
"Note that the ``message`` / ``msg`` / ``args`` changes are related to "
"ensuring the record is pickleable, and you might or might not be able to "
"avoid doing that depending on whether your ``args`` are pickleable. (Note "
"that you may have to consider not only your own code but also code in any "
"libraries that you use.)"
msgstr ""
"基本實作使用參數格式化消息，將``message``和``msg``屬性設定為格式化消息，並將`"
"`args``和``exc_text``屬性設定為``None``以允許酸洗並防止進一步嘗試格式化。"
"這意味著 :class:`QueueListener` 端的處理程式將沒有資訊來進行自定義格式化，例"
"如的例外。您可能希望將``QueueHandler`` 子類別化並覆蓋此方法，例如避免將 "
"``exc_text`` 設定為 ``None``。請注意，``message`` / ``msg`` / ``args`` "
"更改與確保記錄可醃製有關，您可能會或可能無法避免這樣做，具體取決於您的 "
"``args` ` 是可醃製的。 "
"（請注意，您可能不僅要考慮自己的程式碼，還要考慮您使用的任何庫中的程式碼。）"

#: ../../library/logging.handlers.rst:1090
#, fuzzy
msgid ""
"Enqueues the record on the queue using ``put_nowait()``; you may want to "
"override this if you want to use blocking behaviour, or a timeout, or a "
"customized queue implementation."
msgstr "使用 ``put_nowait()`` "
"將記錄排入隊列；如果你想使用阻塞行為、超時或自定義隊列實作，你可能想覆蓋它。"

#: ../../library/logging.handlers.rst:1099
msgid "QueueListener"
msgstr "QueueListener"

#: ../../library/logging.handlers.rst:1103
#, fuzzy
msgid ""
"The :class:`QueueListener` class, located in the :mod:`logging.handlers` "
"module, supports receiving logging messages from a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules. The "
"messages are received from a queue in an internal thread and passed, on the "
"same thread, to one or more handlers for processing. While :class:"
"`QueueListener` is not itself a handler, it is documented here because it "
"works hand-in-hand with :class:`QueueHandler`."
msgstr ""
":class:`QueueListener` 類位於 :mod:`logging.handlers` "
"模組中，支援從隊列接收日誌消息，例如在 :mod:`queue` 或 :mod:`multiprocessing`"
" 模組中實作的消息.消息從內部執行緒中的隊列接收，並在同一執行緒上傳遞給一個或"
"多個處理程式進行處理。雖然 :class:`QueueListener` "
"本身不是處理程式，但在此處記錄了它，因為它與 :class:`QueueHandler` 協同工作。"

#: ../../library/logging.handlers.rst:1111
#, fuzzy
msgid ""
"Along with the :class:`QueueHandler` class, :class:`QueueListener` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""
"與 :class:`QueueHandler` 類一起，:class:`QueueListener` "
"可用於讓處理程式在與執行日誌記錄的執行緒不同的執行緒上完成工作。這在 Web 應用"
"程式和其他服務應用程式中很重要，在這些應用程式中，為客戶端提供服務的執行緒需"
"要盡快響應，而任何可能較慢的操作（例如通過 SMTPHandler "
"發送電子郵件）都在單獨的執行緒上完成。"

#: ../../library/logging.handlers.rst:1120
#, fuzzy
msgid ""
"Returns a new instance of the :class:`QueueListener` class. The instance is "
"initialized with the queue to send messages to and a list of handlers which "
"will handle entries placed on the queue. The queue can be any queue-like "
"object; it's passed as-is to the :meth:`dequeue` method, which needs to know "
"how to get messages from it. The queue is not *required* to have the task "
"tracking API (though it's used if available), which means that you can use :"
"class:`~queue.SimpleQueue` instances for *queue*."
msgstr ""
"回傳 :class:`QueueListener` 類的新實例。該實例使用要發送消息的隊列和處理程式"
"列表進行初始化，這些處理程式將處理放置在隊列中的條目。隊列可以是任何類似隊列"
"的物件；它按原樣傳遞給 dequeue "
"方法，該方法需要知道如何從中獲取消息。隊列不是*必需*擁有任務跟踪 "
"API（儘管它在可用時使用），這意味著您可以為*隊列*使用 :class:`~queue."
"SimpleQueue` 實例。"

#: ../../library/logging.handlers.rst:1131
#, fuzzy
msgid ""
"If ``respect_handler_level`` is ``True``, a handler's level is respected "
"(compared with the level for the message) when deciding whether to pass "
"messages to that handler; otherwise, the behaviour is as in previous Python "
"versions - to always pass each message to each handler."
msgstr ""
"如果 ``respect_handler_level`` 為 ``True``，則在決定是否將消息傳遞給處理程式"
"時考慮處理程式的級別（與消息的級別相比）；否則，行為與以前的 Python "
"版本一樣——始終將每條消息傳遞給每個處理程式。"

#: ../../library/logging.handlers.rst:1136
msgid "The ``respect_handler_level`` argument was added."
msgstr "新增 ``respect_handler_level`` 引數。"

#: ../../library/logging.handlers.rst:1141
#, fuzzy
msgid "Dequeues a record and return it, optionally blocking."
msgstr "將記錄出列並回傳，可選擇阻塞。"

#: ../../library/logging.handlers.rst:1143
#, fuzzy
msgid ""
"The base implementation uses ``get()``. You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr "基本實作使用``get()``。如果您想使用超時或使用自定義隊列實作，您可能需要重寫此"
"方法。"

#: ../../library/logging.handlers.rst:1149
#, fuzzy
msgid "Prepare a record for handling."
msgstr "做好處理記錄。"

#: ../../library/logging.handlers.rst:1151
#, fuzzy
msgid ""
"This implementation just returns the passed-in record. You may want to "
"override this method if you need to do any custom marshalling or "
"manipulation of the record before passing it to the handlers."
msgstr "此實作僅回傳傳入的記錄。如果在將記錄傳遞給處理程式之前需要對記錄進行任何自定"
"義編組或操作，則可能需要覆蓋此方法。"

#: ../../library/logging.handlers.rst:1157
#, fuzzy
msgid "Handle a record."
msgstr "處理記錄。"

#: ../../library/logging.handlers.rst:1159
#, fuzzy
msgid ""
"This just loops through the handlers offering them the record to handle. The "
"actual object passed to the handlers is that which is returned from :meth:"
"`prepare`."
msgstr "這只是循環遍歷處理程式，為它們提供要處理的記錄。傳遞給處理程式的實際對像是從 "
":meth:`prepare` 回傳的物件。"

#: ../../library/logging.handlers.rst:1165
#, fuzzy
msgid "Starts the listener."
msgstr "啟動偵聽器。"

#: ../../library/logging.handlers.rst:1167
#, fuzzy
msgid ""
"This starts up a background thread to monitor the queue for LogRecords to "
"process."
msgstr "這將啟動一個後台執行緒來監視要處理的 LogRecords 隊列。"

#: ../../library/logging.handlers.rst:1172
#, fuzzy
msgid "Stops the listener."
msgstr "停止聽眾。"

#: ../../library/logging.handlers.rst:1174
#, fuzzy
msgid ""
"This asks the thread to terminate, and then waits for it to do so. Note that "
"if you don't call this before your application exits, there may be some "
"records still left on the queue, which won't be processed."
msgstr "這要求執行緒終止，然後等待它這樣做。請注意，如果您在應用程式退出之前未呼叫此"
"方法，則隊列中可能仍有一些記錄不會被處理。"

#: ../../library/logging.handlers.rst:1180
#, fuzzy
msgid ""
"Writes a sentinel to the queue to tell the listener to quit. This "
"implementation uses ``put_nowait()``.  You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr "將哨兵寫入隊列以告知偵聽器退出。此實作使用 ``put_nowait()``。如果您想使用超時"
"或使用自定義隊列實作，您可能需要重寫此方法。"

#: ../../library/logging.handlers.rst:1191
msgid "Module :mod:`logging`"
msgstr ":mod:`logging` 模組"

#: ../../library/logging.handlers.rst:1191
#, fuzzy
msgid "API reference for the logging module."
msgstr "日誌記錄模組的 API 參考。"

#: ../../library/logging.handlers.rst:1193
msgid "Module :mod:`logging.config`"
msgstr ":mod:`logging.config` 模組"

#: ../../library/logging.handlers.rst:1194
#, fuzzy
msgid "Configuration API for the logging module."
msgstr "日誌記錄模組的配置 API。"
