# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-28 00:15+0000\n"
"PO-Revision-Date: 2018-05-23 16:05+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/logging.config.rst:2
msgid ":mod:`logging.config` --- Logging configuration"
msgstr ":mod:`logging.config` --- 日誌記錄配置"

#: ../../library/logging.config.rst:10
msgid "**Source code:** :source:`Lib/logging/config.py`"
msgstr "**原始碼：**\\ :source:`Lib/logging/config.py`"

#: ../../library/logging.config.rst:14
#, fuzzy
msgid ""
"This page contains only reference information. For tutorials, please see"
msgstr "此頁面僅包含參考資訊。有關教程，請參閱"

#: ../../library/logging.config.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`基礎教學 <logging-basic-tutorial>`"

#: ../../library/logging.config.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`進階教學 <logging-advanced-tutorial>`"

#: ../../library/logging.config.rst:19
#, fuzzy
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`Logging Cookbook <logging-cookbook>`"

#: ../../library/logging.config.rst:23
#, fuzzy
msgid "This section describes the API for configuring the logging module."
msgstr "本節介紹用於配置日誌記錄模組的 API。"

#: ../../library/logging.config.rst:28
#, fuzzy
msgid "Configuration functions"
msgstr "配置函式"

#: ../../library/logging.config.rst:30
#, fuzzy
msgid ""
"The following functions configure the logging module. They are located in "
"the :mod:`logging.config` module.  Their use is optional --- you can "
"configure the logging module using these functions or by making calls to the "
"main API (defined in :mod:`logging` itself) and defining handlers which are "
"declared either in :mod:`logging` or :mod:`logging.handlers`."
msgstr ""
"以下函式配置日誌記錄模組。它們位於 :mod:`logging.config` "
"模組中。它們的使用是可選的——您可以使用這些函式或通過呼叫主要 API（在 "
":mod:`logging` 本身中定義）並定義在 :mod:`logging` 或 :mod:`logging."
"handlers`。"

#: ../../library/logging.config.rst:38
#, fuzzy
msgid ""
"Takes the logging configuration from a dictionary.  The contents of this "
"dictionary are described in :ref:`logging-config-dictschema` below."
msgstr "從字典中獲取日誌記錄配置。這個字典的內容在下面的 logging-config-dictschema "
"中描述。"

#: ../../library/logging.config.rst:42
#, fuzzy
msgid ""
"If an error is encountered during configuration, this function will raise a :"
"exc:`ValueError`, :exc:`TypeError`, :exc:`AttributeError` or :exc:"
"`ImportError` with a suitably descriptive message.  The following is a "
"(possibly incomplete) list of conditions which will raise an error:"
msgstr ""
"如果在配置期間遇到錯誤，此函式將引發 "
":exc:`ValueError`、:exc:`TypeError`、:exc:`AttributeError` 或 "
":exc:`ImportError` "
"以及適當的描述性消息。以下是一個（可能不完整）會引發錯誤的條件列表："

#: ../../library/logging.config.rst:48
#, fuzzy
msgid ""
"A ``level`` which is not a string or which is a string not corresponding to "
"an actual logging level."
msgstr "不是字串或與實際日誌記錄級別不對應的字串的“級別”。"

#: ../../library/logging.config.rst:50
#, fuzzy
msgid "A ``propagate`` value which is not a boolean."
msgstr "不是布爾值的“傳播”值。"

#: ../../library/logging.config.rst:51
#, fuzzy
msgid "An id which does not have a corresponding destination."
msgstr "沒有相應目的地的 ID。"

#: ../../library/logging.config.rst:52
#, fuzzy
msgid "A non-existent handler id found during an incremental call."
msgstr "在增量呼叫期間發現不存在的處理程式 ID。"

#: ../../library/logging.config.rst:53
#, fuzzy
msgid "An invalid logger name."
msgstr "無效的記錄器名稱。"

#: ../../library/logging.config.rst:54
#, fuzzy
msgid "Inability to resolve to an internal or external object."
msgstr "無法解析為內部或外部物件。"

#: ../../library/logging.config.rst:56
#, fuzzy
msgid ""
"Parsing is performed by the :class:`DictConfigurator` class, whose "
"constructor is passed the dictionary used for configuration, and has a :meth:"
"`configure` method.  The :mod:`logging.config` module has a callable "
"attribute :attr:`dictConfigClass` which is initially set to :class:"
"`DictConfigurator`. You can replace the value of :attr:`dictConfigClass` "
"with a suitable implementation of your own."
msgstr ""
"解析由 DictConfigurator 類執行，其構造函式傳遞用於配置的字典，並具有 "
":meth:`configure` 方法。 :mod:`logging.config` 模組有一個可呼叫屬性 "
":attr:`dictConfigClass` 最初設定為 :class:`DictConfigurator`。您可以將 "
":attr:`dictConfigClass` 的值替換為您自己的合適實作。"

#: ../../library/logging.config.rst:64
#, fuzzy
msgid ""
":func:`dictConfig` calls :attr:`dictConfigClass` passing the specified "
"dictionary, and then calls the :meth:`configure` method on the returned "
"object to put the configuration into effect::"
msgstr ""
":func:`dictConfig` 呼叫 :attr:`dictConfigClass` "
"傳入指定的字典，然後在回傳的對像上呼叫 :meth:`configure` 方法使配置生效::"

#: ../../library/logging.config.rst:71
#, fuzzy
msgid ""
"For example, a subclass of :class:`DictConfigurator` could call "
"``DictConfigurator.__init__()`` in its own :meth:`__init__()`, then set up "
"custom prefixes which would be usable in the subsequent :meth:`configure` "
"call. :attr:`dictConfigClass` would be bound to this new subclass, and then :"
"func:`dictConfig` could be called exactly as in the default, uncustomized "
"state."
msgstr ""
"例如，DictConfigurator 的子類別可以在其自己的 __init__() 中呼叫 "
"DictConfigurator.__init__()``，然後設定可在後續 :meth 中使用的自定義前綴： "
"`configure` 呼叫。 :attr:`dictConfigClass` 將綁定到這個新的子類別，然後 "
":func:`dictConfig` 可以完全按照預設的未自定義狀態呼叫。"

#: ../../library/logging.config.rst:82
#, fuzzy
msgid ""
"Reads the logging configuration from a :mod:`configparser`\\-format file. "
"The format of the file should be as described in :ref:`logging-config-"
"fileformat`. This function can be called several times from an application, "
"allowing an end user to select from various pre-canned configurations (if "
"the developer provides a mechanism to present the choices and load the "
"chosen configuration)."
msgstr ""
"從 :mod:`configparser`\\-format 文件中讀取日誌記錄配置。文件格式應如 :ref"
":`logging-config-fileformat` 中所述。可以從應用程式中多次呼叫此函式，允許最終"
"使用者從各種預裝配置中進行選擇（如果開發人員提供了一種機制來呈現選擇並加載所"
"選配置）。"

#: ../../library/logging.config.rst:0
msgid "Parameters"
msgstr "參數"

#: ../../library/logging.config.rst:90
#, fuzzy
msgid ""
"A filename, or a file-like object, or an instance derived from :class:"
"`~configparser.RawConfigParser`. If a ``RawConfigParser``-derived instance "
"is passed, it is used as is. Otherwise, a :class:`~configparser."
"Configparser` is instantiated, and the configuration read by it from the "
"object passed in ``fname``. If that has a :meth:`readline` method, it is "
"assumed to be a file-like object and read using :meth:`~configparser."
"ConfigParser.read_file`; otherwise, it is assumed to be a filename and "
"passed to :meth:`~configparser.ConfigParser.read`."
msgstr ""
"文件名，或類似文件的物件，或派生自 :class:`~configparser.RawConfigParser` 的"
"實例。如果傳遞了``RawConfigParser``派生的實例，則按原樣使用。否則，將實例化一"
"個 :class:`~configparser.Configparser`，並從傳入``fname`` 的對像中讀取配置。"
"如果它有 :meth:`readline` 方法，則假定它是一個類文件物件並使用 "
":meth:`~configparser.ConfigParser.read_file` 讀取；否則，"
"它被假定為一個文件名並傳遞給 :meth:`~configparser.ConfigParser.read`。"

#: ../../library/logging.config.rst:102
#, fuzzy
msgid ""
"Defaults to be passed to the ConfigParser can be specified in this argument."
msgstr "可以在此參數中指定要傳遞給 ConfigParser 的預設值。"

#: ../../library/logging.config.rst:105
#, fuzzy
msgid ""
"If specified as ``False``, loggers which                                 "
"exist when this call is made are left                                 "
"enabled. The default is ``True`` because "
"this                                 enables old behaviour in "
"a                                 backward-compatible way. This behaviour is "
"to                                 disable any existing non-root loggers "
"unless                                 they or their ancestors are "
"explicitly named                                 in the logging "
"configuration.  :param encoding: The encoding used to open file when *fname* "
"is filename."
msgstr ""
"如果指定為 ``False``，則在進行此呼叫時存在的記錄器將保持啟用狀態。預設值為 ``True``"
"，因為這會以向後相容的方式啟用舊行為。此行為是禁用任何現有的非根記錄器，除非"
"它們或它們的祖先在日誌記錄配置中明確命名。 :param encoding: 當*fname* "
"為文件名時用於打開文件的編碼。"

#: ../../library/logging.config.rst:112
#, fuzzy
msgid "If specified as ``False``, loggers which"
msgstr "如果指定為 ``False``，記錄器"

#: ../../library/logging.config.rst:106
#, fuzzy
msgid ""
"exist when this call is made are left enabled. The default is ``True`` "
"because this enables old behaviour in a backward-compatible way. This "
"behaviour is to disable any existing non-root loggers unless they or their "
"ancestors are explicitly named in the logging configuration."
msgstr ""
"進行此呼叫時存在。預設值為 ``True``，因為這會以向後相容的方式啟用舊行為。此行為"
"是禁用任何現有的非根記錄器，除非它們或它們的祖先在日誌記錄配置中明確命名。"

#: ../../library/logging.config.rst:0
#, fuzzy
msgid "param encoding"
msgstr "參數編碼"

#: ../../library/logging.config.rst:114
#, fuzzy
msgid "The encoding used to open file when *fname* is filename."
msgstr "*fname* 為文件名時用於打開文件的編碼。"

#: ../../library/logging.config.rst:116
#, fuzzy
msgid ""
"An instance of a subclass of :class:`~configparser.RawConfigParser` is   now "
"accepted as a value for ``fname``. This facilitates:"
msgstr ":class:`~configparser.RawConfigParser` 的子類別實例現在被接受為``fname`` "
"的值。這有利於："

#: ../../library/logging.config.rst:120
#, fuzzy
msgid ""
"Use of a configuration file where logging configuration is just part of the "
"overall application configuration."
msgstr "使用配置文件，其中日誌記錄配置只是整個應用程式配置的一部分。"

#: ../../library/logging.config.rst:122
#, fuzzy
msgid ""
"Use of a configuration read from a file, and then modified by the using "
"application (e.g. based on command-line parameters or other aspects of the "
"runtime environment) before being passed to ``fileConfig``."
msgstr "使用從文件中讀取的配置，然後在傳遞給 ``fileConfig`` "
"之前由使用應用程式修改（例如，基於命令列參數或運行時環境的其他方面）。"

#: ../../library/logging.config.rst:126
#, fuzzy
msgid "The *encoding* parameter is added."
msgstr "新增了 *encoding* 參數。"

#: ../../library/logging.config.rst:131
#, fuzzy
msgid ""
"Starts up a socket server on the specified port, and listens for new "
"configurations. If no port is specified, the module's default :const:"
"`DEFAULT_LOGGING_CONFIG_PORT` is used. Logging configurations will be sent "
"as a file suitable for processing by :func:`dictConfig` or :func:"
"`fileConfig`. Returns a :class:`~threading.Thread` instance on which you can "
"call :meth:`~threading.Thread.start` to start the server, and which you can :"
"meth:`~threading.Thread.join` when appropriate. To stop the server, call :"
"func:`stopListening`."
msgstr ""
"在指定端口上啟動 socket 伺服器，並偵聽新配置。如果未指定端口，則使用模組的預設"
"值 :const:`DEFAULT_LOGGING_CONFIG_PORT`。日誌記錄配置將作為適合 "
":func:`dictConfig` 或 :func:`fileConfig` 處理的文件發送。回傳一個 "
":class:`~threading.Thread` 實例，您可以在該實例上呼叫 :meth:`~threading."
"Thread.start` 來啟動伺服器，並且可以在適當的時候 :meth:`~threading.Thread."
"join` .要停止伺服器，請呼叫 :func:`stopListening`。"

#: ../../library/logging.config.rst:140
#, fuzzy
msgid ""
"The ``verify`` argument, if specified, should be a callable which should "
"verify whether bytes received across the socket are valid and should be "
"processed. This could be done by encrypting and/or signing what is sent "
"across the socket, such that the ``verify`` callable can perform signature "
"verification and/or decryption. The ``verify`` callable is called with a "
"single argument - the bytes received across the socket - and should return "
"the bytes to be processed, or ``None`` to indicate that the bytes should be "
"discarded. The returned bytes could be the same as the passed in bytes (e.g. "
"when only verification is done), or they could be completely different "
"(perhaps if decryption were performed)."
msgstr ""
"``verify`` 參數，如果指定的話，應該是一個可呼叫的，它應該驗證通過 socket 接收的"
"位元組是否有效並且應該被處理。這可以通過對通過 socket 發送的內容進行加密和/或簽"
"名來完成，這樣 ``verify`` 可呼叫函式可以執行簽名驗證和/或解密。 ``verify`` "
"可呼叫函式使用單個參數呼叫 - 通過 socket 接收的位元組 - "
"並且應該回傳要處理的位元組，或者 ``None`` 表示應該丟棄這些位元組。回傳的位元"
"組可能與傳入的位元組相同（例如，僅完成驗證時），或者它們可能完全不同（可能如"
"果執行了解密）。"

#: ../../library/logging.config.rst:151
#, fuzzy
msgid ""
"To send a configuration to the socket, read in the configuration file and "
"send it to the socket as a sequence of bytes preceded by a four-byte length "
"string packed in binary using ``struct.pack('>L', n)``."
msgstr ""
"要將配置發送到 socket ，請讀入配置文件並將其作為位元組序列發送到 socket ，"
"前面是使用 ``struct.pack('>L', n)` 以二進位形式打包的四位元組長度字串`。"

#: ../../library/logging.config.rst:159
#, fuzzy
msgid ""
"Because portions of the configuration are passed through :func:`eval`, use "
"of this function may open its users to a security risk. While the function "
"only binds to a socket on ``localhost``, and so does not accept connections "
"from remote machines, there are scenarios where untrusted code could be run "
"under the account of the process which calls :func:`listen`. Specifically, "
"if the process calling :func:`listen` runs on a multi-user machine where "
"users cannot trust each other, then a malicious user could arrange to run "
"essentially arbitrary code in a victim user's process, simply by connecting "
"to the victim's :func:`listen` socket and sending a configuration which runs "
"whatever code the attacker wants to have executed in the victim's process. "
"This is especially easy to do if the default port is used, but not hard even "
"if a different port is used. To avoid the risk of this happening, use the "
"``verify`` argument to :func:`listen` to prevent unrecognised configurations "
"from being applied."
msgstr ""
"由於部分配置是通過 eval 傳遞的，因此使用此功能可能會使使用者面臨安全風險。"
"雖然該函式僅綁定到 ``localhost`` "
"上的 socket ，因此不接受來自遠程機器的連接，但在某些情況下，"
"不受信任的程式碼可能會在呼叫 :func:`listen` 的行程的帳戶下運行。具體來說，"
"如果呼叫 :func:`listen` 的行程在使用者無法相互信任的多使用者機器上運行，那麼"
"惡意使用者可以安排在受害使用者的行程中運行基本上任意的程式碼，只需連接到受害"
"者的： func:`listen`  socket 並發送一個配置，該配置運行攻擊者想要在受害者行程中"
"執行的任何程式碼。如果使用預設端口，這尤其容易做到，但即使使用不同的端口也不"
"難。為避免發生這種情況的風險，請使用 ``verify`` 參數到 :func:`listen` "
"以防止應用無法識別的配置。"

#: ../../library/logging.config.rst:175
msgid "The ``verify`` argument was added."
msgstr "新增 ``verify`` 引數。"

#: ../../library/logging.config.rst:180
#, fuzzy
msgid ""
"If you want to send configurations to the listener which don't disable "
"existing loggers, you will need to use a JSON format for the configuration, "
"which will use :func:`dictConfig` for configuration. This method allows you "
"to specify ``disable_existing_loggers`` as ``False`` in the configuration "
"you send."
msgstr ""
"如果您想將配置發送到不禁用現有記錄器的偵聽器，則需要使用 JSON 格式進行配置，"
"這將使用 :func:`dictConfig` 進行配置。此方法允許您在發送的配置中將 "
"``disable_existing_loggers`` 指定為 ``False``。"

#: ../../library/logging.config.rst:189
#, fuzzy
msgid ""
"Stops the listening server which was created with a call to :func:`listen`. "
"This is typically called before calling :meth:`join` on the return value "
"from :func:`listen`."
msgstr ""
"停止通過呼叫 :func:`listen` 建立的監聽伺服器。這通常在呼叫 :meth:`join` 從 "
":func:`listen` 的回傳值之前呼叫。"

#: ../../library/logging.config.rst:195
#, fuzzy
msgid "Security considerations"
msgstr "安全考慮"

#: ../../library/logging.config.rst:197
#, fuzzy
msgid ""
"The logging configuration functionality tries to offer convenience, and in "
"part this is done by offering the ability to convert text in configuration "
"files into Python objects used in logging configuration - for example, as "
"described in :ref:`logging-config-dict-userdef`. However, these same "
"mechanisms (importing callables from user-defined modules and calling them "
"with parameters from the configuration) could be used to invoke any code you "
"like, and for this reason you should treat configuration files from "
"untrusted sources with *extreme caution* and satisfy yourself that nothing "
"bad can happen if you load them, before actually loading them."
msgstr ""
"日誌配置功能試圖提供便利，"
"部分是通過提供將配置文件中的文本轉換為日誌配置中使用的 Python "
"物件的能力來實作的——例如，如 :ref:`logging-config-dict-userdef 中所述`。然而"
"，這些相同的機制（從使用者定義的模組導入可呼叫物件並使用配置中的參數呼叫它們"
"）可用於呼叫您喜歡的任何程式碼，因此您應該*極其謹慎*地對待來自不受信任來源的"
"配置文件，並且在實際加載它們之前，讓自己確信如果加載它們不會發生任何不好的事"
"情。"

#: ../../library/logging.config.rst:211
#, fuzzy
msgid "Configuration dictionary schema"
msgstr "配置字典架構"

#: ../../library/logging.config.rst:213
#, fuzzy
msgid ""
"Describing a logging configuration requires listing the various objects to "
"create and the connections between them; for example, you may create a "
"handler named 'console' and then say that the logger named 'startup' will "
"send its messages to the 'console' handler. These objects aren't limited to "
"those provided by the :mod:`logging` module because you might write your own "
"formatter or handler class. The parameters to these classes may also need to "
"include external objects such as ``sys.stderr``.  The syntax for describing "
"these objects and connections is defined in :ref:`logging-config-dict-"
"connections` below."
msgstr ""
"描述日誌記錄配置需要列出要建立的各種對像以及它們之間的連接；例如，您可以建立"
"一個名為 ``console`` 的處理程式，然後說名為 ``startup`` 的記錄器會將其消息發送到“cons"
"ole”處理程式。這些對像不限於 :mod:`logging` 模組提供的物件，因為您可以編寫自"
"己的格式化程式或處理程式類。這些類的參數可能還需要包括外部物件，例如“sys."
"stderr”。描述這些物件和連接的語法在下面的 logging-config-dict-connections "
"中定義。"

#: ../../library/logging.config.rst:225
#, fuzzy
msgid "Dictionary Schema Details"
msgstr "字典模式詳細資訊"

#: ../../library/logging.config.rst:227
#, fuzzy
msgid ""
"The dictionary passed to :func:`dictConfig` must contain the following keys:"
msgstr "傳遞給 :func:`dictConfig` 的字典必須包含以下鍵："

#: ../../library/logging.config.rst:230
#, fuzzy
msgid ""
"*version* - to be set to an integer value representing the schema version.  "
"The only valid value at present is 1, but having this key allows the schema "
"to evolve while still preserving backwards compatibility."
msgstr "*version* - 設定為表示模式版本的整數值。目前唯一有效的值是 "
"1，但擁有此鍵允許架構在保持向後相容性的同時發展。"

#: ../../library/logging.config.rst:235
#, fuzzy
msgid ""
"All other keys are optional, but if present they will be interpreted as "
"described below.  In all cases below where a 'configuring dict' is "
"mentioned, it will be checked for the special ``'()'`` key to see if a "
"custom instantiation is required.  If so, the mechanism described in :ref:"
"`logging-config-dict-userdef` below is used to create an instance; "
"otherwise, the context is used to determine what to instantiate."
msgstr ""
"所有其他鍵都是可選的，但如果存在，它們將按如下所述進行解釋。在下面提到“配置字"
"典”的所有情況下，將檢查特殊的“()”鍵以查看是否需要自定義實例化。如果是這樣，"
"下面 :ref:`logging-config-dict-userdef` "
"中描述的機制用於建立實例；否則，上下文用於確定要實例化的內容。"

#: ../../library/logging.config.rst:244
#, fuzzy
msgid ""
"*formatters* - the corresponding value will be a dict in which each key is a "
"formatter id and each value is a dict describing how to configure the "
"corresponding :class:`~logging.Formatter` instance."
msgstr ""
"*formatters* - 相應的值將是一個字典，其中每個鍵都是一個格式化程式 ID，"
"每個值都是一個描述如何配置相應 :class:`~logging.Formatter` 實例的字典。"

#: ../../library/logging.config.rst:248
#, fuzzy
msgid ""
"The configuring dict is searched for the following optional keys which "
"correspond to the arguments passed to create a :class:`~logging.Formatter` "
"object:"
msgstr "在配置字典中搜索以下可選鍵，這些鍵對應於傳遞給建立 :class:`~logging."
"Formatter` 物件的參數："

#: ../../library/logging.config.rst:252
msgid "``format``"
msgstr "``format``"

#: ../../library/logging.config.rst:253
msgid "``datefmt``"
msgstr "``datefmt``"

#: ../../library/logging.config.rst:254
msgid "``style``"
msgstr "``style``"

#: ../../library/logging.config.rst:255
#, fuzzy
msgid "``validate`` (since version >=3.8)"
msgstr "``驗證``（自版本 >=3.8 起）"

#: ../../library/logging.config.rst:257
#, fuzzy
msgid ""
"An optional ``class`` key indicates the name of the formatter's class (as a "
"dotted module and class name).  The instantiation arguments are as for :"
"class:`~logging.Formatter`, thus this key is most useful for instantiating a "
"customised subclass of :class:`~logging.Formatter`.  For example, the "
"alternative class might present exception tracebacks in an expanded or "
"condensed format.  If your formatter requires different or extra "
"configuration keys, you should use :ref:`logging-config-dict-userdef`."
msgstr ""
"可選的 ``class`` 鍵指示格式化程式類的名稱（作為帶點的模組和類名）。"
"實例化參數與 :class:`~logging.Formatter` 一樣，因此此鍵對於實例化 "
":class:`~logging.Formatter` 的自定義子類別最有用。例如，替代類可能會以擴充或"
"壓縮格式呈現例外回溯。如果你的格式化程式需要不同的或額外的配置鍵，你應該使用 "
":ref:`logging-config-dict-userdef`。"

#: ../../library/logging.config.rst:266
#, fuzzy
msgid ""
"*filters* - the corresponding value will be a dict in which each key is a "
"filter id and each value is a dict describing how to configure the "
"corresponding Filter instance."
msgstr "*filters* - 相應的值將是一個字典，其中每個鍵都是一個過濾器 ID，"
"每個值都是一個描述如何配置相應 Filter 實例的字典。"

#: ../../library/logging.config.rst:270
#, fuzzy
msgid ""
"The configuring dict is searched for the key ``name`` (defaulting to the "
"empty string) and this is used to construct a :class:`logging.Filter` "
"instance."
msgstr "在配置字典中搜索鍵 ``name``（預設為空字串），這用於構造一個 :class:`logging."
"Filter` 實例。"

#: ../../library/logging.config.rst:274
#, fuzzy
msgid ""
"*handlers* - the corresponding value will be a dict in which each key is a "
"handler id and each value is a dict describing how to configure the "
"corresponding Handler instance."
msgstr "*handlers* - 相應的值將是一個字典，其中每個鍵都是一個處理程式 "
"ID，每個值都是一個描述如何配置相應的處理程式實例的字典。"

#: ../../library/logging.config.rst:278 ../../library/logging.config.rst:323
#, fuzzy
msgid "The configuring dict is searched for the following keys:"
msgstr "在配置字典中搜索以下鍵："

#: ../../library/logging.config.rst:280
#, fuzzy
msgid ""
"``class`` (mandatory).  This is the fully qualified name of the handler "
"class."
msgstr "``類``（強制性的）。這是處理程式類的完全限定名稱。"

#: ../../library/logging.config.rst:283
#, fuzzy
msgid "``level`` (optional).  The level of the handler."
msgstr "``級別``（可選）。處理程式的級別。"

#: ../../library/logging.config.rst:285
#, fuzzy
msgid "``formatter`` (optional).  The id of the formatter for this handler."
msgstr "``格式化程式``（可選）。此處理程式的格式化程式的 ID。"

#: ../../library/logging.config.rst:288
#, fuzzy
msgid "``filters`` (optional).  A list of ids of the filters for this handler."
msgstr "``過濾器``（可選）。此處理程式的過濾器 ID 列表。"

#: ../../library/logging.config.rst:291 ../../library/logging.config.rst:332
#, fuzzy
msgid "``filters`` can take filter instances in addition to ids."
msgstr "``filters`` 除了 ids 之外還可以採用過濾器實例。"

#: ../../library/logging.config.rst:294
#, fuzzy
msgid ""
"All *other* keys are passed through as keyword arguments to the handler's "
"constructor.  For example, given the snippet:"
msgstr "所有 *other* 鍵都作為關鍵字參數傳遞給處理程式的構造函式。例如，給定片段："

#: ../../library/logging.config.rst:313
#, fuzzy
msgid ""
"the handler with id ``console`` is instantiated as a :class:`logging."
"StreamHandler`, using ``sys.stdout`` as the underlying stream.  The handler "
"with id ``file`` is instantiated as a :class:`logging.handlers."
"RotatingFileHandler` with the keyword arguments ``filename='logconfig.log', "
"maxBytes=1024, backupCount=3``."
msgstr ""
"帶有 id ``console`` 的處理程式被實例化為 logging.StreamHandler`，使用 ``sys."
"stdout`` 作為基礎流。 ID 為 ``file``的處理程式被實例化為一個 logging.handlers."
"RotatingFileHandler，關鍵字參數為“filename='logconfig.log', maxBytes=1024, "
"backupCount=3”。"

#: ../../library/logging.config.rst:319
#, fuzzy
msgid ""
"*loggers* - the corresponding value will be a dict in which each key is a "
"logger name and each value is a dict describing how to configure the "
"corresponding Logger instance."
msgstr "*loggers* - 相應的值將是一個字典，其中每個鍵都是一個記錄器名稱，"
"每個值都是一個描述如何配置相應的 Logger 實例的字典。"

#: ../../library/logging.config.rst:325
#, fuzzy
msgid "``level`` (optional).  The level of the logger."
msgstr "``級別``（可選）。記錄器的級別。"

#: ../../library/logging.config.rst:327
#, fuzzy
msgid "``propagate`` (optional).  The propagation setting of the logger."
msgstr "``傳播``（可選）。記錄器的傳播設定。"

#: ../../library/logging.config.rst:329
#, fuzzy
msgid "``filters`` (optional).  A list of ids of the filters for this logger."
msgstr "``過濾器``（可選）。此記錄器的過濾器 ID 列表。"

#: ../../library/logging.config.rst:335
#, fuzzy
msgid ""
"``handlers`` (optional).  A list of ids of the handlers for this logger."
msgstr "``處理程式``（可選）。此記錄器的處理程式的 ID 列表。"

#: ../../library/logging.config.rst:338
#, fuzzy
msgid ""
"The specified loggers will be configured according to the level, "
"propagation, filters and handlers specified."
msgstr "指定的記錄器將根據指定的級別、傳播、過濾器和處理程式進行配置。"

#: ../../library/logging.config.rst:341
#, fuzzy
msgid ""
"*root* - this will be the configuration for the root logger. Processing of "
"the configuration will be as for any logger, except that the ``propagate`` "
"setting will not be applicable."
msgstr "*root* - 這將是根記錄器的配置。配置的處理將與任何記錄器一樣，除了 "
"``propagate`` 設定將不適用。"

#: ../../library/logging.config.rst:345
#, fuzzy
msgid ""
"*incremental* - whether the configuration is to be interpreted as "
"incremental to the existing configuration.  This value defaults to "
"``False``, which means that the specified configuration replaces the "
"existing configuration with the same semantics as used by the existing :func:"
"`fileConfig` API."
msgstr ""
"*增量* - 配置是否被解釋為對現有配置的增量。此值預設為 ``False``，"
"這意味著指定的配置將使用與現有 :func:`fileConfig` API "
"使用的語義相同的語義替換現有配置。"

#: ../../library/logging.config.rst:351
#, fuzzy
msgid ""
"If the specified value is ``True``, the configuration is processed as "
"described in the section on :ref:`logging-config-dict-incremental`."
msgstr "如果指定值為 ``True``，則按照 logging-config-dict-incremental "
"部分中的描述處理配置。"

#: ../../library/logging.config.rst:354
#, fuzzy
msgid ""
"*disable_existing_loggers* - whether any existing non-root loggers are to be "
"disabled. This setting mirrors the parameter of the same name in :func:"
"`fileConfig`. If absent, this parameter defaults to ``True``. This value is "
"ignored if *incremental* is ``True``."
msgstr ""
"*disable_existing_loggers* - 是否要禁用任何現有的非根記錄器。此設定反映了 "
":func:`fileConfig` 中的同名參數。如果不存在，則此參數預設為 ``True``。如果 "
"*incremental* 為 ``True``，則忽略此值。"

#: ../../library/logging.config.rst:362
#, fuzzy
msgid "Incremental Configuration"
msgstr "增量配置"

#: ../../library/logging.config.rst:364
#, fuzzy
msgid ""
"It is difficult to provide complete flexibility for incremental "
"configuration.  For example, because objects such as filters and formatters "
"are anonymous, once a configuration is set up, it is not possible to refer "
"to such anonymous objects when augmenting a configuration."
msgstr "很難為增量配置提供完整的靈活性。例如，因為過濾器和格式化程式等對像是匿名的，"
"一旦設定了配置，就不可能在擴充配置時引用此類匿名物件。"

#: ../../library/logging.config.rst:370
#, fuzzy
msgid ""
"Furthermore, there is not a compelling case for arbitrarily altering the "
"object graph of loggers, handlers, filters, formatters at run-time, once a "
"configuration is set up; the verbosity of loggers and handlers can be "
"controlled just by setting levels (and, in the case of loggers, propagation "
"flags).  Changing the object graph arbitrarily in a safe way is problematic "
"in a multi-threaded environment; while not impossible, the benefits are not "
"worth the complexity it adds to the implementation."
msgstr ""
"此外，一旦設定了配置，就沒有必要在運行時任意更改記錄器、處理程式、過濾器、格"
"式化程式的對像圖；記錄器和處理程式的冗長程度可以通過設定級別來控制（對於記錄"
"器，還有傳播旗標）。以安全的方式任意更改對像圖在多執行緒環境中是有問題的；雖"
"然並非不可能，但其帶來的好處不值得為實施增加複雜性。"

#: ../../library/logging.config.rst:379
#, fuzzy
msgid ""
"Thus, when the ``incremental`` key of a configuration dict is present and is "
"``True``, the system will completely ignore any ``formatters`` and "
"``filters`` entries, and process only the ``level`` settings in the "
"``handlers`` entries, and the ``level`` and ``propagate`` settings in the "
"``loggers`` and ``root`` entries."
msgstr ""
"因此，當配置字典的 ``incremental`` 鍵存在且為 ``True``時，系統將完全忽略任何“formatt"
"ers”和 ``filters`` 條目，並僅處理 ``level`` ``handlers`` 條目中的`` "
"設定，以及``loggers`` 和``root`` 條目中的``level`` 和``propagate`` 設定。"

#: ../../library/logging.config.rst:385
#, fuzzy
msgid ""
"Using a value in the configuration dict lets configurations to be sent over "
"the wire as pickled dicts to a socket listener. Thus, the logging verbosity "
"of a long-running application can be altered over time with no need to stop "
"and restart the application."
msgstr ""
"在配置字典中使用一個值可以讓配置作為醃製字典通過網絡發送到 socket 偵聽器。因此"
"，長時間運行的應用程式的日誌記錄詳細程度可以隨著時間的推移而改變，而無需停止"
"並重新啟動應用程式。"

#: ../../library/logging.config.rst:393
#, fuzzy
msgid "Object connections"
msgstr "物件連接"

#: ../../library/logging.config.rst:395
#, fuzzy
msgid ""
"The schema describes a set of logging objects - loggers, handlers, "
"formatters, filters - which are connected to each other in an object graph.  "
"Thus, the schema needs to represent connections between the objects.  For "
"example, say that, once configured, a particular logger has attached to it a "
"particular handler.  For the purposes of this discussion, we can say that "
"the logger represents the source, and the handler the destination, of a "
"connection between the two.  Of course in the configured objects this is "
"represented by the logger holding a reference to the handler.  In the "
"configuration dict, this is done by giving each destination object an id "
"which identifies it unambiguously, and then using the id in the source "
"object's configuration to indicate that a connection exists between the "
"source and the destination object with that id."
msgstr ""
"該模式描述了一組日誌記錄物件——記錄器、處理程式、格式化程式、過濾器——它們在對"
"像圖中相互連接。因此，模式需要表示物件之間的連接。例如，假設一旦配置，一個特"
"定的記錄器就附加了一個特定的處理程式。出於討論的目的，我們可以說記錄器代表兩"
"者之間連接的源，處理程式代表目的地。當然，在配置的對像中，這由持有對處理程式"
"的引用的記錄器表示。在配置字典中，這是通過為每個目標物件提供一個明確標識它的 "
"id，然後在源物件的配置中使用該 id 來指示源物件和具有該 id "
"的目標物件之間存在連接來完成的。"

#: ../../library/logging.config.rst:409
#, fuzzy
msgid "So, for example, consider the following YAML snippet:"
msgstr "因此，例如，考慮以下 YAML 片段："

#: ../../library/logging.config.rst:430
#, fuzzy
msgid ""
"(Note: YAML used here because it's a little more readable than the "
"equivalent Python source form for the dictionary.)"
msgstr "（注意：此處使用 YAML 是因為它比字典的等效 Python 源程式碼形式更具可讀性。）"

#: ../../library/logging.config.rst:433
#, fuzzy
msgid ""
"The ids for loggers are the logger names which would be used "
"programmatically to obtain a reference to those loggers, e.g. ``foo.bar."
"baz``.  The ids for Formatters and Filters can be any string value (such as "
"``brief``, ``precise`` above) and they are transient, in that they are only "
"meaningful for processing the configuration dictionary and used to determine "
"connections between objects, and are not persisted anywhere when the "
"configuration call is complete."
msgstr ""
"記錄器的 id 是記錄器名稱，它將以編程方式用於獲取對這些記錄器的引用，例如``foo"
".bar.baz``。 Formatters 和 Filters 的 id 可以是任何字串值（例如上面的``brief`"
"`，``precise``）並且它們是瞬態的，因為它們僅對處理配置字典有意義並用於確定物"
"件之間的連接，並且在配置呼叫完成後不會在任何地方持久存在。"

#: ../../library/logging.config.rst:441
#, fuzzy
msgid ""
"The above snippet indicates that logger named ``foo.bar.baz`` should have "
"two handlers attached to it, which are described by the handler ids ``h1`` "
"and ``h2``. The formatter for ``h1`` is that described by id ``brief``, and "
"the formatter for ``h2`` is that described by id ``precise``."
msgstr ""
"上面的程式碼片段表明名為“foo.bar.baz”的記錄器應該附加兩個處理程式，"
"由處理程式 ID ``h1``和 ``h2``描述。 ``h1`` 的格式化程式是由 id ``brief`` "
"描述的，``h2`` 的格式化程式是由 id ``precise`` 描述的。"

#: ../../library/logging.config.rst:451
#, fuzzy
msgid "User-defined objects"
msgstr "使用者定義的物件"

#: ../../library/logging.config.rst:453
#, fuzzy
msgid ""
"The schema supports user-defined objects for handlers, filters and "
"formatters.  (Loggers do not need to have different types for different "
"instances, so there is no support in this configuration schema for user-"
"defined logger classes.)"
msgstr ""
"該架構支援用於處理程式、過濾器和格式化程式的使用者定義物件。 （記錄器不需要針"
"對不同的實例具有不同的型別，因此此配置模式不支援使用者定義的記錄器類。）"

#: ../../library/logging.config.rst:458
#, fuzzy
msgid ""
"Objects to be configured are described by dictionaries which detail their "
"configuration.  In some places, the logging system will be able to infer "
"from the context how an object is to be instantiated, but when a user-"
"defined object is to be instantiated, the system will not know how to do "
"this.  In order to provide complete flexibility for user-defined object "
"instantiation, the user needs to provide a 'factory' - a callable which is "
"called with a configuration dictionary and which returns the instantiated "
"object. This is signalled by an absolute import path to the factory being "
"made available under the special key ``'()'``.  Here's a concrete example:"
msgstr ""
"要配置的物件由詳細說明其配置的字典描述。在某些地方，日誌系統將能夠從上下文中"
"推斷出一個物件將如何被實例化，但是當一個使用者定義的物件將被實例化時，系統將"
"不知道如何去做。為了為使用者定義的物件實例化提供完全的靈活性，使用者需要提供"
"一個“工廠”——一個用配置字典呼叫並回傳實例化物件的可呼叫物件。這是通過在特殊鍵 "
"``'()'`` 下可用的工廠的絕對導入路徑來表示的。這是一個具體的例子："

#: ../../library/logging.config.rst:484
#, fuzzy
msgid ""
"The above YAML snippet defines three formatters.  The first, with id "
"``brief``, is a standard :class:`logging.Formatter` instance with the "
"specified format string.  The second, with id ``default``, has a longer "
"format and also defines the time format explicitly, and will result in a :"
"class:`logging.Formatter` initialized with those two format strings.  Shown "
"in Python source form, the ``brief`` and ``default`` formatters have "
"configuration sub-dictionaries::"
msgstr ""
"上面的 YAML 片段定義了三個格式化程式。第一個是帶有 id ``brief`` 的標準 "
"logging.Formatter 實例，具有指定的格式字串。第二個，帶有 id "
"``default``，具有更長的格式，還明確定義了時間格式，"
"並將導致使用這兩種格式字串初始化的 :class:`logging.Formatter`。以 Python "
"源程式碼形式顯示，``brief`` 和 ``default`` 格式化程式具有配置子字典："

#: ../../library/logging.config.rst:496
msgid "and::"
msgstr ""
"和：\n"
"\n"
"::"

#: ../../library/logging.config.rst:503
#, fuzzy
msgid ""
"respectively, and as these dictionaries do not contain the special key "
"``'()'``, the instantiation is inferred from the context: as a result, "
"standard :class:`logging.Formatter` instances are created.  The "
"configuration sub-dictionary for the third formatter, with id ``custom``, "
"is::"
msgstr ""
"分別，並且由於這些字典不包含特殊鍵 "
"``'()'``，實例化是從上下文中推斷出來的：因此，建立了標準的 logging.Formatter "
"實例。第三個格式化程式的配置子字典，id為 ``custom``，是："

#: ../../library/logging.config.rst:516
#, fuzzy
msgid ""
"and this contains the special key ``'()'``, which means that user-defined "
"instantiation is wanted.  In this case, the specified factory callable will "
"be used. If it is an actual callable it will be used directly - otherwise, "
"if you specify a string (as in the example) the actual callable will be "
"located using normal import mechanisms. The callable will be called with the "
"**remaining** items in the configuration sub-dictionary as keyword "
"arguments.  In the above example, the formatter with id ``custom`` will be "
"assumed to be returned by the call::"
msgstr ""
"這包含特殊鍵 ``'()'``，這意味著需要使用者定義的實例化。在這種情況下，將使用指"
"定的工廠可呼叫物件。如果它是一個實際的可呼叫物件，它將被直接使用 - 否則，如果"
"您指定一個字串（如示例中所示），實際的可呼叫物件將使用正常的導入機制定位。將"
"使用配置子字典中的**剩餘**項作為關鍵字參數呼叫可呼叫物件。在上面的示例中，id "
"為 ``custom``的格式化程式將被假定為由呼叫回傳："

#: ../../library/logging.config.rst:528
#, fuzzy
msgid ""
"The values for keys such as ``bar``, ``spam`` and ``answer`` in the above "
"example should not be configuration dictionaries or references such as "
"``cfg://foo`` or ``ext://bar``, because they will not be processed by the "
"configuration machinery, but passed to the callable as-is."
msgstr ""
"上例中 ``bar``、 ``spam``和 ``answer``等鍵的值不應是配置字典或引用，如“cfg://foo”或“ex"
"t”： //bar``，因為它們不會被配置機制處理，而是按原樣傳遞給可呼叫物件。"

#: ../../library/logging.config.rst:533
#, fuzzy
msgid ""
"The key ``'()'`` has been used as the special key because it is not a valid "
"keyword parameter name, and so will not clash with the names of the keyword "
"arguments used in the call.  The ``'()'`` also serves as a mnemonic that the "
"corresponding value is a callable."
msgstr ""
"鍵 ``'()'`` 已被用作特殊鍵，因為它不是有效的關鍵字參數名稱，因此不會與呼叫中"
"使用的關鍵字參數名稱衝突。 ``'()'`` 也用作相應值可呼叫的助記符。"

#: ../../library/logging.config.rst:538
#, fuzzy
msgid ""
"The ``filters`` member of ``handlers`` and ``loggers`` can take filter "
"instances in addition to ids."
msgstr "``handlers`` 和 ``loggers`` 的 ``filters`` 成員除了 ids "
"之外還可以接受過濾器實例。"

#: ../../library/logging.config.rst:542
#, fuzzy
msgid ""
"You can also specify a special key ``'.'`` whose value is a dictionary is a "
"mapping of attribute names to values. If found, the specified attributes "
"will be set on the user-defined object before it is returned. Thus, with the "
"following configuration::"
msgstr ""
"您還可以指定一個特殊的鍵 ``'.'`` 其值是一個字典是屬性名稱到值的映射。如果找到"
"，將在回傳之前在使用者定義的對像上設定指定的屬性。因此，使用以下配置::"

#: ../../library/logging.config.rst:558
#, fuzzy
msgid ""
"the returned formatter will have attribute ``foo`` set to ``'bar'`` and "
"attribute ``baz`` set to ``'bozz'``."
msgstr "回傳的格式化程式將屬性 ``foo``設定為 ``bar``，屬性 ``baz``設定為 ``bozz``。"

#: ../../library/logging.config.rst:561
#, fuzzy
msgid ""
"The values for attributes such as ``foo`` and ``baz`` in the above example "
"should not be configuration dictionaries or references such as ``cfg://foo`` "
"or ``ext://bar``, because they will not be processed by the configuration "
"machinery, but set as attribute values as-is."
msgstr ""
"上例中的 ``foo``和 ``baz``等屬性的值不應是配置字典或引用，如“cfg://foo”或“ext://bar"
"”，因為它們不會被配置機制處理，而是按原樣設定為屬性值。"

#: ../../library/logging.config.rst:570
#, fuzzy
msgid "Handler configuration order"
msgstr "處理程式配置順序"

#: ../../library/logging.config.rst:572
#, fuzzy
msgid ""
"Handlers are configured in alphabetical order of their keys, and a "
"configured handler replaces the configuration dictionary in (a working copy "
"of) the ``handlers`` dictionary in the schema. If you use a construct such "
"as ``cfg://handlers.foo``, then initially ``handlers['foo']`` points to the "
"configuration dictionary for the handler named ``foo``, and later (once that "
"handler has been configured) it points to the configured handler instance. "
"Thus, ``cfg://handlers.foo`` could resolve to either a dictionary or a "
"handler instance. In general, it is wise to name handlers in a way such that "
"dependent handlers are configured _after_ any handlers they depend on; that "
"allows something like ``cfg://handlers.foo`` to be used in configuring a "
"handler that depends on handler ``foo``. If that dependent handler were "
"named ``bar``, problems would result, because the configuration of ``bar`` "
"would be attempted before that of ``foo``, and ``foo`` would not yet have "
"been configured. However, if the dependent handler were named ``foobar``, it "
"would be configured after ``foo``, with the result that ``cfg://handlers."
"foo`` would resolve to configured handler ``foo``, and not its configuration "
"dictionary."
msgstr ""
"處理程式按其鍵的字母順序配置，配置的處理程式替換模式中“處理程式”字典（的工作"
"副本）中的配置字典。如果您使用諸如``cfg://handlers.foo`` "
"的構造，那麼最初``handlers['foo']`` 指向名為``foo`` 的處理程式的配置字典，之"
"後（一次該處理程式已配置）它指向已配置的處理程式實例。因此，``cfg://handlers."
"foo`` 可以解析為字典或處理程式實例。一般來說，以一種方式命名處理程式是明智的"
"，這樣依賴的處理程式_在_它們依賴的任何處理程式之後配置；這允許使用諸如“cfg://"
"handlers.foo”之類的東西來配置依賴於處理程式 ``foo``的處理程式。如果那個依賴處理"
"程式被命名為 ``bar``，就會出現問題，因為 ``bar``的配置將在 ``foo``之前嘗試，而 ``foo``還"
"沒有被配置。但是，如果依賴處理程式被命名為 ``foobar``，它將在 ``foo``之後配置，結果"
"“cfg://handlers.foo”將解析為配置的處理程式 ``foo`` ，而不是它的配置字典。"

#: ../../library/logging.config.rst:593
#, fuzzy
msgid "Access to external objects"
msgstr "訪問外部物件"

#: ../../library/logging.config.rst:595
#, fuzzy
msgid ""
"There are times where a configuration needs to refer to objects external to "
"the configuration, for example ``sys.stderr``.  If the configuration dict is "
"constructed using Python code, this is straightforward, but a problem arises "
"when the configuration is provided via a text file (e.g. JSON, YAML).  In a "
"text file, there is no standard way to distinguish ``sys.stderr`` from the "
"literal string ``'sys.stderr'``.  To facilitate this distinction, the "
"configuration system looks for certain special prefixes in string values and "
"treat them specially.  For example, if the literal string ``'ext://sys."
"stderr'`` is provided as a value in the configuration, then the ``ext://`` "
"will be stripped off and the remainder of the value processed using normal "
"import mechanisms."
msgstr ""
"有時配置需要引用配置外部的物件，例如“sys.stderr”。如果配置字典是使用 Python "
"程式碼構建的，這很簡單，但是當通過文本文件（例如 "
"JSON、YAML）提供配置時就會出現問題。在文本文件中，沒有標準的方法來區分 ``sys."
"stderr`` 和文字字串 ``'sys.stderr'``。為了便於區分，配置系統會在字串值中查找"
"某些特殊前綴並對其進行特殊處理。例如，如果在配置中提供文字字串“ext://sys."
"stderr”作為值，則“ext://”將被剝離，其餘值將被處理使用正常的導入機制。"

#: ../../library/logging.config.rst:608
#, fuzzy
msgid ""
"The handling of such prefixes is done in a way analogous to protocol "
"handling: there is a generic mechanism to look for prefixes which match the "
"regular expression ``^(?P<prefix>[a-z]+)://(?P<suffix>.*)$`` whereby, if the "
"``prefix`` is recognised, the ``suffix`` is processed in a prefix-dependent "
"manner and the result of the processing replaces the string value.  If the "
"prefix is not recognised, then the string value will be left as-is."
msgstr ""
"此類前綴的處理以類似於協定處理的方式完成："
"有一種通用機制來查找與正則表達式匹配的前綴 ``^(?P<prefix>[a-z]+)://(?P< "
"suffix>.*)$`` 由此，如果識別出 ``prefix``，則以依賴於前綴的方式處理 "
"``suffix``，並且處理結果替換字串值。如果無法識別前綴，則字串值將保持原樣。"

#: ../../library/logging.config.rst:620
#, fuzzy
msgid "Access to internal objects"
msgstr "訪問內部物件"

#: ../../library/logging.config.rst:622
#, fuzzy
msgid ""
"As well as external objects, there is sometimes also a need to refer to "
"objects in the configuration.  This will be done implicitly by the "
"configuration system for things that it knows about.  For example, the "
"string value ``'DEBUG'`` for a ``level`` in a logger or handler will "
"automatically be converted to the value ``logging.DEBUG``, and the "
"``handlers``, ``filters`` and ``formatter`` entries will take an object id "
"and resolve to the appropriate destination object."
msgstr ""
"除了外部物件，有時還需要引用配置中的物件。這將由配置系統針對它所知道的事情隱"
"式完成。例如，記錄器或處理程式中“級別”的字串值 ``DEBUG``將自動轉換為值“logging."
"DEBUG”，而“處理程式”、“ filters`` 和 ``formatter`` 條目將採用物件 ID "
"並解析為適當的目標物件。"

#: ../../library/logging.config.rst:630
#, fuzzy
msgid ""
"However, a more generic mechanism is needed for user-defined objects which "
"are not known to the :mod:`logging` module.  For example, consider :class:"
"`logging.handlers.MemoryHandler`, which takes a ``target`` argument which is "
"another handler to delegate to. Since the system already knows about this "
"class, then in the configuration, the given ``target`` just needs to be the "
"object id of the relevant target handler, and the system will resolve to the "
"handler from the id.  If, however, a user defines a ``my.package.MyHandler`` "
"which has an ``alternate`` handler, the configuration system would not know "
"that the ``alternate`` referred to a handler.  To cater for this, a generic "
"resolution system allows the user to specify:"
msgstr ""
"但是，對於 :mod:`logging` "
"模組不知道的使用者定義物件，需要更通用的機制。例如，考慮 :class:`logging."
"handlers.MemoryHandler`，它接受一個 ``target`` 參數，這是另一個要委託給的處理"
"程式。由於系統已經知道這個類，那麼在配置中，給定的``target`` "
"只需要是相關目標處理程式的物件id，系統將根據id 解析到處理程式。然而，"
"如果使用者定義了一個 my.package.MyHandler ，它有一個 alternate 處理程式，"
"配置系統將不知道 alternate "
"指的是一個處理程式。為了滿足這一點，通用解析系統允許使用者指定："

#: ../../library/logging.config.rst:652
#, fuzzy
msgid ""
"The literal string ``'cfg://handlers.file'`` will be resolved in an "
"analogous way to strings with the ``ext://`` prefix, but looking in the "
"configuration itself rather than the import namespace.  The mechanism allows "
"access by dot or by index, in a similar way to that provided by ``str."
"format``.  Thus, given the following snippet:"
msgstr ""
"文字字串 ``'cfg://handlers.file'`` 將以類似於帶有 ``ext://`` 前綴的字串的方式"
"解析，但在配置本身而不是導入命名空間中查找。該機制允許通過點或索引進行訪問，"
"類似於“str.format”提供的方式。因此，給定以下程式碼段："

#: ../../library/logging.config.rst:670
#, fuzzy
msgid ""
"in the configuration, the string ``'cfg://handlers'`` would resolve to the "
"dict with key ``handlers``, the string ``'cfg://handlers.email`` would "
"resolve to the dict with key ``email`` in the ``handlers`` dict, and so on.  "
"The string ``'cfg://handlers.email.toaddrs[1]`` would resolve to "
"``'dev_team@domain.tld'`` and the string ``'cfg://handlers.email."
"toaddrs[0]'`` would resolve to the value ``'support_team@domain.tld'``. The "
"``subject`` value could be accessed using either ``'cfg://handlers.email."
"subject'`` or, equivalently, ``'cfg://handlers.email[subject]'``.  The "
"latter form only needs to be used if the key contains spaces or non-"
"alphanumeric characters.  If an index value consists only of decimal digits, "
"access will be attempted using the corresponding integer value, falling back "
"to the string value if needed."
msgstr ""
"在配置中，字串 ``'cfg://handlers'`` 將解析為鍵為 ``handlers`` 的字典，字串 "
"``'cfg://handlers.email`` 將解析為鍵為 ``handlers`` 的字典在 ``handlers`` "
"字典中鍵入 ``email``，等等。字串 ``'cfg://handlers.email.toaddrs[1]`` "
"將解析為 ``'dev_team@domain.tld'`` 和字串 ``'cfg://handlers.email.toaddrs[0 "
"]'`` 將解析為值 ``'support_team@domain.tld'``。 ``subject`` "
"值可以使用``'cfg://handlers.email.subject'`` 或等效地``'cfg://handlers."
"email[subject]'`` 訪問。僅當密鑰包含空格或非字母數字字元時才需要使用後一種形"
"式。如果索引值僅由十進位數字組成，將嘗試使用相應的整數值進行訪問，如果需要則"
"回退到字串值。"

#: ../../library/logging.config.rst:684
#, fuzzy
msgid ""
"Given a string ``cfg://handlers.myhandler.mykey.123``, this will resolve to "
"``config_dict['handlers']['myhandler']['mykey']['123']``. If the string is "
"specified as ``cfg://handlers.myhandler.mykey[123]``, the system will "
"attempt to retrieve the value from ``config_dict['handlers']['myhandler']"
"['mykey'][123]``, and fall back to ``config_dict['handlers']['myhandler']"
"['mykey']['123']`` if that fails."
msgstr ""
"給定一個字串“cfg://handlers.myhandler.mykey.123”，這將解析為“config_dict['han"
"dlers']['myhandler']['mykey']['123']”。如果字串指定為“cfg://handlers."
"myhandler."
"mykey[123]”，系統將嘗試從“config_dict['handlers']['myhandler']['mykey'] 中檢"
"索值[123]``，如果失敗則回退到``config_dict['handlers']['myhandler']['mykey']["
"'123']``。"

#: ../../library/logging.config.rst:696
#, fuzzy
msgid "Import resolution and custom importers"
msgstr "導入解析和自定義導入器"

#: ../../library/logging.config.rst:698
#, fuzzy
msgid ""
"Import resolution, by default, uses the builtin :func:`__import__` function "
"to do its importing. You may want to replace this with your own importing "
"mechanism: if so, you can replace the :attr:`importer` attribute of the :"
"class:`DictConfigurator` or its superclass, the :class:`BaseConfigurator` "
"class. However, you need to be careful because of the way functions are "
"accessed from classes via descriptors. If you are using a Python callable to "
"do your imports, and you want to define it at class level rather than "
"instance level, you need to wrap it with :func:`staticmethod`. For example::"
msgstr ""
"預設情況下，導入解析使用內建的 :func:`__import__` "
"函式進行導入。你可能想用你自己的導入機制替換它：如果是這樣，你可以替換 "
"DictConfigurator 或其超類 BaseConfigurator 類的 importer "
"屬性。但是，由於通過描述器從類訪問函式的方式，您需要小心。如果您使用 Python "
"可呼叫函式來執行導入，並且您想在類級別而不是實例級別定義它，則需要使用 "
":func:`staticmethod` 包裝它。例如：："

#: ../../library/logging.config.rst:713
#, fuzzy
msgid ""
"You don't need to wrap with :func:`staticmethod` if you're setting the "
"import callable on a configurator *instance*."
msgstr "如果您在配置器*實例*上設定可呼叫導入，則不需要使用 :func:`staticmethod` "
"包裝。"

#: ../../library/logging.config.rst:720
#, fuzzy
msgid "Configuration file format"
msgstr "配置文件格式"

#: ../../library/logging.config.rst:722
#, fuzzy
msgid ""
"The configuration file format understood by :func:`fileConfig` is based on :"
"mod:`configparser` functionality. The file must contain sections called "
"``[loggers]``, ``[handlers]`` and ``[formatters]`` which identify by name "
"the entities of each type which are defined in the file. For each such "
"entity, there is a separate section which identifies how that entity is "
"configured.  Thus, for a logger named ``log01`` in the ``[loggers]`` "
"section, the relevant configuration details are held in a section "
"``[logger_log01]``. Similarly, a handler called ``hand01`` in the "
"``[handlers]`` section will have its configuration held in a section called "
"``[handler_hand01]``, while a formatter called ``form01`` in the "
"``[formatters]`` section will have its configuration specified in a section "
"called ``[formatter_form01]``. The root logger configuration must be "
"specified in a section called ``[logger_root]``."
msgstr ""
":func:`fileConfig` 理解的配置文件格式基於 :mod:`configparser` 功能。該文件必"
"須包含名為“[loggers]”、“[handlers]”和“[formatters]”的部分，它們按名稱標識文件"
"中定義的每種型別的實體。對於每個這樣的實體，都有一個單獨的部分來標識該實體的"
"配置方式。因此，對於“[loggers]”部分中名為 ``log01``的記錄器，相關配置詳細資訊保"
"存在“[logger_log01]”部分中。類似地，在“[handlers]”部分中名為 ``hand01``的處理程"
"序將在名為“[handler_hand01]”的部分中保存其配置，而在“[handlers]”部分中名為“fo"
"rm01”的格式化程式[formatters]`` 部分將在名為``[formatter_form01]`` "
"的部分中指定其配置。根記錄器配置必須在名為“[logger_root]”的部分中指定。"

#: ../../library/logging.config.rst:737
#, fuzzy
msgid ""
"The :func:`fileConfig` API is older than the :func:`dictConfig` API and does "
"not provide functionality to cover certain aspects of logging. For example, "
"you cannot configure :class:`~logging.Filter` objects, which provide for "
"filtering of messages beyond simple integer levels, using :func:"
"`fileConfig`. If you need to have instances of :class:`~logging.Filter` in "
"your logging configuration, you will need to use :func:`dictConfig`. Note "
"that future enhancements to configuration functionality will be added to :"
"func:`dictConfig`, so it's worth considering transitioning to this newer API "
"when it's convenient to do so."
msgstr ""
":func:`fileConfig` API 比 :func:`dictConfig` API "
"更舊，並且不提供涵蓋日誌記錄某些方面的功能。例如，您不能配置 :class:`~logging"
".Filter` 物件，它使用 :func:`fileConfig` 來過濾超出簡單整數級別的消息。"
"如果您需要在日誌配置中包含 :class:`~logging.Filter` 的實例，則需要使用 "
":func:`dictConfig`。請注意，未來對配置功能的增強將新增到 :func:`dictConfig`，"
"因此值得考慮在方便時過渡到這個更新的 API。"

#: ../../library/logging.config.rst:747
#, fuzzy
msgid "Examples of these sections in the file are given below."
msgstr "下面給出了文件中這些部分的示例。"

#: ../../library/logging.config.rst:760
#, fuzzy
msgid ""
"The root logger must specify a level and a list of handlers. An example of a "
"root logger section is given below."
msgstr "根記錄器必須指定級別和處理程式列表。下面給出了根記錄器部分的示例。"

#: ../../library/logging.config.rst:769
#, fuzzy
msgid ""
"The ``level`` entry can be one of ``DEBUG, INFO, WARNING, ERROR, CRITICAL`` "
"or ``NOTSET``. For the root logger only, ``NOTSET`` means that all messages "
"will be logged. Level values are :ref:`evaluated <func-eval>` in the context "
"of the ``logging`` package's namespace."
msgstr ""
" ``level``條目可以是“DEBUG、INFO、WARNING、ERROR、CRITICAL”或 ``NOTSET``之一。僅對"
"於根記錄器，``NOTSET`` 意味著將記錄所有消息。在 ``logging`` "
"包命名空間的上下文中，級別值是 :ref:`evaluated <func-eval>`。"

#: ../../library/logging.config.rst:774
#, fuzzy
msgid ""
"The ``handlers`` entry is a comma-separated list of handler names, which "
"must appear in the ``[handlers]`` section. These names must appear in the "
"``[handlers]`` section and have corresponding sections in the configuration "
"file."
msgstr ""
"``handlers`` 條目是以逗號分隔的處理程式名稱列表，它必須出現在 ``[handlers]`` "
"部分中。這些名稱必須出現在 ``[handlers]`` "
"部分，並且在配置文件中有相應的部分。"

#: ../../library/logging.config.rst:779
#, fuzzy
msgid ""
"For loggers other than the root logger, some additional information is "
"required. This is illustrated by the following example."
msgstr "對於根記錄器以外的記錄器，需要一些額外的資訊。以下示例說明了這一點。"

#: ../../library/logging.config.rst:790
#, fuzzy
msgid ""
"The ``level`` and ``handlers`` entries are interpreted as for the root "
"logger, except that if a non-root logger's level is specified as ``NOTSET``, "
"the system consults loggers higher up the hierarchy to determine the "
"effective level of the logger. The ``propagate`` entry is set to 1 to "
"indicate that messages must propagate to handlers higher up the logger "
"hierarchy from this logger, or 0 to indicate that messages are **not** "
"propagated to handlers up the hierarchy. The ``qualname`` entry is the "
"hierarchical channel name of the logger, that is to say the name used by the "
"application to get the logger."
msgstr ""
"``level`` 和 ``handlers`` 條目被解釋為根記錄器，除瞭如果非根記錄器的級別被指"
"定為``NOTSET``，系統會諮詢層次結構更高的記錄器以確定記錄器的有效級別。 "
"``propagate`` 條目設定為 1 "
"以指示消息必須從該記錄器傳播到記錄器層次結構中更高層的處理程式，或設定為 0 "
"以指示消息**不**傳播到層次結構中更高層的處理程式。 ``qualname`` "
"條目是記錄器的分層通道名稱，也就是說應用程式用來獲取記錄器的名稱。"

#: ../../library/logging.config.rst:799
#, fuzzy
msgid ""
"Sections which specify handler configuration are exemplified by the "
"following."
msgstr "下面舉例說明指定處理程式配置的部分。"

#: ../../library/logging.config.rst:809
#, fuzzy
msgid ""
"The ``class`` entry indicates the handler's class (as determined by :func:"
"`eval` in the ``logging`` package's namespace). The ``level`` is interpreted "
"as for loggers, and ``NOTSET`` is taken to mean 'log everything'."
msgstr ""
"``class`` 條目表示處理程式的類（由 ``logging`` 包命名空間中的 :func:`eval` "
"確定）。 ``level`` 被解釋為記錄器，``NOTSET`` 被認為是“記錄一切”。"

#: ../../library/logging.config.rst:813
#, fuzzy
msgid ""
"The ``formatter`` entry indicates the key name of the formatter for this "
"handler. If blank, a default formatter (``logging._defaultFormatter``) is "
"used. If a name is specified, it must appear in the ``[formatters]`` section "
"and have a corresponding section in the configuration file."
msgstr ""
"``formatter`` 條目指示此處理程式的格式化程式的鍵名。如果為空，則使用預設格式"
"化程式（``logging._defaultFormatter``）。如果指定了名稱，則它必須出現在 "
"``[formatters]`` 部分，並且在配置文件中有相應的部分。"

#: ../../library/logging.config.rst:818
#, fuzzy
msgid ""
"The ``args`` entry, when :ref:`evaluated <func-eval>` in the context of the "
"``logging`` package's namespace, is the list of arguments to the constructor "
"for the handler class. Refer to the constructors for the relevant handlers, "
"or to the examples below, to see how typical entries are constructed. If not "
"provided, it defaults to ``()``."
msgstr ""
"``args`` 條目，當 :ref:`在 ``logging`` 包命名空間的上下文中評估 <func-eval>` "
"時，是處理程式類的構造函式的參數列表。請參閱相關處理程式的構造函式或下面的示"
"例，以了解典型條目的構造方式。如果未提供，則預設為 ``()``。"

#: ../../library/logging.config.rst:824
#, fuzzy
msgid ""
"The optional ``kwargs`` entry, when :ref:`evaluated <func-eval>` in the "
"context of the ``logging`` package's namespace, is the keyword argument dict "
"to the constructor for the handler class. If not provided, it defaults to "
"``{}``."
msgstr ""
"可選的 ``kwargs`` 條目，當在 ``logging`` 包的命名空間的上下文中評估 <func-"
"eval>` 時，是處理程式類的構造函式的關鍵字參數字典。如果未提供，則預設為“{}”。"

#: ../../library/logging.config.rst:881
#, fuzzy
msgid ""
"Sections which specify formatter configuration are typified by the following."
msgstr "指定格式化程式配置的部分由以下代表。"

#: ../../library/logging.config.rst:892
#, fuzzy
msgid ""
"The arguments for the formatter configuration are the same as the keys in "
"the dictionary schema :ref:`formatters section <logging-config-dictschema-"
"formatters>`."
msgstr ""
"格式化程式配置的參數與字典模式中的鍵相同 :ref:`formatters 部分 <logging-"
"config-dictschema-formatters>`。"

#: ../../library/logging.config.rst:898
#, fuzzy
msgid ""
"Due to the use of :func:`eval` as described above, there are potential "
"security risks which result from using the :func:`listen` to send and "
"receive configurations via sockets. The risks are limited to where multiple "
"users with no mutual trust run code on the same machine; see the :func:"
"`listen` documentation for more information."
msgstr ""
"由於如上所述使用 :func:`eval`，使用 :func:`listen` 通過 socket 發送和接收配置會"
"導致潛在的安全風險。風險僅限於多個互不信任的使用者在同一台機器上運行程式碼；"
"有關詳細資訊，請參閱 :func:`listen` 文檔。"

#: ../../library/logging.config.rst:907
msgid "Module :mod:`logging`"
msgstr ":mod:`logging` 模組"

#: ../../library/logging.config.rst:907
#, fuzzy
msgid "API reference for the logging module."
msgstr "日誌記錄模組的 API 參考。"

#: ../../library/logging.config.rst:909
msgid "Module :mod:`logging.handlers`"
msgstr ":mod:`logging.handlers` 模組"

#: ../../library/logging.config.rst:910
#, fuzzy
msgid "Useful handlers included with the logging module."
msgstr "日誌記錄模組中包含有用的處理程式。"
