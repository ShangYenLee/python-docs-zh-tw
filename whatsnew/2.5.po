# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-07 00:27+0000\n"
"PO-Revision-Date: 2018-05-23 16:20+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/2.5.rst:3
msgid "What's New in Python 2.5"
msgstr "Python 2.5 有什麼新功能"

#: ../../whatsnew/2.5.rst:0
msgid "Author"
msgstr "作者"

#: ../../whatsnew/2.5.rst:5
msgid "A.M. Kuchling"
msgstr "A.M. Kuchling"

#: ../../whatsnew/2.5.rst:12
#, fuzzy
msgid ""
"This article explains the new features in Python 2.5.  The final release of "
"Python 2.5 is scheduled for August 2006; :pep:`356` describes the planned "
"release schedule.  Python 2.5 was released on September 19, 2006."
msgstr ""
"本文介紹了 Python 2.5 中的新功能。 Python 2.5 的最終版本定於 2006 年 8 "
"月發布； :pep:`356` 描述了計劃的發佈時間表。 Python 2.5 於 2006 年 9 月 19 "
"日發布。"

#: ../../whatsnew/2.5.rst:16
#, fuzzy
msgid ""
"The changes in Python 2.5 are an interesting mix of language and library "
"improvements. The library enhancements will be more important to Python's "
"user community, I think, because several widely useful packages were added.  "
"New modules include ElementTree for XML processing (:mod:`xml.etree`), the "
"SQLite database module (:mod:`sqlite`), and the :mod:`ctypes` module for "
"calling C functions."
msgstr ""
"Python 2.5 中的變化是語言和庫改進的有趣組合。我認為，庫的增強對 Python "
"的使用者社區更為重要，因為新增了幾個廣泛有用的包。新模組包括用於 XML 處理的 "
"ElementTree (:mod:`xml.etree`)、SQLite 資料庫模組 (:mod:`sqlite`) 和用於呼叫 "
"C 函式的 :mod:`ctypes` 模組。"

#: ../../whatsnew/2.5.rst:23
#, fuzzy
msgid ""
"The language changes are of middling significance.  Some pleasant new "
"features were added, but most of them aren't features that you'll use every "
"day. Conditional expressions were finally added to the language using a "
"novel syntax; see section :ref:`pep-308`.  The new ':keyword:`with`' "
"statement will make writing cleanup code easier (section :ref:`pep-343`).  "
"Values can now be passed into generators (section :ref:`pep-342`).  Imports "
"are now visible as either absolute or relative (section :ref:`pep-328`).  "
"Some corner cases of exception handling are handled better (section :ref:"
"`pep-341`).  All these improvements are worthwhile, but they're improvements "
"to one specific language feature or another; none of them are broad "
"modifications to Python's semantics."
msgstr ""
"語言變化具有中等意義。新增了一些令人愉快的新功能，但其中大部分不是您每天都會"
"使用的功能。條件表達式最終被新增到使用新語法的語言中；請參閱 :ref:`pep-308` "
"部分。新的 ':keyword:`with`' 語句將使編寫清理程式碼更容易（部分 "
":ref:`pep-343`）。現在可以將值傳遞給生成器（section "
":ref:`pep-342`）。匯入現在可以顯示為絕對或相對（section "
":ref:`pep-328`）。例外處理的一些極端情況得到了更好的處理（section :ref:`pep-3"
"41`）。所有這些改進都是值得的，但它們是對一種或另一種特定語言功能的改進；"
"它們都不是對 Python 語義的廣泛修改。"

#: ../../whatsnew/2.5.rst:34
#, fuzzy
msgid ""
"As well as the language and library additions, other improvements and "
"bugfixes were made throughout the source tree.  A search through the SVN "
"change logs finds there were 353 patches applied and 458 bugs fixed between "
"Python 2.4 and 2.5.  (Both figures are likely to be underestimates.)"
msgstr ""
"除了新增語言和庫之外，還對整個源程式碼樹進行了其他改進和錯誤修復。搜索 SVN "
"更改日誌發現在 Python 2.4 和 2.5 之間應用了 353 個補丁並修復了 458 個錯誤。 "
"（這兩個數字可能都被低估了。）"

#: ../../whatsnew/2.5.rst:39
#, fuzzy
msgid ""
"This article doesn't try to be a complete specification of the new features; "
"instead changes are briefly introduced using helpful examples.  For full "
"details, you should always refer to the documentation for Python 2.5 at "
"https://docs.python.org. If you want to understand the complete "
"implementation and design rationale, refer to the PEP for a particular new "
"feature."
msgstr ""
"本文並不試圖成為新功能的完整規範；而是使用有用的示例簡要介紹更改。有關完整詳"
"細資訊，您應該始終參考 Python 2.5 的文檔，網址為 https://docs.python."
"org。如果您想了解完整的實作和設計原理，請參閱特定新功能的 PEP。"

#: ../../whatsnew/2.5.rst:45
#, fuzzy
msgid ""
"Comments, suggestions, and error reports for this document are welcome; "
"please e-mail them to the author or open a bug in the Python bug tracker."
msgstr "歡迎對本文檔提出意見、建議和錯誤報告；請將它們通過電子郵件發送給作者或在 "
"Python 錯誤跟踪器中打開錯誤。"

#: ../../whatsnew/2.5.rst:54
#, fuzzy
msgid "PEP 308: Conditional Expressions"
msgstr "PEP 308：條件表達式"

#: ../../whatsnew/2.5.rst:56
#, fuzzy
msgid ""
"For a long time, people have been requesting a way to write conditional "
"expressions, which are expressions that return value A or value B depending "
"on whether a Boolean value is true or false.  A conditional expression lets "
"you write a single assignment statement that has the same effect as the "
"following::"
msgstr ""
"長期以來，人們一直在尋求一種編寫條件表達式的方法，"
"條件表達式是根據布爾值是真還是假回傳值 A 或值 B "
"的表達式。條件表達式使您可以編寫與以下具有相同效果的單個賦值語句："

#: ../../whatsnew/2.5.rst:66
#, fuzzy
msgid ""
"There have been endless tedious discussions of syntax on both python-dev and "
"comp.lang.python.  A vote was even held that found the majority of voters "
"wanted conditional expressions in some form, but there was no syntax that "
"was preferred by a clear majority. Candidates included C's ``cond ? true_v : "
"false_v``, ``if cond then true_v else false_v``, and 16 other variations."
msgstr ""
"對 python-dev 和 comp.lang.python 的語法進行了無窮無盡的乏味討論。甚至舉行了"
"一次投票，發現大多數選民想要某種形式的條件表達式，但沒有明顯多數人更喜歡的語"
"法。候選人包括 C 的 ``cond ? true_v : false_v``、``if cond then true_v else "
"false_v`` 和其他 16 種變體。"

#: ../../whatsnew/2.5.rst:72
#, fuzzy
msgid "Guido van Rossum eventually chose a surprising syntax::"
msgstr "Guido van Rossum 最終選擇了一個令人驚訝的語法："

#: ../../whatsnew/2.5.rst:76
#, fuzzy
msgid ""
"Evaluation is still lazy as in existing Boolean expressions, so the order of "
"evaluation jumps around a bit.  The *condition* expression in the middle is "
"evaluated first, and the *true_value* expression is evaluated only if the "
"condition was true.  Similarly, the *false_value* expression is only "
"evaluated when the condition is false."
msgstr ""
"與現有的布爾表達式一樣，評估仍然是惰性的，因此評估的順序有點跳躍。中間的 "
"*condition* 表達式首先求值，只有當條件為真時才求值 *true_value* "
"表達式。類似地，*false_value* 表達式僅在條件為假時才被評估。"

#: ../../whatsnew/2.5.rst:82
#, fuzzy
msgid ""
"This syntax may seem strange and backwards; why does the condition go in the "
"*middle* of the expression, and not in the front as in C's ``c ? x : y``?  "
"The decision was checked by applying the new syntax to the modules in the "
"standard library and seeing how the resulting code read.  In many cases "
"where a conditional expression is used, one value seems to be the 'common "
"case' and one value is an 'exceptional case', used only on rarer occasions "
"when the condition isn't met.  The conditional syntax makes this pattern a "
"bit more obvious::"
msgstr ""
"這種語法可能看起來很奇怪而且倒退；為什麼條件放在表達式的*中間*，而不是像 C "
"的 ``c 那樣放在前面？ x : y``?通過將新語法應用於標準庫中的模組並查看生成的程"
"式碼如何讀取來檢查該決定。在許多使用條件表達式的情況下，一個值似乎是“常見情況"
"”，另一個值是“例外情況”，僅在不滿足條件的極少數情況下使用。條件語法使這種模式"
"更加明顯："

#: ../../whatsnew/2.5.rst:92
#, fuzzy
msgid ""
"I read the above statement as meaning \"here *contents* is  usually assigned "
"a value of ``doc+'\\n'``; sometimes  *doc* is empty, in which special case "
"an empty string is returned.\"   I doubt I will use conditional expressions "
"very often where there  isn't a clear common and uncommon case."
msgstr ""
"我將上面的語句理解為“這裡 *contents* 通常被賦予一個值 ``doc+'\\n"
"'``；有時 *doc* 是空的，在這種特殊情況下會回傳一個空字串。”我懷疑我會在沒有明"
"確的常見和不常見情況的情況下經常使用條件表達式。"

#: ../../whatsnew/2.5.rst:97
#, fuzzy
msgid ""
"There was some discussion of whether the language should require surrounding "
"conditional expressions with parentheses.  The decision was made to *not* "
"require parentheses in the Python language's grammar, but as a matter of "
"style I think you should always use them. Consider these two statements::"
msgstr ""
"有一些關於語言是否應該要求用括號包圍條件表達式的討論。決定*不*要求在 Python "
"語言的語法中使用括號，但作為一種風格，我認為您應該始終使用它們。考慮這兩個語"
"句："

#: ../../whatsnew/2.5.rst:108
#, fuzzy
msgid ""
"In the first version, I think a reader's eye might group the statement into "
"'level = 1', 'if logging', 'else 0', and think that the condition decides "
"whether the assignment to *level* is performed.  The second version reads "
"better, in my opinion, because it makes it clear that the assignment is "
"always performed and the choice is being made between two values."
msgstr ""
"在第一個版本中，我認為讀者的眼睛可能會將語句分為'level = 1'、'if logging'、"
"'else 0'，並認為條件決定是否執行對*level* 的賦值。在我看來，第二個版本讀起來"
"更好，因為它清楚地表明總是執行賦值並且在兩個值之間做出選擇。"

#: ../../whatsnew/2.5.rst:114
#, fuzzy
msgid ""
"Another reason for including the brackets: a few odd combinations of list "
"comprehensions and lambdas could look like incorrect conditional "
"expressions. See :pep:`308` for some examples.  If you put parentheses "
"around your conditional expressions, you won't run into this case."
msgstr ""
"包含方括號的另一個原因：列表理解和 lambda "
"的一些奇怪組合可能看起來像不正確的條件表達式。有關示例，請參見 "
":pep:`308`。如果在條件表達式兩邊加上括號，就不會遇到這種情況。"

#: ../../whatsnew/2.5.rst:123
#, fuzzy
msgid ":pep:`308` - Conditional Expressions"
msgstr ":pep:`308` - 條件表達式"

#: ../../whatsnew/2.5.rst:123
#, fuzzy
msgid ""
"PEP written by Guido van Rossum and Raymond D. Hettinger; implemented by "
"Thomas Wouters."
msgstr "PEP 由 Guido van Rossum 和 Raymond D. Hettinger 撰寫；由 Thomas Wouters "
"實施。"

#: ../../whatsnew/2.5.rst:132
#, fuzzy
msgid "PEP 309: Partial Function Application"
msgstr "PEP 309：部分函式應用"

#: ../../whatsnew/2.5.rst:134
#, fuzzy
msgid ""
"The :mod:`functools` module is intended to contain tools for functional-"
"style programming."
msgstr ":mod:`functools` 模組旨在包含用於函式式編程的工具。"

#: ../../whatsnew/2.5.rst:137
#, fuzzy
msgid ""
"One useful tool in this module is the :func:`partial` function. For programs "
"written in a functional style, you'll sometimes want to construct variants "
"of existing functions that have some of the parameters filled in.  Consider "
"a Python function ``f(a, b, c)``; you could create a new function ``g(b, "
"c)`` that was equivalent to ``f(1, b, c)``.  This is called \"partial "
"function application\"."
msgstr ""
"該模組中的一個有用工具是 :func:`partial` 函式。對於以函式式風格編寫的程式，有"
"時您會希望構建填充了一些參數的現有函式的變體。考慮一個 Python 函式“f(a, b, "
"c)”；你可以建立一個新函式 ``g(b, c)`` 相當於 ``f(1, b, "
"c)``。這稱為“部分功能應用程式”。"

#: ../../whatsnew/2.5.rst:144
#, fuzzy
msgid ""
":func:`partial` takes the arguments ``(function, arg1, arg2, ... "
"kwarg1=value1, kwarg2=value2)``.  The resulting object is callable, so you "
"can just call it to invoke *function* with the filled-in arguments."
msgstr ""
":func:`partial` 採用參數``(function, arg1, arg2, ... kwarg1=value1, "
"kwarg2=value2)``。生成的對像是可呼叫的，"
"因此您只需呼叫它即可使用填充的參數呼叫 *function*。"

#: ../../whatsnew/2.5.rst:148
#, fuzzy
msgid "Here's a small but realistic example::"
msgstr "這是一個小而現實的例子::"

#: ../../whatsnew/2.5.rst:160
#, fuzzy
msgid ""
"Here's another example, from a program that uses PyGTK.  Here a context-"
"sensitive pop-up menu is being constructed dynamically.  The callback "
"provided for the menu option is a partially applied version of the :meth:"
"`open_item` method, where the first argument has been provided. ::"
msgstr ""
"這是另一個示例，來自使用 PyGTK "
"的程式。這裡動態構建了一個上下文相關的彈出菜單。為菜單選項提供的回呼是 "
":meth:`open_item` 方法的部分應用版本，其中提供了第一個參數。 ::"

#: ../../whatsnew/2.5.rst:173
#, fuzzy
msgid ""
"Another function in the :mod:`functools` module is the "
"``update_wrapper(wrapper, wrapped)`` function that helps you write well-"
"behaved decorators.  :func:`update_wrapper` copies the name, module, and "
"docstring attribute to a wrapper function so that tracebacks inside the "
"wrapped function are easier to understand.  For example, you might write::"
msgstr ""
":mod:`functools` 模組中的另一個函式是 ``update_wrapper(wrapper, wrapped)`` "
"函式，它可以幫助您編寫行為良好的裝飾器。 :func:`update_wrapper` 將 name、"
"module 和 docstring "
"屬性複製到包裝函式，以便更容易理解包裝函式內的回溯。例如，您可以這樣寫："

#: ../../whatsnew/2.5.rst:186
#, fuzzy
msgid ""
":func:`wraps` is a decorator that can be used inside your own decorators to "
"copy the wrapped function's information.  An alternate  version of the "
"previous example would be::"
msgstr ":func:`wraps` 是一個裝飾器，可以在您自己的裝飾器中使用它來複製包裝函式的資訊"
"。上一個示例的替代版本是："

#: ../../whatsnew/2.5.rst:201
#, fuzzy
msgid ":pep:`309` - Partial Function Application"
msgstr ":pep:`309` - 偏函式應用"

#: ../../whatsnew/2.5.rst:201
#, fuzzy
msgid ""
"PEP proposed and written by Peter Harris; implemented by Hye-Shik Chang and "
"Nick Coghlan, with adaptations by Raymond Hettinger."
msgstr ""
"PEP 由 Peter Harris 提出並撰寫；由 Hye-Shik Chang 和 Nick Coghlan 實施，由 "
"Raymond Hettinger 改編。"

#: ../../whatsnew/2.5.rst:210
#, fuzzy
msgid "PEP 314: Metadata for Python Software Packages v1.1"
msgstr "PEP 314：Python 軟件包的元資料 v1.1"

#: ../../whatsnew/2.5.rst:212
#, fuzzy
msgid ""
"Some simple dependency support was added to Distutils.  The :func:`setup` "
"function now has ``requires``, ``provides``, and ``obsoletes`` keyword "
"parameters.  When you build a source distribution using the ``sdist`` "
"command, the dependency information will be recorded in the :file:`PKG-INFO` "
"file."
msgstr ""
"Distutils 新增了一些簡單的依賴支援。 :func:`setup` 函式現在有 "
"``requires``、``provides`` 和 ``obsoletes`` 關鍵字參數。當您使用 ``sdist`` "
"命令構建源程式碼分發時，依賴資訊將記錄在 :file:`PKG-INFO` 文件中。"

#: ../../whatsnew/2.5.rst:217
#, fuzzy
msgid ""
"Another new keyword parameter is ``download_url``, which should be set to a "
"URL for the package's source code.  This means it's now possible to look up "
"an entry in the package index, determine the dependencies for a package, and "
"download the required packages. ::"
msgstr ""
"另一個新的關鍵字參數是 ``download_url``，它應該設定為包源程式碼的 "
"URL。這意味著現在可以在包索引中查找條目、確定包的依賴項並下載所需的包。 ::"

#: ../../whatsnew/2.5.rst:231
#, fuzzy
msgid ""
"Another new enhancement to the Python package index at https://pypi.org is "
"storing source and binary archives for a package.  The new :command:`upload` "
"Distutils command will upload a package to the repository."
msgstr ""
"https://pypi.org 上 Python "
"包索引的另一個新增強功能是儲存包的源程式碼和二進位存檔。新的 "
":command:`upload` Distutils 命令會將包上傳到儲存庫。"

#: ../../whatsnew/2.5.rst:236
#, fuzzy
msgid ""
"Before a package can be uploaded, you must be able to build a distribution "
"using the :command:`sdist` Distutils command.  Once that works, you can run "
"``python setup.py upload`` to add your package to the PyPI archive.  "
"Optionally you can GPG-sign the package by supplying the :option:`!--sign` "
"and :option:`!--identity` options."
msgstr ""
"在可以上傳包之前，您必須能夠使用 :command:`sdist` Distutils "
"命令構建一個發行版。一旦成功，您可以運行 ``python setup.py upload`` "
"將您的包新增到 PyPI 存檔中。或者，您可以通過提供 :option:`!--sign` 和 "
":option:`!--identity` 選項對包進行 GPG 簽名。"

#: ../../whatsnew/2.5.rst:242
#, fuzzy
msgid ""
"Package uploading was implemented by Martin von Löwis and Richard Jones."
msgstr "包上傳由 Martin von Löwis 和 Richard Jones 實作。"

#: ../../whatsnew/2.5.rst:248
#, fuzzy
msgid ":pep:`314` - Metadata for Python Software Packages v1.1"
msgstr ":pep:`314` - Python 軟件包 v1.1 的元資料"

#: ../../whatsnew/2.5.rst:248
#, fuzzy
msgid ""
"PEP proposed and written by A.M. Kuchling, Richard Jones, and Fred Drake; "
"implemented by Richard Jones and Fred Drake."
msgstr ""
"PEP 由 A.M. 提出並撰寫Kuchling、Richard Jones 和 Fred Drake；由 Richard "
"Jones 和 Fred Drake 實施。"

#: ../../whatsnew/2.5.rst:257
#, fuzzy
msgid "PEP 328: Absolute and Relative Imports"
msgstr "PEP 328：絕對和相對匯入"

#: ../../whatsnew/2.5.rst:259
#, fuzzy
msgid ""
"The simpler part of :pep:`328` was implemented in Python 2.4: parentheses "
"could now be used to enclose the names imported from a module using the "
"``from ... import ...`` statement, making it easier to import many different "
"names."
msgstr ""
":pep:`328` 中更簡單的部分在 Python 2.4 中實作：現在可以使用圓括號括起使用 ``"
"from ... import ...`` 語句從模組匯入的名稱，使其更易於匯入許多不同的名字。"

#: ../../whatsnew/2.5.rst:263
#, fuzzy
msgid ""
"The more complicated part has been implemented in Python 2.5: importing a "
"module can be specified to use absolute or package-relative imports.  The "
"plan is to move toward making absolute imports the default in future "
"versions of Python."
msgstr ""
"更複雜的部分已在 Python 2.5 "
"中實作：匯入模組可以指定使用絕對匯入或相對包匯入。計劃是在未來的 Python "
"版本中使絕對匯入成為預設值。"

#: ../../whatsnew/2.5.rst:267
#, fuzzy
msgid "Let's say you have a package directory like this::"
msgstr "假設您有一個這樣的包目錄："

#: ../../whatsnew/2.5.rst:274
#, fuzzy
msgid ""
"This defines a package named :mod:`pkg` containing the :mod:`pkg.main` and :"
"mod:`pkg.string` submodules."
msgstr "這定義了一個名為 :mod:`pkg` 的包，其中包含 :mod:`pkg.main` 和 :mod:`pkg."
"string` 子模組。"

#: ../../whatsnew/2.5.rst:277
#, fuzzy
msgid ""
"Consider the code in the :file:`main.py` module.  What happens if it "
"executes the statement ``import string``?  In Python 2.4 and earlier, it "
"will first look in the package's directory to perform a relative import, "
"finds :file:`pkg/string.py`, imports the contents of that file as the :mod:"
"`pkg.string` module, and that module is bound to the name ``string`` in the :"
"mod:`pkg.main` module's namespace."
msgstr ""
"考慮 :file:`main.py` 模組中的程式碼。如果它執行語句 ``import string`` "
"會發生什麼？在 Python 2.4 "
"及更早版本中，它會首先在包的目錄中查找以執行相對匯入，找到 :file:`pkg/string."
"py`，將該文件的內容匯入為 :mod:`pkg.string` 模組，並且該模組綁定到 :mod:`pkg."
"main` 模組命名空間中的名稱 ``string``。"

#: ../../whatsnew/2.5.rst:284
#, fuzzy
msgid ""
"That's fine if :mod:`pkg.string` was what you wanted.  But what if you "
"wanted Python's standard :mod:`string` module?  There's no clean way to "
"ignore :mod:`pkg.string` and look for the standard module; generally you had "
"to look at the contents of ``sys.modules``, which is slightly unclean.    "
"Holger Krekel's :mod:`py.std` package provides a tidier way to perform "
"imports from the standard library, ``import py; py.std.string.join()``, but "
"that package isn't available on all Python installations."
msgstr ""
"如果 :mod:`pkg.string` 是您想要的，那很好。但是，如果您想要 Python 的標準 "
":mod:`string` 模組怎麼辦？沒有乾淨的方法可以忽略 :mod:`pkg.string` "
"並尋找標準模組；通常，您必須查看 ``sys.modules`` 的內容，這有點不干淨。 "
"Holger Krekel 的 :mod:`py.std` "
"包提供了一種更簡潔的方法來執行從標準庫的匯入，``import py; py.std.string."
"join()``，但並非所有 Python 安裝都提供該包。"

#: ../../whatsnew/2.5.rst:292
#, fuzzy
msgid ""
"Reading code which relies on relative imports is also less clear, because a "
"reader may be confused about which module, :mod:`string` or :mod:`pkg."
"string`, is intended to be used.  Python users soon learned not to duplicate "
"the names of standard library modules in the names of their packages' "
"submodules, but you can't protect against having your submodule's name being "
"used for a new module added in a future version of Python."
msgstr ""
"閱讀依賴於相對匯入的程式碼也不太清楚，因為讀者可能會混淆要使用哪個模組，:mod:"
"`string` 或 :mod:`pkg.string`。 Python "
"使用者很快就學會了不要在他們的包的子模組名稱中重複標準庫模組的名稱，"
"但是您無法防止您的子模組的名稱被用於 Python 的未來版本中新增的新模組。"

#: ../../whatsnew/2.5.rst:299
#, fuzzy
msgid ""
"In Python 2.5, you can switch :keyword:`import`'s behaviour to  absolute "
"imports using a ``from __future__ import absolute_import`` directive.  This "
"absolute-import behaviour will become the default in a future version "
"(probably Python 2.7).  Once absolute imports  are the default, ``import "
"string`` will always find the standard library's version. It's suggested "
"that users should begin using absolute imports as much as possible, so it's "
"preferable to begin writing ``from pkg import string`` in your code."
msgstr ""
"在 Python 2.5 中，您可以使用 ``from __future__ import absolute_import`` "
"指令將 :keyword:`import` "
"的行為切換為絕對匯入。這種絕對匯入行為將成為未來版本（可能是 Python 2."
"7）中的預設行為。一旦絕對匯入成為預設值，``import string`` 將始終找到標準庫的"
"版本。建議使用者開始盡可能多地使用絕對匯入，因此最好在程式碼中開始編寫“from "
"pkg import string”。"

#: ../../whatsnew/2.5.rst:307
#, fuzzy
msgid ""
"Relative imports are still possible by adding a leading period  to the "
"module name when using the ``from ... import`` form::"
msgstr "在使用“from ... "
"import”形式時，通過在模組名稱中新增一個前導句點，仍然可以進行相對匯入："

#: ../../whatsnew/2.5.rst:315
#, fuzzy
msgid ""
"This imports the :mod:`string` module relative to the current package, so "
"in :mod:`pkg.main` this will import *name1* and *name2* from :mod:`pkg."
"string`. Additional leading periods perform the relative import starting "
"from the parent of the current package.  For example, code in the :mod:`A.B."
"C` module can do::"
msgstr ""
"這將匯入相對於當前包的 :mod:`string` 模組，因此在 :mod:`pkg.main` 中，這將從 "
":mod:`pkg.string` 匯入 *name1* 和 "
"*name2*。額外的領先期從當前包的父級開始執行相對匯入。例如，:mod:`A.B.C` "
"模組中的程式碼可以執行以下操作："

#: ../../whatsnew/2.5.rst:324
#, fuzzy
msgid ""
"Leading periods cannot be used with the ``import modname``  form of the "
"import statement, only the ``from ... import`` form."
msgstr ""
"前導句點不能與 import 語句的 ``import modname`` 形式一起使用，只能與 ``from "
"... import`` 形式一起使用。"

#: ../../whatsnew/2.5.rst:331
#, fuzzy
msgid ":pep:`328` - Imports: Multi-Line and Absolute/Relative"
msgstr ":pep:`328` - 匯入：多行和絕對/相對"

#: ../../whatsnew/2.5.rst:331
msgid "PEP written by Aahz; implemented by Thomas Wouters."
msgstr "由 Aahz 撰寫 PEP；由 Thomas Wouters 實作。"

#: ../../whatsnew/2.5.rst:333
msgid "https://pylib.readthedocs.io/"
msgstr "https://pylib.readthedocs.io/"

#: ../../whatsnew/2.5.rst:334
#, fuzzy
msgid ""
"The py library by Holger Krekel, which contains the :mod:`py.std` package."
msgstr "Holger Krekel 的 py 庫，其中包含 :mod:`py.std` 包。"

#: ../../whatsnew/2.5.rst:342
#, fuzzy
msgid "PEP 338: Executing Modules as Scripts"
msgstr "PEP 338：將模組作為腳本執行"

#: ../../whatsnew/2.5.rst:344
#, fuzzy
msgid ""
"The :option:`-m` switch added in Python 2.4 to execute a module as a script "
"gained a few more abilities.  Instead of being implemented in C code inside "
"the Python interpreter, the switch now uses an implementation in a new "
"module, :mod:`runpy`."
msgstr ""
"Python 2.4 中新增的 :option:`-m` 開關作為腳本執行模組獲得了更多功能。"
"該開關現在不是在 Python 直譯器中用 C 程式碼實作，而是在新模組 :mod:`runpy` "
"中使用實作。"

#: ../../whatsnew/2.5.rst:349
#, fuzzy
msgid ""
"The :mod:`runpy` module implements a more sophisticated import mechanism so "
"that it's now possible to run modules in a package such as :mod:`pychecker."
"checker`. The module also supports alternative import mechanisms such as "
"the :mod:`zipimport` module.  This means you can add a .zip archive's path "
"to ``sys.path`` and then use the :option:`-m` switch to execute code from "
"the archive."
msgstr ""
":mod:`runpy` 模組實作了更複雜的匯入機制，因此現在可以在包中運行模組，例如 "
":mod:`pychecker.checker`。該模組還支援替代匯入機制，例如 :mod:`zipimport` "
"模組。這意味著您可以將 .zip 存檔的路徑新增到 ``sys."
"path``，然後使用 :option:`-m` 開關從存檔中執行程式碼。"

#: ../../whatsnew/2.5.rst:359
#, fuzzy
msgid ":pep:`338` - Executing modules as scripts"
msgstr ":pep:`338` - 將模組作為腳本執行"

#: ../../whatsnew/2.5.rst:360
msgid "PEP written and  implemented by Nick Coghlan."
msgstr "由 Nick Coghlan 撰寫 PEP 與實作。"

#: ../../whatsnew/2.5.rst:368
#, fuzzy
msgid "PEP 341: Unified try/except/finally"
msgstr "PEP 341：統一的 try/except/finally"

#: ../../whatsnew/2.5.rst:370
#, fuzzy
msgid ""
"Until Python 2.5, the :keyword:`try` statement came in two flavours. You "
"could use a :keyword:`finally` block to ensure that code is always executed, "
"or one or more :keyword:`except` blocks to catch  specific exceptions.  You "
"couldn't combine both :keyword:`!except` blocks and a :keyword:`!finally` "
"block, because generating the right bytecode for the combined version was "
"complicated and it wasn't clear what the semantics of the combined statement "
"should be."
msgstr ""
"在 Python 2.5 之前，:keyword:`try` 語句有兩種形式。您可以使用 "
":keyword:`finally` 塊來確保始終執行程式碼，或者使用一個或多個 "
":keyword:`except` 塊來捕獲特定例外。你不能將 :keyword:`!except` 塊和 "
":keyword:`!finally` 塊結合起來，因為為組合版本生成正確的位元組碼很複雜，而且"
"不清楚組合語句的語義應該是什麼是。"

#: ../../whatsnew/2.5.rst:377
#, fuzzy
msgid ""
"Guido van Rossum spent some time working with Java, which does support the "
"equivalent of combining :keyword:`except` blocks and a :keyword:`finally` "
"block, and this clarified what the statement should mean.  In Python 2.5, "
"you can now write::"
msgstr ""
"Guido van Rossum 花了一些時間研究 Java，它確實支援組合 :keyword:`except` "
"塊和 :keyword:`finally` 塊的等價物，這闡明了語句的含義。在 Python 2.5 "
"中，您現在可以編寫："

#: ../../whatsnew/2.5.rst:393
#, fuzzy
msgid ""
"The code in *block-1* is executed.  If the code raises an exception, the "
"various :keyword:`except` blocks are tested: if the exception is of class :"
"class:`Exception1`, *handler-1* is executed; otherwise if it's of class :"
"class:`Exception2`, *handler-2* is executed, and so forth.  If no exception "
"is raised, the *else-block* is executed."
msgstr ""
"*block-1* 中的程式碼被執行。如果程式碼引發例外，則會測試各種 "
":keyword:`except` 塊：如果例外屬於 :class:`Exception1` 類，則執行 "
"*handler-1*；否則，如果它屬於 :class:`Exception2` 類，則執行 "
"*handler-2*，依此類推。如果沒有引發例外，則執行 *else-block*。"

#: ../../whatsnew/2.5.rst:399
#, fuzzy
msgid ""
"No matter what happened previously, the *final-block* is executed once the "
"code block is complete and any raised exceptions handled. Even if there's an "
"error in an exception handler or the *else-block* and a new exception is "
"raised, the code in the *final-block* is still run."
msgstr ""
"無論之前發生了什麼，*final-block* "
"都會在程式碼塊完成並處理任何引發的例外後執行。即使在例外處理程式或 *else-"
"block* 中出現錯誤並引發新的例外，*final-block* 中的程式碼仍會運行。"

#: ../../whatsnew/2.5.rst:407
#, fuzzy
msgid ":pep:`341` - Unifying try-except and try-finally"
msgstr ":pep:`341` - 統一 try-except 和 try-finally"

#: ../../whatsnew/2.5.rst:408
msgid "PEP written by Georg Brandl;  implementation by Thomas Lee."
msgstr "由 Georg Brandl 撰寫 PEP；由 Thomas Lee 實作。"

#: ../../whatsnew/2.5.rst:416
#, fuzzy
msgid "PEP 342: New Generator Features"
msgstr "PEP 342：新的生成器特性"

#: ../../whatsnew/2.5.rst:418
#, fuzzy
msgid ""
"Python 2.5 adds a simple way to pass values *into* a generator. As "
"introduced in Python 2.3, generators only produce output; once a generator's "
"code was invoked to create an iterator, there was no way to pass any new "
"information into the function when its execution is resumed.  Sometimes the "
"ability to pass in some information would be useful.  Hackish solutions to "
"this include making the generator's code look at a global variable and then "
"changing the global variable's value, or passing in some mutable object that "
"callers then modify."
msgstr ""
"Python 2.5 新增了一種將值傳遞*到*生成器的簡單方法。正如在 Python 2.3 中引入的"
"那樣，生成器只產生輸出；一旦呼叫了生成器的程式碼來建立疊代器，就無法在恢復執"
"行時將任何新資訊傳遞到函式中。有時傳遞某些資訊的能力會很有用。對此的 hackish "
"解決方案包括讓生成器的程式碼查看全局變數然後更改全局變數的值，或者傳入一些可"
"變物件供呼叫者修改。"

#: ../../whatsnew/2.5.rst:426
#, fuzzy
msgid "To refresh your memory of basic generators, here's a simple example::"
msgstr "為了刷新您對基本生成器的記憶，這裡有一個簡單的例子::"

#: ../../whatsnew/2.5.rst:434
#, fuzzy
msgid ""
"When you call ``counter(10)``, the result is an iterator that returns the "
"values from 0 up to 9.  On encountering the :keyword:`yield` statement, the "
"iterator returns the provided value and suspends the function's execution, "
"preserving the local variables. Execution resumes on the following call to "
"the iterator's :meth:`next` method, picking up after the :keyword:`!yield` "
"statement."
msgstr ""
"當你呼叫 ``counter(10)`` 時，結果是一個疊代器，它回傳從 0 到 9 的值。在遇到 "
":keyword:`yield` 語句時，疊代器回傳提供的值並暫停函式的執行，保留局部變數。"
"在以下對疊代器的 next 方法的呼叫中恢復執行，在 :keyword:`!yield` "
"語句之後繼續執行。"

#: ../../whatsnew/2.5.rst:440
#, fuzzy
msgid ""
"In Python 2.3, :keyword:`yield` was a statement; it didn't return any "
"value.  In 2.5, :keyword:`!yield` is now an expression, returning a value "
"that can be assigned to a variable or otherwise operated on::"
msgstr ""
"在 Python 2.3 中，:keyword:`yield` 是一個語句；它沒有回傳任何值。在 2.5 "
"中，:keyword:`!yield` "
"現在是一個表達式，回傳一個可以分配給變數或以其他方式操作的值："

#: ../../whatsnew/2.5.rst:446
#, fuzzy
msgid ""
"I recommend that you always put parentheses around a :keyword:`yield` "
"expression when you're doing something with the returned value, as in the "
"above example. The parentheses aren't always necessary, but it's easier to "
"always add them instead of having to remember when they're needed."
msgstr ""
"我建議您在對回傳值執行某些操作時始終將 :keyword:`yield` 表達式括起來，如上例"
"所示。括號並不總是必需的，但始終新增它們比在需要時記住它們更容易。"

#: ../../whatsnew/2.5.rst:451
#, fuzzy
msgid ""
"(:pep:`342` explains the exact rules, which are that a :keyword:`yield`\\ -"
"expression must always be parenthesized except when it occurs at the top-"
"level expression on the right-hand side of an assignment.  This means you "
"can write ``val = yield i`` but have to use parentheses when there's an "
"operation, as in ``val = (yield i) + 12``.)"
msgstr ""
"(:pep:`342` 解釋了確切的規則，即 :keyword:`yield`\\ "
"-表達式必須始終用括號括起來，除非它出現在賦值右側的頂級表達式中。"
"這意味著你可以寫 ``val = yield i`` 但是當有操作時必須使用括號，如 ``val = ("
"yield i) + 12``。）"

#: ../../whatsnew/2.5.rst:458
#, fuzzy
msgid ""
"Values are sent into a generator by calling its ``send(value)`` method.  The "
"generator's code is then resumed and the :keyword:`yield` expression returns "
"the specified *value*.  If the regular :meth:`next` method is called, the :"
"keyword:`!yield` returns :const:`None`."
msgstr ""
"通過呼叫其 send(value) 方法將值發送到生成器。然後恢復生成器的程式碼，yield "
"表達式回傳指定的*值*。如果呼叫常規 :meth:`next` 方法，則 :keyword:`!yield` "
"回傳 :const:`None`。"

#: ../../whatsnew/2.5.rst:463
#, fuzzy
msgid ""
"Here's the previous example, modified to allow changing the value of the "
"internal counter. ::"
msgstr "這是前面的示例，修改後允許更改內部計數器的值。 ::"

#: ../../whatsnew/2.5.rst:476
#, fuzzy
msgid "And here's an example of changing the counter::"
msgstr "這是更改計數器的示例::"

#: ../../whatsnew/2.5.rst:493
#, fuzzy
msgid ""
":keyword:`yield` will usually return :const:`None`, so you should always "
"check for this case.  Don't just use its value in expressions unless you're "
"sure that the :meth:`send` method will be the only method used to resume "
"your generator function."
msgstr ""
":keyword:`yield` 通常會回傳 "
":const:`None`，因此您應該始終檢查這種情況。不要只在表達式中使用它的值，"
"除非你確定 :meth:`send` 方法將是唯一用於恢復生成器函式的方法。"

#: ../../whatsnew/2.5.rst:498
#, fuzzy
msgid ""
"In addition to :meth:`send`, there are two other new methods on generators:"
msgstr "除了 :meth:`send` 之外，生成器還有另外兩個新方法："

#: ../../whatsnew/2.5.rst:500
#, fuzzy
msgid ""
"``throw(type, value=None, traceback=None)`` is used to raise an exception "
"inside the generator; the exception is raised by the :keyword:`yield` "
"expression where the generator's execution is paused."
msgstr ""
"``throw(type, value=None, traceback=None)`` 用於在生成器內部引發例外；"
"生成器執行暫停的 :keyword:`yield` 表達式會引發例外。"

#: ../../whatsnew/2.5.rst:504
#, fuzzy
msgid ""
":meth:`close` raises a new :exc:`GeneratorExit` exception inside the "
"generator to terminate the iteration.  On receiving this exception, the "
"generator's code must either raise :exc:`GeneratorExit` or :exc:"
"`StopIteration`.  Catching the :exc:`GeneratorExit` exception and returning "
"a value is illegal and will trigger a :exc:`RuntimeError`; if the function "
"raises some other exception, that exception is propagated to the caller.  :"
"meth:`close` will also be called by Python's garbage collector when the "
"generator is garbage-collected."
msgstr ""
":meth:`close` 在生成器內部引發一個新的 :exc:`GeneratorExit` "
"例外以終止疊代。收到此例外時，生成器的程式碼必須引發 :exc:`GeneratorExit` 或 "
":exc:`StopIteration`。捕獲 :exc:`GeneratorExit` 例外並回傳一個值是非法的，"
"將觸發 "
":exc:`RuntimeError`；如果該函式引發了一些其他例外，則該例外將傳播給呼叫者。 "
":meth:`close` 也會在生成器被垃圾回收時被 Python 的垃圾回收器呼叫。"

#: ../../whatsnew/2.5.rst:512
#, fuzzy
msgid ""
"If you need to run cleanup code when a :exc:`GeneratorExit` occurs, I "
"suggest using a ``try: ... finally:`` suite instead of  catching :exc:"
"`GeneratorExit`."
msgstr ""
"如果您需要在 :exc:`GeneratorExit` 發生時運行清理程式碼，我建議使用 ``try: "
"... finally:`` 套件而不是捕獲 :exc:`GeneratorExit`。"

#: ../../whatsnew/2.5.rst:515
#, fuzzy
msgid ""
"The cumulative effect of these changes is to turn generators from one-way "
"producers of information into both producers and consumers."
msgstr "這些變化的累積效應是將生成者從單向資訊生產者轉變為生產者和消費者。"

#: ../../whatsnew/2.5.rst:518
#, fuzzy
msgid ""
"Generators also become *coroutines*, a more generalized form of subroutines. "
"Subroutines are entered at one point and exited at another point (the top of "
"the function, and a :keyword:`return` statement), but coroutines can be "
"entered, exited, and resumed at many different points (the :keyword:`yield` "
"statements). We'll have to figure out patterns for using coroutines "
"effectively in Python."
msgstr ""
"生成器也成為*協程*，一種更通用的子例程形式。子例程在一個點進入，在另一個點退"
"出（函式的頂部，和一個 :keyword:`return` "
"語句），但是協程可以在許多不同的點進入、退出和恢復（:keyword:`yield ` "
"語句）。我們必須找出在 Python 中有效使用協程的模式。"

#: ../../whatsnew/2.5.rst:524
#, fuzzy
msgid ""
"The addition of the :meth:`close` method has one side effect that isn't "
"obvious. :meth:`close` is called when a generator is garbage-collected, so "
"this means the generator's code gets one last chance to run before the "
"generator is destroyed. This last chance means that ``try...finally`` "
"statements in generators can now be guaranteed to work; the :keyword:"
"`finally` clause will now always get a chance to run.  The syntactic "
"restriction that you couldn't mix :keyword:`yield` statements with a ``try..."
"finally`` suite has therefore been removed.  This seems like a minor bit of "
"language trivia, but using generators and ``try...finally`` is actually "
"necessary in order to implement the :keyword:`with` statement described by :"
"pep:`343`.  I'll look at this new statement in the following  section."
msgstr ""
"新增 :meth:`close` 方法有一個不明顯的副作用。 :meth:`close` 在生成器被垃圾回"
"收時呼叫，因此這意味著生成器的程式碼在生成器被銷毀之前獲得最後一次運行機會。"
"這最後一次機會意味著生成器中的 ``try...finally`` 語句現在可以保證工作； "
":keyword:`finally` 子句現在總是有機會運行。因此，您不能將 :keyword:`yield` "
"語句與 ``try...finally`` "
"組合混合的句法限制已被刪除。這似乎是一個小的語言瑣事，"
"但實際上需要使用生成器和 ``try...finally`` 來實作 :keyword:`with` 描述的 "
":pep:`343` 語句。我將在下一節中查看這個新聲明。"

#: ../../whatsnew/2.5.rst:536
#, fuzzy
msgid ""
"Another even more esoteric effect of this change: previously, the :attr:"
"`gi_frame` attribute of a generator was always a frame object. It's now "
"possible for :attr:`gi_frame` to be ``None`` once the generator has been "
"exhausted."
msgstr ""
"此更改的另一個更深奧的影響：以前，生成器的 :attr:`gi_frame` "
"屬性始終是一個框架物件。一旦生成器耗盡，現在 :attr:`gi_frame` 可能為 "
"``None``。"

#: ../../whatsnew/2.5.rst:549
#, fuzzy
msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ":pep:`342` - 通過增強生成器的協程"

#: ../../whatsnew/2.5.rst:545
#, fuzzy
msgid ""
"PEP written by  Guido van Rossum and Phillip J. Eby; implemented by Phillip "
"J. Eby.  Includes examples of  some fancier uses of generators as coroutines."
msgstr ""
"PEP 由 Guido van Rossum 和 Phillip J. Eby 撰寫；由 Phillip J. Eby "
"實施。包括將生成器用作協程的一些更有趣的示例。"

#: ../../whatsnew/2.5.rst:548
#, fuzzy
msgid ""
"Earlier versions of these features were proposed in  :pep:`288` by Raymond "
"Hettinger and :pep:`325` by Samuele Pedroni."
msgstr ""
"這些功能的早期版本由 Raymond Hettinger 在 :pep:`288` 和 Samuele Pedroni 的 "
":pep:`325` 中提出。"

#: ../../whatsnew/2.5.rst:552
msgid "https://en.wikipedia.org/wiki/Coroutine"
msgstr "https://en.wikipedia.org/wiki/Coroutine"

#: ../../whatsnew/2.5.rst:552
#, fuzzy
msgid "The Wikipedia entry for  coroutines."
msgstr "協程的維基百科條目。"

#: ../../whatsnew/2.5.rst:554
#, fuzzy
msgid ""
"https://web.archive.org/web/20160321211320/http://www.sidhe.org/~dan/blog/"
"archives/000178.html"
msgstr ""
"https://web.archive.org/web/20160321211320/http://www.sidhe.org/~dan/blog/"
"archives/000178.html"

#: ../../whatsnew/2.5.rst:555
#, fuzzy
msgid ""
"An explanation of coroutines from a Perl point of view, written by Dan "
"Sugalski."
msgstr "從 Perl 的角度解釋協程，由 Dan Sugalski 撰寫。"

#: ../../whatsnew/2.5.rst:563
#, fuzzy
msgid "PEP 343: The 'with' statement"
msgstr "PEP 343： ``with``語句"

#: ../../whatsnew/2.5.rst:565
#, fuzzy
msgid ""
"The ':keyword:`with`' statement clarifies code that previously would use "
"``try...finally`` blocks to ensure that clean-up code is executed.  In this "
"section, I'll discuss the statement as it will commonly be used.  In the "
"next section, I'll examine the implementation details and show how to write "
"objects for use with this statement."
msgstr ""
"':keyword:`with`' 語句澄清了以前使用 ``try...finally`` 塊來確保執行清理程式碼"
"的程式碼。在本節中，我將討論該語句，因為它通常會被使用。在下一節中，我將檢查"
"實作細節並展示如何編寫用於此語句的物件。"

#: ../../whatsnew/2.5.rst:571
#, fuzzy
msgid ""
"The ':keyword:`with`' statement is a new control-flow structure whose basic "
"structure is::"
msgstr "':keyword:`with`' 語句是一個新的控制流結構，其基本結構是："

#: ../../whatsnew/2.5.rst:577
#, fuzzy
msgid ""
"The expression is evaluated, and it should result in an object that supports "
"the context management protocol (that is, has :meth:`__enter__` and :meth:"
"`__exit__` methods."
msgstr ""
"對錶達式進行求值，它應該產生一個支援上下文管理協定的物件（即，具有 "
":meth:`__enter__` 和 :meth:`__exit__` 方法。"

#: ../../whatsnew/2.5.rst:581
#, fuzzy
msgid ""
"The object's :meth:`__enter__` is called before *with-block* is executed and "
"therefore can run set-up code. It also may return a value that is bound to "
"the name *variable*, if given.  (Note carefully that *variable* is *not* "
"assigned the result of *expression*.)"
msgstr ""
"物件的 :meth:`__enter__` 在執行 *with-block* "
"之前被呼叫，因此可以運行設定程式碼。它還可能回傳一個綁定到名稱 *variable* "
"的值，如果給定的話。 （請注意，*變數* *未* 分配 *表達式* 的結果。）"

#: ../../whatsnew/2.5.rst:586
#, fuzzy
msgid ""
"After execution of the *with-block* is finished, the object's :meth:"
"`__exit__` method is called, even if the block raised an exception, and can "
"therefore run clean-up code."
msgstr "*with-block* 執行完成後，將呼叫物件的 :meth:`__exit__` "
"方法，即使該塊引發例外，也可以因此運行清理程式碼。"

#: ../../whatsnew/2.5.rst:590
#, fuzzy
msgid ""
"To enable the statement in Python 2.5, you need to add the following "
"directive to your module::"
msgstr "要在 Python 2.5 中啟用該語句，您需要將以下指令新增到您的模組中："

#: ../../whatsnew/2.5.rst:595
#, fuzzy
msgid "The statement will always be enabled in Python 2.6."
msgstr "該語句將始終在 Python 2.6 中啟用。"

#: ../../whatsnew/2.5.rst:597
#, fuzzy
msgid ""
"Some standard Python objects now support the context management protocol and "
"can be used with the ':keyword:`with`' statement. File objects are one "
"example::"
msgstr "一些標準的 Python 物件現在支援上下文管理協定，並且可以與 ':keyword:`with`' "
"語句一起使用。文件物件就是一個例子::"

#: ../../whatsnew/2.5.rst:605
#, fuzzy
msgid ""
"After this statement has executed, the file object in *f* will have been "
"automatically closed, even if the :keyword:`for` loop raised an exception "
"part-way through the block."
msgstr "執行此語句後，*f* 中的文件物件將自動關閉，即使 for "
"循環在塊中途引發例外也是如此。"

#: ../../whatsnew/2.5.rst:611
#, fuzzy
msgid ""
"In this case, *f* is the same object created by :func:`open`, because :meth:"
"`file.__enter__` returns *self*."
msgstr "在這種情況下，*f* 與 :func:`open` 建立的物件相同，因為 :meth:`file.__enter__`"
" 回傳 *self*。"

#: ../../whatsnew/2.5.rst:614
#, fuzzy
msgid ""
"The :mod:`threading` module's locks and condition variables  also support "
"the ':keyword:`with`' statement::"
msgstr ":mod:`threading` 模組的鎖和條件變數也支援 ':keyword:`with`' 語句::"

#: ../../whatsnew/2.5.rst:622
#, fuzzy
msgid ""
"The lock is acquired before the block is executed and always released once  "
"the block is complete."
msgstr "鎖在塊執行之前獲取，並在塊完成後始終釋放。"

#: ../../whatsnew/2.5.rst:625
#, fuzzy
msgid ""
"The new :func:`localcontext` function in the :mod:`decimal` module makes it "
"easy to save and restore the current decimal context, which encapsulates the "
"desired precision and rounding characteristics for computations::"
msgstr ""
":mod:`decimal` 模組中的新 :func:`localcontext` "
"函式可以輕鬆保存和恢復當前的十進位上下文，它封裝了計算所需的精度和舍入特性::"

#: ../../whatsnew/2.5.rst:644
#, fuzzy
msgid "Writing Context Managers"
msgstr "編寫上下文管理器"

#: ../../whatsnew/2.5.rst:646
#, fuzzy
msgid ""
"Under the hood, the ':keyword:`with`' statement is fairly complicated. Most "
"people will only use ':keyword:`!with`' in company with existing objects and "
"don't need to know these details, so you can skip the rest of this section "
"if you like.  Authors of new objects will need to understand the details of "
"the underlying implementation and should keep reading."
msgstr ""
"在幕後，':keyword:`with`' 語句相當複雜。大多數人只會將 ':keyword:`!with`' 與"
"現有對像一起使用，不需要了解這些細節，因此您可以根據需要跳過本節的其餘部分。"
"新物件的作者需要了解底層實作的細節並且應該繼續閱讀。"

#: ../../whatsnew/2.5.rst:652
#, fuzzy
msgid "A high-level explanation of the context management protocol is:"
msgstr "上下文管理協定的高階解釋是："

#: ../../whatsnew/2.5.rst:654
#, fuzzy
msgid ""
"The expression is evaluated and should result in an object called a "
"\"context manager\".  The context manager must have :meth:`__enter__` and :"
"meth:`__exit__` methods."
msgstr ""
"表達式被評估並且應該產生一個稱為“上下文管理器”的物件。上下文管理器必須具有 "
":meth:`__enter__` 和 :meth:`__exit__` 方法。"

#: ../../whatsnew/2.5.rst:658
#, fuzzy
msgid ""
"The context manager's :meth:`__enter__` method is called.  The value "
"returned is assigned to *VAR*.  If no ``'as VAR'`` clause is present, the "
"value is simply discarded."
msgstr ""
"上下文管理器的 :meth:`__enter__` 方法被呼叫。回傳的值分配給 *VAR*。"
"如果不存在 ``'as VAR'`` 子句，則該值將被簡單地丟棄。"

#: ../../whatsnew/2.5.rst:662
#, fuzzy
msgid "The code in *BLOCK* is executed."
msgstr "*BLOCK* 中的程式碼被執行。"

#: ../../whatsnew/2.5.rst:664
#, fuzzy
msgid ""
"If *BLOCK* raises an exception, the ``__exit__(type, value, traceback)`` is "
"called with the exception details, the same values returned by :func:`sys."
"exc_info`.  The method's return value controls whether the exception is re-"
"raised: any false value re-raises the exception, and ``True`` will result in "
"suppressing it.  You'll only rarely want to suppress the exception, because "
"if you do the author of the code containing the ':keyword:`with`' statement "
"will never realize anything went wrong."
msgstr ""
"如果 *BLOCK* 引發例外，則使用例外詳細資訊呼叫 `__exit__(type, value, "
"traceback)``，與 :func:`sys.exc_info` "
"回傳的值相同。該方法的回傳值控制是否重新引發例外：任何 false "
"值都會重新引發例外，而 ``True`` 將導致抑制它。你很少會想要抑制例外，因為如果"
"你這樣做，包含':keyword:`with`'語句的程式碼的作者將永遠不會意識到出了什麼問題"
"。"

#: ../../whatsnew/2.5.rst:672
#, fuzzy
msgid ""
"If *BLOCK* didn't raise an exception,  the :meth:`__exit__` method is still "
"called, but *type*, *value*, and *traceback* are all ``None``."
msgstr ""
"如果 *BLOCK* 沒有引發例外，:meth:`__exit__` 方法仍然會被呼叫，但是 "
"*type*、*value* 和 *traceback* 都是 ``None``。"

#: ../../whatsnew/2.5.rst:675
#, fuzzy
msgid ""
"Let's think through an example.  I won't present detailed code but will only "
"sketch the methods necessary for a database that supports transactions."
msgstr "讓我們通過一個例子來思考。我不會提供詳細的程式碼，而只會概述支援事務的資料庫"
"所需的方法。"

#: ../../whatsnew/2.5.rst:678
#, fuzzy
msgid ""
"(For people unfamiliar with database terminology: a set of changes to the "
"database are grouped into a transaction.  Transactions can be either "
"committed, meaning that all the changes are written into the database, or "
"rolled back, meaning that the changes are all discarded and the database is "
"unchanged.  See any database textbook for more information.)"
msgstr ""
"（對於不熟悉資料庫術語的人：對資料庫的一組更改被分組到一個事務中。事務可以是"
"提交的，這意味著所有的更改都被寫入資料庫，或者回滾，這意味著所有的更改都被丟"
"棄並且資料庫不變。有關更多資訊，請參閱任何資料庫教科書。）"

#: ../../whatsnew/2.5.rst:684
#, fuzzy
msgid ""
"Let's assume there's an object representing a database connection. Our goal "
"will be to let the user write code like this::"
msgstr "假設有一個表示資料庫連接的物件。我們的目標是讓使用者編寫這樣的程式碼::"

#: ../../whatsnew/2.5.rst:693
#, fuzzy
msgid ""
"The transaction should be committed if the code in the block runs flawlessly "
"or rolled back if there's an exception. Here's the basic interface for :"
"class:`DatabaseConnection` that I'll assume::"
msgstr ""
"如果塊中的程式碼運行無誤，則應提交事務；如果出現例外，則應回滾。這是我假設的 "
":class:`DatabaseConnection` 的基本介面："

#: ../../whatsnew/2.5.rst:706
#, fuzzy
msgid ""
"The :meth:`__enter__` method is pretty easy, having only to start a new "
"transaction.  For this application the resulting cursor object would be a "
"useful result, so the method will return it.  The user can then add ``as "
"cursor`` to their ':keyword:`with`' statement to bind the cursor to a "
"variable name. ::"
msgstr ""
":meth:`__enter__` 方法非常簡單，只需開始一個新事務。對於此應用程式，生成的游"
"標物件將是一個有用的結果，因此該方法將回傳它。然後，使用者可以將 ``as "
"cursor`` 新增到他們的 ':keyword:`with`' 語句中，以將游標綁定到變數名。 ::"

#: ../../whatsnew/2.5.rst:718
#, fuzzy
msgid ""
"The :meth:`__exit__` method is the most complicated because it's where most "
"of the work has to be done.  The method has to check if an exception "
"occurred.  If there was no exception, the transaction is committed.  The "
"transaction is rolled back if there was an exception."
msgstr ""
":meth:`__exit__` 方法是最複雜的，因為它是大部分工作必須完成的地方。該方法必須"
"檢查是否發生例外。如果沒有例外，則提交事務。如果出現例外，事務將回滾。"

#: ../../whatsnew/2.5.rst:723
#, fuzzy
msgid ""
"In the code below, execution will just fall off the end of the function, "
"returning the default value of ``None``.  ``None`` is false, so the "
"exception will be re-raised automatically.  If you wished, you could be more "
"explicit and add a :keyword:`return` statement at the marked location. ::"
msgstr ""
"在下面的程式碼中，執行將剛好從函式的末尾掉下來，回傳預設值 ``None``。 ``None`` "
"為 false，因此將自動重新引發例外。如果您願意，您可以更明確地在標記位置新增一"
"個 :keyword:`return` 語句。 ::"

#: ../../whatsnew/2.5.rst:743
#, fuzzy
msgid "The contextlib module"
msgstr "上下文庫模組"

#: ../../whatsnew/2.5.rst:745
#, fuzzy
msgid ""
"The new :mod:`contextlib` module provides some functions and a decorator "
"that are useful for writing objects for use with the ':keyword:`with`' "
"statement."
msgstr ""
"新的 :mod:`contextlib` 模組提供了一些函式和一個裝飾器，可用於編寫與 "
"':keyword:`with`' 語句一起使用的物件。"

#: ../../whatsnew/2.5.rst:748
#, fuzzy
msgid ""
"The decorator is called :func:`contextmanager`, and lets you write a single "
"generator function instead of defining a new class.  The generator should "
"yield exactly one value.  The code up to the :keyword:`yield` will be "
"executed as the :meth:`__enter__` method, and the value yielded will be the "
"method's return value that will get bound to the variable in the ':keyword:"
"`with`' statement's :keyword:`!as` clause, if any.  The code after the :"
"keyword:`yield` will be executed in the :meth:`__exit__` method.  Any "
"exception raised in the block will be raised by the :keyword:`!yield` "
"statement."
msgstr ""
"裝飾器稱為 :func:`contextmanager`，可讓您編寫單個生成器函式而不是定義新類。生"
"成器應該只產生一個值。 :keyword:`yield` 之前的程式碼將作為 :meth:`__enter__` "
"方法執行，產生的值將是方法的回傳值，該值將綁定到 ':keyword:`with` 中的變數' "
"語句的 :keyword:`!as` 子句，如果有的話。 :keyword:`yield` 之後的程式碼將在 "
":meth:`__exit__` 方法中執行。塊中引發的任何例外都將由 :keyword:`!yield` "
"語句引發。"

#: ../../whatsnew/2.5.rst:757
#, fuzzy
msgid ""
"Our database example from the previous section could be written  using this "
"decorator as::"
msgstr "上一節中的資料庫示例可以使用此裝飾器編寫為："

#: ../../whatsnew/2.5.rst:777
#, fuzzy
msgid ""
"The :mod:`contextlib` module also has a ``nested(mgr1, mgr2, ...)`` function "
"that combines a number of context managers so you don't need to write nested "
"':keyword:`with`' statements.  In this example, the single ':keyword:`!"
"with`' statement both starts a database transaction and acquires a thread "
"lock::"
msgstr ""
":mod:`contextlib` 模組還有一個``nested(mgr1, mgr2, ...)`` "
"函式，它結合了多個上下文管理器，所以你不需要編寫 nested "
"':keyword:`with`'聲明。在此示例中，單個 ':keyword:`!with`' "
"語句啟動資料庫事務並獲取執行緒鎖::"

#: ../../whatsnew/2.5.rst:786
#, fuzzy
msgid ""
"Finally, the ``closing(object)`` function returns *object* so that it can be "
"bound to a variable, and calls ``object.close`` at the end of the block. ::"
msgstr ""
"最後，``closing(object)`` 函式回傳 *object* 以便它可以綁定到一個變數，"
"並在塊的末尾呼叫 ``object.close``。 ::"

#: ../../whatsnew/2.5.rst:803
#, fuzzy
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` -  ``with``語句"

#: ../../whatsnew/2.5.rst:800
#, fuzzy
msgid ""
"PEP written by Guido van Rossum and Nick Coghlan; implemented by Mike Bland, "
"Guido van Rossum, and Neal Norwitz.  The PEP shows the code generated for a "
"':keyword:`with`' statement, which can be helpful in learning how the "
"statement works."
msgstr ""
"PEP 由 Guido van Rossum 和 Nick Coghlan 撰寫；由 Mike Bland、Guido van "
"Rossum 和 Neal Norwitz 實施。 PEP 顯示了為 ':keyword:`with`' "
"語句生成的程式碼，這有助於了解該語句的工作原理。"

#: ../../whatsnew/2.5.rst:805
#, fuzzy
msgid "The documentation  for the :mod:`contextlib` module."
msgstr ":mod:`contextlib` 模組的文檔。"

#: ../../whatsnew/2.5.rst:813
#, fuzzy
msgid "PEP 352: Exceptions as New-Style Classes"
msgstr "PEP 352：作為新型類的例外"

#: ../../whatsnew/2.5.rst:815
#, fuzzy
msgid ""
"Exception classes can now be new-style classes, not just classic classes, "
"and the built-in :exc:`Exception` class and all the standard built-in "
"exceptions (:exc:`NameError`, :exc:`ValueError`, etc.) are now new-style "
"classes."
msgstr ""
"例外類現在可以是新式類，而不僅僅是經典類，內建的 :exc:`Exception` "
"類和所有標準的內建例外 (:exc:`NameError`, "
":exc:`ValueError`,等）現在是新型類。"

#: ../../whatsnew/2.5.rst:819
#, fuzzy
msgid ""
"The inheritance hierarchy for exceptions has been rearranged a bit. In 2.5, "
"the inheritance relationships are::"
msgstr "例外的繼承層次結構已經重新排列了一點。 2.5中，繼承關係為：："

#: ../../whatsnew/2.5.rst:828
#, fuzzy
msgid ""
"This rearrangement was done because people often want to catch all "
"exceptions that indicate program errors.  :exc:`KeyboardInterrupt` and :exc:"
"`SystemExit` aren't errors, though, and usually represent an explicit action "
"such as the user hitting :kbd:`Control-C` or code calling :func:`sys.exit`.  "
"A bare ``except:`` will catch all exceptions, so you commonly need to list :"
"exc:`KeyboardInterrupt` and :exc:`SystemExit` in order to re-raise them.  "
"The usual pattern is::"
msgstr ""
"之所以進行這種重新安排，是因為人們通常希望捕獲所有指示程式錯誤的例外。不過，:"
"exc:`KeyboardInterrupt` 和 :exc:`SystemExit` "
"不是錯誤，它們通常表示一個顯式操作，例如使用者點擊 :kbd:`Control-C` "
"或程式碼呼叫 :func:`sys.exit` .簡單的 ``except:`` 將捕獲所有例外，"
"因此您通常需要列出 :exc:`KeyboardInterrupt` 和 :exc:`SystemExit` "
"以便重新引發它們。通常的模式是："

#: ../../whatsnew/2.5.rst:843
#, fuzzy
msgid ""
"In Python 2.5, you can now write ``except Exception`` to achieve the same "
"result, catching all the exceptions that usually indicate errors  but "
"leaving :exc:`KeyboardInterrupt` and :exc:`SystemExit` alone.  As in "
"previous versions, a bare ``except:`` still catches all exceptions."
msgstr ""
"在 Python 2.5 中，您現在可以編寫 ``except Exception`` "
"來獲得相同的結果，捕獲所有通常指示錯誤的例外，但單獨留下 "
":exc:`KeyboardInterrupt` 和 :exc:`SystemExit`。與以前的版本一樣，一個簡單的 "
"``except:`` 仍然捕獲所有例外。"

#: ../../whatsnew/2.5.rst:848
#, fuzzy
msgid ""
"The goal for Python 3.0 is to require any class raised as an exception to "
"derive from :exc:`BaseException` or some descendant of :exc:`BaseException`, "
"and future releases in the Python 2.x series may begin to enforce this "
"constraint. Therefore, I suggest you begin making all your exception classes "
"derive from :exc:`Exception` now.  It's been suggested that the bare "
"``except:`` form should be removed in Python 3.0, but Guido van Rossum "
"hasn't decided whether to do this or not."
msgstr ""
"Python 3.0 的目標是要求任何作為例外引發的類派生自 :exc:`BaseException` 或 "
":exc:`BaseException` 的某些後代，並且 Python 2.x "
"系列的未來版本可能會開始強制執行此約束.因此，"
"我建議您現在開始讓所有例外類都派生自 :exc:`Exception`。有人建議應該在 Python "
"3.0 中刪除裸露的 ``except:`` 形式，但 Guido van Rossum 尚未決定是否這樣做。"

#: ../../whatsnew/2.5.rst:856
#, fuzzy
msgid ""
"Raising of strings as exceptions, as in the statement ``raise \"Error "
"occurred\"``, is deprecated in Python 2.5 and will trigger a warning.  The "
"aim is to be able to remove the string-exception feature in a few releases."
msgstr "將字串作為例外引發，如語句“引發“發生錯誤””，在 Python 2.5 "
"中已棄用，並將觸發警告。目的是能夠在幾個版本中刪除字串例外功能。"

#: ../../whatsnew/2.5.rst:863
#, fuzzy
msgid ":pep:`352` - Required Superclass for Exceptions"
msgstr ":pep:`352` - 例外所需的超類"

#: ../../whatsnew/2.5.rst:864
#, fuzzy
msgid ""
"PEP written by  Brett Cannon and Guido van Rossum; implemented by Brett "
"Cannon."
msgstr "PEP 由 Brett Cannon 和 Guido van Rossum 撰寫；由 Brett Cannon 實施。"

#: ../../whatsnew/2.5.rst:872
#, fuzzy
msgid "PEP 353: Using ssize_t as the index type"
msgstr "PEP 353：使用 ssize_t 作為索引型別"

#: ../../whatsnew/2.5.rst:874
#, fuzzy
msgid ""
"A wide-ranging change to Python's C API, using a new  :c:type:`Py_ssize_t` "
"type definition instead of :c:expr:`int`,  will permit the interpreter to "
"handle more data on 64-bit platforms. This change doesn't affect Python's "
"capacity on 32-bit platforms."
msgstr ""
"使用新的 Py_ssize_t 型別定義而不是 :c:expr:`int 對 Python 的 C API "
"進行了廣泛的更改，這將允許直譯器在 64 位平台上處理更多資料。此更改不會影響 "
"Python 在 32 位平台上的容量。"

#: ../../whatsnew/2.5.rst:879
#, fuzzy
msgid ""
"Various pieces of the Python interpreter used C's :c:expr:`int` type to "
"store sizes or counts; for example, the number of items in a list or tuple "
"were stored in an :c:expr:`int`.  The C compilers for most 64-bit platforms "
"still define :c:expr:`int` as a 32-bit type, so that meant that lists could "
"only hold up to ``2**31 - 1`` = 2147483647 items. (There are actually a few "
"different programming models that 64-bit C compilers can use -- see https://"
"unix.org/version2/whatsnew/lp64_wp.html for a discussion -- but the most "
"commonly available model leaves :c:expr:`int` as 32 bits.)"
msgstr ""
"Python 直譯器的各個部分使用 C 的 :c:expr:`int` 型別來儲存大小或計數；例如，"
"列表或元組中的項目數儲存在 :c:expr:`int` 中。大多數 64 位平台的 C "
"編譯器仍然將 :c:expr:`int` 定義為 32 位型別，這意味著列表最多只能容納 ``2**"
"31 - 1`` = 2147483647 項。 （實際上，64 位 C "
"編譯器可以使用幾種不同的編程模型——有關討論，請參閱 https://unix.org/version2/"
"whatsnew/lp64_wp.html——但最常用的模型是:c:expr:`int` 作為 32 位。）"

#: ../../whatsnew/2.5.rst:888
#, fuzzy
msgid ""
"A limit of 2147483647 items doesn't really matter on a 32-bit platform "
"because you'll run out of memory before hitting the length limit. Each list "
"item requires space for a pointer, which is 4 bytes, plus space for a :c:"
"type:`PyObject` representing the item.  2147483647\\*4 is already more bytes "
"than a 32-bit address space can contain."
msgstr ""
"2147483647 個項目的限制在 32 位平台上並不重要，因為您會在達到長度限制之前耗盡"
"記憶體。每個列表項都需要一個指標空間，即 4 個位元組，再加上表示該項目的 "
"PyObject 的空間。 2147483647\\*4 已經超過了 32 位地址空間可以包含的位元組數。"

#: ../../whatsnew/2.5.rst:894
#, fuzzy
msgid ""
"It's possible to address that much memory on a 64-bit platform, however.  "
"The pointers for a list that size would only require 16 GiB of space, so "
"it's not unreasonable that Python programmers might construct lists that "
"large. Therefore, the Python interpreter had to be changed to use some type "
"other than :c:expr:`int`, and this will be a 64-bit type on 64-bit "
"platforms.  The change will cause incompatibilities on 64-bit machines, so "
"it was deemed worth making the transition now, while the number of 64-bit "
"users is still relatively small. (In 5 or 10 years, we may *all* be on 64-"
"bit machines, and the transition would be more painful then.)"
msgstr ""
"但是，可以在 64 位平台上尋址這麼多記憶體。這種大小的列表的指標只需要 16 GiB "
"的空間，因此 Python 程式員可能會構造這麼大的列表並不是沒有道理的。因此，"
"Python 直譯器必須更改為使用 :c:expr:`int` 以外的某種型別，這將是 64 "
"位平台上的 64 位型別。該更改將導致 64 "
"位機器不相容，因此認為現在進行轉換是值得的，而 64 "
"位使用者的數量仍然相對較少。 （5 年或 10 年後，我們可能*全部*都在 64 "
"位機器上，屆時過渡會更加痛苦。）"

#: ../../whatsnew/2.5.rst:904
#, fuzzy
msgid ""
"This change most strongly affects authors of C extension modules.   Python "
"strings and container types such as lists and tuples  now use :c:type:"
"`Py_ssize_t` to store their size.   Functions such as :c:func:`PyList_Size`  "
"now return :c:type:`Py_ssize_t`.  Code in extension modules may therefore "
"need to have some variables changed to :c:type:`Py_ssize_t`."
msgstr ""
"此更改對 C 擴充模組的作者影響最大。 Python 字串和容器型別（例如列表和元組）"
"現在使用 :c:type:`Py_ssize_t` 來儲存它們的大小。 :c:func:`PyList_Size` "
"等函式現在回傳 :c:type:`Py_ssize_t`。因此，"
"擴充模組中的程式碼可能需要將一些變數更改為 :c:type:`Py_ssize_t`。"

#: ../../whatsnew/2.5.rst:910
#, fuzzy
msgid ""
"The :c:func:`PyArg_ParseTuple` and :c:func:`Py_BuildValue` functions have a "
"new conversion code, ``n``, for :c:type:`Py_ssize_t`.   :c:func:"
"`PyArg_ParseTuple`'s ``s#`` and ``t#`` still output :c:expr:`int` by "
"default, but you can define the macro  :c:macro:`PY_SSIZE_T_CLEAN` before "
"including :file:`Python.h`  to make them return :c:type:`Py_ssize_t`."
msgstr ""
":c:func:`PyArg_ParseTuple` 和 :c:func:`Py_BuildValue` "
"函式有一個新的轉換程式碼，``n``，用於 :c:type:`Py_ssize_t`。 "
":c:func:`PyArg_ParseTuple` 的 ``s#`` 和 ``t#`` 仍然預設輸出 :c:expr:`int`，"
"但你可以定義巨集 :c:macro:`PY_SSIZE_T_CLEAN`在包含 :file:`Python.h` "
"使它們回傳 :c:type:`Py_ssize_t` 之前。"

#: ../../whatsnew/2.5.rst:916
#, fuzzy
msgid ""
":pep:`353` has a section on conversion guidelines that  extension authors "
"should read to learn about supporting 64-bit platforms."
msgstr ":pep:`353` 有一個關於轉換指南的部分，擴充作者應該閱讀該部分以了解支援 64 "
"位平台。"

#: ../../whatsnew/2.5.rst:922
#, fuzzy
msgid ":pep:`353` - Using ssize_t as the index type"
msgstr ":pep:`353` - 使用 ssize_t 作為索引型別"

#: ../../whatsnew/2.5.rst:923
msgid "PEP written and implemented by Martin von Löwis."
msgstr "由 Martin von Löwis 撰寫 PEP 與實作。"

#: ../../whatsnew/2.5.rst:931
#, fuzzy
msgid "PEP 357: The '__index__' method"
msgstr "PEP 357：'__index__' 方法"

#: ../../whatsnew/2.5.rst:933
#, fuzzy
msgid ""
"The NumPy developers had a problem that could only be solved by adding a new "
"special method, :meth:`__index__`.  When using slice notation, as in "
"``[start:stop:step]``, the values of the *start*, *stop*, and *step* indexes "
"must all be either integers or long integers.  NumPy defines a variety of "
"specialized integer types corresponding to unsigned and signed integers of "
"8, 16, 32, and 64 bits, but there was no way to signal that these types "
"could be used as slice indexes."
msgstr ""
"NumPy 開發人員遇到了一個只能通過新增新的特殊方法 :meth:`__index__` "
"來解決的問題。當使用切片表示法時，如在“[start:stop:step]”中，*start*、*stop* "
"和 *step* 索引的值必須全部為整數或長整數。 NumPy 定義了多種專門的整數型別，"
"對應於 8、16、32 和 64 "
"位的無符號和有符號整數，但無法表明這些型別可以用作切片索引。"

#: ../../whatsnew/2.5.rst:941
#, fuzzy
msgid ""
"Slicing can't just use the existing :meth:`__int__` method because that "
"method is also used to implement coercion to integers.  If slicing used :"
"meth:`__int__`, floating-point numbers would also become legal slice indexes "
"and that's clearly an undesirable behaviour."
msgstr ""
"切片不能只使用現有的 :meth:`__int__` "
"方法，因為該方法也用於實作對整數的強制轉換。如果切片使用 "
":meth:`__int__`，浮點數也將成為合法的切片索引，這顯然是一種不受歡迎的行為。"

#: ../../whatsnew/2.5.rst:946
#, fuzzy
msgid ""
"Instead, a new special method called :meth:`__index__` was added.  It takes "
"no arguments and returns an integer giving the slice index to use.  For "
"example::"
msgstr "相反，新增了一個名為 :meth:`__index__` "
"的新特殊方法。它不接受任何參數並回傳一個整數，給出要使用的切片索引。例如：："

#: ../../whatsnew/2.5.rst:953
#, fuzzy
msgid ""
"The return value must be either a Python integer or long integer. The "
"interpreter will check that the type returned is correct, and raises a :exc:"
"`TypeError` if this requirement isn't met."
msgstr "回傳值必須是 Python "
"整數或長整數。直譯器將檢查回傳的型別是否正確，如果不滿足此要求，則引發 "
":exc:`TypeError`。"

#: ../../whatsnew/2.5.rst:957
#, fuzzy
msgid ""
"A corresponding :attr:`nb_index` slot was added to the C-level :c:type:"
"`PyNumberMethods` structure to let C extensions implement this protocol. "
"``PyNumber_Index(obj)`` can be used in extension code to call the :meth:"
"`__index__` function and retrieve its result."
msgstr ""
"一個相應的 :attr:`nb_index` 槽被新增到 C 級:c:type:`PyNumberMethods` 結構中，"
"讓 C 擴充實作這個協定。 ``PyNumber_Index(obj)`` 可以在擴充程式碼中用於呼叫 "
":meth:`__index__` 函式並檢索其結果。"

#: ../../whatsnew/2.5.rst:965
#, fuzzy
msgid ":pep:`357` - Allowing Any Object to be Used for Slicing"
msgstr ":pep:`357` - 允許任何對像用於切片"

#: ../../whatsnew/2.5.rst:966
msgid "PEP written  and implemented by Travis Oliphant."
msgstr "由 Travis Oliphant 撰寫 PEP 與實作。"

#: ../../whatsnew/2.5.rst:974
#, fuzzy
msgid "Other Language Changes"
msgstr "其他語言變化"

#: ../../whatsnew/2.5.rst:976
#, fuzzy
msgid ""
"Here are all of the changes that Python 2.5 makes to the core Python "
"language."
msgstr "以下是 Python 2.5 對核心 Python 語言所做的所有更改。"

#: ../../whatsnew/2.5.rst:978
#, fuzzy
msgid ""
"The :class:`dict` type has a new hook for letting subclasses provide a "
"default value when a key isn't contained in the dictionary. When a key isn't "
"found, the dictionary's ``__missing__(key)`` method will be called.  This "
"hook is used to implement the new :class:`defaultdict` class in the :mod:"
"`collections` module.  The following example defines a dictionary  that "
"returns zero for any missing key::"
msgstr ""
":class:`dict` "
"型別有一個新的掛鉤，用於讓子類別在字典中不包含鍵時提供預設值。當找不到鍵時，"
"將呼叫字典的 ``__missing__(key)`` 方法。這個鉤子用於在 :mod:`collections` "
"模組中實作新的 :class:`defaultdict` "
"類。以下示例定義了一個字典，它為任何缺少的鍵回傳零："

#: ../../whatsnew/2.5.rst:993
#, fuzzy
msgid ""
"Both 8-bit and Unicode strings have new ``partition(sep)``  and "
"``rpartition(sep)`` methods that simplify a common use case."
msgstr "8 位和 Unicode 字串都有新的 ``partition(sep)`` 和 ``rpartition(sep)`` "
"方法來簡化常見用例。"

#: ../../whatsnew/2.5.rst:996
#, fuzzy
msgid ""
"The ``find(S)`` method is often used to get an index which is then used to "
"slice the string and obtain the pieces that are before and after the "
"separator. ``partition(sep)`` condenses this pattern into a single method "
"call that returns a 3-tuple containing the substring before the separator, "
"the separator itself, and the substring after the separator.  If the "
"separator isn't found, the first element of the tuple is the entire string "
"and the other two elements are empty.  ``rpartition(sep)`` also returns a 3-"
"tuple but starts searching from the end of the string; the ``r`` stands for "
"'reverse'."
msgstr ""
"``find(S)`` "
"方法通常用於獲取索引，然後使用該索引對字串進行切片並獲取分隔符前後的片段。 "
"``partition(sep)`` 將此模式壓縮為單個方法呼叫，該方法呼叫回傳一個 3 元組，其"
"中包含分隔符之前的子字串、分隔符本身以及分隔符之後的子字串。如果未找到分隔符"
"，則元組的第一個元素是整個字串，其他兩個元素為空。 ``rpartition(sep)`` "
"也回傳一個 3 元組，但從字串的末尾開始搜索； ``r`` 代表“反向”。"

#: ../../whatsnew/2.5.rst:1005
msgid "Some examples::"
msgstr ""
"一些範例：\n"
"\n"
"::"

#: ../../whatsnew/2.5.rst:1018
#, fuzzy
msgid ""
"(Implemented by Fredrik Lundh following a suggestion by Raymond Hettinger.)"
msgstr "（由 Fredrik Lundh 根據 Raymond Hettinger 的建議實施。）"

#: ../../whatsnew/2.5.rst:1020
#, fuzzy
msgid ""
"The :meth:`startswith` and :meth:`endswith` methods of string types now "
"accept tuples of strings to check for. ::"
msgstr "字串型別的 :meth:`startswith` 和 :meth:`endswith` "
"方法現在接受要檢查的字串元組。 ::"

#: ../../whatsnew/2.5.rst:1026
#, fuzzy
msgid "(Implemented by Georg Brandl following a suggestion by Tom Lynn.)"
msgstr "（由 Georg Brandl 根據 Tom Lynn 的建議實施。）"

#: ../../whatsnew/2.5.rst:1030
#, fuzzy
msgid ""
"The :func:`min` and :func:`max` built-in functions gained a ``key`` keyword "
"parameter analogous to the ``key`` argument for :meth:`sort`.  This "
"parameter supplies a function that takes a single argument and is called for "
"every value in the list; :func:`min`/:func:`max` will return the element "
"with the smallest/largest return value from this function. For example, to "
"find the longest string in a list, you can do::"
msgstr ""
":func:`min` 和 :func:`max` 內建函式獲得了一個 ``key`` 關鍵字參數，類似於 "
":meth:`sort` 的 ``key`` "
"參數。該參數提供了一個函式，該函式接受一個參數並為列表中的每個值呼叫； "
":func:`min`/:func:`max` 將從該函式回傳具有最小/最大回傳值的元素。例如，要查找"
"列表中最長的字串，您可以這樣做："

#: ../../whatsnew/2.5.rst:1043
#, fuzzy
msgid "(Contributed by Steven Bethard and Raymond Hettinger.)"
msgstr "（由 Steven Bethard 和 Raymond Hettinger 提供。）"

#: ../../whatsnew/2.5.rst:1045
#, fuzzy
msgid ""
"Two new built-in functions, :func:`any` and :func:`all`, evaluate whether an "
"iterator contains any true or false values.  :func:`any` returns :const:"
"`True` if any value returned by the iterator is true; otherwise it will "
"return :const:`False`.  :func:`all` returns :const:`True` only if all of the "
"values returned by the iterator evaluate as true. (Suggested by Guido van "
"Rossum, and implemented by Raymond Hettinger.)"
msgstr ""
"兩個新的內建函式 :func:`any` 和 :func:`all` "
"評估疊代器是否包含任何真值或假值。 :func:`any` 回傳 :const:`True` "
"如果疊代器回傳的任何值是真；否則它將回傳 :const:`False`。 :func:`all` "
"僅當疊代器回傳的所有值都為真時才回傳 :const:`True`。 （由 Guido van Rossum "
"建議，由 Raymond Hettinger 實施。）"

#: ../../whatsnew/2.5.rst:1052
#, fuzzy
msgid ""
"The result of a class's :meth:`__hash__` method can now be either a long "
"integer or a regular integer.  If a long integer is returned, the hash of "
"that value is taken.  In earlier versions the hash value was required to be "
"a regular integer, but in 2.5 the :func:`id` built-in was changed to always "
"return non-negative numbers, and users often seem to use ``id(self)`` in :"
"meth:`__hash__` methods (though this is discouraged)."
msgstr ""
"類的 :meth:`__hash__` 方法的結果現在可以是長整數或常規整數。如果回傳長整數，"
"則採用該值的散列。在早期版本中，散列值需要是一個常規整數，但在 2.5 中，"
"內建的 :func:`id` 被更改為始終回傳非負數，並且使用者似乎經常使用 ``id(self)` "
"` in :meth:`__hash__` 方法（儘管不鼓勵這樣做）。"

#: ../../whatsnew/2.5.rst:1061
#, fuzzy
msgid ""
"ASCII is now the default encoding for modules.  It's now  a syntax error if "
"a module contains string literals with 8-bit characters but doesn't have an "
"encoding declaration.  In Python 2.4 this triggered a warning, not a syntax "
"error.  See :pep:`263`  for how to declare a module's encoding; for example, "
"you might add  a line like this near the top of the source file::"
msgstr ""
"ASCII 現在是模組的預設編碼。現在，如果模組包含具有 8 "
"位字元的字串文字但沒有編碼聲明，則會出現語法錯誤。在 Python 2.4 "
"中，這會觸發警告，而不是語法錯誤。有關如何聲明模組編碼的資訊，請參見 "
":pep:`263`；例如，您可以在源文件頂部附近新增這樣一行："

#: ../../whatsnew/2.5.rst:1069
#, fuzzy
msgid ""
"A new warning, :class:`UnicodeWarning`, is triggered when  you attempt to "
"compare a Unicode string and an 8-bit string  that can't be converted to "
"Unicode using the default ASCII encoding.   The result of the comparison is "
"false::"
msgstr ""
"當您嘗試比較 Unicode 字串和無法使用預設 ASCII 編碼轉換為 Unicode 的 8 "
"位字串時，會觸發一個新警告 :class:`UnicodeWarning`。比較結果為 false::"

#: ../../whatsnew/2.5.rst:1081
#, fuzzy
msgid ""
"Previously this would raise a :class:`UnicodeDecodeError` exception, but in "
"2.5 this could result in puzzling problems when accessing a dictionary.  If "
"you looked up ``unichr(128)`` and ``chr(128)`` was being used as a key, "
"you'd get a :class:`UnicodeDecodeError` exception.  Other changes in 2.5 "
"resulted in this exception being raised instead of suppressed by the code "
"in :file:`dictobject.c` that implements dictionaries."
msgstr ""
"以前這會引發 :class:`UnicodeDecodeError` 例外，但在 2.5 "
"中，這可能會在訪問字典時導致令人費解的問題。如果您查找 ``unichr(128)`` 並且 "
"``chr(128)`` 被用作鍵，您將得到一個 :class:`UnicodeDecodeError` 例外。 2.5 "
"中的其他更改導致引發此例外，而不是被實作字典的 :file:`dictobject.c` "
"中的程式碼抑制。"

#: ../../whatsnew/2.5.rst:1088
#, fuzzy
msgid ""
"Raising an exception for such a comparison is strictly correct, but the "
"change might have broken code, so instead  :class:`UnicodeWarning` was "
"introduced."
msgstr "為此類比較引發例外是完全正確的，但更改可能會破壞程式碼，因此引入了 "
":class:`UnicodeWarning`。"

#: ../../whatsnew/2.5.rst:1091
#, fuzzy
msgid "(Implemented by Marc-André Lemburg.)"
msgstr "（由 Marc-André Lemburg 實施。）"

#: ../../whatsnew/2.5.rst:1093
#, fuzzy
msgid ""
"One error that Python programmers sometimes make is forgetting to include "
"an :file:`__init__.py` module in a package directory. Debugging this mistake "
"can be confusing, and usually requires running Python with the :option:`-v` "
"switch to log all the paths searched. In Python 2.5, a new :exc:"
"`ImportWarning` warning is triggered when an import would have picked up a "
"directory as a package but no :file:`__init__.py` was found.  This warning "
"is silently ignored by default; provide the :option:`-Wd <-W>` option when "
"running the Python executable to display the warning message. (Implemented "
"by Thomas Wouters.)"
msgstr ""
"Python 程式員有時會犯的一個錯誤是忘記在包目錄中包含 :file:`__init__.py` "
"模組。除錯此錯誤可能會造成混淆，並且通常需要使用 :option:`-v` 開關運行 "
"Python 以記錄所有搜索到的路徑。在 Python 2.5 中，"
"當匯入會選擇一個目錄作為包但沒有找到 :exc:`__init__.py` 時，會觸發一個新的 "
":exc:`ImportWarning` 警告。預設情況下，此警告會被忽略；在運行 Python "
"可執行文件時提供 :option:`-Wd <-W>` 選項以顯示警告消息。 （由 Thomas Wouters "
"實施。）"

#: ../../whatsnew/2.5.rst:1102
#, fuzzy
msgid ""
"The list of base classes in a class definition can now be empty.   As an "
"example, this is now legal::"
msgstr "類定義中的基底類別列表現在可以為空。例如，這現在是合法的::"

#: ../../whatsnew/2.5.rst:1108
#, fuzzy
msgid "(Implemented by Brett Cannon.)"
msgstr "（由 Brett Cannon 實施。）"

#: ../../whatsnew/2.5.rst:1116
#, fuzzy
msgid "Interactive Interpreter Changes"
msgstr "交互式直譯器更改"

#: ../../whatsnew/2.5.rst:1118
#, fuzzy
msgid ""
"In the interactive interpreter, ``quit`` and ``exit``  have long been "
"strings so that new users get a somewhat helpful message when they try to "
"quit::"
msgstr "在交互式直譯器中，``quit`` 和 ``exit`` "
"長期以來一直是字串，以便新使用者在嘗試退出時得到一些有用的消息::"

#: ../../whatsnew/2.5.rst:1124
#, fuzzy
msgid ""
"In Python 2.5, ``quit`` and ``exit`` are now objects that still produce "
"string representations of themselves, but are also callable. Newbies who try "
"``quit()`` or ``exit()`` will now exit the interpreter as they expect.  "
"(Implemented by Georg Brandl.)"
msgstr ""
"在 Python 2.5 中，``quit`` 和 ``exit`` "
"現在是仍然生成自身字串表示形式的物件，但也是可呼叫的。嘗試 ``quit()`` 或 "
"``exit()`` 的新手現在將按預期退出直譯器。 （由 Georg Brandl 實施。）"

#: ../../whatsnew/2.5.rst:1129
#, fuzzy
msgid ""
"The Python executable now accepts the standard long options  :option:`--"
"help` and :option:`--version`; on Windows,  it also accepts the :option:`/? "
"<-?>` option for displaying a help message. (Implemented by Georg Brandl.)"
msgstr ""
"Python 可執行文件現在接受標準的長選項 :option:`--help` 和 "
":option:`--version`；在 Windows 上，它也接受 :option:`/? <-?>` "
"用於顯示幫助消息的選項。 （由 Georg Brandl 實施。）"

#: ../../whatsnew/2.5.rst:1139
#, fuzzy
msgid "Optimizations"
msgstr "最佳化"

#: ../../whatsnew/2.5.rst:1141
#, fuzzy
msgid ""
"Several of the optimizations were developed at the NeedForSpeed sprint, an "
"event held in Reykjavik, Iceland, from May 21--28 2006. The sprint focused "
"on speed enhancements to the CPython implementation and was funded by EWT "
"LLC with local support from CCP Games.  Those optimizations added at this "
"sprint are specially marked in the following list."
msgstr ""
"多項最佳化是在 NeedForSpeed sprint 上開發的，該活動於 2006 年 5 月 21 日至 "
"28 日在冰島雷克雅未克舉行。該 sprint 的重點是提高 CPython 實施的速度，並由 "
"EWT LLC 資助並獲得 CCP Games "
"的本地支援。在此衝刺中新增的最佳化在以下列表中特別標記。"

#: ../../whatsnew/2.5.rst:1147
#, fuzzy
msgid ""
"When they were introduced  in Python 2.4, the built-in :class:`set` and :"
"class:`frozenset` types were built on top of Python's dictionary type.   In "
"2.5 the internal data structure has been customized for implementing sets, "
"and as a result sets will use a third less memory and are somewhat faster. "
"(Implemented by Raymond Hettinger.)"
msgstr ""
"當它們在 Python 2.4 中被引入時，內建的 :class:`set` 和 :class:`frozenset` "
"型別建立在 Python 的字典型別之上。在 2.5 中，內部資料結構已為實作集合而定制，"
"因此集合將使用三分之一更少的記憶體並且速度更快。 （由 Raymond Hettinger "
"實施。）"

#: ../../whatsnew/2.5.rst:1153
#, fuzzy
msgid ""
"The speed of some Unicode operations, such as finding substrings, string "
"splitting, and character map encoding and decoding, has been improved. "
"(Substring search and splitting improvements were added by Fredrik Lundh and "
"Andrew Dalke at the NeedForSpeed sprint. Character maps were improved by "
"Walter Dörwald and Martin von Löwis.)"
msgstr ""
"某些 Unicode "
"操作（例如查找子字串、字串拆分和字元映射編碼和解碼）的速度已得到改進。 （"
"子字串搜索和拆分改進由 Fredrik Lundh 和 Andrew Dalke 在 NeedForSpeed "
"衝刺中新增。字元映射由 Walter Dörwald 和 Martin von Löwis 改進。）"

#: ../../whatsnew/2.5.rst:1161
#, fuzzy
msgid ""
"The ``long(str, base)`` function is now faster on long digit strings because "
"fewer intermediate results are calculated.  The peak is for strings of "
"around 800--1000 digits where  the function is 6 times faster. (Contributed "
"by Alan McIntyre and committed at the NeedForSpeed sprint.)"
msgstr ""
"``long(str, base)`` 函式現在在長數字字串上更快，因為計算的中間結果更少。"
"峰值是大約 800--1000 位的字串，其中函式快 6 倍。 （由 Alan McIntyre 提供並在 "
"NeedForSpeed 衝刺中承諾。）"

#: ../../whatsnew/2.5.rst:1168
#, fuzzy
msgid ""
"It's now illegal to mix iterating over a file  with ``for line in file`` and "
"calling  the file object's :meth:`read`/:meth:`readline`/:meth:`readlines` "
"methods.  Iteration uses an internal buffer and the  :meth:`read\\*` methods "
"don't use that buffer.   Instead they would return the data following the "
"buffer, causing the data to appear out of order.  Mixing iteration and these "
"methods will now trigger a :exc:`ValueError` from the :meth:`read\\*` "
"method. (Implemented by Thomas Wouters.)"
msgstr ""
"現在，將文件疊代與 ``for line in file`` 和呼叫文件物件的 "
":meth:`read`/:meth:`readline`/:meth:`readlines` "
"方法混合使用是非法的。疊代使用內部緩衝區，而 :meth:`read\\*` "
"方法不使用該緩衝區。相反，它們會回傳緩衝區後面的資料，導致資料出現亂序。"
"混合疊代和這些方法現在將從 :meth:`read\\*` 方法觸發 :exc:`ValueError`。 （由 "
"Thomas Wouters 實施。）"

#: ../../whatsnew/2.5.rst:1178
#, fuzzy
msgid ""
"The :mod:`struct` module now compiles structure format  strings into an "
"internal representation and caches this representation, yielding a 20% "
"speedup. (Contributed by Bob Ippolito at the NeedForSpeed sprint.)"
msgstr ""
":mod:`struct` 模組現在將結構格式字串編譯為內部表示並快取該表示，從而產生 20% "
"的加速。 （由 Bob Ippolito 在 NeedForSpeed 衝刺中貢獻。）"

#: ../../whatsnew/2.5.rst:1182
#, fuzzy
msgid ""
"The :mod:`re` module got a 1 or 2% speedup by switching to  Python's "
"allocator functions instead of the system's  :c:func:`malloc` and :c:func:"
"`free`. (Contributed by Jack Diederich at the NeedForSpeed sprint.)"
msgstr ""
":mod:`re` 模組通過切換到 Python 的分配器函式而不是系統的:c:func:`malloc` "
"和:c:func:`free` 獲得了 1% 或 2% 的加速。 （由 Jack Diederich 在 "
"NeedForSpeed 衝刺中貢獻。）"

#: ../../whatsnew/2.5.rst:1186
#, fuzzy
msgid ""
"The code generator's peephole optimizer now performs simple constant folding "
"in expressions.  If you write something like ``a = 2+3``, the code generator "
"will do the arithmetic and produce code corresponding to ``a = 5``.  "
"(Proposed and implemented  by Raymond Hettinger.)"
msgstr ""
"程式碼生成器的窺孔最佳化器現在可以在表達式中執行簡單的常數折疊。如果你寫類似 "
"``a = 2+3`` 的程式碼，程式碼生成器將進行算術運算並生成對應於 ``a = 5`` "
"的程式碼。 （由 Raymond Hettinger 提出並實施。）"

#: ../../whatsnew/2.5.rst:1191
#, fuzzy
msgid ""
"Function calls are now faster because code objects now keep  the most "
"recently finished frame (a \"zombie frame\") in an internal field of the "
"code object, reusing it the next time the code object is invoked.  (Original "
"patch by Michael Hudson, modified by Armin Rigo and Richard Jones; committed "
"at the NeedForSpeed sprint.)  Frame objects are also slightly smaller, which "
"may improve cache locality and reduce memory usage a bit.  (Contributed by "
"Neal Norwitz.)"
msgstr ""
"函式呼叫現在更快，因為程式碼物件現在將最近完成的幀（“殭屍幀”）保留在程式碼物"
"件的內部欄位中，下次呼叫程式碼物件時重新使用它。 （Michael Hudson "
"的原始補丁，由 Armin Rigo 和 Richard Jones 修改；在 NeedForSpeed sprint "
"中提交。）Frame "
"對像也稍微小一些，這可能會改善快取局部性並稍微減少記憶體使用。 "
"（尼爾·諾維茨供稿。）"

#: ../../whatsnew/2.5.rst:1201
#, fuzzy
msgid ""
"Python's built-in exceptions are now new-style classes, a change that speeds "
"up instantiation considerably.  Exception handling in Python 2.5 is "
"therefore about 30% faster than in 2.4. (Contributed by Richard Jones, Georg "
"Brandl and Sean Reifschneider at the NeedForSpeed sprint.)"
msgstr ""
"Python 的內建例外現在是新型類，這一變化大大加快了實例化速度。因此，Python "
"2.5 中的例外處理比 2.4 快大約 30%。 （由 Richard Jones、Georg Brandl 和 Sean "
"Reifschneider 在 NeedForSpeed 衝刺中貢獻。）"

#: ../../whatsnew/2.5.rst:1206
#, fuzzy
msgid ""
"Importing now caches the paths tried, recording whether  they exist or not "
"so that the interpreter makes fewer  :c:func:`open` and :c:func:`stat` calls "
"on startup. (Contributed by Martin von Löwis and Georg Brandl.)"
msgstr ""
"匯入現在快取嘗試過的路徑，記錄它們是否存在，以便直譯器在啟動時進行更少的 "
":c:func:`open` 和 :c:func:`stat` 呼叫。 （由 Martin von Löwis 和 Georg "
"Brandl 提供。）"

#: ../../whatsnew/2.5.rst:1218
#, fuzzy
msgid "New, Improved, and Removed Modules"
msgstr "新的、改進的和刪除的模組"

#: ../../whatsnew/2.5.rst:1220
#, fuzzy
msgid ""
"The standard library received many enhancements and bug fixes in Python 2.5. "
"Here's a partial list of the most notable changes, sorted alphabetically by "
"module name. Consult the :file:`Misc/NEWS` file in the source tree for a "
"more complete list of changes, or look through the SVN logs for all the "
"details."
msgstr ""
"標準庫在 Python 2.5 中得到了許多增強和錯誤修復。這是最顯著更改的部分列表，按"
"模組名稱的字母順序排序。請查閱源程式碼樹中的 :file:`Misc/NEWS` "
"文件以獲取更完整的更改列表，或查看 SVN 日誌以獲取所有詳細資訊。"

#: ../../whatsnew/2.5.rst:1225
#, fuzzy
msgid ""
"The :mod:`audioop` module now supports the a-LAW encoding, and the code for "
"u-LAW encoding has been improved.  (Contributed by Lars Immisch.)"
msgstr ":mod:`audioop` 模組現在支援 a-LAW 編碼，並且改進了 u-LAW 編碼的程式碼。 "
"（由拉爾斯·伊米施提供。）"

#: ../../whatsnew/2.5.rst:1228
#, fuzzy
msgid ""
"The :mod:`codecs` module gained support for incremental codecs.  The :func:"
"`codec.lookup` function now returns a :class:`CodecInfo` instance instead of "
"a tuple. :class:`CodecInfo` instances behave like a 4-tuple to preserve "
"backward compatibility but also have the attributes :attr:`encode`, :attr:"
"`decode`, :attr:`incrementalencoder`, :attr:`incrementaldecoder`, :attr:"
"`streamwriter`, and :attr:`streamreader`.  Incremental codecs  can receive "
"input and produce output in multiple chunks; the output is the same as if "
"the entire input was fed to the non-incremental codec. See the :mod:`codecs` "
"module documentation for details. (Designed and implemented by Walter "
"Dörwald.)"
msgstr ""
":mod:`codecs` 模組獲得了對增量編解碼器的支援。 :func:`codec.lookup` "
"函式現在回傳一個 :class:`CodecInfo` 實例而不是元組。 :class:`CodecInfo` "
"實例的行為類似於 4 元組以保持向後相容性，但也具有屬性 :attr:`encode`、:attr:`d"
"ecode`、:attr:`incrementalencoder`、:attr:`incrementaldecoder`、 "
":attr:`streamwriter` 和 :attr:`streamreader`。增量編解碼器可以接收輸入並產生"
"多個塊的輸出；輸出與將整個輸入饋送到非增量編解碼器一樣。有關詳細資訊，請參閱 "
":mod:`codecs` 模組文檔。 （由 Walter Dörwald 設計和實施。）"

#: ../../whatsnew/2.5.rst:1240
#, fuzzy
msgid ""
"The :mod:`collections` module gained a new type, :class:`defaultdict`, that "
"subclasses the standard :class:`dict` type.  The new type mostly behaves "
"like a dictionary but constructs a default value when a key isn't present, "
"automatically adding it to the dictionary for the requested key value."
msgstr ""
":mod:`collections` 模組獲得了一個新型別 :class:`defaultdict`，它是標準 "
":class:`dict` 型別的子類別。新型別的行為主要類似於字典，但會在鍵不存在時構造"
"預設值，並自動將其新增到字典中以獲取所請求的鍵值。"

#: ../../whatsnew/2.5.rst:1245
#, fuzzy
msgid ""
"The first argument to :class:`defaultdict`'s constructor is a factory "
"function that gets called whenever a key is requested but not found. This "
"factory function receives no arguments, so you can use built-in type "
"constructors such as :func:`list` or :func:`int`.  For example,  you can "
"make an index of words based on their initial letter like this::"
msgstr ""
":class:`defaultdict` 的構造函式的第一個參數是一個工廠函式，每當請求一個鍵但找"
"不到時呼叫它。此工廠函式不接收任何參數，因此您可以使用內建型別構造函式，例如 "
":func:`list` 或 "
":func:`int`。例如，您可以根據單詞的首字母建立單詞索引，如下所示："

#: ../../whatsnew/2.5.rst:1261
#, fuzzy
msgid "Printing ``index`` results in the following output::"
msgstr "印出 ``index`` 結果如下："

#: ../../whatsnew/2.5.rst:1269
#, fuzzy
msgid "(Contributed by Guido van Rossum.)"
msgstr "（由 Guido van Rossum 提供。）"

#: ../../whatsnew/2.5.rst:1271
#, fuzzy
msgid ""
"The :class:`deque` double-ended queue type supplied by the :mod:"
"`collections` module now has a ``remove(value)`` method that removes the "
"first occurrence of *value* in the queue, raising :exc:`ValueError` if the "
"value isn't found. (Contributed by Raymond Hettinger.)"
msgstr ""
":mod:`collections` 模組提供的 :class:`deque` 雙端隊列型別現在有一個 "
"``remove(value)`` 方法，可以刪除隊列中第一次出現的 *value*，引發 :exc "
":`ValueError` 如果找不到該值。 （雷蒙德·赫廷格供稿。）"

#: ../../whatsnew/2.5.rst:1276
#, fuzzy
msgid ""
"New module: The :mod:`contextlib` module contains helper functions for use "
"with the new ':keyword:`with`' statement.  See section :ref:`contextlibmod` "
"for more about this module."
msgstr ""
"新模組：:mod:`contextlib` 模組包含與新的 ':keyword:`with`' "
"語句一起使用的輔助函式。有關此模組的更多資訊，請參閱 :ref:`contextlibmod` "
"部分。"

#: ../../whatsnew/2.5.rst:1280
#, fuzzy
msgid ""
"New module: The :mod:`cProfile` module is a C implementation of  the "
"existing :mod:`profile` module that has much lower overhead. The module's "
"interface is the same as :mod:`profile`: you run ``cProfile.run('main()')`` "
"to profile a function, can save profile data to a file, etc.  It's not yet "
"known if the Hotshot profiler, which is also written in C but doesn't match "
"the :mod:`profile` module's interface, will continue to be maintained in "
"future versions of Python.  (Contributed by Armin Rigo.)"
msgstr ""
"新模組：:mod:`cProfile` 模組是現有 :mod:`profile` 模組的 C "
"實作，其開銷要低得多。該模組的介面與 :mod:`profile` 相同：您運行 ``cProfile."
"run('main()')`` 來分析函式，可以將分析資料保存到文件等。尚不清楚是否Hotshot "
"分析器也是用 C 編寫的，但與 :mod:`profile` 模組的介面不匹配，將在未來的 "
"Python 版本中繼續維護。 （由 Armin Rigo 提供。）"

#: ../../whatsnew/2.5.rst:1288
#, fuzzy
msgid ""
"Also, the :mod:`pstats` module for analyzing the data measured by the "
"profiler now supports directing the output to any file object by supplying a "
"*stream* argument to the :class:`Stats` constructor. (Contributed by Skip "
"Montanaro.)"
msgstr ""
"此外，用於分析探查器測量資料的 pstats 模組現在支援通過向 Stats 構造函式提供 "
"*stream* 參數將輸出定向到任何文件物件。 （由 Skip Montanaro 提供。）"

#: ../../whatsnew/2.5.rst:1292
#, fuzzy
msgid ""
"The :mod:`csv` module, which parses files in comma-separated value format, "
"received several enhancements and a number of bugfixes.  You can now set the "
"maximum size in bytes of a field by calling the ``csv."
"field_size_limit(new_limit)`` function; omitting the *new_limit* argument "
"will return the currently set limit.  The :class:`reader` class now has a :"
"attr:`line_num` attribute that counts the number of physical lines read from "
"the source; records can span multiple physical lines, so :attr:`line_num` is "
"not the same as the number of records read."
msgstr ""
":mod:`csv` 模組以逗號分隔值格式解析文件，獲得了一些增強功能和一些錯誤修復。"
"您現在可以通過呼叫 csv.field_size_limit(new_limit) "
"函式來設定欄位的最大大小（以位元組為單位）；省略 *new_limit* "
"參數將回傳當前設定的限制。 :class:`reader` 類現在有一個 :attr:`line_num` "
"屬性，用於計算從源讀取的物理行數；記錄可以跨越多個物理行，因此 "
":attr:`line_num` 與讀取的記錄數不同。"

#: ../../whatsnew/2.5.rst:1301
#, fuzzy
msgid ""
"The CSV parser is now stricter about multi-line quoted fields. Previously, "
"if a line ended within a quoted field without a terminating newline "
"character, a newline would be inserted into the returned field. This "
"behavior caused problems when reading files that contained carriage return "
"characters within fields, so the code was changed to return the field "
"without inserting newlines. As a consequence, if newlines embedded within "
"fields are important, the input should be split into lines in a manner that "
"preserves the newline characters."
msgstr ""
"CSV 解析器現在對多行引用欄位更加嚴格。以前，如果一行在帶引號的欄位中結束而沒"
"有終止換行符，則換行符將插入到回傳的欄位中。在讀取欄位中包含回車符的文件時，"
"此行為會導致出現問題，因此更改程式碼以回傳欄位而不插入換行符。因此，如果嵌入"
"在欄位中的換行符很重要，則應以保留換行符的方式將輸入分成幾行。"

#: ../../whatsnew/2.5.rst:1309
#, fuzzy
msgid "(Contributed by Skip Montanaro and Andrew McNamara.)"
msgstr "（由 Skip Montanaro 和 Andrew McNamara 提供。）"

#: ../../whatsnew/2.5.rst:1311
#, fuzzy
msgid ""
"The :class:`~datetime.datetime` class in the :mod:`datetime`  module now has "
"a ``strptime(string, format)``  method for parsing date strings, contributed "
"by Josh Spoerri. It uses the same format characters as :func:`time.strptime` "
"and :func:`time.strftime`::"
msgstr ""
":mod:`datetime` 模組中的 :class:`~datetime.datetime` "
"類現在有一個用於解析日期字串的 ``strptime(string, format)`` 方法，由 Josh "
"Spoerri 貢獻。它使用與 :func:`time.strptime` 和 :func:`time.strftime` "
"相同的格式字元::"

#: ../../whatsnew/2.5.rst:1321
#, fuzzy
msgid ""
"The :meth:`SequenceMatcher.get_matching_blocks` method in the :mod:`difflib` "
"module now guarantees to return a minimal list of blocks describing matching "
"subsequences.  Previously, the algorithm would occasionally break a block of "
"matching elements into two list entries. (Enhancement by Tim Peters.)"
msgstr ""
"difflib 模組中的 SequenceMatcher.get_matching_blocks 方法現在保證回傳描述匹配"
"子序列的最小塊列表。以前，該演算法有時會將匹配元素塊分成兩個列表條目。 "
"（蒂姆彼得斯的增強。）"

#: ../../whatsnew/2.5.rst:1326
#, fuzzy
msgid ""
"The :mod:`doctest` module gained a ``SKIP`` option that keeps an example "
"from being executed at all.  This is intended for code snippets that are "
"usage examples intended for the reader and aren't actually test cases."
msgstr ""
":mod:`doctest` 模組獲得了一個 ``SKIP`` 選項，可以防止示例被執行。這適用於程式"
"碼片段，這些程式碼片段是為讀者準備的使用示例，而不是實際的測試用例。"

#: ../../whatsnew/2.5.rst:1330
#, fuzzy
msgid ""
"An *encoding* parameter was added to the :func:`testfile` function and the :"
"class:`DocFileSuite` class to specify the file's encoding.  This makes it "
"easier to use non-ASCII characters in  tests contained within a docstring. "
"(Contributed by Bjorn Tillenius.)"
msgstr ""
"*encoding* 參數已新增到 :func:`testfile` 函式和 :class:`DocFileSuite` "
"類以指定文件的編碼。這使得在文檔字串中包含的測試中使用非 ASCII "
"字元變得更加容易。 （由 Bjorn Tillenius 提供。）"

#: ../../whatsnew/2.5.rst:1337
#, fuzzy
msgid ""
"The :mod:`email` package has been updated to version 4.0. (Contributed by "
"Barry Warsaw.)"
msgstr ":mod:`email` 包已更新至 4.0 版。 （由 Barry Warsaw 提供。）"

#: ../../whatsnew/2.5.rst:1345
#, fuzzy
msgid ""
"The :mod:`fileinput` module was made more flexible. Unicode filenames are "
"now supported, and a *mode* parameter that defaults to ``\"r\"`` was added "
"to the :func:`input` function to allow opening files in binary or :term:"
"`universal newlines` mode.  Another new parameter, *openhook*, lets you use "
"a function other than :func:`open`  to open the input files.  Once you're "
"iterating over the set of files, the :class:`FileInput` object's new :meth:"
"`fileno` returns the file descriptor for the currently opened file. "
"(Contributed by Georg Brandl.)"
msgstr ""
":mod:`fileinput` 模組變得更加靈活。現在支援 Unicode 文件名，並將預設為 ``\"r"
"\"`` 的 *mode* 參數新增到 :func:`input` 函式以允許以二進位或 :term:`"
"universal newlines` 模式打開文件。另一個新參數 *openhook* 允許您使用 "
":func:`open` 以外的函式打開輸入文件。遍歷文件集後，FileInput 物件的新 fileno "
"會回傳當前打開文件的文件描述器。 （由喬治·布蘭德爾提供。）"

#: ../../whatsnew/2.5.rst:1354
#, fuzzy
msgid ""
"In the :mod:`gc` module, the new :func:`get_count` function returns a 3-"
"tuple containing the current collection counts for the three GC "
"generations.  This is accounting information for the garbage collector; when "
"these counts reach a specified threshold, a garbage collection sweep will be "
"made.  The existing :func:`gc.collect` function now takes an optional "
"*generation* argument of 0, 1, or 2 to specify which generation to collect. "
"(Contributed by Barry Warsaw.)"
msgstr ""
"在 :mod:`gc` 模組中，新的 :func:`get_count` 函式回傳一個三元組，其中包含三代 "
"GC 的當前收集計數。這是垃圾收集器的會計資訊；當這些計數達到指定閾值時，將進行"
"垃圾收集掃描。現有的 :func:`gc.collect` 函式現在採用可選的 *generation* 參數 "
"0、1 或 2 來指定收集哪一代。 （由 Barry Warsaw 提供。）"

#: ../../whatsnew/2.5.rst:1361
#, fuzzy
msgid ""
"The :func:`nsmallest` and  :func:`nlargest` functions in the :mod:`heapq` "
"module  now support a ``key`` keyword parameter similar to the one provided "
"by the :func:`min`/:func:`max` functions and the :meth:`sort` methods.  For "
"example::"
msgstr ""
":mod:`heapq` 模組中的 :func:`nsmallest` 和 :func:`nlargest` 函式現在支援類似於 "
":func:`min`/:func 提供的 ``key`` 關鍵字參數:`max` 函式和 :meth:`sort` "
"方法。例如：："

#: ../../whatsnew/2.5.rst:1373 ../../whatsnew/2.5.rst:1382
#, fuzzy
msgid "(Contributed by Raymond Hettinger.)"
msgstr "（雷蒙德·赫廷格供稿。）"

#: ../../whatsnew/2.5.rst:1375
#, fuzzy
msgid ""
"The :func:`itertools.islice` function now accepts ``None`` for the start and "
"step arguments.  This makes it more compatible with the attributes of slice "
"objects, so that you can now write the following::"
msgstr ""
":func:`itertools.islice` 函式現在接受 ``None`` 作為開始和步驟參數。"
"這使得它與 slice 物件的屬性更加相容，因此您現在可以編寫以下內容::"

#: ../../whatsnew/2.5.rst:1384
#, fuzzy
msgid ""
"The :func:`format` function in the :mod:`locale` module has been modified "
"and two new functions were added, :func:`format_string` and :func:`currency`."
msgstr ""
":mod:`locale` 模組中的 :func:`format` "
"函式已被修改並新增了兩個新函式：:func:`format_string` 和 :func:`currency`。"

#: ../../whatsnew/2.5.rst:1387
#, fuzzy
msgid ""
"The :func:`format` function's *val* parameter could previously be a string "
"as long as no more than one %char specifier appeared; now the parameter must "
"be exactly one %char specifier with no surrounding text.  An optional "
"*monetary* parameter was also added which, if ``True``, will use the "
"locale's rules for formatting currency in placing a separator between groups "
"of three digits."
msgstr ""
":func:`format` 函式的 *val* 參數以前可以是一個字串，只要出現不超過一個 %char "
"說明符；現在參數必須恰好是一個沒有周圍文本的 %char 說明符。"
"還新增了一個可選的 *monetary* 參數，如果 "
"``True``，將使用語言環境的規則來格式化貨幣，在三位數字組之間放置分隔符。"

#: ../../whatsnew/2.5.rst:1393
#, fuzzy
msgid ""
"To format strings with multiple %char specifiers, use the new :func:"
"`format_string` function that works like :func:`format` but also supports "
"mixing %char specifiers with arbitrary text."
msgstr ""
"要使用多個 %char 說明符格式化字串，請使用新的 :func:`format_string` 函式，"
"它的工作方式與 :func:`format` 類似，但還支援將 %char 說明符與任意文本混合。"

#: ../../whatsnew/2.5.rst:1397
#, fuzzy
msgid ""
"A new :func:`currency` function was also added that formats a number "
"according to the current locale's settings."
msgstr "還新增了一個新的 :func:`currency` 函式，它根據當前區域設定格式化數字。"

#: ../../whatsnew/2.5.rst:1400
#, fuzzy
msgid "(Contributed by Georg Brandl.)"
msgstr "（由喬治·布蘭德爾提供。）"

#: ../../whatsnew/2.5.rst:1404
#, fuzzy
msgid ""
"The :mod:`mailbox` module underwent a massive rewrite to add the capability "
"to modify mailboxes in addition to reading them.  A new set of classes that "
"include :class:`mbox`, :class:`MH`, and :class:`Maildir` are used to read "
"mailboxes, and have an ``add(message)`` method to add messages, "
"``remove(key)`` to remove messages, and :meth:`lock`/:meth:`unlock` to lock/"
"unlock the mailbox. The following example converts a maildir-format mailbox "
"into an mbox-format one::"
msgstr ""
":mod:`mailbox` "
"模組進行了大規模重寫，以新增除了讀取郵箱之外還可以修改郵箱的功能。包括 "
":class:`mbox`、:class:`MH` 和 :class:`Maildir` 的一組新類用於讀取郵箱，"
"並具有用於新增消息的 ``add(message)`` 方法， ``remove(key)`` 刪除消息，和 "
":meth:`lock`/:meth:`unlock` 鎖定/解鎖郵箱。以下示例將 maildir "
"格式的郵箱轉換為 mbox 格式的郵箱："

#: ../../whatsnew/2.5.rst:1422
#, fuzzy
msgid ""
"(Contributed by Gregory K. Johnson.  Funding was provided by Google's 2005 "
"Summer of Code.)"
msgstr "（由 Gregory K. Johnson 提供。資金由 Google 的 2005 年編程之夏提供。）"

#: ../../whatsnew/2.5.rst:1425
#, fuzzy
msgid ""
"New module: the :mod:`msilib` module allows creating Microsoft Installer :"
"file:`.msi` files and CAB files.  Some support for reading the :file:`.msi` "
"database is also included. (Contributed by Martin von Löwis.)"
msgstr ""
"新模組：:mod:`msilib` 模組允許建立 Microsoft Installer :file:`.msi` 文件和 "
"CAB 文件。還包括對讀取 :file:`.msi` 資料庫的一些支援。 （由 Martin von Löwis "
"提供。）"

#: ../../whatsnew/2.5.rst:1429
#, fuzzy
msgid ""
"The :mod:`nis` module now supports accessing domains other than the system "
"default domain by supplying a *domain* argument to the :func:`nis.match` "
"and :func:`nis.maps` functions. (Contributed by Ben Bell.)"
msgstr ""
":mod:`nis` 模組現在支援通過向 :func:`nis.match` 和 :func:`nis.maps` "
"函式提供*domain* 參數來訪問系統預設域以外的域。 （由本·貝爾提供。）"

#: ../../whatsnew/2.5.rst:1433
#, fuzzy
msgid ""
"The :mod:`operator` module's :func:`itemgetter`  and :func:`attrgetter` "
"functions now support multiple fields.   A call such as ``operator."
"attrgetter('a', 'b')`` will return a function  that retrieves the :attr:`a` "
"and :attr:`b` attributes.  Combining  this new feature with the :meth:`sort` "
"method's ``key`` parameter  lets you easily sort lists using multiple "
"fields. (Contributed by Raymond Hettinger.)"
msgstr ""
":mod:`operator` 模組的 :func:`itemgetter` 和 :func:`attrgetter` "
"函式現在支援多個欄位。諸如 ``operator.attrgetter('a', 'b')`` "
"之類的呼叫將回傳一個函式，該函式會檢索 :attr:`a` 和 :attr:`b` 屬性。"
"將此新功能與 :meth:`sort` 方法的 ``key`` "
"參數相結合，可以讓您輕鬆地使用多個欄位對列表進行排序。 "
"（雷蒙德·赫廷格供稿。）"

#: ../../whatsnew/2.5.rst:1440
#, fuzzy
msgid ""
"The :mod:`optparse` module was updated to version 1.5.1 of the Optik "
"library. The :class:`OptionParser` class gained an :attr:`epilog` attribute, "
"a string that will be printed after the help message, and a :meth:`destroy` "
"method to break reference cycles created by the object. (Contributed by Greg "
"Ward.)"
msgstr ""
":mod:`optparse` 模組已更新至 Optik 庫的 1.5.1 版。 :class:`OptionParser` "
"類獲得了一個 :attr:`epilog` 屬性，一個將在幫助消息之後印出的字串，以及一個 "
":meth:`destroy` 方法來打破物件建立的引用循環。 （由格雷格·沃德提供。）"

#: ../../whatsnew/2.5.rst:1445
#, fuzzy
msgid ""
"The :mod:`os` module underwent several changes.  The :attr:"
"`stat_float_times` variable now defaults to true, meaning that :func:`os."
"stat` will now return time values as floats.  (This doesn't necessarily mean "
"that :func:`os.stat` will return times that are precise to fractions of a "
"second; not all systems support such precision.)"
msgstr ""
":mod:`os` 模組經歷了一些變化。 :attr:`stat_float_times` 變數現在預設為 true，"
"這意味著 :func:`os.stat` 現在將以浮點數形式回傳時間值。 （這並不一定意味著 "
":func:`os.stat` 將回傳精確到幾分之一秒的時間；並非所有系統都支援這種精度。）"

#: ../../whatsnew/2.5.rst:1451
#, fuzzy
msgid ""
"Constants named :attr:`os.SEEK_SET`, :attr:`os.SEEK_CUR`, and :attr:`os."
"SEEK_END` have been added; these are the parameters to the :func:`os.lseek` "
"function.  Two new constants for locking are :attr:`os.O_SHLOCK` and :attr:"
"`os.O_EXLOCK`."
msgstr ""
"新增了名為 :attr:`os.SEEK_SET`、:attr:`os.SEEK_CUR` 和 :attr:`os.SEEK_END` "
"的常數；這些是 os.lseek 函式的參數。用於鎖定的兩個新常數是 :attr:`os."
"O_SHLOCK` 和 :attr:`os.O_EXLOCK`。"

#: ../../whatsnew/2.5.rst:1456
#, fuzzy
msgid ""
"Two new functions, :func:`wait3` and :func:`wait4`, were added.  They're "
"similar the :func:`waitpid` function which waits for a child process to exit "
"and returns a tuple of the process ID and its exit status, but :func:`wait3` "
"and :func:`wait4` return additional information.  :func:`wait3` doesn't take "
"a process ID as input, so it waits for any child process to exit and returns "
"a 3-tuple of *process-id*, *exit-status*, *resource-usage* as returned from "
"the :func:`resource.getrusage` function. ``wait4(pid)`` does take a process "
"ID. (Contributed by Chad J. Schroeder.)"
msgstr ""
"新增了兩個新函式 :func:`wait3` 和 :func:`wait4`。"
"它們類似於等待子行程退出並回傳行程 ID 及其退出狀態的元組的 :func:`waitpid` "
"函式，但是 :func:`wait3` 和 :func:`wait4` 回傳附加資訊. :func:`wait3` "
"不將行程 ID 作為輸入，因此它等待任何子行程退出並回傳 *process-id*、*exit-"
"status*、*resource-usage* 的三元組作為從 :func:`resource.getrusage` 函式回傳。"
" ``wait4(pid)`` 確實需要一個行程 ID。 （由 Chad J. Schroeder 提供。）"

#: ../../whatsnew/2.5.rst:1465
#, fuzzy
msgid ""
"On FreeBSD, the :func:`os.stat` function now returns  times with nanosecond "
"resolution, and the returned object now has :attr:`st_gen` and :attr:"
"`st_birthtime`. The :attr:`st_flags` attribute is also available, if the "
"platform supports it. (Contributed by Antti Louko and  Diego Pettenò.)"
msgstr ""
"在 FreeBSD 上，:func:`os.stat` "
"函式現在以納秒分辨率回傳時間，並且回傳的物件現在有 :attr:`st_gen` "
"和 :attr:`st_birthtime`。 :attr:`st_flags` 屬性也可用，如果平台支援的話。 （"
"由 Antti Louko 和 Diego Petteno 提供。）"

#: ../../whatsnew/2.5.rst:1472
#, fuzzy
msgid ""
"The Python debugger provided by the :mod:`pdb` module can now store lists of "
"commands to execute when a breakpoint is reached and execution stops.  Once "
"breakpoint #1 has been created, enter ``commands 1`` and enter a series of "
"commands to be executed, finishing the list with ``end``.  The command list "
"can include commands that resume execution, such as ``continue`` or "
"``next``. (Contributed by Grégoire Dooms.)"
msgstr ""
":mod:`pdb` 模組提供的 Python "
"除錯器現在可以儲存命令列表，以便在到達斷點並停止執行時執行。建立斷點 #1 後，"
"輸入 ``commands 1`` 並輸入一系列要執行的命令，以 ``end`` "
"結束列表。命令列表可以包括恢復執行的命令，例如 ``continue`` 或 ``next``。 （"
"由 Grégoire Dooms 提供。）"

#: ../../whatsnew/2.5.rst:1481
#, fuzzy
msgid ""
"The :mod:`pickle` and :mod:`cPickle` modules no longer accept a return value "
"of ``None`` from the :meth:`__reduce__` method; the method must return a "
"tuple of arguments instead.  The ability to return ``None`` was deprecated "
"in Python 2.4, so this completes the removal of the feature."
msgstr ""
":mod:`pickle` 和 :mod:`cPickle` 模組不再接受來自 :meth:`__reduce__` 方法的 "
"``None`` 回傳值；該方法必須回傳一個參數元組。回傳 ``None`` 的能力在 Python 2.4 "
"中已被棄用，因此該功能的刪除到此結束。"

#: ../../whatsnew/2.5.rst:1486
#, fuzzy
msgid ""
"The :mod:`pkgutil` module, containing various utility functions for finding "
"packages, was enhanced to support :pep:`302`'s import hooks and now also "
"works for packages stored in ZIP-format archives. (Contributed by Phillip J. "
"Eby.)"
msgstr ""
":mod:`pkgutil` 模組，包含用於查找包的各種實用函式，已得到增強以支援 "
":pep:`302` 的匯入掛鉤，現在也適用於儲存在 ZIP 格式檔案中的包。 （由 Phillip "
"J. Eby 提供。）"

#: ../../whatsnew/2.5.rst:1490
#, fuzzy
msgid ""
"The pybench benchmark suite by Marc-André Lemburg is now included in the :"
"file:`Tools/pybench` directory.  The pybench suite is an improvement on the "
"commonly used :file:`pystone.py` program because pybench provides a more "
"detailed measurement of the interpreter's speed.  It times particular "
"operations such as function calls, tuple slicing, method lookups, and "
"numeric operations, instead of performing many different operations and "
"reducing the result to a single number as :file:`pystone.py` does."
msgstr ""
"Marc-André Lemburg 的 pybench 基準套件現在包含在 :file:`Tools/pybench` "
"目錄中。 pybench 套件是對常用 :file:`pystone.py` 程式的改進，因為 pybench 提"
"供了對直譯器速度的更詳細測量。它對函式呼叫、元組切片、方法查找和數字操作等特"
"定操作進行計時，而不是像 :file:`pystone.py` "
"那樣執行許多不同的操作並將結果減少為單個數字。"

#: ../../whatsnew/2.5.rst:1498
#, fuzzy
msgid ""
"The :mod:`pyexpat` module now uses version 2.0 of the Expat parser. "
"(Contributed by Trent Mick.)"
msgstr ":mod:`pyexpat` 模組現在使用 Expat 解析器的 2.0 版。 （特倫特·米克供稿。）"

#: ../../whatsnew/2.5.rst:1501
#, fuzzy
msgid ""
"The :class:`~queue.Queue` class provided by the :mod:`Queue` module gained "
"two new methods.  :meth:`join` blocks until all items in the queue have been "
"retrieved and all processing work on the items  have been completed.  Worker "
"threads call the other new method,  :meth:`task_done`, to signal that "
"processing for an item has been completed.  (Contributed by Raymond "
"Hettinger.)"
msgstr ""
":mod:`Queue` 模組提供的 :class:`~queue.Queue` 類獲得了兩個新方法。 "
":meth:`join` 阻塞，直到檢索到隊列中的所有項目並且完成對項目的所有處理工作。"
"工作執行緒呼叫另一個新方法 :meth:`task_done` 來表示對某個項目的處理已經完成。"
" （雷蒙德·赫廷格供稿。）"

#: ../../whatsnew/2.5.rst:1507
#, fuzzy
msgid ""
"The old :mod:`regex` and :mod:`regsub` modules, which have been  deprecated "
"ever since Python 2.0, have finally been deleted.   Other deleted modules: :"
"mod:`statcache`, :mod:`tzparse`, :mod:`whrandom`."
msgstr ""
"舊的 :mod:`regex` 和 :mod:`regsub` 模組，自 Python 2.0 以來一直被棄用，終於被"
"刪除了。其他刪除的模組：:mod:`statcache`、:mod:`tzparse`、:mod:`whrandom`。"

#: ../../whatsnew/2.5.rst:1511
#, fuzzy
msgid ""
"Also deleted: the :file:`lib-old` directory, which includes ancient modules "
"such as :mod:`dircmp` and :mod:`ni`, was removed.  :file:`lib-old` wasn't on "
"the default ``sys.path``, so unless your programs explicitly added the "
"directory to ``sys.path``, this removal shouldn't affect your code."
msgstr ""
"還刪除了：:file:`lib-old` 目錄，其中包括古老的模組，例如 :mod:`dircmp` 和 "
":mod:`ni`，已被刪除。 :file:`lib-old` 不在預設的 ``sys.path`` 中，"
"因此除非您的程式明確地將目錄新增到 ``sys."
"path``，否則此刪除不應影響您的程式碼。"

#: ../../whatsnew/2.5.rst:1516
#, fuzzy
msgid ""
"The :mod:`rlcompleter` module is no longer  dependent on importing the :mod:"
"`readline` module and therefore now works on non-Unix platforms. (Patch from "
"Robert Kiendl.)"
msgstr ""
":mod:`rlcompleter` 模組不再依賴於匯入 :mod:`readline` 模組，因此現在可以在非 "
"Unix 平台上運行。 （來自 Robert Kiendl 的補丁。）"

#: ../../whatsnew/2.5.rst:1522
#, fuzzy
msgid ""
"The :mod:`SimpleXMLRPCServer` and :mod:`DocXMLRPCServer`  classes now have "
"a :attr:`rpc_paths` attribute that constrains XML-RPC operations to a "
"limited set of URL paths; the default is to allow only ``'/'`` and ``'/"
"RPC2'``.  Setting :attr:`rpc_paths` to ``None`` or an empty tuple disables  "
"this path checking."
msgstr ""
":mod:`SimpleXMLRPCServer` 和 :mod:`DocXMLRPCServer` "
"類現在有一個 :attr:`rpc_paths` 屬性，將 XML-RPC 操作限制在一組有限的 URL "
"路徑中；預設是只允許``'/'`` 和``'/RPC2'``。將 :attr:`rpc_paths` 設定為 "
"``None`` 或空元組將禁用此路徑檢查。"

#: ../../whatsnew/2.5.rst:1529
#, fuzzy
msgid ""
"The :mod:`socket` module now supports :const:`AF_NETLINK` sockets on Linux, "
"thanks to a patch from Philippe Biondi.   Netlink sockets are a Linux-"
"specific mechanism for communications between a user-space process and "
"kernel code; an introductory  article about them is at https://www."
"linuxjournal.com/article/7356. In Python code, netlink addresses are "
"represented as a tuple of 2 integers, ``(pid, group_mask)``."
msgstr ""
"得益於 Philippe Biondi 的補丁，:mod:`socket` 模組現在支援 Linux "
"上的 :const:`AF_NETLINK`  socket 。 Netlink  socket 是一種特定於 Linux "
"的機制，用於在使用者空間行程和內核程式碼之間進行通信；"
"關於它們的介紹性文章位於 https://www.linuxjournal.com/article/7356。在 "
"Python 程式碼中，網絡鏈接地址表示為 2 個整數的元組，``(pid, group_mask)``。"

#: ../../whatsnew/2.5.rst:1536
#, fuzzy
msgid ""
"Two new methods on socket objects, ``recv_into(buffer)`` and "
"``recvfrom_into(buffer)``, store the received data in an object  that "
"supports the buffer protocol instead of returning the data as a string.  "
"This means you can put the data directly into an array or a memory-mapped "
"file."
msgstr ""
" socket 對像上的兩個新方法，``recv_into(buffer)`` 和 ``recvfrom_into(buffer)``"
"，將接收到的資料儲存在支援緩衝協定的對像中，而不是將資料作為字串回傳。這意味"
"著您可以將資料直接放入數組或記憶體映射文件中。"

#: ../../whatsnew/2.5.rst:1541
#, fuzzy
msgid ""
"Socket objects also gained :meth:`getfamily`, :meth:`gettype`, and :meth:"
"`getproto` accessor methods to retrieve the family, type, and protocol "
"values for the socket."
msgstr ""
" socket 對像還獲得了 :meth:`getfamily`、:meth:`gettype` 和 :meth:`getproto` "
"訪問器方法來檢索 socket 的系列、型別和協定值。"

#: ../../whatsnew/2.5.rst:1545
#, fuzzy
msgid ""
"New module: the :mod:`spwd` module provides functions for accessing the "
"shadow password database on systems that support  shadow passwords."
msgstr "新模組：:mod:`spwd` "
"模組提供了在支援影子密碼的系統上訪問影子密碼資料庫的功能。"

#: ../../whatsnew/2.5.rst:1548
#, fuzzy
msgid ""
"The :mod:`struct` is now faster because it  compiles format strings into :"
"class:`Struct` objects with :meth:`pack` and :meth:`unpack` methods.  This "
"is similar to how the :mod:`re` module lets you create compiled regular "
"expression objects.  You can still use the module-level  :func:`pack` and :"
"func:`unpack` functions; they'll create  :class:`Struct` objects and cache "
"them.  Or you can use  :class:`Struct` instances directly::"
msgstr ""
":mod:`struct` 現在更快，因為它使用 :meth:`pack` 和 :meth:`unpack` "
"方法將格式字串編譯成 :class:`Struct` 物件。這類似於 :mod:`re` "
"模組如何讓您建立已編譯的正則表達式物件。您仍然可以使用模組級的 :func:`pack` "
"和 :func:`unpack` 函式；他們將建立 :class:`Struct` 物件並快取它們。"
"或者你可以直接使用 :class:`Struct` 實例::"

#: ../../whatsnew/2.5.rst:1560
#, fuzzy
msgid ""
"You can also pack and unpack data to and from buffer objects directly using "
"the ``pack_into(buffer, offset, v1, v2, ...)`` and ``unpack_from(buffer, "
"offset)`` methods.  This lets you store data directly into an array or a "
"memory-mapped file."
msgstr ""
"您還可以直接使用``pack_into(buffer, offset, v1, v2, ...)`` 和``unpack_from("
"buffer, offset)`` 方法將資料打包到緩衝區對像或從緩衝區對像中解包。這使您可以"
"將資料直接儲存到數組或記憶體映射文件中。"

#: ../../whatsnew/2.5.rst:1565
#, fuzzy
msgid ""
"(:class:`Struct` objects were implemented by Bob Ippolito at the "
"NeedForSpeed sprint.  Support for buffer objects was added by Martin Blais, "
"also at the NeedForSpeed sprint.)"
msgstr ""
"（:class:`Struct` 物件由 Bob Ippolito 在 NeedForSpeed 衝刺中實作。"
"對緩衝區物件的支援由 Martin Blais 新增，也在 NeedForSpeed 衝刺中。）"

#: ../../whatsnew/2.5.rst:1569
#, fuzzy
msgid ""
"The Python developers switched from CVS to Subversion during the 2.5 "
"development process.  Information about the exact build version is available "
"as the ``sys.subversion`` variable, a 3-tuple of ``(interpreter-name, branch-"
"name, revision-range)``.  For example, at the time of writing my copy of 2.5 "
"was reporting ``('CPython', 'trunk', '45313:45315')``."
msgstr ""
"Python 開發人員在 2.5 開發過程中從 CVS 切換到 Subversion。"
"關於確切構建版本的資訊可作為 ``sys.subversion`` 變數，一個 ``(interpreter-"
"name, branch-name, revision-range)`` 的 3 元組。例如，在撰寫本文時，我的 2.5 "
"副本正在報告 ``('CPython', 'trunk', '45313:45315')``。"

#: ../../whatsnew/2.5.rst:1575
#, fuzzy
msgid ""
"This information is also available to C extensions via the :c:func:"
"`Py_GetBuildInfo` function that returns a  string of build information like "
"this: ``\"trunk:45355:45356M, Apr 13 2006, 07:42:19\"``.   (Contributed by "
"Barry Warsaw.)"
msgstr ""
"此資訊也可通過 Py_GetBuildInfo 函式提供給 C "
"擴充，該函式回傳一串構建資訊，如下所示：``\"trunk:45355:45356M, Apr 13 2006, "
"07:42:19\"`` . （由 Barry Warsaw 提供。）"

#: ../../whatsnew/2.5.rst:1580
#, fuzzy
msgid ""
"Another new function, :func:`sys._current_frames`, returns the current stack "
"frames for all running threads as a dictionary mapping thread identifiers to "
"the topmost stack frame currently active in that thread at the time the "
"function is called.  (Contributed by Tim Peters.)"
msgstr ""
"另一個新函式 :func:`sys._current_frames` 將所有正在運行的執行緒的當前堆疊幀作"
"為字典將執行緒標識符映射到呼叫該函式時該執行緒中當前活動的最頂層堆疊幀。 "
"（由蒂姆·彼得斯提供。）"

#: ../../whatsnew/2.5.rst:1585
#, fuzzy
msgid ""
"The :class:`TarFile` class in the :mod:`tarfile` module now has an :meth:"
"`extractall` method that extracts all members from the archive into the "
"current working directory.  It's also possible to set a different directory "
"as the extraction target, and to unpack only a subset of the archive's "
"members."
msgstr ""
":mod:`tarfile` 模組中的 :class:`TarFile` 類現在有一個 :meth:`extractall` 方法"
"，可以將存檔中的所有成員提取到當前工作目錄中。也可以將不同的目錄設定為提取目"
"標，並僅解壓縮存檔成員的一個子集。"

#: ../../whatsnew/2.5.rst:1590
#, fuzzy
msgid ""
"The compression used for a tarfile opened in stream mode can now be "
"autodetected using the mode ``'r|*'``. (Contributed by Lars Gustäbel.)"
msgstr "現在可以使用模式 ``'r|*'`` 自動檢測用於以流模式打開的 tarfile 的壓縮。 （由 "
"Lars Gustäbel 提供。）"

#: ../../whatsnew/2.5.rst:1595
#, fuzzy
msgid ""
"The :mod:`threading` module now lets you set the stack size used when new "
"threads are created. The ``stack_size([*size*])`` function returns the "
"currently configured stack size, and supplying the optional *size* parameter "
"sets a new value.  Not all platforms support changing the stack size, but "
"Windows, POSIX threading, and OS/2 all do. (Contributed by Andrew MacIntyre.)"
msgstr ""
":mod:`threading` 模組現在允許您設定建立新執行緒時使用的堆疊大小。 "
"``stack_size([*size*])`` 函式回傳當前配置的堆疊大小，並提供可選的 *size* "
"參數設定一個新值。並非所有平台都支援更改堆疊大小，但 Windows、POSIX 執行緒和 "
"OS/2 都支援。 （由安德魯·麥金泰爾提供。）"

#: ../../whatsnew/2.5.rst:1603
#, fuzzy
msgid ""
"The :mod:`unicodedata` module has been updated to use version 4.1.0 of the "
"Unicode character database.  Version 3.2.0 is required  by some "
"specifications, so it's still available as  :attr:`unicodedata.ucd_3_2_0`."
msgstr ""
":mod:`unicodedata` 模組已更新為使用 Unicode 字元資料庫的 4.1.0 版。"
"某些規範要求版本 3.2.0，因此它仍然可以作為 :attr:`unicodedata.ucd_3_2_0` "
"使用。"

#: ../../whatsnew/2.5.rst:1607
#, fuzzy
msgid ""
"New module: the  :mod:`uuid` module generates  universally unique "
"identifiers (UUIDs) according to :rfc:`4122`.  The RFC defines several "
"different UUID versions that are generated from a starting string, from "
"system properties, or purely randomly.  This module contains a :class:`UUID` "
"class and  functions named :func:`uuid1`, :func:`uuid3`, :func:`uuid4`,  "
"and  :func:`uuid5` to generate different versions of UUID.  (Version 2 "
"UUIDs  are not specified in :rfc:`4122` and are not supported by this "
"module.) ::"
msgstr ""
"新模組：:mod:`uuid` 模組根據 :rfc:`4122` 生成通用唯一標識符 (UUID)。 RFC "
"定義了幾個不同的 UUID 版本，它們是從起始字串、系統屬性或純粹隨機生成的。"
"該模組包含一個 UUID 類和名為 uuid1、uuid3、uuid4 和 uuid5 的函式，"
"用於生成不同版本的 UUID。 （版本 2 UUID 未在 :rfc:`4122` "
"中指定，並且不受此模組支援。）::"

#: ../../whatsnew/2.5.rst:1632
#, fuzzy
msgid "(Contributed by Ka-Ping Yee.)"
msgstr "（由 Ka-Ping Yee 提供。）"

#: ../../whatsnew/2.5.rst:1634
#, fuzzy
msgid ""
"The :mod:`weakref` module's :class:`WeakKeyDictionary` and :class:"
"`WeakValueDictionary` types gained new methods for iterating over the weak "
"references contained in the dictionary.  :meth:`iterkeyrefs` and :meth:"
"`keyrefs` methods were added to :class:`WeakKeyDictionary`, and :meth:"
"`itervaluerefs` and :meth:`valuerefs` were added to :class:"
"`WeakValueDictionary`.  (Contributed by Fred L. Drake, Jr.)"
msgstr ""
":mod:`weakref` 模組的 :class:`WeakKeyDictionary` 和 "
":class:`WeakValueDictionary` 型別獲得了疊代字典中包含的弱引用的新方法。 "
":meth:`iterkeyrefs` 和 :meth:`keyrefs` 方法被新增到 "
":class:`WeakKeyDictionary`，並且 :meth:`itervaluerefs` 和 :meth:`valuerefs` "
"被新增到 :class:`WeakValueDictionary`。 （由 Fred L. Drake, Jr. 提供）"

#: ../../whatsnew/2.5.rst:1641
#, fuzzy
msgid ""
"The :mod:`webbrowser` module received a number of enhancements. It's now "
"usable as a script with ``python -m webbrowser``, taking a URL as the "
"argument; there are a number of switches  to control the behaviour (:option:"
"`!-n` for a new browser window,  :option:`!-t` for a new tab).  New module-"
"level functions, :func:`open_new` and :func:`open_new_tab`, were added  to "
"support this.  The module's :func:`open` function supports an additional "
"feature, an *autoraise* parameter that signals whether to raise the open "
"window when possible. A number of additional browsers were added to the "
"supported list such as Firefox, Opera, Konqueror, and elinks.  (Contributed "
"by Oleg Broytmann and Georg Brandl.)"
msgstr ""
":mod:`webbrowser` 模組獲得了許多增強功能。它現在可以用作帶有 ``python -m "
"webbrowser`` 的腳本，以 URL 作為參數；有許多開關可以控制行為（:option:`!-n` "
"用於新瀏覽器窗口，:option:`!-t` 用於新選項卡）。新增了新的模組級函式 "
":func:`open_new` 和 :func:`open_new_tab` 來支援這一點。該模組的 :func:`open` "
"函式支援一個附加功能，一個 *autorase* 參數，表示是否在可能的情況下提升打開的"
"窗口。許多其他瀏覽器已新增到受支援的列表中，例如 Firefox、Opera、Konqueror "
"和 elinks。 （由 Oleg Broytmann 和 Georg Brandl 提供。）"

#: ../../whatsnew/2.5.rst:1653
#, fuzzy
msgid ""
"The :mod:`xmlrpclib` module now supports returning  :class:`~datetime."
"datetime` objects for the XML-RPC date type.  Supply  ``use_datetime=True`` "
"to the :func:`loads` function or the :class:`Unmarshaller` class to enable "
"this feature. (Contributed by Skip Montanaro.)"
msgstr ""
":mod:`xmlrpclib` 模組現在支援為 XML-RPC 日期型別回傳 :class:`~datetime."
"datetime` 物件。向 loads 函式或 Unmarshaller 類提供 use_datetime=True "
"以啟用此功能。 （由 Skip Montanaro 提供。）"

#: ../../whatsnew/2.5.rst:1660
#, fuzzy
msgid ""
"The :mod:`zipfile` module now supports the ZIP64 version of the  format, "
"meaning that a .zip archive can now be larger than 4 GiB and can contain "
"individual files larger than 4 GiB.  (Contributed by Ronald Oussoren.)"
msgstr ""
":mod:`zipfile` 模組現在支援格式的 ZIP64 版本，這意味著 .zip 存檔現在可以大於 "
"4 GiB，並且可以包含大於 4 GiB 的單個文件。 （由羅納德·奧索倫提供。）"

#: ../../whatsnew/2.5.rst:1666
#, fuzzy
msgid ""
"The :mod:`zlib` module's :class:`Compress` and :class:`Decompress` objects "
"now support a :meth:`copy` method that makes a copy of the  object's "
"internal state and returns a new  :class:`Compress` or :class:`Decompress` "
"object. (Contributed by Chris AtLee.)"
msgstr ""
":mod:`zlib` 模組的 :class:`Compress` 和 :class:`Decompress` "
"物件現在支援 :meth:`copy` 方法，該方法複製物件的內部狀態並回傳一個新的 :class:`"
"Compress ` 或 :class:`Decompress` 物件。 （由 Chris AtLee 提供。）"

#: ../../whatsnew/2.5.rst:1679
msgid "The ctypes package"
msgstr "ctypes 套件"

#: ../../whatsnew/2.5.rst:1681
#, fuzzy
msgid ""
"The :mod:`ctypes` package, written by Thomas Heller, has been added  to the "
"standard library.  :mod:`ctypes` lets you call arbitrary functions  in "
"shared libraries or DLLs.  Long-time users may remember the :mod:`dl` "
"module, which provides functions for loading shared libraries and calling "
"functions in them. The :mod:`ctypes` package is much fancier."
msgstr ""
"由 Thomas Heller 編寫的 :mod:`ctypes` 包已新增到標準庫中。 :mod:`ctypes` "
"讓您可以呼叫共享庫或 DLL 中的任意函式。長期使用的使用者可能還記得 :mod:`dl` "
"模組，它提供了加載共享庫和呼叫其中函式的功能。 :mod:`ctypes` 包更漂亮。"

#: ../../whatsnew/2.5.rst:1687
#, fuzzy
msgid ""
"To load a shared library or DLL, you must create an instance of the :class:"
"`CDLL` class and provide the name or path of the shared library or DLL. Once "
"that's done, you can call arbitrary functions by accessing them as "
"attributes of the :class:`CDLL` object.   ::"
msgstr ""
"要加載共享庫或 DLL，您必須建立 :class:`CDLL` 類的實例並提供共享庫或 DLL "
"的名稱或路徑。完成後，您可以通過訪問它們作為 CDLL 物件的屬性來呼叫任意函式。 "
"::"

#: ../../whatsnew/2.5.rst:1697
#, fuzzy
msgid ""
"Type constructors for the various C types are provided: :func:`c_int`, :func:"
"`c_float`, :func:`c_double`, :func:`c_char_p` (equivalent to :c:expr:`char "
"\\*`), and so forth.  Unlike Python's types, the C versions are all mutable; "
"you can assign to their :attr:`value` attribute to change the wrapped "
"value.  Python integers and strings will be automatically converted to the "
"corresponding C types, but for other types you  must call the correct type "
"constructor.  (And I mean *must*;  getting it wrong will often result in the "
"interpreter crashing with a segmentation fault.)"
msgstr ""
"提供了各種 C 型別的型別構造函式：:func:`c_int`、:func:`c_float`、:func:`c_dou"
"ble`、:func:`c_char_p`（等同於:c:expr:`char \\*` ), 等等。與 Python "
"的型別不同，C 版本都是可變的；您可以分配給它們的 :attr:`value` "
"屬性來更改包裝的值。 Python 整數和字串會自動轉換為相應的 C "
"型別，但對於其他型別，您必須呼叫正確的型別構造函式。 "
"（我的意思是*必須*；弄錯通常會導致直譯器因分段錯誤而崩潰。）"

#: ../../whatsnew/2.5.rst:1706
#, fuzzy
msgid ""
"You shouldn't use :func:`c_char_p` with a Python string when the C function "
"will be modifying the memory area, because Python strings are  supposed to "
"be immutable; breaking this rule will cause puzzling bugs.  When you need a "
"modifiable memory area, use :func:`create_string_buffer`::"
msgstr ""
"當 C 函式將修改記憶體區域時，您不應該將 :func:`c_char_p` 與 Python "
"字串一起使用，因為 Python 字串應該是不可變的；打破這條規則會導致令人費解的錯"
"誤。當你需要一個可修改的記憶體區域時，使用 :func:`create_string_buffer`::"

#: ../../whatsnew/2.5.rst:1715
#, fuzzy
msgid ""
"C functions are assumed to return integers, but you can set the :attr:"
"`restype` attribute of the function object to  change this::"
msgstr "假定 C 函式回傳整數，但您可以設定函式物件的 :attr:`restype` 屬性來更改此::"

#: ../../whatsnew/2.5.rst:1724
#, fuzzy
msgid ""
":mod:`ctypes` also provides a wrapper for Python's C API  as the ``ctypes."
"pythonapi`` object.  This object does *not*  release the global interpreter "
"lock before calling a function, because the lock must be held when calling "
"into the interpreter's code.   There's a :class:`py_object()` type "
"constructor that will create a  :c:expr:`PyObject *` pointer.  A simple "
"usage::"
msgstr ""
":mod:`ctypes` 還為 Python 的 C API 提供了一個包裝器作為 ``ctypes.pythonapi`` "
"物件。該對像在呼叫函式之前*不會*釋放全局直譯器鎖，因為呼叫直譯器程式碼時必須"
"持有該鎖。有一個 :class:`py_object()` 型別構造函式，它將建立一個 :c:expr:`"
"PyObject *` 指標。一個簡單的用法::"

#: ../../whatsnew/2.5.rst:1737
#, fuzzy
msgid ""
"Don't forget to use :class:`py_object()`; if it's omitted you end  up with a "
"segmentation fault."
msgstr "不要忘記使用 :class:`py_object()`;如果它被省略，你最終會遇到分段錯誤。"

#: ../../whatsnew/2.5.rst:1740
#, fuzzy
msgid ""
":mod:`ctypes` has been around for a while, but people still write  and "
"distribution hand-coded extension modules because you can't rely on :mod:"
"`ctypes` being present. Perhaps developers will begin to write  Python "
"wrappers atop a library accessed through :mod:`ctypes` instead of extension "
"modules, now that :mod:`ctypes` is included with core Python."
msgstr ""
":mod:`ctypes` 已經存在了一段時間，但人們仍然編寫和分發手工編碼的擴充模組，"
"因為您不能依賴 :mod:`ctypes` 的存在。也許開發人員將開始在通過 :mod:`ctypes` "
"而不是擴充模組訪問的庫之上編寫 Python 包裝器，因為 :mod:`ctypes` 包含在核心 "
"Python 中。"

#: ../../whatsnew/2.5.rst:1750
msgid ""
"https://web.archive.org/web/20180410025338/http://starship.python.net/crew/"
"theller/ctypes/"
msgstr ""
"https://web.archive.org/web/20180410025338/http://starship.python.net/crew/"
"theller/ctypes/"

#: ../../whatsnew/2.5.rst:1750
#, fuzzy
msgid "The pre-stdlib ctypes web page, with a tutorial, reference, and FAQ."
msgstr "stdlib 之前的 ctypes 網頁，包含教程、參考和常見問題解答。"

#: ../../whatsnew/2.5.rst:1752
#, fuzzy
msgid "The documentation  for the :mod:`ctypes` module."
msgstr ":mod:`ctypes` 模組的文檔。"

#: ../../whatsnew/2.5.rst:1760
msgid "The ElementTree package"
msgstr "ElementTree 套件"

#: ../../whatsnew/2.5.rst:1762
#, fuzzy
msgid ""
"A subset of Fredrik Lundh's ElementTree library for processing XML has been "
"added to the standard library as :mod:`xml.etree`.  The available modules "
"are :mod:`ElementTree`, :mod:`ElementPath`, and :mod:`ElementInclude` from "
"ElementTree 1.2.6.    The :mod:`cElementTree` accelerator module is also "
"included."
msgstr ""
"Fredrik Lundh 用於處理 XML 的 ElementTree 庫的一個子集已作為 :mod:`xml.etree`"
" 新增到標準庫中。可用的模組是 ElementTree 1.2.6 中的 "
":mod:`ElementTree`、:mod:`ElementPath` 和 :mod:`ElementInclude`。 "
":mod:`cElementTree` 加速器模組也包括在內。"

#: ../../whatsnew/2.5.rst:1768
#, fuzzy
msgid ""
"The rest of this section will provide a brief overview of using ElementTree. "
"Full documentation for ElementTree is available at https://web.archive.org/"
"web/20201124024954/http://effbot.org/zone/element-index.htm."
msgstr ""
"本節的其餘部分將提供使用 ElementTree 的簡要概述。 ElementTree 的完整文檔可在 "
"https://web.archive.org/web/20201124024954/http://effbot.org/zone/element-"
"index.htm 獲取。"

#: ../../whatsnew/2.5.rst:1772
#, fuzzy
msgid ""
"ElementTree represents an XML document as a tree of element nodes. The text "
"content of the document is stored as the :attr:`text` and :attr:`tail` "
"attributes of  (This is one of the major differences between ElementTree and "
"the Document Object Model; in the DOM there are many different types of "
"node, including :class:`TextNode`.)"
msgstr ""
"ElementTree 將 XML 文檔表示為元素節點樹。文檔的文本內容儲存為 :attr:`text` "
"和 :attr:`tail` 屬性（這是 ElementTree 和文檔對像模型之間的主要區別之一；在 "
"DOM 中有許多不同型別的節點，包括 :class:`TextNode`。）"

#: ../../whatsnew/2.5.rst:1778
#, fuzzy
msgid ""
"The most commonly used parsing function is :func:`parse`, that takes either "
"a string (assumed to contain a filename) or a file-like object and returns "
"an :class:`ElementTree` instance::"
msgstr ""
"最常用的解析函式是 :func:`parse`，它接受一個字串（假定包含文件名）"
"或一個類似文件的物件並回傳一個 ElementTree 實例::"

#: ../../whatsnew/2.5.rst:1790
#, fuzzy
msgid ""
"Once you have an :class:`ElementTree` instance, you can call its :meth:"
"`getroot` method to get the root :class:`Element` node."
msgstr "一旦有了 ElementTree 實例，就可以呼叫它的 getroot 方法來獲取根 Element 節點。"

#: ../../whatsnew/2.5.rst:1793
#, fuzzy
msgid ""
"There's also an :func:`XML` function that takes a string literal and returns "
"an :class:`Element` node (not an :class:`ElementTree`).   This function "
"provides a tidy way to incorporate XML fragments, approaching the "
"convenience of an XML literal::"
msgstr ""
"還有一個 :func:`XML` 函式接受字串文字並回傳一個 :class:`Element` 節點（不是 "
":class:`ElementTree`）。此函式提供了一種合併 XML 片段的簡潔方法，接近 XML "
"文字的便利性："

#: ../../whatsnew/2.5.rst:1803
#, fuzzy
msgid ""
"Each XML element supports some dictionary-like and some list-like access "
"methods.  Dictionary-like operations are used to access attribute values, "
"and list-like operations are used to access child nodes."
msgstr "每個 XML 元素都支援一些類似字典和一些類似列表的訪問方法。類字典操作用於訪問屬"
"性值，類列表操作用於訪問子節點。"

#: ../../whatsnew/2.5.rst:1808
#, fuzzy
msgid "Operation"
msgstr "手術"

#: ../../whatsnew/2.5.rst:1808
#, fuzzy
msgid "Result"
msgstr "結果"

#: ../../whatsnew/2.5.rst:1810
msgid "``elem[n]``"
msgstr "``elem[n]``"

#: ../../whatsnew/2.5.rst:1810
#, fuzzy
msgid "Returns n'th child element."
msgstr "回傳第 n 個子元素。"

#: ../../whatsnew/2.5.rst:1812
msgid "``elem[m:n]``"
msgstr "``elem[m:n]``"

#: ../../whatsnew/2.5.rst:1812
#, fuzzy
msgid "Returns list of m'th through n'th child elements."
msgstr "回傳第 m 到第 n 個子元素的列表。"

#: ../../whatsnew/2.5.rst:1815
msgid "``len(elem)``"
msgstr "``len(elem)``"

#: ../../whatsnew/2.5.rst:1815
#, fuzzy
msgid "Returns number of child elements."
msgstr "回傳子元素的數量。"

#: ../../whatsnew/2.5.rst:1817
msgid "``list(elem)``"
msgstr "``list(elem)``"

#: ../../whatsnew/2.5.rst:1817
#, fuzzy
msgid "Returns list of child elements."
msgstr "回傳子元素列表。"

#: ../../whatsnew/2.5.rst:1819
msgid "``elem.append(elem2)``"
msgstr "``elem.append(elem2)``"

#: ../../whatsnew/2.5.rst:1819
#, fuzzy
msgid "Adds *elem2* as a child."
msgstr "新增 *elem2* 作為孩子。"

#: ../../whatsnew/2.5.rst:1821
msgid "``elem.insert(index, elem2)``"
msgstr "``elem.insert(index, elem2)``"

#: ../../whatsnew/2.5.rst:1821
#, fuzzy
msgid "Inserts *elem2* at the specified location."
msgstr "在指定位置插入 *elem2*。"

#: ../../whatsnew/2.5.rst:1823
msgid "``del elem[n]``"
msgstr "``del elem[n]``"

#: ../../whatsnew/2.5.rst:1823
#, fuzzy
msgid "Deletes n'th child element."
msgstr "刪除第 n 個子元素。"

#: ../../whatsnew/2.5.rst:1825
msgid "``elem.keys()``"
msgstr "``elem.keys()``"

#: ../../whatsnew/2.5.rst:1825
#, fuzzy
msgid "Returns list of attribute names."
msgstr "回傳屬性名稱列表。"

#: ../../whatsnew/2.5.rst:1827
msgid "``elem.get(name)``"
msgstr "``elem.get(name)``"

#: ../../whatsnew/2.5.rst:1827
#, fuzzy
msgid "Returns value of attribute *name*."
msgstr "回傳屬性 *name* 的值。"

#: ../../whatsnew/2.5.rst:1829
msgid "``elem.set(name, value)``"
msgstr "``elem.set(name, value)``"

#: ../../whatsnew/2.5.rst:1829
#, fuzzy
msgid "Sets new value for attribute *name*."
msgstr "為屬性 *name* 設定新值。"

#: ../../whatsnew/2.5.rst:1831
msgid "``elem.attrib``"
msgstr "``elem.attrib``"

#: ../../whatsnew/2.5.rst:1831
#, fuzzy
msgid "Retrieves the dictionary containing attributes."
msgstr "檢索包含屬性的字典。"

#: ../../whatsnew/2.5.rst:1834
msgid "``del elem.attrib[name]``"
msgstr "``del elem.attrib[name]``"

#: ../../whatsnew/2.5.rst:1834
#, fuzzy
msgid "Deletes attribute *name*."
msgstr "刪除屬性 *name*。"

#: ../../whatsnew/2.5.rst:1837
#, fuzzy
msgid ""
"Comments and processing instructions are also represented as :class:"
"`Element` nodes.  To check if a node is a comment or processing "
"instructions::"
msgstr "註釋和處理指令也表示為 :class:`Element` 節點。檢查節點是評論還是處理指令："

#: ../../whatsnew/2.5.rst:1845
#, fuzzy
msgid ""
"To generate XML output, you should call the :meth:`ElementTree.write` "
"method. Like :func:`parse`, it can take either a string or a file-like "
"object::"
msgstr ""
"要生成 XML 輸出，您應該呼叫 ElementTree.write 方法。像 :func:`parse` "
"一樣，它可以接受字串或類似文件的物件::"

#: ../../whatsnew/2.5.rst:1855
#, fuzzy
msgid ""
"(Caution: the default encoding used for output is ASCII.  For general XML "
"work, where an element's name may contain arbitrary Unicode characters, "
"ASCII isn't a very useful encoding because it will raise an exception if an "
"element's name contains any characters with values greater than 127.  "
"Therefore, it's best to specify a different encoding such as UTF-8 that can "
"handle any Unicode character.)"
msgstr ""
"（注意：用於輸出的預設編碼是 ASCII。對於一般的 XML 工作，"
"其中元素的名稱可能包含任意 Unicode 字元，ASCII "
"不是非常有用的編碼，因為如果元素的名稱包含任何具有值的字元，它會引發例外大於 "
"127。因此，最好指定一個不同的編碼，例如可以處理任何 Unicode 字元的 UTF-8。）"

#: ../../whatsnew/2.5.rst:1862
#, fuzzy
msgid ""
"This section is only a partial description of the ElementTree interfaces. "
"Please read the package's official documentation for more details."
msgstr "本節只是對 ElementTree "
"介面的部分描述。請閱讀軟件包的官方文檔以獲取更多詳細資訊。"

#: ../../whatsnew/2.5.rst:1868
msgid ""
"https://web.archive.org/web/20201124024954/http://effbot.org/zone/element-"
"index.htm"
msgstr ""
"https://web.archive.org/web/20201124024954/http://effbot.org/zone/element-"
"index.htm"

#: ../../whatsnew/2.5.rst:1869
#, fuzzy
msgid "Official documentation for ElementTree."
msgstr "ElementTree 的官方文檔。"

#: ../../whatsnew/2.5.rst:1877
msgid "The hashlib package"
msgstr "hashlib 套件"

#: ../../whatsnew/2.5.rst:1879
#, fuzzy
msgid ""
"A new :mod:`hashlib` module, written by Gregory P. Smith,  has been added to "
"replace the :mod:`md5` and :mod:`sha` modules.  :mod:`hashlib` adds support "
"for additional secure hashes (SHA-224, SHA-256, SHA-384, and SHA-512). When "
"available, the module uses OpenSSL for fast platform optimized "
"implementations of algorithms."
msgstr ""
"新增了一個新的 :mod:`hashlib` 模組，由 Gregory P. Smith 編寫，以替換 "
":mod:`md5` 和 :mod:`sha` 模組。 :mod:`hashlib` "
"新增了對其他安全雜湊（SHA-224、SHA-256、SHA-384 和 "
"SHA-512）的支援。如果可用，該模組將使用 OpenSSL "
"來實作演算法的快速平台最佳化實作。"

#: ../../whatsnew/2.5.rst:1885
#, fuzzy
msgid ""
"The old :mod:`md5` and :mod:`sha` modules still exist as wrappers around "
"hashlib to preserve backwards compatibility.  The new module's interface is "
"very close to that of the old modules, but not identical. The most "
"significant difference is that the constructor functions for creating new "
"hashing objects are named differently. ::"
msgstr ""
"舊的 :mod:`md5` 和 :mod:`sha` 模組仍然作為 hashlib 的包裝器存在，以保持向後相"
"容性。新模組的界面與舊模組的界面非常接近，但並不完全相同。最顯著的區別是用於"
"建立新散列物件的構造函式的命名不同。 ::"

#: ../../whatsnew/2.5.rst:1914
#, fuzzy
msgid ""
"Once a hash object has been created, its methods are the same as before: "
"``update(string)`` hashes the specified string into the  current digest "
"state, :meth:`digest` and :meth:`hexdigest` return the digest value as a "
"binary string or a string of hex digits, and :meth:`copy` returns a new "
"hashing object with the same digest state."
msgstr ""
"建立雜湊對像後，其方法與以前相同：``update(string)`` "
"將指定的字串雜湊到當前摘要狀態，:meth:`digest` 和 :meth:`hexdigest` "
"回傳摘要value 作為二進位字串或十六進位數字字串，並且 :meth:`copy` "
"回傳具有相同摘要狀態的新雜湊物件。"

#: ../../whatsnew/2.5.rst:1923
#, fuzzy
msgid "The documentation  for the :mod:`hashlib` module."
msgstr ":mod:`hashlib` 模組的文檔。"

#: ../../whatsnew/2.5.rst:1931
msgid "The sqlite3 package"
msgstr "sqlite3 套件"

#: ../../whatsnew/2.5.rst:1933
#, fuzzy
msgid ""
"The pysqlite module (https://www.pysqlite.org), a wrapper for the SQLite "
"embedded database, has been added to the standard library under the package "
"name :mod:`sqlite3`."
msgstr ""
"pysqlite 模組 (https://www.pysqlite.org) 是 SQLite 嵌入式資料庫的包裝器，"
"已新增到包名 :mod:`sqlite3` 下的標準庫中。"

#: ../../whatsnew/2.5.rst:1937
#, fuzzy
msgid ""
"SQLite is a C library that provides a lightweight disk-based database that "
"doesn't require a separate server process and allows accessing the database "
"using a nonstandard variant of the SQL query language. Some applications can "
"use SQLite for internal data storage.  It's also possible to prototype an "
"application using SQLite and then port the code to a larger database such as "
"PostgreSQL or Oracle."
msgstr ""
"SQLite 是一個 C 庫，它提供基於磁盤的輕型資料庫，不需要單獨的伺服器行程，"
"並允許使用 SQL 查詢語言的非標準變體訪問資料庫。一些應用程式可以使用 SQLite "
"進行內部資料儲存。還可以使用 SQLite "
"製作應用程式原型，然後將程式碼移植到更大的資料庫，例如 PostgreSQL 或 Oracle。"

#: ../../whatsnew/2.5.rst:1944
#, fuzzy
msgid ""
"pysqlite was written by Gerhard Häring and provides a SQL interface "
"compliant with the DB-API 2.0 specification described by :pep:`249`."
msgstr "pysqlite 由 Gerhard Häring 編寫，提供符合 :pep:`249` 描述的 DB-API 2.0 "
"規範的 SQL 介面。"

#: ../../whatsnew/2.5.rst:1947
#, fuzzy
msgid ""
"If you're compiling the Python source yourself, note that the source tree "
"doesn't include the SQLite code, only the wrapper module. You'll need to "
"have the SQLite libraries and headers installed before compiling Python, and "
"the build process will compile the module when the necessary headers are "
"available."
msgstr ""
"如果您自己編譯 Python 源程式碼，請注意源程式碼樹不包含 SQLite "
"程式碼，僅包含包裝器模組。在編譯 Python 之前，您需要安裝 SQLite "
"庫和標頭，構建過程將在必要的標頭可用時編譯模組。"

#: ../../whatsnew/2.5.rst:1952
#, fuzzy
msgid ""
"To use the module, you must first create a :class:`Connection` object that "
"represents the database.  Here the data will be stored in the :file:`/tmp/"
"example` file::"
msgstr ""
"要使用該模組，您必須首先建立一個表示資料庫的 :class:`Connection` "
"物件。這裡的資料將儲存在 :file:`/tmp/example` 文件中::"

#: ../../whatsnew/2.5.rst:1958
#, fuzzy
msgid ""
"You can also supply the special name ``:memory:`` to create a database in "
"RAM."
msgstr "您還可以提供特殊名稱 ``:memory:`` 在 RAM 中建立資料庫。"

#: ../../whatsnew/2.5.rst:1960
#, fuzzy
msgid ""
"Once you have a :class:`Connection`, you can create a :class:`Cursor`  "
"object and call its :meth:`execute` method to perform SQL commands::"
msgstr ""
"一旦有了 :class:`Connection`，就可以建立一個 :class:`Cursor` 物件並呼叫它的 "
":meth:`execute` 方法來執行 SQL 命令::"

#: ../../whatsnew/2.5.rst:1974
#, fuzzy
msgid ""
"Usually your SQL operations will need to use values from Python variables.  "
"You shouldn't assemble your query using Python's string operations because "
"doing so is insecure; it makes your program vulnerable to an SQL injection "
"attack."
msgstr ""
"通常，您的 SQL 操作需要使用來自 Python 變數的值。您不應該使用 Python "
"的字串操作來組合您的查詢，因為這樣做是不安全的；它使您的程式容易受到 SQL "
"注入攻擊。"

#: ../../whatsnew/2.5.rst:1978
#, fuzzy
msgid ""
"Instead, use the DB-API's parameter substitution.  Put ``?`` as a "
"placeholder wherever you want to use a value, and then provide a tuple of "
"values as the second argument to the cursor's :meth:`execute` method.  "
"(Other database modules may use a different placeholder, such as ``%s`` or "
"``:1``.) For example::"
msgstr ""
"相反，使用 DB-API 的參數替換。將 ``?`` 作為佔位符放在任何您想使用值的地方，"
"然後提供一個值元組作為游標的 :meth:`execute` 方法的第二個參數。 "
"（其他資料庫模組可能使用不同的佔位符，例如 ``%s`` 或 ``:1``。）例如："

#: ../../whatsnew/2.5.rst:1998
#, fuzzy
msgid ""
"To retrieve data after executing a SELECT statement, you can either  treat "
"the cursor as an iterator, call the cursor's :meth:`fetchone` method to "
"retrieve a single matching row,  or call :meth:`fetchall` to get a list of "
"the matching rows."
msgstr ""
"要在執行 SELECT 語句後檢索資料，您可以將游標視為疊代器，呼叫游標的 fetchone "
"方法檢索單個匹配行，或呼叫 fetchall 獲取列表匹配行。"

#: ../../whatsnew/2.5.rst:2003
#, fuzzy
msgid "This example uses the iterator form::"
msgstr "此示例使用疊代器形式::"

#: ../../whatsnew/2.5.rst:2016
#, fuzzy
msgid ""
"For more information about the SQL dialect supported by SQLite, see https://"
"www.sqlite.org."
msgstr "有關 SQLite 支援的 SQL 方言的更多資訊，請參閱 https://www.sqlite.org。"

#: ../../whatsnew/2.5.rst:2023
msgid "https://www.pysqlite.org"
msgstr "https://www.pysqlite.org"

#: ../../whatsnew/2.5.rst:2023
#, fuzzy
msgid "The pysqlite web page."
msgstr "pysqlite 網頁。"

#: ../../whatsnew/2.5.rst:2027
msgid "https://www.sqlite.org"
msgstr "https://www.sqlite.org"

#: ../../whatsnew/2.5.rst:2026
#, fuzzy
msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr "SQLite 網頁；該文檔描述了支援的 SQL 方言的語法和可用資料型別。"

#: ../../whatsnew/2.5.rst:2029
#, fuzzy
msgid "The documentation  for the :mod:`sqlite3` module."
msgstr ":mod:`sqlite3` 模組的文檔。"

#: ../../whatsnew/2.5.rst:2031
#, fuzzy
msgid ":pep:`249` - Database API Specification 2.0"
msgstr ":pep:`249` - 資料庫 API 規範 2.0"

#: ../../whatsnew/2.5.rst:2032
msgid "PEP written by Marc-André Lemburg."
msgstr "由 Marc-André Lemburg 撰寫 PEP。"

#: ../../whatsnew/2.5.rst:2040
msgid "The wsgiref package"
msgstr "wsgiref 套件"

#: ../../whatsnew/2.5.rst:2042
#, fuzzy
msgid ""
"The Web Server Gateway Interface (WSGI) v1.0 defines a standard interface "
"between web servers and Python web applications and is described in :pep:"
"`333`. The :mod:`wsgiref` package is a reference implementation of the WSGI "
"specification."
msgstr ""
"Web 伺服器網關介面 (WSGI) v1.0 定義了 Web 伺服器和 Python Web "
"應用程式之間的標準介面，並在 :pep:`333` 中進行了描述。 :mod:`wsgiref` 包是 "
"WSGI 規範的參考實作。"

#: ../../whatsnew/2.5.rst:2049
#, fuzzy
msgid ""
"The package includes a basic HTTP server that will run a WSGI application; "
"this server is useful for debugging but isn't intended for  production use.  "
"Setting up a server takes only a few lines of code::"
msgstr "該軟件包包括一個將運行 WSGI 應用程式的基本 HTTP "
"伺服器；此伺服器可用於除錯，但不適合生產使用。設定伺服器只需要幾行程式碼::"

#: ../../whatsnew/2.5.rst:2069
msgid ""
"https://web.archive.org/web/20160331090247/http://wsgi.readthedocs.org/en/"
"latest/"
msgstr ""
"https://web.archive.org/web/20160331090247/http://wsgi.readthedocs.org/en/"
"latest/"

#: ../../whatsnew/2.5.rst:2069
#, fuzzy
msgid "A central web site for WSGI-related resources."
msgstr "WSGI 相關資源的中央網站。"

#: ../../whatsnew/2.5.rst:2071
#, fuzzy
msgid ":pep:`333` - Python Web Server Gateway Interface v1.0"
msgstr ":pep:`333` - Python Web 伺服器網關介面 v1.0"

#: ../../whatsnew/2.5.rst:2072
msgid "PEP written by Phillip J. Eby."
msgstr "由 Phillip J. Eby 撰寫 PEP。"

#: ../../whatsnew/2.5.rst:2080
#, fuzzy
msgid "Build and C API Changes"
msgstr "構建和 C API 更改"

#: ../../whatsnew/2.5.rst:2082
#, fuzzy
msgid "Changes to Python's build process and to the C API include:"
msgstr "Python 構建過程和 C API 的變化包括："

#: ../../whatsnew/2.5.rst:2084
#, fuzzy
msgid ""
"The Python source tree was converted from CVS to Subversion,  in a complex "
"migration procedure that was supervised and flawlessly carried out by Martin "
"von Löwis.  The procedure was developed as :pep:`347`."
msgstr ""
"Python 源程式碼樹從 CVS 轉換到 Subversion，這是一個複雜的遷移過程，由 Martin "
"von Löwis 監督並完美執行。該程式開發為 :pep:`347`。"

#: ../../whatsnew/2.5.rst:2088
#, fuzzy
msgid ""
"Coverity, a company that markets a source code analysis tool called Prevent, "
"provided the results of their examination of the Python source code.  The "
"analysis found about 60 bugs that  were quickly fixed.  Many of the bugs "
"were refcounting problems, often occurring in error-handling code.  See "
"https://scan.coverity.com for the statistics."
msgstr ""
"Coverity 是一家銷售名為 Prevent 的源程式碼分析工具的公司，它提供了他們對 "
"Python 源程式碼的檢查結果。分析發現了大約 60 個錯誤，這些錯誤很快得到了修復。"
"許多錯誤是引用計數問題，通常出現在錯誤處理程式碼中。有關統計資訊，請參閱 "
"https://scan.coverity.com。"

#: ../../whatsnew/2.5.rst:2094
#, fuzzy
msgid ""
"The largest change to the C API came from :pep:`353`, which modifies the "
"interpreter to use a :c:type:`Py_ssize_t` type definition instead of :c:expr:"
"`int`.  See the earlier section :ref:`pep-353` for a discussion of this "
"change."
msgstr ""
"C API 的最大變化來自 :pep:`353`，它修改了直譯器以使用 :c:type:`Py_ssize_t` "
"型別定義而不是 :c:expr:`int`。有關此更改的討論，請參閱前面的部分 "
":ref:`pep-353`。"

#: ../../whatsnew/2.5.rst:2099
#, fuzzy
msgid ""
"The design of the bytecode compiler has changed a great deal,  no longer "
"generating bytecode by traversing the parse tree.  Instead the parse tree is "
"converted to an abstract syntax tree (or AST), and it is  the abstract "
"syntax tree that's traversed to produce the bytecode."
msgstr ""
"位元組碼編譯器的設計發生了很大變化，不再通過遍歷解析樹來生成位元組碼。相反，"
"解析樹被轉換為抽象語法樹（或 AST），並且它是遍歷生成位元組碼的抽象語法樹。"

#: ../../whatsnew/2.5.rst:2104
#, fuzzy
msgid ""
"It's possible for Python code to obtain AST objects by using the :func:"
"`compile` built-in and specifying ``_ast.PyCF_ONLY_AST`` as the value of "
"the  *flags* parameter::"
msgstr ""
"Python 程式碼可以通過使用內建的 :func:`compile` 並指定 ``_ast.PyCF_ONLY_AST``"
" 作為 *flags* 參數的值來獲取 AST 物件::"

#: ../../whatsnew/2.5.rst:2117
#, fuzzy
msgid ""
"No official documentation has been written for the AST code yet, but :pep:"
"`339` discusses the design.  To start learning about the code, read the "
"definition of the various AST nodes in :file:`Parser/Python.asdl`.  A Python "
"script reads this file and generates a set of C structure definitions in :"
"file:`Include/Python-ast.h`.  The :c:func:`PyParser_ASTFromString` and :c:"
"func:`PyParser_ASTFromFile`, defined in :file:`Include/pythonrun.h`, take "
"Python source as input and return the root of an AST representing the "
"contents. This AST can then be turned into a code object by :c:func:"
"`PyAST_Compile`.  For more information, read the source code, and then ask "
"questions on python-dev."
msgstr ""
"目前還沒有為 AST 程式碼編寫官方文檔，但是 :pep:`339` "
"討論了設計。要開始了解程式碼，請閱讀 Parser/Python.asdl 中各種 AST "
"節點的定義。 Python 腳本讀取此文件並在 :file:`Include/Python-ast.h` "
"中生成一組 C 結構定義。 :c:func:`PyParser_ASTFromString` 和 "
":c:func:`PyParser_ASTFromFile` 在 :file:`Include/pythonrun.h` 中定義，將 "
"Python 源作為輸入並回傳表示內容的 AST 的根。這個 AST 可以通過 "
":c:func:`PyAST_Compile` 變成一個程式碼物件。更多資訊，閱讀源程式碼"
"，然後在python-dev上提問。"

#: ../../whatsnew/2.5.rst:2127
#, fuzzy
msgid ""
"The AST code was developed under Jeremy Hylton's management, and implemented "
"by (in alphabetical order) Brett Cannon, Nick Coghlan, Grant Edwards, John "
"Ehresman, Kurt Kaiser, Neal Norwitz, Tim Peters, Armin Rigo, and Neil "
"Schemenauer, plus the participants in a number of AST sprints at conferences "
"such as PyCon."
msgstr ""
"AST 程式碼是在 Jeremy Hylton 的管理下開發的，並由（按字母順序排列）Brett "
"Cannon、Nick Coghlan、Grant Edwards、John Ehresman、Kurt Kaiser、Neal "
"Norwitz、Tim Peters、Armin Rigo 和 Neil Schenmauer 以及參與者實施在 PyCon "
"等會議上進行了許多 AST 衝刺。"

#: ../../whatsnew/2.5.rst:2136
#, fuzzy
msgid ""
"Evan Jones's patch to obmalloc, first described in a talk at PyCon DC 2005, "
"was applied.  Python 2.4 allocated small objects in 256K-sized arenas, but "
"never freed arenas.  With this patch, Python will free arenas when they're "
"empty.  The net effect is that on some platforms, when you allocate many "
"objects, Python's memory usage may actually drop when you delete them and "
"the memory may be returned to the operating system.  (Implemented by Evan "
"Jones, and reworked by Tim Peters.)"
msgstr ""
"應用了 Evan Jones 的 obmalloc 補丁，該補丁最初是在 PyCon DC 2005 "
"的一次演講中描述的。 Python 2.4 在 256K "
"大小的競技場中分配小物件，但從未釋放競技場。有了這個補丁，Python 將在競技場為"
"空時釋放他們。最終結果是，在某些平台上，當您分配許多物件時，當您刪除它們時，"
"Python 的記憶體使用量實際上可能會下降，並且記憶體可能會回傳給操作系統。 （由 "
"Evan Jones 實施，並由 Tim Peters 修改。）"

#: ../../whatsnew/2.5.rst:2144
#, fuzzy
msgid ""
"Note that this change means extension modules must be more careful when "
"allocating memory.  Python's API has many different functions for allocating "
"memory that are grouped into families.  For example, :c:func:"
"`PyMem_Malloc`, :c:func:`PyMem_Realloc`, and :c:func:`PyMem_Free` are one "
"family that allocates raw memory, while :c:func:`PyObject_Malloc`, :c:func:"
"`PyObject_Realloc`, and :c:func:`PyObject_Free` are another family that's "
"supposed to be used for creating Python objects."
msgstr ""
"請注意，此更改意味著擴充模組在分配記憶體時必須更加小心。 Python 的 API 有許多"
"不同的函式用於分配記憶體，這些函式被分組到不同的系列中。例如，:c:func:`PyMem_"
"Malloc`、:c:func:`PyMem_Realloc` 和:c:func:`PyMem_Free` "
"是分配原始記憶體的一個系列，而:c:func:`PyObject_Malloc`、:c "
":func:`PyObject_Realloc` 和 :c:func:`PyObject_Free` 是另一個應該用於建立 "
"Python 物件的家族。"

#: ../../whatsnew/2.5.rst:2152
#, fuzzy
msgid ""
"Previously these different families all reduced to the platform's :c:func:"
"`malloc` and :c:func:`free` functions.  This meant  it didn't matter if you "
"got things wrong and allocated memory with the :c:func:`PyMem` function but "
"freed it with the :c:func:`PyObject` function.  With 2.5's changes to "
"obmalloc, these families now do different things and mismatches will "
"probably result in a segfault.  You should carefully test your C extension "
"modules with Python 2.5."
msgstr ""
"以前，這些不同的系列都簡化為平台的 :c:func:`malloc` 和 :c:func:`free` 函式。"
"這意味著如果您出錯並使用 PyMem 函式分配記憶體但使用 PyObject "
"函式釋放它並不重要。隨著 2.5 對 obmalloc "
"的更改，這些系列現在做不同的事情，不匹配可能會導致段錯誤。您應該使用 Python "
"2.5 仔細測試您的 C 擴充模組。"

#: ../../whatsnew/2.5.rst:2159
#, fuzzy
msgid ""
"The built-in set types now have an official C API.  Call :c:func:`PySet_New` "
"and :c:func:`PyFrozenSet_New` to create a new set, :c:func:`PySet_Add` and :"
"c:func:`PySet_Discard` to add and remove elements, and :c:func:"
"`PySet_Contains` and :c:func:`PySet_Size` to examine the set's state. "
"(Contributed by Raymond Hettinger.)"
msgstr ""
"內建集合型別現在有一個官方的 C API。呼叫 :c:func:`PySet_New` 和 "
":c:func:`PyFrozenSet_New` 來建立一個新集合， :c:func:`PySet_Add` 和 "
":c:func:`PySet_Discard` 來新增和刪除元素，以及 :c :func:`PySet_Contains` 和 "
":c:func:`PySet_Size` 來檢查集合的狀態。 （雷蒙德·赫廷格供稿。）"

#: ../../whatsnew/2.5.rst:2165
#, fuzzy
msgid ""
"C code can now obtain information about the exact revision of the Python "
"interpreter by calling the  :c:func:`Py_GetBuildInfo` function that returns "
"a string of build information like this: ``\"trunk:45355:45356M, Apr 13 "
"2006, 07:42:19\"``.   (Contributed by Barry Warsaw.)"
msgstr ""
"C 程式碼現在可以通過呼叫 Py_GetBuildInfo 函式獲取有關 Python "
"直譯器的確切版本的資訊，該函式回傳一串構建資訊，如下所示：``\"trunk:45355:"
"45356M, Apr 13 2006, 07 :42:19\"``。 （由 Barry Warsaw 提供。）"

#: ../../whatsnew/2.5.rst:2170
#, fuzzy
msgid ""
"Two new macros can be used to indicate C functions that are local to the "
"current file so that a faster calling convention can be used. "
"``Py_LOCAL(type)`` declares the function as returning a value of the "
"specified *type* and uses a fast-calling qualifier. "
"``Py_LOCAL_INLINE(type)`` does the same thing and also requests the function "
"be inlined.  If :c:func:`PY_LOCAL_AGGRESSIVE` is defined before :file:"
"`python.h` is included, a set of more aggressive optimizations are enabled "
"for the module; you should benchmark the results to find out if these "
"optimizations actually make the code faster.  (Contributed by Fredrik Lundh "
"at the NeedForSpeed sprint.)"
msgstr ""
"兩個新的巨集可用於指示當前文件的本地 C 函式，以便可以使用更快的呼叫約定。 "
"``Py_LOCAL(type)`` 將函式聲明為回傳指定 *type* 的值並使用快速呼叫限定符。 "
"``Py_LOCAL_INLINE(type)`` "
"做同樣的事情並且還請求內聯函式。如果:c:func:`PY_LOCAL_AGGRESSIVE` "
"在包含 :file:`python.h` 之前定義，則為模組啟用一組更積極的最佳化；您應該對結果"
"進行基準測試，以了解這些最佳化是否真的使程式碼更快。 （由 Fredrik Lundh 在 "
"NeedForSpeed 衝刺中貢獻。）"

#: ../../whatsnew/2.5.rst:2181
#, fuzzy
msgid ""
"``PyErr_NewException(name, base, dict)`` can now accept a tuple of base "
"classes as its *base* argument.  (Contributed by Georg Brandl.)"
msgstr ""
"``PyErr_NewException(name, base, dict)`` "
"現在可以接受一個基底類別元組作為它的 *base* 參數。 （由喬治·布蘭德爾提供。）"

#: ../../whatsnew/2.5.rst:2184
#, fuzzy
msgid ""
"The :c:func:`PyErr_Warn` function for issuing warnings is now deprecated in "
"favour of ``PyErr_WarnEx(category, message, stacklevel)`` which lets you "
"specify the number of stack frames separating this function and the caller.  "
"A *stacklevel* of 1 is the function calling :c:func:`PyErr_WarnEx`, 2 is the "
"function above that, and so forth.  (Added by Neal Norwitz.)"
msgstr ""
"用於發出警告的 :c:func:`PyErr_Warn` 函式現已棄用，取而代之的是 "
"``PyErr_WarnEx(category, message, "
"stacklevel)``，它允許您指定分隔此函式和呼叫者的堆疊幀數。 *stacklevel* 為 1 "
"的是呼叫 :c:func:`PyErr_WarnEx` 的函式，2 是其上方的函式，依此類推。 （由 "
"Neal Norwitz 新增。）"

#: ../../whatsnew/2.5.rst:2190
#, fuzzy
msgid ""
"The CPython interpreter is still written in C, but  the code can now be "
"compiled with a C++ compiler without errors.   (Implemented by Anthony "
"Baxter, Martin von Löwis, Skip Montanaro.)"
msgstr ""
"CPython 直譯器仍然是用 C 編寫的，但程式碼現在可以使用 C++ "
"編譯器編譯而不會出錯。 （由 Anthony Baxter、Martin von Löwis 和 Skip "
"Montanaro 實施。）"

#: ../../whatsnew/2.5.rst:2194
#, fuzzy
msgid ""
"The :c:func:`PyRange_New` function was removed.  It was never documented, "
"never used in the core code, and had dangerously lax error checking.  In the "
"unlikely case that your extensions were using it, you can replace it by "
"something like the following::"
msgstr ""
":c:func:`PyRange_New` 函式已被刪除。它從未被記錄在案，從未在核心程式碼中使用"
"過，並且錯誤檢查非常鬆懈。在不太可能的情況下，您的擴充正在使用它，您可以將其"
"替換為如下內容："

#: ../../whatsnew/2.5.rst:2208
#, fuzzy
msgid "Port-Specific Changes"
msgstr "特定於端口的更改"

#: ../../whatsnew/2.5.rst:2210
#, fuzzy
msgid ""
"MacOS X (10.3 and higher): dynamic loading of modules now uses the :c:func:"
"`dlopen` function instead of MacOS-specific functions."
msgstr "MacOS X（10.3 及更高版本）：模組的動態加載現在使用 :c:func:`dlopen` "
"函式而不是 MacOS 特定的函式。"

#: ../../whatsnew/2.5.rst:2213
#, fuzzy
msgid ""
"MacOS X: an :option:`!--enable-universalsdk` switch was added to the :"
"program:`configure` script that compiles the interpreter as a universal "
"binary able to run on both PowerPC and Intel processors. (Contributed by "
"Ronald Oussoren; :issue:`2573`.)"
msgstr ""
"MacOS X：一個 :option:`!--enable-universalsdk` 開關被新增到 "
":program:`configure` 腳本中，該腳本將直譯器編譯為能夠在 PowerPC 和 Intel "
"處理器上運行的通用二進位文件。 （由 Ronald Oussoren 提供；:issue:`2573`。）"

#: ../../whatsnew/2.5.rst:2218
#, fuzzy
msgid ""
"Windows: :file:`.dll` is no longer supported as a filename extension for "
"extension modules.  :file:`.pyd` is now the only filename extension that "
"will be searched for."
msgstr "Windows：不再支援將 :file:`.dll` 作為擴充模組的文件擴充名。 :file:`.pyd` "
"現在是唯一要搜索的文件擴充名。"

#: ../../whatsnew/2.5.rst:2228
#, fuzzy
msgid "Porting to Python 2.5"
msgstr "移植到 Python 2.5"

#: ../../whatsnew/2.5.rst:2230
#, fuzzy
msgid ""
"This section lists previously described changes that may require changes to "
"your code:"
msgstr "本部分列出了之前描述的可能需要更改程式碼的更改："

#: ../../whatsnew/2.5.rst:2233
#, fuzzy
msgid ""
"ASCII is now the default encoding for modules.  It's now  a syntax error if "
"a module contains string literals with 8-bit characters but doesn't have an "
"encoding declaration.  In Python 2.4 this triggered a warning, not a syntax "
"error."
msgstr ""
"ASCII 現在是模組的預設編碼。現在，如果模組包含具有 8 "
"位字元的字串文字但沒有編碼聲明，則會出現語法錯誤。在 Python 2.4 "
"中，這會觸發警告，而不是語法錯誤。"

#: ../../whatsnew/2.5.rst:2238
#, fuzzy
msgid ""
"Previously, the :attr:`gi_frame` attribute of a generator was always a frame "
"object.  Because of the :pep:`342` changes described in section :ref:"
"`pep-342`, it's now possible for :attr:`gi_frame` to be ``None``."
msgstr ""
"以前，生成器的 :attr:`gi_frame` 屬性始終是一個框架物件。由於 :pep:`pep-342` "
"部分中描述的 :pep:`342` 更改，現在可以將 :attr:`gi_frame` 設定為 ``None``。"

#: ../../whatsnew/2.5.rst:2242
#, fuzzy
msgid ""
"A new warning, :class:`UnicodeWarning`, is triggered when  you attempt to "
"compare a Unicode string and an 8-bit string that can't be converted to "
"Unicode using the default ASCII encoding.  Previously such comparisons would "
"raise a :class:`UnicodeDecodeError` exception."
msgstr ""
"當您嘗試比較 Unicode 字串和無法使用預設 ASCII 編碼轉換為 Unicode 的 8 "
"位字串時，會觸發一個新警告 :class:`UnicodeWarning`。以前這樣的比較會引發 "
":class:`UnicodeDecodeError` 例外。"

#: ../../whatsnew/2.5.rst:2247
#, fuzzy
msgid ""
"Library: the :mod:`csv` module is now stricter about multi-line quoted "
"fields. If your files contain newlines embedded within fields, the input "
"should be split into lines in a manner which preserves the newline "
"characters."
msgstr "庫：:mod:`csv` 模組現在對多行引用欄位更加嚴格。如果您的文件包含嵌入在欄位中的"
"換行符，則應以保留換行符的方式將輸入分成幾行。"

#: ../../whatsnew/2.5.rst:2251
#, fuzzy
msgid ""
"Library: the :mod:`locale` module's  :func:`format` function's would "
"previously  accept any string as long as no more than one %char specifier "
"appeared.  In Python 2.5, the argument must be exactly one %char specifier "
"with no surrounding text."
msgstr ""
"庫：:mod:`locale` 模組的 :func:`format` 函式以前會接受任何字串，"
"只要出現不超過一個 %char 說明符即可。在 Python 2.5 中，"
"參數必須恰好是一個沒有周圍文本的 %char 說明符。"

#: ../../whatsnew/2.5.rst:2256
#, fuzzy
msgid ""
"Library: The :mod:`pickle` and :mod:`cPickle` modules no longer accept a "
"return value of ``None`` from the :meth:`__reduce__` method; the method must "
"return a tuple of arguments instead.  The modules also no longer accept the "
"deprecated *bin* keyword parameter."
msgstr ""
"庫：:mod:`pickle` 和 :mod:`cPickle` 模組不再接受 :meth:`__reduce__` "
"方法的回傳值 ``None``；該方法必須回傳一個參數元組。"
"這些模組也不再接受已棄用的 *bin* 關鍵字參數。"

#: ../../whatsnew/2.5.rst:2261
#, fuzzy
msgid ""
"Library: The :mod:`SimpleXMLRPCServer` and :mod:`DocXMLRPCServer`  classes "
"now have a :attr:`rpc_paths` attribute that constrains XML-RPC operations to "
"a limited set of URL paths; the default is to allow only ``'/'`` and ``'/"
"RPC2'``. Setting  :attr:`rpc_paths` to ``None`` or an empty tuple disables  "
"this path checking."
msgstr ""
"庫：:mod:`SimpleXMLRPCServer` 和 :mod:`DocXMLRPCServer` "
"類現在有一個 :attr:`rpc_paths` 屬性，將 XML-RPC 操作限制在一組有限的 URL "
"路徑；預設是只允許``'/'`` 和``'/RPC2'``。將 :attr:`rpc_paths` 設定為 ``None``"
" 或空元組將禁用此路徑檢查。"

#: ../../whatsnew/2.5.rst:2267
#, fuzzy
msgid ""
"C API: Many functions now use :c:type:`Py_ssize_t`  instead of :c:expr:`int` "
"to allow processing more data on 64-bit machines.  Extension code may need "
"to make the same change to avoid warnings and to support 64-bit machines.  "
"See the earlier section :ref:`pep-353` for a discussion of this change."
msgstr ""
"C API：許多函式現在使用 :c:type:`Py_ssize_t` 而不是 :c:expr:`int` 以允許在 "
"64 位機器上處理更多資料。擴充程式碼可能需要進行相同的更改以避免警告並支援 64 "
"位機器。有關此更改的討論，請參閱前面的部分 :ref:`pep-353`。"

#: ../../whatsnew/2.5.rst:2272
#, fuzzy
msgid ""
"C API:  The obmalloc changes mean that  you must be careful to not mix usage "
"of the ``PyMem_*`` and ``PyObject_*`` families of functions. Memory "
"allocated with  one family's ``*_Malloc`` must be  freed with the "
"corresponding family's ``*_Free`` function."
msgstr ""
"C API：obmalloc 更改意味著您必須小心不要混合使用 ``PyMem_*`` 和 "
"``PyObject_*`` 函式族。使用一個系列的 ``*_Malloc`` "
"分配的記憶體必須使用相應系列的 ``*_Free`` 函式釋放。"

#: ../../whatsnew/2.5.rst:2281
msgid "Acknowledgements"
msgstr "致謝"

#: ../../whatsnew/2.5.rst:2283
#, fuzzy
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article: "
"Georg Brandl, Nick Coghlan, Phillip J. Eby, Lars Gustäbel, Raymond "
"Hettinger, Ralf W. Grosse-Kunstleve, Kent Johnson, Iain Lowe, Martin von "
"Löwis, Fredrik Lundh, Andrew McNamara, Skip Montanaro, Gustavo Niemeyer, "
"Paul Prescod, James Pryor, Mike Rovner, Scott Weikart, Barry Warsaw, Thomas "
"Wouters."
msgstr ""
"作者要感謝以下人員為本文的各種草稿提供的建議、更正和協助：Georg Brandl、Nick "
"Coghlan、Phillip J. Eby、Lars Gustäbel、Raymond Hettinger、Ralf W. Grosse-"
"Kunstleve、Kent Johnson、 Iain Lowe、Martin von Löwis、Fredrik Lundh、Andrew "
"McNamara、Skip Montanaro、Gustavo Niemeyer、Paul Prescod、James Pryor、Mike "
"Rovner、Scott Weikart、Barry Warsaw、Thomas Wouters。"
