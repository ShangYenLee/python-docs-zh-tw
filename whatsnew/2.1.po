# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-22 00:18+0000\n"
"PO-Revision-Date: 2018-05-23 16:19+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/2.1.rst:3
msgid "What's New in Python 2.1"
msgstr "Python 2.1 有什麼新功能"

#: ../../whatsnew/2.1.rst:0
msgid "Author"
msgstr "作者"

#: ../../whatsnew/2.1.rst:5
msgid "A.M. Kuchling"
msgstr "A.M. Kuchling"

#: ../../whatsnew/2.1.rst:13
msgid "Introduction"
msgstr "簡介"

#: ../../whatsnew/2.1.rst:15
#, fuzzy
msgid ""
"This article explains the new features in Python 2.1.  While there aren't as "
"many changes in 2.1 as there were in Python 2.0, there are still some "
"pleasant surprises in store.  2.1 is the first release to be steered through "
"the use of Python Enhancement Proposals, or PEPs, so most of the sizable "
"changes have accompanying PEPs that provide more complete documentation and "
"a design rationale for the change.  This article doesn't attempt to document "
"the new features completely, but simply provides an overview of the new "
"features for Python programmers. Refer to the Python 2.1 documentation, or "
"to the specific PEP, for more details about any new feature that "
"particularly interests you."
msgstr ""
"本文介紹了 Python 2.1 中的新特性。雖然 2.1 中的變化不如 Python 2.0 "
"中那麼多，但仍有一些令人驚喜的驚喜。 2.1 是第一個通過使用 Python 增強建議 "
"(PEP) 來引導的版本，因此大多數相當大的更改都伴隨著 PEP，這些 PEP "
"提供了更完整的文檔和更改的設計理由。本文並不試圖完整記錄新功能，而只是為 "
"Python 程式員提供新功能的概述。有關您特別感興趣的任何新功能的更多詳細資訊，"
"請參閱 Python 2.1 文檔或特定的 PEP。"

#: ../../whatsnew/2.1.rst:25
#, fuzzy
msgid ""
"One recent goal of the Python development team has been to accelerate the "
"pace of new releases, with a new release coming every 6 to 9 months. 2.1 is "
"the first release to come out at this faster pace, with the first alpha "
"appearing in January, 3 months after the final version of 2.0 was released."
msgstr ""
"Python 開發團隊最近的一個目標是加快新版本的發布速度，每 6 到 9 "
"個月發布一個新版本。 2.1 是第一個以這種更快的速度發布的版本，第一個 alpha "
"版本在 2.0 最終版本發布 3 個月後的 1 月出現。"

#: ../../whatsnew/2.1.rst:30
#, fuzzy
msgid "The final release of Python 2.1 was made on April 17, 2001."
msgstr "Python 2.1 的最終版本發佈於 2001 年 4 月 17 日。"

#: ../../whatsnew/2.1.rst:36
#, fuzzy
msgid "PEP 227: Nested Scopes"
msgstr "PEP 227：嵌套作用域"

#: ../../whatsnew/2.1.rst:38
#, fuzzy
msgid ""
"The largest change in Python 2.1 is to Python's scoping rules.  In Python "
"2.0, at any given time there are at most three namespaces used to look up "
"variable names: local, module-level, and the built-in namespace.  This often "
"surprised people because it didn't match their intuitive expectations.  For "
"example, a nested recursive function definition doesn't work::"
msgstr ""
"Python 2.1 中最大的變化是 Python 的作用域規則。在 Python 2.0 中，在任何給定時"
"間最多有三個名稱空間用於查找變數名稱：本地名稱空間、模組級名稱空間和內建名稱"
"空間。這常常讓人們感到驚訝，因為它不符合他們的直覺預期。例如，嵌套遞迴函式定"
"義不起作用::"

#: ../../whatsnew/2.1.rst:51
#, fuzzy
msgid ""
"The function :func:`g` will always raise a :exc:`NameError` exception, "
"because the binding of the name ``g`` isn't in either its local namespace or "
"in the module-level namespace.  This isn't much of a problem in practice "
"(how often do you recursively define interior functions like this?), but "
"this also made using the :keyword:`lambda` expression clumsier, and this was "
"a problem in practice. In code which uses :keyword:`lambda` you can often "
"find local variables being copied by passing them as the default values of "
"arguments. ::"
msgstr ""
"函式 :func:`g` 將始終引發 :exc:`NameError` 例外，因為名稱 ``g`` 的綁定既不在"
"其本地命名空間中，也不在模組級命名空間中。這在實踐中不是什麼大問題（你多久會"
"像這樣遞迴定義內部函式？），但這也使得使用 :keyword:`lambda` "
"表達式變得笨拙，這在實踐中是一個問題。在使用 :keyword:`lambda` 的程式碼中，您"
"經常可以找到通過將局部變數作為參數的預設值傳遞來複製的局部變數。 ::"

#: ../../whatsnew/2.1.rst:65
#, fuzzy
msgid ""
"The readability of Python code written in a strongly functional style "
"suffers greatly as a result."
msgstr "以強函式風格編寫的 Python 程式碼的可讀性因此受到很大影響。"

#: ../../whatsnew/2.1.rst:68
#, fuzzy
msgid ""
"The most significant change to Python 2.1 is that static scoping has been "
"added to the language to fix this problem.  As a first effect, the "
"``name=name`` default argument is now unnecessary in the above example.  Put "
"simply, when a given variable name is not assigned a value within a function "
"(by an assignment, or the :keyword:`def`, :keyword:`class`, or :keyword:"
"`import` statements), references to the variable will be looked up in the "
"local namespace of the enclosing scope.  A more detailed explanation of the "
"rules, and a dissection of the implementation, can be found in the PEP."
msgstr ""
"Python 2.1 "
"最重要的變化是在語言中新增了靜態作用域來解決這個問題。作為第一個效果，"
"在上面的例子中現在不需要 ``name=name`` 預設參數。簡而言之，當一個給定的變數名"
"沒有在函式中被賦值時（通過賦值，或 :keyword:`def`、:keyword:`class` "
"或 :keyword:`import` 語句），引用變數將在封閉範圍的本地名稱空間中查找。可以在 "
"PEP 中找到對規則的更詳細解釋和對實作的剖析。"

#: ../../whatsnew/2.1.rst:77
#, fuzzy
msgid ""
"This change may cause some compatibility problems for code where the same "
"variable name is used both at the module level and as a local variable "
"within a function that contains further function definitions. This seems "
"rather unlikely though, since such code would have been pretty confusing to "
"read in the first place."
msgstr ""
"此更改可能會導致程式碼出現一些相容性問題，在這些程式碼中，相同的變數名稱既用"
"於模組級別，又用作包含更多函式定義的函式中的局部變數。但這似乎不太可能，因為"
"這樣的程式碼一開始讀起來會很混亂。"

#: ../../whatsnew/2.1.rst:83
#, fuzzy
msgid ""
"One side effect of the change is that the ``from module import *`` and "
"``exec`` statements have been made illegal inside a function scope under "
"certain conditions.  The Python reference manual has said all along that "
"``from module import *`` is only legal at the top level of a module, but the "
"CPython interpreter has never enforced this before.  As part of the "
"implementation of nested scopes, the compiler which turns Python source into "
"bytecodes has to generate different code to access variables in a containing "
"scope.  ``from module import *`` and ``exec`` make it impossible for the "
"compiler to figure this out, because they add names to the local namespace "
"that are unknowable at compile time. Therefore, if a function contains "
"function definitions or :keyword:`lambda` expressions with free variables, "
"the compiler will flag this by raising a :exc:`SyntaxError` exception."
msgstr ""
"這一變化的一個副作用是，在某些情況下，``from module import *`` 和 ``exec`` "
"語句在函式範圍內是非法的。 Python 參考手冊一直說“from module import "
"*”只在模組的頂層是合法的，但 CPython "
"直譯器以前從未強制執行過。作為嵌套作用域實作的一部分，將 Python "
"源程式碼轉換為位元組碼的編譯器必須生成不同的程式碼來訪問包含作用域中的變數。 "
"``from module import *`` 和 ``exec`` 使編譯器無法解決這個問題，因為它們將名稱"
"新增到編譯時不可知的本地命名空間。因此，如果函式包含函式定義或帶有自由變數的 "
"lambda 表達式，編譯器將通過引發 SyntaxError 例外來標記它。"

#: ../../whatsnew/2.1.rst:96
#, fuzzy
msgid "To make the preceding explanation a bit clearer, here's an example::"
msgstr "為了使前面的解釋更清楚一些，這裡有一個例子："

#: ../../whatsnew/2.1.rst:105
#, fuzzy
msgid ""
"Line 4 containing the ``exec`` statement is a syntax error, since ``exec`` "
"would define a new local variable named ``x`` whose value should be accessed "
"by :func:`g`."
msgstr ""
"包含 ``exec`` 語句的第 4 行是語法錯誤，因為 ``exec`` 將定義一個名為 ``x`` "
"的新局部變數，其值應由 :func:`g` 訪問。"

#: ../../whatsnew/2.1.rst:109
#, fuzzy
msgid ""
"This shouldn't be much of a limitation, since ``exec`` is rarely used in "
"most Python code (and when it is used, it's often a sign of a poor design "
"anyway)."
msgstr "這不應該是一個很大的限制，因為 ``exec`` 在大多數 Python "
"程式碼中很少使用（而且當它被使用時，它通常是糟糕設計的旗標）。"

#: ../../whatsnew/2.1.rst:113
#, fuzzy
msgid ""
"Compatibility concerns have led to nested scopes being introduced gradually; "
"in Python 2.1, they aren't enabled by default, but can be turned on within a "
"module by using a future statement as described in :pep:`236`.  (See the "
"following section for further discussion of :pep:`236`.)  In Python 2.2, "
"nested scopes will become the default and there will be no way to turn them "
"off, but users will have had all of 2.1's lifetime to fix any breakage "
"resulting from their introduction."
msgstr ""
"相容性問題導致嵌套作用域逐漸被引入；在 Python 2.1 中，預設情況下不啟用它們，"
"但可以通過使用 :pep:`236` 中描述的 future 語句在模組中打開。 （有關 "
":pep:`236` 的進一步討論，請參閱下一節。）在 Python 2.2 "
"中，嵌套範圍將成為預設設定，並且無法關閉它們，但使用者將擁有 2.1 "
"的全部生命週期修復因引入它們而導致的任何破損。"

#: ../../whatsnew/2.1.rst:123
#, fuzzy
msgid ":pep:`227` - Statically Nested Scopes"
msgstr ":pep:`227` - 靜態嵌套作用域"

#: ../../whatsnew/2.1.rst:124
msgid "Written and implemented by Jeremy Hylton."
msgstr "由 Jeremy Hylton 編寫和實作。"

#: ../../whatsnew/2.1.rst:130
#, fuzzy
msgid "PEP 236: __future__ Directives"
msgstr "PEP 236：__future__ 指令"

#: ../../whatsnew/2.1.rst:132
#, fuzzy
msgid ""
"The reaction to nested scopes was widespread concern about the dangers of "
"breaking code with the 2.1 release, and it was strong enough to make the "
"Pythoneers take a more conservative approach.  This approach consists of "
"introducing a convention for enabling optional functionality in release N "
"that will become compulsory in release N+1."
msgstr ""
"對嵌套作用域的反應是對 2.1 版本破壞程式碼的危險的廣泛關注，並且它足以讓 "
"Pythoneers 採取更保守的方法。這種方法包括在版本 N "
"中引入一個啟用可選功能的約定，該約定將在版本 N+1 中成為強制性的。"

#: ../../whatsnew/2.1.rst:138
#, fuzzy
msgid ""
"The syntax uses a ``from...import`` statement using the reserved module "
"name :mod:`__future__`.  Nested scopes can be enabled by the following "
"statement::"
msgstr "該語法使用一個使用保留模組名稱的``from...import`` "
"語句 :mod:`__future__`。可以通過以下語句啟用嵌套範圍："

#: ../../whatsnew/2.1.rst:143
#, fuzzy
msgid ""
"While it looks like a normal :keyword:`import` statement, it's not; there "
"are strict rules on where such a future statement can be put. They can only "
"be at the top of a module, and must precede any Python code or regular :"
"keyword:`!import` statements.  This is because such statements can affect "
"how the Python bytecode compiler parses code and generates bytecode, so they "
"must precede any statement that will result in bytecodes being produced."
msgstr ""
"雖然它看起來像一個普通的 :keyword:`import` 語句，但它不是；對於可以放置此類未"
"來聲明的位置，有嚴格的規定。它們只能位於模組的頂部，並且必須位於任何 Python "
"程式碼或常規 :keyword:`!import` 語句之前。這是因為此類語句會影響 Python 位元"
"組碼編譯器解析程式碼和生成位元組碼的方式，因此它們必須位於將導致生成位元組碼"
"的任何語句之前。"

#: ../../whatsnew/2.1.rst:153
#, fuzzy
msgid ":pep:`236` - Back to the :mod:`__future__`"
msgstr ":pep:`236` - 回到 :mod:`__future__`"

#: ../../whatsnew/2.1.rst:154
#, fuzzy
msgid "Written by Tim Peters, and primarily implemented by Jeremy Hylton."
msgstr "由 Tim Peters 編寫，主要由 Jeremy Hylton 實施。"

#: ../../whatsnew/2.1.rst:160
#, fuzzy
msgid "PEP 207: Rich Comparisons"
msgstr "PEP 207：豐富的比較"

#: ../../whatsnew/2.1.rst:162
#, fuzzy
msgid ""
"In earlier versions, Python's support for implementing comparisons on user-"
"defined classes and extension types was quite simple. Classes could "
"implement a :meth:`__cmp__` method that was given two instances of a class, "
"and could only return 0 if they were equal or +1 or -1 if they weren't; the "
"method couldn't raise an exception or return anything other than a Boolean "
"value.  Users of Numeric Python often found this model too weak and "
"restrictive, because in the number-crunching programs that numeric Python is "
"used for, it would be more useful to be able to perform elementwise "
"comparisons of two matrices, returning a matrix containing the results of a "
"given comparison for each element.  If the two matrices are of different "
"sizes, then the compare has to be able to raise an exception to signal the "
"error."
msgstr ""
"在早期版本中，Python 對實作使用者定義類和擴充型別比較的支援非常簡單。"
"類可以實作一個 :meth:`__cmp__` 方法，給定一個類的兩個實例，"
"如果它們相等則只能回傳 0，否則只能回傳 +1 或 "
"-1；該方法不能引發例外或回傳布爾值以外的任何值。 Numeric Python "
"的使用者經常發現此模型太弱且限制性太強，因為在使用 numeric Python 的數字運算"
"程式中，能夠對兩個矩陣執行元素比較更有用，回傳包含結果的矩陣每個元素的給定比"
"較。如果兩個矩陣的大小不同，則比較必須能夠引發例外以發出錯誤信號。"

#: ../../whatsnew/2.1.rst:174
#, fuzzy
msgid ""
"In Python 2.1, rich comparisons were added in order to support this need. "
"Python classes can now individually overload each of the ``<``, ``<=``, "
"``>``, ``>=``, ``==``, and ``!=`` operations.  The new magic method names "
"are:"
msgstr ""
"在 Python 2.1 中，新增了豐富的比較以支援這種需求。 Python "
"類現在可以單獨重載每個 ``<``、``<=``、``>``、``>=``、``==`` 和 ``!=`` 操作."
"新的魔術方法名稱是："

#: ../../whatsnew/2.1.rst:179
#, fuzzy
msgid "Operation"
msgstr "手術"

#: ../../whatsnew/2.1.rst:179
#, fuzzy
msgid "Method name"
msgstr "方法名稱"

#: ../../whatsnew/2.1.rst:181
msgid "``<``"
msgstr "``<``"

#: ../../whatsnew/2.1.rst:181
msgid ":meth:`__lt__`"
msgstr ":meth:`__lt__`"

#: ../../whatsnew/2.1.rst:183
msgid "``<=``"
msgstr "``<=``"

#: ../../whatsnew/2.1.rst:183
msgid ":meth:`__le__`"
msgstr ":meth:`__le__`"

#: ../../whatsnew/2.1.rst:185
msgid "``>``"
msgstr "``>``"

#: ../../whatsnew/2.1.rst:185
msgid ":meth:`__gt__`"
msgstr ":meth:`__gt__`"

#: ../../whatsnew/2.1.rst:187
msgid "``>=``"
msgstr "``>=``"

#: ../../whatsnew/2.1.rst:187
msgid ":meth:`__ge__`"
msgstr ":meth:`__ge__`"

#: ../../whatsnew/2.1.rst:189
msgid "``==``"
msgstr "``==``"

#: ../../whatsnew/2.1.rst:189
msgid ":meth:`__eq__`"
msgstr ":meth:`__eq__`"

#: ../../whatsnew/2.1.rst:191
msgid "``!=``"
msgstr "``!=``"

#: ../../whatsnew/2.1.rst:191
msgid ":meth:`__ne__`"
msgstr ":meth:`__ne__`"

#: ../../whatsnew/2.1.rst:194
#, fuzzy
msgid ""
"(The magic methods are named after the corresponding Fortran operators ``.LT."
"``. ``.LE.``, &c.  Numeric programmers are almost certainly quite familiar "
"with these names and will find them easy to remember.)"
msgstr ""
"（魔術方法以相應的 Fortran 運算符命名 ``.LT.``. ``.LE.`` "
"等。數字程式員幾乎肯定非常熟悉這些名稱，並且會發現它們很容易記住。）"

#: ../../whatsnew/2.1.rst:198
#, fuzzy
msgid ""
"Each of these magic methods is of the form ``method(self, other)``, where "
"``self`` will be the object on the left-hand side of the operator, while "
"``other`` will be the object on the right-hand side.  For example, the "
"expression ``A < B`` will cause ``A.__lt__(B)`` to be called."
msgstr ""
"這些魔術方法中的每一個都是“method(self, other)”的形式，其中 ``self``將是運算符左"
"側的物件，而 ``other``將是物件在右手側。例如，表達式“A < B”將導致呼叫“A."
"__lt__(B)”。"

#: ../../whatsnew/2.1.rst:203
#, fuzzy
msgid ""
"Each of these magic methods can return anything at all: a Boolean, a matrix, "
"a list, or any other Python object.  Alternatively they can raise an "
"exception if the comparison is impossible, inconsistent, or otherwise "
"meaningless."
msgstr ""
"這些魔術方法中的每一個都可以回傳任何東西：布爾值、矩陣、列表或任何其他 "
"Python 物件。或者，如果比較不可能、不一致或無意義，他們可以引發例外。"

#: ../../whatsnew/2.1.rst:207
#, fuzzy
msgid ""
"The built-in ``cmp(A,B)`` function can use the rich comparison machinery, "
"and now accepts an optional argument specifying which comparison operation "
"to use; this is given as one of the strings ``\"<\"``, ``\"<=\"``, ``\">"
"\"``, ``\">=\"``, ``\"==\"``, or ``\"!=\"``.  If called without the optional "
"third argument, :func:`cmp` will only return -1, 0, or +1 as in previous "
"versions of Python; otherwise it will call the appropriate method and can "
"return any Python object."
msgstr ""
"內建的 ``cmp(A,B)`` "
"函式可以使用豐富的比較機制，現在接受一個可選參數來指定要使用的比較操作；"
"這是作為字串之一給出的 ``\"<\"``, ``\"<=\"``, ``\">\"``, ``\">=\"``, ``\"==\""
"`` , 或 ``\"!=\"``。如果在沒有可選的第三個參數的情況下呼叫，:func:`cmp` "
"將只回傳 -1、0 或 +1，就像在以前的 Python 版本中一樣；"
"否則它將呼叫適當的方法並可以回傳任何 Python 物件。"

#: ../../whatsnew/2.1.rst:214
#, fuzzy
msgid ""
"There are also corresponding changes of interest to C programmers; there's a "
"new slot ``tp_richcmp`` in type objects and an API for performing a given "
"rich comparison.  I won't cover the C API here, but will refer you to :pep:"
"`207`, or to 2.1's C API documentation, for the full list of related "
"functions."
msgstr ""
"C程式員也有相應的興趣變化；型別對像中有一個新槽“tp_richcmp”，"
"還有一個用於執行給定豐富比較的 API。我不會在這裡介紹 C API，但會向您推薦 "
":pep:`207` 或 2.1 的 C API 文檔，以獲取相關函式的完整列表。"

#: ../../whatsnew/2.1.rst:223
#, fuzzy
msgid ":pep:`207` - Rich Comparisons"
msgstr ":pep:`207` - 豐富的比較"

#: ../../whatsnew/2.1.rst:223
#, fuzzy
msgid ""
"Written by Guido van Rossum, heavily based on earlier work by David Ascher, "
"and implemented by Guido van Rossum."
msgstr "由 Guido van Rossum 編寫，主要基於 David Ascher 的早期作品，並由 Guido van "
"Rossum 實施。"

#: ../../whatsnew/2.1.rst:230
#, fuzzy
msgid "PEP 230: Warning Framework"
msgstr "PEP 230：警告框架"

#: ../../whatsnew/2.1.rst:232
#, fuzzy
msgid ""
"Over its 10 years of existence, Python has accumulated a certain number of "
"obsolete modules and features along the way.  It's difficult to know when a "
"feature is safe to remove, since there's no way of knowing how much code "
"uses it --- perhaps no programs depend on the feature, or perhaps many do.  "
"To enable removing old features in a more structured way, a warning "
"framework was added. When the Python developers want to get rid of a "
"feature, it will first trigger a warning in the next version of Python.  The "
"following Python version can then drop the feature, and users will have had "
"a full release cycle to remove uses of the old feature."
msgstr ""
"在其存在的 10 年中，Python 一路積累了一定數量的過時模組和功能。很難知道何時可"
"以安全地刪除某個功能，因為無法知道有多少程式碼使用了它——也許沒有程式依賴於該"
"功能，或者可能有很多程式依賴於該功能。為了能夠以更有條理的方式刪除舊功能，新"
"增了一個警告框架。當 Python 開發者想要去掉一個特性時，它會首先在下一版本的 "
"Python 中觸發一個警告。接下來的 Python "
"版本可以刪除該功能，使用者將有一個完整的發布週期來刪除舊功能的使用。"

#: ../../whatsnew/2.1.rst:242
#, fuzzy
msgid ""
"Python 2.1 adds the warning framework to be used in this scheme.  It adds a :"
"mod:`warnings` module that provide functions to issue warnings, and to "
"filter out warnings that you don't want to be displayed. Third-party modules "
"can also use this framework to deprecate old features that they no longer "
"wish to support."
msgstr ""
"Python 2.1 增加了該方案中使用的警告框架。它新增了一個 :mod:`warnings` 模組，"
"該模組提供發出警告的功能，並過濾掉您不想顯示的警告。第三方模組也可以使用此框"
"架來棄用他們不再希望支援的舊功能。"

#: ../../whatsnew/2.1.rst:248
#, fuzzy
msgid ""
"For example, in Python 2.1 the :mod:`regex` module is deprecated, so "
"importing it causes a warning to be printed::"
msgstr "例如，在 Python 2.1 中，不推薦使用 :mod:`regex` "
"模組，因此導入它會導致印出警告："

#: ../../whatsnew/2.1.rst:256
#, fuzzy
msgid "Warnings can be issued by calling the :func:`warnings.warn` function::"
msgstr "可以通過呼叫 :func:`warnings.warn` 函式發出警告："

#: ../../whatsnew/2.1.rst:260
#, fuzzy
msgid ""
"The first parameter is the warning message; an additional optional "
"parameters can be used to specify a particular warning category."
msgstr "第一個參數是警告資訊；一個附加的可選參數可用於指定特定的警告類別。"

#: ../../whatsnew/2.1.rst:263
#, fuzzy
msgid ""
"Filters can be added to disable certain warnings; a regular expression "
"pattern can be applied to the message or to the module name in order to "
"suppress a warning.  For example, you may have a program that uses the :mod:"
"`regex` module and not want to spare the time to convert it to use the :mod:"
"`re` module right now.  The warning can be suppressed by calling ::"
msgstr ""
"可以新增過濾器以禁用某些警告；可以將正則表達式模式應用於消息或模組名稱以抑制"
"警告。例如，您可能有一個使用 :mod:`regex` 模組的程式，"
"現在不想花時間將其轉換為使用 :mod:`re` 模組。可以通過呼叫 :: 來抑制警告"

#: ../../whatsnew/2.1.rst:275
#, fuzzy
msgid ""
"This adds a filter that will apply only to warnings of the class :class:"
"`DeprecationWarning` triggered in the :mod:`__main__` module, and applies a "
"regular expression to only match the message about the :mod:`regex` module "
"being deprecated, and will cause such warnings to be ignored.  Warnings can "
"also be printed only once, printed every time the offending code is "
"executed, or turned into exceptions that will cause the program to stop "
"(unless the exceptions are caught in the usual way, of course)."
msgstr ""
"這新增了一個過濾器，該過濾器將僅適用於在 :mod:`__main__` "
"模組中觸發的類 :class:`DeprecationWarning` 的警告，並應用正則表達式僅匹配有關 "
":mod:`regex` 模組的消息已棄用，並將導致此類警告被忽略。警告也可以只印出一次，"
"每次執行有問題的程式碼時印出，或者變成會導致程式停止的例外（當然，除非以通常"
"的方式捕獲例外）。"

#: ../../whatsnew/2.1.rst:283
#, fuzzy
msgid ""
"Functions were also added to Python's C API for issuing warnings; refer to "
"PEP 230 or to Python's API documentation for the details."
msgstr "函式也被新增到 Python 的 C API 中以發出警告；有關詳細資訊，請參閱 PEP 230 或 "
"Python 的 API 文檔。"

#: ../../whatsnew/2.1.rst:293
#, fuzzy
msgid ":pep:`5` - Guidelines for Language Evolution"
msgstr ":pep:`5` - 語言進化指南"

#: ../../whatsnew/2.1.rst:290
#, fuzzy
msgid ""
"Written by Paul Prescod, to specify procedures to be followed when removing "
"old features from Python.  The policy described in this PEP hasn't been "
"officially adopted, but the eventual policy probably won't be too different "
"from Prescod's proposal."
msgstr ""
"由 Paul Prescod 編寫，用於指定從 Python 中刪除舊功能時要遵循的過程。本 PEP "
"中描述的政策尚未正式採用，但最終的政策可能不會與 Prescod 的提案有太大差異。"

#: ../../whatsnew/2.1.rst:295
#, fuzzy
msgid ":pep:`230` - Warning Framework"
msgstr ":pep:`230` - 警告框架"

#: ../../whatsnew/2.1.rst:296
#, fuzzy
msgid "Written and implemented by Guido van Rossum."
msgstr "由 Guido van Rossum 編寫和實施。"

#: ../../whatsnew/2.1.rst:302
#, fuzzy
msgid "PEP 229: New Build System"
msgstr "PEP 229：新構建系統"

#: ../../whatsnew/2.1.rst:304
#, fuzzy
msgid ""
"When compiling Python, the user had to go in and edit the :file:`Modules/"
"Setup` file in order to enable various additional modules; the default set "
"is relatively small and limited to modules that compile on most Unix "
"platforms. This means that on Unix platforms with many more features, most "
"notably Linux, Python installations often don't contain all useful modules "
"they could."
msgstr ""
"編譯 Python 時，使用者必須進入並編輯 Modules/Setup "
"文件才能啟用各種附加模組；預設設定相對較小，僅限於在大多數 Unix "
"平台上編譯的模組。這意味著在具有更多功能的 Unix 平台上，尤其是 Linux，Python "
"安裝通常不包含它們可能包含的所有有用模組。"

#: ../../whatsnew/2.1.rst:310
#, fuzzy
msgid ""
"Python 2.0 added the Distutils, a set of modules for distributing and "
"installing extensions.  In Python 2.1, the Distutils are used to compile "
"much of the standard library of extension modules, autodetecting which ones "
"are supported on the current machine.  It's hoped that this will make Python "
"installations easier and more featureful."
msgstr ""
"Python 2.0 新增了 Distutils，一組用於分發和安裝擴充的模組。在 Python 2.1 中，"
"Distutils 用於編譯大部分擴充模組的標準庫，自動檢測當前機器支援哪些模組。"
"希望這將使 Python 安裝更容易、功能更強大。"

#: ../../whatsnew/2.1.rst:316
#, fuzzy
msgid ""
"Instead of having to edit the :file:`Modules/Setup` file in order to enable "
"modules, a :file:`setup.py` script in the top directory of the Python source "
"distribution is run at build time, and attempts to discover which modules "
"can be enabled by examining the modules and header files on the system.  If "
"a module is configured in :file:`Modules/Setup`, the :file:`setup.py` script "
"won't attempt to compile that module and will defer to the :file:`Modules/"
"Setup` file's contents.  This provides a way to specific any strange command-"
"line flags or libraries that are required for a specific platform."
msgstr ""
"不必編輯 Modules/Setup 文件來啟用模組，而是在構建時運行 Python "
"源程式碼分發頂層目錄中的 setup.py "
"腳本，並嘗試發現通過檢查系統上的模組和標頭檔可以啟用哪些模組。如果在 Modules/"
"Setup 中配置了一個模組，setup.py 腳本將不會嘗試編譯該模組，而是遵從 Modules/"
"Setup "
"文件的內容。這提供了一種方法來指定特定平台所需的任何奇怪的命令列旗標或庫。"

#: ../../whatsnew/2.1.rst:325
#, fuzzy
msgid ""
"In another far-reaching change to the build mechanism, Neil Schemenauer "
"restructured things so Python now uses a single makefile that isn't "
"recursive, instead of makefiles in the top directory and in each of the :"
"file:`Python/`, :file:`Parser/`, :file:`Objects/`, and :file:`Modules/` "
"subdirectories.  This makes building Python faster and also makes hacking "
"the Makefiles clearer and simpler."
msgstr ""
"在構建機制的另一個影響深遠的變化中，Neil Schemenauer 重構了一些東西，因此 "
"Python 現在使用一個非遞迴的 makefile，而不是頂層目錄和每個 :file:`Python/`, :"
"file 中的 makefile :`Parser/`、:file:`Objects/` 和 :file:`Modules/` 子目錄。"
"這使得構建 Python 的速度更快，也使得破解 Makefile 更清晰、更簡單。"

#: ../../whatsnew/2.1.rst:335
#, fuzzy
msgid ":pep:`229` - Using Distutils to Build Python"
msgstr ":pep:`229` - 使用 Distutils 構建 Python"

#: ../../whatsnew/2.1.rst:336 ../../whatsnew/2.1.rst:574
#, fuzzy
msgid "Written and implemented by A.M. Kuchling."
msgstr "由 A.M. 編寫和實施庫奇林。"

#: ../../whatsnew/2.1.rst:342
#, fuzzy
msgid "PEP 205: Weak References"
msgstr "PEP 205：弱引用"

#: ../../whatsnew/2.1.rst:344
#, fuzzy
msgid ""
"Weak references, available through the :mod:`weakref` module, are a minor "
"but useful new data type in the Python programmer's toolbox."
msgstr "弱引用可通過 :mod:`weakref` 模組獲得，是 Python "
"程式員工具箱中的一種次要但有用的新資料型別。"

#: ../../whatsnew/2.1.rst:347
#, fuzzy
msgid ""
"Storing a reference to an object (say, in a dictionary or a list) has the "
"side effect of keeping that object alive forever.  There are a few specific "
"cases where this behaviour is undesirable, object caches being the most "
"common one, and another being circular references in data structures such as "
"trees."
msgstr ""
"儲存對物件的引用（例如，在字典或列表中）具有使該物件永遠存在的副作用。在一些"
"特定情況下，這種行為是不可取的，物件快取是最常見的一種，另一種是資料結構（如"
"樹）中的循環引用。"

#: ../../whatsnew/2.1.rst:352
#, fuzzy
msgid ""
"For example, consider a memoizing function that caches the results of "
"another function ``f(x)`` by storing the function's argument and its result "
"in a dictionary::"
msgstr "例如，考慮一個記憶函式，它通過將函式的參數及其結果儲存在字典中來快取另一個函"
"式“f(x)”的結果："

#: ../../whatsnew/2.1.rst:368
#, fuzzy
msgid ""
"This version works for simple things such as integers, but it has a side "
"effect; the ``_cache`` dictionary holds a reference to the return values, so "
"they'll never be deallocated until the Python process exits and cleans up. "
"This isn't very noticeable for integers, but if :func:`f` returns an object, "
"or a data structure that takes up a lot of memory, this can be a problem."
msgstr ""
"這個版本適用於簡單的東西，比如整數，但它有一個副作用； ``_cache`` "
"字典包含對回傳值的引用，因此在 Python "
"行程退出並清理之前它們永遠不會被釋放。這對於整數來說不是很明顯，但是如果 "
":func:`f` 回傳一個物件，或者一個佔用大量記憶體的資料結構，這可能是一個問題。"

#: ../../whatsnew/2.1.rst:374
#, fuzzy
msgid ""
"Weak references provide a way to implement a cache that won't keep objects "
"alive beyond their time.  If an object is only accessible through weak "
"references, the object will be deallocated and the weak references will now "
"indicate that the object it referred to no longer exists.  A weak reference "
"to an object *obj* is created by calling ``wr = weakref.ref(obj)``.  The "
"object being referred to is returned by calling the weak reference as if it "
"were a function: ``wr()``.  It will return the referenced object, or "
"``None`` if the object no longer exists."
msgstr ""
"弱引用提供了一種實作快取的方法，該快取不會使對像在超時後仍保持活動狀態。如果"
"一個對像只能通過弱引用訪問，該物件將被釋放，弱引用現在將指示它引用的對像不再"
"存在。通過呼叫 wr = weakref.ref(obj) 建立對物件 *obj* 的弱引用。被引用的物件"
"通過呼叫弱引用回傳，就好像它是一個函式：``wr()``。它將回傳引用的物件，如果該"
"對像不再存在，則回傳 ``None``。"

#: ../../whatsnew/2.1.rst:382
#, fuzzy
msgid ""
"This makes it possible to write a :func:`memoize` function whose cache "
"doesn't keep objects alive, by storing weak references in the cache. ::"
msgstr "這使得通過在快取中儲存弱引用來編寫其快取不會使物件保持活動狀態的 "
":func:`memoize` 函式成為可能。 ::"

#: ../../whatsnew/2.1.rst:400
#, fuzzy
msgid ""
"The :mod:`weakref` module also allows creating proxy objects which behave "
"like weak references --- an object referenced only by proxy objects is "
"deallocated -- but instead of requiring an explicit call to retrieve the "
"object, the proxy transparently forwards all operations to the object as "
"long as the object still exists.  If the object is deallocated, attempting "
"to use a proxy will cause a :exc:`weakref.ReferenceError` exception to be "
"raised. ::"
msgstr ""
":mod:`weakref` 模組還允許建立行為類似於弱引用的代理物件——僅由代理物件引用的對"
"像被釋放——但不需要顯式呼叫來檢索物件，代理透明地轉發所有操作只要物件仍然存在"
"。如果對像被釋放，嘗試使用代理將導致引發 :exc:`weakref.ReferenceError` 例外。"
" ::"

#: ../../whatsnew/2.1.rst:416
msgid ":pep:`205` - Weak References"
msgstr ":pep:`205` - 弱引用"

#: ../../whatsnew/2.1.rst:417
#, fuzzy
msgid "Written and implemented by Fred L. Drake, Jr."
msgstr "由 Fred L. Drake, Jr. 編寫和實施。"

#: ../../whatsnew/2.1.rst:423
#, fuzzy
msgid "PEP 232: Function Attributes"
msgstr "PEP 232：函式屬性"

#: ../../whatsnew/2.1.rst:425
#, fuzzy
msgid ""
"In Python 2.1, functions can now have arbitrary information attached to "
"them. People were often using docstrings to hold information about functions "
"and methods, because the ``__doc__`` attribute was the only way of attaching "
"any information to a function.  For example, in the Zope web application "
"server, functions are marked as safe for public access by having a "
"docstring, and in John Aycock's SPARK parsing framework, docstrings hold "
"parts of the BNF grammar to be parsed.  This overloading is unfortunate, "
"since docstrings are really intended to hold a function's documentation; for "
"example, it means you can't properly document functions intended for private "
"use in Zope."
msgstr ""
"在 Python 2.1 中，函式現在可以附加任意資訊。人們經常使用文檔字串來保存有關函"
"式和方法的資訊，因為 ``__doc__`` 屬性是將任何資訊附加到函式的唯一方法。例如，"
"在 Zope web 應用程式伺服器中，函式通過文檔字串被標記為對公開訪問是安全的，"
"而在 John Aycock 的 SPARK 解析框架中，文檔字串包含要解析的 BNF "
"語法部分。這種重載是不幸的，因為文檔字串實際上是為了保存函式的文檔；例如，"
"這意味著您無法正確記錄 Zope 中專供私人使用的功能。"

#: ../../whatsnew/2.1.rst:435
#, fuzzy
msgid ""
"Arbitrary attributes can now be set and retrieved on functions using the "
"regular Python syntax::"
msgstr "現在可以使用常規 Python 語法在函式上設定和檢索任意屬性："

#: ../../whatsnew/2.1.rst:444
#, fuzzy
msgid ""
"The dictionary containing attributes can be accessed as the function's :attr:"
"`~object.__dict__`. Unlike the :attr:`~object.__dict__` attribute of class "
"instances, in functions you can actually assign a new dictionary to :attr:"
"`~object.__dict__`, though the new value is restricted to a regular Python "
"dictionary; you *can't* be tricky and set it to a :class:`UserDict` "
"instance, or any other random object that behaves like a mapping."
msgstr ""
"包含屬性的字典可以作為函式的 :attr:`~object.__dict__` 訪問。與類實例的 "
":attr:`~object.__dict__` 屬性不同，在函式中，您實際上可以為 :attr:`~object."
"__dict__` 分配一個新字典，儘管新值僅限於常規 Python 字典；您 *不能* "
"狡猾並將其設定為 :class:`UserDict` 實例，或任何其他行為類似於映射的隨機物件。"

#: ../../whatsnew/2.1.rst:454
msgid ":pep:`232` - Function Attributes"
msgstr ":pep:`232` - 函式屬性"

#: ../../whatsnew/2.1.rst:455
msgid "Written and implemented by Barry Warsaw."
msgstr "由 Barry Warsaw 編寫和實作。"

#: ../../whatsnew/2.1.rst:461
#, fuzzy
msgid "PEP 235: Importing Modules on Case-Insensitive Platforms"
msgstr "PEP 235：在不區分大小寫的平台上導入模組"

#: ../../whatsnew/2.1.rst:463
#, fuzzy
msgid ""
"Some operating systems have filesystems that are case-insensitive, MacOS and "
"Windows being the primary examples; on these systems, it's impossible to "
"distinguish the filenames ``FILE.PY`` and ``file.py``, even though they do "
"store the file's name  in its original case (they're case-preserving, too)."
msgstr ""
"一些操作系統的文件系統不區分大小寫，MacOS 和 Windows "
"是主要示例；在這些系統上，不可能區分文件名 ``FILE.PY`` 和 ``file."
"py``，即使它們確實以原始大小寫儲存文件名（它們也是大小寫保留的）。"

#: ../../whatsnew/2.1.rst:468
#, fuzzy
msgid ""
"In Python 2.1, the :keyword:`import` statement will work to simulate case-"
"sensitivity on case-insensitive platforms.  Python will now search for the "
"first case-sensitive match by default, raising an :exc:`ImportError` if no "
"such file is found, so ``import file`` will not import a module named ``FILE."
"PY``. Case-insensitive matching can be requested by setting the :envvar:"
"`PYTHONCASEOK` environment variable before starting the Python interpreter."
msgstr ""
"在 Python 2.1 中，:keyword:`import` "
"語句將在不區分大小寫的平台上模擬區分大小寫。 Python "
"現在將預設搜索第一個區分大小寫的匹配項，如果未找到此類文件，則會引發 "
"ImportError，因此“導入文件”將不會導入名為“FILE.PY”的模組。在啟動 Python "
"直譯器之前，可以通過設定 PYTHONCASEOK 環境變數來請求不區分大小寫的匹配。"

#: ../../whatsnew/2.1.rst:479
#, fuzzy
msgid "PEP 217: Interactive Display Hook"
msgstr "PEP 217：交互式顯示掛鉤"

#: ../../whatsnew/2.1.rst:481
#, fuzzy
msgid ""
"When using the Python interpreter interactively, the output of commands is "
"displayed using the built-in :func:`repr` function. In Python 2.1, the "
"variable :func:`sys.displayhook` can be set to a callable object which will "
"be called instead of :func:`repr`. For example, you can set it to a special "
"pretty-printing function::"
msgstr ""
"當以交互方式使用 Python 直譯器時，命令的輸出使用內建的 repr 函式顯示。在 "
"Python 2.1 中，變數 :func:`sys.displayhook` 可以設定為一個可呼叫物件，"
"該物件將被呼叫而不是 :func:`repr`。例如，您可以將其設定為特殊的漂亮印出功能::"

#: ../../whatsnew/2.1.rst:502
#, fuzzy
msgid ":pep:`217` - Display Hook for Interactive Use"
msgstr ":pep:`217` - 用於交互使用的顯示掛鉤"

#: ../../whatsnew/2.1.rst:503
#, fuzzy
msgid "Written and implemented by Moshe Zadka."
msgstr "由 Moshe Zadka 編寫和實施。"

#: ../../whatsnew/2.1.rst:509
#, fuzzy
msgid "PEP 208: New Coercion Model"
msgstr "PEP 208：新的強制模型"

#: ../../whatsnew/2.1.rst:511
#, fuzzy
msgid ""
"How numeric coercion is done at the C level was significantly modified.  "
"This will only affect the authors of C extensions to Python, allowing them "
"more flexibility in writing extension types that support numeric operations."
msgstr "如何在 C 級別進行數字強制轉換已被顯著修改。這只會影響 Python 的 C "
"擴充的作者，使他們能夠更靈活地編寫支援數字操作的擴充型別。"

#: ../../whatsnew/2.1.rst:515
#, fuzzy
msgid ""
"Extension types can now set the type flag ``Py_TPFLAGS_CHECKTYPES`` in their "
"``PyTypeObject`` structure to indicate that they support the new coercion "
"model. In such extension types, the numeric slot functions can no longer "
"assume that they'll be passed two arguments of the same type; instead they "
"may be passed two arguments of differing types, and can then perform their "
"own internal coercion. If the slot function is passed a type it can't "
"handle, it can indicate the failure by returning a reference to the "
"``Py_NotImplemented`` singleton value. The numeric functions of the other "
"type will then be tried, and perhaps they can handle the operation; if the "
"other type also returns ``Py_NotImplemented``, then a :exc:`TypeError` will "
"be raised.  Numeric methods written in Python can also return "
"``Py_NotImplemented``, causing the interpreter to act as if the method did "
"not exist (perhaps raising a :exc:`TypeError`, perhaps trying another "
"object's numeric methods)."
msgstr ""
"擴充型別現在可以在其 ``PyTypeObject`` 結構中設定型別旗標“Py_TPFLAGS_CHECKTYPES”，"
"以指示它們支援新的強制模型。在這樣的擴充型別中，數字槽函式不能再假設它們將被"
"傳遞給相同型別的兩個參數；相反，它們可能會被傳遞給兩個不同型別的參數，然後可"
"以執行它們自己的內部強制轉換。如果槽函式傳遞給它無法處理的型別，"
"它可以通過回傳對 Py_NotImplemented 單例值的引用來指示失敗。然後將嘗試其他型別"
"的數字函式，也許它們可以處理該操作；如果其他型別也回傳 "
"``Py_NotImplemented``，則會引發 :exc:`TypeError`。用 Python 編寫的數字方法也"
"可以回傳“Py_NotImplemented”，導致直譯器就好像該方法不存在一樣（可能引發 "
":exc:`TypeError`，可能嘗試另一個物件的數字方法）。"

#: ../../whatsnew/2.1.rst:534
#, fuzzy
msgid ":pep:`208` - Reworking the Coercion Model"
msgstr ":pep:`208` - 改造強制模型"

#: ../../whatsnew/2.1.rst:533
#, fuzzy
msgid ""
"Written and implemented by Neil Schemenauer, heavily based upon earlier work "
"by Marc-André Lemburg.  Read this to understand the fine points of how "
"numeric operations will now be processed at the C level."
msgstr ""
"由 Neil Schenmauer 編寫和實施，主要基於 Marc-André Lemburg 的早期工作。"
"閱讀本文以了解現在如何在 C 級別處理數字運算的要點。"

#: ../../whatsnew/2.1.rst:541
#, fuzzy
msgid "PEP 241: Metadata in Python Packages"
msgstr "PEP 241：Python 包中的元資料"

#: ../../whatsnew/2.1.rst:543
#, fuzzy
msgid ""
"A common complaint from Python users is that there's no single catalog of "
"all the Python modules in existence.  T. Middleton's Vaults of Parnassus at "
"``www.vex.net/parnassus/`` (retired in February 2009, `available in the "
"Internet Archive Wayback Machine <https://web.archive.org/web/20090130140102/"
"http://www.vex.net/parnassus/>`_) was the largest catalog of Python modules, "
"but registering software at the Vaults is optional, and many people did not "
"bother."
msgstr ""
"Python 使用者普遍抱怨的是，沒有一個包含所有 Python 模組的單一目錄。 T. "
"Middleton 的 Vaults of Parnassus 位於 ``www.vex.net/parnassus/``（於 2009 年 "
"2 月退休，`可在 Internet Archive Wayback Machine <https://web.archive.org/"
"web/20090130140102/http: //www.vex.net/parnassus/>`_) 是最大的 Python "
"模組目錄，但在 Vaults 註冊軟件是可選的，很多人沒有費心。"

#: ../../whatsnew/2.1.rst:551
#, fuzzy
msgid ""
"As a first small step toward fixing the problem, Python software packaged "
"using the Distutils :command:`sdist` command will include a file named :file:"
"`PKG-INFO` containing information about the package such as its name, "
"version, and author (metadata, in cataloguing terminology).  :pep:`241` "
"contains the full list of fields that can be present in the :file:`PKG-INFO` "
"file.  As people began to package their software using Python 2.1, more and "
"more packages will include metadata, making it possible to build automated "
"cataloguing systems and experiment with them.  With the result experience, "
"perhaps it'll be possible to design a really good catalog and then build "
"support for it into Python 2.2. For example, the Distutils :command:`sdist` "
"and :command:`bdist_\\*` commands could support an ``upload`` option that "
"would automatically upload your package to a catalog server."
msgstr ""
"作為解決該問題的第一步，使用 Distutils :command:`sdist` 命令打包的 Python "
"軟件將包含一個名為 :file:`PKG-INFO` 的文件，其中包含有關包的資訊，例如其名稱"
"、版本和作者（元資料，在編目術語中）。 :pep:`241` 包含可以出現在 :file:`PKG-"
"INFO` 文件中的完整欄位列表。隨著人們開始使用 Python 2.1 打包他們的軟件，越來"
"越多的包將包含元資料，這使得構建自動化編目系統並對其進行試驗成為可能。有了結"
"果經驗，也許可以設計一個非常好的目錄，然後將對它的支援構建到 Python 2.2 "
"中。例如，Distutils :command:`sdist` 和 :command:`bdist_\\*` 命令可以支援 "
"``upload`` 選項，該選項會自動將您的包上傳到目錄伺服器。"

#: ../../whatsnew/2.1.rst:564
#, fuzzy
msgid ""
"You can start creating packages containing :file:`PKG-INFO` even if you're "
"not using Python 2.1, since a new release of the Distutils will be made for "
"users of earlier Python versions.  Version 1.0.2 of the Distutils includes "
"the changes described in :pep:`241`, as well as various bugfixes and "
"enhancements.  It will be available from the Distutils SIG at https://www."
"python.org/community/sigs/current/distutils-sig/."
msgstr ""
"即使您沒有使用 Python 2.1，您也可以開始建立包含 PKG-INFO 的包，因為將為早期 "
"Python 版本的使用者製作新版本的 Distutils。 Distutils 1.0.2 版包括 :pep:`241`"
" 中描述的更改，以及各種錯誤修復和增強功能。它可以從 Distutils SIG 獲得，"
"網址為 https://www.python.org/community/sigs/current/distutils-sig/。"

#: ../../whatsnew/2.1.rst:574
#, fuzzy
msgid ":pep:`241` - Metadata for Python Software Packages"
msgstr ":pep:`241` - Python 軟件包的元資料"

#: ../../whatsnew/2.1.rst:577
#, fuzzy
msgid ":pep:`243` - Module Repository Upload Mechanism"
msgstr ":pep:`243` - 模組儲存庫上傳機制"

#: ../../whatsnew/2.1.rst:577
#, fuzzy
msgid ""
"Written by Sean Reifschneider, this draft PEP describes a proposed mechanism "
"for uploading  Python packages to a central server."
msgstr "該 PEP 草案由 Sean Reifschneider 撰寫，描述了一種將 Python "
"包上傳到中央伺服器的擬議機制。"

#: ../../whatsnew/2.1.rst:584
#, fuzzy
msgid "New and Improved Modules"
msgstr "新的和改進的模組"

#: ../../whatsnew/2.1.rst:586
#, fuzzy
msgid ""
"Ka-Ping Yee contributed two new modules: :mod:`inspect.py`, a module for "
"getting information about live Python code, and :mod:`pydoc.py`, a module "
"for interactively converting docstrings to HTML or text.  As a bonus, :file:"
"`Tools/scripts/pydoc`, which is now automatically installed, uses :mod:"
"`pydoc.py` to display documentation given a Python module, package, or class "
"name.  For example, ``pydoc xml.dom`` displays the following::"
msgstr ""
"Ka-Ping Yee 貢獻了兩個新模組：:mod:`inspect.py`，一個用於獲取實時 Python "
"程式碼資訊的模組，和 :mod:`pydoc.py`，一個用於將文檔字串交互式轉換為 HTML "
"或文本的模組。作為獎勵，現在自動安裝的 :file:`Tools/scripts/pydoc` 使用 "
":mod:`pydoc.py` 顯示給定 Python 模組、包或類名的文檔。例如，``pydoc xml.dom``"
" 顯示以下內容："

#: ../../whatsnew/2.1.rst:608
#, fuzzy
msgid ""
":file:`pydoc` also includes a Tk-based interactive help browser.   :file:"
"`pydoc` quickly becomes addictive; try it out!"
msgstr ":file:`pydoc` 還包括一個基於 Tk 的交互式幫助瀏覽器。 :file:`pydoc` "
"很快就會讓人上癮；試試看！"

#: ../../whatsnew/2.1.rst:611
#, fuzzy
msgid ""
"Two different modules for unit testing were added to the standard library. "
"The :mod:`doctest` module, contributed by Tim Peters, provides a testing "
"framework based on running embedded examples in docstrings and comparing the "
"results against the expected output.  PyUnit, contributed by Steve Purcell, "
"is a unit testing framework inspired by JUnit, which was in turn an "
"adaptation of Kent Beck's Smalltalk testing framework.  See http://pyunit."
"sourceforge.net/ for more information about PyUnit."
msgstr ""
"標準庫中新增了兩個不同的單元測試模組。 :mod:`doctest` 模組由 Tim Peters 貢獻"
"，提供了一個基於在文檔字串中運行嵌入式示例並將結果與預期輸出進行比較的測試框"
"架。 PyUnit 由 Steve Purcell 貢獻，是一個受 JUnit 啟發的單元測試框架，"
"它又是對 Kent Beck 的 Smalltalk 測試框架的改編。有關 PyUnit 的更多資訊，"
"請參見 http://pyunit.sourceforge.net/。"

#: ../../whatsnew/2.1.rst:619
#, fuzzy
msgid ""
"The :mod:`difflib` module contains a class, :class:`SequenceMatcher`, which "
"compares two sequences and computes the changes required to transform one "
"sequence into the other.  For example, this module can be used to write a "
"tool similar to the Unix :program:`diff` program, and in fact the sample "
"program :file:`Tools/scripts/ndiff.py` demonstrates how to write such a "
"script."
msgstr ""
":mod:`difflib` 模組包含一個類：:class:`SequenceMatcher`，它比較兩個序列併計算"
"將一個序列轉換為另一個序列所需的更改。例如，此模組可用於編寫類似於 Unix "
":program:`diff` 程式的工具，實際上示例程式 :file:`Tools/scripts/ndiff.py` "
"演示瞭如何編寫此類腳本。"

#: ../../whatsnew/2.1.rst:625
#, fuzzy
msgid ""
":mod:`curses.panel`, a wrapper for the panel library, part of ncurses and of "
"SYSV curses, was contributed by Thomas Gellekum.  The panel library provides "
"windows with the additional feature of depth. Windows can be moved higher or "
"lower in the depth ordering, and the panel library figures out where panels "
"overlap and which sections are visible."
msgstr ""
":mod:`curses.panel` 是面板庫的包裝器，是 ncurses 和 SYSV curses 的一部分，由 "
"Thomas Gellekum 貢獻。面板庫為窗口提供了深度的附加功能。窗口可以按深度排序向"
"上或向下移動，面板庫會計算出面板重疊的位置以及可見的部分。"

#: ../../whatsnew/2.1.rst:631
#, fuzzy
msgid ""
"The PyXML package has gone through a few releases since Python 2.0, and "
"Python 2.1 includes an updated version of the :mod:`xml` package.  Some of "
"the noteworthy changes include support for Expat 1.2 and later versions, the "
"ability for Expat parsers to handle files in any encoding supported by "
"Python, and various bugfixes for SAX, DOM, and the :mod:`minidom` module."
msgstr ""
"PyXML 包自 Python 2.0 以來已經經歷了幾個版本，Python 2.1 包括 :mod:`xml` "
"包的更新版本。一些值得注意的變化包括對 Expat 1.2 及更高版本的支援，Expat "
"解析器能夠處理 Python 支援的任何編碼的文件，以及針對 SAX、DOM 和 "
":mod:`minidom` 模組的各種錯誤修復。"

#: ../../whatsnew/2.1.rst:637
#, fuzzy
msgid ""
"Ping also contributed another hook for handling uncaught exceptions. :func:"
"`sys.excepthook` can be set to a callable object.  When an exception isn't "
"caught by any :keyword:`try`...\\ :keyword:`except` blocks, the exception "
"will be passed to :func:`sys.excepthook`, which can then do whatever it "
"likes.  At the Ninth Python Conference, Ping demonstrated an application for "
"this hook: printing an extended traceback that not only lists the stack "
"frames, but also lists the function arguments and the local variables for "
"each frame."
msgstr ""
"Ping 還貢獻了另一個用於處理未捕獲例外的鉤子。 :func:`sys.excepthook` "
"可以設定為可呼叫物件。當例外沒有被任何 :keyword:`try`...\\ :keyword:`except` "
"塊捕獲時，例外將被傳遞給 :func:`sys."
"excepthook`，然後它可以做任何牠喜歡的事情。在第九屆 Python 大會上，Ping 演示"
"了這個鉤子的一個應用：印出一個擴充的回溯，它不僅列出了堆疊幀，還列出了每個幀"
"的函式參數和局部變數。"

#: ../../whatsnew/2.1.rst:645
#, fuzzy
msgid ""
"Various functions in the :mod:`time` module, such as :func:`asctime` and :"
"func:`localtime`, require a floating point argument containing the time in "
"seconds since the epoch.  The most common use of these functions is to work "
"with the current time, so the floating point argument has been made "
"optional; when a value isn't provided, the current time will be used.  For "
"example, log file entries usually need a string containing the current time; "
"in Python 2.1, ``time.asctime()`` can be used, instead of the lengthier "
"``time.asctime(time.localtime(time.time()))`` that was previously required."
msgstr ""
":mod:`time` 模組中的各種函式，例如 :func:`asctime` 和 :func:`localtime`，需要"
"一個浮點參數，其中包含自紀元以來的時間（以秒為單位）。這些函式最常見的用途是"
"處理當前時間，因此浮點參數是可選的；當未提供值時，將使用當前時間。例如，日誌"
"文件條目通常需要一個包含當前時間的字串；在 Python 2.1 中，可以使用 ``time."
"asctime()``，而不是以前需要的更長的 ``time.asctime(time.localtime(time."
"time()))``。"

#: ../../whatsnew/2.1.rst:654
#, fuzzy
msgid "This change was proposed and implemented by Thomas Wouters."
msgstr "此更改由 Thomas Wouters 提出並實施。"

#: ../../whatsnew/2.1.rst:656
#, fuzzy
msgid ""
"The :mod:`ftplib` module now defaults to retrieving files in passive mode, "
"because passive mode is more likely to work from behind a firewall.  This "
"request came from the Debian bug tracking system, since other Debian "
"packages use :mod:`ftplib` to retrieve files and then don't work from behind "
"a firewall. It's deemed unlikely that this will cause problems for anyone, "
"because Netscape defaults to passive mode and few people complain, but if "
"passive mode is unsuitable for your application or network setup, call "
"``set_pasv(0)`` on FTP objects to disable passive mode."
msgstr ""
":mod:`ftplib` "
"模組現在預設以被動模式檢索文件，因為被動模式更有可能在防火牆後面工作。"
"此請求來自 Debian 錯誤跟踪系統，因為其他 Debian 軟件包使用 :mod:`ftplib` "
"來檢索文件，然後無法在防火牆後工作。這被認為不太可能給任何人帶來問題，因為 "
"Netscape 預設為被動模式並且很少有人抱怨，但是如果被動模式不適合您的應用程式或"
"網絡設定，請在 FTP 對像上呼叫 ``set_pasv(0)`` 以禁用被動模式模式。"

#: ../../whatsnew/2.1.rst:665
#, fuzzy
msgid ""
"Support for raw socket access has been added to the :mod:`socket` module, "
"contributed by Grant Edwards."
msgstr "對原始 socket 訪問的支援已新增到 :mod:`socket` 模組，由 Grant Edwards 提供。"

#: ../../whatsnew/2.1.rst:668
#, fuzzy
msgid ""
"The :mod:`pstats` module now contains a simple interactive statistics "
"browser for displaying timing profiles for Python programs, invoked when the "
"module is run as a script.  Contributed by  Eric S. Raymond."
msgstr ""
"pstats 模組現在包含一個簡單的交互式統計瀏覽器，用於顯示 Python "
"程式的計時配置文件，當模組作為腳本運行時呼叫。由 Eric S. Raymond 提供。"

#: ../../whatsnew/2.1.rst:672
#, fuzzy
msgid ""
"A new implementation-dependent function, ``sys._getframe([depth])``, has "
"been added to return a given frame object from the current call stack. :func:"
"`sys._getframe` returns the frame at the top of the call stack;  if the "
"optional integer argument *depth* is supplied, the function returns the "
"frame that is *depth* calls below the top of the stack.  For example, ``sys."
"_getframe(1)`` returns the caller's frame object."
msgstr ""
"新增了一個新的依賴於實作的函式 ``sys._getframe([depth])`` "
"以從當前呼叫堆疊回傳給定的幀物件。 :func:`sys._getframe` "
"回傳呼叫堆疊頂部的幀；如果提供了可選的整數參數 *depth*，"
"則該函式回傳堆疊頂部以下 *depth* 呼叫的幀。例如，``sys._getframe(1)`` "
"回傳呼叫者的框架物件。"

#: ../../whatsnew/2.1.rst:679
#, fuzzy
msgid ""
"This function is only present in CPython, not in Jython or the .NET "
"implementation.  Use it for debugging, and resist the temptation to put it "
"into production code."
msgstr "此函式僅存在於 CPython 中，不存在於 Jython 或 .NET "
"實作中。將其用於除錯，並抵制將其放入生產程式碼的誘惑。"

#: ../../whatsnew/2.1.rst:687
msgid "Other Changes and Fixes"
msgstr "其他更改和修正"

#: ../../whatsnew/2.1.rst:689
#, fuzzy
msgid ""
"There were relatively few smaller changes made in Python 2.1 due to the "
"shorter release cycle.  A search through the CVS change logs turns up 117 "
"patches applied, and 136 bugs fixed; both figures are likely to be "
"underestimates.  Some of the more notable changes are:"
msgstr ""
"由於較短的發布週期，Python 2.1 中的較小更改相對較少。搜索 CVS "
"更改日誌發現應用了 117 個補丁，修復了 136 "
"個錯誤；這兩個數字都可能被低估了。一些更顯著的變化是："

#: ../../whatsnew/2.1.rst:694
#, fuzzy
msgid ""
"A specialized object allocator is now optionally available, that should be "
"faster than the system :func:`malloc` and have less memory overhead.  The "
"allocator uses C's :func:`malloc` function to get large pools of memory, and "
"then fulfills smaller memory requests from these pools.  It can be enabled "
"by providing the :option:`!--with-pymalloc` option to the :program:"
"`configure` script; see :file:`Objects/obmalloc.c` for the implementation "
"details."
msgstr ""
"現在可選擇使用專門的物件分配器，它應該比系統 :func:`malloc` "
"更快並且記憶體開銷更少。分配器使用 C 的 :func:`malloc` "
"函式獲取大記憶體池，然後從這些池中滿足較小的記憶體請求。可以通過向 "
":program:`configure` 腳本提供 :option:`!--with-pymalloc` "
"選項來啟用它；有關實施細節，請參閱 :file:`Objects/obmalloc.c`。"

#: ../../whatsnew/2.1.rst:701
#, fuzzy
msgid ""
"Authors of C extension modules should test their code with the object "
"allocator enabled, because some incorrect code may break, causing core dumps "
"at runtime. There are a bunch of memory allocation functions in Python's C "
"API that have previously been just aliases for the C library's :func:"
"`malloc` and :func:`free`, meaning that if you accidentally called "
"mismatched functions, the error wouldn't be noticeable.  When the object "
"allocator is enabled, these functions aren't aliases of :func:`malloc` and :"
"func:`free` any more, and calling the wrong function to free memory will get "
"you a core dump.  For example, if memory was allocated using :func:"
"`PyMem_New`, it has to be freed using :func:`PyMem_Del`, not :func:`free`.  "
"A few modules included with Python fell afoul of this and had to be fixed; "
"doubtless there are more third-party modules that will have the same problem."
msgstr ""
"C 擴充模組的作者應該在啟用物件分配器的情況下測試他們的程式碼，因為一些不正確"
"的程式碼可能會中斷，從而在運行時導致核心轉儲。 Python 的 C API "
"中有一堆記憶體分配函式，以前只是 C 庫的 :func:`malloc` 和 :func:`free` 的別名，"
"意味著如果你不小心呼叫了不匹配的函式，就不會報錯引人注目。啟用物件分配器後，"
"這些函式不再是 :func:`malloc` 和 :func:`free` "
"的別名，呼叫錯誤的函式來釋放記憶體將導致核心轉儲。例如，如果記憶體是使用 "
"PyMem_New 分配的，則必須使用 PyMem_Del 釋放它，而不是 :func:`free`。 Python "
"中的一些模組與此衝突，必須修復；毫無疑問，會有更多的第三方模組出現同樣的問題"
"。"

#: ../../whatsnew/2.1.rst:714
#, fuzzy
msgid "The object allocator was contributed by Vladimir Marangozov."
msgstr "物件分配器由 Vladimir Marangozov 貢獻。"

#: ../../whatsnew/2.1.rst:716
#, fuzzy
msgid ""
"The speed of line-oriented file I/O has been improved because people often "
"complain about its lack of speed, and because it's often been used as a "
"naïve benchmark.  The :meth:`readline` method of file objects has therefore "
"been rewritten to be much faster.  The exact amount of the speedup will vary "
"from platform to platform depending on how slow the C library's :func:`getc` "
"was, but is around 66%, and potentially much faster on some particular "
"operating systems. Tim Peters did much of the benchmarking and coding for "
"this change, motivated by a discussion in comp.lang.python."
msgstr ""
"面向行的文件 I/O 的速度得到了改進，因為人們經常抱怨它的速度不夠快，而且它經常"
"被用作一個簡單的基準。因此，文件物件的 :meth:`readline` "
"方法被重寫得更快。確切的加速量因平台而異，具體取決於 C 庫的 :func:`getc` "
"有多慢，但大約為 66%，並且在某些特定操作系統上可能更快。受 comp.lang.python "
"中的討論啟發，Tim Peters 為這一變化做了很多基準測試和編碼工作。"

#: ../../whatsnew/2.1.rst:725
#, fuzzy
msgid ""
"A new module and method for file objects was also added, contributed by Jeff "
"Epler. The new method, :meth:`xreadlines`, is similar to the existing :func:"
"`xrange` built-in.  :func:`xreadlines` returns an opaque sequence object "
"that only supports being iterated over, reading a line on every iteration "
"but not reading the entire file into memory as the existing :meth:"
"`readlines` method does. You'd use it like this::"
msgstr ""
"還新增了一個新的文件對像模組和方法，由 Jeff Epler "
"貢獻。新方法 :meth:`xreadlines` 類似於現有的內建方法 :func:`xrange`。 "
":func:`xreadlines` 回傳一個只支援疊代的不透明序列物件，在每次疊代時讀取一行，"
"但不像現有的 :meth:`readlines` "
"方法那樣將整個文件讀入記憶體。你會像這樣使用它::"

#: ../../whatsnew/2.1.rst:736
#, fuzzy
msgid ""
"For a fuller discussion of the line I/O changes, see the python-dev summary "
"for January 1--15, 2001 at https://mail.python.org/pipermail/python-dev/2001-"
"January/."
msgstr ""
"有關行 I/O 更改的更全面討論，請參閱 2001 年 1 月 1--15 日的 python-dev 摘要，"
"網址為 https://mail.python.org/pipermail/python-dev/2001-January/。"

#: ../../whatsnew/2.1.rst:739
#, fuzzy
msgid ""
"A new method, :meth:`popitem`, was added to dictionaries to enable "
"destructively iterating through the contents of a dictionary; this can be "
"faster for large dictionaries because there's no need to construct a list "
"containing all the keys or values. ``D.popitem()`` removes a random ``(key, "
"value)`` pair from the dictionary ``D`` and returns it as a 2-tuple.  This "
"was implemented mostly by Tim Peters and Guido van Rossum, after a "
"suggestion and preliminary patch by Moshe Zadka."
msgstr ""
"一種新方法，:meth:`popitem`，被新增到字典中，以實作對字典內容的破壞性疊代；這"
"對於大型詞典來說會更快，因為不需要構建包含所有鍵或值的列表。 ``D.popitem()`` "
"從字典 ``D`` 中刪除一個隨機的 ``(key, value)`` 對並將其作為 2 元組回傳。"
"這主要是由 Tim Peters 和 Guido van Rossum 在 Moshe Zadka "
"的建議和初步補丁之後實作的。"

#: ../../whatsnew/2.1.rst:747
#, fuzzy
msgid ""
"Modules can now control which names are imported when ``from module import "
"*`` is used, by defining an ``__all__`` attribute containing a list of names "
"that will be imported.  One common complaint is that if the module imports "
"other modules such as :mod:`sys` or :mod:`string`, ``from module import *`` "
"will add them to the importing module's namespace.  To fix this, simply list "
"the public names in ``__all__``::"
msgstr ""
"模組現在可以控制在使用“from module import *”時導入哪些名稱，方法是定義一個包"
"含將要導入的名稱列表的“__all__”屬性。一種常見的抱怨是，如果模組導入其他模組，"
"例如 :mod:`sys` 或 :mod:`string`，``from module import *`` "
"會將它們新增到導入模組的命名空間中。要解決此問題，只需在 ``__all__`` "
"中列出公開名稱::"

#: ../../whatsnew/2.1.rst:757
#, fuzzy
msgid ""
"A stricter version of this patch was first suggested and implemented by Ben "
"Wolfson, but after some python-dev discussion, a weaker final version was "
"checked in."
msgstr "Ben Wolfson 首先建議並實施了此補丁的更嚴格版本，但在一些 python-dev "
"討論之後，簽入了一個較弱的最終版本。"

#: ../../whatsnew/2.1.rst:761
#, fuzzy
msgid ""
"Applying :func:`repr` to strings previously used octal escapes for non-"
"printable characters; for example, a newline was ``'\\012'``.  This was a "
"vestigial trace of Python's C ancestry, but today octal is of very little "
"practical use.  Ka-Ping Yee suggested using hex escapes instead of octal "
"ones, and using the ``\\n``, ``\\t``, ``\\r`` escapes for the appropriate "
"characters, and implemented this new formatting."
msgstr ""
"將 :func:`repr` 應用於以前使用八進位轉義字元表示不可印出字元的字串；例如，"
"換行符是 ``'\\012'``。這是 Python 的 C "
"祖先的殘餘痕跡，但今天八進位幾乎沒有實際用途。 Ka-Ping Yee "
"建議使用十六進位轉義而不是八進位轉義，並對適當的字元使用 ``\\n"
"``、``\\t``、``\\r`` 轉義，並實作了這種新格式。"

#: ../../whatsnew/2.1.rst:768
#, fuzzy
msgid ""
"Syntax errors detected at compile-time can now raise exceptions containing "
"the filename and line number of the error, a pleasant side effect of the "
"compiler reorganization done by Jeremy Hylton."
msgstr "在編譯時檢測到的語法錯誤現在可以引發包含錯誤的文件名和行號的例外，這是 "
"Jeremy Hylton 完成的編譯器重組的一個令人愉快的副作用。"

#: ../../whatsnew/2.1.rst:772
#, fuzzy
msgid ""
"C extensions which import other modules have been changed to use :func:"
"`PyImport_ImportModule`, which means that they will use any import hooks "
"that have been installed.  This is also encouraged for third-party "
"extensions that need to import some other module from C code."
msgstr ""
"導入其他模組的 C 擴充已更改為使用 :func:`PyImport_ImportModule`，這意味著它們"
"將使用已安裝的任何導入掛鉤。這也鼓勵需要從 C "
"程式碼導入一些其他模組的第三方擴充。"

#: ../../whatsnew/2.1.rst:777
#, fuzzy
msgid ""
"The size of the Unicode character database was shrunk by another 340K thanks "
"to Fredrik Lundh."
msgstr "由於 Fredrik Lundh，Unicode 字元資料庫的大小又縮小了 340K。"

#: ../../whatsnew/2.1.rst:780
#, fuzzy
msgid ""
"Some new ports were contributed: MacOS X (by Steven Majewski), Cygwin (by "
"Jason Tishler); RISCOS (by Dietmar Schwertberger); Unixware 7  (by Billy G. "
"Allie)."
msgstr ""
"貢獻了一些新端口：MacOS X（Steven Majewski）、Cygwin（Jason Tishler）； "
"RISCOS（由 Dietmar Schwertberger 設計）； Unixware 7（Billy G. Allie）。"

#: ../../whatsnew/2.1.rst:784
#, fuzzy
msgid ""
"And there's the usual list of minor bugfixes, minor memory leaks, docstring "
"edits, and other tweaks, too lengthy to be worth itemizing; see the CVS logs "
"for the full details if you want them."
msgstr "還有通常的小錯誤修復、小記憶體洩漏、文檔字串編輯和其他調整的列表，太長了，不"
"值得逐條列出；如果需要，請參閱 CVS 日誌以獲取完整詳細資訊。"

#: ../../whatsnew/2.1.rst:792
msgid "Acknowledgements"
msgstr "致謝"

#: ../../whatsnew/2.1.rst:794
#, fuzzy
msgid ""
"The author would like to thank the following people for offering suggestions "
"on various drafts of this article: Graeme Cross, David Goodger, Jay Graves, "
"Michael Hudson, Marc-André Lemburg, Fredrik Lundh, Neil Schemenauer, Thomas "
"Wouters."
msgstr ""
"作者要感謝以下人員對本文的各種草稿提出的建議：Graeme Cross、David Goodger、"
"Jay Graves、Michael Hudson、Marc-André Lemburg、Fredrik Lundh、Neil "
"Schenmauer、Thomas Wouters。"
