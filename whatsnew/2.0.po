# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-15 20:43+0000\n"
"PO-Revision-Date: 2018-05-23 16:19+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/2.0.rst:3
msgid "What's New in Python 2.0"
msgstr "Python 2.0 有什麼新功能"

#: ../../whatsnew/2.0.rst:0
msgid "Author"
msgstr "作者"

#: ../../whatsnew/2.0.rst:5
msgid "A.M. Kuchling and Moshe Zadka"
msgstr "A.M. Kuchling 和 Moshe Zadka"

#: ../../whatsnew/2.0.rst:13
msgid "Introduction"
msgstr "簡介"

#: ../../whatsnew/2.0.rst:15
#, fuzzy
msgid ""
"A new release of Python, version 2.0, was released on October 16, 2000. This "
"article covers the exciting new features in 2.0, highlights some other "
"useful changes, and points out a few incompatible changes that may require "
"rewriting code."
msgstr ""
"Python 的新版本 2.0 於 2000 年 10 月 16 日發布。本文介紹了 2.0 中激動人心的新"
"功能，重點介紹了一些其他有用的更改，並指出了一些可能需要重寫程式碼的不相容更"
"改。"

#: ../../whatsnew/2.0.rst:20
#, fuzzy
msgid ""
"Python's development never completely stops between releases, and a steady "
"flow of bug fixes and improvements are always being submitted. A host of "
"minor fixes, a few optimizations, additional docstrings, and better error "
"messages went into 2.0; to list them all would be impossible, but they're "
"certainly significant. Consult the publicly available CVS logs if you want "
"to see the full list.  This progress is due to the five developers working "
"for  PythonLabs are now getting paid to spend their days fixing bugs, and "
"also due to the improved communication resulting  from moving to SourceForge."
msgstr ""
"Python 的開發在發布之間永遠不會完全停止，並且始終會提交源源不斷的錯誤修復和改"
"進。大量的小修復、一些最佳化、額外的文檔字串和更好的錯誤消息進入 2."
"0；將它們全部列出是不可能的，但它們肯定很重要。如果您想查看完整列表，"
"請查閱公開可用的 CVS 日誌。這一進展歸功於為 PythonLabs "
"工作的五名開發人員現在可以花時間修復錯誤並獲得報酬，也歸功於遷移到 "
"SourceForge 後溝通得到改善。"

#: ../../whatsnew/2.0.rst:33
#, fuzzy
msgid "What About Python 1.6?"
msgstr "Python 1.6 怎麼樣？"

#: ../../whatsnew/2.0.rst:35
#, fuzzy
msgid ""
"Python 1.6 can be thought of as the Contractual Obligations Python release. "
"After the core development team left CNRI in May 2000, CNRI requested that a "
"1.6 release be created, containing all the work on Python that had been "
"performed at CNRI.  Python 1.6 therefore represents the state of the CVS "
"tree as of May 2000, with the most significant new feature being Unicode "
"support.  Development continued after May, of course, so the 1.6 tree "
"received a few fixes to ensure that it's forward-compatible with Python "
"2.0.  1.6 is therefore part of Python's evolution, and not a side branch."
msgstr ""
"Python 1.6 可以被認為是合同義務 Python 版本。在核心開發團隊於 2000 年 5 "
"月離開 CNRI 後，CNRI 要求建立 1.6 版本，其中包含在 CNRI 上執行的所有 Python "
"工作。因此，Python 1.6 代表了截至 2000 年 5 月 CVS 樹的狀態，"
"其中最重要的新特性是 Unicode 支援。當然，開發在 5 月之後繼續進行，因此 1.6 "
"樹得到了一些修復，以確保它與 Python 2.0 向前相容。因此，1.6 是 Python "
"進化的一部分，而不是一個分支。"

#: ../../whatsnew/2.0.rst:44
#, fuzzy
msgid ""
"So, should you take much interest in Python 1.6?  Probably not.  The "
"1.6final and 2.0beta1 releases were made on the same day (September 5, "
"2000), the plan being to finalize Python 2.0 within a month or so.  If you "
"have applications to maintain, there seems little point in breaking things "
"by moving to 1.6, fixing them, and then having another round of breakage "
"within a month by moving to 2.0; you're better off just going straight to "
"2.0.  Most of the really interesting features described in this document are "
"only in 2.0, because a lot of work was done between May and September."
msgstr ""
"那麼，您應該對 Python 1.6 感興趣嗎？可能不是。 1.6final 和 2.0beta1 "
"版本是在同一天（2000 年 9 月 5 日）發布的，計劃在一個月左右的時間內完成 "
"Python 2.0。如果您有應用程式需要維護，那麼通過移動到 1.6 "
"來修復它們並在一個月內通過移動到 2.0 來進行另一輪破壞似乎沒有什麼意義；"
"你最好直接進入 2.0。本文檔中描述的大多數真正有趣的功能只在 2.0 中出現，"
"因為很多工作是在 5 月和 9 月之間完成的。"

#: ../../whatsnew/2.0.rst:57
#, fuzzy
msgid "New Development Process"
msgstr "新開發流程"

#: ../../whatsnew/2.0.rst:59
#, fuzzy
msgid ""
"The most important change in Python 2.0 may not be to the code at all, but "
"to how Python is developed: in May 2000 the Python developers began using "
"the tools made available by SourceForge for storing  source code, tracking "
"bug reports, and managing the queue of patch submissions.  To report bugs or "
"submit patches for Python 2.0, use the bug tracking and patch manager tools "
"available from Python's project page, located at https://sourceforge.net/"
"projects/python/."
msgstr ""
"Python 2.0 中最重要的變化可能根本不是程式碼，而是 Python 的開發方式：2000 年 "
"5 月，Python 開發人員開始使用 SourceForge "
"提供的工具來儲存源程式碼、跟踪錯誤報告和管理隊列補丁提交。要報告 Python 2.0 "
"的錯誤或提交補丁，請使用 Python 項目頁面上的錯誤跟踪和補丁管理器工具，"
"該頁面位於 https://sourceforge.net/projects/python/。"

#: ../../whatsnew/2.0.rst:66
#, fuzzy
msgid ""
"The most important of the services now hosted at SourceForge is the Python "
"CVS tree, the version-controlled repository containing the source code for "
"Python. Previously, there were roughly 7 or so people who had write access "
"to the CVS tree, and all patches had to be inspected and checked in by one "
"of the people on this short list. Obviously, this wasn't very scalable.  By "
"moving the CVS tree to SourceForge, it became possible to grant write access "
"to more people; as of September 2000 there were 27 people able to check in "
"changes, a fourfold increase.  This makes possible large-scale changes that "
"wouldn't be attempted if they'd have to be filtered through the small group "
"of core developers.  For example, one day Peter Schneider-Kamp took it into "
"his head to drop K&R C compatibility and convert the C source for Python to "
"ANSI C. After getting approval on the python-dev mailing list, he launched "
"into a flurry of checkins that lasted about a week, other developers joined "
"in to help, and the job was done.  If there were only 5 people with write "
"access, probably that task would have been viewed as \"nice, but not worth "
"the time and effort needed\" and it would never have gotten done."
msgstr ""
"現在託管在 SourceForge 上的最重要的服務是 Python CVS 樹，這是包含 Python "
"源程式碼的版本控制儲存庫。以前，大約有 7 個左右的人對 CVS 樹具有寫入權限，所"
"有補丁都必須由這個短名單上的一個人檢查和簽入。顯然，這不是很可擴充。通過將 "
"CVS 樹移動到 SourceForge，可以向更多人授予寫入權限；截至 2000 年 9 月，有 27 "
"人能夠檢查更改，增加了四倍。這使得大規模更改成為可能，如果必須通過一小群核心"
"開發人員進行過濾，則不會嘗試這些更改。例如，有一天 Peter Schneider-Kamp "
"想到放棄 K&R C 相容性並將 Python 的 C 源程式碼轉換為 ANSI C。在獲得 python-"
"dev 郵件列表的批准後，他發起了一系列持續的簽到大約一周後，其他開發人員加入幫"
"助，工作完成。如果只有 5 個人具有寫入權限，那麼該任務可能會被視為“不錯，但不"
"值得花費所需的時間和精力”，並且永遠不會完成。"

#: ../../whatsnew/2.0.rst:83
#, fuzzy
msgid ""
"The shift to using SourceForge's services has resulted in a remarkable "
"increase in the speed of development.  Patches now get submitted, commented "
"on, revised by people other than the original submitter, and bounced back "
"and forth between people until the patch is deemed worth checking in.  Bugs "
"are tracked in one central location and can be assigned to a specific person "
"for fixing, and we can count the number of open bugs to measure progress.  "
"This didn't come without a cost: developers now have more e-mail to deal "
"with, more mailing lists to follow, and special tools had to be written for "
"the new environment. For example, SourceForge sends default patch and bug "
"notification e-mail messages that are completely unhelpful, so Ka-Ping Yee "
"wrote an HTML screen-scraper that sends more useful messages."
msgstr ""
"轉向使用 SourceForge 的服務導致開發速度顯著提高。補丁現在由原始提交者以外的其"
"他人提交、評論和修改，並在人們之間來回反彈，直到補丁被認為值得簽入。錯誤在一"
"個中央位置被跟踪，並且可以分配給特定的人進行修復，我們可以計算打開的錯誤數量"
"來衡量進度。這並非沒有代價：開發人員現在要處理更多的電子郵件，要遵循更多的郵"
"件列表，並且必須為新環境編寫特殊工具。例如，SourceForge "
"發送的預設補丁和錯誤通知電子郵件消息完全沒有幫助，因此 Ka-Ping Yee "
"編寫了一個 HTML 屏幕抓取程式來發送更有用的消息。"

#: ../../whatsnew/2.0.rst:95
#, fuzzy
msgid ""
"The ease of adding code caused a few initial growing pains, such as code was "
"checked in before it was ready or without getting clear agreement from the "
"developer group.  The approval process that has emerged is somewhat similar "
"to that used by the Apache group. Developers can vote +1, +0, -0, or -1 on a "
"patch; +1 and -1 denote acceptance or rejection, while +0 and -0 mean the "
"developer is mostly indifferent to the change, though with a slight positive "
"or negative slant.  The most significant change from the Apache model is "
"that the voting is essentially advisory, letting Guido van Rossum, who has "
"Benevolent Dictator For Life status, know what the general opinion is. He "
"can still ignore the result of a vote, and approve or reject a change even "
"if the community disagrees with him."
msgstr ""
"新增程式碼的簡便性導致了一些最初的成長煩惱，例如程式碼在準備好之前就被簽入了"
"，或者沒有得到開發人員組的明確同意。已經出現的批准過程與 Apache "
"組使用的有點相似。開發人員可以對補丁進行 +1、+0、-0 或 -1 投票； +1 和 -1 "
"表示接受或拒絕，而 +0 和 -0 "
"表示開發人員對更改幾乎無動於衷，儘管有輕微的積極或消極傾向。與 Apache "
"模型相比，最顯著的變化是投票本質上是諮詢性的，讓擁有 Benevolent Dictator For "
"Life 身份的 Guido van Rossum 知道一般意見是什麼。即使社區不同意他，他仍然可以"
"忽略投票結果，批准或拒絕更改。"

#: ../../whatsnew/2.0.rst:106
#, fuzzy
msgid ""
"Producing an actual patch is the last step in adding a new feature, and is "
"usually easy compared to the earlier task of coming up with a good design. "
"Discussions of new features can often explode into lengthy mailing list "
"threads, making the discussion hard to follow, and no one can read every "
"posting to python-dev.  Therefore, a relatively formal process has been set "
"up to write Python Enhancement Proposals (PEPs), modelled on the internet "
"RFC process.  PEPs are draft documents that describe a proposed new feature, "
"and are continually revised until the community reaches a consensus, either "
"accepting or rejecting the proposal.  Quoting from the introduction to :pep:"
"`1`, \"PEP Purpose and Guidelines\":"
msgstr ""
"製作實際補丁是新增新功能的最後一步，與早期提出良好設計的任務相比，通常很容易"
"。對新功能的討論通常會爆發成冗長的郵件列表執行緒，使討論難以跟進，"
"而且沒有人可以閱讀每一篇發給 python-dev 的帖子。因此，"
"已經建立了一個相對正式的流程來編寫 Python Enhancement Proposals (PEPs)，"
"仿照網際網路 RFC 流程。 PEP 是描述提議的新功能的草案文件，並且會不斷修訂，直到"
"社區達成共識，接受或拒絕該提議。引用 :pep:`1` 的介紹，“PEP 目的和指南”："

#: ../../whatsnew/2.0.rst:120
#, fuzzy
msgid ""
"PEP stands for Python Enhancement Proposal.  A PEP is a design document "
"providing information to the Python community, or describing a new feature "
"for Python.  The PEP should provide a concise technical specification of the "
"feature and a rationale for the feature."
msgstr ""
"PEP 代表 Python 增強提案。 PEP 是向 Python 社區提供資訊或描述 Python "
"新功能的設計文檔。 PEP 應提供功能的簡明技術規範和功能的基本原理。"

#: ../../whatsnew/2.0.rst:125
#, fuzzy
msgid ""
"We intend PEPs to be the primary mechanisms for proposing new features, for "
"collecting community input on an issue, and for documenting the design "
"decisions that have gone into Python.  The PEP author is responsible for "
"building consensus within the community and documenting dissenting opinions."
msgstr ""
"我們希望 PEP 成為提出新功能、收集社區對某個問題的意見以及記錄已進入 Python "
"的設計決策的主要機制。 PEP 作者負責在社區內建立共識並記錄不同意見。"

#: ../../whatsnew/2.0.rst:130
#, fuzzy
msgid ""
"Read the rest of :pep:`1` for the details of the PEP editorial process, "
"style, and format.  PEPs are kept in the Python CVS tree on SourceForge, "
"though they're not part of the Python 2.0 distribution, and are also "
"available in HTML form from https://peps.python.org/.  As of September 2000, "
"there are 25 PEPS, ranging from :pep:`201`, \"Lockstep Iteration\", to PEP "
"225, \"Elementwise/Objectwise Operators\"."
msgstr ""
"閱讀 :pep:`1` 的其餘部分，了解 PEP 編輯過程、風格和格式的詳細資訊。 PEP "
"保存在 SourceForge 上的 Python CVS 樹中，儘管它們不是 Python 2.0 "
"發行版的一部分，並且也可以從 https://peps.python.org/ 以 HTML 形式獲得。截至 "
"2000 年 9 月，共有 25 個 PEPS，範圍從 :pep:`201`，“Lockstep Iteration”，到 "
"PEP 225，“Elementwise/Objectwise Operators”。"

#: ../../whatsnew/2.0.rst:141
msgid "Unicode"
msgstr "Unicode"

#: ../../whatsnew/2.0.rst:143
#, fuzzy
msgid ""
"The largest new feature in Python 2.0 is a new fundamental data type: "
"Unicode strings.  Unicode uses 16-bit numbers to represent characters "
"instead of the 8-bit number used by ASCII, meaning that 65,536 distinct "
"characters can be supported."
msgstr ""
"Python 2.0 中最大的新特性是一種新的基本資料型別：Unicode 字串。 Unicode 使用 "
"16 位數字來表示字元，而不是 ASCII 使用的 8 位數字，這意味著可以支援 65,536 "
"個不同的字元。"

#: ../../whatsnew/2.0.rst:148
#, fuzzy
msgid ""
"The final interface for Unicode support was arrived at through countless "
"often-stormy discussions on the python-dev mailing list, and mostly "
"implemented by Marc-André Lemburg, based on a Unicode string type "
"implementation by Fredrik Lundh.  A detailed explanation of the interface "
"was written up as :pep:`100`, \"Python Unicode Integration\". This article "
"will simply cover the most significant points about the Unicode interfaces."
msgstr ""
"Unicode 支援的最終介面是通過 python-dev "
"郵件列表上無數次經常激烈的討論得出的，主要由 Marc-André Lemburg 實作，基於 "
"Fredrik Lundh 的 Unicode 字串型別實作。介面的詳細解釋被寫成 :pep:`100`，“"
"Python Unicode Integration”。本文將簡單介紹有關 Unicode 介面的最重要的要點。"

#: ../../whatsnew/2.0.rst:155
#, fuzzy
msgid ""
"In Python source code, Unicode strings are written as ``u\"string\"``.  "
"Arbitrary Unicode characters can be written using a new escape sequence, ``"
"\\uHHHH``, where *HHHH* is a 4-digit hexadecimal number from 0000 to FFFF.  "
"The existing ``\\xHHHH`` escape sequence can also be used, and octal escapes "
"can be used for characters up to U+01FF, which is represented by ``\\777``."
msgstr ""
"在 Python 源程式碼中，Unicode 字串被寫為 ``u\"string\""
"``。可以使用新的轉義序列“\\uHHHH”來編寫任意 Unicode 字元，其中 *HHHH* 是從 "
"0000 到 FFFF 的 4 位十六進位數。也可以使用現有的``\\xHHHH"
"``轉義序列，對於U+01FF以內的字元可以使用八進位轉義，用``\\777``表示。"

#: ../../whatsnew/2.0.rst:161
#, fuzzy
msgid ""
"Unicode strings, just like regular strings, are an immutable sequence type. "
"They can be indexed and sliced, but not modified in place. Unicode strings "
"have an ``encode( [encoding] )`` method that returns an 8-bit string in the "
"desired encoding.  Encodings are named by strings, such as ``'ascii'``, "
"``'utf-8'``, ``'iso-8859-1'``, or whatever.  A codec API is defined for "
"implementing and registering new encodings that are then available "
"throughout a Python program. If an encoding isn't specified, the default "
"encoding is usually 7-bit ASCII, though it can be changed for your Python "
"installation by calling the ``sys.setdefaultencoding(encoding)`` function in "
"a customized version of :file:`site.py`."
msgstr ""
"Unicode 字串，就像常規字串一樣，是一種不可變的序列型別。它們可以被索引和切片"
"，但不能就地修改。 Unicode 字串有一個 ``encode( [encoding] )`` 方法，"
"它以所需的編碼回傳一個 8 "
"位字串。編碼由字串命名，例如 ``'ascii'``、 ``'utf-8'``、 ``'iso-8859-1'``等。編解碼器 API "
"被定義為實作和註冊新的編碼，然後在整個 Python 程式中可用。如果未指定編碼，"
"則預設編碼通常為 7 位 ASCII，但可以通過在自定義版本的 :file:`site.py` 中呼叫"
" ``sys.setdefaultencoding(encoding)`` 函式來更改 Python 安裝網站。"

#: ../../whatsnew/2.0.rst:172
#, fuzzy
msgid ""
"Combining 8-bit and Unicode strings always coerces to Unicode, using the "
"default ASCII encoding; the result of ``'a' + u'bc'`` is ``u'abc'``."
msgstr ""
"結合 8 位和 Unicode 字串總是強制轉換為 Unicode，使用預設的 ASCII 編碼； ``"
"'a' + u'bc'`` 的結果是 ``u'abc'``。"

#: ../../whatsnew/2.0.rst:175
#, fuzzy
msgid ""
"New built-in functions have been added, and existing built-ins modified to "
"support Unicode:"
msgstr "新增了新的內建函式，並修改了現有的內建函式以支援 Unicode："

#: ../../whatsnew/2.0.rst:178
#, fuzzy
msgid ""
"``unichr(ch)`` returns a Unicode string 1 character long, containing the "
"character *ch*."
msgstr "``unichr(ch)`` 回傳一個 1 個字元長的 Unicode 字串，包含字元 *ch*。"

#: ../../whatsnew/2.0.rst:181
#, fuzzy
msgid ""
"``ord(u)``, where *u* is a 1-character regular or Unicode string, returns "
"the number of the character as an integer."
msgstr "``ord(u)``，其中 *u* 是 1 個字元的常規字串或 Unicode "
"字串，回傳字元數作為整數。"

#: ../../whatsnew/2.0.rst:184
#, fuzzy
msgid ""
"``unicode(string [, encoding]  [, errors] )`` creates a Unicode string from "
"an 8-bit string.  ``encoding`` is a string naming the encoding to use. The "
"``errors`` parameter specifies the treatment of characters that are invalid "
"for the current encoding; passing ``'strict'`` as the value causes an "
"exception to be raised on any encoding error, while ``'ignore'`` causes "
"errors to be silently ignored and ``'replace'`` uses U+FFFD, the official "
"replacement character, in case of any problems."
msgstr ""
"``unicode(string [, encoding] [, errors] )`` 從一個 8 位字串建立一個 Unicode "
"字串。 ``encoding`` 是命名要使用的編碼的字串。 ``errors`` 參數指定對當前編碼"
"無效字元的處理；將 ``'strict'``作為值傳遞會導致在任何編碼錯誤時引發例外，而 ``'ignore'``"
" 會導致錯誤被靜默忽略，而 ``'replace'`` 會使用 "
"U+FFFD，官方替換字元，以防出現任何問題。"

#: ../../whatsnew/2.0.rst:192
#, fuzzy
msgid ""
"The ``exec`` statement, and various built-ins such as ``eval()``, "
"``getattr()``, and ``setattr()`` will also accept Unicode strings as well as "
"regular strings.  (It's possible that the process of fixing this missed some "
"built-ins; if you find a built-in function that accepts strings but doesn't "
"accept Unicode strings at all, please report it as a bug.)"
msgstr ""
"``exec`` 語句和各種內建函式，例如 ``eval()``、``getattr()`` 和 ``setattr()`` "
"也將接受 Unicode 字串和常規字串。 （修復此問題的過程可能遺漏了一些內建函式；"
"如果您發現一個接受字串但根本不接受 Unicode "
"字串的內建函式，請將其報告為錯誤。）"

#: ../../whatsnew/2.0.rst:198
#, fuzzy
msgid ""
"A new module, :mod:`unicodedata`, provides an interface to Unicode character "
"properties.  For example, ``unicodedata.category(u'A')`` returns the 2-"
"character string 'Lu', the 'L' denoting it's a letter, and 'u' meaning that "
"it's uppercase. ``unicodedata.bidirectional(u'\\u0660')`` returns 'AN', "
"meaning that U+0660 is an Arabic number."
msgstr ""
"一個新模組 :mod:`unicodedata` 提供了一個 Unicode "
"字元屬性的介面。例如，``unicodedata.category(u'A')`` 回傳 2 個字元的字串 "
"'Lu'，'L' 表示它是一個字母，'u' 表示它是大寫的。 ``unicodedata."
"bidirectional(u'\\u0660')`` 回傳'AN'，表示U+0660 是一個阿拉伯數字。"

#: ../../whatsnew/2.0.rst:204
#, fuzzy
msgid ""
"The :mod:`codecs` module contains functions to look up existing encodings "
"and register new ones.  Unless you want to implement a new encoding, you'll "
"most often use the ``codecs.lookup(encoding)`` function, which returns a 4-"
"element tuple: ``(encode_func, decode_func, stream_reader, stream_writer)``."
msgstr ""
":mod:`codecs` "
"模組包含查找現有編碼和註冊新編碼的功能。除非你想實作一個新的編碼，"
"否則你將最常使用 ``codecs.lookup(encoding)`` 函式，它回傳一個 4 元素元組：``("
"encode_func, decode_func, stream_reader, stream_writer)``。"

#: ../../whatsnew/2.0.rst:209
#, fuzzy
msgid ""
"*encode_func* is a function that takes a Unicode string, and returns a 2-"
"tuple ``(string, length)``.  *string* is an 8-bit string containing a "
"portion (perhaps all) of the Unicode string converted into the given "
"encoding, and *length* tells you how much of the Unicode string was "
"converted."
msgstr ""
"*encode_func* 是一個函式，它接受一個 Unicode 字串，並回傳一個二元組``("
"string, length)``。 *string* 是一個 8 位字串，包含轉換為給定編碼的 Unicode "
"字串的一部分（可能是全部），*length* 告訴您轉換了多少 Unicode 字串。"

#: ../../whatsnew/2.0.rst:214
#, fuzzy
msgid ""
"*decode_func* is the opposite of *encode_func*, taking an 8-bit string and "
"returning a 2-tuple ``(ustring, length)``, consisting of the resulting "
"Unicode string *ustring* and the integer *length* telling how much of the 8-"
"bit string was consumed."
msgstr ""
"*decode_func* 與 *encode_func* 相反，採用一個 8 位字串並回傳一個 2 元組 ``("
"ustring, length)``，由生成的 Unicode 字串 *ustring* 和整數 *length* 組成，"
"說明如何消耗了大部分 8 位字串。"

#: ../../whatsnew/2.0.rst:219
#, fuzzy
msgid ""
"*stream_reader* is a class that supports decoding input from a stream. "
"*stream_reader(file_obj)* returns an object that supports the :meth:`read`, :"
"meth:`readline`, and :meth:`readlines` methods.  These methods will all "
"translate from the given encoding and return Unicode strings."
msgstr ""
"*stream_reader* 是一個支援從流中解碼輸入的類。 *stream_reader(file_obj)* "
"回傳一個支援 :meth:`read`、:meth:`readline` 和 :meth:`readlines` 方法的物件。"
"這些方法都將從給定的編碼轉換並回傳 Unicode 字串。"

#: ../../whatsnew/2.0.rst:224
#, fuzzy
msgid ""
"*stream_writer*, similarly, is a class that supports encoding output to a "
"stream.  *stream_writer(file_obj)* returns an object that supports the :meth:"
"`write` and :meth:`writelines` methods.  These methods expect Unicode "
"strings, translating them to the given encoding on output."
msgstr ""
"*stream_writer*，類似地，是一個支援編碼輸出到流的類。 "
"*stream_writer(file_obj)* 回傳一個支援 :meth:`write` 和 :meth:`writelines` "
"方法的物件。這些方法需要 Unicode 字串，將它們轉換為給定的輸出編碼。"

#: ../../whatsnew/2.0.rst:229
#, fuzzy
msgid ""
"For example, the following code writes a Unicode string into a file,  "
"encoding it as UTF-8::"
msgstr "例如，以下程式碼將 Unicode 字串寫入文件，並將其編碼為 UTF-8::"

#: ../../whatsnew/2.0.rst:243
#, fuzzy
msgid "The following code would then read UTF-8 input from the file::"
msgstr "下面的程式碼將從文件中讀取 UTF-8 輸入："

#: ../../whatsnew/2.0.rst:249
#, fuzzy
msgid ""
"Unicode-aware regular expressions are available through the :mod:`re` "
"module, which has a new underlying implementation called SRE written by "
"Fredrik Lundh of Secret Labs AB."
msgstr ""
"可通過 :mod:`re` 模組獲得支援 Unicode 的正則表達式，該模組有一個名為 SRE "
"的新底層實作，由 Secret Labs AB 的 Fredrik Lundh 編寫。"

#: ../../whatsnew/2.0.rst:253
#, fuzzy
msgid ""
"A ``-U`` command line option was added which causes the Python compiler to "
"interpret all string literals as Unicode string literals. This is intended "
"to be used in testing and future-proofing your Python code, since some "
"future version of Python may drop support for 8-bit strings and provide only "
"Unicode strings."
msgstr ""
"新增了一個 ``-U``命令列選項，它會導致 Python 編譯器將所有字串文字解釋為 Unicode "
"字串文字。這旨在用於測試和驗證您的 Python 程式碼，因為某些未來版本的 Python "
"可能會放棄對 8 位字串的支援並僅提供 Unicode 字串。"

#: ../../whatsnew/2.0.rst:262
msgid "List Comprehensions"
msgstr "串列綜合運算（List Comprehension）"

#: ../../whatsnew/2.0.rst:264
#, fuzzy
msgid ""
"Lists are a workhorse data type in Python, and many programs manipulate a "
"list at some point.  Two common operations on lists are to loop over them, "
"and either pick out the elements that meet a certain criterion, or apply "
"some function to each element.  For example, given a list of strings, you "
"might want to pull out all the strings containing a given substring, or "
"strip off trailing whitespace from each line."
msgstr ""
"列表是 Python 中的主力資料型別，許多程式在某些時候操作列表。列表上的兩個常見"
"操作是遍歷它們，或者挑選出滿足特定條件的元素，或者對每個元素應用一些函式。例"
"如，給定一個字串列表，您可能想要提取包含給定子字串的所有字串，或者從每一行中"
"去除尾隨空格。"

#: ../../whatsnew/2.0.rst:271
#, fuzzy
msgid ""
"The existing :func:`map` and :func:`filter` functions can be used for this "
"purpose, but they require a function as one of their arguments.  This is "
"fine if there's an existing built-in function that can be passed directly, "
"but if there isn't, you have to create a little function to do the required "
"work, and Python's scoping rules make the result ugly if the little function "
"needs additional information.  Take the first example in the previous "
"paragraph, finding all the strings in the list containing a given "
"substring.  You could write the following to do it::"
msgstr ""
"現有的 :func:`map` 和 :func:`filter` 函式可用於此目的，但它們需要一個函式作為"
"它們的參數之一。如果存在可以直接傳遞的現有內建函式，這很好，但如果沒有，則必"
"須建立一個小函式來完成所需的工作，如果小函式需要，Python 的作用域規則會使結果"
"變得醜陋附加資訊。以上一段中的第一個示例為例，查找列表中包含給定子字串的所有"
"字串。您可以編寫以下內容來執行此操作::"

#: ../../whatsnew/2.0.rst:286
#, fuzzy
msgid ""
"Because of Python's scoping rules, a default argument is used so that the "
"anonymous function created by the :keyword:`lambda` expression knows what "
"substring is being searched for.  List comprehensions make this cleaner::"
msgstr ""
"由於 Python 的作用域規則，使用預設參數以便由 :keyword:`lambda` "
"表達式建立的匿名函式知道要搜索的子字串。列表理解使這個更清晰::"

#: ../../whatsnew/2.0.rst:292
#, fuzzy
msgid "List comprehensions have the form::"
msgstr "列表推導具有以下形式："

#: ../../whatsnew/2.0.rst:299
#, fuzzy
msgid ""
"The :keyword:`!for`...\\ :keyword:`!in` clauses contain the sequences to be "
"iterated over.  The sequences do not have to be the same length, because "
"they are *not* iterated over in parallel, but from left to right; this is "
"explained more clearly in the following paragraphs.  The elements of the "
"generated list will be the successive values of *expression*.  The final :"
"keyword:`!if` clause is optional; if present, *expression* is only evaluated "
"and added to the result if *condition* is true."
msgstr ""
":keyword:`!for`...\\ :keyword:`!in` 子句包含要疊代的序列。序列不必具有相同的"
"長度，因為它們*不是*並行疊代，而是從左到右疊代；這在以下段落中有更清楚的解釋"
"。生成的列表的元素將是 *expression* 的連續值。最後的 :keyword:`!if` "
"子句是可選的；如果存在，則 *expression* 僅在 *condition* "
"為真時才被評估並新增到結果中。"

#: ../../whatsnew/2.0.rst:307
#, fuzzy
msgid ""
"To make the semantics very clear, a list comprehension is equivalent to the "
"following Python code::"
msgstr "為了使語義非常清楚，列表推導等同於以下 Python 程式碼："

#: ../../whatsnew/2.0.rst:319
#, fuzzy
msgid ""
"This means that when there are multiple :keyword:`!for`...\\ :keyword:`!in` "
"clauses, the resulting list will be equal to the product of the lengths of "
"all the sequences.  If you have two lists of length 3, the output list is 9 "
"elements long::"
msgstr ""
"這意味著當有多個 :keyword:`!for`...\\ :keyword:`!in` "
"子句時，結果列表將等於所有序列長度的乘積。如果您有兩個長度為 3 的列表，"
"則輸出列表的長度為 9 個元素："

#: ../../whatsnew/2.0.rst:330
#, fuzzy
msgid ""
"To avoid introducing an ambiguity into Python's grammar, if *expression* is "
"creating a tuple, it must be surrounded with parentheses.  The first list "
"comprehension below is a syntax error, while the second one is correct::"
msgstr ""
"為避免在 Python 語法中引入歧義，如果 *expression* 正在建立一個元組，則它必須"
"用括號括起來。下面的第一個列表理解是語法錯誤，而第二個是正確的::"

#: ../../whatsnew/2.0.rst:339
#, fuzzy
msgid ""
"The idea of list comprehensions originally comes from the functional "
"programming language Haskell (https://www.haskell.org).  Greg Ewing argued "
"most effectively for adding them to Python and wrote the initial list "
"comprehension patch, which was then discussed for a seemingly endless time "
"on the python-dev mailing list and kept up-to-date by Skip Montanaro."
msgstr ""
"列表理解的思想最初來自函式式編程語言 Haskell (https://www.haskell.org)。 "
"Greg Ewing 最有效地爭論將它們新增到 Python 並編寫了最初的列表理解補丁，"
"然後在 python-dev 郵件列表上討論了似乎無休止的時間，並由 Skip Montanaro "
"保持最新。"

#: ../../whatsnew/2.0.rst:349
#, fuzzy
msgid "Augmented Assignment"
msgstr "增強分配"

#: ../../whatsnew/2.0.rst:351
#, fuzzy
msgid ""
"Augmented assignment operators, another long-requested feature, have been "
"added to Python 2.0.  Augmented assignment operators include ``+=``, ``-=``, "
"``*=``, and so forth.  For example, the statement ``a += 2`` increments the "
"value of the variable  ``a`` by 2, equivalent to the slightly lengthier ``a "
"= a + 2``."
msgstr ""
"Python 2.0 中新增了另一個期待已久的功能——增強賦值運算符。擴充賦值運算符包括“+"
"=”、“-=”、“*=”等。例如，語句 ``a += 2`` 將變數 ``a`` 的值遞增 2，"
"相當於稍長的 ``a = a + 2``。"

#: ../../whatsnew/2.0.rst:356
#, fuzzy
msgid ""
"The full list of supported assignment operators is ``+=``, ``-=``, ``*=``, "
"``/=``, ``%=``, ``**=``, ``&=``, ``|=``, ``^=``, ``>>=``, and ``<<=``.  "
"Python classes can override the augmented assignment operators by defining "
"methods named :meth:`__iadd__`, :meth:`__isub__`, etc.  For example, the "
"following :class:`Number` class stores a number and supports using += to "
"create a new instance with an incremented value."
msgstr ""
"支援的賦值運算符的完整列表是``+=``, ``-=``, ``*=``, ``/=``, ``%=``, ``**=`` "
"，``&=``，``|=``，``^=``，``>>=`` 和``<<=``。 Python 類可以通過定義名為 "
":meth:`__iadd__`、:meth:`__isub__` 等的方法來覆蓋擴充賦值運算符。例如，"
"下面的 :class:`Number` 類儲存數字並支援使用 += 建立具有增量值的新實例。"

#: ../../whatsnew/2.0.rst:377
#, fuzzy
msgid ""
"The :meth:`__iadd__` special method is called with the value of the "
"increment, and should return a new instance with an appropriately modified "
"value; this return value is bound as the new value of the variable on the "
"left-hand side."
msgstr ":meth:`__iadd__` 特殊方法使用增量值呼叫，並且應該回傳一個具有適當修改值的新實"
"例；此回傳值綁定為左側變數的新值。"

#: ../../whatsnew/2.0.rst:381
#, fuzzy
msgid ""
"Augmented assignment operators were first introduced in the C programming "
"language, and most C-derived languages, such as :program:`awk`, C++, Java, "
"Perl, and PHP also support them.  The augmented assignment patch was "
"implemented by Thomas Wouters."
msgstr ""
"增廣賦值運算符首先在 C 編程語言中引入，大多數 C 派生的語言，如 "
"awk、C++、Java、Perl 和 PHP 也支援它們。增強分配補丁由 Thomas Wouters 實施。"

#: ../../whatsnew/2.0.rst:390
#, fuzzy
msgid "String Methods"
msgstr "字串方法"

#: ../../whatsnew/2.0.rst:392
#, fuzzy
msgid ""
"Until now string-manipulation functionality was in the :mod:`string` module, "
"which was usually a front-end for the :mod:`strop` module written in C.  The "
"addition of Unicode posed a difficulty for the :mod:`strop` module, because "
"the functions would all need to be rewritten in order to accept either 8-bit "
"or Unicode strings.  For functions such as :func:`string.replace`, which "
"takes 3 string arguments, that means eight possible permutations, and "
"correspondingly complicated code."
msgstr ""
"到目前為止，字串操作功能在 :mod:`string` 模組中，它通常是用 C 編寫的 "
":mod:`strop` 模組的前端。新增 Unicode 給 :mod:` 帶來了困難strop` 模組，"
"因為所有函式都需要重寫才能接受 8 位或 Unicode 字串。對於像 :func:`string."
"replace` 這樣的函式，它接受 3 "
"個字串參數，這意味著八種可能的排列，以及相應的複雜程式碼。"

#: ../../whatsnew/2.0.rst:400
#, fuzzy
msgid ""
"Instead, Python 2.0 pushes the problem onto the string type, making string "
"manipulation functionality available through methods on both 8-bit strings "
"and Unicode strings.   ::"
msgstr "相反，Python 2.0 將問題推給了字串型別，通過 8 位字串和 Unicode "
"字串的方法提供了字串操作功能。 ::"

#: ../../whatsnew/2.0.rst:411
#, fuzzy
msgid ""
"One thing that hasn't changed, a noteworthy April Fools' joke "
"notwithstanding, is that Python strings are immutable. Thus, the string "
"methods return new strings, and do not modify the string on which they "
"operate."
msgstr "有一件事沒有改變，儘管有一個值得注意的愚人節笑話，那就是 Python "
"字串是不可變的。因此，字串方法回傳新字串，並且不修改它們操作的字串。"

#: ../../whatsnew/2.0.rst:415
#, fuzzy
msgid ""
"The old :mod:`string` module is still around for backwards compatibility, "
"but it mostly acts as a front-end to the new string methods."
msgstr "舊的 :mod:`string` 模組仍然存在是為了向後相容，但它主要充當新字串方法的前端。"

#: ../../whatsnew/2.0.rst:418
#, fuzzy
msgid ""
"Two methods which have no parallel in pre-2.0 versions, although they did "
"exist in JPython for quite some time, are :meth:`startswith` and :meth:"
"`endswith`. ``s.startswith(t)`` is equivalent to ``s[:len(t)] == t``, while "
"``s.endswith(t)`` is equivalent to ``s[-len(t):] == t``."
msgstr ""
"兩個在 pre-2.0 版本中沒有並行的方法，儘管它們確實存在於 JPython "
"中很長一段時間，它們是 :meth:`startswith` 和 :meth:`endswith`。 ``s."
"startswith(t)`` 相當於 ``s[:len(t)] == t``，而 ``s.endswith(t)`` 相當於 "
"``s[-len( t):] == t``。"

#: ../../whatsnew/2.0.rst:423
#, fuzzy
msgid ""
"One other method which deserves special mention is :meth:`join`.  The :meth:"
"`join` method of a string receives one parameter, a sequence of strings, and "
"is equivalent to the :func:`string.join` function from the old :mod:`string` "
"module, with the arguments reversed. In other words, ``s.join(seq)`` is "
"equivalent to the old ``string.join(seq, s)``."
msgstr ""
"另一種值得特別提及的方法是 :meth:`join`。字串的 :meth:`join` "
"方法接收一個參數，即一系列字串，相當於舊 :mod:`string` 模組中的 :func:`string"
".join` 函式，只是參數顛倒了。換句話說，``s.join(seq)`` 等同於舊的``string."
"join(seq, s)``。"

#: ../../whatsnew/2.0.rst:433
#, fuzzy
msgid "Garbage Collection of Cycles"
msgstr "循環的垃圾收集"

#: ../../whatsnew/2.0.rst:435
#, fuzzy
msgid ""
"The C implementation of Python uses reference counting to implement garbage "
"collection.  Every Python object maintains a count of the number of "
"references pointing to itself, and adjusts the count as references are "
"created or destroyed.  Once the reference count reaches zero, the object is "
"no longer accessible, since you need to have a reference to an object to "
"access it, and if the count is zero, no references exist any longer."
msgstr ""
"Python 的 C 實作使用引用計數來實作垃圾收集。每個 Python 物件都維護指向自身的"
"引用數量的計數，並在建立或銷毀引用時調整計數。一旦引用計數達到零，就無法再訪"
"問該物件，因為您需要有一個物件的引用才能訪問它，如果計數為零，則不再存在引用"
"。"

#: ../../whatsnew/2.0.rst:442
#, fuzzy
msgid ""
"Reference counting has some pleasant properties: it's easy to understand and "
"implement, and the resulting implementation is portable, fairly fast, and "
"reacts well with other libraries that implement their own memory handling "
"schemes.  The major problem with reference counting is that it sometimes "
"doesn't realise that objects are no longer accessible, resulting in a memory "
"leak.  This happens when there are cycles of references."
msgstr ""
"引用計數有一些令人愉快的特性：它易於理解和實作，並且最終的實作是可移植的、相"
"當快的，並且與其他實作自己的記憶體處理方案的庫反應良好。引用計數的主要問題是"
"它有時沒有意識到物件不再可訪問，從而導致記憶體洩漏。當存在引用循環時會發生這"
"種情況。"

#: ../../whatsnew/2.0.rst:449
#, fuzzy
msgid ""
"Consider the simplest possible cycle,  a class instance which has a "
"reference to itself::"
msgstr "考慮最簡單的循環，一個引用自身的類實例："

#: ../../whatsnew/2.0.rst:455
#, fuzzy
msgid ""
"After the above two lines of code have been executed, the reference count of "
"``instance`` is 2; one reference is from the variable named ``'instance'``, "
"and the other is from the ``myself`` attribute of the instance."
msgstr ""
"上面兩行程式碼執行後，``instance``的引用計數為2；一個引用來自名為 ``'instance'`` 的"
"變數，另一個來自實例的 ``myself``屬性。"

#: ../../whatsnew/2.0.rst:459
#, fuzzy
msgid ""
"If the next line of code is ``del instance``, what happens?  The reference "
"count of ``instance`` is decreased by 1, so it has a reference count of 1; "
"the reference in the ``myself`` attribute still exists.  Yet the instance is "
"no longer accessible through Python code, and it could be deleted.  Several "
"objects can participate in a cycle if they have references to each other, "
"causing all of the objects to be leaked."
msgstr ""
"如果下一行程式碼是“del instance”，會發生什麼？ ``instance`` 的引用計數減 1，"
"因此它的引用計數為 1； ``myself`` 屬性中的引用仍然存在。然而，"
"該實例無法再通過 Python 程式碼訪問，並且可以將其刪除。如果多個物件相互引用，"
"則它們可以參與一個循環，從而導致所有物件都被洩漏。"

#: ../../whatsnew/2.0.rst:466
#, fuzzy
msgid ""
"Python 2.0 fixes this problem by periodically executing a cycle detection "
"algorithm which looks for inaccessible cycles and deletes the objects "
"involved. A new :mod:`gc` module provides functions to perform a garbage "
"collection, obtain debugging statistics, and tuning the collector's "
"parameters."
msgstr ""
"Python 2.0 通過定期執行循環檢測演算法來解決此問題，該演算法查找不可訪問的循環"
"並刪除涉及的物件。一個新的 :mod:`gc` "
"模組提供了執行垃圾收集、獲取除錯統計資訊和調整收集器參數的功能。"

#: ../../whatsnew/2.0.rst:471
#, fuzzy
msgid ""
"Running the cycle detection algorithm takes some time, and therefore will "
"result in some additional overhead.  It is hoped that after we've gotten "
"experience with the cycle collection from using 2.0, Python 2.1 will be able "
"to minimize the overhead with careful tuning.  It's not yet obvious how much "
"performance is lost, because benchmarking this is tricky and depends "
"crucially on how often the program creates and destroys objects.  The "
"detection of cycles can be disabled when Python is compiled, if you can't "
"afford even a tiny speed penalty or suspect that the cycle collection is "
"buggy, by specifying the :option:`!--without-cycle-gc` switch when running "
"the :program:`configure` script."
msgstr ""
"運行循環檢測演算法需要一些時間，因此會導致一些額外的開銷。希望在我們使用 2.0 "
"獲得循環收集的經驗之後，Python 2.1 將能夠通過仔細調整將開銷降至最低。目前尚不"
"清楚損失了多少性能，因為對此進行基準測試很棘手，並且關鍵取決於程式建立和銷毀"
"物件的頻率。編譯 Python 時可以禁用循環檢測，如果你不能承受哪怕是微小的速度損"
"失或懷疑循環收集有問題，通過在以下情況下指定 :option:`!--without-cycle-gc` "
"開關運行 :program:`configure` 腳本。"

#: ../../whatsnew/2.0.rst:482
#, fuzzy
msgid ""
"Several people tackled this problem and contributed to a solution.  An early "
"implementation of the cycle detection approach was written by Toby Kelsey.  "
"The current algorithm was suggested by Eric Tiedemann during a visit to "
"CNRI, and Guido van Rossum and Neil Schemenauer wrote two different "
"implementations, which were later integrated by Neil.  Lots of other people "
"offered suggestions along the way; the March 2000 archives of the python-dev "
"mailing list contain most of the relevant discussion, especially in the "
"threads titled \"Reference cycle collection for Python\" and \"Finalization "
"again\"."
msgstr ""
"幾個人解決了這個問題並為解決方案做出了貢獻。 Toby Kelsey "
"編寫了循環檢測方法的早期實作。目前的演算法是由 Eric Tiedemann 在訪問 CNRI "
"時提出的，Guido van Rossum 和 Neil Schenmauer 編寫了兩種不同的實作，後來由 "
"Neil 進行了整合。在此過程中，許多其他人提出了建議； python-dev 郵件列表的 "
"2000 年 3 月存檔包含大部分相關討論，尤其是標題為“Python "
"的參考週期集合”和“再次完成”的主題。"

#: ../../whatsnew/2.0.rst:495
#, fuzzy
msgid "Other Core Changes"
msgstr "其他核心變化"

#: ../../whatsnew/2.0.rst:497
#, fuzzy
msgid ""
"Various minor changes have been made to Python's syntax and built-in "
"functions. None of the changes are very far-reaching, but they're handy "
"conveniences."
msgstr "對 Python 的語法和內建函式進行了各種細微的更改。這些變化都不是影響深遠的，但"
"它們很方便。"

#: ../../whatsnew/2.0.rst:502
#, fuzzy
msgid "Minor Language Changes"
msgstr "小的語言變化"

#: ../../whatsnew/2.0.rst:504
#, fuzzy
msgid ""
"A new syntax makes it more convenient to call a given function with a tuple "
"of arguments and/or a dictionary of keyword arguments. In Python 1.5 and "
"earlier, you'd use the :func:`apply` built-in function: ``apply(f, args, "
"kw)`` calls the function :func:`f` with the argument tuple *args* and the "
"keyword arguments in the dictionary *kw*.  :func:`apply`  is the same in "
"2.0, but thanks to a patch from Greg Ewing, ``f(*args, **kw)`` is a shorter "
"and clearer way to achieve the same effect.  This syntax is symmetrical with "
"the syntax for defining functions::"
msgstr ""
"新的語法使得使用參數元組和/或關鍵字參數字典呼叫給定函式變得更加方便。在 "
"Python 1.5 及更早版本中，您將使用 :func:`apply` 內建函式：``apply(f, args, "
"kw)`` 使用參數元組 *args* 呼叫函式 :func:`f`和字典 *kw* 中的關鍵字參數。 "
":func:`apply` 在 2.0 中是相同的，但多虧了 Greg Ewing 的補丁，``f(*args, "
"**kw)`` 是實作相同效果的更短更清晰的方法。此語法與定義函式的語法對稱："

#: ../../whatsnew/2.0.rst:518
#, fuzzy
msgid ""
"The ``print`` statement can now have its output directed to a file-like "
"object by following the ``print`` with  ``>> file``, similar to the "
"redirection operator in Unix shells. Previously you'd either have to use "
"the :meth:`write` method of the file-like object, which lacks the "
"convenience and simplicity of ``print``, or you could assign a new value to "
"``sys.stdout`` and then restore the old value.  For sending output to "
"standard error, it's much easier to write this::"
msgstr ""
"``print`` 語句現在可以通過在 ``print`` 後加上 ``>> file`` "
"將其輸出定向到類似文件的物件，類似於 Unix shell 中的重定向運算符。"
"以前你要么必須使用類文件物件的 write 方法，它缺乏 ``print`` 的方便和簡單，"
"要么你可以為 ``sys.stdout` 分配一個新值` "
"然後恢復舊值。要將輸出發送到標準錯誤，寫這個要容易得多::"

#: ../../whatsnew/2.0.rst:528
#, fuzzy
msgid ""
"Modules can now be renamed on importing them, using the syntax ``import "
"module as name`` or ``from module import name as othername``.  The patch was "
"submitted by Thomas Wouters."
msgstr ""
"模組現在可以在導入時重命名，使用語法“import module as name”或“from module "
"import name as othername”。該補丁由 Thomas Wouters 提交。"

#: ../../whatsnew/2.0.rst:532
#, fuzzy
msgid ""
"A new format style is available when using the ``%`` operator; '%r' will "
"insert the :func:`repr` of its argument.  This was also added from symmetry "
"considerations, this time for symmetry with the existing '%s' format style, "
"which inserts the :func:`str` of its argument.  For example, ``'%r %s' % "
"('abc', 'abc')`` returns a string containing ``'abc' abc``."
msgstr ""
"使用 ``%`` 運算符時可以使用新的格式樣式； '%r' 將插入其參數的 "
":func:`repr`。這也是出於對稱考慮而新增的，這次是為了與現有的 '%s' "
"格式樣式對稱，它插入了其參數的 :func:`str`。例如，``'%r %s' % ('abc', "
"'abc')`` 回傳包含 ``'abc' abc`` 的字串。"

#: ../../whatsnew/2.0.rst:538
#, fuzzy
msgid ""
"Previously there was no way to implement a class that overrode Python's "
"built-in :keyword:`in` operator and implemented a custom version.  ``obj in "
"seq`` returns true if *obj* is present in the sequence *seq*; Python "
"computes this by simply trying every index of the sequence until either "
"*obj* is found or an :exc:`IndexError` is encountered.  Moshe Zadka "
"contributed a patch which adds a :meth:`__contains__` magic method for "
"providing a custom implementation for :keyword:`!in`. Additionally, new "
"built-in objects written in C can define what :keyword:`!in` means for them "
"via a new slot in the sequence protocol."
msgstr ""
"以前沒有辦法實作一個類來覆蓋 Python 的內建 :keyword:`in` "
"運算符並實作自定義版本。如果 *obj* 存在於序列 *seq* 中，``obj in seq`` 回傳 "
"true； Python 通過簡單地嘗試序列的每個索引直到找到 *obj* 或遇到 IndexError "
"來計算它。 Moshe Zadka 貢獻了一個補丁，其中新增了一個 :meth:`__contains__` "
"魔術方法，用於為 :keyword:`!in` 提供自定義實作。此外，用 C "
"語言編寫的新內建物件可以通過序列協定中的新插槽定義 :keyword:`!in` "
"對它們意味著什麼。"

#: ../../whatsnew/2.0.rst:547
#, fuzzy
msgid ""
"Earlier versions of Python used a recursive algorithm for deleting objects. "
"Deeply nested data structures could cause the interpreter to fill up the C "
"stack and crash; Christian Tismer rewrote the deletion logic to fix this "
"problem.  On a related note, comparing recursive objects recursed infinitely "
"and crashed; Jeremy Hylton rewrote the code to no longer crash, producing a "
"useful result instead.  For example, after this code::"
msgstr ""
"早期版本的 Python 使用遞迴演算法來刪除物件。"
"深度嵌套的資料結構可能導致直譯器填滿 C 堆疊並崩潰； Christian Tismer "
"重寫了刪除邏輯來解決這個問題。在相關說明中，比較遞迴物件無限遞迴併崩潰； "
"Jeremy Hylton "
"重寫了程式碼以不再崩潰，而是產生了一個有用的結果。例如，在這段程式碼之後："

#: ../../whatsnew/2.0.rst:559
#, fuzzy
msgid ""
"The comparison ``a==b`` returns true, because the two recursive data "
"structures are isomorphic. See the thread \"trashcan and PR#7\" in the April "
"2000 archives of the python-dev mailing list for the discussion leading up "
"to this implementation, and some useful relevant links.    Note that "
"comparisons can now also raise exceptions. In earlier versions of Python, a "
"comparison operation such as ``cmp(a,b)`` would always produce an answer, "
"even if a user-defined :meth:`__cmp__` method encountered an error, since "
"the resulting exception would simply be silently swallowed."
msgstr ""
"比較 ``a==b`` 回傳 true，因為這兩個遞迴資料結構是同構的。請參閱 python-dev "
"郵件列表 2000 年 4 月的存檔中的主題“trashcan and PR#7”以了解導致此實作的討論"
"以及一些有用的相關鏈接。請注意，比較現在也可以引發例外。在 Python "
"的早期版本中，諸如 cmp(a,b) 之類的比較操作總是會產生一個答案，"
"即使使用者定義的 :meth:`__cmp__` "
"方法遇到錯誤，因為由此產生的例外只會被無聲吞噬。"

#: ../../whatsnew/2.0.rst:571
#, fuzzy
msgid ""
"Work has been done on porting Python to 64-bit Windows on the Itanium "
"processor, mostly by Trent Mick of ActiveState.  (Confusingly, ``sys."
"platform`` is still ``'win32'`` on Win64 because it seems that for ease of "
"porting, MS Visual C++ treats code as 32 bit on Itanium.) PythonWin also "
"supports Windows CE; see the Python CE page at https://pythonce.sourceforge."
"net/ for more information."
msgstr ""
"已經完成了將 Python 移植到 Itanium 處理器上的 64 位 Windows 的工作，主要由 "
"ActiveState 的 Trent Mick 完成。 （令人困惑的是，“sys.platform”在 Win64 "
"上仍然是 ``'win32'``，因為似乎為了便於移植，MS Visual C++ 在 Itanium "
"上將程式碼視為 32 位。）PythonWin 還支援 Windows CE；有關詳細資訊，"
"請參閱位於 https://pythonce.sourceforge.net/ 的 Python CE 頁面。"

#: ../../whatsnew/2.0.rst:577
#, fuzzy
msgid ""
"Another new platform is Darwin/MacOS X; initial support for it is in Python "
"2.0. Dynamic loading works, if you specify \"configure --with-dyld --with-"
"suffix=.x\". Consult the README in the Python source distribution for more "
"instructions."
msgstr ""
"另一個新平台是 Darwin/MacOS X； Python 2.0 對它的最初支援。如果您指定“"
"configure --with-dyld --with-suffix=.x”，則動態加載有效。有關更多說明，"
"請參閱 Python 源程式碼分發中的自述文件。"

#: ../../whatsnew/2.0.rst:581
#, fuzzy
msgid ""
"An attempt has been made to alleviate one of Python's warts, the often-"
"confusing :exc:`NameError` exception when code refers to a local variable "
"before the variable has been assigned a value.  For example, the following "
"code raises an exception on the ``print`` statement in both 1.5.2 and 2.0; "
"in 1.5.2 a :exc:`NameError` exception is raised, while 2.0 raises a new :exc:"
"`UnboundLocalError` exception. :exc:`UnboundLocalError` is a subclass of :"
"exc:`NameError`, so any existing code that expects :exc:`NameError` to be "
"raised should still work. ::"
msgstr ""
"已經嘗試減輕 Python 的缺陷之一，"
"即當程式碼在變數被賦值之前引用局部變數時經常令人困惑的 NameError 例外。例如，"
"以下程式碼在 1.5.2 和 2.0 中都對 ``print`` 語句引發例外；在 1.5.2 "
"中引發了一個 :exc:`NameError` 例外，而 2.0 引發了一個新的 "
":exc:`UnboundLocalError` 例外。 :exc:`UnboundLocalError` 是 :exc:`NameError` "
"的子類別，因此任何期望引發 :exc:`NameError` 的現有程式碼應該仍然有效。 ::"

#: ../../whatsnew/2.0.rst:595
#, fuzzy
msgid ""
"Two new exceptions, :exc:`TabError` and :exc:`IndentationError`, have been "
"introduced.  They're both subclasses of :exc:`SyntaxError`, and are raised "
"when Python code is found to be improperly indented."
msgstr ""
"引入了兩個新例外 :exec:`TabError` 和 :exc:`IndentationError`。它們都是 "
":exc:`SyntaxError` 的子類別，並在發現 Python 程式碼縮進不正確時引發。"

#: ../../whatsnew/2.0.rst:601
msgid "Changes to Built-in Functions"
msgstr "內建函式的更改"

#: ../../whatsnew/2.0.rst:603
#, fuzzy
msgid ""
"A new built-in, ``zip(seq1, seq2, ...)``, has been added.  :func:`zip` "
"returns a list of tuples where each tuple contains the i-th element from "
"each of the argument sequences.  The difference between :func:`zip` and "
"``map(None, seq1, seq2)`` is that :func:`map` pads the sequences with "
"``None`` if the sequences aren't all of the same length, while :func:`zip` "
"truncates the returned list to the length of the shortest argument sequence."
msgstr ""
"新增了一個新的內建函式 ``zip(seq1, seq2, ...)``。 :func:`zip` 回傳元組列表，"
"其中每個元組包含來自每個參數序列的第 i 個元素。 :func:`zip` 和 ``map(None, "
"seq1, seq2)`` 之間的區別在於 :func:`map` 在序列長度不同的情況下用 ``None`` "
"填充序列, 而 :func:`zip` 將回傳的列表截斷為最短參數序列的長度。"

#: ../../whatsnew/2.0.rst:610
#, fuzzy
msgid ""
"The :func:`int` and :func:`long` functions now accept an optional \"base\" "
"parameter when the first argument is a string. ``int('123', 10)`` returns "
"123, while ``int('123', 16)`` returns 291.  ``int(123, 16)`` raises a :exc:"
"`TypeError` exception with the message \"can't convert non-string with "
"explicit base\"."
msgstr ""
"當第一個參數是字串時，:func:`int` 和 :func:`long` "
"函式現在接受一個可選的 ``base``參數。 ``int('123', 10)`` 回傳 123，而 ``int("
"'123', 16)`` 回傳 291。``int(123, 16)`` 引發 :exc:`TypeError` "
"例外消息“無法轉換具有顯式基數的非字串”。"

#: ../../whatsnew/2.0.rst:616
#, fuzzy
msgid ""
"A new variable holding more detailed version information has been added to "
"the :mod:`sys` module.  ``sys.version_info`` is a tuple ``(major, minor, "
"micro, level, serial)`` For example, in a hypothetical 2.0.1beta1, ``sys."
"version_info`` would be ``(2, 0, 1, 'beta', 1)``. *level* is a string such "
"as ``\"alpha\"``, ``\"beta\"``, or ``\"final\"`` for a final release."
msgstr ""
"一個包含更詳細版本資訊的新變數已新增到 :mod:`sys` 模組中。 ``sys."
"version_info`` 是一個元組``(major, minor, micro, level, serial)`` 例如，"
"在假設的 2.0.1beta1 中，``sys.version_info`` 將是 ``(2, 0 , 1, \\'beta\\', "
"1)``. *level* 是一個字串，例如 ``\"alpha\"``、``\"beta\"`` 或用於最終版本的 "
"``\"final\"``。"

#: ../../whatsnew/2.0.rst:622
#, fuzzy
msgid ""
"Dictionaries have an odd new method, ``setdefault(key, default)``, which "
"behaves similarly to the existing :meth:`get` method.  However, if the key "
"is missing, :meth:`setdefault` both returns the value of *default* as :meth:"
"`get` would do, and also inserts it into the dictionary as the value for "
"*key*.  Thus, the following lines of code::"
msgstr ""
"字典有一個奇怪的新方法，``setdefault(key, default)``，它的行為類似於現有的 "
":meth:`get` 方法。但是，如果缺少鍵，setdefault 會像 get 一樣回傳 *default* "
"的值，並將其作為 *key* 的值插入到字典中。因此，以下程式碼行::"

#: ../../whatsnew/2.0.rst:633
#, fuzzy
msgid ""
"can be reduced to a single ``return dict.setdefault(key, [])`` statement."
msgstr "可以簡化為單個“return dict.setdefault(key, [])”語句。"

#: ../../whatsnew/2.0.rst:635
#, fuzzy
msgid ""
"The interpreter sets a maximum recursion depth in order to catch runaway "
"recursion before filling the C stack and causing a core dump or GPF.. "
"Previously this limit was fixed when you compiled Python, but in 2.0 the "
"maximum recursion depth can be read and modified using :func:`sys."
"getrecursionlimit` and :func:`sys.setrecursionlimit`. The default value is "
"1000, and a rough maximum value for a given platform can be found by running "
"a new script, :file:`Misc/find_recursionlimit.py`."
msgstr ""
"直譯器設定最大遞迴深度，以便在填充 C 堆疊並導致核心轉儲或 GPF "
"之前捕獲失控的遞迴。以前此限制在編譯 Python 時已修復，但在 2.0 "
"中可以讀取和修改最大遞迴深度使用 :func:`sys.getrecursionlimit` 和 :func:`sys."
"setrecursionlimit`。預設值為 1000，給定平台的粗略最大值可以通過運行新腳本 "
":file:`Misc/find_recursionlimit.py` 找到。"

#: ../../whatsnew/2.0.rst:647
msgid "Porting to 2.0"
msgstr "移植到 2.0"

#: ../../whatsnew/2.0.rst:649
#, fuzzy
msgid ""
"New Python releases try hard to be compatible with previous releases, and "
"the record has been pretty good.  However, some changes are considered "
"useful enough, usually because they fix initial design decisions that turned "
"out to be actively mistaken, that breaking backward compatibility can't "
"always be avoided. This section lists the changes in Python 2.0 that may "
"cause old Python code to break."
msgstr ""
"新的 Python 版本努力與以前的版本相容，並且記錄一直很好。然而，一些更改被認為"
"足夠有用，通常是因為它們修復了最初被證明是錯誤的設計決策，無法總是避免破壞向"
"後相容性。本節列出了 Python 2.0 中可能導致舊 Python 程式碼中斷的更改。"

#: ../../whatsnew/2.0.rst:656
#, fuzzy
msgid ""
"The change which will probably break the most code is tightening up the "
"arguments accepted by some methods.  Some methods would take multiple "
"arguments and treat them as a tuple, particularly various list methods such "
"as :meth:`append` and :meth:`insert`. In earlier versions of Python, if "
"``L`` is a list, ``L.append( 1,2 )`` appends the tuple ``(1,2)`` to the "
"list.  In Python 2.0 this causes a :exc:`TypeError` exception to be raised, "
"with the message: 'append requires exactly 1 argument; 2 given'.  The fix is "
"to simply add an extra set of parentheses to pass both values as a tuple:  "
"``L.append( (1,2) )``."
msgstr ""
"可能會破壞最多程式碼的更改是收緊某些方法接受的參數。有些方法會採用多個參數並"
"將它們視為一個元組，尤其是各種列表方法，例如 :meth:`append` 和 "
":meth:`insert`。在早期版本的 Python 中，如果 ``L``是一個列表，“L."
"append(1,2)”會將元組“(1,2)”附加到列表中。在 Python 2.0 中，這會引發 "
":exc:`TypeError` 例外，並顯示消息：'append requires exactly 1 argument; "
"2給'。解決方法是簡單地新增一組額外的括號以將兩個值作為元組傳遞：``L.append( "
"(1,2) )``。"

#: ../../whatsnew/2.0.rst:665
#, fuzzy
msgid ""
"The earlier versions of these methods were more forgiving because they used "
"an old function in Python's C interface to parse their arguments; 2.0 "
"modernizes them to use :func:`PyArg_ParseTuple`, the current argument "
"parsing function, which provides more helpful error messages and treats "
"multi-argument calls as errors.  If you absolutely must use 2.0 but can't "
"fix your code, you can edit :file:`Objects/listobject.c` and define the "
"preprocessor symbol ``NO_STRICT_LIST_APPEND`` to preserve the old behaviour; "
"this isn't recommended."
msgstr ""
"這些方法的早期版本更加寬容，因為它們使用 Python C "
"介面中的舊函式來解析它們的參數； 2.0 使它們現代化以使用當前參數解析函式 "
"PyArg_ParseTuple，它提供更有用的錯誤消息並將多參數呼叫視為錯誤。"
"如果您絕對必須使用 2.0 但無法修復您的程式碼，則可以編輯 :file:`Objects/"
"listobject.c` 並定義預處理器符號 ``NO_STRICT_LIST_APPEND`` "
"以保留舊行為；不推薦這樣做。"

#: ../../whatsnew/2.0.rst:673
#, fuzzy
msgid ""
"Some of the functions in the :mod:`socket` module are still forgiving in "
"this way.  For example, :func:`socket.connect( ('hostname', 25) )` is the "
"correct form, passing a tuple representing an IP address, but :func:`socket."
"connect( 'hostname', 25 )` also works. :func:`socket.connect_ex` and :func:"
"`socket.bind` are similarly easy-going.  2.0alpha1 tightened these functions "
"up, but because the documentation actually used the erroneous multiple "
"argument form, many people wrote code which would break with the stricter "
"checking.  GvR backed out the changes in the face of public reaction, so for "
"the :mod:`socket` module, the documentation was fixed and the multiple "
"argument form is simply marked as deprecated; it *will* be tightened up "
"again in a future Python version."
msgstr ""
":mod:`socket` 模組中的一些函式仍然以這種方式寬容。例如，:func:`socket."
"connect( ('hostname', 25) )` 是正確的形式，傳遞一個表示 IP 地址的元組，但是 "
":func:`socket.connect( 'hostname', 25 )` 也是作品。 :func:`socket.connect_ex`"
" 和 :func:`socket.bind` 同樣容易上手。 2.0alpha1 收緊了這些功能，但由於文檔實"
"際上使用了錯誤的多參數形式，許多人編寫的程式碼會因更嚴格的檢查而中斷。面對公"
"眾的反應，GvR 取消了更改，因此對於 :mod:`socket` "
"模組，文檔已修復，多參數形式被簡單地標記為已棄用；它*將*在未來的 Python "
"版本中再次收緊。"

#: ../../whatsnew/2.0.rst:684
#, fuzzy
msgid ""
"The ``\\x`` escape in string literals now takes exactly 2 hex digits.  "
"Previously it would consume all the hex digits following the 'x' and take "
"the lowest 8 bits of the result, so ``\\x123456`` was equivalent to ``"
"\\x56``."
msgstr ""
"字串文字中的 ``\\x`` 轉義符現在正好需要 2 個十六進位數字。"
"以前它會消耗'x'之後的所有十六進位數字並取結果的最低 8 位，因此 ``\\x123456`` "
"等同於 ``\\x56``。"

#: ../../whatsnew/2.0.rst:688
#, fuzzy
msgid ""
"The :exc:`AttributeError` and :exc:`NameError` exceptions have a more "
"friendly error message, whose text will be something like ``'Spam' instance "
"has no attribute 'eggs'`` or ``name 'eggs' is not defined``.  Previously the "
"error message was just the missing attribute name ``eggs``, and code written "
"to take advantage of this fact will break in 2.0."
msgstr ""
":exc:`AttributeError` 和 :exc:`NameError` "
"例外有一個更友好的錯誤消息，其文本類似於“'Spam' instance has no attribute "
"'eggs'”或“name 'eggs' is未定義``。以前的錯誤消息只是缺少屬性名稱 ``eggs``，"
"利用這一事實編寫的程式碼將在 2.0 中中斷。"

#: ../../whatsnew/2.0.rst:694
#, fuzzy
msgid ""
"Some work has been done to make integers and long integers a bit more "
"interchangeable.  In 1.5.2, large-file support was added for Solaris, to "
"allow reading files larger than 2 GiB; this made the :meth:`tell` method of "
"file objects return a long integer instead of a regular integer.  Some code "
"would subtract two file offsets and attempt to use the result to multiply a "
"sequence or slice a string, but this raised a :exc:`TypeError`.  In 2.0, "
"long integers can be used to multiply or slice a sequence, and it'll behave "
"as you'd intuitively expect it to; ``3L * 'abc'`` produces 'abcabcabc', and "
"``(0,1,2,3)[2L:4L]`` produces (2,3). Long integers can also be used in "
"various contexts where previously only integers were accepted, such as in "
"the :meth:`seek` method of file objects, and in the formats supported by the "
"``%`` operator (``%d``, ``%i``, ``%x``, etc.).  For example, ``\"%d\" % "
"2L**64`` will produce the string ``18446744073709551616``."
msgstr ""
"已經做了一些工作來使整數和長整數更容易互換。在 1.5.2 中，為 Solaris "
"新增了大文件支援，以允許讀取大於 2 GiB 的文件；這使得文件物件的 :meth:`tell` "
"方法回傳一個長整數而不是常規整數。一些程式碼會減去兩個文件偏移量並嘗試使用結"
"果來乘以序列或切片字串，但這會引發 :exc:`TypeError`。在 2.0 "
"中，長整數可用於對序列進行乘法或切片操作，它的行為將與您直觀預期的一樣； ``"
"3L * \\'abc\\'`` 產生 \\'abcabcabc\\'，而 ``(0,1,2,3)[2L:4L]`` 產生 "
"(2,3)。長整數也可以用於以前只接受整數的各種上下文中，例如在文件物件的 "
":meth:`seek` 方法中，以及在 ``%`` 運算符 (``%d`) "
"支援的格式中`、``%i``、``%x`` 等）。例如，``\"%d\" % 2L**64`` 將生成字串 "
"``18446744073709551616``。"

#: ../../whatsnew/2.0.rst:708
#, fuzzy
msgid ""
"The subtlest long integer change of all is that the :func:`str` of a long "
"integer no longer has a trailing 'L' character, though :func:`repr` still "
"includes it.  The 'L' annoyed many people who wanted to print long integers "
"that looked just like regular integers, since they had to go out of their "
"way to chop off the character.  This is no longer a problem in 2.0, but code "
"which does ``str(longval)[:-1]`` and assumes the 'L' is there, will now lose "
"the final digit."
msgstr ""
"最微妙的長整數變化是長整數的 :func:`str` 不再有尾隨 'L' 字元，儘管 "
":func:`repr` 仍然包含它。 'L' 惹惱了許多想要印出看起來就像普通整數的長整數的"
"人，因為他們不得不特意把這個字元砍掉。這在 2.0 中不再是問題，但是執行“str(lon"
"gval)[:-1]”並假設 ``L``在那裡的程式碼現在將丟失最後一位數字。"

#: ../../whatsnew/2.0.rst:716
#, fuzzy
msgid ""
"Taking the :func:`repr` of a float now uses a different formatting precision "
"than :func:`str`.  :func:`repr` uses ``%.17g`` format string for C's :func:"
"`sprintf`, while :func:`str` uses ``%.12g`` as before.  The effect is that :"
"func:`repr` may occasionally show more decimal places than  :func:`str`, for "
"certain numbers.  For example, the number 8.1 can't be represented exactly "
"in binary, so ``repr(8.1)`` is ``'8.0999999999999996'``, while str(8.1) is "
"``'8.1'``."
msgstr ""
"採用浮點數的 :func:`repr` 現在使用與 :func:`str` 不同的格式化精度。 "
":func:`repr` 使用 C 的 :func:`sprintf` 的 ``%.17g`` 格式字串，而 :func:`str` "
"和以前一樣使用 ``%.12g``。結果是，對於某些數字，:func:`repr` "
"有時可能會顯示比 :func:`str` 更多的小數位。例如，數字 8.1 不能用二進位表示，"
"所以 ``repr(8.1)`` 是 ``'8.0999999999999996'``，而 str(8.1) 是 ``'8.1'``。"

#: ../../whatsnew/2.0.rst:724
#, fuzzy
msgid ""
"The ``-X`` command-line option, which turned all standard exceptions into "
"strings instead of classes, has been removed; the standard exceptions will "
"now always be classes.  The :mod:`exceptions` module containing the standard "
"exceptions was translated from Python to a built-in C module, written by "
"Barry Warsaw and Fredrik Lundh."
msgstr ""
"將所有標準例外轉換為字串而不是類的 ``-X``命令列選項已被刪除"
"；標準例外現在將始終是類。包含標準例外的 :mod:`exceptions` 模組已從 Python "
"翻譯成內建 C 模組，由 Barry Warsaw 和 Fredrik Lundh 編寫。"

#: ../../whatsnew/2.0.rst:740
#, fuzzy
msgid "Extending/Embedding Changes"
msgstr "擴充/嵌入更改"

#: ../../whatsnew/2.0.rst:742
#, fuzzy
msgid ""
"Some of the changes are under the covers, and will only be apparent to "
"people writing C extension modules or embedding a Python interpreter in a "
"larger application.  If you aren't dealing with Python's C API, you can "
"safely skip this section."
msgstr ""
"一些變化是隱藏的，只有編寫 C 擴充模組或在更大的應用程式中嵌入 Python "
"直譯器的人才能看到。如果您不處理 Python 的 C API，則可以安全地跳過本節。"

#: ../../whatsnew/2.0.rst:747
#, fuzzy
msgid ""
"The version number of the Python C API was incremented, so C extensions "
"compiled for 1.5.2 must be recompiled in order to work with 2.0.  On "
"Windows, it's not possible for Python 2.0 to import a third party extension "
"built for Python 1.5.x due to how Windows DLLs work, so Python will raise an "
"exception and the import will fail."
msgstr ""
"Python C API 的版本號增加了，因此為 1.5.2 編譯的 C 擴充必須重新編譯才能與 "
"2.0 一起使用。在 Windows 上，由於 Windows DLL 的工作方式，Python 2.0 "
"無法導入為 Python 1.5.x 構建的第三方擴充，因此 Python "
"將引發例外並且導入將失敗。"

#: ../../whatsnew/2.0.rst:753
#, fuzzy
msgid ""
"Users of Jim Fulton's ExtensionClass module will be pleased to find out that "
"hooks have been added so that ExtensionClasses are now supported by :func:"
"`isinstance` and :func:`issubclass`. This means you no longer have to "
"remember to write code such as ``if type(obj) == myExtensionClass``, but can "
"use the more natural ``if isinstance(obj, myExtensionClass)``."
msgstr ""
"Jim Fulton 的 ExtensionClass 模組的使用者會很高興地發現已新增掛鉤，因此 "
"ExtensionClasses 現在由 :func:`isinstance` 和 :func:`issubclass` 支援。"
"這意味著您不再需要記住編寫諸如 ``if type(obj) == myExtensionClass`` "
"之類的程式碼，而是可以使用更自然的 ``if isinstance(obj, myExtensionClass)``。"

#: ../../whatsnew/2.0.rst:759
#, fuzzy
msgid ""
"The :file:`Python/importdl.c` file, which was a mass of #ifdefs to support "
"dynamic loading on many different platforms, was cleaned up and reorganised "
"by Greg Stein.  :file:`importdl.c` is now quite small, and platform-specific "
"code has been moved into a bunch of :file:`Python/dynload_\\*.c` files.  "
"Another cleanup: there were also a number of :file:`my\\*.h` files in the "
"Include/ directory that held various portability hacks; they've been merged "
"into a single file, :file:`Include/pyport.h`."
msgstr ""
":file:`Python/importdl.c` 文件是一大堆 "
"#ifdef，用於支援在許多不同平台上進行動態加載，Greg Stein "
"對其進行了清理和重組。 :file:`importdl.c` 現在非常小，"
"特定於平台的程式碼已移入一堆 :file:`Python/dynload_\\*.c` "
"文件中。另一個清理：Include/ 目錄中還有許多 :file:`my\\*.h` "
"文件，其中包含各種可移植性黑客攻擊；它們已被合併到一個文件中，:file:`Include/"
"pyport.h`。"

#: ../../whatsnew/2.0.rst:767
#, fuzzy
msgid ""
"Vladimir Marangozov's long-awaited malloc restructuring was completed, to "
"make it easy to have the Python interpreter use a custom allocator instead "
"of C's standard :func:`malloc`.  For documentation, read the comments in :"
"file:`Include/pymem.h` and :file:`Include/objimpl.h`.  For the lengthy "
"discussions during which the interface was hammered out, see the web "
"archives of the 'patches' and 'python-dev' lists at python.org."
msgstr ""
"Vladimir Marangozov 期待已久的 malloc 重組已經完成，讓 Python "
"直譯器更容易使用自定義分配器而不是 C 的標準 :func:`malloc`。有關文檔，請閱讀 "
":file:`Include/pymem.h` 和 :file:`Include/objimpl.h` "
"中的註釋。對於敲定界面的冗長討論，請參閱 python.org 上的“補丁”和“python-"
"dev”列表的網絡檔案。"

#: ../../whatsnew/2.0.rst:774
#, fuzzy
msgid ""
"Recent versions of the GUSI development environment for MacOS support POSIX "
"threads.  Therefore, Python's POSIX threading support now works on the "
"Macintosh.  Threading support using the user-space GNU ``pth`` library was "
"also contributed."
msgstr ""
"用於 MacOS 的 GUSI 開發環境的最新版本支援 POSIX 執行緒。因此，Python 的 "
"POSIX 執行緒支援現在可以在 Macintosh 上運行。還貢獻了使用使用者空間 GNU "
"``pth`` 庫的執行緒支援。"

#: ../../whatsnew/2.0.rst:779
#, fuzzy
msgid ""
"Threading support on Windows was enhanced, too.  Windows supports thread "
"locks that use kernel objects only in case of contention; in the common case "
"when there's no contention, they use simpler functions which are an order of "
"magnitude faster.  A threaded version of Python 1.5.2 on NT is twice as slow "
"as an unthreaded version; with the 2.0 changes, the difference is only 10%.  "
"These improvements were contributed by Yakov Markovitch."
msgstr ""
"Windows 上的執行緒支援也得到了增強。 Windows 支援僅在爭用情況下使用內核物件的"
"執行緒鎖；在沒有爭用的常見情況下，他們使用更簡單的函式，這些函式的速度要快一"
"個數量級。 NT 上的執行緒版本 Python 1.5.2 比非執行緒版本慢兩倍；隨著2."
"0的變化，差異只有10%。這些改進是由 Yakov Markovitch 貢獻的。"

#: ../../whatsnew/2.0.rst:786
#, fuzzy
msgid ""
"Python 2.0's source now uses only ANSI C prototypes, so compiling Python now "
"requires an ANSI C compiler, and can no longer be done using a compiler that "
"only supports K&R C."
msgstr ""
"Python 2.0 的源程式碼現在只使用 ANSI C 原型，所以編譯 Python 現在需要一個 "
"ANSI C 編譯器，而不能再使用只支援 K&R C 的編譯器來完成。"

#: ../../whatsnew/2.0.rst:790
#, fuzzy
msgid ""
"Previously the Python virtual machine used 16-bit numbers in its bytecode, "
"limiting the size of source files.  In particular, this affected the maximum "
"size of literal lists and dictionaries in Python source; occasionally people "
"who are generating Python code would run into this limit.  A patch by "
"Charles G. Waldman raises the limit from ``2**16`` to ``2**32``."
msgstr ""
"以前 Python 虛擬機在其位元組碼中使用 16 位數字，限制源文件的大小。特別是，"
"這影響了 Python 源程式碼中文字列表和字典的最大大小；生成 Python "
"程式碼的人偶爾會遇到這個限制。 Charles G. Waldman "
"的補丁將限制從“2**16”提高到“2**32”。"

#: ../../whatsnew/2.0.rst:796
#, fuzzy
msgid ""
"Three new convenience functions intended for adding constants to a module's "
"dictionary at module initialization time were added: :func:"
"`PyModule_AddObject`, :func:`PyModule_AddIntConstant`, and :func:"
"`PyModule_AddStringConstant`.  Each of these functions takes a module "
"object, a null-terminated C string containing the name to be added, and a "
"third argument for the value to be assigned to the name.  This third "
"argument is, respectively, a Python object, a C long, or a C string."
msgstr ""
"新增了三個用於在模組初始化時將常數新增到模組字典的新便利函式：:func:`PyModule"
"_AddObject`、:func:`PyModule_AddIntConstant` "
"和 :func:`PyModule_AddStringConstant`。這些函式中的每一個都接受一個模組物件，"
"一個包含要新增的名稱的以 null 結尾的 C "
"字串，以及要分配給該名稱的值的第三個參數。第三個參數分別是 Python 物件、C "
"long 或 C 字串。"

#: ../../whatsnew/2.0.rst:804
#, fuzzy
msgid ""
"A wrapper API was added for Unix-style signal handlers. :func:`PyOS_getsig` "
"gets a signal handler and :func:`PyOS_setsig` will set a new handler."
msgstr ""
"為 Unix 風格的信號處理程式新增了包裝器 API。 :func:`PyOS_getsig` "
"獲取一個信號處理程式，而 :func:`PyOS_setsig` 將設定一個新的處理程式。"

#: ../../whatsnew/2.0.rst:811
#, fuzzy
msgid "Distutils: Making Modules Easy to Install"
msgstr "Distutils：使模組易於安裝"

#: ../../whatsnew/2.0.rst:813
#, fuzzy
msgid ""
"Before Python 2.0, installing modules was a tedious affair -- there was no "
"way to figure out automatically where Python is installed, or what compiler "
"options to use for extension modules.  Software authors had to go through an "
"arduous ritual of editing Makefiles and configuration files, which only "
"really work on Unix and leave Windows and MacOS unsupported.  Python users "
"faced wildly differing installation instructions which varied between "
"different extension packages, which made administering a Python installation "
"something of  a chore."
msgstr ""
"在 Python 2.0 之前，安裝模組是一件乏味的事情——沒有辦法自動找出 Python "
"的安裝位置，或者用於擴充模組的編譯器選項。軟件作者必須經歷編輯 Makefile "
"和配置文件的艱鉅儀式，這些文件只能真正在 Unix 上運行，而 Windows 和 MacOS "
"不受支援。 Python "
"使用者面臨著截然不同的安裝說明，這些安裝說明因不同的擴充包而異，這使得管理 "
"Python 安裝成為一件苦差事。"

#: ../../whatsnew/2.0.rst:821
#, fuzzy
msgid ""
"The SIG for distribution utilities, shepherded by Greg Ward, has created the "
"Distutils, a system to make package installation much easier.  They form "
"the :mod:`distutils` package, a new part of Python's standard library. In "
"the best case, installing a Python module from source will require the same "
"steps: first you simply mean unpack the tarball or zip archive, and the run "
"\"``python setup.py install``\".  The platform will be automatically "
"detected, the compiler will be recognized, C extension modules will be "
"compiled, and the distribution installed into the proper directory.  "
"Optional command-line arguments provide more control over the installation "
"process, the distutils package offers many places to override defaults -- "
"separating the build from the install, building or installing in non-default "
"directories, and more."
msgstr ""
"由 Greg Ward 領導的分發實用程式 SIG 建立了 "
"Distutils，這是一個使包安裝更容易的系統。它們構成了 :mod:`distutils` 包，"
"這是 Python 標準庫的一個新部分。在最好的情況下，從源程式碼安裝 Python "
"模組將需要相同的步驟：首先，您只需解壓縮 tarball 或 zip 存檔，然後運行“``"
"python setup.py install``”。平台會被自動檢測，編譯器會被識別，C 擴充模組會被"
"編譯，並且分發安裝到適當的目錄中。可選的命令列參數提供了對安裝過程的更多控制"
"，distutils 包提供了許多地方來覆蓋預設設定——將構建與安裝分開，在非預設目錄中"
"構建或安裝等等。"

#: ../../whatsnew/2.0.rst:833
#, fuzzy
msgid ""
"In order to use the Distutils, you need to write a :file:`setup.py` script.  "
"For the simple case, when the software contains only .py files, a minimal :"
"file:`setup.py` can be just a few lines long::"
msgstr ""
"為了使用 Distutils，您需要編寫一個 :file:`setup.py` 腳本。對於簡單的情況，"
"當軟件僅包含 .py 文件時，最小的 :file:`setup.py` 可以只有幾行長::"

#: ../../whatsnew/2.0.rst:841
#, fuzzy
msgid ""
"The :file:`setup.py` file isn't much more complicated if the software "
"consists of a few packages::"
msgstr "如果軟件由幾個包組成，則 :file:`setup.py` 文件不會復雜太多::"

#: ../../whatsnew/2.0.rst:848
#, fuzzy
msgid ""
"A C extension can be the most complicated case; here's an example taken from "
"the PyXML package::"
msgstr "C擴充可能是最複雜的情況；這是從 PyXML 包中獲取的示例："

#: ../../whatsnew/2.0.rst:864
#, fuzzy
msgid ""
"The Distutils can also take care of creating source and binary "
"distributions. The \"sdist\" command, run by \"``python setup.py sdist``', "
"builds a source distribution such as :file:`foo-1.0.tar.gz`. Adding new "
"commands isn't difficult, \"bdist_rpm\" and \"bdist_wininst\" commands have "
"already been contributed to create an RPM distribution and a Windows "
"installer for the software, respectively.  Commands to create other "
"distribution formats such as Debian packages and Solaris :file:`.pkg` files "
"are in various stages of development."
msgstr ""
"Distutils 還可以負責建立源程式碼和二進位分發版。由“``python setup.py sdist``"
"' 運行的 ``sdist``命令構建了一個源程式碼分發，例如 :file:`foo-1.0.tar."
"gz`。新增新命令並不困難，“bdist_rpm”和“bdist_wininst”"
"命令已經分別用於建立軟件的 RPM 分發和 Windows 安裝程式。建立其他分發格式（如 "
"Debian 軟件包和 Solaris :file:`.pkg` 文件的命令處於不同的開發階段."

#: ../../whatsnew/2.0.rst:873
#, fuzzy
msgid ""
"All this is documented in a new manual, *Distributing Python Modules*, that "
"joins the basic set of Python documentation."
msgstr "所有這些都記錄在一本新手冊 *Distributing Python Modules* 中，"
"該手冊加入了基本的 Python 文檔集。"

#: ../../whatsnew/2.0.rst:880
#, fuzzy
msgid "XML Modules"
msgstr "XML 模組"

#: ../../whatsnew/2.0.rst:882
#, fuzzy
msgid ""
"Python 1.5.2 included a simple XML parser in the form of the :mod:`xmllib` "
"module, contributed by Sjoerd Mullender.  Since 1.5.2's release, two "
"different interfaces for processing XML have become common: SAX2 (version 2 "
"of the Simple API for XML) provides an event-driven interface with some "
"similarities to :mod:`xmllib`, and the DOM (Document Object Model) provides "
"a tree-based interface, transforming an XML document into a tree of nodes "
"that can be traversed and modified.  Python 2.0 includes a SAX2 interface "
"and a stripped-down DOM interface as part of the :mod:`xml` package. Here we "
"will give a brief overview of these new interfaces; consult the Python "
"documentation or the source code for complete details. The Python XML SIG is "
"also working on improved documentation."
msgstr ""
"Python 1.5.2 包含一個簡單的 XML 解析器，其形式為 :mod:`xmllib` 模組，由 "
"Sjoerd Mullender 貢獻。自 1.5.2 發布以來，兩種不同的 XML "
"處理介面變得很常見：SAX2（XML 簡單 API 的第 2 版）提供了一個事件驅動的介面，"
"與 :mod:`xmllib` 和 DOM（文檔物件）有一些相似之處Model) "
"提供了一個基於樹的介面，將 XML 文檔轉換為可以遍歷和修改的節點樹。 Python 2.0 "
"包括一個 SAX2 介面和一個精簡的 DOM 介面，作為 :mod:`xml` "
"包的一部分。在這裡，我們將簡要概述這些新介面；有關完整的詳細資訊，請參閱 "
"Python 文檔或源程式碼。 Python XML SIG 也在致力於改進文檔。"

#: ../../whatsnew/2.0.rst:896
#, fuzzy
msgid "SAX2 Support"
msgstr "SAX2 支援"

#: ../../whatsnew/2.0.rst:898
#, fuzzy
msgid ""
"SAX defines an event-driven interface for parsing XML.  To use SAX, you must "
"write a SAX handler class.  Handler classes inherit from various classes "
"provided by SAX, and override various methods that will then be called by "
"the XML parser.  For example, the :meth:`startElement` and :meth:"
"`endElement` methods are called for every starting and end tag encountered "
"by the parser, the :meth:`characters` method is called for every chunk of "
"character data, and so forth."
msgstr ""
"SAX 定義了一個用於解析 XML 的事件驅動介面。要使用 SAX，您必須編寫一個 SAX "
"處理程式類。處理程式類繼承自 SAX 提供的各種類，並覆蓋各種隨後將由 XML "
"解析器呼叫的方法。例如，解析器遇到的每個開始和結束標記都會呼叫 "
":meth:`startElement` 和 :meth:`endElement` 方法，為每個字元資料塊呼叫 "
":meth:`characters` 方法，等等向前。"

#: ../../whatsnew/2.0.rst:906
#, fuzzy
msgid ""
"The advantage of the event-driven approach is that the whole document "
"doesn't have to be resident in memory at any one time, which matters if you "
"are processing really huge documents.  However, writing the SAX handler "
"class can get very complicated if you're trying to modify the document "
"structure in some elaborate way."
msgstr ""
"事件驅動方法的優點是整個文檔不必在任何時候都駐留在記憶體中，如果您正在處理非"
"常大的文檔，這一點很重要。但是，如果您試圖以某種複雜的方式修改文檔結構，"
"那麼編寫 SAX 處理程式類可能會變得非常複雜。"

#: ../../whatsnew/2.0.rst:912
#, fuzzy
msgid ""
"For example, this little example program defines a handler that prints a "
"message for every starting and ending tag, and then parses the file :file:"
"`hamlet.xml` using it::"
msgstr "例如，這個小示例程式定義了一個處理程式，它為每個開始和結束標記印出一條消息，"
"然後使用它解析文件 :file:`hamlet.xml`::"

#: ../../whatsnew/2.0.rst:935
#, fuzzy
msgid ""
"For more information, consult the Python documentation, or the XML HOWTO at "
"http://pyxml.sourceforge.net/topics/howto/xml-howto.html."
msgstr ""
"有關詳細資訊，請參閱 Python 文檔或位於 http://pyxml.sourceforge.net/topics/"
"howto/xml-howto.html 的 XML HOWTO。"

#: ../../whatsnew/2.0.rst:940
#, fuzzy
msgid "DOM Support"
msgstr "支援DOM"

#: ../../whatsnew/2.0.rst:942
#, fuzzy
msgid ""
"The Document Object Model is a tree-based representation for an XML "
"document.  A top-level :class:`Document` instance is the root of the tree, "
"and has a single child which is the top-level :class:`Element` instance. "
"This :class:`Element` has children nodes representing character data and any "
"sub-elements, which may have further children of their own, and so forth.  "
"Using the DOM you can traverse the resulting tree any way you like, access "
"element and attribute values, insert and delete nodes, and convert the tree "
"back into XML."
msgstr ""
"文檔物件模型是 XML 文檔的基於樹的表示。頂級 :class:`Document` 實例是樹的根，"
"並且有一個子級是頂級 :class:`Element` 實例。這個 :class:`Element` "
"有代表字元資料和任何子元素的子節點，這些子元素可能有自己的更多子元素，等等。"
"使用 "
"DOM，您可以按照自己喜歡的方式遍歷生成的樹，訪問元素和屬性值，插入和刪除節點，"
"並將樹轉換回 XML。"

#: ../../whatsnew/2.0.rst:950
#, fuzzy
msgid ""
"The DOM is useful for modifying XML documents, because you can create a DOM "
"tree, modify it by adding new nodes or rearranging subtrees, and then "
"produce a new XML document as output.  You can also construct a DOM tree "
"manually and convert it to XML, which can be a more flexible way of "
"producing XML output than simply writing ``<tag1>``...\\ ``</tag1>`` to a "
"file."
msgstr ""
"DOM 對於修改 XML 文檔很有用，因為您可以建立一個 DOM "
"樹，通過新增新節點或重新排列子樹來修改它，然後生成一個新的 XML 文檔作為輸出。"
"您還可以手動構建 DOM 樹並將其轉換為 XML，這是一種比簡單地將 ``<tag1>``...\\ "
"``</tag1>`` 寫入文件更靈活的生成 XML 輸出的方法."

#: ../../whatsnew/2.0.rst:956
#, fuzzy
msgid ""
"The DOM implementation included with Python lives in the :mod:`xml.dom."
"minidom` module.  It's a lightweight implementation of the Level 1 DOM with "
"support for XML namespaces.  The  :func:`parse` and :func:`parseString` "
"convenience functions are provided for generating a DOM tree::"
msgstr ""
"Python 中包含的 DOM 實作位於 :mod:`xml.dom.minidom` 模組中。它是支援 XML "
"命名空間的 Level 1 DOM 的輕量級實作。 :func:`parse` 和 :func:`parseString` "
"便利函式用於生成 DOM 樹::"

#: ../../whatsnew/2.0.rst:964
#, fuzzy
msgid ""
"``doc`` is a :class:`Document` instance.  :class:`Document`, like all the "
"other DOM classes such as :class:`Element` and :class:`Text`, is a subclass "
"of the :class:`Node` base class.  All the nodes in a DOM tree therefore "
"support certain common methods, such as :meth:`toxml` which returns a string "
"containing the XML representation of the node and its children.  Each class "
"also has special methods of its own; for example, :class:`Element` and :"
"class:`Document` instances have a method to find all child elements with a "
"given tag name. Continuing from the previous 2-line example::"
msgstr ""
"``doc`` 是一個 :class:`Document` 實例。 :class:`Document` 與所有其他 DOM 類（"
"如 :class:`Element` 和 :class:`Text` 一樣，是 :class:`Node` "
"基底類別的子類別。因此，DOM "
"樹中的所有節點都支援某些通用方法，例如 :meth:`toxml`，"
"它回傳一個包含節點及其子節點的 XML "
"表示的字串。每個類也有自己的特殊方法；例如，:class:`Element` 和 "
":class:`Document` 實例有一個方法來查找具有給定標籤名稱的所有子元素。"
"繼續前面的 2 行示例："

#: ../../whatsnew/2.0.rst:977
#, fuzzy
msgid "For the *Hamlet* XML file, the above few lines output::"
msgstr "對於 *Hamlet* XML 文件，以上幾行輸出："

#: ../../whatsnew/2.0.rst:982
#, fuzzy
msgid ""
"The root element of the document is available as ``doc.documentElement``, "
"and its children can be easily modified by deleting, adding, or removing "
"nodes::"
msgstr "文檔的根元素作為 doc.documentElement "
"可用，其子元素可以通過刪除、新增或刪除節點輕鬆修改："

#: ../../whatsnew/2.0.rst:997
#, fuzzy
msgid ""
"Again, I will refer you to the Python documentation for a complete listing "
"of the different :class:`Node` classes and their various methods."
msgstr "同樣，我將向您推薦 Python 文檔，以獲取不同 :class:`Node` "
"類及其各種方法的完整列表。"

#: ../../whatsnew/2.0.rst:1002
#, fuzzy
msgid "Relationship to PyXML"
msgstr "與 PyXML 的關係"

#: ../../whatsnew/2.0.rst:1004
#, fuzzy
msgid ""
"The XML Special Interest Group has been working on XML-related Python code "
"for a while.  Its code distribution, called PyXML, is available from the "
"SIG's web pages at https://www.python.org/community/sigs/current/xml-sig. "
"The PyXML distribution also used the package name ``xml``.  If you've "
"written programs that used PyXML, you're probably wondering about its "
"compatibility with the 2.0 :mod:`xml` package."
msgstr ""
"一段時間以來，XML 特別興趣小組一直在研究與 XML 相關的 Python 程式碼。"
"它的程式碼分發稱為 PyXML，可從 SIG 的網頁 https://www.python.org/community/"
"sigs/current/xml-sig 獲得。 PyXML 發行版還使用了包名 ``xml``。如果您編寫過使用 "
"PyXML 的程式，您可能想知道它與 2.0 :mod:`xml` 包的相容性。"

#: ../../whatsnew/2.0.rst:1010
#, fuzzy
msgid ""
"The answer is that Python 2.0's :mod:`xml` package isn't compatible with "
"PyXML, but can be made compatible by installing a recent version PyXML.  "
"Many applications can get by with the XML support that is included with "
"Python 2.0, but more complicated applications will require that the full "
"PyXML package will be installed.  When installed, PyXML versions 0.6.0 or "
"greater will replace the :mod:`xml` package shipped with Python, and will be "
"a strict superset of the standard package, adding a bunch of additional "
"features.  Some of the additional features in PyXML include:"
msgstr ""
"答案是 Python 2.0 的 :mod:`xml` 包與 PyXML 不相容，但可以通過安裝最新版本的 "
"PyXML 使其相容。許多應用程式可以使用 Python 2.0 中包含的 XML 支援，"
"但更複雜的應用程式將需要安裝完整的 PyXML 包。安裝後，PyXML 版本 0.6.0 "
"或更高版本將替換 Python 隨附的 :mod:`xml` "
"包，並將成為標準包的嚴格超集，新增了一系列附加功能。 PyXML "
"中的一些附加功能包括："

#: ../../whatsnew/2.0.rst:1019
#, fuzzy
msgid "4DOM, a full DOM implementation from FourThought, Inc."
msgstr "4DOM，FourThought, Inc. 的完整 DOM 實作。"

#: ../../whatsnew/2.0.rst:1021
#, fuzzy
msgid "The xmlproc validating parser, written by Lars Marius Garshol."
msgstr "xmlproc 驗證解析器，由 Lars Marius Garshol 編寫。"

#: ../../whatsnew/2.0.rst:1023
#, fuzzy
msgid "The :mod:`sgmlop` parser accelerator module, written by Fredrik Lundh."
msgstr ":mod:`sgmlop` 解析器加速器模組，由 Fredrik Lundh 編寫。"

#: ../../whatsnew/2.0.rst:1029
msgid "Module changes"
msgstr "模組變更"

#: ../../whatsnew/2.0.rst:1031
#, fuzzy
msgid ""
"Lots of improvements and bugfixes were made to Python's extensive standard "
"library; some of the affected modules include :mod:`readline`, :mod:"
"`ConfigParser`, :mod:`cgi`, :mod:`calendar`, :mod:`posix`, :mod:`readline`, :"
"mod:`xmllib`, :mod:`aifc`, :mod:`chunk, wave`, :mod:`random`, :mod:`shelve`, "
"and :mod:`nntplib`.  Consult the CVS logs for the exact patch-by-patch "
"details."
msgstr ""
"對 Python 廣泛的標準庫進行了大量改進和錯誤修復；一些受影響的模組包括 :mod:`re"
"adline`、:mod:`ConfigParser`、:mod:`cgi`、:mod:`calendar`、:mod:`posix`、:mod"
":`readline`、:mod ：`xmllib`，:mod:`aifc`，:mod:`chunk，wave`，:mod:`ra"
"ndom`，:mod:`shelve`，和 :mod:`nntplib`。請查閱 CVS "
"日誌以了解每個補丁的確切詳細資訊。"

#: ../../whatsnew/2.0.rst:1037
#, fuzzy
msgid ""
"Brian Gallew contributed OpenSSL support for the :mod:`socket` module.  "
"OpenSSL is an implementation of the Secure Socket Layer, which encrypts the "
"data being sent over a socket.  When compiling Python, you can edit :file:"
"`Modules/Setup` to include SSL support, which adds an additional function to "
"the :mod:`socket` module: ``socket.ssl(socket, keyfile, certfile)``, which "
"takes a socket object and returns an SSL socket.  The :mod:`httplib` and :"
"mod:`urllib` modules were also changed to support ``https://`` URLs, though "
"no one has implemented FTP or SMTP over SSL."
msgstr ""
"Brian Gallew 貢獻了對 :mod:`socket` 模組的 OpenSSL 支援。 OpenSSL "
"是安全 socket 層的一種實作，它對通過 socket 發送的資料進行加密。編譯 Python 時，"
"您可以編輯 Modules/Setup 以包含 SSL 支援，這會為 socket "
"模組新增一個附加功能：``socket.ssl(socket, keyfile, certfile)``，"
"它接受一個 socket 物件並回傳一個 SSL  socket 。 :mod:`httplib` 和 :mod:`urllib` "
"模組也被更改為支援 ``https://`` URL，儘管還沒有人通過 SSL 實作 FTP 或 SMTP。"

#: ../../whatsnew/2.0.rst:1046
#, fuzzy
msgid ""
"The :mod:`httplib` module has been rewritten by Greg Stein to support "
"HTTP/1.1. Backward compatibility with the 1.5 version of :mod:`httplib` is "
"provided, though using HTTP/1.1 features such as pipelining will require "
"rewriting code to use a different set of interfaces."
msgstr ""
":mod:`httplib` 模組已被 Greg Stein 重寫以支援 HTTP/1.1。提供了與 1.5 版 "
"httplib 的向後相容性，儘管使用流水線等 HTTP/1.1 "
"功能將需要重寫程式碼以使用一組不同的介面。"

#: ../../whatsnew/2.0.rst:1051
#, fuzzy
msgid ""
"The :mod:`Tkinter` module now supports Tcl/Tk version 8.1, 8.2, or 8.3, and "
"support for the older 7.x versions has been dropped.  The Tkinter module now "
"supports displaying Unicode strings in Tk widgets. Also, Fredrik Lundh "
"contributed an optimization which makes operations like ``create_line`` and "
"``create_polygon`` much faster, especially when using lots of coordinates."
msgstr ""
":mod:`Tkinter` 模組現在支援 Tcl/Tk 版本 8.1、8.2 或 8.3，並且不再支援舊的 "
"7.x 版本。 Tkinter 模組現在支援在 Tk 小部件中顯示 Unicode 字串。此外，"
"Fredrik Lundh 貢獻了一項最佳化，使像“create_line”和“create_polygon”這樣的操作"
"更快，尤其是在使用大量坐標時。"

#: ../../whatsnew/2.0.rst:1057
#, fuzzy
msgid ""
"The :mod:`curses` module has been greatly extended, starting from Oliver "
"Andrich's enhanced version, to provide many additional functions from "
"ncurses and SYSV curses, such as colour, alternative character set support, "
"pads, and mouse support.  This means the module is no longer compatible with "
"operating systems that only have BSD curses, but there don't seem to be any "
"currently maintained OSes that fall into this category."
msgstr ""
":mod:`curses` 模組得到了極大的擴充，從 Oliver Andrich 的增強版開始，提供了 "
"ncurses 和 SYSV curses "
"的許多附加功能，例如顏色、替代字元集支援、鍵盤和鼠標支援。"
"這意味著該模組不再與僅具有 BSD curses "
"的操作系統相容，但似乎沒有任何當前維護的操作系統屬於此類。"

#: ../../whatsnew/2.0.rst:1064
#, fuzzy
msgid ""
"As mentioned in the earlier discussion of 2.0's Unicode support, the "
"underlying implementation of the regular expressions provided by the :mod:"
"`re` module has been changed.  SRE, a new regular expression engine written "
"by Fredrik Lundh and partially funded by Hewlett Packard, supports matching "
"against both 8-bit strings and Unicode strings."
msgstr ""
"正如前面討論 2.0 的 Unicode 支援時提到的，由 :mod:`re` "
"模組提供的正則表達式的底層實作已經改變。 SRE 是一種新的正則表達式引擎，由 "
"Fredrik Lundh 編寫，部分由惠普資助，支援匹配 8 位字串和 Unicode 字串。"

#: ../../whatsnew/2.0.rst:1074
#, fuzzy
msgid "New modules"
msgstr "新模組"

#: ../../whatsnew/2.0.rst:1076
#, fuzzy
msgid ""
"A number of new modules were added.  We'll simply list them with brief "
"descriptions; consult the 2.0 documentation for the details of a particular "
"module."
msgstr "新增了許多新模組。我們將簡單地列出它們並進行簡要說明；有關特定模組的詳細資訊"
"，請參閱 2.0 文檔。"

#: ../../whatsnew/2.0.rst:1080
#, fuzzy
msgid ""
":mod:`atexit`:  For registering functions to be called before the Python "
"interpreter exits. Code that currently sets ``sys.exitfunc`` directly should "
"be changed to  use the :mod:`atexit` module instead, importing :mod:`atexit` "
"and calling :func:`atexit.register` with  the function to be called on exit. "
"(Contributed by Skip Montanaro.)"
msgstr ""
":mod:`atexit`: 用於註冊在 Python 直譯器退出之前呼叫的函式。當前直接設定 "
"sys.exitfunc 的程式碼應該改為使用 atexit 模組，導入 atexit "
"並使用要呼叫的函式呼叫 atexit.register在退出。 （由 Skip Montanaro 提供。）"

#: ../../whatsnew/2.0.rst:1086
#, fuzzy
msgid ""
":mod:`codecs`, :mod:`encodings`, :mod:`unicodedata`:  Added as part of the "
"new Unicode support."
msgstr ""
":mod:`codecs`, :mod:`encodings`, :mod:`unicodedata`：作為新 Unicode "
"支援的一部分新增。"

#: ../../whatsnew/2.0.rst:1089
#, fuzzy
msgid ""
":mod:`filecmp`: Supersedes the old :mod:`cmp`, :mod:`cmpcache` and :mod:"
"`dircmp` modules, which have now become deprecated. (Contributed by Gordon "
"MacMillan and Moshe Zadka.)"
msgstr ""
":mod:`filecmp`：取代舊的 :mod:`cmp`、:mod:`cmpcache` 和 :mod:`dircmp` "
"模組，這些模組現已棄用。 （由 Gordon MacMillan 和 Moshe Zadka 提供。）"

#: ../../whatsnew/2.0.rst:1093
#, fuzzy
msgid ""
":mod:`gettext`: This module provides internationalization (I18N) and "
"localization (L10N) support for Python programs by providing an interface to "
"the GNU gettext message catalog library. (Integrated by Barry Warsaw, from "
"separate contributions by Martin  von Löwis, Peter Funk, and James "
"Henstridge.)"
msgstr ""
":mod:`gettext`：該模組通過提供 GNU gettext 消息目錄庫的介面為 Python "
"程式提供國際化 (I18N) 和本地化 (L10N) 支援。 （由 Barry Warsaw 整合，來自 "
"Martin von Löwis、Peter Funk 和 James Henstridge 的獨立貢獻。）"

#: ../../whatsnew/2.0.rst:1098
#, fuzzy
msgid ""
":mod:`linuxaudiodev`: Support for the :file:`/dev/audio` device on Linux, a "
"twin to the existing :mod:`sunaudiodev` module. (Contributed by Peter Bosch, "
"with fixes by Jeremy Hylton.)"
msgstr ""
":mod:`linuxaudiodev`：支援 Linux 上的 :file:`/dev/audio` 設備，是現有 "
":mod:`sunaudiodev` 模組的雙胞胎。 （由 Peter Bosch 提供，由 Jeremy Hylton "
"修復。）"

#: ../../whatsnew/2.0.rst:1102
#, fuzzy
msgid ""
":mod:`mmap`: An interface to memory-mapped files on both Windows and Unix.  "
"A file's contents can be mapped directly into memory, at which point it "
"behaves like a mutable string, so its contents can be read and modified.  "
"They can even be passed to functions that expect ordinary strings, such as "
"the :mod:`re` module. (Contributed by Sam Rushing, with some extensions by A."
"M. Kuchling.)"
msgstr ""
":mod:`mmap`：Windows 和 Unix 上記憶體映射文件的介面。文件的內容可以直接映射到"
"記憶體中，此時它的行為就像一個可變字串，因此可以讀取和修改其內容。它們甚至可"
"以傳遞給需要普通字串的函式，例如 :mod:`re` 模組。 （由 Sam Rushing 提供，"
"部分擴充由 A.M. Kuchling 提供。）"

#: ../../whatsnew/2.0.rst:1108
#, fuzzy
msgid ""
":mod:`pyexpat`: An interface to the Expat XML parser. (Contributed by Paul "
"Prescod.)"
msgstr ":mod:`pyexpat`: Expat XML 解析器的介面。 （由保羅·普雷斯科德提供。）"

#: ../../whatsnew/2.0.rst:1111
#, fuzzy
msgid ""
":mod:`robotparser`: Parse a :file:`robots.txt` file, which is used for "
"writing web spiders that politely avoid certain areas of a web site.  The "
"parser accepts the contents of a :file:`robots.txt` file, builds a set of "
"rules from it, and can then answer questions about the fetchability of a "
"given URL.  (Contributed by Skip Montanaro.)"
msgstr ""
":mod:`robotparser`：解析 :file:`robots.txt` "
"文件，該文件用於編寫禮貌地避開網站某些區域的網絡蜘蛛。解析器接受 "
":file:`robots.txt` 文件的內容，從中構建一組規則，然後可以回答有關給定 URL "
"的可獲取性的問題。 （由 Skip Montanaro 提供。）"

#: ../../whatsnew/2.0.rst:1117
#, fuzzy
msgid ""
":mod:`tabnanny`: A module/script to  check Python source code for ambiguous "
"indentation. (Contributed by Tim Peters.)"
msgstr ":mod:`tabnanny`：用於檢查 Python 源程式碼是否有歧義縮進的模組/腳本。 "
"（由蒂姆·彼得斯提供。）"

#: ../../whatsnew/2.0.rst:1120
#, fuzzy
msgid ""
":mod:`UserString`: A base class useful for deriving objects that behave like "
"strings."
msgstr ":mod:`UserString`：一個基底類別，可用於派生行為類似於字串的物件。"

#: ../../whatsnew/2.0.rst:1123
#, fuzzy
msgid ""
":mod:`webbrowser`: A module that provides a platform independent way to "
"launch a web browser on a specific URL. For each platform, various browsers "
"are tried in a specific order. The user can alter which browser is launched "
"by setting the *BROWSER* environment variable.  (Originally inspired by Eric "
"S. Raymond's patch to :mod:`urllib` which added similar functionality, but "
"the final module comes from code originally  implemented by Fred Drake as :"
"file:`Tools/idle/BrowserControl.py`, and adapted for the standard library by "
"Fred.)"
msgstr ""
":mod:`webbrowser`: 一個模組，它提供了一種獨立於平台的方式來在特定的 URL "
"上啟動網絡瀏覽器。對於每個平台，將按特定順序嘗試各種瀏覽器。"
"使用者可以通過設定 *BROWSER* 環境變數來改變啟動哪個瀏覽器。 （最初受到 Eric "
"S. Raymond 的 :mod:`urllib` 補丁的啟發，它新增了類似的功能，但最終模組來自 "
"Fred Drake 最初實作的程式碼 :file:`Tools/idle/BrowserControl.py`，"
"並適用於Fred 的標準庫。）"

#: ../../whatsnew/2.0.rst:1132
#, fuzzy
msgid ""
":mod:`_winreg`: An interface to the Windows registry.  :mod:`_winreg` is an "
"adaptation of functions that have been part of PythonWin since 1995, but has "
"now been added to the core  distribution, and enhanced to support Unicode. :"
"mod:`_winreg` was written by Bill Tutt and Mark Hammond."
msgstr ""
":mod:`_winreg`: Windows 註冊表的介面。 :mod:`_winreg` 是對自 1995 "
"年以來一直是 PythonWin 一部分的函式的改編，但現在已新增到核心發行版中，"
"並得到增強以支援 Unicode。 :mod:`_winreg` 由 Bill Tutt 和 Mark Hammond 編寫。"

#: ../../whatsnew/2.0.rst:1137
#, fuzzy
msgid ""
":mod:`zipfile`: A module for reading and writing ZIP-format archives.  These "
"are archives produced by :program:`PKZIP` on DOS/Windows or :program:`zip` "
"on Unix, not to be confused with :program:`gzip`\\ -format files (which are "
"supported by the :mod:`gzip` module) (Contributed by James C. Ahlstrom.)"
msgstr ""
":mod:`zipfile`: 用於讀取和寫入 ZIP 格式檔案的模組。這些是由 DOS/Windows 上的 "
":program:`PKZIP` 或 Unix 上的 :program:`zip` 生成的檔案，不要與 "
":program:`gzip`\\ 格式的文件（由 :mod:` 支援）混淆gzip` 模組）（由 James C. "
"Ahlstrom 提供。）"

#: ../../whatsnew/2.0.rst:1142
#, fuzzy
msgid ""
":mod:`imputil`: A module that provides a simpler way for writing customized "
"import hooks, in comparison to the existing :mod:`ihooks` module.  "
"(Implemented by Greg Stein, with much discussion on python-dev along the "
"way.)"
msgstr ""
":mod:`imputil`：與現有的 :mod:`ihooks` "
"模組相比，該模組提供了一種更簡單的方法來編寫自定義導入掛鉤。 （由 Greg Stein "
"實施，沿途對 python-dev 進行了大量討論。）"

#: ../../whatsnew/2.0.rst:1150
#, fuzzy
msgid "IDLE Improvements"
msgstr "空閒改進"

#: ../../whatsnew/2.0.rst:1152
#, fuzzy
msgid ""
"IDLE is the official Python cross-platform IDE, written using Tkinter. "
"Python 2.0 includes IDLE 0.6, which adds a number of new features and "
"improvements.  A partial list:"
msgstr ""
"IDLE 是官方的 Python 跨平台 IDE，使用 Tkinter 編寫。 Python 2.0 包括 IDLE 0."
"6，它增加了許多新特性和改進。部分清單："

#: ../../whatsnew/2.0.rst:1156
#, fuzzy
msgid ""
"UI improvements and optimizations, especially in the area of syntax "
"highlighting and auto-indentation."
msgstr "UI 改進和最佳化，特別是在語法突出顯示和自動縮進方面。"

#: ../../whatsnew/2.0.rst:1159
#, fuzzy
msgid ""
"The class browser now shows more information, such as the top level "
"functions in a module."
msgstr "類瀏覽器現在顯示更多資訊，例如模組中的頂級函式。"

#: ../../whatsnew/2.0.rst:1162
#, fuzzy
msgid ""
"Tab width is now a user settable option. When opening an existing Python "
"file, IDLE automatically detects the indentation conventions, and adapts."
msgstr "標籤寬度現在是使用者可設定的選項。打開現有的 Python 文件時，IDLE "
"會自動檢測縮進約定並進行調整。"

#: ../../whatsnew/2.0.rst:1165
#, fuzzy
msgid ""
"There is now support for calling browsers on various platforms, used to open "
"the Python documentation in a browser."
msgstr "現已支援呼叫各平台瀏覽器，用於在瀏覽器中打開Python文檔。"

#: ../../whatsnew/2.0.rst:1168
#, fuzzy
msgid ""
"IDLE now has a command line, which is largely similar to  the vanilla Python "
"interpreter."
msgstr "IDLE 現在有一個命令列，它在很大程度上類似於 vanilla Python 直譯器。"

#: ../../whatsnew/2.0.rst:1171
#, fuzzy
msgid "Call tips were added in many places."
msgstr "多處增加了來電提示。"

#: ../../whatsnew/2.0.rst:1173
#, fuzzy
msgid "IDLE can now be installed as a package."
msgstr "IDLE 現在可以作為一個包安裝。"

#: ../../whatsnew/2.0.rst:1175
#, fuzzy
msgid "In the editor window, there is now a line/column bar at the bottom."
msgstr "在編輯器窗口中，底部現在有一個行/列欄。"

#: ../../whatsnew/2.0.rst:1177
#, fuzzy
msgid ""
"Three new keystroke commands: Check module (:kbd:`Alt-F5`), Import module (:"
"kbd:`F5`) and Run script (:kbd:`Ctrl-F5`)."
msgstr "三個新的擊鍵命令：檢查模組 (:kbd:`Alt-F5`)、導入模組 (:kbd:`F5`) 和運行腳本 "
"(:kbd:`Ctrl-F5`)。"

#: ../../whatsnew/2.0.rst:1184
#, fuzzy
msgid "Deleted and Deprecated Modules"
msgstr "刪除和棄用的模組"

#: ../../whatsnew/2.0.rst:1186
#, fuzzy
msgid ""
"A few modules have been dropped because they're obsolete, or because there "
"are now better ways to do the same thing.  The :mod:`stdwin` module is gone; "
"it was for a platform-independent windowing toolkit that's no longer "
"developed."
msgstr ""
"一些模組已被刪除，因為它們已經過時，或者因為現在有更好的方法來做同樣的事情。 "
":mod:`stdwin` 模組不見了；它用於不再開發的獨立於平台的窗口工具包。"

#: ../../whatsnew/2.0.rst:1190
#, fuzzy
msgid ""
"A number of modules have been moved to the :file:`lib-old` subdirectory: :"
"mod:`cmp`, :mod:`cmpcache`, :mod:`dircmp`, :mod:`dump`,  :mod:`find`, :mod:"
"`grep`, :mod:`packmail`,  :mod:`poly`, :mod:`util`, :mod:`whatsound`, :mod:"
"`zmod`.  If you have code which relies on a module  that's been moved to :"
"file:`lib-old`, you can simply add that directory to ``sys.path``   to get "
"them back, but you're encouraged to update any code that uses these modules."
msgstr ""
"許多模組已移至 :file:`lib-old` "
"子目錄：:mod:`cmp`、:mod:`cmpcache`、:mod:`dircmp`、:mod:`dump`、:mod: `find`"
"、:mod:`grep`、:mod:`packmail`、:mod:`poly`、:mod:`util`、:mod:`whatsound`、:"
"mod:`zmod`。如果您的程式碼依賴於已移至 :file:`lib-old` 的模組，"
"您只需將該目錄新增到 ``sys.path`` "
"即可取回它們，但我們鼓勵您更新任何程式碼使用這些模組的。"

#: ../../whatsnew/2.0.rst:1199
msgid "Acknowledgements"
msgstr "致謝"

#: ../../whatsnew/2.0.rst:1201
#, fuzzy
msgid ""
"The authors would like to thank the following people for offering "
"suggestions on various drafts of this article: David Bolen, Mark Hammond, "
"Gregg Hauser, Jeremy Hylton, Fredrik Lundh, Detlef Lannert, Aahz Maruch, "
"Skip Montanaro, Vladimir Marangozov, Tobias Polzin, Guido van Rossum, Neil "
"Schemenauer, and Russ Schmidt."
msgstr ""
"作者要感謝以下人員對本文的各種草稿提出的建議：David Bolen、Mark Hammond、"
"Gregg Hauser、Jeremy Hylton、Fredrik Lundh、Detlef Lannert、Aahz Maruch、"
"Skip Montanaro、Vladimir Marangozov、Tobias Polzin、Guido van Rossum、Neil "
"Schemenauer 和 Russ Schmidt。"
