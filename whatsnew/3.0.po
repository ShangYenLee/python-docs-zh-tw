# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-06 00:17+0000\n"
"PO-Revision-Date: 2018-05-23 16:20+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/3.0.rst:3
msgid "What's New In Python 3.0"
msgstr "Python 3.0 有什麼新功能"

#: ../../whatsnew/3.0.rst:0
msgid "Author"
msgstr "作者"

#: ../../whatsnew/3.0.rst:7
msgid "Guido van Rossum"
msgstr "Guido van Rossum"

#: ../../whatsnew/3.0.rst:54
#, fuzzy
msgid ""
"This article explains the new features in Python 3.0, compared to 2.6. "
"Python 3.0, also known as \"Python 3000\" or \"Py3K\", is the first ever "
"*intentionally backwards incompatible* Python release. Python 3.0 was "
"released on December 3, 2008. There are more changes than in a typical "
"release, and more that are important for all Python users. Nevertheless, "
"after digesting the changes, you'll find that Python really hasn't changed "
"all that much -- by and large, we're mostly fixing well-known annoyances and "
"warts, and removing a lot of old cruft."
msgstr ""
"本文介紹了 Python 3.0 與 2.6 相比的新功能。 Python 3.0，也稱為“Python "
"3000”或 ``Py3K``，是有史以來第一個*故意向後不相容*的 Python 版本。 Python 3.0 "
"於 2008 年 12 月 3 日發布。與典型版本相比有更多變化，而且對所有 Python "
"使用者來說都很重要。然而，在消化了這些變化之後，您會發現 Python 實際上並沒有"
"發生太大的變化——總的來說，我們主要是在修復眾所周知的煩惱和缺點，並刪除很多舊"
"的東西。"

#: ../../whatsnew/3.0.rst:63
#, fuzzy
msgid ""
"This article doesn't attempt to provide a complete specification of all new "
"features, but instead tries to give a convenient overview. For full details, "
"you should refer to the documentation for Python 3.0, and/or the many PEPs "
"referenced in the text. If you want to understand the complete "
"implementation and design rationale for a particular feature, PEPs usually "
"have more details than the regular documentation; but note that PEPs usually "
"are not kept up-to-date once a feature has been fully implemented."
msgstr ""
"本文並不試圖提供所有新功能的完整規範，而是試圖提供一個方便的概述。有關完整詳"
"細資訊，您應該參考 Python 3.0 的文檔和/或文本中引用的許多 "
"PEP。如果您想了解特定功能的完整實作和設計原理，PEP "
"通常比常規文檔有更多細節；但請注意，一旦功能已完全實作，PEP "
"通常不會保持最新狀態。"

#: ../../whatsnew/3.0.rst:72
#, fuzzy
msgid ""
"Due to time constraints this document is not as complete as it should have "
"been.  As always for a new release, the ``Misc/NEWS`` file in the source "
"distribution contains a wealth of detailed information about every small "
"thing that was changed."
msgstr ""
"由於時間限制，本文檔沒有達到應有的完整程度。與新版本一樣，源程式碼分發中的 ``"
"Misc/NEWS`` 文件包含大量有關更改的每一件小事的詳細資訊。"

#: ../../whatsnew/3.0.rst:89
#, fuzzy
msgid "Common Stumbling Blocks"
msgstr "常見的絆腳石"

#: ../../whatsnew/3.0.rst:91
#, fuzzy
msgid ""
"This section lists those few changes that are most likely to trip you up if "
"you're used to Python 2.5."
msgstr "如果您習慣了 Python 2.5，本節列出了最有可能讓您感到困惑的少數更改。"

#: ../../whatsnew/3.0.rst:95
#, fuzzy
msgid "Print Is A Function"
msgstr "印出是一個函式"

#: ../../whatsnew/3.0.rst:97
#, fuzzy
msgid ""
"The ``print`` statement has been replaced with a :func:`print` function, "
"with keyword arguments to replace most of the special syntax of the old "
"``print`` statement (:pep:`3105`).  Examples::"
msgstr ""
"``print`` 語句已被替換為 :func:`print` 函式，並使用關鍵字參數替換舊的 "
"``print`` 語句 (:pep:`3105`) 的大部分特殊語法。例子：："

#: ../../whatsnew/3.0.rst:116
#, fuzzy
msgid "You can also customize the separator between items, e.g.::"
msgstr "您還可以自定義項目之間的分隔符，例如：::"

#: ../../whatsnew/3.0.rst:120
#, fuzzy
msgid "which produces:"
msgstr "產生："

#: ../../whatsnew/3.0.rst:126
#, fuzzy
msgid "Note:"
msgstr "筆記："

#: ../../whatsnew/3.0.rst:128
#, fuzzy
msgid ""
"The :func:`print` function doesn't support the \"softspace\" feature of the "
"old ``print`` statement.  For example, in Python 2.x, ``print \"A\\n\", \"B"
"\"`` would write ``\"A\\nB\\n\"``; but in Python 3.0, ``print(\"A\\n\", \"B"
"\")`` writes ``\"A\\n B\\n\"``."
msgstr ""
":func:`print` 函式不支援舊版 ``print`` 語句的“軟空間”功能。例如，在 Python "
"2.x 中，``print \"A\\n"
"\", \"B\"`` 會寫成 ``\"A\\n"
"B\\n"
"\"``；但在 Python 3.0 中，``print(\"A\\n"
"\", \"B\")`` 寫成 ``\"A\\n"
" B\\n"
"\"``。"

#: ../../whatsnew/3.0.rst:133
#, fuzzy
msgid ""
"Initially, you'll be finding yourself typing the old ``print x`` a lot in "
"interactive mode.  Time to retrain your fingers to type ``print(x)`` instead!"
msgstr "最初，您會發現自己在交互模式下大量鍵入舊的 ``print x``。"
"是時候重新訓練你的手指來輸入 ``print(x)`` 了！"

#: ../../whatsnew/3.0.rst:137
#, fuzzy
msgid ""
"When using the ``2to3`` source-to-source conversion tool, all ``print`` "
"statements are automatically converted to :func:`print` function calls, so "
"this is mostly a non-issue for larger projects."
msgstr ""
"使用 ``2to3`` 源到源轉換工具時，所有 ``print`` 語句都會自動轉換為 "
":func:`print` 函式呼叫，因此對於大型項目來說這基本上不是問題。"

#: ../../whatsnew/3.0.rst:143
#, fuzzy
msgid "Views And Iterators Instead Of Lists"
msgstr "視圖和疊代器而不是列表"

#: ../../whatsnew/3.0.rst:145
#, fuzzy
msgid "Some well-known APIs no longer return lists:"
msgstr "一些著名的 API 不再回傳列表："

#: ../../whatsnew/3.0.rst:147
#, fuzzy
msgid ""
":class:`dict` methods :meth:`dict.keys`, :meth:`dict.items` and :meth:`dict."
"values` return \"views\" instead of lists.  For example, this no longer "
"works: ``k = d.keys(); k.sort()``.  Use ``k = sorted(d)`` instead (this "
"works in Python 2.5 too and is just as efficient)."
msgstr ""
":class:`dict` 方法 :meth:`dict.keys`、:meth:`dict.items` 和 :meth:`dict."
"values` 回傳“視圖”而不是列表。例如，這不再有效：``k = d.keys(); k.sort()``。"
"請改用 ``k = sorted(d)``（這在 Python 2.5 中也有效並且同樣有效）。"

#: ../../whatsnew/3.0.rst:153
#, fuzzy
msgid ""
"Also, the :meth:`dict.iterkeys`, :meth:`dict.iteritems` and :meth:`dict."
"itervalues` methods are no longer supported."
msgstr ""
"此外，不再支援 :meth:`dict.iterkeys`、:meth:`dict.iteritems` 和 :meth:`dict."
"itervalues` 方法。"

#: ../../whatsnew/3.0.rst:156
#, fuzzy
msgid ""
":func:`map` and :func:`filter` return iterators.  If you really need a list "
"and the input sequences are all of equal length, a quick fix is to wrap :"
"func:`map` in :func:`list`, e.g. ``list(map(...))``, but a better fix is "
"often to use a list comprehension (especially when the original code uses :"
"keyword:`lambda`), or rewriting the code so it doesn't need a list at all.  "
"Particularly tricky is :func:`map` invoked for the side effects of the "
"function; the correct transformation is to use a regular :keyword:`for` loop "
"(since creating a list would just be wasteful)."
msgstr ""
":func:`map` 和 :func:`filter` "
"回傳疊代器。如果你真的需要一個列表並且輸入序列都是等長的，"
"一個快速的解決方法是將 :func:`map` 包裝在 :func:`list` "
"中，例如``list(map(...))``，但更好的解決方法通常是使用列表理解（"
"尤其是當原始程式碼使用 :keyword:`lambda` "
"時），或者重寫程式碼，這樣它就不需要一個清單。特別棘手的是 :func:`map` "
"被函式的副作用呼叫；正確的轉換是使用常規的 :keyword:`for` "
"循環（因為建立列表只會造成浪費）。"

#: ../../whatsnew/3.0.rst:167
#, fuzzy
msgid ""
"If the input sequences are not of equal length, :func:`map` will stop at the "
"termination of the shortest of the sequences. For full compatibility with :"
"func:`map` from Python 2.x, also wrap the sequences in :func:`itertools."
"zip_longest`, e.g. ``map(func, *sequences)`` becomes ``list(map(func, "
"itertools.zip_longest(*sequences)))``."
msgstr ""
"如果輸入序列的長度不相等，:func:`map` 將在最短序列的結尾處停止。為了與 "
"Python 2.x 中的 :func:`map` 完全相容，還將序列包裝在 :func:`itertools."
"zip_longest` 中，例如``map(func, *sequences)`` 變成 ``list(map(func, "
"itertools.zip_longest(*sequences)))``。"

#: ../../whatsnew/3.0.rst:173
#, fuzzy
msgid ""
":func:`range` now behaves like :func:`xrange` used to behave, except it "
"works with values of arbitrary size.  The latter no longer exists."
msgstr ":func:`range` 現在的行為類似於 :func:`xrange` "
"過去的行為，除了它適用於任意大小的值。後者不再存在。"

#: ../../whatsnew/3.0.rst:177
#, fuzzy
msgid ":func:`zip` now returns an iterator."
msgstr ":func:`zip` 現在回傳一個疊代器。"

#: ../../whatsnew/3.0.rst:180
#, fuzzy
msgid "Ordering Comparisons"
msgstr "訂購比較"

#: ../../whatsnew/3.0.rst:182
#, fuzzy
msgid "Python 3.0 has simplified the rules for ordering comparisons:"
msgstr "Python 3.0 簡化了排序比較的規則："

#: ../../whatsnew/3.0.rst:184
#, fuzzy
msgid ""
"The ordering comparison operators (``<``, ``<=``, ``>=``, ``>``) raise a "
"TypeError exception when the operands don't have a meaningful natural "
"ordering.  Thus, expressions like ``1 < ''``, ``0 > None`` or ``len <= len`` "
"are no longer valid, and e.g. ``None < None`` raises :exc:`TypeError` "
"instead of returning ``False``.  A corollary is that sorting a heterogeneous "
"list no longer makes sense -- all the elements must be comparable to each "
"other.  Note that this does not apply to the ``==`` and ``!=`` operators: "
"objects of different incomparable types always compare unequal to each other."
msgstr ""
"當操作數沒有有意義的自然順序時，排序比較運算符（``<``、``<=``、``>=``、``>``"
"）會引發 TypeError 例外。因此，像``1 < ''``、``0 > None`` 或``len <= len`` "
"這樣的表達式不再有效，例如``None < None`` 引發 :exec:`TypeError` 而不是回傳 ``"
"False``。一個推論是，對異構列表進行排序不再有意義——所有元素必須相互比較。請注"
"意，這不適用於 ``==`` 和 ``!=`` "
"運算符：不同不可比較型別的物件總是相互比較不相等。"

#: ../../whatsnew/3.0.rst:195
#, fuzzy
msgid ""
":meth:`builtin.sorted` and :meth:`list.sort` no longer accept the *cmp* "
"argument providing a comparison function.  Use the *key* argument instead. N."
"B. the *key* and *reverse* arguments are now \"keyword-only\"."
msgstr ""
":meth:`builtin.sorted` 和 :meth:`list.sort` 不再接受提供比較函式的 *cmp* "
"參數。請改用 *key* 參數。注意*key* 和 *reverse* 參數現在是“僅關鍵字”。"

#: ../../whatsnew/3.0.rst:200
#, fuzzy
msgid ""
"The :func:`cmp` function should be treated as gone, and the :meth:`__cmp__` "
"special method is no longer supported.  Use :meth:`__lt__` for sorting, :"
"meth:`__eq__` with :meth:`__hash__`, and other rich comparisons as needed. "
"(If you really need the :func:`cmp` functionality, you could use the "
"expression ``(a > b) - (a < b)`` as the equivalent for ``cmp(a, b)``.)"
msgstr ""
":func:`cmp` 函式應該被視為已消失，不再支援 :meth:`__cmp__` 特殊方法。使用 "
":meth:`__lt__` 進行排序，使用 :meth:`__eq__` 和 "
":meth:`__hash__`，並根據需要進行其他豐富的比較。 （如果你真的需要 :func:`cmp`"
" 功能，你可以使用表達式 ``(a > b) - (a < b)`` 作為 ``cmp(a, b)`` 的等價物。）"

#: ../../whatsnew/3.0.rst:207
#, fuzzy
msgid "Integers"
msgstr "整數"

#: ../../whatsnew/3.0.rst:209
#, fuzzy
msgid ""
":pep:`237`: Essentially, :class:`long` renamed to :class:`int`. That is, "
"there is only one built-in integral type, named :class:`int`; but it behaves "
"mostly like the old :class:`long` type."
msgstr ""
":pep:`237`: 本質上，:class:`long` 重命名為 "
":class:`int`。也就是說，只有一種內建整數型別，名為 :class:`int`;"
"但它的行為大多像舊的 :class:`long` 型別。"

#: ../../whatsnew/3.0.rst:213
#, fuzzy
msgid ""
":pep:`238`: An expression like ``1/2`` returns a float.  Use ``1//2`` to get "
"the truncating behavior.  (The latter syntax has existed for years, at least "
"since Python 2.2.)"
msgstr ""
":pep:`238`: 像 ``1/2`` 這樣的表達式回傳一個浮點數。使用 ``1//2`` "
"獲得截斷行為。 （後一種語法已經存在多年，至少從 Python 2.2 開始是這樣。）"

#: ../../whatsnew/3.0.rst:217
#, fuzzy
msgid ""
"The :data:`sys.maxint` constant was removed, since there is no longer a "
"limit to the value of integers.  However, :data:`sys.maxsize` can be used as "
"an integer larger than any practical list or string index.  It conforms to "
"the implementation's \"natural\" integer size and is typically the same as :"
"data:`sys.maxint` in previous releases on the same platform (assuming the "
"same build options)."
msgstr ""
":data:`sys.maxint` 常數已被刪除，因為整數值不再有限制。但是，:data:`sys."
"maxsize` "
"可以用作大於任何實際列表或字串索引的整數。它符合實作的“自然”整數大小，"
"並且通常與同一平台上先前版本中的 :data:`sys.maxint` "
"相同（假設構建選項相同）。"

#: ../../whatsnew/3.0.rst:224
#, fuzzy
msgid ""
"The :func:`repr` of a long integer doesn't include the trailing ``L`` "
"anymore, so code that unconditionally strips that character will chop off "
"the last digit instead.  (Use :func:`str` instead.)"
msgstr ""
"長整數的 :func:`repr` 不再包含尾隨的 "
"``L``，因此無條件剝離該字元的程式碼將截斷最後一位數字。 （改用 "
":func:`str`。）"

#: ../../whatsnew/3.0.rst:228
#, fuzzy
msgid ""
"Octal literals are no longer of the form ``0720``; use ``0o720`` instead."
msgstr "八進位文字不再是 ``0720`` 的形式；使用 ``0o720`` 代替。"

#: ../../whatsnew/3.0.rst:232
#, fuzzy
msgid "Text Vs. Data Instead Of Unicode Vs. 8-bit"
msgstr "文本與。資料而不是 Unicode 與。 8位"

#: ../../whatsnew/3.0.rst:234
#, fuzzy
msgid ""
"Everything you thought you knew about binary data and Unicode has changed."
msgstr "您自以為了解的有關二進位資料和 Unicode 的一切都已改變。"

#: ../../whatsnew/3.0.rst:237
#, fuzzy
msgid ""
"Python 3.0 uses the concepts of *text* and (binary) *data* instead of "
"Unicode strings and 8-bit strings.  All text is Unicode; however *encoded* "
"Unicode is represented as binary data.  The type used to hold text is :class:"
"`str`, the type used to hold data is :class:`bytes`.  The biggest difference "
"with the 2.x situation is that any attempt to mix text and data in Python "
"3.0 raises :exc:`TypeError`, whereas if you were to mix Unicode and 8-bit "
"strings in Python 2.x, it would work if the 8-bit string happened to contain "
"only 7-bit (ASCII) bytes, but you would get :exc:`UnicodeDecodeError` if it "
"contained non-ASCII values.  This value-specific behavior has caused "
"numerous sad faces over the years."
msgstr ""
"Python 3.0 使用 *text* 和（二進位）*data* 的概念，而不是 Unicode 字串和 8 "
"位字串。所有文本都是 Unicode；但是*編碼* Unicode 表示為二進位資料。"
"用於保存文本的型別是 :class:`str`，用於保存資料的型別是 :class:`bytes`。與 "
"2.x 情況的最大區別在於，任何在 Python 3.0 中混合文本和資料的嘗試都會引發 "
":exc:`TypeError`，而如果您在 Python 2.x 中混合 Unicode 和 8 位字串，"
"它會起作用如果 8 位字串碰巧只包含 7 位 (ASCII) 位元組，但如果它包含非 ASCII "
"值，您將得到 :exc:`UnicodeDecodeError`。多年來，這種特定於價值觀的行為引起了"
"無數悲傷的表情。"

#: ../../whatsnew/3.0.rst:250
#, fuzzy
msgid ""
"As a consequence of this change in philosophy, pretty much all code that "
"uses Unicode, encodings or binary data most likely has to change.  The "
"change is for the better, as in the 2.x world there were numerous bugs "
"having to do with mixing encoded and unencoded text.  To be prepared in "
"Python 2.x, start using :class:`unicode` for all unencoded text, and :class:"
"`str` for binary or encoded data only.  Then the ``2to3`` tool will do most "
"of the work for you."
msgstr ""
"由於理念上的這種變化，幾乎所有使用 "
"Unicode、編碼或二進位資料的程式碼很可能都必須更改。更改是為了更好，因為在 "
"2.x 世界中存在許多與混合編碼和未編碼文本有關的錯誤。要在 Python 2.x "
"中做好準備，請開始對所有未編碼的文本使用 :class:`unicode`，"
"並僅對二進位或編碼資料使用 :class:`str`。然後 ``2to3`` "
"工具將為您完成大部分工作。"

#: ../../whatsnew/3.0.rst:258
#, fuzzy
msgid ""
"You can no longer use ``u\"...\"`` literals for Unicode text. However, you "
"must use ``b\"...\"`` literals for binary data."
msgstr "您不能再對 Unicode 文本使用 ``u\"...\"`` 文字。但是，您必須對二進位資料使用 "
"``b\"...\"`` 文字。"

#: ../../whatsnew/3.0.rst:261
#, fuzzy
msgid ""
"As the :class:`str` and :class:`bytes` types cannot be mixed, you must "
"always explicitly convert between them.  Use :meth:`str.encode` to go from :"
"class:`str` to :class:`bytes`, and :meth:`bytes.decode` to go from :class:"
"`bytes` to :class:`str`.  You can also use ``bytes(s, encoding=...)`` and "
"``str(b, encoding=...)``, respectively."
msgstr ""
"由於 :class:`str` 和 :class:`bytes` "
"型別不能混合，您必須始終在它們之間進行顯式轉換。使用 :meth:`str.encode` 從 "
":class:`str` 到 :class:`bytes`，使用 :meth:`bytes.decode` 從 :class:`bytes` "
"到 :class:`str `。您還可以分別使用 ``bytes(s, encoding=...)`` 和 ``str(b, "
"encoding=...)``。"

#: ../../whatsnew/3.0.rst:268
#, fuzzy
msgid ""
"Like :class:`str`, the :class:`bytes` type is immutable.  There is a "
"separate *mutable* type to hold buffered binary data, :class:`bytearray`.  "
"Nearly all APIs that accept :class:`bytes` also accept :class:`bytearray`.  "
"The mutable API is based on :class:`collections.MutableSequence`."
msgstr ""
"與 :class:`str` 一樣，:class:`bytes` 型別是不可變的。有一個單獨的 *mutable* "
"型別來保存緩衝的二進位資料，:class:`bytearray`。幾乎所有接受 :class:`bytes` "
"的 API 也接受 :class:`bytearray`。可變 API 基於 :class:`collections."
"MutableSequence`。"

#: ../../whatsnew/3.0.rst:274
#, fuzzy
msgid ""
"All backslashes in raw string literals are interpreted literally. This means "
"that ``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated "
"specially.  For example, ``r'\\u20ac'`` is a string of 6 characters in "
"Python 3.0, whereas in 2.6, ``ur'\\u20ac'`` was the single \"euro\" "
"character.  (Of course, this change only affects raw string literals; the "
"euro character is ``'\\u20ac'`` in Python 3.0.)"
msgstr ""
"原始字串文字中的所有反斜杠都按字面解釋。這意味著原始字串中的 ``'\\U'`` 和 ``'"
"\\u'`` 轉義不會被特殊處理。例如，``r'\\u20ac'`` 在 Python 3.0 中是一個包含 6 "
"個字元的字串，而在 2.6 中，``ur'\\u20ac'`` 是單個“歐元”字元。 "
"（當然，此更改僅影響原始字串文字；歐元字元在 Python 3.0 中為 ``'\\u20ac"
"'``。）"

#: ../../whatsnew/3.0.rst:281
#, fuzzy
msgid ""
"The built-in :class:`basestring` abstract type was removed.  Use :class:"
"`str` instead.  The :class:`str` and :class:`bytes` types don't have "
"functionality enough in common to warrant a shared base class.  The ``2to3`` "
"tool (see below) replaces every occurrence of :class:`basestring` with :"
"class:`str`."
msgstr ""
"內建的 :class:`basestring` 抽像型別被移除。使用 :class:`str` 代替。 "
":class:`str` 和 :class:`bytes` 型別沒有足夠的共同功能來保證共享基底類別。 "
"``2to3`` 工具（見下文）將每次出現的 :class:`basestring` 替換為 :class:`str`。"

#: ../../whatsnew/3.0.rst:287
#, fuzzy
msgid ""
"Files opened as text files (still the default mode for :func:`open`) always "
"use an encoding to map between strings (in memory) and bytes (on disk).  "
"Binary files (opened with a ``b`` in the mode argument) always use bytes in "
"memory.  This means that if a file is opened using an incorrect mode or "
"encoding, I/O will likely fail loudly, instead of silently producing "
"incorrect data.  It also means that even Unix users will have to specify the "
"correct mode (text or binary) when opening a file.  There is a platform-"
"dependent default encoding, which on Unixy platforms can be set with the "
"``LANG`` environment variable (and sometimes also with some other platform-"
"specific locale-related environment variables).  In many cases, but not all, "
"the system default is UTF-8; you should never count on this default.  Any "
"application reading or writing more than pure ASCII text should probably "
"have a way to override the encoding. There is no longer any need for using "
"the encoding-aware streams in the :mod:`codecs` module."
msgstr ""
"作為文本文件打開的文件（仍然是 :func:`open` 的預設模式）總是使用編碼來映射字"
"串（在記憶體中）和位元組（在磁盤上）。二進位文件（在模式參數中使用 ``b``打開）總"
"是使用記憶體中的位元組。這意味著如果使用不正確的模式或編碼打開文件，I/O "
"可能會大聲失敗，而不是默默地產生不正確的資料。這也意味著即使是 Unix 使用者在"
"打開文件時也必須指定正確的模式（文本或二進位）。有一個依賴於平台的預設編碼，"
"在 Unixy 平台上可以使用 ``LANG`` 環境變數設定（有時也可以使用其他一些特定於平"
"台的與區域設定相關的環境變數）。在很多情況下，但不是全部，系統預設是 "
"UTF-8；你永遠不應該指望這個預設值。任何讀取或寫入超過純 ASCII "
"文本的應用程式都應該有一種方法來覆蓋編碼。不再需要在 :mod:`codecs` "
"模組中使用編碼感知流。"

#: ../../whatsnew/3.0.rst:304
#, fuzzy
msgid ""
"The initial values of :data:`sys.stdin`, :data:`sys.stdout` and :data:`sys."
"stderr` are now unicode-only text files (i.e., they are instances of :class:"
"`io.TextIOBase`).  To read and write bytes data with these streams, you need "
"to use their :data:`io.TextIOBase.buffer` attribute."
msgstr ""
":data:`sys.stdin`、:data:`sys.stdout` 和 :data:`sys.stderr` 的初始值現在是純 "
"unicode 文本文件（即，它們是 :class:`io. "
"TextIOBase`）。要使用這些流讀取和寫入位元組資料，您需要使用它們的 :data:`io."
"TextIOBase.buffer` 屬性。"

#: ../../whatsnew/3.0.rst:310
#, fuzzy
msgid ""
"Filenames are passed to and returned from APIs as (Unicode) strings. This "
"can present platform-specific problems because on some platforms filenames "
"are arbitrary byte strings.  (On the other hand, on Windows filenames are "
"natively stored as Unicode.)  As a work-around, most APIs (e.g. :func:`open` "
"and many functions in the :mod:`os` module) that take filenames accept :"
"class:`bytes` objects as well as strings, and a few APIs have a way to ask "
"for a :class:`bytes` return value.  Thus, :func:`os.listdir` returns a list "
"of :class:`bytes` instances if the argument is a :class:`bytes` instance, "
"and :func:`os.getcwdb` returns the current working directory as a :class:"
"`bytes` instance.  Note that when :func:`os.listdir` returns a list of "
"strings, filenames that cannot be decoded properly are omitted rather than "
"raising :exc:`UnicodeError`."
msgstr ""
"文件名作為 (Unicode) 字串傳遞給 API 或從 API "
"回傳。這可能會出現特定於平台的問題，因為在某些平台上文件名是任意位元組字串。 "
"（另一方面，在 Windows 上，文件名本機儲存為 Unicode。）作為變通方法，"
"大多數採用文件名的 API（例如 :func:`open` 和 :mod:`os` "
"模組中的許多函式）接受： class:`bytes` 物件和字串，一些 API 可以請求 "
":class:`bytes` 回傳值。因此，如果參數是 bytes 實例，os.listdir 回傳 bytes "
"實例列表，而 os.getcwdb 回傳當前工作目錄作為 :class:`bytes` 實例。請注意，當 "
":func:`os.listdir` 回傳字串列表時，無法正確解碼的文件名將被忽略，而不是引發 "
":exc:`UnicodeError`。"

#: ../../whatsnew/3.0.rst:325
#, fuzzy
msgid ""
"Some system APIs like :data:`os.environ` and :data:`sys.argv` can also "
"present problems when the bytes made available by the system is not "
"interpretable using the default encoding.  Setting the ``LANG`` variable and "
"rerunning the program is probably the best approach."
msgstr ""
"當系統提供的位元組無法使用預設編碼進行解釋時，某些系統 API（例如 os.environ "
"和 sys.argv）也會出現問題。設定 ``LANG`` 變數並重新運行程式可能是最好的方法。"

#: ../../whatsnew/3.0.rst:330
#, fuzzy
msgid ""
":pep:`3138`: The :func:`repr` of a string no longer escapes non-ASCII "
"characters.  It still escapes control characters and code points with non-"
"printable status in the Unicode standard, however."
msgstr ""
":pep:`3138`: 字串的 :func:`repr` 不再轉義非 ASCII 字元。但是，它仍然轉義 "
"Unicode 標準中具有不可印出狀態的控制字元和程式碼點。"

#: ../../whatsnew/3.0.rst:334
#, fuzzy
msgid ":pep:`3120`: The default source encoding is now UTF-8."
msgstr ":pep:`3120`: 預設源編碼現在是 UTF-8。"

#: ../../whatsnew/3.0.rst:336
#, fuzzy
msgid ""
":pep:`3131`: Non-ASCII letters are now allowed in identifiers. (However, the "
"standard library remains ASCII-only with the exception of contributor names "
"in comments.)"
msgstr ":pep:`3131`: 標識符中現在允許使用非 ASCII 字母。 （但是，標準庫仍然只使用 "
"ASCII，但註釋中的貢獻者姓名除外。）"

#: ../../whatsnew/3.0.rst:340
#, fuzzy
msgid ""
"The :mod:`StringIO` and :mod:`cStringIO` modules are gone.  Instead, import "
"the :mod:`io` module and use :class:`io.StringIO` or :class:`io.BytesIO` for "
"text and data respectively."
msgstr ""
":mod:`StringIO` 和 :mod:`cStringIO` 模組消失了。相反，導入 :mod:`io` "
"模組並分別對文本和資料使用 :class:`io.StringIO` 或 :class:`io.BytesIO`。"

#: ../../whatsnew/3.0.rst:344
msgid "See also the :ref:`unicode-howto`, which was updated for Python 3.0."
msgstr "也請見為了 Python 3.0 所更新的 :ref:`unicode-howto`\\ 。"

#: ../../whatsnew/3.0.rst:348
#, fuzzy
msgid "Overview Of Syntax Changes"
msgstr "語法變化概述"

#: ../../whatsnew/3.0.rst:350
#, fuzzy
msgid ""
"This section gives a brief overview of every *syntactic* change in Python "
"3.0."
msgstr "本節簡要概述了 Python 3.0 中的每個*語法*更改。"

#: ../../whatsnew/3.0.rst:354
#, fuzzy
msgid "New Syntax"
msgstr "新語法"

#: ../../whatsnew/3.0.rst:356
#, fuzzy
msgid ""
":pep:`3107`: Function argument and return value annotations.  This provides "
"a standardized way of annotating a function's parameters and return value.  "
"There are no semantics attached to such annotations except that they can be "
"introspected at runtime using the :attr:`__annotations__` attribute.  The "
"intent is to encourage experimentation through metaclasses, decorators or "
"frameworks."
msgstr ""
":pep:`3107`: "
"函式參數和回傳值註釋。這提供了一種註釋函式參數和回傳值的標準化方法。"
"除了可以在運行時使用 :attr:`__annotations__` 屬性對它們進行自省外，此類註釋沒"
"有附加語義。目的是鼓勵通過元類、裝飾器或框架進行實驗。"

#: ../../whatsnew/3.0.rst:363
#, fuzzy
msgid ""
":pep:`3102`: Keyword-only arguments.  Named parameters occurring after "
"``*args`` in the parameter list *must* be specified using keyword syntax in "
"the call.  You can also use a bare ``*`` in the parameter list to indicate "
"that you don't accept a variable-length argument list, but you do have "
"keyword-only arguments."
msgstr ""
":pep:`3102`: 僅關鍵字參數。在參數列表中出現在“*args”之後的命名參數*必須*在呼"
"叫中使用關鍵字語法指定。您還可以在參數列表中使用一個簡單的 ``*``來表示您不接受可"
"變長度參數列表，但您確實有僅關鍵字參數。"

#: ../../whatsnew/3.0.rst:369
#, fuzzy
msgid ""
"Keyword arguments are allowed after the list of base classes in a class "
"definition.  This is used by the new convention for specifying a metaclass "
"(see next section), but can be used for other purposes as well, as long as "
"the metaclass supports it."
msgstr "在類定義中的基底類別列表之後允許使用關鍵字參數。這被新約定用於指定元類（見下"
"一節），但也可以用於其他目的，只要元類支援它。"

#: ../../whatsnew/3.0.rst:374
#, fuzzy
msgid ""
":pep:`3104`: :keyword:`nonlocal` statement.  Using ``nonlocal x`` you can "
"now assign directly to a variable in an outer (but non-global) scope.  :"
"keyword:`!nonlocal` is a new reserved word."
msgstr ""
":pep:`3104`: :keyword:`nonlocal` 語句。使用 ``nonlocal "
"x``，您現在可以直接分配給外部（但非全局）範圍內的變數。 :keyword:`!nonlocal` "
"是一個新的保留字。"

#: ../../whatsnew/3.0.rst:378
#, fuzzy
msgid ""
":pep:`3132`: Extended Iterable Unpacking.  You can now write things like "
"``a, b, *rest = some_sequence``.  And even ``*rest, a = stuff``.  The "
"``rest`` object is always a (possibly empty) list; the right-hand side may "
"be any iterable.  Example::"
msgstr ""
":pep:`3132`：擴充的可疊代拆包。你現在可以寫類似 ``a, b, *rest = "
"some_sequence`` 的東西。甚至``*rest, a = stuff``。 ``rest`` "
"物件總是一個（可能是空的）列表；右側可以是任何可疊代的。例子：："

#: ../../whatsnew/3.0.rst:385
#, fuzzy
msgid "This sets *a* to ``0``, *b* to ``4``, and *rest* to ``[1, 2, 3]``."
msgstr "這會將 *a* 設定為 ``0``，將 *b* 設定為 ``4``，將 *rest* 設定為“[1, 2, 3]”。"

#: ../../whatsnew/3.0.rst:387
#, fuzzy
msgid ""
"Dictionary comprehensions: ``{k: v for k, v in stuff}`` means the same thing "
"as ``dict(stuff)`` but is more flexible.  (This is :pep:`274` vindicated. :-)"
msgstr ""
"字典理解：``{k: v for k, v in stuff}`` 與 ``dict(stuff)`` "
"意思相同，但更靈活。 （這是 :pep:`274` 的證明。:-)"

#: ../../whatsnew/3.0.rst:391
#, fuzzy
msgid ""
"Set literals, e.g. ``{1, 2}``.  Note that ``{}`` is an empty dictionary; use "
"``set()`` for an empty set.  Set comprehensions are also supported; e.g., "
"``{x for x in stuff}`` means the same thing as ``set(stuff)`` but is more "
"flexible."
msgstr ""
"設定文字，例如``{1, 2}``。請注意，``{}`` 是一個空字典；對空集使用 "
"``set()``。還支援集合推導；例如，``{x for x in stuff}`` 與 ``set(stuff)`` "
"意思相同，但更靈活。"

#: ../../whatsnew/3.0.rst:396
#, fuzzy
msgid ""
"New octal literals, e.g. ``0o720`` (already in 2.6).  The old octal literals "
"(``0720``) are gone."
msgstr "新的八進位文字，例如``0o720``（已經在 2.6 中）。舊的八進位文字 (``0720``) "
"消失了。"

#: ../../whatsnew/3.0.rst:399
#, fuzzy
msgid ""
"New binary literals, e.g. ``0b1010`` (already in 2.6), and there is a new "
"corresponding built-in function, :func:`bin`."
msgstr "新的二進位文字，例如``0b1010``（已經在 2.6 "
"中），並且有一個新的對應內建函式，:func:`bin`。"

#: ../../whatsnew/3.0.rst:402
#, fuzzy
msgid ""
"Bytes literals are introduced with a leading ``b`` or ``B``, and there is a "
"new corresponding built-in function, :func:`bytes`."
msgstr "位元組字面量以 ``b``或 ``B``開頭，並且有一個新的對應內建函式 :func:`bytes`。"

#: ../../whatsnew/3.0.rst:406
#, fuzzy
msgid "Changed Syntax"
msgstr "更改語法"

#: ../../whatsnew/3.0.rst:408
#, fuzzy
msgid ""
":pep:`3109` and :pep:`3134`: new :keyword:`raise` statement syntax: :samp:"
"`raise [{expr} [from {expr}]]`.  See below."
msgstr ""
":pep:`3109` 和 :pep:`3134`：新的 :keyword:`raise` 語句語法：:samp:`raise "
"[{expr} [from {expr}]]`。見下文。"

#: ../../whatsnew/3.0.rst:411
#, fuzzy
msgid ""
":keyword:`!as` and :keyword:`with` are now reserved words.  (Since 2.6, "
"actually.)"
msgstr ":keyword:`!as` 和 :keyword:`with` 現在是保留字。 （實際上從 2.6 開始。）"

#: ../../whatsnew/3.0.rst:414
#, fuzzy
msgid ""
"``True``, ``False``, and ``None`` are reserved words.  (2.6 partially "
"enforced the restrictions on ``None`` already.)"
msgstr "``True``、``False`` 和 ``None`` 是保留字。 （2.6 "
"已經部分實施了對 ``None`` 的限制。）"

#: ../../whatsnew/3.0.rst:417
#, fuzzy
msgid ""
"Change from :keyword:`except` *exc*, *var* to :keyword:`!except` *exc* :"
"keyword:`!as` *var*.  See :pep:`3110`."
msgstr ""
"從 :keyword:`except` *exc*, *var* 更改為 :keyword:`!except` *exc* "
":keyword:`!as` *var*。請參閱 :pep:`3110`。"

#: ../../whatsnew/3.0.rst:420
#, fuzzy
msgid ":pep:`3115`: New Metaclass Syntax.  Instead of::"
msgstr ":pep:`3115`: 新元類語法。代替：："

#: ../../whatsnew/3.0.rst:426
#, fuzzy
msgid "you must now use::"
msgstr "你現在必須使用::"

#: ../../whatsnew/3.0.rst:431
#, fuzzy
msgid ""
"The module-global :data:`__metaclass__` variable is no longer supported.  "
"(It was a crutch to make it easier to default to new-style classes without "
"deriving every class from :class:`object`.)"
msgstr ""
"不再支援模組全局 :data:`__metaclass__` 變數。 （在不從 :class:`object` "
"派生每個類的情況下，更容易預設為新式類是一個拐杖。）"

#: ../../whatsnew/3.0.rst:436
#, fuzzy
msgid ""
"List comprehensions no longer support the syntactic form :samp:`[... for "
"{var} in {item1}, {item2}, ...]`.  Use :samp:`[... for {var} in ({item1}, "
"{item2}, ...)]` instead. Also note that list comprehensions have different "
"semantics: they are closer to syntactic sugar for a generator expression "
"inside a :func:`list` constructor, and in particular the loop control "
"variables are no longer leaked into the surrounding scope."
msgstr ""
"列表理解不再支援句法形式 :samp:`[... for {var} in {item1}, {item2}, ...]`。"
"使用 :samp:`[... for {var} in ({item1}, {item2}, ...)]` "
"代替。另請注意，列表理解具有不同的語義：它們更接近 :func:`list` "
"構造函式中生成器表達式的語法糖，特別是循環控制變數不再洩漏到周圍範圍。"

#: ../../whatsnew/3.0.rst:444
#, fuzzy
msgid ""
"The *ellipsis* (``...``) can be used as an atomic expression anywhere.  "
"(Previously it was only allowed in slices.)  Also, it *must* now be spelled "
"as ``...``.  (Previously it could also be spelled as ``. . .``, by a mere "
"accident of the grammar.)"
msgstr ""
"*省略號* (``...``) 可以在任何地方用作原子表達式。 "
"（以前它只允許在切片中使用。）此外，它*必須*現在拼寫為``...``。 （"
"以前它也可以拼寫為 ``. . .``，只是語法上的意外。）"

#: ../../whatsnew/3.0.rst:450
#, fuzzy
msgid "Removed Syntax"
msgstr "刪除語法"

#: ../../whatsnew/3.0.rst:452
#, fuzzy
msgid ""
":pep:`3113`: Tuple parameter unpacking removed.  You can no longer write "
"``def foo(a, (b, c)): ...``. Use ``def foo(a, b_c): b, c = b_c`` instead."
msgstr ""
":pep:`3113`: 刪除元組參數解包。你不能再寫 ``def foo(a, (b, c)): ...``。使用 "
"``def foo(a, b_c): b, c = b_c`` 代替。"

#: ../../whatsnew/3.0.rst:456
#, fuzzy
msgid "Removed backticks (use :func:`repr` instead)."
msgstr "刪除了反引號（改用 :func:`repr`）。"

#: ../../whatsnew/3.0.rst:458
#, fuzzy
msgid "Removed ``<>`` (use ``!=`` instead)."
msgstr "刪除了``<>``（改用``！=``）。"

#: ../../whatsnew/3.0.rst:460
#, fuzzy
msgid ""
"Removed keyword: :func:`exec` is no longer a keyword; it remains as a "
"function.  (Fortunately the function syntax was also accepted in 2.x.)  Also "
"note that :func:`exec` no longer takes a stream argument; instead of "
"``exec(f)`` you can use ``exec(f.read())``."
msgstr ""
"刪除關鍵字：:func:`exec` 不再是關鍵字；它仍然是一個功能。 （幸運的是，"
"函式語法在 2.x 中也被接受。）另請注意 :func:`exec` 不再採用流參數；"
"你可以使用 exec(f.read()) 而不是 exec(f) 。"

#: ../../whatsnew/3.0.rst:465
#, fuzzy
msgid "Integer literals no longer support a trailing ``l`` or ``L``."
msgstr "整數文字不再支援尾隨 ``l`` 或 ``L``。"

#: ../../whatsnew/3.0.rst:467
#, fuzzy
msgid "String literals no longer support a leading ``u`` or ``U``."
msgstr "字串文字不再支援前導 ``u`` 或 ``U``。"

#: ../../whatsnew/3.0.rst:469
#, fuzzy
msgid ""
"The :keyword:`from` *module* :keyword:`import` ``*`` syntax is only allowed "
"at the module level, no longer inside functions."
msgstr ""
":keyword:`from` *module* :keyword:`import` ``*`` "
"語法只允許在模組級別使用，不再在函式內部使用。"

#: ../../whatsnew/3.0.rst:472
#, fuzzy
msgid ""
"The only acceptable syntax for relative imports is :samp:`from .[{module}] "
"import {name}`.  All :keyword:`import` forms not starting with ``.`` are "
"interpreted as absolute imports.  (:pep:`328`)"
msgstr ""
"相對導入唯一可接受的語法是 :samp:`from .[{module}] import {name}`。所有不以 "
". 開頭的 :keyword:`import` 形式都被解釋為絕對導入。 (:pep:`328`)"

#: ../../whatsnew/3.0.rst:476
#, fuzzy
msgid "Classic classes are gone."
msgstr "經典課程不見了。"

#: ../../whatsnew/3.0.rst:480
#, fuzzy
msgid "Changes Already Present In Python 2.6"
msgstr "Python 2.6 中已經存在的變化"

#: ../../whatsnew/3.0.rst:482
#, fuzzy
msgid ""
"Since many users presumably make the jump straight from Python 2.5 to Python "
"3.0, this section reminds the reader of new features that were originally "
"designed for Python 3.0 but that were back-ported to Python 2.6.  The "
"corresponding sections in :ref:`whats-new-in-2.6` should be consulted for "
"longer descriptions."
msgstr ""
"由於許多使用者可能會直接從 Python 2.5 跳到 Python 3.0，"
"因此本節提醒讀者註意最初為 Python 3.0 設計但被反向移植到 Python 2.6 "
"的新功能。應查閱 :ref:`whats-new-in-2.6` 中的相應部分以獲得更長的描述。"

#: ../../whatsnew/3.0.rst:488
#, fuzzy
msgid ""
":ref:`pep-0343`.  The :keyword:`with` statement is now a standard feature "
"and no longer needs to be imported from the :mod:`__future__`. Also check "
"out :ref:`new-26-context-managers` and :ref:`new-module-contextlib`."
msgstr ""
":ref:`pep-0343`。 :keyword:`with` 語句現在是標準功能，不再需要從 "
":mod:`__future__` 導入。另請查看 :ref:`new-26-context-managers` 和 :ref:`new-"
"module-contextlib`。"

#: ../../whatsnew/3.0.rst:493
#, fuzzy
msgid ""
":ref:`pep-0366`.  This enhances the usefulness of the :option:`-m` option "
"when the referenced module lives in a package."
msgstr ":ref:`pep-0366`。當引用的模組位於包中時，這會增強 :option:`-m` 選項的實用性。"

#: ../../whatsnew/3.0.rst:496
msgid ":ref:`pep-0370`."
msgstr ":ref:`pep-0370`\\ 。"

#: ../../whatsnew/3.0.rst:498
msgid ":ref:`pep-0371`."
msgstr ":ref:`pep-0371`\\ 。"

#: ../../whatsnew/3.0.rst:500
#, fuzzy
msgid ""
":ref:`pep-3101`.  Note: the 2.6 description mentions the :meth:`format` "
"method for both 8-bit and Unicode strings.  In 3.0, only the :class:`str` "
"type (text strings with Unicode support) supports this method; the :class:"
"`bytes` type does not.  The plan is to eventually make this the only API for "
"string formatting, and to start deprecating the ``%`` operator in Python 3.1."
msgstr ""
":ref:`pep-3101`。注意：2.6 的描述提到了 8 位和 Unicode 字串的 :meth:`format` "
"方法。在 3.0 中，只有 :class:`str` 型別（支援 Unicode "
"的文本字串）支援此方法； :class:`bytes` 型別沒有。"
"計劃最終使它成為唯一的字串格式化 API，並開始棄用 Python 3.1 中的 ``%`` "
"運算符。"

#: ../../whatsnew/3.0.rst:507
#, fuzzy
msgid ""
":ref:`pep-3105`.  This is now a standard feature and no longer needs to be "
"imported from :mod:`__future__`.  More details were given above."
msgstr ":ref:`pep-3105`。現在這是一項標準功能，不再需要從 :mod:`__future__` "
"導入。上面給出了更多細節。"

#: ../../whatsnew/3.0.rst:510
#, fuzzy
msgid ""
":ref:`pep-3110`.  The :keyword:`except` *exc* :keyword:`!as` *var* syntax is "
"now standard and :keyword:`!except` *exc*, *var* is no longer supported.  "
"(Of course, the :keyword:`!as` *var* part is still optional.)"
msgstr ""
":ref:`pep-3110`。 :keyword:`except` *exc* :keyword:`!as` *var* "
"語法現在是標準語法，不再支援 :keyword:`!except` *exc*, *var*。 "
"（當然，:keyword:`!as` *var* 部分仍然是可選的。）"

#: ../../whatsnew/3.0.rst:515
#, fuzzy
msgid ""
":ref:`pep-3112`.  The ``b\"...\"`` string literal notation (and its variants "
"like ``b'...'``, ``b\"\"\"...\"\"\"``, and ``br\"...\"``) now produces a "
"literal of type :class:`bytes`."
msgstr ""
":ref:`pep-3112`。 ``b\"...\"`` 字串文字元號（及其變體，如 ``b\\'...\\'``、``"
"b\"\"\"...\"\"\"`` 和 ``br\" ...\"``) 現在生成型別為 :class:`bytes` 的文字。"

#: ../../whatsnew/3.0.rst:519
#, fuzzy
msgid ""
":ref:`pep-3116`.  The :mod:`io` module is now the standard way of doing file "
"I/O.  The built-in :func:`open` function is now an alias for :func:`io.open` "
"and has additional keyword arguments *encoding*, *errors*, *newline* and "
"*closefd*.  Also note that an invalid *mode* argument now raises :exc:"
"`ValueError`, not :exc:`IOError`.  The binary file object underlying a text "
"file object can be accessed as :attr:`f.buffer` (but beware that the text "
"object maintains a buffer of itself in order to speed up the encoding and "
"decoding operations)."
msgstr ""
":ref:`pep-3116`。 :mod:`io` 模組現在是執行文件 I/O 的標準方式。內建的 "
":func:`open` 函式現在是 :func:`io.open` 的別名，並且有額外的關鍵字參數 "
"*encoding*、*errors*、*newline* 和 *closefd*。另請注意，無效的 *mode* "
"參數現在會引發 :exc:`ValueError`，而不是 :exc:`IOError`。"
"文本文件對像下的二進位文件物件可以作為 :attr:`f.buffer` "
"訪問（但要注意文本物件維護自身的緩衝區以加速編碼和解碼操作）。"

#: ../../whatsnew/3.0.rst:529
#, fuzzy
msgid ""
":ref:`pep-3118`.  The old builtin :func:`buffer` is now really gone; the new "
"builtin :func:`memoryview` provides (mostly) similar functionality."
msgstr ""
":ref:`pep-3118`。舊的內建 :func:`buffer` 現在真的消失了；新的內建 "
":func:`memoryview` 提供（大部分）類似的功能。"

#: ../../whatsnew/3.0.rst:533
#, fuzzy
msgid ""
":ref:`pep-3119`.  The :mod:`abc` module and the ABCs defined in the :mod:"
"`collections` module plays a somewhat more prominent role in the language "
"now, and built-in collection types like :class:`dict` and :class:`list` "
"conform to the :class:`collections.MutableMapping` and :class:`collections."
"MutableSequence` ABCs, respectively."
msgstr ""
":ref:`pep-3119`。 :mod:`abc` 模組和 :mod:`collections` 模組中定義的 ABC "
"現在在語言中扮演著更突出的角色，內建的集合型別如 :class:`dict` 和 :class:` "
"list` 分別符合 :class:`collections.MutableMapping` 和 :class:`collections."
"MutableSequence` ABCs。"

#: ../../whatsnew/3.0.rst:539
#, fuzzy
msgid ""
":ref:`pep-3127`.  As mentioned above, the new octal literal notation is the "
"only one supported, and binary literals have been added."
msgstr ":ref:`pep-3127`。如上所述，新的八進位文字表示法是唯一受支援的，並且新增了二進"
"製文字。"

#: ../../whatsnew/3.0.rst:543
msgid ":ref:`pep-3129`."
msgstr ":ref:`pep-3129`\\ 。"

#: ../../whatsnew/3.0.rst:545
#, fuzzy
msgid ""
":ref:`pep-3141`.  The :mod:`numbers` module is another new use of ABCs, "
"defining Python's \"numeric tower\".  Also note the new :mod:`fractions` "
"module which implements :class:`numbers.Rational`."
msgstr ""
":ref:`pep-3141`。 :mod:`numbers` 模組是 ABC 的另一個新用途，它定義了 Python "
"的“數字塔”。還要注意新的 :mod:`fractions` 模組，它實作了 :class:`numbers."
"Rational`。"

#: ../../whatsnew/3.0.rst:551
#, fuzzy
msgid "Library Changes"
msgstr "圖書館的變化"

#: ../../whatsnew/3.0.rst:553
#, fuzzy
msgid ""
"Due to time constraints, this document does not exhaustively cover the very "
"extensive changes to the standard library.  :pep:`3108` is the reference for "
"the major changes to the library.  Here's a capsule review:"
msgstr "由於時間限制，本文檔並未詳盡涵蓋對標準庫的大量更改。 :pep:`3108` "
"是庫主要更改的參考。這是一個膠囊評論："

#: ../../whatsnew/3.0.rst:558
#, fuzzy
msgid ""
"Many old modules were removed.  Some, like :mod:`gopherlib` (no longer used) "
"and :mod:`md5` (replaced by :mod:`hashlib`), were already deprecated by :pep:"
"`4`.  Others were removed as a result of the removal of support for various "
"platforms such as Irix, BeOS and Mac OS 9 (see :pep:`11`).  Some modules "
"were also selected for removal in Python 3.0 due to lack of use or because a "
"better replacement exists.  See :pep:`3108` for an exhaustive list."
msgstr ""
"許多舊模組被刪除。有些，比如 :mod:`gopherlib`（不再使用）和 :mod:`md5`（被 "
":mod:`hashlib` 取代），已經被 :pep:`4` 棄用了。由於取消了對 Irix、BeOS 和 "
"Mac OS 9 等各種平台的支援，其他的也被刪除（參見 "
":pep:`11`）。由於缺乏使用或存在更好的替代品，一些模組也被選擇在 Python 3.0 "
"中刪除。有關詳盡列表，請參閱 :pep:`3108`。"

#: ../../whatsnew/3.0.rst:566
#, fuzzy
msgid ""
"The :mod:`bsddb3` package was removed because its presence in the core "
"standard library has proved over time to be a particular burden for the core "
"developers due to testing instability and Berkeley DB's release schedule.  "
"However, the package is alive and well, externally maintained at https://www."
"jcea.es/programacion/pybsddb.htm."
msgstr ""
":mod:`bsddb3` 包已被刪除，因為隨著時間的推移，由於測試不穩定和 Berkeley DB 的"
"發布計劃，它在核心標準庫中的存在已被證明對核心開發人員來說是一個特殊的負擔。"
"但是，該包仍然存在並且運行良好，外部維護在 https://www.jcea.es/programacion/"
"pybsddb.htm。"

#: ../../whatsnew/3.0.rst:572
#, fuzzy
msgid ""
"Some modules were renamed because their old name disobeyed :pep:`8`, or for "
"various other reasons.  Here's the list:"
msgstr "一些模組被重命名是因為它們的舊名稱不符合 :pep:`8` 或其他各種原因。這是列表："

#: ../../whatsnew/3.0.rst:576
msgid "Old Name"
msgstr "舊名"

#: ../../whatsnew/3.0.rst:576
msgid "New Name"
msgstr "新名"

#: ../../whatsnew/3.0.rst:578
msgid "_winreg"
msgstr "_winreg"

#: ../../whatsnew/3.0.rst:578
msgid "winreg"
msgstr "winreg"

#: ../../whatsnew/3.0.rst:579
msgid "ConfigParser"
msgstr "ConfigParser"

#: ../../whatsnew/3.0.rst:579
msgid "configparser"
msgstr "configparser"

#: ../../whatsnew/3.0.rst:580
msgid "copy_reg"
msgstr "copy_reg"

#: ../../whatsnew/3.0.rst:580
msgid "copyreg"
msgstr "copyreg"

#: ../../whatsnew/3.0.rst:581
msgid "Queue"
msgstr "Queue"

#: ../../whatsnew/3.0.rst:581
msgid "queue"
msgstr "queue"

#: ../../whatsnew/3.0.rst:582
msgid "SocketServer"
msgstr "SocketServer"

#: ../../whatsnew/3.0.rst:582
msgid "socketserver"
msgstr "socketserver"

#: ../../whatsnew/3.0.rst:583
msgid "markupbase"
msgstr "markupbase"

#: ../../whatsnew/3.0.rst:583
msgid "_markupbase"
msgstr "_markupbase"

#: ../../whatsnew/3.0.rst:584
msgid "repr"
msgstr "repr"

#: ../../whatsnew/3.0.rst:584
msgid "reprlib"
msgstr "reprlib"

#: ../../whatsnew/3.0.rst:585
msgid "test.test_support"
msgstr "test.test_support"

#: ../../whatsnew/3.0.rst:585
msgid "test.support"
msgstr "test.support"

#: ../../whatsnew/3.0.rst:588
#, fuzzy
msgid ""
"A common pattern in Python 2.x is to have one version of a module "
"implemented in pure Python, with an optional accelerated version implemented "
"as a C extension; for example, :mod:`pickle` and :mod:`cPickle`.  This "
"places the burden of importing the accelerated version and falling back on "
"the pure Python version on each user of these modules.  In Python 3.0, the "
"accelerated versions are considered implementation details of the pure "
"Python versions. Users should always import the standard version, which "
"attempts to import the accelerated version and falls back to the pure Python "
"version.  The :mod:`pickle` / :mod:`cPickle` pair received this treatment.  "
"The :mod:`profile` module is on the list for 3.1.  The :mod:`StringIO` "
"module has been turned into a class in the :mod:`io` module."
msgstr ""
"Python 2.x 中的一種常見模式是使用純 Python 實作模組的一個版本，"
"並將可選的加速版本實作為 C 擴充；例如，:mod:`pickle` 和 :mod:`cPickle`。"
"這給這些模組的每個使用者帶來了導入加速版本和回退到純 Python 版本的負擔。在 "
"Python 3.0 中，加速版本被認為是純 Python "
"版本的實作細節。使用者應該始終導入標準版本，它會嘗試導入加速版本並回退到純 "
"Python 版本。 :mod:`pickle` / :mod:`cPickle` 對接受了這種處理。 "
":mod:`profile` 模組在 3.1 的列表中。 :mod:`StringIO` 模組已變成 :mod:`io` "
"模組中的一個類。"

#: ../../whatsnew/3.0.rst:602
#, fuzzy
msgid ""
"Some related modules have been grouped into packages, and usually the "
"submodule names have been simplified.  The resulting new packages are:"
msgstr "一些相關模組已被分組到包中，通常子模組名稱已被簡化。由此產生的新包是："

#: ../../whatsnew/3.0.rst:606
#, fuzzy
msgid ""
":mod:`dbm` (:mod:`anydbm`, :mod:`dbhash`, :mod:`dbm`, :mod:`dumbdbm`, :mod:"
"`gdbm`, :mod:`whichdb`)."
msgstr ""
":mod:`dbm` (:mod:`anydbm`, :mod:`dbhash`, :mod:`dbm`, :mod:`dumbdbm`, "
":mod:`gdbm`, :mod:`whichdb`)。"

#: ../../whatsnew/3.0.rst:609
msgid ":mod:`html` (:mod:`HTMLParser`, :mod:`htmlentitydefs`)."
msgstr ""
":mod:`html`\\ （\\ :mod:`HTMLParser`\\ 、\\ :mod:`htmlentitydefs`\\ ）。"

#: ../../whatsnew/3.0.rst:611
#, fuzzy
msgid ""
":mod:`http` (:mod:`httplib`, :mod:`BaseHTTPServer`, :mod:`CGIHTTPServer`, :"
"mod:`SimpleHTTPServer`, :mod:`Cookie`, :mod:`cookielib`)."
msgstr ""
":mod:`http` (:mod:`httplib`, :mod:`BaseHTTPServer`, :mod:`CGIHTTPServer`, "
":mod:`SimpleHTTPServer`, :mod:`Cookie`, :mod:`cookielib`)。"

#: ../../whatsnew/3.0.rst:615
#, fuzzy
msgid ""
":mod:`tkinter` (all :mod:`Tkinter`-related modules except :mod:`turtle`).  "
"The target audience of :mod:`turtle` doesn't really care about :mod:"
"`tkinter`.  Also note that as of Python 2.6, the functionality of :mod:"
"`turtle` has been greatly enhanced."
msgstr ""
":mod:`tkinter`（所有 :mod:`Tkinter` 相關模組，除了 :mod:`turtle`）。 "
":mod:`turtle` 的目標受眾並不真正關心 :mod:`tkinter`。另請注意，從 Python 2.6 "
"開始，:mod:`turtle` 的功能得到了極大增強。"

#: ../../whatsnew/3.0.rst:620
#, fuzzy
msgid ""
":mod:`urllib` (:mod:`urllib`, :mod:`urllib2`, :mod:`urlparse`, :mod:"
"`robotparse`)."
msgstr ""
":mod:`urllib` (:mod:`urllib`, :mod:`urllib2`, :mod:`urlparse`, "
":mod:`robotparse`)。"

#: ../../whatsnew/3.0.rst:623
#, fuzzy
msgid ""
":mod:`xmlrpc` (:mod:`xmlrpclib`, :mod:`DocXMLRPCServer`, :mod:"
"`SimpleXMLRPCServer`)."
msgstr ""
":mod:`xmlrpc` (:mod:`xmlrpclib`, :mod:`DocXMLRPCServer`, "
":mod:`SimpleXMLRPCServer`)。"

#: ../../whatsnew/3.0.rst:626
#, fuzzy
msgid ""
"Some other changes to standard library modules, not covered by :pep:`3108`:"
msgstr ":pep:`3108` 未涵蓋的標準庫模組的一些其他更改："

#: ../../whatsnew/3.0.rst:629
#, fuzzy
msgid "Killed :mod:`sets`.  Use the built-in :func:`set` class."
msgstr "殺死 :mod:`sets`。使用內建的 :func:`set` 類。"

#: ../../whatsnew/3.0.rst:631
#, fuzzy
msgid ""
"Cleanup of the :mod:`sys` module: removed :func:`sys.exitfunc`, :func:`sys."
"exc_clear`, :data:`sys.exc_type`, :data:`sys.exc_value`, :data:`sys."
"exc_traceback`.  (Note that :data:`sys.last_type` etc. remain.)"
msgstr ""
":mod:`sys` 模組的清理：刪除了 :func:`sys.exitfunc`, :func:`sys.exc_clear`, "
":data:`sys.exc_type`, :data:`sys.exc_value`, :data ：`sys.exc_traceback`。 "
"（請注意 :data:`sys.last_type` 等仍然存在。）"

#: ../../whatsnew/3.0.rst:636
#, fuzzy
msgid ""
"Cleanup of the :class:`array.array` type: the :meth:`read` and :meth:`write` "
"methods are gone; use :meth:`fromfile` and :meth:`tofile` instead.  Also, "
"the ``'c'`` typecode for array is gone -- use either ``'b'`` for bytes or "
"``'u'`` for Unicode characters."
msgstr ""
":class:`array.array` 型別的清理：:meth:`read` 和 :meth:`write` 方法消失了；"
"使用 :meth:`fromfile` 和 :meth:`tofile` 代替。此外，數組的 ``'c'`` "
"型別程式碼消失了——使用 ``'b'`` 表示位元組或 ``'u'`` 表示 Unicode 字元。"

#: ../../whatsnew/3.0.rst:642
#, fuzzy
msgid ""
"Cleanup of the :mod:`operator` module: removed :func:`sequenceIncludes` and :"
"func:`isCallable`."
msgstr ":mod:`operator` 模組的清理：刪除了 :func:`sequenceIncludes` "
"和 :func:`isCallable`。"

#: ../../whatsnew/3.0.rst:645
#, fuzzy
msgid ""
"Cleanup of the :mod:`thread` module: :func:`acquire_lock` and :func:"
"`release_lock` are gone; use :func:`acquire` and :func:`release` instead."
msgstr ""
":mod:`thread` 模組的清理：:func:`acquire_lock` 和 :func:`release_lock` "
"消失了；使用 :func:`acquire` 和 :func:`release` 代替。"

#: ../../whatsnew/3.0.rst:649
#, fuzzy
msgid "Cleanup of the :mod:`random` module: removed the :func:`jumpahead` API."
msgstr ":mod:`random` 模組的清理：刪除了 :func:`jumpahead` API。"

#: ../../whatsnew/3.0.rst:651
#, fuzzy
msgid "The :mod:`new` module is gone."
msgstr ":mod:`new` 模組不見了。"

#: ../../whatsnew/3.0.rst:653
#, fuzzy
msgid ""
"The functions :func:`os.tmpnam`, :func:`os.tempnam` and :func:`os.tmpfile` "
"have been removed in favor of the :mod:`tempfile` module."
msgstr ""
"函式 :func:`os.tmpnam`、:func:`os.tempnam` 和 :func:`os.tmpfile` "
"已被刪除以支援 :mod:`tempfile` 模組。"

#: ../../whatsnew/3.0.rst:657
#, fuzzy
msgid ""
"The :mod:`tokenize` module has been changed to work with bytes.  The main "
"entry point is now :func:`tokenize.tokenize`, instead of generate_tokens."
msgstr ""
":mod:`tokenize` 模組已更改為使用位元組。主要入口點現在是 :func:`tokenize."
"tokenize`，而不是 generate_tokens。"

#: ../../whatsnew/3.0.rst:661
#, fuzzy
msgid ""
":data:`string.letters` and its friends (:data:`string.lowercase` and :data:"
"`string.uppercase`) are gone.  Use :data:`string.ascii_letters` etc. "
"instead.  (The reason for the removal is that :data:`string.letters` and "
"friends had locale-specific behavior, which is a bad idea for such "
"attractively named global \"constants\".)"
msgstr ""
":data:`string.letters` 和它的朋友（:data:`string.lowercase` 和 :data:`string."
"uppercase`）都不見了。使用 :data:`string.ascii_letters` 等代替。 （"
"刪除的原因是 :data:`string.letters` 和朋友有特定於語言環境的行為，這對於這種"
"有吸引力的命名全局“常數”來說是個壞主意。）"

#: ../../whatsnew/3.0.rst:668
#, fuzzy
msgid ""
"Renamed module :mod:`__builtin__` to :mod:`builtins` (removing the "
"underscores, adding an 's').  The :data:`__builtins__` variable found in "
"most global namespaces is unchanged.  To modify a builtin, you should use :"
"mod:`builtins`, not :data:`__builtins__`!"
msgstr ""
"將模組 :mod:`__builtin__` 重命名為 :mod:`builtins`（刪除底線，新增 ``s``）。"
"大多數全局命名空間中的 :data:`__builtins__` 變數沒有改變。要修改內建函式，"
"您應該使用 :mod:`builtins`，而不是 :data:`__builtins__`！"

#: ../../whatsnew/3.0.rst:675
#, fuzzy
msgid ":pep:`3101`: A New Approach To String Formatting"
msgstr ":pep:`3101`: 一種新的字串格式化方法"

#: ../../whatsnew/3.0.rst:677
#, fuzzy
msgid ""
"A new system for  built-in string formatting operations replaces the ``%`` "
"string  formatting operator.   (However, the ``%``  operator is still "
"supported;  it will  be deprecated in  Python 3.1  and removed from the "
"language at some later time.)  Read :pep:`3101` for the full scoop."
msgstr ""
"一個用於內建字串格式化操作的新系統取代了 ``%``字串格式化操作符。 （但是，``%`` "
"運算符仍然受支援；它將在 Python 3.1 "
"中被棄用，並在稍後的某個時間從語言中刪除。）閱讀 :pep:`3101` "
"以獲得完整的獨家新聞。"

#: ../../whatsnew/3.0.rst:685
#, fuzzy
msgid "Changes To Exceptions"
msgstr "例外變化"

#: ../../whatsnew/3.0.rst:687
#, fuzzy
msgid ""
"The APIs for raising and catching exception have been cleaned up and new "
"powerful features added:"
msgstr "用於引發和捕獲例外的 API 已被清理並新增了新的強大功能："

#: ../../whatsnew/3.0.rst:690
#, fuzzy
msgid ""
":pep:`352`: All exceptions must be derived (directly or indirectly) from :"
"exc:`BaseException`.  This is the root of the exception hierarchy.  This is "
"not new as a recommendation, but the *requirement* to inherit from :exc:"
"`BaseException` is new.  (Python 2.6 still allowed classic classes to be "
"raised, and placed no restriction on what you can catch.)  As a consequence, "
"string exceptions are finally truly and utterly dead."
msgstr ""
":pep:`352`: 所有例外都必須（直接或間接）從 :exc:`BaseException` "
"派生。這是例外層次結構的根。這不是新的建議，但是從 :exc:`BaseException` "
"繼承的 *requirement* 是新的。 （Python 2.6 仍然允許引發經典類，並且對您可以捕"
"獲的內容沒有任何限制。）因此，字串例外最終真正徹底地消亡了。"

#: ../../whatsnew/3.0.rst:698
#, fuzzy
msgid ""
"Almost all exceptions should actually derive from :exc:`Exception`; :exc:"
"`BaseException` should only be used as a base class for exceptions that "
"should only be handled at the top level, such as :exc:`SystemExit` or :exc:"
"`KeyboardInterrupt`.  The recommended idiom for handling all exceptions "
"except for this latter category is to use :keyword:`except` :exc:`Exception`."
msgstr ""
"幾乎所有例外實際上都應該派生自 :exc:`Exception`; :exc:`BaseException` "
"應僅用作僅應在頂層處理的例外的基底類別，例如 :exc:`SystemExit` 或 :exc:`Keybo"
"ardInterrupt`。推薦用於處理除後一類之外的所有例外的習慣用法是使用 :keyword:`e"
"xcept` :exc:`Exception`。"

#: ../../whatsnew/3.0.rst:705
msgid ":exc:`StandardError` was removed."
msgstr ":exc:`StandardError` 被移除。"

#: ../../whatsnew/3.0.rst:707
#, fuzzy
msgid ""
"Exceptions no longer behave as sequences.  Use the :attr:`args` attribute "
"instead."
msgstr "例外不再表現為序列。請改用 :attr:`args` 屬性。"

#: ../../whatsnew/3.0.rst:710
#, fuzzy
msgid ""
":pep:`3109`: Raising exceptions.  You must now use :samp:`raise {Exception}"
"({args})` instead of :samp:`raise {Exception}, {args}`. Additionally, you "
"can no longer explicitly specify a traceback; instead, if you *have* to do "
"this, you can assign directly to the :attr:`__traceback__` attribute (see "
"below)."
msgstr ""
":pep:`3109`: 引發例外。您現在必須使用 :samp:`raise {Exception}({args})` "
"而不是 :samp:`raise {Exception}, "
"{args}`。此外，您不能再明確指定回溯；相反，如果你*必須*這樣做，"
"你可以直接分配給 :attr:`__traceback__` 屬性（見下文）。"

#: ../../whatsnew/3.0.rst:716
#, fuzzy
msgid ""
":pep:`3110`: Catching exceptions.  You must now use :samp:`except "
"{SomeException} as {variable}` instead of :samp:`except {SomeException}, "
"{variable}`.  Moreover, the *variable* is explicitly deleted when the :"
"keyword:`except` block is left."
msgstr ""
":pep:`3110`: 捕獲例外。您現在必須使用 :samp:`except {SomeException} 作為 "
"{variable}` 而不是 :samp:`except {SomeException}, {variable}`。此外，當 "
":keyword:`except` 塊被保留時，*變數* 被顯式刪除。"

#: ../../whatsnew/3.0.rst:722
#, fuzzy
msgid ""
":pep:`3134`: Exception chaining.  There are two cases: implicit chaining and "
"explicit chaining.  Implicit chaining happens when an exception is raised in "
"an :keyword:`except` or :keyword:`finally` handler block.  This usually "
"happens due to a bug in the handler block; we call this a *secondary* "
"exception.  In this case, the original exception (that was being handled) is "
"saved as the :attr:`__context__` attribute of the secondary exception. "
"Explicit chaining is invoked with this syntax::"
msgstr ""
":pep:`3134`: 例外鏈接。有兩種情況：隱式鏈接和顯式鏈接。當在 :keyword:`except`"
" 或 :keyword:`finally` 處理程式塊中引發例外時，會發生隱式鏈接。這通常是由於處"
"理程式塊中的錯誤而發生的；我們稱之為*次要*例外。在這種情況下，原始例外（正在"
"處理）被保存為輔助例外的 :attr:`__context__` 屬性。使用以下語法呼叫顯式鏈接："

#: ../../whatsnew/3.0.rst:733
#, fuzzy
msgid ""
"(where *primary_exception* is any expression that produces an exception "
"object, probably an exception that was previously caught). In this case, the "
"primary exception is stored on the :attr:`__cause__` attribute of the "
"secondary exception.  The traceback printed when an unhandled exception "
"occurs walks the chain of :attr:`__cause__` and :attr:`__context__` "
"attributes and prints a separate traceback for each component of the chain, "
"with the primary exception at the top.  (Java users may recognize this "
"behavior.)"
msgstr ""
"（其中 *primary_exception* "
"是任何產生例外物件的表達式，可能是先前捕獲的例外）。在這種情況下，"
"主要例外儲存在次要例外的 :attr:`__cause__` 屬性中。"
"發生未處理例外時印出的回溯遍歷 :attr:`__cause__` 和 :attr:`__context__` "
"屬性鏈，並為鏈的每個組件印出單獨的回溯，主要例外位於頂部。 （Java "
"使用者可能會識別這種行為。）"

#: ../../whatsnew/3.0.rst:742
#, fuzzy
msgid ""
":pep:`3134`: Exception objects now store their traceback as the :attr:"
"`__traceback__` attribute.  This means that an exception object now contains "
"all the information pertaining to an exception, and there are fewer reasons "
"to use :func:`sys.exc_info` (though the latter is not removed)."
msgstr ""
":pep:`3134`: Exception 物件現在將它們的回溯儲存為 :attr:`__traceback__` "
"屬性。這意味著例外物件現在包含與例外有關的所有資訊，並且使用 :func:`sys."
"exc_info` 的理由更少（儘管後者未被刪除）。"

#: ../../whatsnew/3.0.rst:748
#, fuzzy
msgid ""
"A few exception messages are improved when Windows fails to load an "
"extension module.  For example, ``error code 193`` is now ``%1 is not a "
"valid Win32 application``.  Strings now deal with non-English locales."
msgstr ""
"當 Windows 無法加載擴充模組時，一些例外消息得到改進。例如，“錯誤程式碼 "
"193”現在是“%1 不是有效的 Win32 應用程式”。字串現在處理非英語語言環境。"

#: ../../whatsnew/3.0.rst:755
#, fuzzy
msgid "Miscellaneous Other Changes"
msgstr "雜項其他變化"

#: ../../whatsnew/3.0.rst:758
#, fuzzy
msgid "Operators And Special Methods"
msgstr "運算符和特殊方法"

#: ../../whatsnew/3.0.rst:760
#, fuzzy
msgid ""
"``!=`` now returns the opposite of ``==``, unless ``==`` returns :data:"
"`NotImplemented`."
msgstr "``!=`` 現在回傳 ``==`` 的反義詞，除非 ``==`` 回傳 :data:`NotImplemented`。"

#: ../../whatsnew/3.0.rst:763
#, fuzzy
msgid ""
"The concept of \"unbound methods\" has been removed from the language. When "
"referencing a method as a class attribute, you now get a plain function "
"object."
msgstr "“未綁定方法”的概念已從語言中刪除。當引用一個方法作為類屬性時，您現在得到一個"
"普通的函式物件。"

#: ../../whatsnew/3.0.rst:767
#, fuzzy
msgid ""
":meth:`__getslice__`, :meth:`__setslice__` and :meth:`__delslice__` were "
"killed.  The syntax ``a[i:j]`` now translates to ``a.__getitem__(slice(i, "
"j))`` (or :meth:`__setitem__` or :meth:`__delitem__`, when used as an "
"assignment or deletion target, respectively)."
msgstr ""
":meth:`__getslice__`、:meth:`__setslice__` 和 :meth:`__delslice__` 被殺死。"
"語法 ``a[i:j]`` 現在轉換為 ``a.__getitem__(slice(i, "
"j))``分配或刪除目標，分別）。"

#: ../../whatsnew/3.0.rst:773
#, fuzzy
msgid ""
":pep:`3114`: the standard :meth:`next` method has been renamed to :meth:"
"`~iterator.__next__`."
msgstr ":pep:`3114`: 標準 :meth:`next` 方法已重命名為 :meth:`~iterator.__next__`。"

#: ../../whatsnew/3.0.rst:776
#, fuzzy
msgid ""
"The :meth:`__oct__` and :meth:`__hex__` special methods are removed -- :func:"
"`oct` and :func:`hex` use :meth:`__index__` now to convert the argument to "
"an integer."
msgstr ""
":meth:`__oct__` 和 :meth:`__hex__` 特殊方法已被刪除 -- :func:`oct` 和 "
":func:`hex` 現在使用 :meth:`__index__` 將參數轉換為整數。"

#: ../../whatsnew/3.0.rst:780
#, fuzzy
msgid "Removed support for :attr:`__members__` and :attr:`__methods__`."
msgstr "刪除了對 :attr:`__members__` 和 :attr:`__methods__` 的支援。"

#: ../../whatsnew/3.0.rst:782
#, fuzzy
msgid ""
"The function attributes named :attr:`func_X` have been renamed to use the :"
"data:`__X__` form, freeing up these names in the function attribute "
"namespace for user-defined attributes.  To wit, :attr:`func_closure`, :attr:"
"`func_code`, :attr:`func_defaults`, :attr:`func_dict`, :attr:`func_doc`, :"
"attr:`func_globals`, :attr:`func_name` were renamed to :attr:`__closure__`, :"
"attr:`__code__`, :attr:`__defaults__`, :attr:`~object.__dict__`, :attr:"
"`__doc__`, :attr:`__globals__`, :attr:`~definition.__name__`, respectively."
msgstr ""
"名為 :attr:`func_X` 的函式屬性已重命名為使用 :data:`__X__` 形式，從而在函式屬"
"性命名空間中為使用者定義的屬性釋放這些名稱。也就是說，:attr:`func_closure`, "
":attr:`func_code`, :attr:`func_defaults`, :attr:`func_dict`, :attr:`func_doc`"
", :attr:`func_globals`, :attr:`func_name ` 重命名為 :attr:`__closure__`, "
":attr:`__code__`, :attr:`__defaults__`, :attr:`~object.__dict__`, "
":attr:`__doc__`, :attr:`__globals__`, : attr:`~definition.__name__`，分別。"

#: ../../whatsnew/3.0.rst:792
msgid ":meth:`__nonzero__` is now :meth:`__bool__`."
msgstr ":meth:`__nonzero__` 現在為 :meth:`__bool__`\\ 。"

#: ../../whatsnew/3.0.rst:795
#, fuzzy
msgid "Builtins"
msgstr "內建"

#: ../../whatsnew/3.0.rst:797
#, fuzzy
msgid ""
":pep:`3135`: New :func:`super`.  You can now invoke :func:`super` without "
"arguments and (assuming this is in a regular instance method defined inside "
"a :keyword:`class` statement) the right class and instance will "
"automatically be chosen.  With arguments, the behavior of :func:`super` is "
"unchanged."
msgstr ""
":pep:`3135`: 新的 :func:`super`。您現在可以不帶參數呼叫 :func:`super` 並且（"
"假設這是在 :keyword:`class` "
"語句內定義的常規實例方法中）將自動選擇正確的類和實例。有了參數， "
":func:`super` 的行為沒有改變。"

#: ../../whatsnew/3.0.rst:803
#, fuzzy
msgid ""
":pep:`3111`: :func:`raw_input` was renamed to :func:`input`.  That is, the "
"new :func:`input` function reads a line from :data:`sys.stdin` and returns "
"it with the trailing newline stripped. It raises :exc:`EOFError` if the "
"input is terminated prematurely. To get the old behavior of :func:`input`, "
"use ``eval(input())``."
msgstr ""
":pep:`3111`: :func:`raw_input` 重命名為 :func:`input`。也就是說，新的 "
":func:`input` 函式從 :data:`sys.stdin` "
"讀取一行並回傳它，並去除尾隨換行符。如果輸入過早終止，它會引發 "
":exc:`EOFError`。要獲得 :func:`input` 的舊行為，請使用 ``eval(input())``。"

#: ../../whatsnew/3.0.rst:809
#, fuzzy
msgid ""
"A new built-in function :func:`next` was added to call the :meth:`~iterator."
"__next__` method on an object."
msgstr "新增了一個新的內建函式 :func:`next` 來呼叫物件的 :meth:`~iterator.__next__` "
"方法。"

#: ../../whatsnew/3.0.rst:812
#, fuzzy
msgid ""
"The :func:`round` function rounding strategy and return type have changed.  "
"Exact halfway cases are now rounded to the nearest even result instead of "
"away from zero.  (For example, ``round(2.5)`` now returns ``2`` rather than "
"``3``.)  ``round(x[, n])`` now delegates to ``x.__round__([n])`` instead of "
"always returning a float.  It generally returns an integer when called with "
"a single argument and a value of the same type as ``x`` when called with two "
"arguments."
msgstr ""
":func:`round` 函式舍入策略和回傳型別已更改。精確的中途案例現在四捨五入到最接"
"近的偶數結果，而不是遠離零。 （例如，``round(2.5)`` 現在回傳``2`` "
"而不是``3``。）``round(x[, n])`` 現在委託給``x.__round__([ n])`` 而不是總是回"
"傳一個浮點數。它通常在使用單個參數呼叫時回傳一個整數，在使用兩個參數呼叫時回"
"傳與 ``x``相同型別的值。"

#: ../../whatsnew/3.0.rst:821
#, fuzzy
msgid "Moved :func:`intern` to :func:`sys.intern`."
msgstr "將 :func:`intern` 移動到 :func:`sys.intern`。"

#: ../../whatsnew/3.0.rst:823
#, fuzzy
msgid ""
"Removed: :func:`apply`.  Instead of ``apply(f, args)`` use ``f(*args)``."
msgstr "刪除：:func:`apply`。而不是 ``apply(f, args)`` 使用 ``f(*args)``。"

#: ../../whatsnew/3.0.rst:826
#, fuzzy
msgid ""
"Removed :func:`callable`.  Instead of ``callable(f)`` you can use "
"``isinstance(f, collections.Callable)``.  The :func:`operator.isCallable` "
"function is also gone."
msgstr ""
"刪除 :func:`可呼叫`。你可以使用 isinstance(f, collections.Callable) 而不是 "
"``callable(f)``。 :func:`operator.isCallable` 函式也消失了。"

#: ../../whatsnew/3.0.rst:830
#, fuzzy
msgid ""
"Removed :func:`coerce`.  This function no longer serves a purpose now that "
"classic classes are gone."
msgstr "刪除 :func:`coerce`。既然經典課程已經消失，這個功能就不再有用了。"

#: ../../whatsnew/3.0.rst:833
#, fuzzy
msgid ""
"Removed :func:`execfile`.  Instead of ``execfile(fn)`` use ``exec(open(fn)."
"read())``."
msgstr "刪除 :func:`execfile`。而不是 ``execfile(fn)`` 使用 ``exec(open(fn)."
"read())``。"

#: ../../whatsnew/3.0.rst:836
#, fuzzy
msgid ""
"Removed the :class:`file` type.  Use :func:`open`.  There are now several "
"different kinds of streams that open can return in the :mod:`io` module."
msgstr "刪除了 :class:`file` 型別。使用 :func:`open`。現在有幾種不同型別的流可以在 "
":mod:`io` 模組中回傳。"

#: ../../whatsnew/3.0.rst:839
#, fuzzy
msgid ""
"Removed :func:`reduce`.  Use :func:`functools.reduce` if you really need it; "
"however, 99 percent of the time an explicit :keyword:`for` loop is more "
"readable."
msgstr ""
"移除 :func:`reduce`。如果確實需要，請使用 func:`functools.reduce`；但是，在 "
"99% 的情況下，顯式 for 循環更具可讀性。"

#: ../../whatsnew/3.0.rst:843
msgid "Removed :func:`reload`.  Use :func:`imp.reload`."
msgstr "刪除 :func:`reload`。使用 :func:`imp.reload`。"

#: ../../whatsnew/3.0.rst:845
#, fuzzy
msgid ""
"Removed. :meth:`dict.has_key` -- use the :keyword:`in` operator instead."
msgstr "刪除。 :meth:`dict.has_key` -- 使用 :keyword:`in` 運算符代替。"

#: ../../whatsnew/3.0.rst:852
msgid "Build and C API Changes"
msgstr "建置和 C API 更改"

#: ../../whatsnew/3.0.rst:854
#, fuzzy
msgid ""
"Due to time constraints, here is a *very* incomplete list of changes to the "
"C API."
msgstr "由於時間限制，這裡是一個*非常*不完整的 C API 更改列表。"

#: ../../whatsnew/3.0.rst:857
#, fuzzy
msgid ""
"Support for several platforms was dropped, including but not limited to Mac "
"OS 9, BeOS, RISCOS, Irix, and Tru64."
msgstr "取消了對多個平台的支援，包括但不限於 Mac OS 9、BeOS、RISCOS、Irix 和 Tru64。"

#: ../../whatsnew/3.0.rst:860
msgid ":pep:`3118`: New Buffer API."
msgstr ":pep:`3118`: 新的緩衝區 API。"

#: ../../whatsnew/3.0.rst:862
msgid ":pep:`3121`: Extension Module Initialization & Finalization."
msgstr ":pep:`3121`：擴充模組初始化和完成。"

#: ../../whatsnew/3.0.rst:864
#, fuzzy
msgid ":pep:`3123`: Making :c:macro:`PyObject_HEAD` conform to standard C."
msgstr ":pep:`3123`: 使 :c:macro:`PyObject_HEAD` 符合標準 C。"

#: ../../whatsnew/3.0.rst:866
#, fuzzy
msgid "No more C API support for restricted execution."
msgstr "不再支援受限執行的 C API。"

#: ../../whatsnew/3.0.rst:868
#, fuzzy
msgid ""
":c:func:`PyNumber_Coerce`, :c:func:`PyNumber_CoerceEx`, :c:func:"
"`PyMember_Get`, and :c:func:`PyMember_Set` C APIs are removed."
msgstr ""
":c:func:`PyNumber_Coerce`、:c:func:`PyNumber_CoerceEx`、:c:func:`PyMember_Get"
"` 和:c:func:`PyMember_Set` C API 已刪除。"

#: ../../whatsnew/3.0.rst:871
#, fuzzy
msgid ""
"New C API :c:func:`PyImport_ImportModuleNoBlock`, works like :c:func:"
"`PyImport_ImportModule` but won't block on the import lock (returning an "
"error instead)."
msgstr ""
"新的 C API :c:func:`PyImport_ImportModuleNoBlock`，工作方式類似於 "
":c:func:`PyImport_ImportModule` 但不會阻塞導入鎖（而是回傳錯誤）。"

#: ../../whatsnew/3.0.rst:875
#, fuzzy
msgid ""
"Renamed the boolean conversion C-level slot and method: ``nb_nonzero`` is "
"now ``nb_bool``."
msgstr "重命名布爾轉換 C 級槽和方法：``nb_nonzero`` 現在是 ``nb_bool``。"

#: ../../whatsnew/3.0.rst:878
#, fuzzy
msgid ""
"Removed :c:macro:`METH_OLDARGS` and :c:macro:`WITH_CYCLE_GC` from the C API."
msgstr "從 C API 中刪除了 :c:macro:`METH_OLDARGS` 和 :c:macro:`WITH_CYCLE_GC`。"

#: ../../whatsnew/3.0.rst:884
#, fuzzy
msgid "Performance"
msgstr "表現"

#: ../../whatsnew/3.0.rst:886
#, fuzzy
msgid ""
"The net result of the 3.0 generalizations is that Python 3.0 runs the "
"pystone benchmark around 10% slower than Python 2.5.  Most likely the "
"biggest cause is the removal of special-casing for small integers. There's "
"room for improvement, but it will happen after 3.0 is released!"
msgstr ""
"3.0 概括的最終結果是 Python 3.0 運行 pystone 基準測試比 Python 2.5 慢 10% "
"左右。最有可能的最大原因是移除了小整數的特殊大小寫。有改進的餘地，但3."
"0發布後會發生！"

#: ../../whatsnew/3.0.rst:896
#, fuzzy
msgid "Porting To Python 3.0"
msgstr "移植到 Python 3.0"

#: ../../whatsnew/3.0.rst:898
#, fuzzy
msgid ""
"For porting existing Python 2.5 or 2.6 source code to Python 3.0, the best "
"strategy is the following:"
msgstr "要將現有的 Python 2.5 或 2.6 源程式碼移植到 Python 3.0，最佳策略如下："

#: ../../whatsnew/3.0.rst:901
#, fuzzy
msgid "(Prerequisite:) Start with excellent test coverage."
msgstr "（先決條件：）從出色的測試覆蓋率開始。"

#: ../../whatsnew/3.0.rst:903
#, fuzzy
msgid ""
"Port to Python 2.6.  This should be no more work than the average port from "
"Python 2.x to Python 2.(x+1).  Make sure all your tests pass."
msgstr "移植到 Python 2.6。這應該不會比從 Python 2.x 到 Python 2.(x+1) "
"的平均端口更多。確保所有測試都通過。"

#: ../../whatsnew/3.0.rst:907
#, fuzzy
msgid ""
"(Still using 2.6:) Turn on the :option:`!-3` command line switch. This "
"enables warnings about features that will be removed (or change) in 3.0.  "
"Run your test suite again, and fix code that you get warnings about until "
"there are no warnings left, and all your tests still pass."
msgstr ""
"（仍在使用 2.6:) 打開 :option:`!-3` 命令列開關。這會啟用有關將在 3.0 中刪除（"
"或更改）的功能的警告。再次運行您的測試套件，並修復您收到警告的程式碼，直到沒"
"有警告，並且您的所有測試仍然通過。"

#: ../../whatsnew/3.0.rst:913
#, fuzzy
msgid ""
"Run the ``2to3`` source-to-source translator over your source code tree.  "
"(See :ref:`2to3-reference` for more on this tool.)  Run the result of the "
"translation under Python 3.0.  Manually fix up any remaining issues, fixing "
"problems until all tests pass again."
msgstr ""
"在源程式碼樹上運行 ``2to3`` 源到源轉換器。 （有關此工具的更多資訊，請參閱 "
":ref:`2to3-reference`。）在 Python 3.0 "
"下運行翻譯結果。手動修復所有遺留問題，修復問題，直到再次通過所有測試。"

#: ../../whatsnew/3.0.rst:918
#, fuzzy
msgid ""
"It is not recommended to try to write source code that runs unchanged under "
"both Python 2.6 and 3.0; you'd have to use a very contorted coding style, e."
"g. avoiding ``print`` statements, metaclasses, and much more.  If you are "
"maintaining a library that needs to support both Python 2.6 and Python 3.0, "
"the best approach is to modify step 3 above by editing the 2.6 version of "
"the source code and running the ``2to3`` translator again, rather than "
"editing the 3.0 version of the source code."
msgstr ""
"不建議嘗試編寫在 Python 2.6 和 3.0 "
"下都運行不變的源程式碼；您必須使用非常扭曲的編碼風格，例如避免 ``print`` "
"語句、元類等等。如果您正在維護一個需要同時支援 Python 2.6 和 Python 3.0 "
"的庫，最好的方法是通過編輯 2.6 版本的源程式碼並再次運行 ``2to3`` "
"轉換器來修改上面的步驟 3，而不是編輯3.0版本的源程式碼。"

#: ../../whatsnew/3.0.rst:927
#, fuzzy
msgid ""
"For porting C extensions to Python 3.0, please see :ref:`cporting-howto`."
msgstr "要將 C 擴充移植到 Python 3.0，請參閱 :ref:`cporting-howto`。"
