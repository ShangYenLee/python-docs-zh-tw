# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-06 00:23+0000\n"
"PO-Revision-Date: 2018-05-23 16:19+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/2.3.rst:3
msgid "What's New in Python 2.3"
msgstr "Python 2.3 有什麼新功能"

#: ../../whatsnew/2.3.rst:0
msgid "Author"
msgstr "作者"

#: ../../whatsnew/2.3.rst:5
msgid "A.M. Kuchling"
msgstr "A.M. Kuchling"

#: ../../whatsnew/2.3.rst:11
#, fuzzy
msgid ""
"This article explains the new features in Python 2.3.  Python 2.3 was "
"released on July 29, 2003."
msgstr "本文介紹了 Python 2.3 中的新功能。 Python 2.3 於 2003 年 7 月 29 日發布。"

#: ../../whatsnew/2.3.rst:14
#, fuzzy
msgid ""
"The main themes for Python 2.3 are polishing some of the features added in "
"2.2, adding various small but useful enhancements to the core language, and "
"expanding the standard library.  The new object model introduced in the "
"previous version has benefited from 18 months of bugfixes and from "
"optimization efforts that have improved the performance of new-style "
"classes.  A few new built-in functions have been added such as :func:`sum` "
"and :func:`enumerate`.  The :keyword:`in` operator can now be used for "
"substring searches (e.g. ``\"ab\" in \"abc\"`` returns :const:`True`)."
msgstr ""
"Python 2.3 的主要主題是完善 2.2 "
"中新增的一些功能，為核心語言新增各種小而有用的增強功能，以及擴充標準庫。"
"上一版本中引入的新對像模型受益於 18 "
"個月的錯誤修復和改進新型類性能的最佳化工作。新增了一些新的內建函式，例如 "
":func:`sum` 和 :func:`enumerate`。 :keyword:`in` "
"運算符現在可用於子字串搜索（例如，``\"ab\" in \"abc\"`` 回傳 "
":const:`True`）。"

#: ../../whatsnew/2.3.rst:23
#, fuzzy
msgid ""
"Some of the many new library features include Boolean, set, heap, and date/"
"time data types, the ability to import modules from ZIP-format archives, "
"metadata support for the long-awaited Python catalog, an updated version of "
"IDLE, and modules for logging messages, wrapping text, parsing CSV files, "
"processing command-line options, using BerkeleyDB databases...  the list of "
"new and enhanced modules is lengthy."
msgstr ""
"許多新庫功能中的一些包括布爾、集合、堆和日期/時間資料型別，從 ZIP "
"格式存檔導入模組的能力，對期待已久的 Python 目錄的元資料支援，IDLE "
"的更新版本和模組用於記錄消息、包裝文本、解析 CSV 文件、處理命令列選項、使用 "
"BerkeleyDB 資料庫……新模組和增強模組的列表很長。"

#: ../../whatsnew/2.3.rst:30
#, fuzzy
msgid ""
"This article doesn't attempt to provide a complete specification of the new "
"features, but instead provides a convenient overview.  For full details, you "
"should refer to the documentation for Python 2.3, such as the Python Library "
"Reference and the Python Reference Manual.  If you want to understand the "
"complete implementation and design rationale, refer to the PEP for a "
"particular new feature."
msgstr ""
"本文並不試圖提供新功能的完整規範，而是提供一個方便的概述。有關完整的詳細資訊"
"，您應該參考 Python 2.3 的文檔，例如 Python Library Reference 和 Python "
"Reference Manual。如果您想了解完整的實作和設計原理，請參閱特定新功能的 PEP。"

#: ../../whatsnew/2.3.rst:41
#, fuzzy
msgid "PEP 218: A Standard Set Datatype"
msgstr "PEP 218：標準集資料型別"

#: ../../whatsnew/2.3.rst:43
#, fuzzy
msgid ""
"The new :mod:`sets` module contains an implementation of a set datatype.  "
"The :class:`Set` class is for mutable sets, sets that can have members added "
"and removed.  The :class:`ImmutableSet` class is for sets that can't be "
"modified, and instances of :class:`ImmutableSet` can therefore be used as "
"dictionary keys. Sets are built on top of dictionaries, so the elements "
"within a set must be hashable."
msgstr ""
"新的 :mod:`sets` 模組包含一個 set 資料型別的實作。 :class:`Set` "
"類用於可變集，可以新增和刪除成員的集。 :class:`ImmutableSet` "
"類用於無法修改的集合，因此 :class:`ImmutableSet` "
"的實例可以用作字典鍵。集合建立在字典之上，因此集合中的元素必須是可散列的。"

#: ../../whatsnew/2.3.rst:50
msgid "Here's a simple example::"
msgstr ""
"以下是個簡單範例：\n"
"\n"
"::"

#: ../../whatsnew/2.3.rst:66
#, fuzzy
msgid ""
"The union and intersection of sets can be computed with the :meth:`union` "
"and :meth:`intersection` methods; an alternative notation uses the bitwise "
"operators ``&`` and ``|``. Mutable sets also have in-place versions of these "
"methods, :meth:`union_update` and :meth:`intersection_update`. ::"
msgstr ""
"集合的並集和交集可以用 union 和 intersection 方法計算；另一種表示法使用按位運"
"算符 ``&``和 ``|``。可變集也有這些方法的就地版本，:meth:`union_update` "
"和 :meth:`intersection_update`。 ::"

#: ../../whatsnew/2.3.rst:86
#, fuzzy
msgid ""
"It's also possible to take the symmetric difference of two sets.  This is "
"the set of all elements in the union that aren't in the intersection.  "
"Another way of putting it is that the symmetric difference contains all "
"elements that are in exactly one set.  Again, there's an alternative "
"notation (``^``), and an in-place version with the ungainly name :meth:"
"`symmetric_difference_update`. ::"
msgstr ""
"也可以取兩組的對稱差。這是並集中所有不在交集中的元素的集合。另一種表達方式是"
"，對稱差包含恰好位於一個集合中的所有元素。同樣，還有一個替代符號（``^``）"
"和一個名稱笨拙的就地版本 :meth:`symmetric_difference_update`。 ::"

#: ../../whatsnew/2.3.rst:100
#, fuzzy
msgid ""
"There are also :meth:`issubset` and :meth:`issuperset` methods for checking "
"whether one set is a subset or superset of another::"
msgstr "還有 :meth:`issubset` 和 :meth:`issuperset` "
"方法用於檢查一個集合是另一個集合的子集還是超集::"

#: ../../whatsnew/2.3.rst:117
#, fuzzy
msgid ":pep:`218` - Adding a Built-In Set Object Type"
msgstr ":pep:`218` - 新增內建的集合對像型別"

#: ../../whatsnew/2.3.rst:117
#, fuzzy
msgid ""
"PEP written by Greg V. Wilson. Implemented by Greg V. Wilson, Alex Martelli, "
"and GvR."
msgstr "PEP 由 Greg V. Wilson 撰寫。由 Greg V. Wilson、Alex Martelli 和 GvR 實施。"

#: ../../whatsnew/2.3.rst:126
#, fuzzy
msgid "PEP 255: Simple Generators"
msgstr "PEP 255：簡單生成器"

#: ../../whatsnew/2.3.rst:128
#, fuzzy
msgid ""
"In Python 2.2, generators were added as an optional feature, to be enabled "
"by a ``from __future__ import generators`` directive.  In 2.3 generators no "
"longer need to be specially enabled, and are now always present; this means "
"that :keyword:`yield` is now always a keyword.  The rest of this section is "
"a copy of the description of generators from the \"What's New in Python "
"2.2\" document; if you read it back when Python 2.2 came out, you can skip "
"the rest of this section."
msgstr ""
"在 Python 2.2 中，生成器作為可選功能新增，由“from __future__ import "
"generators”指令啟用。在 2.3 中，生成器不再需要特別啟用，並且現在始終存在；"
"這意味著 :keyword:`yield` 現在始終是關鍵字。本節的其餘部分是“What's New in "
"Python 2.2”文檔中生成器描述的副本；如果您在 Python 2.2 "
"發佈時回頭閱讀它，則可以跳過本節的其餘部分。"

#: ../../whatsnew/2.3.rst:136
#, fuzzy
msgid ""
"You're doubtless familiar with how function calls work in Python or C. When "
"you call a function, it gets a private namespace where its local variables "
"are created.  When the function reaches a :keyword:`return` statement, the "
"local variables are destroyed and the resulting value is returned to the "
"caller.  A later call to the same function will get a fresh new set of local "
"variables. But, what if the local variables weren't thrown away on exiting a "
"function? What if you could later resume the function where it left off?  "
"This is what generators provide; they can be thought of as resumable "
"functions."
msgstr ""
"您無疑熟悉函式呼叫在 Python 或 C 中的工作方式。當您呼叫一個函式時，它會獲得一"
"個私有名稱空間，在該名稱空間中建立了它的局部變數。當函式到達 :keyword:`return`"
" 語句時，局部變數將被銷毀並將結果值回傳給呼叫者。稍後呼叫同一函式將獲得一組全"
"新的局部變數。但是，如果局部變數在退出函式時沒有被丟棄怎麼辦？如果您稍後可以"
"在它停止的地方恢復功能怎麼辦？這就是生成器提供的；它們可以被認為是可恢復的功"
"能。"

#: ../../whatsnew/2.3.rst:145
#, fuzzy
msgid "Here's the simplest example of a generator function::"
msgstr "這是生成器函式的最簡單示例："

#: ../../whatsnew/2.3.rst:151
#, fuzzy
msgid ""
"A new keyword, :keyword:`yield`, was introduced for generators.  Any "
"function containing a :keyword:`!yield` statement is a generator function; "
"this is detected by Python's bytecode compiler which compiles the function "
"specially as a result."
msgstr ""
"為生成器引入了一個新關鍵字 :keyword:`yield`。任何包含 :keyword:`!yield` "
"語句的函式都是生成器函式；這是由 Python "
"的位元組碼編譯器檢測到的，它會專門編譯該函式作為結果。"

#: ../../whatsnew/2.3.rst:156
#, fuzzy
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the :keyword:`yield` statement, the generator outputs the value "
"of ``i``, similar to a :keyword:`return` statement.  The big difference "
"between :keyword:`!yield` and a :keyword:`!return` statement is that on "
"reaching a :keyword:`!yield` the generator's state of execution is suspended "
"and local variables are preserved.  On the next call to the generator's ``."
"next()`` method, the function will resume executing immediately after the :"
"keyword:`!yield` statement.  (For complicated reasons, the :keyword:`!yield` "
"statement isn't allowed inside the :keyword:`try` block of a :keyword:`!"
"try`...\\ :keyword:`!finally` statement; read :pep:`255` for a full "
"explanation of the interaction between :keyword:`!yield` and exceptions.)"
msgstr ""
"當您呼叫生成器函式時，它不會回傳單個值；相反，它回傳一個支援疊代器協定的生成"
"器物件。在執行 :keyword:`yield` 語句時，生成器輸出 ``i`` 的值，類似於 "
":keyword:`return` 語句。 :keyword:`!yield` 和 :keyword:`!return` "
"語句之間的最大區別在於，在到達 :keyword:`!yield` "
"時，生成器的執行狀態被掛起並保留局部變數。在下一次呼叫生成器的 ``.next()`` "
"方法時，該函式將在 :keyword:`!yield` 語句之後立即恢復執行。 "
"（由於復雜的原因，:keyword:`!yield` 語句不允許在 :keyword:`!try`...\\ "
":keyword:`!finally` 語句的 :keyword:`try` 塊內；閱讀 :pep:`255` 以獲得 "
":keyword:`!yield` 和例外之間相互作用的完整解釋。）"

#: ../../whatsnew/2.3.rst:169
#, fuzzy
msgid "Here's a sample usage of the :func:`generate_ints` generator::"
msgstr "以下是 :func:`generate_ints` 生成器的示例用法："

#: ../../whatsnew/2.3.rst:186
#, fuzzy
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a,b,c = "
"generate_ints(3)``."
msgstr "你同樣可以寫 ``for i in generate_ints(5)`` 或 ``a,b,c = generate_ints(3)``。"

#: ../../whatsnew/2.3.rst:189
#, fuzzy
msgid ""
"Inside a generator function, the :keyword:`return` statement can only be "
"used without a value, and signals the end of the procession of values; "
"afterwards the generator cannot return any further values. :keyword:`!"
"return` with a value, such as ``return 5``, is a syntax error inside a "
"generator function.  The end of the generator's results can also be "
"indicated by raising :exc:`StopIteration` manually, or by just letting the "
"flow of execution fall off the bottom of the function."
msgstr ""
"在生成器函式中，:keyword:`return` 語句只能在沒有值的情況下使用，並表示值處理"
"的結束；之後生成器不能回傳任何進一步的值。 :keyword:`!return` 帶有一個值，"
"例如 ``return 5``，是生成器函式內部的語法錯誤。"
"生成器結果的結束也可以通過手動提高 :exc:`StopIteration` "
"來指示，或者只是讓執行流從函式的底部掉下來。"

#: ../../whatsnew/2.3.rst:197
#, fuzzy
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`next` method increment "
"``self.count`` and return it. However, for a moderately complicated "
"generator, writing a corresponding class would be much messier. :file:`Lib/"
"test/test_generators.py` contains a number of more interesting examples.  "
"The simplest one implements an in-order traversal of a tree using generators "
"recursively. ::"
msgstr ""
"您可以通過編寫自己的類並將生成器的所有局部變數儲存為實例變數來手動實作生成器"
"的效果。例如，回傳一個整數列表可以通過將 ``self.count`` 設定為 0 來完成，"
"並讓 :meth:`next` 方法遞增 ``self.count`` "
"並回傳它。但是，對於一個中等複雜度的生成器，寫一個相應的類就麻煩多了。 "
":file:`Lib/test/test_generators.py` "
"包含許多更有趣的示例。最簡單的一個是遞迴地使用生成器實作樹的有序遍歷。 ::"

#: ../../whatsnew/2.3.rst:215
#, fuzzy
msgid ""
"Two other examples in :file:`Lib/test/test_generators.py` produce solutions "
"for the N-Queens problem (placing $N$ queens on an $NxN$ chess board so that "
"no queen threatens another) and the Knight's Tour (a route that takes a "
"knight to every square of an $NxN$ chessboard without visiting any square "
"twice)."
msgstr ""
":file:`Lib/test/test_generators.py` 中的另外兩個示例為 N 皇后問題（將 $N$ "
"皇后放在 $NxN$ 棋盤上，這樣就沒有皇后威脅到另一個）和 Knight's Tour（"
"a將馬帶到 $NxN$ 棋盤的每個方格而不訪問任何方格兩次的路線）。"

#: ../../whatsnew/2.3.rst:220
#, fuzzy
msgid ""
"The idea of generators comes from other programming languages, especially "
"Icon (https://www.cs.arizona.edu/icon/), where the idea of generators is "
"central.  In Icon, every expression and function call behaves like a "
"generator.  One example from \"An Overview of the Icon Programming Language"
"\" at https://www.cs.arizona.edu/icon/docs/ipd266.htm gives an idea of what "
"this looks like::"
msgstr ""
"生成器的想法來自其他編程語言，尤其是 Icon (https://www.cs.arizona.edu/icon/"
")，其中生成器的想法是核心。在 Icon "
"中，每個表達式和函式呼叫的行為都像一個生成器。 https://www.cs.arizona.edu/"
"icon/docs/ipd266.htm "
"上的“圖標編程語言概述”中的一個示例給出了這看起來像什麼的想法："

#: ../../whatsnew/2.3.rst:230
#, fuzzy
msgid ""
"In Icon the :func:`find` function returns the indexes at which the substring "
"\"or\" is found: 3, 23, 33.  In the :keyword:`if` statement, ``i`` is first "
"assigned a value of 3, but 3 is less than 5, so the comparison fails, and "
"Icon retries it with the second value of 23.  23 is greater than 5, so the "
"comparison now succeeds, and the code prints the value 23 to the screen."
msgstr ""
"在 Icon 中，:func:`find` 函式回傳找到子字串 \"or\" "
"的索引：3、23、33。在 :keyword:`if` 語句中，首先為 ``i`` 賦值3，但 3 小於 "
"5，因此比較失敗，Icon 將使用第二個值 23 重試。23 大於 5，因此現在比較成功，"
"並且程式碼將值 23 印出到屏幕。"

#: ../../whatsnew/2.3.rst:236
#, fuzzy
msgid ""
"Python doesn't go nearly as far as Icon in adopting generators as a central "
"concept.  Generators are considered part of the core Python language, but "
"learning or using them isn't compulsory; if they don't solve any problems "
"that you have, feel free to ignore them. One novel feature of Python's "
"interface as compared to Icon's is that a generator's state is represented "
"as a concrete object (the iterator) that can be passed around to other "
"functions or stored in a data structure."
msgstr ""
"在採用生成器作為中心概念方面，Python 遠不及 Icon。生成器被認為是核心 Python "
"語言的一部分，但學習或使用它們並不是強制性的；如果他們不能解決您遇到的任何問"
"題，請隨意忽略它們。與 Icon 相比，Python 界面的一個新穎特徵是生成器的狀態表示"
"為一個具體物件（疊代器），可以傳遞給其他函式或儲存在資料結構中。"

#: ../../whatsnew/2.3.rst:248
#, fuzzy
msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - 簡單的生成器"

#: ../../whatsnew/2.3.rst:248
#, fuzzy
msgid ""
"Written by Neil Schemenauer, Tim Peters, Magnus Lie Hetland.  Implemented "
"mostly by Neil Schemenauer and Tim Peters, with other fixes from the Python "
"Labs crew."
msgstr ""
"由 Neil Schenmauer、Tim Peters、Magnus Lie Hetland 撰寫。主要由 Neil "
"Schenmauer 和 Tim Peters 實施，其他修復來自 Python 實驗室工作人員。"

#: ../../whatsnew/2.3.rst:257
#, fuzzy
msgid "PEP 263: Source Code Encodings"
msgstr "PEP 263：源程式碼編碼"

#: ../../whatsnew/2.3.rst:259
#, fuzzy
msgid ""
"Python source files can now be declared as being in different character set "
"encodings.  Encodings are declared by including a specially formatted "
"comment in the first or second line of the source file.  For example, a "
"UTF-8 file can be declared with::"
msgstr ""
"Python 源文件現在可以聲明為不同的字元集編碼。通過在源文件的第一行或第二行中包"
"含特殊格式的註釋來聲明編碼。例如，一個 UTF-8 文件可以聲明為："

#: ../../whatsnew/2.3.rst:267
#, fuzzy
msgid ""
"Without such an encoding declaration, the default encoding used is 7-bit "
"ASCII. Executing or importing modules that contain string literals with 8-"
"bit characters and have no encoding declaration will result in a :exc:"
"`DeprecationWarning` being signalled by Python 2.3; in 2.4 this will be a "
"syntax error."
msgstr ""
"如果沒有這樣的編碼聲明，使用的預設編碼是 7 位 ASCII。執行或導入包含 8 "
"位字元字串文字且沒有編碼聲明的模組將導致 Python 2.3 發出 DeprecationWarning "
"信號；在 2.4 中，這將是一個語法錯誤。"

#: ../../whatsnew/2.3.rst:273
#, fuzzy
msgid ""
"The encoding declaration only affects Unicode string literals, which will be "
"converted to Unicode using the specified encoding.  Note that Python "
"identifiers are still restricted to ASCII characters, so you can't have "
"variable names that use characters outside of the usual alphanumerics."
msgstr ""
"編碼聲明只影響 Unicode 字串文字，它將使用指定的編碼轉換為 Unicode。請注意，"
"Python 標識符仍然僅限於 ASCII "
"字元，因此您不能擁有使用通常字母數字之外的字元的變數名。"

#: ../../whatsnew/2.3.rst:282
#, fuzzy
msgid ":pep:`263` - Defining Python Source Code Encodings"
msgstr ":pep:`263` - 定義 Python 源程式碼編碼"

#: ../../whatsnew/2.3.rst:282
#, fuzzy
msgid ""
"Written by Marc-André Lemburg and Martin von Löwis; implemented by Suzuki "
"Hisao and Martin von Löwis."
msgstr ""
"由 Marc-André Lemburg 和 Martin von Löwis 撰寫；由 Suzuki Hisao 和 Martin "
"von Löwis 實施。"

#: ../../whatsnew/2.3.rst:289
#, fuzzy
msgid "PEP 273: Importing Modules from ZIP Archives"
msgstr "PEP 273：從 ZIP 檔案導入模組"

#: ../../whatsnew/2.3.rst:291
#, fuzzy
msgid ""
"The new :mod:`zipimport` module adds support for importing modules from a "
"ZIP-format archive.  You don't need to import the module explicitly; it will "
"be automatically imported if a ZIP archive's filename is added to ``sys."
"path``. For example:"
msgstr ""
"新的 :mod:`zipimport` 模組增加了對從 ZIP "
"格式存檔導入模組的支援。您不需要顯式導入模組；如果將 ZIP "
"存檔的文件名新增到“sys.path”，它將自動導入。例如："

#: ../../whatsnew/2.3.rst:314
#, fuzzy
msgid ""
"An entry in ``sys.path`` can now be the filename of a ZIP archive. The ZIP "
"archive can contain any kind of files, but only files named :file:`\\*.py`, :"
"file:`\\*.pyc`, or :file:`\\*.pyo` can be imported.  If an archive only "
"contains :file:`\\*.py` files, Python will not attempt to modify the archive "
"by adding the corresponding :file:`\\*.pyc` file, meaning that if a ZIP "
"archive doesn't contain :file:`\\*.pyc` files, importing may be rather slow."
msgstr ""
"``sys.path`` 中的條目現在可以是 ZIP 存檔的文件名。 ZIP "
"存檔可以包含任何型別的文件，但只能導入名為 :file:`\\*.py`、:file:`\\*.pyc` "
"或 :file:`\\*.pyo` 的文件。如果存檔僅包含 :file:`\\*.py` 文件，Python "
"不會嘗試通過新增相應的 :file:`\\*.pyc` 文件來修改存檔，這意味著如果 ZIP "
"存檔不包含： file:`\\*.pyc` 文件，導入可能會很慢。"

#: ../../whatsnew/2.3.rst:321
#, fuzzy
msgid ""
"A path within the archive can also be specified to only import from a "
"subdirectory; for example, the path :file:`/tmp/example.zip/lib/` would only "
"import from the :file:`lib/` subdirectory within the archive."
msgstr ""
"存檔中的路徑也可以指定為僅從子目錄導入；例如，路徑 :file:`/tmp/example.zip/"
"lib/` 只會從存檔中的 :file:`lib/` 子目錄導入。"

#: ../../whatsnew/2.3.rst:331
#, fuzzy
msgid ":pep:`273` - Import Modules from Zip Archives"
msgstr ":pep:`273` - 從 Zip 檔案中導入模組"

#: ../../whatsnew/2.3.rst:329
#, fuzzy
msgid ""
"Written by James C. Ahlstrom,  who also provided an implementation. Python "
"2.3 follows the specification in :pep:`273`,  but uses an implementation "
"written by Just van Rossum  that uses the import hooks described in :pep:"
"`302`. See section :ref:`section-pep302` for a description of the new import "
"hooks."
msgstr ""
"由 James C. Ahlstrom 編寫，他還提供了一個實作。 Python 2.3 遵循 :pep:`273` "
"中的規範，但使用 Just van Rossum 編寫的實作，該實作使用 :pep:`302` "
"中描述的導入掛鉤。有關新導入掛鉤的說明，請參閱 section-pep302 部分。"

#: ../../whatsnew/2.3.rst:338
#, fuzzy
msgid "PEP 277: Unicode file name support for Windows NT"
msgstr "PEP 277：Windows NT 的 Unicode 文件名支援"

#: ../../whatsnew/2.3.rst:340
#, fuzzy
msgid ""
"On Windows NT, 2000, and XP, the system stores file names as Unicode "
"strings. Traditionally, Python has represented file names as byte strings, "
"which is inadequate because it renders some file names inaccessible."
msgstr ""
"在 Windows NT、2000 和 XP 上，系統將文件名儲存為 Unicode 字串。傳統上，"
"Python 將文件名表示為位元組字串，這是不夠的，因為它使某些文件名無法訪問。"

#: ../../whatsnew/2.3.rst:344
#, fuzzy
msgid ""
"Python now allows using arbitrary Unicode strings (within the limitations of "
"the file system) for all functions that expect file names, most notably the :"
"func:`open` built-in function. If a Unicode string is passed to :func:`os."
"listdir`, Python now returns a list of Unicode strings.  A new function, :"
"func:`os.getcwdu`, returns the current directory as a Unicode string."
msgstr ""
"Python 現在允許對所有需要文件名的函式使用任意 Unicode "
"字串（在文件系統的限制內），最值得注意的是 :func:`open` 內建函式。如果將 "
"Unicode 字串傳遞給 :func:`os.listdir`，Python 現在會回傳一個 Unicode "
"字串列表。新函式 :func:`os.getcwdu` 將當前目錄作為 Unicode 字串回傳。"

#: ../../whatsnew/2.3.rst:350
#, fuzzy
msgid ""
"Byte strings still work as file names, and on Windows Python will "
"transparently convert them to Unicode using the ``mbcs`` encoding."
msgstr "位元組字串仍然用作文件名，在 Windows 上，Python 會使用 ``mbcs`` "
"編碼將它們透明地轉換為 Unicode。"

#: ../../whatsnew/2.3.rst:353
#, fuzzy
msgid ""
"Other systems also allow Unicode strings as file names but convert them to "
"byte strings before passing them to the system, which can cause a :exc:"
"`UnicodeError` to be raised. Applications can test whether arbitrary Unicode "
"strings are supported as file names by checking :attr:`os.path."
"supports_unicode_filenames`, a Boolean value."
msgstr ""
"其他系統也允許 Unicode "
"字串作為文件名，但在將它們傳遞給系統之前將它們轉換為位元組字串，"
"這可能會導致引發 :exc:`UnicodeError`。應用程式可以通過檢查布爾值 "
"os.path.supports_unicode_filenames 來測試是否支援任意 Unicode "
"字串作為文件名。"

#: ../../whatsnew/2.3.rst:359
#, fuzzy
msgid "Under MacOS, :func:`os.listdir` may now return Unicode filenames."
msgstr "在 MacOS 下，:func:`os.listdir` 現在可以回傳 Unicode 文件名。"

#: ../../whatsnew/2.3.rst:365
#, fuzzy
msgid ":pep:`277` - Unicode file name support for Windows NT"
msgstr ":pep:`277` - Windows NT 的 Unicode 文件名支援"

#: ../../whatsnew/2.3.rst:365
#, fuzzy
msgid ""
"Written by Neil Hodgson; implemented by Neil Hodgson, Martin von Löwis, and "
"Mark Hammond."
msgstr "由尼爾霍奇森撰寫；由 Neil Hodgson、Martin von Löwis 和 Mark Hammond 實施。"

#: ../../whatsnew/2.3.rst:375
#, fuzzy
msgid "PEP 278: Universal Newline Support"
msgstr "PEP 278：通用換行符支援"

#: ../../whatsnew/2.3.rst:377
#, fuzzy
msgid ""
"The three major operating systems used today are Microsoft Windows, Apple's "
"Macintosh OS, and the various Unix derivatives.  A minor irritation of cross-"
"platform work  is that these three platforms all use different characters to "
"mark the ends of lines in text files.  Unix uses the linefeed (ASCII "
"character 10), MacOS uses the carriage return (ASCII character 13), and "
"Windows uses a two-character sequence of a carriage return plus a newline."
msgstr ""
"當今使用的三大操作系統是 Microsoft Windows、Apple 的 Macintosh OS 和各種 "
"Unix 衍生系統。跨平台工作的一個小問題是這三個平台都使用不同的字元來標記文本文"
"件中的行尾。 Unix 使用換行符（ASCII 字元 10），MacOS 使用回車符（ASCII 字元 "
"13），Windows 使用回車符和換行符的兩個字元序列。"

#: ../../whatsnew/2.3.rst:384
#, fuzzy
msgid ""
"Python's file objects can now support end of line conventions other than the "
"one followed by the platform on which Python is running. Opening a file with "
"the mode ``'U'`` or ``'rU'`` will open a file for reading in :term:"
"`universal newlines` mode.  All three line ending conventions will be "
"translated to a ``'\\n'`` in the strings returned by the various file "
"methods such as :meth:`read` and :meth:`readline`."
msgstr ""
"Python 的文件物件現在可以支援行尾約定，而不是運行 Python 的平台所遵循的約定。"
"使用模式 ``'U'`` 或 ``'rU'`` 打開文件將以 :term:`universal newlines` "
"模式打開文件進行讀取。所有三種行結束約定都將在各種文件方法（如 :meth:`read` "
"和 :meth:`readline`）回傳的字串中轉換為 ``'\\n'``。"

#: ../../whatsnew/2.3.rst:391
#, fuzzy
msgid ""
"Universal newline support is also used when importing modules and when "
"executing a file with the :func:`execfile` function.  This means that Python "
"modules can be shared between all three operating systems without needing to "
"convert the line-endings."
msgstr ""
"導入模組和使用 :func:`execfile` 函式執行文件時，也會使用通用換行符支援。"
"這意味著 Python 模組可以在所有三個操作系統之間共享，而無需轉換行尾。"

#: ../../whatsnew/2.3.rst:396
#, fuzzy
msgid ""
"This feature can be disabled when compiling Python by specifying the :option:"
"`!--without-universal-newlines` switch when running Python's :program:"
"`configure` script."
msgstr ""
"通過在運行 Python 的 :program:`configure` 腳本時指定 :option:`!--without-"
"universal-newlines` 開關編譯 Python 時可以禁用此功能。"

#: ../../whatsnew/2.3.rst:403
#, fuzzy
msgid ":pep:`278` - Universal Newline Support"
msgstr ":pep:`278` - 通用換行支援"

#: ../../whatsnew/2.3.rst:404
#, fuzzy
msgid "Written and implemented by Jack Jansen."
msgstr "由 Jack Jansen 編寫和實施。"

#: ../../whatsnew/2.3.rst:412
#, fuzzy
msgid "PEP 279: enumerate()"
msgstr "PEP 279：枚舉（）"

#: ../../whatsnew/2.3.rst:414
#, fuzzy
msgid ""
"A new built-in function, :func:`enumerate`, will make certain loops a bit "
"clearer.  ``enumerate(thing)``, where *thing* is either an iterator or a "
"sequence, returns an iterator that will return ``(0, thing[0])``, ``(1, "
"thing[1])``, ``(2, thing[2])``, and so forth."
msgstr ""
"一個新的內建函式 :func:`enumerate` 將使某些循環更清晰一些。 "
"``enumerate(thing)``，其中 *thing* 是疊代器或序列，回傳一個疊代器，"
"該疊代器將回傳 ``(0, thing[0])``, ``(1, thing[1]) ``、``(2, thing[2])`` "
"等等。"

#: ../../whatsnew/2.3.rst:419
#, fuzzy
msgid "A common idiom to change every element of a list looks like this::"
msgstr "更改列表中每個元素的常見用法如下所示："

#: ../../whatsnew/2.3.rst:426
#, fuzzy
msgid "This can be rewritten using :func:`enumerate` as::"
msgstr "這可以使用 :func:`enumerate` 重寫為："

#: ../../whatsnew/2.3.rst:435
#, fuzzy
msgid ":pep:`279` - The enumerate() built-in function"
msgstr ":pep:`279` - enumerate() 內建函式"

#: ../../whatsnew/2.3.rst:436
#, fuzzy
msgid "Written and implemented by Raymond D. Hettinger."
msgstr "由 Raymond D. Hettinger 編寫和實施。"

#: ../../whatsnew/2.3.rst:442
#, fuzzy
msgid "PEP 282: The logging Package"
msgstr "PEP 282：日誌包"

#: ../../whatsnew/2.3.rst:444
#, fuzzy
msgid ""
"A standard package for writing logs, :mod:`logging`, has been added to "
"Python 2.3.  It provides a powerful and flexible mechanism for generating "
"logging output which can then be filtered and processed in various ways.  A "
"configuration file written in a standard format can be used to control the "
"logging behavior of a program.  Python includes handlers that will write log "
"records to standard error or to a file or socket, send them to the system "
"log, or even e-mail them to a particular address; of course, it's also "
"possible to write your own handler classes."
msgstr ""
"用於編寫日誌的標準包 :mod:`logging` 已新增到 Python 2.3。它提供了一種強大而靈"
"活的機制來生成日誌輸出，然後可以通過多種方式對其進行過濾和處理。以標準格式編"
"寫的配置文件可用於控制程式的日誌記錄行為。 Python 包含將日誌記錄寫入標準錯誤"
"或文件或 socket 的處理程式，將它們發送到系統日誌，甚至通過電子郵件將它們發送到"
"特定地址；當然，也可以編寫自己的處理程式類。"

#: ../../whatsnew/2.3.rst:453
#, fuzzy
msgid ""
"The :class:`Logger` class is the primary class. Most application code will "
"deal with one or more :class:`Logger` objects, each one used by a particular "
"subsystem of the application. Each :class:`Logger` is identified by a name, "
"and names are organized into a hierarchy using ``.``  as the component "
"separator. For example, you might have :class:`Logger` instances named "
"``server``, ``server.auth`` and ``server.network``.  The latter two "
"instances are below ``server`` in the hierarchy.  This means that if you "
"turn up the verbosity for ``server`` or direct ``server`` messages to a "
"different handler, the changes will also apply to records logged to ``server."
"auth`` and ``server.network``. There's also a root :class:`Logger` that's "
"the parent of all other loggers."
msgstr ""
":class:`Logger` 類是主要類。大多數應用程式程式碼將處理一個或多個 "
":class:`Logger` 物件，每個對像都由應用程式的特定子系統使用。每個 "
":class:`Logger` 都由一個名稱標識，名稱被組織成一個層次結構，使用 ``.`` "
"作為組件分隔符。例如，您可能有名為 ``server``、“server.auth”和“server.network”"
"的 Logger 實例。後兩個實例在層次結構中的“伺服器”之下。這意味著，如果您調高 "
"``server`` 的詳細程度或將 ``server`` 消息定向到不同的處理程式，"
"這些更改也將應用於記錄到 ``server.auth`` 和 ``server.network` 的記錄``。"
"還有一個根 :class:`Logger` 是所有其他記錄器的父級。"

#: ../../whatsnew/2.3.rst:464
#, fuzzy
msgid ""
"For simple uses, the :mod:`logging` package contains some convenience "
"functions that always use the root log::"
msgstr "對於簡單的使用，:mod:`logging` 包包含一些始終使用根日誌的便利函式："

#: ../../whatsnew/2.3.rst:475 ../../whatsnew/2.3.rst:500
#, fuzzy
msgid "This produces the following output::"
msgstr "這會產生以下輸出："

#: ../../whatsnew/2.3.rst:481
#, fuzzy
msgid ""
"In the default configuration, informational and debugging messages are "
"suppressed and the output is sent to standard error.  You can enable the "
"display of informational and debugging messages by calling the :meth:"
"`setLevel` method on the root logger."
msgstr "在預設配置中，資訊和除錯消息被抑制，輸出被發送到標準錯誤。"
"您可以通過在根記錄器上呼叫 setLevel 方法來啟用資訊和除錯消息的顯示。"

#: ../../whatsnew/2.3.rst:486
#, fuzzy
msgid ""
"Notice the :func:`warning` call's use of string formatting operators; all of "
"the functions for logging messages take the arguments ``(msg, arg1, "
"arg2, ...)`` and log the string resulting from ``msg % (arg1, arg2, ...)``."
msgstr ""
"注意 :func:`warning` "
"呼叫對字串格式化運算符的使用；所有用於記錄消息的函式都採用參數``(msg, arg1, "
"arg2, ...)`` 並記錄由``msg % (arg1, arg2, ...)`` 產生的字串。"

#: ../../whatsnew/2.3.rst:490
#, fuzzy
msgid ""
"There's also an :func:`exception` function that records the most recent "
"traceback.  Any of the other functions will also record the traceback if you "
"specify a true value for the keyword argument *exc_info*. ::"
msgstr ""
"還有一個 :func:`exception` 函式記錄最近的回溯。如果您為關鍵字參數 *exc_info* "
"指定真值，則任何其他函式也將記錄回溯。 ::"

#: ../../whatsnew/2.3.rst:508
#, fuzzy
msgid ""
"Slightly more advanced programs will use a logger other than the root "
"logger. The ``getLogger(name)`` function is used to get a particular log, "
"creating it if it doesn't exist yet. ``getLogger(None)`` returns the root "
"logger. ::"
msgstr ""
"稍微更高階的程式將使用根記錄器以外的記錄器。 ``getLogger(name)`` "
"函式用於獲取特定日誌，如果它不存在則建立它。 ``getLogger(None)`` "
"回傳根記錄器。 ::"

#: ../../whatsnew/2.3.rst:519
#, fuzzy
msgid ""
"Log records are usually propagated up the hierarchy, so a message logged to "
"``server.auth`` is also seen by ``server`` and ``root``, but a :class:"
"`Logger` can prevent this by setting its :attr:`propagate` attribute to :"
"const:`False`."
msgstr ""
"日誌記錄通常向上傳播層次結構，因此記錄到 server.auth 的消息也會被 server 和 "
"root 看到，但是 :class: `Logger` 可以通過設定來防止這種情況它的 "
":attr:`propagate` 屬性為 :const:`False`。"

#: ../../whatsnew/2.3.rst:523
#, fuzzy
msgid ""
"There are more classes provided by the :mod:`logging` package that can be "
"customized.  When a :class:`Logger` instance is told to log a message, it "
"creates a :class:`LogRecord` instance that is sent to any number of "
"different :class:`Handler` instances.  Loggers and handlers can also have an "
"attached list of filters, and each filter can cause the :class:`LogRecord` "
"to be ignored or can modify the record before passing it along.  When "
"they're finally output, :class:`LogRecord` instances are converted to text "
"by a :class:`Formatter` class.  All of these classes can be replaced by your "
"own specially written classes."
msgstr ""
":mod:`logging` 包提供了更多可以自定義的類。當 :class:`Logger` "
"實例被告知記錄一條消息時，它會建立一個 :class:`LogRecord` 實例，"
"該實例被發送到任意數量的不同 :class:`Handler` "
"實例。記錄器和處理程式也可以有一個附加的過濾器列表，每個過濾器都可以導致 "
":class:`LogRecord` "
"被忽略或者可以在傳遞之前修改記錄。當它們最終輸出時，:class:`LogRecord` "
"實例由 :class:`Formatter` "
"類轉換為文本。所有這些類都可以替換為您自己專門編寫的類。"

#: ../../whatsnew/2.3.rst:533
#, fuzzy
msgid ""
"With all of these features the :mod:`logging` package should provide enough "
"flexibility for even the most complicated applications.  This is only an "
"incomplete overview of its features, so please see the package's reference "
"documentation for all of the details.  Reading :pep:`282` will also be "
"helpful."
msgstr ""
"有了所有這些特性，:mod:`logging` 包應該為最複雜的應用程式提供足夠的靈活性。這"
"只是對其功能的不完整概述，因此請參閱軟件包的參考文檔以了解所有詳細資訊。閱讀 "
":pep:`282` 也會有所幫助。"

#: ../../whatsnew/2.3.rst:541
#, fuzzy
msgid ":pep:`282` - A Logging System"
msgstr ":pep:`282` - 一個日誌系統"

#: ../../whatsnew/2.3.rst:542
#, fuzzy
msgid "Written by Vinay Sajip and Trent Mick; implemented by Vinay Sajip."
msgstr "由 Vinay Sajip 和 Trent Mick 撰寫；由 Vinay Sajip 實施。"

#: ../../whatsnew/2.3.rst:550
#, fuzzy
msgid "PEP 285: A Boolean Type"
msgstr "PEP 285：布爾型別"

#: ../../whatsnew/2.3.rst:552
#, fuzzy
msgid ""
"A Boolean type was added to Python 2.3.  Two new constants were added to "
"the :mod:`__builtin__` module, :const:`True` and :const:`False`.  (:const:"
"`True` and :const:`False` constants were added to the built-ins in Python "
"2.2.1, but the 2.2.1 versions are simply set to integer values of 1 and 0 "
"and aren't a different type.)"
msgstr ""
"布爾型別被新增到 Python 2.3。 :mod:`__builtin__` "
"模組中新增了兩個新常數 :const:`True` 和 :const:`False`。 （:const:`True` 和 "
":const:`False` 常數被新增到 Python 2.2.1 的內建函式中，但是 2.2.1 "
"版本只是簡單地設定為整數值 1 和 0，並且沒有什麼不同型別。）"

#: ../../whatsnew/2.3.rst:558
#, fuzzy
msgid ""
"The type object for this new type is named :class:`bool`; the constructor "
"for it takes any Python value and converts it to :const:`True` or :const:"
"`False`. ::"
msgstr ""
"這個新型別的型別對像被命名為 :class:`bool`；它的構造函式接受任何 Python "
"值並將其轉換為 :const:`True` 或 :const:`False`。 ::"

#: ../../whatsnew/2.3.rst:570
#, fuzzy
msgid ""
"Most of the standard library modules and built-in functions have been "
"changed to return Booleans. ::"
msgstr "大多數標準庫模組和內建函式已更改為回傳布爾值。 ::"

#: ../../whatsnew/2.3.rst:581
#, fuzzy
msgid ""
"Python's Booleans were added with the primary goal of making code clearer.  "
"For example, if you're reading a function and encounter the statement "
"``return 1``, you might wonder whether the ``1`` represents a Boolean truth "
"value, an index, or a coefficient that multiplies some other quantity.  If "
"the statement is ``return True``, however, the meaning of the return value "
"is quite clear."
msgstr ""
"新增 Python "
"的布爾值的主要目的是使程式碼更清晰。例如，如果您正在閱讀一個函式並遇到語句“"
"return 1”，您可能想知道 ``1``是否代表布爾真值、索引或與其他數量相乘的係數。但是"
"，如果語句是“return True”，那麼回傳值的含義就很清楚了。"

#: ../../whatsnew/2.3.rst:587
#, fuzzy
msgid ""
"Python's Booleans were *not* added for the sake of strict type-checking.  A "
"very strict language such as Pascal would also prevent you performing "
"arithmetic with Booleans, and would require that the expression in an :"
"keyword:`if` statement always evaluate to a Boolean result.  Python is not "
"this strict and never will be, as :pep:`285` explicitly says.  This means "
"you can still use any expression in an :keyword:`!if` statement, even ones "
"that evaluate to a list or tuple or some random object.  The Boolean type is "
"a subclass of the :class:`int` class so that arithmetic using a Boolean "
"still works. ::"
msgstr ""
"為了嚴格的型別檢查，*未*新增 Python 的布爾值。一種非常嚴格的語言，如 "
"Pascal，也會阻止您使用布爾值進行算術運算，並要求 :keyword:`if` "
"語句中的表達式始終計算為布爾值結果。正如 :pep:`285` 明確指出的那樣，Python "
"不是那麼嚴格，而且永遠不會。這意味著您仍然可以在 :keyword:`!if` "
"語句中使用任何表達式，甚至是計算結果為列表、元組或某個隨機物件的表達式。 "
"Boolean 型別是 int 類的子類別，因此使用 Boolean 的算術仍然有效。 ::"

#: ../../whatsnew/2.3.rst:605
#, fuzzy
msgid ""
"To sum up :const:`True` and :const:`False` in a sentence: they're "
"alternative ways to spell the integer values 1 and 0, with the single "
"difference that :func:`str` and :func:`repr` return the strings ``'True'`` "
"and ``'False'`` instead of ``'1'`` and ``'0'``."
msgstr ""
"用一句話總結 :const:`True` 和 :const:`False`：它們是拼寫整數值 1 和 0 "
"的替代方法，唯一的區別是 :func:`str` 和 :func:` repr` 回傳字串``'True'`` "
"和``'False'`` 而不是``'1'`` 和``'0'``。"

#: ../../whatsnew/2.3.rst:613
#, fuzzy
msgid ":pep:`285` - Adding a bool type"
msgstr ":pep:`285` - 新增一個 bool 型別"

#: ../../whatsnew/2.3.rst:614
#, fuzzy
msgid "Written and implemented by GvR."
msgstr "由 GvR 編寫和實施。"

#: ../../whatsnew/2.3.rst:620
#, fuzzy
msgid "PEP 293: Codec Error Handling Callbacks"
msgstr "PEP 293：編解碼器錯誤處理回呼"

#: ../../whatsnew/2.3.rst:622
#, fuzzy
msgid ""
"When encoding a Unicode string into a byte string, unencodable characters "
"may be encountered.  So far, Python has allowed specifying the error "
"processing as either \"strict\" (raising :exc:`UnicodeError`), \"ignore"
"\" (skipping the character), or \"replace\" (using a question mark in the "
"output string), with \"strict\" being the default behavior. It may be "
"desirable to specify alternative processing of such errors, such as "
"inserting an XML character reference or HTML entity reference into the "
"converted string."
msgstr ""
"在將 Unicode 字串編碼為位元組字串時，可能會遇到無法編碼的字元。到目前為止，"
"Python 允許將錯誤處理指定為“嚴格”（引發 :exc:`UnicodeError`）、“忽略”（跳過字"
"元）或“替換”（在輸出字串中使用問號），其中“嚴格”是預設行為。可能需要指定對此"
"類錯誤的替代處理，例如將 XML 字元引用或 HTML 實體引用插入到轉換後的字串中。"

#: ../../whatsnew/2.3.rst:630
#, fuzzy
msgid ""
"Python now has a flexible framework to add different processing strategies.  "
"New error handlers can be added with :func:`codecs.register_error`, and "
"codecs then can access the error handler with :func:`codecs.lookup_error`. "
"An equivalent C API has been added for codecs written in C. The error "
"handler gets the necessary state information such as the string being "
"converted, the position in the string where the error was detected, and the "
"target encoding.  The handler can then either raise an exception or return a "
"replacement string."
msgstr ""
"Python 現在有一個靈活的框架來新增不同的處理策略。可以使用 :func:`codecs."
"register_error` 新增新的錯誤處理程式，然後編解碼器可以使用 :func:`codecs."
"lookup_error` 訪問錯誤處理程式。為用 C 編寫的編解碼器新增了等效的 C API。錯誤"
"處理程式獲取必要的狀態資訊，例如正在轉換的字串、檢測到錯誤的字串中的位置以及"
"目標編碼。然後處理程式可以引發例外或回傳替換字串。"

#: ../../whatsnew/2.3.rst:638
#, fuzzy
msgid ""
"Two additional error handlers have been implemented using this framework: "
"\"backslashreplace\" uses Python backslash quoting to represent unencodable "
"characters and \"xmlcharrefreplace\" emits XML character references."
msgstr ""
"使用此框架實作了兩個額外的錯誤處理程式： ``backslashreplace`` 使用 Python "
"反斜杠引號來表示不可編碼的字元， ``xmlcharrefreplace`` 發出 XML 字元引用。"

#: ../../whatsnew/2.3.rst:645
#, fuzzy
msgid ":pep:`293` - Codec Error Handling Callbacks"
msgstr ":pep:`293` - 編解碼器錯誤處理回呼"

#: ../../whatsnew/2.3.rst:646
#, fuzzy
msgid "Written and implemented by Walter Dörwald."
msgstr "由 Walter Dörwald 編寫和實施。"

#: ../../whatsnew/2.3.rst:654
#, fuzzy
msgid "PEP 301: Package Index and Metadata for Distutils"
msgstr "PEP 301：Distutils 的包索引和元資料"

#: ../../whatsnew/2.3.rst:656
#, fuzzy
msgid ""
"Support for the long-requested Python catalog makes its first appearance in "
"2.3."
msgstr "對長期請求的 Python 目錄的支援在 2.3 中首次出現。"

#: ../../whatsnew/2.3.rst:658
#, fuzzy
msgid ""
"The heart of the catalog is the new Distutils :command:`register` command. "
"Running ``python setup.py register`` will collect the metadata describing a "
"package, such as its name, version, maintainer, description, &c., and send "
"it to a central catalog server.  The resulting catalog is available from "
"https://pypi.org."
msgstr ""
"目錄的核心是新的 Distutils :command:`register` 命令。運行 ``python setup.py "
"register`` 將收集描述包的元資料，例如它的名稱、版本、維護者、描述等，並將其發"
"送到中央目錄伺服器。生成的目錄可從 https://pypi.org 獲得。"

#: ../../whatsnew/2.3.rst:664
#, fuzzy
msgid ""
"To make the catalog a bit more useful, a new optional *classifiers* keyword "
"argument has been added to the Distutils :func:`setup` function.  A list of "
"`Trove <http://catb.org/~esr/trove/>`_-style strings can be supplied to help "
"classify the software."
msgstr ""
"為了使目錄更有用，一個新的可選 *classifiers* 關鍵字參數已新增到 Distutils "
":func:`setup` 函式中。可以提供 `Trove <http://catb.org/~esr/trove/>`_ "
"風格的字串列表來幫助對軟件進行分類。"

#: ../../whatsnew/2.3.rst:669
#, fuzzy
msgid ""
"Here's an example :file:`setup.py` with classifiers, written to be "
"compatible with older versions of the Distutils::"
msgstr "這是一個帶有分類器的示例 :file:`setup.py`，編寫為與舊版本的 Distutils:: 相容"

#: ../../whatsnew/2.3.rst:688
#, fuzzy
msgid ""
"The full list of classifiers can be obtained by running  ``python setup.py "
"register --list-classifiers``."
msgstr "可以通過運行 ``python setup.py register --list-classifiers`` "
"獲得分類器的完整列表。"

#: ../../whatsnew/2.3.rst:694
#, fuzzy
msgid ":pep:`301` - Package Index and Metadata for Distutils"
msgstr ":pep:`301` - Distutils 的包索引和元資料"

#: ../../whatsnew/2.3.rst:695
#, fuzzy
msgid "Written and implemented by Richard Jones."
msgstr "由 Richard Jones 編寫和實施。"

#: ../../whatsnew/2.3.rst:703
#, fuzzy
msgid "PEP 302: New Import Hooks"
msgstr "PEP 302：新的導入掛鉤"

#: ../../whatsnew/2.3.rst:705
#, fuzzy
msgid ""
"While it's been possible to write custom import hooks ever since the :mod:"
"`ihooks` module was introduced in Python 1.3, no one has ever been really "
"happy with it because writing new import hooks is difficult and messy.  "
"There have been various proposed alternatives such as the :mod:`imputil` "
"and :mod:`iu` modules, but none of them has ever gained much acceptance, and "
"none of them were easily usable from C code."
msgstr ""
"自從在 Python 1.3 中引入了 :mod:`ihooks` 模組以來，就可以編寫自定義導入掛鉤，"
"但沒有人真正對它感到滿意，因為編寫新的導入掛鉤既困難又混亂。已經有各種提議的"
"替代方案，例如 :mod:`imputil` 和 :mod:`iu` 模組，但它們都沒有獲得太多認可，"
"而且它們都不能輕鬆地從 C 程式碼中使用。"

#: ../../whatsnew/2.3.rst:712
#, fuzzy
msgid ""
":pep:`302` borrows ideas from its predecessors, especially from Gordon "
"McMillan's :mod:`iu` module.  Three new items  are added to the :mod:`sys` "
"module:"
msgstr ""
":pep:`302` 借鑒了其前輩的想法，尤其是 Gordon McMillan 的 :mod:`iu` 模組。 "
":mod:`sys` 模組中新增了三個新項目："

#: ../../whatsnew/2.3.rst:716
#, fuzzy
msgid ""
"``sys.path_hooks`` is a list of callable objects; most  often they'll be "
"classes.  Each callable takes a string containing a path and either returns "
"an importer object that will handle imports from this path or raises an :exc:"
"`ImportError` exception if it can't handle this path."
msgstr ""
"``sys.path_hooks`` 是可呼叫物件的列表；大多數情況下，他們會上課。每個可呼叫對"
"像都接受一個包含路徑的字串，並回傳一個導入程式物件，該物件將處理從該路徑導入"
"的內容，或者如果無法處理該路徑則引發 ImportError 例外。"

#: ../../whatsnew/2.3.rst:721
#, fuzzy
msgid ""
"``sys.path_importer_cache`` caches importer objects for each path, so ``sys."
"path_hooks`` will only need to be traversed once for each path."
msgstr ""
"``sys.path_importer_cache`` 為每個路徑快取導入器物件，因此``sys.path_hooks`` "
"只需要為每個路徑遍歷一次。"

#: ../../whatsnew/2.3.rst:724
#, fuzzy
msgid ""
"``sys.meta_path`` is a list of importer objects that will be traversed "
"before ``sys.path`` is checked.  This list is initially empty, but user code "
"can add objects to it.  Additional built-in and frozen modules can be "
"imported by an object added to this list."
msgstr ""
"``sys.meta_path`` 是在檢查 ``sys.path`` 之前將遍歷的導入器物件列表。該列表最"
"初是空的，但使用者程式碼可以向其中新增物件。新增到此列表的物件可以導入其他內"
"置和凍結模組。"

#: ../../whatsnew/2.3.rst:729
#, fuzzy
msgid ""
"Importer objects must have a single method, ``find_module(fullname, "
"path=None)``.  *fullname* will be a module or package name, e.g. ``string`` "
"or ``distutils.core``.  :meth:`find_module` must return a loader object that "
"has a single method, ``load_module(fullname)``, that creates and returns the "
"corresponding module object."
msgstr ""
"導入器物件必須有一個方法，``find_module(fullname, path=None)``。 *fullname* "
"將是模組或包名稱，例如``string`` 或 ``distutils.core``。 :meth:`find_module` "
"必須回傳一個加載器物件，該對像只有一個方法，``load_module(fullname)``，它建立"
"並回傳相應的模組物件。"

#: ../../whatsnew/2.3.rst:735
#, fuzzy
msgid ""
"Pseudo-code for Python's new import logic, therefore, looks something like "
"this (simplified a bit; see :pep:`302` for the full details)::"
msgstr "因此，Python "
"的新導入邏輯的偽程式碼看起來像這樣（稍微簡化了一點；有關詳細資訊，請參閱 "
":pep:`302`）::"

#: ../../whatsnew/2.3.rst:760
#, fuzzy
msgid ":pep:`302` - New Import Hooks"
msgstr ":pep:`302` - 新的導入掛鉤"

#: ../../whatsnew/2.3.rst:761
#, fuzzy
msgid ""
"Written by Just van Rossum and Paul Moore. Implemented by Just van Rossum."
msgstr "由 Just van Rossum 和 Paul Moore 撰寫。由 Just van Rossum 實施。"

#: ../../whatsnew/2.3.rst:769
#, fuzzy
msgid "PEP 305: Comma-separated Files"
msgstr "PEP 305：逗號分隔的文件"

#: ../../whatsnew/2.3.rst:771
#, fuzzy
msgid ""
"Comma-separated files are a format frequently used for exporting data from "
"databases and spreadsheets.  Python 2.3 adds a parser for comma-separated "
"files."
msgstr "逗號分隔文件是一種經常用於從資料庫和電子表格中導出資料的格式。 Python 2.3 "
"為逗號分隔的文件新增了一個解析器。"

#: ../../whatsnew/2.3.rst:774
#, fuzzy
msgid "Comma-separated format is deceptively simple at first glance::"
msgstr "乍一看，逗號分隔格式看似簡單::"

#: ../../whatsnew/2.3.rst:778
#, fuzzy
msgid ""
"Read a line and call ``line.split(',')``: what could be simpler? But toss in "
"string data that can contain commas, and things get more complicated::"
msgstr "閱讀一行並呼叫 ``line.split(',')``：還有什麼比這更簡單的呢？但是加入可以包含"
"逗號的字串資料，事情變得更加複雜::"

#: ../../whatsnew/2.3.rst:783
#, fuzzy
msgid ""
"A big ugly regular expression can parse this, but using the new  :mod:`csv` "
"package is much simpler::"
msgstr "一個醜陋的大正則表達式可以解析這個，但是使用新的 :mod:`csv` 包要簡單得多::"

#: ../../whatsnew/2.3.rst:793
#, fuzzy
msgid ""
"The :func:`reader` function takes a number of different options. The field "
"separator isn't limited to the comma and can be changed to any character, "
"and so can the quoting and line-ending characters."
msgstr ":func:`reader` 函式有許多不同的選項。欄位分隔符不限於逗號，可以更改為任何字元"
"，引號和行結束符也可以。"

#: ../../whatsnew/2.3.rst:797
#, fuzzy
msgid ""
"Different dialects of comma-separated files can be defined and registered; "
"currently there are two dialects, both used by Microsoft Excel. A separate :"
"class:`csv.writer` class will generate comma-separated files from a "
"succession of tuples or lists, quoting strings that contain the delimiter."
msgstr ""
"可以定義和註冊逗號分隔文件的不同方言；目前有兩種方言，均由 Microsoft Excel "
"使用。一個單獨的 csv.writer "
"類將從一系列元組或列表中生成逗號分隔的文件，引用包含分隔符的字串。"

#: ../../whatsnew/2.3.rst:806
#, fuzzy
msgid ":pep:`305` - CSV File API"
msgstr ":pep:`305` - CSV 文件 API"

#: ../../whatsnew/2.3.rst:806
#, fuzzy
msgid ""
"Written and implemented  by Kevin Altis, Dave Cole, Andrew McNamara, Skip "
"Montanaro, Cliff Wells."
msgstr ""
"由 Kevin Altis、Dave Cole、Andrew McNamara、Skip Montanaro、Cliff Wells "
"編寫和實施。"

#: ../../whatsnew/2.3.rst:815
#, fuzzy
msgid "PEP 307: Pickle Enhancements"
msgstr "PEP 307：Pickle 增強功能"

#: ../../whatsnew/2.3.rst:817
#, fuzzy
msgid ""
"The :mod:`pickle` and :mod:`cPickle` modules received some attention during "
"the 2.3 development cycle.  In 2.2, new-style classes could be pickled "
"without difficulty, but they weren't pickled very compactly; :pep:`307` "
"quotes a trivial example where a new-style class results in a pickled string "
"three times longer than that for a classic class."
msgstr ""
":mod:`pickle` 和 :mod:`cPickle` 模組在 2.3 開發週期中受到了一些關注。在 2.2 "
"中，可以毫無困難地 pickle 新式類，但它們的 pickle 不是很緊湊； :pep:`307` "
"引用了一個簡單的例子，其中新式類導致醃製字串的長度是經典類的三倍。"

#: ../../whatsnew/2.3.rst:823
#, fuzzy
msgid ""
"The solution was to invent a new pickle protocol.  The :func:`pickle.dumps` "
"function has supported a text-or-binary flag  for a long time.  In 2.3, this "
"flag is redefined from a Boolean to an integer: 0 is the old text-mode "
"pickle format, 1 is the old binary format, and now 2 is a new 2.3-specific "
"format.  A new constant, :const:`pickle.HIGHEST_PROTOCOL`, can be used to "
"select the fanciest protocol available."
msgstr ""
"解決方案是發明一種新的 pickle 協定。 :func:`pickle.dumps` "
"函式長期以來一直支援文本或二進位旗標。在 2.3 "
"中，此旗標從布爾值重新定義為整數：0 是舊的文本模式 pickle 格式，1 "
"是舊的二進位格式，現在 2 是新的 2.3 特定格式。一個新常數 "
"pickle.HIGHEST_PROTOCOL 可用於選擇可用的最奇特的協定。"

#: ../../whatsnew/2.3.rst:830
#, fuzzy
msgid ""
"Unpickling is no longer considered a safe operation.  2.2's :mod:`pickle` "
"provided hooks for trying to prevent unsafe classes from being unpickled "
"(specifically, a :attr:`__safe_for_unpickling__` attribute), but none of "
"this code was ever audited and therefore it's all been ripped out in 2.3.  "
"You should not unpickle untrusted data in any version of Python."
msgstr ""
"酸洗不再被認為是一種安全操作。 2.2 的 :mod:`pickle` "
"提供了鉤子來試圖防止不安全的類被 unpickled（具體來說，一個 "
":attr:`__safe_for_unpickling__` 屬性），但是這些程式碼都沒有經過審計，因此在 "
"2.3 中都被刪除了.你不應該在任何版本的 Python 中 unpickle 不受信任的資料。"

#: ../../whatsnew/2.3.rst:836
#, fuzzy
msgid ""
"To reduce the pickling overhead for new-style classes, a new interface for "
"customizing pickling was added using three special methods: :meth:"
"`__getstate__`, :meth:`__setstate__`, and :meth:`__getnewargs__`.  Consult :"
"pep:`307` for the full semantics  of these methods."
msgstr ""
"為了減少新樣式類的酸洗開銷，使用三種特殊方法新增了一個用於自定義酸洗的新介面"
"：:meth:`__getstate__`、:meth:`__setstate__` "
"和 :meth:`__getnewargs__`。有關這些方法的完整語義，請參閱 :pep:`307`。"

#: ../../whatsnew/2.3.rst:841
#, fuzzy
msgid ""
"As a way to compress pickles yet further, it's now possible to use integer "
"codes instead of long strings to identify pickled classes. The Python "
"Software Foundation will maintain a list of standardized codes; there's also "
"a range of codes for private use.  Currently no codes have been specified."
msgstr ""
"作為進一步壓縮 pickle 的一種方法，現在可以使用整數程式碼而不是長字串來標識 "
"pickle 類。 Python 軟件基金會將維護一份標準化程式碼列表；還有一系列供私人使用"
"的程式碼。目前沒有指定程式碼。"

#: ../../whatsnew/2.3.rst:849
#, fuzzy
msgid ":pep:`307` - Extensions to the pickle protocol"
msgstr ":pep:`307` - pickle 協定的擴充"

#: ../../whatsnew/2.3.rst:850
#, fuzzy
msgid "Written and implemented  by Guido van Rossum and Tim Peters."
msgstr "由 Guido van Rossum 和 Tim Peters 編寫和實施。"

#: ../../whatsnew/2.3.rst:858
#, fuzzy
msgid "Extended Slices"
msgstr "擴充切片"

#: ../../whatsnew/2.3.rst:860
#, fuzzy
msgid ""
"Ever since Python 1.4, the slicing syntax has supported an optional third "
"\"step\" or \"stride\" argument.  For example, these are all legal Python "
"syntax: ``L[1:10:2]``, ``L[:-1:1]``, ``L[::-1]``.  This was added to Python "
"at the request of the developers of Numerical Python, which uses the third "
"argument extensively.  However, Python's built-in list, tuple, and string "
"sequence types have never supported this feature, raising a :exc:`TypeError` "
"if you tried it. Michael Hudson contributed a patch to fix this shortcoming."
msgstr ""
"自 Python 1.4 以來，切片語法支援可選的第三個 ``step``或 ``stride``參數。例如，"
"這些都是合法的 Python 語法：``L[1:10:2]``、``L[:-1:1]``、``L[::-1]``。這是應 "
"Numerical Python 開發人員的要求新增到 Python "
"中的，它廣泛使用了第三個參數。然而，Python "
"的內建列表、元組和字串序列型別從不支援此功能，如果您嘗試它會引發 "
":exc:`TypeError`。 Michael Hudson 貢獻了一個補丁來修復這個缺點。"

#: ../../whatsnew/2.3.rst:868
#, fuzzy
msgid ""
"For example, you can now easily extract the elements of a list that have "
"even indexes::"
msgstr "例如，您現在可以輕鬆提取具有偶數索引的列表的元素："

#: ../../whatsnew/2.3.rst:875
#, fuzzy
msgid ""
"Negative values also work to make a copy of the same list in reverse order::"
msgstr "負值也可以以相反的順序複製同一個列表："

#: ../../whatsnew/2.3.rst:880
#, fuzzy
msgid "This also works for tuples, arrays, and strings::"
msgstr "這也適用於元組、數組和字串::"

#: ../../whatsnew/2.3.rst:888
#, fuzzy
msgid ""
"If you have a mutable sequence such as a list or an array you can assign to "
"or delete an extended slice, but there are some differences between "
"assignment to extended and regular slices.  Assignment to a regular slice "
"can be used to change the length of the sequence::"
msgstr ""
"如果您有一個可變序列，例如列表或數組，您可以分配或刪除擴充切片，但分配給擴充"
"切片和常規切片之間存在一些差異。對常規切片的分配可用於更改序列的長度::"

#: ../../whatsnew/2.3.rst:900
#, fuzzy
msgid ""
"Extended slices aren't this flexible.  When assigning to an extended slice, "
"the list on the right hand side of the statement must contain the same "
"number of items as the slice it is replacing::"
msgstr "擴充切片沒有這麼靈活。分配給擴充切片時，語句右側的列表必須包含與其要替換的切"
"片相同數量的項目："

#: ../../whatsnew/2.3.rst:917
#, fuzzy
msgid "Deletion is more straightforward::"
msgstr "刪除更直接::"

#: ../../whatsnew/2.3.rst:928
#, fuzzy
msgid ""
"One can also now pass slice objects to the :meth:`__getitem__` methods of "
"the built-in sequences::"
msgstr "現在還可以將切片對像傳遞給內建序列的 :meth:`__getitem__` 方法::"

#: ../../whatsnew/2.3.rst:934
#, fuzzy
msgid "Or use slice objects directly in subscripts::"
msgstr "或者直接在下標中使用切片物件::"

#: ../../whatsnew/2.3.rst:939
#, fuzzy
msgid ""
"To simplify implementing sequences that support extended slicing, slice "
"objects now have a method ``indices(length)`` which, given the length of a "
"sequence, returns a ``(start, stop, step)`` tuple that can be passed "
"directly to :func:`range`. :meth:`indices` handles omitted and out-of-bounds "
"indices in a manner consistent with regular slices (and this innocuous "
"phrase hides a welter of confusing details!).  The method is intended to be "
"used like this::"
msgstr ""
"為了簡化支援擴充切片的序列的實作，切片物件現在有一個方法 ``indices(length)`` "
"給定序列的長度，回傳一個 ``(start, stop, step)`` 可以傳遞的元組直接到 "
":func:`range`。 :meth:`indices` 以與常規切片一致的方式處理省略的和越界的索引"
"（這個無傷大雅的短語隱藏了一大堆令人困惑的細節！）。該方法旨在像這樣使用::"

#: ../../whatsnew/2.3.rst:957
#, fuzzy
msgid ""
"From this example you can also see that the built-in :class:`slice` object "
"is now the type object for the slice type, and is no longer a function.  "
"This is consistent with Python 2.2, where :class:`int`, :class:`str`, etc., "
"underwent the same change."
msgstr ""
"從這個例子中你也可以看到內建的 :class:`slice` "
"物件現在是切片型別的型別物件，不再是一個函式。這與 Python 2.2 一致，其中 "
":class:`int`、:class:`str` 等進行了相同的更改。"

#: ../../whatsnew/2.3.rst:966
#, fuzzy
msgid "Other Language Changes"
msgstr "其他語言變化"

#: ../../whatsnew/2.3.rst:968
#, fuzzy
msgid ""
"Here are all of the changes that Python 2.3 makes to the core Python "
"language."
msgstr "以下是 Python 2.3 對核心 Python 語言所做的所有更改。"

#: ../../whatsnew/2.3.rst:970
#, fuzzy
msgid ""
"The :keyword:`yield` statement is now always a keyword, as described in "
"section :ref:`section-generators` of this document."
msgstr ":keyword:`yield` 語句現在始終是關鍵字，如本文檔的 :ref:`section-generators` "
"部分所述。"

#: ../../whatsnew/2.3.rst:973
#, fuzzy
msgid ""
"A new built-in function :func:`enumerate` was added, as described in "
"section :ref:`section-enumerate` of this document."
msgstr "新增了一個新的內建函式 :func:`enumerate`，如本文檔的 :ref:`section-enumerate`"
" 部分所述。"

#: ../../whatsnew/2.3.rst:976
#, fuzzy
msgid ""
"Two new constants, :const:`True` and :const:`False` were added along with "
"the built-in :class:`bool` type, as described in section :ref:`section-bool` "
"of this document."
msgstr ""
"兩個新常數 :const:`True` 和 :const:`False` 與內建的 :class:`bool` "
"型別一起新增，如本文檔的 :ref:`section-bool` 部分所述。"

#: ../../whatsnew/2.3.rst:980
#, fuzzy
msgid ""
"The :func:`int` type constructor will now return a long integer instead of "
"raising an :exc:`OverflowError` when a string or floating-point number is "
"too large to fit into an integer.  This can lead to the paradoxical result "
"that ``isinstance(int(expression), int)`` is false, but that seems unlikely "
"to cause problems in practice."
msgstr ""
":func:`int` 型別構造函式現在將回傳一個長整數，"
"而不是在字串或浮點數太大而無法放入整數時引發 :exc:`OverflowError`。"
"這可能會導致 ``isinstance(int(expression), int)`` "
"為假的矛盾結果，但這似乎不太可能在實踐中引起問題。"

#: ../../whatsnew/2.3.rst:986
#, fuzzy
msgid ""
"Built-in types now support the extended slicing syntax, as described in "
"section :ref:`section-slices` of this document."
msgstr "內建型別現在支援擴充切片語法，如本文檔的 section-slices 部分所述。"

#: ../../whatsnew/2.3.rst:989
#, fuzzy
msgid ""
"A new built-in function, ``sum(iterable, start=0)``,  adds up the numeric "
"items in the iterable object and returns their sum.  :func:`sum` only "
"accepts numbers, meaning that you can't use it to concatenate a bunch of "
"strings. (Contributed by Alex Martelli.)"
msgstr ""
"一個新的內建函式 ``sum(iterable, start=0)`` "
"將可疊代對像中的數字項相加並回傳它們的總和。 :func:`sum` "
"只接受數字，這意味著你不能用它來連接一堆字串。 （由 Alex Martelli 提供。）"

#: ../../whatsnew/2.3.rst:994
#, fuzzy
msgid ""
"``list.insert(pos, value)`` used to  insert *value* at the front of the list "
"when *pos* was negative.  The behaviour has now been changed to be "
"consistent with slice indexing, so when *pos* is -1 the value will be "
"inserted before the last element, and so forth."
msgstr ""
"``list.insert(pos, value)`` 用於在 *pos* 為負數時將 *value* "
"插入列表的前面。該行為現已更改為與切片索引一致，因此當 *pos* 為 -1 "
"時，該值將插入到最後一個元素之前，依此類推。"

#: ../../whatsnew/2.3.rst:999
#, fuzzy
msgid ""
"``list.index(value)``, which searches for *value*  within the list and "
"returns its index, now takes optional  *start* and *stop* arguments to limit "
"the search to  only part of the list."
msgstr ""
"``list.index(value)`` 在列表中搜索 *value* 並回傳其索引，現在採用可選的 "
"*start* 和 *stop* 參數將搜索限制為僅列表的一部分。"

#: ../../whatsnew/2.3.rst:1003
#, fuzzy
msgid ""
"Dictionaries have a new method, ``pop(key[, *default*])``, that returns the "
"value corresponding to *key* and removes that key/value pair from the "
"dictionary.  If the requested key isn't present in the dictionary, *default* "
"is returned if it's specified and :exc:`KeyError` raised if it isn't. ::"
msgstr ""
"字典有一個新方法，``pop(key[, *default*])``，它回傳對應於 *key* "
"的值並從字典中刪除該鍵/值對。如果字典中不存在請求的鍵，則回傳 *default* "
"如果指定，則回傳 :exc:`KeyError` 如果不是。 ::"

#: ../../whatsnew/2.3.rst:1025
#, fuzzy
msgid ""
"There's also a new class method,  ``dict.fromkeys(iterable, value)``, that "
"creates a dictionary with keys taken from the supplied iterator *iterable* "
"and all values set to *value*, defaulting to ``None``."
msgstr ""
"還有一個新的類方法，``dict.fromkeys(iterable, value)``，它建立一個字典，其中"
"的鍵取自提供的疊代器*iterable*，所有值都設定為*value*，預設為``None`` ."

#: ../../whatsnew/2.3.rst:1029
#, fuzzy
msgid "(Patches contributed by Raymond Hettinger.)"
msgstr "（Raymond Hettinger 貢獻的補丁。）"

#: ../../whatsnew/2.3.rst:1031
#, fuzzy
msgid ""
"Also, the :func:`dict` constructor now accepts keyword arguments to simplify "
"creating small dictionaries::"
msgstr "此外，:func:`dict` 構造函式現在接受關鍵字參數以簡化建立小型字典::"

#: ../../whatsnew/2.3.rst:1037
#, fuzzy
msgid "(Contributed by Just van Rossum.)"
msgstr "（由 Just van Rossum 提供。）"

#: ../../whatsnew/2.3.rst:1039
#, fuzzy
msgid ""
"The :keyword:`assert` statement no longer checks the ``__debug__`` flag, so "
"you can no longer disable assertions by assigning to ``__debug__``. Running "
"Python with the :option:`-O` switch will still generate code that doesn't "
"execute any assertions."
msgstr ""
":keyword:`assert` 語句不再檢查 ``__debug__`` 旗標，因此您不能再通過分配給 "
"``__debug__`` 來禁用斷言。使用 :option:`-O` 開關運行 Python "
"仍將生成不執行任何斷言的程式碼。"

#: ../../whatsnew/2.3.rst:1044
#, fuzzy
msgid ""
"Most type objects are now callable, so you can use them to create new "
"objects such as functions, classes, and modules.  (This means that the :mod:"
"`new` module can be deprecated in a future Python version, because you can "
"now use the type objects available in the :mod:`types` module.) For example, "
"you can create a new module object with the following code:"
msgstr ""
"大多數型別物件現在都是可呼叫的，因此您可以使用它們來建立新物件，例如函式、類"
"和模組。 （這意味著 :mod:`new` 模組可以在未來的 Python 版本中棄用，"
"因為您現在可以使用 :mod:`types` "
"模組中可用的型別物件。）例如，您可以建立一個新模組具有以下程式碼的物件："

#: ../../whatsnew/2.3.rst:1059
#, fuzzy
msgid ""
"A new warning, :exc:`PendingDeprecationWarning` was added to indicate "
"features which are in the process of being deprecated.  The warning will "
"*not* be printed by default.  To check for use of features that will be "
"deprecated in the future, supply :option:`-Walways::"
"PendingDeprecationWarning:: <-W>` on the command line or use :func:`warnings."
"filterwarnings`."
msgstr ""
"新增了一個新警告 :exc:`PendingDeprecationWarning` 以指示正在棄用的功能。預設"
"情況下*不會*印出警告。要檢查將來會棄用的功能的使用情況，請在命令列上提供：選"
"項：`-Walways::PendingDeprecationWarning:: <-W>` 或使用 :func:`warnings."
"filterwarnings`。"

#: ../../whatsnew/2.3.rst:1065
#, fuzzy
msgid ""
"The process of deprecating string-based exceptions, as in ``raise \"Error "
"occurred\"``, has begun.  Raising a string will now trigger :exc:"
"`PendingDeprecationWarning`."
msgstr ""
"棄用基於字串的例外的過程，如 ``raise \"Error occurred\""
"``，已經開始。引發一個字串現在會觸發 :exec:`PendingDeprecationWarning`。"

#: ../../whatsnew/2.3.rst:1069
#, fuzzy
msgid ""
"Using ``None`` as a variable name will now result in a :exc:`SyntaxWarning` "
"warning.  In a future version of Python, ``None`` may finally become a "
"keyword."
msgstr ""
"使用 ``None`` 作為變數名現在將導致 :exc:`SyntaxWarning` 警告。在未來的 "
"Python 版本中，``None`` 可能最終成為關鍵字。"

#: ../../whatsnew/2.3.rst:1072
#, fuzzy
msgid ""
"The :meth:`xreadlines` method of file objects, introduced in Python 2.1, is "
"no longer necessary because files now behave as their own iterator. :meth:"
"`xreadlines` was originally introduced as a faster way to loop over all the "
"lines in a file, but now you can simply write ``for line in file_obj``. File "
"objects also have a new read-only :attr:`encoding` attribute that gives the "
"encoding used by the file; Unicode strings written to the file will be "
"automatically  converted to bytes using the given encoding."
msgstr ""
"Python 2.1 中引入的文件物件的 xreadlines "
"方法不再是必需的，因為文件現在表現為它們自己的疊代器。 :meth:`xreadlines` "
"最初是作為循環遍歷文件中所有行的更快方法引入的，但現在您可以簡單地編寫 ``for "
"line in file_obj``。文件對像還有一個新的只讀 encoding "
"屬性，它給出了文件使用的編碼；寫入文件的 Unicode "
"字串將使用給定的編碼自動轉換為位元組。"

#: ../../whatsnew/2.3.rst:1080
#, fuzzy
msgid ""
"The method resolution order used by new-style classes has changed, though "
"you'll only notice the difference if you have a really complicated "
"inheritance hierarchy.  Classic classes are unaffected by this change.  "
"Python 2.2 originally used a topological sort of a class's ancestors, but "
"2.3 now uses the C3 algorithm as described in the paper `\"A Monotonic "
"Superclass Linearization for Dylan\" <https://citeseerx.ist.psu.edu/viewdoc/"
"summary?doi=10.1.1.19.3910>`_. To understand the motivation for this "
"change,  read Michele Simionato's article `\"Python 2.3 Method Resolution "
"Order\" <http://www.phyast.pitt.edu/~micheles/mro.html>`_, or read the "
"thread on python-dev starting with the message at https://mail.python.org/"
"pipermail/python-dev/2002-October/029035.html. Samuele Pedroni first pointed "
"out the problem and also implemented the fix by coding the C3 algorithm."
msgstr ""
"新式類使用的方法解析順序發生了變化，但只有當您擁有非常複雜的繼承層次結構時，"
"您才會注意到差異。經典課程不受此更改的影響。 Python 2.2 "
"最初使用類祖先的拓撲排序，但 2.3 現在使用 C3 演算法，如論文“A Monotonic "
"Superclass Linearization for Dylan”<https://citeseerx.ist.psu.edu/viewdoc/"
"summary? doi=10.1.1.19.3910>`_.要了解此更改的動機，請閱讀 Michele Simionato "
"的文章“Python 2.3 方法解析順序”<http://www.phyast.pitt.edu/~micheles/mro."
"html>`_，或閱讀 python 上的執行緒- dev 從 https://mail.python.org/pipermail/"
"python-dev/2002-October/029035.html 中的消息開始。 Samuele Pedroni "
"首先指出了問題並通過編寫 C3 演算法實作了修復。"

#: ../../whatsnew/2.3.rst:1093
#, fuzzy
msgid ""
"Python runs multithreaded programs by switching between threads after "
"executing N bytecodes.  The default value for N has been increased from 10 "
"to 100 bytecodes, speeding up single-threaded applications by reducing the "
"switching overhead.  Some multithreaded applications may suffer slower "
"response time, but that's easily fixed by setting the limit back to a lower "
"number using ``sys.setcheckinterval(N)``. The limit can be retrieved with "
"the new :func:`sys.getcheckinterval` function."
msgstr ""
"Python通過執行N個位元組碼後在執行緒之間切換來運行多執行緒程式。 N "
"的預設值已從 10 個位元組碼增加到 100 個位元組碼，通過減少切換開銷來加速單執行"
"緒應用程式。一些多執行緒應用程式可能會遇到較慢的響應時間，但是通過使用 sys."
"setcheckinterval(N) 將限制設定回較低的數字可以輕鬆解決這個問題。可以使用新的 "
":func:`sys.getcheckinterval` 函式檢索該限制。"

#: ../../whatsnew/2.3.rst:1101
#, fuzzy
msgid ""
"One minor but far-reaching change is that the names of extension types "
"defined by the modules included with Python now contain the module and a "
"``'.'`` in front of the type name.  For example, in Python 2.2, if you "
"created a socket and printed its :attr:`__class__`, you'd get this output::"
msgstr ""
"一個微小但影響深遠的變化是，由 Python "
"包含的模組定義的擴充型別的名稱現在包含模組和型別名稱前面的 ``'.'``。例如，在 "
"Python 2.2 中，如果您建立了一個 socket 並印出了它的 "
":attr:`__class__`，您將得到以下輸出："

#: ../../whatsnew/2.3.rst:1110
#, fuzzy
msgid "In 2.3, you get this::"
msgstr "在 2.3 中，你得到這個::"

#: ../../whatsnew/2.3.rst:1115
#, fuzzy
msgid ""
"One of the noted incompatibilities between old- and new-style classes has "
"been removed: you can now assign to the :attr:`~definition.__name__` and :"
"attr:`~class.__bases__` attributes of new-style classes.  There are some "
"restrictions on what can be assigned to :attr:`~class.__bases__` along the "
"lines of those relating to assigning to an instance's :attr:`~instance."
"__class__` attribute."
msgstr ""
"舊式類和新式類之間的一個值得注意的不相容性已被刪除：您現在可以分配給新式類的 "
":attr:`~definition.__name__` 和 :attr:`~class.__bases__` 屬性。"
"對於可以分配給 :attr:`~class.__bases__` 的內容有一些限制，"
"這些限制與分配給實例的 :attr:`~instance.__class__` 屬性相關。"

#: ../../whatsnew/2.3.rst:1125
#, fuzzy
msgid "String Changes"
msgstr "字串更改"

#: ../../whatsnew/2.3.rst:1127
#, fuzzy
msgid ""
"The :keyword:`in` operator now works differently for strings. Previously, "
"when evaluating ``X in Y`` where *X* and *Y* are strings, *X* could only be "
"a single character. That's now changed; *X* can be a string of any length, "
"and ``X in Y`` will return :const:`True` if *X* is a substring of *Y*.  If "
"*X* is the empty string, the result is always :const:`True`. ::"
msgstr ""
":keyword:`in` 運算符現在對字串的作用有所不同。以前，在評估 *X* 和 *Y* "
"是字串的 ``X in Y`` 時，*X* 只能是單個字元。現在改變了； *X* "
"可以是任意長度的字串，如果 *X* 是 *Y* 的子字串，``X in Y`` 將回傳 "
":const:`True`。如果 *X* 是空字串，結果總是 :const:`True`。 ::"

#: ../../whatsnew/2.3.rst:1140
#, fuzzy
msgid ""
"Note that this doesn't tell you where the substring starts; if you need that "
"information, use the :meth:`find` string method."
msgstr "請注意，這並沒有告訴您子字串從哪裡開始；如果您需要該資訊，請使用 :meth:`find`"
" 字串方法。"

#: ../../whatsnew/2.3.rst:1143
#, fuzzy
msgid ""
"The :meth:`strip`, :meth:`lstrip`, and :meth:`rstrip` string methods now "
"have an optional argument for specifying the characters to strip.  The "
"default is still to remove all whitespace characters::"
msgstr ""
":meth:`strip`、:meth:`lstrip` 和 :meth:`rstrip` 字串方法現在有一個可選參數，"
"用於指定要去除的字元。預設仍然是刪除所有空白字元::"

#: ../../whatsnew/2.3.rst:1157
#, fuzzy
msgid "(Suggested by Simon Brunning and implemented by Walter Dörwald.)"
msgstr "（由 Simon Brunning 建議並由 Walter Dörwald 實施。）"

#: ../../whatsnew/2.3.rst:1159
#, fuzzy
msgid ""
"The :meth:`startswith` and :meth:`endswith` string methods now accept "
"negative numbers for the *start* and *end* parameters."
msgstr ":meth:`startswith` 和 :meth:`endswith` 字串方法現在接受 *start* 和 *end* "
"參數的負數。"

#: ../../whatsnew/2.3.rst:1162
#, fuzzy
msgid ""
"Another new string method is :meth:`zfill`, originally a function in the :"
"mod:`string` module.  :meth:`zfill` pads a numeric string with zeros on the "
"left until it's the specified width. Note that the ``%`` operator is still "
"more flexible and powerful than :meth:`zfill`. ::"
msgstr ""
"另一個新的字串方法是 :meth:`zfill`，最初是 :mod:`string` 模組中的一個函式。 "
":meth:`zfill` 在左邊用零填充數字字串，直到它達到指定的寬度。請注意，``%`` "
"運算符仍然比 :meth:`zfill` 更靈活、更強大。 ::"

#: ../../whatsnew/2.3.rst:1174
#, fuzzy
msgid "(Contributed by Walter Dörwald.)"
msgstr "（由 Walter Dörwald 提供。）"

#: ../../whatsnew/2.3.rst:1176
#, fuzzy
msgid ""
"A new type object, :class:`basestring`, has been added. Both 8-bit strings "
"and Unicode strings inherit from this type, so ``isinstance(obj, "
"basestring)`` will return :const:`True` for either kind of string.  It's a "
"completely abstract type, so you can't create :class:`basestring` instances."
msgstr ""
"新增了一個新型別物件 :class:`basestring`。 8 位字串和 Unicode "
"字串都繼承自此型別，因此 ``isinstance(obj, basestring)`` "
"將為任何一種字串回傳 :const:`True`。它是一個完全抽象的型別，所以你不能建立 "
":class:`basestring` 實例。"

#: ../../whatsnew/2.3.rst:1181
#, fuzzy
msgid ""
"Interned strings are no longer immortal and will now be garbage-collected in "
"the usual way when the only reference to them is from the internal "
"dictionary of interned strings.  (Implemented by Oren Tirosh.)"
msgstr ""
"Interned 字串不再是不朽的，現在當對它們的唯一引用來自 interned "
"字串的內部字典時，它們將以通常的方式被垃圾收集。 （由 Oren Tirosh 實施。）"

#: ../../whatsnew/2.3.rst:1189
#, fuzzy
msgid "Optimizations"
msgstr "最佳化"

#: ../../whatsnew/2.3.rst:1191
#, fuzzy
msgid ""
"The creation of new-style class instances has been made much faster; they're "
"now faster than classic classes!"
msgstr "新型類實例的建立速度更快；他們現在比經典課程更快！"

#: ../../whatsnew/2.3.rst:1194
#, fuzzy
msgid ""
"The :meth:`sort` method of list objects has been extensively rewritten by "
"Tim Peters, and the implementation is significantly faster."
msgstr "列表物件的 :meth:`sort` 方法已被 Tim Peters 大量重寫，實作速度明顯加快。"

#: ../../whatsnew/2.3.rst:1197
#, fuzzy
msgid ""
"Multiplication of large long integers is now much faster thanks to an "
"implementation of Karatsuba multiplication, an algorithm that scales better "
"than the O(n\\*n) required for the grade-school multiplication algorithm.  "
"(Original patch by Christopher A. Craig, and significantly reworked by Tim "
"Peters.)"
msgstr ""
"得益於 Karatsuba 乘法的實作，大長整數的乘法現在要快得多，Karatsuba "
"乘法是一種比小學乘法演算法所需的 O(n\\*n) 更好的演算法。 （Christopher A. "
"Craig 的原始補丁，並由 Tim Peters 進行了重大修改。）"

#: ../../whatsnew/2.3.rst:1202
#, fuzzy
msgid ""
"The ``SET_LINENO`` opcode is now gone.  This may provide a small speed "
"increase, depending on your compiler's idiosyncrasies. See section :ref:"
"`23section-other` for a longer explanation. (Removed by Michael Hudson.)"
msgstr ""
"``SET_LINENO`` 操作碼現在不見了。這可能會略微提高速度，具體取決於您的編譯器的"
"特性。有關更長的解釋，請參閱 :ref:`23section-other` 部分。 "
"（由邁克爾哈德森刪除。）"

#: ../../whatsnew/2.3.rst:1206
#, fuzzy
msgid ""
":func:`xrange` objects now have their own iterator, making ``for i in "
"xrange(n)`` slightly faster than ``for i in range(n)``.  (Patch by Raymond "
"Hettinger.)"
msgstr ""
":func:`xrange` 物件現在有自己的疊代器，使得 ``for i in xrange(n)`` 比 ``for "
"i in range(n)`` 稍微快一些。 （Raymond Hettinger 的補丁。）"

#: ../../whatsnew/2.3.rst:1210
#, fuzzy
msgid ""
"A number of small rearrangements have been made in various hotspots to "
"improve performance, such as inlining a function or removing some code.  "
"(Implemented mostly by GvR, but lots of people have contributed single "
"changes.)"
msgstr "在各種熱點中進行了一些小的重新安排以提高性能，例如內聯函式或刪除一些程式碼。 "
"（主要由 GvR 實施，但很多人都貢獻了單一的變化。）"

#: ../../whatsnew/2.3.rst:1214
#, fuzzy
msgid ""
"The net result of the 2.3 optimizations is that Python 2.3 runs the  pystone "
"benchmark around 25% faster than Python 2.2."
msgstr "2.3 最佳化的最終結果是 Python 2.3 運行 pystone 基準測試的速度比 Python 2.2 "
"快大約 25%。"

#: ../../whatsnew/2.3.rst:1221
#, fuzzy
msgid "New, Improved, and Deprecated Modules"
msgstr "新的、改進的和棄用的模組"

#: ../../whatsnew/2.3.rst:1223
#, fuzzy
msgid ""
"As usual, Python's standard library received a number of enhancements and "
"bug fixes.  Here's a partial list of the most notable changes, sorted "
"alphabetically by module name. Consult the :file:`Misc/NEWS` file in the "
"source tree for a more complete list of changes, or look through the CVS "
"logs for all the details."
msgstr ""
"像往常一樣，Python 的標準庫得到了一些增強和錯誤修復。這是最顯著更改的部分列表"
"，按模組名稱的字母順序排序。請查閱源程式碼樹中的 :file:`Misc/NEWS` "
"文件以獲取更完整的更改列表，或查看 CVS 日誌以獲取所有詳細資訊。"

#: ../../whatsnew/2.3.rst:1228
#, fuzzy
msgid ""
"The :mod:`array` module now supports arrays of Unicode characters using the "
"``'u'`` format character.  Arrays also now support using the ``+=`` "
"assignment operator to add another array's contents, and the ``*=`` "
"assignment operator to repeat an array. (Contributed by Jason Orendorff.)"
msgstr ""
":mod:`array` 模組現在支援使用 ``'u'`` 格式字元的 Unicode 字元數組。"
"數組現在還支援使用 ``+=`` 賦值運算符新增另一個數組的內容，以及``*=`` "
"賦值運算符重複一個數組。 （由傑森·奧倫多夫提供。）"

#: ../../whatsnew/2.3.rst:1233
#, fuzzy
msgid ""
"The :mod:`bsddb` module has been replaced by version 4.1.6 of the `PyBSDDB "
"<https://pybsddb.sourceforge.net>`_ package, providing a more complete "
"interface to the transactional features of the BerkeleyDB library."
msgstr ""
":mod:`bsddb` 模組已被 `PyBSDDB <https://pybsddb.sourceforge.net>`_ 包的 "
"4.1.6 版取代，為 BerkeleyDB 庫的事務功能提供了更完整的介面。"

#: ../../whatsnew/2.3.rst:1237
#, fuzzy
msgid ""
"The old version of the module has been renamed to  :mod:`bsddb185` and is no "
"longer built automatically; you'll  have to edit :file:`Modules/Setup` to "
"enable it.  Note that the new :mod:`bsddb` package is intended to be "
"compatible with the  old module, so be sure to file bugs if you discover any "
"incompatibilities. When upgrading to Python 2.3, if the new interpreter is "
"compiled with a new version of  the underlying BerkeleyDB library, you will "
"almost certainly have to convert your database files to the new version.  "
"You can do this fairly easily with the new scripts :file:`db2pickle.py` and :"
"file:`pickle2db.py` which you will find in the distribution's :file:`Tools/"
"scripts` directory.  If you've already been using the PyBSDDB package and "
"importing it as :mod:`bsddb3`, you will have to change your ``import`` "
"statements to import it as :mod:`bsddb`."
msgstr ""
"該模組的舊版本已重命名為 :mod:`bsddb185` 並且不再自動構建；你必須編輯 :file:`"
"Modules/Setup` 來啟用它。請注意，新的 :mod:`bsddb` "
"包旨在與舊模組相容，因此如果您發現任何不相容性，請務必提交錯誤。升級到 "
"Python 2.3 時，如果新直譯器是使用新版本的底層 BerkeleyDB "
"庫編譯的，那麼幾乎可以肯定，您必須將資料庫文件轉換為新版本。您可以使用新腳本 "
":file:`db2pickle.py` 和 :file:`pickle2db.py` 相當輕鬆地完成此操作，"
"您可以在發行版的 :file:`Tools/scripts` 目錄中找到它們。如果您已經在使用 "
"PyBSDDB 包並將其導入為 :mod:`bsddb3`，則必須更改您的 ``import`` "
"語句以將其導入為 :mod:`bsddb`。"

#: ../../whatsnew/2.3.rst:1249
#, fuzzy
msgid ""
"The new :mod:`bz2` module is an interface to the bz2 data compression "
"library. bz2-compressed data is usually smaller than  corresponding :mod:"
"`zlib`\\ -compressed data. (Contributed by Gustavo Niemeyer.)"
msgstr ""
"新的 :mod:`bz2` 模組是 bz2 資料壓縮庫的介面。 bz2 壓縮資料通常小於對應的 "
":mod:`zlib`\\ 壓縮資料。 （古斯塔沃·尼邁耶供稿。）"

#: ../../whatsnew/2.3.rst:1253
#, fuzzy
msgid ""
"A set of standard date/time types has been added in the new :mod:`datetime` "
"module.  See the following section for more details."
msgstr "在新的 datetime "
"模組中新增了一組標準日期/時間型別。有關詳細資訊，請參閱以下部分。"

#: ../../whatsnew/2.3.rst:1256
#, fuzzy
msgid ""
"The Distutils :class:`Extension` class now supports an extra constructor "
"argument named *depends* for listing additional source files that an "
"extension depends on.  This lets Distutils recompile the module if any of "
"the dependency files are modified.  For example, if :file:`sampmodule.c` "
"includes the header file :file:`sample.h`, you would create the :class:"
"`Extension` object like this::"
msgstr ""
"Distutils :class:`Extension` 類現在支援名為 *depends* "
"的額外構造函式參數，用於列出擴充所依賴的其他源文件。這讓 Distutils "
"在任何依賴文件被修改時重新編譯模組。例如，如果 :file:`sampmodule.c` "
"包含標頭檔 :file:`sample.h`，您將建立 :class:`Extension` 物件，如下所示："

#: ../../whatsnew/2.3.rst:1267
#, fuzzy
msgid ""
"Modifying :file:`sample.h` would then cause the module to be recompiled. "
"(Contributed by Jeremy Hylton.)"
msgstr "修改 :file:`sample.h` 會導致模組被重新編譯。 （由傑里米·希爾頓提供。）"

#: ../../whatsnew/2.3.rst:1270
#, fuzzy
msgid ""
"Other minor changes to Distutils: it now checks for the :envvar:`CC`, :"
"envvar:`CFLAGS`, :envvar:`CPP`, :envvar:`LDFLAGS`, and :envvar:`CPPFLAGS` "
"environment variables, using them to override the settings in Python's "
"configuration (contributed by Robert Weber)."
msgstr ""
"Distutils 的其他小改動：它現在檢查 "
":envvar:`CC`、:envvar:`CFLAGS`、:envvar:`CPP`、:envvar:`LDFLAGS` 和 "
":envvar:`CPPFLAGS` 環境變數，使用它們覆蓋 Python 配置中的設定（由 Robert "
"Weber 提供）。"

#: ../../whatsnew/2.3.rst:1275
#, fuzzy
msgid ""
"Previously the :mod:`doctest` module would only search the docstrings of "
"public methods and functions for test cases, but it now also examines "
"private ones as well.  The :func:`DocTestSuite` function creates a :class:"
"`unittest.TestSuite` object from a set of :mod:`doctest` tests."
msgstr ""
"以前的 :mod:`doctest` 模組只會搜索公開方法和函式的文檔字串以查找測試用例，但"
"現在它也可以檢查私有方法和函式。 :func:`DocTestSuite` 函式從一組 "
":mod:`doctest` 測試建立一個 :class:`unittest.TestSuite` 物件。"

#: ../../whatsnew/2.3.rst:1280
#, fuzzy
msgid ""
"The new ``gc.get_referents(object)`` function returns a list of all the "
"objects referenced by *object*."
msgstr "新的 ``gc.get_referents(object)`` 函式回傳 *object* 引用的所有物件的列表。"

#: ../../whatsnew/2.3.rst:1283
#, fuzzy
msgid ""
"The :mod:`getopt` module gained a new function, :func:`gnu_getopt`, that "
"supports the same arguments as the existing :func:`getopt` function but uses "
"GNU-style scanning mode. The existing :func:`getopt` stops processing "
"options as soon as a non-option argument is encountered, but in GNU-style "
"mode processing continues, meaning that options and arguments can be mixed.  "
"For example::"
msgstr ""
"getopt 模組獲得了一個新函式 gnu_getopt，它支援與現有 getopt 函式相同的參數，"
"但使用 GNU 風格的掃描模式。現有的 :func:`getopt` "
"會在遇到非選項參數時立即停止處理選項，但在 GNU "
"風格模式下處理會繼續，這意味著選項和參數可以混合使用。例如：："

#: ../../whatsnew/2.3.rst:1294
#, fuzzy
msgid "(Contributed by Peter Åstrand.)"
msgstr "（由 Peter Åstrand 提供。）"

#: ../../whatsnew/2.3.rst:1296
#, fuzzy
msgid ""
"The :mod:`grp`, :mod:`pwd`, and :mod:`resource` modules now return enhanced "
"tuples::"
msgstr ":mod:`grp`、:mod:`pwd` 和 :mod:`resource` 模組現在回傳增強的元組::"

#: ../../whatsnew/2.3.rst:1304
#, fuzzy
msgid "The :mod:`gzip` module can now handle files exceeding 2 GiB."
msgstr ":mod:`gzip` 模組現在可以處理超過 2 GiB 的文件。"

#: ../../whatsnew/2.3.rst:1306
#, fuzzy
msgid ""
"The new :mod:`heapq` module contains an implementation of a heap queue "
"algorithm.  A heap is an array-like data structure that keeps items in a "
"partially sorted order such that, for every index *k*, ``heap[k] <= heap[2*k"
"+1]`` and ``heap[k] <= heap[2*k+2]``.  This makes it quick to remove the "
"smallest item, and inserting a new item while maintaining the heap property "
"is O(lg n).  (See https://xlinux.nist.gov/dads//HTML/priorityque.html for "
"more information about the priority queue data structure.)"
msgstr ""
"新的 :mod:`heapq` 模組包含堆隊列演算法的實作。堆是一種類似數組的資料結構，它"
"以部分排序的順序保存項目，這樣，對於每個索引 *k*，``heap[k] <= heap[2*k+1]`` "
"和 ``heap[ k] <= 堆[2*k+2]``。這使得它可以快速刪除最小的項目，"
"並在保持堆屬性的同時插入新項目是 O(lg n)。 "
"（有關優先級隊列資料結構的更多資訊，請參閱 https://xlinux.nist.gov/dads//"
"HTML/priorityque.html。）"

#: ../../whatsnew/2.3.rst:1314
#, fuzzy
msgid ""
"The :mod:`heapq` module provides :func:`heappush` and :func:`heappop` "
"functions for adding and removing items while maintaining the heap property "
"on top of some other mutable Python sequence type.  Here's an example that "
"uses a Python list::"
msgstr ""
":mod:`heapq` 模組提供 :func:`heappush` 和 :func:`heappop` "
"函式，用於新增和刪除項目，同時在其他一些可變 Python 序列型別之上維護堆屬性。"
"這是一個使用 Python 列表的示例："

#: ../../whatsnew/2.3.rst:1332
#, fuzzy
msgid "(Contributed by Kevin O'Connor.)"
msgstr "（由凱文·奧康納提供。）"

#: ../../whatsnew/2.3.rst:1334
#, fuzzy
msgid ""
"The IDLE integrated development environment has been updated using the code "
"from the IDLEfork project (http://idlefork.sourceforge.net).  The most "
"notable feature is that the code being developed is now executed in a "
"subprocess, meaning that there's no longer any need for manual ``reload()`` "
"operations. IDLE's core code has been incorporated into the standard library "
"as the :mod:`idlelib` package."
msgstr ""
"IDLE 集成開發環境已使用 IDLEfork 項目 (http://idlefork.sourceforge.net) 中的"
"程式碼進行了更新。最顯著的特點是正在開發的程式碼現在在子行程中執行，這意味著"
"不再需要手動“reload()”操作。 IDLE 的核心程式碼已作為 :mod:`idlelib` "
"包合併到標準庫中。"

#: ../../whatsnew/2.3.rst:1340
#, fuzzy
msgid ""
"The :mod:`imaplib` module now supports IMAP over SSL. (Contributed by Piers "
"Lauder and Tino Lange.)"
msgstr ":mod:`imaplib` 模組現在支援 IMAP over SSL。 （由 Piers Lauder 和 Tino Lange "
"提供。）"

#: ../../whatsnew/2.3.rst:1343
#, fuzzy
msgid ""
"The :mod:`itertools` contains a number of useful functions for use with "
"iterators, inspired by various functions provided by the ML and Haskell "
"languages.  For example, ``itertools.ifilter(predicate, iterator)`` returns "
"all elements in the iterator for which the function :func:`predicate` "
"returns :const:`True`, and ``itertools.repeat(obj, N)`` returns ``obj`` *N* "
"times. There are a number of other functions in the module; see the "
"package's reference documentation for details. (Contributed by Raymond "
"Hettinger.)"
msgstr ""
":mod:`itertools` 包含許多與疊代器一起使用的有用函式，其靈感來自 ML 和 "
"Haskell 語言提供的各種函式。例如，``itertools.ifilter(predicate, iterator)`` "
"回傳函式 predicate 回傳 :const:`True 的疊代器中的所有元素，以及 ``itertools."
"repeat(obj, N) `` 回傳 ``obj`` *N* "
"次。模組中還有許多其他功能；有關詳細資訊，請參閱包的參考文檔。 "
"（雷蒙德·赫廷格供稿。）"

#: ../../whatsnew/2.3.rst:1352
#, fuzzy
msgid ""
"Two new functions in the :mod:`math` module, ``degrees(rads)`` and "
"``radians(degs)``, convert between radians and degrees.  Other functions in "
"the :mod:`math` module such as :func:`math.sin` and :func:`math.cos` have "
"always required input values measured in radians.  Also, an optional *base* "
"argument was added to :func:`math.log` to make it easier to compute "
"logarithms for bases other than ``e`` and ``10``.  (Contributed by Raymond "
"Hettinger.)"
msgstr ""
":mod:`math` 模組中的兩個新函式，``degrees(rads)`` 和 "
"``radians(degs)``，在弧度和度數之間進行轉換。 :mod:`math` 模組中的其他函式，"
"例如 :func:`math.sin` 和 :func:`math.cos` 始終需要以弧度測量的輸入值。此外，"
"一個可選的 *base* 參數被新增到 :func:`math.log` 以便更容易地計算除 ``e`` 和 "
"``10`` 以外的底數的對數。 （雷蒙德·赫廷格供稿。）"

#: ../../whatsnew/2.3.rst:1359
#, fuzzy
msgid ""
"Several new POSIX functions (:func:`getpgid`, :func:`killpg`, :func:"
"`lchown`, :func:`loadavg`, :func:`major`, :func:`makedev`, :func:`minor`, "
"and :func:`mknod`) were added to the :mod:`posix` module that underlies the :"
"mod:`os` module. (Contributed by Gustavo Niemeyer, Geert Jansen, and Denis "
"S. Otkidach.)"
msgstr ""
"幾個新的 POSIX 函式（:func:`getpgid`、:func:`killpg`、:func:`lchown`、:func:`"
"loadavg`、:func:`major`、:func:`makedev`、:func: `minor` 和 :func:`mknod`) "
"被新增到 :mod:`os` 模組下的 :mod:`posix` 模組。 （由 Gustavo Niemeyer、Geert "
"Jansen 和 Denis S. Otkidach 提供。）"

#: ../../whatsnew/2.3.rst:1365
#, fuzzy
msgid ""
"In the :mod:`os` module, the :func:`\\*stat` family of functions can now "
"report fractions of a second in a timestamp.  Such time stamps are "
"represented as floats, similar to the value returned by :func:`time.time`."
msgstr ""
"在 :mod:`os` 模組中，:func:`\\*stat` "
"系列函式現在可以報告時間戳中的幾分之一秒。這樣的時間戳表示為浮點數，類似於 "
":func:`time.time` 回傳的值。"

#: ../../whatsnew/2.3.rst:1369
#, fuzzy
msgid ""
"During testing, it was found that some applications will break if time "
"stamps are floats.  For compatibility, when using the tuple interface of "
"the :class:`stat_result` time stamps will be represented as integers. When "
"using named fields (a feature first introduced in Python 2.2), time stamps "
"are still represented as integers, unless :func:`os.stat_float_times` is "
"invoked to enable float return values::"
msgstr ""
"在測試過程中，發現如果時間戳是浮動的，一些應用程式會中斷。為了相容性，當使用 "
":class:`stat_result` 的元組介面時，時間戳將表示為整數。使用命名欄位（Python "
"2.2 中首次引入的功能）時，時間戳仍表示為整數，除非呼叫 os.stat_float_times "
"以啟用浮點回傳值::"

#: ../../whatsnew/2.3.rst:1382
#, fuzzy
msgid "In Python 2.4, the default will change to always returning floats."
msgstr "在 Python 2.4 中，預設值將更改為始終回傳浮點數。"

#: ../../whatsnew/2.3.rst:1384
#, fuzzy
msgid ""
"Application developers should enable this feature only if all their "
"libraries work properly when confronted with floating point time stamps, or "
"if they use the tuple API. If used, the feature should be activated on an "
"application level instead of trying to enable it on a per-use basis."
msgstr ""
"應用程式開發人員只有在遇到浮點時間戳或使用元組 API 時所有庫都能正常工作時才應"
"啟用此功能。如果使用，該功能應該在應用程式級別激活，而不是嘗試在每次使用的基"
"礎上啟用它。"

#: ../../whatsnew/2.3.rst:1389
#, fuzzy
msgid ""
"The :mod:`optparse` module contains a new parser for command-line arguments "
"that can convert option values to a particular Python type  and will "
"automatically generate a usage message.  See the following section for  more "
"details."
msgstr ""
":mod:`optparse` 模組包含一個新的命令列參數解析器，可以將選項值轉換為特定的 "
"Python 型別，並自動生成用法消息。有關詳細資訊，請參閱以下部分。"

#: ../../whatsnew/2.3.rst:1394
#, fuzzy
msgid ""
"The old and never-documented :mod:`linuxaudiodev` module has been "
"deprecated, and a new version named :mod:`ossaudiodev` has been added.  The "
"module was renamed because the OSS sound drivers can be used on platforms "
"other than Linux, and the interface has also been tidied and brought up to "
"date in various ways. (Contributed by Greg Ward and Nicholas FitzRoy-Dale.)"
msgstr ""
"舊的和從未記錄的 :mod:`linuxaudiodev` 模組已被棄用，並新增了一個名為 "
":mod:`ossaudiodev` 的新版本。該模組已重命名，因為 OSS 聲音驅動程式可以在 "
"Linux 以外的平台上使用，並且界面也經過整理並以各種方式更新。 （由 Greg Ward "
"和 Nicholas FitzRoy-Dale 提供。）"

#: ../../whatsnew/2.3.rst:1400
#, fuzzy
msgid ""
"The new :mod:`platform` module contains a number of functions that try to "
"determine various properties of the platform you're running on.  There are "
"functions for getting the architecture, CPU type, the Windows OS version, "
"and even the Linux distribution version. (Contributed by Marc-André Lemburg.)"
msgstr ""
"新的 :mod:`platform` 模組包含許多函式，這些函式試圖確定您正在運行的平台的各種"
"屬性。有獲取體系結構、CPU 型別、Windows 操作系統版本甚至 Linux "
"發行版本的函式。 （由 Marc-André Lemburg 提供。）"

#: ../../whatsnew/2.3.rst:1405
#, fuzzy
msgid ""
"The parser objects provided by the :mod:`pyexpat` module can now optionally "
"buffer character data, resulting in fewer calls to your character data "
"handler and therefore faster performance.  Setting the parser object's :attr:"
"`buffer_text` attribute to :const:`True` will enable buffering."
msgstr ""
":mod:`pyexpat` 模組提供的解析器物件現在可以選擇緩衝字元資料，從而減少對字元資"
"料處理程式的呼叫，從而提高性能。將解析器物件的 :attr:`buffer_text` "
"屬性設定為 :const:`True` 將啟用緩衝。"

#: ../../whatsnew/2.3.rst:1410
#, fuzzy
msgid ""
"The ``sample(population, k)`` function was added to the :mod:`random` "
"module.  *population* is a sequence or :class:`xrange` object containing the "
"elements of a population, and :func:`sample` chooses *k* elements from the "
"population without replacing chosen elements.  *k* can be any value up to "
"``len(population)``. For example::"
msgstr ""
"``sample(population, k)`` 函式被新增到 :mod:`random` 模組中。 *population* "
"是包含總體元素的序列或 xrange 物件，而 :func:`sample` 從總體中選擇 *k* "
"個元素而不替換所選元素。 *k* 可以是不超過 ``len(population)`` "
"的任何值。例如：："

#: ../../whatsnew/2.3.rst:1432
#, fuzzy
msgid ""
"The :mod:`random` module now uses a new algorithm, the Mersenne Twister, "
"implemented in C.  It's faster and more extensively studied than the "
"previous algorithm."
msgstr ":mod:`random` 模組現在使用一種用 C 語言實作的新演算法 Mersenne "
"Twister。它比以前的演算法更快，研究也更廣泛。"

#: ../../whatsnew/2.3.rst:1436
#, fuzzy
msgid "(All changes contributed by Raymond Hettinger.)"
msgstr "（所有更改均由 Raymond Hettinger 貢獻。）"

#: ../../whatsnew/2.3.rst:1438
#, fuzzy
msgid ""
"The :mod:`readline` module also gained a number of new functions: :func:"
"`get_history_item`, :func:`get_current_history_length`, and :func:"
"`redisplay`."
msgstr ""
":mod:`readline` 模組還獲得了許多新功能：:func:`get_history_item`、:func:`get_"
"current_history_length` 和 :func:`redisplay`。"

#: ../../whatsnew/2.3.rst:1442
#, fuzzy
msgid ""
"The :mod:`rexec` and :mod:`Bastion` modules have been declared dead, and "
"attempts to import them will fail with a :exc:`RuntimeError`.  New-style "
"classes provide new ways to break out of the restricted execution "
"environment provided by :mod:`rexec`, and no one has interest in fixing them "
"or time to do so.  If you have applications using :mod:`rexec`, rewrite them "
"to use something else."
msgstr ""
":mod:`rexec` 和 :mod:`Bastion` 模組已被宣布死亡，嘗試導入它們將失敗並出現 "
":exc:`RuntimeError`。新型類提供了打破 :mod:`rexec` "
"提供的受限執行環境的新方法，沒有人有興趣或沒有時間修復它們。如果您有使用 "
":mod:`rexec` 的應用程式，請重寫它們以使用其他東西。"

#: ../../whatsnew/2.3.rst:1448
#, fuzzy
msgid ""
"(Sticking with Python 2.2 or 2.1 will not make your applications any safer "
"because there are known bugs in the :mod:`rexec` module in those versions.  "
"To repeat: if you're using :mod:`rexec`, stop using it immediately.)"
msgstr ""
"（堅持使用 Python 2.2 或 2.1 不會使您的應用程式更安全，因為這些版本的 "
":mod:`rexec` 模組中存在已知錯誤。重複：如果您正在使用 "
":mod:`rexec`，請停止使用它立即地。）"

#: ../../whatsnew/2.3.rst:1452
#, fuzzy
msgid ""
"The :mod:`rotor` module has been deprecated because the  algorithm it uses "
"for encryption is not believed to be secure.  If you need encryption, use "
"one of the several AES Python modules that are available separately."
msgstr ""
":mod:`rotor` "
"模組已被棄用，因為它用於加密的演算法被認為是不安全的。如果您需要加密，"
"請使用單獨提供的幾個 AES Python 模組之一。"

#: ../../whatsnew/2.3.rst:1456
#, fuzzy
msgid ""
"The :mod:`shutil` module gained a ``move(src, dest)`` function that "
"recursively moves a file or directory to a new location."
msgstr ":mod:`shutil` 模組獲得了一個 ``move(src, dest)`` "
"函式，可以遞迴地將文件或目錄移動到新位置。"

#: ../../whatsnew/2.3.rst:1459
#, fuzzy
msgid ""
"Support for more advanced POSIX signal handling was added to the :mod:"
"`signal` but then removed again as it proved impossible to make it work "
"reliably across platforms."
msgstr "對更高階的 POSIX 信號處理的支援被新增到 :mod:`signal` "
"但隨後又被刪除，因為事實證明它不可能跨平台可靠地工作。"

#: ../../whatsnew/2.3.rst:1463
#, fuzzy
msgid ""
"The :mod:`socket` module now supports timeouts.  You can call the "
"``settimeout(t)`` method on a socket object to set a timeout of *t* seconds. "
"Subsequent socket operations that take longer than *t* seconds to complete "
"will abort and raise a :exc:`socket.timeout` exception."
msgstr ""
":mod:`socket` 模組現在支援超時。您可以在 socket 對像上呼叫 ``settimeout(t)`` "
"方法來設定 *t* 秒的超時。完成時間超過 *t* 秒的後續 socket 操作將中止並引發 "
":exc:`socket.timeout` 例外。"

#: ../../whatsnew/2.3.rst:1468
#, fuzzy
msgid ""
"The original timeout implementation was by Tim O'Malley.  Michael Gilfix "
"integrated it into the Python :mod:`socket` module and shepherded it through "
"a lengthy review.  After the code was checked in, Guido van Rossum rewrote "
"parts of it.  (This is a good example of a collaborative development process "
"in action.)"
msgstr ""
"最初的超時實作是由 Tim O'Malley 完成的。 Michael Gilfix 將其集成到 Python "
":mod:`socket` 模組中，並對其進行了長時間的審查。程式碼簽入後，Guido van "
"Rossum 重寫了部分程式碼。 （這是實際協作開發過程的一個很好的例子。）"

#: ../../whatsnew/2.3.rst:1474
#, fuzzy
msgid ""
"On Windows, the :mod:`socket` module now ships with Secure  Sockets Layer "
"(SSL) support."
msgstr "在 Windows 上，:mod:`socket` 模組現在附帶安全 socket 層 (SSL) 支援。"

#: ../../whatsnew/2.3.rst:1477
#, fuzzy
msgid ""
"The value of the C :const:`PYTHON_API_VERSION` macro is now exposed at the "
"Python level as ``sys.api_version``.  The current exception can be cleared "
"by calling the new :func:`sys.exc_clear` function."
msgstr ""
"C :const:`PYTHON_API_VERSION` 巨集的值現在在 Python 級別公開為 ``sys."
"api_version``。可以通過呼叫新的 :func:`sys.exc_clear` 函式來清除當前例外。"

#: ../../whatsnew/2.3.rst:1481
#, fuzzy
msgid ""
"The new :mod:`tarfile` module  allows reading from and writing to :program:"
"`tar`\\ -format archive files. (Contributed by Lars Gustäbel.)"
msgstr ""
"新的 :mod:`tarfile` 模組允許讀取和寫入 :program:`tar`\\ 格式的歸檔文件。 （"
"由 Lars Gustäbel 提供。）"

#: ../../whatsnew/2.3.rst:1484
#, fuzzy
msgid ""
"The new :mod:`textwrap` module contains functions for wrapping strings "
"containing paragraphs of text.  The ``wrap(text, width)`` function takes a "
"string and returns a list containing the text split into lines of no more "
"than the chosen width.  The ``fill(text, width)`` function returns a single "
"string, reformatted to fit into lines no longer than the chosen width. (As "
"you can guess, :func:`fill` is built on top of :func:`wrap`.  For example::"
msgstr ""
"新的 :mod:`textwrap` 模組包含用於包裝包含文本段落的字串的函式。 ``wrap(text, "
"width)`` "
"函式接受一個字串並回傳一個列表，其中包含拆分為不超過所選寬度的行的文本。 "
"``fill(text, width)`` 函式回傳一個字串，重新格式化以適合不超過所選寬度的行。 "
"（你可以猜到，:func:`fill` 是建立在 :func:`wrap` 之上的。例如："

#: ../../whatsnew/2.3.rst:1506
#, fuzzy
msgid ""
"The module also contains a :class:`TextWrapper` class that actually "
"implements the text wrapping strategy.   Both the :class:`TextWrapper` class "
"and the :func:`wrap` and :func:`fill` functions support a number of "
"additional keyword arguments for fine-tuning the formatting; consult the "
"module's documentation for details. (Contributed by Greg Ward.)"
msgstr ""
"該模組還包含一個實際實作文本換行策略的 TextWrapper 類。 :class:`TextWrapper` "
"類以及 :func:`wrap` 和 :func:`fill` 函式都支援許多額外的關鍵字參數，用於微調"
"格式；有關詳細資訊，請參閱模組的文檔。 （由格雷格·沃德提供。）"

#: ../../whatsnew/2.3.rst:1512
#, fuzzy
msgid ""
"The :mod:`thread` and :mod:`threading` modules now have companion modules, :"
"mod:`dummy_thread` and :mod:`dummy_threading`, that provide a do-nothing "
"implementation of the :mod:`thread` module's interface for platforms where "
"threads are not supported.  The intention is to simplify thread-aware "
"modules (ones that *don't* rely on threads to run) by putting the following "
"code at the top::"
msgstr ""
":mod:`thread` 和 :mod:`threading` 模組現在有配套模組 :mod:`dummy_thread` 和 "
":mod:`dummy_threading`，它們提供了 :mod:`thread` 模組的無操作實作不支援執行緒"
"的平台的介面。目的是通過將以下程式碼放在頂部來簡化執行緒感知模組（*不*依賴執"
"行緒運行的模組）："

#: ../../whatsnew/2.3.rst:1524
#, fuzzy
msgid ""
"In this example, :mod:`_threading` is used as the module name to make it "
"clear that the module being used is not necessarily the actual :mod:"
"`threading` module. Code can call functions and use classes in :mod:"
"`_threading` whether or not threads are supported, avoiding an :keyword:`if` "
"statement and making the code slightly clearer.  This module will not "
"magically make multithreaded code run without threads; code that waits for "
"another thread to return or to do something will simply hang forever."
msgstr ""
"在此示例中，:mod:`_threading` 用作模組名稱，"
"以表明正在使用的模組不一定是實際的 :mod:`threading` "
"模組。無論是否支援執行緒，程式碼都可以在 :mod:`_threading` 中呼叫"
"函式和使用類，避免使用 :keyword:`if` 語句並使程式碼更清晰。這個模組不"
"會神奇地讓多執行緒程式碼在沒有執行緒的情況下運行；等待另一個執行緒回傳或做某"
"事的程式碼將永遠掛起。"

#: ../../whatsnew/2.3.rst:1532
#, fuzzy
msgid ""
"The :mod:`time` module's :func:`strptime` function has long been an "
"annoyance because it uses the platform C library's :func:`strptime` "
"implementation, and different platforms sometimes have odd bugs.  Brett "
"Cannon contributed a portable implementation that's written in pure Python "
"and should behave identically on all platforms."
msgstr ""
":mod:`time` 模組的 :func:`strptime` 函式長期以來一直令人煩惱，因為它使用平台 "
"C 庫的 :func:`strptime` 實作，不同的平台有時會有奇怪的錯誤。 Brett Cannon "
"貢獻了一個用純 Python 編寫的可移植實作，並且在所有平台上的行為應該相同。"

#: ../../whatsnew/2.3.rst:1538
#, fuzzy
msgid ""
"The new :mod:`timeit` module helps measure how long snippets of Python code "
"take to execute.  The :file:`timeit.py` file can be run directly from the "
"command line, or the module's :class:`Timer` class can be imported and used "
"directly.  Here's a short example that figures out whether it's faster to "
"convert an 8-bit string to Unicode by appending an empty Unicode string to "
"it or by using the :func:`unicode` function::"
msgstr ""
"新的 :mod:`timeit` 模組有助於測量 Python 程式碼片段的執行時間。 :file:`timeit"
".py` 文件可以直接從命令列運行，也可以導入模組的 :class:`Timer` "
"類直接使用。下面是一個簡短的示例，它通過向 8 位字串附加空 Unicode 字串或使用 "
":func:`unicode` 函式來確定將 8 位字串轉換為 Unicode 的速度更快："

#: ../../whatsnew/2.3.rst:1558
#, fuzzy
msgid ""
"The :mod:`Tix` module has received various bug fixes and updates for the "
"current version of the Tix package."
msgstr ":mod:`Tix` 模組已收到針對當前版本 Tix 包的各種錯誤修復和更新。"

#: ../../whatsnew/2.3.rst:1561
#, fuzzy
msgid ""
"The :mod:`Tkinter` module now works with a thread-enabled  version of Tcl. "
"Tcl's threading model requires that widgets only be accessed from the thread "
"in which they're created; accesses from another thread can cause Tcl to "
"panic.  For certain Tcl interfaces, :mod:`Tkinter` will now automatically "
"avoid this  when a widget is accessed from a different thread by marshalling "
"a command, passing it to the correct thread, and waiting for the results.  "
"Other interfaces can't be handled automatically but :mod:`Tkinter` will now "
"raise an exception on such an access so that you can at least find out about "
"the problem.  See https://mail.python.org/pipermail/python-dev/2002-"
"December/031107.html for a more detailed explanation of this change.  "
"(Implemented by Martin von Löwis.)"
msgstr ""
":mod:`Tkinter` 模組現在可以與支援執行緒的 Tcl 版本一起使用。 Tcl "
"的執行緒模型要求小部件只能從建立它們的執行緒訪問；"
"來自另一個執行緒的訪問會導致 Tcl 崩潰。對於某些 Tcl 介面，Tkinter 現在將通過"
"編組命令、將其傳遞到正確的執行緒並等待結果從不同的執行緒訪問小部件時自動避免"
"這種情況。其他介面無法自動處理，但 :mod:`Tkinter` 現在將在此類訪問中引發例外"
"，以便您至少可以找出問題所在。有關此更改的更詳細說明，請參閱 https://mail."
"python.org/pipermail/python-dev/2002-December/031107.html。 （由 Martin von "
"Löwis 實施。）"

#: ../../whatsnew/2.3.rst:1572
#, fuzzy
msgid ""
"Calling Tcl methods through :mod:`_tkinter` no longer  returns only strings. "
"Instead, if Tcl returns other objects those objects are converted to their "
"Python equivalent, if one exists, or wrapped with a :class:`_tkinter."
"Tcl_Obj` object if no Python equivalent exists. This behavior can be "
"controlled through the :meth:`wantobjects` method of :class:`tkapp` objects."
msgstr ""
"通過 :mod:`_tkinter` 呼叫 Tcl 方法不再僅回傳字串。相反，如果 Tcl "
"回傳其他物件，則這些物件將轉換為它們的 Python 等效項（如果存在），"
"或者如果不存在 Python 等效項則用 :class:`_tkinter.Tcl_Obj` 物件包裝。"
"這種行為可以通過 :meth:`tkapp` 物件的 :meth:`wantobjects` 方法來控制。"

#: ../../whatsnew/2.3.rst:1578
#, fuzzy
msgid ""
"When using :mod:`_tkinter` through the :mod:`Tkinter` module (as most "
"Tkinter applications will), this feature is always activated. It should not "
"cause compatibility problems, since Tkinter would always convert string "
"results to Python types where possible."
msgstr ""
"當通過 :mod:`Tkinter` 模組使用 :mod:`_tkinter` 時（就像大多數 Tkinter "
"應用程式一樣），此功能始終處於激活狀態。它不應該導致相容性問題，因為 Tkinter "
"總是會在可能的情況下將字串結果轉換為 Python 型別。"

#: ../../whatsnew/2.3.rst:1583
#, fuzzy
msgid ""
"If any incompatibilities are found, the old behavior can be restored by "
"setting the :attr:`wantobjects` variable in the :mod:`Tkinter` module to "
"false before creating the first :class:`tkapp` object. ::"
msgstr ""
"如果發現任何不相容性，可以通過在建立第一個 :class: `tkapp` 物件之前將 "
":mod:`Tkinter` 模組中的 :attr:`wantobjects` 變數設定為 false 來恢復舊行為。 "
"::"

#: ../../whatsnew/2.3.rst:1590
#, fuzzy
msgid "Any breakage caused by this change should be reported as a bug."
msgstr "此更改導致的任何損壞都應報告為錯誤。"

#: ../../whatsnew/2.3.rst:1592
#, fuzzy
msgid ""
"The :mod:`UserDict` module has a new :class:`DictMixin` class which defines "
"all dictionary methods for classes that already have a minimum mapping "
"interface.  This greatly simplifies writing classes that need to be "
"substitutable for dictionaries, such as the classes in  the :mod:`shelve` "
"module."
msgstr ""
":mod:`UserDict` 模組有一個新的 :class:`DictMixin` 類，它為已經具有最小映射介面"
"的類定義了所有字典方法。這極大地簡化了需要可替換字典的類的編寫，例如 "
":mod:`shelve` 模組中的類。"

#: ../../whatsnew/2.3.rst:1598
#, fuzzy
msgid ""
"Adding the mix-in as a superclass provides the full dictionary interface "
"whenever the class defines :meth:`__getitem__`, :meth:`__setitem__`, :meth:"
"`__delitem__`, and :meth:`keys`. For example::"
msgstr ""
"每當類定義 :meth:`__getitem__`、:meth:`__setitem__`、:meth:`__delitem__` 和 "
":meth:`keys 時，將混合作為超類新增即可提供完整的字典介面。例如：："

#: ../../whatsnew/2.3.rst:1639
#, fuzzy
msgid "(Contributed by Raymond Hettinger.)"
msgstr "（雷蒙德·赫廷格供稿。）"

#: ../../whatsnew/2.3.rst:1641
#, fuzzy
msgid ""
"The DOM implementation in :mod:`xml.dom.minidom` can now generate XML output "
"in a particular encoding by providing an optional encoding argument to the :"
"meth:`toxml` and :meth:`toprettyxml` methods of DOM nodes."
msgstr ""
":mod:`xml.dom.minidom` 中的 DOM 實作現在可以通過向 DOM 節點的 :meth:`toxml` "
"和:meth:`toprettyxml` 方法提供可選的編碼參數，以特定編碼生成 "
"XML 輸出。"

#: ../../whatsnew/2.3.rst:1645
#, fuzzy
msgid ""
"The :mod:`xmlrpclib` module now supports an XML-RPC extension for handling "
"nil data values such as Python's ``None``.  Nil values are always supported "
"on unmarshalling an XML-RPC response.  To generate requests containing "
"``None``, you must supply a true value for the *allow_none* parameter when "
"creating a :class:`Marshaller` instance."
msgstr ""
":mod:`xmlrpclib` 模組現在支援用於處理 nil 資料值的 XML-RPC 擴充，例如 Python "
"的 ``None``。解組 XML-RPC 響應時始終支援 Nil 值。要生成包含 ``None``的請求，"
"您必須在建立 Marshaller 實例時為 *allow_none* 參數提供一個真值。"

#: ../../whatsnew/2.3.rst:1651
#, fuzzy
msgid ""
"The new :mod:`DocXMLRPCServer` module allows writing self-documenting XML-"
"RPC servers. Run it in demo mode (as a program) to see it in action.   "
"Pointing the web browser to the RPC server produces pydoc-style "
"documentation; pointing xmlrpclib to the server allows invoking the actual "
"methods. (Contributed by Brian Quinlan.)"
msgstr ""
"新的 :mod:`DocXMLRPCServer` 模組允許編寫自文檔化的 XML-RPC "
"伺服器。以演示模式（作為程式）運行它以查看它的實際效果。將 Web 瀏覽器指向 "
"RPC 伺服器會生成 pydoc 樣式的文檔；將 xmlrpclib 指向伺服器允許呼叫實際方法。 "
"（由布賴恩·昆蘭提供。）"

#: ../../whatsnew/2.3.rst:1657
#, fuzzy
msgid ""
"Support for internationalized domain names (RFCs 3454, 3490, 3491, and 3492) "
"has been added. The \"idna\" encoding can be used to convert between a "
"Unicode domain name and the ASCII-compatible encoding (ACE) of that name. ::"
msgstr ""
"新增了對國際化域名（RFC 3454、3490、3491 和 3492）的支援。  ``idna``"
"編碼可用於在 Unicode 域名和該名稱的 ASCII 相容編碼 (ACE) 之間進行轉換。 ::"

#: ../../whatsnew/2.3.rst:1664
#, fuzzy
msgid ""
"The :mod:`socket` module has also been extended to transparently convert "
"Unicode hostnames to the ACE version before passing them to the C library. "
"Modules that deal with hostnames such as :mod:`httplib` and :mod:`ftplib`) "
"also support Unicode host names; :mod:`httplib` also sends HTTP ``Host`` "
"headers using the ACE version of the domain name.  :mod:`urllib` supports "
"Unicode URLs with non-ASCII host names as long as the ``path`` part of the "
"URL is ASCII only."
msgstr ""
":mod:`socket` 模組也得到了擴充，可以在將 Unicode 主機名傳遞給 C "
"庫之前透明地將它們轉換為 ACE 版本。處理主機名的模組，例如 :mod:`httplib` 和 "
":mod:`ftplib`) 也支援 Unicode 主機名； :mod:`httplib` 還使用域名的 ACE "
"版本發送 HTTP ``Host`` 標頭。 :mod:`urllib` 支援具有非 ASCII 主機名的 "
"Unicode URL，只要 URL 的 ``path`` 部分僅為 ASCII。"

#: ../../whatsnew/2.3.rst:1672
#, fuzzy
msgid ""
"To implement this change, the :mod:`stringprep` module, the  "
"``mkstringprep`` tool and the ``punycode`` encoding have been added."
msgstr "為實作此更改，新增了 :mod:`stringprep` 模組、``mkstringprep`` 工具和 "
"``punycode`` 編碼。"

#: ../../whatsnew/2.3.rst:1679
#, fuzzy
msgid "Date/Time Type"
msgstr "日期/時間型別"

#: ../../whatsnew/2.3.rst:1681
#, fuzzy
msgid ""
"Date and time types suitable for expressing timestamps were added as the :"
"mod:`datetime` module.  The types don't support different calendars or many "
"fancy features, and just stick to the basics of representing time."
msgstr ""
"適合表達時間戳的日期和時間型別被新增為 :mod:`datetime` "
"模組。這些型別不支援不同的日曆或許多花哨的功能，只是堅持表示時間的基礎知識。"

#: ../../whatsnew/2.3.rst:1685
#, fuzzy
msgid ""
"The three primary types are: :class:`date`, representing a day, month, and "
"year; :class:`~datetime.time`, consisting of hour, minute, and second; and :"
"class:`~datetime.datetime`, which contains all the attributes of both :class:"
"`date` and :class:`~datetime.time`. There's also a :class:`timedelta` class "
"representing differences between two points in time, and time zone logic is "
"implemented by classes inheriting from the abstract :class:`tzinfo` class."
msgstr ""
"三種主要型別是：:class:`date`，代表日、月和年； :class:`~datetime."
"time`，由時、分、秒組成；和 :class:`~datetime.datetime`，它包含 :class:`date` "
"和 :class:`~datetime.time` 的所有屬性。還有一個 :class:`timedelta` "
"類表示兩個時間點之間的差異，時區邏輯由繼承自抽象 :class:`tzinfo` 類的類實作。"

#: ../../whatsnew/2.3.rst:1692
#, fuzzy
msgid ""
"You can create instances of :class:`date` and :class:`~datetime.time` by "
"either supplying keyword arguments to the appropriate constructor, e.g. "
"``datetime.date(year=1972, month=10, day=15)``, or by using one of a number "
"of class methods.  For example, the :meth:`date.today` class method returns "
"the current local date."
msgstr ""
"您可以通過向適當的構造函式提供關鍵字參數來建立 :class:`date` 和 "
":class:`~datetime.time` 的實例，例如``datetime.date(year=1972, month=10, "
"day=15)``，或使用多種類方法之一。例如，:meth:`date.today` "
"類方法回傳當前本地日期。"

#: ../../whatsnew/2.3.rst:1698
#, fuzzy
msgid ""
"Once created, instances of the date/time classes are all immutable. There "
"are a number of methods for producing formatted strings from objects::"
msgstr "一旦建立，日期/時間類的實例都是不可變的。有許多方法可以從對像中生成格式化字串"
"："

#: ../../whatsnew/2.3.rst:1710
#, fuzzy
msgid ""
"The :meth:`replace` method allows modifying one or more fields  of a :class:"
"`date` or :class:`~datetime.datetime` instance, returning a new instance::"
msgstr ""
":meth:`replace` 方法允許修改 :class:`date` 或 :class:`~datetime.datetime` "
"實例的一個或多個欄位，回傳一個新實例::"

#: ../../whatsnew/2.3.rst:1720
#, fuzzy
msgid ""
"Instances can be compared, hashed, and converted to strings (the result is "
"the same as that of :meth:`isoformat`).  :class:`date` and :class:`~datetime."
"datetime` instances can be subtracted from each other, and added to :class:"
"`timedelta` instances.  The largest missing feature is that there's no "
"standard library support for parsing strings and getting back a :class:"
"`date` or :class:`~datetime.datetime`."
msgstr ""
"可以對實例進行比較、散列和轉換為字串（結果與 :meth:`isoformat` 的結果相同）。"
" :class:`date` 和 :class:`~datetime.datetime` 實例可以相互減去，並新增到 "
":class:`timedelta` "
"實例中。最大的缺失功能是沒有標準庫支援解析字串和回傳 :class:`date` "
"或 :class:`~datetime.datetime`。"

#: ../../whatsnew/2.3.rst:1727
#, fuzzy
msgid ""
"For more information, refer to the module's reference documentation. "
"(Contributed by Tim Peters.)"
msgstr "有關詳細資訊，請參閱模組的參考文檔。 （由蒂姆·彼得斯提供。）"

#: ../../whatsnew/2.3.rst:1734
#, fuzzy
msgid "The optparse Module"
msgstr "optparse 模組"

#: ../../whatsnew/2.3.rst:1736
#, fuzzy
msgid ""
"The :mod:`getopt` module provides simple parsing of command-line arguments.  "
"The new :mod:`optparse` module (originally named Optik) provides more "
"elaborate command-line parsing that follows the Unix conventions, "
"automatically creates the output for :option:`!--help`, and can perform "
"different actions for different options."
msgstr ""
":mod:`getopt` 模組提供對命令列參數的簡單解析。新的 :mod:`optparse` 模組（"
"最初名為 Optik）提供了更精細的命令列解析，它遵循 Unix 約定，自動為 :option:`!"
"--help` 建立輸出，並且可以針對不同的選項執行不同的操作."

#: ../../whatsnew/2.3.rst:1742
#, fuzzy
msgid ""
"You start by creating an instance of :class:`OptionParser` and telling it "
"what your program's options are. ::"
msgstr "您首先建立一個 OptionParser 的實例並告訴它您的程式的選項是什麼。 ::"

#: ../../whatsnew/2.3.rst:1756
#, fuzzy
msgid ""
"Parsing a command line is then done by calling the :meth:`parse_args` "
"method. ::"
msgstr "然後通過呼叫 parse_args 方法來解析命令列。 ::"

#: ../../whatsnew/2.3.rst:1762
#, fuzzy
msgid ""
"This returns an object containing all of the option values, and a list of "
"strings containing the remaining arguments."
msgstr "這將回傳一個包含所有選項值的物件，以及一個包含剩餘參數的字串列表。"

#: ../../whatsnew/2.3.rst:1765
#, fuzzy
msgid ""
"Invoking the script with the various arguments now works as you'd expect it "
"to. Note that the length argument is automatically converted to an integer."
msgstr "使用各種參數呼叫腳本現在可以像您期望的那樣工作。請注意，長度參數會自動轉換為"
"整數。"

#: ../../whatsnew/2.3.rst:1778
#, fuzzy
msgid "The help message is automatically generated for you:"
msgstr "自動為您生成幫助消息："

#: ../../whatsnew/2.3.rst:1793
msgid "See the module's documentation for more details."
msgstr "更多細節請見 module 文件。"

#: ../../whatsnew/2.3.rst:1796
#, fuzzy
msgid ""
"Optik was written by Greg Ward, with suggestions from the readers of the "
"Getopt SIG."
msgstr "Optik 由 Greg Ward 根據 Getopt SIG 的讀者的建議編寫。"

#: ../../whatsnew/2.3.rst:1805
#, fuzzy
msgid "Pymalloc: A Specialized Object Allocator"
msgstr "Pymalloc：一個專門的物件分配器"

#: ../../whatsnew/2.3.rst:1807
#, fuzzy
msgid ""
"Pymalloc, a specialized object allocator written by Vladimir Marangozov, was "
"a feature added to Python 2.1.  Pymalloc is intended to be faster than the "
"system :c:func:`malloc` and to have less memory overhead for allocation "
"patterns typical of Python programs. The allocator uses C's :c:func:`malloc` "
"function to get large pools of memory and then fulfills smaller memory "
"requests from these pools."
msgstr ""
"Pymalloc 是一種由 Vladimir Marangozov 編寫的專用物件分配器，是 Python 2.1 "
"中新增的一項功能。 Pymalloc 旨在比系統 :c:func:`malloc` 更快，並且對於 "
"Python 程式典型的分配模式具有更少的記憶體開銷。分配器使用 C 的 "
":c:func:`malloc` 函式獲取大記憶體池，然後從這些池中滿足較小的記憶體請求。"

#: ../../whatsnew/2.3.rst:1813
#, fuzzy
msgid ""
"In 2.1 and 2.2, pymalloc was an experimental feature and wasn't enabled by "
"default; you had to explicitly enable it when compiling Python by providing "
"the :option:`!--with-pymalloc` option to the :program:`configure` script.  "
"In 2.3, pymalloc has had further enhancements and is now enabled by default; "
"you'll have to supply :option:`!--without-pymalloc` to disable it."
msgstr ""
"在 2.1 和 2.2 中，pymalloc 是一項實驗性功能，預設情況下未啟用；在編譯 Python "
"時，您必須通過向 :program:`configure` 腳本提供 :option:`!--with-pymalloc` "
"選項來顯式啟用它。在 2.3 中，pymalloc 有了進一步的增強，現在預設啟用；"
"你必須提供 :option:`!--without-pymalloc` 來禁用它。"

#: ../../whatsnew/2.3.rst:1819
#, fuzzy
msgid ""
"This change is transparent to code written in Python; however, pymalloc may "
"expose bugs in C extensions.  Authors of C extension modules should test "
"their code with pymalloc enabled, because some incorrect code may cause core "
"dumps at runtime."
msgstr ""
"這種變化對用 Python 編寫的程式碼是透明的；但是，pymalloc 可能會暴露 C "
"擴充中的錯誤。 C 擴充模組的作者應該在啟用 pymalloc "
"的情況下測試他們的程式碼，因為一些不正確的程式碼可能會在運行時導致核心轉儲。"

#: ../../whatsnew/2.3.rst:1824
#, fuzzy
msgid ""
"There's one particularly common error that causes problems.  There are a "
"number of memory allocation functions in Python's C API that have previously "
"just been aliases for the C library's :c:func:`malloc` and :c:func:`free`, "
"meaning that if you accidentally called mismatched functions the error "
"wouldn't be noticeable. When the object allocator is enabled, these "
"functions aren't aliases of :c:func:`malloc` and :c:func:`free` any more, "
"and calling the wrong function to free memory may get you a core dump.  For "
"example, if memory was allocated using :c:func:`PyObject_Malloc`, it has to "
"be freed using :c:func:`PyObject_Free`, not :c:func:`free`.  A few modules "
"included with Python fell afoul of this and had to be fixed; doubtless there "
"are more third-party modules that will have the same problem."
msgstr ""
"有一個特別常見的錯誤會導致問題。 Python 的 C API 中有許多記憶體分配函式，"
"它們以前只是 C 庫的 :c:func:`malloc` 和 :c:func:`free` 的別名，這意味著如果你"
"不小心呼叫了不匹配的函式，錯誤不會引人注意。啟用物件分配器後，這些函式不再是:"
"c:func:`malloc` 和:c:func:`free` "
"的別名，呼叫錯誤的函式來釋放記憶體可能會導致核心轉儲。例如，如果使用 "
":c:func:`PyObject_Malloc` 分配記憶體，則必須使用 :c:func:`PyObject_Free` "
"釋放記憶體，而不是 :c:func:`free`。 Python 中的一些模組與此衝突，必須修復；毫"
"無疑問，會有更多的第三方模組出現同樣的問題。"

#: ../../whatsnew/2.3.rst:1836
#, fuzzy
msgid ""
"As part of this change, the confusing multiple interfaces for allocating "
"memory have been consolidated down into two API families. Memory allocated "
"with one family must not be manipulated with functions from the other "
"family.  There is one family for allocating chunks of memory and another "
"family of functions specifically for allocating Python objects."
msgstr ""
"作為此更改的一部分，用於分配記憶體的混亂的多個介面已合併為兩個 API 系列。分配"
"給一個家族的記憶體不得由另一家族的函式操作。有一個函式族用於分配記憶體塊，"
"而另一族函式專門用於分配 Python 物件。"

#: ../../whatsnew/2.3.rst:1842
#, fuzzy
msgid ""
"To allocate and free an undistinguished chunk of memory use the \"raw memory"
"\" family: :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc`, and :c:func:"
"`PyMem_Free`."
msgstr ""
"要分配和釋放未區分的記憶體塊，請使用“原始記憶體”系列：:c:func:`PyMem_Malloc`"
"、:c:func:`PyMem_Realloc` 和:c:func:`PyMem_Free`。"

#: ../../whatsnew/2.3.rst:1845
#, fuzzy
msgid ""
"The \"object memory\" family is the interface to the pymalloc facility "
"described above and is biased towards a large number of \"small\" "
"allocations: :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc`, and :c:"
"func:`PyObject_Free`."
msgstr ""
"“物件記憶體”系列是上述 pymalloc 設施的介面，並且偏向於大量的 ``小``分配：:c:func"
":`PyObject_Malloc`、:c:func:`PyObject_Realloc` 和:c:功能：`PyObject_Free`。"

#: ../../whatsnew/2.3.rst:1849
#, fuzzy
msgid ""
"To allocate and free Python objects, use the \"object\" family :c:func:"
"`PyObject_New`, :c:func:`PyObject_NewVar`, and :c:func:`PyObject_Del`."
msgstr ""
"要分配和釋放 Python "
"物件，請使用“物件”系列 :c:func:`PyObject_New`、:c:func:`PyObject_NewVar` "
"和:c:func:`PyObject_Del`。"

#: ../../whatsnew/2.3.rst:1852
#, fuzzy
msgid ""
"Thanks to lots of work by Tim Peters, pymalloc in 2.3 also provides "
"debugging features to catch memory overwrites and doubled frees in both "
"extension modules and in the interpreter itself.  To enable this support, "
"compile a debugging version of the Python interpreter by running :program:"
"`configure` with :option:`!--with-pydebug`."
msgstr ""
"感謝 Tim Peters 的大量工作，2.3 中的 pymalloc 還提供了除錯功能，以捕獲擴充模"
"組和直譯器本身中的記憶體覆蓋和雙重釋放。要啟用此支援，請通過運行 "
":program:`configure` 和 :option:`!--with-pydebug` 來編譯 Python "
"直譯器的除錯版本。"

#: ../../whatsnew/2.3.rst:1858
#, fuzzy
msgid ""
"To aid extension writers, a header file :file:`Misc/pymemcompat.h` is "
"distributed with the source to Python 2.3 that allows Python extensions to "
"use the 2.3 interfaces to memory allocation while compiling against any "
"version of Python since 1.5.2.  You would copy the file from Python's source "
"distribution and bundle it with the source of your extension."
msgstr ""
"為了幫助擴充編寫者，一個標頭檔 :file:`Misc/pymemcompat.h` 與 Python 2.3 "
"的源程式碼一起分發，它允許 Python 擴充使用 2.3 介面進行記憶體分配，"
"同時針對自 1.5.2 以來的任何版本的 Python 進行編譯。您將從 Python "
"的源程式碼分發中復制該文件並將其與您的擴充源捆綁在一起。"

#: ../../whatsnew/2.3.rst:1869
msgid "https://hg.python.org/cpython/file/default/Objects/obmalloc.c"
msgstr "https://hg.python.org/cpython/file/default/Objects/obmalloc.c"

#: ../../whatsnew/2.3.rst:1868
#, fuzzy
msgid ""
"For the full details of the pymalloc implementation, see the comments at the "
"top of the file :file:`Objects/obmalloc.c` in the Python source code. The "
"above link points to the file within the python.org SVN browser."
msgstr ""
"有關 pymalloc 實作的完整詳細資訊，請參閱 Python "
"源程式碼中文件頂部的註釋 :file:`Objects/obmalloc.c`。上面的鏈接指向 "
"python.org SVN 瀏覽器中的文件。"

#: ../../whatsnew/2.3.rst:1876
#, fuzzy
msgid "Build and C API Changes"
msgstr "構建和 C API 更改"

#: ../../whatsnew/2.3.rst:1878
#, fuzzy
msgid "Changes to Python's build process and to the C API include:"
msgstr "Python 構建過程和 C API 的變化包括："

#: ../../whatsnew/2.3.rst:1880
#, fuzzy
msgid ""
"The cycle detection implementation used by the garbage collection has proven "
"to be stable, so it's now been made mandatory.  You can no longer compile "
"Python without it, and the :option:`!--with-cycle-gc` switch to :program:"
"`configure` has been removed."
msgstr ""
"垃圾收集使用的循環檢測實作已被證明是穩定的，因此現在已成為強制性的。如果沒有"
"它，您將無法再編譯 Python，並且 :option:`!--with-cycle-gc` 切換到 "
":program:`configure` 已被刪除。"

#: ../../whatsnew/2.3.rst:1885
#, fuzzy
msgid ""
"Python can now optionally be built as a shared library (:file:`libpython2.3."
"so`) by supplying :option:`!--enable-shared` when running Python's :program:"
"`configure` script.  (Contributed by Ondrej Palkovsky.)"
msgstr ""
"現在可以選擇將 Python 構建為共享庫 (:file:`libpython2.3.so`)，方法是在運行 "
"Python 的 :program:`configure` 腳本時提供 :option:`!--enable-shared`。 （由 "
"Ondrej Palkovsky 提供。）"

#: ../../whatsnew/2.3.rst:1889
#, fuzzy
msgid ""
"The :c:macro:`DL_EXPORT` and :c:macro:`DL_IMPORT` macros are now deprecated. "
"Initialization functions for Python extension modules should now be declared "
"using the new macro :c:macro:`PyMODINIT_FUNC`, while the Python core will "
"generally use the :c:macro:`PyAPI_FUNC` and :c:macro:`PyAPI_DATA` macros."
msgstr ""
":c:macro:`DL_EXPORT` 和 :c:macro:`DL_IMPORT` 巨集現已棄用。 Python "
"擴充模組的初始化函式現在應該使用新巨集 PyMODINIT_FUNC 聲明，而 Python "
"核心通常使用 PyAPI_FUNC 和 PyAPI_DATA 巨集。"

#: ../../whatsnew/2.3.rst:1894
#, fuzzy
msgid ""
"The interpreter can be compiled without any docstrings for the built-in "
"functions and modules by supplying :option:`!--without-doc-strings` to the :"
"program:`configure` script. This makes the Python executable about 10% "
"smaller, but will also mean that you can't get help for Python's built-ins.  "
"(Contributed by Gustavo Niemeyer.)"
msgstr ""
"通過為 :program: `configure` 腳本提供 :option:`!--without-doc-strings` "
"，可以在沒有任何文檔字串的情況下為內建函式和模組編譯直譯器。這使得 Python "
"可執行文件的大小減少了大約 10%，但也意味著您無法獲得 Python 內建函式的幫助。 "
"（古斯塔沃·尼邁耶供稿。）"

#: ../../whatsnew/2.3.rst:1900
#, fuzzy
msgid ""
"The :c:func:`PyArg_NoArgs` macro is now deprecated, and code that uses it "
"should be changed.  For Python 2.2 and later, the method definition table "
"can specify the :const:`METH_NOARGS` flag, signalling that there are no "
"arguments, and the argument checking can then be removed.  If compatibility "
"with pre-2.2 versions of Python is important, the code could use "
"``PyArg_ParseTuple(args, \"\")`` instead, but this will be slower than "
"using :const:`METH_NOARGS`."
msgstr ""
":c:func:`PyArg_NoArgs` 巨集現已棄用，應更改使用它的程式碼。對於 Python 2.2 "
"及更高版本，方法定義表可以指定 :const:`METH_NOARGS` "
"旗標，表示沒有參數，然後可以刪除參數檢查。如果與 2.2 之前版本的 Python "
"的相容性很重要，程式碼可以使用 PyArg_ParseTuple(args, \"\")`` 代替，"
"但這會比使用 METH_NOARGS 慢。"

#: ../../whatsnew/2.3.rst:1907
#, fuzzy
msgid ""
":c:func:`PyArg_ParseTuple` accepts new format characters for various sizes "
"of unsigned integers: ``B`` for :c:expr:`unsigned char`, ``H`` for :c:expr:"
"`unsigned short int`,  ``I`` for :c:expr:`unsigned int`,  and ``K`` for :c:"
"expr:`unsigned long long`."
msgstr ""
":c:func:`PyArg_ParseTuple` 接受各種大小的無符號整數的新格式字元：``B`` 用於 "
":c:expr:`unsigned char`，``H`` 用於 :c:expr:`unsigned short int `，``I`` "
"用於 :c:expr:`unsigned int`，``K`` 用於 :c:expr:`unsigned long long`。"

#: ../../whatsnew/2.3.rst:1912
#, fuzzy
msgid ""
"A new function, ``PyObject_DelItemString(mapping, char *key)`` was added as "
"shorthand for ``PyObject_DelItem(mapping, PyString_New(key))``."
msgstr ""
"新增了一個新函式“PyObject_DelItemString(mapping, char "
"*key)”作為“PyObject_DelItem(mapping, PyString_New(key))”的簡寫。"

#: ../../whatsnew/2.3.rst:1915
#, fuzzy
msgid ""
"File objects now manage their internal string buffer differently, increasing "
"it exponentially when needed.  This results in the benchmark tests in :file:"
"`Lib/test/test_bufio.py` speeding up considerably (from 57 seconds to 1.7 "
"seconds, according to one measurement)."
msgstr ""
"文件物件現在以不同方式管理其內部字串緩衝區，在需要時以指數方式增加。這導致 "
":file:`Lib/test/test_bufio.py` 中的基準測試大大加快（根據一項測量，從 57 "
"秒到 1.7 秒）。"

#: ../../whatsnew/2.3.rst:1920
#, fuzzy
msgid ""
"It's now possible to define class and static methods for a C extension type "
"by setting either the :const:`METH_CLASS` or :const:`METH_STATIC` flags in a "
"method's :c:type:`PyMethodDef` structure."
msgstr ""
"現在可以通過在方法的 PyMethodDef 結構中設定 METH_CLASS 或 METH_STATIC "
"旗標來為 C 擴充型別定義類和靜態方法。"

#: ../../whatsnew/2.3.rst:1924
#, fuzzy
msgid ""
"Python now includes a copy of the Expat XML parser's source code, removing "
"any dependence on a system version or local installation of Expat."
msgstr "Python 現在包含 Expat XML 解析器源程式碼的副本，消除了對系統版本或 Expat "
"本地安裝的任何依賴。"

#: ../../whatsnew/2.3.rst:1927
#, fuzzy
msgid ""
"If you dynamically allocate type objects in your extension, you should be "
"aware of a change in the rules relating to the :attr:`__module__` and :attr:"
"`~definition.__name__` attributes.  In summary, you will want to ensure the "
"type's dictionary contains a ``'__module__'`` key; making the module name "
"the part of the type name leading up to the final period will no longer have "
"the desired effect.  For more detail, read the API reference documentation "
"or the  source."
msgstr ""
"如果你在你的擴充中動態分配型別物件，你應該知道與 :attr:`__module__` 和 "
":attr:`~definition.__name__` 屬性相關的規則的變化。總之，"
"您需要確保型別的字典包含一個 ``'__module__'`` 鍵；使模組名稱成為導致最後一個"
"句點的型別名稱的一部分將不再具有預期的效果。有關更多詳細資訊，請閱讀 API "
"參考文檔或來源。"

#: ../../whatsnew/2.3.rst:1938
#, fuzzy
msgid "Port-Specific Changes"
msgstr "特定於端口的更改"

#: ../../whatsnew/2.3.rst:1940
#, fuzzy
msgid ""
"Support for a port to IBM's OS/2 using the EMX runtime environment was "
"merged into the main Python source tree.  EMX is a POSIX emulation layer "
"over the OS/2 system APIs.  The Python port for EMX tries to support all the "
"POSIX-like capability exposed by the EMX runtime, and mostly succeeds; :func:"
"`fork` and :func:`fcntl` are restricted by the limitations of the underlying "
"emulation layer.  The standard OS/2 port, which uses IBM's Visual Age "
"compiler, also gained support for case-sensitive import semantics as part of "
"the integration of the EMX port into CVS.  (Contributed by Andrew MacIntyre.)"
msgstr ""
"對使用 EMX 運行時環境的 IBM OS/2 端口的支援已合併到主 Python 源程式碼樹中。 "
"EMX 是 OS/2 系統 API 上的 POSIX 仿真層。 EMX 的 Python 端口試圖支援 EMX "
"運行時公開的所有類似 POSIX 的功能，並且大部分都成功了； :func:`fork` 和 "
":func:`fcntl` 受底層仿真層的限制。作為 EMX 端口集成到 CVS 的一部分，使用 IBM "
"的 Visual Age 編譯器的標準 OS/2 端口也獲得了對區分大小寫的導入語"
"義的支援。 （由安德魯·麥金泰爾提供。）"

#: ../../whatsnew/2.3.rst:1949
#, fuzzy
msgid ""
"On MacOS, most toolbox modules have been weaklinked to improve backward "
"compatibility.  This means that modules will no longer fail to load if a "
"single routine is missing on the current OS version. Instead calling the "
"missing routine will raise an exception. (Contributed by Jack Jansen.)"
msgstr ""
"在 MacOS 上，大多數工具箱模組都被弱鏈接以提高向後相容性。這意味著如果當前操作"
"系統版本缺少單個例程，模組將不再無法加載。相反，呼叫缺少的例程將引發例外。 "
"（由傑克詹森提供。）"

#: ../../whatsnew/2.3.rst:1954
#, fuzzy
msgid ""
"The RPM spec files, found in the :file:`Misc/RPM/` directory in the Python "
"source distribution, were updated for 2.3.  (Contributed by Sean "
"Reifschneider.)"
msgstr ""
"RPM 規範文件位於 Python 源程式碼分發的 :file:`Misc/RPM/` 目錄中，已針對 2.3 "
"進行了更新。 （由肖恩·賴夫施耐德提供。）"

#: ../../whatsnew/2.3.rst:1957
#, fuzzy
msgid ""
"Other new platforms now supported by Python include AtheOS (http://www."
"atheos.cx/), GNU/Hurd, and OpenVMS."
msgstr "Python 現在支援的其他新平台包括 AtheOS (http://www.atheos.cx/)、GNU/Hurd 和 "
"OpenVMS。"

#: ../../whatsnew/2.3.rst:1966
#, fuzzy
msgid "Other Changes and Fixes"
msgstr "其他更改和修復"

#: ../../whatsnew/2.3.rst:1968
#, fuzzy
msgid ""
"As usual, there were a bunch of other improvements and bugfixes scattered "
"throughout the source tree.  A search through the CVS change logs finds "
"there were 523 patches applied and 514 bugs fixed between Python 2.2 and "
"2.3.  Both figures are likely to be underestimates."
msgstr ""
"像往常一樣，在整個源程式碼樹中散佈著許多其他改進和錯誤修復。搜索 CVS "
"更改日誌發現在 Python 2.2 和 2.3 之間應用了 523 個補丁並修復了 514 "
"個錯誤。這兩個數字都可能被低估。"

#: ../../whatsnew/2.3.rst:1973
#, fuzzy
msgid "Some of the more notable changes are:"
msgstr "一些更顯著的變化是："

#: ../../whatsnew/2.3.rst:1975
#, fuzzy
msgid ""
"If the :envvar:`PYTHONINSPECT` environment variable is set, the Python "
"interpreter will enter the interactive prompt after running a Python "
"program, as if Python had been invoked with the :option:`-i` option. The "
"environment variable can be set before running the Python interpreter, or it "
"can be set by the Python program as part of its execution."
msgstr ""
"如果設定了 :envvar:`PYTHONINSPECT` 環境變數，Python 直譯器將在運行 Python "
"程式後進入交互式提示，就好像 Python 已使用 :option:`-i` 選項呼叫一樣。"
"環境變數可以在運行 Python 直譯器之前設定，也可以由 Python "
"程式作為其執行的一部分進行設定。"

#: ../../whatsnew/2.3.rst:1981
#, fuzzy
msgid ""
"The :file:`regrtest.py` script now provides a way to allow \"all resources "
"except *foo*.\"  A resource name passed to the :option:`!-u` option can now "
"be prefixed with a hyphen (``'-'``) to mean \"remove this resource.\"  For "
"example, the option '``-uall,-bsddb``' could be used to enable the use of "
"all resources except ``bsddb``."
msgstr ""
":file:`regrtest.py` 腳本現在提供了一種允許“除 *foo* 之外的所有資源”的方法。"
"傳遞給 :option:`!-u` 選項的資源名稱現在可以使用連字元 (``'-'``) 作為前綴，表"
"示“刪除此資源”。例如，選項“-uall,-bsddb”可用於啟用除 ``bsddb``之外的所有資源。"

#: ../../whatsnew/2.3.rst:1987
#, fuzzy
msgid ""
"The tools used to build the documentation now work under Cygwin as well as "
"Unix."
msgstr "用於構建文檔的工具現在可以在 Cygwin 和 Unix 下運行。"

#: ../../whatsnew/2.3.rst:1990
#, fuzzy
msgid ""
"The ``SET_LINENO`` opcode has been removed.  Back in the mists of time, this "
"opcode was needed to produce line numbers in tracebacks and support trace "
"functions (for, e.g., :mod:`pdb`). Since Python 1.5, the line numbers in "
"tracebacks have been computed using a different mechanism that works with "
"\"python -O\".  For Python 2.3 Michael Hudson implemented a similar scheme "
"to determine when to call the trace function, removing the need for "
"``SET_LINENO`` entirely."
msgstr ""
"``SET_LINENO`` 操作碼已被刪除。回到過去，需要這個操作碼來在回溯中生成行號並支"
"援跟踪函式（例如，:mod:`pdb`）。從 Python 1.5 開始，回溯中的行號是使用與“"
"python -O”一起使用的不同機制計算的。對於 Python 2.3，Michael Hudson "
"實施了一個類似的方案來確定何時呼叫跟踪函式，完全消除了對 SET_LINENO 的需要。"

#: ../../whatsnew/2.3.rst:1998
#, fuzzy
msgid ""
"It would be difficult to detect any resulting difference from Python code, "
"apart from a slight speed up when Python is run without :option:`-O`."
msgstr "除了在沒有 :option:`-O` 的情況下運行 Python 時略有加速之外，很難檢測到與 "
"Python 程式碼的任何結果差異。"

#: ../../whatsnew/2.3.rst:2001
#, fuzzy
msgid ""
"C extensions that access the :attr:`f_lineno` field of frame objects should "
"instead call ``PyCode_Addr2Line(f->f_code, f->f_lasti)``. This will have the "
"added effect of making the code work as desired under \"python -O\" in "
"earlier versions of Python."
msgstr ""
"訪問框架物件的 f_lineno 欄位的 C 擴充應該改為呼叫 PyCode_Addr2Line(f-"
">f_code, f->f_lasti)。這將使程式碼在早期版本的 Python 中的“python "
"-O”下按需要工作。"

#: ../../whatsnew/2.3.rst:2006
#, fuzzy
msgid ""
"A nifty new feature is that trace functions can now assign to the :attr:"
"`f_lineno` attribute of frame objects, changing the line that will be "
"executed next.  A ``jump`` command has been added to the :mod:`pdb` debugger "
"taking advantage of this new feature. (Implemented by Richie Hindle.)"
msgstr ""
"一個漂亮的新功能是跟踪函式現在可以分配給框架物件的 f_lineno "
"屬性，更改接下來將要執行的行。 ``jump`` 命令已新增到 :mod:`pdb` "
"除錯器中，利用了這一新功能。 （由 Richie Hindle 實施。）"

#: ../../whatsnew/2.3.rst:2015
#, fuzzy
msgid "Porting to Python 2.3"
msgstr "移植到 Python 2.3"

#: ../../whatsnew/2.3.rst:2017
#, fuzzy
msgid ""
"This section lists previously described changes that may require changes to "
"your code:"
msgstr "本部分列出了之前描述的可能需要更改程式碼的更改："

#: ../../whatsnew/2.3.rst:2020
#, fuzzy
msgid ""
":keyword:`yield` is now always a keyword; if it's used as a variable name in "
"your code, a different name must be chosen."
msgstr ":keyword:`yield` "
"現在始終是關鍵字；如果它在您的程式碼中用作變數名，則必須選擇不同的名稱。"

#: ../../whatsnew/2.3.rst:2023
#, fuzzy
msgid ""
"For strings *X* and *Y*, ``X in Y`` now works if *X* is more than one "
"character long."
msgstr "對於字串 *X* 和 *Y*，如果 *X* 的長度超過一個字元，``X in Y`` 現在可以工作。"

#: ../../whatsnew/2.3.rst:2026
#, fuzzy
msgid ""
"The :func:`int` type constructor will now return a long integer instead of "
"raising an :exc:`OverflowError` when a string or floating-point number is "
"too large to fit into an integer."
msgstr ""
":func:`int` 型別構造函式現在將回傳一個長整數，"
"而不是在字串或浮點數太大而無法放入整數時引發 :exc:`OverflowError`。"

#: ../../whatsnew/2.3.rst:2030
#, fuzzy
msgid ""
"If you have Unicode strings that contain 8-bit characters, you must declare "
"the file's encoding (UTF-8, Latin-1, or whatever) by adding a comment to the "
"top of the file.  See section :ref:`section-encodings` for more information."
msgstr ""
"如果您有包含 8 位字元的 Unicode "
"字串，則必須通過在文件頂部新增註釋來聲明文件的編碼（UTF-8、Latin-1 "
"或其他）。有關詳細資訊，請參閱部分 :ref:`section-encodings`。"

#: ../../whatsnew/2.3.rst:2034
#, fuzzy
msgid ""
"Calling Tcl methods through :mod:`_tkinter` no longer  returns only strings. "
"Instead, if Tcl returns other objects those objects are converted to their "
"Python equivalent, if one exists, or wrapped with a :class:`_tkinter."
"Tcl_Obj` object if no Python equivalent exists."
msgstr ""
"通過 :mod:`_tkinter` 呼叫 Tcl 方法不再僅回傳字串。相反，如果 Tcl "
"回傳其他物件，則這些物件將轉換為它們的 Python 等效項（如果存在），"
"或者如果不存在 Python 等效項則用 :class:`_tkinter.Tcl_Obj` 物件包裝。"

#: ../../whatsnew/2.3.rst:2039
#, fuzzy
msgid ""
"Large octal and hex literals such as ``0xffffffff`` now trigger a :exc:"
"`FutureWarning`. Currently they're stored as 32-bit numbers and result in a "
"negative value, but in Python 2.4 they'll become positive long integers."
msgstr ""
"大八進位和十六進位文字，例如 ``0xffffffff`` 現在觸發 :exc:`FutureWarning`。"
"目前它們儲存為 32 位數字並產生負值，但在 Python 2.4 中它們將變為正長整數。"

#: ../../whatsnew/2.3.rst:2043
#, fuzzy
msgid ""
"There are a few ways to fix this warning.  If you really need a positive "
"number, just add an ``L`` to the end of the literal.  If you're trying to "
"get a 32-bit integer with low bits set and have previously used an "
"expression such as ``~(1 << 31)``, it's probably clearest to start with all "
"bits set and clear the desired upper bits. For example, to clear just the "
"top bit (bit 31), you could write ``0xffffffffL &~(1L<<31)``."
msgstr ""
"有幾種方法可以修復此警告。如果你真的需要一個正數，只需在文字的末尾新增一個 ``L``"
"。如果你試圖獲得一個設定了低位的 32 位整數，並且之前使用過諸如 ``~(1 << 31)``"
" 的表達式，那麼從設定所有位開始並清除所需的高位可能是最清楚的位。例如，要僅清"
"除最高位（第 31 位），您可以編寫 ``0xffffffffL &~(1L<<31)``。"

#: ../../whatsnew/2.3.rst:2050
#, fuzzy
msgid "You can no longer disable assertions by assigning to ``__debug__``."
msgstr "您不能再通過分配給 __debug__ 來禁用斷言。"

#: ../../whatsnew/2.3.rst:2052
#, fuzzy
msgid ""
"The Distutils :func:`setup` function has gained various new keyword "
"arguments such as *depends*.  Old versions of the Distutils will abort if "
"passed unknown keywords.  A solution is to check for the presence of the "
"new :func:`get_distutil_options` function in your :file:`setup.py` and only "
"uses the new keywords with a version of the Distutils that supports them::"
msgstr ""
"Distutils :func:`setup` 函式獲得了各種新的關鍵字參數，例如 "
"*depends*。如果傳遞未知關鍵字，舊版本的 Distutils 將中止。一個解決方案是檢查 "
":func:`get_distutil_options` 函式是否存在於您的 :file:`setup.py` 中，"
"並且僅將新關鍵字與支援它們的 Distutils 版本一起使用::"

#: ../../whatsnew/2.3.rst:2065
#, fuzzy
msgid ""
"Using ``None`` as a variable name will now result in a :exc:`SyntaxWarning` "
"warning."
msgstr "使用 ``None`` 作為變數名現在將導致 :exc:`SyntaxWarning` 警告。"

#: ../../whatsnew/2.3.rst:2068
#, fuzzy
msgid ""
"Names of extension types defined by the modules included with Python now "
"contain the module and a ``'.'`` in front of the type name."
msgstr "由 Python 包含的模組定義的擴充型別的名稱現在包含模組和型別名稱前面的 ``'.'``。"

#: ../../whatsnew/2.3.rst:2077
msgid "Acknowledgements"
msgstr "致謝"

#: ../../whatsnew/2.3.rst:2079
#, fuzzy
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article: "
"Jeff Bauer, Simon Brunning, Brett Cannon, Michael Chermside, Andrew Dalke, "
"Scott David Daniels, Fred L. Drake, Jr., David Fraser,  Kelly Gerber, "
"Raymond Hettinger, Michael Hudson, Chris Lambert, Detlef Lannert, Martin von "
"Löwis, Andrew MacIntyre, Lalo Martins, Chad Netzer, Gustavo Niemeyer, Neal "
"Norwitz, Hans Nowak, Chris Reedy, Francesco Ricciardi, Vinay Sajip, Neil "
"Schemenauer, Roman Suzi, Jason Tishler, Just van Rossum."
msgstr ""
"作者要感謝以下人員為本文的各種草稿提供的建議、更正和幫助：Jeff Bauer、Simon "
"Brunning、Brett Cannon、Michael Chermside、Andrew Dalke、Scott David "
"Daniels、Fred L. Drake, Jr.、大衛·弗雷澤、凱利·格伯、雷蒙德·海廷格、邁克爾·哈"
"德森、克里斯·蘭伯特、德特勒夫·蘭內特、馬丁·馮·洛維斯、安德魯·麥金太爾、拉羅·"
"馬丁斯、查德·內策、古斯塔沃·尼邁耶、尼爾·諾維茨、漢斯·諾瓦克、克里斯·里迪、弗"
"朗切斯科·裡恰爾迪、維奈·薩吉普、尼爾Schemenauer、Roman Suzi、Jason Tishler、"
"Just van Rossum。"
