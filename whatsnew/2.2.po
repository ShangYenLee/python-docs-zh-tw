# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-31 08:13+0000\n"
"PO-Revision-Date: 2018-05-23 16:19+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../whatsnew/2.2.rst:3
msgid "What's New in Python 2.2"
msgstr "Python 2.2 有什麼新功能"

#: ../../whatsnew/2.2.rst:0
msgid "Author"
msgstr "作者"

#: ../../whatsnew/2.2.rst:5
msgid "A.M. Kuchling"
msgstr "A.M. Kuchling"

#: ../../whatsnew/2.2.rst:13
msgid "Introduction"
msgstr "簡介"

#: ../../whatsnew/2.2.rst:15
#, fuzzy
msgid ""
"This article explains the new features in Python 2.2.2, released on October "
"14, 2002.  Python 2.2.2 is a bugfix release of Python 2.2, originally "
"released on December 21, 2001."
msgstr ""
"本文介紹了 2002 年 10 月 14 日發布的 Python 2.2.2 中的新功能。Python 2.2.2 "
"是 Python 2.2 的錯誤修復版本，最初發佈於 2001 年 12 月 21 日。"

#: ../../whatsnew/2.2.rst:19
#, fuzzy
msgid ""
"Python 2.2 can be thought of as the \"cleanup release\".  There are some "
"features such as generators and iterators that are completely new, but most "
"of the changes, significant and far-reaching though they may be, are aimed "
"at cleaning up irregularities and dark corners of the language design."
msgstr ""
"Python 2.2 可以被認為是“清理版本”。有一些特性，如生成器和疊代器，是全新的，但"
"大多數變化，儘管它們可能是重要和深遠的，旨在清理語言設計中的不規則和黑暗角落"
"。"

#: ../../whatsnew/2.2.rst:24
#, fuzzy
msgid ""
"This article doesn't attempt to provide a complete specification of the new "
"features, but instead provides a convenient overview.  For full details, you "
"should refer to the documentation for Python 2.2, such as the `Python "
"Library Reference <https://docs.python.org/2.2/lib/lib.html>`_ and the "
"`Python Reference Manual <https://docs.python.org/2.2/ref/ref.html>`_.  If "
"you want to understand the complete implementation and design rationale for "
"a change, refer to the PEP for a particular new feature."
msgstr ""
"本文並不試圖提供新功能的完整規範，而是提供一個方便的概述。有關完整詳細資訊，"
"您應該參考 Python 2.2 的文檔，例如 `Python 庫參考 <https://docs.python.org/2."
"2/lib/lib.html>`_ 和 `Python 參考手冊 <https //docs.python.org/2.2/ref/ref."
"html>`_。如果您想了解更改的完整實作和設計原理，請參閱特定新功能的 PEP。"

#: ../../whatsnew/2.2.rst:43
#, fuzzy
msgid "PEPs 252 and 253: Type and Class Changes"
msgstr "PEP 252 和 253：型別和類別變更"

#: ../../whatsnew/2.2.rst:45
#, fuzzy
msgid ""
"The largest and most far-reaching changes in Python 2.2 are to Python's "
"model of objects and classes.  The changes should be backward compatible, so "
"it's likely that your code will continue to run unchanged, but the changes "
"provide some amazing new capabilities. Before beginning this, the longest "
"and most complicated section of this article, I'll provide an overview of "
"the changes and offer some comments."
msgstr ""
"Python 2.2 中最大和影響最深遠的變化是 Python 的物件和類模型。這些更改應該是向"
"後相容的，因此您的程式碼很可能會繼續保持不變地運行，但是這些更改提供了一些驚"
"人的新功能。在開始這篇文章中最長和最複雜的部分之前，我將概述更改並提供一些評"
"論。"

#: ../../whatsnew/2.2.rst:52
#, fuzzy
msgid ""
"A long time ago I wrote a web page listing flaws in Python's design.  One of "
"the most significant flaws was that it's impossible to subclass Python types "
"implemented in C.  In particular, it's not possible to subclass built-in "
"types, so you can't just subclass, say, lists in order to add a single "
"useful method to them. The :mod:`UserList` module provides a class that "
"supports all of the methods of lists and that can be subclassed further, but "
"there's lots of C code that expects a regular Python list and won't accept "
"a :class:`UserList` instance."
msgstr ""
"很久以前，我寫了一個網頁，列出了 Python 設計中的缺陷。"
"最重要的缺陷之一是不可能對用 C 實作的 Python 型別進行子類別化。特別是，不可能"
"對內建型別進行子類別化，因此您不能只對列表進行子類別化以新增一個有用的方法給"
"他們。 :mod:`UserList` "
"模組提供了一個類，它支援列表的所有方法並且可以進一步子類別化，但是有很多 C "
"程式碼需要一個常規的 Python 列表並且不會接受一個 :class:`UserList`實例。"

#: ../../whatsnew/2.2.rst:61
#, fuzzy
msgid ""
"Python 2.2 fixes this, and in the process adds some exciting new "
"capabilities. A brief summary:"
msgstr "Python 2.2 修復了這個問題，並在此過程中新增了一些令人興奮的新功能。簡要總結："

#: ../../whatsnew/2.2.rst:64
#, fuzzy
msgid ""
"You can subclass built-in types such as lists and even integers, and your "
"subclasses should work in every place that requires the original type."
msgstr "您可以對內建型別（例如列表甚至整數）進行子類別化，並且您的子類別應該適用於需"
"要原始型別的每個地方。"

#: ../../whatsnew/2.2.rst:67
#, fuzzy
msgid ""
"It's now possible to define static and class methods, in addition to the "
"instance methods available in previous versions of Python."
msgstr "除了以前版本的 Python 中可用的實例方法之外，現在還可以定義靜態方法和類方法。"

#: ../../whatsnew/2.2.rst:70
#, fuzzy
msgid ""
"It's also possible to automatically call methods on accessing or setting an "
"instance attribute by using a new mechanism called :dfn:`properties`.  Many "
"uses of :meth:`__getattr__` can be rewritten to use properties instead, "
"making the resulting code simpler and faster.  As a small side benefit, "
"attributes can now have docstrings, too."
msgstr ""
"還可以通過使用稱為 :dfn:`properties` "
"的新機制自動呼叫訪問或設定實例屬性的方法。 :meth:`__getattr__` 的許多用法都可"
"以改寫為使用屬性，從而使生成的程式碼更簡單、更快。作為一個小的附帶好處，屬性"
"現在也可以有文檔字串。"

#: ../../whatsnew/2.2.rst:76
#, fuzzy
msgid ""
"The list of legal attributes for an instance can be limited to a particular "
"set using :dfn:`slots`, making it possible to safeguard against typos and "
"perhaps make more optimizations possible in future versions of Python."
msgstr ""
"實例的合法屬性列表可以使用 :dfn:`slots` "
"限制為特定集合，從而可以防止打字錯誤，並可能在未來的 Python "
"版本中進行更多最佳化。"

#: ../../whatsnew/2.2.rst:80
#, fuzzy
msgid ""
"Some users have voiced concern about all these changes.  Sure, they say, the "
"new features are neat and lend themselves to all sorts of tricks that "
"weren't possible in previous versions of Python, but they also make the "
"language more complicated.  Some people have said that they've always "
"recommended Python for its simplicity, and feel that its simplicity is being "
"lost."
msgstr ""
"一些使用者對所有這些變化表示擔憂。當然，他們說，新功能很簡潔，"
"可以使用以前版本的 Python 不可能實作的各種技巧，"
"但它們也使語言更加複雜。有些人說他們一直推薦 Python "
"是因為它的簡單性，並且感覺它的簡單性正在丟失。"

#: ../../whatsnew/2.2.rst:86
#, fuzzy
msgid ""
"Personally, I think there's no need to worry.  Many of the new features are "
"quite esoteric, and you can write a lot of Python code without ever needed "
"to be aware of them.  Writing a simple class is no more difficult than it "
"ever was, so you don't need to bother learning or teaching them unless "
"they're actually needed.  Some very complicated tasks that were previously "
"only possible from C will now be possible in pure Python, and to my mind "
"that's all for the better."
msgstr ""
"就我個人而言，我認為沒有必要擔心。許多新功能都非常深奧，您可以編寫大量 "
"Python 程式碼而無需了解它們。編寫一個簡單的類並不比以往任何時候都困難，因此除"
"非確實需要，否則您無需費心學習或教授它們。以前只能從 C "
"中完成的一些非常複雜的任務現在可以在純 Python "
"中完成，在我看來，這一切都是為了更好。"

#: ../../whatsnew/2.2.rst:93
#, fuzzy
msgid ""
"I'm not going to attempt to cover every single corner case and small change "
"that were required to make the new features work.  Instead this section will "
"paint only the broad strokes.  See section :ref:`sect-rellinks`, \"Related "
"Links\", for further sources of information about Python 2.2's new object "
"model."
msgstr ""
"我不會嘗試涵蓋使新功能正常工作所需的每一個角落案例和小改動。相反，本節將只描"
"繪粗線條。有關 Python 2.2 的新物件模型的更多資訊來源，請參閱 :ref:`sect-"
"rellinks` 部分，“相關鏈接”。"

#: ../../whatsnew/2.2.rst:100
#, fuzzy
msgid "Old and New Classes"
msgstr "新老班級"

#: ../../whatsnew/2.2.rst:102
#, fuzzy
msgid ""
"First, you should know that Python 2.2 really has two kinds of classes: "
"classic or old-style classes, and new-style classes.  The old-style class "
"model is exactly the same as the class model in earlier versions of Python.  "
"All the new features described in this section apply only to new-style "
"classes. This divergence isn't intended to last forever; eventually old-"
"style classes will be dropped, possibly in Python 3.0."
msgstr ""
"首先，您應該知道 Python 2.2 確實有兩種類：經典或舊式類和新式類。"
"舊式類模型與早期版本的 Python 中的類模型完全相同。本節中描述的所有新功能僅適"
"用於新型類。這種分歧不會永遠持續下去。最終舊式類將被刪除，可能在 Python 3.0 "
"中。"

#: ../../whatsnew/2.2.rst:109
#, fuzzy
msgid ""
"So how do you define a new-style class?  You do it by subclassing an "
"existing new-style class.  Most of Python's built-in types, such as "
"integers, lists, dictionaries, and even files, are new-style classes now.  A "
"new-style class named :class:`object`, the base class for all built-in "
"types, has also been added so if no built-in type is suitable, you can just "
"subclass :class:`object`::"
msgstr ""
"那麼如何定義一個新式類呢？您可以通過子類別化現有的新型類來實作。 Python "
"的大部分內建型別，例如整數、列表、字典，甚至文件，現在都是新式類。"
"還新增了一個名為 :class:`object` "
"的新樣式類，它是所有內建型別的基底類別，因此如果沒有合適的內建型別，"
"您可以繼承 :class:`object`::"

#: ../../whatsnew/2.2.rst:121
#, fuzzy
msgid ""
"This means that :keyword:`class` statements that don't have any base classes "
"are always classic classes in Python 2.2.  (Actually you can also change "
"this by setting a module-level variable named :attr:`__metaclass__` --- see :"
"pep:`253` for the details --- but it's easier to just subclass :class:"
"`object`.)"
msgstr ""
"這意味著沒有任何基底類別的 :keyword:`class` 語句在 Python 2.2 "
"中始終是經典類。 （實際上你也可以通過設定一個模組級變數來改變它，命名為)"

#: ../../whatsnew/2.2.rst:126
#, fuzzy
msgid ""
"The type objects for the built-in types are available as built-ins, named "
"using a clever trick.  Python has always had built-in functions named :func:"
"`int`, :func:`float`, and :func:`str`.  In 2.2, they aren't functions any "
"more, but type objects that behave as factories when called. ::"
msgstr ""
"內建型別的型別物件可作為內建物件使用，使用巧妙的技巧命名。 Python "
"始終具有名為 :func:`int`、:func:`float` 和 :func:`str` 的內建函式。在 2.2 "
"中，它們不再是函式，而是在呼叫時充當工廠的型別物件。 ::"

#: ../../whatsnew/2.2.rst:136
#, fuzzy
msgid ""
"To make the set of types complete, new type objects such as :func:`dict` "
"and :func:`file` have been added.  Here's a more interesting example, adding "
"a :meth:`lock` method to file objects::"
msgstr ""
"為了使型別集完整，新增了新的型別物件，例如 :func:`dict` 和 "
":func:`file`。這是一個更有趣的示例，向文件物件新增 :meth:`lock` 方法::"

#: ../../whatsnew/2.2.rst:146
#, fuzzy
msgid ""
"The now-obsolete :mod:`posixfile` module contained a class that emulated all "
"of a file object's methods and also added a :meth:`lock` method, but this "
"class couldn't be passed to internal functions that expected a built-in "
"file, something which is possible with our new :class:`LockableFile`."
msgstr ""
"現已過時的 posixfile 模組包含一個模擬文件物件的所有方法的類，還新增了一個 "
"lock 方法，但此類無法傳遞給需要內建函式的內部函式在文件中，我們的新 "
":class:`LockableFile` 是可能的。"

#: ../../whatsnew/2.2.rst:153
#, fuzzy
msgid "Descriptors"
msgstr "描述器"

#: ../../whatsnew/2.2.rst:155
#, fuzzy
msgid ""
"In previous versions of Python, there was no consistent way to discover what "
"attributes and methods were supported by an object. There were some informal "
"conventions, such as defining :attr:`__members__` and :attr:`__methods__` "
"attributes that were lists of names, but often the author of an extension "
"type or a class wouldn't bother to define them.  You could fall back on "
"inspecting the :attr:`~object.__dict__` of an object, but when class "
"inheritance or an arbitrary :meth:`__getattr__` hook were in use this could "
"still be inaccurate."
msgstr ""
"在以前的 Python "
"版本中，沒有一致的方法來發現物件支援哪些屬性和方法。有一些非正式的約定，"
"例如定義 :attr:`__members__` 和 :attr:`__methods__` "
"屬性是名稱列表，但通常擴充型別或類的作者不會費心去定義它們。"
"您可以回過頭來檢查物件的 :attr:`~object.__dict__`，但是當使用類繼承或任意 "
":meth:`__getattr__` 掛鉤時，這仍然可能不准確。"

#: ../../whatsnew/2.2.rst:163
#, fuzzy
msgid ""
"The one big idea underlying the new class model is that an API for "
"describing the attributes of an object using :dfn:`descriptors` has been "
"formalized. Descriptors specify the value of an attribute, stating whether "
"it's a method or a field.  With the descriptor API, static methods and class "
"methods become possible, as well as more exotic constructs."
msgstr ""
"新類模型背後的一個重要想法是，使用 descriptors 描述物件屬性的 API "
"已經形式化。描述器指定屬性的值，說明它是方法還是欄位。使用描述器 "
"API，靜態方法和類方法以及更奇特的構造成為可能。"

#: ../../whatsnew/2.2.rst:169
#, fuzzy
msgid ""
"Attribute descriptors are objects that live inside class objects, and have a "
"few attributes of their own:"
msgstr "屬性描述器是存在於類物件中的物件，並且有一些自己的屬性："

#: ../../whatsnew/2.2.rst:172
#, fuzzy
msgid ":attr:`~definition.__name__` is the attribute's name."
msgstr ":attr:`~definition.__name__` 是屬性的名稱。"

#: ../../whatsnew/2.2.rst:174
#, fuzzy
msgid ":attr:`__doc__` is the attribute's docstring."
msgstr ":attr:`__doc__` 是屬性的文檔字串。"

#: ../../whatsnew/2.2.rst:176
#, fuzzy
msgid ""
"``__get__(object)`` is a method that retrieves the attribute value from "
"*object*."
msgstr "``__get__(object)`` 是一種從 *object* 中檢索屬性值的方法。"

#: ../../whatsnew/2.2.rst:179
msgid "``__set__(object, value)`` sets the attribute on *object* to *value*."
msgstr "``__set__(object, value)`` 將 *object* 上的屬性設定為 *value*。"

#: ../../whatsnew/2.2.rst:181
msgid ""
"``__delete__(object, value)`` deletes the *value*  attribute of *object*."
msgstr "``__delete__(object, value)`` 會刪除 *object* 的 *value* 屬性。"

#: ../../whatsnew/2.2.rst:183
#, fuzzy
msgid ""
"For example, when you write ``obj.x``, the steps that Python actually "
"performs are::"
msgstr "例如，當你寫 ``obj.x`` 時，Python 實際執行的步驟是："

#: ../../whatsnew/2.2.rst:189
#, fuzzy
msgid ""
"For methods, :meth:`descriptor.__get__` returns a temporary object that's "
"callable, and wraps up the instance and the method to be called on it. This "
"is also why static methods and class methods are now possible; they have "
"descriptors that wrap up just the method, or the method and the class.  As a "
"brief explanation of these new kinds of methods, static methods aren't "
"passed the instance, and therefore resemble regular functions.  Class "
"methods are passed the class of the object, but not the object itself.  "
"Static and class methods are defined like this::"
msgstr ""
"對於方法，:meth:`descriptor.__get__` 回傳一個可呼叫的臨時物件，並包裝實例和要"
"在其上呼叫的方法。這也是為什麼現在可以使用靜態方法和類方法的原因；它們的描述"
"器僅包含方法，或方法和類。作為對這些新型方法的簡要說明，靜態方法不通過實例傳"
"遞，因此類似於常規函式"
"。類方法傳遞給物件的類，而不是物件本身。靜態和類方法定義如下："

#: ../../whatsnew/2.2.rst:207
#, fuzzy
msgid ""
"The :func:`staticmethod` function takes the function :func:`f`, and returns "
"it wrapped up in a descriptor so it can be stored in the class object.  You "
"might expect there to be special syntax for creating such methods (``def "
"static f``, ``defstatic f()``, or something like that) but no such syntax "
"has been defined yet; that's been left for future versions of Python."
msgstr ""
":func:`staticmethod` 函式採用函式 :func:`f`，並將其包裝在描述器中回傳，以便將"
"其儲存在類物件中。您可能希望有用於建立此類方法的特殊語法（``def static "
"f``、``defstatic f()`` 或類似的東西），但尚未定義此類語法；"
"這是留給未來版本的 Python 的。"

#: ../../whatsnew/2.2.rst:213
#, fuzzy
msgid ""
"More new features, such as slots and properties, are also implemented as new "
"kinds of descriptors, and it's not difficult to write a descriptor class "
"that does something novel.  For example, it would be possible to write a "
"descriptor class that made it possible to write Eiffel-style preconditions "
"and postconditions for a method.  A class that used this feature might be "
"defined like this::"
msgstr ""
"更多的新特性，比如槽和屬性，也被實作為新種類的描述器，編寫一個描述器類來做一"
"些新穎的事情並不困難。例如，可以編寫一個描述器類，使為方法編寫 Eiffel "
"風格的前置條件和後置條件成為可能。使用此功能的類可能定義如下："

#: ../../whatsnew/2.2.rst:235
#, fuzzy
msgid ""
"Note that a person using the new :func:`eiffelmethod` doesn't have to "
"understand anything about descriptors.  This is why I think the new features "
"don't increase the basic complexity of the language. There will be a few "
"wizards who need to know about it in order to write :func:`eiffelmethod` or "
"the ZODB or whatever, but most users will just write code on top of the "
"resulting libraries and ignore the implementation details."
msgstr ""
"請注意，使用新的 :func:`eiffelmethod` 的人不必了解任何關於描述器的知識。這就"
"是為什麼我認為新特性不會增加語言的基本複雜性。會有一些嚮導需要了解它才能編寫 "
":func:`eiffelmethod` 或 ZODB "
"或其他任何東西，但大多數使用者只會在生成的庫之上編寫程式碼而忽略實作細節。"

#: ../../whatsnew/2.2.rst:244
#, fuzzy
msgid "Multiple Inheritance: The Diamond Rule"
msgstr "多重繼承：鑽石法則"

#: ../../whatsnew/2.2.rst:246
#, fuzzy
msgid ""
"Multiple inheritance has also been made more useful through changing the "
"rules under which names are resolved.  Consider this set of classes (diagram "
"taken from :pep:`253` by Guido van Rossum)::"
msgstr "通過更改解析名稱的規則，多重繼承也變得更加有用。考慮這組類（圖表取自 Guido "
"van Rossum 的 :pep:`253`）："

#: ../../whatsnew/2.2.rst:264
#, fuzzy
msgid ""
"The lookup rule for classic classes is simple but not very smart; the base "
"classes are searched depth-first, going from left to right.  A reference to :"
"meth:`D.save` will search the classes :class:`D`, :class:`B`, and then :"
"class:`A`, where :meth:`save` would be found and returned.  :meth:`C.save` "
"would never be found at all.  This is bad, because if :class:`C`'s :meth:"
"`save` method is saving some internal state specific to :class:`C`, not "
"calling it will result in that state never getting saved."
msgstr ""
"經典類的查找規則簡單但不是很智能；基底類別的搜索深度優先，從左到右。對 :meth:`"
"D.save` 的引用將搜索類 :class:`D`、:class:`B`，然後是 :class:`A`，其中將找到並"
"回傳 :meth:`save` . :meth:`C.save` 根本找不到。這很糟糕，因為如果 :class:`C` "
"的 :meth:`save` 方法正在保存一些特定於 :class:`C` "
"的內部狀態，不呼叫它會導致該狀態永遠不會被保存。"

#: ../../whatsnew/2.2.rst:272
#, fuzzy
msgid ""
"New-style classes follow a different algorithm that's a bit more complicated "
"to explain, but does the right thing in this situation. (Note that Python "
"2.3 changes this algorithm to one that produces the same results in most "
"cases, but produces more useful results for really complicated inheritance "
"graphs.)"
msgstr ""
"新型類遵循一種不同的演算法，解釋起來有點複雜，但在這種情況下會做正確的事情。 "
"（請注意，Python 2.3 將此演算法更改為在大多數情況下產生相同結果的演算法，但對"
"真正複雜的繼承圖產生更有用的結果。）"

#: ../../whatsnew/2.2.rst:277
#, fuzzy
msgid ""
"List all the base classes, following the classic lookup rule and include a "
"class multiple times if it's visited repeatedly.  In the above example, the "
"list of visited classes is [ :class:`D`, :class:`B`, :class:`A`, :class:`C`, :"
"class:`A`]."
msgstr ""
"列出所有基底類別，遵循經典查找規則，如果重複訪問某個類，則多次包含該類。在上"
"面的例子中，訪問類的列表是 [ :class:`D`, :class:`B`, :class:`A`, :class:`C`, "
":class:`A`]。"

#: ../../whatsnew/2.2.rst:282
#, fuzzy
msgid ""
"Scan the list for duplicated classes.  If any are found, remove all but one "
"occurrence, leaving the *last* one in the list.  In the above example, the "
"list becomes [ :class:`D`, :class:`B`, :class:`C`, :class:`A`] after dropping "
"duplicates."
msgstr ""
"掃描列表以查找重複的類。如果找到任何一個，則刪除除一個以外的所有匹配項，將*最"
"後一個*保留在列表中。在上面的示例中，列表在刪除重複項後變為 [ :class:`D`, "
":class:`B`, :class:`C`, :class:`A`]。"

#: ../../whatsnew/2.2.rst:287
#, fuzzy
msgid ""
"Following this rule, referring to :meth:`D.save` will return :meth:`C.save`, "
"which is the behaviour we're after.  This lookup rule is the same as the one "
"followed by Common Lisp.  A new built-in function, :func:`super`, provides a "
"way to get at a class's superclasses without having to reimplement Python's "
"algorithm. The most commonly used form will be  ``super(class, obj)``, which "
"returns  a bound superclass object (not the actual class object).  This form "
"will be used in methods to call a method in the superclass; for example, :"
"class:`D`'s :meth:`save` method would look like this::"
msgstr ""
"遵循此規則，引用 :meth:`D.save` 將回傳 :meth:`C.save`，這是我們所追求的行為。"
"這個查找規則與 Common Lisp 遵循的規則相同。一個新的內建函式 :func:`super` "
"提供了一種獲取類的超類的方法，而無需重新實作 Python 的演算法。最常用的形式是 "
"``super(class, obj)``，它回傳一個綁定的超類物件（不是實際的類物件）。這種形式"
"將在方法中用於呼叫超類中的方法；例如，:class:`D` 的 :meth:`save` "
"方法看起來像這樣："

#: ../../whatsnew/2.2.rst:303
#, fuzzy
msgid ""
":func:`super` can also return unbound superclass objects when called as "
"``super(class)`` or ``super(class1, class2)``, but this probably won't often "
"be useful."
msgstr ""
":func:`super` 也可以在呼叫為 ``super(class)`` 或 ``super(class1, class2)`` "
"時回傳未綁定的超類物件，但這可能不會經常有用。"

#: ../../whatsnew/2.2.rst:309
#, fuzzy
msgid "Attribute Access"
msgstr "屬性訪問"

#: ../../whatsnew/2.2.rst:311
#, fuzzy
msgid ""
"A fair number of sophisticated Python classes define hooks for attribute "
"access using :meth:`__getattr__`; most commonly this is done for "
"convenience, to make code more readable by automatically mapping an "
"attribute access such as ``obj.parent`` into a method call such as ``obj."
"get_parent``.  Python 2.2 adds some new ways of controlling attribute access."
msgstr ""
"相當多的複雜 Python 類使用 :meth:`__getattr__` "
"定義屬性訪問的鉤子；大多數情況下，這樣做是為了方便，通過自動將屬性訪問（例如 "
"``obj.parent`` 映射到方法呼叫（例如 ``obj."
"get_parent``）來提高程式碼的可讀性。 Python 2.2 "
"新增了一些控制屬性訪問的新方法。"

#: ../../whatsnew/2.2.rst:317
#, fuzzy
msgid ""
"First, ``__getattr__(attr_name)`` is still supported by new-style classes, "
"and nothing about it has changed.  As before, it will be called when an "
"attempt is made to access ``obj.foo`` and no attribute named ``foo`` is "
"found in the instance's dictionary."
msgstr ""
"首先，``__getattr__(attr_name)`` "
"仍然受到新型類的支援，並且沒有任何改變。和以前一樣，當嘗試訪問 ``obj.foo`` "
"並且在實例的字典中找不到名為 ``foo`` 的屬性時，它將被呼叫。"

#: ../../whatsnew/2.2.rst:322
#, fuzzy
msgid ""
"New-style classes also support a new method, "
"``__getattribute__(attr_name)``.  The difference between the two methods is "
"that :meth:`__getattribute__` is *always* called whenever any attribute is "
"accessed, while the old :meth:`__getattr__` is only called if ``foo`` isn't "
"found in the instance's dictionary."
msgstr ""
"新型類還支援一種新方法，``__getattribute__(attr_name)``。這兩種方法之間的區別"
"在於 :meth:`__getattribute__` "
"*總是*在訪問任何屬性時呼叫，而舊的 :meth:`__getattr__` 僅在實例的字典。"

#: ../../whatsnew/2.2.rst:328
#, fuzzy
msgid ""
"However, Python 2.2's support for :dfn:`properties` will often be a simpler "
"way to trap attribute references.  Writing a :meth:`__getattr__` method is "
"complicated because to avoid recursion you can't use regular attribute "
"accesses inside them, and instead have to mess around with the contents of :"
"attr:`~object.__dict__`. :meth:`__getattr__` methods also end up being "
"called by Python when it checks for other methods such as :meth:`__repr__` "
"or :meth:`__coerce__`, and so have to be written with this in mind. Finally, "
"calling a function on every attribute access results in a sizable "
"performance loss."
msgstr ""
"然而，Python 2.2 對 :dfn:`properties` 的支援通常是捕獲屬性引用的更簡單方法。"
"編寫 :meth:`__getattr__` "
"方法很複雜，因為要避免遞迴，您不能在其中使用常規屬性訪問，而必須弄亂 "
":attr:`~object.__dict__` 的內容。 :meth:`__getattr__` 方法最終也會在 Python "
"檢查其他方法時被呼叫，例如 :meth:`__repr__` 或 :meth:`__coerce__`，因此在編寫"
"時必須牢記這一點。最後，對每個屬性訪問呼叫一個函式會導致相當大的性能損失。"

#: ../../whatsnew/2.2.rst:337
#, fuzzy
msgid ""
":class:`property` is a new built-in type that packages up three functions "
"that get, set, or delete an attribute, and a docstring.  For example, if you "
"want to define a :attr:`size` attribute that's computed, but also settable, "
"you could write::"
msgstr ""
":class:`property` "
"是一種新的內建型別，它封裝了獲取、設定或刪除屬性和文檔字串這三個函式。例如，"
"如果你想定義一個 :attr:`size` "
"屬性，它是可計算的，但也是可設定的，你可以這樣寫："

#: ../../whatsnew/2.2.rst:357
#, fuzzy
msgid ""
"That is certainly clearer and easier to write than a pair of :meth:"
"`__getattr__`/:meth:`__setattr__` methods that check for the :attr:`size` "
"attribute and handle it specially while retrieving all other attributes from "
"the instance's :attr:`~object.__dict__`.  Accesses to :attr:`size` are also "
"the only ones which have to perform the work of calling a function, so "
"references to other attributes run at their usual speed."
msgstr ""
"這肯定比一對 :meth:`__getattr__`/:meth:`__setattr__` 方法更清晰、更容易編寫，"
"後者檢查 :attr:`size` "
"屬性並在從實例的檢索所有其他屬性時專門處理它 :attr:`~object.__dict__`。對 "
":attr:`size` 的訪問也是唯一必須執行呼叫函式工作的訪問，因此對其他屬性的引用以"
"它們通常的速度運行。"

#: ../../whatsnew/2.2.rst:364
#, fuzzy
msgid ""
"Finally, it's possible to constrain the list of attributes that can be "
"referenced on an object using the new :attr:`~object.__slots__` class "
"attribute. Python objects are usually very dynamic; at any time it's "
"possible to define a new attribute on an instance by just doing ``obj."
"new_attr=1``.   A new-style class can define a class attribute named :attr:"
"`~object.__slots__` to limit the legal attributes  to a particular set of "
"names.  An example will make this clear::"
msgstr ""
"最後，可以使用新的 :attr:`~object.__slots__` "
"類屬性來限制可在物件上引用的屬性列表。 Python 物件通常非常動態；在任何時候，"
"只需執行 obj.new_attr=1 就可以在實例上定義新屬性。新式類可以定義一個名為 "
":attr:`~object.__slots__` "
"的類屬性，以將合法屬性限制為一組特定的名稱。一個例子將清楚地說明這一點::"

#: ../../whatsnew/2.2.rst:385
#, fuzzy
msgid ""
"Note how you get an :exc:`AttributeError` on the attempt to assign to an "
"attribute not listed in :attr:`~object.__slots__`."
msgstr ""
"請注意，在嘗試分配給未在 :attr:`~object.__slots__` 中列出的屬性時，"
"您是如何得到 :exc:`AttributeError` 的。"

#: ../../whatsnew/2.2.rst:392
#, fuzzy
msgid "Related Links"
msgstr "相關鏈接"

#: ../../whatsnew/2.2.rst:394
#, fuzzy
msgid ""
"This section has just been a quick overview of the new features, giving "
"enough of an explanation to start you programming, but many details have "
"been simplified or ignored.  Where should you go to get a more complete "
"picture?"
msgstr "本節只是對新功能的快速概述，提供了足夠的解釋來開始您的編程，但許多細節已被簡"
"化或忽略。您應該去哪裡獲得更完整的圖片？"

#: ../../whatsnew/2.2.rst:398
#, fuzzy
msgid ""
"The :ref:`descriptorhowto` is a lengthy tutorial introduction to the "
"descriptor features, written by Guido van Rossum. If my description has "
"whetted your appetite, go read this tutorial next, because it goes into much "
"more detail about the new features while still remaining quite easy to read."
msgstr ""
":ref:`descriptorhowto` 是描述器功能的冗長教程介紹，由 Guido van Rossum 編寫。"
"如果我的描述激起了您的胃口，請接下來閱讀本教程，因為它更詳細地介紹了新功能，"
"同時仍然非常易於閱讀。"

#: ../../whatsnew/2.2.rst:403
#, fuzzy
msgid ""
"Next, there are two relevant PEPs, :pep:`252` and :pep:`253`.  :pep:`252` is "
"titled \"Making Types Look More Like Classes\", and covers the descriptor "
"API. :pep:`253` is titled \"Subtyping Built-in Types\", and describes the "
"changes to type objects that make it possible to subtype built-in objects.  :"
"pep:`253` is the more complicated PEP of the two, and at a few points the "
"necessary explanations of types and meta-types may cause your head to "
"explode.  Both PEPs were written and implemented by Guido van Rossum, with "
"substantial assistance from the rest of the Zope Corp. team."
msgstr ""
"接下來，有兩個相關的 PEP，:pep:`252` 和 :pep:`253`。 :pep:`252` "
"的標題是“讓型別看起來更像類”，涵蓋了描述器 API。 :pep:`253` 的標題是“子型別化"
"內建型別”，並描述了型別物件的變化，這些變化使得可以對內建物件進行子型別化。 "
":pep:`253` 是兩者中更複雜的 "
"PEP，在某些地方，對型別和元型別的必要解釋可能會使您的腦袋爆炸。這兩個 PEP "
"都是由 Guido van Rossum 編寫和實施的，並得到了 Zope Corp. "
"團隊其他成員的大力協助。"

#: ../../whatsnew/2.2.rst:412
#, fuzzy
msgid ""
"Finally, there's the ultimate authority: the source code.  Most of the "
"machinery for the type handling is in :file:`Objects/typeobject.c`, but you "
"should only resort to it after all other avenues have been exhausted, "
"including posting a question to python-list or python-dev."
msgstr ""
"最後，還有終極權威：源程式碼。大多數型別處理機制都在 :file:`Objects/"
"typeobject.c` 中，但您應該只在用盡所有其他途徑（包括向 python-list 或 python-"
"dev 發布問題）後才求助於它。"

#: ../../whatsnew/2.2.rst:421
#, fuzzy
msgid "PEP 234: Iterators"
msgstr "PEP 234：疊代器"

#: ../../whatsnew/2.2.rst:423
#, fuzzy
msgid ""
"Another significant addition to 2.2 is an iteration interface at both the C "
"and Python levels.  Objects can define how they can be looped over by "
"callers."
msgstr "2.2 的另一個重要補充是 C 和 Python "
"級別的疊代介面。物件可以定義它們如何被呼叫者循環。"

#: ../../whatsnew/2.2.rst:426
#, fuzzy
msgid ""
"In Python versions up to 2.1, the usual way to make ``for item in obj`` work "
"is to define a :meth:`__getitem__` method that looks something like this::"
msgstr ""
"在高達 2.1 的 Python 版本中，使 ``for item in obj`` 工作的通常方法是定義一個 "
":meth:`__getitem__` 方法，如下所示："

#: ../../whatsnew/2.2.rst:432
#, fuzzy
msgid ""
":meth:`__getitem__` is more properly used to define an indexing operation on "
"an object so that you can write ``obj[5]`` to retrieve the sixth element.  "
"It's a bit misleading when you're using this only to support :keyword:`for` "
"loops. Consider some file-like object that wants to be looped over; the "
"*index* parameter is essentially meaningless, as the class probably assumes "
"that a series of :meth:`__getitem__` calls will be made with *index* "
"incrementing by one each time.  In other words, the presence of the :meth:"
"`__getitem__` method doesn't mean that using ``file[5]``  to randomly access "
"the sixth element will work, though it really should."
msgstr ""
":meth:`__getitem__` 更適合用於定義物件的索引操作，這樣您就可以編寫 ``obj[5]``"
" 來檢索第六個元素。當您僅使用它來支援 :keyword:`for` "
"循環時，這有點誤導。考慮一些想要循環的類似文件的物件； *index* "
"參數本質上是無意義的，因為該類可能假設將進行一系列 :meth:`__getitem__` 呼叫，"
"每次 *index* 遞增 1。換句話說，:meth:`__getitem__` 方法的存在並不意味著使用 "
"``file[5]`` 隨機訪問第六個元素會起作用，儘管它確實應該起作用。"

#: ../../whatsnew/2.2.rst:442
#, fuzzy
msgid ""
"In Python 2.2, iteration can be implemented separately, and :meth:"
"`__getitem__` methods can be limited to classes that really do support "
"random access.  The basic idea of iterators is  simple.  A new built-in "
"function, ``iter(obj)`` or ``iter(C, sentinel)``, is used to get an "
"iterator. ``iter(obj)`` returns an iterator for the object *obj*, while "
"``iter(C, sentinel)`` returns an iterator that will invoke the callable "
"object *C* until it returns *sentinel* to signal that the iterator is done."
msgstr ""
"在 Python 2.2 中，疊代可以單獨實作，並且 :meth:`__getitem__` 方法可以限制在真"
"正支援隨機訪問的類中。疊代器的基本思想很簡單。一個新的內建函式“iter(obj)”或“i"
"ter(C, sentinel)”用於獲取疊代器。 ``iter(obj)`` 回傳物件 *obj* 的疊代器，而 "
"``iter(C, sentinel)`` 回傳一個疊代器，該疊代器將呼叫可呼叫物件 *C* "
"直到它回傳 *sentinel* 以發出信號疊代器完成了。"

#: ../../whatsnew/2.2.rst:450
#, fuzzy
msgid ""
"Python classes can define an :meth:`__iter__` method, which should create "
"and return a new iterator for the object; if the object is its own iterator, "
"this method can just return ``self``.  In particular, iterators will usually "
"be their own iterators.  Extension types implemented in C can implement a :c:"
"member:`~PyTypeObject.tp_iter` function in order to return an iterator, and "
"extension types that want to behave as iterators can define a :c:member:"
"`~PyTypeObject.tp_iternext` function."
msgstr ""
"Python 類可以定義一個 :meth:`__iter__` "
"方法，該方法應該為物件建立並回傳一個新的疊代器；如果物件是它自己的疊代器，"
"這個方法可以只回傳 ``self``。特別是，疊代器通常是它們自己的疊代器。在 C "
"中實作的擴充型別可以實作一個 :c:member:`~PyTypeObject.tp_iter` "
"函式以回傳一個疊代器，而想要作為疊代器的擴充型別可以定義一個 "
":c:member:`~PyTypeObject.tp_iternext`功能。"

#: ../../whatsnew/2.2.rst:457
#, fuzzy
msgid ""
"So, after all this, what do iterators actually do?  They have one required "
"method, :meth:`next`, which takes no arguments and returns the next value.  "
"When there are no more values to be returned, calling :meth:`next` should "
"raise the :exc:`StopIteration` exception. ::"
msgstr ""
"那麼，在這之後，疊代器實際上做了什麼？他們有一個必需的方法 :meth:`next`，它不"
"帶參數並回傳下一個值。當沒有更多值要回傳時，呼叫 next 應該引發 StopIteration "
"例外。 ::"

#: ../../whatsnew/2.2.rst:478
#, fuzzy
msgid ""
"In 2.2, Python's :keyword:`for` statement no longer expects a sequence; it "
"expects something for which :func:`iter` will return an iterator. For "
"backward compatibility and convenience, an iterator is automatically "
"constructed for sequences that don't implement :meth:`__iter__` or a :c:"
"member:`~PyTypeObject.tp_iter` slot, so ``for i in [1,2,3]`` will still "
"work.  Wherever the Python interpreter loops over a sequence, it's been "
"changed to use the iterator protocol.  This means you can do things like "
"this::"
msgstr ""
"在 2.2 中，Python 的 :keyword:`for` 語句不再需要序列；它期望 :func:`iter` "
"將回傳一個疊代器。為了向後相容和方便，會自動為未實作 :meth:`__iter__` 或 "
":c:member:`~PyTypeObject.tp_iter` 槽的序列構造疊代器，因此 ``for i in [1,2, "
"3]`` 仍然有效。無論 Python 直譯器在哪個序列上循環，它都已更改為使用疊代器協定"
"。這意味著你可以做這樣的事情::"

#: ../../whatsnew/2.2.rst:492
#, fuzzy
msgid ""
"Iterator support has been added to some of Python's basic types.   Calling :"
"func:`iter` on a dictionary will return an iterator which loops over its "
"keys::"
msgstr "疊代器支援已新增到 Python 的一些基本型別中。在字典上呼叫 :func:`iter` "
"將回傳一個遍歷其鍵的疊代器::"

#: ../../whatsnew/2.2.rst:512
#, fuzzy
msgid ""
"That's just the default behaviour.  If you want to iterate over keys, "
"values, or key/value pairs, you can explicitly call the :meth:`iterkeys`, :"
"meth:`itervalues`, or :meth:`iteritems` methods to get an appropriate "
"iterator. In a minor related change, the :keyword:`in` operator now works on "
"dictionaries, so ``key in dict`` is now equivalent to ``dict.has_key(key)``."
msgstr ""
"這只是預設行為。如果要疊代鍵、值或鍵/值對，可以顯式呼叫 iterkeys、itervalues "
"或 iteritems 方法來獲取合適的疊代器。在一個較小的相關更改中，:keyword:`in` "
"運算符現在適用於字典，因此 ``key in dict`` 現在等同於 ``dict.has_key(key)``。"

#: ../../whatsnew/2.2.rst:518
#, fuzzy
msgid ""
"Files also provide an iterator, which calls the :meth:`readline` method "
"until there are no more lines in the file.  This means you can now read each "
"line of a file using code like this::"
msgstr "文件還提供了一個疊代器，它呼叫 :meth:`readline` "
"方法，直到文件中不再有行。這意味著您現在可以使用如下程式碼讀取文件的每一行："

#: ../../whatsnew/2.2.rst:526
#, fuzzy
msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it. An iterator "
"object could provide such additional capabilities, but the iterator protocol "
"only requires a :meth:`next` method."
msgstr ""
"請注意，您只能在疊代器中前進；無法獲取前一個元素、重置疊代器或複制它。疊代器"
"物件可以提供這樣的附加功能，但疊代器協定只需要一個 next 方法。"

#: ../../whatsnew/2.2.rst:535
#, fuzzy
msgid ":pep:`234` - Iterators"
msgstr ":pep:`234` - 疊代器"

#: ../../whatsnew/2.2.rst:535
#, fuzzy
msgid ""
"Written by Ka-Ping Yee and GvR; implemented  by the Python Labs crew, mostly "
"by GvR and Tim Peters."
msgstr "由 Ka-Ping Yee 和 GvR 撰寫；由 Python Labs 工作人員實施，主要由 GvR 和 Tim "
"Peters 實施。"

#: ../../whatsnew/2.2.rst:542
#, fuzzy
msgid "PEP 255: Simple Generators"
msgstr "PEP 255：簡單生成器"

#: ../../whatsnew/2.2.rst:544
#, fuzzy
msgid ""
"Generators are another new feature, one that interacts with the introduction "
"of iterators."
msgstr "生成器是另一個新特性，它與疊代器的引入相互作用。"

#: ../../whatsnew/2.2.rst:547
#, fuzzy
msgid ""
"You're doubtless familiar with how function calls work in Python or C.  When "
"you call a function, it gets a private namespace where its local variables "
"are created.  When the function reaches a :keyword:`return` statement, the "
"local variables are destroyed and the resulting value is returned to the "
"caller.  A later call to the same function will get a fresh new set of local "
"variables. But, what if the local variables weren't thrown away on exiting a "
"function? What if you could later resume the function where it left off?  "
"This is what generators provide; they can be thought of as resumable "
"functions."
msgstr ""
"您無疑熟悉函式呼叫在 Python 或 C 中的工作方式。當您呼叫一個函式時，它會獲得一"
"個私有名稱空間，在該名稱空間中建立了它的局部變數。當函式到達 :keyword:`return`"
" 語句時，局部變數將被銷毀並將結果值回傳給呼叫者。稍後呼叫同一函式將獲得一組全"
"新的局部變數。但是，如果局部變數在退出函式時沒有被丟棄怎麼辦？如果您稍後可以"
"在它停止的地方恢復功能怎麼辦？這就是生成器提供的；它們可以被認為是可恢復的功"
"能。"

#: ../../whatsnew/2.2.rst:556
#, fuzzy
msgid "Here's the simplest example of a generator function::"
msgstr "這是生成器函式的最簡單示例："

#: ../../whatsnew/2.2.rst:562
#, fuzzy
msgid ""
"A new keyword, :keyword:`yield`, was introduced for generators.  Any "
"function containing a :keyword:`!yield` statement is a generator function; "
"this is detected by Python's bytecode compiler which compiles the function "
"specially as a result.  Because a new keyword was introduced, generators "
"must be explicitly enabled in a module by including a ``from __future__ "
"import generators`` statement near the top of the module's source code.  In "
"Python 2.3 this statement will become unnecessary."
msgstr ""
"為生成器引入了一個新關鍵字 :keyword:`yield`。任何包含 :keyword:`!yield` "
"語句的函式都是生成器函式；這是由 Python 的位元組碼編譯器檢測到的，它會專門編"
"譯該函式作為結果。由於引入了一個新關鍵字，因此必須通過在模組源程式碼頂部附近"
"包含“from __future__ import generators”語句來在模組中顯式啟用生成器。在 "
"Python 2.3 中，這個語句將變得不必要。"

#: ../../whatsnew/2.2.rst:570
#, fuzzy
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the :keyword:`yield` statement, the generator outputs the value "
"of ``i``, similar to a :keyword:`return` statement.  The big difference "
"between :keyword:`!yield` and a :keyword:`!return` statement is that on "
"reaching a :keyword:`!yield` the generator's state of execution is suspended "
"and local variables are preserved.  On the next call to the generator's "
"``next()`` method, the function will resume executing immediately after the :"
"keyword:`!yield` statement.  (For complicated reasons, the :keyword:`!yield` "
"statement isn't allowed inside the :keyword:`!try` block of a :keyword:"
"`try`...\\ :keyword:`finally` statement; read :pep:`255` for a full "
"explanation of the interaction between :keyword:`!yield` and exceptions.)"
msgstr ""
"當您呼叫生成器函式時，它不會回傳單個值；相反，它回傳一個支援疊代器協定的生成"
"器物件。在執行 :keyword:`yield` 語句時，生成器輸出 ``i`` 的值，類似於 "
":keyword:`return` 語句。 :keyword:`!yield` 和 :keyword:`!return` "
"語句之間的最大區別在於，在到達 :keyword:`!yield` "
"時，生成器的執行狀態被掛起並保留局部變數。在下一次呼叫生成器的 ``next()`` "
"方法時，該函式將在 :keyword:`!yield` 語句之後立即恢復執行。 "
"（出於復雜的原因，:keyword:`!yield` 語句不允許在 :keyword:`try`...\\ "
":keyword:`finally` 語句的 :keyword:`!try` 塊內；閱讀： pep:`255` 以獲得 "
":keyword:`!yield` 和例外之間相互作用的完整解釋。）"

#: ../../whatsnew/2.2.rst:583
#, fuzzy
msgid "Here's a sample usage of the :func:`generate_ints` generator::"
msgstr "以下是 :func:`generate_ints` 生成器的示例用法："

#: ../../whatsnew/2.2.rst:600
#, fuzzy
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a,b,c = "
"generate_ints(3)``."
msgstr "你同樣可以寫 ``for i in generate_ints(5)`` 或 ``a,b,c = generate_ints(3)``。"

#: ../../whatsnew/2.2.rst:603
#, fuzzy
msgid ""
"Inside a generator function, the :keyword:`return` statement can only be "
"used without a value, and signals the end of the procession of values; "
"afterwards the generator cannot return any further values. :keyword:`!"
"return` with a value, such as ``return 5``, is a syntax error inside a "
"generator function.  The end of the generator's results can also be "
"indicated by raising :exc:`StopIteration` manually, or by just letting the "
"flow of execution fall off the bottom of the function."
msgstr ""
"在生成器函式中，:keyword:`return` 語句只能在沒有值的情況下使用，並表示值處理"
"的結束；之後生成器不能回傳任何進一步的值。 :keyword:`!return` 帶有一個值，"
"例如 ``return 5``，是生成器函式內部的語法錯誤。"
"生成器結果的結束也可以通過手動提高 :exc:`StopIteration` "
"來指示，或者只是讓執行流從函式的底部掉下來。"

#: ../../whatsnew/2.2.rst:611
#, fuzzy
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`next` method increment "
"``self.count`` and return it. However, for a moderately complicated "
"generator, writing a corresponding class would be much messier. :file:`Lib/"
"test/test_generators.py` contains a number of more interesting examples.  "
"The simplest one implements an in-order traversal of a tree using generators "
"recursively. ::"
msgstr ""
"您可以通過編寫自己的類並將生成器的所有局部變數儲存為實例變數來手動實作生成器"
"的效果。例如，回傳一個整數列表可以通過將 ``self.count`` 設定為 0 來完成，"
"並讓 :meth:`next` 方法遞增 ``self.count`` "
"並回傳它。但是，對於一個中等複雜度的生成器，寫一個相應的類就麻煩多了。 "
":file:`Lib/test/test_generators.py` "
"包含許多更有趣的示例。最簡單的一個是遞迴地使用生成器實作樹的有序遍歷。 ::"

#: ../../whatsnew/2.2.rst:629
#, fuzzy
msgid ""
"Two other examples in :file:`Lib/test/test_generators.py` produce solutions "
"for the N-Queens problem (placing $N$ queens on an $NxN$ chess board so that "
"no queen threatens another) and the Knight's Tour (a route that takes a "
"knight to every square of an $NxN$ chessboard without visiting any square "
"twice)."
msgstr ""
":file:`Lib/test/test_generators.py` 中的另外兩個示例為 N 皇后問題（將 $N$ "
"皇后放在 $NxN$ 棋盤上，這樣就沒有皇后威脅到另一個）和 Knight's Tour（"
"a將馬帶到 $NxN$ 棋盤的每個方格而不訪問任何方格兩次的路線）。"

#: ../../whatsnew/2.2.rst:634
#, fuzzy
msgid ""
"The idea of generators comes from other programming languages, especially "
"Icon (https://www.cs.arizona.edu/icon/), where the idea of generators is "
"central.  In Icon, every expression and function call behaves like a "
"generator.  One example from \"An Overview of the Icon Programming Language"
"\" at https://www.cs.arizona.edu/icon/docs/ipd266.htm gives an idea of what "
"this looks like::"
msgstr ""
"生成器的想法來自其他編程語言，尤其是 Icon (https://www.cs.arizona.edu/icon/"
")，其中生成器的想法是核心。在 Icon "
"中，每個表達式和函式呼叫的行為都像一個生成器。 https://www.cs.arizona.edu/"
"icon/docs/ipd266.htm "
"上的“圖標編程語言概述”中的一個示例給出了這看起來像什麼的想法："

#: ../../whatsnew/2.2.rst:644
#, fuzzy
msgid ""
"In Icon the :func:`find` function returns the indexes at which the substring "
"\"or\" is found: 3, 23, 33.  In the :keyword:`if` statement, ``i`` is first "
"assigned a value of 3, but 3 is less than 5, so the comparison fails, and "
"Icon retries it with the second value of 23.  23 is greater than 5, so the "
"comparison now succeeds, and the code prints the value 23 to the screen."
msgstr ""
"在 Icon 中，:func:`find` 函式回傳找到子字串 \"or\" "
"的索引：3、23、33。在 :keyword:`if` 語句中，首先為 ``i`` 賦值3，但 3 小於 "
"5，因此比較失敗，Icon 將使用第二個值 23 重試。23 大於 5，因此現在比較成功，"
"並且程式碼將值 23 印出到屏幕。"

#: ../../whatsnew/2.2.rst:650
#, fuzzy
msgid ""
"Python doesn't go nearly as far as Icon in adopting generators as a central "
"concept.  Generators are considered a new part of the core Python language, "
"but learning or using them isn't compulsory; if they don't solve any "
"problems that you have, feel free to ignore them. One novel feature of "
"Python's interface as compared to Icon's is that a generator's state is "
"represented as a concrete object (the iterator) that can be passed around to "
"other functions or stored in a data structure."
msgstr ""
"在採用生成器作為中心概念方面，Python 遠不及 Icon。生成器被認為是核心 Python "
"語言的新部分，但學習或使用它們不是強制性的；如果他們不能解決您遇到的任何問題"
"，請隨意忽略它們。與 Icon 相比，Python 界面的一個新穎特徵是生成器的狀態表示為"
"一個具體物件（疊代器），可以傳遞給其他函式或儲存在資料結構中。"

#: ../../whatsnew/2.2.rst:662
#, fuzzy
msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - 簡單的生成器"

#: ../../whatsnew/2.2.rst:662
#, fuzzy
msgid ""
"Written by Neil Schemenauer, Tim Peters, Magnus Lie Hetland.  Implemented "
"mostly by Neil Schemenauer and Tim Peters, with other fixes from the Python "
"Labs crew."
msgstr ""
"由 Neil Schenmauer、Tim Peters、Magnus Lie Hetland 撰寫。主要由 Neil "
"Schenmauer 和 Tim Peters 實施，其他修復來自 Python 實驗室工作人員。"

#: ../../whatsnew/2.2.rst:669
#, fuzzy
msgid "PEP 237: Unifying Long Integers and Integers"
msgstr "PEP 237：統一長整數和整數"

#: ../../whatsnew/2.2.rst:671
#, fuzzy
msgid ""
"In recent versions, the distinction between regular integers, which are 32-"
"bit values on most machines, and long integers, which can be of arbitrary "
"size, was becoming an annoyance.  For example, on platforms that support "
"files larger than ``2**32`` bytes, the :meth:`tell` method of file objects "
"has to return a long integer. However, there were various bits of Python "
"that expected plain integers and would raise an error if a long integer was "
"provided instead.  For example, in Python 1.5, only regular integers could "
"be used as a slice index, and ``'abc'[1L:]`` would raise a :exc:`TypeError` "
"exception with the message 'slice index must be int'."
msgstr ""
"在最近的版本中，常規整數（在大多數機器上是 32 "
"位值）和長整數（可以是任意大小）之間的區別變得令人討厭。例如，在支援大於 "
"``2**32`` 位元組的文件的平台上，文件物件的 :meth:`tell` "
"方法必須回傳一個長整數。但是，Python "
"的很多位都需要純整數，如果提供的是長整數，則會引發錯誤。例如，在 Python 1.5 "
"中，只有常規整數可以用作切片索引，而 ``'abc'[1L:]`` 會引發 :exc:`TypeError` "
"例外，並顯示消息 'slice index must be int' ."

#: ../../whatsnew/2.2.rst:681
#, fuzzy
msgid ""
"Python 2.2 will shift values from short to long integers as required. The "
"'L' suffix is no longer needed to indicate a long integer literal, as now "
"the compiler will choose the appropriate type.  (Using the 'L' suffix will "
"be discouraged in future 2.x versions of Python, triggering a warning in "
"Python 2.4, and probably dropped in Python 3.0.)  Many operations that used "
"to raise an :exc:`OverflowError` will now return a long integer as their "
"result.  For example::"
msgstr ""
"Python 2.2 將根據需要將值從短整數轉換為長整數。不再需要 ``L``後綴來指示長整數文"
"字，因為現在編譯器將選擇合適的型別。 （在未來的 2.x 版本的 Python "
"中不鼓勵使用 ``L``後綴，在 Python 2.4 中觸發警告，並且可能在 Python 3.0 "
"中刪除。）許多用於引發 :exc:`OverflowError` "
"的操作現在將回傳一個長整數作為他們的結果。例如：："

#: ../../whatsnew/2.2.rst:694
#, fuzzy
msgid ""
"In most cases, integers and long integers will now be treated identically.  "
"You can still distinguish them with the :func:`type` built-in function, but "
"that's rarely needed."
msgstr "在大多數情況下，整數和長整數現在將被同等對待。您仍然可以使用 :func:`type` "
"內建函式來區分它們，但這很少需要。"

#: ../../whatsnew/2.2.rst:702
#, fuzzy
msgid ":pep:`237` - Unifying Long Integers and Integers"
msgstr ":pep:`237` - 統一長整數和整數"

#: ../../whatsnew/2.2.rst:702
#, fuzzy
msgid ""
"Written by Moshe Zadka and Guido van Rossum.  Implemented mostly by Guido "
"van Rossum."
msgstr "由 Moshe Zadka 和 Guido van Rossum 撰寫。主要由 Guido van Rossum 實施。"

#: ../../whatsnew/2.2.rst:709
#, fuzzy
msgid "PEP 238: Changing the Division Operator"
msgstr "PEP 238：更改除法運算符"

#: ../../whatsnew/2.2.rst:711
#, fuzzy
msgid ""
"The most controversial change in Python 2.2 heralds the start of an effort "
"to fix an old design flaw that's been in Python from the beginning. "
"Currently Python's division operator, ``/``, behaves like C's division "
"operator when presented with two integer arguments: it returns an integer "
"result that's truncated down when there would be a fractional part.  For "
"example, ``3/2`` is 1, not 1.5, and ``(-1)/2`` is -1, not -0.5.  This means "
"that the results of division can vary unexpectedly depending on the type of "
"the two operands and because Python is dynamically typed, it can be "
"difficult to determine the possible types of the operands."
msgstr ""
"Python 2.2 中最具爭議的變化預示著人們開始努力修復從一開始就存在於 Python "
"中的舊設計缺陷。目前 Python 的除法運算符 ``/``在有兩個整數參數時表現得像 C "
"的除法運算符：它回傳一個整數結果，當有小數部分時該結果被截斷。例如，``3/2`` "
"是 1，而不是 1.5，``(-1)/2`` 是 -1，而不是 -0."
"5。這意味著根據兩個操作數的型別，除法的結果可能會出乎意料地不同，並且由於 "
"Python 是動態型別的，因此可能很難確定操作數的可能型別。"

#: ../../whatsnew/2.2.rst:721
#, fuzzy
msgid ""
"(The controversy is over whether this is *really* a design flaw, and whether "
"it's worth breaking existing code to fix this.  It's caused endless "
"discussions on python-dev, and in July 2001 erupted into a storm of acidly "
"sarcastic postings on :newsgroup:`comp.lang.python`. I won't argue for "
"either side here and will stick to describing what's  implemented in 2.2.  "
"Read :pep:`238` for a summary of arguments and counter-arguments.)"
msgstr ""
"（爭論的焦點是這是否*真的*是一個設計缺陷，以及是否值得打破現有程式碼來解決這"
"個問題。它在 python-dev 上引起了無休止的討論，並於 2001 年 7 月在 :newsgroup "
"上爆發了尖銳諷刺的帖子:`comp.lang.python`。我不會在這里為任何一方爭論，"
"並將堅持描述 2.2 中實作的內容。閱讀 :pep:`238` 以獲得論點和反論點的摘要。）"

#: ../../whatsnew/2.2.rst:728
#, fuzzy
msgid ""
"Because this change might break code, it's being introduced very gradually. "
"Python 2.2 begins the transition, but the switch won't be complete until "
"Python 3.0."
msgstr "由於此更改可能會破壞程式碼，因此它的引入非常緩慢。 Python 2.2 開始過渡，"
"但轉換要到 Python 3.0 才能完成。"

#: ../../whatsnew/2.2.rst:732
#, fuzzy
msgid ""
"First, I'll borrow some terminology from :pep:`238`.  \"True division\" is "
"the division that most non-programmers are familiar with: 3/2 is 1.5, 1/4 is "
"0.25, and so forth.  \"Floor division\" is what Python's ``/`` operator "
"currently does when given integer operands; the result is the floor of the "
"value returned by true division.  \"Classic division\" is the current mixed "
"behaviour of ``/``; it returns the result of floor division when the "
"operands are integers, and returns the result of true division when one of "
"the operands is a floating-point number."
msgstr ""
"首先，我將從 :pep:`238` 借用一些術語。 “真除法”是大多數非程式員都熟悉的除法："
"3/2 是 1.5，1/4 是 0.25，等等。 “樓層除法”是 Python 的 ``/`` "
"運算符當前在給定整數操作數時所做的；結果是真除法回傳值的下限。 “經典除法”是``"
"/``的當前混合行為；當操作數為整數時回傳底除法結果，當其中一個操作數為浮點數時"
"回傳真除法結果。"

#: ../../whatsnew/2.2.rst:740
#, fuzzy
msgid "Here are the changes 2.2 introduces:"
msgstr "以下是 2.2 引入的更改："

#: ../../whatsnew/2.2.rst:742
#, fuzzy
msgid ""
"A new operator, ``//``, is the floor division operator. (Yes, we know it "
"looks like C++'s comment symbol.)  ``//`` *always* performs floor division "
"no matter what the types of its operands are, so ``1 // 2`` is 0 and "
"``1.0 // 2.0`` is also 0.0."
msgstr ""
"一個新的運算符，``//``，是地板除法運算符。 （是的，我們知道它看起來像 C++ "
"的註釋符號。）無論其操作數的型別是什麼，``//`` *總是*執行底除法，所以 ``1 // "
"2`` 是 0 和 ``1.0 // 2.0`` 也是 0.0。"

#: ../../whatsnew/2.2.rst:747
#, fuzzy
msgid ""
"``//`` is always available in Python 2.2; you don't need to enable it using "
"a ``__future__`` statement."
msgstr "``//`` 在 Python 2.2 中始終可用；您不需要使用 ``__future__`` 語句啟用它。"

#: ../../whatsnew/2.2.rst:750
#, fuzzy
msgid ""
"By including a ``from __future__ import division`` in a module, the ``/`` "
"operator will be changed to return the result of true division, so ``1/2`` "
"is 0.5.  Without the ``__future__`` statement, ``/`` still means classic "
"division. The default meaning of ``/`` will not change until Python 3.0."
msgstr ""
"通過在模組中包含``from __future__ import division``，``/`` "
"運算符將更改為回傳真正除法的結果，因此``1/2`` 為0.5。沒有 ``__future__`` "
"語句，``/`` 仍然表示經典除法。在 Python 3.0 之前，``/`` 的預設含義不會改變。"

#: ../../whatsnew/2.2.rst:755
#, fuzzy
msgid ""
"Classes can define methods called :meth:`__truediv__` and :meth:"
"`__floordiv__` to overload the two division operators.  At the C level, "
"there are also slots in the :c:type:`PyNumberMethods` structure so extension "
"types can define the two operators."
msgstr ""
"類可以定義名為 :meth:`__truediv__` 和 :meth:`__floordiv__` "
"的方法來重載兩個除法運算符。在 C 級別，:c:type:`PyNumberMethods` "
"結構中也有插槽，因此擴充型別可以定義兩個運算符。"

#: ../../whatsnew/2.2.rst:760
#, fuzzy
msgid ""
"Python 2.2 supports some command-line arguments for testing whether code "
"will work with the changed division semantics.  Running python with :option:"
"`!-Q warn` will cause a warning to be issued whenever division is applied to "
"two integers.  You can use this to find code that's affected by the change "
"and fix it.  By default, Python 2.2 will simply perform classic division "
"without a warning; the warning will be turned on by default in Python 2.3."
msgstr ""
"Python 2.2 支援一些命令列參數，用於測試程式碼是否適用於更改後的除法語義。"
"使用 :option:`!-Q warn` 運行 python 將導致在對兩個整數應用除法時發出警告。您"
"可以使用它來查找受更改影響的程式碼並修復它。預設情況下，Python 2.2 "
"會在沒有警告的情況下簡單地執行經典除法；該警告將在 Python 2.3 中預設打開。"

#: ../../whatsnew/2.2.rst:770
#, fuzzy
msgid ":pep:`238` - Changing the Division Operator"
msgstr ":pep:`238` - 更改除法運算符"

#: ../../whatsnew/2.2.rst:771
#, fuzzy
msgid ""
"Written by Moshe Zadka and  Guido van Rossum.  Implemented by Guido van "
"Rossum.."
msgstr "由 Moshe Zadka 和 Guido van Rossum 撰寫。由 Guido van Rossum 實施。"

#: ../../whatsnew/2.2.rst:777
#, fuzzy
msgid "Unicode Changes"
msgstr "Unicode 更改"

#: ../../whatsnew/2.2.rst:779
#, fuzzy
msgid ""
"Python's Unicode support has been enhanced a bit in 2.2.  Unicode strings "
"are usually stored as UCS-2, as 16-bit unsigned integers. Python 2.2 can "
"also be compiled to use UCS-4, 32-bit unsigned integers, as its internal "
"encoding by supplying :option:`!--enable-unicode=ucs4` to the configure "
"script.   (It's also possible to specify :option:`!--disable-unicode` to "
"completely disable Unicode support.)"
msgstr ""
"Python 的 Unicode 支援在 2.2 中得到了增強。 Unicode 字串通常儲存為 UCS-2，即 "
"16 位無符號整數。 Python 2.2 也可以編譯為使用 UCS-4、32 "
"位無符號整數作為其內部編碼，方法是向配置腳本提供 :option:`!--enable-"
"unicode=ucs4`。 （也可以指定 :option:`!--disable-unicode` 以完全禁用 Unicode "
"支援。）"

#: ../../whatsnew/2.2.rst:786
#, fuzzy
msgid ""
"When built to use UCS-4 (a \"wide Python\"), the interpreter can natively "
"handle Unicode characters from U+000000 to U+110000, so the range of legal "
"values for the :func:`unichr` function is expanded accordingly.  Using an "
"interpreter compiled to use UCS-2 (a \"narrow Python\"), values greater than "
"65535 will still cause :func:`unichr` to raise a :exc:`ValueError` "
"exception. This is all described in :pep:`261`, \"Support for 'wide' Unicode "
"characters\"; consult it for further details."
msgstr ""
"當構建為使用 UCS-4（“寬 Python”）時，直譯器可以原生處理從 U+000000 到 U+"
"110000 的 Unicode 字元，因此 :func:`unichr` 函式的合法值範圍相應擴充。"
"使用編譯為使用 UCS-2（“窄 Python”）的直譯器，大於 65535 的值仍會導致 "
":func:`unichr` 引發 :exc:`ValueError` 例外。這些都在 :pep:`261`，“支援‘寬’"
"Unicode 字元”中進行了描述；請諮詢它以獲取更多詳細資訊。"

#: ../../whatsnew/2.2.rst:794
#, fuzzy
msgid ""
"Another change is simpler to explain. Since their introduction, Unicode "
"strings have supported an :meth:`encode` method to convert the string to a "
"selected encoding such as UTF-8 or Latin-1.  A symmetric "
"``decode([*encoding*])`` method has been added to 8-bit strings (though not "
"to Unicode strings) in 2.2. :meth:`decode` assumes that the string is in the "
"specified encoding and decodes it, returning whatever is returned by the "
"codec."
msgstr ""
"另一個變化更容易解釋。自推出以來，Unicode 字串就支援 :meth:`encode` "
"方法將字串轉換為選定的編碼，例如 UTF-8 或 "
"Latin-1。對稱的``decode([*encoding*])`` 方法已新增到 2.2 中的 8 位字串（"
"儘管不是 Unicode 字串）。 :meth:`decode` "
"假定字串採用指定的編碼並對其進行解碼，回傳編解碼器回傳的任何內容。"

#: ../../whatsnew/2.2.rst:801
#, fuzzy
msgid ""
"Using this new feature, codecs have been added for tasks not directly "
"related to Unicode.  For example, codecs have been added for uu-encoding, "
"MIME's base64 encoding, and compression with the :mod:`zlib` module::"
msgstr ""
"使用此新功能，已為與 Unicode 不直接相關的任務新增了編解碼器。例如，為 uu "
"編碼、MIME 的 base64 編碼和 :mod:`zlib` 模組壓縮新增了編解碼器："

#: ../../whatsnew/2.2.rst:822
#, fuzzy
msgid ""
"To convert a class instance to Unicode, a :meth:`__unicode__` method can be "
"defined by a class, analogous to :meth:`__str__`."
msgstr "要將類實例轉換為 Unicode，類可以定義一個 :meth:`__unicode__` 方法，類似於 "
":meth:`__str__`。"

#: ../../whatsnew/2.2.rst:825
#, fuzzy
msgid ""
":meth:`encode`, :meth:`decode`, and :meth:`__unicode__` were implemented by "
"Marc-André Lemburg.  The changes to support using UCS-4 internally were "
"implemented by Fredrik Lundh and Martin von Löwis."
msgstr ""
":meth:`encode`、:meth:`decode` 和 :meth:`__unicode__` 由 Marc-André Lemburg "
"實作。 Fredrik Lundh 和 Martin von Löwis 實施了支援在內部使用 UCS-4 的更改。"

#: ../../whatsnew/2.2.rst:832
#, fuzzy
msgid ":pep:`261` - Support for 'wide' Unicode characters"
msgstr ":pep:`261` - 支援 ``寬``Unicode 字元"

#: ../../whatsnew/2.2.rst:833
#, fuzzy
msgid "Written by Paul Prescod."
msgstr "由保羅普雷斯科德撰寫。"

#: ../../whatsnew/2.2.rst:839
#, fuzzy
msgid "PEP 227: Nested Scopes"
msgstr "PEP 227：嵌套作用域"

#: ../../whatsnew/2.2.rst:841
#, fuzzy
msgid ""
"In Python 2.1, statically nested scopes were added as an optional feature, "
"to be enabled by a ``from __future__ import nested_scopes`` directive.  In "
"2.2 nested scopes no longer need to be specially enabled, and are now always "
"present.  The rest of this section is a copy of the description of nested "
"scopes from my \"What's New in Python 2.1\" document; if you read it when "
"2.1 came out, you can skip the rest of this section."
msgstr ""
"在 Python 2.1 中，靜態嵌套範圍作為可選功能新增，由“from __future__ import "
"nested_scopes”指令啟用。在 2.2 "
"中，嵌套範圍不再需要特別啟用，並且現在始終存在。本節的其餘部分是我的“What's "
"New in Python 2.1”文檔中嵌套作用域描述的副本；如果您在 2.1 "
"發佈時閱讀它，則可以跳過本節的其餘部分。"

#: ../../whatsnew/2.2.rst:848
#, fuzzy
msgid ""
"The largest change introduced in Python 2.1, and made complete in 2.2, is to "
"Python's scoping rules.  In Python 2.0, at any given time there are at most "
"three namespaces used to look up variable names: local, module-level, and "
"the built-in namespace.  This often surprised people because it didn't match "
"their intuitive expectations.  For example, a nested recursive function "
"definition doesn't work::"
msgstr ""
"Python 2.1 中引入並在 2.2 中完成的最大變化是 Python 的作用域規則。在 Python "
"2.0 中，在任何給定時間最多有三個名稱空間用於查找變數名稱：本地名稱空間、模組"
"級名稱空間和內建名稱空間。這常常讓人們感到驚訝，因為它不符合他們的直覺預期。"
"例如，嵌套遞迴函式定義不起作用::"

#: ../../whatsnew/2.2.rst:862
#, fuzzy
msgid ""
"The function :func:`g` will always raise a :exc:`NameError` exception, "
"because the binding of the name ``g`` isn't in either its local namespace or "
"in the module-level namespace.  This isn't much of a problem in practice "
"(how often do you recursively define interior functions like this?), but "
"this also made using the :keyword:`lambda` expression clumsier, and this was "
"a problem in practice. In code which uses :keyword:`!lambda` you can often "
"find local variables being copied by passing them as the default values of "
"arguments. ::"
msgstr ""
"函式 :func:`g` 將始終引發 :exc:`NameError` 例外，因為名稱 ``g`` 的綁定既不在"
"其本地命名空間中，也不在模組級命名空間中。這在實踐中不是什麼大問題（你多久會"
"像這樣遞迴定義內部函式？），但這也使得使用 :keyword:`lambda` "
"表達式變得笨拙，這在實踐中是一個問題。在使用 :keyword:`!lambda` 的程式碼中，"
"您經常可以找到通過將局部變數作為參數的預設值傳遞來複製的局部變數。 ::"

#: ../../whatsnew/2.2.rst:876
#, fuzzy
msgid ""
"The readability of Python code written in a strongly functional style "
"suffers greatly as a result."
msgstr "以強函式風格編寫的 Python 程式碼的可讀性因此受到很大影響。"

#: ../../whatsnew/2.2.rst:879
#, fuzzy
msgid ""
"The most significant change to Python 2.2 is that static scoping has been "
"added to the language to fix this problem.  As a first effect, the "
"``name=name`` default argument is now unnecessary in the above example.  Put "
"simply, when a given variable name is not assigned a value within a function "
"(by an assignment, or the :keyword:`def`, :keyword:`class`, or :keyword:"
"`import` statements), references to the variable will be looked up in the "
"local namespace of the enclosing scope.  A more detailed explanation of the "
"rules, and a dissection of the implementation, can be found in the PEP."
msgstr ""
"Python 2.2 "
"最重要的變化是在語言中新增了靜態作用域來解決這個問題。作為第一個效果，"
"在上面的例子中現在不需要 ``name=name`` 預設參數。簡而言之，當一個給定的變數名"
"沒有在函式中被賦值時（通過賦值，或 :keyword:`def`、:keyword:`class` "
"或 :keyword:`import` 語句），引用變數將在封閉範圍的本地名稱空間中查找。可以在 "
"PEP 中找到對規則的更詳細解釋和對實作的剖析。"

#: ../../whatsnew/2.2.rst:888
#, fuzzy
msgid ""
"This change may cause some compatibility problems for code where the same "
"variable name is used both at the module level and as a local variable "
"within a function that contains further function definitions. This seems "
"rather unlikely though, since such code would have been pretty confusing to "
"read in the first place."
msgstr ""
"此更改可能會導致程式碼出現一些相容性問題，在這些程式碼中，相同的變數名稱既用"
"於模組級別，又用作包含更多函式定義的函式中的局部變數。但這似乎不太可能，因為"
"這樣的程式碼一開始讀起來會很混亂。"

#: ../../whatsnew/2.2.rst:894
#, fuzzy
msgid ""
"One side effect of the change is that the ``from module import *`` and "
"``exec`` statements have been made illegal inside a function scope under "
"certain conditions.  The Python reference manual has said all along that "
"``from module import *`` is only legal at the top level of a module, but the "
"CPython interpreter has never enforced this before.  As part of the "
"implementation of nested scopes, the compiler which turns Python source into "
"bytecodes has to generate different code to access variables in a containing "
"scope.  ``from module import *`` and ``exec`` make it impossible for the "
"compiler to figure this out, because they add names to the local namespace "
"that are unknowable at compile time. Therefore, if a function contains "
"function definitions or :keyword:`lambda` expressions with free variables, "
"the compiler will flag this by raising a :exc:`SyntaxError` exception."
msgstr ""
"這一變化的一個副作用是，在某些情況下，``from module import *`` 和 ``exec`` "
"語句在函式範圍內是非法的。 Python 參考手冊一直說“from module import "
"*”只在模組的頂層是合法的，但 CPython "
"直譯器以前從未強制執行過。作為嵌套作用域實作的一部分，將 Python "
"源程式碼轉換為位元組碼的編譯器必須生成不同的程式碼來訪問包含作用域中的變數。 "
"``from module import *`` 和 ``exec`` 使編譯器無法解決這個問題，因為它們將名稱"
"新增到編譯時不可知的本地命名空間。因此，如果函式包含函式定義或帶有自由變數的 "
"lambda 表達式，編譯器將通過引發 SyntaxError 例外來標記它。"

#: ../../whatsnew/2.2.rst:907
#, fuzzy
msgid "To make the preceding explanation a bit clearer, here's an example::"
msgstr "為了使前面的解釋更清楚一些，這裡有一個例子："

#: ../../whatsnew/2.2.rst:916
#, fuzzy
msgid ""
"Line 4 containing the ``exec`` statement is a syntax error, since ``exec`` "
"would define a new local variable named ``x`` whose value should be accessed "
"by :func:`g`."
msgstr ""
"包含 ``exec`` 語句的第 4 行是語法錯誤，因為 ``exec`` 將定義一個名為 ``x`` "
"的新局部變數，其值應由 :func:`g` 訪問。"

#: ../../whatsnew/2.2.rst:920
#, fuzzy
msgid ""
"This shouldn't be much of a limitation, since ``exec`` is rarely used in "
"most Python code (and when it is used, it's often a sign of a poor design "
"anyway)."
msgstr "這不應該是一個很大的限制，因為 ``exec`` 在大多數 Python "
"程式碼中很少使用（而且當它被使用時，它通常是糟糕設計的旗標）。"

#: ../../whatsnew/2.2.rst:927
#, fuzzy
msgid ":pep:`227` - Statically Nested Scopes"
msgstr ":pep:`227` - 靜態嵌套作用域"

#: ../../whatsnew/2.2.rst:928
#, fuzzy
msgid "Written and implemented by Jeremy Hylton."
msgstr "由 Jeremy Hylton 編寫和實施。"

#: ../../whatsnew/2.2.rst:934
#, fuzzy
msgid "New and Improved Modules"
msgstr "新的和改進的模組"

#: ../../whatsnew/2.2.rst:936
#, fuzzy
msgid ""
"The :mod:`xmlrpclib` module was contributed to the standard library by "
"Fredrik Lundh, providing support for writing XML-RPC clients.  XML-RPC is a "
"simple remote procedure call protocol built on top of HTTP and XML. For "
"example, the following snippet retrieves a list of RSS channels from the "
"O'Reilly Network, and then  lists the recent headlines for one channel::"
msgstr ""
":mod:`xmlrpclib` 模組由 Fredrik Lundh 貢獻到標準庫中，為編寫 XML-RPC "
"客戶端提供支援。 XML-RPC 是一種建立在 HTTP 和 XML "
"之上的簡單遠程過程呼叫協定。例如，以下程式碼片段從 O'Reilly 網絡檢索 RSS "
"頻道列表，然後列出一個頻道的最新標題："

#: ../../whatsnew/2.2.rst:959
#, fuzzy
msgid ""
"The :mod:`SimpleXMLRPCServer` module makes it easy to create straightforward "
"XML-RPC servers.  See http://xmlrpc.scripting.com/ for more information "
"about XML-RPC."
msgstr ""
":mod:`SimpleXMLRPCServer` 模組可以輕鬆建立簡單的 XML-RPC 伺服器。有關 XML-"
"RPC 的更多資訊，請參閱 http://xmlrpc.scripting.com/。"

#: ../../whatsnew/2.2.rst:962
#, fuzzy
msgid ""
"The new :mod:`hmac` module implements the HMAC algorithm described by :rfc:"
"`2104`. (Contributed by Gerhard Häring.)"
msgstr "新的 :mod:`hmac` 模組實作了 :rfc:`2104` 描述的 HMAC 演算法。 （由 Gerhard "
"Häring 提供。）"

#: ../../whatsnew/2.2.rst:965
#, fuzzy
msgid ""
"Several functions that originally returned lengthy tuples now return pseudo-"
"sequences that still behave like tuples but also have mnemonic attributes "
"such as memberst_mtime or :attr:`tm_year`. The enhanced functions include :"
"func:`stat`, :func:`fstat`, :func:`statvfs`, and :func:`fstatvfs` in the :"
"mod:`os` module, and :func:`localtime`, :func:`gmtime`, and :func:`strptime` "
"in the :mod:`time` module."
msgstr ""
"幾個最初回傳冗長元組的函式現在回傳偽序列，這些偽序列仍然表現得像元組，但也具"
"有助記屬性，例如 memberst_mtime 或 :attr:`tm_year`。增強功能包括 :func:`stat`"
", :func:`fstat`, :func:`statvfs`, :func:`os` 模組中的 :func:`fstatvfs`, "
":func:`localtime`, :func:`gmtime` 和 :func:`strptime` 在 :mod:`time` 模組中。"

#: ../../whatsnew/2.2.rst:972
#, fuzzy
msgid ""
"For example, to obtain a file's size using the old tuples, you'd end up "
"writing something like ``file_size = os.stat(filename)[stat.ST_SIZE]``, but "
"now this can be written more clearly as ``file_size = os.stat(filename)."
"st_size``."
msgstr ""
"例如，要使用舊元組獲取文件大小，您最終會寫成類似 ``file_size = os."
"stat(filename)[stat.ST_SIZE]`` 的內容，但現在可以更清楚地寫成 `` file_size = "
"os.stat(文件名).st_size``。"

#: ../../whatsnew/2.2.rst:976
#, fuzzy
msgid "The original patch for this feature was contributed by Nick Mathewson."
msgstr "此功能的原始補丁由 Nick Mathewson 貢獻。"

#: ../../whatsnew/2.2.rst:978
#, fuzzy
msgid ""
"The Python profiler has been extensively reworked and various errors in its "
"output have been corrected.  (Contributed by Fred L. Drake, Jr. and Tim "
"Peters.)"
msgstr ""
"Python 探查器已被廣泛修改，其輸出中的各種錯誤已得到糾正。 （由 Fred L. "
"Drake, Jr. 和 Tim Peters 提供。）"

#: ../../whatsnew/2.2.rst:981
#, fuzzy
msgid ""
"The :mod:`socket` module can be compiled to support IPv6; specify the :"
"option:`!--enable-ipv6` option to Python's configure script.  (Contributed "
"by Jun-ichiro \"itojun\" Hagino.)"
msgstr ""
":mod:`socket` 模組可以編譯為支援 IPv6；為 Python 的配置腳本指定 :option"
":`!--enable-ipv6` 選項。 （由 Jun-ichiro \"itojun\" Hagino 提供。）"

#: ../../whatsnew/2.2.rst:985
#, fuzzy
msgid ""
"Two new format characters were added to the :mod:`struct` module for 64-bit "
"integers on platforms that support the C :c:expr:`long long` type.  ``q`` is "
"for a signed 64-bit integer, and ``Q`` is for an unsigned one.  The value is "
"returned in Python's long integer type.  (Contributed by Tim Peters.)"
msgstr ""
"在支援 C :c:expr:`long long` 型別的平台上，為 64 位整數的 :mod:`struct` "
"模組新增了兩個新的格式字元。 ``q`` 用於帶符號的 64 位整數，``Q`` "
"用於無符號整數。該值以 Python 的長整數型別回傳。 （由蒂姆·彼得斯提供。）"

#: ../../whatsnew/2.2.rst:990
#, fuzzy
msgid ""
"In the interpreter's interactive mode, there's a new built-in function :func:"
"`help` that uses the :mod:`pydoc` module introduced in Python 2.1 to provide "
"interactive help. ``help(object)`` displays any available help text about "
"*object*.  :func:`help` with no argument puts you in an online help utility, "
"where you can enter the names of functions, classes, or modules to read "
"their help text. (Contributed by Guido van Rossum, using Ka-Ping Yee's :mod:"
"`pydoc` module.)"
msgstr ""
"在直譯器的交互模式中，有一個新的內建函式 :func:`help`，它使用 Python 2.1 "
"中引入的 :mod:`pydoc` 模組來提供交互幫助。 ``help(object)`` 顯示關於 *object* "
"的任何可用幫助文本。不帶參數的 :func:`help` 使您進入在線幫助實用程式，您可以"
"在其中輸入函式、類或模組的名稱以閱讀它們的幫助文本。 （由 Guido van Rossum "
"提供，使用 Ka-Ping Yee 的 :mod:`pydoc` 模組。）"

#: ../../whatsnew/2.2.rst:998
#, fuzzy
msgid ""
"Various bugfixes and performance improvements have been made to the SRE "
"engine underlying the :mod:`re` module.  For example, the :func:`re.sub` "
"and :func:`re.split` functions have been rewritten in C.  Another "
"contributed patch speeds up certain Unicode character ranges by a factor of "
"two, and a new :meth:`finditer`  method that returns an iterator over all "
"the non-overlapping matches in  a given string.  (SRE is maintained by "
"Fredrik Lundh.  The BIGCHARSET patch was contributed by Martin von Löwis.)"
msgstr ""
"對 :mod:`re` 模組下的 SRE 引擎進行了各種錯誤修復和性能改進。例如，:func:`re."
"sub` 和 :func:`re.split` 函式已用 C 語言重寫。另一個貢獻的補丁將某些 Unicode "
"字元範圍加速了兩倍，還有一個新的 :meth:` finditer "
"方法回傳給定字串中所有非重疊匹配項的疊代器。 （SRE 由 Fredrik Lundh 維護。"
"BIGCHARSET 補丁由 Martin von Löwis 貢獻。）"

#: ../../whatsnew/2.2.rst:1006
#, fuzzy
msgid ""
"The :mod:`smtplib` module now supports :rfc:`2487`, \"Secure SMTP over TLS"
"\", so it's now possible to encrypt the SMTP traffic between a Python "
"program and the mail transport agent being handed a message.  :mod:`smtplib` "
"also supports SMTP authentication.  (Contributed by Gerhard Häring.)"
msgstr ""
":mod:`smtplib` 模組現在支援 :rfc:`2487`，“基於 TLS 的安全 SMTP”，"
"因此現在可以加密 Python 程式和正在傳遞消息的郵件傳輸代理之間的 SMTP 流量。 "
":mod:`smtplib` 還支援 SMTP 身份驗證。 （由 Gerhard Häring 提供。）"

#: ../../whatsnew/2.2.rst:1011
#, fuzzy
msgid ""
"The :mod:`imaplib` module, maintained by Piers Lauder, has support for "
"several new extensions: the NAMESPACE extension defined in :rfc:`2342`, "
"SORT, GETACL and SETACL.  (Contributed by Anthony Baxter and Michel "
"Pelletier.)"
msgstr ""
"由 Piers Lauder 維護的 :mod:`imaplib` 模組支援幾個新的擴充：:rfc:`2342` "
"中定義的 NAMESPACE 擴充、SORT、GETACL 和 SETACL。 "
"（由安東尼·巴克斯特和米歇爾·佩爾蒂埃提供。）"

#: ../../whatsnew/2.2.rst:1015
#, fuzzy
msgid ""
"The :mod:`rfc822` module's parsing of email addresses is now compliant with :"
"rfc:`2822`, an update to :rfc:`822`.  (The module's name is *not* going to "
"be changed to ``rfc2822``.)  A new package, :mod:`email`, has also been "
"added for parsing and generating e-mail messages.  (Contributed by Barry "
"Warsaw, and arising out of his work on Mailman.)"
msgstr ""
":mod:`rfc822` 模組對電子郵件地址的解析現在符合 :rfc:`2822`，這是對 :rfc:`822`"
" 的更新。 （該模組的名稱 *not* 將更改為 ``rfc2822``。）還新增了一個新包 "
":mod:`email` 用於解析和生成電子郵件消息。 （由 Barry Warsaw 提供，源於他在 "
"Mailman 上的工作。）"

#: ../../whatsnew/2.2.rst:1021
#, fuzzy
msgid ""
"The :mod:`difflib` module now contains a new :class:`Differ` class for "
"producing human-readable lists of changes (a \"delta\") between two "
"sequences of lines of text.  There are also two generator functions, :func:"
"`ndiff` and :func:`restore`, which respectively return a delta from two "
"sequences, or one of the original sequences from a delta. (Grunt work "
"contributed by David Goodger, from ndiff.py code by Tim Peters who then did "
"the generatorization.)"
msgstr ""
":mod:`difflib` 模組現在包含一個新的 :class:`Differ` 類，用於在兩個文本行序列"
"之間生成人類可讀的更改列表（“增量”）。還有兩個生成器函式，:func:`ndiff` "
"和 :func:`restore`，它們分別從兩個序列回傳一個 delta，或者從一個 delta "
"回傳一個原始序列。 （由 David Goodger 貢獻的 Grunt 工作，來自 Tim Peters 的 "
"ndiff.py 程式碼，他隨後進行了生成。）"

#: ../../whatsnew/2.2.rst:1028
#, fuzzy
msgid ""
"New constants :const:`ascii_letters`, :const:`ascii_lowercase`, and :const:"
"`ascii_uppercase` were added to the :mod:`string` module.  There were "
"several modules in the standard library that used :const:`string.letters` to "
"mean the ranges A-Za-z, but that assumption is incorrect when locales are in "
"use, because :const:`string.letters` varies depending on the set of legal "
"characters defined by the current locale.  The buggy modules have all been "
"fixed to use :const:`ascii_letters` instead. (Reported by an unknown person; "
"fixed by Fred L. Drake, Jr.)"
msgstr ""
"新常數 :const:`ascii_letters`、:const:`ascii_lowercase` 和 "
":const:`ascii_uppercase` 已新增到 :mod:`string` 模組。標準庫中有幾個模組使用 "
":const:`string.letters` 來表示 A-Za-z "
"範圍，但是當使用語言環境時，這個假設是不正確的，因為 :const:`string.letters` "
"會根據情況而變化在當前語言環境定義的合法字元集上。錯誤的模組已全部修復為使用 "
":const:`ascii_letters` 代替。 （由未知人士報告；由 Fred L. Drake, Jr. 修復）"

#: ../../whatsnew/2.2.rst:1037
#, fuzzy
msgid ""
"The :mod:`mimetypes` module now makes it easier to use alternative MIME-type "
"databases by the addition of a :class:`MimeTypes` class, which takes a list "
"of filenames to be parsed.  (Contributed by Fred L. Drake, Jr.)"
msgstr ""
":mod:`mimetypes` 模組現在通過新增 :class:`MimeTypes` 類使使用替代 MIME "
"型別資料庫變得更加容易，該類採用要解析的文件名列表。 （由 Fred L. Drake, Jr. "
"提供）"

#: ../../whatsnew/2.2.rst:1041
#, fuzzy
msgid ""
"A :class:`Timer` class was added to the :mod:`threading` module that allows "
"scheduling an activity to happen at some future time.  (Contributed by "
"Itamar Shtull-Trauring.)"
msgstr ""
"一個 :class:`Timer` 類被新增到 :mod:`threading` "
"模組，允許安排一個活動在未來的某個時間發生。 （由 Itamar Shtull-Trauring "
"提供。）"

#: ../../whatsnew/2.2.rst:1049
#, fuzzy
msgid "Interpreter Changes and Fixes"
msgstr "直譯器更改和修復"

#: ../../whatsnew/2.2.rst:1051
#, fuzzy
msgid ""
"Some of the changes only affect people who deal with the Python interpreter "
"at the C level because they're writing Python extension modules, embedding "
"the interpreter, or just hacking on the interpreter itself. If you only "
"write Python code, none of the changes described here will affect you very "
"much."
msgstr ""
"一些更改只影響在 C 級別處理 Python 直譯器的人，因為他們正在編寫 Python "
"擴充模組、嵌入直譯器或只是攻擊直譯器本身。如果您只編寫 Python "
"程式碼，那麼此處描述的任何更改都不會對您產生太大影響。"

#: ../../whatsnew/2.2.rst:1056
#, fuzzy
msgid ""
"Profiling and tracing functions can now be implemented in C, which can "
"operate at much higher speeds than Python-based functions and should reduce "
"the overhead of profiling and tracing.  This  will be of interest to authors "
"of development environments for Python.  Two new C functions were added to "
"Python's API, :c:func:`PyEval_SetProfile` and :c:func:`PyEval_SetTrace`. The "
"existing :func:`sys.setprofile` and :func:`sys.settrace` functions still "
"exist, and have simply been changed to use the new C-level interface.  "
"(Contributed by Fred L. Drake, Jr.)"
msgstr ""
"分析和跟踪功能現在可以在 C 中實作，它可以比基於 Python "
"的函式以更高的速度運行，並且應該減少分析和跟踪的開銷。這將引起 Python "
"開發環境作者的興趣。 Python 的 API 新增了兩個新的 C "
"函式 :c:func:`PyEval_SetProfile` 和 :c:func:`PyEval_SetTrace`。現有的 "
":func:`sys.setprofile` 和 :func:`sys.settrace` 函式仍然存在，"
"只是被更改為使用新的 C 級介面。 （由 Fred L. Drake, Jr. 提供）"

#: ../../whatsnew/2.2.rst:1065
#, fuzzy
msgid ""
"Another low-level API, primarily of interest to implementors of Python "
"debuggers and development tools, was added. :c:func:"
"`PyInterpreterState_Head` and :c:func:`PyInterpreterState_Next` let a caller "
"walk through all the existing interpreter objects; :c:func:"
"`PyInterpreterState_ThreadHead` and :c:func:`PyThreadState_Next` allow "
"looping over all the thread states for a given interpreter.  (Contributed by "
"David Beazley.)"
msgstr ""
"新增了另一個低階 API，主要是 Python 除錯器和開發工具的實作者感興趣。 "
":c:func:`PyInterpreterState_Head` 和 :c:func:`PyInterpreterState_Next` "
"讓呼叫者遍歷所有現有的直譯器物件； :c:func:`PyInterpreterState_ThreadHead` "
"和 :c:func:`PyThreadState_Next` 允許循環遍歷給定直譯器的所有執行緒狀態。 "
"（由大衛·比茲利提供。）"

#: ../../whatsnew/2.2.rst:1072
#, fuzzy
msgid ""
"The C-level interface to the garbage collector has been changed to make it "
"easier to write extension types that support garbage collection and to debug "
"misuses of the functions. Various functions have slightly different "
"semantics, so a bunch of functions had to be renamed.  Extensions that use "
"the old API will still compile but will *not* participate in garbage "
"collection, so updating them for 2.2 should be considered fairly high "
"priority."
msgstr ""
"垃圾收集器的 C 級介面已更改，以便更容易編寫支援垃圾收集的擴充型別和除錯函式的"
"誤用。各種函式的語義略有不同，因此必須重命名一堆函式。使用舊 API "
"的擴充仍然可以編譯，但*不會*參與垃圾回收，因此為 2.2 "
"更新它們應該被視為相當高的優先級。"

#: ../../whatsnew/2.2.rst:1079
#, fuzzy
msgid ""
"To upgrade an extension module to the new API, perform the following steps:"
msgstr "要將擴充模組升級到新 API，請執行以下步驟："

#: ../../whatsnew/2.2.rst:1081
#, fuzzy
msgid "Rename :c:func:`Py_TPFLAGS_GC` to :c:func:`PyTPFLAGS_HAVE_GC`."
msgstr "將 :c:func:`Py_TPFLAGS_GC` 重命名為 :c:func:`PyTPFLAGS_HAVE_GC`。"

#: ../../whatsnew/2.2.rst:1084
#, fuzzy
msgid ""
"Use :c:func:`PyObject_GC_New` or :c:func:`PyObject_GC_NewVar` to allocate"
msgstr "使用 :c:func:`PyObject_GC_New` 或 :c:func:`PyObject_GC_NewVar` 分配"

#: ../../whatsnew/2.2.rst:1084
#, fuzzy
msgid "objects, and :c:func:`PyObject_GC_Del` to deallocate them."
msgstr "物件，並使用 :c:func:`PyObject_GC_Del` 來釋放它們。"

#: ../../whatsnew/2.2.rst:1087
#, fuzzy
msgid "Rename :c:func:`PyObject_GC_Init` to :c:func:`PyObject_GC_Track` and"
msgstr "將 :c:func:`PyObject_GC_Init` 重命名為 :c:func:`PyObject_GC_Track` 和"

#: ../../whatsnew/2.2.rst:1087
#, fuzzy
msgid ":c:func:`PyObject_GC_Fini` to :c:func:`PyObject_GC_UnTrack`."
msgstr ":c:func:`PyObject_GC_Fini` 到 :c:func:`PyObject_GC_UnTrack`。"

#: ../../whatsnew/2.2.rst:1089
#, fuzzy
msgid "Remove :c:func:`PyGC_HEAD_SIZE` from object size calculations."
msgstr "從物件大小計算中刪除:c:func:`PyGC_HEAD_SIZE`。"

#: ../../whatsnew/2.2.rst:1091
#, fuzzy
msgid ""
"Remove calls to :c:func:`PyObject_AS_GC` and :c:func:`PyObject_FROM_GC`."
msgstr "刪除對 :c:func:`PyObject_AS_GC` 和 :c:func:`PyObject_FROM_GC` 的呼叫。"

#: ../../whatsnew/2.2.rst:1093
#, fuzzy
msgid ""
"A new ``et`` format sequence was added to :c:func:`PyArg_ParseTuple`; ``et`` "
"takes both a parameter and an encoding name, and converts the parameter to "
"the given encoding if the parameter turns out to be a Unicode string, or "
"leaves it alone if it's an 8-bit string, assuming it to already be in the "
"desired encoding.  This differs from the ``es`` format character, which "
"assumes that 8-bit strings are in Python's default ASCII encoding and "
"converts them to the specified new encoding. (Contributed by M.-A. Lemburg, "
"and used for the MBCS support on Windows described in the following section.)"
msgstr ""
"一個新的 ``et`` 格式序列被新增到 :c:func:`PyArg_ParseTuple`； ``et`` "
"接受一個參數和一個編碼名稱，如果參數原來是一個 Unicode "
"字串，則將參數轉換為給定的編碼，如果它是一個 8 "
"位字串，則不理會它，假設它已經是在所需的編碼中。這與 ``es`` 格式字元不同，"
"它假定 8 位字串採用 Python 的預設 ASCII 編碼並將它們轉換為指定的新編碼。 （"
"由 M.-A. Lemburg 提供，並用於下一節中描述的 Windows 上的 MBCS 支援。）"

#: ../../whatsnew/2.2.rst:1102
#, fuzzy
msgid ""
"A different argument parsing function, :c:func:`PyArg_UnpackTuple`, has been "
"added that's simpler and presumably faster.  Instead of specifying a format "
"string, the caller simply gives the minimum and maximum number of arguments "
"expected, and a set of pointers to :c:expr:`PyObject*` variables that will "
"be filled in with argument values."
msgstr ""
"新增了一個不同的參數解析函式 :c:func:`PyArg_UnpackTuple`，它更簡單並且可能更"
"快。呼叫者沒有指定格式字串，而是簡單地給出了預期參數的最小和最大數量，"
"以及一組指向將用參數值填充的 PyObject* 變數的指標。"

#: ../../whatsnew/2.2.rst:1108
#, fuzzy
msgid ""
"Two new flags :const:`METH_NOARGS` and :const:`METH_O` are available in "
"method definition tables to simplify implementation of methods with no "
"arguments or a single untyped argument. Calling such methods is more "
"efficient than calling a corresponding method that uses :const:"
"`METH_VARARGS`.  Also, the old :const:`METH_OLDARGS` style of writing C "
"methods is  now officially deprecated."
msgstr ""
"兩個新旗標 :const:`METH_NOARGS` 和 :const:`METH_O` "
"在方法定義表中可用，以簡化沒有參數或單個無型別參數的方法的實作。"
"呼叫此類方法比呼叫使用 METH_VARARGS 的相應方法更有效。此外，舊的 "
":const:`METH_OLDARGS` 編寫 C 方法的風格現已正式棄用。"

#: ../../whatsnew/2.2.rst:1114
#, fuzzy
msgid ""
"Two new wrapper functions, :c:func:`PyOS_snprintf` and :c:func:"
"`PyOS_vsnprintf` were added to provide  cross-platform implementations for "
"the relatively new :c:func:`snprintf` and :c:func:`vsnprintf` C lib APIs. In "
"contrast to the standard :c:func:`sprintf` and :c:func:`vsprintf` functions, "
"the Python versions check the bounds of the buffer used to protect against "
"buffer overruns. (Contributed by M.-A. Lemburg.)"
msgstr ""
"新增了兩個新的包裝函式 :c:func:`PyOS_snprintf` 和 :c:func:`PyOS_vsnprintf` "
"來為相對較新的 :c:func:`snprintf` 和 :c:func:`vsnprintf 提供跨平台實作` C 庫 "
"API。與標準 :c:func:`sprintf` 和 :c:func:`vsprintf` 函式相比，Python "
"版本檢查用於防止緩衝區溢出的緩衝區邊界。 （由 M.-A. Lemburg 提供。）"

#: ../../whatsnew/2.2.rst:1121
#, fuzzy
msgid ""
"The :c:func:`_PyTuple_Resize` function has lost an unused parameter, so now "
"it takes 2 parameters instead of 3.  The third argument was never used, and "
"can simply be discarded when porting code from earlier versions to Python "
"2.2."
msgstr ""
":c:func:`_PyTuple_Resize` 函式丟失了一個未使用的參數，因此現在它需要 2 "
"個參數而不是 3 個。第三個參數從未使用過，在將程式碼從早期版本移植到 Python "
"2.2 時可以簡單地丟棄。"

#: ../../whatsnew/2.2.rst:1129
#, fuzzy
msgid "Other Changes and Fixes"
msgstr "其他更改和修復"

#: ../../whatsnew/2.2.rst:1131
#, fuzzy
msgid ""
"As usual there were a bunch of other improvements and bugfixes scattered "
"throughout the source tree.  A search through the CVS change logs finds "
"there were 527 patches applied and 683 bugs fixed between Python 2.1 and "
"2.2; 2.2.1 applied 139 patches and fixed 143 bugs; 2.2.2 applied 106 patches "
"and fixed 82 bugs.  These figures are likely to be underestimates."
msgstr ""
"像往常一樣，在整個源程式碼樹中散佈著許多其他改進和錯誤修復。搜索 CVS "
"更改日誌發現在 Python 2.1 和 2.2 之間應用了 527 個補丁並修復了 683 個錯誤； "
"2.2.1 打了139個補丁，修復了143個bug； 2.2."
"2打了106個補丁，修復了82個bug。這些數字很可能被低估了。"

#: ../../whatsnew/2.2.rst:1137
#, fuzzy
msgid "Some of the more notable changes are:"
msgstr "一些更顯著的變化是："

#: ../../whatsnew/2.2.rst:1139
#, fuzzy
msgid ""
"The code for the MacOS port for Python, maintained by Jack Jansen, is now "
"kept in the main Python CVS tree, and many changes have been made to support "
"MacOS X."
msgstr ""
"由 Jack Jansen 維護的用於 Python 的 MacOS 端口的程式碼現在保存在主要的 "
"Python CVS 樹中，並且已經進行了許多更改以支援 MacOS X。"

#: ../../whatsnew/2.2.rst:1142
#, fuzzy
msgid ""
"The most significant change is the ability to build Python as a framework, "
"enabled by supplying the :option:`!--enable-framework` option to the "
"configure script when compiling Python.  According to Jack Jansen, \"This "
"installs a self-contained Python installation plus the OS X framework \"glue"
"\" into :file:`/Library/Frameworks/Python.framework` (or another location of "
"choice). For now there is little immediate added benefit to this (actually, "
"there is the disadvantage that you have to change your PATH to be able to "
"find Python), but it is the basis for creating a full-blown Python "
"application, porting the MacPython IDE, possibly using Python as a standard "
"OSA scripting language and much more.\""
msgstr ""
"最重要的變化是將 Python 構建為框架的能力，這是通過在編譯 Python "
"時向配置腳本提供 :option:`!--enable-framework` 選項來實作的。根據 Jack "
"Jansen 的說法，“這將安裝一個獨立的 Python 安裝和 OS X 框架“膠水”到 :file:`/"
"Library/Frameworks/Python."
"framework`（或其他選擇的位置）。目前幾乎沒有直接的這增加了好處（實際上，"
"缺點是您必須更改 PATH 才能找到 Python），但它是建立成熟的 Python 應用程式、"
"移植 MacPython IDE 的基礎，可能使用 Python 作為標準 OSA 腳本語言等等。”"

#: ../../whatsnew/2.2.rst:1153
#, fuzzy
msgid ""
"Most of the MacPython toolbox modules, which interface to MacOS APIs such as "
"windowing, QuickTime, scripting, etc. have been ported to OS X, but they've "
"been left commented out in :file:`setup.py`.  People who want to experiment "
"with these modules can uncomment them manually."
msgstr ""
"大多數 MacPython 工具箱模組，它們與窗口、QuickTime、腳本等 MacOS API 介面，"
"已移植到 OS X，但它們在 setup.py "
"中被註釋掉了。想要試用這些模組的人可以手動取消註釋。"

#: ../../whatsnew/2.2.rst:1176
#, fuzzy
msgid ""
"Keyword arguments passed to built-in functions that don't take them now "
"cause a :exc:`TypeError` exception to be raised, with the message "
"\"*function* takes no keyword arguments\"."
msgstr ""
"傳遞給不接受它們的內建函式的關鍵字參數現在會引發 :exc:`TypeError` "
"例外，並顯示消息“*function* takes no keyword arguments”。"

#: ../../whatsnew/2.2.rst:1180
#, fuzzy
msgid ""
"Weak references, added in Python 2.1 as an extension module, are now part of "
"the core because they're used in the implementation of new-style classes.  "
"The :exc:`ReferenceError` exception has therefore moved from the :mod:"
"`weakref` module to become a built-in exception."
msgstr ""
"弱引用作為擴充模組新增到 Python 2.1 中，現在已成為核心的一部分，因為它們用於"
"實作新型類。因此，:exc:`ReferenceError` 例外已從 :mod:`weakref` "
"模組移至內建例外。"

#: ../../whatsnew/2.2.rst:1185
#, fuzzy
msgid ""
"A new script, :file:`Tools/scripts/cleanfuture.py` by Tim Peters, "
"automatically removes obsolete ``__future__`` statements from Python source "
"code."
msgstr ""
"Tim Peters 的新腳本 :file:`Tools/scripts/cleanfuture.py` 自動從 Python "
"源程式碼中刪除過時的 `__future__`` 語句。"

#: ../../whatsnew/2.2.rst:1189
#, fuzzy
msgid ""
"An additional *flags* argument has been added to the built-in function :func:"
"`compile`, so the behaviour of ``__future__`` statements can now be "
"correctly observed in simulated shells, such as those presented by IDLE and "
"other development environments.  This is described in :pep:`264`. "
"(Contributed by Michael Hudson.)"
msgstr ""
"內建函式 :func:`compile` 中新增了一個額外的 *flags* 參數，因此現在可以在模擬 "
"shell 中正確觀察到 `__future__`` 語句的行為，例如 IDLE "
"和其他開發提供的那些環境。這在 :pep:`264` 中有描述。 （由邁克爾哈德森提供。）"

#: ../../whatsnew/2.2.rst:1195
#, fuzzy
msgid ""
"The new license introduced with Python 1.6 wasn't GPL-compatible.  This is "
"fixed by some minor textual changes to the 2.2 license, so it's now legal to "
"embed Python inside a GPLed program again.  Note that Python itself is not "
"GPLed, but instead is under a license that's essentially equivalent to the "
"BSD license, same as it always was.  The license changes were also applied "
"to the Python 2.0.1 and 2.1.1 releases."
msgstr ""
"Python 1.6 引入的新許可證與 GPL 不相容。這通過對 2.2 "
"許可證的一些小的文本更改得到修復，因此現在再次將 Python 嵌入到 GPLed "
"程式中是合法的。請注意，Python 本身不是 GPLed，而是在本質上等同於 BSD "
"許可證的許可證下，一如既往。許可證更改也適用於 Python 2.0.1 和 2.1.1 版本。"

#: ../../whatsnew/2.2.rst:1202
#, fuzzy
msgid ""
"When presented with a Unicode filename on Windows, Python will now convert "
"it to an MBCS encoded string, as used by the Microsoft file APIs.  As MBCS "
"is explicitly used by the file APIs, Python's choice of ASCII as the default "
"encoding turns out to be an annoyance.  On Unix, the locale's character set "
"is used if ``locale.nl_langinfo(CODESET)`` is available.  (Windows support "
"was contributed by Mark Hammond with assistance from Marc-André Lemburg. "
"Unix support was added by Martin von Löwis.)"
msgstr ""
"當在 Windows 上顯示 Unicode 文件名時，Python 現在會將其轉換為 MBCS 編碼字串，"
"供 Microsoft 文件 API 使用。由於文件 API 明確使用 MBCS，因此 Python 選擇 "
"ASCII 作為預設編碼被證明是一種煩惱。在 Unix 上，如果 locale."
"nl_langinfo(CODESET) 可用，則使用語言環境的字元集。 （Windows 支援由 Mark "
"Hammond 在 Marc-André Lemburg 的協助下貢獻。Unix 支援由 Martin von Löwis "
"新增。）"

#: ../../whatsnew/2.2.rst:1210
#, fuzzy
msgid ""
"Large file support is now enabled on Windows.  (Contributed by Tim Peters.)"
msgstr "Windows 現已啟用大文件支援。 （由蒂姆·彼得斯提供。）"

#: ../../whatsnew/2.2.rst:1212
#, fuzzy
msgid ""
"The :file:`Tools/scripts/ftpmirror.py` script now parses a :file:`.netrc` "
"file, if you have one. (Contributed by Mike Romberg.)"
msgstr ""
":file:`Tools/scripts/ftpmirror.py` 腳本現在可以解析 :file:`.netrc` "
"文件（如果有的話）。 （由 Mike Romberg 提供。）"

#: ../../whatsnew/2.2.rst:1215
#, fuzzy
msgid ""
"Some features of the object returned by the :func:`xrange` function are now "
"deprecated, and trigger warnings when they're accessed; they'll disappear in "
"Python 2.3. :class:`xrange` objects tried to pretend they were full sequence "
"types by supporting slicing, sequence multiplication, and the :keyword:`in` "
"operator, but these features were rarely used and therefore buggy.  The :"
"meth:`tolist` method and the :attr:`start`, :attr:`stop`, and :attr:`step` "
"attributes are also being deprecated.  At the C level, the fourth argument "
"to the :c:func:`PyRange_New` function, ``repeat``, has also been deprecated."
msgstr ""
":func:`xrange` 函式回傳的物件的一些特性現在已被棄用，並在訪問時觸發警告；"
"它們將在 Python 2.3 中消失。 :class:`xrange` 物件試圖通過支援切片、"
"序列乘法和 :keyword:`in` "
"運算符來假裝它們是完整的序列型別，但這些功能很少使用，因此存在錯誤。 "
":meth:`tolist` 方法和 :attr:`start`、:attr:`stop` 和 :attr:`step` "
"屬性也被棄用。在 C 級別，:c:func:`PyRange_New` "
"函式的第四個參數，``repeat``，也被棄用了。"

#: ../../whatsnew/2.2.rst:1224
#, fuzzy
msgid ""
"There were a bunch of patches to the dictionary implementation, mostly to "
"fix potential core dumps if a dictionary contains objects that sneakily "
"changed their hash value, or mutated the dictionary they were contained in. "
"For a while python-dev fell into a gentle rhythm of Michael Hudson finding a "
"case that dumped core, Tim Peters fixing the bug, Michael finding another "
"case, and round and round it went."
msgstr ""
"字典實作有很多補丁，主要是為了修復潛在的核心轉儲，如果字典包含偷偷改變它們的"
"雜湊值的物件，或者改變它們所在的字典。有一段時間 python-dev "
"陷入了一個溫和的節奏Michael Hudson 找到了一個傾倒核心的案例，Tim Peters "
"修復了這個 bug，Michael 找到了另一個案例，周而復始。"

#: ../../whatsnew/2.2.rst:1231
#, fuzzy
msgid ""
"On Windows, Python can now be compiled with Borland C thanks to a number of "
"patches contributed by Stephen Hansen, though the result isn't fully "
"functional yet.  (But this *is* progress...)"
msgstr ""
"在 Windows 上，由於 Stephen Hansen 提供的許多補丁，現在可以使用 Borland C "
"編譯 Python，儘管結果尚未完全發揮作用。 （但這*是*進步......）"

#: ../../whatsnew/2.2.rst:1235
#, fuzzy
msgid ""
"Another Windows enhancement: Wise Solutions generously offered PythonLabs "
"use of their InstallerMaster 8.1 system.  Earlier PythonLabs Windows "
"installers used Wise 5.0a, which was beginning to show its age.  (Packaged "
"up by Tim Peters.)"
msgstr ""
"另一個 Windows 增強功能：Wise Solutions 慷慨地為 PythonLabs 提供了他們的 "
"InstallerMaster 8.1 系統。早期的 PythonLabs Windows 安裝程式使用 Wise 5."
"0a，它開始顯示出它的時代。 （由蒂姆·彼得斯打包。）"

#: ../../whatsnew/2.2.rst:1239
#, fuzzy
msgid ""
"Files ending in ``.pyw`` can now be imported on Windows. ``.pyw`` is a "
"Windows-only thing, used to indicate that a script needs to be run using "
"PYTHONW.EXE instead of PYTHON.EXE in order to prevent a DOS console from "
"popping up to display the output.  This patch makes it possible to import "
"such scripts, in case they're also usable as modules.  (Implemented by David "
"Bolen.)"
msgstr ""
"現在可以在 Windows 上導入以 .pyw 結尾的文件。 ``.pyw`` 是 Windows "
"獨有的東西，用於指示腳本需要使用 PYTHONW.EXE 而不是 PYTHON.EXE 運行，"
"以防止彈出 DOS "
"控制台來顯示輸出。這個補丁可以導入這樣的腳本，以防它們也可以作為模組使用。 （"
"由 David Bolen 實施。）"

#: ../../whatsnew/2.2.rst:1245
#, fuzzy
msgid ""
"On platforms where Python uses the C :c:func:`dlopen` function  to load "
"extension modules, it's now possible to set the flags used  by :c:func:"
"`dlopen` using the :func:`sys.getdlopenflags` and :func:`sys.setdlopenflags` "
"functions. (Contributed by Bram Stolk.)"
msgstr ""
"在 Python 使用 C:c:func:`dlopen` 函式加載擴充模組的平台上，現在可以使用 "
":func:`sys.getdlopenflags` 設定由:c:func:`dlopen` 使用的旗標，並且： "
"func:`sys.setdlopenflags` 函式。 （由 Bram Stolk 提供。）"

#: ../../whatsnew/2.2.rst:1250
#, fuzzy
msgid ""
"The :func:`pow` built-in function no longer supports 3 arguments when "
"floating-point numbers are supplied. ``pow(x, y, z)`` returns ``(x**y) % "
"z``, but this is never useful for floating point numbers, and the final "
"result varies unpredictably depending on the platform.  A call such as "
"``pow(2.0, 8.0, 7.0)`` will now raise a :exc:`TypeError` exception."
msgstr ""
":func:`pow` 內建函式在提供浮點數時不再支援 3 個參數。 ``pow(x, y, z)`` 回傳 "
"``(x**y) % z``，但這對浮點數沒有用，最終結果因平台而異。諸如 ``pow(2.0, 8.0, "
"7.0)`` 之類的呼叫現在將引發 :exc:`TypeError` 例外。"

#: ../../whatsnew/2.2.rst:1260
msgid "Acknowledgements"
msgstr "致謝"

#: ../../whatsnew/2.2.rst:1262
#, fuzzy
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article: "
"Fred Bremmer, Keith Briggs, Andrew Dalke, Fred L. Drake, Jr., Carel "
"Fellinger, David Goodger, Mark Hammond, Stephen Hansen, Michael Hudson, Jack "
"Jansen, Marc-André Lemburg, Martin von Löwis, Fredrik Lundh, Michael McLay, "
"Nick Mathewson, Paul Moore, Gustavo Niemeyer, Don O'Donnell, Joonas "
"Paalasma, Tim Peters, Jens Quade, Tom Reinhardt, Neil Schemenauer, Guido van "
"Rossum, Greg Ward, Edward Welbourne."
msgstr ""
"作者要感謝以下人員為本文的各種草稿提供的建議、更正和協助：Fred Bremmer、"
"Keith Briggs、Andrew Dalke、Fred L. Drake, Jr.、Carel Fellinger、David "
"Goodger、Mark Hammond、Stephen漢森、邁克爾·哈德森、傑克·詹森、馬克-安德烈·倫"
"堡、馬丁·馮·洛維斯、弗雷德里克·隆德、邁克爾·麥克萊、尼克·馬修森、保羅·摩爾、"
"古斯塔沃·尼邁耶、唐·奧唐奈、喬納斯·帕拉斯瑪、蒂姆·彼得斯、延斯·奎德、湯姆·賴"
"因哈特、尼爾Schemenauer、Guido van Rossum、Greg Ward、Edward Welbourne。"
