# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Leon H., 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-15 20:43+0000\n"
"PO-Revision-Date: 2023-05-02 17:53+0800\n"
"Last-Translator: Matt Wang <mattwang44@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../distutils/apiref.rst:5
msgid "API Reference"
msgstr "API 參照"

#: ../../distutils/apiref.rst:11
#, fuzzy
msgid "`New and changed setup.py arguments in setuptools`_"
msgstr "`setuptools 中新的和更改的 setup.py 參數`_"

#: ../../distutils/apiref.rst:10
#, fuzzy
msgid ""
"The ``setuptools`` project adds new capabilities to the ``setup`` function "
"and other APIs, makes the API consistent across different Python versions, "
"and is hence recommended over using ``distutils`` directly."
msgstr ""
"``setuptools`` 項目為 ``setup`` 函式和其他 API 新增了新功能，使 API 在不同的 "
"Python 版本之間保持一致，因此建議不要直接使用 ``distutils``。"

#: ../../distutils/_setuptools_disclaimer.rst:3
#, fuzzy
msgid ""
"This document is being retained solely until the ``setuptools`` "
"documentation at https://setuptools.readthedocs.io/en/latest/setuptools.html "
"independently covers all of the relevant information currently included here."
msgstr ""
"本文檔僅保留到 https://setuptools.readthedocs.io/en/latest/setuptools.html 上"
"的 ``setuptools``文檔獨立涵蓋當前包含在此處的所有相關資訊。"

#: ../../distutils/apiref.rst:19
msgid ":mod:`distutils.core` --- Core Distutils functionality"
msgstr ":mod:`distutils.core` --- 核心 Distutils 功能"

#: ../../distutils/apiref.rst:25
#, fuzzy
msgid ""
"The :mod:`distutils.core` module is the only module that needs to be "
"installed to use the Distutils. It provides the :func:`setup` (which is "
"called from the setup script). Indirectly provides the  :class:`distutils."
"dist.Distribution` and :class:`distutils.cmd.Command` class."
msgstr ""
":mod:`distutils.core` 模組是唯一需要安裝才能使用 Distutils 的模組。它提供 :"
"func:`setup`（從安裝腳本中呼叫）。間接提供 distutils.dist.Distribution 和 "
"distutils.cmd.Command 類。"

#: ../../distutils/apiref.rst:33
#, fuzzy
msgid ""
"The basic do-everything function that does most everything you could ever "
"ask for from a Distutils method."
msgstr ""
"基本的 do-everything 功能可以完成您可以從 Distutils 方法中請求的大部分內容。"

#: ../../distutils/apiref.rst:36
#, fuzzy
msgid ""
"The setup function takes a large number of arguments. These are laid out in "
"the following table."
msgstr "setup 函式採用大量參數。這些在下表中列出。"

#: ../../distutils/apiref.rst:42 ../../distutils/apiref.rst:185
msgid "argument name"
msgstr "引數名稱"

#: ../../distutils/apiref.rst:42 ../../distutils/apiref.rst:143
#: ../../distutils/apiref.rst:185
#, fuzzy
msgid "value"
msgstr "價值"

#: ../../distutils/apiref.rst:42 ../../distutils/apiref.rst:185
msgid "type"
msgstr "型別"

#: ../../distutils/apiref.rst:44 ../../distutils/apiref.rst:187
msgid "*name*"
msgstr "*name*"

#: ../../distutils/apiref.rst:44
msgid "The name of the package"
msgstr "套件名稱"

#: ../../distutils/apiref.rst:44 ../../distutils/apiref.rst:46
#: ../../distutils/apiref.rst:50 ../../distutils/apiref.rst:53
#: ../../distutils/apiref.rst:56 ../../distutils/apiref.rst:58
#: ../../distutils/apiref.rst:61 ../../distutils/apiref.rst:68
#: ../../distutils/apiref.rst:72 ../../distutils/apiref.rst:75
#: ../../distutils/apiref.rst:96 ../../distutils/apiref.rst:106
#: ../../distutils/apiref.rst:187 ../../distutils/apiref.rst:278
#, fuzzy
msgid "a string"
msgstr "一個字串"

#: ../../distutils/apiref.rst:46
msgid "*version*"
msgstr "*version*"

#: ../../distutils/apiref.rst:46
#, fuzzy
msgid "The version number of the package; see :mod:`distutils.version`"
msgstr "包的版本號；見 :mod:`distutils.version`"

#: ../../distutils/apiref.rst:50
msgid "*description*"
msgstr "*description*"

#: ../../distutils/apiref.rst:50
#, fuzzy
msgid "A single line describing the package"
msgstr "一行描述包"

#: ../../distutils/apiref.rst:53
msgid "*long_description*"
msgstr "*long_description*"

#: ../../distutils/apiref.rst:53
#, fuzzy
msgid "Longer description of the package"
msgstr "更長的包裝描述"

#: ../../distutils/apiref.rst:56
msgid "*author*"
msgstr "*author*"

#: ../../distutils/apiref.rst:56
#, fuzzy
msgid "The name of the package author"
msgstr "包作者的名字"

#: ../../distutils/apiref.rst:58
msgid "*author_email*"
msgstr "*author_email*"

#: ../../distutils/apiref.rst:58
#, fuzzy
msgid "The email address of the package author"
msgstr "包作者的電子郵件地址"

#: ../../distutils/apiref.rst:61
msgid "*maintainer*"
msgstr "*maintainer*"

#: ../../distutils/apiref.rst:61
#, fuzzy
msgid ""
"The name of the current maintainer, if different from the author. Note that "
"if the maintainer is provided, distutils will use it as the author in :file:"
"`PKG-INFO`"
msgstr ""
"當前維護者的姓名，如果與作者不同。請注意，如果提供了維護者，distutils 將使用"
"它作為 :file:`PKG-INFO` 中的作者"

#: ../../distutils/apiref.rst:68
msgid "*maintainer_email*"
msgstr "*maintainer_email*"

#: ../../distutils/apiref.rst:68
#, fuzzy
msgid ""
"The email address of the current maintainer, if different from the author"
msgstr "當前維護者的電子郵件地址，如果與作者不同"

#: ../../distutils/apiref.rst:72
msgid "*url*"
msgstr "*url*"

#: ../../distutils/apiref.rst:72
#, fuzzy
msgid "A URL for the package (homepage)"
msgstr "包的 URL（主頁）"

#: ../../distutils/apiref.rst:75
msgid "*download_url*"
msgstr "*download_url*"

#: ../../distutils/apiref.rst:75
#, fuzzy
msgid "A URL to download the package"
msgstr "下載套件的 URL"

#: ../../distutils/apiref.rst:77
msgid "*packages*"
msgstr "*packages*"

#: ../../distutils/apiref.rst:77
#, fuzzy
msgid "A list of Python packages that distutils will manipulate"
msgstr "distutils 將操作的 Python 套件列表"

#: ../../distutils/apiref.rst:77 ../../distutils/apiref.rst:80
#: ../../distutils/apiref.rst:83 ../../distutils/apiref.rst:100
#: ../../distutils/apiref.rst:193 ../../distutils/apiref.rst:207
#: ../../distutils/apiref.rst:223 ../../distutils/apiref.rst:226
#: ../../distutils/apiref.rst:230 ../../distutils/apiref.rst:234
#: ../../distutils/apiref.rst:240 ../../distutils/apiref.rst:247
#: ../../distutils/apiref.rst:258 ../../distutils/apiref.rst:267
#: ../../distutils/apiref.rst:275
#, fuzzy
msgid "a list of strings"
msgstr "字串列表"

#: ../../distutils/apiref.rst:80
msgid "*py_modules*"
msgstr "*py_modules*"

#: ../../distutils/apiref.rst:80
#, fuzzy
msgid "A list of Python modules that distutils will manipulate"
msgstr "distutils 將操作的 Python 模組列表"

#: ../../distutils/apiref.rst:83
msgid "*scripts*"
msgstr "*scripts*"

#: ../../distutils/apiref.rst:83
#, fuzzy
msgid "A list of standalone script files to be built and installed"
msgstr "要構建和安裝的獨立腳本文件列表"

#: ../../distutils/apiref.rst:87
msgid "*ext_modules*"
msgstr "*ext_modules*"

#: ../../distutils/apiref.rst:87
#, fuzzy
msgid "A list of Python extensions to be built"
msgstr "要構建的 Python 擴充列表"

#: ../../distutils/apiref.rst:87
#, fuzzy
msgid "a list of instances of :class:`distutils.core.Extension`"
msgstr "distutils.core.Extension 的實例列表"

#: ../../distutils/apiref.rst:90
msgid "*classifiers*"
msgstr "*classifiers*"

#: ../../distutils/apiref.rst:90
#, fuzzy
msgid "A list of categories for the package"
msgstr "套件的類別列表"

#: ../../distutils/apiref.rst:90
#, fuzzy
msgid ""
"a list of strings; valid classifiers are listed on `PyPI <https://pypi.org/"
"classifiers>`_."
msgstr ""
"字串列表； `PyPI <https://pypi.org/classifiers>`_ 上列出了有效的分類器。"

#: ../../distutils/apiref.rst:93
msgid "*distclass*"
msgstr "*distclass*"

#: ../../distutils/apiref.rst:93
#, fuzzy
msgid "the :class:`Distribution` class to use"
msgstr "要使用的 :class:`Distribution` 類"

#: ../../distutils/apiref.rst:93
#, fuzzy
msgid "a subclass of :class:`distutils.core.Distribution`"
msgstr "distutils.core.Distribution 的子類別"

#: ../../distutils/apiref.rst:96
msgid "*script_name*"
msgstr "*script_name*"

#: ../../distutils/apiref.rst:96
#, fuzzy
msgid "The name of the setup.py script - defaults to ``sys.argv[0]``"
msgstr "setup.py 腳本的名稱——預設為 ``sys.argv[0]``"

#: ../../distutils/apiref.rst:100
msgid "*script_args*"
msgstr "*script_args*"

#: ../../distutils/apiref.rst:100
#, fuzzy
msgid "Arguments to supply to the setup script"
msgstr "提供給安裝腳本的參數"

#: ../../distutils/apiref.rst:103
msgid "*options*"
msgstr "*options*"

#: ../../distutils/apiref.rst:103
#, fuzzy
msgid "default options for the setup script"
msgstr "安裝腳本的預設選項"

#: ../../distutils/apiref.rst:103 ../../distutils/apiref.rst:113
#: ../../distutils/apiref.rst:119
#, fuzzy
msgid "a dictionary"
msgstr "一本字典"

#: ../../distutils/apiref.rst:106
msgid "*license*"
msgstr "*license*"

#: ../../distutils/apiref.rst:106
#, fuzzy
msgid "The license for the package"
msgstr "套件的許可證"

#: ../../distutils/apiref.rst:108
msgid "*keywords*"
msgstr "*keywords*"

#: ../../distutils/apiref.rst:108
#, fuzzy
msgid "Descriptive meta-data, see :pep:`314`"
msgstr "描述性元資料，參見 :pep:`314`"

#: ../../distutils/apiref.rst:108 ../../distutils/apiref.rst:111
#, fuzzy
msgid "a list of strings or a comma-separated string"
msgstr "字串列表或逗號分隔的字串"

#: ../../distutils/apiref.rst:111
msgid "*platforms*"
msgstr "*platforms*"

#: ../../distutils/apiref.rst:113
msgid "*cmdclass*"
msgstr "*cmdclass*"

#: ../../distutils/apiref.rst:113
#, fuzzy
msgid "A mapping of command names to :class:`Command` subclasses"
msgstr "命令名稱到 :class:`Command` 子類別的映射"

#: ../../distutils/apiref.rst:116
msgid "*data_files*"
msgstr "*data_files*"

#: ../../distutils/apiref.rst:116
#, fuzzy
msgid "A list of data files to install"
msgstr "要安裝的資料文件列表"

#: ../../distutils/apiref.rst:116
#, fuzzy
msgid "a list"
msgstr "一個列表"

#: ../../distutils/apiref.rst:119
msgid "*package_dir*"
msgstr "*package_dir*"

#: ../../distutils/apiref.rst:119
#, fuzzy
msgid "A mapping of package to directory names"
msgstr "套件到目錄名的映射"

#: ../../distutils/apiref.rst:127
#, fuzzy
msgid ""
"Run a setup script in a somewhat controlled environment, and return  the :"
"class:`distutils.dist.Distribution` instance that drives things.   This is "
"useful if you need to find out the distribution meta-data  (passed as "
"keyword args from *script* to :func:`setup`), or  the contents of the config "
"files or command-line."
msgstr ""
"在某種程度上受控的環境中運行設定腳本，並回傳驅動事物的 distutils.dist."
"Distribution 實例。如果您需要找出分發元資料（作為關鍵字參數從 *script* 傳遞"
"到 :func:`setup`）或配置文件或命令列的內容，這將很有用。"

#: ../../distutils/apiref.rst:133
#, fuzzy
msgid ""
"*script_name* is a file that will be read and run with :func:`exec`.  ``sys."
"argv[0]`` will be replaced with *script* for the duration of the call.  "
"*script_args* is a list of strings; if supplied, ``sys.argv[1:]`` will be "
"replaced by *script_args* for the duration  of the call."
msgstr ""
"*script_name* 是一個將使用 :func:`exec` 讀取和運行的文件。在通話期間，``sys."
"argv[0]`` 將被替換為 *script*。 *script_args* 是一個字串列表；如果提供，"
"``sys.argv[1:]`` 將在呼叫期間被 *script_args* 替換。"

#: ../../distutils/apiref.rst:138
#, fuzzy
msgid ""
"*stop_after* tells :func:`setup` when to stop processing; possible  values:"
msgstr "*stop_after* 告訴 :func:`setup` 何時停止處理；可能的值："

#: ../../distutils/apiref.rst:143 ../../distutils/apiref.rst:562
#: ../../distutils/apiref.rst:1606
msgid "description"
msgstr "描述"

#: ../../distutils/apiref.rst:145
msgid "*init*"
msgstr "*init*"

#: ../../distutils/apiref.rst:145
#, fuzzy
msgid ""
"Stop after the :class:`Distribution` instance has been created  and "
"populated with the keyword arguments to :func:`setup`"
msgstr "在建立 Distribution 實例並使用 setup 的關鍵字參數填充後停止"

#: ../../distutils/apiref.rst:149
msgid "*config*"
msgstr "*config*"

#: ../../distutils/apiref.rst:149
#, fuzzy
msgid ""
"Stop after config files have been parsed (and their data stored in the :"
"class:`Distribution` instance)"
msgstr "配置文件被解析後停止（它們的資料儲存在 Distribution 實例中）"

#: ../../distutils/apiref.rst:153
msgid "*commandline*"
msgstr "*commandline*"

#: ../../distutils/apiref.rst:153
#, fuzzy
msgid ""
"Stop after the command-line (``sys.argv[1:]`` or  *script_args*) have been "
"parsed (and the data stored in the :class:`Distribution` instance.)"
msgstr ""
"在解析命令列（``sys.argv[1:]`` 或 *script_args*）（以及儲存在 Distribution 實"
"例中的資料）後停止。"

#: ../../distutils/apiref.rst:158
msgid "*run*"
msgstr "*run*"

#: ../../distutils/apiref.rst:158
#, fuzzy
msgid ""
"Stop after all commands have been run (the same as  if :func:`setup` had "
"been called in the usual way). This is the default value."
msgstr ""
"在運行所有命令後停止（就像 :func:`setup` 以通常的方式被呼叫一樣）。這是預設"
"值。"

#: ../../distutils/apiref.rst:164
#, fuzzy
msgid ""
"In addition, the :mod:`distutils.core` module exposed a number of  classes "
"that live elsewhere."
msgstr "此外，:mod:`distutils.core` 模組公開了許多位於其他地方的類。"

#: ../../distutils/apiref.rst:167
#, fuzzy
msgid ":class:`~distutils.extension.Extension` from :mod:`distutils.extension`"
msgstr ""
":class:`~distutils.extension.Extension` 來自 :mod:`distutils.extension`"

#: ../../distutils/apiref.rst:169
#, fuzzy
msgid ":class:`~distutils.cmd.Command` from :mod:`distutils.cmd`"
msgstr ":class:`~distutils.cmd.Command` 來自 :mod:`distutils.cmd`"

#: ../../distutils/apiref.rst:171
#, fuzzy
msgid ":class:`~distutils.dist.Distribution` from :mod:`distutils.dist`"
msgstr ":class:`~distutils.dist.Distribution` 來自 :mod:`distutils.dist`"

#: ../../distutils/apiref.rst:173
#, fuzzy
msgid ""
"A short description of each of these follows, but see the relevant module "
"for the full reference."
msgstr "以下是對其中每一個的簡短描述，但請參閱相關模組以獲取完整參考。"

#: ../../distutils/apiref.rst:179
#, fuzzy
msgid ""
"The Extension class describes a single C or C++ extension module in a setup "
"script. It accepts the following keyword arguments in its constructor:"
msgstr ""
"Extension 類描述安裝腳本中的單個 C 或 C++ 擴充模組。它在其構造函式中接受以下"
"關鍵字參數："

#: ../../distutils/apiref.rst:187
#, fuzzy
msgid ""
"the full name of the extension, including any packages --- ie. *not* a "
"filename or pathname, but Python dotted name"
msgstr ""
"擴充的全名，包括任何套件 --- 即。 *不是*文件名或路徑名，而是 Python 點名"

#: ../../distutils/apiref.rst:193
msgid "*sources*"
msgstr "*sources*"

#: ../../distutils/apiref.rst:193
#, fuzzy
msgid ""
"list of source filenames, relative to the distribution root (where the setup "
"script lives), in Unix form (slash-separated) for portability. Source files "
"may be C, C++, SWIG (.i), platform-specific resource files, or whatever else "
"is recognized by the :command:`build_ext` command as source for a Python "
"extension."
msgstr ""
"源文件名列表，相對於分髮根目錄（安裝腳本所在的位置），以 Unix 形式（斜杠分"
"隔）以便於移植。源文件可以是 C、C++、SWIG (.i)、特定於平台的資源文件，或者任"
"何其他被 :command:`build_ext` 命令識別為 Python 擴充源的文件。"

#: ../../distutils/apiref.rst:207
msgid "*include_dirs*"
msgstr "*include_dirs*"

#: ../../distutils/apiref.rst:207
#, fuzzy
msgid ""
"list of directories to search for C/C++ header files (in Unix form for "
"portability)"
msgstr "用於搜索 C/C++ 標頭檔的目錄列表（以 Unix 形式提供可移植性）"

#: ../../distutils/apiref.rst:211
msgid "*define_macros*"
msgstr "*define_macros*"

#: ../../distutils/apiref.rst:211
#, fuzzy
msgid ""
"list of macros to define; each macro is defined using a 2-tuple ``(name, "
"value)``, where *value* is either the string to define it to or ``None`` to "
"define it without a particular value (equivalent of ``#define FOO`` in "
"source or :option:`!-DFOO` on Unix C compiler command line)"
msgstr ""
"要定義的巨集列表；每個巨集都是使用二元組``(name, value)``定義的，其中 "
"*value* 是定義它的字串或``None``定義它沒有特定值（相當於``#在源程式碼中定義 "
"FOO`` 或在 Unix C 編譯器命令列上定義 :option:`!-DFOO`）"

#: ../../distutils/apiref.rst:211
#, fuzzy
msgid "a list of tuples"
msgstr "元組列表"

#: ../../distutils/apiref.rst:223
msgid "*undef_macros*"
msgstr "*undef_macros*"

#: ../../distutils/apiref.rst:223
#, fuzzy
msgid "list of macros to undefine explicitly"
msgstr "要顯式取消定義的巨集列表"

#: ../../distutils/apiref.rst:226
msgid "*library_dirs*"
msgstr "*library_dirs*"

#: ../../distutils/apiref.rst:226
#, fuzzy
msgid "list of directories to search for C/C++ libraries at link time"
msgstr "在鏈接時搜索 C/C++ 庫的目錄列表"

#: ../../distutils/apiref.rst:230
msgid "*libraries*"
msgstr "*libraries*"

#: ../../distutils/apiref.rst:230
#, fuzzy
msgid "list of library names (not filenames or paths) to link against"
msgstr "要鏈接的庫名稱列表（不是文件名或路徑）"

#: ../../distutils/apiref.rst:234
msgid "*runtime_library_dirs*"
msgstr "*runtime_library_dirs*"

#: ../../distutils/apiref.rst:234
#, fuzzy
msgid ""
"list of directories to search for C/C++ libraries at run time (for shared "
"extensions, this is when the extension is loaded)"
msgstr "在運行時搜索 C/C++ 庫的目錄列表（對於共享擴充，這是在加載擴充時）"

#: ../../distutils/apiref.rst:240
msgid "*extra_objects*"
msgstr "*extra_objects*"

#: ../../distutils/apiref.rst:240
#, fuzzy
msgid ""
"list of extra files to link with (eg. object files not implied by 'sources', "
"static library that must be explicitly specified, binary resource files, "
"etc.)"
msgstr ""
"要鏈接的額外文件列表（例如，'sources' 未暗示的目標文件、必須明確指定的靜態"
"庫、二進制資源文件等）"

#: ../../distutils/apiref.rst:247
msgid "*extra_compile_args*"
msgstr "*extra_compile_args*"

#: ../../distutils/apiref.rst:247
#, fuzzy
msgid ""
"any extra platform- and compiler-specific information to use when compiling "
"the source files in 'sources'. For platforms and compilers where a command "
"line makes sense, this is typically a list of command-line arguments, but "
"for other platforms it could be anything."
msgstr ""
"編譯 ``sources`` 中的源文件時要使用的任何額外的特定於平台和編譯器的資訊。對於"
"命令列有意義的平台和編譯器，這通常是命令列參數列表，但對於其他平台，它可以是"
"任何東西。"

#: ../../distutils/apiref.rst:258
msgid "*extra_link_args*"
msgstr "*extra_link_args*"

#: ../../distutils/apiref.rst:258
#, fuzzy
msgid ""
"any extra platform- and compiler-specific information to use when linking "
"object files together to create the extension (or to create a new static "
"Python interpreter). Similar interpretation as for 'extra_compile_args'."
msgstr ""
"將目標文件鏈接在一起以建立擴充（或建立新的靜態 Python 直譯器）時要使用的任何"
"額外的特定於平台和編譯器的資訊。與“extra_compile_args”類似的解釋。"

#: ../../distutils/apiref.rst:267
msgid "*export_symbols*"
msgstr "*export_symbols*"

#: ../../distutils/apiref.rst:267
#, fuzzy
msgid ""
"list of symbols to be exported from a shared extension. Not used on all "
"platforms, and not generally necessary for Python extensions, which "
"typically export exactly one symbol: ``init`` + extension_name."
msgstr ""
"要從共享擴充中導出的符號列表。並非在所有平台上都使用，並且通常不是 Python 擴"
"充所必需的，Python 擴充通常只導出一個符號：``init`` + extension_name。"

#: ../../distutils/apiref.rst:275
msgid "*depends*"
msgstr "*depends*"

#: ../../distutils/apiref.rst:275
#, fuzzy
msgid "list of files that the extension depends on"
msgstr "擴充依賴的文件列表"

#: ../../distutils/apiref.rst:278
msgid "*language*"
msgstr "*language*"

#: ../../distutils/apiref.rst:278
#, fuzzy
msgid ""
"extension language (i.e. ``'c'``, ``'c++'``, ``'objc'``). Will be detected "
"from the source extensions if not provided."
msgstr ""
"擴充語言（即``'c'``，``'c++'``，``'objc'``）。如果未提供，將從源擴充中檢測"
"到。"

#: ../../distutils/apiref.rst:284
msgid "*optional*"
msgstr "*optional*"

#: ../../distutils/apiref.rst:284
#, fuzzy
msgid ""
"specifies that a build failure in the extension should not abort the build "
"process, but simply skip the extension."
msgstr "指定擴充中的構建失敗不應中止構建過程，而只是跳過擴充。"

#: ../../distutils/apiref.rst:284
#, fuzzy
msgid "a boolean"
msgstr "一個布爾值"

#: ../../distutils/apiref.rst:292
#, fuzzy
msgid ""
"On Unix, C extensions are no longer linked to libpython except on Android "
"and Cygwin."
msgstr ""
"在 Unix 上，C 擴充不再鏈接到 libpython，但在 Android 和 Cygwin 上除外。"

#: ../../distutils/apiref.rst:298
#, fuzzy
msgid ""
"A :class:`Distribution` describes how to build, install and package up a "
"Python software package."
msgstr ":class:`Distribution` 描述瞭如何構建、安裝和打包 Python 軟件套件。"

#: ../../distutils/apiref.rst:301
#, fuzzy
msgid ""
"See the :func:`setup` function for a list of keyword arguments accepted  by "
"the Distribution constructor. :func:`setup` creates a Distribution instance."
msgstr ""
"有關 Distribution 構造函式接受的關鍵字參數列表，請參閱 :func:`setup` 函式。 :"
"func:`setup` 建立一個 Distribution 實例。"

#: ../../distutils/apiref.rst:304
#, fuzzy
msgid ""
":class:`~distutils.core.Distribution` now warns if ``classifiers``, "
"``keywords`` and ``platforms`` fields are not specified as a list or a "
"string."
msgstr ""
":class:`~distutils.core.Distribution` 現在會在 ``classifiers``、``keywords`` "
"和 ``platforms`` 欄位未指定為列表或字串時發出警告。"

#: ../../distutils/apiref.rst:311
#, fuzzy
msgid ""
"A :class:`Command` class (or rather, an instance of one of its subclasses) "
"implement a single distutils command."
msgstr ""
":class:`Command` 類（或者更確切地說，它的子類別之一的實例）實作單個 "
"distutils 命令。"

#: ../../distutils/apiref.rst:316
#, fuzzy
msgid ":mod:`distutils.ccompiler` --- CCompiler base class"
msgstr ":mod:`distutils.ccompiler` --- CCompiler 基底類別"

#: ../../distutils/apiref.rst:322
#, fuzzy
msgid ""
"This module provides the abstract base class for the :class:`CCompiler` "
"classes.  A :class:`CCompiler` instance can be used for all the compile  and "
"link steps needed to build a single project. Methods are provided to  set "
"options for the compiler --- macro definitions, include directories,  link "
"path, libraries and the like."
msgstr ""
"該模組為 CCompiler 類提供抽象基底類別。 :class:`CCompiler` 實例可用於構建單個"
"項目所需的所有編譯和鏈接步驟。提供了為編譯器設定選項的方法---巨集定義，包括目"
"錄、鏈接路徑、庫等。"

#: ../../distutils/apiref.rst:328
#, fuzzy
msgid "This module provides the following functions."
msgstr "該模組提供以下功能。"

#: ../../distutils/apiref.rst:333
#, fuzzy
msgid ""
"Generate linker options for searching library directories and linking with "
"specific libraries.  *libraries* and *library_dirs* are, respectively, lists "
"of library names (not filenames!) and search directories.  Returns a list of "
"command-line options suitable for use with some compiler (depending on the "
"two format strings passed in)."
msgstr ""
"生成用於搜索庫目錄和與特定庫鏈接的鏈接器選項。 *libraries* 和 *library_dirs* "
"分別是庫名稱（不是文件名！）和搜索目錄的列表。回傳適用於某些編譯器的命令列選"
"項列表（取決於傳入的兩個格式字串）。"

#: ../../distutils/apiref.rst:342
#, fuzzy
msgid ""
"Generate C pre-processor options (:option:`!-D`, :option:`!-U`, :option:`!-"
"I`) as used by at least two types of compilers: the typical Unix compiler "
"and Visual C++. *macros* is the usual thing, a list of 1- or 2-tuples, where "
"``(name,)`` means undefine (:option:`!-U`) macro *name*, and ``(name, "
"value)`` means define (:option:`!-D`) macro *name* to *value*.  "
"*include_dirs* is just a list of directory names to be added to the header "
"file search path (:option:`!-I`). Returns a list of command-line options "
"suitable for either Unix compilers or Visual C++."
msgstr ""
"生成至少兩種型別的編譯器使用的 C 預處理器選項（:option:`!-D`、:option:`!-"
"U`、:option:`!-I`）：典型的 Unix 編譯器和 Visual C++。 *macros* 是通常的東"
"西，一個 1 元組或 2 元組的列表，其中 ``(name,)`` 表示未定義 (:option:`!-U`) "
"macro *name*，而 ``(name, value)`` 表示定義 (:option:`!-D`) 巨集 *name* 到 "
"*value*。 *include_dirs* 只是要新增到標頭檔搜索路徑的目錄名稱列表 (:option:"
"`!-I`)。回傳適用於 Unix 編譯器或 Visual C++ 的命令列選項列表。"

#: ../../distutils/apiref.rst:354
#, fuzzy
msgid "Determine the default compiler to use for the given platform."
msgstr "確定用於給定平台的預設編譯器。"

#: ../../distutils/apiref.rst:356
#, fuzzy
msgid ""
"*osname* should be one of the standard Python OS names (i.e. the ones "
"returned by ``os.name``) and *platform* the common value returned by ``sys."
"platform`` for the platform in question."
msgstr ""
"*osname* 應該是標準的 Python 操作系統名稱之一（即由 ``os.name`` 回傳的名稱）"
"和 *platform* 由``sys.platform`` 為相關平台回傳的公開值。"

#: ../../distutils/apiref.rst:360
#, fuzzy
msgid ""
"The default values are ``os.name`` and ``sys.platform`` in case the "
"parameters are not given."
msgstr "如果未給出參數，預設值為 ``os.name`` 和 ``sys.platform``。"

#: ../../distutils/apiref.rst:366
#, fuzzy
msgid ""
"Factory function to generate an instance of some CCompiler subclass for the "
"supplied platform/compiler combination. *plat* defaults to ``os.name`` (eg. "
"``'posix'``, ``'nt'``), and *compiler*  defaults to the default compiler for "
"that platform. Currently only ``'posix'`` and ``'nt'`` are supported, and "
"the default compilers are \"traditional Unix interface\" (:class:"
"`UnixCCompiler` class) and Visual C++ (:class:`MSVCCompiler` class).  Note "
"that it's perfectly possible to ask for a Unix compiler object under "
"Windows, and a Microsoft compiler object under Unix---if you supply a value "
"for *compiler*, *plat* is ignored."
msgstr ""
"為提供的平台/編譯器組合生成某些 CCompiler 子類別實例的工廠函式。 *plat* 預設"
"為 ``os.name``（例如 ``'posix'``、``'nt'``），*compiler* 預設為該平台的預設編"
"譯器。目前只支援 ``'posix'`` 和 ``'nt'``，預設編譯器是“傳統 Unix 介面”（:"
"class:`UnixCCompiler` 類）和 Visual C++（:class:`MSVCCompiler` 類） ).請注"
"意，完全有可能在 Windows 下請求一個 Unix 編譯器物件，在 Unix 下請求一個 "
"Microsoft 編譯器物件——如果您為 *compiler* 提供一個值，*plat* 將被忽略。"

#: ../../distutils/apiref.rst:382
#, fuzzy
msgid ""
"Print list of available compilers (used by the :option:`!--help-compiler` "
"options to :command:`build`, :command:`build_ext`, :command:`build_clib`)."
msgstr ""
"印出可用編譯器列表（由 :option:`!--help-compiler` 選項用於 :command:"
"`build`、:command:`build_ext`、:command:`build_clib`）。"

#: ../../distutils/apiref.rst:388
#, fuzzy
msgid ""
"The abstract base class :class:`CCompiler` defines the interface that  must "
"be implemented by real compiler classes.  The class also has  some utility "
"methods used by several compiler classes."
msgstr ""
"抽象基底類別 CCompiler 定義了必須由真實編譯器類實作的介面。該類還有一些被多個"
"編譯器類使用的實用方法。"

#: ../../distutils/apiref.rst:392
#, fuzzy
msgid ""
"The basic idea behind a compiler abstraction class is that each instance can "
"be used for all the compile/link steps in building a single project.  Thus, "
"attributes common to all of those compile and link steps --- include "
"directories, macros to define, libraries to link against, etc. --- are "
"attributes of the compiler instance.  To allow for variability in how "
"individual files are treated, most of those attributes may be varied on a "
"per-compilation or per-link basis."
msgstr ""
"編譯器抽像類背後的基本思想是每個實例都可以用於構建單個項目的所有編譯/鏈接步"
"驟。因此，所有這些編譯和鏈接步驟共有的屬性——包括目錄、要定義的巨集、要鏈接的"
"庫等——是編譯器實例的屬性。為了允許處理單個文件的方式的可變性，這些屬性中的大"
"多數可能會在每個編譯或每個鏈接的基礎上發生變化。"

#: ../../distutils/apiref.rst:400
#, fuzzy
msgid ""
"The constructor for each subclass creates an instance of the Compiler "
"object. Flags are *verbose* (show verbose output), *dry_run* (don't actually "
"execute the steps) and *force* (rebuild everything, regardless of "
"dependencies). All of these flags default to ``0`` (off). Note that you "
"probably don't want to instantiate :class:`CCompiler` or one of its "
"subclasses directly - use the :func:`distutils.CCompiler.new_compiler` "
"factory function instead."
msgstr ""
"每個子類別的構造函式建立一個 Compiler 物件的實例。旗標是 *verbose*（顯示詳細"
"輸出）、*dry_run*（實際上不執行這些步驟）和 *force*（重建所有內容，無論依賴性"
"如何）。所有這些旗標都預設為 ``0``（關閉）。請注意，您可能不想直接實例化 "
"CCompiler 或其子類別之一 - 請改用 distutils.CCompiler.new_compiler 工廠函式。"

#: ../../distutils/apiref.rst:407
#, fuzzy
msgid ""
"The following methods allow you to manually alter compiler options for  the "
"instance of the Compiler class."
msgstr "以下方法允許您手動更改 Compiler 類實例的編譯器選項。"

#: ../../distutils/apiref.rst:413
#, fuzzy
msgid ""
"Add *dir* to the list of directories that will be searched for header files. "
"The compiler is instructed to search directories in the order in which they "
"are supplied by successive calls to :meth:`add_include_dir`."
msgstr ""
"將 *dir* 新增到將搜索標頭檔的目錄列表中。指示編譯器按照連續呼叫 "
"add_include_dir 提供目錄的順序搜索目錄。"

#: ../../distutils/apiref.rst:420
#, fuzzy
msgid ""
"Set the list of directories that will be searched to *dirs* (a list of "
"strings). Overrides any preceding calls to :meth:`add_include_dir`; "
"subsequent calls to :meth:`add_include_dir` add to the list passed to :meth:"
"`set_include_dirs`. This does not affect any list of standard include "
"directories that the compiler may search by default."
msgstr ""
"將要搜索的目錄列表設定為 *dirs*（字串列表）。覆蓋之前對 add_include_dir 的任"
"何呼叫；隨後呼叫 :meth:`add_include_dir` 新增到傳遞給 :meth:"
"`set_include_dirs` 的列表。這不會影響編譯器預設搜索的任何標準包含目錄列表。"

#: ../../distutils/apiref.rst:429
#, fuzzy
msgid ""
"Add *libname* to the list of libraries that will be included in all links "
"driven by this compiler object.  Note that *libname* should \\*not\\* be the "
"name of a file containing a library, but the name of the library itself: the "
"actual filename will be inferred by the linker, the compiler, or the "
"compiler class (depending on the platform)."
msgstr ""
"將 *libname* 新增到將包含在此編譯器物件驅動的所有鏈接中的庫列表中。請注意，"
"*libname* 應該\\*不是\\* 是包含庫的文件的名稱，而是庫本身的名稱：實際的文件名"
"將由鏈接器、編譯器或編譯器類（取決於平台）。"

#: ../../distutils/apiref.rst:435
#, fuzzy
msgid ""
"The linker will be instructed to link against libraries in the order they "
"were supplied to :meth:`add_library` and/or :meth:`set_libraries`.  It is "
"perfectly valid to duplicate library names; the linker will be instructed to "
"link against libraries as many times as they are mentioned."
msgstr ""
"將指示鏈接器按照庫提供給 add_library 和/或 set_libraries 的順序鏈接庫。重複庫"
"名是完全有效的；鏈接器將被指示鏈接到庫的次數與提到的次數一樣多。"

#: ../../distutils/apiref.rst:443
#, fuzzy
msgid ""
"Set the list of libraries to be included in all links driven by this "
"compiler object to *libnames* (a list of strings).  This does not affect any "
"standard system libraries that the linker may include by default."
msgstr ""
"將要包含在此編譯器物件驅動的所有鏈接中的庫列表設定為 *libnames*（字串列表）。"
"這不會影響鏈接器預設包含的任何標準系統庫。"

#: ../../distutils/apiref.rst:450
#, fuzzy
msgid ""
"Add *dir* to the list of directories that will be searched for libraries "
"specified to :meth:`add_library` and :meth:`set_libraries`.  The linker will "
"be instructed to search for libraries in the order they are supplied to :"
"meth:`add_library_dir` and/or :meth:`set_library_dirs`."
msgstr ""
"將 *dir* 新增到將搜索指定給 add_library 和 set_libraries 的庫的目錄列表中。鏈"
"接器將被指示按照它們提供給 :meth:`add_library_dir` 和/或 :meth:"
"`set_library_dirs` 的順序搜索庫。"

#: ../../distutils/apiref.rst:458
#, fuzzy
msgid ""
"Set the list of library search directories to *dirs* (a list of strings).  "
"This does not affect any standard library search path that the linker may "
"search by default."
msgstr ""
"將庫搜索目錄列表設定為 *dirs*（字串列表）。這不會影響鏈接器預設搜索的任何標準"
"庫搜索路徑。"

#: ../../distutils/apiref.rst:465
#, fuzzy
msgid ""
"Add *dir* to the list of directories that will be searched for shared "
"libraries at runtime."
msgstr "將 *dir* 新增到將在運行時搜索共享庫的目錄列表。"

#: ../../distutils/apiref.rst:471
#, fuzzy
msgid ""
"Set the list of directories to search for shared libraries at runtime to "
"*dirs* (a list of strings).  This does not affect any standard search path "
"that the runtime linker may search by default."
msgstr ""
"將運行時搜索共享庫的目錄列表設定為 *dirs*（字串列表）。這不會影響運行時鏈接程"
"式預設搜索的任何標準搜索路徑。"

#: ../../distutils/apiref.rst:478
#, fuzzy
msgid ""
"Define a preprocessor macro for all compilations driven by this compiler "
"object. The optional parameter *value* should be a string; if it is not "
"supplied, then the macro will be defined without an explicit value and the "
"exact outcome depends on the compiler used."
msgstr ""
"為此編譯器物件驅動的所有編譯定義預處理器巨集。可選參數 *value* 應該是一個字"
"串；如果未提供，則巨集將在沒有顯式值的情況下定義，具體結果取決於所使用的編譯"
"器。"

#: ../../distutils/apiref.rst:488
#, fuzzy
msgid ""
"Undefine a preprocessor macro for all compilations driven by this compiler "
"object.  If the same macro is defined by :meth:`define_macro` and undefined "
"by :meth:`undefine_macro` the last call takes precedence (including multiple "
"redefinitions or undefinitions).  If the macro is redefined/undefined on a "
"per-compilation basis (ie. in the call to :meth:`compile`), then that takes "
"precedence."
msgstr ""
"取消為此編譯器物件驅動的所有編譯定義預處理器巨集。如果同一個巨集由 :meth:"
"`define_macro` 定義並且由 :meth:`undefine_macro` 未定義，則最後一次呼叫優先"
"（包括多次重新定義或取消定義）。如果在每次編譯的基礎上重新定義/取消定義巨集"
"（即在對 :meth:`compile` 的呼叫中），那麼它優先。"

#: ../../distutils/apiref.rst:498
#, fuzzy
msgid ""
"Add *object* to the list of object files (or analogues, such as explicitly "
"named library files or the output of \"resource compilers\") to be included "
"in every link driven by this compiler object."
msgstr ""
"將 *object* 新增到目標文件列表（或類似物，例如明確命名的庫文件或“資源編譯"
"器”的輸出），以包含在此編譯器物件驅動的每個鏈接中。"

#: ../../distutils/apiref.rst:505
#, fuzzy
msgid ""
"Set the list of object files (or analogues) to be included in every link to "
"*objects*.  This does not affect any standard object files that the linker "
"may include by default (such as system libraries)."
msgstr ""
"將目標文件（或類似物）列表設定為包含在指向 *objects* 的每個鏈接中。這不會影響"
"鏈接器預設包含的任何標準目標文件（例如係統庫）。"

#: ../../distutils/apiref.rst:509
#, fuzzy
msgid ""
"The following methods implement methods for autodetection of compiler  "
"options, providing some functionality similar to GNU :program:`autoconf`."
msgstr ""
"以下方法實作了自動檢測編譯器選項的方法，提供了一些類似於 GNU :program:"
"`autoconf` 的功能。"

#: ../../distutils/apiref.rst:515
#, fuzzy
msgid ""
"Detect the language of a given file, or list of files. Uses the  instance "
"attributes :attr:`language_map` (a dictionary), and  :attr:`language_order` "
"(a list) to do the job."
msgstr ""
"檢測給定文件或文件列表的語言。使用實例屬性 :attr:`language_map`（字典）和 :"
"attr:`language_order`（列表）來完成這項工作。"

#: ../../distutils/apiref.rst:522
#, fuzzy
msgid ""
"Search the specified list of directories for a static or shared library file "
"*lib* and return the full path to that file.  If *debug* is true, look for a "
"debugging version (if that makes sense on the current platform).  Return "
"``None`` if *lib* wasn't found in any of the specified directories."
msgstr ""
"在指定的目錄列表中搜索靜態或共享庫文件 *lib* 並回傳該文件的完整路徑。如果 "
"*debug* 為真，則查找除錯版本（如果這在當前平台上有意義）。如果在任何指定目錄"
"中都找不到 *lib*，則回傳 ``None``。"

#: ../../distutils/apiref.rst:530
#, fuzzy
msgid ""
"Return a boolean indicating whether *funcname* is supported on the current "
"platform.  The optional arguments can be used to augment the compilation "
"environment by providing additional include files and paths and libraries "
"and paths."
msgstr ""
"回傳一個布爾值，指示當前平台是否支援 *funcname*。可選參數可用於通過提供額外的"
"包含文件和路徑以及庫和路徑來擴充編譯環境。"

#: ../../distutils/apiref.rst:538
#, fuzzy
msgid ""
"Return the compiler option to add *dir* to the list of directories searched "
"for libraries."
msgstr "回傳編譯器選項以將 *dir* 新增到搜索庫的目錄列表中。"

#: ../../distutils/apiref.rst:544
#, fuzzy
msgid ""
"Return the compiler option to add *lib* to the list of libraries linked into "
"the shared library or executable."
msgstr "回傳編譯器選項以將 *lib* 新增到鏈接到共享庫或可執行文件的庫列表中。"

#: ../../distutils/apiref.rst:550
#, fuzzy
msgid ""
"Return the compiler option to add *dir* to the list of directories searched "
"for runtime libraries."
msgstr "回傳編譯器選項以將 *dir* 新增到搜索運行時庫的目錄列表中。"

#: ../../distutils/apiref.rst:556
#, fuzzy
msgid ""
"Define the executables (and options for them) that will be run to perform "
"the various stages of compilation.  The exact set of executables that may be "
"specified here depends on the compiler class (via the 'executables' class "
"attribute), but most will have:"
msgstr ""
"定義將運行以執行編譯的各個階段的可執行文件（及其選項）。可在此處指定的確切可"
"執行文件集取決於編譯器類（通過“可執行文件”類屬性），但大多數將具有："

#: ../../distutils/apiref.rst:562
#, fuzzy
msgid "attribute"
msgstr "屬性"

#: ../../distutils/apiref.rst:564
#, fuzzy
msgid "*compiler*"
msgstr "*編譯器*"

#: ../../distutils/apiref.rst:564
#, fuzzy
msgid "the C/C++ compiler"
msgstr "C/C++ 編譯器"

#: ../../distutils/apiref.rst:566
msgid "*linker_so*"
msgstr "*linker_so*"

#: ../../distutils/apiref.rst:566
#, fuzzy
msgid "linker used to create shared objects and libraries"
msgstr "用於建立共享物件和庫的鏈接器"

#: ../../distutils/apiref.rst:569
msgid "*linker_exe*"
msgstr "*linker_exe*"

#: ../../distutils/apiref.rst:569
#, fuzzy
msgid "linker used to create binary executables"
msgstr "用於建立二進位可執行文件的鏈接器"

#: ../../distutils/apiref.rst:571
msgid "*archiver*"
msgstr "*archiver*"

#: ../../distutils/apiref.rst:571
#, fuzzy
msgid "static library creator"
msgstr "靜態庫建立者"

#: ../../distutils/apiref.rst:574
#, fuzzy
msgid ""
"On platforms with a command-line (Unix, DOS/Windows), each of these is a "
"string that will be split into executable name and (optional) list of "
"arguments. (Splitting the string is done similarly to how Unix shells "
"operate: words are delimited by spaces, but quotes and backslashes can "
"override this.  See :func:`distutils.util.split_quoted`.)"
msgstr ""
"在具有命令列的平台（Unix、DOS/Windows）上，每一個都是一個字串，將被拆分為可執"
"行文件名稱和（可選）參數列表。 （拆分字串的方式類似於 Unix shell 的操作方式："
"單詞由空格分隔，但引號和反斜杠可以覆蓋它。請參閱 :func:`distutils.util."
"split_quoted`。）"

#: ../../distutils/apiref.rst:580
#, fuzzy
msgid "The following methods invoke stages in the build process."
msgstr "以下方法呼叫構建過程中的階段。"

#: ../../distutils/apiref.rst:585
#, fuzzy
msgid ""
"Compile one or more source files. Generates object files (e.g.  transforms "
"a :file:`.c` file to a :file:`.o` file.)"
msgstr ""
"編譯一個或多個源文件。生成目標文件（例如，將 :file:`.c` 文件轉換為 :file:`."
"o` 文件。）"

#: ../../distutils/apiref.rst:588
#, fuzzy
msgid ""
"*sources* must be a list of filenames, most likely C/C++ files, but in "
"reality anything that can be handled by a particular compiler and compiler "
"class (eg. :class:`MSVCCompiler` can handle resource files in *sources*).  "
"Return a list of object filenames, one per source filename in *sources*.  "
"Depending on the implementation, not all source files will necessarily be "
"compiled, but all corresponding object filenames will be returned."
msgstr ""
"*sources* 必須是文件名列表，很可能是 C/C++ 文件，但實際上任何可以由特定編譯器"
"和編譯器類處理的文件（例如 :class:`MSVCCompiler` 可以處理 *sources* 中的資源"
"文件） .回傳目標文件名列表，*sources* 中每個源文件名一個。根據實作的不同，不"
"一定會編譯所有源文件，但會回傳所有相應的目標文件名。"

#: ../../distutils/apiref.rst:595
#, fuzzy
msgid ""
"If *output_dir* is given, object files will be put under it, while retaining "
"their original path component.  That is, :file:`foo/bar.c` normally compiles "
"to :file:`foo/bar.o` (for a Unix implementation); if *output_dir* is "
"*build*, then it would compile to :file:`build/foo/bar.o`."
msgstr ""
"如果給出 *output_dir*，目標文件將被放在它下面，同時保留它們的原始路徑組件。也"
"就是說，:file:`foo/bar.c` 通常編譯為 :file:`foo/bar.o`（對於 Unix 實作）；如"
"果 *output_dir* 是 *build*，那麼它將編譯為 :file:`build/foo/bar.o`。"

#: ../../distutils/apiref.rst:600
#, fuzzy
msgid ""
"*macros*, if given, must be a list of macro definitions.  A macro definition "
"is either a ``(name, value)`` 2-tuple or a ``(name,)`` 1-tuple. The former "
"defines a macro; if the value is ``None``, the macro is defined without an "
"explicit value.  The 1-tuple case undefines a macro.  Later definitions/"
"redefinitions/undefinitions take precedence."
msgstr ""
"*macros*，如果給出，必須是巨集定義列表。巨集定義是一個 ``(name, value)`` 二元"
"組或一個 ``(name,)`` 1 元組。前者定義了一個巨集；如果值為 ``None``，則巨集定"
"義時沒有明確的值。 1 元組情況取消定義巨集。以後的定義/重新定義/取消定義優先。"

#: ../../distutils/apiref.rst:606
#, fuzzy
msgid ""
"*include_dirs*, if given, must be a list of strings, the directories to add "
"to the default include file search path for this compilation only."
msgstr ""
"*include_dirs*，如果給定，必須是字串列表，新增到預設包含文件搜索路徑的目錄僅"
"用於此編譯。"

#: ../../distutils/apiref.rst:609
#, fuzzy
msgid ""
"*debug* is a boolean; if true, the compiler will be instructed to output "
"debug symbols in (or alongside) the object file(s)."
msgstr ""
"*debug* 是一個布爾值；如果為真，將指示編譯器在目標文件中（或旁邊）輸出除錯符"
"號。"

#: ../../distutils/apiref.rst:612
#, fuzzy
msgid ""
"*extra_preargs* and *extra_postargs* are implementation-dependent. On "
"platforms that have the notion of a command-line (e.g. Unix, DOS/Windows), "
"they are most likely lists of strings: extra command-line arguments to "
"prepend/append to the compiler command line.  On other platforms, consult "
"the implementation class documentation.  In any event, they are intended as "
"an escape hatch for those occasions when the abstract compiler framework "
"doesn't cut the mustard."
msgstr ""
"*extra_preargs* 和 *extra_postargs* 依賴於實作。在具有命令列概念的平台上（例"
"如 Unix、DOS/Windows），它們很可能是字串列表：附加到編譯器命令列的額外命令列"
"參數。在其他平台上，請查閱實作類文檔。無論如何，它們旨在作為抽象編譯器框架不"
"符合要求的情況下的逃生艙口。"

#: ../../distutils/apiref.rst:619
#, fuzzy
msgid ""
"*depends*, if given, is a list of filenames that all targets depend on.  If "
"a source file is older than any file in depends, then the source file will "
"be recompiled.  This supports dependency tracking, but only at a coarse "
"granularity."
msgstr ""
"*depends*，如果給出，是所有目標所依賴的文件名列表。如果源文件比 depends 中的"
"任何文件都舊，則源文件將被重新編譯。這支援依賴關係跟踪，但只是在粗粒度上。"

#: ../../distutils/apiref.rst:624
#, fuzzy
msgid "Raises :exc:`CompileError` on failure."
msgstr "引發 :exc:`CompileError` 失敗。"

#: ../../distutils/apiref.rst:629
#, fuzzy
msgid ""
"Link a bunch of stuff together to create a static library file. The \"bunch "
"of stuff\" consists of the list of object files supplied as *objects*, the "
"extra object files supplied to :meth:`add_link_object` and/or :meth:"
"`set_link_objects`, the libraries supplied to :meth:`add_library` and/or :"
"meth:`set_libraries`, and the libraries supplied as *libraries* (if any)."
msgstr ""
"將一堆東西鏈接在一起以建立靜態庫文件。 “一堆東西”包括作為 *objects* 提供的目"
"標文件列表、提供給 add_link_object 和/或 set_link_objects 的額外目標文件、提"
"供給 add_library 的庫` 和/或 :meth:`set_libraries`，以及作為 *libraries*（如"
"果有）提供的庫。"

#: ../../distutils/apiref.rst:635
#, fuzzy
msgid ""
"*output_libname* should be a library name, not a filename; the filename will "
"be inferred from the library name.  *output_dir* is the directory where the "
"library file will be put."
msgstr ""
"*output_libname* 應該是庫名，而不是文件名；文件名將從庫名中推斷出來。 "
"*output_dir* 是放置庫文件的目錄。"

#: ../../distutils/apiref.rst:641
#, fuzzy
msgid ""
"*debug* is a boolean; if true, debugging information will be included in the "
"library (note that on most platforms, it is the compile step where this "
"matters: the *debug* flag is included here just for consistency)."
msgstr ""
"*debug* 是一個布爾值；如果為 true，則除錯資訊將包含在庫中（請注意，在大多數平"
"台上，重要的是編譯步驟：此處包含 *debug* 旗標只是為了保持一致性）。"

#: ../../distutils/apiref.rst:645 ../../distutils/apiref.rst:687
#, fuzzy
msgid ""
"*target_lang* is the target language for which the given objects are being "
"compiled. This allows specific linkage time treatment of certain languages."
msgstr ""
"*target_lang* 是編譯給定物件的目標語言。這允許對某些語言進行特定的鏈接時間處"
"理。"

#: ../../distutils/apiref.rst:648
#, fuzzy
msgid "Raises :exc:`LibError` on failure."
msgstr "引發 :exc:`LibError` 失敗。"

#: ../../distutils/apiref.rst:653
#, fuzzy
msgid ""
"Link a bunch of stuff together to create an executable or shared library "
"file."
msgstr "將一堆東西鏈接在一起以建立可執行文件或共享庫文件。"

#: ../../distutils/apiref.rst:655
#, fuzzy
msgid ""
"The \"bunch of stuff\" consists of the list of object files supplied as "
"*objects*. *output_filename* should be a filename.  If *output_dir* is "
"supplied, *output_filename* is relative to it (i.e. *output_filename* can "
"provide directory components if needed)."
msgstr ""
"“一堆東西”由作為 *objects* 提供的目標文件列表組成。 *output_filename* 應該是"
"一個文件名。如果提供了 *output_dir*，則 *output_filename* 是相對於它的（即 "
"*output_filename* 可以根據需要提供目錄組件）。"

#: ../../distutils/apiref.rst:660
#, fuzzy
msgid ""
"*libraries* is a list of libraries to link against.  These are library "
"names, not filenames, since they're translated into filenames in a platform-"
"specific way (eg. *foo* becomes :file:`libfoo.a` on Unix and :file:`foo.lib` "
"on DOS/Windows).  However, they can include a directory component, which "
"means the linker will look in that specific directory rather than searching "
"all the normal locations."
msgstr ""
"*libraries* 是要鏈接的庫列表。這些是庫名稱，而不是文件名，因為它們以特定於平"
"台的方式轉換為文件名（例如，*foo* 在 Unix 上變為 :file:`libfoo.a`，在 DOS/ 上"
"變為 :file:`foo.lib`視窗）。但是，它們可以包含一個目錄組件，這意味著鏈接器將"
"在該特定目錄中查找而不是搜索所有正常位置。"

#: ../../distutils/apiref.rst:667
#, fuzzy
msgid ""
"*library_dirs*, if supplied, should be a list of directories to search for "
"libraries that were specified as bare library names (ie. no directory "
"component).  These are on top of the system default and those supplied to :"
"meth:`add_library_dir` and/or :meth:`set_library_dirs`.  "
"*runtime_library_dirs* is a list of directories that will be embedded into "
"the shared library and used to search for other shared libraries that "
"\\*it\\* depends on at run-time.  (This may only be relevant on Unix.)"
msgstr ""
"*library_dirs*，如果提供的話，應該是一個目錄列表，用於搜索指定為裸庫名稱（即"
"沒有目錄組件）的庫。這些是在系統預設值和提供給 :meth:`add_library_dir` 和/"
"或 :meth:`set_library_dirs` 之上的。 *runtime_library_dirs* 是將嵌入到共享庫"
"中的目錄列表，用於搜索\\*它\\*在運行時依賴的其他共享庫。 （這可能只與 Unix 相"
"關。）"

#: ../../distutils/apiref.rst:675
#, fuzzy
msgid ""
"*export_symbols* is a list of symbols that the shared library will export. "
"(This appears to be relevant only on Windows.)"
msgstr ""
"*export_symbols* 是共享庫將導出的符號列表。 （這似乎只與 Windows 相關。）"

#: ../../distutils/apiref.rst:678
#, fuzzy
msgid ""
"*debug* is as for :meth:`compile` and :meth:`create_static_lib`,  with the "
"slight distinction that it actually matters on most platforms (as opposed "
"to :meth:`create_static_lib`, which includes a *debug* flag mostly for "
"form's sake)."
msgstr ""
"*debug* 與 :meth:`compile` 和 :meth:`create_static_lib` 有細微差別，它在大多"
"數平台上實際上很重要（與 :meth:`create_static_lib` 相對，後者主要包含 "
"*debug* 旗標為了形式）。"

#: ../../distutils/apiref.rst:683
#, fuzzy
msgid ""
"*extra_preargs* and *extra_postargs* are as for :meth:`compile`  (except of "
"course that they supply command-line arguments for the particular linker "
"being used)."
msgstr ""
"*extra_preargs* 和 *extra_postargs* 與 :meth:`compile` 相同（當然除了它們為正"
"在使用的特定鏈接器提供命令列參數）。"

#: ../../distutils/apiref.rst:690
#, fuzzy
msgid "Raises :exc:`LinkError` on failure."
msgstr "引發 :exc:`LinkError` 失敗。"

#: ../../distutils/apiref.rst:695
#, fuzzy
msgid ""
"Link an executable.  *output_progname* is the name of the file executable, "
"while *objects* are a list of object filenames to link in. Other arguments  "
"are as for the :meth:`link` method."
msgstr ""
"鏈接一個可執行文件。 *output_progname* 是可執行文件的名稱，而 *objects* 是要"
"鏈接的目標文件名列表。其他參數與 :meth:`link` 方法相同。"

#: ../../distutils/apiref.rst:702
#, fuzzy
msgid ""
"Link a shared library. *output_libname* is the name of the output  library, "
"while *objects* is a list of object filenames to link in.  Other arguments "
"are as for the :meth:`link` method."
msgstr ""
"鏈接共享庫。 *output_libname* 是輸出庫的名稱，而 *objects* 是要鏈接的目標文件"
"名列表。其他參數與 :meth:`link` 方法相同。"

#: ../../distutils/apiref.rst:709
#, fuzzy
msgid ""
"Link a shared object. *output_filename* is the name of the shared object "
"that will be created, while *objects* is a list of object filenames  to link "
"in. Other arguments are as for the :meth:`link` method."
msgstr ""
"鏈接共享物件。 *output_filename* 是將要建立的共享物件的名稱，而 *objects* 是"
"要鏈接的物件文件名列表。其他參數與 :meth:`link` 方法相同。"

#: ../../distutils/apiref.rst:716
#, fuzzy
msgid ""
"Preprocess a single C/C++ source file, named in *source*. Output will be "
"written to file named *output_file*, or *stdout* if *output_file* not "
"supplied. *macros* is a list of macro definitions as for :meth:`compile`, "
"which will augment the macros set with :meth:`define_macro` and :meth:"
"`undefine_macro`. *include_dirs* is a list of directory names that will be "
"added to the  default list, in the same way as :meth:`add_include_dir`."
msgstr ""
"預處理單個 C/C++ 源文件，在 *source* 中命名。輸出將寫入名為 *output_file* 的"
"文件，或者如果未提供 *output_file* 則寫入 *stdout*。 *macros* 是關於 :meth:"
"`compile` 的巨集定義列表，它將擴充使用 :meth:`define_macro` 和 :meth:"
"`undefine_macro` 設定的巨集。 *include_dirs* 是將新增到預設列表的目錄名稱列"
"表，與 add_include_dir 的方式相同。"

#: ../../distutils/apiref.rst:723
#, fuzzy
msgid "Raises :exc:`PreprocessError` on failure."
msgstr "引發 :exc:`PreprocessError` 失敗。"

#: ../../distutils/apiref.rst:725
#, fuzzy
msgid ""
"The following utility methods are defined by the :class:`CCompiler` class, "
"for use by the various concrete subclasses."
msgstr "以下實用方法由 CCompiler 類定義，供各種具體子類別使用。"

#: ../../distutils/apiref.rst:731
#, fuzzy
msgid ""
"Returns the filename of the executable for the given *basename*.  Typically "
"for non-Windows platforms this is the same as the basename,  while Windows "
"will get a :file:`.exe` added."
msgstr ""
"回傳給定 *basename* 的可執行文件的文件名。通常對於非 Windows 平台，這與基本名"
"稱相同，而 Windows 將新增一個 :file:`.exe`。"

#: ../../distutils/apiref.rst:738
#, fuzzy
msgid ""
"Returns the filename for the given library name on the current platform. On "
"Unix a library with *lib_type* of ``'static'`` will typically  be of the "
"form :file:`liblibname.a`, while a *lib_type* of ``'dynamic'``  will be of "
"the form :file:`liblibname.so`."
msgstr ""
"回傳當前平台上給定庫名稱的文件名。在 Unix 上，*lib_type* 為 ``'static'`` 的庫"
"通常採用以下形式 :file:`liblibname.a`，而 *lib_type* 為 ``'dynamic'`` 的形式"
"為 :file:`liblibname.so`。"

#: ../../distutils/apiref.rst:746
#, fuzzy
msgid ""
"Returns the name of the object files for the given source files. "
"*source_filenames* should be a list of filenames."
msgstr "回傳給定源文件的目標文件的名稱。 *source_filenames* 應該是文件名列表。"

#: ../../distutils/apiref.rst:752
#, fuzzy
msgid ""
"Returns the name of a shared object file for the given file name *basename*."
msgstr "回傳給定文件名 *basename* 的共享目標文件的名稱。"

#: ../../distutils/apiref.rst:757
#, fuzzy
msgid ""
"Invokes :func:`distutils.util.execute`. This method invokes a  Python "
"function *func* with the given arguments *args*, after  logging and taking "
"into account the *dry_run* flag."
msgstr ""
"呼叫 :func:`distutils.util.execute`。此方法在記錄並考慮 *dry_run* 旗標後，使"
"用給定參數 *args* 呼叫 Python 函式 *func*。"

#: ../../distutils/apiref.rst:764
#, fuzzy
msgid ""
"Invokes :func:`distutils.util.spawn`. This invokes an external  process to "
"run the given command."
msgstr ""
"呼叫 :func:`distutils.util.spawn`。這會呼叫一個外部行程來運行給定的命令。"

#: ../../distutils/apiref.rst:770
#, fuzzy
msgid ""
"Invokes :func:`distutils.dir_util.mkpath`. This creates a directory  and any "
"missing ancestor directories."
msgstr ""
"呼叫 :func:`distutils.dir_util.mkpath`。這將建立一個目錄和任何缺少的祖先目"
"錄。"

#: ../../distutils/apiref.rst:776
#, fuzzy
msgid "Invokes :meth:`distutils.file_util.move_file`. Renames *src* to  *dst*."
msgstr "呼叫 :meth:`distutils.file_util.move_file`。將 *src* 重命名為 *dst*。"

#: ../../distutils/apiref.rst:781
#, fuzzy
msgid "Write a message using :func:`distutils.log.debug`."
msgstr "使用 distutils.log.debug 編寫消息。"

#: ../../distutils/apiref.rst:786
#, fuzzy
msgid "Write a warning message *msg* to standard error."
msgstr "將警告消息 *msg* 寫入標準錯誤。"

#: ../../distutils/apiref.rst:791
#, fuzzy
msgid ""
"If the *debug* flag is set on this :class:`CCompiler` instance, print  *msg* "
"to standard output, otherwise do nothing."
msgstr ""
"如果在這個 CCompiler 實例上設定了 *debug* 旗標，則將 *msg* 印出到標準輸出，否"
"則什麼都不做。"

#: ../../distutils/apiref.rst:803
#, fuzzy
msgid ":mod:`distutils.unixccompiler` --- Unix C Compiler"
msgstr ":mod:`distutils.unixccompiler` --- Unix C 編譯器"

#: ../../distutils/apiref.rst:809
#, fuzzy
msgid ""
"This module provides the :class:`UnixCCompiler` class, a subclass of :class:"
"`CCompiler` that handles the typical Unix-style command-line  C compiler:"
msgstr ""
"此模組提供 :class:`UnixCCompiler` 類，它是 :class:`CCompiler` 的子類別，用於"
"處理典型的 Unix 風格的命令列 C 編譯器："

#: ../../distutils/apiref.rst:812
#, fuzzy
msgid "macros defined with :option:`!-Dname[=value]`"
msgstr "使用 :option:`!-Dname[=value]` 定義的巨集"

#: ../../distutils/apiref.rst:814
#, fuzzy
msgid "macros undefined with :option:`!-Uname`"
msgstr "使用 :option:`!-Uname` 未定義的巨集"

#: ../../distutils/apiref.rst:816
#, fuzzy
msgid "include search directories specified with :option:`!-Idir`"
msgstr "包括使用 :option:`!-Idir` 指定的搜索目錄"

#: ../../distutils/apiref.rst:818
#, fuzzy
msgid "libraries specified with :option:`!-llib`"
msgstr "使用 :option:`!-llib` 指定的庫"

#: ../../distutils/apiref.rst:820
#, fuzzy
msgid "library search directories specified with :option:`!-Ldir`"
msgstr "使用 :option:`!-Ldir` 指定的庫搜索目錄"

#: ../../distutils/apiref.rst:822
#, fuzzy
msgid ""
"compile handled by :program:`cc` (or similar) executable with :option:`!-c` "
"option: compiles :file:`.c` to :file:`.o`"
msgstr ""
"由帶有 :option:`!-c` 選項的 :program:`cc`（或類似的）可執行文件處理的編譯："
"將 :file:`.c` 編譯為 :file:`.o`"

#: ../../distutils/apiref.rst:825
#, fuzzy
msgid ""
"link static library handled by :program:`ar` command (possibly with :program:"
"`ranlib`)"
msgstr "鏈接由 :program:`ar` 命令處理的靜態庫（可能使用 :program:`ranlib`）"

#: ../../distutils/apiref.rst:828
#, fuzzy
msgid "link shared library handled by :program:`cc` :option:`!-shared`"
msgstr "鏈接由 :program:`cc` :option:`!-shared` 處理的共享庫"

#: ../../distutils/apiref.rst:832
#, fuzzy
msgid ":mod:`distutils.msvccompiler` --- Microsoft Compiler"
msgstr ":mod:`distutils.msvccompiler` --- 微軟編譯器"

#: ../../distutils/apiref.rst:839
#, fuzzy
msgid ""
"This module provides :class:`MSVCCompiler`, an implementation of the "
"abstract :class:`CCompiler` class for Microsoft Visual Studio. Typically, "
"extension modules need to be compiled with the same compiler that was used "
"to compile Python. For Python 2.3 and earlier, the compiler was Visual "
"Studio 6. For Python 2.4 and 2.5, the compiler is Visual Studio .NET 2003."
msgstr ""
"此模組提供 :class:`MSVCCompiler`，它是 Microsoft Visual Studio 的抽象 :class:"
"`CCompiler` 類的實作。通常，擴充模組需要使用用於編譯 Python 的相同編譯器進行"
"編譯。對於 Python 2.3 及更早版本，編譯器是 Visual Studio 6。對於 Python 2.4 "
"和 2.5，編譯器是 Visual Studio .NET 2003。"

#: ../../distutils/apiref.rst:845
#, fuzzy
msgid ""
":class:`MSVCCompiler` will normally choose the right compiler, linker etc. "
"on its own. To override this choice, the environment variables "
"*DISTUTILS_USE_SDK* and *MSSdk* must be both set. *MSSdk* indicates that the "
"current environment has been setup by the SDK's ``SetEnv.Cmd`` script, or "
"that the environment variables had been registered when the SDK was "
"installed; *DISTUTILS_USE_SDK* indicates that the distutils user has made an "
"explicit choice to override the compiler selection by :class:`MSVCCompiler`."
msgstr ""
":class:`MSVCCompiler` 通常會自行選擇正確的編譯器、鏈接器等。要覆蓋此選擇，必"
"須同時設定環境變數 *DISTUTILS_USE_SDK* 和 *MSSdk*。 *MSSdk*表示當前環境已經通"
"過SDK的``SetEnv.Cmd``腳本設定好，或者說安裝SDK的時候已經註冊了環境變數； "
"*DISTUTILS_USE_SDK* 表示 distutils 使用者已明確選擇通過 :class:"
"`MSVCCompiler` 覆蓋編譯器選擇。"

#: ../../distutils/apiref.rst:855
#, fuzzy
msgid ":mod:`distutils.bcppcompiler` --- Borland Compiler"
msgstr ":mod:`distutils.bcppcompiler` --- Borland 編譯器"

#: ../../distutils/apiref.rst:860
#, fuzzy
msgid ""
"This module provides :class:`BorlandCCompiler`, a subclass of the abstract :"
"class:`CCompiler` class for the Borland C++ compiler."
msgstr ""
"該模組提供 BorlandCCompiler，它是 Borland C++ 編譯器抽像類 CCompiler 的子類"
"別。"

#: ../../distutils/apiref.rst:865
#, fuzzy
msgid ":mod:`distutils.cygwincompiler` --- Cygwin Compiler"
msgstr ":mod:`distutils.cygwincompiler` --- Cygwin 編譯器"

#: ../../distutils/apiref.rst:870
#, fuzzy
msgid ""
"This module provides the :class:`CygwinCCompiler` class, a subclass of :"
"class:`UnixCCompiler` that handles the Cygwin port of the GNU C compiler to "
"Windows.  It also contains the Mingw32CCompiler class which handles the "
"mingw32 port of GCC (same as cygwin in no-cygwin mode)."
msgstr ""
"此模組提供 :class:`CygwinCCompiler` 類，它是 :class:`UnixCCompiler` 的子類"
"別，用於處理 GNU C 編譯器到 Windows 的 Cygwin 端口。它還包含處理 GCC 的 "
"mingw32 端口的 Mingw32CCompiler 類（與非 cygwin 模式下的 cygwin 相同）。"

#: ../../distutils/apiref.rst:877
#, fuzzy
msgid ":mod:`distutils.archive_util` ---  Archiving utilities"
msgstr ":mod:`distutils.archive_util` --- 歸檔工具"

#: ../../distutils/apiref.rst:883
#, fuzzy
msgid ""
"This module provides a few functions for creating archive files, such as "
"tarballs or zipfiles."
msgstr "該模組提供了一些用於建立存檔文件的函式，例如 tarball 或 zipfiles。"

#: ../../distutils/apiref.rst:889
#, fuzzy
msgid ""
"Create an archive file (eg. ``zip`` or ``tar``).  *base_name*  is the name "
"of the file to create, minus any format-specific extension;  *format* is the "
"archive format: one of ``zip``, ``tar``, ``gztar``, ``bztar``, ``xztar``, or "
"``ztar``. *root_dir* is a directory that will be the root directory of the "
"archive; ie. we typically ``chdir`` into *root_dir* before  creating the "
"archive.  *base_dir* is the directory where we start  archiving from; ie. "
"*base_dir* will be the common prefix of all files and directories in the "
"archive.  *root_dir* and *base_dir* both default to the current directory. "
"Returns the name of the archive file."
msgstr ""
"建立一個歸檔文件（例如 ``zip`` 或 ``tar``）。 *base_name* 是要建立的文件的名"
"稱，減去任何格式特定的擴充名； *format* 是存檔格式：``zip``、``tar``、"
"``gztar``、``bztar``、``xztar`` 或 ``ztar`` 之一。 *root_dir* 是將成為歸檔文"
"件根目錄的目錄； IE。我們通常在建立存檔之前將 ``chdir`` 放入 *root_dir*。 "
"*base_dir* 是我們開始歸檔的目錄； IE。 *base_dir* 將是存檔中所有文件和目錄的"
"公開前綴。 *root_dir* 和 *base_dir* 都預設為當前目錄。回傳存檔文件的名稱。"

#: ../../distutils/apiref.rst:899
#, fuzzy
msgid "Added support for the ``xztar`` format."
msgstr "新增了對 ``xztar`` 格式的支援。"

#: ../../distutils/apiref.rst:905
#, fuzzy
msgid ""
"'Create an (optional compressed) archive as a tar file from all files in and "
"under *base_dir*. *compress* must be ``'gzip'`` (the default), ``'bzip2'``, "
"``'xz'``, ``'compress'``, or ``None``.  For the ``'compress'`` method the "
"compression utility named by :program:`compress` must be on the default "
"program search path, so this is probably Unix-specific.  The output tar file "
"will be named :file:`base_dir.tar`, possibly plus the appropriate "
"compression extension (``.gz``, ``.bz2``, ``.xz`` or ``.Z``).  Return the "
"output filename."
msgstr ""
"'從 *base_dir* 中和下的所有文件建立一個（可選的壓縮）存檔作為 tar 文件。 "
"*compress* 必須是``'gzip'``（預設值）、``'bzip2'``、``'xz'``、``'compress'`` "
"或``None``。對於 ``'compress'`` 方法，由 :program:`compress` 命名的壓縮實用程"
"式必須位於預設程式搜索路徑上，因此這可能是特定於 Unix 的。輸出的 tar 文件將被"
"命名為 :file:`base_dir.tar`，可能加上適當的壓縮擴充名（``.gz``、``.bz2``、``."
"xz`` 或``.Z`` ).回傳輸出文件名。"

#: ../../distutils/apiref.rst:914
#, fuzzy
msgid "Added support for the ``xz`` compression."
msgstr "新增了對 ``xz`` 壓縮的支援。"

#: ../../distutils/apiref.rst:920
#, fuzzy
msgid ""
"Create a zip file from all files in and under *base_dir*.  The output zip "
"file will be named *base_name* + :file:`.zip`.  Uses either the  :mod:"
"`zipfile` Python module (if available) or the InfoZIP :file:`zip`  utility "
"(if installed and found on the default search path).  If neither  tool is "
"available, raises :exc:`DistutilsExecError`.   Returns the name of the "
"output zip file."
msgstr ""
"從 *base_dir* 中和下的所有文件建立一個 zip 文件。輸出的 zip 文件將被命名為 "
"*base_name* + :file:`.zip`。使用 :mod:`zipfile` Python 模組（如果可用）或 "
"InfoZIP :file:`zip` 實用程式（如果安裝並在預設搜索路徑中找到）。如果這兩個工"
"具都不可用，則引發 :exec:`DistutilsExecError`。回傳輸出 zip 文件的名稱。"

#: ../../distutils/apiref.rst:928
#, fuzzy
msgid ":mod:`distutils.dep_util` --- Dependency checking"
msgstr ":mod:`distutils.dep_util` ---依賴檢查"

#: ../../distutils/apiref.rst:934
#, fuzzy
msgid ""
"This module provides functions for performing simple, timestamp-based "
"dependency of files and groups of files; also, functions based entirely  on "
"such timestamp dependency analysis."
msgstr ""
"該模組提供了用於執行簡單的、基於時間戳的文件和文件組依賴性的函式；此外，功能"
"完全基於此類時間戳依賴性分析。"

#: ../../distutils/apiref.rst:941
#, fuzzy
msgid ""
"Return true if *source* exists and is more recently modified than *target*, "
"or if *source* exists and *target* doesn't. Return false if both exist and "
"*target* is the same age or newer  than *source*. Raise :exc:"
"`DistutilsFileError` if *source* does not exist."
msgstr ""
"如果 *source* 存在並且比 *target* 最近修改過，或者如果 *source* 存在而 "
"*target* 不存在，則回傳 true。如果兩者都存在且 *target* 與 *source* 年齡相同"
"或更新，則回傳 false。如果 *source* 不存在，則引發 :exc:"
"`DistutilsFileError`。"

#: ../../distutils/apiref.rst:949
#, fuzzy
msgid ""
"Walk two filename lists in parallel, testing if each source is newer than "
"its corresponding target.  Return a pair of lists (*sources*, *targets*) "
"where source is newer than target, according to the semantics of :func:"
"`newer`."
msgstr ""
"並行遍歷兩個文件名列表，測試每個源是否比其對應的目標更新。根據 :func:`newer` "
"的語義，回傳一對列表 (*sources*, *targets*)，其中 source 比 target 更新。"

#: ../../distutils/apiref.rst:958
#, fuzzy
msgid ""
"Return true if *target* is out-of-date with respect to any file listed in "
"*sources*.  In other words, if *target* exists and is newer than every file "
"in *sources*, return false; otherwise return true. *missing* controls what "
"we do when a source file is missing; the default (``'error'``) is to blow up "
"with an :exc:`OSError` from  inside :func:`os.stat`; if it is ``'ignore'``, "
"we silently drop any missing source files; if it is ``'newer'``, any missing "
"source files make us assume that *target* is out-of-date (this is handy in "
"\"dry-run\" mode: it'll make you pretend to carry out commands that wouldn't "
"work because inputs are missing, but that doesn't matter because you're not "
"actually going to run the commands)."
msgstr ""
"如果 *target* 對於 *sources* 中列出的任何文件都已過期，則回傳 true。換句話"
"說，如果 *target* 存在並且比 *sources* 中的每個文件都新，則回傳 false；否則回"
"傳真。 *missing* 控制我們在源文件丟失時做什麼；預設（``'error'``）是從 :func:"
"`os.stat` 中用 :exc:`OSError` 炸毀；如果它是 ``'ignore'``，我們會靜靜地刪除任"
"何丟失的源文件；如果它是 ``'newer'``，任何丟失的源文件都會讓我們假設 "
"*target* 已經過時（這在“空運行”模式下很方便：它會讓你假裝執行命令那是行不通"
"的，因為缺少輸入，但這無關緊要，因為您實際上並不打算運行命令）。"

#: ../../distutils/apiref.rst:971
#, fuzzy
msgid ":mod:`distutils.dir_util` --- Directory tree operations"
msgstr ":mod:`distutils.dir_util` --- 目錄樹操作"

#: ../../distutils/apiref.rst:977
#, fuzzy
msgid ""
"This module provides functions for operating on directories and trees of "
"directories."
msgstr "該模組提供了對目錄和目錄樹進行操作的功能。"

#: ../../distutils/apiref.rst:983
#, fuzzy
msgid ""
"Create a directory and any missing ancestor directories.  If the directory "
"already exists (or if *name* is the empty string, which means the current "
"directory, which of course exists), then do nothing.  Raise :exc:"
"`DistutilsFileError` if unable to create some directory along the way (eg. "
"some sub-path exists, but is a file rather than a directory).  If *verbose* "
"is true, print a one-line summary of each mkdir to stdout.  Return the list "
"of directories actually created."
msgstr ""
"建立目錄和任何缺少的祖先目錄。如果目錄已經存在（或者如果 *name* 是空字串，這"
"意味著當前目錄當然存在），則什麼也不做。如果無法在此過程中建立某些目錄（例"
"如，存在某些子路徑，但它是文件而不是目錄），則引發 :exc:"
"`DistutilsFileError`。如果 *verbose* 為真，則將每個 mkdir 的單行摘要印出到標"
"準輸出。回傳實際建立的目錄列表。"

#: ../../distutils/apiref.rst:994
#, fuzzy
msgid ""
"Create all the empty directories under *base_dir* needed to put *files* "
"there. *base_dir* is just the name of a directory which doesn't necessarily "
"exist yet; *files* is a list of filenames to be interpreted relative to "
"*base_dir*. *base_dir* + the directory portion of every file in *files* will "
"be created if it doesn't already exist.  *mode*, *verbose* and *dry_run* "
"flags  are as for :func:`mkpath`."
msgstr ""
"在 *base_dir* 下建立所有需要放置 *files* 的空目錄。 *base_dir* 只是一個不一定"
"存在的目錄的名稱； *files* 是要相對於 *base_dir* 解釋的文件名列表。 "
"*base_dir* + *files* 中每個文件的目錄部分如果尚不存在則將被建立。 *mode*、"
"*verbose* 和 *dry_run* 旗標與 :func:`mkpath` 相同。"

#: ../../distutils/apiref.rst:1004
#, fuzzy
msgid ""
"Copy an entire directory tree *src* to a new location *dst*.  Both *src* and "
"*dst* must be directory names.  If *src* is not a directory, raise :exc:"
"`DistutilsFileError`.  If *dst* does  not exist, it is created with :func:"
"`mkpath`.  The end result of the  copy is that every file in *src* is copied "
"to *dst*, and  directories under *src* are recursively copied to *dst*. "
"Return the list of files that were copied or might have been copied, using "
"their output name. The return value is unaffected by *update* or *dry_run*: "
"it is simply the list of all files under *src*, with the names changed to be "
"under *dst*."
msgstr ""
"將整個目錄樹 *src* 複製到新位置 *dst*。 *src* 和 *dst* 都必須是目錄名。如果 "
"*src* 不是目錄，引發 :exec:`DistutilsFileError`。如果 *dst* 不存在，則使用 :"
"func:`mkpath` 建立。複製的最終結果是*src*中的所有文件都被複製到*dst*中，*src*"
"下的目錄被遞迴複製到*dst*中。使用輸出名稱回傳已復製或可能已復制的文件列表。回"
"傳值不受*update* 或*dry_run* 的影響：它只是*src* 下所有文件的列表，名稱更改為"
"*dst* 下。"

#: ../../distutils/apiref.rst:1014
#, fuzzy
msgid ""
"*preserve_mode* and *preserve_times* are the same as for :func:`distutils."
"file_util.copy_file`; note that they only apply to regular files, not to "
"directories.  If *preserve_symlinks* is true, symlinks will be copied as "
"symlinks (on platforms that support them!); otherwise (the default), the "
"destination of the symlink will be copied.  *update* and *verbose* are the "
"same as for :func:`copy_file`."
msgstr ""
"*preserve_mode* 和 *preserve_times* 與 distutils.file_util.copy_file 相同；請"
"注意，它們僅適用於常規文件，不適用於目錄。如果 *preserve_symlinks* 為真，符號"
"鏈接將被複製為符號鏈接（在支援它們的平台上！）；否則（預設），將復制符號鏈接"
"的目標。 *update* 和 *verbose* 與 :func:`copy_file` 相同。"

#: ../../distutils/apiref.rst:1022
#, fuzzy
msgid ""
"Files in *src* that begin with :file:`.nfs` are skipped (more information on "
"these files is available in answer D2 of the `NFS FAQ page <http://nfs."
"sourceforge.net/#section_d>`_)."
msgstr ""
"*src* 中以 :file:`.nfs` 開頭的文件被跳過（有關這些文件的更多資訊，請參見`NFS "
"FAQ 頁面 <http://nfs.sourceforge.net/#section_d>`_ 的答案 D2 )."

#: ../../distutils/apiref.rst:1026
#, fuzzy
msgid "NFS files are ignored."
msgstr "NFS 文件將被忽略。"

#: ../../distutils/apiref.rst:1031
#, fuzzy
msgid ""
"Recursively remove *directory* and all files and directories underneath it. "
"Any errors are ignored (apart from being reported to ``sys.stdout`` if "
"*verbose* is true)."
msgstr ""
"遞迴刪除 *directory* 及其下的所有文件和目錄。任何錯誤都將被忽略（如果 "
"*verbose* 為真，則報告給 ``sys.stdout`` 除外）。"

#: ../../distutils/apiref.rst:1037
#, fuzzy
msgid ":mod:`distutils.file_util` --- Single file operations"
msgstr ":mod:`distutils.file_util` --- 單文件操作"

#: ../../distutils/apiref.rst:1043
#, fuzzy
msgid ""
"This module contains some utility functions for operating on individual "
"files."
msgstr "該模組包含一些用於對單個文件進行操作的實用函式。"

#: ../../distutils/apiref.rst:1048
#, fuzzy
msgid ""
"Copy file *src* to *dst*. If *dst* is a directory, then *src* is copied "
"there with the same name; otherwise, it must be a filename. (If the file "
"exists, it will be ruthlessly clobbered.) If *preserve_mode* is true (the "
"default), the file's mode (type and permission bits, or whatever is "
"analogous on the current platform) is copied. If *preserve_times* is true "
"(the default), the last-modified and last-access times are copied as well. "
"If *update* is true, *src* will only be copied if *dst* does not exist, or "
"if *dst* does exist but is older than *src*."
msgstr ""
"將文件 *src* 複製到 *dst*。如果 *dst* 是一個目錄，那麼 *src* 會以相同的名稱複"
"製到那裡；否則，它必須是一個文件名。 （如果文件存在，它將被無情地破壞。）如"
"果 *preserve_mode* 為 true（預設值），則復製文件的模式（型別和權限位，或當前"
"平台上的任何類似內容）。如果 *preserve_times* 為真（預設），最後修改時間和最"
"後訪問時間也會被複製。如果 *update* 為 true，則 *src* 僅在 *dst* 不存在或 "
"*dst* 存在但早於 *src* 時才被複製。"

#: ../../distutils/apiref.rst:1057
#, fuzzy
msgid ""
"*link* allows you to make hard links (using :func:`os.link`) or symbolic "
"links (using :func:`os.symlink`) instead of copying: set it to ``'hard'`` or "
"``'sym'``; if it is ``None`` (the default), files are copied. Don't set "
"*link* on systems that don't support it: :func:`copy_file` doesn't check if "
"hard or symbolic linking is available.  It uses :func:`_copy_file_contents` "
"to copy file contents."
msgstr ""
"*link* 允許您建立硬鏈接（使用 :func:`os.link`）或符號鏈接（使用 :func:`os."
"symlink`）而不是複制：將其設定為 ``'hard'`` 或 ``'sym'``;如果它是``None`` "
"（預設），文件被複製。不要在不支援它的系統上設定 *link*：:func:`copy_file` 不"
"檢查硬鏈接或符號鏈接是否可用。它使用 :func:`_copy_file_contents` 來複製文件內"
"容。"

#: ../../distutils/apiref.rst:1064
#, fuzzy
msgid ""
"Return a tuple ``(dest_name, copied)``: *dest_name* is the actual  name of "
"the output file, and *copied* is true if the file was copied  (or would have "
"been copied, if *dry_run* true)."
msgstr ""
"回傳一個元組``(dest_name, copied)``：*dest_name* 是輸出文件的實際名稱，如果文"
"件被複製（或者如果*dry_run* 為真，則*copied* 為真）。"

#: ../../distutils/apiref.rst:1078
#, fuzzy
msgid ""
"Move file *src* to *dst*. If *dst* is a directory, the file will be moved "
"into it with the same name; otherwise, *src* is just renamed to *dst*.  "
"Returns the new full name of the file."
msgstr ""
"將文件 *src* 移動到 *dst*。如果 *dst* 是目錄，則文件將以相同的名稱移動到其"
"中；否則，*src* 只是重命名為 *dst*。回傳文件的新全名。"

#: ../../distutils/apiref.rst:1084
#, fuzzy
msgid ""
"Handles cross-device moves on Unix using :func:`copy_file`.  What about "
"other systems?"
msgstr "使用 :func:`copy_file` 在 Unix 上處理跨設備移動。其他系統呢？"

#: ../../distutils/apiref.rst:1090
#, fuzzy
msgid ""
"Create a file called *filename* and write *contents* (a sequence of strings "
"without line terminators) to it."
msgstr ""
"建立一個名為 *filename* 的文件並向其寫入 *contents*（不帶行終止符的字串序"
"列）。"

#: ../../distutils/apiref.rst:1095
#, fuzzy
msgid ":mod:`distutils.util` --- Miscellaneous other utility functions"
msgstr ":mod:`distutils.util` --- 雜項其他實用函式"

#: ../../distutils/apiref.rst:1101
#, fuzzy
msgid ""
"This module contains other assorted bits and pieces that don't fit into  any "
"other utility module."
msgstr "該模組包含不適合任何其他實用程式模組的其他各種零碎資訊。"

#: ../../distutils/apiref.rst:1107
#, fuzzy
msgid ""
"Return a string that identifies the current platform.  This is used mainly "
"to distinguish platform-specific build directories and platform-specific "
"built distributions.  Typically includes the OS name and version and the "
"architecture (as supplied by 'os.uname()'), although the exact information "
"included depends on the OS; e.g., on Linux, the kernel version isn't "
"particularly important."
msgstr ""
"回傳標識當前平台的字串。這主要用於區分特定於平台的構建目錄和特定於平台的構建"
"發行版。通常包括操作系統名稱和版本以及體系結構（由“os.uname()”提供），儘管所"
"包含的確切資訊取決於操作系統；例如，在 Linux 上，內核版本並不是特別重要。"

#: ../../distutils/apiref.rst:1114
#, fuzzy
msgid "Examples of returned values:"
msgstr "回傳值示例："

#: ../../distutils/apiref.rst:1116
msgid "``linux-i586``"
msgstr "``linux-i586``"

#: ../../distutils/apiref.rst:1117
msgid "``linux-alpha``"
msgstr "``linux-alpha``"

#: ../../distutils/apiref.rst:1118
msgid "``solaris-2.6-sun4u``"
msgstr "``solaris-2.6-sun4u``"

#: ../../distutils/apiref.rst:1120
#, fuzzy
msgid "For non-POSIX platforms, currently just returns ``sys.platform``."
msgstr "對於非 POSIX 平台，目前只回傳 ``sys.platform``。"

#: ../../distutils/apiref.rst:1122
#, fuzzy
msgid ""
"For macOS systems the OS version reflects the minimal version on which "
"binaries will run (that is, the value of ``MACOSX_DEPLOYMENT_TARGET`` during "
"the build of Python), not the OS version of the current system."
msgstr ""
"對於 macOS 系統，操作系統版本反映了二進位文件將運行的最低版本（即 Python 構建"
"期間 ``MACOSX_DEPLOYMENT_TARGET`` 的值），而不是當前系統的操作系統版本。"

#: ../../distutils/apiref.rst:1126
#, fuzzy
msgid ""
"For universal binary builds on macOS the architecture value reflects the "
"universal binary status instead of the architecture of the current "
"processor. For 32-bit universal binaries the architecture is ``fat``, for 64-"
"bit universal binaries the architecture is ``fat64``, and for 4-way "
"universal binaries the architecture is ``universal``. Starting from Python "
"2.7 and Python 3.2 the architecture ``fat3`` is used for a 3-way universal "
"build (ppc, i386, x86_64) and ``intel`` is used for a universal build with "
"the i386 and x86_64 architectures"
msgstr ""
"對於在 macOS 上構建的通用二進位文件，體系結構值反映了通用二進位文件的狀態，而"
"不是當前處理器的體系結構。對於 32 位通用二進位文件，體系結構是 ``fat``，對於 "
"64 位通用二進位文件，體系結構是 ``fat64``，對於 4 路通用二進位文件，體系結構"
"是“通用”。從 Python 2.7 和 Python 3.2 開始，架構 ``fat3``用於 3 路通用構建"
"（ppc、i386、x86_64）， ``intel``用於 i386 和 x86_64 架構的通用構建"

#: ../../distutils/apiref.rst:1135
#, fuzzy
msgid "Examples of returned values on macOS:"
msgstr "macOS 上的回傳值示例："

#: ../../distutils/apiref.rst:1137
msgid "``macosx-10.3-ppc``"
msgstr "``macosx-10.3-ppc``"

#: ../../distutils/apiref.rst:1139
msgid "``macosx-10.3-fat``"
msgstr "``macosx-10.3-fat``"

#: ../../distutils/apiref.rst:1141
msgid "``macosx-10.5-universal``"
msgstr "``macosx-10.5-universal``"

#: ../../distutils/apiref.rst:1143
msgid "``macosx-10.6-intel``"
msgstr "``macosx-10.6-intel``"

#: ../../distutils/apiref.rst:1145
#, fuzzy
msgid ""
"For AIX, Python 3.9 and later return a string starting with \"aix\", "
"followed by additional fields (separated by ``'-'``) that represent the "
"combined values of AIX Version, Release and Technology Level (first field), "
"Build Date (second field), and bit-size (third field). Python 3.8 and "
"earlier returned only a single additional field with the AIX Version and "
"Release."
msgstr ""
"對於 AIX，Python 3.9 及更高版本回傳以 ``aix``開頭的字串，後跟表示 AIX 版本、"
"發行版和技術級別（第一個欄位）、Build日期（第二個欄位）和位大小（第三個欄"
"位）。 Python 3.8 及更早版本僅回傳一個帶有 AIX 版本和發行版的附加欄位。"

#: ../../distutils/apiref.rst:1151
#, fuzzy
msgid "Examples of returned values on AIX:"
msgstr "AIX 上的回傳值示例："

#: ../../distutils/apiref.rst:1153
#, fuzzy
msgid ""
"``aix-5307-0747-32`` # 32-bit build on AIX ``oslevel -s``: 5300-07-00-0000"
msgstr ""
"``aix-5307-0747-32`` # AIX ``oslevel -s`` 上的 32 位構建：5300-07-00-0000"

#: ../../distutils/apiref.rst:1155
#, fuzzy
msgid ""
"``aix-7105-1731-64`` # 64-bit build on AIX ``oslevel -s``: 7100-05-01-1731"
msgstr ""
"``aix-7105-1731-64`` # AIX ``oslevel -s`` 上的 64 位構建：7100-05-01-1731"

#: ../../distutils/apiref.rst:1157
#, fuzzy
msgid "``aix-7.2``          # Legacy form reported in Python 3.8 and earlier"
msgstr "``aix-7.2`` # Python 3.8 及更早版本中報告的遺留形式"

#: ../../distutils/apiref.rst:1159
#, fuzzy
msgid ""
"The AIX platform string format now also includes the technology level, build "
"date, and ABI bit-size."
msgstr "AIX 平台字串格式現在還包括技術級別、構建日期和 ABI 位大小。"

#: ../../distutils/apiref.rst:1166
#, fuzzy
msgid ""
"Return 'pathname' as a name that will work on the native filesystem, i.e. "
"split it on '/' and put it back together again using the current directory "
"separator. Needed because filenames in the setup script are always supplied "
"in Unix style, and have to be converted to the local convention before we "
"can actually use them in the filesystem.  Raises :exc:`ValueError` on non-"
"Unix-ish systems if *pathname* either  starts or ends with a slash."
msgstr ""
"將“路徑名”作為可在本機文件系統上使用的名稱回傳，即將其拆分為 ``/``，然後使用"
"當前目錄分隔符將其重新組合在一起。之所以需要，是因為安裝腳本中的文件名始終以 "
"Unix 風格提供，並且必須先轉換為本地約定，然後才能在文件系統中實際使用它們。如"
"果 *pathname* 以斜杠開頭或結尾，則在非 Unix-ish 系統上引發 :exc:"
"`ValueError`。"

#: ../../distutils/apiref.rst:1176
#, fuzzy
msgid ""
"Return *pathname* with *new_root* prepended.  If *pathname* is relative, "
"this is equivalent to ``os.path.join(new_root,pathname)`` Otherwise, it "
"requires making *pathname* relative and then joining the two, which is "
"tricky on DOS/Windows."
msgstr ""
"回傳帶有 *new_root* 前綴的 *pathname*。如果 *pathname* 是相對的，這相當於 "
"``os.path.join(new_root,pathname)`` 否則，它需要使 *pathname* 成為相對的，然"
"後將兩者連接起來，這在 DOS/Windows 上很棘手。"

#: ../../distutils/apiref.rst:1183
#, fuzzy
msgid ""
"Ensure that 'os.environ' has all the environment variables we guarantee that "
"users can use in config files, command-line options, etc.  Currently this "
"includes:"
msgstr ""
"確保“os.environ”具有我們保證使用者可以在配置文件、命令列選項等中使用的所有環"
"境變數。目前這包括："

#: ../../distutils/apiref.rst:1187
#, fuzzy
msgid ":envvar:`HOME` - user's home directory (Unix only)"
msgstr ":envvar:`HOME` - 使用者的主目錄（僅限 Unix）"

#: ../../distutils/apiref.rst:1188
#, fuzzy
msgid ""
":envvar:`PLAT` - description of the current platform, including hardware and "
"OS (see :func:`get_platform`)"
msgstr ""
":envvar:`PLAT` - 當前平台的描述，包括硬件和操作系統（參見 :func:"
"`get_platform`）"

#: ../../distutils/apiref.rst:1194
#, fuzzy
msgid ""
"Perform shell/Perl-style variable substitution on *s*.  Every occurrence of "
"``$`` followed by a name is considered a variable, and variable is "
"substituted by the value found in the *local_vars* dictionary, or in ``os."
"environ`` if it's not in *local_vars*. *os.environ* is first checked/"
"augmented to guarantee that it contains certain values: see :func:"
"`check_environ`.  Raise :exc:`ValueError` for any variables not found in "
"either *local_vars* or ``os.environ``."
msgstr ""
"對 *s* 執行 shell/Perl 風格的變數替換。每次出現 ``$`` 後跟一個名稱都被認為是"
"一個變數，並且變數被替換為在 *local_vars* 字典中找到的值，或者如果它不在 "
"*local_vars* 中，則替換為在 ``os.environ`` 中找到的值。 *os.environ* 首先被檢"
"查/擴充以保證它包含某些值：參見 :func:`check_environ`。為在 *local_vars* 或 "
"``os.environ`` 中找不到的任何變數引發 :exc:`ValueError`。"

#: ../../distutils/apiref.rst:1201
#, fuzzy
msgid ""
"Note that this is not a full-fledged string interpolation function. A valid "
"``$variable`` can consist only of upper and lower case letters, numbers and "
"an underscore. No { } or ( ) style quoting is available."
msgstr ""
"請注意，這不是一個成熟的字串插值函式。一個有效的 ``$variable`` 只能由大小寫字"
"母、數字和底線組成。沒有可用的 { } 或 ( ) 樣式引用。"

#: ../../distutils/apiref.rst:1208
#, fuzzy
msgid ""
"Split a string up according to Unix shell-like rules for quotes and "
"backslashes. In short: words are delimited by spaces, as long as those "
"spaces are not escaped by a backslash, or inside a quoted string. Single and "
"double quotes are equivalent, and the quote characters can be backslash-"
"escaped.  The backslash is stripped from any two-character escape sequence, "
"leaving only the escaped character.  The quote characters are stripped from "
"any quoted string.  Returns a list of words."
msgstr ""
"根據類似 Unix shell 的引號和反斜杠規則拆分字串。簡而言之：單詞由空格分隔，只"
"要這些空格沒有被反斜杠或引號字串轉義即可。單引號和雙引號是等價的，引號字元可"
"以反斜杠轉義。反斜杠從任何雙字元轉義序列中剝離，只留下轉義字元。引號字元從任"
"何帶引號的字串中刪除。回傳單詞列表。"

#: ../../distutils/apiref.rst:1221
#, fuzzy
msgid ""
"Perform some action that affects the outside world (for instance, writing to "
"the filesystem).  Such actions are special because they are disabled by the "
"*dry_run* flag.  This method takes  care of all that bureaucracy for you; "
"all you have to do is supply the function to call and an argument tuple for "
"it (to embody the \"external action\" being performed), and an optional "
"message to print."
msgstr ""
"執行一些影響外部世界的操作（例如，寫入文件系統）。此類操作很特殊，因為它們被 "
"*dry_run* 旗標禁用。這種方法可以為您解決所有官僚主義問題；您所要做的就是提供"
"要呼叫的函式和它的參數元組（以體現正在執行的“外部操作”），以及要印出的可選消"
"息。"

#: ../../distutils/apiref.rst:1230
#, fuzzy
msgid "Convert a string representation of truth to true (1) or false (0)."
msgstr "將 truth 的字串表示形式轉換為 true (1) 或 false (0)。"

#: ../../distutils/apiref.rst:1232
#, fuzzy
msgid ""
"True values are ``y``, ``yes``, ``t``, ``true``, ``on``  and ``1``; false "
"values are ``n``, ``no``, ``f``, ``false``,  ``off`` and ``0``.  Raises :exc:"
"`ValueError` if *val*  is anything else."
msgstr ""
"真值為 ``y``、 ``yes``、 ``t``、 ``true``、 ``on``和 ``1``；錯誤值是 ``n``、 "
"``no``、 ``f``、 ``false``、“off”和 ``0``。如果 *val* 是其他值，則引發 :exc:"
"`ValueError`。"

#: ../../distutils/apiref.rst:1239
#, fuzzy
msgid ""
"Byte-compile a collection of Python source files to :file:`.pyc` files in a :"
"file:`__pycache__` subdirectory (see :pep:`3147` and :pep:`488`). *py_files* "
"is a list of files to compile; any files that don't end in :file:`.py` are "
"silently skipped.  *optimize* must be one of the following:"
msgstr ""
"將一組 Python 源文件位元組編譯為 :file:`__pycache__` 子目錄中的 :file:`.pyc` "
"文件（參見 :pep:`3147` 和 :pep:`488`）。 *py_files* 是要編譯的文件列表；任何"
"不以 :file:`.py` 結尾的文件都會被靜默跳過。 *最佳化* 必須是以下之一："

#: ../../distutils/apiref.rst:1244
msgid "``0`` - don't optimize"
msgstr "``0`` - 不最佳化"

#: ../../distutils/apiref.rst:1245
msgid "``1`` - normal optimization (like ``python -O``)"
msgstr "``1`` - 正常最佳化（如 ``python -O``）"

#: ../../distutils/apiref.rst:1246
msgid "``2`` - extra optimization (like ``python -OO``)"
msgstr "``2`` - 額外最佳化（如 ``python -OO``）"

#: ../../distutils/apiref.rst:1248
#, fuzzy
msgid "If *force* is true, all files are recompiled regardless of timestamps."
msgstr "如果 *force* 為 true，則所有文件都會重新編譯，而不管時間戳。"

#: ../../distutils/apiref.rst:1250
#, fuzzy
msgid ""
"The source filename encoded in each :term:`bytecode` file defaults to the "
"filenames listed in *py_files*; you can modify these with *prefix* and "
"*basedir*. *prefix* is a string that will be stripped off of each source "
"filename, and *base_dir* is a directory name that will be prepended (after "
"*prefix* is stripped).  You can supply either or both (or neither) of "
"*prefix* and *base_dir*, as you wish."
msgstr ""
"每個 :term:`bytecode` 文件中編碼的源文件名預設為 *py_files* 中列出的文件名；"
"您可以使用 *prefix* 和 *basedir* 修改它們。 *prefix* 是將從每個源文件名中剝離"
"的字串，*base_dir* 是將被新增到前面的目錄名（在 *prefix* 被剝離之後）。您可以"
"根據需要提供 *prefix* 和 *base_dir* 之一或兩者（或兩者都不提供）。"

#: ../../distutils/apiref.rst:1257
#, fuzzy
msgid ""
"If *dry_run* is true, doesn't actually do anything that would affect the "
"filesystem."
msgstr "如果 *dry_run* 為真，實際上不會做任何會影響文件系統的事情。"

#: ../../distutils/apiref.rst:1260
#, fuzzy
msgid ""
"Byte-compilation is either done directly in this interpreter process with "
"the standard :mod:`py_compile` module, or indirectly by writing a temporary "
"script and executing it.  Normally, you should let :func:`byte_compile` "
"figure out to use direct compilation or not (see the source for details).  "
"The *direct* flag is used by the script generated in indirect mode; unless "
"you know what you're doing, leave it set to ``None``."
msgstr ""
"位元組編譯要么直接在這個直譯器行程中使用標準 :mod:`py_compile` 模組完成，要么"
"通過編寫臨時腳本並執行它來間接完成。通常，您應該讓 :func:`byte_compile` 確定"
"是否使用直接編譯（詳情請參閱源程式碼）。 *direct* 旗標由間接模式生成的腳本使"
"用；除非您知道自己在做什麼，否則請將其設定為 ``None`` 。"

#: ../../distutils/apiref.rst:1267
#, fuzzy
msgid ""
"Create ``.pyc`` files with an :func:`import magic tag <imp.get_tag>` in "
"their name, in a :file:`__pycache__` subdirectory instead of files without "
"tag in the current directory."
msgstr ""
"在 :file:`__pycache__` 子目錄中建立名稱中帶有 :func:`import magic tag <imp."
"get_tag>` 的 ``.pyc`` 文件，而不是當前目錄中沒有標記的文件。"

#: ../../distutils/apiref.rst:1272
msgid "Create ``.pyc`` files according to :pep:`488`."
msgstr "根據 :pep:`488` 建立 ``.pyc`` 文件。"

#: ../../distutils/apiref.rst:1278
#, fuzzy
msgid ""
"Return a version of *header* escaped for inclusion in an :rfc:`822` header, "
"by ensuring there are 8 spaces space after each newline. Note that it does "
"no other modification of the string."
msgstr ""
"通過確保每個換行符後有 8 個空格，回傳轉義的 *header* 版本以包含在 :rfc:`822` "
"標頭中。請注意，它不會對字串進行其他修改。"

#: ../../distutils/apiref.rst:1288
#, fuzzy
msgid ":mod:`distutils.dist` --- The Distribution class"
msgstr ":mod:`distutils.dist` --- 分發類別"

#: ../../distutils/apiref.rst:1295
#, fuzzy
msgid ""
"This module provides the :class:`~distutils.core.Distribution` class, which "
"represents the module distribution being built/installed/distributed."
msgstr ""
"該模組提供 :class:`~distutils.core.Distribution` 類，它表示正在構建/安裝/分發"
"的模組分發。"

#: ../../distutils/apiref.rst:1300
#, fuzzy
msgid ":mod:`distutils.extension` --- The Extension class"
msgstr ":mod:`distutils.extension` --- 擴充類別"

#: ../../distutils/apiref.rst:1307
#, fuzzy
msgid ""
"This module provides the :class:`Extension` class, used to describe C/C++ "
"extension modules in setup scripts."
msgstr ""
"該模組提供 :class:`Extension` 類別，用於描述安裝腳本中的 C/C++ 擴充模組。"

#: ../../distutils/apiref.rst:1315
msgid ":mod:`distutils.debug` --- Distutils debug mode"
msgstr ":mod:`distutils.debug` --- Distutils 除錯模式"

#: ../../distutils/apiref.rst:1321
msgid "This module provides the DEBUG flag."
msgstr "該模組提供 DEBUG 旗標。"

#: ../../distutils/apiref.rst:1325
msgid ":mod:`distutils.errors` --- Distutils exceptions"
msgstr ":mod:`distutils.errors` --- Distutils 例外"

#: ../../distutils/apiref.rst:1331
#, fuzzy
msgid ""
"Provides exceptions used by the Distutils modules.  Note that Distutils "
"modules may raise standard exceptions; in particular, SystemExit is usually "
"raised for errors that are obviously the end-user's fault (eg. bad command-"
"line arguments)."
msgstr ""
"提供 Distutils 模組使用的例外。請注意，Distutils 模組可能會引發標準例外；特別"
"是，SystemExit 通常針對明顯是最終使用者錯誤的錯誤（例如錯誤的命令列參數）引"
"發。"

#: ../../distutils/apiref.rst:1335
#, fuzzy
msgid ""
"This module is safe to use in ``from ... import *`` mode; it only exports "
"symbols whose names start with ``Distutils`` and end with ``Error``."
msgstr ""
"這個模組可以安全地用於``from ... import *`` 模式；它只導出名稱以 "
"``Distutils`` 開頭並以 ``Error``結尾的符號。"

#: ../../distutils/apiref.rst:1340
#, fuzzy
msgid ""
":mod:`distutils.fancy_getopt` --- Wrapper around the standard getopt module"
msgstr ":mod:`distutils.fancy_getopt` --- 標準 getopt 模組的包裝器"

#: ../../distutils/apiref.rst:1346
#, fuzzy
msgid ""
"This module provides a wrapper around the standard :mod:`getopt`  module "
"that provides the following additional features:"
msgstr ""
"該模組圍繞標準 :mod:`getopt` 模組提供了一個包裝器，該模組提供了以下附加功能："

#: ../../distutils/apiref.rst:1349
#, fuzzy
msgid "short and long options are tied together"
msgstr "空頭和多頭選項捆綁在一起"

#: ../../distutils/apiref.rst:1351
#, fuzzy
msgid ""
"options have help strings, so :func:`fancy_getopt` could potentially  create "
"a complete usage summary"
msgstr "選項有幫助字串，所以 :func:`fancy_getopt` 可能會建立一個完整的使用總結"

#: ../../distutils/apiref.rst:1354
#, fuzzy
msgid "options set attributes of a passed-in object"
msgstr "選項設定傳入物件的屬性"

#: ../../distutils/apiref.rst:1356
#, fuzzy
msgid ""
"boolean options can have \"negative aliases\" --- eg. if :option:`!--quiet` "
"is the \"negative alias\" of :option:`!--verbose`, then :option:`!--quiet` "
"on the command line sets *verbose* to false."
msgstr ""
"布爾選項可以有“負別名”---例如。如果 :option:`!--quiet` 是 :option:`!--"
"verbose` 的“負別名”，則命令列上的 :option:`!--quiet` 將 *verbose* 設定為 "
"false。"

#: ../../distutils/apiref.rst:1362
#, fuzzy
msgid ""
"Wrapper function. *options* is a list of ``(long_option, short_option, "
"help_string)`` 3-tuples as described in the constructor for :class:"
"`FancyGetopt`. *negative_opt* should be a dictionary mapping option names to "
"option names, both the key and value should be in the *options* list. "
"*object* is an object which will be used to store values (see the :meth:"
"`getopt` method of the :class:`FancyGetopt` class). *args* is the argument "
"list. Will use ``sys.argv[1:]`` if you  pass ``None`` as *args*."
msgstr ""
"包裝函式。 *options* 是 ``(long_option, short_option, help_string)`` 三元組的"
"列表，如 FancyGetopt 的構造函式中所述。 *negative_opt* 應該是一個字典映射選項"
"名稱到選項名稱，鍵和值都應該在 *options* 列表中。 *object* 是一個用於儲存值的"
"物件（參見 FancyGetopt 類的 getopt 方法）。 *args* 是參數列表。如果您將 "
"``None``作為 *args* 傳遞，將使用“sys.argv[1:]”。"

#: ../../distutils/apiref.rst:1373
#, fuzzy
msgid "Wraps *text* to less than *width* wide."
msgstr "將 *text* 換行到小於 *width* 寬。"

#: ../../distutils/apiref.rst:1378
#, fuzzy
msgid ""
"The option_table is a list of 3-tuples: ``(long_option, short_option, "
"help_string)``"
msgstr ""
"option_table 是一個三元組列表：``(long_option, short_option, help_string)``"

#: ../../distutils/apiref.rst:1381
#, fuzzy
msgid ""
"If an option takes an argument, its *long_option* should have ``'='`` "
"appended; *short_option* should just be a single character, no ``':'`` in "
"any case. *short_option* should be ``None`` if a *long_option*  doesn't have "
"a corresponding *short_option*. All option tuples must have long options."
msgstr ""
"如果一個選項接受一個參數，它的 *long_option* 應該附加 ``'='``； "
"*short_option* 應該只是一個字元，在任何情況下都沒有 ``':'``。如果"
"*long_option* 沒有相應的*short_option*，*short_option* 應該是``None``。所有選"
"項元組都必須有長選項。"

#: ../../distutils/apiref.rst:1386
#, fuzzy
msgid "The :class:`FancyGetopt` class provides the following methods:"
msgstr "FancyGetopt 類提供以下方法："

#: ../../distutils/apiref.rst:1391
#, fuzzy
msgid "Parse command-line options in args. Store as attributes on *object*."
msgstr "解析 args 中的命令列選項。儲存為 *object* 上的屬性。"

#: ../../distutils/apiref.rst:1393
#, fuzzy
msgid ""
"If *args* is ``None`` or not supplied, uses ``sys.argv[1:]``.  If *object* "
"is ``None`` or not supplied, creates a new :class:`OptionDummy` instance, "
"stores option values there, and returns a tuple ``(args, object)``.  If "
"*object* is supplied, it is modified in place and :func:`getopt` just "
"returns *args*; in both cases, the returned *args* is a modified copy of the "
"passed-in *args* list, which is left untouched."
msgstr ""
"如果 *args* 為 ``None`` 或未提供，則使用“sys.argv[1:]”。如果 *object* 為 "
"``None``或未提供，則建立一個新的 OptionDummy 實例，將選項值儲存在那裡，並回傳"
"一個元組“(args, object)”。如果提供了 *object*，它就被修改並且 :func:`getopt` "
"只回傳 *args*；在這兩種情況下，回傳的 *args* 都是傳入的 *args* 列表的修改副"
"本，它保持不變。"

#: ../../distutils/apiref.rst:1405
#, fuzzy
msgid ""
"Returns the list of ``(option, value)`` tuples processed by the previous run "
"of :meth:`getopt`  Raises :exc:`RuntimeError` if :meth:`getopt` hasn't been "
"called yet."
msgstr ""
"回傳由之前運行的 getopt 處理過的 `（選項，值）`` 元組列表 如果尚未呼叫 "
"getopt 則引發 RuntimeError。"

#: ../../distutils/apiref.rst:1412
#, fuzzy
msgid ""
"Generate help text (a list of strings, one per suggested line of output) "
"from the option table for this :class:`FancyGetopt` object."
msgstr ""
"從此 FancyGetopt 物件的選項表生成幫助文本（字串列表，每個建議的輸出行一個）。"

#: ../../distutils/apiref.rst:1415
#, fuzzy
msgid "If supplied, prints the supplied *header* at the top of the help."
msgstr "如果提供，則在幫助頂部印出提供的 *header*。"

#: ../../distutils/apiref.rst:1419
#, fuzzy
msgid ":mod:`distutils.filelist` --- The FileList class"
msgstr ":mod:`distutils.filelist` --- 文件列表類別"

#: ../../distutils/apiref.rst:1426
#, fuzzy
msgid ""
"This module provides the :class:`FileList` class, used for poking about the "
"filesystem and building lists of files."
msgstr "該模組提供 :class:`FileList` 類別，用於查看文件系統和構建文件列表。"

#: ../../distutils/apiref.rst:1431
msgid ":mod:`distutils.log` --- Simple :pep:`282`-style logging"
msgstr ":mod:`distutils.log` --- 簡單的 :pep:`282` 風格的日誌記錄"

#: ../../distutils/apiref.rst:1438
msgid ":mod:`distutils.spawn` --- Spawn a sub-process"
msgstr ":mod:`distutils.spawn` --- 產生一個子行程"

#: ../../distutils/apiref.rst:1444
#, fuzzy
msgid ""
"This module provides the :func:`spawn` function, a front-end to  various "
"platform-specific functions for launching another program in a  sub-process. "
"Also provides :func:`find_executable` to search the path for a given "
"executable name."
msgstr ""
"該模組提供 :func:`spawn` 函式，這是各種平台特定函式的前端，用於在子行程中啟動"
"另一個程式。還提供 :func:`find_executable` 來搜索給定可執行文件名稱的路徑。"

#: ../../distutils/apiref.rst:1451
msgid ":mod:`distutils.sysconfig` --- System configuration information"
msgstr ":mod:`distutils.sysconfig` --- 系統配置資訊"

#: ../../distutils/apiref.rst:1455
msgid ":mod:`distutils.sysconfig` has been merged into :mod:`sysconfig`."
msgstr ":mod:`distutils.sysconfig` 已合併到 :mod:`sysconfig` 中。"

#: ../../distutils/apiref.rst:1462
#, fuzzy
msgid ""
"The :mod:`distutils.sysconfig` module provides access to Python's low-level "
"configuration information.  The specific configuration variables available "
"depend heavily on the platform and configuration. The specific variables "
"depend on the build process for the specific version of Python being run; "
"the variables are those found in the :file:`Makefile` and configuration "
"header that are installed with Python on Unix systems.  The configuration "
"header is called :file:`pyconfig.h` for Python versions starting with 2.2, "
"and :file:`config.h` for earlier versions of Python."
msgstr ""
":mod:`distutils.sysconfig` 模組提供對 Python 低階配置資訊的訪問。可用的特定配"
"置變數在很大程度上取決於平台和配置。具體變數取決於正在運行的特定 Python 版本"
"的構建過程；這些變數是在 Unix 系統上隨 Python 安裝的 Makefile 和配置標頭中找"
"到的變數。對於從 2.2 開始的 Python 版本，配置標頭稱為 :file:`pyconfig.h`，對"
"於早期版本的 Python，稱為 :file:`config.h`。"

#: ../../distutils/apiref.rst:1471
#, fuzzy
msgid ""
"Some additional functions are provided which perform some useful "
"manipulations for other parts of the :mod:`distutils` package."
msgstr ""
"提供了一些額外的功能，這些功能對 :mod:`distutils` 包的其他部分執行一些有用的"
"操作。"

#: ../../distutils/apiref.rst:1477
msgid "The result of ``os.path.normpath(sys.prefix)``."
msgstr "``os.path.normpath(sys.prefix)`` 的結果。"

#: ../../distutils/apiref.rst:1482
msgid "The result of ``os.path.normpath(sys.exec_prefix)``."
msgstr "``os.path.normpath(sys.exec_prefix)`` 的結果。"

#: ../../distutils/apiref.rst:1487
#, fuzzy
msgid ""
"Return the value of a single variable.  This is equivalent to "
"``get_config_vars().get(name)``."
msgstr "回傳單個變數的值。這相當於 ``get_config_vars().get(name)``。"

#: ../../distutils/apiref.rst:1493
#, fuzzy
msgid ""
"Return a set of variable definitions.  If there are no arguments, this "
"returns a dictionary mapping names of configuration variables to values.  If "
"arguments are provided, they should be strings, and the return value will be "
"a sequence giving the associated values. If a given name does not have a "
"corresponding value, ``None`` will be included for that variable."
msgstr ""
"回傳一組變數定義。如果沒有參數，這將回傳一個字典，將配置變數的名稱映射到值。"
"如果提供了參數，它們應該是字串，回傳值將是一個給出相關值的序列。如果給定名稱"
"沒有相應的值，則該變數將包含 ``None`` 。"

#: ../../distutils/apiref.rst:1502
#, fuzzy
msgid ""
"Return the full path name of the configuration header.  For Unix, this will "
"be the header generated by the :program:`configure` script; for other "
"platforms the header will have been supplied directly by the Python source "
"distribution.  The file is a platform-specific text file."
msgstr ""
"回傳配置標頭的完整路徑名。對於 Unix，這將是 :program:`configure` 腳本生成的標"
"頭；對於其他平台，標頭將由 Python 源程式碼分發直接提供。該文件是特定於平台的"
"文本文件。"

#: ../../distutils/apiref.rst:1510
#, fuzzy
msgid ""
"Return the full path name of the :file:`Makefile` used to build Python.  For "
"Unix, this will be a file generated by the :program:`configure` script; the "
"meaning for other platforms will vary.  The file is a platform-specific text "
"file, if it exists. This function is only useful on POSIX platforms."
msgstr ""
"回傳用於構建 Python 的 Makefile 的完整路徑名。對於 Unix，這將是一個由 :"
"program:`configure` 腳本生成的文件；其他平台的含義會有所不同。該文件是特定於"
"平台的文本文件（如果存在）。此函式僅在 POSIX 平台上有用。"

#: ../../distutils/apiref.rst:1515
#, fuzzy
msgid ""
"The following functions are deprecated together with this module and they "
"have no direct replacement."
msgstr "以下功能與此模組一起棄用，它們沒有直接替代品。"

#: ../../distutils/apiref.rst:1521
#, fuzzy
msgid ""
"Return the directory for either the general or platform-dependent C include "
"files.  If *plat_specific* is true, the platform-dependent include directory "
"is returned; if false or omitted, the platform-independent directory is "
"returned. If *prefix* is given, it is used as either the prefix instead of :"
"const:`PREFIX`, or as the exec-prefix instead of :const:`EXEC_PREFIX` if "
"*plat_specific* is true."
msgstr ""
"回傳通用或平台相關的 C 包含文件的目錄。如果 *plat_specific* 為真，則回傳平台"
"相關的包含目錄；如果為 false 或省略，則回傳與平台無關的目錄。如果給出了 "
"*prefix*，則它被用作前綴而不是 :const:`PREFIX`，或者如果 *plat_specific* 為"
"真，則用作 exec-prefix 而不是 :const:`EXEC_PREFIX`。"

#: ../../distutils/apiref.rst:1531
#, fuzzy
msgid ""
"Return the directory for either the general or platform-dependent library "
"installation.  If *plat_specific* is true, the platform-dependent include "
"directory is returned; if false or omitted, the platform-independent "
"directory is returned.  If *prefix* is given, it is used as either the "
"prefix instead of :const:`PREFIX`, or as the exec-prefix instead of :const:"
"`EXEC_PREFIX` if *plat_specific* is true.  If *standard_lib* is true, the "
"directory for the standard library is returned rather than the directory for "
"the installation of third-party extensions."
msgstr ""
"回傳通用或平台相關庫安裝的目錄。如果 *plat_specific* 為真，則回傳平台相關的包"
"含目錄；如果為 false 或省略，則回傳與平台無關的目錄。如果給出了 *prefix*，則"
"它被用作前綴而不是 :const:`PREFIX`，或者如果 *plat_specific* 為真，則用作 "
"exec-prefix 而不是 :const:`EXEC_PREFIX`。如果 *standard_lib* 為真，則回傳標準"
"庫的目錄而不是第三方擴充的安裝目錄。"

#: ../../distutils/apiref.rst:1540
msgid ""
"The following function is only intended for use within the :mod:`distutils` "
"package."
msgstr "以下函式僅供在 :mod:`distutils` 套件中使用。"

#: ../../distutils/apiref.rst:1546
#, fuzzy
msgid ""
"Do any platform-specific customization of a :class:`distutils.ccompiler."
"CCompiler` instance."
msgstr "對 distutils.ccompiler.CCompiler 實例進行任何特定於平台的自定義。"

#: ../../distutils/apiref.rst:1549
#, fuzzy
msgid ""
"This function is only needed on Unix at this time, but should be called "
"consistently to support forward-compatibility.  It inserts the information "
"that varies across Unix flavors and is stored in Python's :file:`Makefile`.  "
"This information includes the selected compiler, compiler and linker "
"options, and the extension used by the linker for shared objects."
msgstr ""
"這個函式目前只在 Unix 上需要，但應該一致地呼叫以支援向前相容。它插入因 Unix "
"風格而異的資訊，並儲存在 Python 的 Makefile 中。此資訊包括選定的編譯器、編譯"
"器和鏈接器選項，以及鏈接器用於共享物件的擴充。"

#: ../../distutils/apiref.rst:1555
#, fuzzy
msgid ""
"This function is even more special-purpose, and should only be used from "
"Python's own build procedures."
msgstr "這個函式的用途更加特殊，只能在 Python 自己的構建過程中使用。"

#: ../../distutils/apiref.rst:1561
#, fuzzy
msgid ""
"Inform the :mod:`distutils.sysconfig` module that it is being used as part "
"of the build process for Python.  This changes a lot of relative locations "
"for files, allowing them to be located in the build area rather than in an "
"installed Python."
msgstr ""
"通知 :mod:`distutils.sysconfig` 模組它被用作 Python 構建過程的一部分。這改變"
"了文件的許多相對位置，允許它們位於構建區域而不是已安裝的 Python 中。"

#: ../../distutils/apiref.rst:1568
msgid ":mod:`distutils.text_file` --- The TextFile class"
msgstr ":mod:`distutils.text_file` --- TextFile 類別"

#: ../../distutils/apiref.rst:1574
#, fuzzy
msgid ""
"This module provides the :class:`TextFile` class, which gives an interface  "
"to text files that (optionally) takes care of stripping comments, ignoring  "
"blank lines, and joining lines with backslashes."
msgstr ""
"該模組提供 :class:`TextFile` 類，它為文本文件提供了一個介面，該介面（可選）負"
"責剝離註釋、忽略空行以及使用反斜杠連接行。"

#: ../../distutils/apiref.rst:1581
#, fuzzy
msgid ""
"This class provides a file-like object that takes care of all  the things "
"you commonly want to do when processing a text file  that has some line-by-"
"line syntax: strip comments (as long as ``#``  is your comment character), "
"skip blank lines, join adjacent lines by escaping the newline (ie. backslash "
"at end of line), strip leading and/or trailing whitespace.  All of these are "
"optional and independently controllable."
msgstr ""
"此類提供了一個類文件物件，它處理您在處理具有某些逐行語法的文本文件時通常想要"
"做的所有事情：去除註釋（只要``#``是您的註釋字元), 跳過空白行，通過轉義換行符"
"（即行尾的反斜杠）連接相鄰行，去除前導和/或尾隨空白。所有這些都是可選的和獨立"
"可控的。"

#: ../../distutils/apiref.rst:1588
#, fuzzy
msgid ""
"The class provides a :meth:`warn` method so you can generate  warning "
"messages that report physical line number, even if the  logical line in "
"question spans multiple physical lines.  Also  provides :meth:`unreadline` "
"for implementing line-at-a-time lookahead."
msgstr ""
"該類提供了一個 :meth:`warn` 方法，因此您可以生成報告物理行號的警告消息，即使"
"有問題的邏輯行跨越多條物理行也是如此。還提供 :meth:`unreadline` 用於實作一次"
"一行的前瞻。"

#: ../../distutils/apiref.rst:1593
#, fuzzy
msgid ""
":class:`TextFile` instances are create with either *filename*, *file*, or "
"both. :exc:`RuntimeError` is raised if both are ``None``. *filename* should "
"be a string, and *file* a file object (or something that provides :meth:"
"`readline` and :meth:`close`  methods).  It is recommended that you supply "
"at least *filename*,  so that :class:`TextFile` can include it in warning "
"messages.  If *file* is not supplied, :class:`TextFile` creates its own "
"using the :func:`open` built-in function."
msgstr ""
":class:`TextFile` 實例是使用 *filename*、*file* 或兩者建立的。 :exc:"
"`RuntimeError` 如果兩者都是 ``None`` 則被引發。 *filename* 應該是一個字串，"
"*file* 是一個文件物件（或者提供 :meth:`readline` 和 :meth:`close` 方法的東"
"西）。建議您至少提供 *filename*，以便 TextFile 可以將其包含在警告消息中。如果"
"未提供 *file*，TextFile 會使用 :func:`open` 內建函式建立自己的文件。"

#: ../../distutils/apiref.rst:1601
#, fuzzy
msgid ""
"The options are all boolean, and affect the values returned by :meth:"
"`readline`"
msgstr "這些選項都是布爾值，並影響 :meth:`readline` 回傳的值"

#: ../../distutils/apiref.rst:1606
msgid "option name"
msgstr "選項名稱"

#: ../../distutils/apiref.rst:1606
msgid "default"
msgstr "預設"

#: ../../distutils/apiref.rst:1608
msgid "*strip_comments*"
msgstr "*strip_comments*"

#: ../../distutils/apiref.rst:1608
#, fuzzy
msgid ""
"strip from ``'#'`` to end-of-line, as well as any whitespace leading up to "
"the ``'#'``\\ ---unless it is escaped by a backslash"
msgstr "從 ``'#'`` 到行尾，以及導致 ``'#'``\\ 的任何空格 - 除非它被反斜杠轉義"

#: ../../distutils/apiref.rst:1608 ../../distutils/apiref.rst:1617
#: ../../distutils/apiref.rst:1622
msgid "true"
msgstr "true"

#: ../../distutils/apiref.rst:1614
msgid "*lstrip_ws*"
msgstr "*lstrip_ws*"

#: ../../distutils/apiref.rst:1614
#, fuzzy
msgid "strip leading whitespace from each line before returning it"
msgstr "在回傳之前從每一行中去除前導空格"

#: ../../distutils/apiref.rst:1614 ../../distutils/apiref.rst:1632
#: ../../distutils/apiref.rst:1643
msgid "false"
msgstr "false"

#: ../../distutils/apiref.rst:1617
msgid "*rstrip_ws*"
msgstr "*rstrip_ws*"

#: ../../distutils/apiref.rst:1617
#, fuzzy
msgid ""
"strip trailing whitespace (including line terminator!) from each line before "
"returning it."
msgstr "在回傳之前從每行中去除尾隨空格（包括行終止符！）。"

#: ../../distutils/apiref.rst:1622
msgid "*skip_blanks*"
msgstr "*skip_blanks*"

#: ../../distutils/apiref.rst:1622
#, fuzzy
msgid ""
"skip lines that are empty \\*after\\* stripping comments and whitespace.  "
"(If both lstrip_ws and rstrip_ws are false, then some lines may consist of "
"solely whitespace: these will \\*not\\* be skipped, even if *skip_blanks* is "
"true.)"
msgstr ""
"跳過\\*在\\* 剝離註釋和空格之後的空行。 （如果 lstrip_ws 和 rstrip_ws 都為"
"假，那麼某些行可能只包含空格：這些將\\*不會\\*被跳過，即使 *skip_blanks* 為"
"真。）"

#: ../../distutils/apiref.rst:1632
msgid "*join_lines*"
msgstr "*join_lines*"

#: ../../distutils/apiref.rst:1632
#, fuzzy
msgid ""
"if a backslash is the last non-newline character on a line after stripping "
"comments and whitespace, join the following line to it to form one logical "
"line; if N consecutive lines end with a backslash, then N+1 physical lines "
"will be joined to form one logical line."
msgstr ""
"如果反斜杠是去除註釋和空格後一行中的最後一個非換行符，則將下一行連接到它以形"
"成一個邏輯行；如果 N 個連續的行以反斜杠結尾，那麼 N+1 個物理行將被連接起來形"
"成一個邏輯行。"

#: ../../distutils/apiref.rst:1643
msgid "*collapse_join*"
msgstr "*collapse_join*"

#: ../../distutils/apiref.rst:1643
#, fuzzy
msgid ""
"strip leading whitespace from lines that are joined to their predecessor; "
"only matters if ``(join_lines and not lstrip_ws)``"
msgstr ""
"從連接到其前身的行中去除前導空格；僅在``（join_lines 而不是lstrip_ws）``時才"
"重要"

#: ../../distutils/apiref.rst:1650
#, fuzzy
msgid ""
"Note that since *rstrip_ws* can strip the trailing newline, the semantics "
"of :meth:`readline` must differ from those of the built-in file object's :"
"meth:`readline` method!  In particular, :meth:`readline`  returns ``None`` "
"for end-of-file: an empty string might just be a  blank line (or an all-"
"whitespace line), if *rstrip_ws* is true  but *skip_blanks* is not."
msgstr ""
"請注意，由於 *rstrip_ws* 可以去除尾隨的換行符，因此 :meth:`readline` 的語義必"
"須與內建文件物件的 :meth:`readline` 方法的語義不同！特別是，對於文件結尾，"
"readline 回傳 ``None``：如果 *rstrip_ws* 為真但 *skip_blanks* 則空字串可能只"
"是一個空行（或全空白行）不是。"

#: ../../distutils/apiref.rst:1659
#, fuzzy
msgid ""
"Open a new file *filename*.  This overrides any *file* or *filename* "
"constructor arguments."
msgstr ""
"打開一個新文件 *文件名*。這會覆蓋任何 *file* 或 *filename* 構造函式參數。"

#: ../../distutils/apiref.rst:1665
#, fuzzy
msgid ""
"Close the current file and forget everything we know about it (including the "
"filename and the current line number)."
msgstr "關閉當前文件並忘記我們所知道的一切（包括文件名和當前行號）。"

#: ../../distutils/apiref.rst:1671
#, fuzzy
msgid ""
"Print (to stderr) a warning message tied to the current logical line in the "
"current file.  If the current logical line in the file spans multiple "
"physical lines, the warning refers to the whole range, such as ``\"lines "
"3-5\"``.  If *line* is supplied,  it overrides the current line number; it "
"may be a list or tuple  to indicate a range of physical lines, or an integer "
"for a  single physical line."
msgstr ""
"印出（到 stderr）與當前文件中的當前邏輯行相關的警告消息。如果文件中的當前邏輯"
"行跨越多個物理行，則警告指的是整個範圍，例如 ``\"lines 3-5\"``。如果提供了 "
"*line*，它會覆蓋當前行號；它可以是一個列表或元組來指示物理行的範圍，或者是一"
"個整數來表示單個物理行。"

#: ../../distutils/apiref.rst:1681
#, fuzzy
msgid ""
"Read and return a single logical line from the current file (or from an "
"internal buffer if lines have previously been \"unread\" with :meth:"
"`unreadline`).  If the *join_lines* option  is true, this may involve "
"reading multiple physical lines concatenated into a single string.  Updates "
"the current line number,  so calling :meth:`warn` after :meth:`readline` "
"emits a warning  about the physical line(s) just read.  Returns ``None`` on "
"end-of-file,  since the empty string can occur if *rstrip_ws* is true but  "
"*strip_blanks* is not."
msgstr ""
"從當前文件讀取並回傳單個邏輯行（或者如果行之前使用 :meth:`unreadline` 被“未"
"讀”，則從內部緩衝區讀取）。如果 *join_lines* 選項為真，這可能涉及讀取連接成單"
"個字串的多條物理行。更新當前行號，因此在 :meth:`readline` 之後呼叫 :meth:"
"`warn` 會發出有關剛剛讀取的物理行的警告。在文件末尾回傳 ``None`` ，因為如果 "
"*rstrip_ws* 為真但 *strip_blanks* 不是，則可能出現空字串。"

#: ../../distutils/apiref.rst:1692
#, fuzzy
msgid ""
"Read and return the list of all logical lines remaining in the current file. "
"This updates the current line number to the last line of the file."
msgstr ""
"讀取並回傳當前文件中剩餘的所有邏輯行的列表。這會將當前行號更新為文件的最後一"
"行。"

#: ../../distutils/apiref.rst:1698
#, fuzzy
msgid ""
"Push *line* (a string) onto an internal buffer that will be checked by "
"future :meth:`readline` calls.  Handy for implementing a parser with line-at-"
"a-time lookahead. Note that lines that are \"unread\" with :meth:"
"`unreadline` are not subsequently re-cleansed (whitespace  stripped, or "
"whatever) when read with :meth:`readline`. If multiple calls are made to :"
"meth:`unreadline` before a call to :meth:`readline`, the lines will be "
"returned most in most recent first order."
msgstr ""
"將 *line*（一個字串）推送到一個內部緩衝區，該緩衝區將被未來的 readline 呼叫檢"
"查。方便地使用一次一行的前瞻實作解析器。請注意，使用 :meth:`unreadline` 讀取"
"的“未讀”行在使用 :meth:`readline` 讀取時不會隨後重新清理（去除空白，或其"
"他）。如果在呼叫 :meth:`readline` 之前對 :meth:`unreadline` 進行了多次呼叫，"
"則將以最近的第一順序回傳最多的行。"

#: ../../distutils/apiref.rst:1707
msgid ":mod:`distutils.version` --- Version number classes"
msgstr ":mod:`distutils.version` --- 版本號類別"

#: ../../distutils/apiref.rst:1722
msgid ":mod:`distutils.cmd` --- Abstract base class for Distutils commands"
msgstr ":mod:`distutils.cmd` --- Distutils 命令的抽象基底類別"

#: ../../distutils/apiref.rst:1729
msgid "This module supplies the abstract base class :class:`Command`."
msgstr "該模組提供抽象基底類別 :class:`Command`。"

#: ../../distutils/apiref.rst:1734
#, fuzzy
msgid ""
"Abstract base class for defining command classes, the \"worker bees\" of the "
"Distutils.  A useful analogy for command classes is to think of them as "
"subroutines with local variables called *options*.  The options are declared "
"in :meth:`initialize_options` and defined (given their final values) in :"
"meth:`finalize_options`, both of which must be defined by every command "
"class.  The distinction between the two is necessary because option values "
"might come from the outside world (command line, config file, ...), and any "
"options dependent on other options must be computed after these outside "
"influences have been processed --- hence :meth:`finalize_options`.  The body "
"of the subroutine, where it does all its work based on the values of its "
"options, is the :meth:`run` method, which must also be implemented by every "
"command class."
msgstr ""
"用於定義命令類的抽象基底類別，即 Distutils 的“工蜂”。命令類的一個有用類比是將"
"它們視為具有稱為 *options* 的局部變數的子例程。這些選項在 :meth:"
"`initialize_options` 中聲明並在 :meth:`finalize_options` 中定義（給定它們的最"
"終值），這兩者都必須由每個命令類定義。兩者之間的區別是必要的，因為選項值可能"
"來自外部世界（命令列、配置文件等），並且任何依賴於其他選項的選項都必須在處理"
"完這些外部影響後進行計算——因此 :meth:`finalize_options`。子例程的主體是 :"
"meth:`run` 方法，它根據其選項的值完成所有工作，每個命令類也必須實作該方法。"

#: ../../distutils/apiref.rst:1747
#, fuzzy
msgid ""
"The class constructor takes a single argument *dist*, a :class:`~distutils."
"core.Distribution` instance."
msgstr ""
"類構造函式採用單個參數 *dist*，一個 :class:`~distutils.core.Distribution` 實"
"例。"

#: ../../distutils/apiref.rst:1752
msgid "Creating a new Distutils command"
msgstr "建立一個新的 Distutils 命令"

#: ../../distutils/apiref.rst:1754
#, fuzzy
msgid "This section outlines the steps to create a new Distutils command."
msgstr "本節概述了建立新 Distutils 命令的步驟。"

#: ../../distutils/apiref.rst:1756
#, fuzzy
msgid ""
"A new command lives in a module in the :mod:`distutils.command` package. "
"There is a sample template in that directory called :file:"
"`command_template`.  Copy this file to a new module with the same name as "
"the new command you're implementing.  This module should implement a class "
"with the same name as the module (and the command).  So, for instance, to "
"create the command ``peel_banana`` (so that users can run ``setup.py "
"peel_banana``), you'd copy :file:`command_template` to :file:`distutils/"
"command/peel_banana.py`, then edit it so that it's implementing the class :"
"class:`peel_banana`, a subclass of :class:`distutils.cmd.Command`."
msgstr ""
"一個新命令存在於 :mod:`distutils.command` 包中的一個模組中。該目錄中有一個名"
"為 :file:`command_template` 的示例模板。將此文件複製到與您正在實施的新命令同"
"名的新模組。這個模組應該實作一個與模組（和命令）同名的類。因此，例如，要建立"
"命令 ``peel_banana``（以便使用者可以運行 ``setup.py peel_banana``），您可以"
"將 :file:`command_template` 複製到 :file:`distutils/command/peel_banana ."
"py`，然後對其進行編輯，使其實作類 :class:`peel_banana`，它是 :class:"
"`distutils.cmd.Command` 的子類別。"

#: ../../distutils/apiref.rst:1766
#, fuzzy
msgid "Subclasses of :class:`Command` must define the following methods."
msgstr ":class:`Command` 的子類別必須定義以下方法。"

#: ../../distutils/apiref.rst:1770
#, fuzzy
msgid ""
"Set default values for all the options that this command supports.  Note "
"that these defaults may be overridden by other commands, by the setup "
"script, by config files, or by the command-line.  Thus, this is not the "
"place to code dependencies between options; generally, :meth:"
"`initialize_options` implementations are just a bunch of ``self.foo = None`` "
"assignments."
msgstr ""
"為該命令支援的所有選項設定預設值。請注意，這些預設值可能會被其他命令、設定腳"
"本、配置文件或命令列覆蓋。因此，這不是編寫選項之間依賴關係的地方；一般來說，:"
"meth:`initialize_options` 實作只是一堆 ``self.foo = None`` 賦值。"

#: ../../distutils/apiref.rst:1779
#, fuzzy
msgid ""
"Set final values for all the options that this command supports. This is "
"always called as late as possible, ie.  after any option assignments from "
"the command-line or from other commands have been done.  Thus, this is the "
"place to code option dependencies: if *foo* depends on *bar*, then it is "
"safe to set *foo* from *bar* as long as *foo* still has the same value it "
"was assigned in :meth:`initialize_options`."
msgstr ""
"為該命令支援的所有選項設定最終值。這總是盡可能晚地呼叫，即。在命令列或其他命"
"令的任何選項分配完成後。因此，這是編寫選項依賴項程式碼的地方：如果 *foo* 依賴"
"於 *bar*，那麼從 *bar* 設定 *foo* 是安全的，只要 *foo* 仍然具有與分配給它的值"
"相同的值 :meth:`initialize_options`。"

#: ../../distutils/apiref.rst:1789
#, fuzzy
msgid ""
"A command's raison d'etre: carry out the action it exists to perform, "
"controlled by the options initialized in :meth:`initialize_options`, "
"customized by other commands, the setup script, the command-line, and config "
"files, and finalized in :meth:`finalize_options`.  All terminal output and "
"filesystem interaction should be done by :meth:`run`."
msgstr ""
"命令的存在理由：執行它存在的操作，由 initialize_options 中初始化的選項控制，"
"由其他命令定制，安裝腳本，命令列和配置文件，並最終確定 :meth:"
"`finalize_options`。所有終端輸出和文件系統交互都應該由 :meth:`run` 完成。"

#: ../../distutils/apiref.rst:1798
#, fuzzy
msgid ""
"*sub_commands* formalizes the notion of a \"family\" of commands, e.g. "
"``install`` as the parent with sub-commands ``install_lib``, "
"``install_headers``, etc.  The parent of a family of commands defines "
"*sub_commands* as a class attribute; it's a list of 2-tuples "
"``(command_name, predicate)``, with *command_name* a string and *predicate* "
"a function, a string or ``None``.  *predicate* is a method of the parent "
"command that determines whether the corresponding command is applicable in "
"the current situation.  (E.g. ``install_headers`` is only applicable if we "
"have any C header files to install.)  If *predicate* is ``None``, that "
"command is always applicable."
msgstr ""
"*sub_commands* 形式化了命令“家族”的概念，例如``install`` 作為帶有子命令"
"``install_lib``、``install_headers`` 等的父命令。命令家族的父命令定義 "
"*sub_commands* 作為類屬性；它是一個二元組列表``(command_name, predicate)``，"
"*command_name* 是一個字串，*predicate* 是一個函式，一個字串或``None``。 "
"*predicate* 是父命令的一個方法，判斷對應的命令是否適用於當前情況。 （例如，"
"``install_headers`` 僅在我們有任何要安裝的 C 標頭檔時適用。）如果 "
"*predicate* 為 ``None``，則該命令始終適用。"

#: ../../distutils/apiref.rst:1809
#, fuzzy
msgid ""
"*sub_commands* is usually defined at the *end* of a class, because "
"predicates can be methods of the class, so they must already have been "
"defined.  The canonical example is the :command:`install` command."
msgstr ""
"*sub_commands* 通常定義在類的*end*，因為謂詞可以是類的方法，所以它們必須已經"
"被定義。典型的例子是 :command:`install` 命令。"

#: ../../distutils/apiref.rst:1815
#, fuzzy
msgid ":mod:`distutils.command` --- Individual Distutils commands"
msgstr ":mod:`distutils.command` --- 單獨的 Distutils 命令"

#: ../../distutils/apiref.rst:1826
msgid ":mod:`distutils.command.bdist` --- Build a binary installer"
msgstr ":mod:`distutils.command.bdist` --- 建置二進位安裝程式"

#: ../../distutils/apiref.rst:1836
#, fuzzy
msgid ""
":mod:`distutils.command.bdist_packager` --- Abstract base class for packagers"
msgstr ":mod:`distutils.command.bdist_packager` --- 包裝器的抽象基底類別"

#: ../../distutils/apiref.rst:1846
#, fuzzy
msgid ":mod:`distutils.command.bdist_dumb` --- Build a \"dumb\" installer"
msgstr ":mod:`distutils.command.bdist_dumb` --- 構建一個“啞巴”安裝程式"

#: ../../distutils/apiref.rst:1856
#, fuzzy
msgid ""
":mod:`distutils.command.bdist_rpm` --- Build a binary distribution as a "
"Redhat RPM and SRPM"
msgstr ""
":mod:`distutils.command.bdist_rpm` --- 將二進位分發構建為 Redhat RPM 和 SRPM"

#: ../../distutils/apiref.rst:1866
#, fuzzy
msgid ":mod:`distutils.command.sdist` --- Build a source distribution"
msgstr ":mod:`distutils.command.sdist` --- 建置源程式碼分發"

#: ../../distutils/apiref.rst:1876
#, fuzzy
msgid ":mod:`distutils.command.build` --- Build all files of a package"
msgstr ":mod:`distutils.command.build` --- 建置一個包的所有文件"

#: ../../distutils/apiref.rst:1886
#, fuzzy
msgid ""
":mod:`distutils.command.build_clib` --- Build any C libraries in a package"
msgstr ":mod:`distutils.command.build_clib` --- 在套件中建置任何 C 函式庫"

#: ../../distutils/apiref.rst:1896
#, fuzzy
msgid ""
":mod:`distutils.command.build_ext` --- Build any extensions in a package"
msgstr ":mod:`distutils.command.build_ext` --- 在套件中構建任何擴充"

#: ../../distutils/apiref.rst:1906
#, fuzzy
msgid ""
":mod:`distutils.command.build_py` --- Build the .py/.pyc files of a package"
msgstr ":mod:`distutils.command.build_py` --- 建置套件的 .py/.pyc 文件"

#: ../../distutils/apiref.rst:1916
#, fuzzy
msgid ""
"Alternative implementation of build_py which also runs the 2to3 conversion "
"library on each .py file that is going to be installed. To use this in a "
"setup.py file for a distribution that is designed to run with both Python 2."
"x and 3.x, add::"
msgstr ""
"build_py 的替代實作，它還在將要安裝的每個 .py 文件上運行 2to3 轉換庫。要在 "
"setup.py 文件中將其用於旨在與 Python 2.x 和 3.x 一起運行的發行版，請新增："

#: ../../distutils/apiref.rst:1926
#, fuzzy
msgid "to your setup.py, and later::"
msgstr "到你的 setup.py，然後："

#: ../../distutils/apiref.rst:1930
#, fuzzy
msgid "to the invocation of setup()."
msgstr "呼叫 setup()。"

#: ../../distutils/apiref.rst:1934
msgid ""
":mod:`distutils.command.build_scripts` --- Build the scripts of a package"
msgstr ":mod:`distutils.command.build_scripts` --- 構建套件的腳本"

#: ../../distutils/apiref.rst:1944
msgid ":mod:`distutils.command.clean` --- Clean a package build area"
msgstr ":mod:`distutils.command.clean` --- 清理套件建置區域"

#: ../../distutils/apiref.rst:1949
#, fuzzy
msgid ""
"This command removes the temporary files created by :command:`build` and its "
"subcommands, like intermediary compiled object files.  With the ``--all`` "
"option, the complete build directory will be removed."
msgstr ""
"此命令刪除由 :command:`build` 及其子命令建立的臨時文件，如中間編譯目標文件。"
"使用 ``--all`` 選項，將刪除完整的構建目錄。"

#: ../../distutils/apiref.rst:1953
#, fuzzy
msgid ""
"Extension modules built :ref:`in place <distutils-build-ext-inplace>` will "
"not be cleaned, as they are not in the build directory."
msgstr ""
"構建的擴充模組 <distutils-build-ext-inplace>` 將不會被清除，因為它們不在構建"
"目錄中。"

#: ../../distutils/apiref.rst:1958
msgid ":mod:`distutils.command.config` --- Perform package configuration"
msgstr ":mod:`distutils.command.config` --- 執行套件配置"

#: ../../distutils/apiref.rst:1968
msgid ":mod:`distutils.command.install` --- Install a package"
msgstr ":mod:`distutils.command.install` --- 安裝一個套件"

#: ../../distutils/apiref.rst:1978
msgid ""
":mod:`distutils.command.install_data` --- Install data files from a package"
msgstr ":mod:`distutils.command.install_data` --- 從套件中安裝資料檔案"

#: ../../distutils/apiref.rst:1988
msgid ""
":mod:`distutils.command.install_headers` --- Install C/C++ header files from "
"a package"
msgstr ":mod:`distutils.command.install_headers` --- 從套件中安裝 C/C++ 標頭檔"

#: ../../distutils/apiref.rst:1998
msgid ""
":mod:`distutils.command.install_lib` --- Install library files from a package"
msgstr ":mod:`distutils.command.install_lib` --- 從套件中安裝函式庫檔案"

#: ../../distutils/apiref.rst:2008
msgid ""
":mod:`distutils.command.install_scripts` --- Install script files from a "
"package"
msgstr ":mod:`distutils.command.install_scripts` --- 從套件中安裝腳本檔案"

#: ../../distutils/apiref.rst:2018
#, fuzzy
msgid ""
":mod:`distutils.command.register` --- Register a module with the Python "
"Package Index"
msgstr ":mod:`distutils.command.register` --- 向 Python 套件索引註冊一個模組"

#: ../../distutils/apiref.rst:2024
#, fuzzy
msgid ""
"The ``register`` command registers the package with the Python Package  "
"Index. This is described in more detail in :pep:`301`."
msgstr ""
"``register`` 命令將包註冊到 Python 包索引。這在 :pep:`301` 中有更詳細的描述。"

#: ../../distutils/apiref.rst:2031
msgid ":mod:`distutils.command.check` --- Check the meta-data of a package"
msgstr ":mod:`distutils.command.check` --- 檢查套件的元資料"

#: ../../distutils/apiref.rst:2037
#, fuzzy
msgid ""
"The ``check`` command performs some tests on the meta-data of a package. For "
"example, it verifies that all required meta-data are provided as the "
"arguments passed to the :func:`setup` function."
msgstr ""
"``check`` 命令對包的元資料執行一些測試。例如，它驗證是否提供了所有必需的元資"
"料作為傳遞給 :func:`setup` 函式的參數。"
