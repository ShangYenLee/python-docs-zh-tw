# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-06-20 18:08+0800\n"
"PO-Revision-Date: 2018-05-23 14:09+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../distutils/setupscript.rst:5
#, fuzzy
msgid "Writing the Setup Script"
msgstr "編寫安裝腳本"

#: ../../distutils/_setuptools_disclaimer.rst:3
#, fuzzy
msgid ""
"This document is being retained solely until the ``setuptools`` "
"documentation at https://setuptools.readthedocs.io/en/latest/setuptools.html "
"independently covers all of the relevant information currently included here."
msgstr ""
"本文檔僅保留到 https://setuptools.readthedocs.io/en/latest/setuptools.html "
"上的 ``setuptools``文檔獨立涵蓋當前包含在此處的所有相關資訊。"

#: ../../distutils/setupscript.rst:9
#, fuzzy
msgid ""
"The setup script is the centre of all activity in building, distributing, "
"and installing modules using the Distutils.  The main purpose of the setup "
"script is to describe your module distribution to the Distutils, so that the "
"various commands that operate on your modules do the right thing.  As we saw "
"in section :ref:`distutils-simple-example` above, the setup script consists "
"mainly of a call to :func:`setup`, and most information supplied to the "
"Distutils by the module developer is supplied as keyword arguments to :func:"
"`setup`."
msgstr ""
"安裝腳本是使用 Distutils 構建、分發和安裝模組的所有活動的中心。"
"安裝腳本的主要目的是向 Distutils "
"描述您的模組分發，以便在您的模組上運行的各種命令做正確的事情。"
"正如我們在上面的 :ref:`distutils-simple-example` 部分中看到的，"
"設定腳本主要包括對 :func:`setup` 的呼叫，模組開發人員提供給 Distutils "
"的大部分資訊作為關鍵字參數提供給 :func:`setup`。"

#: ../../distutils/setupscript.rst:17
#, fuzzy
msgid ""
"Here's a slightly more involved example, which we'll follow for the next "
"couple of sections: the Distutils' own setup script.  (Keep in mind that "
"although the Distutils are included with Python 1.6 and later, they also "
"have an independent existence so that Python 1.5.2 users can use them to "
"install other module distributions.  The Distutils' own setup script, shown "
"here, is used to install the package into Python 1.5.2.) ::"
msgstr ""
"這是一個稍微複雜一些的示例，我們將在接下來的幾節中遵循它：Distutils "
"自己的安裝腳本。 （請記住，雖然 Distutils 包含在 Python 1.6 "
"及更高版本中，但它們也是獨立存在的，因此 Python 1.5.2 "
"使用者可以使用它們來安裝其他模組發行版。此處顯示的 Distutils "
"自己的安裝腳本用於將軟件包安裝到 Python 1.5.2 中。）::"

#: ../../distutils/setupscript.rst:37
#, fuzzy
msgid ""
"There are only two differences between this and the trivial one-file "
"distribution presented in section :ref:`distutils-simple-example`: more "
"metadata, and the specification of pure Python modules by package, rather "
"than by module.  This is important since the Distutils consist of a couple "
"of dozen modules split into (so far) two packages; an explicit list of every "
"module would be tedious to generate and difficult to maintain.  For more "
"information on the additional meta-data, see section :ref:`meta-data`."
msgstr ""
"這與 :ref:`distutils-simple-example` "
"部分中介紹的簡單的單文件分發之間只有兩個區別：更多的元資料，"
"以及按包而不是按模組的純 Python 模組規範。這很重要，因為 Distutils 由幾十個模"
"組組成（到目前為止）分為兩個包；每個模組的明確列表生成起來很乏味且難以維護。"
"有關其他元資料的更多資訊，請參閱 :ref:`meta-data` 部分。"

#: ../../distutils/setupscript.rst:45
#, fuzzy
msgid ""
"Note that any pathnames (files or directories) supplied in the setup script "
"should be written using the Unix convention, i.e. slash-separated.  The "
"Distutils will take care of converting this platform-neutral representation "
"into whatever is appropriate on your current platform before actually using "
"the pathname.  This makes your setup script portable across operating "
"systems, which of course is one of the major goals of the Distutils.  In "
"this spirit, all pathnames in this document are slash-separated."
msgstr ""
"請注意，安裝腳本中提供的任何路徑名（文件或目錄）都應使用 Unix "
"約定編寫，即以斜杠分隔。在實際使用路徑名之前，Distutils 將負責將這種平台中立"
"的表示形式轉換為適合您當前平台的任何形式。這使您的設定腳本可跨操作系統移植，"
"這當然是 Distutils "
"的主要目標之一。本著這種精神，本文檔中的所有路徑名均以斜杠分隔。"

#: ../../distutils/setupscript.rst:53
#, fuzzy
msgid ""
"This, of course, only applies to pathnames given to Distutils functions.  If "
"you, for example, use standard Python functions such as :func:`glob.glob` "
"or :func:`os.listdir` to specify files, you should be careful to write "
"portable code instead of hardcoding path separators::"
msgstr ""
"當然，這只適用於給 Distutils 函式的路徑名。例如，如果您使用標準的 Python "
"函式，例如 :func:`glob.glob` 或 :func:`os.listdir` "
"來指定文件，您應該小心編寫可移植程式碼而不是硬編碼路徑分隔符::"

#: ../../distutils/setupscript.rst:65
#, fuzzy
msgid "Listing whole packages"
msgstr "列出整個包"

#: ../../distutils/setupscript.rst:67
#, fuzzy
msgid ""
"The ``packages`` option tells the Distutils to process (build, distribute, "
"install, etc.) all pure Python modules found in each package mentioned in "
"the ``packages`` list.  In order to do this, of course, there has to be a "
"correspondence between package names and directories in the filesystem.  The "
"default correspondence is the most obvious one, i.e. package :mod:"
"`distutils` is found in the directory :file:`distutils` relative to the "
"distribution root. Thus, when you say ``packages = ['foo']`` in your setup "
"script, you are promising that the Distutils will find a file :file:`foo/"
"__init__.py` (which might be spelled differently on your system, but you get "
"the idea) relative to the directory where your setup script lives.  If you "
"break this promise, the Distutils will issue a warning but still process the "
"broken package anyway."
msgstr ""
"``packages`` 選項告訴 Distutils 處理（構建、分發、安裝等）在 ``packages`` "
"列表中提到的每個包中找到的所有純 Python 模組。當然，為了做到這一點，文件系統"
"中的包名和目錄之間必須存在對應關係。預設對應關係是最明顯的對應關係，即包 "
":mod:`distutils` 位於相對於分髮根目錄的 :file:`distutils` "
"目錄中。因此，當您在安裝腳本中使用 ``packages = ['foo']`` 時，您承諾 "
"Distutils 將找到一個文件 :file:`foo/__init__.py`（在您的系統中可能拼寫不同，"
"但你明白了）相對於你的安裝腳本所在的目錄。如果你違反了這個承諾，Distutils "
"會發出警告，但仍然會處理損壞的包。"

#: ../../distutils/setupscript.rst:79
#, fuzzy
msgid ""
"If you use a different convention to lay out your source directory, that's "
"no problem: you just have to supply the ``package_dir`` option to tell the "
"Distutils about your convention.  For example, say you keep all Python "
"source under :file:`lib`, so that modules in the \"root package\" (i.e., not "
"in any package at all) are in :file:`lib`, modules in the :mod:`foo` package "
"are in :file:`lib/foo`, and so forth.  Then you would put ::"
msgstr ""
"如果您使用不同的約定來佈局您的源目錄，那沒問題：您只需要提供 ``package_dir`` "
"選項來告訴 Distutils 您的約定。例如，假設您將所有 Python 源程式碼保存在 "
":file:`lib` 下，因此“根包”中的模組（即根本不在任何包中）位於 :file:`lib` 中，"
"模組位於 :mod :`foo` 包在 :file:`lib/foo` 中，依此類推。然後你會把 ::"

#: ../../distutils/setupscript.rst:88
#, fuzzy
msgid ""
"in your setup script.  The keys to this dictionary are package names, and an "
"empty package name stands for the root package.  The values are directory "
"names relative to your distribution root.  In this case, when you say "
"``packages = ['foo']``, you are promising that the file :file:`lib/foo/"
"__init__.py` exists."
msgstr ""
"在你的安裝腳本中。這個字典的鍵是包名，空包名代表根包。這些值是相對於您的分髮"
"根目錄的目錄名稱。在這種情況下，當您說 ``packages = ['foo']`` 時，您承諾文件 "
":file:`lib/foo/__init__.py` 存在。"

#: ../../distutils/setupscript.rst:93
#, fuzzy
msgid ""
"Another possible convention is to put the :mod:`foo` package right in :file:"
"`lib`, the :mod:`foo.bar` package in :file:`lib/bar`, etc.  This would be "
"written in the setup script as ::"
msgstr ""
"另一種可能的約定是將 :mod:`foo` 包放在 :file:`lib` 中，將 :mod:`foo.bar` "
"包放在 :file:`lib/bar` 中，等等。這將寫成設定腳本為 ::"

#: ../../distutils/setupscript.rst:99
#, fuzzy
msgid ""
"A ``package: dir`` entry in the ``package_dir`` dictionary implicitly "
"applies to all packages below *package*, so the :mod:`foo.bar` case is "
"automatically handled here.  In this example, having ``packages = ['foo', "
"'foo.bar']`` tells the Distutils to look for :file:`lib/__init__.py` and :"
"file:`lib/bar/__init__.py`.  (Keep in mind that although ``package_dir`` "
"applies recursively, you must explicitly list all packages in ``packages``: "
"the Distutils will *not* recursively scan your source tree looking for any "
"directory with an :file:`__init__.py` file.)"
msgstr ""
"``package_dir`` 字典中的 ``package:dir`` 條目隱式適用於 *package* "
"下的所有包，所以 :mod:`foo.bar` 的情況在這裡自動處理。在這個例子中，讓 ``"
"packages = ['foo', 'foo.bar']`` 告訴 Distutils 尋找 :file:`lib/__init__.py` "
"和 :file:`lib/bar/__init__.py `。 （請記住，雖然 ``package_dir`` 遞迴應用，"
"但您必須明確列出 ``packages`` 中的所有包：Distutils *不會* "
"遞迴掃描您的源程式碼樹以查找任何帶有 :file:`__init__ 的目錄。 py`文件。）"

#: ../../distutils/setupscript.rst:112
#, fuzzy
msgid "Listing individual modules"
msgstr "列出單個模組"

#: ../../distutils/setupscript.rst:114
#, fuzzy
msgid ""
"For a small module distribution, you might prefer to list all modules rather "
"than listing packages---especially the case of a single module that goes in "
"the \"root package\" (i.e., no package at all).  This simplest case was "
"shown in section :ref:`distutils-simple-example`; here is a slightly more "
"involved example::"
msgstr ""
"對於小型模組分發，您可能更願意列出所有模組而不是列出包——尤其是“根包”中的單個"
"模組（即根本沒有包）的情況。這個最簡單的案例顯示在 distutils-simple-example "
"部分；這是一個稍微複雜一點的例子::"

#: ../../distutils/setupscript.rst:121
#, fuzzy
msgid ""
"This describes two modules, one of them in the \"root\" package, the other "
"in the :mod:`pkg` package.  Again, the default package/directory layout "
"implies that these two modules can be found in :file:`mod1.py` and :file:"
"`pkg/mod2.py`, and that :file:`pkg/__init__.py` exists as well. And again, "
"you can override the package/directory correspondence using the "
"``package_dir`` option."
msgstr ""
"這描述了兩個模組，一個在 \"root\" 包中，另一個在 :mod:`pkg` 包中。同樣，預設的包/"
"目錄佈局意味著這兩個模組可以在 :file:`mod1.py` 和 :file:`pkg/mod2.py` "
"中找到，並且 :file:`pkg/__init__.py` "
"存在以及。同樣，您可以使用“package_dir”選項覆蓋包/目錄對應關係。"

#: ../../distutils/setupscript.rst:131
#, fuzzy
msgid "Describing extension modules"
msgstr "描述擴充模組"

#: ../../distutils/setupscript.rst:133
#, fuzzy
msgid ""
"Just as writing Python extension modules is a bit more complicated than "
"writing pure Python modules, describing them to the Distutils is a bit more "
"complicated. Unlike pure modules, it's not enough just to list modules or "
"packages and expect the Distutils to go out and find the right files; you "
"have to specify the extension name, source file(s), and any compile/link "
"requirements (include directories, libraries to link with, etc.)."
msgstr ""
"正如編寫 Python 擴充模組比編寫純 Python 模組要復雜一些一樣，向 Distutils "
"描述它們也要復雜一些。與純模組不同，僅僅列出模組或包並期望 Distutils 出去並找"
"到正確的文件是不夠的；您必須指定擴充名、源文件和任何編譯/鏈接要求（包括目錄、"
"要鏈接的庫等）。"

#: ../../distutils/setupscript.rst:142
#, fuzzy
msgid ""
"All of this is done through another keyword argument to :func:`setup`, the "
"``ext_modules`` option.  ``ext_modules`` is just a list of :class:"
"`~distutils.core.Extension` instances, each of which describes a single "
"extension module. Suppose your distribution includes a single extension, "
"called :mod:`foo` and implemented by :file:`foo.c`.  If no additional "
"instructions to the compiler/linker are needed, describing this extension is "
"quite simple::"
msgstr ""
"所有這些都是通過 :func:`setup` 的另一個關鍵字參數，``ext_modules`` "
"選項完成的。 ``ext_modules`` 只是 :class:`~distutils.core.Extension` "
"實例的列表，每個實例都描述了一個擴充模組。假設您的發行版包含一個名為 "
":mod:`foo` 的擴充，由 :file:`foo.c` "
"實作。如果不需要對編譯器/鏈接器的額外指令，那麼描述這個擴充非常簡單："

#: ../../distutils/setupscript.rst:152
#, fuzzy
msgid ""
"The :class:`Extension` class can be imported from :mod:`distutils.core` "
"along with :func:`setup`.  Thus, the setup script for a module distribution "
"that contains only this one extension and nothing else might be::"
msgstr ""
":class:`Extension` 類可以從 :mod:`distutils.core` 與 :func:`setup` "
"一起導入。因此，僅包含這個擴充而沒有其他任何內容的模組分發的安裝腳本可能是："

#: ../../distutils/setupscript.rst:162
#, fuzzy
msgid ""
"The :class:`Extension` class (actually, the underlying extension-building "
"machinery implemented by the :command:`build_ext` command) supports a great "
"deal of flexibility in describing Python extensions, which is explained in "
"the following sections."
msgstr ""
":class:`Extension` 類（實際上，是由 :command:`build_ext` "
"命令實作的底層擴充構建機制）在描述 Python "
"擴充方面提供了極大的靈活性，這將在以下部分中進行解釋。"

#: ../../distutils/setupscript.rst:169
#, fuzzy
msgid "Extension names and packages"
msgstr "擴充名和包"

#: ../../distutils/setupscript.rst:171
#, fuzzy
msgid ""
"The first argument to the :class:`~distutils.core.Extension` constructor is "
"always the name of the extension, including any package names.  For "
"example, ::"
msgstr ":class:`~distutils.core.Extension` "
"構造函式的第一個參數始終是擴充的名稱，包括任何包名稱。例如， ：："

#: ../../distutils/setupscript.rst:176
#, fuzzy
msgid "describes an extension that lives in the root package, while ::"
msgstr "描述存在於根包中的擴充，而 ::"

#: ../../distutils/setupscript.rst:180
#, fuzzy
msgid ""
"describes the same extension in the :mod:`pkg` package.  The source files "
"and resulting object code are identical in both cases; the only difference "
"is where in the filesystem (and therefore where in Python's namespace "
"hierarchy) the resulting extension lives."
msgstr ""
"在 :mod:`pkg` 包中描述了相同的擴充。兩種情況下的源文件和生成的目標程式碼都是"
"相同的；唯一的區別是生成的擴充在文件系統中的位置（因此在 Python "
"的命名空間層次結構中的位置）。"

#: ../../distutils/setupscript.rst:185
#, fuzzy
msgid ""
"If you have a number of extensions all in the same package (or all under the "
"same base package), use the ``ext_package`` keyword argument to :func:"
"`setup`.  For example, ::"
msgstr ""
"如果您有多個擴充都在同一個包中（或都在同一個基礎包下），請使用 "
"``ext_package`` 關鍵字參數到 :func:`setup`。例如， ：："

#: ../../distutils/setupscript.rst:195
#, fuzzy
msgid ""
"will compile :file:`foo.c` to the extension :mod:`pkg.foo`, and :file:`bar."
"c` to :mod:`pkg.subpkg.bar`."
msgstr ""
"會將 :file:`foo.c` 編譯為擴充名 :mod:`pkg.foo`，將 :file:`bar.c` 編譯為 :mod:`pkg"
".subpkg.bar`。"

#: ../../distutils/setupscript.rst:200
#, fuzzy
msgid "Extension source files"
msgstr "擴充源文件"

#: ../../distutils/setupscript.rst:202
#, fuzzy
msgid ""
"The second argument to the :class:`~distutils.core.Extension` constructor is "
"a list of source files.  Since the Distutils currently only support C, C++, "
"and Objective-C extensions, these are normally C/C++/Objective-C source "
"files.  (Be sure to use appropriate extensions to distinguish C++ source "
"files: :file:`.cc` and :file:`.cpp` seem to be recognized by both Unix and "
"Windows compilers.)"
msgstr ""
":class:`~distutils.core.Extension` 構造函式的第二個參數是源文件列表。由於 "
"Distutils 目前僅支援 C、C++ 和 Objective-C 擴充，因此這些通常是 C/"
"C++/Objective-C 源文件。 （確保使用適當的擴充名來區分 C++ 源文件：:file:`.cc`"
" 和 :file:`.cpp` 似乎可以被 Unix 和 Windows 編譯器識別。）"

#: ../../distutils/setupscript.rst:209
#, fuzzy
msgid ""
"However, you can also include SWIG interface (:file:`.i`) files in the list; "
"the :command:`build_ext` command knows how to deal with SWIG extensions: it "
"will run SWIG on the interface file and compile the resulting C/C++ file "
"into your extension."
msgstr ""
"但是，您也可以在列表中包含 SWIG 介面 (:file:`.i`) 文件； :command:`build_ext`"
" 命令知道如何處理 SWIG 擴充：它將在介面文件上運行 SWIG，並將生成的 C/C++ "
"文件編譯到您的擴充中。"

#: ../../distutils/setupscript.rst:216
#, fuzzy
msgid ""
"This warning notwithstanding, options to SWIG can be currently passed like "
"this::"
msgstr "儘管有此警告，但 SWIG 的選項當前可以像這樣傳遞："

#: ../../distutils/setupscript.rst:225
#, fuzzy
msgid "Or on the commandline like this::"
msgstr "或者在這樣的命令列上::"

#: ../../distutils/setupscript.rst:229
#, fuzzy
msgid ""
"On some platforms, you can include non-source files that are processed by "
"the compiler and included in your extension.  Currently, this just means "
"Windows message text (:file:`.mc`) files and resource definition (:file:`."
"rc`) files for Visual C++. These will be compiled to binary resource (:file:"
"`.res`) files and linked into the executable."
msgstr ""
"在某些平台上，您可以包含由編譯器處理並包含在您的擴充中的非源文件。目前，"
"這僅意味著 Windows 消息文本 (:file:`.mc`) 文件和 Visual C++ 的資源定義 "
"(:file:`.rc`) 文件。這些將被編譯為二進位資源 (:file:`.res`) "
"文件並鏈接到可執行文件中。"

#: ../../distutils/setupscript.rst:237
#, fuzzy
msgid "Preprocessor options"
msgstr "預處理器選項"

#: ../../distutils/setupscript.rst:239
#, fuzzy
msgid ""
"Three optional arguments to :class:`~distutils.core.Extension` will help if "
"you need to specify include directories to search or preprocessor macros to "
"define/undefine: ``include_dirs``, ``define_macros``, and ``undef_macros``."
msgstr ""
":class:`~distutils.core.Extension` 的三個可選參數將在您需要指定要搜索的包含目"
"錄或要定義/取消定義的預處理器巨集時提供幫助：``include_dirs``、``define_macro"
"s`` 和 ``undef_macros ``。"

#: ../../distutils/setupscript.rst:243
#, fuzzy
msgid ""
"For example, if your extension requires header files in the :file:`include` "
"directory under your distribution root, use the ``include_dirs`` option::"
msgstr "例如，如果您的擴充程式需要位於分髮根目錄下的 :file:`include` 目錄中的標頭檔，"
"請使用 ``include_dirs`` 選項："

#: ../../distutils/setupscript.rst:248
#, fuzzy
msgid ""
"You can specify absolute directories there; if you know that your extension "
"will only be built on Unix systems with X11R6 installed to :file:`/usr`, you "
"can get away with ::"
msgstr "您可以在那裡指定絕對目錄；如果你知道你的擴充只會在 Unix 系統上構建，X11R6 "
"安裝到 :file:`/usr`，你可以逃脫 ::"

#: ../../distutils/setupscript.rst:254
#, fuzzy
msgid ""
"You should avoid this sort of non-portable usage if you plan to distribute "
"your code: it's probably better to write C code like  ::"
msgstr "如果您打算分發您的程式碼，您應該避免這種不可移植的用法：最好編寫像 :: 這樣的 "
"C 程式碼"

#: ../../distutils/setupscript.rst:259
#, fuzzy
msgid ""
"If you need to include header files from some other Python extension, you "
"can take advantage of the fact that header files are installed in a "
"consistent way by the Distutils :command:`install_headers` command.  For "
"example, the Numerical Python header files are installed (on a standard Unix "
"installation) to :file:`/usr/local/include/python1.5/Numerical`. (The exact "
"location will differ according to your platform and Python installation.)  "
"Since the Python include directory---\\ :file:`/usr/local/include/python1.5` "
"in this case---is always included in the search path when building Python "
"extensions, the best approach is to write C code like  ::"
msgstr ""
"如果您需要包含來自其他 Python 擴充的標頭檔，您可以利用 Distutils "
"命令以一致的方式安裝標頭檔這一事實。例如，Numerical Python 標頭檔安裝（"
"在標準 Unix 安裝上）到 :file:`/usr/local/include/python1.5/Numerical`。 （"
"確切位置將根據您的平台和 Python 安裝而有所不同。）由於 Python 包含目錄---\\ "
":file:`/usr/local/include/python1.5` 在這種情況下---總是包含在構建 Python "
"擴充時的搜索路徑，最好的方法是編寫像 :: 這樣的 C 程式碼"

#: ../../distutils/setupscript.rst:271
#, fuzzy
msgid ""
"If you must put the :file:`Numerical` include directory right into your "
"header search path, though, you can find that directory using the Distutils :"
"mod:`distutils.sysconfig` module::"
msgstr ""
"但是，如果您必須將 :file:`Numerical` include 目錄直接放入您的標題搜索路徑中，"
"您可以使用 Distutils :mod:`distutils.sysconfig` 模組::找到該目錄："

#: ../../distutils/setupscript.rst:281
#, fuzzy
msgid ""
"Even though this is quite portable---it will work on any Python "
"installation, regardless of platform---it's probably easier to just write "
"your C code in the sensible way."
msgstr "儘管這是非常可移植的——它可以在任何 Python 安裝上工作，無論平台如何——"
"以合理的方式編寫 C 程式碼可能更容易。"

#: ../../distutils/setupscript.rst:285
#, fuzzy
msgid ""
"You can define and undefine pre-processor macros with the ``define_macros`` "
"and ``undef_macros`` options. ``define_macros`` takes a list of ``(name, "
"value)`` tuples, where ``name`` is the name of the macro to define (a "
"string) and ``value`` is its value: either a string or ``None``.  (Defining "
"a macro ``FOO`` to ``None`` is the equivalent of a bare ``#define FOO`` in "
"your C source: with most compilers, this sets ``FOO`` to the string ``1``.)  "
"``undef_macros`` is just a list of macros to undefine."
msgstr ""
"您可以使用“define_macros”和“undef_macros”選項定義和取消定義預處理器巨集。 "
"``define_macros`` 採用``(name, value)`` 元組列表，其中``name`` "
"是要定義的巨集的名稱（字串），``value`` 是它的值：要么字串或 ``None`` 。 （將巨集 "
"``FOO`` 定義為 ``None`` 等同於 C 源程式碼中的裸``#define "
"FOO``：對於大多數編譯器，這會將 ``FOO`` 設定為字串 ``1 ``.) ``undef_macros`` "
"只是要取消定義的巨集列表。"

#: ../../distutils/setupscript.rst:293
msgid "For example::"
msgstr ""
"舉例來說：\n"
"\n"
"::"

#: ../../distutils/setupscript.rst:300
#, fuzzy
msgid "is the equivalent of having this at the top of every C source file::"
msgstr "相當於在每個 C 源文件的頂部都有它::"

#: ../../distutils/setupscript.rst:309
#, fuzzy
msgid "Library options"
msgstr "庫選項"

#: ../../distutils/setupscript.rst:311
#, fuzzy
msgid ""
"You can also specify the libraries to link against when building your "
"extension, and the directories to search for those libraries.  The "
"``libraries`` option is a list of libraries to link against, "
"``library_dirs`` is a list of directories to search for libraries at  link-"
"time, and ``runtime_library_dirs`` is a list of directories to  search for "
"shared (dynamically loaded) libraries at run-time."
msgstr ""
"您還可以指定構建擴充時要鏈接的庫，以及要搜索這些庫的目錄。 ``libraries`` "
"選項是要鏈接的庫列表，``library_dirs`` "
"是在鏈接時搜索庫的目錄列表，``runtime_library_dirs`` "
"是要搜索共享目錄的目錄列表（動態加載）庫在運行時。"

#: ../../distutils/setupscript.rst:317
#, fuzzy
msgid ""
"For example, if you need to link against libraries known to be in the "
"standard library search path on target systems ::"
msgstr "例如，如果您需要鏈接已知位於目標系統上標準庫搜索路徑中的庫："

#: ../../distutils/setupscript.rst:323
#, fuzzy
msgid ""
"If you need to link with libraries in a non-standard location, you'll have "
"to include the location in ``library_dirs``::"
msgstr "如果您需要鏈接非標準位置的庫，則必須將該位置包含在 ``library_dirs``::"

#: ../../distutils/setupscript.rst:330
#, fuzzy
msgid ""
"(Again, this sort of non-portable construct should be avoided if you intend "
"to distribute your code.)"
msgstr "（同樣，如果你打算分發你的程式碼，應該避免這種不可移植的結構。）"

#: ../../distutils/setupscript.rst:337
#, fuzzy
msgid "Other options"
msgstr "其他選項"

#: ../../distutils/setupscript.rst:339
#, fuzzy
msgid ""
"There are still some other options which can be used to handle special cases."
msgstr "還有一些其他選項可用於處理特殊情況。"

#: ../../distutils/setupscript.rst:341
#, fuzzy
msgid ""
"The ``optional`` option is a boolean; if it is true, a build failure in the "
"extension will not abort the build process, but instead simply not install "
"the failing extension."
msgstr "``optional`` 選項是一個布爾值；如果為真，則擴充中的構建失敗不會中止構建過程，"
"而只是不安裝失敗的擴充。"

#: ../../distutils/setupscript.rst:345
#, fuzzy
msgid ""
"The ``extra_objects`` option is a list of object files to be passed to the "
"linker. These files must not have extensions, as the default extension for "
"the compiler is used."
msgstr "``extra_objects`` 選項是要傳遞給鏈接器的目標文件列表。這些文件不能有擴充名，"
"因為使用編譯器的預設擴充名。"

#: ../../distutils/setupscript.rst:349
#, fuzzy
msgid ""
"``extra_compile_args`` and ``extra_link_args`` can be used to specify "
"additional command line options for the respective compiler and linker "
"command lines."
msgstr ""
"``extra_compile_args`` 和 ``extra_link_args`` "
"可用於為相應的編譯器和鏈接器命令列指定額外的命令列選項。"

#: ../../distutils/setupscript.rst:353
#, fuzzy
msgid ""
"``export_symbols`` is only useful on Windows.  It can contain a list of "
"symbols (functions or variables) to be exported. This option is not needed "
"when building compiled extensions: Distutils  will automatically add "
"``initmodule`` to the list of exported symbols."
msgstr ""
"``export_symbols`` 僅在 Windows 上有用。它可以包含要導出的符號列表（函式或變"
"數）。構建編譯擴充時不需要此選項：Distutils 會自動將 ``initmodule`` "
"新增到導出符號列表中。"

#: ../../distutils/setupscript.rst:358
#, fuzzy
msgid ""
"The ``depends`` option is a list of files that the extension depends on (for "
"example header files). The build command will call the compiler on the "
"sources to rebuild extension if any on this files has been modified since "
"the previous build."
msgstr ""
"``depends`` 選項是擴充所依賴的文件列表（例如標頭檔）。如果自上次構建以來此文"
"件中的任何內容已被修改，構建命令將呼叫源上的編譯器來重建擴充。"

#: ../../distutils/setupscript.rst:364
#, fuzzy
msgid "Relationships between Distributions and Packages"
msgstr "發行版和包之間的關係"

#: ../../distutils/setupscript.rst:366
#, fuzzy
msgid "A distribution may relate to packages in three specific ways:"
msgstr "發行版可能以三種特定方式與包相關："

#: ../../distutils/setupscript.rst:368
#, fuzzy
msgid "It can require packages or modules."
msgstr "它可能需要包或模組。"

#: ../../distutils/setupscript.rst:370
#, fuzzy
msgid "It can provide packages or modules."
msgstr "它可以提供包或模組。"

#: ../../distutils/setupscript.rst:372
#, fuzzy
msgid "It can obsolete packages or modules."
msgstr "它可以廢棄包或模組。"

#: ../../distutils/setupscript.rst:374
#, fuzzy
msgid ""
"These relationships can be specified using keyword arguments to the :func:"
"`distutils.core.setup` function."
msgstr "這些關係可以使用 distutils.core.setup 函式的關鍵字參數來指定。"

#: ../../distutils/setupscript.rst:377
#, fuzzy
msgid ""
"Dependencies on other Python modules and packages can be specified by "
"supplying the *requires* keyword argument to :func:`setup`. The value must "
"be a list of strings.  Each string specifies a package that is required, and "
"optionally what versions are sufficient."
msgstr ""
"可以通過向 :func:`setup` 提供 *requires* 關鍵字參數來指定對其他 Python 模組和"
"包的依賴關係。該值必須是字串列表。每個字串指定一個所需的包，以及可選的版本是"
"足夠的。"

#: ../../distutils/setupscript.rst:382
#, fuzzy
msgid ""
"To specify that any version of a module or package is required, the string "
"should consist entirely of the module or package name. Examples include "
"``'mymodule'`` and ``'xml.parsers.expat'``."
msgstr "要指定需要模組或包的任何版本，字串應完全由模組或包名稱組成。示例包括 ``'mymodule'``"
" 和 ``'xml.parsers.expat'``。"

#: ../../distutils/setupscript.rst:386
#, fuzzy
msgid ""
"If specific versions are required, a sequence of qualifiers can be supplied "
"in parentheses.  Each qualifier may consist of a comparison operator and a "
"version number.  The accepted comparison operators are::"
msgstr "如果需要特定版本，可以在括號中提供一系列限定符。每個限定符可能由一個比較運算"
"符和一個版本號組成。接受的比較運算符是："

#: ../../distutils/setupscript.rst:393
#, fuzzy
msgid ""
"These can be combined by using multiple qualifiers separated by commas (and "
"optional whitespace).  In this case, all of the qualifiers must be matched; "
"a logical AND is used to combine the evaluations."
msgstr "這些可以通過使用以逗號（和可選的空格）分隔的多個限定符來組合。在這種情況下，"
"必須匹配所有限定符；邏輯 AND 用於合併評估。"

#: ../../distutils/setupscript.rst:397
#, fuzzy
msgid "Let's look at a bunch of examples:"
msgstr "讓我們看一堆例子："

#: ../../distutils/setupscript.rst:400
#, fuzzy
msgid "Requires Expression"
msgstr "需要表達"

#: ../../distutils/setupscript.rst:400 ../../distutils/setupscript.rst:418
#, fuzzy
msgid "Explanation"
msgstr "解釋"

#: ../../distutils/setupscript.rst:402
msgid "``==1.0``"
msgstr "``==1.0``"

#: ../../distutils/setupscript.rst:402
#, fuzzy
msgid "Only version ``1.0`` is compatible"
msgstr "只有版本 ``1.0`` 相容"

#: ../../distutils/setupscript.rst:404
msgid "``>1.0, !=1.5.1, <2.0``"
msgstr "``>1.0, !=1.5.1, <2.0``"

#: ../../distutils/setupscript.rst:404
#, fuzzy
msgid ""
"Any version after ``1.0`` and before ``2.0`` is compatible, except ``1.5.1``"
msgstr "``1.0`` 之後和 ``2.0`` 之前的任何版本都是相容的，除了 ``1.5.1``"

#: ../../distutils/setupscript.rst:408
#, fuzzy
msgid ""
"Now that we can specify dependencies, we also need to be able to specify "
"what we provide that other distributions can require.  This is done using "
"the *provides* keyword argument to :func:`setup`. The value for this keyword "
"is a list of strings, each of which names a Python module or package, and "
"optionally identifies the version.  If the version is not specified, it is "
"assumed to match that of the distribution."
msgstr ""
"現在我們可以指定依賴項，我們還需要能夠指定我們提供的其他發行版可能需要的內容"
"。這是使用 :func:`setup` 的 *provides* "
"關鍵字參數完成的。此關鍵字的值是一個字串列表，每個字串命名一個 Python "
"模組或包，並可選擇標識版本。如果未指定版本，則假定與發行版匹配。"

#: ../../distutils/setupscript.rst:415
#, fuzzy
msgid "Some examples:"
msgstr "一些例子："

#: ../../distutils/setupscript.rst:418
#, fuzzy
msgid "Provides Expression"
msgstr "提供表達"

#: ../../distutils/setupscript.rst:420
msgid "``mypkg``"
msgstr "``mypkg``"

#: ../../distutils/setupscript.rst:420
#, fuzzy
msgid "Provide ``mypkg``, using the distribution version"
msgstr "提供``mypkg``，使用發行版"

#: ../../distutils/setupscript.rst:423
msgid "``mypkg (1.1)``"
msgstr "``mypkg (1.1)``"

#: ../../distutils/setupscript.rst:423
#, fuzzy
msgid "Provide ``mypkg`` version 1.1, regardless of the distribution version"
msgstr "提供 ``mypkg`` 版本 1.1，不管發行版本"

#: ../../distutils/setupscript.rst:427
#, fuzzy
msgid ""
"A package can declare that it obsoletes other packages using the *obsoletes* "
"keyword argument.  The value for this is similar to that of the *requires* "
"keyword: a list of strings giving module or package specifiers.  Each "
"specifier consists of a module or package name optionally followed by one or "
"more version qualifiers.  Version qualifiers are given in parentheses after "
"the module or package name."
msgstr ""
"一個包可以使用 *obsoletes* 關鍵字參數聲明它廢棄了其他包。這個值類似於 "
"*requires* 關鍵字的值：一個字串列表，給出模組或包說明符。每個說明符都包含一個"
"模組或包名稱，可選地後跟一個或多個版本限定符。版本限定符在模組或包名稱後的括"
"號中給出。"

#: ../../distutils/setupscript.rst:434
#, fuzzy
msgid ""
"The versions identified by the qualifiers are those that are obsoleted by "
"the distribution being described.  If no qualifiers are given, all versions "
"of the named module or package are understood to be obsoleted."
msgstr "由限定符標識的版本是被描述的發行版廢棄的版本。如果沒有給出限定符，則指定模組"
"或包的所有版本都被理解為已過時。"

#: ../../distutils/setupscript.rst:441
#, fuzzy
msgid "Installing Scripts"
msgstr "安裝腳本"

#: ../../distutils/setupscript.rst:443
#, fuzzy
msgid ""
"So far we have been dealing with pure and non-pure Python modules, which are "
"usually not run by themselves but imported by scripts."
msgstr "到目前為止，我們一直在處理純和非純 Python "
"模組，它們通常不是自己運行的，而是通過腳本導入的。"

#: ../../distutils/setupscript.rst:446
#, fuzzy
msgid ""
"Scripts are files containing Python source code, intended to be started from "
"the command line.  Scripts don't require Distutils to do anything very "
"complicated. The only clever feature is that if the first line of the script "
"starts with ``#!`` and contains the word \"python\", the Distutils will "
"adjust the first line to refer to the current interpreter location. By "
"default, it is replaced with the current interpreter location.  The :option:"
"`!--executable` (or :option:`!-e`) option will allow the interpreter path to "
"be explicitly overridden."
msgstr ""
"腳本是包含 Python 源程式碼的文件，旨在從命令列啟動。腳本不需要 Distutils "
"來做任何非常複雜的事情。唯一聰明的特點是，如果腳本的第一行以``#!`` "
"開頭並包含單詞 ``python``，Distutils "
"將調整第一行以引用當前直譯器位置。預設情況下，它被替換為當前直譯器位置。 "
":option:`!--executable`（或 :option:`!-e`）選項將允許顯式覆蓋直譯器路徑。"

#: ../../distutils/setupscript.rst:454
#, fuzzy
msgid ""
"The ``scripts`` option simply is a list of files to be handled in this way.  "
"From the PyXML setup script::"
msgstr "``scripts`` 選項只是以這種方式處理的文件列表。從 PyXML 設定腳本::"

#: ../../distutils/setupscript.rst:461
#, fuzzy
msgid ""
"All the scripts will also be added to the ``MANIFEST`` file if no template "
"is provided.  See :ref:`manifest`."
msgstr "如果沒有提供模板，所有腳本也將新增到 ``MANIFEST`` "
"文件中。請參閱 :ref:`清單`。"

#: ../../distutils/setupscript.rst:469
#, fuzzy
msgid "Installing Package Data"
msgstr "安裝包資料"

#: ../../distutils/setupscript.rst:471
#, fuzzy
msgid ""
"Often, additional files need to be installed into a package.  These files "
"are often data that's closely related to the package's implementation, or "
"text files containing documentation that might be of interest to programmers "
"using the package.  These files are called :dfn:`package data`."
msgstr ""
"通常，需要將其他文件安裝到包中。這些文件通常是與包的實作密切相關的資料，或者"
"是包含使用該包的程式員可能感興趣的文檔的文本文件。這些文件稱為 :dfn:`package "
"data`。"

#: ../../distutils/setupscript.rst:476
#, fuzzy
msgid ""
"Package data can be added to packages using the ``package_data`` keyword "
"argument to the :func:`setup` function.  The value must be a mapping from "
"package name to a list of relative path names that should be copied into the "
"package.  The paths are interpreted as relative to the directory containing "
"the package (information from the ``package_dir`` mapping is used if "
"appropriate); that is, the files are expected to be part of the package in "
"the source directories. They may contain glob patterns as well."
msgstr ""
"可以使用 :func:`setup` 函式的 ``package_data`` 關鍵字參數將包資料新增到包中。"
"該值必須是從包名稱到應複製到包中的相對路徑名列表的映射。路徑被解釋為相對於包"
"含包的目錄（如果合適，使用來自 ``package_dir`` "
"映射的資訊）；也就是說，這些文件應該是源目錄中包的一部分。它們也可能包含 "
"glob 模式。"

#: ../../distutils/setupscript.rst:484
#, fuzzy
msgid ""
"The path names may contain directory portions; any necessary directories "
"will be created in the installation."
msgstr "路徑名可能包含目錄部分；任何必要的目錄都將在安裝中建立。"

#: ../../distutils/setupscript.rst:487
#, fuzzy
msgid ""
"For example, if a package should contain a subdirectory with several data "
"files, the files can be arranged like this in the source tree::"
msgstr "例如，如果一個包應該包含一個包含多個資料文件的子目錄，那麼這些文件在源程式碼"
"樹中可以這樣排列："

#: ../../distutils/setupscript.rst:500
#, fuzzy
msgid "The corresponding call to :func:`setup` might be::"
msgstr "對 :func:`setup` 的相應呼叫可能是："

#: ../../distutils/setupscript.rst:509
#, fuzzy
msgid ""
"All the files that match ``package_data`` will be added to the ``MANIFEST`` "
"file if no template is provided.  See :ref:`manifest`."
msgstr "如果沒有提供模板，所有匹配 ``package_data`` 的文件都將被新增到 ``MANIFEST`` "
"文件中。請參閱 :ref:`清單`。"

#: ../../distutils/setupscript.rst:517
#, fuzzy
msgid "Installing Additional Files"
msgstr "安裝附加文件"

#: ../../distutils/setupscript.rst:519
#, fuzzy
msgid ""
"The ``data_files`` option can be used to specify additional files needed by "
"the module distribution: configuration files, message catalogs, data files, "
"anything which doesn't fit in the previous categories."
msgstr "``data_files`` 選項可用於指定模組分發所需的其他文件：配置文件、消息目錄、資料"
"文件，以及任何不屬於上述類別的文件。"

#: ../../distutils/setupscript.rst:523
#, fuzzy
msgid ""
"``data_files`` specifies a sequence of (*directory*, *files*) pairs in the "
"following way::"
msgstr "``data_files`` 以下列方式指定一系列 (*directory*, *files*) 對："

#: ../../distutils/setupscript.rst:531
#, fuzzy
msgid ""
"Each (*directory*, *files*) pair in the sequence specifies the installation "
"directory and the files to install there."
msgstr "序列中的每個 (*directory*, *files*) 對指定安裝目錄和要安裝在那裡的文件。"

#: ../../distutils/setupscript.rst:534
#, fuzzy
msgid ""
"Each file name in *files* is interpreted relative to the :file:`setup.py` "
"script at the top of the package source distribution. Note that you can "
"specify the directory where the data files will be installed, but you cannot "
"rename the data files themselves."
msgstr ""
"*files* 中的每個文件名都相對於包源分發頂部的 :file:`setup.py` 腳本進行解釋。"
"請注意，您可以指定安裝資料文件的目錄，但不能重命名資料文件本身。"

#: ../../distutils/setupscript.rst:539
#, fuzzy
msgid ""
"The *directory* should be a relative path. It is interpreted relative to the "
"installation prefix (Python's ``sys.prefix`` for system installations; "
"``site.USER_BASE`` for user installations). Distutils allows *directory* to "
"be an absolute installation path, but this is discouraged since it is "
"incompatible with the wheel packaging format. No directory information from "
"*files* is used to determine the final location of the installed file; only "
"the name of the file is used."
msgstr ""
"*directory* 應該是相對路徑。它相對於安裝前綴進行解釋（Python 的 ``sys."
"prefix`` 用於系統安裝；``site.USER_BASE`` 用於使用者安裝）。 Distutils 允許 "
"*directory* 為絕對安裝路徑，但不鼓勵這樣做，因為它與 wheel 打包格式不相容。 "
"*files* 中沒有目錄資訊用於確定安裝文件的最終位置；僅使用文件名。"

#: ../../distutils/setupscript.rst:547
#, fuzzy
msgid ""
"You can specify the ``data_files`` options as a simple sequence of files "
"without specifying a target directory, but this is not recommended, and the :"
"command:`install` command will print a warning in this case. To install data "
"files directly in the target directory, an empty string should be given as "
"the directory."
msgstr ""
"您可以將 ``data_files`` "
"選項指定為簡單的文件序列而不指定目標目錄，但不推薦這樣做，在這種情況下 "
":command:`install` "
"命令將印出警告。要直接在目標目錄中安裝資料文件，應給出一個空字串作為目錄。"

#: ../../distutils/setupscript.rst:553
#, fuzzy
msgid ""
"All the files that match ``data_files`` will be added to the ``MANIFEST`` "
"file if no template is provided.  See :ref:`manifest`."
msgstr "如果沒有提供模板，所有匹配 ``data_files`` 的文件都將被新增到 ``MANIFEST`` "
"文件中。請參閱 :ref:`清單`。"

#: ../../distutils/setupscript.rst:561
#, fuzzy
msgid "Additional meta-data"
msgstr "附加元資料"

#: ../../distutils/setupscript.rst:563
#, fuzzy
msgid ""
"The setup script may include additional meta-data beyond the name and "
"version. This information includes:"
msgstr "安裝腳本可能包含除名稱和版本之外的其他元資料。這些資訊包括："

#: ../../distutils/setupscript.rst:567
#, fuzzy
msgid "Meta-Data"
msgstr "元資料"

#: ../../distutils/setupscript.rst:567
msgid "Description"
msgstr "描述"

#: ../../distutils/setupscript.rst:567
#, fuzzy
msgid "Value"
msgstr "價值"

#: ../../distutils/setupscript.rst:567
msgid "Notes"
msgstr "註解"

#: ../../distutils/setupscript.rst:569
msgid "``name``"
msgstr "``name``"

#: ../../distutils/setupscript.rst:569
#, fuzzy
msgid "name of the package"
msgstr "包裹名稱"

#: ../../distutils/setupscript.rst:569 ../../distutils/setupscript.rst:571
#: ../../distutils/setupscript.rst:573 ../../distutils/setupscript.rst:578
#: ../../distutils/setupscript.rst:585 ../../distutils/setupscript.rst:601
#, fuzzy
msgid "short string"
msgstr "短字串"

#: ../../distutils/setupscript.rst:569 ../../distutils/setupscript.rst:583
msgid "\\(1)"
msgstr "\\(1)"

#: ../../distutils/setupscript.rst:571
msgid "``version``"
msgstr "``version``"

#: ../../distutils/setupscript.rst:571
#, fuzzy
msgid "version of this release"
msgstr "此版本的版本"

#: ../../distutils/setupscript.rst:571
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../../distutils/setupscript.rst:573
msgid "``author``"
msgstr "``author``"

#: ../../distutils/setupscript.rst:573
#, fuzzy
msgid "package author's name"
msgstr "包作者的名字"

#: ../../distutils/setupscript.rst:573 ../../distutils/setupscript.rst:575
#: ../../distutils/setupscript.rst:578 ../../distutils/setupscript.rst:580
msgid "\\(3)"
msgstr "\\(3)"

#: ../../distutils/setupscript.rst:575
msgid "``author_email``"
msgstr "``author_email``"

#: ../../distutils/setupscript.rst:575
#, fuzzy
msgid "email address of the package author"
msgstr "包作者的電子郵件地址"

#: ../../distutils/setupscript.rst:575 ../../distutils/setupscript.rst:580
#, fuzzy
msgid "email address"
msgstr "電子郵件地址"

#: ../../distutils/setupscript.rst:578
msgid "``maintainer``"
msgstr "``maintainer``"

#: ../../distutils/setupscript.rst:578
#, fuzzy
msgid "package maintainer's name"
msgstr "包維護者的名字"

#: ../../distutils/setupscript.rst:580
msgid "``maintainer_email``"
msgstr "``maintainer_email``"

#: ../../distutils/setupscript.rst:580
#, fuzzy
msgid "email address of the package maintainer"
msgstr "包維護者的電子郵件地址"

#: ../../distutils/setupscript.rst:583
msgid "``url``"
msgstr "``url``"

#: ../../distutils/setupscript.rst:583
#, fuzzy
msgid "home page for the package"
msgstr "包的主頁"

#: ../../distutils/setupscript.rst:583 ../../distutils/setupscript.rst:592
msgid "URL"
msgstr "URL"

#: ../../distutils/setupscript.rst:585
msgid "``description``"
msgstr "``description``"

#: ../../distutils/setupscript.rst:585
#, fuzzy
msgid "short, summary description of the package"
msgstr "包的簡短摘要描述"

#: ../../distutils/setupscript.rst:589
msgid "``long_description``"
msgstr "``long_description``"

#: ../../distutils/setupscript.rst:589
#, fuzzy
msgid "longer description of the package"
msgstr "包的詳細描述"

#: ../../distutils/setupscript.rst:589
#, fuzzy
msgid "long string"
msgstr "長串"

#: ../../distutils/setupscript.rst:589
msgid "\\(4)"
msgstr "\\(4)"

#: ../../distutils/setupscript.rst:592
msgid "``download_url``"
msgstr "``download_url``"

#: ../../distutils/setupscript.rst:592
#, fuzzy
msgid "location where the package may be downloaded"
msgstr "可以下載包的位置"

#: ../../distutils/setupscript.rst:595
msgid "``classifiers``"
msgstr "``classifiers``"

#: ../../distutils/setupscript.rst:595
#, fuzzy
msgid "a list of classifiers"
msgstr "分類器列表"

#: ../../distutils/setupscript.rst:595 ../../distutils/setupscript.rst:597
#: ../../distutils/setupscript.rst:599
#, fuzzy
msgid "list of strings"
msgstr "字串列表"

#: ../../distutils/setupscript.rst:595
msgid "(6)(7)"
msgstr "(6)(7)"

#: ../../distutils/setupscript.rst:597
msgid "``platforms``"
msgstr "``platforms``"

#: ../../distutils/setupscript.rst:597
#, fuzzy
msgid "a list of platforms"
msgstr "平台列表"

#: ../../distutils/setupscript.rst:597 ../../distutils/setupscript.rst:599
msgid "(6)(8)"
msgstr "(6)(8)"

#: ../../distutils/setupscript.rst:599
msgid "``keywords``"
msgstr "``keywords``"

#: ../../distutils/setupscript.rst:599
#, fuzzy
msgid "a list of keywords"
msgstr "關鍵字列表"

#: ../../distutils/setupscript.rst:601
msgid "``license``"
msgstr "``license``"

#: ../../distutils/setupscript.rst:601
#, fuzzy
msgid "license for the package"
msgstr "包的許可證"

#: ../../distutils/setupscript.rst:601
msgid "\\(5)"
msgstr "\\(5)"

#: ../../distutils/setupscript.rst:604
msgid "Notes:"
msgstr "註解："

#: ../../distutils/setupscript.rst:607
#, fuzzy
msgid "These fields are required."
msgstr "這些欄位是必需的。"

#: ../../distutils/setupscript.rst:610
#, fuzzy
msgid ""
"It is recommended that versions take the form *major.minor[.patch[.sub]]*."
msgstr "建議版本採用 *major.minor[.patch[.sub]]* 的形式。"

#: ../../distutils/setupscript.rst:613
#, fuzzy
msgid ""
"Either the author or the maintainer must be identified. If maintainer is "
"provided, distutils lists it as the author in :file:`PKG-INFO`."
msgstr "必須標識作者或維護者。如果提供了維護者，distutils 會將其列為 PKG-INFO "
"中的作者。"

#: ../../distutils/setupscript.rst:617
#, fuzzy
msgid ""
"The ``long_description`` field is used by PyPI when you publish a package, "
"to build its project page."
msgstr "PyPI 在發布包時使用 ``long_description`` 欄位來構建其項目頁面。"

#: ../../distutils/setupscript.rst:621
#, fuzzy
msgid ""
"The ``license`` field is a text indicating the license covering the package "
"where the license is not a selection from the \"License\" Trove classifiers. "
"See the ``Classifier`` field. Notice that there's a ``licence`` distribution "
"option which is deprecated but still acts as an alias for ``license``."
msgstr ""
"``license`` 欄位是一個文本，指示涵蓋包的許可證，其中許可證不是從“許可證”"
"Trove 分類器中選擇的。請參閱“分類器”欄位。請注意，有一個 ``licence`` "
"分發選項已被棄用，但仍充當 ``license`` 的別名。"

#: ../../distutils/setupscript.rst:628
#, fuzzy
msgid "This field must be a list."
msgstr "該欄位必須是一個列表。"

#: ../../distutils/setupscript.rst:631
#, fuzzy
msgid ""
"The valid classifiers are listed on `PyPI <https://pypi.org/classifiers>`_."
msgstr "有效的分類器列在`PyPI <https://pypi.org/classifiers>`_ 上。"

#: ../../distutils/setupscript.rst:635
#, fuzzy
msgid ""
"To preserve backward compatibility, this field also accepts a string. If you "
"pass a comma-separated string ``'foo, bar'``, it will be converted to "
"``['foo', 'bar']``, Otherwise, it will be converted to a list of one string."
msgstr ""
"為了保持向後相容性，該欄位還接受一個字串。如果你傳遞一個逗號分隔的字串``"
"'foo, bar'``，它將被轉換為``['foo', "
"'bar']``，否則，它將被轉換為一個字串列表。"

#: ../../distutils/setupscript.rst:641
#, fuzzy
msgid "'short string'"
msgstr "'短字串'"

#: ../../distutils/setupscript.rst:641
#, fuzzy
msgid "A single line of text, not more than 200 characters."
msgstr "單行文字，不超過200個字元。"

#: ../../distutils/setupscript.rst:645
#, fuzzy
msgid "'long string'"
msgstr "'長字串'"

#: ../../distutils/setupscript.rst:644
#, fuzzy
msgid ""
"Multiple lines of plain text in reStructuredText format (see http://docutils."
"sourceforge.net/)."
msgstr "reStructuredText 格式的多行純文本（參見 http://docutils.sourceforge.net/）。"

#: ../../distutils/setupscript.rst:648
#, fuzzy
msgid "'list of strings'"
msgstr "'字串列表'"

#: ../../distutils/setupscript.rst:648
#, fuzzy
msgid "See below."
msgstr "見下文。"

#: ../../distutils/setupscript.rst:650
#, fuzzy
msgid ""
"Encoding the version information is an art in itself. Python packages "
"generally adhere to the version format *major.minor[.patch][sub]*. The major "
"number is 0 for initial, experimental releases of software. It is "
"incremented for releases that represent major milestones in a package. The "
"minor number is incremented when important new features are added to the "
"package. The patch number increments when bug-fix releases are made. "
"Additional trailing version information is sometimes used to indicate sub-"
"releases.  These are \"a1,a2,...,aN\" (for alpha releases, where "
"functionality and API may change), \"b1,b2,...,bN\" (for beta releases, "
"which only fix bugs) and \"pr1,pr2,...,prN\" (for final pre-release release "
"testing). Some examples:"
msgstr ""
"編碼版本資訊本身就是一門藝術。 Python 包通常遵循版本格式 *major.minor[."
"patch][sub]*。對於軟件的初始實驗版本，主要編號為 0。對於代表包中主要里程碑的"
"版本，它會增加。當重要的新功能被新增到包中時，次要編號會增加。當發布錯誤修復"
"版本時，補丁號會增加。附加的尾隨版本資訊有時用於指示子版本。它們是“a1,a2,...,"
"aN”（對於 alpha 版本，功能和 API 可能會更改），“b1,b2,...,bN”（對於 beta "
"版本，僅修復錯誤）和 ``pr1`` ,pr2,...,prN”（用於最終預發布版本測試）。一些例子："

#: ../../distutils/setupscript.rst:662
msgid "0.1.0"
msgstr "0.1.0"

#: ../../distutils/setupscript.rst:662
#, fuzzy
msgid "the first, experimental release of a package"
msgstr "第一，包的實驗性發布"

#: ../../distutils/setupscript.rst:665
msgid "1.0.1a2"
msgstr "1.0.1a2"

#: ../../distutils/setupscript.rst:665
#, fuzzy
msgid "the second alpha release of the first patch version of 1.0"
msgstr "1.0 第一個補丁版本的第二個 alpha 版本"

#: ../../distutils/setupscript.rst:667
#, fuzzy
msgid "``classifiers`` must be specified in a list::"
msgstr "``分類器`` 必須在列表中指定::"

#: ../../distutils/setupscript.rst:688
#, fuzzy
msgid ""
":class:`~distutils.core.setup` now warns when ``classifiers``, ``keywords`` "
"or ``platforms`` fields are not specified as a list or a string."
msgstr ""
":class:`~distutils.core.setup` 現在會在 ``classifiers``、``keywords`` 或 "
"``platforms`` 欄位未指定為列表或字串時發出警告。"

#: ../../distutils/setupscript.rst:695
#, fuzzy
msgid "Debugging the setup script"
msgstr "除錯設定腳本"

#: ../../distutils/setupscript.rst:697
#, fuzzy
msgid ""
"Sometimes things go wrong, and the setup script doesn't do what the "
"developer wants."
msgstr "有時會出錯，安裝腳本不會按照開發人員的要求進行操作。"

#: ../../distutils/setupscript.rst:700
#, fuzzy
msgid ""
"Distutils catches any exceptions when running the setup script, and print a "
"simple error message before the script is terminated.  The motivation for "
"this behaviour is to not confuse administrators who don't know much about "
"Python and are trying to install a package.  If they get a big long "
"traceback from deep inside the guts of Distutils, they may think the package "
"or the Python installation is broken because they don't read all the way "
"down to the bottom and see that it's a permission problem."
msgstr ""
"Distutils "
"在運行安裝腳本時捕獲任何例外，並在腳本終止之前印出一條簡單的錯誤消息。"
"這種行為的動機是為了不讓不太了解 Python 並試圖安裝包的管理員感到困惑。"
"如果他們從 Distutils 的內部深處得到一個很長的追溯，他們可能會認為包或 Python "
"安裝被破壞了，因為他們沒有一直讀到底部並看到這是一個權限問題。"

#: ../../distutils/setupscript.rst:708
#, fuzzy
msgid ""
"On the other hand, this doesn't help the developer to find the cause of the "
"failure. For this purpose, the :envvar:`DISTUTILS_DEBUG` environment "
"variable can be set to anything except an empty string, and distutils will "
"now print detailed information about what it is doing, dump the full "
"traceback when an exception occurs, and print the whole command line when an "
"external program (like a C compiler) fails."
msgstr ""
"另一方面，這無助於開發人員找到失敗的原因。為此，可以將 "
":envvar:`DISTUTILS_DEBUG` 環境變數設定為空字串以外的任何值，distutils 現在將"
"印出有關它正在做什麼的詳細資訊，在發生例外時轉儲完整的回溯，並印出整個命令外"
"部程式（如 C 編譯器）失敗時的行。"
