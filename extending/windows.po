# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-05-21 17:35+0000\n"
"PO-Revision-Date: 2015-12-09 17:51+0000\n"
"Last-Translator: Liang-Bo Wang <me@liang2.tw>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../extending/windows.rst:8
msgid "Building C and C++ Extensions on Windows"
msgstr "在 Windows 上構建 C 和 C++ 擴充"

#: ../../extending/windows.rst:10
#, fuzzy
msgid ""
"This chapter briefly explains how to create a Windows extension module for "
"Python using Microsoft Visual C++, and follows with more detailed background "
"information on how it works.  The explanatory material is useful for both "
"the Windows programmer learning to build Python extensions and the Unix "
"programmer interested in producing software which can be successfully built "
"on both Unix and Windows."
msgstr ""
"本章簡要說明瞭如何使用 Microsoft Visual C++ 建立適用於 Python 的 Windows "
"擴充模組，隨後提供了有關其工作原理的更詳細的背景資訊。解釋性材料對於學習構建 "
"Python 擴充的 Windows 程式員和對生產可以在 Unix 和 Windows "
"上成功構建的軟件感興趣的 Unix 程式員都很有用。"

#: ../../extending/windows.rst:17
#, fuzzy
msgid ""
"Module authors are encouraged to use the distutils approach for building "
"extension modules, instead of the one described in this section. You will "
"still need the C compiler that was used to build Python; typically Microsoft "
"Visual C++."
msgstr ""
"鼓勵模組作者使用 distutils 方法來構建擴充模組，而不是本節中描述的方法。"
"您仍然需要用於構建 Python 的 C 編譯器；通常是 Microsoft Visual C++。"

#: ../../extending/windows.rst:24
#, fuzzy
msgid ""
"This chapter mentions a number of filenames that include an encoded Python "
"version number.  These filenames are represented with the version number "
"shown as ``XY``; in practice, ``'X'`` will be the major version number and "
"``'Y'`` will be the minor version number of the Python release you're "
"working with.  For example, if you are using Python 2.2.1, ``XY`` will "
"actually be ``22``."
msgstr ""
"本章提到了許多包含編碼的 Python "
"版本號的文件名。這些文件名用顯示為 ``XY``的版本號表示；實際上，``'X'`` "
"將是您正在使用的 Python 版本的主要版本號，而 ``'Y'`` 將是您正在使用的 Python "
"版本的次要版本號。例如，如果您使用的是 Python 2.2.1， ``XY``實際上是 ``22``。"

#: ../../extending/windows.rst:34
#, fuzzy
msgid "A Cookbook Approach"
msgstr "食譜方法"

#: ../../extending/windows.rst:36
#, fuzzy
msgid ""
"There are two approaches to building extension modules on Windows, just as "
"there are on Unix: use the :mod:`distutils` package to control the build "
"process, or do things manually.  The distutils approach works well for most "
"extensions; documentation on using :mod:`distutils` to build and package "
"extension modules is available in :ref:`distutils-index`.  If you find you "
"really need to do things manually, it may be instructive to study the "
"project file for the :source:`winsound <PCbuild/winsound.vcxproj>` standard "
"library module."
msgstr ""
"在 Windows 上有兩種構建擴充模組的方法，就像在 Unix 上一樣：使用 "
":mod:`distutils` 包來控制構建過程，或者手動執行操作。 distutils "
"方法適用於大多數擴充；有關使用 :mod:`distutils` 構建和打包擴充模組的文檔可在 "
":ref:`distutils-index` 中找到。如果您發現確實需要手動執行操作，那麼研究 "
":source:`winsound <PCbuild/winsound.vcxproj>` "
"標準庫模組的項目文件可能會有所幫助。"

#: ../../extending/windows.rst:48
#, fuzzy
msgid "Differences Between Unix and Windows"
msgstr "Unix 和 Windows 之間的區別"

#: ../../extending/windows.rst:53
#, fuzzy
msgid ""
"Unix and Windows use completely different paradigms for run-time loading of "
"code.  Before you try to build a module that can be dynamically loaded, be "
"aware of how your system works."
msgstr "Unix 和 Windows 使用完全不同的程式碼運行時加載範例。在您嘗試構建一個可以動態"
"加載的模組之前，請了解您的系統是如何工作的。"

#: ../../extending/windows.rst:57
#, fuzzy
msgid ""
"In Unix, a shared object (:file:`.so`) file contains code to be used by the "
"program, and also the names of functions and data that it expects to find in "
"the program.  When the file is joined to the program, all references to "
"those functions and data in the file's code are changed to point to the "
"actual locations in the program where the functions and data are placed in "
"memory. This is basically a link operation."
msgstr ""
"在 Unix 中，共享物件 (:file:`.so`) 文件包含程式要使用的程式碼，以及它希望在程"
"序中找到的函式和資料的名稱。將文件加入程式後，文件程式碼中對這些函式和資料的"
"所有引用都會更改為指向程式中函式和資料在記憶體中的實際位置。這基本上是一個鏈"
"接操作。"

#: ../../extending/windows.rst:64
#, fuzzy
msgid ""
"In Windows, a dynamic-link library (:file:`.dll`) file has no dangling "
"references.  Instead, an access to functions or data goes through a lookup "
"table.  So the DLL code does not have to be fixed up at runtime to refer to "
"the program's memory; instead, the code already uses the DLL's lookup table, "
"and the lookup table is modified at runtime to point to the functions and "
"data."
msgstr ""
"在 Windows 中，動態鏈接庫 (:file:`.dll`) "
"文件沒有懸掛引用。相反，對函式或資料的訪問是通過查找表進行的。因此，"
"不必在運行時固定 DLL 程式碼來引用程式的記憶體；相反，程式碼已經使用了 DLL "
"的查找表，查找表在運行時被修改以指向函式和資料。"

#: ../../extending/windows.rst:70
#, fuzzy
msgid ""
"In Unix, there is only one type of library file (:file:`.a`) which contains "
"code from several object files (:file:`.o`).  During the link step to create "
"a shared object file (:file:`.so`), the linker may find that it doesn't know "
"where an identifier is defined.  The linker will look for it in the object "
"files in the libraries; if it finds it, it will include all the code from "
"that object file."
msgstr ""
"在 Unix 中，只有一種型別的庫文件 (:file:`.a`) 包含來自多個目標文件 (:file:`."
"o`) 的程式碼。在建立共享物件文件 (:file:`.so`) 的鏈接步驟中，鏈接器可能會發現"
"它不知道標識符的定義位置。鏈接器將在庫中的目標文件中查找它；如果找到它，它將"
"包含該目標文件中的所有程式碼。"

#: ../../extending/windows.rst:76
#, fuzzy
msgid ""
"In Windows, there are two types of library, a static library and an import "
"library (both called :file:`.lib`).  A static library is like a Unix :file:`."
"a` file; it contains code to be included as necessary. An import library is "
"basically used only to reassure the linker that a certain identifier is "
"legal, and will be present in the program when the DLL is loaded.  So the "
"linker uses the information from the import library to build the lookup "
"table for using identifiers that are not included in the DLL.  When an "
"application or a DLL is linked, an import library may be generated, which "
"will need to be used for all future DLLs that depend on the symbols in the "
"application or DLL."
msgstr ""
"在 Windows 中，有兩種型別的庫，靜態庫和導入庫（都稱為 :file:`."
"lib`）。靜態庫就像 Unix :file:`.a` 文件；它包含必要時包含的程式碼。導入庫基本"
"上僅用於向鏈接器保證某個標識符是合法的，並且會在加載 DLL "
"時出現在程式中。因此，鏈接器使用導入庫中的資訊來構建查找表，以使用未包含在 "
"DLL 中的標識符。鏈接應用程式或 DLL 時，可能會生成一個導入庫，"
"以後所有依賴於該應用程式或 DLL 中的符號的 DLL 都需要使用該導入庫。"

#: ../../extending/windows.rst:86
#, fuzzy
msgid ""
"Suppose you are building two dynamic-load modules, B and C, which should "
"share another block of code A.  On Unix, you would *not* pass :file:`A.a` to "
"the linker for :file:`B.so` and :file:`C.so`; that would cause it to be "
"included twice, so that B and C would each have their own copy.  In Windows, "
"building :file:`A.dll` will also build :file:`A.lib`.  You *do* pass :file:"
"`A.lib` to the linker for B and C.  :file:`A.lib` does not contain code; it "
"just contains information which will be used at runtime to access A's code."
msgstr ""
"假設您正在構建兩個動態加載模組 B 和 C，它們應該共享另一個程式碼塊 A。在 Unix "
"上，您*不會*將 :file:`A.a` 傳遞給 :file:`B.so` 的鏈接器和 :file:`C."
"so`；這將導致它被包含兩次，因此 B 和 C 將各自擁有自己的副本。在 Windows 中，"
"構建 :file:`A.dll` 也會構建 :file:`A.lib`。您*確實*將 :file:`A.lib` 傳遞給 B "
"和 C 的鏈接器。 :file:`A.lib` 不包含程式碼；它只包含將在運行時用於訪問 A "
"的程式碼的資訊。"

#: ../../extending/windows.rst:94
#, fuzzy
msgid ""
"In Windows, using an import library is sort of like using ``import spam``; "
"it gives you access to spam's names, but does not create a separate copy.  "
"On Unix, linking with a library is more like ``from spam import *``; it does "
"create a separate copy."
msgstr ""
"在 Windows 中，使用導入庫有點像使用“導入垃圾郵件”；它使您可以訪問垃圾郵件的名"
"稱，但不會建立單獨的副本。在 Unix 上，鏈接庫更像是``from spam import "
"*``；它確實建立了一個單獨的副本。"

#: ../../extending/windows.rst:103
#, fuzzy
msgid "Using DLLs in Practice"
msgstr "在實踐中使用 DLL"

#: ../../extending/windows.rst:108
#, fuzzy
msgid ""
"Windows Python is built in Microsoft Visual C++; using other compilers may "
"or may not work.  The rest of this section is MSVC++ specific."
msgstr ""
"Windows Python 是在 Microsoft Visual C++ "
"中構建的；使用其他編譯器可能會也可能不會。本節的其餘部分是特定於 MSVC++ 的。"

#: ../../extending/windows.rst:111
#, fuzzy
msgid ""
"When creating DLLs in Windows, you must pass :file:`pythonXY.lib` to the "
"linker. To build two DLLs, spam and ni (which uses C functions found in "
"spam), you could use these commands::"
msgstr ""
"在 Windows 中建立 DLL 時，必須將 :file:`pythonXY.lib` 傳遞給鏈接器。"
"要構建兩個 DLL，spam 和 ni（使用 spam 中的 C 函式），您可以使用這些命令："

#: ../../extending/windows.rst:118
#, fuzzy
msgid ""
"The first command created three files: :file:`spam.obj`, :file:`spam.dll` "
"and :file:`spam.lib`.  :file:`Spam.dll` does not contain any Python "
"functions (such as :c:func:`PyArg_ParseTuple`), but it does know how to find "
"the Python code thanks to :file:`pythonXY.lib`."
msgstr ""
"第一個命令建立了三個文件：:file:`spam.obj`、:file:`spam.dll` 和:"
"file:`spam.lib`。 :file:`Spam.dll` 不包含任何 Python 函式（例如 "
":c:func:`PyArg_ParseTuple`），但由於 :file:`pythonXY.lib`，它知道如何找到 "
"Python 程式碼。"

#: ../../extending/windows.rst:123
#, fuzzy
msgid ""
"The second command created :file:`ni.dll` (and :file:`.obj` and :file:`."
"lib`), which knows how to find the necessary functions from spam, and also "
"from the Python executable."
msgstr ""
"第二個命令建立了 :file:`ni.dll`（以及 :file:`.obj` 和 :file:`.lib`），"
"它知道如何從垃圾郵件和 Python 可執行文件中找到必要的函式。"

#: ../../extending/windows.rst:127
#, fuzzy
msgid ""
"Not every identifier is exported to the lookup table.  If you want any other "
"modules (including Python) to be able to see your identifiers, you have to "
"say ``_declspec(dllexport)``, as in ``void _declspec(dllexport) "
"initspam(void)`` or ``PyObject _declspec(dllexport) *NiGetSpamData(void)``."
msgstr ""
"並非每個標識符都導出到查找表。如果你想讓任何其他模組（包括 "
"Python）能夠看到你的標識符，你必須說 ``_declspec(dllexport)``，如 ``void "
"_declspec(dllexport) initspam(void)`` 或 ``PyObject _declspec(dllexport) "
"*NiGetSpamData(void)``。"

#: ../../extending/windows.rst:132
#, fuzzy
msgid ""
"Developer Studio will throw in a lot of import libraries that you do not "
"really need, adding about 100K to your executable.  To get rid of them, use "
"the Project Settings dialog, Link tab, to specify *ignore default "
"libraries*.  Add the correct :file:`msvcrtxx.lib` to the list of libraries."
msgstr ""
"Developer Studio 會放入很多您並不真正需要的導入庫，將大約 100K 新增到您的可執"
"行文件中。要擺脫它們，請使用“項目設定”對話框的“鏈接”選項卡來指定*忽略預設庫*"
"。將正確的 :file:`msvcrtxx.lib` 新增到庫列表中。"
