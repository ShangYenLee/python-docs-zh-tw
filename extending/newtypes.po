# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Leon H., 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-07 00:27+0000\n"
"PO-Revision-Date: 2018-05-23 14:34+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../extending/newtypes.rst:7
#, fuzzy
msgid "Defining Extension Types: Assorted Topics"
msgstr "定義擴充型別：各種主題"

#: ../../extending/newtypes.rst:11
#, fuzzy
msgid ""
"This section aims to give a quick fly-by on the various type methods you can "
"implement and what they do."
msgstr "本節旨在快速瀏覽您可以實作的各種型別方法以及它們的作用。"

#: ../../extending/newtypes.rst:14
#, fuzzy
msgid ""
"Here is the definition of :c:type:`PyTypeObject`, with some fields only used "
"in :ref:`debug builds <debug-build>` omitted:"
msgstr ""
"下面是 :c:type:`PyTypeObject` 的定義，其中一些欄位僅在 :ref:`debug builds "
"<debug-build>` 中使用，省略了："

#: ../../extending/newtypes.rst:20
#, fuzzy
msgid ""
"Now that's a *lot* of methods.  Don't worry too much though -- if you have a "
"type you want to define, the chances are very good that you will only "
"implement a handful of these."
msgstr "現在有很多*方法。不過不要太擔心——如果您有一個想要定義的型別，您很可能只會實作"
"其中的一小部分。"

#: ../../extending/newtypes.rst:24
#, fuzzy
msgid ""
"As you probably expect by now, we're going to go over this and give more "
"information about the various handlers.  We won't go in the order they are "
"defined in the structure, because there is a lot of historical baggage that "
"impacts the ordering of the fields.  It's often easiest to find an example "
"that includes the fields you need and then change the values to suit your "
"new type. ::"
msgstr ""
"正如您現在可能期望的那樣，我們將討論這個問題並提供有關各種處理程式的更多資訊"
"。我們不會按照它們在結構中定義的順序進行，因為有很多影響欄位順序的歷史包袱。"
"通常最容易找到包含所需欄位的示例，然後更改值以適合您的新型別。 ::"

#: ../../extending/newtypes.rst:33
#, fuzzy
msgid ""
"The name of the type -- as mentioned in the previous chapter, this will "
"appear in various places, almost entirely for diagnostic purposes. Try to "
"choose something that will be helpful in such a situation! ::"
msgstr "型別的名稱——如前一章所述，這將出現在不同的地方，幾乎完全用於診斷目的。嘗試選"
"擇在這種情況下會有所幫助的東西！ ::"

#: ../../extending/newtypes.rst:39
#, fuzzy
msgid ""
"These fields tell the runtime how much memory to allocate when new objects "
"of this type are created.  Python has some built-in support for variable "
"length structures (think: strings, tuples) which is where the :c:member:"
"`~PyTypeObject.tp_itemsize` field comes in.  This will be dealt with "
"later. ::"
msgstr ""
"這些欄位告訴運行時在建立這種型別的新物件時要分配多少記憶體。 Python "
"對可變長度結構（想想：字串、元組）有一些內建支援，這是 "
":c:member:`~PyTypeObject.tp_itemsize` 欄位的用武之地。這將在稍後處理。 ::"

#: ../../extending/newtypes.rst:46
#, fuzzy
msgid ""
"Here you can put a string (or its address) that you want returned when the "
"Python script references ``obj.__doc__`` to retrieve the doc string."
msgstr "當 Python 腳本引用 ``obj.__doc__`` 來檢索 doc "
"字串時，您可以在此處放置要回傳的字串（或其地址）。"

#: ../../extending/newtypes.rst:49
#, fuzzy
msgid ""
"Now we come to the basic type methods -- the ones most extension types will "
"implement."
msgstr "現在我們來看看基本的型別方法——大多數擴充型別將實作的方法。"

#: ../../extending/newtypes.rst:54
#, fuzzy
msgid "Finalization and De-allocation"
msgstr "完成和取消分配"

#: ../../extending/newtypes.rst:66
#, fuzzy
msgid ""
"This function is called when the reference count of the instance of your "
"type is reduced to zero and the Python interpreter wants to reclaim it.  If "
"your type has memory to free or other clean-up to perform, you can put it "
"here.  The object itself needs to be freed here as well.  Here is an example "
"of this function::"
msgstr ""
"當您的型別實例的引用計數減少到零並且 Python 直譯器想要回收它時，將呼叫此函式"
"。如果您的型別需要釋放記憶體或執行其他清理工作，您可以將它放在這裡。物件本身"
"也需要在這裡被釋放。這是此函式的示例::"

#: ../../extending/newtypes.rst:79
#, fuzzy
msgid ""
"If your type supports garbage collection, the destructor should call :c:func:"
"`PyObject_GC_UnTrack` before clearing any member fields::"
msgstr "如果您的型別支援垃圾回收，則析構函式應在清除任何成員欄位之前呼叫 "
"PyObject_GC_UnTrack::"

#: ../../extending/newtypes.rst:95
#, fuzzy
msgid ""
"One important requirement of the deallocator function is that it leaves any "
"pending exceptions alone.  This is important since deallocators are "
"frequently called as the interpreter unwinds the Python stack; when the "
"stack is unwound due to an exception (rather than normal returns), nothing "
"is done to protect the deallocators from seeing that an exception has "
"already been set.  Any actions which a deallocator performs which may cause "
"additional Python code to be executed may detect that an exception has been "
"set.  This can lead to misleading errors from the interpreter.  The proper "
"way to protect against this is to save a pending exception before performing "
"the unsafe action, and restoring it when done.  This can be done using the :"
"c:func:`PyErr_Fetch` and :c:func:`PyErr_Restore` functions::"
msgstr ""
"deallocator 函式的一個重要要求是它不處理任何掛起的例外。這很重要，"
"因為當直譯器展開 Python 堆疊時，解分配器經常被呼叫；當堆疊由於例外（而不是正"
"常回傳）而被展開時，沒有採取任何措施來保護釋放器不看到已經設定了例外。"
"解除分配器執行的任何可能導致執行其他 Python 程式碼的操作都可能檢測到已設定例"
"外。這可能會導致直譯器產生誤導性錯誤。防止這種情況的正確方法是在執行不安全操"
"作之前保存掛起的例外，並在完成後恢復它。這可以使用 PyErr_Fetch 和 "
"PyErr_Restore 函式來完成："

#: ../../extending/newtypes.rst:134
#, fuzzy
msgid ""
"There are limitations to what you can safely do in a deallocator function. "
"First, if your type supports garbage collection (using :c:member:"
"`~PyTypeObject.tp_traverse` and/or :c:member:`~PyTypeObject.tp_clear`), some "
"of the object's members can have been cleared or finalized by the time :c:"
"member:`~PyTypeObject.tp_dealloc` is called.  Second, in :c:member:"
"`~PyTypeObject.tp_dealloc`, your object is in an unstable state: its "
"reference count is equal to zero.  Any call to a non-trivial object or API "
"(as in the example above) might end up calling :c:member:`~PyTypeObject."
"tp_dealloc` again, causing a double free and a crash."
msgstr ""
"在解除分配器函式中可以安全地執行的操作是有限制的。首先，如果你的型別支援垃圾"
"回收（使用 :c:member:`~PyTypeObject.tp_traverse` 和/或 "
":c:member:`~PyTypeObject.tp_clear`），一些物件的成員可能已經被時間 "
":c:member:`~PyTypeObject.tp_dealloc` 被呼叫。其次，在 "
":c:member:`~PyTypeObject.tp_dealloc` "
"中，您的物件處於不穩定狀態：它的引用計數等於零。對非平凡對像或 API "
"的任何呼叫（如上例所示）都可能最終再次呼叫 :c:member:`~PyTypeObject."
"tp_dealloc`，導致雙重釋放和崩潰。"

#: ../../extending/newtypes.rst:143
#, fuzzy
msgid ""
"Starting with Python 3.4, it is recommended not to put any complex "
"finalization code in :c:member:`~PyTypeObject.tp_dealloc`, and instead use "
"the new :c:member:`~PyTypeObject.tp_finalize` type method."
msgstr ""
"從 Python 3.4 開始，建議不要在 :c:member:`~PyTypeObject.tp_dealloc` "
"中放入任何復雜的終結程式碼，而是使用新的 :c:member:`~PyTypeObject."
"tp_finalize` 型別方法。"

#: ../../extending/newtypes.rst:148
#, fuzzy
msgid ":pep:`442` explains the new finalization scheme."
msgstr ":pep:`442` 解釋了新的定稿方案。"

#: ../../extending/newtypes.rst:155
#, fuzzy
msgid "Object Presentation"
msgstr "物件介紹"

#: ../../extending/newtypes.rst:157
#, fuzzy
msgid ""
"In Python, there are two ways to generate a textual representation of an "
"object: the :func:`repr` function, and the :func:`str` function.  (The :func:"
"`print` function just calls :func:`str`.)  These handlers are both optional."
msgstr ""
"在 Python 中，有兩種方法可以生成物件的文本表示：:func:`repr` "
"函式和 :func:`str` 函式。 （:func:`print` 函式只是呼叫 "
":func:`str`。）這些處理程式都是可選的。"

#: ../../extending/newtypes.rst:166
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_repr` handler should return a string object "
"containing a representation of the instance for which it is called.  Here is "
"a simple example::"
msgstr ""
":c:member:`~PyTypeObject.tp_repr` 處理程式應回傳一個字串物件，其中包含呼叫它"
"的實例的表示形式。這是一個簡單的例子::"

#: ../../extending/newtypes.rst:177
#, fuzzy
msgid ""
"If no :c:member:`~PyTypeObject.tp_repr` handler is specified, the "
"interpreter will supply a representation that uses the type's :c:member:"
"`~PyTypeObject.tp_name` and a uniquely identifying value for the object."
msgstr "如果沒有指定處理程式，直譯器將提供一個使用型別的表示和物件的唯一標識值。"

#: ../../extending/newtypes.rst:181
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_str` handler is to :func:`str` what the :c:"
"member:`~PyTypeObject.tp_repr` handler described above is to :func:`repr`; "
"that is, it is called when Python code calls :func:`str` on an instance of "
"your object.  Its implementation is very similar to the :c:member:"
"`~PyTypeObject.tp_repr` function, but the resulting string is intended for "
"human consumption.  If :c:member:`~PyTypeObject.tp_str` is not specified, "
"the :c:member:`~PyTypeObject.tp_repr` handler is used instead."
msgstr ""
":c:member:`~PyTypeObject.tp_str` 處理程式到 :func:`str` 就像上面描述的 "
":c:member:`~PyTypeObject.tp_repr` 處理程式到 :func:`repr` 一樣；也就是說，當 "
"Python 程式碼在您的物件實例上呼叫 :func:`str` 時，它會被呼叫。它的實作與 "
":c:member:`~PyTypeObject.tp_repr` 函式非常相似，但生成的字串是供人類使用的。"
"如果未指定 :c:member:`~PyTypeObject.tp_str`，則使用 :c:member:`~PyTypeObject."
"tp_repr` 處理程式。"

#: ../../extending/newtypes.rst:188
msgid "Here is a simple example::"
msgstr ""
"以下是個簡單的範例：\n"
"\n"
"::"

#: ../../extending/newtypes.rst:200
#, fuzzy
msgid "Attribute Management"
msgstr "屬性管理"

#: ../../extending/newtypes.rst:202
#, fuzzy
msgid ""
"For every object which can support attributes, the corresponding type must "
"provide the functions that control how the attributes are resolved.  There "
"needs to be a function which can retrieve attributes (if any are defined), "
"and another to set attributes (if setting attributes is allowed).  Removing "
"an attribute is a special case, for which the new value passed to the "
"handler is ``NULL``."
msgstr ""
"對於每個可以支援屬性的物件，相應的型別必須提供控制屬性解析方式的函式。需要有"
"一個可以檢索屬性的函式（如果定義了任何屬性）和另一個設定屬性的函式（如果允許"
"設定屬性）。刪除屬性是一種特殊情況，傳遞給處理程式的新值是 ``NULL`` 。"

#: ../../extending/newtypes.rst:208
#, fuzzy
msgid ""
"Python supports two pairs of attribute handlers; a type that supports "
"attributes only needs to implement the functions for one pair.  The "
"difference is that one pair takes the name of the attribute as a :c:expr:"
"`char\\*`, while the other accepts a :c:expr:`PyObject*`.  Each type can use "
"whichever pair makes more sense for the implementation's convenience. ::"
msgstr ""
"Python 支援兩對屬性處理程式；支援屬性的型別只需要實作一對的功能。"
"不同之處在於一對將屬性名稱作為 :c:expr:`char\\*`，而另一對接受 "
":c:expr:`PyObject*`。每種型別都可以使用任何一對對實作的方便更有意義。 ::"

#: ../../extending/newtypes.rst:220
#, fuzzy
msgid ""
"If accessing attributes of an object is always a simple operation (this will "
"be explained shortly), there are generic implementations which can be used "
"to provide the :c:expr:`PyObject*` version of the attribute management "
"functions. The actual need for type-specific attribute handlers almost "
"completely disappeared starting with Python 2.2, though there are many "
"examples which have not been updated to use some of the new generic "
"mechanism that is available."
msgstr ""
"如果訪問物件的屬性始終是一個簡單的操作（稍後將對此進行解釋），"
"則可以使用通用實作來提供 PyObject* 版本的屬性管理功能。從 Python 2.2 開始，對"
"特定於型別的屬性處理程式的實際需求幾乎完全消失，儘管有許多示例尚未更新以使用"
"一些可用的新通用機制。"

#: ../../extending/newtypes.rst:231
#, fuzzy
msgid "Generic Attribute Management"
msgstr "通用屬性管理"

#: ../../extending/newtypes.rst:233
#, fuzzy
msgid ""
"Most extension types only use *simple* attributes.  So, what makes the "
"attributes simple?  There are only a couple of conditions that must be met:"
msgstr "大多數擴充型別只使用*簡單*屬性。那麼，是什麼讓屬性變得簡單呢？只有幾個條件必"
"須滿足："

#: ../../extending/newtypes.rst:236
#, fuzzy
msgid ""
"The name of the attributes must be known when :c:func:`PyType_Ready` is "
"called."
msgstr "呼叫 :c:func:`PyType_Ready` 時必須知道屬性的名稱。"

#: ../../extending/newtypes.rst:239
#, fuzzy
msgid ""
"No special processing is needed to record that an attribute was looked up or "
"set, nor do actions need to be taken based on the value."
msgstr "不需要特殊處理來記錄查找或設定屬性，也不需要根據值採取操作。"

#: ../../extending/newtypes.rst:242
#, fuzzy
msgid ""
"Note that this list does not place any restrictions on the values of the "
"attributes, when the values are computed, or how relevant data is stored."
msgstr "請注意，此列表不對屬性值、計算值的時間或相關資料的儲存方式施加任何限制。"

#: ../../extending/newtypes.rst:245
#, fuzzy
msgid ""
"When :c:func:`PyType_Ready` is called, it uses three tables referenced by "
"the type object to create :term:`descriptor`\\s which are placed in the "
"dictionary of the type object.  Each descriptor controls access to one "
"attribute of the instance object.  Each of the tables is optional; if all "
"three are ``NULL``, instances of the type will only have attributes that are "
"inherited from their base type, and should leave the :c:member:"
"`~PyTypeObject.tp_getattro` and :c:member:`~PyTypeObject.tp_setattro` fields "
"``NULL`` as well, allowing the base type to handle attributes."
msgstr ""
"當 :c:func:`PyType_Ready` 被呼叫時，它使用型別物件引用的三個表來建立 "
":term:`descriptor`\\s，它們被放置在型別物件的字典中。每個描述器控制對實例物件"
"的一個屬性的訪問。每個表都是可選的；如果這三個都為 ``NULL`` ，則該型別的實例將僅"
"具有從其基型別繼承的屬性，並且應該保留:c:member:`~PyTypeObject.tp_getattro` "
"和:c:member:`~PyTypeObject .tp_setattro "
"欄位也為 ``NULL`` ，允許基本型別處理屬性。"

#: ../../extending/newtypes.rst:253
#, fuzzy
msgid "The tables are declared as three fields of the type object::"
msgstr "這些表被聲明為型別物件的三個欄位："

#: ../../extending/newtypes.rst:259
#, fuzzy
msgid ""
"If :c:member:`~PyTypeObject.tp_methods` is not ``NULL``, it must refer to an "
"array of :c:type:`PyMethodDef` structures.  Each entry in the table is an "
"instance of this structure::"
msgstr ""
"如果 :c:member:`~PyTypeObject.tp_methods` 不是 ``NULL``，它必須引用 "
":c:type:`PyMethodDef` 結構數組。表中的每個條目都是此結構的一個實例："

#: ../../extending/newtypes.rst:270
#, fuzzy
msgid ""
"One entry should be defined for each method provided by the type; no entries "
"are needed for methods inherited from a base type.  One additional entry is "
"needed at the end; it is a sentinel that marks the end of the array.  The :"
"attr:`ml_name` field of the sentinel must be ``NULL``."
msgstr ""
"應該為型別提供的每個方法定義一個條目；從基型別繼承的方法不需要條目。最後需要"
"一個額外的條目；它是一個標記數組結束的哨兵。哨兵的 :attr:`ml_name` "
"欄位必須為 ``NULL``。"

#: ../../extending/newtypes.rst:275
#, fuzzy
msgid ""
"The second table is used to define attributes which map directly to data "
"stored in the instance.  A variety of primitive C types are supported, and "
"access may be read-only or read-write.  The structures in the table are "
"defined as::"
msgstr "第二個表用於定義直接映射到實例中儲存的資料的屬性。支援各種原始 C "
"型別，訪問可以是只讀或讀寫。表中的結構定義為："

#: ../../extending/newtypes.rst:287
#, fuzzy
msgid ""
"For each entry in the table, a :term:`descriptor` will be constructed and "
"added to the type which will be able to extract a value from the instance "
"structure.  The :attr:`type` field should contain one of the type codes "
"defined in the :file:`structmember.h` header; the value will be used to "
"determine how to convert Python values to and from C values.  The :attr:"
"`flags` field is used to store flags which control how the attribute can be "
"accessed."
msgstr ""
"對於表中的每個條目，將構造一個描述器並將其新增到能夠從實例結構中提取值的型別"
"。 :attr:`type` 欄位應包含 :file:`structmember.h` "
"標頭中定義的型別程式碼之一；該值將用於確定如何將 Python 值與 C 值相互轉換。 "
":attr:`flags` 欄位用於儲存控制如何訪問屬性的旗標。"

#: ../../extending/newtypes.rst:294
#, fuzzy
msgid ""
"The following flag constants are defined in :file:`structmember.h`; they may "
"be combined using bitwise-OR."
msgstr "以下旗標常數在 structmember.h 中定義；它們可以使用按位或組合。"

#: ../../extending/newtypes.rst:298
msgid "Constant"
msgstr "常數"

#: ../../extending/newtypes.rst:298
#, fuzzy
msgid "Meaning"
msgstr "意義"

#: ../../extending/newtypes.rst:300
msgid ":const:`READONLY`"
msgstr ":const:`READONLY`"

#: ../../extending/newtypes.rst:300
#, fuzzy
msgid "Never writable."
msgstr "永遠不可寫。"

#: ../../extending/newtypes.rst:302
msgid ":const:`PY_AUDIT_READ`"
msgstr ":const:`PY_AUDIT_READ`"

#: ../../extending/newtypes.rst:302
#, fuzzy
msgid ""
"Emit an ``object.__getattr__`` :ref:`audit events <audit-events>` before "
"reading."
msgstr "在讀取之前發出 ``object.__getattr__`` :ref:`audit events <audit-events>`。"

#: ../../extending/newtypes.rst:307
#, fuzzy
msgid ""
":const:`RESTRICTED`, :const:`READ_RESTRICTED` and :const:`WRITE_RESTRICTED` "
"are deprecated. However, :const:`READ_RESTRICTED` is an alias for :const:"
"`PY_AUDIT_READ`, so fields that specify either :const:`RESTRICTED` or :const:"
"`READ_RESTRICTED` will also raise an audit event."
msgstr ""
":const:`RESTRICTED`、:const:`READ_RESTRICTED` 和 :const:`WRITE_RESTRICTED` "
"已棄用。但是，READ_RESTRICTED 是 PY_AUDIT_READ 的別名，因此指定 "
"READ_RESTRICTED 或 READ_RESTRICTED 的欄位也會引發審計事件。"

#: ../../extending/newtypes.rst:320
#, fuzzy
msgid ""
"An interesting advantage of using the :c:member:`~PyTypeObject.tp_members` "
"table to build descriptors that are used at runtime is that any attribute "
"defined this way can have an associated doc string simply by providing the "
"text in the table.  An application can use the introspection API to retrieve "
"the descriptor from the class object, and get the doc string using its :attr:"
"`__doc__` attribute."
msgstr ""
"使用 :c:member:`~PyTypeObject.tp_members` 表來構建在運行時使用的描述器的一個"
"有趣優點是，以這種方式定義的任何屬性都可以通過提供表中的文本來簡單地具有關聯"
"的文檔字串。應用程式可以使用內省 API 從類對像中檢索描述器，並使用其 "
":attr:`__doc__` 屬性獲取文檔字串。"

#: ../../extending/newtypes.rst:326
#, fuzzy
msgid ""
"As with the :c:member:`~PyTypeObject.tp_methods` table, a sentinel entry "
"with a :attr:`name` value of ``NULL`` is required."
msgstr ""
"與 :c:member:`~PyTypeObject.tp_methods` 表一樣，需要一個 :attr:`name` 值為 "
"``NULL`` 的哨兵條目。"

#: ../../extending/newtypes.rst:340
#, fuzzy
msgid "Type-specific Attribute Management"
msgstr "型別特定的屬性管理"

#: ../../extending/newtypes.rst:342
#, fuzzy
msgid ""
"For simplicity, only the :c:expr:`char\\*` version will be demonstrated "
"here; the type of the name parameter is the only difference between the :c:"
"expr:`char\\*` and :c:expr:`PyObject*` flavors of the interface. This "
"example effectively does the same thing as the generic example above, but "
"does not use the generic support added in Python 2.2.  It explains how the "
"handler functions are called, so that if you do need to extend their "
"functionality, you'll understand what needs to be done."
msgstr ""
"為簡單起見，這裡只演示 :c:expr:`char\\*` 版本； name 參數的型別是介面的 "
":c:expr:`char\\*` 和 :c:expr:`PyObject*` "
"風格之間的唯一區別。此示例有效地執行與上面的通用示例相同的操作，但不使用 "
"Python 2.2 中新增的通用支援。它解釋瞭如何呼叫處理程式函式，這樣如果您確實需要"
"擴充它們的功能，您就會明白需要做什麼。"

#: ../../extending/newtypes.rst:350
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_getattr` handler is called when the object "
"requires an attribute look-up.  It is called in the same situations where "
"the :meth:`__getattr__` method of a class would be called."
msgstr ""
":c:member:`~PyTypeObject.tp_getattr` 處理程式在物件需要查找屬性時被呼叫。"
"它在呼叫類的 :meth:`__getattr__` 方法的相同情況下被呼叫。"

#: ../../extending/newtypes.rst:354
msgid "Here is an example::"
msgstr ""
"舉例來說：\n"
"\n"
"::"

#: ../../extending/newtypes.rst:370
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_setattr` handler is called when the :meth:"
"`__setattr__` or :meth:`__delattr__` method of a class instance would be "
"called.  When an attribute should be deleted, the third parameter will be "
"``NULL``.  Here is an example that simply raises an exception; if this were "
"really all you wanted, the :c:member:`~PyTypeObject.tp_setattr` handler "
"should be set to ``NULL``. ::"
msgstr ""
"當呼叫類實例的 :meth:`__setattr__` 或 :meth:`__delattr__` 方法時，將呼叫 "
":c:member:`~PyTypeObject.tp_setattr` 處理程式。當應刪除屬性時，第三個參數將為"
" ``NULL`` 。這是一個簡單地引發例外的示例；如果這真的是你想要的，:c:member:`~PyTyp"
"eObject.tp_setattr` 處理程式應該設定為 ``NULL``。 ::"

#: ../../extending/newtypes.rst:384
#, fuzzy
msgid "Object Comparison"
msgstr "對像比較"

#: ../../extending/newtypes.rst:390
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_richcompare` handler is called when "
"comparisons are needed.  It is analogous to the :ref:`rich comparison "
"methods <richcmpfuncs>`, like :meth:`__lt__`, and also called by :c:func:"
"`PyObject_RichCompare` and :c:func:`PyObject_RichCompareBool`."
msgstr ""
":c:member:`~PyTypeObject.tp_richcompare` 處理程式在需要比較時被呼叫。"
"它類似於 :ref:`rich 比較方法 <richcmpfuncs>`，如 :meth:`__lt__`，也被 "
":c:func:`PyObject_RichCompare` 和 :c:func:`PyObject_RichCompareBool` 呼叫。"

#: ../../extending/newtypes.rst:395
#, fuzzy
msgid ""
"This function is called with two Python objects and the operator as "
"arguments, where the operator is one of ``Py_EQ``, ``Py_NE``, ``Py_LE``, "
"``Py_GE``, ``Py_LT`` or ``Py_GT``.  It should compare the two objects with "
"respect to the specified operator and return ``Py_True`` or ``Py_False`` if "
"the comparison is successful, ``Py_NotImplemented`` to indicate that "
"comparison is not implemented and the other object's comparison method "
"should be tried, or ``NULL`` if an exception was set."
msgstr ""
"此函式使用兩個 Python 物件和運算符作為參數呼叫，其中運算符是 "
"``Py_EQ``、``Py_NE``、``Py_LE``、``Py_GE``、``Py_LT`` 或``Py_GT``。它應該根據"
"指定的運算符比較兩個物件，如果比較成功，則回傳``Py_True``或``Py_False``，``Py"
"_NotImplemented``表示比較沒有實作，另一個物件的比較方法應該被嘗試，"
"或者如果設定了例外則為 ``NULL``。"

#: ../../extending/newtypes.rst:403
#, fuzzy
msgid ""
"Here is a sample implementation, for a datatype that is considered equal if "
"the size of an internal pointer is equal::"
msgstr "這是一個示例實作，對於如果內部指標的大小相等則被視為相等的資料型別："

#: ../../extending/newtypes.rst:433
#, fuzzy
msgid "Abstract Protocol Support"
msgstr "抽象協定支援"

#: ../../extending/newtypes.rst:435
#, fuzzy
msgid ""
"Python supports a variety of *abstract* 'protocols;' the specific interfaces "
"provided to use these interfaces are documented in :ref:`abstract`."
msgstr "Python 支援各種*抽象*“協定”；為使用這些介面而提供的特定介面記錄在 "
":ref:`abstract` 中。"

#: ../../extending/newtypes.rst:439
#, fuzzy
msgid ""
"A number of these abstract interfaces were defined early in the development "
"of the Python implementation.  In particular, the number, mapping, and "
"sequence protocols have been part of Python since the beginning.  Other "
"protocols have been added over time.  For protocols which depend on several "
"handler routines from the type implementation, the older protocols have been "
"defined as optional blocks of handlers referenced by the type object.  For "
"newer protocols there are additional slots in the main type object, with a "
"flag bit being set to indicate that the slots are present and should be "
"checked by the interpreter.  (The flag bit does not indicate that the slot "
"values are non-``NULL``. The flag may be set to indicate the presence of a "
"slot, but a slot may still be unfilled.) ::"
msgstr ""
"許多這樣的抽象介面是在 Python 實作的開發早期定義的。特別是，數字、"
"映射和序列協定從一開始就是 Python 的一部分。隨著時間的推移，已經新增了其他協"
"議。對於依賴於型別實作中的多個處理程式例程的協定，較舊的協定已定義為型別物件"
"引用的可選處理程式塊。對於較新的協定，主型別對像中有額外的槽，設定了一個旗標"
"位以指示槽存在並且應該由直譯器檢查。 （旗標位並不表示插槽值是非 ``NULL`` 。旗標可"
"能被設定為指示插槽的存在，但插槽可能仍未填充。）::"

#: ../../extending/newtypes.rst:454
#, fuzzy
msgid ""
"If you wish your object to be able to act like a number, a sequence, or a "
"mapping object, then you place the address of a structure that implements "
"the C type :c:type:`PyNumberMethods`, :c:type:`PySequenceMethods`, or :c:"
"type:`PyMappingMethods`, respectively. It is up to you to fill in this "
"structure with appropriate values. You can find examples of the use of each "
"of these in the :file:`Objects` directory of the Python source "
"distribution. ::"
msgstr ""
"如果您希望您的物件能夠像數字、序列或映射對像一樣工作，那麼您可以放置"
"實作 C 型別的結構的地址 :c:type:`PyNumberMethods`, :c:type:` "
"PySequenceMethods` 或 "
":c:type:`PyMappingMethods`。您可以使用適當的值填充此結構。您可以在 Python "
"源程式碼分發的 :file:`Objects` 目錄中找到每一個的使用示例。 ::"

#: ../../extending/newtypes.rst:463
#, fuzzy
msgid ""
"This function, if you choose to provide it, should return a hash number for "
"an instance of your data type. Here is a simple example::"
msgstr "這個函式，如果你選擇提供它，應該為你的資料型別的一個實例回傳一個雜湊值。這是"
"一個簡單的例子::"

#: ../../extending/newtypes.rst:476
#, fuzzy
msgid ""
":c:type:`Py_hash_t` is a signed integer type with a platform-varying width. "
"Returning ``-1`` from :c:member:`~PyTypeObject.tp_hash` indicates an error, "
"which is why you should be careful to avoid returning it when hash "
"computation is successful, as seen above."
msgstr ""
":c:type:`Py_hash_t` 是具有平台變化寬度的有符號整數型別。從 "
":c:member:`~PyTypeObject.tp_hash` 回傳 ``-1`` "
"表示錯誤，這就是為什麼你應該小心避免在雜湊計算成功時回傳它，如上所示。"

#: ../../extending/newtypes.rst:485
#, fuzzy
msgid ""
"This function is called when an instance of your data type is \"called\", "
"for example, if ``obj1`` is an instance of your data type and the Python "
"script contains ``obj1('hello')``, the :c:member:`~PyTypeObject.tp_call` "
"handler is invoked."
msgstr ""
"當您的資料型別的實例被“呼叫”時呼叫此函式，例如，如果 ``obj1`` "
"是您的資料型別的實例並且 Python 腳本包含 ``obj1('hello')``，則： "
"c:member:`~PyTypeObject.tp_call` 處理程式被呼叫。"

#: ../../extending/newtypes.rst:489
#, fuzzy
msgid "This function takes three arguments:"
msgstr "該函式接受三個參數："

#: ../../extending/newtypes.rst:491
#, fuzzy
msgid ""
"*self* is the instance of the data type which is the subject of the call. If "
"the call is ``obj1('hello')``, then *self* is ``obj1``."
msgstr "*self* 是作為呼叫主題的資料型別的實例。如果呼叫是 ``obj1('hello')``，那麼 "
"*self* 就是 ``obj1``。"

#: ../../extending/newtypes.rst:494
#, fuzzy
msgid ""
"*args* is a tuple containing the arguments to the call.  You can use :c:func:"
"`PyArg_ParseTuple` to extract the arguments."
msgstr "*args* 是一個包含呼叫參數的元組。您可以使用 :c:func:`PyArg_ParseTuple` "
"來提取參數。"

#: ../../extending/newtypes.rst:497
#, fuzzy
msgid ""
"*kwds* is a dictionary of keyword arguments that were passed. If this is non-"
"``NULL`` and you support keyword arguments, use :c:func:"
"`PyArg_ParseTupleAndKeywords` to extract the arguments.  If you do not want "
"to support keyword arguments and this is non-``NULL``, raise a :exc:"
"`TypeError` with a message saying that keyword arguments are not supported."
msgstr ""
"*kwds* 是傳遞的關鍵字參數的字典。如果這是非 ``NULL`` 並且您支援關鍵字參數，"
"請使用 PyArg_ParseTupleAndKeywords "
"來提取參數。如果您不想支援關鍵字參數並且這是非 ``NULL`` ，請引發 :exc:`TypeError`"
" 並顯示一條消息，說明不支援關鍵字參數。"

#: ../../extending/newtypes.rst:503
#, fuzzy
msgid "Here is a toy ``tp_call`` implementation::"
msgstr "這是一個玩具 ``tp_call`` 實作::"

#: ../../extending/newtypes.rst:529
#, fuzzy
msgid ""
"These functions provide support for the iterator protocol.  Both handlers "
"take exactly one parameter, the instance for which they are being called, "
"and return a new reference.  In the case of an error, they should set an "
"exception and return ``NULL``.  :c:member:`~PyTypeObject.tp_iter` "
"corresponds to the Python :meth:`__iter__` method, while :c:member:"
"`~PyTypeObject.tp_iternext` corresponds to the Python :meth:`~iterator."
"__next__` method."
msgstr ""
"這些函式提供對疊代器協定的支援。兩個處理程式都只接受一個參數，即呼叫它們的實"
"例，並回傳一個新的引用。如果出現錯誤，他們應該設定一個例外並回傳 ``NULL`` 。 "
":c:member:`~PyTypeObject.tp_iter` 對應於 Python :meth:`__iter__` 方法，而 "
":c:member:`~PyTypeObject.tp_iternext` 對應於 Python :meth:`~iterator."
"__next__` 方法。"

#: ../../extending/newtypes.rst:536
#, fuzzy
msgid ""
"Any :term:`iterable` object must implement the :c:member:`~PyTypeObject."
"tp_iter` handler, which must return an :term:`iterator` object.  Here the "
"same guidelines apply as for Python classes:"
msgstr ""
"任何 :term:`iterable` 物件必須實作 :c:member:`~PyTypeObject.tp_iter` "
"處理程式，它必須回傳一個 :term:`iterator` 物件。這裡適用與 Python "
"類相同的準則："

#: ../../extending/newtypes.rst:540
#, fuzzy
msgid ""
"For collections (such as lists and tuples) which can support multiple "
"independent iterators, a new iterator should be created and returned by each "
"call to :c:member:`~PyTypeObject.tp_iter`."
msgstr ""
"對於可以支援多個獨立疊代器的集合（例如列表和元組），每次呼叫 "
":c:member:`~PyTypeObject.tp_iter` 都應該建立並回傳一個新的疊代器。"

#: ../../extending/newtypes.rst:543
#, fuzzy
msgid ""
"Objects which can only be iterated over once (usually due to side effects of "
"iteration, such as file objects) can implement :c:member:`~PyTypeObject."
"tp_iter` by returning a new reference to themselves -- and should also "
"therefore implement the :c:member:`~PyTypeObject.tp_iternext`  handler."
msgstr ""
"只能疊代一次的物件（通常是由於疊代的副作用，例如文件物件）"
"可以通過回傳對自身的新引用來實作 :c:member:`~PyTypeObject.tp_iter` —— "
"因此也應該實作:c:member:`~PyTypeObject.tp_iternext` 處理程式。"

#: ../../extending/newtypes.rst:548
#, fuzzy
msgid ""
"Any :term:`iterator` object should implement both :c:member:`~PyTypeObject."
"tp_iter` and :c:member:`~PyTypeObject.tp_iternext`.  An iterator's :c:member:"
"`~PyTypeObject.tp_iter` handler should return a new reference to the "
"iterator.  Its :c:member:`~PyTypeObject.tp_iternext` handler should return a "
"new reference to the next object in the iteration, if there is one. If the "
"iteration has reached the end, :c:member:`~PyTypeObject.tp_iternext` may "
"return ``NULL`` without setting an exception, or it may set :exc:"
"`StopIteration` *in addition* to returning ``NULL``; avoiding the exception "
"can yield slightly better performance.  If an actual error occurs, :c:member:"
"`~PyTypeObject.tp_iternext` should always set an exception and return "
"``NULL``."
msgstr ""
"任何 :term:`iterator` 對像都應該同時實作 :c:member:`~PyTypeObject.tp_iter` "
"和 :c:member:`~PyTypeObject.tp_iternext`。疊代器的 :c:member:`~PyTypeObject."
"tp_iter` 處理程式應該回傳對疊代器的新引用。它的 :c:member:`~PyTypeObject."
"tp_iternext` 處理程式應該回傳對疊代中下一個物件的新引用，如果有的話。如果疊代"
"已經結束，:c:member:`~PyTypeObject.tp_iternext` 可能會回傳 ``NULL`` "
"而不會設定例外，或者它可能會設定 :exc:`StopIteration` *除了*回傳 ``NULL "
"``;避免例外可以產生稍微更好的性能。如果發生實際錯誤，:c:member:`~PyTypeObject"
".tp_iternext` 應始終設定例外並回傳 ``NULL``。"

#: ../../extending/newtypes.rst:564
#, fuzzy
msgid "Weak Reference Support"
msgstr "弱參考支援"

#: ../../extending/newtypes.rst:566
#, fuzzy
msgid ""
"One of the goals of Python's weak reference implementation is to allow any "
"type to participate in the weak reference mechanism without incurring the "
"overhead on performance-critical objects (such as numbers)."
msgstr "Python 弱引用實作的目標之一是允許任何型別參與弱引用機制，而不會對性能關鍵物件"
"（例如數字）產生開銷。"

#: ../../extending/newtypes.rst:571
#, fuzzy
msgid "Documentation for the :mod:`weakref` module."
msgstr ":mod:`weakref` 模組的文檔。"

#: ../../extending/newtypes.rst:573
#, fuzzy
msgid ""
"For an object to be weakly referencable, the extension type must do two "
"things:"
msgstr "對於弱可引用的物件，擴充型別必須做兩件事："

#: ../../extending/newtypes.rst:575
#, fuzzy
msgid ""
"Include a :c:expr:`PyObject*` field in the C object structure dedicated to "
"the weak reference mechanism.  The object's constructor should leave it "
"``NULL`` (which is automatic when using the default :c:member:`~PyTypeObject."
"tp_alloc`)."
msgstr ""
"在專用於弱引用機制的 C 物件結構中包含一個 :c:expr:`PyObject*` 欄位。物件的構"
"造函式應將其保留為 ``NULL`` （使用預設值時自動執行 :c:member:`~PyTypeObject."
"tp_alloc`）。"

#: ../../extending/newtypes.rst:580
#, fuzzy
msgid ""
"Set the :c:member:`~PyTypeObject.tp_weaklistoffset` type member to the "
"offset of the aforementioned field in the C object structure, so that the "
"interpreter knows how to access and modify that field."
msgstr ""
"將 :c:member:`~PyTypeObject.tp_weaklistoffset` 型別成員設定為 C "
"物件結構中上述欄位的偏移量，以便直譯器知道如何訪問和修改該欄位。"

#: ../../extending/newtypes.rst:584
#, fuzzy
msgid ""
"Concretely, here is how a trivial object structure would be augmented with "
"the required field::"
msgstr "具體來說，這裡是一個簡單的物件結構如何用所需的欄位來擴充："

#: ../../extending/newtypes.rst:592
#, fuzzy
msgid "And the corresponding member in the statically declared type object::"
msgstr "以及靜態聲明型別對像中對應的成員::"

#: ../../extending/newtypes.rst:600
#, fuzzy
msgid ""
"The only further addition is that ``tp_dealloc`` needs to clear any weak "
"references (by calling :c:func:`PyObject_ClearWeakRefs`) if the field is non-"
"``NULL``::"
msgstr "唯一進一步的補充是，如果該欄位為非 ``NULL`` ::"

#: ../../extending/newtypes.rst:616
#, fuzzy
msgid "More Suggestions"
msgstr "更多建議"

#: ../../extending/newtypes.rst:618
#, fuzzy
msgid ""
"In order to learn how to implement any specific method for your new data "
"type, get the :term:`CPython` source code.  Go to the :file:`Objects` "
"directory, then search the C source files for ``tp_`` plus the function you "
"want (for example, ``tp_richcompare``).  You will find examples of the "
"function you want to implement."
msgstr ""
"為了了解如何為您的新資料型別實作任何特定方法，請獲取 CPython 源程式碼。轉到 "
":file:`Objects` 目錄，然後在 C 源文件中搜索 ``tp_`` "
"以及您想要的函式（例如，``tp_richcompare``）。您將找到要實作的功能的示例。"

#: ../../extending/newtypes.rst:624
#, fuzzy
msgid ""
"When you need to verify that an object is a concrete instance of the type "
"you are implementing, use the :c:func:`PyObject_TypeCheck` function.  A "
"sample of its use might be something like the following::"
msgstr "當您需要驗證對像是否是您正在實作的型別的具體實例時，請使用 "
"PyObject_TypeCheck 函式。它的使用示例可能如下所示："

#: ../../extending/newtypes.rst:635
#, fuzzy
msgid "Download CPython source releases."
msgstr "下載 CPython 源版本。"

#: ../../extending/newtypes.rst:635
msgid "https://www.python.org/downloads/source/"
msgstr "https://www.python.org/downloads/source/"

#: ../../extending/newtypes.rst:637
#, fuzzy
msgid ""
"The CPython project on GitHub, where the CPython source code is developed."
msgstr "GitHub 上的 CPython 項目，開發了 CPython 源程式碼。"

#: ../../extending/newtypes.rst:638
msgid "https://github.com/python/cpython"
msgstr "https://github.com/python/cpython"
