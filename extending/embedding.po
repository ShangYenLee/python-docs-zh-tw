# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Leon H., 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-31 08:13+0000\n"
"PO-Revision-Date: 2018-05-23 14:09+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../extending/embedding.rst:8
msgid "Embedding Python in Another Application"
msgstr "在其它 App 內嵌入 Python"

#: ../../extending/embedding.rst:10
#, fuzzy
msgid ""
"The previous chapters discussed how to extend Python, that is, how to extend "
"the functionality of Python by attaching a library of C functions to it.  It "
"is also possible to do it the other way around: enrich your C/C++ "
"application by embedding Python in it.  Embedding provides your application "
"with the ability to implement some of the functionality of your application "
"in Python rather than C or C++. This can be used for many purposes; one "
"example would be to allow users to tailor the application to their needs by "
"writing some scripts in Python.  You can also use it yourself if some of the "
"functionality can be written in Python more easily."
msgstr ""
"前面的章節討論瞭如何擴充Python，即如何通過附加一個C函式庫來擴充Python的功能。"
"也可以反過來做：通過在其中嵌入 Python 來豐富您的 C/C++ 應用程式。"
"嵌入使您的應用程式能夠在 Python 而不是 C 或 C++ "
"中實作應用程式的某些功能。這可以用於多種目的；一個例子是允許使用者通過用 "
"Python 編寫一些腳本來根據他們的需要定制應用程式。如果某些功能可以更輕鬆地用 "
"Python 編寫，您也可以自己使用它。"

#: ../../extending/embedding.rst:20
#, fuzzy
msgid ""
"Embedding Python is similar to extending it, but not quite.  The difference "
"is that when you extend Python, the main program of the application is still "
"the Python interpreter, while if you embed Python, the main program may have "
"nothing to do with Python --- instead, some parts of the application "
"occasionally call the Python interpreter to run some Python code."
msgstr ""
"嵌入 Python 類似於擴充它，但又不完全相同。不同之處在於，當你擴充 Python 時，"
"應用程式的主程式仍然是 Python 直譯器，而如果你嵌入 Python，則主程式可能與 "
"Python 無關——相反，應用程式的某些部分偶爾會呼叫運行一些 Python 程式碼的 "
"Python 直譯器。"

#: ../../extending/embedding.rst:26
#, fuzzy
msgid ""
"So if you are embedding Python, you are providing your own main program.  "
"One of the things this main program has to do is initialize the Python "
"interpreter.  At the very least, you have to call the function :c:func:"
"`Py_Initialize`.  There are optional calls to pass command line arguments to "
"Python.  Then later you can call the interpreter from any part of the "
"application."
msgstr ""
"所以如果你嵌入 Python，你就是在提供你自己的主程式。"
"這個主程式必須做的一件事是初始化 Python 直譯器。至少，您必須呼叫函式 "
":c:func:`Py_Initialize`。有一些可選的呼叫可以將命令列參數傳遞給 "
"Python。然後您可以從應用程式的任何部分呼叫直譯器。"

#: ../../extending/embedding.rst:32
#, fuzzy
msgid ""
"There are several different ways to call the interpreter: you can pass a "
"string containing Python statements to :c:func:`PyRun_SimpleString`, or you "
"can pass a stdio file pointer and a file name (for identification in error "
"messages only) to :c:func:`PyRun_SimpleFile`.  You can also call the lower-"
"level operations described in the previous chapters to construct and use "
"Python objects."
msgstr ""
"呼叫直譯器有幾種不同的方法：您可以將包含 Python "
"語句的字串傳遞給 :c:func:`PyRun_SimpleString`，或者您可以將一個 stdio "
"文件指標和一個文件名（僅用於在錯誤消息中識別）傳遞給： "
"c:func:`PyRun_SimpleFile`。您還可以呼叫前面章節中描述的低階操作來構造和使用 "
"Python 物件。"

#: ../../extending/embedding.rst:42
msgid ":ref:`c-api-index`"
msgstr ":ref:`c-api-index`"

#: ../../extending/embedding.rst:42
#, fuzzy
msgid ""
"The details of Python's C interface are given in this manual. A great deal "
"of necessary information can be found here."
msgstr "Python 的 C 介面的詳細資訊在本手冊中給出。在這裡可以找到大量必要的資訊。"

#: ../../extending/embedding.rst:49
#, fuzzy
msgid "Very High Level Embedding"
msgstr "非常高階的嵌入"

#: ../../extending/embedding.rst:51
#, fuzzy
msgid ""
"The simplest form of embedding Python is the use of the very high level "
"interface. This interface is intended to execute a Python script without "
"needing to interact with the application directly. This can for example be "
"used to perform some operation on a file. ::"
msgstr ""
"嵌入 Python 的最簡單形式是使用非常高階的介面。此介面旨在執行 Python "
"腳本，而無需直接與應用程式交互。例如，這可以用於對文件執行某些操作。 ::"

#: ../../extending/embedding.rst:78
#, fuzzy
msgid ""
"The :c:func:`Py_SetProgramName` function should be called before :c:func:"
"`Py_Initialize` to inform the interpreter about paths to Python run-time "
"libraries.  Next, the Python interpreter is initialized with :c:func:"
"`Py_Initialize`, followed by the execution of a hard-coded Python script "
"that prints the date and time.  Afterwards, the :c:func:`Py_FinalizeEx` call "
"shuts the interpreter down, followed by the end of the program.  In a real "
"program, you may want to get the Python script from another source, perhaps "
"a text-editor routine, a file, or a database.  Getting the Python code from "
"a file can better be done by using the :c:func:`PyRun_SimpleFile` function, "
"which saves you the trouble of allocating memory space and loading the file "
"contents."
msgstr ""
":c:func:`Py_SetProgramName` 函式應在 :c:func:`Py_Initialize` 之前呼叫，"
"以通知直譯器有關 Python 運行時庫的路徑。接下來，使用 Py_Initialize 初始化 "
"Python 直譯器，然後執行印出日期和時間的硬編碼 Python "
"腳本。之後，:c:func:`Py_FinalizeEx` "
"呼叫關閉直譯器，隨後程式結束。在實際程式中，您可能希望從其他來源獲取 Python "
"腳本，可能是文本編輯器例程、文件或資料庫。使用 PyRun_SimpleFile "
"函式可以更好地從文件中獲取 Python "
"程式碼，這樣可以省去分配記憶體空間和加載文件內容的麻煩。"

#: ../../extending/embedding.rst:93
#, fuzzy
msgid "Beyond Very High Level Embedding: An overview"
msgstr "超越超高層嵌入：概述"

#: ../../extending/embedding.rst:95
#, fuzzy
msgid ""
"The high level interface gives you the ability to execute arbitrary pieces "
"of Python code from your application, but exchanging data values is quite "
"cumbersome to say the least. If you want that, you should use lower level "
"calls. At the cost of having to write more C code, you can achieve almost "
"anything."
msgstr ""
"高階介面使您能夠從您的應用程式執行任意 Python 程式碼片段，但交換資料值至少可"
"以說是相當麻煩的。如果需要，您應該使用較低階別的呼叫。以必須編寫更多 C "
"程式碼為代價，您幾乎可以實作任何目標。"

#: ../../extending/embedding.rst:100
#, fuzzy
msgid ""
"It should be noted that extending Python and embedding Python is quite the "
"same activity, despite the different intent. Most topics discussed in the "
"previous chapters are still valid. To show this, consider what the extension "
"code from Python to C really does:"
msgstr ""
"應該注意的是，擴充 Python 和嵌入 Python 是完全相同的活動，儘管意圖不同。前幾"
"章中討論的大多數主題仍然有效。為了說明這一點，請考慮從 Python 到 C "
"的擴充程式碼的真正作用："

#: ../../extending/embedding.rst:105
#, fuzzy
msgid "Convert data values from Python to C,"
msgstr "將資料值從 Python 轉換為 C，"

#: ../../extending/embedding.rst:107
#, fuzzy
msgid "Perform a function call to a C routine using the converted values, and"
msgstr "使用轉換後的值執行對 C 例程的函式呼叫，以及"

#: ../../extending/embedding.rst:109
#, fuzzy
msgid "Convert the data values from the call from C to Python."
msgstr "將 C 呼叫中的資料值轉換為 Python。"

#: ../../extending/embedding.rst:111
#, fuzzy
msgid "When embedding Python, the interface code does:"
msgstr "嵌入Python時，介面程式碼做的事情："

#: ../../extending/embedding.rst:113
#, fuzzy
msgid "Convert data values from C to Python,"
msgstr "將資料值從 C 轉換為 Python，"

#: ../../extending/embedding.rst:115
#, fuzzy
msgid ""
"Perform a function call to a Python interface routine using the converted "
"values, and"
msgstr "使用轉換後的值執行對 Python 介面例程的函式呼叫，以及"

#: ../../extending/embedding.rst:118
#, fuzzy
msgid "Convert the data values from the call from Python to C."
msgstr "將來自 Python 的呼叫的資料值轉換為 C。"

#: ../../extending/embedding.rst:120
#, fuzzy
msgid ""
"As you can see, the data conversion steps are simply swapped to accommodate "
"the different direction of the cross-language transfer. The only difference "
"is the routine that you call between both data conversions. When extending, "
"you call a C routine, when embedding, you call a Python routine."
msgstr ""
"如您所見，只是交換了資料轉換步驟以適應跨語言傳輸的不同方向。唯一的區別是您在"
"兩次資料轉換之間呼叫的例程。擴充時呼叫 C 例程，嵌入時呼叫 Python 例程。"

#: ../../extending/embedding.rst:125
#, fuzzy
msgid ""
"This chapter will not discuss how to convert data from Python to C and vice "
"versa.  Also, proper use of references and dealing with errors is assumed to "
"be understood.  Since these aspects do not differ from extending the "
"interpreter, you can refer to earlier chapters for the required information."
msgstr ""
"本章不會討論如何將資料從 Python 轉換為 C，反之亦然。此外，假定已理解正確使用"
"參考資料和處理錯誤。由於這些方面與擴充直譯器沒有區別，您可以參考前面的章節以"
"獲取所需資訊。"

#: ../../extending/embedding.rst:134
#, fuzzy
msgid "Pure Embedding"
msgstr "純嵌入"

#: ../../extending/embedding.rst:136
#, fuzzy
msgid ""
"The first program aims to execute a function in a Python script. Like in the "
"section about the very high level interface, the Python interpreter does not "
"directly interact with the application (but that will change in the next "
"section)."
msgstr "第一個程式旨在執行 Python 腳本中的函式。與關於超高層介面的部分一樣，Python "
"直譯器不直接與應用程式交互（但這將在下一節中改變）。"

#: ../../extending/embedding.rst:141
#, fuzzy
msgid "The code to run a function defined in a Python script is:"
msgstr "運行 Python 腳本中定義的函式的程式碼是："

#: ../../extending/embedding.rst:146
#, fuzzy
msgid ""
"This code loads a Python script using ``argv[1]``, and calls the function "
"named in ``argv[2]``.  Its integer arguments are the other values of the "
"``argv`` array.  If you :ref:`compile and link <compiling>` this program "
"(let's call the finished executable :program:`call`), and use it to execute "
"a Python script, such as:"
msgstr ""
"此程式碼使用 ``argv[1]`` 加載 Python 腳本，並呼叫 ``argv[2]`` 中命名的函式。"
"它的整數參數是 argv 數組的其他值。如果你 :ref:`compile and link <compiling>` "
"這個程式（讓我們呼叫完成的可執行文件 :program:`call`），並用它來執行 Python "
"腳本，例如："

#: ../../extending/embedding.rst:161
#, fuzzy
msgid "then the result should be:"
msgstr "那麼結果應該是："

#: ../../extending/embedding.rst:169
#, fuzzy
msgid ""
"Although the program is quite large for its functionality, most of the code "
"is for data conversion between Python and C, and for error reporting.  The "
"interesting part with respect to embedding Python starts with ::"
msgstr ""
"儘管該程式的功能相當龐大，但大部分程式碼用於 Python 和 C "
"之間的資料轉換以及錯誤報告。關於嵌入 Python 的有趣部分從 :: 開始"

#: ../../extending/embedding.rst:178
#, fuzzy
msgid ""
"After initializing the interpreter, the script is loaded using :c:func:"
"`PyImport_Import`.  This routine needs a Python string as its argument, "
"which is constructed using the :c:func:`PyUnicode_FromString` data "
"conversion routine. ::"
msgstr ""
"初始化直譯器後，使用 :c:func:`PyImport_Import` 加載腳本。這個例程需要一個 "
"Python 字串作為它的參數，它是使用 PyUnicode_FromString 資料轉換例程構造的。 "
"::"

#: ../../extending/embedding.rst:191
#, fuzzy
msgid ""
"Once the script is loaded, the name we're looking for is retrieved using :c:"
"func:`PyObject_GetAttrString`.  If the name exists, and the object returned "
"is callable, you can safely assume that it is a function.  The program then "
"proceeds by constructing a tuple of arguments as normal.  The call to the "
"Python function is then made with::"
msgstr ""
"加載腳本後，我們將使用 PyObject_GetAttrString 檢索我們要查找的名稱。如果名稱"
"存在，並且回傳的對像是可呼叫的，您可以安全地假設它是一個函式。然後程式繼續正"
"常構建參數元組。然後呼叫 Python 函式："

#: ../../extending/embedding.rst:199
#, fuzzy
msgid ""
"Upon return of the function, ``pValue`` is either ``NULL`` or it contains a "
"reference to the return value of the function.  Be sure to release the "
"reference after examining the value."
msgstr "函式回傳時，``pValue`` 要么是 "
"``NULL``，要么包含對函式回傳值的引用。請務必在檢查值後釋放引用。"

#: ../../extending/embedding.rst:207
#, fuzzy
msgid "Extending Embedded Python"
msgstr "擴充嵌入式 Python"

#: ../../extending/embedding.rst:209
#, fuzzy
msgid ""
"Until now, the embedded Python interpreter had no access to functionality "
"from the application itself.  The Python API allows this by extending the "
"embedded interpreter.  That is, the embedded interpreter gets extended with "
"routines provided by the application. While it sounds complex, it is not so "
"bad.  Simply forget for a while that the application starts the Python "
"interpreter.  Instead, consider the application to be a set of subroutines, "
"and write some glue code that gives Python access to those routines, just "
"like you would write a normal Python extension.  For example::"
msgstr ""
"到目前為止，嵌入式 Python 直譯器無法訪問應用程式本身的功能。 Python API 通過"
"擴充嵌入式直譯器來實作這一點。也就是說，嵌入式直譯器使用應用程式提供的例程進"
"行擴充。雖然聽起來很複雜，但還不錯。暫時忘記應用程式啟動 Python "
"直譯器。相反，將應用程式視為一組子例程，並編寫一些膠水程式碼，使 Python "
"能夠訪問這些例程，就像編寫普通的 Python 擴充一樣。例如：："

#: ../../extending/embedding.rst:246
#, fuzzy
msgid ""
"Insert the above code just above the :c:func:`main` function. Also, insert "
"the following two statements before the call to :c:func:`Py_Initialize`::"
msgstr ""
"將上述程式碼插入 :c:func:`main` 函式的正上方。此外，在呼叫 "
":c:func:`Py_Initialize`:: 之前插入以下兩個語句："

#: ../../extending/embedding.rst:252
#, fuzzy
msgid ""
"These two lines initialize the ``numargs`` variable, and make the :func:`emb."
"numargs` function accessible to the embedded Python interpreter. With these "
"extensions, the Python script can do things like"
msgstr ""
"這兩行初始化 ``numargs`` 變數，並使 :func:`emb.numargs` 函式可供嵌入式 "
"Python 直譯器訪問。有了這些擴充，Python 腳本可以做類似的事情"

#: ../../extending/embedding.rst:261
#, fuzzy
msgid ""
"In a real application, the methods will expose an API of the application to "
"Python."
msgstr "在實際應用程式中，這些方法會將應用程式的 API 公開給 Python。"

#: ../../extending/embedding.rst:271
#, fuzzy
msgid "Embedding Python in C++"
msgstr "在 C++ 中嵌入 Python"

#: ../../extending/embedding.rst:273
#, fuzzy
msgid ""
"It is also possible to embed Python in a C++ program; precisely how this is "
"done will depend on the details of the C++ system used; in general you will "
"need to write the main program in C++, and use the C++ compiler to compile "
"and link your program.  There is no need to recompile Python itself using C+"
"+."
msgstr ""
"也可以將 Python 嵌入到 C++ 程式中；具體如何完成將取決於所使用的 C++ "
"系統的細節；一般來說，您需要用 C++ 編寫主程式，並使用 C++ "
"編譯器編譯和鏈接您的程式。無需使用 C++ 重新編譯 Python 本身。"

#: ../../extending/embedding.rst:282
#, fuzzy
msgid "Compiling and Linking under Unix-like systems"
msgstr "類 Unix 系統下的編譯和鏈接"

#: ../../extending/embedding.rst:284
#, fuzzy
msgid ""
"It is not necessarily trivial to find the right flags to pass to your "
"compiler (and linker) in order to embed the Python interpreter into your "
"application, particularly because Python needs to load library modules "
"implemented as C dynamic extensions (:file:`.so` files) linked against it."
msgstr ""
"為了將 Python 直譯器嵌入到您的應用程式中，找到傳遞給編譯器（和鏈接器）的正確"
"旗標不一定是微不足道的，特別是因為 Python 需要加載作為 C "
"動態擴充實作的庫模組（:file:`.so ` 文件）鏈接到它。"

#: ../../extending/embedding.rst:290
#, fuzzy
msgid ""
"To find out the required compiler and linker flags, you can execute the :"
"file:`python{X.Y}-config` script which is generated as part of the "
"installation process (a :file:`python3-config` script may also be "
"available).  This script has several options, of which the following will be "
"directly useful to you:"
msgstr ""
"要找出所需的編譯器和鏈接器旗標，您可以執行作為安裝過程的一部分生成的 "
":file:`python{X.Y}-config` 腳本（也可以使用 :file:`python3-config` 腳本)."
"該腳本有幾個選項，其中以下選項將直接對您有用："

#: ../../extending/embedding.rst:296
#, fuzzy
msgid ""
"``pythonX.Y-config --cflags`` will give you the recommended flags when "
"compiling:"
msgstr "``pythonX.Y-config --cflags`` 會在編譯時給你推薦的旗標："

#: ../../extending/embedding.rst:304
#, fuzzy
msgid ""
"``pythonX.Y-config --ldflags --embed`` will give you the recommended flags "
"when linking:"
msgstr "``pythonX.Y-config --ldflags --embed`` 將在鏈接時為您提供推薦的旗標："

#: ../../extending/embedding.rst:313
#, fuzzy
msgid ""
"To avoid confusion between several Python installations (and especially "
"between the system Python and your own compiled Python), it is recommended "
"that you use the absolute path to :file:`python{X.Y}-config`, as in the "
"above example."
msgstr ""
"為避免多個 Python 安裝之間的混淆（尤其是系統 Python 和您自己編譯的 Python "
"之間），建議您使用 :file:`python{X.Y}-config` 的絕對路徑，如上例所示。"

#: ../../extending/embedding.rst:318
#, fuzzy
msgid ""
"If this procedure doesn't work for you (it is not guaranteed to work for all "
"Unix-like platforms; however, we welcome :ref:`bug reports <reporting-"
"bugs>`) you will have to read your system's documentation about dynamic "
"linking and/or examine Python's :file:`Makefile` (use :func:`sysconfig."
"get_makefile_filename` to find its location) and compilation options.  In "
"this case, the :mod:`sysconfig` module is a useful tool to programmatically "
"extract the configuration values that you will want to combine together.  "
"For example:"
msgstr ""
"如果此過程對您不起作用（不能保證它適用於所有類 Unix 平台；但是，我們歡迎 "
":ref:`bug 報告 <reporting-bugs>`）您將必須閱讀系統的有關動態的文檔鏈接和/"
"或檢查 Python 的 Makefile（使用 sysconfig.get_makefile_filename "
"找到它的位置）和編譯選項。在這種情況下，:mod:`sysconfig` "
"模組是一個有用的工具，可以以編程方式提取您想要組合在一起的配置值。例如："
