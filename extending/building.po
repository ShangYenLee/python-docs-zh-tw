# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-06 00:17+0000\n"
"PO-Revision-Date: 2018-05-23 14:09+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../extending/building.rst:7
msgid "Building C and C++ Extensions"
msgstr "建置 C 和 C++ 擴充"

#: ../../extending/building.rst:9
#, fuzzy
msgid ""
"A C extension for CPython is a shared library (e.g. a ``.so`` file on Linux, "
"``.pyd`` on Windows), which exports an *initialization function*."
msgstr ""
"CPython 的 C 擴充是一個共享庫（例如，Linux 上的 ``.so`` 文件，Windows 上的 ``"
".pyd`` 文件），它導出一個*初始化函式*。"

#: ../../extending/building.rst:12
#, fuzzy
msgid ""
"To be importable, the shared library must be available on :envvar:"
"`PYTHONPATH`, and must be named after the module name, with an appropriate "
"extension. When using distutils, the correct filename is generated "
"automatically."
msgstr ""
"要導入，共享庫必須在 :envvar:`PYTHONPATH` "
"上可用，並且必須以模組名稱命名，並帶有適當的擴充名。使用 distutils "
"時，會自動生成正確的文件名。"

#: ../../extending/building.rst:16
#, fuzzy
msgid "The initialization function has the signature:"
msgstr "初始化函式具有簽名："

#: ../../extending/building.rst:20
#, fuzzy
msgid ""
"It returns either a fully initialized module, or a :c:type:`PyModuleDef` "
"instance. See :ref:`initializing-modules` for details."
msgstr ""
"它回傳一個完全初始化的模組，或者一個 :c:type:`PyModuleDef` "
"實例。有關詳細資訊，請參閱 :ref:`initializing-modules`。"

#: ../../extending/building.rst:25
#, fuzzy
msgid ""
"For modules with ASCII-only names, the function must be named "
"``PyInit_<modulename>``, with ``<modulename>`` replaced by the name of the "
"module. When using :ref:`multi-phase-initialization`, non-ASCII module names "
"are allowed. In this case, the initialization function name is "
"``PyInitU_<modulename>``, with ``<modulename>`` encoded using Python's "
"*punycode* encoding with hyphens replaced by underscores. In Python::"
msgstr ""
"對於僅使用 ASCII 名稱的模組，該函式必須命名為“PyInit_<modulename>”，其中“<mod"
"ulename>”替換為模組名稱。使用 :ref:`multi-phase-initialization` 時，"
"允許使用非 ASCII 模組名稱。在這種情況下，初始化函式名稱是“PyInitU_<modulename"
">”，“<modulename>”使用 Python 的 *punycode* "
"編碼進行編碼，連字元替換為底線。在 Python 中："

#: ../../extending/building.rst:39
#, fuzzy
msgid ""
"It is possible to export multiple modules from a single shared library by "
"defining multiple initialization functions. However, importing them requires "
"using symbolic links or a custom importer, because by default only the "
"function corresponding to the filename is found. See the *\"Multiple modules "
"in one library\"* section in :pep:`489` for details."
msgstr ""
"通過定義多個初始化函式，可以從單個共享庫中導出多個模組。但是，導入它們需要使"
"用符號鏈接或自定義導入器，因為預設情況下只會找到與文件名對應的函式。有關詳細"
"資訊，請參閱 :pep:`489` 中的*“一個庫中的多個模組”*部分。"

#: ../../extending/building.rst:49
#, fuzzy
msgid "Building C and C++ Extensions with distutils"
msgstr "使用 distutils 建置 C 和 C++ 擴充"

#: ../../extending/building.rst:53
#, fuzzy
msgid ""
"Extension modules can be built using distutils,  which is included in "
"Python. Since distutils also supports creation of binary packages, users "
"don't necessarily need a compiler and distutils to install the extension."
msgstr ""
"可以使用 Python 中包含的 distutils 建置擴充模組。由於 distutils "
"還支援建立二進位包，因此使用者不一定需要編譯器和 distutils 來安裝擴充。"

#: ../../extending/building.rst:57
#, fuzzy
msgid ""
"A distutils package contains a driver script, :file:`setup.py`. This is a "
"plain Python file, which, in the most simple case, could look like this:"
msgstr ""
"distutils 包包含一個驅動程式腳本 :file:`setup.py`。這是一個普通的 Python "
"文件，在最簡單的情況下，它可能如下所示："

#: ../../extending/building.rst:73
#, fuzzy
msgid "With this :file:`setup.py`, and a file :file:`demo.c`, running ::"
msgstr "使用這個 :file:`setup.py` 和一個文件 :file:`demo.c`，運行 ::"

#: ../../extending/building.rst:77
#, fuzzy
msgid ""
"will compile :file:`demo.c`, and produce an extension module named ``demo`` "
"in the :file:`build` directory. Depending on the system, the module file "
"will end up in a subdirectory :file:`build/lib.system`, and may have a name "
"like :file:`demo.so` or :file:`demo.pyd`."
msgstr ""
"將編譯 demo.c，並在 build 目錄中生成名為 demo 的擴充模組。根據系統的不同，"
"模組文件最終將位於子目錄 :file:`build/lib.system` 中，並且可能具有類似 "
":file:`demo.so` 或 :file:`demo.pyd` 的名稱。"

#: ../../extending/building.rst:82
#, fuzzy
msgid ""
"In the :file:`setup.py`, all execution is performed by calling the ``setup`` "
"function. This takes a variable number of keyword arguments, of which the "
"example above uses only a subset. Specifically, the example specifies meta-"
"information to build packages, and it specifies the contents of the "
"package.  Normally, a package will contain additional modules, like Python "
"source modules, documentation, subpackages, etc. Please refer to the "
"distutils documentation in :ref:`distutils-index` to learn more about the "
"features of distutils; this section explains building extension modules only."
msgstr ""
"在 :file:`setup.py` 中，所有執行都是通過呼叫 ``setup`` 函式來執行的。這需要可"
"變數量的關鍵字參數，上面的示例僅使用其中的一個子集。具體來說，該示例指定了構"
"建包的元資訊，並指定了包的內容。通常，一個包會包含額外的模組，如 Python "
"源模組、文檔、子包等。請參閱 :ref:`distutils-index` 中的 distutils "
"文檔以了解有關 distutils 功能的更多資訊；本節僅解釋建置擴充模組。"

#: ../../extending/building.rst:91
#, fuzzy
msgid ""
"It is common to pre-compute arguments to :func:`setup`, to better structure "
"the driver script. In the example above, the ``ext_modules`` argument to :"
"func:`~distutils.core.setup` is a list of extension modules, each of which "
"is an instance of the :class:`~distutils.extension.Extension`. In the "
"example, the instance defines an extension named ``demo`` which is build by "
"compiling a single source file, :file:`demo.c`."
msgstr ""
"預先計算 :func:`setup` "
"的參數是很常見的，以更好地建置驅動程式腳本。在上面的示例中，:func:`~distutils"
".core.setup` 的 ``ext_modules`` 參數是一個擴充模組列表，每個擴充模組都是 "
":class:`~distutils.extension.Extension` 的一個實例."
"在示例中，實例定義了一個名為 ``demo``的擴充，它是通過編譯單個源文件 demo.c "
"建置的。"

#: ../../extending/building.rst:99
#, fuzzy
msgid ""
"In many cases, building an extension is more complex, since additional "
"preprocessor defines and libraries may be needed. This is demonstrated in "
"the example below."
msgstr "在許多情況下，建置擴充更為複雜，因為可能需要額外的預處理器定義和庫。這在下面"
"的示例中得到了證明。"

#: ../../extending/building.rst:127
#, fuzzy
msgid ""
"In this example, :func:`~distutils.core.setup` is called with additional "
"meta-information, which is recommended when distribution packages have to be "
"built. For the extension itself, it specifies preprocessor defines, include "
"directories, library directories, and libraries. Depending on the compiler, "
"distutils passes this information in different ways to the compiler. For "
"example, on Unix, this may result in the compilation commands ::"
msgstr ""
"在此示例中，呼叫 :func:`~distutils.core.setup` 時帶有額外的元資訊，建議在必須"
"建置分發包時使用。對於擴充本身，它指定預處理器定義、包含目錄、庫目錄和庫。根"
"據編譯器的不同，distutils 以不同的方式將此資訊傳遞給編譯器。例如，在 Unix "
"上，這可能導致編譯命令 ::"

#: ../../extending/building.rst:139
#, fuzzy
msgid ""
"These lines are for demonstration purposes only; distutils users should "
"trust that distutils gets the invocations right."
msgstr "這些行僅用於演示目的； distutils 使用者應該相信 distutils 會正確呼叫。"

#: ../../extending/building.rst:146
#, fuzzy
msgid "Distributing your extension modules"
msgstr "分發您的擴充模組"

#: ../../extending/building.rst:148
#, fuzzy
msgid ""
"When an extension has been successfully built, there are three ways to use "
"it."
msgstr "成功建置擴充後，可以通過三種方式使用它。"

#: ../../extending/building.rst:150
#, fuzzy
msgid ""
"End-users will typically want to install the module, they do so by running ::"
msgstr "最終使用者通常希望安裝該模組，他們通過運行 ::"

#: ../../extending/building.rst:154
#, fuzzy
msgid ""
"Module maintainers should produce source packages; to do so, they run ::"
msgstr "模組維護者應該生產源碼包；為此，他們運行 ::"

#: ../../extending/building.rst:158
#, fuzzy
msgid ""
"In some cases, additional files need to be included in a source "
"distribution; this is done through a :file:`MANIFEST.in` file; see :ref:"
"`manifest` for details."
msgstr ""
"在某些情況下，源程式碼分發中需要包含其他文件；這是通過 :file:`MANIFEST.in` "
"文件完成的；有關詳細資訊，請參閱 :ref:`manifest`。"

#: ../../extending/building.rst:161
#, fuzzy
msgid ""
"If the source distribution has been built successfully, maintainers can also "
"create binary distributions. Depending on the platform, one of the following "
"commands can be used to do so. ::"
msgstr "如果源碼分發已經成功建置，維護者也可以建立二進位分發。根據平台的不同，可以使"
"用以下命令之一來執行此操作。 ::"
