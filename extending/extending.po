# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Leon H., 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-06 00:23+0000\n"
"PO-Revision-Date: 2018-05-23 14:34+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../extending/extending.rst:8
msgid "Extending Python with C or C++"
msgstr "以 C 或 C++ 擴充 Python"

#: ../../extending/extending.rst:10
#, fuzzy
msgid ""
"It is quite easy to add new built-in modules to Python, if you know how to "
"program in C.  Such :dfn:`extension modules` can do two things that can't be "
"done directly in Python: they can implement new built-in object types, and "
"they can call C library functions and system calls."
msgstr ""
"向 Python 新增新的內建模組非常容易，如果你知道如何用 C 編程。"
"這樣的擴充模組可以做兩件不能直接在 Python 中完成的事情：它們可以實作新構建的-"
"in 對像型別，它們可以呼叫 C 庫函式和系統呼叫。"

#: ../../extending/extending.rst:15
#, fuzzy
msgid ""
"To support extensions, the Python API (Application Programmers Interface) "
"defines a set of functions, macros and variables that provide access to most "
"aspects of the Python run-time system.  The Python API is incorporated in a "
"C source file by including the header ``\"Python.h\"``."
msgstr ""
"為了支援擴充，Python API（應用程式員介面）定義了一組函式、巨集和變數，"
"它們提供對 Python 運行時系統大部分方面的訪問。 Python API 通過包含標題“Python"
".h”`` 合併到 C 源文件中。"

#: ../../extending/extending.rst:20
#, fuzzy
msgid ""
"The compilation of an extension module depends on its intended use as well "
"as on your system setup; details are given in later chapters."
msgstr "擴充模組的編譯取決於其預期用途以及您的系統設定；詳細資訊在後面的章節中給出。"

#: ../../extending/extending.rst:25
#, fuzzy
msgid ""
"The C extension interface is specific to CPython, and extension modules do "
"not work on other Python implementations.  In many cases, it is possible to "
"avoid writing C extensions and preserve portability to other "
"implementations. For example, if your use case is calling C library "
"functions or system calls, you should consider using the :mod:`ctypes` "
"module or the `cffi <https://cffi.readthedocs.io/>`_ library rather than "
"writing custom C code. These modules let you write Python code to interface "
"with C code and are more portable between implementations of Python than "
"writing and compiling a C extension module."
msgstr ""
"C 擴充介面特定於 CPython，擴充模組不適用於其他 Python 實作。在許多情況下，"
"可以避免編寫 C 擴充並保持對其他實作的可移植性。例如，如果您的用例是呼叫 C "
"庫函式或系統呼叫，您應該考慮使用 :mod:`ctypes` 模組或 `cffi <https://cffi."
"readthedocs.io/>`_ 庫而不是編寫自定義 C 程式碼。這些模組允許您編寫 Python "
"程式碼以與 C 程式碼交互，並且比編寫和編譯 C 擴充模組更易於在 Python "
"實作之間移植。"

#: ../../extending/extending.rst:40
msgid "A Simple Example"
msgstr "一個簡單範例"

#: ../../extending/extending.rst:42
#, fuzzy
msgid ""
"Let's create an extension module called ``spam`` (the favorite food of Monty "
"Python fans...) and let's say we want to create a Python interface to the C "
"library function :c:func:`system` [#]_. This function takes a null-"
"terminated character string as argument and returns an integer.  We want "
"this function to be callable from Python as follows:"
msgstr ""
"讓我們建立一個名為 ``spam`` 的擴充模組（Monty Python 粉絲最喜歡的食物...），"
"假設我們要為 C 庫函式建立一個 Python 介面 :c:func:`system` [#]_ ."
"此函式將以空字元結尾的字串作為參數並回傳一個整數。我們希望這個函式可以從 "
"Python 中呼叫，如下所示："

#: ../../extending/extending.rst:53
#, fuzzy
msgid ""
"Begin by creating a file :file:`spammodule.c`.  (Historically, if a module "
"is called ``spam``, the C file containing its implementation is called :file:"
"`spammodule.c`; if the module name is very long, like ``spammify``, the "
"module name can be just :file:`spammify.c`.)"
msgstr ""
"首先建立一個文件 :file:`spammodule.c`。 （從歷史上看，如果一個模組稱為 "
"``spam``，則包含其實作的 C 文件稱為 :file:`spammodule.c`；如果模組名稱很長，"
"如 ``spammify``，則模組名稱可以只是 :file:`spammify.c`。）"

#: ../../extending/extending.rst:58
#, fuzzy
msgid "The first two lines of our file can be::"
msgstr "我們文件的前兩行可以是："

#: ../../extending/extending.rst:63
#, fuzzy
msgid ""
"which pulls in the Python API (you can add a comment describing the purpose "
"of the module and a copyright notice if you like)."
msgstr "它引入了 Python API（如果願意，您可以新增描述模組用途的註釋和版權聲明）。"

#: ../../extending/extending.rst:68
#, fuzzy
msgid ""
"Since Python may define some pre-processor definitions which affect the "
"standard headers on some systems, you *must* include :file:`Python.h` before "
"any standard headers are included."
msgstr ""
"由於 Python "
"可能會定義一些預處理器定義，這些定義會影響某些系統上的標準標頭檔，因此您 "
"*必須* 在包含任何標準標頭檔之前包含 :file:`Python.h`。"

#: ../../extending/extending.rst:72
#, fuzzy
msgid ""
"It is recommended to always define ``PY_SSIZE_T_CLEAN`` before including "
"``Python.h``.  See :ref:`parsetuple` for a description of this macro."
msgstr ""
"建議在包含 ``Python.h`` 之前始終定義 ``PY_SSIZE_T_CLEAN``。有關此巨集的說明，"
"請參閱 :ref:`parsetuple`。"

#: ../../extending/extending.rst:75
#, fuzzy
msgid ""
"All user-visible symbols defined by :file:`Python.h` have a prefix of ``Py`` "
"or ``PY``, except those defined in standard header files. For convenience, "
"and since they are used extensively by the Python interpreter, ``\"Python.h"
"\"`` includes a few standard header files: ``<stdio.h>``, ``<string.h>``, "
"``<errno.h>``, and ``<stdlib.h>``.  If the latter header file does not exist "
"on your system, it declares the functions :c:func:`malloc`, :c:func:`free` "
"and :c:func:`realloc` directly."
msgstr ""
":file:`Python.h` 定義的所有使用者可見符號都有一個前綴 ``Py`` 或 "
"``PY``，標準標頭檔中定義的除外。為方便起見，並且由於它們被 Python "
"直譯器廣泛使用，``\"Python.h\"`` 包括一些標準標頭檔：``<stdio.h>``、``<string"
".h>``、 ``<errno.h>`` 和``<stdlib.h>``。如果後一個標頭檔在您的系統上不存在，"
"它會直接聲明函式:c:func:`malloc`、:c:func:`free` 和:c:func:`realloc`。"

#: ../../extending/extending.rst:83
#, fuzzy
msgid ""
"The next thing we add to our module file is the C function that will be "
"called when the Python expression ``spam.system(string)`` is evaluated "
"(we'll see shortly how it ends up being called)::"
msgstr ""
"接下來我們新增到模組文件的是 C 函式，它將在計算 Python 表達式 ``spam."
"system(string)`` 時被呼叫（我們很快就會看到它最終是如何被呼叫的）::"

#: ../../extending/extending.rst:99
#, fuzzy
msgid ""
"There is a straightforward translation from the argument list in Python (for "
"example, the single expression ``\"ls -l\"``) to the arguments passed to the "
"C function.  The C function always has two arguments, conventionally named "
"*self* and *args*."
msgstr ""
"從 Python 中的參數列表（例如，單個表達式 ``\"ls -l\"``）到傳遞給 C "
"函式的參數有一個直接的轉換。 C 函式總是有兩個參數，通常命名為 *self* 和 "
"*args*。"

#: ../../extending/extending.rst:104
#, fuzzy
msgid ""
"The *self* argument points to the module object for module-level functions; "
"for a method it would point to the object instance."
msgstr "*self* 參數指向模組級函式的模組物件；對於方法，它將指向物件實例。"

#: ../../extending/extending.rst:107
#, fuzzy
msgid ""
"The *args* argument will be a pointer to a Python tuple object containing "
"the arguments.  Each item of the tuple corresponds to an argument in the "
"call's argument list.  The arguments are Python objects --- in order to do "
"anything with them in our C function we have to convert them to C values.  "
"The function :c:func:`PyArg_ParseTuple` in the Python API checks the "
"argument types and converts them to C values.  It uses a template string to "
"determine the required types of the arguments as well as the types of the C "
"variables into which to store the converted values.  More about this later."
msgstr ""
"*args* 參數將是指向包含參數的 Python "
"元組物件的指標。元組的每一項對應於呼叫參數列表中的一個參數。參數是 Python "
"物件——為了在我們的 C 函式中對它們執行任何操作，我們必須將它們轉換為 C 值。 "
"Python API 中的函式:c:func:`PyArg_ParseTuple` 檢查參數型別並將它們轉換為 C "
"值。它使用模板字串來確定所需的參數型別以及用於儲存轉換值的 C "
"變數的型別。稍後會詳細介紹。"

#: ../../extending/extending.rst:116
#, fuzzy
msgid ""
":c:func:`PyArg_ParseTuple` returns true (nonzero) if all arguments have the "
"right type and its components have been stored in the variables whose "
"addresses are passed.  It returns false (zero) if an invalid argument list "
"was passed.  In the latter case it also raises an appropriate exception so "
"the calling function can return ``NULL`` immediately (as we saw in the "
"example)."
msgstr ""
":c:func:`PyArg_ParseTuple` 如果所有參數都具有正確的型別並且其組件已儲存在地址"
"被傳遞的變數中，則回傳真（非零）。如果傳遞了無效的參數列表，它會回傳 false（"
"零）。在後一種情況下，它還會引發一個適當的例外，以便呼叫函式可以立即回傳“NULL"
"”（正如我們在示例中看到的那樣）。"

#: ../../extending/extending.rst:126
#, fuzzy
msgid "Intermezzo: Errors and Exceptions"
msgstr "間奏曲：錯誤和例外"

#: ../../extending/extending.rst:128
#, fuzzy
msgid ""
"An important convention throughout the Python interpreter is the following: "
"when a function fails, it should set an exception condition and return an "
"error value (usually ``-1`` or a ``NULL`` pointer).  Exception information "
"is stored in three members of the interpreter's thread state.  These are "
"``NULL`` if there is no exception.  Otherwise they are the C equivalents of "
"the members of the Python tuple returned by :meth:`sys.exc_info`.  These are "
"the exception type, exception instance, and a traceback object.  It is "
"important to know about them to understand how errors are passed around."
msgstr ""
"貫穿 Python 直譯器的一個重要約定如下：當一個函式失敗時，它應該設定一個例外條"
"件並回傳一個錯誤值（通常是 ``-1``或 ``NULL`` 指標）。例外資訊儲存在直譯器執行緒狀態"
"的三個成員中。如果沒有例外，這些都是 ``NULL`` 。否則它們是 sys.exc_info 回傳的 "
"Python 元組成員的 C 等價物。它們是例外型別、例外實例和回溯物件。了解它們對於"
"理解錯誤是如何傳遞的很重要。"

#: ../../extending/extending.rst:137
#, fuzzy
msgid ""
"The Python API defines a number of functions to set various types of "
"exceptions."
msgstr "Python API 定義了許多函式來設定各種型別的例外。"

#: ../../extending/extending.rst:139
#, fuzzy
msgid ""
"The most common one is :c:func:`PyErr_SetString`.  Its arguments are an "
"exception object and a C string.  The exception object is usually a "
"predefined object like :c:data:`PyExc_ZeroDivisionError`.  The C string "
"indicates the cause of the error and is converted to a Python string object "
"and stored as the \"associated value\" of the exception."
msgstr ""
"最常見的是 :c:func:`PyErr_SetString`。它的參數是一個例外物件和一個 C "
"字串。例外物件通常是預定義的物件，如 :c:data:`PyExc_ZeroDivisionError`。 C "
"字串表示錯誤的原因，並轉換為 Python 字串物件並儲存為例外的“關聯值”。"

#: ../../extending/extending.rst:145
#, fuzzy
msgid ""
"Another useful function is :c:func:`PyErr_SetFromErrno`, which only takes an "
"exception argument and constructs the associated value by inspection of the "
"global variable :c:data:`errno`.  The most general function is :c:func:"
"`PyErr_SetObject`, which takes two object arguments, the exception and its "
"associated value.  You don't need to :c:func:`Py_INCREF` the objects passed "
"to any of these functions."
msgstr ""
"另一個有用的函式是:c:func:`PyErr_SetFromErrno`，它只接受一個例外參數並通過檢"
"查全局變數:c:data:`errno` 來構造關聯值。最通用的函式是 "
":c:func:`PyErr_SetObject`，它有兩個物件參數，即例外及其關聯值。您不需要 "
":c:func:`Py_INCREF` 將對像傳遞給這些函式中的任何一個。"

#: ../../extending/extending.rst:152
#, fuzzy
msgid ""
"You can test non-destructively whether an exception has been set with :c:"
"func:`PyErr_Occurred`.  This returns the current exception object, or "
"``NULL`` if no exception has occurred.  You normally don't need to call :c:"
"func:`PyErr_Occurred` to see whether an error occurred in a function call, "
"since you should be able to tell from the return value."
msgstr ""
"您可以非破壞性地測試是否已使用 :c:func:`PyErr_Occurred` "
"設定了例外。這將回傳當前例外物件，如果沒有發生例外，則回傳 ``NULL`` 。"
"您通常不需要呼叫 :c:func:`PyErr_Occurred` "
"來查看函式呼叫中是否發生錯誤，因為您應該能夠從回傳值中判斷出來。"

#: ../../extending/extending.rst:158
#, fuzzy
msgid ""
"When a function *f* that calls another function *g* detects that the latter "
"fails, *f* should itself return an error value (usually ``NULL`` or "
"``-1``).  It should *not* call one of the ``PyErr_*`` functions --- one has "
"already been called by *g*. *f*'s caller is then supposed to also return an "
"error indication to *its* caller, again *without* calling ``PyErr_*``, and "
"so on --- the most detailed cause of the error was already reported by the "
"function that first detected it.  Once the error reaches the Python "
"interpreter's main loop, this aborts the currently executing Python code and "
"tries to find an exception handler specified by the Python programmer."
msgstr ""
"當呼叫另一個函式 *g* 的函式 *f* 檢測到後者失敗時，*f* "
"本身應該回傳一個錯誤值（通常是 ``NULL`` 或 ``-1``）。它不應該*呼叫 "
"``PyErr_*`` 函式之一——一個已經被 *g* 呼叫過。 *f* 的呼叫者然後應該也向 *its* "
"呼叫者回傳一個錯誤指示，再次*不*呼叫``PyErr_*``，等等——最詳細的錯誤原因已經報"
"告了最先檢測到它的函式。一旦錯誤到達 Python 直譯器的主循環，"
"這將中止當前正在執行的 Python 程式碼並嘗試查找由 Python "
"程式員指定的例外處理程式。"

#: ../../extending/extending.rst:168
#, fuzzy
msgid ""
"(There are situations where a module can actually give a more detailed error "
"message by calling another ``PyErr_*`` function, and in such cases it is "
"fine to do so.  As a general rule, however, this is not necessary, and can "
"cause information about the cause of the error to be lost: most operations "
"can fail for a variety of reasons.)"
msgstr ""
"（在某些情況下，模組實際上可以通過呼叫另一個 ``PyErr_*`` 函式來給出更詳細的錯"
"誤消息，在這種情況下這樣做很好。然而，作為一般規則，這不是必需的，並且可能導"
"致有關錯誤原因的資訊丟失：大多數操作可能因各種原因而失敗。）"

#: ../../extending/extending.rst:174
#, fuzzy
msgid ""
"To ignore an exception set by a function call that failed, the exception "
"condition must be cleared explicitly by calling :c:func:`PyErr_Clear`.  The "
"only time C code should call :c:func:`PyErr_Clear` is if it doesn't want to "
"pass the error on to the interpreter but wants to handle it completely by "
"itself (possibly by trying something else, or pretending nothing went wrong)."
msgstr ""
"要忽略由失敗的函式呼叫設定的例外，必須通過呼叫 :c:func:`PyErr_Clear` "
"明確清除例外條件。 C 程式碼唯一應該呼叫 :c:func:`PyErr_Clear` 的情況是它不想"
"將錯誤傳遞給直譯器但想完全自己處理它（可能通過嘗試其他方法，或者假裝沒有出錯)"
"."

#: ../../extending/extending.rst:180
#, fuzzy
msgid ""
"Every failing :c:func:`malloc` call must be turned into an exception --- the "
"direct caller of :c:func:`malloc` (or :c:func:`realloc`) must call :c:func:"
"`PyErr_NoMemory` and return a failure indicator itself.  All the object-"
"creating functions (for example, :c:func:`PyLong_FromLong`) already do this, "
"so this note is only relevant to those who call :c:func:`malloc` directly."
msgstr ""
"每次失敗的 :c:func:`malloc` 呼叫都必須轉換為例外 --- :c:func:`malloc`（或 "
":c:func:`realloc`）的直接呼叫者必須呼叫 :c:func： `PyErr_NoMemory` 並回傳失敗"
"指示器本身。所有建立物件的函式（例如，:c:func:`PyLong_FromLong`）都已經這樣做"
"了，因此本說明僅與那些直接呼叫:c:func:`malloc` 的人相關。"

#: ../../extending/extending.rst:186
#, fuzzy
msgid ""
"Also note that, with the important exception of :c:func:`PyArg_ParseTuple` "
"and friends, functions that return an integer status usually return a "
"positive value or zero for success and ``-1`` for failure, like Unix system "
"calls."
msgstr ""
"另請注意，除了 :c:func:`PyArg_ParseTuple` "
"和朋友的重要例外，回傳整數狀態的函式通常回傳正值或零表示成功，``-1`` "
"表示失敗，如 Unix 系統呼叫。"

#: ../../extending/extending.rst:190
#, fuzzy
msgid ""
"Finally, be careful to clean up garbage (by making :c:func:`Py_XDECREF` or :"
"c:func:`Py_DECREF` calls for objects you have already created) when you "
"return an error indicator!"
msgstr ""
"最後，當您回傳錯誤指示器時，請小心清理垃圾（通過對您已經建立的物件進行 "
":c:func:`Py_XDECREF` 或 :c:func:`Py_DECREF` 呼叫）！"

#: ../../extending/extending.rst:194
#, fuzzy
msgid ""
"The choice of which exception to raise is entirely yours.  There are "
"predeclared C objects corresponding to all built-in Python exceptions, such "
"as :c:data:`PyExc_ZeroDivisionError`, which you can use directly. Of course, "
"you should choose exceptions wisely --- don't use :c:data:`PyExc_TypeError` "
"to mean that a file couldn't be opened (that should probably be :c:data:"
"`PyExc_IOError`). If something's wrong with the argument list, the :c:func:"
"`PyArg_ParseTuple` function usually raises :c:data:`PyExc_TypeError`.  If "
"you have an argument whose value must be in a particular range or must "
"satisfy other conditions, :c:data:`PyExc_ValueError` is appropriate."
msgstr ""
"選擇引發哪個例外完全由您決定。所有Python內建例外都有對應的預聲明C物件，如:c:d"
"ata:`PyExc_ZeroDivisionError`，可以直接使用。當然，您應該明智地選擇例外——"
"不要使用 :c:data:`PyExc_TypeError` 表示無法打開文件（應該是 "
":c:data:`PyExc_IOError`）。如果參數列表有問題，:c:func:`PyArg_ParseTuple` 函"
"式通常會引發:c:data:`PyExc_TypeError`。如果您有一個參數，其值必須在特定範圍內"
"或必須滿足其他條件，那麼 :c:data:`PyExc_ValueError` 是合適的。"

#: ../../extending/extending.rst:204
#, fuzzy
msgid ""
"You can also define a new exception that is unique to your module. For this, "
"you usually declare a static object variable at the beginning of your file::"
msgstr "您還可以定義一個對您的模組唯一的新例外。為此，您通常在文件的開頭聲明一個靜態"
"對像變數::"

#: ../../extending/extending.rst:209
#, fuzzy
msgid ""
"and initialize it in your module's initialization function (:c:func:"
"`PyInit_spam`) with an exception object::"
msgstr "並使用例外對像在模組的初始化函式 (:c:func:`PyInit_spam`) 中初始化它::"

#: ../../extending/extending.rst:233
#, fuzzy
msgid ""
"Note that the Python name for the exception object is :exc:`spam.error`.  "
"The :c:func:`PyErr_NewException` function may create a class with the base "
"class being :exc:`Exception` (unless another class is passed in instead of "
"``NULL``), described in :ref:`bltin-exceptions`."
msgstr ""
"請注意，例外物件的 Python 名稱是 :exc:`spam.error`。 "
":c:func:`PyErr_NewException` 函式可以建立一個基底類別為 :exc:`Exception` "
"的類（除非傳入另一個類而不是 ``NULL``），在 :ref:`bltin-exceptions "
"中有描述`。"

#: ../../extending/extending.rst:238
#, fuzzy
msgid ""
"Note also that the :c:data:`SpamError` variable retains a reference to the "
"newly created exception class; this is intentional!  Since the exception "
"could be removed from the module by external code, an owned reference to the "
"class is needed to ensure that it will not be discarded, causing :c:data:"
"`SpamError` to become a dangling pointer. Should it become a dangling "
"pointer, C code which raises the exception could cause a core dump or other "
"unintended side effects."
msgstr ""
"還要注意 :c:data:`SpamError` 變數保留了對新建立的例外類的引用；這是故意的！由"
"於例外可以通過外部程式碼從模組中刪除，因此需要一個對類的擁有引用以確保它不會"
"被丟棄，從而導致 :c:data:`SpamError` 成為懸空指標。如果它變成懸空指標，"
"引發例外的 C 程式碼可能會導致核心轉儲或其他意外的副作用。"

#: ../../extending/extending.rst:245
#, fuzzy
msgid ""
"We discuss the use of ``PyMODINIT_FUNC`` as a function return type later in "
"this sample."
msgstr "我們稍後將在本示例中討論使用“PyMODINIT_FUNC”作為函式回傳型別。"

#: ../../extending/extending.rst:248
#, fuzzy
msgid ""
"The :exc:`spam.error` exception can be raised in your extension module using "
"a call to :c:func:`PyErr_SetString` as shown below::"
msgstr ":exc:`spam.error` 例外可以通過呼叫 :c:func:`PyErr_SetString` "
"在您的擴充模組中引發，如下所示："

#: ../../extending/extending.rst:271
msgid "Back to the Example"
msgstr "回到範例"

#: ../../extending/extending.rst:273
#, fuzzy
msgid ""
"Going back to our example function, you should now be able to understand "
"this statement::"
msgstr "回到我們的示例函式，您現在應該能夠理解這個語句::"

#: ../../extending/extending.rst:279
#, fuzzy
msgid ""
"It returns ``NULL`` (the error indicator for functions returning object "
"pointers) if an error is detected in the argument list, relying on the "
"exception set by :c:func:`PyArg_ParseTuple`.  Otherwise the string value of "
"the argument has been copied to the local variable :c:data:`command`.  This "
"is a pointer assignment and you are not supposed to modify the string to "
"which it points (so in Standard C, the variable :c:data:`command` should "
"properly be declared as ``const char *command``)."
msgstr ""
"如果在參數列表中檢測到錯誤，它回傳 ``NULL``（函式回傳物件指標的錯誤指示符），"
"依賴於 :c:func:`PyArg_ParseTuple` 設定的例外。否則，"
"參數的字串值已被複製到局部變數 "
":c:data:`command`。這是一個指標賦值，您不應該修改它指向的字串（因此在標準 C "
"中，變數 :c:data:`command` 應該正確地聲明為 ``const char *command``）。"

#: ../../extending/extending.rst:287
#, fuzzy
msgid ""
"The next statement is a call to the Unix function :c:func:`system`, passing "
"it the string we just got from :c:func:`PyArg_ParseTuple`::"
msgstr ""
"下一條語句是對 Unix 函式 :c:func:`system` 的呼叫，將我們剛剛從 "
":c:func:`PyArg_ParseTuple` 獲得的字串傳遞給它::"

#: ../../extending/extending.rst:292
#, fuzzy
msgid ""
"Our :func:`spam.system` function must return the value of :c:data:`sts` as a "
"Python object.  This is done using the function :c:func:`PyLong_FromLong`. ::"
msgstr ""
"我們的 :func:`spam.system` 函式必須回傳 :c:data:`sts` 的值作為 Python 物件。"
"這是使用函式 :c:func:`PyLong_FromLong` 完成的。 ::"

#: ../../extending/extending.rst:297
#, fuzzy
msgid ""
"In this case, it will return an integer object.  (Yes, even integers are "
"objects on the heap in Python!)"
msgstr "在這種情況下，它將回傳一個整數物件。 （是的，即使是整數也是 Python "
"中堆上的物件！）"

#: ../../extending/extending.rst:300
#, fuzzy
msgid ""
"If you have a C function that returns no useful argument (a function "
"returning :c:expr:`void`), the corresponding Python function must return "
"``None``.   You need this idiom to do so (which is implemented by the :c:"
"macro:`Py_RETURN_NONE` macro)::"
msgstr ""
"如果您有一個不回傳任何有用參數的 C 函式（一個回傳 :c:expr:`void` 的函式），"
"相應的 Python 函式必須回傳 ``None``。你需要這個習慣用法來做到這一點（這是由 "
":c:macro:`Py_RETURN_NONE` 巨集實作的）："

#: ../../extending/extending.rst:308
#, fuzzy
msgid ""
":c:data:`Py_None` is the C name for the special Python object ``None``.  It "
"is a genuine Python object rather than a ``NULL`` pointer, which means "
"\"error\" in most contexts, as we have seen."
msgstr ""
":c:data:`Py_None` 是特殊 Python 物件``None`` 的 C 名稱。它是一個真正的 "
"Python 物件，而不是一個 ``NULL`` "
"指標，正如我們所見，在大多數情況下這意味著“錯誤”。"

#: ../../extending/extending.rst:316
#, fuzzy
msgid "The Module's Method Table and Initialization Function"
msgstr "模組的方法表和初始化函式"

#: ../../extending/extending.rst:318
#, fuzzy
msgid ""
"I promised to show how :c:func:`spam_system` is called from Python programs. "
"First, we need to list its name and address in a \"method table\"::"
msgstr "我答應展示如何從 Python 程式呼叫 "
":c:func:`spam_system`。首先，我們需要在“方法表”中列出它的名稱和地址::"

#: ../../extending/extending.rst:329
#, fuzzy
msgid ""
"Note the third entry (``METH_VARARGS``).  This is a flag telling the "
"interpreter the calling convention to be used for the C function.  It should "
"normally always be ``METH_VARARGS`` or ``METH_VARARGS | METH_KEYWORDS``; a "
"value of ``0`` means that an obsolete variant of :c:func:`PyArg_ParseTuple` "
"is used."
msgstr ""
"注意第三個條目（``METH_VARARGS``）。這是一個旗標，告訴直譯器要用於 C "
"函式的呼叫約定。它通常應該總是 ``METH_VARARGS`` 或 ``METH_VARARGS | "
"METH_KEYWORDS``;值 ``0`` 表示使用了 :c:func:`PyArg_ParseTuple` 的過時變體。"

#: ../../extending/extending.rst:334
#, fuzzy
msgid ""
"When using only ``METH_VARARGS``, the function should expect the Python-"
"level parameters to be passed in as a tuple acceptable for parsing via :c:"
"func:`PyArg_ParseTuple`; more information on this function is provided below."
msgstr ""
"當僅使用 ``METH_VARARGS`` 時，該函式應該期望 Python 級參數作為元組傳入，"
"以便通過 PyArg_ParseTuple 進行解析；下面提供了有關此功能的更多資訊。"

#: ../../extending/extending.rst:338
#, fuzzy
msgid ""
"The :const:`METH_KEYWORDS` bit may be set in the third field if keyword "
"arguments should be passed to the function.  In this case, the C function "
"should accept a third ``PyObject *`` parameter which will be a dictionary of "
"keywords. Use :c:func:`PyArg_ParseTupleAndKeywords` to parse the arguments "
"to such a function."
msgstr ""
"如果要將關鍵字參數傳遞給函式，可以在第三個欄位中設定 :const:`METH_KEYWORDS` "
"位。在這種情況下，C 函式應該接受第三個“PyObject "
"*”參數，它將是一個關鍵字字典。使用:c:func:`PyArg_ParseTupleAndKeywords` "
"來解析此類函式的參數。"

#: ../../extending/extending.rst:344
#, fuzzy
msgid ""
"The method table must be referenced in the module definition structure::"
msgstr "方法表必須在模組定義結構中被引用::"

#: ../../extending/extending.rst:355
#, fuzzy
msgid ""
"This structure, in turn, must be passed to the interpreter in the module's "
"initialization function.  The initialization function must be named :c:func:"
"`PyInit_name`, where *name* is the name of the module, and should be the "
"only non-\\ ``static`` item defined in the module file::"
msgstr ""
"反過來，這個結構必須在模組的初始化函式中傳遞給直譯器。初始化函式必須命名為 "
":c:func:`PyInit_name`，其中 *name* 是模組的名稱，"
"並且應該是模組文件中定義的唯一非\\ ``static`` 項::"

#: ../../extending/extending.rst:366
#, fuzzy
msgid ""
"Note that PyMODINIT_FUNC declares the function as ``PyObject *`` return "
"type, declares any special linkage declarations required by the platform, "
"and for C++ declares the function as ``extern \"C\"``."
msgstr ""
"請注意，PyMODINIT_FUNC 將函式聲明為 ``PyObject *`` "
"回傳型別，聲明平台所需的任何特殊鏈接聲明，對於 C++，將函式聲明為 ``extern \"C"
"\"``。"

#: ../../extending/extending.rst:370
#, fuzzy
msgid ""
"When the Python program imports module :mod:`spam` for the first time, :c:"
"func:`PyInit_spam` is called. (See below for comments about embedding "
"Python.) It calls :c:func:`PyModule_Create`, which returns a module object, "
"and inserts built-in function objects into the newly created module based "
"upon the table (an array of :c:type:`PyMethodDef` structures) found in the "
"module definition. :c:func:`PyModule_Create` returns a pointer to the module "
"object that it creates.  It may abort with a fatal error for certain errors, "
"or return ``NULL`` if the module could not be initialized satisfactorily. "
"The init function must return the module object to its caller, so that it "
"then gets inserted into ``sys.modules``."
msgstr ""
"當 Python 程式第一次導入模組 :mod:`spam` 時，:c:func:`PyInit_spam` 被呼叫。 "
"（有關嵌入 Python 的評論見下文。）它呼叫 "
":c:func:`PyModule_Create`，它回傳一個模組物件，並根據表（一個 :c: "
"type:`PyMethodDef` 結構）在模組定義中找到。 :c:func:`PyModule_Create` 回傳指"
"向它建立的模組物件的指標。對於某些錯誤，它可能會因致命錯誤而中止，或者如果模"
"組無法令人滿意地初始化，則回傳 ``NULL`` 。 init "
"函式必須將模組物件回傳給它的呼叫者，這樣它就會被插入到“sys.modules”中。"

#: ../../extending/extending.rst:381
#, fuzzy
msgid ""
"When embedding Python, the :c:func:`PyInit_spam` function is not called "
"automatically unless there's an entry in the :c:data:`PyImport_Inittab` "
"table. To add the module to the initialization table, use :c:func:"
"`PyImport_AppendInittab`, optionally followed by an import of the module::"
msgstr ""
"嵌入 Python 時，不會自動呼叫 PyInit_spam 函式，除非在 "
":c:data:`PyImport_Inittab` 表中有一個條目。要將模組新增到初始化表，請使用 :c:"
"func:`PyImport_AppendInittab`，之後可以選擇導入模組："

#: ../../extending/extending.rst:425
#, fuzzy
msgid ""
"Removing entries from ``sys.modules`` or importing compiled modules into "
"multiple interpreters within a process (or following a :c:func:`fork` "
"without an intervening :c:func:`exec`) can create problems for some "
"extension modules. Extension module authors should exercise caution when "
"initializing internal data structures."
msgstr ""
"從 ``sys.modules`` 中刪除條目或將已編譯的模組導入行程中的多個直譯器（"
"或在沒有 :c:func:`exec` 介入的 :c:func:`fork` 之後）可能會為某些擴充帶來問題"
"模組。擴充模組作者在初始化內部資料結構時應謹慎行事。"

#: ../../extending/extending.rst:431
#, fuzzy
msgid ""
"A more substantial example module is included in the Python source "
"distribution as :file:`Modules/xxmodule.c`.  This file may be used as a  "
"template or simply read as an example."
msgstr ""
"Python 源程式碼分發中包含一個更重要的示例模組，如 :file:`Modules/xxmodule."
"c`。該文件可用作模板或僅作為示例閱讀。"

#: ../../extending/extending.rst:437
#, fuzzy
msgid ""
"Unlike our ``spam`` example, ``xxmodule`` uses *multi-phase initialization* "
"(new in Python 3.5), where a PyModuleDef structure is returned from "
"``PyInit_spam``, and creation of the module is left to the import machinery. "
"For details on multi-phase initialization, see :PEP:`489`."
msgstr ""
"與我們的“垃圾郵件”示例不同， ``xxmodule`` 使用*多階段初始化*（Python 3.5 "
"中的新功能），其中從“PyInit_spam”回傳 PyModuleDef 結構，模組的建立留給進口機"
"械。有關多階段初始化的詳細資訊，請參閱 :PEP:`489`。"

#: ../../extending/extending.rst:446
#, fuzzy
msgid "Compilation and Linkage"
msgstr "編譯鏈接"

#: ../../extending/extending.rst:448
#, fuzzy
msgid ""
"There are two more things to do before you can use your new extension: "
"compiling and linking it with the Python system.  If you use dynamic "
"loading, the details may depend on the style of dynamic loading your system "
"uses; see the chapters about building extension modules (chapter :ref:"
"`building`) and additional information that pertains only to building on "
"Windows (chapter :ref:`building-on-windows`) for more information about this."
msgstr ""
"在您可以使用新擴充之前還有兩件事要做：編譯它並將其與 Python 系統鏈接。如果您"
"使用動態加載，細節可能取決於您的系統使用的動態加載風格；有關此的更多資訊，請"
"參閱有關構建擴充模組的章節（章節 :ref:`building`）和僅適用於在 Windows "
"上構建的其他資訊（章節 :ref:`building-on-windows`）。"

#: ../../extending/extending.rst:455
#, fuzzy
msgid ""
"If you can't use dynamic loading, or if you want to make your module a "
"permanent part of the Python interpreter, you will have to change the "
"configuration setup and rebuild the interpreter.  Luckily, this is very "
"simple on Unix: just place your file (:file:`spammodule.c` for example) in "
"the :file:`Modules/` directory of an unpacked source distribution, add a "
"line to the file :file:`Modules/Setup.local` describing your file:"
msgstr ""
"如果你不能使用動態加載，或者如果你想讓你的模組成為 Python "
"直譯器的永久部分，你將不得不更改配置設定並重建直譯器。幸運的是，這在 Unix "
"上非常簡單：只需將文件（例如 :file:`spammodule."
"c`）放在解壓後的源程式碼分發的 :file:`Modules/` "
"目錄中，在文件中新增一行：file： `Modules/Setup.local` 描述您的文件："

#: ../../extending/extending.rst:466
#, fuzzy
msgid ""
"and rebuild the interpreter by running :program:`make` in the toplevel "
"directory.  You can also run :program:`make` in the :file:`Modules/` "
"subdirectory, but then you must first rebuild :file:`Makefile` there by "
"running ':program:`make` Makefile'.  (This is necessary each time you change "
"the :file:`Setup` file.)"
msgstr ""
"並通過在頂層目錄中運行 :program:`make` 來重建直譯器。您也可以在 :file:`"
"Modules/` 子目錄中運行 :program:`make` ，但是您必須首先通過運行 "
"':program:`make` Makefile' 在那裡重建 :file:`Makefile` 。 （每次更改 "
":file:`Setup` 文件時都需要這樣做。）"

#: ../../extending/extending.rst:472
#, fuzzy
msgid ""
"If your module requires additional libraries to link with, these can be "
"listed on the line in the configuration file as well, for instance:"
msgstr "如果你的模組需要額外的庫來鏈接，這些庫也可以列在配置文件的行中，例如："

#: ../../extending/extending.rst:483
#, fuzzy
msgid "Calling Python Functions from C"
msgstr "從 C 呼叫 Python 函式"

#: ../../extending/extending.rst:485
#, fuzzy
msgid ""
"So far we have concentrated on making C functions callable from Python.  The "
"reverse is also useful: calling Python functions from C. This is especially "
"the case for libraries that support so-called \"callback\" functions.  If a "
"C interface makes use of callbacks, the equivalent Python often needs to "
"provide a callback mechanism to the Python programmer; the implementation "
"will require calling the Python callback functions from a C callback.  Other "
"uses are also imaginable."
msgstr ""
"到目前為止，我們一直專注於使 C 函式可從 Python 呼叫。反過來也很有用：從 C "
"呼叫 Python 函式。對於支援所謂的“回呼”函式的庫來說尤其如此。如果 C "
"介面使用回呼，則等效的 Python 通常需要為 Python 程式員提供回呼機制；"
"該實作將需要從 C 回呼呼叫 Python 回呼函式。其他用途也是可以想像的。"

#: ../../extending/extending.rst:493
#, fuzzy
msgid ""
"Fortunately, the Python interpreter is easily called recursively, and there "
"is a standard interface to call a Python function.  (I won't dwell on how to "
"call the Python parser with a particular string as input --- if you're "
"interested, have a look at the implementation of the :option:`-c` command "
"line option in :file:`Modules/main.c` from the Python source code.)"
msgstr ""
"幸運的是，Python 直譯器很容易被遞迴呼叫，並且有一個標準的介面來呼叫 Python "
"函式。 （我不會詳述如何使用特定字串作為輸入呼叫 Python 解析器——如果您有興趣，"
"請查看 :option:`-c` 命令列選項在 :file 中的實作：來自 Python 源程式碼的`"
"Modules/main.c`。）"

#: ../../extending/extending.rst:499
#, fuzzy
msgid ""
"Calling a Python function is easy.  First, the Python program must somehow "
"pass you the Python function object.  You should provide a function (or some "
"other interface) to do this.  When this function is called, save a pointer "
"to the Python function object (be careful to :c:func:`Py_INCREF` it!) in a "
"global variable --- or wherever you see fit. For example, the following "
"function might be part of a module definition::"
msgstr ""
"呼叫 Python 函式很容易。首先，Python 程式必須以某種方式將 Python 函式對像傳遞"
"給您。您應該提供一個函式（或其他介面）來執行此操作。呼叫此函式時，將指向 "
"Python 函式物件的指標（小心 :c:func:`Py_INCREF` 它！）保存在全局變數 --- "
"或您認為合適的任何位置。例如，以下函式可能是模組定義的一部分："

#: ../../extending/extending.rst:529
#, fuzzy
msgid ""
"This function must be registered with the interpreter using the :const:"
"`METH_VARARGS` flag; this is described in section :ref:`methodtable`.  The :"
"c:func:`PyArg_ParseTuple` function and its arguments are documented in "
"section :ref:`parsetuple`."
msgstr ""
"此函式必須使用 METH_VARARGS 旗標向直譯器註冊；這在 :ref:`methodtable` "
"部分中有描述。 :c:func:`PyArg_ParseTuple` 函式及其參數記錄在 "
":ref:`parsetuple` 部分。"

#: ../../extending/extending.rst:534
#, fuzzy
msgid ""
"The macros :c:func:`Py_XINCREF` and :c:func:`Py_XDECREF` increment/decrement "
"the reference count of an object and are safe in the presence of ``NULL`` "
"pointers (but note that *temp* will not be  ``NULL`` in this context).  More "
"info on them in section :ref:`refcounts`."
msgstr ""
"巨集 :c:func:`Py_XINCREF` 和 :c:func:`Py_XDECREF` 遞增/"
"遞減物件的引用計數並且在存在 ``NULL`` 指標時是安全的（但請注意 *temp* "
"不會在此上下文中為 ``NULL`` ）。有關它們的更多資訊，請參閱 :ref:`refcounts` "
"部分。"

#: ../../extending/extending.rst:541
#, fuzzy
msgid ""
"Later, when it is time to call the function, you call the C function :c:func:"
"`PyObject_CallObject`.  This function has two arguments, both pointers to "
"arbitrary Python objects: the Python function, and the argument list.  The "
"argument list must always be a tuple object, whose length is the number of "
"arguments.  To call the Python function with no arguments, pass in ``NULL``, "
"or an empty tuple; to call it with one argument, pass a singleton tuple. :c:"
"func:`Py_BuildValue` returns a tuple when its format string consists of zero "
"or more format codes between parentheses.  For example::"
msgstr ""
"稍後，當需要呼叫函式時，呼叫 C 函式 "
":c:func:`PyObject_CallObject`。這個函式有兩個參數，都是指向任意 Python "
"物件的指標：Python "
"函式和參數列表。參數列表必須始終是一個元組物件，其長度是參數的數量。"
"要不帶參數呼叫 Python "
"函式，請傳入 ``NULL`` 或空元組；要用一個參數呼叫它，傳遞一個單例元組。 "
":c:func:`Py_BuildValue` "
"在其格式字串由括號之間的零個或多個格式程式碼組成時回傳一個元組。例如：："

#: ../../extending/extending.rst:561
#, fuzzy
msgid ""
":c:func:`PyObject_CallObject` returns a Python object pointer: this is the "
"return value of the Python function.  :c:func:`PyObject_CallObject` is "
"\"reference-count-neutral\" with respect to its arguments.  In the example a "
"new tuple was created to serve as the argument list, which is :c:func:"
"`Py_DECREF`\\ -ed immediately after the :c:func:`PyObject_CallObject` call."
msgstr ""
":c:func:`PyObject_CallObject` 回傳一個 Python 物件指標：這是 Python "
"函式的回傳值。 :c:func:`PyObject_CallObject` 就其參數而言是“引用計數中立的”。"
"在這個例子中，建立了一個新的元組作為參數列表，它是:c:func:`Py_DECREF`\\ - "
"在:c:func:`PyObject_CallObject` 呼叫之後立即編輯。"

#: ../../extending/extending.rst:568
#, fuzzy
msgid ""
"The return value of :c:func:`PyObject_CallObject` is \"new\": either it is a "
"brand new object, or it is an existing object whose reference count has been "
"incremented.  So, unless you want to save it in a global variable, you "
"should somehow :c:func:`Py_DECREF` the result, even (especially!) if you are "
"not interested in its value."
msgstr ""
":c:func:`PyObject_CallObject` 的回傳值是“新的”：它要么是一個全新的物件，要么"
"是一個引用計數已增加的現有物件。所以，除非你想把它保存在一個全局變數中，"
"否則你應該以某種方式 :c:func:`Py_DECREF` "
"結果，即使（尤其是！）如果你對它的值不感興趣。"

#: ../../extending/extending.rst:574
#, fuzzy
msgid ""
"Before you do this, however, it is important to check that the return value "
"isn't ``NULL``.  If it is, the Python function terminated by raising an "
"exception. If the C code that called :c:func:`PyObject_CallObject` is called "
"from Python, it should now return an error indication to its Python caller, "
"so the interpreter can print a stack trace, or the calling Python code can "
"handle the exception. If this is not possible or desirable, the exception "
"should be cleared by calling :c:func:`PyErr_Clear`.  For example::"
msgstr ""
"然而，在執行此操作之前，重要的是檢查回傳值是否為 ``NULL`` 。如果是，則 Python "
"函式會引發例外而終止。如果呼叫 :c:func:`PyObject_CallObject` 的 C 程式碼是從 "
"Python 呼叫的，它現在應該向其 Python "
"呼叫者回傳錯誤指示，以便直譯器可以印出堆疊跟踪，或者呼叫 Python "
"程式碼可以處理例外。如果這不可能或不可取，則應通過呼叫 :c:func:`PyErr_Clear` "
"清除例外。例如：："

#: ../../extending/extending.rst:587
#, fuzzy
msgid ""
"Depending on the desired interface to the Python callback function, you may "
"also have to provide an argument list to :c:func:`PyObject_CallObject`.  In "
"some cases the argument list is also provided by the Python program, through "
"the same interface that specified the callback function.  It can then be "
"saved and used in the same manner as the function object.  In other cases, "
"you may have to construct a new tuple to pass as the argument list.  The "
"simplest way to do this is to call :c:func:`Py_BuildValue`.  For example, if "
"you want to pass an integral event code, you might use the following code::"
msgstr ""
"根據所需的 Python 回呼函式介面，您可能還必須為 :c:func:`PyObject_CallObject` "
"提供一個參數列表。在某些情況下，參數列表也由 Python 程式通過指定回呼函式的同"
"一介面提供。然後可以像函式對像一樣保存和使用它。在其他情況下，您可能必須構造"
"一個新元組作為參數列表傳遞。最簡單的方法是呼叫 :c:func:`Py_BuildValue`。例如"
"，如果你想傳遞一個完整的事件程式碼，你可能會使用下面的程式碼："

#: ../../extending/extending.rst:606
#, fuzzy
msgid ""
"Note the placement of ``Py_DECREF(arglist)`` immediately after the call, "
"before the error check!  Also note that strictly speaking this code is not "
"complete: :c:func:`Py_BuildValue` may run out of memory, and this should be "
"checked."
msgstr ""
"請注意在錯誤檢查之前呼叫後立即放置 Py_DECREF(arglist) "
"！另請注意，嚴格來說這段程式碼並不完整：:c:func:`Py_BuildValue` "
"可能會耗盡記憶體，這應該進行檢查。"

#: ../../extending/extending.rst:610
#, fuzzy
msgid ""
"You may also call a function with keyword arguments by using :c:func:"
"`PyObject_Call`, which supports arguments and keyword arguments.  As in the "
"above example, we use :c:func:`Py_BuildValue` to construct the dictionary. ::"
msgstr ""
"您還可以使用 :c:func:`PyObject_Call` "
"呼叫帶有關鍵字參數的函式，它支援參數和關鍵字參數。如上例所示，我們使用 "
":c:func:`Py_BuildValue` 來構建字典。 ::"

#: ../../extending/extending.rst:628
#, fuzzy
msgid "Extracting Parameters in Extension Functions"
msgstr "在擴充函式中提取參數"

#: ../../extending/extending.rst:632
#, fuzzy
msgid "The :c:func:`PyArg_ParseTuple` function is declared as follows::"
msgstr ":c:func:`PyArg_ParseTuple` 函式聲明如下："

#: ../../extending/extending.rst:636
#, fuzzy
msgid ""
"The *arg* argument must be a tuple object containing an argument list passed "
"from Python to a C function.  The *format* argument must be a format string, "
"whose syntax is explained in :ref:`arg-parsing` in the Python/C API "
"Reference Manual.  The remaining arguments must be addresses of variables "
"whose type is determined by the format string."
msgstr ""
"*arg* 參數必須是包含從 Python 傳遞到 C 函式的參數列表的元組物件。 *format* "
"參數必須是格式字串，其語法在 Python/C API 參考手冊的 :ref:`arg-parsing` "
"中有解釋。其餘參數必須是變數的地址，其型別由格式字串確定。"

#: ../../extending/extending.rst:642
#, fuzzy
msgid ""
"Note that while :c:func:`PyArg_ParseTuple` checks that the Python arguments "
"have the required types, it cannot check the validity of the addresses of C "
"variables passed to the call: if you make mistakes there, your code will "
"probably crash or at least overwrite random bits in memory.  So be careful!"
msgstr ""
"請注意，雖然 :c:func:`PyArg_ParseTuple` 檢查 Python 參數是否具有所需的型別，"
"但它無法檢查傳遞給呼叫的 C 變數地址的有效性：如果你在那裡犯了錯誤，你的程式碼"
"可能會崩潰或在最少覆蓋記憶體中的隨機位。所以要小心！"

#: ../../extending/extending.rst:647
#, fuzzy
msgid ""
"Note that any Python object references which are provided to the caller are "
"*borrowed* references; do not decrement their reference count!"
msgstr "請注意，提供給呼叫者的任何 Python 物件引用都是 *借用* "
"引用；不要減少它們的引用計數！"

#: ../../extending/extending.rst:650
msgid "Some example calls::"
msgstr ""
"一些呼叫範例：\n"
"\n"
"::"

#: ../../extending/extending.rst:720
#, fuzzy
msgid "Keyword Parameters for Extension Functions"
msgstr "擴充函式的關鍵字參數"

#: ../../extending/extending.rst:724
#, fuzzy
msgid ""
"The :c:func:`PyArg_ParseTupleAndKeywords` function is declared as follows::"
msgstr ":c:func:`PyArg_ParseTupleAndKeywords` 函式聲明如下："

#: ../../extending/extending.rst:729
#, fuzzy
msgid ""
"The *arg* and *format* parameters are identical to those of the :c:func:"
"`PyArg_ParseTuple` function.  The *kwdict* parameter is the dictionary of "
"keywords received as the third parameter from the Python runtime.  The "
"*kwlist* parameter is a ``NULL``-terminated list of strings which identify "
"the parameters; the names are matched with the type information from "
"*format* from left to right.  On success, :c:func:"
"`PyArg_ParseTupleAndKeywords` returns true, otherwise it returns false and "
"raises an appropriate exception."
msgstr ""
"*arg* 和 *format* 參數與 :c:func:`PyArg_ParseTuple` 函式的參數相同。 *kwdict*"
" 參數是從 Python 運行時作為第三個參數接收的關鍵字字典。 *kwlist* "
"參數是一個以 ``NULL`` 結尾的字串列表，用於標識參數；名稱與 *format* "
"從左到右的型別資訊相匹配。成功時，:c:func:`PyArg_ParseTupleAndKeywords` 回傳 "
"true，否則回傳 false 並引發適當的例外。"

#: ../../extending/extending.rst:739
#, fuzzy
msgid ""
"Nested tuples cannot be parsed when using keyword arguments!  Keyword "
"parameters passed in which are not present in the *kwlist* will cause :exc:"
"`TypeError` to be raised."
msgstr "使用關鍵字參數時無法解析嵌套元組！ *kwlist* "
"中不存在的傳遞的關鍵字參數將導致引發 :exc:`TypeError`。"

#: ../../extending/extending.rst:745
#, fuzzy
msgid ""
"Here is an example module which uses keywords, based on an example by Geoff "
"Philbrick (philbrick@hks.com)::"
msgstr "這是一個使用關鍵字的示例模組，基於 Geoff Philbrick (philbrick@hks.com) "
"的示例："

#: ../../extending/extending.rst:800
#, fuzzy
msgid "Building Arbitrary Values"
msgstr "建立任意值"

#: ../../extending/extending.rst:802
#, fuzzy
msgid ""
"This function is the counterpart to :c:func:`PyArg_ParseTuple`.  It is "
"declared as follows::"
msgstr "此函式與 :c:func:`PyArg_ParseTuple` 對應。聲明如下："

#: ../../extending/extending.rst:807
#, fuzzy
msgid ""
"It recognizes a set of format units similar to the ones recognized by :c:"
"func:`PyArg_ParseTuple`, but the arguments (which are input to the function, "
"not output) must not be pointers, just values.  It returns a new Python "
"object, suitable for returning from a C function called from Python."
msgstr ""
"它識別一組類似於 :c:func:`PyArg_ParseTuple` "
"識別的格式單元，但參數（輸入到函式，而不是輸出）不能是指標，只能是值。"
"它回傳一個新的 Python 物件，適用於從 Python 呼叫的 C 函式回傳。"

#: ../../extending/extending.rst:812
#, fuzzy
msgid ""
"One difference with :c:func:`PyArg_ParseTuple`: while the latter requires "
"its first argument to be a tuple (since Python argument lists are always "
"represented as tuples internally), :c:func:`Py_BuildValue` does not always "
"build a tuple.  It builds a tuple only if its format string contains two or "
"more format units. If the format string is empty, it returns ``None``; if it "
"contains exactly one format unit, it returns whatever object is described by "
"that format unit.  To force it to return a tuple of size 0 or one, "
"parenthesize the format string."
msgstr ""
"與 :c:func:`PyArg_ParseTuple` "
"的一個區別：雖然後者要求其第一個參數是一個元組（因為 Python "
"參數列表在內部總是表示為元組），:c:func:`Py_BuildValue` 並不總是構建一個元組."
"只有當它的格式字串包含兩個或更多格式單元時，它才會構建一個元組。如果格式字串"
"為空，則回傳 ``None`` ；如果它只包含一個格式單元，則回傳該格式單元描述的任何物件。"
"要強制它回傳大小為 0 或 1 的元組，請將格式字串括起來。"

#: ../../extending/extending.rst:820
#, fuzzy
msgid ""
"Examples (to the left the call, to the right the resulting Python value):"
msgstr "示例（左邊是呼叫，右邊是生成的 Python 值）："

#: ../../extending/extending.rst:846
#, fuzzy
msgid "Reference Counts"
msgstr "引用計數"

#: ../../extending/extending.rst:848
#, fuzzy
msgid ""
"In languages like C or C++, the programmer is responsible for dynamic "
"allocation and deallocation of memory on the heap.  In C, this is done using "
"the functions :c:func:`malloc` and :c:func:`free`.  In C++, the operators "
"``new`` and ``delete`` are used with essentially the same meaning and we'll "
"restrict the following discussion to the C case."
msgstr ""
"在 C 或 C++ 等語言中，程式員負責堆上記憶體的動態分配和釋放。在 C 中，"
"這是使用函式 :c:func:`malloc` 和 :c:func:`free` 完成的。在 C++ 中，操作符 "
"``new`` 和 ``delete`` 本質上具有相同的含義，我們將以下討論限制在 C 的情況下。"

#: ../../extending/extending.rst:854
#, fuzzy
msgid ""
"Every block of memory allocated with :c:func:`malloc` should eventually be "
"returned to the pool of available memory by exactly one call to :c:func:"
"`free`. It is important to call :c:func:`free` at the right time.  If a "
"block's address is forgotten but :c:func:`free` is not called for it, the "
"memory it occupies cannot be reused until the program terminates.  This is "
"called a :dfn:`memory leak`.  On the other hand, if a program calls :c:func:"
"`free` for a block and then continues to use the block, it creates a "
"conflict with re-use of the block through another :c:func:`malloc` call.  "
"This is called :dfn:`using freed memory`. It has the same bad consequences "
"as referencing uninitialized data --- core dumps, wrong results, mysterious "
"crashes."
msgstr ""
"用 :c:func:`malloc` 分配的每一塊記憶體最終都應該通過一次呼叫 :c:func:`free` "
"回傳到可用記憶體池。在正確的時間呼叫 :c:func:`free` 很重要。"
"如果一個塊的地址被遺忘但沒有為它呼叫 :c:func:`free` "
"，它佔用的記憶體在程式終止之前不能被重用。這稱為 "
":dfn:`記憶體洩漏`。另一方面，如果一個程式為一個塊呼叫 :c:func:`free` "
"然後繼續使用該塊，它會與通過另一個 :c:func:`malloc` "
"呼叫重新使用該塊產生衝突.這稱為 :dfn:`using freed memory`。它具有與引用未初始"
"化資料相同的不良後果——核心轉儲、錯誤結果、莫名其妙的崩潰。"

#: ../../extending/extending.rst:865
#, fuzzy
msgid ""
"Common causes of memory leaks are unusual paths through the code.  For "
"instance, a function may allocate a block of memory, do some calculation, "
"and then free the block again.  Now a change in the requirements for the "
"function may add a test to the calculation that detects an error condition "
"and can return prematurely from the function.  It's easy to forget to free "
"the allocated memory block when taking this premature exit, especially when "
"it is added later to the code.  Such leaks, once introduced, often go "
"undetected for a long time: the error exit is taken only in a small fraction "
"of all calls, and most modern machines have plenty of virtual memory, so the "
"leak only becomes apparent in a long-running process that uses the leaking "
"function frequently.  Therefore, it's important to prevent leaks from "
"happening by having a coding convention or strategy that minimizes this kind "
"of errors."
msgstr ""
"記憶體洩漏的常見原因是通過程式碼的例外路徑。例如，一個函式可能會分配一塊記憶"
"體，進行一些計算，然後再次釋放該塊。現在，函式需求的變化可能會向計算新增一個"
"測試，以檢測錯誤情況並可以從函式中提前回傳。過早退出時很容易忘記釋放分配的記"
"憶體塊，尤其是稍後將其新增到程式碼中時。這種洩漏，一旦引入，通常很長一段時間"
"都不會被發現：錯誤退出只發生在所有呼叫的一小部分，而且大多數現代機器都有大量"
"的虛擬記憶體，所以洩漏只會在長時間運行的過程中變得明顯經常使用洩漏功能。因此"
"，重要的是要通過編碼約定或策略來最大限度地減少此類錯誤，從而防止洩漏的發生。"

#: ../../extending/extending.rst:878
#, fuzzy
msgid ""
"Since Python makes heavy use of :c:func:`malloc` and :c:func:`free`, it "
"needs a strategy to avoid memory leaks as well as the use of freed memory.  "
"The chosen method is called :dfn:`reference counting`.  The principle is "
"simple: every object contains a counter, which is incremented when a "
"reference to the object is stored somewhere, and which is decremented when a "
"reference to it is deleted. When the counter reaches zero, the last "
"reference to the object has been deleted and the object is freed."
msgstr ""
"由於 Python 大量使用:c:func:`malloc` 和:c:func:`free`，因此它需要一種策略來避"
"免記憶體洩漏以及使用釋放的記憶體。選擇的方法稱為 :dfn:`引用計數`。原理很簡單"
"：每個對像都包含一個計數器，當對物件的引用儲存在某處時計數器遞增，當對它的引"
"用被刪除時計數器遞減。當計數器達到零時，物件的最後一個引用已被刪除，對像被釋"
"放。"

#: ../../extending/extending.rst:886
#, fuzzy
msgid ""
"An alternative strategy is called :dfn:`automatic garbage collection`. "
"(Sometimes, reference counting is also referred to as a garbage collection "
"strategy, hence my use of \"automatic\" to distinguish the two.)  The big "
"advantage of automatic garbage collection is that the user doesn't need to "
"call :c:func:`free` explicitly.  (Another claimed advantage is an "
"improvement in speed or memory usage --- this is no hard fact however.)  The "
"disadvantage is that for C, there is no truly portable automatic garbage "
"collector, while reference counting can be implemented portably (as long as "
"the functions :c:func:`malloc` and :c:func:`free` are available --- which "
"the C Standard guarantees). Maybe some day a sufficiently portable automatic "
"garbage collector will be available for C. Until then, we'll have to live "
"with reference counts."
msgstr ""
"另一種策略稱為 :dfn:`automatic garbage collection`。 "
"（有時，引用計數也稱為垃圾收集策略，因此我使用“自動”來區分兩者。）"
"自動垃圾收集的一大優點是使用者不需要呼叫 :c:func:明確地`免費`。 （"
"另一個聲稱的優勢是速度或記憶體使用率的提高 --- 但這不是硬性事實。）"
"缺點是對於 C，沒有真正可移植的自動垃圾收集器，而引用計數可以可移植地實作（"
"只要函式 :c:func:`malloc` 和 :c:func:`free` 可用 --- C "
"標准保證）。也許有一天，一個足夠便攜的自動垃圾收集器將可用於 "
"C。在那之前，我們將不得不忍受引用計數。"

#: ../../extending/extending.rst:898
#, fuzzy
msgid ""
"While Python uses the traditional reference counting implementation, it also "
"offers a cycle detector that works to detect reference cycles.  This allows "
"applications to not worry about creating direct or indirect circular "
"references; these are the weakness of garbage collection implemented using "
"only reference counting.  Reference cycles consist of objects which contain "
"(possibly indirect) references to themselves, so that each object in the "
"cycle has a reference count which is non-zero.  Typical reference counting "
"implementations are not able to reclaim the memory belonging to any objects "
"in a reference cycle, or referenced from the objects in the cycle, even "
"though there are no further references to the cycle itself."
msgstr ""
"雖然 Python 使用傳統的引用計數實作，但它還提供了一個循環檢測器來檢測引用循環"
"。這使應用程式不必擔心建立直接或間接循環引用；這些是僅使用引用計數實作的垃圾"
"收集的弱點。引用循環由包含（可能是間接的）對自身引用的物件組成，因此循環中的"
"每個對像都有一個非零的引用計數。典型的引用計數實作無法回收屬於引用循環中任何"
"物件的記憶體，或從循環中的物件引用的記憶體，即使沒有進一步引用循環本身。"

#: ../../extending/extending.rst:909
#, fuzzy
msgid ""
"The cycle detector is able to detect garbage cycles and can reclaim them. "
"The :mod:`gc` module exposes a way to run the detector (the :func:`~gc."
"collect` function), as well as configuration interfaces and the ability to "
"disable the detector at runtime."
msgstr ""
"循環檢測器能夠檢測垃圾循環並回收它們。 :mod:`gc` "
"模組公開了一種運行檢測器的方法（:func:`~gc.collect` "
"函式），以及配置介面和在運行時禁用檢測器的能力。"

#: ../../extending/extending.rst:918
#, fuzzy
msgid "Reference Counting in Python"
msgstr "Python 中的引用計數"

#: ../../extending/extending.rst:920
#, fuzzy
msgid ""
"There are two macros, ``Py_INCREF(x)`` and ``Py_DECREF(x)``, which handle "
"the incrementing and decrementing of the reference count. :c:func:"
"`Py_DECREF` also frees the object when the count reaches zero. For "
"flexibility, it doesn't call :c:func:`free` directly --- rather, it makes a "
"call through a function pointer in the object's :dfn:`type object`.  For "
"this purpose (and others), every object also contains a pointer to its type "
"object."
msgstr ""
"有兩個巨集，``Py_INCREF(x)`` 和 "
"``Py_DECREF(x)``，它們處理引用計數的遞增和遞減。 :c:func:`Py_DECREF` "
"還會在計數達到零時釋放物件。為了靈活性，它不直接呼叫 :c:func:`free` --- "
"而是通過物件的 :dfn:`type object` 中的函式指標進行呼叫。為此（以及其他目的）"
"，每個對像還包含一個指向其型別物件的指標。"

#: ../../extending/extending.rst:927
#, fuzzy
msgid ""
"The big question now remains: when to use ``Py_INCREF(x)`` and "
"``Py_DECREF(x)``? Let's first introduce some terms.  Nobody \"owns\" an "
"object; however, you can :dfn:`own a reference` to an object.  An object's "
"reference count is now defined as the number of owned references to it.  The "
"owner of a reference is responsible for calling :c:func:`Py_DECREF` when the "
"reference is no longer needed.  Ownership of a reference can be "
"transferred.  There are three ways to dispose of an owned reference: pass it "
"on, store it, or call :c:func:`Py_DECREF`. Forgetting to dispose of an owned "
"reference creates a memory leak."
msgstr ""
"現在最大的問題仍然是：什麼時候使用``Py_INCREF(x)`` 和``Py_DECREF(x)``？讓我們"
"首先介紹一些術語。沒有人“擁有”一個物件；但是，您可以 :dfn:`擁有一個物件的引用"
"。物件的引用計數現在定義為對其擁有的引用數。"
"引用的所有者負責在不再需要引用時呼叫 Py_DECREF。引用的所有權可以轉移。有三種"
"方法可以處理擁有的引用：傳遞它、儲存它或呼叫:c:func:`Py_DECREF`。忘記處理擁有"
"的引用會導致記憶體洩漏。"

#: ../../extending/extending.rst:936
#, fuzzy
msgid ""
"It is also possible to :dfn:`borrow` [#]_ a reference to an object.  The "
"borrower of a reference should not call :c:func:`Py_DECREF`.  The borrower "
"must not hold on to the object longer than the owner from which it was "
"borrowed. Using a borrowed reference after the owner has disposed of it "
"risks using freed memory and should be avoided completely [#]_."
msgstr ""
"也可以 :dfn:`借用` [#]_ 物件的引用。引用的借用者不應呼叫 :c:func:`Py_DECREF`"
"。借用人持有物品的時間不得超過借出物品的所有者。在所有者處理後使用借用的引用"
"有使用釋放記憶體的風險，應該完全避免 [#]_。"

#: ../../extending/extending.rst:942
#, fuzzy
msgid ""
"The advantage of borrowing over owning a reference is that you don't need to "
"take care of disposing of the reference on all possible paths through the "
"code --- in other words, with a borrowed reference you don't run the risk of "
"leaking when a premature exit is taken.  The disadvantage of borrowing over "
"owning is that there are some subtle situations where in seemingly correct "
"code a borrowed reference can be used after the owner from which it was "
"borrowed has in fact disposed of it."
msgstr ""
"與擁有引用相比，借用的優點是您無需處理程式碼中所有可能路徑上的引用——換句話說"
"，使用借用的引用，您不會冒洩漏的風險當過早退出時。借用而不是擁有的缺點是，在"
"某些微妙的情況下，在看似正確的程式碼中，借用的引用可以在被借用的所有者實際上"
"已經處理掉後使用。"

#: ../../extending/extending.rst:950
#, fuzzy
msgid ""
"A borrowed reference can be changed into an owned reference by calling :c:"
"func:`Py_INCREF`.  This does not affect the status of the owner from which "
"the reference was borrowed --- it creates a new owned reference, and gives "
"full owner responsibilities (the new owner must dispose of the reference "
"properly, as well as the previous owner)."
msgstr ""
"可以通過呼叫 Py_INCREF 將藉用的引用更改為擁有的引用。這不會影響借用引用的所有"
"者的狀態——它會建立一個新的引用，並賦予所有者全部責任（新所有者必須正確處置引"
"用，以及以前的所有者）。"

#: ../../extending/extending.rst:960
#, fuzzy
msgid "Ownership Rules"
msgstr "所有權規則"

#: ../../extending/extending.rst:962
#, fuzzy
msgid ""
"Whenever an object reference is passed into or out of a function, it is part "
"of the function's interface specification whether ownership is transferred "
"with the reference or not."
msgstr "無論何時將物件引用傳入或傳出函式，無論所有權是否隨引用一起轉移，都是函式介面"
"規範的一部分。"

#: ../../extending/extending.rst:966
#, fuzzy
msgid ""
"Most functions that return a reference to an object pass on ownership with "
"the reference.  In particular, all functions whose function it is to create "
"a new object, such as :c:func:`PyLong_FromLong` and :c:func:`Py_BuildValue`, "
"pass ownership to the receiver.  Even if the object is not actually new, you "
"still receive ownership of a new reference to that object.  For instance, :c:"
"func:`PyLong_FromLong` maintains a cache of popular values and can return a "
"reference to a cached item."
msgstr ""
"大多數回傳物件引用的函式都會通過引用傳遞所有權。特別是，所有以建立新物件為功"
"能的函式，例如 :c:func:`PyLong_FromLong` 和:c:func:`Py_BuildValue`，都將所有"
"權傳遞給接收者。即使該物件實際上不是新的，您仍然會獲得對該物件的新引用的所有"
"權。例如，:c:func:`PyLong_FromLong` "
"維護流行值的快取，並可以回傳對快取項的引用。"

#: ../../extending/extending.rst:974
#, fuzzy
msgid ""
"Many functions that extract objects from other objects also transfer "
"ownership with the reference, for instance :c:func:"
"`PyObject_GetAttrString`.  The picture is less clear, here, however, since a "
"few common routines are exceptions: :c:func:`PyTuple_GetItem`, :c:func:"
"`PyList_GetItem`, :c:func:`PyDict_GetItem`, and :c:func:"
"`PyDict_GetItemString` all return references that you borrow from the tuple, "
"list or dictionary."
msgstr ""
"許多從其他對像中提取物件的函式也會通過引用轉移所有權，例如 :c:func:`PyObject_"
"GetAttrString`。然而，這裡的情況不太清楚，因為一些常見例程是例外：:c:func:`Py"
"Tuple_GetItem`、:c:func:`PyList_GetItem`、:c:func:`PyDict_GetItem` 和:c:func "
":`PyDict_GetItemString` 全部回傳您從元組、列表或字典中藉用的引用。"

#: ../../extending/extending.rst:981
#, fuzzy
msgid ""
"The function :c:func:`PyImport_AddModule` also returns a borrowed reference, "
"even though it may actually create the object it returns: this is possible "
"because an owned reference to the object is stored in ``sys.modules``."
msgstr ""
"函式 :c:func:`PyImport_AddModule` "
"也回傳一個借用的引用，即使它可能實際上建立了它回傳的物件：這是可能的，"
"因為對該物件的擁有引用儲存在 ``sys.modules`` 中。"

#: ../../extending/extending.rst:985
#, fuzzy
msgid ""
"When you pass an object reference into another function, in general, the "
"function borrows the reference from you --- if it needs to store it, it will "
"use :c:func:`Py_INCREF` to become an independent owner.  There are exactly "
"two important exceptions to this rule: :c:func:`PyTuple_SetItem` and :c:func:"
"`PyList_SetItem`.  These functions take over ownership of the item passed to "
"them --- even if they fail!  (Note that :c:func:`PyDict_SetItem` and friends "
"don't take over ownership --- they are \"normal.\")"
msgstr ""
"當您將一個物件引用傳遞給另一個函式時，通常，該函式會向您借用該引用——如果它需"
"要儲存它，它將使用:c:func:`Py_INCREF` "
"成為一個獨立的所有者。此規則有兩個重要的例外：:c:func:`PyTuple_SetItem` 和:c:"
"func:`PyList_SetItem`。這些函式接管傳遞給它們的項目的所有權——即使它們失敗了！"
" （請注意 :c:func:`PyDict_SetItem` 和朋友不會接管所有權——它們是“正常的”。）"

#: ../../extending/extending.rst:993
#, fuzzy
msgid ""
"When a C function is called from Python, it borrows references to its "
"arguments from the caller.  The caller owns a reference to the object, so "
"the borrowed reference's lifetime is guaranteed until the function returns.  "
"Only when such a borrowed reference must be stored or passed on, it must be "
"turned into an owned reference by calling :c:func:`Py_INCREF`."
msgstr ""
"當從 Python 呼叫 C 函式時，它會從呼叫者那裡借用對其參數的引用。呼叫者擁有對該"
"物件的引用，因此在函式回傳之前，借用的引用的生命週期得到保證。只有當必須儲存"
"或傳遞此類借用引用時，才必須通過呼叫 Py_INCREF 將其轉換為擁有引用。"

#: ../../extending/extending.rst:999
#, fuzzy
msgid ""
"The object reference returned from a C function that is called from Python "
"must be an owned reference --- ownership is transferred from the function to "
"its caller."
msgstr "從 Python 呼叫的 C "
"函式回傳的物件引用必須是擁有的引用——所有權從函式轉移到它的呼叫者。"

#: ../../extending/extending.rst:1007
#, fuzzy
msgid "Thin Ice"
msgstr "薄冰"

#: ../../extending/extending.rst:1009
#, fuzzy
msgid ""
"There are a few situations where seemingly harmless use of a borrowed "
"reference can lead to problems.  These all have to do with implicit "
"invocations of the interpreter, which can cause the owner of a reference to "
"dispose of it."
msgstr "在某些情況下，看似無害地使用借用的引用可能會導致問題。這些都與直譯器的隱式呼"
"叫有關，這可能導致引用的所有者處置它。"

#: ../../extending/extending.rst:1013
#, fuzzy
msgid ""
"The first and most important case to know about is using :c:func:`Py_DECREF` "
"on an unrelated object while borrowing a reference to a list item.  For "
"instance::"
msgstr "要了解的第一個也是最重要的情況是在不相關的對像上使用:c:func:`Py_DECREF`，同時"
"藉用對列表項的引用。例如：："

#: ../../extending/extending.rst:1025
#, fuzzy
msgid ""
"This function first borrows a reference to ``list[0]``, then replaces "
"``list[1]`` with the value ``0``, and finally prints the borrowed reference. "
"Looks harmless, right?  But it's not!"
msgstr ""
"這個函式首先借用一個對 ``list[0]`` 的引用，然後用值 ``0`` 替換 "
"``list[1]``，最後印出借用的引用。看起來無害，對吧？但事實並非如此！"

#: ../../extending/extending.rst:1029
#, fuzzy
msgid ""
"Let's follow the control flow into :c:func:`PyList_SetItem`.  The list owns "
"references to all its items, so when item 1 is replaced, it has to dispose "
"of the original item 1.  Now let's suppose the original item 1 was an "
"instance of a user-defined class, and let's further suppose that the class "
"defined a :meth:`__del__` method.  If this class instance has a reference "
"count of 1, disposing of it will call its :meth:`__del__` method."
msgstr ""
"讓我們跟隨控制流進入:c:func:`PyList_SetItem`。該列表擁有對其所有項目的引用，"
"因此當項目 1 被替換時，它必須處理原始項目 1。現在讓我們假設原始項目 1 "
"是使用者定義類的實例，讓我們進一步假設該類定義了一個 :meth:`__del__` 方法。"
"如果此類實例的引用計數為 1，則處理它時將呼叫其 :meth:`__del__` 方法。"

#: ../../extending/extending.rst:1036
#, fuzzy
msgid ""
"Since it is written in Python, the :meth:`__del__` method can execute "
"arbitrary Python code.  Could it perhaps do something to invalidate the "
"reference to ``item`` in :c:func:`bug`?  You bet!  Assuming that the list "
"passed into :c:func:`bug` is accessible to the :meth:`__del__` method, it "
"could execute a statement to the effect of ``del list[0]``, and assuming "
"this was the last reference to that object, it would free the memory "
"associated with it, thereby invalidating ``item``."
msgstr ""
"由於它是用 Python 編寫的，因此 :meth:`__del__` 方法可以執行任意 Python "
"程式碼。它可能會做些什麼來使 :c:func:`bug` 中對 ``item`` "
"的引用無效嗎？你打賭！假設傳遞給 :c:func:`bug` 的列表可以被 :meth:`__del__` "
"方法訪問，它可以執行一個語句來達到 ``del list[0]`` "
"的效果，並假設這是最後引用那個物件，它會釋放與之關聯的記憶體，從而使 ``item``"
" 無效。"

#: ../../extending/extending.rst:1044
#, fuzzy
msgid ""
"The solution, once you know the source of the problem, is easy: temporarily "
"increment the reference count.  The correct version of the function reads::"
msgstr "一旦知道問題的根源，解決方案就很簡單：臨時增加引用計數。該函式的正確版本如下"
"："

#: ../../extending/extending.rst:1058
#, fuzzy
msgid ""
"This is a true story.  An older version of Python contained variants of this "
"bug and someone spent a considerable amount of time in a C debugger to "
"figure out why his :meth:`__del__` methods would fail..."
msgstr ""
"這是一個真實的故事。舊版本的 Python 包含此錯誤的變體，有人在 C "
"除錯器中花費了大量時間來弄清楚為什麼他的 :meth:`__del__` 方法會失敗......"

#: ../../extending/extending.rst:1062
#, fuzzy
msgid ""
"The second case of problems with a borrowed reference is a variant involving "
"threads.  Normally, multiple threads in the Python interpreter can't get in "
"each other's way, because there is a global lock protecting Python's entire "
"object space.  However, it is possible to temporarily release this lock "
"using the macro :c:macro:`Py_BEGIN_ALLOW_THREADS`, and to re-acquire it "
"using :c:macro:`Py_END_ALLOW_THREADS`.  This is common around blocking I/O "
"calls, to let other threads use the processor while waiting for the I/O to "
"complete. Obviously, the following function has the same problem as the "
"previous one::"
msgstr ""
"借用引用問題的第二種情況是涉及執行緒的變體。通常情況下，Python "
"直譯器中的多個執行緒是不能互相干擾的，因為有一個全局鎖保護著 Python "
"的整個物件空間。但是，可以使用巨集 :c:macro:`Py_BEGIN_ALLOW_THREADS` "
"暫時釋放此鎖，並使用 :c:macro:`Py_END_ALLOW_THREADS` 重新獲取它。這在阻塞 I/"
"O 呼叫中很常見，讓其他執行緒在等待 I/O "
"完成時使用處理器。顯然，下面的函式和前面的函式有同樣的問題："

#: ../../extending/extending.rst:1085
#, fuzzy
msgid "NULL Pointers"
msgstr "空指標"

#: ../../extending/extending.rst:1087
#, fuzzy
msgid ""
"In general, functions that take object references as arguments do not expect "
"you to pass them ``NULL`` pointers, and will dump core (or cause later core "
"dumps) if you do so.  Functions that return object references generally "
"return ``NULL`` only to indicate that an exception occurred.  The reason for "
"not testing for ``NULL`` arguments is that functions often pass the objects "
"they receive on to other function --- if each function were to test for "
"``NULL``, there would be a lot of redundant tests and the code would run "
"more slowly."
msgstr ""
"通常，將物件引用作為參數的函式不希望您將 ``NULL`` 指標傳遞給它們，如果您這樣做，"
"它們將轉儲核心（或導致稍後的核心轉儲）。回傳物件引用的函式通常回傳 ``NULL`` 只是"
"為了表明發生了例外。不測試 ``NULL`` 參數的原因是函式經常將它們接收到的對像傳遞給"
"其他函式——如果每個函式都測試 ``NULL`` ，就會有很多冗餘測試和程式碼會運行得更慢。"

#: ../../extending/extending.rst:1095
#, fuzzy
msgid ""
"It is better to test for ``NULL`` only at the \"source:\" when a pointer "
"that may be ``NULL`` is received, for example, from :c:func:`malloc` or from "
"a function that may raise an exception."
msgstr ""
"最好只在“源：”處測試 ``NULL`` ，當接收到一個可能為 ``NULL`` 的指標時，例如，來自 "
":c:func:`malloc` 或來自一個可能為 ``NULL`` 的函式引發例外。"

#: ../../extending/extending.rst:1099
#, fuzzy
msgid ""
"The macros :c:func:`Py_INCREF` and :c:func:`Py_DECREF` do not check for "
"``NULL`` pointers --- however, their variants :c:func:`Py_XINCREF` and :c:"
"func:`Py_XDECREF` do."
msgstr ""
"巨集 :c:func:`Py_INCREF` 和 :c:func:`Py_DECREF` 不檢查 ``NULL`` 指標 --- "
"然而，它們的變體 :c:func:`Py_XINCREF` 和 :c:func: `Py_XDECREF` 做。"

#: ../../extending/extending.rst:1103
#, fuzzy
msgid ""
"The macros for checking for a particular object type (``Pytype_Check()``) "
"don't check for ``NULL`` pointers --- again, there is much code that calls "
"several of these in a row to test an object against various different "
"expected types, and this would generate redundant tests.  There are no "
"variants with ``NULL`` checking."
msgstr ""
"用於檢查特定對像型別的巨集（``Pytype_Check()``）不檢查``NULL`` 指標——同樣，有"
"很多程式碼連續呼叫其中的幾個來測試一個物件針對各種不同的預期型別，這會產生冗"
"餘測試。沒有帶有 ``NULL`` 檢查的變體。"

#: ../../extending/extending.rst:1109
#, fuzzy
msgid ""
"The C function calling mechanism guarantees that the argument list passed to "
"C functions (``args`` in the examples) is never ``NULL`` --- in fact it "
"guarantees that it is always a tuple [#]_."
msgstr "C 函式呼叫機制保證傳遞給 C 函式的參數列表（示例中的 ``args``）永遠不會是 ``NULL`` ——"
"事實上它保證它總是一個元組 [#]_。"

#: ../../extending/extending.rst:1113
#, fuzzy
msgid ""
"It is a severe error to ever let a ``NULL`` pointer \"escape\" to the Python "
"user."
msgstr "讓 ``NULL`` 指標“轉義”給 Python 使用者是一個嚴重的錯誤。"

#: ../../extending/extending.rst:1124
#, fuzzy
msgid "Writing Extensions in C++"
msgstr "用 C++ 編寫擴充"

#: ../../extending/extending.rst:1126
#, fuzzy
msgid ""
"It is possible to write extension modules in C++.  Some restrictions apply.  "
"If the main program (the Python interpreter) is compiled and linked by the C "
"compiler, global or static objects with constructors cannot be used.  This "
"is not a problem if the main program is linked by the C++ compiler.  "
"Functions that will be called by the Python interpreter (in particular, "
"module initialization functions) have to be declared using ``extern \"C\"``. "
"It is unnecessary to enclose the Python header files in ``extern \"C\" {...}"
"`` --- they use this form already if the symbol ``__cplusplus`` is defined "
"(all recent C++ compilers define this symbol)."
msgstr ""
"可以用 C++ 編寫擴充模組。一些限制適用。如果主程式（Python 直譯器）由 C "
"編譯器編譯和鏈接，則不能使用具有構造函式的全局或靜態物件。如果主程式由 C++ "
"編譯器鏈接，這不是問題。將由 Python 直譯器呼叫的函式（特別是模組初始化函式）"
"必須使用 ``extern \"C\"`` 聲明。沒有必要在 ``extern \"C\" {...}`` 中包含 "
"Python 標頭檔——如果定義了符號 `__cplusplus``（所有最新的 C++ "
"編譯器都定義了這個符號），它們已經使用了這種形式."

#: ../../extending/extending.rst:1140
#, fuzzy
msgid "Providing a C API for an Extension Module"
msgstr "為擴充模組提供 C API"

#: ../../extending/extending.rst:1145
#, fuzzy
msgid ""
"Many extension modules just provide new functions and types to be used from "
"Python, but sometimes the code in an extension module can be useful for "
"other extension modules. For example, an extension module could implement a "
"type \"collection\" which works like lists without order. Just like the "
"standard Python list type has a C API which permits extension modules to "
"create and manipulate lists, this new collection type should have a set of C "
"functions for direct manipulation from other extension modules."
msgstr ""
"許多擴充模組只是提供新的函式和型別以供 Python 使用，但有時擴充模組中的程式碼"
"對其他擴充模組也很有用。例如，一個擴充模組可以實作一個“集合”型別，它像沒有順"
"序的列表一樣工作。就像標準的 Python "
"列表型別有一個允許擴充模組建立和操作列表的 C API 一樣，"
"這個新的集合型別應該有一組 C 函式，以便從其他擴充模組直接操作。"

#: ../../extending/extending.rst:1153
#, fuzzy
msgid ""
"At first sight this seems easy: just write the functions (without declaring "
"them ``static``, of course), provide an appropriate header file, and "
"document the C API. And in fact this would work if all extension modules "
"were always linked statically with the Python interpreter. When modules are "
"used as shared libraries, however, the symbols defined in one module may not "
"be visible to another module. The details of visibility depend on the "
"operating system; some systems use one global namespace for the Python "
"interpreter and all extension modules (Windows, for example), whereas others "
"require an explicit list of imported symbols at module link time (AIX is one "
"example), or offer a choice of different strategies (most Unices). And even "
"if symbols are globally visible, the module whose functions one wishes to "
"call might not have been loaded yet!"
msgstr ""
"乍一看，這似乎很簡單：只需編寫函式（當然不用將它們聲明為“靜態”），提供適當的"
"標頭檔，並記錄 C API。事實上，如果所有擴充模組始終與 Python 直譯器靜態鏈接，"
"這將起作用。但是，當模組用作共享庫時，一個模組中定義的符號可能對另一個模組不"
"可見。可見性的細節取決於操作系統；一些系統為 Python 直譯器和所有擴充模組（"
"例如 "
"Windows）使用一個全局名稱空間，而其他系統則需要在模組鏈接時明確導入符號列表（"
"AIX 是一個例子），或者提供不同策略的選擇（大多數聯合國）。即使符號是全局可見"
"的，人們希望呼叫其功能的模組可能還沒有加載！"

#: ../../extending/extending.rst:1165
#, fuzzy
msgid ""
"Portability therefore requires not to make any assumptions about symbol "
"visibility. This means that all symbols in extension modules should be "
"declared ``static``, except for the module's initialization function, in "
"order to avoid name clashes with other extension modules (as discussed in "
"section :ref:`methodtable`). And it means that symbols that *should* be "
"accessible from other extension modules must be exported in a different way."
msgstr ""
"因此，可移植性要求不對符號可見性做出任何假設。這意味著擴充模組中的所有符號都"
"應聲明為 ``static``，除了模組的初始化函式，以避免與其他擴充模組的名稱衝突（如 "
":ref:`methodtable` "
"部分所述）。這意味著*應該*可以從其他擴充模組訪問的符號必須以不同的方式導出。"

#: ../../extending/extending.rst:1172
#, fuzzy
msgid ""
"Python provides a special mechanism to pass C-level information (pointers) "
"from one extension module to another one: Capsules. A Capsule is a Python "
"data type which stores a pointer (:c:expr:`void \\*`).  Capsules can only be "
"created and accessed via their C API, but they can be passed around like any "
"other Python object. In particular,  they can be assigned to a name in an "
"extension module's namespace. Other extension modules can then import this "
"module, retrieve the value of this name, and then retrieve the pointer from "
"the Capsule."
msgstr ""
"Python 提供了一種特殊的機制來將 C "
"級資訊（指標）從一個擴充模組傳遞到另一個擴充模組：Capsules。"
"膠囊是一種儲存指標的 Python 資料型別 (:c:expr:`void \\*`)。膠囊只能通過其 C "
"API 建立和訪問，但它們可以像任何其他 Python 對像一樣傳遞。特別是，它們可以分"
"配給擴充模組命名空間中的名稱。然後其他擴充模組可以導入這個模組，檢索這個名稱"
"的值，然後從膠囊中檢索指標。"

#: ../../extending/extending.rst:1180
#, fuzzy
msgid ""
"There are many ways in which Capsules can be used to export the C API of an "
"extension module. Each function could get its own Capsule, or all C API "
"pointers could be stored in an array whose address is published in a "
"Capsule. And the various tasks of storing and retrieving the pointers can be "
"distributed in different ways between the module providing the code and the "
"client modules."
msgstr ""
"有許多方法可以使用 Capsules 來導出擴充模組的 C API。每個函式都可以獲得自己的 "
"Capsule，或者所有 C API 指標都可以儲存在一個數組中，該數組的地址在 Capsule 中"
"發布。儲存和檢索指標的各種任務可以在提供程式碼的模組和客戶端模組之間以不同的"
"方式分配。"

#: ../../extending/extending.rst:1186
#, fuzzy
msgid ""
"Whichever method you choose, it's important to name your Capsules properly. "
"The function :c:func:`PyCapsule_New` takes a name parameter (:c:expr:`const "
"char \\*`); you're permitted to pass in a ``NULL`` name, but we strongly "
"encourage you to specify a name.  Properly named Capsules provide a degree "
"of runtime type-safety; there is no feasible way to tell one unnamed Capsule "
"from another."
msgstr ""
"無論您選擇哪種方法，正確命名您的 Capsules 都很重要。函式 "
":c:func:`PyCapsule_New` 採用名稱參數 (:c:expr:`const char \\"
"*`)；您可以傳入一個 ``NULL`` 名稱，但我們強烈建議您指定一個名稱。正確命名的 "
"Capsules 提供了一定程度的運行時型別安全；沒有可行的方法來區分一個未命名的 "
"Capsule 和另一個。"

#: ../../extending/extending.rst:1193
#, fuzzy
msgid ""
"In particular, Capsules used to expose C APIs should be given a name "
"following this convention::"
msgstr "特別是，用於公開 C API 的膠囊應該按照以下約定命名："

#: ../../extending/extending.rst:1198
#, fuzzy
msgid ""
"The convenience function :c:func:`PyCapsule_Import` makes it easy to load a "
"C API provided via a Capsule, but only if the Capsule's name matches this "
"convention.  This behavior gives C API users a high degree of certainty that "
"the Capsule they load contains the correct C API."
msgstr ""
"便利函式 :c:func:`PyCapsule_Import` 可以輕鬆加載通過 Capsule 提供的 C API，"
"但前提是 Capsule 的名稱符合此約定。這種行為為 C API "
"使用者提供了高度的確定性，即他們加載的 Capsule 包含正確的 C API。"

#: ../../extending/extending.rst:1203
#, fuzzy
msgid ""
"The following example demonstrates an approach that puts most of the burden "
"on the writer of the exporting module, which is appropriate for commonly "
"used library modules. It stores all C API pointers (just one in the "
"example!) in an array of :c:expr:`void` pointers which becomes the value of "
"a Capsule. The header file corresponding to the module provides a macro that "
"takes care of importing the module and retrieving its C API pointers; client "
"modules only have to call this macro before accessing the C API."
msgstr ""
"以下示例演示了一種將大部分負擔放在導出模組的編寫者身上的方法，這適用於常用的"
"庫模組。它將所有 C API 指標（示例中只有一個！）儲存在一個 :c:expr:`void` "
"指標數組中，該指標成為 Capsule 的值。與模組對應的標頭檔提供了一個巨集，"
"負責導入模組並檢索其 C API 指標；客戶端模組只需在訪問 C API 之前呼叫此巨集。"

#: ../../extending/extending.rst:1211
#, fuzzy
msgid ""
"The exporting module is a modification of the :mod:`spam` module from "
"section :ref:`extending-simpleexample`. The function :func:`spam.system` "
"does not call the C library function :c:func:`system` directly, but a "
"function :c:func:`PySpam_System`, which would of course do something more "
"complicated in reality (such as adding \"spam\" to every command). This "
"function :c:func:`PySpam_System` is also exported to other extension modules."
msgstr ""
"導出模組是對 :ref:`extending-simpleexample` 部分中的 :mod:`spam` 模組的修改。"
"函式 :func:`spam.system` 不直接呼叫 C 庫函式 :c:func:`system` ，而是一個函式 "
":c:func:`PySpam_System` "
"，這在現實中當然會做一些更複雜的事情（例如在每個命令中新增“垃圾郵件”）。"
"這個函式 :c:func:`PySpam_System` 也被導出到其他擴充模組。"

#: ../../extending/extending.rst:1218
#, fuzzy
msgid ""
"The function :c:func:`PySpam_System` is a plain C function, declared "
"``static`` like everything else::"
msgstr ":c:func:`PySpam_System` 函式是一個普通的 C 函式，像其他所有函式一樣聲明為 "
"``static``::"

#: ../../extending/extending.rst:1227
#, fuzzy
msgid "The function :c:func:`spam_system` is modified in a trivial way::"
msgstr "函式 :c:func:`spam_system` 以微不足道的方式進行了修改::"

#: ../../extending/extending.rst:1241
#, fuzzy
msgid "In the beginning of the module, right after the line ::"
msgstr "在模組的開頭，就在 :: 行之後"

#: ../../extending/extending.rst:1245
#, fuzzy
msgid "two more lines must be added::"
msgstr "必須再新增兩行::"

#: ../../extending/extending.rst:1250
#, fuzzy
msgid ""
"The ``#define`` is used to tell the header file that it is being included in "
"the exporting module, not a client module. Finally, the module's "
"initialization function must take care of initializing the C API pointer "
"array::"
msgstr "``#define`` 用於告訴標頭檔它被包含在導出模組中，而不是客戶端模組中。最後，"
"模組的初始化函式必須負責初始化 C API 指標數組::"

#: ../../extending/extending.rst:1280
#, fuzzy
msgid ""
"Note that ``PySpam_API`` is declared ``static``; otherwise the pointer array "
"would disappear when :func:`PyInit_spam` terminates!"
msgstr "請注意，``PySpam_API`` 被聲明為``static``；否則指標數組會在 "
":func:`PyInit_spam` 終止時消失！"

#: ../../extending/extending.rst:1283
#, fuzzy
msgid ""
"The bulk of the work is in the header file :file:`spammodule.h`, which looks "
"like this::"
msgstr "大部分工作在標頭檔 :file:`spammodule.h` 中，如下所示："

#: ../../extending/extending.rst:1334
#, fuzzy
msgid ""
"All that a client module must do in order to have access to the function :c:"
"func:`PySpam_System` is to call the function (or rather macro) :c:func:"
"`import_spam` in its initialization function::"
msgstr ""
"為了訪問函式 :c:func:`PySpam_System`，客戶端模組必須做的就是在其初始化函式中"
"呼叫函式（或者更確切地說是巨集）:c:func:`import_spam`::"

#: ../../extending/extending.rst:1352
#, fuzzy
msgid ""
"The main disadvantage of this approach is that the file :file:`spammodule.h` "
"is rather complicated. However, the basic structure is the same for each "
"function that is exported, so it has to be learned only once."
msgstr "這種方法的主要缺點是文件 :file:`spammodule.h` "
"相當複雜。但是，每個導出的函式的基本結構都是相同的，因此只需學習一次。"

#: ../../extending/extending.rst:1356
#, fuzzy
msgid ""
"Finally it should be mentioned that Capsules offer additional functionality, "
"which is especially useful for memory allocation and deallocation of the "
"pointer stored in a Capsule. The details are described in the Python/C API "
"Reference Manual in the section :ref:`capsules` and in the implementation of "
"Capsules (files :file:`Include/pycapsule.h` and :file:`Objects/pycapsule.c` "
"in the Python source code distribution)."
msgstr ""
"最後應該提到的是，Capsules 提供了額外的功能，這對於儲存在 Capsule "
"中的指標的記憶體分配和釋放特別有用。詳細資訊在 Python/C API 參考手冊中的 "
":ref:`capsules` 部分和 Capsules 的實作中進行了描述（文件 :file:`Include/"
"pycapsule.h` 和 :file:`Objects/pycapsule.c`在 Python 源程式碼分發中）。"

#: ../../extending/extending.rst:1364
msgid "Footnotes"
msgstr "註解"

#: ../../extending/extending.rst:1365
#, fuzzy
msgid ""
"An interface for this function already exists in the standard module :mod:"
"`os` --- it was chosen as a simple and straightforward example."
msgstr "這個函式的介面已經存在於標準模組 :mod:`os` --- 它被選為一個簡單直接的例子。"

#: ../../extending/extending.rst:1368
#, fuzzy
msgid ""
"The metaphor of \"borrowing\" a reference is not completely correct: the "
"owner still has a copy of the reference."
msgstr "“借用”參考文獻的比喻並不完全正確：所有者仍然有參考文獻的副本。"

#: ../../extending/extending.rst:1371
#, fuzzy
msgid ""
"Checking that the reference count is at least 1 **does not work** --- the "
"reference count itself could be in freed memory and may thus be reused for "
"another object!"
msgstr "檢查引用計數是否至少為 1 **不起作用** --- "
"引用計數本身可能位於已釋放的記憶體中，因此可能會被另一個物件重用！"

#: ../../extending/extending.rst:1375
#, fuzzy
msgid ""
"These guarantees don't hold when you use the \"old\" style calling "
"convention --- this is still found in much existing code."
msgstr "當您使用「舊」樣式呼叫約定時，這些保證不成立——這在許多現有程式碼中仍然存在。"
