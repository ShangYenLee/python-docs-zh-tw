# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-07 00:27+0000\n"
"PO-Revision-Date: 2018-07-15 18:56+0800\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../extending/newtypes_tutorial.rst:7
#, fuzzy
msgid "Defining Extension Types: Tutorial"
msgstr "定義擴充型別教學"

#: ../../extending/newtypes_tutorial.rst:14
#, fuzzy
msgid ""
"Python allows the writer of a C extension module to define new types that "
"can be manipulated from Python code, much like the built-in :class:`str` "
"and :class:`list` types.  The code for all extension types follows a "
"pattern, but there are some details that you need to understand before you "
"can get started.  This document is a gentle introduction to the topic."
msgstr ""
"Python 允許 C 擴充模組的編寫者定義可以從 Python 程式碼操作的新型別，"
"很像內建的 str 和 list 型別。所有擴充型別的程式碼都遵循一種模式，但在開始之前"
"您需要了解一些細節。本文檔是對該主題的簡要介紹。"

#: ../../extending/newtypes_tutorial.rst:24
#, fuzzy
msgid "The Basics"
msgstr "基礎"

#: ../../extending/newtypes_tutorial.rst:26
#, fuzzy
msgid ""
"The :term:`CPython` runtime sees all Python objects as variables of type :c:"
"expr:`PyObject*`, which serves as a \"base type\" for all Python objects. "
"The :c:type:`PyObject` structure itself only contains the object's :term:"
"`reference count` and a pointer to the object's \"type object\". This is "
"where the action is; the type object determines which (C) functions get "
"called by the interpreter when, for instance, an attribute gets looked up on "
"an object, a method called, or it is multiplied by another object.  These C "
"functions are called \"type methods\"."
msgstr ""
":term:`CPython` 運行時將所有 Python 物件視為 :c:expr:`PyObject*` 型別的變數，"
"它充當所有 Python 物件的“基本型別”。 :c:type:`PyObject` 結構本身只包含物件的 "
":term:`reference count` 和指向物件“型別物件”的指標。這就是行動所在；"
"型別物件確定直譯器呼叫哪些 (C) "
"函式，例如，在對像上查找屬性、呼叫方法或將其乘以另一個物件。這些 C "
"函式稱為“型別方法”。"

#: ../../extending/newtypes_tutorial.rst:35
#, fuzzy
msgid ""
"So, if you want to define a new extension type, you need to create a new "
"type object."
msgstr "所以，如果你想定義一個新的擴充型別，你需要建立一個新的型別物件。"

#: ../../extending/newtypes_tutorial.rst:38
#, fuzzy
msgid ""
"This sort of thing can only be explained by example, so here's a minimal, "
"but complete, module that defines a new type named :class:`Custom` inside a "
"C extension module :mod:`custom`:"
msgstr ""
"這種事情只能通過示例來解釋，所以這裡有一個最小但完整的模組，它在 C 擴充模組 "
":mod:`custom` 中定義了一個名為 :class:`Custom` 的新型別："

#: ../../extending/newtypes_tutorial.rst:43
#, fuzzy
msgid ""
"What we're showing here is the traditional way of defining *static* "
"extension types.  It should be adequate for most uses.  The C API also "
"allows defining heap-allocated extension types using the :c:func:"
"`PyType_FromSpec` function, which isn't covered in this tutorial."
msgstr ""
"我們在這裡展示的是定義 *static* "
"擴充型別的傳統方式。它應該足以滿足大多數用途。 C API 還允許使用 "
"PyType_FromSpec 函式定義堆分配的擴充型別，這在本教程中沒有涉及。"

#: ../../extending/newtypes_tutorial.rst:50
#, fuzzy
msgid ""
"Now that's quite a bit to take in at once, but hopefully bits will seem "
"familiar from the previous chapter.  This file defines three things:"
msgstr "一下子要理解的內容有點多，但希望這些內容對上一章的內容很熟悉。這個文件定義了"
"三件事："

#: ../../extending/newtypes_tutorial.rst:53
#, fuzzy
msgid ""
"What a :class:`Custom` **object** contains: this is the ``CustomObject`` "
"struct, which is allocated once for each :class:`Custom` instance."
msgstr ""
":class:`Custom` **object** 包含什麼：這是 ``CustomObject`` 結構，它為每個 "
":class:`Custom` 實例分配一次。"

#: ../../extending/newtypes_tutorial.rst:55
#, fuzzy
msgid ""
"How the :class:`Custom` **type** behaves: this is the ``CustomType`` struct, "
"which defines a set of flags and function pointers that the interpreter "
"inspects when specific operations are requested."
msgstr ""
":class:`Custom` **type** 的行為方式：這是 ``CustomType`` 結構，它定義了一組旗"
"標和函式指標，直譯器在請求特定操作時檢查這些旗標和函式指標。"

#: ../../extending/newtypes_tutorial.rst:58
#, fuzzy
msgid ""
"How to initialize the :mod:`custom` module: this is the ``PyInit_custom`` "
"function and the associated ``custommodule`` struct."
msgstr "如何初始化 :mod:`custom` 模組：這是 ``PyInit_custom`` 函式和關聯的 "
"``custommodule`` 結構。"

#: ../../extending/newtypes_tutorial.rst:61
#, fuzzy
msgid "The first bit is::"
msgstr "第一位是::"

#: ../../extending/newtypes_tutorial.rst:67
#, fuzzy
msgid ""
"This is what a Custom object will contain.  ``PyObject_HEAD`` is mandatory "
"at the start of each object struct and defines a field called ``ob_base`` of "
"type :c:type:`PyObject`, containing a pointer to a type object and a "
"reference count (these can be accessed using the macros :c:macro:`Py_TYPE` "
"and :c:macro:`Py_REFCNT` respectively).  The reason for the macro is to "
"abstract away the layout and to enable additional fields in :ref:`debug "
"builds <debug-build>`."
msgstr ""
"這是自定義物件將包含的內容。 ``PyObject_HEAD`` "
"在每個物件結構的開頭是強制性的，它定義了一個名為 ``ob_base`` "
"的欄位，型別為 :c:type:`PyObject`，包含指向型別物件的指標和引用計數（"
"這些可以是分別使用巨集 :c:macro:`Py_TYPE` 和 :c:macro:`Py_REFCNT` 訪問）。"
"巨集的原因是抽像出佈局並在 :ref:`debug builds <debug-build>` 中啟用其他欄位。"

#: ../../extending/newtypes_tutorial.rst:76
#, fuzzy
msgid ""
"There is no semicolon above after the :c:macro:`PyObject_HEAD` macro. Be "
"wary of adding one by accident: some compilers will complain."
msgstr "在 :c:macro:`PyObject_HEAD` "
"巨集之後沒有上面的分號。小心不要意外新增一個：一些編譯器會抱怨。"

#: ../../extending/newtypes_tutorial.rst:79
#, fuzzy
msgid ""
"Of course, objects generally store additional data besides the standard "
"``PyObject_HEAD`` boilerplate; for example, here is the definition for "
"standard Python floats::"
msgstr "當然，除了標準的“PyObject_HEAD”樣板之外，物件通常還儲存額外的資料；例如，"
"這裡是標準 Python 浮點數的定義："

#: ../../extending/newtypes_tutorial.rst:88
#, fuzzy
msgid "The second bit is the definition of the type object. ::"
msgstr "第二位是型別物件的定義。 ::"

#: ../../extending/newtypes_tutorial.rst:101
#, fuzzy
msgid ""
"We recommend using C99-style designated initializers as above, to avoid "
"listing all the :c:type:`PyTypeObject` fields that you don't care about and "
"also to avoid caring about the fields' declaration order."
msgstr "我們建議像上面那樣使用 C99 風格的指定初始化器，以避免列出所有你不關心的 "
"PyTypeObject 欄位，也避免關心欄位的聲明順序。"

#: ../../extending/newtypes_tutorial.rst:105
#, fuzzy
msgid ""
"The actual definition of :c:type:`PyTypeObject` in :file:`object.h` has many "
"more :ref:`fields <type-structs>` than the definition above.  The remaining "
"fields will be filled with zeros by the C compiler, and it's common practice "
"to not specify them explicitly unless you need them."
msgstr ""
":file:`object.h` 中 :c:type:`PyTypeObject` 的實際定義比上面的定義有更多的 "
":ref:`fields <type-structs>`。其餘欄位將由 C "
"編譯器用零填充，除非您需要，否則不顯式指定它們是常見的做法。"

#: ../../extending/newtypes_tutorial.rst:110
#, fuzzy
msgid "We're going to pick it apart, one field at a time::"
msgstr "我們要把它分開，一次一個欄位::"

#: ../../extending/newtypes_tutorial.rst:114
#, fuzzy
msgid ""
"This line is mandatory boilerplate to initialize the ``ob_base`` field "
"mentioned above. ::"
msgstr "這一行是強制性的樣板文件，用於初始化上面提到的 ``ob_base`` 欄位。 ::"

#: ../../extending/newtypes_tutorial.rst:119
#, fuzzy
msgid ""
"The name of our type.  This will appear in the default textual "
"representation of our objects and in some error messages, for example:"
msgstr "我們型別的名稱。這將出現在我們物件的預設文本表示和一些錯誤消息中，例如："

#: ../../extending/newtypes_tutorial.rst:129
#, fuzzy
msgid ""
"Note that the name is a dotted name that includes both the module name and "
"the name of the type within the module. The module in this case is :mod:"
"`custom` and the type is :class:`Custom`, so we set the type name to :class:"
"`custom.Custom`. Using the real dotted import path is important to make your "
"type compatible with the :mod:`pydoc` and :mod:`pickle` modules. ::"
msgstr ""
"請注意，該名稱是一個帶點的名稱，其中包括模組名稱和模組內型別的名稱。本例中的"
"模組是 :mod:`custom`，型別是 :class:`Custom`，所以我們將型別名稱設定為 :class:`c"
"ustom.Custom`。使用真正的點分導入路徑對於使您的型別與 :mod:`pydoc` 和 "
":mod:`pickle` 模組相容很重要。 ::"

#: ../../extending/newtypes_tutorial.rst:138
#, fuzzy
msgid ""
"This is so that Python knows how much memory to allocate when creating new :"
"class:`Custom` instances.  :c:member:`~PyTypeObject.tp_itemsize` is only "
"used for variable-sized objects and should otherwise be zero."
msgstr ""
"這是為了讓 Python 知道在建立新的 Custom 實例時要分配多少記憶體。 "
":c:member:`~PyTypeObject.tp_itemsize` 僅用於可變大小的物件，否則應為零。"

#: ../../extending/newtypes_tutorial.rst:144
#, fuzzy
msgid ""
"If you want your type to be subclassable from Python, and your type has the "
"same :c:member:`~PyTypeObject.tp_basicsize` as its base type, you may have "
"problems with multiple inheritance.  A Python subclass of your type will "
"have to list your type first in its :attr:`~class.__bases__`, or else it "
"will not be able to call your type's :meth:`__new__` method without getting "
"an error.  You can avoid this problem by ensuring that your type has a "
"larger value for :c:member:`~PyTypeObject.tp_basicsize` than its base type "
"does.  Most of the time, this will be true anyway, because either your base "
"type will be :class:`object`, or else you will be adding data members to "
"your base type, and therefore increasing its size."
msgstr ""
"如果您希望您的型別可以從 Python 繼承，並且您的型別具有相同的 "
":c:member:`~PyTypeObject.tp_basicsize` "
"作為其基型別，您可能會遇到多重繼承問題。您的型別的 Python 子類別必須首先在其 "
":attr:`~class.__bases__` 中列出您的型別，否則它將無法呼叫您的型別的 "
":meth:`__new__` 方法而不會出錯。您可以通過確保您的型別具有比其基型別更大的 "
":c:member:`~PyTypeObject.tp_basicsize` "
"值來避免此問題。大多數時候，這無論如何都是正確的，因為要么你的基型別是 "
":class:`object`，要么你將向你的基型別新增資料成員，從而增加它的大小。"

#: ../../extending/newtypes_tutorial.rst:154
#, fuzzy
msgid "We set the class flags to :const:`Py_TPFLAGS_DEFAULT`. ::"
msgstr "我們將類旗標設定為 :const:`Py_TPFLAGS_DEFAULT`。 ::"

#: ../../extending/newtypes_tutorial.rst:158
#, fuzzy
msgid ""
"All types should include this constant in their flags.  It enables all of "
"the members defined until at least Python 3.3.  If you need further members, "
"you will need to OR the corresponding flags."
msgstr "所有型別都應在其旗標中包含此常數。它啟用至少在 Python 3.3 "
"之前定義的所有成員。如果您需要更多成員，則需要對相應的旗標進行 OR。"

#: ../../extending/newtypes_tutorial.rst:162
#, fuzzy
msgid ""
"We provide a doc string for the type in :c:member:`~PyTypeObject.tp_doc`. ::"
msgstr "我們為 :c:member:`~PyTypeObject.tp_doc` 中的型別提供了一個文檔字串。 ::"

#: ../../extending/newtypes_tutorial.rst:166
#, fuzzy
msgid ""
"To enable object creation, we have to provide a :c:member:`~PyTypeObject."
"tp_new` handler.  This is the equivalent of the Python method :meth:"
"`__new__`, but has to be specified explicitly.  In this case, we can just "
"use the default implementation provided by the API function :c:func:"
"`PyType_GenericNew`. ::"
msgstr ""
"要啟用物件建立，我們必須提供一個 :c:member:`~PyTypeObject.tp_new` 處理程式。"
"這等同於 Python 方法 :meth:`__new__`，但必須明確指定。在這種情況下，"
"我們可以只使用 API 函式 :c:func:`PyType_GenericNew` 提供的預設實作。 ::"

#: ../../extending/newtypes_tutorial.rst:173
#, fuzzy
msgid ""
"Everything else in the file should be familiar, except for some code in :c:"
"func:`PyInit_custom`::"
msgstr "除了 :c:function:`PyInit custom`:: "
"中的一些程式碼外，文件中的其他所有內容都應該很熟悉："

#: ../../extending/newtypes_tutorial.rst:179
#, fuzzy
msgid ""
"This initializes the :class:`Custom` type, filling in a number of members to "
"the appropriate default values, including :attr:`ob_type` that we initially "
"set to ``NULL``. ::"
msgstr "這會初始化 Custom 型別，將一些成員填充為適當的預設值，包括我們最初設定為 "
"NULL 的 ob_type。 ::"

#: ../../extending/newtypes_tutorial.rst:190
#, fuzzy
msgid ""
"This adds the type to the module dictionary.  This allows us to create :"
"class:`Custom` instances by calling the :class:`Custom` class:"
msgstr "這會將型別新增到模組字典中。這允許我們通過呼叫 Custom 類來建立 Custom 實例："

#: ../../extending/newtypes_tutorial.rst:198
#, fuzzy
msgid ""
"That's it!  All that remains is to build it; put the above code in a file "
"called :file:`custom.c` and:"
msgstr "就是這樣！剩下的就是建造它；將上面的程式碼放在一個名為 :file:`custom.c` "
"的文件中，然後："

#: ../../extending/newtypes_tutorial.rst:207
#, fuzzy
msgid "in a file called :file:`setup.py`; then typing"
msgstr "在一個名為 :file:`setup.py` 的文件中；然後打字"

#: ../../extending/newtypes_tutorial.rst:213
#, fuzzy
msgid ""
"at a shell should produce a file :file:`custom.so` in a subdirectory; move "
"to that directory and fire up Python --- you should be able to ``import "
"custom`` and play around with Custom objects."
msgstr ""
"在 shell 中應該在子目錄中生成一個文件 :file:`custom.so`；"
"移動到那個目錄並啟動 Python --- 你應該能夠“導入自定義”並使用自定義物件。"

#: ../../extending/newtypes_tutorial.rst:217
#, fuzzy
msgid "That wasn't so hard, was it?"
msgstr "那並不難，是嗎？"

#: ../../extending/newtypes_tutorial.rst:219
#, fuzzy
msgid ""
"Of course, the current Custom type is pretty uninteresting. It has no data "
"and doesn't do anything. It can't even be subclassed."
msgstr "當然，當前的 Custom "
"型別非常無趣。它沒有資料，也不做任何事情。它甚至不能被子類別化。"

#: ../../extending/newtypes_tutorial.rst:223
#, fuzzy
msgid ""
"While this documentation showcases the standard :mod:`distutils` module for "
"building C extensions, it is recommended in real-world use cases to use the "
"newer and better-maintained ``setuptools`` library.  Documentation on how to "
"do this is out of scope for this document and can be found in the `Python "
"Packaging User's Guide <https://packaging.python.org/tutorials/distributing-"
"packages/>`_."
msgstr ""
"雖然本文檔展示了用於構建 C 擴充的標準 :mod:`distutils` 模組，"
"但建議在實際用例中使用更新且維護更好的 ``setuptools`` "
"庫。有關如何執行此操作的文檔超出了本文檔的範圍，可以在 `Python "
"打包使用者指南 <https://packaging.python.org/tutorials/distributing-packages/"
">`_ 中找到。"

#: ../../extending/newtypes_tutorial.rst:231
#, fuzzy
msgid "Adding data and methods to the Basic example"
msgstr "向 Basic 示例新增資料和方法"

#: ../../extending/newtypes_tutorial.rst:233
#, fuzzy
msgid ""
"Let's extend the basic example to add some data and methods.  Let's also "
"make the type usable as a base class. We'll create a new module, :mod:"
"`custom2` that adds these capabilities:"
msgstr "讓我們擴充基本示例以新增一些資料和方法。讓我們也使該型別可用作基底類別。"
"我們將建立一個新模組 :mod:`custom2` 來新增以下功能："

#: ../../extending/newtypes_tutorial.rst:240
#, fuzzy
msgid "This version of the module has a number of changes."
msgstr "這個版本的模組有一些變化。"

#: ../../extending/newtypes_tutorial.rst:242
#, fuzzy
msgid "We've added an extra include::"
msgstr "我們新增了一個額外的 include::"

#: ../../extending/newtypes_tutorial.rst:246
#, fuzzy
msgid ""
"This include provides declarations that we use to handle attributes, as "
"described a bit later."
msgstr "這包括提供我們用來處理屬性的聲明，如稍後所述。"

#: ../../extending/newtypes_tutorial.rst:249
#, fuzzy
msgid ""
"The  :class:`Custom` type now has three data attributes in its C struct, "
"*first*, *last*, and *number*.  The *first* and *last* variables are Python "
"strings containing first and last names.  The *number* attribute is a C "
"integer."
msgstr ""
":class:`Custom` 型別現在在其 C 結構中具有三個資料屬性，*first*、*last* 和 "
"*number*。 *first* 和 *last* 變數是包含名字和姓氏的 Python 字串。 *number* "
"屬性是一個 C 整數。"

#: ../../extending/newtypes_tutorial.rst:253
#, fuzzy
msgid "The object structure is updated accordingly::"
msgstr "物件結構相應更新::"

#: ../../extending/newtypes_tutorial.rst:262
#, fuzzy
msgid ""
"Because we now have data to manage, we have to be more careful about object "
"allocation and deallocation.  At a minimum, we need a deallocation method::"
msgstr "因為我們現在有資料要管理，所以我們必須更加小心物件分配和釋放。至少，我們需要"
"一個釋放方法::"

#: ../../extending/newtypes_tutorial.rst:273
#, fuzzy
msgid "which is assigned to the :c:member:`~PyTypeObject.tp_dealloc` member::"
msgstr "分配給 :c:member:`~PyTypeObject.tp_dealloc` 成員::"

#: ../../extending/newtypes_tutorial.rst:277
#, fuzzy
msgid ""
"This method first clears the reference counts of the two Python attributes. :"
"c:func:`Py_XDECREF` correctly handles the case where its argument is "
"``NULL`` (which might happen here if ``tp_new`` failed midway).  It then "
"calls the :c:member:`~PyTypeObject.tp_free` member of the object's type "
"(computed by ``Py_TYPE(self)``) to free the object's memory.  Note that the "
"object's type might not be :class:`CustomType`, because the object may be an "
"instance of a subclass."
msgstr ""
"該方法首先清除兩個 Python 屬性的引用計數。 :c:func:`Py_XDECREF` "
"正確處理其參數為 ``NULL`` 的情況（如果 ``tp_new`` "
"中途失敗，可能會發生這種情況）。然後呼叫對像型別的 :c:member:`~PyTypeObject."
"tp_free` 成員（由 Py_TYPE(self) 計算）來釋放物件的記憶體。請注意，"
"該物件的型別可能不是 CustomType，因為該物件可能是子類別的實例。"

#: ../../extending/newtypes_tutorial.rst:286
#, fuzzy
msgid ""
"The explicit cast to ``destructor`` above is needed because we defined "
"``Custom_dealloc`` to take a ``CustomObject *`` argument, but the "
"``tp_dealloc`` function pointer expects to receive a ``PyObject *`` "
"argument.  Otherwise, the compiler will emit a warning.  This is object-"
"oriented polymorphism, in C!"
msgstr ""
"上面需要顯式轉換為“析構函式”，因為我們將“Custom_dealloc”定義為採用“"
"CustomObject *”參數，但“tp_dealloc”函式指標期望接收“PyObject "
"*”爭論。否則，編譯器將發出警告。這就是 C 語言中的面向對像多態性！"

#: ../../extending/newtypes_tutorial.rst:292
#, fuzzy
msgid ""
"We want to make sure that the first and last names are initialized to empty "
"strings, so we provide a ``tp_new`` implementation::"
msgstr "我們要確保將名字和姓氏初始化為空字串，因此我們提供了一個“tp_new”實作："

#: ../../extending/newtypes_tutorial.rst:316
#, fuzzy
msgid "and install it in the :c:member:`~PyTypeObject.tp_new` member::"
msgstr "並將其安裝在 :c:member:`~PyTypeObject.tp_new` 成員::"

#: ../../extending/newtypes_tutorial.rst:320
#, fuzzy
msgid ""
"The ``tp_new`` handler is responsible for creating (as opposed to "
"initializing) objects of the type.  It is exposed in Python as the :meth:"
"`__new__` method. It is not required to define a ``tp_new`` member, and "
"indeed many extension types will simply reuse :c:func:`PyType_GenericNew` as "
"done in the first version of the ``Custom`` type above.  In this case, we "
"use the ``tp_new`` handler to initialize the ``first`` and ``last`` "
"attributes to non-``NULL`` default values."
msgstr ""
"``tp_new`` 處理程式負責建立（而不是初始化）該型別的物件。它在 Python 中作為 "
":meth:`__new__` 方法公開。不需要定義``tp_new`` "
"成員，實際上許多擴充型別將簡單地重用:c:func:`PyType_GenericNew` "
"就像上面第一個版本的``Custom`` 型別所做的那樣。在這種情況下，我們使用“tp_new”"
"處理程式將 ``first``和 ``last``屬性初始化為非 ``NULL`` 預設值。"

#: ../../extending/newtypes_tutorial.rst:328
#, fuzzy
msgid ""
"``tp_new`` is passed the type being instantiated (not necessarily "
"``CustomType``, if a subclass is instantiated) and any arguments passed when "
"the type was called, and is expected to return the instance created.  "
"``tp_new`` handlers always accept positional and keyword arguments, but they "
"often ignore the arguments, leaving the argument handling to initializer (a."
"k.a. ``tp_init`` in C or ``__init__`` in Python) methods."
msgstr ""
"``tp_new`` 傳遞被實例化的型別（不一定是 ``CustomType``，如果子類別被實例化）"
"和呼叫型別時傳遞的任何參數，並期望回傳建立的實例。 ``tp_new`` 處理程式總是接"
"受位置和關鍵字參數，但它們通常會忽略這些參數，將參數處理留給初始化程式（又名 "
"C 中的 ``tp_init`` 或 Python 中的 __init__ ）方法。"

#: ../../extending/newtypes_tutorial.rst:336
#, fuzzy
msgid ""
"``tp_new`` shouldn't call ``tp_init`` explicitly, as the interpreter will do "
"it itself."
msgstr "``tp_new`` 不應該顯式呼叫 ``tp_init``，因為直譯器會自己做。"

#: ../../extending/newtypes_tutorial.rst:339
#, fuzzy
msgid ""
"The ``tp_new`` implementation calls the :c:member:`~PyTypeObject.tp_alloc` "
"slot to allocate memory::"
msgstr "``tp_new`` 實作呼叫 :c:member:`~PyTypeObject.tp_alloc` 插槽來分配記憶體::"

#: ../../extending/newtypes_tutorial.rst:344
#, fuzzy
msgid ""
"Since memory allocation may fail, we must check the :c:member:`~PyTypeObject."
"tp_alloc` result against ``NULL`` before proceeding."
msgstr ""
"由於記憶體分配可能會失敗，我們必須在繼續之前檢查 :c:member:`~PyTypeObject."
"tp_alloc` 結果是否為 ``NULL``。"

#: ../../extending/newtypes_tutorial.rst:348
#, fuzzy
msgid ""
"We didn't fill the :c:member:`~PyTypeObject.tp_alloc` slot ourselves. "
"Rather :c:func:`PyType_Ready` fills it for us by inheriting it from our base "
"class, which is :class:`object` by default.  Most types use the default "
"allocation strategy."
msgstr ""
"我們自己沒有填充 :c:member:`~PyTypeObject.tp_alloc` 槽。而是 "
":c:func:`PyType_Ready` 通過從我們的基底類別繼承它來為我們填充它，"
"預設情況下是 :class:`object`。大多數型別使用預設分配策略。"

#: ../../extending/newtypes_tutorial.rst:354
#, fuzzy
msgid ""
"If you are creating a co-operative :c:member:`~PyTypeObject.tp_new` (one "
"that calls a base type's :c:member:`~PyTypeObject.tp_new` or :meth:"
"`__new__`), you must *not* try to determine what method to call using method "
"resolution order at runtime.  Always statically determine what type you are "
"going to call, and call its :c:member:`~PyTypeObject.tp_new` directly, or "
"via ``type->tp_base->tp_new``.  If you do not do this, Python subclasses of "
"your type that also inherit from other Python-defined classes may not work "
"correctly. (Specifically, you may not be able to create instances of such "
"subclasses without getting a :exc:`TypeError`.)"
msgstr ""
"如果你正在建立一個合作 :c:member:`~PyTypeObject."
"tp_new`（一個呼叫基型別的:c:member:`~PyTypeObject.tp_new` 或 "
":meth:`__new__`），你必須*不* 嘗試在運行時使用方法解析順序來確定要呼叫的方法"
"。始終靜態確定要呼叫的型別，並直接呼叫其:c:member:`~PyTypeObject."
"tp_new`，或通過``type->tp_base->tp_new``。如果您不這樣做，您的型別的 Python "
"子類別也繼承自其他 Python 定義的類可能無法正常工作。 （具體來說，"
"您可能無法在沒有得到 :exc:`TypeError` 的情況下建立此類子類別的實例。）"

#: ../../extending/newtypes_tutorial.rst:364
#, fuzzy
msgid ""
"We also define an initialization function which accepts arguments to provide "
"initial values for our instance::"
msgstr "我們還定義了一個初始化函式，它接受參數為我們的實例提供初始值::"

#: ../../extending/newtypes_tutorial.rst:393
#, fuzzy
msgid "by filling the :c:member:`~PyTypeObject.tp_init` slot. ::"
msgstr "通過填充 :c:member:`~PyTypeObject.tp_init` 槽。 ::"

#: ../../extending/newtypes_tutorial.rst:397
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_init` slot is exposed in Python as the :meth:"
"`__init__` method.  It is used to initialize an object after it's created.  "
"Initializers always accept positional and keyword arguments, and they should "
"return either ``0`` on success or ``-1`` on error."
msgstr ""
":c:member:`~PyTypeObject.tp_init` 插槽在 Python 中作為 :meth:`__init__` 方法"
"公開。它用於在物件建立後對其進行初始化。初始化器總是接受位置參數和關鍵字參數"
"，它們應該在成功時回傳 ``0``或在錯誤時回傳 ``-1``。"

#: ../../extending/newtypes_tutorial.rst:402
#, fuzzy
msgid ""
"Unlike the ``tp_new`` handler, there is no guarantee that ``tp_init`` is "
"called at all (for example, the :mod:`pickle` module by default doesn't "
"call :meth:`__init__` on unpickled instances).  It can also be called "
"multiple times.  Anyone can call the :meth:`__init__` method on our "
"objects.  For this reason, we have to be extra careful when assigning the "
"new attribute values.  We might be tempted, for example to assign the "
"``first`` member like this::"
msgstr ""
"與 ``tp_new`` 處理程式不同，根本無法保證 ``tp_init`` "
"被呼叫（例如，預設情況下，:mod:`pickle` 模組不會呼叫 :meth:`__init__` "
"unpickled 實例).也可以多次呼叫。任何人都可以在我們的對像上呼叫 "
":meth:`__init__` "
"方法。因此，我們在分配新屬性值時必須格外小心。我們可能會被誘惑，"
"例如像這樣分配 ``first`` 成員："

#: ../../extending/newtypes_tutorial.rst:416
#, fuzzy
msgid ""
"But this would be risky.  Our type doesn't restrict the type of the "
"``first`` member, so it could be any kind of object.  It could have a "
"destructor that causes code to be executed that tries to access the "
"``first`` member; or that destructor could release the :term:`Global "
"interpreter Lock <GIL>` and let arbitrary code run in other threads that "
"accesses and modifies our object."
msgstr ""
"但這樣做會有風險。我們的型別不限制“第一個”成員的型別，因此它可以是任何型別的"
"物件。它可能有一個析構函式，導致執行試圖訪問“第一個”成員的程式碼；"
"或者該析構函式可以釋放 :term:`Global interpreter Lock <GIL>` "
"並讓任意程式碼在訪問和修改我們的物件的其他執行緒中運行。"

#: ../../extending/newtypes_tutorial.rst:423
#, fuzzy
msgid ""
"To be paranoid and protect ourselves against this possibility, we almost "
"always reassign members before decrementing their reference counts.  When "
"don't we have to do this?"
msgstr "為了偏執並保護自己免受這種可能性的影響，我們幾乎總是在減少成員的引用計數之前"
"重新分配成員。我們什麼時候不需要這樣做？"

#: ../../extending/newtypes_tutorial.rst:427
#, fuzzy
msgid "when we absolutely know that the reference count is greater than 1;"
msgstr "當我們絕對知道引用計數大於1時；"

#: ../../extending/newtypes_tutorial.rst:429
#, fuzzy
msgid ""
"when we know that deallocation of the object [#]_ will neither release the :"
"term:`GIL` nor cause any calls back into our type's code;"
msgstr "當我們知道物件 [#]_ 的釋放既不會釋放 GIL "
"也不會導致任何回呼到我們型別的程式碼時；"

#: ../../extending/newtypes_tutorial.rst:432
#, fuzzy
msgid ""
"when decrementing a reference count in a :c:member:`~PyTypeObject."
"tp_dealloc` handler on a type which doesn't support cyclic garbage "
"collection [#]_."
msgstr "在不支援循環垃圾收集的型別的 :c:member:`~PyTypeObject.tp_dealloc` "
"處理程式中減少引用計數時 [#]_。"

#: ../../extending/newtypes_tutorial.rst:435
#, fuzzy
msgid ""
"We want to expose our instance variables as attributes. There are a number "
"of ways to do that. The simplest way is to define member definitions::"
msgstr "我們想將我們的實例變數公開為屬性。有很多方法可以做到這一點。最簡單的方法是定"
"義成員定義::"

#: ../../extending/newtypes_tutorial.rst:448
#, fuzzy
msgid ""
"and put the definitions in the :c:member:`~PyTypeObject.tp_members` slot::"
msgstr "並將定義放入 :c:member:`~PyTypeObject.tp_members` 槽中::"

#: ../../extending/newtypes_tutorial.rst:452
#, fuzzy
msgid ""
"Each member definition has a member name, type, offset, access flags and "
"documentation string.  See the :ref:`Generic-Attribute-Management` section "
"below for details."
msgstr ""
"每個成員定義都有成員名稱、型別、偏移量、訪問旗標和文檔字串。有關詳細資訊，"
"請參閱下面的 :ref:`Generic-Attribute-Management` 部分。"

#: ../../extending/newtypes_tutorial.rst:456
#, fuzzy
msgid ""
"A disadvantage of this approach is that it doesn't provide a way to restrict "
"the types of objects that can be assigned to the Python attributes.  We "
"expect the first and last names to be strings, but any Python objects can be "
"assigned. Further, the attributes can be deleted, setting the C pointers to "
"``NULL``.  Even though we can make sure the members are initialized to non-"
"``NULL`` values, the members can be set to ``NULL`` if the attributes are "
"deleted."
msgstr ""
"這種方法的一個缺點是它沒有提供一種方法來限制可以分配給 Python "
"屬性的對像型別。我們希望名字和姓氏是字串，但可以分配任何 Python "
"物件。此外，可以刪除屬性，將 C 指標設定為 ``NULL`` 。即使我們可以確保成員被初始化"
"為非 ``NULL`` 值，如果屬性被刪除，成員也可以設定為 ``NULL`` 。"

#: ../../extending/newtypes_tutorial.rst:463
#, fuzzy
msgid ""
"We define a single method, :meth:`Custom.name()`, that outputs the objects "
"name as the concatenation of the first and last names. ::"
msgstr "我們定義了一個方法 Custom.name() ，它輸出物件名稱作為名字和姓氏的串聯。 ::"

#: ../../extending/newtypes_tutorial.rst:480
#, fuzzy
msgid ""
"The method is implemented as a C function that takes a :class:`Custom` (or :"
"class:`Custom` subclass) instance as the first argument.  Methods always "
"take an instance as the first argument. Methods often take positional and "
"keyword arguments as well, but in this case we don't take any and don't need "
"to accept a positional argument tuple or keyword argument dictionary. This "
"method is equivalent to the Python method:"
msgstr ""
"該方法作為一個 C 函式實作，該函式將 Custom（或 Custom 子類別）實例作為第一個"
"參數。方法總是將實例作為第一個參數。方法通常也採用位置參數和關鍵字參數，但在"
"這種情況下，我們不採用任何參數，也不需要接受位置參數元組或關鍵字參數字典。"
"此方法等同於 Python 方法："

#: ../../extending/newtypes_tutorial.rst:492
#, fuzzy
msgid ""
"Note that we have to check for the possibility that our :attr:`first` and :"
"attr:`last` members are ``NULL``.  This is because they can be deleted, in "
"which case they are set to ``NULL``.  It would be better to prevent deletion "
"of these attributes and to restrict the attribute values to be strings.  "
"We'll see how to do that in the next section."
msgstr ""
"請注意，我們必須檢查我們的 :attr:`first` 和 :attr:`last` 成員是否為``NULL`` 的"
"可能性。這是因為它們可以被刪除，在這種情況下它們被設定為 ``NULL`` 。最好防止刪除"
"這些屬性並將屬性值限制為字串。我們將在下一節中看到如何做到這一點。"

#: ../../extending/newtypes_tutorial.rst:498
#, fuzzy
msgid ""
"Now that we've defined the method, we need to create an array of method "
"definitions::"
msgstr "現在我們已經定義了方法，我們需要建立一個方法定義數組::"

#: ../../extending/newtypes_tutorial.rst:508
#, fuzzy
msgid ""
"(note that we used the :const:`METH_NOARGS` flag to indicate that the method "
"is expecting no arguments other than *self*)"
msgstr "（請注意，我們使用了 :const:`METH_NOARGS` 旗標來指示該方法除了 *self* "
"之外不需要其他參數）"

#: ../../extending/newtypes_tutorial.rst:511
#, fuzzy
msgid "and assign it to the :c:member:`~PyTypeObject.tp_methods` slot::"
msgstr "並將其分配給 :c:member:`~PyTypeObject.tp_methods` 插槽::"

#: ../../extending/newtypes_tutorial.rst:515
#, fuzzy
msgid ""
"Finally, we'll make our type usable as a base class for subclassing.  We've "
"written our methods carefully so far so that they don't make any assumptions "
"about the type of the object being created or used, so all we need to do is "
"to add the :const:`Py_TPFLAGS_BASETYPE` to our class flag definition::"
msgstr ""
"最後，我們將使我們的型別可用作子類別化的基底類別。到目前為止，我們已經仔細編"
"寫了我們的方法，因此它們不會對正在建立或使用的物件的型別做出任何假設，"
"因此我們需要做的就是將 Py_TPFLAGS_BASETYPE 新增到我們的類旗標定義中::"

#: ../../extending/newtypes_tutorial.rst:522
#, fuzzy
msgid ""
"We rename :c:func:`PyInit_custom` to :c:func:`PyInit_custom2`, update the "
"module name in the :c:type:`PyModuleDef` struct, and update the full class "
"name in the :c:type:`PyTypeObject` struct."
msgstr ""
"我們將 :c:func:`PyInit_custom` 重命名為 :c:func:`PyInit_custom2`，更新 "
":c:type:`PyModuleDef` 結構中的模組名稱，並更新 :c:type:` "
"中的完整類名PyTypeObject 結構。"

#: ../../extending/newtypes_tutorial.rst:526
#, fuzzy
msgid "Finally, we update our :file:`setup.py` file to build the new module:"
msgstr "最後，我們更新 :file:`setup.py` 文件來構建新模組："

#: ../../extending/newtypes_tutorial.rst:539
#, fuzzy
msgid "Providing finer control over data attributes"
msgstr "提供對資料屬性的更精細控制"

#: ../../extending/newtypes_tutorial.rst:541
#, fuzzy
msgid ""
"In this section, we'll provide finer control over how the :attr:`first` and :"
"attr:`last` attributes are set in the :class:`Custom` example. In the "
"previous version of our module, the instance variables :attr:`first` and :"
"attr:`last` could be set to non-string values or even deleted. We want to "
"make sure that these attributes always contain strings."
msgstr ""
"在本節中，我們將更好地控制 :attr:`first` 和 :attr:`last` 屬性在 :class:`Custom` "
"示例中的設定方式。在我們模組的先前版本中，實例變數 :attr:`first` 和 "
":attr:`last` "
"可以設定為非字串值，甚至可以刪除。我們要確保這些屬性始終包含字串。"

#: ../../extending/newtypes_tutorial.rst:550
#, fuzzy
msgid ""
"To provide greater control, over the :attr:`first` and :attr:`last` "
"attributes, we'll use custom getter and setter functions.  Here are the "
"functions for getting and setting the :attr:`first` attribute::"
msgstr ""
"為了更好地控制 :attr:`first` 和 :attr:`last` 屬性，我們將使用自定義 getter "
"和 setter 函式。以下是獲取和設定 first 屬性的函式："

#: ../../extending/newtypes_tutorial.rst:581
#, fuzzy
msgid ""
"The getter function is passed a :class:`Custom` object and a \"closure\", "
"which is a void pointer.  In this case, the closure is ignored.  (The "
"closure supports an advanced usage in which definition data is passed to the "
"getter and setter. This could, for example, be used to allow a single set of "
"getter and setter functions that decide the attribute to get or set based on "
"data in the closure.)"
msgstr ""
"getter 函式被傳遞給一個 Custom "
"物件和一個“閉包”，它是一個空指標。在這種情況下，閉包會被忽略。 "
"（閉包支援高階用法，其中將定義資料傳遞給 getter 和 setter。例如，"
"這可以用於允許一組 getter 和 setter 函式，這些函式根據關閉。）"

#: ../../extending/newtypes_tutorial.rst:587
#, fuzzy
msgid ""
"The setter function is passed the :class:`Custom` object, the new value, and "
"the closure.  The new value may be ``NULL``, in which case the attribute is "
"being deleted.  In our setter, we raise an error if the attribute is deleted "
"or if its new value is not a string."
msgstr ""
"setter 函式被傳遞給 Custom "
"物件、新值和閉包。新值可能是 ``NULL`` ，在這種情況下該屬性將被刪除。在我們的 "
"setter 中，如果屬性被刪除或者它的新值不是字串，我們會引發錯誤。"

#: ../../extending/newtypes_tutorial.rst:592
#, fuzzy
msgid "We create an array of :c:type:`PyGetSetDef` structures::"
msgstr "我們建立一個 :c:type:`PyGetSetDef` 結構數組::"

#: ../../extending/newtypes_tutorial.rst:602
#, fuzzy
msgid "and register it in the :c:member:`~PyTypeObject.tp_getset` slot::"
msgstr "並將其註冊到 :c:member:`~PyTypeObject.tp_getset` 插槽::"

#: ../../extending/newtypes_tutorial.rst:606
#, fuzzy
msgid ""
"The last item in a :c:type:`PyGetSetDef` structure is the \"closure\" "
"mentioned above.  In this case, we aren't using a closure, so we just pass "
"``NULL``."
msgstr ":c:type:`PyGetSetDef` 結構中的最後一項是上面提到的“閉包”。在這種情況下，我們"
"沒有使用閉包，所以我們只傳遞 ``NULL`` 。"

#: ../../extending/newtypes_tutorial.rst:609
#, fuzzy
msgid "We also remove the member definitions for these attributes::"
msgstr "我們還刪除了這些屬性的成員定義::"

#: ../../extending/newtypes_tutorial.rst:617
#, fuzzy
msgid ""
"We also need to update the :c:member:`~PyTypeObject.tp_init` handler to only "
"allow strings [#]_ to be passed::"
msgstr "我們還需要更新 :c:member:`~PyTypeObject.tp_init` 處理程式以僅允許傳遞字串 "
"[#]_::"

#: ../../extending/newtypes_tutorial.rst:646
#, fuzzy
msgid ""
"With these changes, we can assure that the ``first`` and ``last`` members "
"are never ``NULL`` so we can remove checks for ``NULL`` values in almost all "
"cases. This means that most of the :c:func:`Py_XDECREF` calls can be "
"converted to :c:func:`Py_DECREF` calls.  The only place we can't change "
"these calls is in the ``tp_dealloc`` implementation, where there is the "
"possibility that the initialization of these members failed in ``tp_new``."
msgstr ""
"通過這些更改，我們可以確保 ``first`` 和 ``last`` 成員永遠不會是 ``NULL``，"
"因此我們可以在幾乎所有情況下刪除對 ``NULL`` 值的檢查。這意味著大多數 "
":c:func:`Py_XDECREF` 呼叫都可以轉換為 :c:func:`Py_DECREF` 呼叫。"
"我們唯一不能更改這些呼叫的地方是在 ``tp_dealloc`` 實作中，"
"這些成員的初始化有可能在 ``tp_new`` 中失敗。"

#: ../../extending/newtypes_tutorial.rst:653
#, fuzzy
msgid ""
"We also rename the module initialization function and module name in the "
"initialization function, as we did before, and we add an extra definition to "
"the :file:`setup.py` file."
msgstr "我們還像之前一樣重命名了模組初始化函式和初始化函式中的模組名稱，並在 "
":file:`setup.py` 文件中新增了一個額外的定義。"

#: ../../extending/newtypes_tutorial.rst:659
#, fuzzy
msgid "Supporting cyclic garbage collection"
msgstr "支援循環垃圾回收"

#: ../../extending/newtypes_tutorial.rst:661
#, fuzzy
msgid ""
"Python has a :term:`cyclic garbage collector (GC) <garbage collection>` that "
"can identify unneeded objects even when their reference counts are not zero. "
"This can happen when objects are involved in cycles.  For example, consider:"
msgstr ""
"Python 有一個 :term:`循環垃圾收集器 (GC) <garbage collection>` 可以識別不需要"
"的物件，即使它們的引用計數不為零。當物件參與循環時，就會發生這種情況。例如，"
"考慮："

#: ../../extending/newtypes_tutorial.rst:671
#, fuzzy
msgid ""
"In this example, we create a list that contains itself. When we delete it, "
"it still has a reference from itself. Its reference count doesn't drop to "
"zero. Fortunately, Python's cyclic garbage collector will eventually figure "
"out that the list is garbage and free it."
msgstr ""
"在此示例中，我們建立了一個包含自身的列表。當我們刪除它時，它仍然有一個來自自"
"身的引用。它的引用計數不會降為零。幸運的是，Python "
"的循環垃圾收集器最終會發現該列表是垃圾並釋放它。"

#: ../../extending/newtypes_tutorial.rst:676
#, fuzzy
msgid ""
"In the second version of the :class:`Custom` example, we allowed any kind of "
"object to be stored in the :attr:`first` or :attr:`last` attributes [#]_. "
"Besides, in the second and third versions, we allowed subclassing :class:"
"`Custom`, and subclasses may add arbitrary attributes.  For any of those two "
"reasons, :class:`Custom` objects can participate in cycles:"
msgstr ""
"在 :class:`Custom` 示例的第二個版本中，我們允許將任何型別的物件儲存在 "
":attr:`first` 或 :attr:`last` 屬性 [#]_ 中。此外，在第二個和第三個版本中，我"
"們允許子類別化 :class:`Custom`，並且子類別可以新增任意屬性。由於這兩個原因中的"
"任何一個，:class:`Custom` 物件可以參與循環："

#: ../../extending/newtypes_tutorial.rst:690
#, fuzzy
msgid ""
"To allow a :class:`Custom` instance participating in a reference cycle to be "
"properly detected and collected by the cyclic GC, our :class:`Custom` type "
"needs to fill two additional slots and to enable a flag that enables these "
"slots:"
msgstr ""
"為了允許循環 GC 正確檢測和收集參與引用循環的 Custom 實例，我們的 Custom "
"型別需要填充兩個額外的插槽並啟用啟用這些插槽的旗標："

#: ../../extending/newtypes_tutorial.rst:697
#, fuzzy
msgid ""
"First, the traversal method lets the cyclic GC know about subobjects that "
"could participate in cycles::"
msgstr "首先，遍歷方法讓循環GC知道可以參與循環的子物件::"

#: ../../extending/newtypes_tutorial.rst:717
#, fuzzy
msgid ""
"For each subobject that can participate in cycles, we need to call the :c:"
"func:`visit` function, which is passed to the traversal method. The :c:func:"
"`visit` function takes as arguments the subobject and the extra argument "
"*arg* passed to the traversal method.  It returns an integer value that must "
"be returned if it is non-zero."
msgstr ""
"對於每個可以參與循環的子物件，我們需要呼叫 :c:func:`visit` "
"函式，該函式傳遞給遍歷方法。 :c:func:`visit` "
"函式將子物件和傳遞給遍歷方法的額外參數 *arg* "
"作為參數。它回傳一個整數值，如果它非零，則必須回傳該整數值。"

#: ../../extending/newtypes_tutorial.rst:723
#, fuzzy
msgid ""
"Python provides a :c:func:`Py_VISIT` macro that automates calling visit "
"functions.  With :c:func:`Py_VISIT`, we can minimize the amount of "
"boilerplate in ``Custom_traverse``::"
msgstr ""
"Python 提供了一個 :c:func:`Py_VISIT` 巨集，可以自動呼叫訪問函式。使用 "
":c:func:`Py_VISIT`，我們可以最小化 ``Custom_traverse`` 中的樣板數量："

#: ../../extending/newtypes_tutorial.rst:736
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` implementation must name its "
"arguments exactly *visit* and *arg* in order to use :c:func:`Py_VISIT`."
msgstr ""
":c:member:`~PyTypeObject.tp_traverse` 實作必須準確命名其參數 *visit* 和 *arg*"
" 才能使用 :c:func:`Py_VISIT`。"

#: ../../extending/newtypes_tutorial.rst:739
#, fuzzy
msgid ""
"Second, we need to provide a method for clearing any subobjects that can "
"participate in cycles::"
msgstr "其次，我們需要提供一種方法來清除任何可以參與循環的子物件："

#: ../../extending/newtypes_tutorial.rst:750
#, fuzzy
msgid ""
"Notice the use of the :c:func:`Py_CLEAR` macro.  It is the recommended and "
"safe way to clear data attributes of arbitrary types while decrementing "
"their reference counts.  If you were to call :c:func:`Py_XDECREF` instead on "
"the attribute before setting it to ``NULL``, there is a possibility that the "
"attribute's destructor would call back into code that reads the attribute "
"again (*especially* if there is a reference cycle)."
msgstr ""
"注意 :c:func:`Py_CLEAR` "
"巨集的使用。這是清除任意型別的資料屬性同時減少其引用計數的推薦且安全的方法。"
"如果在將屬性設定為 ``NULL`` 之前呼叫 :c:func:`Py_XDECREF` 而不是屬性，屬性的"
"析構函式可能會回呼再次讀取屬性的程式碼（*特別是*如果有參考循環）。"

#: ../../extending/newtypes_tutorial.rst:758
#, fuzzy
msgid "You could emulate :c:func:`Py_CLEAR` by writing::"
msgstr "您可以通過編寫來模擬 :c:func:`Py_CLEAR`::"

#: ../../extending/newtypes_tutorial.rst:765
#, fuzzy
msgid ""
"Nevertheless, it is much easier and less error-prone to always use :c:func:"
"`Py_CLEAR` when deleting an attribute.  Don't try to micro-optimize at the "
"expense of robustness!"
msgstr "儘管如此，在刪除屬性時始終使用 :c:func:`Py_CLEAR` "
"會更容易且更不容易出錯。不要試圖以犧牲健壯性為代價進行微最佳化！"

#: ../../extending/newtypes_tutorial.rst:769
#, fuzzy
msgid ""
"The deallocator ``Custom_dealloc`` may call arbitrary code when clearing "
"attributes.  It means the circular GC can be triggered inside the function. "
"Since the GC assumes reference count is not zero, we need to untrack the "
"object from the GC by calling :c:func:`PyObject_GC_UnTrack` before clearing "
"members. Here is our reimplemented deallocator using :c:func:"
"`PyObject_GC_UnTrack` and ``Custom_clear``::"
msgstr ""
"清除屬性時，釋放器“Custom_dealloc”可能會呼叫任意程式碼。這意味著可以在函式內"
"部觸發循環GC。由於 GC 假定引用計數不為零，我們需要在清除成員之前通過呼叫 "
"PyObject_GC_UnTrack 從 GC 中取消跟踪物件。這是我們使用 "
":c:func:`PyObject_GC_UnTrack` 和 ``Custom_clear`` 重新實作的釋放器::"

#: ../../extending/newtypes_tutorial.rst:784
#, fuzzy
msgid ""
"Finally, we add the :const:`Py_TPFLAGS_HAVE_GC` flag to the class flags::"
msgstr "最後，我們將 Py_TPFLAGS_HAVE_GC 旗標新增到類旗標中："

#: ../../extending/newtypes_tutorial.rst:788
#, fuzzy
msgid ""
"That's pretty much it.  If we had written custom :c:member:`~PyTypeObject."
"tp_alloc` or :c:member:`~PyTypeObject.tp_free` handlers, we'd need to modify "
"them for cyclic garbage collection.  Most extensions will use the versions "
"automatically provided."
msgstr ""
"差不多就是這樣。如果我們編寫了自定義 :c:member:`~PyTypeObject.tp_alloc` 或 "
":c:member:`~PyTypeObject.tp_free` 處理程式，我們需要修改它們以進行循環垃圾回"
"收。大多數擴充將使用自動提供的版本。"

#: ../../extending/newtypes_tutorial.rst:794
#, fuzzy
msgid "Subclassing other types"
msgstr "子類別化其他型別"

#: ../../extending/newtypes_tutorial.rst:796
#, fuzzy
msgid ""
"It is possible to create new extension types that are derived from existing "
"types. It is easiest to inherit from the built in types, since an extension "
"can easily use the :c:type:`PyTypeObject` it needs. It can be difficult to "
"share these :c:type:`PyTypeObject` structures between extension modules."
msgstr ""
"可以建立從現有型別派生的新擴充型別。從內建型別繼承是最簡單的，"
"因為擴充可以輕鬆使用它需要的 PyTypeObject。在擴充模組之間共享這些 "
":c:type:`PyTypeObject` 結構可能很困難。"

#: ../../extending/newtypes_tutorial.rst:801
#, fuzzy
msgid ""
"In this example we will create a :class:`SubList` type that inherits from "
"the built-in :class:`list` type. The new type will be completely compatible "
"with regular lists, but will have an additional :meth:`increment` method "
"that increases an internal counter:"
msgstr ""
"在這個例子中，我們將建立一個繼承自內建 list 型別的 SubList "
"型別。新型別將與常規列表完全相容，但會有一個額外的 :meth:`increment` "
"方法來增加一個內部計數器："

#: ../../extending/newtypes_tutorial.rst:821
#, fuzzy
msgid ""
"As you can see, the source code closely resembles the :class:`Custom` "
"examples in previous sections. We will break down the main differences "
"between them. ::"
msgstr "如您所見，源程式碼與前面部分中的 Custom "
"示例非常相似。我們將分解它們之間的主要區別。 ::"

#: ../../extending/newtypes_tutorial.rst:829
#, fuzzy
msgid ""
"The primary difference for derived type objects is that the base type's "
"object structure must be the first value.  The base type will already "
"include the :c:func:`PyObject_HEAD` at the beginning of its structure."
msgstr "派生型別物件的主要區別在於基型別的物件結構必須是第一個值。基本型別將在其結構"
"的開頭包含:c:func:`PyObject_HEAD`。"

#: ../../extending/newtypes_tutorial.rst:833
#, fuzzy
msgid ""
"When a Python object is a :class:`SubList` instance, its ``PyObject *`` "
"pointer can be safely cast to both ``PyListObject *`` and ``SubListObject "
"*``::"
msgstr ""
"當 Python 對像是 SubList 實例時，它的 PyObject *`` 指標可以安全地轉換為 "
"PyListObject *`` 和 SubListObject *``::"

#: ../../extending/newtypes_tutorial.rst:845
#, fuzzy
msgid ""
"We see above how to call through to the :attr:`__init__` method of the base "
"type."
msgstr "我們在上面看到如何呼叫基型別的 :attr:`__init__` 方法。"

#: ../../extending/newtypes_tutorial.rst:848
#, fuzzy
msgid ""
"This pattern is important when writing a type with custom :c:member:"
"`~PyTypeObject.tp_new` and :c:member:`~PyTypeObject.tp_dealloc` members.  "
"The :c:member:`~PyTypeObject.tp_new` handler should not actually create the "
"memory for the object with its :c:member:`~PyTypeObject.tp_alloc`, but let "
"the base class handle it by calling its own :c:member:`~PyTypeObject.tp_new`."
msgstr ""
"在使用自定義 :c:member:`~PyTypeObject.tp_new` 和 :c:member:`~PyTypeObject."
"tp_dealloc` 成員編寫型別時，此模式很重要。 :c:member:`~PyTypeObject.tp_new` "
"處理程式實際上不應該使用它的:c:member:`~PyTypeObject.tp_alloc` "
"為物件建立記憶體，而是讓基底類別通過呼叫它自己的 :c "
"來處理它 :member:`~PyTypeObject.tp_new`。"

#: ../../extending/newtypes_tutorial.rst:854
#, fuzzy
msgid ""
"The :c:type:`PyTypeObject` struct supports a :c:member:`~PyTypeObject."
"tp_base` specifying the type's concrete base class.  Due to cross-platform "
"compiler issues, you can't fill that field directly with a reference to :c:"
"type:`PyList_Type`; it should be done later in the module initialization "
"function::"
msgstr ""
":c:type:`PyTypeObject` 結構支援 :c:member:`~PyTypeObject.tp_base` "
"指定型別的具體基底類別。由於跨平台編譯器問題，您不能直接使用對 "
":c:type:`PyList_Type` 的引用來填充該欄位；它應該稍後在模組初始化函式中完成::"

#: ../../extending/newtypes_tutorial.rst:882
#, fuzzy
msgid ""
"Before calling :c:func:`PyType_Ready`, the type structure must have the :c:"
"member:`~PyTypeObject.tp_base` slot filled in.  When we are deriving an "
"existing type, it is not necessary to fill out the :c:member:`~PyTypeObject."
"tp_alloc` slot with :c:func:`PyType_GenericNew` -- the allocation function "
"from the base type will be inherited."
msgstr ""
"在呼叫 :c:func:`PyType_Ready` 之前，型別結構必須填充 :c:member:`~PyTypeObject"
".tp_base` 插槽。當我們派生現有型別時，沒有必要填寫 :c :member:`~PyTypeObject."
"tp_alloc` slot with :c:func:`PyType_GenericNew` -- 基型別的分配函式將被繼承。"

#: ../../extending/newtypes_tutorial.rst:888
#, fuzzy
msgid ""
"After that, calling :c:func:`PyType_Ready` and adding the type object to the "
"module is the same as with the basic :class:`Custom` examples."
msgstr "之後，呼叫 PyType_Ready 並將型別物件新增到模組與基本的 Custom 示例相同。"

#: ../../extending/newtypes_tutorial.rst:893
msgid "Footnotes"
msgstr "註解"

#: ../../extending/newtypes_tutorial.rst:894
#, fuzzy
msgid ""
"This is true when we know that the object is a basic type, like a string or "
"a float."
msgstr "當我們知道對像是基本型別（如字串或浮點數）時，情況就是如此。"

#: ../../extending/newtypes_tutorial.rst:897
#, fuzzy
msgid ""
"We relied on this in the :c:member:`~PyTypeObject.tp_dealloc` handler in "
"this example, because our type doesn't support garbage collection."
msgstr "我們在此示例的 :c:member:`~PyTypeObject.tp_dealloc` "
"處理程式中依賴於此，因為我們的型別不支援垃圾回收。"

#: ../../extending/newtypes_tutorial.rst:900
#, fuzzy
msgid ""
"We now know that the first and last members are strings, so perhaps we could "
"be less careful about decrementing their reference counts, however, we "
"accept instances of string subclasses.  Even though deallocating normal "
"strings won't call back into our objects, we can't guarantee that "
"deallocating an instance of a string subclass won't call back into our "
"objects."
msgstr ""
"我們現在知道第一個和最後一個成員是字串，所以也許我們可以不那麼小心地減少它們"
"的引用計數，但是，我們接受字串子類別的實例。即使解除分配普通字串不會回呼我們"
"的物件，我們也不能保證解除分配字串子類別的實例不會回呼我們的物件。"

#: ../../extending/newtypes_tutorial.rst:906
#, fuzzy
msgid ""
"Also, even with our attributes restricted to strings instances, the user "
"could pass arbitrary :class:`str` subclasses and therefore still create "
"reference cycles."
msgstr "此外，即使我們的屬性僅限於字串實例，使用者也可以傳遞任意 :class:`str` "
"子類別，因此仍然會建立循環引用。"
