# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Leon H., 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-18 00:16+0000\n"
"PO-Revision-Date: 2023-05-02 17:18+0800\n"
"Last-Translator: Matt Wang <mattwang44@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../c-api/structures.rst:6
msgid "Common Object Structures"
msgstr "通用物件結構"

#: ../../c-api/structures.rst:8
#, fuzzy
msgid ""
"There are a large number of structures which are used in the definition of "
"object types for Python.  This section describes these structures and how "
"they are used."
msgstr ""
"在 Python 的物件型別定義中使用了大量結構。本節介紹這些結構及其使用方法。"

#: ../../c-api/structures.rst:14
#, fuzzy
msgid "Base object types and macros"
msgstr "基礎物件型別和巨集"

#: ../../c-api/structures.rst:16
#, fuzzy
msgid ""
"All Python objects ultimately share a small number of fields at the "
"beginning of the object's representation in memory.  These are represented "
"by the :c:type:`PyObject` and :c:type:`PyVarObject` types, which are "
"defined, in turn, by the expansions of some macros also used, whether "
"directly or indirectly, in the definition of all other Python objects."
msgstr ""
"所有 Python 物件最終在物件在記憶體中表示的開頭共享少量欄位。這些由 :c:type:"
"`PyObject` 和 :c:type:`PyVarObject` 型別表示，這些型別又由一些巨集的擴充定"
"義，這些巨集也直接或間接地用於所有其他 Python 物件。"

#: ../../c-api/structures.rst:25
#, fuzzy
msgid ""
"All object types are extensions of this type.  This is a type which contains "
"the information Python needs to treat a pointer to an object as an object.  "
"In a normal \"release\" build, it contains only the object's reference count "
"and a pointer to the corresponding type object. Nothing is actually declared "
"to be a :c:type:`PyObject`, but every pointer to a Python object can be cast "
"to a :c:expr:`PyObject*`.  Access to the members must be done by using the "
"macros :c:macro:`Py_REFCNT` and :c:macro:`Py_TYPE`."
msgstr ""
"所有物件型別都是這種型別的擴充。這是一種型別，其中包含 Python 將指向物件的指"
"標視為物件所需的資訊。在正常的“發布”構建中，它只包含物件的引用計數和指向相應"
"型別物件的指標。實際上沒有任何東西被聲明為 PyObject，但每個指向 Python 物件的"
"指標都可以轉換為 PyObject*。必須使用巨集 Py_REFCNT 和 Py_TYPE 來訪問成員。"

#: ../../c-api/structures.rst:37
#, fuzzy
msgid ""
"This is an extension of :c:type:`PyObject` that adds the :attr:`ob_size` "
"field.  This is only used for objects that have some notion of *length*. "
"This type does not often appear in the Python/C API. Access to the members "
"must be done by using the macros :c:macro:`Py_REFCNT`, :c:macro:`Py_TYPE`, "
"and :c:macro:`Py_SIZE`."
msgstr ""
"這是 :c:type:`PyObject` 的擴充，新增了 :attr:`ob_size` 欄位。這僅用於具有 "
"*length* 概念的物件。這種型別並不經常出現在 Python/C API 中。必須使用巨集 "
"Py_REFCNT、Py_TYPE 和 Py_SIZE 巨集來訪問成員。"

#: ../../c-api/structures.rst:46
#, fuzzy
msgid ""
"This is a macro used when declaring new types which represent objects "
"without a varying length.  The PyObject_HEAD macro expands to::"
msgstr ""
"這是一個巨集，用於聲明表示沒有可變長度的物件的新型別。 PyObject_HEAD 巨集擴充"
"為："

#: ../../c-api/structures.rst:51
#, fuzzy
msgid "See documentation of :c:type:`PyObject` above."
msgstr "請參閱上面的 :c:type:`PyObject` 文檔。"

#: ../../c-api/structures.rst:56
#, fuzzy
msgid ""
"This is a macro used when declaring new types which represent objects with a "
"length that varies from instance to instance. The PyObject_VAR_HEAD macro "
"expands to::"
msgstr ""
"這是在聲明新型別時使用的巨集，新型別表示長度因實例而異的物件。 "
"PyObject_VAR_HEAD 巨集擴充為："

#: ../../c-api/structures.rst:62
msgid "See documentation of :c:type:`PyVarObject` above."
msgstr "請參閱上面的 :c:type:`PyVarObject` 說明文件。"

#: ../../c-api/structures.rst:67
#, fuzzy
msgid ""
"Test if the *x* object is the *y* object, the same as ``x is y`` in Python."
msgstr "測試 *x* 物件是否為 *y* 物件，與 Python 中的“x is y”相同。"

#: ../../c-api/structures.rst:74
#, fuzzy
msgid ""
"Test if an object is the ``None`` singleton, the same as ``x is None`` in "
"Python."
msgstr "測試一個物件是否是 ``None`` 單例，與 Python 中的 ``x is None`` 相同。"

#: ../../c-api/structures.rst:82
#, fuzzy
msgid ""
"Test if an object is the ``True`` singleton, the same as ``x is True`` in "
"Python."
msgstr "測試物件是否為 ``True`` 單例，與 Python 中的 ``x is True`` 相同。"

#: ../../c-api/structures.rst:90
#, fuzzy
msgid ""
"Test if an object is the ``False`` singleton, the same as ``x is False`` in "
"Python."
msgstr ""
"測試一個物件是否為 ``False`` 單例，與 Python 中的 ``x is False`` 相同。"

#: ../../c-api/structures.rst:98
#, fuzzy
msgid "Get the type of the Python object *o*."
msgstr "獲取 Python 物件 *o* 的型別。"

#: ../../c-api/structures.rst:100
#, fuzzy
msgid "Return a :term:`borrowed reference`."
msgstr "回傳一個 :term:`借用參照`。"

#: ../../c-api/structures.rst:102
#, fuzzy
msgid "Use the :c:func:`Py_SET_TYPE` function to set an object type."
msgstr "使用 :c:func:`Py_SET_TYPE` 函式設定物件型別。"

#: ../../c-api/structures.rst:104
#, fuzzy
msgid ""
":c:func:`Py_TYPE()` is changed to an inline static function. The parameter "
"type is no longer :c:expr:`const PyObject*`."
msgstr ""
":c:func:`Py_TYPE()` 更改為內聯靜態函式。參數型別不再是 :c:expr:`const "
"PyObject*`。"

#: ../../c-api/structures.rst:111
#, fuzzy
msgid ""
"Return non-zero if the object *o* type is *type*. Return zero otherwise. "
"Equivalent to: ``Py_TYPE(o) == type``."
msgstr ""
"如果物件 *o* 型別為 *type*，則回傳非零值。否則回傳零。等同於：``Py_TYPE(o) "
"== type``。"

#: ../../c-api/structures.rst:119
#, fuzzy
msgid "Set the object *o* type to *type*."
msgstr "將物件 *o* 型別設定為 *type*。"

#: ../../c-api/structures.rst:126
#, fuzzy
msgid "Get the reference count of the Python object *o*."
msgstr "獲取 Python 物件 *o* 的引用計數。"

#: ../../c-api/structures.rst:128
#, fuzzy
msgid ""
"Use the :c:func:`Py_SET_REFCNT()` function to set an object reference count."
msgstr "使用 :c:func:`Py_SET_REFCNT()` 函式設定物件引用計數。"

#: ../../c-api/structures.rst:130
#, fuzzy
msgid "The parameter type is no longer :c:expr:`const PyObject*`."
msgstr "參數型別不再是 :c:expr:`const PyObject*`。"

#: ../../c-api/structures.rst:133
#, fuzzy
msgid ":c:func:`Py_REFCNT()` is changed to the inline static function."
msgstr ":c:func:`Py_REFCNT()` 更改為內聯靜態函式。"

#: ../../c-api/structures.rst:139
#, fuzzy
msgid "Set the object *o* reference counter to *refcnt*."
msgstr "將物件 *o* 引用計數器設定為 *refcnt*。"

#: ../../c-api/structures.rst:146
#, fuzzy
msgid "Get the size of the Python object *o*."
msgstr "獲取 Python 物件 *o* 的大小。"

#: ../../c-api/structures.rst:148
#, fuzzy
msgid "Use the :c:func:`Py_SET_SIZE` function to set an object size."
msgstr "使用 :c:func:`Py_SET_SIZE` 函式設定物件大小。"

#: ../../c-api/structures.rst:150
#, fuzzy
msgid ""
":c:func:`Py_SIZE()` is changed to an inline static function. The parameter "
"type is no longer :c:expr:`const PyVarObject*`."
msgstr ""
":c:func:`Py_SIZE()` 更改為內聯靜態函式。參數型別不再是 :c:expr:`const "
"PyVarObject*`。"

#: ../../c-api/structures.rst:157
#, fuzzy
msgid "Set the object *o* size to *size*."
msgstr "將物件 *o* 大小設定為 *size*。"

#: ../../c-api/structures.rst:164
#, fuzzy
msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyObject` type.  This macro expands to::"
msgstr ""
"這是一個擴充為新 :c:type:`PyObject` 型別的初始化值的巨集。此巨集擴充為：："

#: ../../c-api/structures.rst:173
#, fuzzy
msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyVarObject` type, including the :attr:`ob_size` field. This macro expands "
"to::"
msgstr ""
"這是一個擴充為新 PyVarObject 型別的初始化值的巨集，包括 ob_size 欄位。此巨集"
"擴充為：："

#: ../../c-api/structures.rst:182
#, fuzzy
msgid "Implementing functions and methods"
msgstr "實作函式和方法"

#: ../../c-api/structures.rst:186
#, fuzzy
msgid ""
"Type of the functions used to implement most Python callables in C. "
"Functions of this type take two :c:expr:`PyObject*` parameters and return "
"one such value.  If the return value is ``NULL``, an exception shall have "
"been set.  If not ``NULL``, the return value is interpreted as the return "
"value of the function as exposed in Python.  The function must return a new "
"reference."
msgstr ""
"用於在 C 中實作大多數 Python 可呼叫函式的函式型別。這種型別的函式採用兩個 :c:"
"expr:`PyObject*` 參數並回傳一個這樣的值。如果回傳值為 ``NULL`` ，則應設定例"
"外。如果不是 ``NULL`` ，則回傳值被解釋為函式在 Python 中公開的回傳值。該函式"
"必須回傳一個新的引用。"

#: ../../c-api/structures.rst:193
#, fuzzy
msgid "The function signature is::"
msgstr "函式簽名是："

#: ../../c-api/structures.rst:200
#, fuzzy
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :const:`METH_VARARGS | METH_KEYWORDS`. The function signature is::"
msgstr ""
"用於在帶有簽名的 C 中實作 Python 可呼叫函式的型別 :const:`METH_VARARGS | "
"METH_KEYWORDS`。函式簽名是："

#: ../../c-api/structures.rst:211
#, fuzzy
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :const:`METH_FASTCALL`. The function signature is::"
msgstr ""
"用於在 C 中實作 Python 可呼叫函式的型別，帶有簽名 :const:`METH_FASTCALL`。函"
"式簽名是："

#: ../../c-api/structures.rst:221
#, fuzzy
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :const:`METH_FASTCALL | METH_KEYWORDS`. The function signature is::"
msgstr ""
"用於在帶有簽名的 C 中實作 Python 可呼叫函式的型別 :const:`METH_FASTCALL | "
"METH_KEYWORDS`。函式簽名是："

#: ../../c-api/structures.rst:232
#, fuzzy
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :const:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`. The function "
"signature is::"
msgstr ""
"用於在帶有簽名的 C 中實作 Python 可呼叫函式的型別 :const:`METH_METHOD | "
"METH_FASTCALL | METH_KEYWORDS`。函式簽名是："

#: ../../c-api/structures.rst:247
#, fuzzy
msgid ""
"Structure used to describe a method of an extension type.  This structure "
"has four fields:"
msgstr "用於描述擴充型別方法的結構。這個結構有四個欄位："

#: ../../c-api/structures.rst:252
#, fuzzy
msgid "name of the method"
msgstr "方法名稱"

#: ../../c-api/structures.rst:256
#, fuzzy
msgid "pointer to the C implementation"
msgstr "指向 C 實作的指標"

#: ../../c-api/structures.rst:260
#, fuzzy
msgid "flags bits indicating how the call should be constructed"
msgstr "指示應如何構造呼叫的旗標位"

#: ../../c-api/structures.rst:264 ../../c-api/structures.rst:426
#, fuzzy
msgid "points to the contents of the docstring"
msgstr "指向文檔字串的內容"

#: ../../c-api/structures.rst:266
#, fuzzy
msgid ""
"The :c:member:`ml_meth` is a C function pointer.  The functions may be of "
"different types, but they always return :c:expr:`PyObject*`.  If the "
"function is not of the :c:type:`PyCFunction`, the compiler will require a "
"cast in the method table. Even though :c:type:`PyCFunction` defines the "
"first parameter as :c:expr:`PyObject*`, it is common that the method "
"implementation uses the specific C type of the *self* object."
msgstr ""
":c:member:`ml_meth` 是一個 C 函式指標。這些函式可能屬於不同型別，但它們總是回"
"傳 :c:expr:`PyObject*`。如果函式不是 :c:type:`PyCFunction`，編譯器將要求在方"
"法表中進行強制轉換。儘管 :c:type:`PyCFunction` 將第一個參數定義為 :c:expr:"
"`PyObject*`，方法實作通常使用 *self* 物件的特定 C 型別。"

#: ../../c-api/structures.rst:273
#, fuzzy
msgid ""
"The :c:member:`ml_flags` field is a bitfield which can include the following "
"flags. The individual flags indicate either a calling convention or a "
"binding convention."
msgstr ""
":c:member:`ml_flags` 欄位是一個位欄位，可以包含以下旗標。各個旗標指示呼叫約定"
"或綁定約定。"

#: ../../c-api/structures.rst:277
#, fuzzy
msgid "There are these calling conventions:"
msgstr "有這些呼叫約定："

#: ../../c-api/structures.rst:281
#, fuzzy
msgid ""
"This is the typical calling convention, where the methods have the type :c:"
"type:`PyCFunction`. The function expects two :c:expr:`PyObject*` values. The "
"first one is the *self* object for methods; for module functions, it is the "
"module object.  The second parameter (often called *args*) is a tuple object "
"representing all arguments. This parameter is typically processed using :c:"
"func:`PyArg_ParseTuple` or :c:func:`PyArg_UnpackTuple`."
msgstr ""
"這是典型的呼叫約定，其中方法的型別為 :c:type:`PyCFunction`。該函式需要兩個 :"
"c:expr:`PyObject*` 值。第一個是方法的 *self* 物件；對於模組函式，它是模組物"
"件。第二個參數（通常稱為 *args*）是一個表示所有參數的元組物件。此參數通常使"
"用 PyArg_ParseTuple 或 PyArg_UnpackTuple 處理。"

#: ../../c-api/structures.rst:291
#, fuzzy
msgid ""
"Methods with these flags must be of type :c:type:`PyCFunctionWithKeywords`. "
"The function expects three parameters: *self*, *args*, *kwargs* where "
"*kwargs* is a dictionary of all the keyword arguments or possibly ``NULL`` "
"if there are no keyword arguments.  The parameters are typically processed "
"using :c:func:`PyArg_ParseTupleAndKeywords`."
msgstr ""
"帶有這些旗標的方法必須是 :c:type:`PyCFunctionWithKeywords` 型別。該函式需要三"
"個參數：*self*、*args*、*kwargs*，其中 *kwargs* 是所有關鍵字參數的字典，如果"
"沒有關鍵字參數，則可能為 ``NULL`` 。這些參數通常使用 "
"PyArg_ParseTupleAndKeywords 進行處理。"

#: ../../c-api/structures.rst:300
#, fuzzy
msgid ""
"Fast calling convention supporting only positional arguments. The methods "
"have the type :c:type:`_PyCFunctionFast`. The first parameter is *self*, the "
"second parameter is a C array of :c:expr:`PyObject*` values indicating the "
"arguments and the third parameter is the number of arguments (the length of "
"the array)."
msgstr ""
"僅支援位置參數的快速呼叫約定。這些方法的型別為 :c:type:`_PyCFunctionFast`。第"
"一個參數是 *self*，第二個參數是 :c:expr:`PyObject*` 值的 C 數組，指示參數，第"
"三個參數是參數的數量（數組的長度）。"

#: ../../c-api/structures.rst:310
#, fuzzy
msgid "``METH_FASTCALL`` is now part of the stable ABI."
msgstr "``METH_FASTCALL`` 現在是穩定 ABI 的一部分。"

#: ../../c-api/structures.rst:315
#, fuzzy
msgid ""
"Extension of :const:`METH_FASTCALL` supporting also keyword arguments, with "
"methods of type :c:type:`_PyCFunctionFastWithKeywords`. Keyword arguments "
"are passed the same way as in the :ref:`vectorcall protocol <vectorcall>`: "
"there is an additional fourth :c:expr:`PyObject*` parameter which is a tuple "
"representing the names of the keyword arguments (which are guaranteed to be "
"strings) or possibly ``NULL`` if there are no keywords.  The values of the "
"keyword arguments are stored in the *args* array, after the positional "
"arguments."
msgstr ""
":const:`METH_FASTCALL` 的擴充還支援關鍵字參數，方法型別為 :c:type:"
"`_PyCFunctionFastWithKeywords`。關鍵字參數的傳遞方式與 :ref:`vectorcall 協定 "
"<vectorcall>` 中的傳遞方式相同：還有一個額外的第四個:c:expr:`PyObject*` 參"
"數，它是一個表示關鍵字參數名稱的元組（它們是保證是字串）或者如果沒有關鍵字則"
"可能是 ``NULL``。關鍵字參數的值儲存在 *args* 數組中，在位置參數之後。"

#: ../../c-api/structures.rst:330
#, fuzzy
msgid ""
"Extension of :const:`METH_FASTCALL | METH_KEYWORDS` supporting the *defining "
"class*, that is, the class that contains the method in question. The "
"defining class might be a superclass of ``Py_TYPE(self)``."
msgstr ""
"擴充 :const:`METH_FASTCALL | METH_KEYWORDS` 支援*定義類*，即包含相關方法的"
"類。定義類可能是 Py_TYPE(self) 的超類。"

#: ../../c-api/structures.rst:334
#, fuzzy
msgid ""
"The method needs to be of type :c:type:`PyCMethod`, the same as for "
"``METH_FASTCALL | METH_KEYWORDS`` with ``defining_class`` argument added "
"after ``self``."
msgstr ""
"該方法需要是 :c:type:`PyCMethod` 型別，與 ``METH_FASTCALL | 相同"
"METH_KEYWORDS`` 在``self`` 之後新增了``defining_class`` 參數。"

#: ../../c-api/structures.rst:343
#, fuzzy
msgid ""
"Methods without parameters don't need to check whether arguments are given "
"if they are listed with the :const:`METH_NOARGS` flag.  They need to be of "
"type :c:type:`PyCFunction`.  The first parameter is typically named *self* "
"and will hold a reference to the module or object instance.  In all cases "
"the second parameter will be ``NULL``."
msgstr ""
"沒有參數的方法如果使用 METH_NOARGS 旗標列出，則不需要檢查是否給出了參數。它們"
"需要是 :c:type:`PyCFunction` 型別。第一個參數通常命名為 *self* 並將包含對模組"
"或物件實例的引用。在所有情況下，第二個參數將為 ``NULL`` 。"

#: ../../c-api/structures.rst:349
#, fuzzy
msgid ""
"The function must have 2 parameters. Since the second parameter is unused, :"
"c:macro:`Py_UNUSED` can be used to prevent a compiler warning."
msgstr ""
"該函式必須有 2 個參數。由於第二個參數未使用，:c:macro:`Py_UNUSED` 可用於防止"
"編譯器警告。"

#: ../../c-api/structures.rst:355
#, fuzzy
msgid ""
"Methods with a single object argument can be listed with the :const:`METH_O` "
"flag, instead of invoking :c:func:`PyArg_ParseTuple` with a ``\"O\"`` "
"argument. They have the type :c:type:`PyCFunction`, with the *self* "
"parameter, and a :c:expr:`PyObject*` parameter representing the single "
"argument."
msgstr ""
"可以使用 :const:`METH_O` 旗標列出具有單個物件參數的方法，而不是使用 "
"``\"O\"`` 參數呼叫 :c:func:`PyArg_ParseTuple`。它們具有 :c:type:"
"`PyCFunction` 型別，帶有 *self* 參數和一個 :c:expr:`PyObject*` 參數表示單個參"
"數。"

#: ../../c-api/structures.rst:361
#, fuzzy
msgid ""
"These two constants are not used to indicate the calling convention but the "
"binding when use with methods of classes.  These may not be used for "
"functions defined for modules.  At most one of these flags may be set for "
"any given method."
msgstr ""
"這兩個常數不是用於指示呼叫約定，而是用於指示類方法時的綁定。這些不能用於為模"
"組定義的功能。最多可以為任何給定方法設定這些旗標中的一個。"

#: ../../c-api/structures.rst:371
#, fuzzy
msgid ""
"The method will be passed the type object as the first parameter rather than "
"an instance of the type.  This is used to create *class methods*, similar to "
"what is created when using the :func:`classmethod` built-in function."
msgstr ""
"該方法將型別物件作為第一個參數而不是型別的實例傳遞。這用於建立*類方法*，類似"
"於使用 :func:`classmethod` 內建函式時建立的方法。"

#: ../../c-api/structures.rst:381
#, fuzzy
msgid ""
"The method will be passed ``NULL`` as the first parameter rather than an "
"instance of the type.  This is used to create *static methods*, similar to "
"what is created when using the :func:`staticmethod` built-in function."
msgstr ""
"該方法將傳遞 ``NULL`` 作為第一個參數而不是型別的實例。這用於建立*靜態方法*，"
"類似於使用 :func:`staticmethod` 內建函式時建立的方法。"

#: ../../c-api/structures.rst:385
#, fuzzy
msgid ""
"One other constant controls whether a method is loaded in place of another "
"definition with the same method name."
msgstr "另一個常數控制是否加載一個方法來代替具有相同方法名稱的另一個定義。"

#: ../../c-api/structures.rst:391
#, fuzzy
msgid ""
"The method will be loaded in place of existing definitions.  Without "
"*METH_COEXIST*, the default is to skip repeated definitions.  Since slot "
"wrappers are loaded before the method table, the existence of a "
"*sq_contains* slot, for example, would generate a wrapped method named :meth:"
"`__contains__` and preclude the loading of a corresponding PyCFunction with "
"the same name.  With the flag defined, the PyCFunction will be loaded in "
"place of the wrapper object and will co-exist with the slot.  This is "
"helpful because calls to PyCFunctions are optimized more than wrapper object "
"calls."
msgstr ""
"該方法將被加載以代替現有定義。沒有*METH_COEXIST*，預設是跳過重複的定義。由於"
"插槽包裝器是在方法表之前加載的，因此 *sq_contains* 插槽的存在將生成一個名為 :"
"meth:`__contains__` 的包裝方法，並阻止加載具有相同名稱的相應 PyCFunction。定"
"義旗標後，PyCFunction 將代替包裝器物件加載，並將與插槽共存。這很有用，因為對 "
"PyCFunctions 的呼叫比包裝器物件呼叫更最佳化。"

#: ../../c-api/structures.rst:403
#, fuzzy
msgid "Accessing attributes of extension types"
msgstr "訪問擴充型別的屬性"

#: ../../c-api/structures.rst:407
#, fuzzy
msgid ""
"Structure which describes an attribute of a type which corresponds to a C "
"struct member.  Its fields are:"
msgstr "描述對應於 C 結構成員的型別的屬性的結構。它的領域是："

#: ../../c-api/structures.rst:411 ../../c-api/structures.rst:507
#, fuzzy
msgid "Field"
msgstr "場地"

#: ../../c-api/structures.rst:411 ../../c-api/structures.rst:507
msgid "C Type"
msgstr "C Type"

#: ../../c-api/structures.rst:411 ../../c-api/structures.rst:507
#, fuzzy
msgid "Meaning"
msgstr "意義"

#: ../../c-api/structures.rst:413
msgid ":attr:`name`"
msgstr ":attr:`name`"

#: ../../c-api/structures.rst:413 ../../c-api/structures.rst:426
#: ../../c-api/structures.rst:442 ../../c-api/structures.rst:509
#: ../../c-api/structures.rst:517
msgid "const char \\*"
msgstr "const char \\*"

#: ../../c-api/structures.rst:413
#, fuzzy
msgid "name of the member"
msgstr "會員姓名"

#: ../../c-api/structures.rst:415
msgid ":attr:`!type`"
msgstr ":attr:`!type`"

#: ../../c-api/structures.rst:415 ../../c-api/structures.rst:422
#: ../../c-api/structures.rst:438
msgid "int"
msgstr "int"

#: ../../c-api/structures.rst:415
#, fuzzy
msgid "the type of the member in the C struct"
msgstr "C 結構中成員的型別"

#: ../../c-api/structures.rst:418
msgid ":attr:`offset`"
msgstr ":attr:`offset`"

#: ../../c-api/structures.rst:418 ../../c-api/structures.rst:454
msgid "Py_ssize_t"
msgstr "Py_ssize_t"

#: ../../c-api/structures.rst:418
#, fuzzy
msgid ""
"the offset in bytes that the member is located on the type's object struct"
msgstr "成員在型別的物件結構上的偏移量（以位元組為單位）"

#: ../../c-api/structures.rst:422
msgid ":attr:`flags`"
msgstr ":attr:`flags`"

#: ../../c-api/structures.rst:422
#, fuzzy
msgid "flag bits indicating if the field should be read-only or writable"
msgstr "指示該欄位是只讀還是可寫的旗標位"

#: ../../c-api/structures.rst:426
msgid ":attr:`doc`"
msgstr ":attr:`doc`"

#: ../../c-api/structures.rst:430
#, fuzzy
msgid ""
":attr:`!type` can be one of many ``T_`` macros corresponding to various C "
"types.  When the member is accessed in Python, it will be converted to the "
"equivalent Python type."
msgstr ""
":attr:`!type` 可以是對應於各種 C 型別的許多 ``T_`` 巨集之一。當在 Python 中訪"
"問該成員時，它將被轉換為等效的 Python 型別。"

#: ../../c-api/structures.rst:435
msgid "Macro name"
msgstr "巨集名稱"

#: ../../c-api/structures.rst:435
#, fuzzy
msgid "C type"
msgstr "C 型別"

#: ../../c-api/structures.rst:437
msgid "T_SHORT"
msgstr "T_SHORT"

#: ../../c-api/structures.rst:437
#, fuzzy
msgid "short"
msgstr "short"

#: ../../c-api/structures.rst:438
msgid "T_INT"
msgstr "T_INT"

#: ../../c-api/structures.rst:439
msgid "T_LONG"
msgstr "T_LONG"

#: ../../c-api/structures.rst:439
msgid "long"
msgstr "long"

#: ../../c-api/structures.rst:440
msgid "T_FLOAT"
msgstr "T_FLOAT"

#: ../../c-api/structures.rst:440
msgid "float"
msgstr "float"

#: ../../c-api/structures.rst:441
msgid "T_DOUBLE"
msgstr "T_DOUBLE"

#: ../../c-api/structures.rst:441
msgid "double"
msgstr "double"

#: ../../c-api/structures.rst:442
msgid "T_STRING"
msgstr "T_STRING"

#: ../../c-api/structures.rst:443
msgid "T_OBJECT"
msgstr "T_OBJECT"

#: ../../c-api/structures.rst:443 ../../c-api/structures.rst:444
msgid "PyObject \\*"
msgstr "PyObject \\*"

#: ../../c-api/structures.rst:444
msgid "T_OBJECT_EX"
msgstr "T_OBJECT_EX"

#: ../../c-api/structures.rst:445
msgid "T_CHAR"
msgstr "T_CHAR"

#: ../../c-api/structures.rst:445 ../../c-api/structures.rst:446
#: ../../c-api/structures.rst:451
msgid "char"
msgstr "char"

#: ../../c-api/structures.rst:446
msgid "T_BYTE"
msgstr "T_BYTE"

#: ../../c-api/structures.rst:447
msgid "T_UBYTE"
msgstr "T_UBYTE"

#: ../../c-api/structures.rst:447
msgid "unsigned char"
msgstr "unsigned char"

#: ../../c-api/structures.rst:448
msgid "T_UINT"
msgstr "T_UINT"

#: ../../c-api/structures.rst:448
msgid "unsigned int"
msgstr "unsigned int"

#: ../../c-api/structures.rst:449
msgid "T_USHORT"
msgstr "T_USHORT"

#: ../../c-api/structures.rst:449
msgid "unsigned short"
msgstr "unsigned short"

#: ../../c-api/structures.rst:450
msgid "T_ULONG"
msgstr "T_ULONG"

#: ../../c-api/structures.rst:450
msgid "unsigned long"
msgstr "unsigned long"

#: ../../c-api/structures.rst:451
msgid "T_BOOL"
msgstr "T_BOOL"

#: ../../c-api/structures.rst:452
msgid "T_LONGLONG"
msgstr "T_LONGLONG"

#: ../../c-api/structures.rst:452
msgid "long long"
msgstr "long long"

#: ../../c-api/structures.rst:453
msgid "T_ULONGLONG"
msgstr "T_ULONGLONG"

#: ../../c-api/structures.rst:453
msgid "unsigned long long"
msgstr "unsigned long long"

#: ../../c-api/structures.rst:454
msgid "T_PYSSIZET"
msgstr "T_PYSSIZET"

#: ../../c-api/structures.rst:457
#, fuzzy
msgid ""
":c:macro:`T_OBJECT` and :c:macro:`T_OBJECT_EX` differ in that :c:macro:"
"`T_OBJECT` returns ``None`` if the member is ``NULL`` and :c:macro:"
"`T_OBJECT_EX` raises an :exc:`AttributeError`.  Try to use :c:macro:"
"`T_OBJECT_EX` over :c:macro:`T_OBJECT` because :c:macro:`T_OBJECT_EX` "
"handles use of the :keyword:`del` statement on that attribute more correctly "
"than :c:macro:`T_OBJECT`."
msgstr ""
":c:macro:`T_OBJECT` 和 :c:macro:`T_OBJECT_EX` 的不同之處在於 :c:macro:"
"`T_OBJECT` 如果成員為 ``NULL`` 則回傳 ``None`` 和 :c:macro:` T_OBJECT_EX` 引"
"發 :exc:`AttributeError`。嘗試使用 :c:macro:`T_OBJECT_EX` 而不是 :c:macro:"
"`T_OBJECT` 因為 :c:macro:`T_OBJECT_EX` 比 :c:macro 更正確地處理對該屬性的 :"
"keyword:`del` 語句的使用：`T_OBJECT`。"

#: ../../c-api/structures.rst:464
#, fuzzy
msgid ""
":attr:`flags` can be ``0`` for write and read access or :c:macro:`READONLY` "
"for read-only access.  Using :c:macro:`T_STRING` for :attr:`type` implies :c:"
"macro:`READONLY`.  :c:macro:`T_STRING` data is interpreted as UTF-8. Only :c:"
"macro:`T_OBJECT` and :c:macro:`T_OBJECT_EX` members can be deleted.  (They "
"are set to ``NULL``)."
msgstr ""
":attr:`flags` 可以是 ``0`` 用於寫入和讀取訪問，或者 :c:macro:`READONLY` 用於"
"只讀訪問。將:c:macro:`T_STRING` 用於 :attr:`type` 意味著:c:macro:"
"`READONLY`。 :c:macro:`T_STRING` 資料被解釋為 UTF-8。只能刪除:c:macro:"
"`T_OBJECT` 和:c:macro:`T_OBJECT_EX` 成員。 （它們被設定為 ``NULL`` ）。"

#: ../../c-api/structures.rst:472
#, fuzzy
msgid ""
"Heap allocated types (created using :c:func:`PyType_FromSpec` or similar), "
"``PyMemberDef`` may contain definitions for the special members "
"``__dictoffset__``, ``__weaklistoffset__`` and ``__vectorcalloffset__``, "
"corresponding to :c:member:`~PyTypeObject.tp_dictoffset`, :c:member:"
"`~PyTypeObject.tp_weaklistoffset` and :c:member:`~PyTypeObject."
"tp_vectorcall_offset` in type objects. These must be defined with "
"``T_PYSSIZET`` and ``READONLY``, for example::"
msgstr ""
"堆分配型別（使用 :c:func:`PyType_FromSpec` 或類似的建立），``PyMemberDef`` 可"
"能包含特殊成員``__dictoffset__``、``__weaklistoffset__`` 和"
"``__vectorcalloffset__`` 的定義，對應:c:member:`~PyTypeObject."
"tp_dictoffset`, :c:member:`~PyTypeObject.tp_weaklistoffset` 和 :c:member:"
"`~PyTypeObject.tp_vectorcall_offset` 在型別物件中。這些必須用``T_PYSSIZET`` "
"和``READONLY`` 定義，例如："

#: ../../c-api/structures.rst:489
#, fuzzy
msgid ""
"Get an attribute belonging to the object at address *obj_addr*.  The "
"attribute is described by ``PyMemberDef`` *m*.  Returns ``NULL`` on error."
msgstr ""
"獲取屬於地址 *obj_addr* 處物件的屬性。該屬性由 ``PyMemberDef`` *m* 描述。出錯"
"時回傳 ``NULL`` 。"

#: ../../c-api/structures.rst:496
#, fuzzy
msgid ""
"Set an attribute belonging to the object at address *obj_addr* to object "
"*o*. The attribute to set is described by ``PyMemberDef`` *m*.  Returns "
"``0`` if successful and a negative value on failure."
msgstr ""
"將屬於地址 *obj_addr* 處的物件的屬性設定為物件 *o*。要設定的屬性由 "
"``PyMemberDef`` *m* 描述。如果成功則回傳 ``0``，失敗則回傳負值。"

#: ../../c-api/structures.rst:503
#, fuzzy
msgid ""
"Structure to define property-like access for a type. See also description of "
"the :c:member:`PyTypeObject.tp_getset` slot."
msgstr ""
"為型別定義類屬性訪問的結構。另見 :c:member:`PyTypeObject.tp_getset` 槽的描"
"述。"

#: ../../c-api/structures.rst:509
#, fuzzy
msgid "name"
msgstr "名稱"

#: ../../c-api/structures.rst:509
#, fuzzy
msgid "attribute name"
msgstr "屬性名稱"

#: ../../c-api/structures.rst:511
#, fuzzy
msgid "get"
msgstr "得到"

#: ../../c-api/structures.rst:511
#, fuzzy
msgid "getter"
msgstr "吸氣劑"

#: ../../c-api/structures.rst:511
#, fuzzy
msgid "C function to get the attribute"
msgstr "C 函式獲取屬性"

#: ../../c-api/structures.rst:513
#, fuzzy
msgid "set"
msgstr "設定"

#: ../../c-api/structures.rst:513
#, fuzzy
msgid "setter"
msgstr "二傳手"

#: ../../c-api/structures.rst:513
#, fuzzy
msgid ""
"optional C function to set or delete the attribute, if omitted the attribute "
"is readonly"
msgstr "可選的 C 函式來設定或刪除屬性，如果省略該屬性是只讀的"

#: ../../c-api/structures.rst:517
#, fuzzy
msgid "doc"
msgstr "文件"

#: ../../c-api/structures.rst:517
#, fuzzy
msgid "optional docstring"
msgstr "可選文檔字串"

#: ../../c-api/structures.rst:519
#, fuzzy
msgid "closure"
msgstr "關閉"

#: ../../c-api/structures.rst:519
msgid "void \\*"
msgstr "void \\*"

#: ../../c-api/structures.rst:519
#, fuzzy
msgid ""
"optional function pointer, providing additional data for getter and setter"
msgstr "可選的函式指標，為 getter 和 setter 提供額外的資料"

#: ../../c-api/structures.rst:524
#, fuzzy
msgid ""
"The ``get`` function takes one :c:expr:`PyObject*` parameter (the instance) "
"and a function pointer (the associated ``closure``)::"
msgstr ""
"``get`` 函式接受一個 :c:expr:`PyObject*` 參數（實例）和一個函式指標（關聯的 "
"``closure``）::"

#: ../../c-api/structures.rst:529
#, fuzzy
msgid ""
"It should return a new reference on success or ``NULL`` with a set exception "
"on failure."
msgstr ""
"它應該在成功時回傳一個新的引用，或者在失敗時回傳一個設定例外的 ``NULL`` 。"

#: ../../c-api/structures.rst:532
#, fuzzy
msgid ""
"``set`` functions take two :c:expr:`PyObject*` parameters (the instance and "
"the value to be set) and a function pointer (the associated ``closure``)::"
msgstr ""
"``set`` 函式接受兩個:c:expr:`PyObject*` 參數（實例和要設定的值）和一個函式指"
"標（關聯的``closure``）::"

#: ../../c-api/structures.rst:537
#, fuzzy
msgid ""
"In case the attribute should be deleted the second parameter is ``NULL``. "
"Should return ``0`` on success or ``-1`` with a set exception on failure."
msgstr ""
"如果屬性應該被刪除，第二個參數是 ``NULL`` 。成功時應回傳 ``0``，失敗時應回傳 "
"``-1``並設定例外。"
