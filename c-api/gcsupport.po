# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-10-29 00:08+0000\n"
"PO-Revision-Date: 2018-05-23 14:31+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../c-api/gcsupport.rst:6
#, fuzzy
msgid "Supporting Cyclic Garbage Collection"
msgstr "支援循環垃圾回收"

#: ../../c-api/gcsupport.rst:8
#, fuzzy
msgid ""
"Python's support for detecting and collecting garbage which involves "
"circular references requires support from object types which are "
"\"containers\" for other objects which may also be containers.  Types which "
"do not store references to other objects, or which only store references to "
"atomic types (such as numbers or strings), do not need to provide any "
"explicit support for garbage collection."
msgstr ""
"Python 對檢測和收集涉及循環引用的垃圾的支援需要來自對像型別的支援，這些對像型"
"別是其他物件的“容器”，這些對像也可能是容器。不儲存對其他物件的引用或僅儲存對"
"原子型別（例如數字或字串）的引用的型別不需要為垃圾收集提供任何顯式支援。"

#: ../../c-api/gcsupport.rst:15
#, fuzzy
msgid ""
"To create a container type, the :c:member:`~PyTypeObject.tp_flags` field of "
"the type object must include the :const:`Py_TPFLAGS_HAVE_GC` and provide an "
"implementation of the :c:member:`~PyTypeObject.tp_traverse` handler.  If "
"instances of the type are mutable, a :c:member:`~PyTypeObject.tp_clear` "
"implementation must also be provided."
msgstr ""
"要建立容器型別，型別物件的:c:member:`~PyTypeObject.tp_flags` 欄位必須包含 :"
"const:`Py_TPFLAGS_HAVE_GC` 並提供:c:member:`~PyTypeObject.tp_traverse` 處理程"
"式的實作.如果該型別的實例是可變的，則還必須提供 :c:member:`~PyTypeObject."
"tp_clear` 實作。"

#: ../../c-api/gcsupport.rst:24
#, fuzzy
msgid ""
"Objects with a type with this flag set must conform with the rules "
"documented here.  For convenience these objects will be referred to as "
"container objects."
msgstr ""
"具有此旗標集的型別的物件必須符合此處記錄的規則。為了方便起見，這些物件將被稱"
"為容器物件。"

#: ../../c-api/gcsupport.rst:28
#, fuzzy
msgid "Constructors for container types must conform to two rules:"
msgstr "容器型別的構造函式必須符合兩個規則："

#: ../../c-api/gcsupport.rst:30
#, fuzzy
msgid ""
"The memory for the object must be allocated using :c:func:`PyObject_GC_New` "
"or :c:func:`PyObject_GC_NewVar`."
msgstr "物件的記憶體必須使用 PyObject_GC_New 或 PyObject_GC_NewVar 分配。"

#: ../../c-api/gcsupport.rst:33
#, fuzzy
msgid ""
"Once all the fields which may contain references to other containers are "
"initialized, it must call :c:func:`PyObject_GC_Track`."
msgstr ""
"一旦所有可能包含對其他容器的引用的欄位都被初始化，它必須呼叫:c:func:"
"`PyObject_GC_Track`。"

#: ../../c-api/gcsupport.rst:36
#, fuzzy
msgid ""
"Similarly, the deallocator for the object must conform to a similar pair of "
"rules:"
msgstr "同樣，物件的釋放器必須符合一對相似的規則："

#: ../../c-api/gcsupport.rst:39
#, fuzzy
msgid ""
"Before fields which refer to other containers are invalidated, :c:func:"
"`PyObject_GC_UnTrack` must be called."
msgstr ""
"在引用其他容器的欄位失效之前，:c:func:`PyObject_GC_UnTrack` 必須被呼叫。"

#: ../../c-api/gcsupport.rst:42
#, fuzzy
msgid ""
"The object's memory must be deallocated using :c:func:`PyObject_GC_Del`."
msgstr "必須使用 :c:func:`PyObject_GC_Del` 釋放物件的記憶體。"

#: ../../c-api/gcsupport.rst:45
#, fuzzy
msgid ""
"If a type adds the Py_TPFLAGS_HAVE_GC, then it *must* implement at least a :"
"c:member:`~PyTypeObject.tp_traverse` handler or explicitly use one from its "
"subclass or subclasses."
msgstr ""
"如果一個型別新增了 Py_TPFLAGS_HAVE_GC，那麼它*必須*至少實作一個 :c:member:"
"`~PyTypeObject.tp_traverse` 處理程式或顯式地使用其子類別中的一個。"

#: ../../c-api/gcsupport.rst:49
#, fuzzy
msgid ""
"When calling :c:func:`PyType_Ready` or some of the APIs that indirectly call "
"it like :c:func:`PyType_FromSpecWithBases` or :c:func:`PyType_FromSpec` the "
"interpreter will automatically populate the :c:member:`~PyTypeObject."
"tp_flags`, :c:member:`~PyTypeObject.tp_traverse` and :c:member:"
"`~PyTypeObject.tp_clear` fields if the type inherits from a class that "
"implements the garbage collector protocol and the child class does *not* "
"include the :const:`Py_TPFLAGS_HAVE_GC` flag."
msgstr ""
"當呼叫 :c:func:`PyType_Ready` 或一些間接呼叫它的 API 時，如 :c:func:"
"`PyType_FromSpecWithBases` 或 :c:func:`PyType_FromSpec` 直譯器將自動填充 :c:"
"member:`~ PyTypeObject.tp_flags`, :c:member:`~PyTypeObject.tp_traverse` 和 :"
"c:member:`~PyTypeObject.tp_clear` 欄位如果型別繼承自實作垃圾收集器協定的類並"
"且子類別*不*包括 :const:`Py_TPFLAGS_HAVE_GC` 旗標。"

#: ../../c-api/gcsupport.rst:59
#, fuzzy
msgid ""
"Analogous to :c:func:`PyObject_New` but for container objects with the :"
"const:`Py_TPFLAGS_HAVE_GC` flag set."
msgstr ""
"類似於 :c:func:`PyObject_New` 但對於設定了 :const:`Py_TPFLAGS_HAVE_GC` 旗標的"
"容器物件。"

#: ../../c-api/gcsupport.rst:65
#, fuzzy
msgid ""
"Analogous to :c:func:`PyObject_NewVar` but for container objects with the :"
"const:`Py_TPFLAGS_HAVE_GC` flag set."
msgstr ""
"類似於 :c:func:`PyObject_NewVar` 但對於設定了 :const:`Py_TPFLAGS_HAVE_GC` 旗"
"標的容器物件。"

#: ../../c-api/gcsupport.rst:71
#, fuzzy
msgid ""
"Resize an object allocated by :c:func:`PyObject_NewVar`.  Returns the "
"resized object or ``NULL`` on failure.  *op* must not be tracked by the "
"collector yet."
msgstr ""
"調整由 :c:func:`PyObject_NewVar` 分配的物件的大小。失敗時回傳調整大小的對像"
"或 ``NULL`` 。 *op* 還不能被收集器跟踪。"

#: ../../c-api/gcsupport.rst:77
#, fuzzy
msgid ""
"Adds the object *op* to the set of container objects tracked by the "
"collector.  The collector can run at unexpected times so objects must be "
"valid while being tracked.  This should be called once all the fields "
"followed by the :c:member:`~PyTypeObject.tp_traverse` handler become valid, "
"usually near the end of the constructor."
msgstr ""
"將物件 *op* 新增到收集器跟踪的容器物件集中。收集器可以在意外時間運行，因此對"
"像在被跟踪時必須有效。一旦 :c:member:`~PyTypeObject.tp_traverse` 處理程式後面"
"的所有欄位都有效，通常在構造函式末尾附近，就應該呼叫它。"

#: ../../c-api/gcsupport.rst:86
#, fuzzy
msgid ""
"Returns non-zero if the object implements the garbage collector protocol, "
"otherwise returns 0."
msgstr "如果物件實作了垃圾收集器協定，則回傳非零值，否則回傳 0。"

#: ../../c-api/gcsupport.rst:89
#, fuzzy
msgid ""
"The object cannot be tracked by the garbage collector if this function "
"returns 0."
msgstr "如果此函式回傳 0，則垃圾收集器無法跟踪該物件。"

#: ../../c-api/gcsupport.rst:94
#, fuzzy
msgid ""
"Returns 1 if the object type of *op* implements the GC protocol and *op* is "
"being currently tracked by the garbage collector and 0 otherwise."
msgstr ""
"如果 *op* 的對像型別實作了 GC 協定並且 *op* 當前正被垃圾收集器跟踪，則回傳 "
"1，否則回傳 0。"

#: ../../c-api/gcsupport.rst:97
#, fuzzy
msgid "This is analogous to the Python function :func:`gc.is_tracked`."
msgstr "這類似於 Python 函式 :func:`gc.is_tracked`。"

#: ../../c-api/gcsupport.rst:104
#, fuzzy
msgid ""
"Returns 1 if the object type of *op* implements the GC protocol and *op* has "
"been already finalized by the garbage collector and 0 otherwise."
msgstr ""
"如果 *op* 的對像型別實作了 GC 協定並且 *op* 已經被垃圾收集器完成，則回傳 1，"
"否則回傳 0。"

#: ../../c-api/gcsupport.rst:107
#, fuzzy
msgid "This is analogous to the Python function :func:`gc.is_finalized`."
msgstr "這類似於 Python 函式 :func:`gc.is_finalized`。"

#: ../../c-api/gcsupport.rst:114
#, fuzzy
msgid ""
"Releases memory allocated to an object using :c:func:`PyObject_GC_New` or :c:"
"func:`PyObject_GC_NewVar`."
msgstr "使用 PyObject_GC_New 或 PyObject_GC_NewVar 釋放分配給物件的記憶體。"

#: ../../c-api/gcsupport.rst:120
#, fuzzy
msgid ""
"Remove the object *op* from the set of container objects tracked by the "
"collector.  Note that :c:func:`PyObject_GC_Track` can be called again on "
"this object to add it back to the set of tracked objects.  The deallocator (:"
"c:member:`~PyTypeObject.tp_dealloc` handler) should call this for the object "
"before any of the fields used by the :c:member:`~PyTypeObject.tp_traverse` "
"handler become invalid."
msgstr ""
"從收集器跟踪的容器物件集中刪除物件 *op*。請注意 :c:func:`PyObject_GC_Track` "
"可以在此對像上再次呼叫以將其新增回跟踪物件的集合。解除分配器（:c:member:"
"`~PyTypeObject.tp_dealloc` 處理程式）應該在 :c:member:`~PyTypeObject."
"tp_traverse` 處理程式使用的任何欄位變為無效之前為物件呼叫此方法。"

#: ../../c-api/gcsupport.rst:129
#, fuzzy
msgid ""
"The :c:func:`_PyObject_GC_TRACK` and :c:func:`_PyObject_GC_UNTRACK` macros "
"have been removed from the public C API."
msgstr ""
":c:func:`_PyObject_GC_TRACK` 和 :c:func:`_PyObject_GC_UNTRACK` 巨集已從公開 "
"C API 中刪除。"

#: ../../c-api/gcsupport.rst:132
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` handler accepts a function "
"parameter of this type:"
msgstr ":c:member:`~PyTypeObject.tp_traverse` 處理程式接受這種型別的函式參數："

#: ../../c-api/gcsupport.rst:137
#, fuzzy
msgid ""
"Type of the visitor function passed to the :c:member:`~PyTypeObject."
"tp_traverse` handler. The function should be called with an object to "
"traverse as *object* and the third parameter to the :c:member:`~PyTypeObject."
"tp_traverse` handler as *arg*.  The Python core uses several visitor "
"functions to implement cyclic garbage detection; it's not expected that "
"users will need to write their own visitor functions."
msgstr ""
"傳遞給 :c:member:`~PyTypeObject.tp_traverse` 處理程式的訪問者函式的型別。呼叫"
"該函式時應使用一個對像作為 *object* 遍歷，並將第三個參數作為 *arg* 傳遞給 :c:"
"member:`~PyTypeObject.tp_traverse` 處理程式。 Python核心使用幾個訪問者函式來"
"實作循環垃圾檢測；預計使用者不需要編寫自己的訪問者函式。"

#: ../../c-api/gcsupport.rst:144
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` handler must have the following "
"type:"
msgstr ":c:member:`~PyTypeObject.tp_traverse` 處理程式必須具有以下型別："

#: ../../c-api/gcsupport.rst:149
#, fuzzy
msgid ""
"Traversal function for a container object.  Implementations must call the "
"*visit* function for each object directly contained by *self*, with the "
"parameters to *visit* being the contained object and the *arg* value passed "
"to the handler.  The *visit* function must not be called with a ``NULL`` "
"object argument.  If *visit* returns a non-zero value that value should be "
"returned immediately."
msgstr ""
"容器物件的遍歷函式。實作必須為 *self* 直接包含的每個物件呼叫 *visit* 函式，"
"*visit* 的參數是包含的物件，*arg* 值傳遞給處理程式。不得使用 ``NULL`` 物件參"
"數呼叫 *visit* 函式。如果 *visit* 回傳非零值，則應立即回傳該值。"

#: ../../c-api/gcsupport.rst:156
#, fuzzy
msgid ""
"To simplify writing :c:member:`~PyTypeObject.tp_traverse` handlers, a :c:"
"func:`Py_VISIT` macro is provided.  In order to use this macro, the :c:"
"member:`~PyTypeObject.tp_traverse` implementation must name its arguments "
"exactly *visit* and *arg*:"
msgstr ""
"為了簡化編寫 :c:member:`~PyTypeObject.tp_traverse` 處理程式，提供了一個 :c:"
"func:`Py_VISIT` 巨集。為了使用此巨集，:c:member:`~PyTypeObject.tp_traverse` "
"實作必須準確命名其參數 *visit* 和 *arg*："

#: ../../c-api/gcsupport.rst:163
#, fuzzy
msgid ""
"If *o* is not ``NULL``, call the *visit* callback, with arguments *o* and "
"*arg*.  If *visit* returns a non-zero value, then return it. Using this "
"macro, :c:member:`~PyTypeObject.tp_traverse` handlers look like::"
msgstr ""
"如果 *o* 不是 ``NULL`` ，呼叫 *visit* 回呼，參數 *o* 和 *arg*。如果 *visit* "
"回傳非零值，則回傳它。使用此巨集，:c:member:`~PyTypeObject.tp_traverse` 處理"
"程式如下所示："

#: ../../c-api/gcsupport.rst:176
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_clear` handler must be of the :c:type:"
"`inquiry` type, or ``NULL`` if the object is immutable."
msgstr ""
":c:member:`~PyTypeObject.tp_clear` 處理程式必須是 :c:type:`inquiry` 型別，如"
"果對像是不可變的，則為 ``NULL``。"

#: ../../c-api/gcsupport.rst:182
#, fuzzy
msgid ""
"Drop references that may have created reference cycles.  Immutable objects "
"do not have to define this method since they can never directly create "
"reference cycles.  Note that the object must still be valid after calling "
"this method (don't just call :c:func:`Py_DECREF` on a reference).  The "
"collector will call this method if it detects that this object is involved "
"in a reference cycle."
msgstr ""
"刪除可能已建立引用循環的引用。不可變對像不必定義此方法，因為它們永遠無法直接"
"建立引用循環。請注意，對像在呼叫此方法後必須仍然有效（不要只在引用上呼叫 "
"Py_DECREF）。如果收集器檢測到此物件涉及引用循環，則收集器將呼叫此方法。"

#: ../../c-api/gcsupport.rst:191
#, fuzzy
msgid "Controlling the Garbage Collector State"
msgstr "控制垃圾收集器狀態"

#: ../../c-api/gcsupport.rst:193
#, fuzzy
msgid ""
"The C-API provides the following functions for controlling garbage "
"collection runs."
msgstr "C-API 提供以下函式來控制垃圾收集運行。"

#: ../../c-api/gcsupport.rst:198
#, fuzzy
msgid ""
"Perform a full garbage collection, if the garbage collector is enabled. "
"(Note that :func:`gc.collect` runs it unconditionally.)"
msgstr ""
"如果啟用了垃圾收集器，則執行完整的垃圾收集。 （注意 :func:`gc.collect` 無條件"
"地運行它。）"

#: ../../c-api/gcsupport.rst:201
#, fuzzy
msgid ""
"Returns the number of collected + unreachable objects which cannot be "
"collected. If the garbage collector is disabled or already collecting, "
"returns ``0`` immediately. Errors during garbage collection are passed to :"
"data:`sys.unraisablehook`. This function does not raise exceptions."
msgstr ""
"回傳 collected + 無法收集的 unreachable 物件的數量。如果垃圾收集器被禁用或已"
"經在收集，則立即回傳 ``0``。垃圾收集期間的錯誤會傳遞給 :data:`sys."
"unraisablehook`。此函式不會引發例外。"

#: ../../c-api/gcsupport.rst:211
#, fuzzy
msgid ""
"Enable the garbage collector: similar to :func:`gc.enable`. Returns the "
"previous state, 0 for disabled and 1 for enabled."
msgstr ""
"啟用垃圾收集器：類似於 :func:`gc.enable`。回傳之前的狀態，0 表示禁用，1 表示"
"啟用。"

#: ../../c-api/gcsupport.rst:219
#, fuzzy
msgid ""
"Disable the garbage collector: similar to :func:`gc.disable`. Returns the "
"previous state, 0 for disabled and 1 for enabled."
msgstr ""
"禁用垃圾收集器：類似於 :func:`gc.disable`。回傳之前的狀態，0 表示禁用，1 表示"
"啟用。"

#: ../../c-api/gcsupport.rst:227
#, fuzzy
msgid ""
"Query the state of the garbage collector: similar to :func:`gc.isenabled`. "
"Returns the current state, 0 for disabled and 1 for enabled."
msgstr ""
"查詢垃圾收集器的狀態：類似於 :func:`gc.isenabled`。回傳當前狀態，0 表示禁用，"
"1 表示啟用。"
