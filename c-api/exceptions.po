# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Ching-Lung Chuang, 2015
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-13 00:17+0000\n"
"PO-Revision-Date: 2018-05-23 14:05+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../c-api/exceptions.rst:8
msgid "Exception Handling"
msgstr "例外處理"

#: ../../c-api/exceptions.rst:10
#, fuzzy
msgid ""
"The functions described in this chapter will let you handle and raise Python "
"exceptions.  It is important to understand some of the basics of Python "
"exception handling.  It works somewhat like the POSIX :c:data:`errno` "
"variable: there is a global indicator (per thread) of the last error that "
"occurred.  Most C API functions don't clear this on success, but will set it "
"to indicate the cause of the error on failure.  Most C API functions also "
"return an error indicator, usually ``NULL`` if they are supposed to return a "
"pointer, or ``-1`` if they return an integer (exception: the ``PyArg_*`` "
"functions return ``1`` for success and ``0`` for failure)."
msgstr ""
"本章中描述的函式將使您能夠處理和引發 Python 例外。了解 Python 例外處理的一些"
"基礎知識很重要。它的工作方式有點像 POSIX :c:data:`errno` 變數：有一個全局指示"
"符（每個執行緒）發生的最後一個錯誤。大多數 C API 函式在成功時不會清除它，但會"
"設定它以指示失敗時的錯誤原因。大多數 C API 函式還回傳一個錯誤指示符，如果它們"
"應該回傳一個指標，通常回傳 ``NULL`` ，如果它們回傳一個整數，通常回傳 ``-1``"
"（例外：“PyArg_*”函式回傳“ `1`` 表示成功，``0`` 表示失敗）。"

#: ../../c-api/exceptions.rst:20
#, fuzzy
msgid ""
"Concretely, the error indicator consists of three object pointers: the "
"exception's type, the exception's value, and the traceback object.  Any of "
"those pointers can be ``NULL`` if non-set (although some combinations are "
"forbidden, for example you can't have a non-``NULL`` traceback if the "
"exception type is ``NULL``)."
msgstr ""
"具體來說，錯誤指示器由三個物件指標組成：例外型別、例外值和回溯物件。如果未設"
"定，這些指標中的任何一個都可以為 ``NULL`` （儘管某些組合是被禁止的，例如，如"
"果例外型別為 ``NULL`` ，則不能有非 ``NULL`` 的回溯）。"

#: ../../c-api/exceptions.rst:26
#, fuzzy
msgid ""
"When a function must fail because some function it called failed, it "
"generally doesn't set the error indicator; the function it called already "
"set it.  It is responsible for either handling the error and clearing the "
"exception or returning after cleaning up any resources it holds (such as "
"object references or memory allocations); it should *not* continue normally "
"if it is not prepared to handle the error.  If returning due to an error, it "
"is important to indicate to the caller that an error has been set.  If the "
"error is not handled or carefully propagated, additional calls into the "
"Python/C API may not behave as intended and may fail in mysterious ways."
msgstr ""
"當一個函式因為它呼叫的某個函式失敗而必須失敗時，它通常不會設定錯誤指示符；它"
"呼叫的函式已經設定了它。它負責處理錯誤並清除例外或在清除它持有的任何資源（例"
"如物件引用或記憶體分配）後回傳；如果它沒有準備好處理錯誤，它應該 *不* 正常繼"
"續。如果由於錯誤而回傳，重要的是要向呼叫者指示已設定錯誤。如果錯誤沒有得到處"
"理或小心傳播，對 Python/C API 的額外呼叫可能不會按預期運行，並且可能會以神秘"
"的方式失敗。"

#: ../../c-api/exceptions.rst:37
#, fuzzy
msgid ""
"The error indicator is **not** the result of :func:`sys.exc_info()`. The "
"former corresponds to an exception that is not yet caught (and is therefore "
"still propagating), while the latter returns an exception after it is caught "
"(and has therefore stopped propagating)."
msgstr ""
"錯誤指示器**不是** :func:`sys.exc_info()` 的結果。前者對應的是一個還沒有被捕"
"捉到（因此還在傳播）的例外，而後者則是在捕捉到之後回傳一個例外（因此已經停止"
"傳播）。"

#: ../../c-api/exceptions.rst:44
#, fuzzy
msgid "Printing and clearing"
msgstr "印出和清理"

#: ../../c-api/exceptions.rst:49
#, fuzzy
msgid ""
"Clear the error indicator.  If the error indicator is not set, there is no "
"effect."
msgstr "清除錯誤指示器。如果未設定錯誤指示器，則沒有任何效果。"

#: ../../c-api/exceptions.rst:55
#, fuzzy
msgid ""
"Print a standard traceback to ``sys.stderr`` and clear the error indicator. "
"**Unless** the error is a ``SystemExit``, in that case no traceback is "
"printed and the Python process will exit with the error code specified by "
"the ``SystemExit`` instance."
msgstr ""
"將標準回溯印出到 sys.stderr 並清除錯誤指示器。 **除非**錯誤是 "
"``SystemExit``，在這種情況下，不會印出回溯，Python 行程將退出並顯示 "
"``SystemExit`` 實例指定的錯誤程式碼。"

#: ../../c-api/exceptions.rst:60
#, fuzzy
msgid ""
"Call this function **only** when the error indicator is set.  Otherwise it "
"will cause a fatal error!"
msgstr "**僅**在設定錯誤指示器時呼叫此函式。否則會導致致命錯誤！"

#: ../../c-api/exceptions.rst:63
#, fuzzy
msgid ""
"If *set_sys_last_vars* is nonzero, the variables :data:`sys.last_type`, :"
"data:`sys.last_value` and :data:`sys.last_traceback` will be set to the "
"type, value and traceback of the printed exception, respectively."
msgstr ""
"如果 *set_sys_last_vars* 不為零，則變數 sys.last_type、sys.last_value 和 sys."
"last_traceback 將被設定為印出例外的型別、值和回溯，分別。"

#: ../../c-api/exceptions.rst:70
msgid "Alias for ``PyErr_PrintEx(1)``."
msgstr "``PyErr_PrintEx(1)`` 的別名。"

#: ../../c-api/exceptions.rst:75
#, fuzzy
msgid ""
"Call :func:`sys.unraisablehook` using the current exception and *obj* "
"argument."
msgstr "使用當前例外和 *obj* 參數呼叫 :func:`sys.unraisablehook`。"

#: ../../c-api/exceptions.rst:78
#, fuzzy
msgid ""
"This utility function prints a warning message to ``sys.stderr`` when an "
"exception has been set but it is impossible for the interpreter to actually "
"raise the exception.  It is used, for example, when an exception occurs in "
"an :meth:`__del__` method."
msgstr ""
"當設定了例外但直譯器不可能實際引發例外時，此實用程式函式會向 sys.stderr 印出"
"一條警告消息。例如，在 :meth:`__del__` 方法中發生例外時使用它。"

#: ../../c-api/exceptions.rst:83
#, fuzzy
msgid ""
"The function is called with a single argument *obj* that identifies the "
"context in which the unraisable exception occurred. If possible, the repr of "
"*obj* will be printed in the warning message."
msgstr ""
"該函式使用單個參數 *obj* 呼叫，該參數標識發生無法引發的例外的上下文。如果可"
"能，*obj* 的 repr 將印出在警告消息中。"

#: ../../c-api/exceptions.rst:87
msgid "An exception must be set when calling this function."
msgstr "呼叫此函式時必須設定例外。"

#: ../../c-api/exceptions.rst:91
msgid "Raising exceptions"
msgstr "引發例外"

#: ../../c-api/exceptions.rst:93
#, fuzzy
msgid ""
"These functions help you set the current thread's error indicator. For "
"convenience, some of these functions will always return a ``NULL`` pointer "
"for use in a ``return`` statement."
msgstr ""
"這些函式幫助您設定當前執行緒的錯誤指示器。為方便起見，其中一些函式將始終回傳"
"一個 ``NULL`` 指標，以便在 ``return``語句中使用。"

#: ../../c-api/exceptions.rst:100
#, fuzzy
msgid ""
"This is the most common way to set the error indicator.  The first argument "
"specifies the exception type; it is normally one of the standard exceptions, "
"e.g. :c:data:`PyExc_RuntimeError`.  You need not increment its reference "
"count. The second argument is an error message; it is decoded from "
"``'utf-8'``."
msgstr ""
"這是設定錯誤指示器的最常用方法。第一個參數指定例外型別；它通常是標準例外之"
"一，例如:c:data:`PyExc_RuntimeError`。您無需增加其引用計數。第二個參數是錯誤"
"資訊；它是從 ``'utf-8'`` 解碼而來的。"

#: ../../c-api/exceptions.rst:108
#, fuzzy
msgid ""
"This function is similar to :c:func:`PyErr_SetString` but lets you specify "
"an arbitrary Python object for the \"value\" of the exception."
msgstr ""
"此函式類似於 :c:func:`PyErr_SetString` 但允許您為例外的 \"value\" 指定任意 "
"Python 物件。"

#: ../../c-api/exceptions.rst:114
#, fuzzy
msgid ""
"This function sets the error indicator and returns ``NULL``.  *exception* "
"should be a Python exception class.  The *format* and subsequent parameters "
"help format the error message; they have the same meaning and values as in :"
"c:func:`PyUnicode_FromFormat`. *format* is an ASCII-encoded string."
msgstr ""
"此函式設定錯誤指示器並回傳 ``NULL`` 。 *exception* 應該是一個 Python 例外"
"類。 *format* 和後續參數有助於格式化錯誤消息；它們的含義和值與 :c:func:"
"`PyUnicode_FromFormat` 中的相同。 *format* 是一個 ASCII 編碼的字串。"

#: ../../c-api/exceptions.rst:123
#, fuzzy
msgid ""
"Same as :c:func:`PyErr_Format`, but taking a :c:type:`va_list` argument "
"rather than a variable number of arguments."
msgstr ""
"與 :c:func:`PyErr_Format` 相同，但採用 :c:type:`va_list` 參數而不是可變數量的"
"參數。"

#: ../../c-api/exceptions.rst:131
msgid "This is a shorthand for ``PyErr_SetObject(type, Py_None)``."
msgstr "這是 ``PyErr_SetObject(type, Py_None)`` 的簡寫。"

#: ../../c-api/exceptions.rst:136
#, fuzzy
msgid ""
"This is a shorthand for ``PyErr_SetString(PyExc_TypeError, message)``, where "
"*message* indicates that a built-in operation was invoked with an illegal "
"argument.  It is mostly for internal use."
msgstr ""
"這是 ``PyErr_SetString(PyExc_TypeError, message)`` 的簡寫，其中 *message* 表"
"示使用非法參數呼叫了內建操作。它主要供內部使用。"

#: ../../c-api/exceptions.rst:143
#, fuzzy
msgid ""
"This is a shorthand for ``PyErr_SetNone(PyExc_MemoryError)``; it returns "
"``NULL`` so an object allocation function can write ``return "
"PyErr_NoMemory();`` when it runs out of memory."
msgstr ""
"這是``PyErr_SetNone(PyExc_MemoryError)`` 的簡寫；它回傳 ``NULL`` ，因此物件分"
"配函式可以在記憶體不足時寫入“return PyErr_NoMemory();”。"

#: ../../c-api/exceptions.rst:152
#, fuzzy
msgid ""
"This is a convenience function to raise an exception when a C library "
"function has returned an error and set the C variable :c:data:`errno`.  It "
"constructs a tuple object whose first item is the integer :c:data:`errno` "
"value and whose second item is the corresponding error message (gotten from :"
"c:func:`strerror`), and then calls ``PyErr_SetObject(type, object)``.  On "
"Unix, when the :c:data:`errno` value is :const:`EINTR`, indicating an "
"interrupted system call, this calls :c:func:`PyErr_CheckSignals`, and if "
"that set the error indicator, leaves it set to that.  The function always "
"returns ``NULL``, so a wrapper function around a system call can write "
"``return PyErr_SetFromErrno(type);`` when the system call returns an error."
msgstr ""
"這是一個方便的函式，用於在 C 庫函式回傳錯誤並設定 C 變數 :c:data:`errno` 時引"
"發例外。它構造一個元組物件，其第一項是整數 errno 值，第二項是相應的錯誤消息"
"（從 strerror 獲得），然後呼叫 PyErr_SetObject(type ，物件）``。在 Unix 上，"
"當 :c:data:`errno` 值為 :const:`EINTR` 時，表示系統呼叫中斷，這會呼叫 :c:"
"func:`PyErr_CheckSignals`，如果設定了錯誤指示器，則保留它設定到那個。該函式總"
"是回傳 ``NULL`` ，因此當系統呼叫回傳錯誤時，圍繞系統呼叫的包裝函式可以編"
"寫“return PyErr_SetFromErrno(type);”。"

#: ../../c-api/exceptions.rst:166
#, fuzzy
msgid ""
"Similar to :c:func:`PyErr_SetFromErrno`, with the additional behavior that "
"if *filenameObject* is not ``NULL``, it is passed to the constructor of "
"*type* as a third parameter.  In the case of :exc:`OSError` exception, this "
"is used to define the :attr:`filename` attribute of the exception instance."
msgstr ""
"類似於 :c:func:`PyErr_SetFromErrno`，如果 *filenameObject* 不是 ``NULL``，它"
"會作為第三個參數傳遞給 *type* 的構造函式。在 :exc:`OSError` 例外的情況下，這"
"用於定義例外實例的 :attr:`filename` 屬性。"

#: ../../c-api/exceptions.rst:175
#, fuzzy
msgid ""
"Similar to :c:func:`PyErr_SetFromErrnoWithFilenameObject`, but takes a "
"second filename object, for raising errors when a function that takes two "
"filenames fails."
msgstr ""
"類似於 :c:func:`PyErr_SetFromErrnoWithFilenameObject`，但採用第二個文件名物"
"件，用於在採用兩個文件名的函式失敗時引發錯誤。"

#: ../../c-api/exceptions.rst:184
#, fuzzy
msgid ""
"Similar to :c:func:`PyErr_SetFromErrnoWithFilenameObject`, but the filename "
"is given as a C string.  *filename* is decoded from the :term:`filesystem "
"encoding and error handler`."
msgstr ""
"類似於 :c:func:`PyErr_SetFromErrnoWithFilenameObject`，但文件名以 C 字串形式"
"給出。 *文件名* 是從 :term:`文件系統編碼和錯誤處理程式` 解碼而來的。"

#: ../../c-api/exceptions.rst:191
#, fuzzy
msgid ""
"This is a convenience function to raise :exc:`WindowsError`. If called with "
"*ierr* of ``0``, the error code returned by a call to :c:func:`GetLastError` "
"is used instead.  It calls the Win32 function :c:func:`FormatMessage` to "
"retrieve the Windows description of error code given by *ierr* or :c:func:"
"`GetLastError`, then it constructs a tuple object whose first item is the "
"*ierr* value and whose second item is the corresponding error message "
"(gotten from :c:func:`FormatMessage`), and then calls "
"``PyErr_SetObject(PyExc_WindowsError, object)``. This function always "
"returns ``NULL``."
msgstr ""
"這是引發 :exc:`WindowsError` 的便利函式。如果使用 ``0`` 的 *ierr* 呼叫，則使"
"用呼叫 :c:func:`GetLastError` 回傳的錯誤程式碼。它呼叫 Win32 函式:c:func:"
"`FormatMessage` 來檢索 Windows 對 *ierr* 或 :c:func:`GetLastError` 給出的錯誤"
"程式碼的描述，然後構造一個元組物件，其第一項是 *ierr*值，其第二項是相應的錯誤"
"消息（從:c:func:`FormatMessage` 獲得），然後呼叫"
"``PyErr_SetObject(PyExc_WindowsError, object)``。這個函式總是回傳 ``NULL`` 。"

#: ../../c-api/exceptions.rst:200 ../../c-api/exceptions.rst:208
#: ../../c-api/exceptions.rst:217 ../../c-api/exceptions.rst:225
#: ../../c-api/exceptions.rst:233 ../../c-api/exceptions.rst:243
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`適用 <availability>`：Windows。"

#: ../../c-api/exceptions.rst:205
#, fuzzy
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErr`, with an additional parameter "
"specifying the exception type to be raised."
msgstr ""
"類似於 :c:func:`PyErr_SetFromWindowsErr`，帶有一個額外的參數指定要引發的例外"
"型別。"

#: ../../c-api/exceptions.rst:213
#, fuzzy
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErrWithFilenameObject`, but the "
"filename is given as a C string.  *filename* is decoded from the filesystem "
"encoding (:func:`os.fsdecode`)."
msgstr ""
"類似於 :c:func:`PyErr_SetFromWindowsErrWithFilenameObject`，但文件名是作為 C "
"字串給出的。 *filename* 從文件系統編碼 (:func:`os.fsdecode`) 中解碼。"

#: ../../c-api/exceptions.rst:222
#, fuzzy
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErrWithFilenameObject`, with an "
"additional parameter specifying the exception type to be raised."
msgstr ""
"類似於 :c:func:`PyErr_SetFromWindowsErrWithFilenameObject`，帶有一個附加參數"
"指定要引發的例外型別。"

#: ../../c-api/exceptions.rst:230
#, fuzzy
msgid ""
"Similar to :c:func:`PyErr_SetExcFromWindowsErrWithFilenameObject`, but "
"accepts a second filename object."
msgstr ""
"類似於 :c:func:`PyErr_SetExcFromWindowsErrWithFilenameObject`，但接受第二個文"
"件名物件。"

#: ../../c-api/exceptions.rst:240
#, fuzzy
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErrWithFilename`, with an additional "
"parameter specifying the exception type to be raised."
msgstr ""
"類似於 :c:func:`PyErr_SetFromWindowsErrWithFilename`，帶有一個附加參數指定要"
"引發的例外型別。"

#: ../../c-api/exceptions.rst:248
#, fuzzy
msgid ""
"This is a convenience function to raise :exc:`ImportError`. *msg* will be "
"set as the exception's message string. *name* and *path*, both of which can "
"be ``NULL``, will be set as the :exc:`ImportError`'s respective ``name`` and "
"``path`` attributes."
msgstr ""
"這是引發 :exc:`ImportError` 的便利函式。 *msg* 將被設定為例外的消息字串。 "
"*name* 和 *path*，兩者都可以是 NULL，將被設定為 ImportError 各自的 name 和 "
"path 屬性。"

#: ../../c-api/exceptions.rst:258
#, fuzzy
msgid ""
"Much like :c:func:`PyErr_SetImportError` but this function allows for "
"specifying a subclass of :exc:`ImportError` to raise."
msgstr ""
"很像 :c:func:`PyErr_SetImportError` 但此函式允許指定要引發的 :exc:"
"`ImportError` 的子類別。"

#: ../../c-api/exceptions.rst:266
#, fuzzy
msgid ""
"Set file, line, and offset information for the current exception.  If the "
"current exception is not a :exc:`SyntaxError`, then it sets additional "
"attributes, which make the exception printing subsystem think the exception "
"is a :exc:`SyntaxError`."
msgstr ""
"為當前例外設定文件、行和偏移量資訊。如果當前例外不是 :exc:`SyntaxError`，那麼"
"它會設定額外的屬性，使例外印出子系統認為例外是 :exc:`SyntaxError`。"

#: ../../c-api/exceptions.rst:276
#, fuzzy
msgid ""
"Like :c:func:`PyErr_SyntaxLocationObject`, but *filename* is a byte string "
"decoded from the :term:`filesystem encoding and error handler`."
msgstr ""
"像 :c:func:`PyErr_SyntaxLocationObject`，但 *filename* 是從 :term:"
"`filesystem encoding and error handler` 解碼的位元組字串。"

#: ../../c-api/exceptions.rst:284
#, fuzzy
msgid ""
"Like :c:func:`PyErr_SyntaxLocationEx`, but the *col_offset* parameter is "
"omitted."
msgstr "類似於 :c:func:`PyErr_SyntaxLocationEx`，但省略了 *col_offset* 參數。"

#: ../../c-api/exceptions.rst:290
#, fuzzy
msgid ""
"This is a shorthand for ``PyErr_SetString(PyExc_SystemError, message)``, "
"where *message* indicates that an internal operation (e.g. a Python/C API "
"function) was invoked with an illegal argument.  It is mostly for internal "
"use."
msgstr ""
"這是 ``PyErr_SetString(PyExc_SystemError, message)`` 的簡寫，其中 *message* "
"表示使用非法參數呼叫了內部操作（例如 Python/C API 函式）。它主要供內部使用。"

#: ../../c-api/exceptions.rst:297
msgid "Issuing warnings"
msgstr "發出警告"

#: ../../c-api/exceptions.rst:299
#, fuzzy
msgid ""
"Use these functions to issue warnings from C code.  They mirror similar "
"functions exported by the Python :mod:`warnings` module.  They normally "
"print a warning message to *sys.stderr*; however, it is also possible that "
"the user has specified that warnings are to be turned into errors, and in "
"that case they will raise an exception.  It is also possible that the "
"functions raise an exception because of a problem with the warning "
"machinery. The return value is ``0`` if no exception is raised, or ``-1`` if "
"an exception is raised.  (It is not possible to determine whether a warning "
"message is actually printed, nor what the reason is for the exception; this "
"is intentional.)  If an exception is raised, the caller should do its normal "
"exception handling (for example, :c:func:`Py_DECREF` owned references and "
"return an error value)."
msgstr ""
"使用這些函式從 C 程式碼發出警告。它們反映了 Python :mod:`warnings` 模組導出的"
"類似函式。他們通常會向 *sys.stderr* 印出一條警告消息；然而，也有可能使用者已"
"經指定將警告轉換為錯誤，在這種情況下它們將引發例外。由於警告機制的問題，函式"
"也可能引發例外。如果未引發例外，則回傳值為 ``0``，如果引發例外，則回傳值為 "
"``-1``。 （無法確定是否實際印出了警告消息，也無法確定例外的原因是什麼；這是故"
"意的。）如果引發例外，呼叫者應該進行正常的例外處理（例如，:c: func:"
"`Py_DECREF` 擁有引用並回傳錯誤值）。"

#: ../../c-api/exceptions.rst:314
#, fuzzy
msgid ""
"Issue a warning message.  The *category* argument is a warning category (see "
"below) or ``NULL``; the *message* argument is a UTF-8 encoded string.  "
"*stack_level* is a positive number giving a number of stack frames; the "
"warning will be issued from the  currently executing line of code in that "
"stack frame.  A *stack_level* of 1 is the function calling :c:func:"
"`PyErr_WarnEx`, 2 is  the function above that, and so forth."
msgstr ""
"發出警告資訊。 *category* 參數是警告類別（見下文）或 ``NULL`` ； *message* 參"
"數是 UTF-8 編碼的字串。 *stack_level* 是一個正數，給出了堆疊幀的數量；該警告"
"將從該堆疊框架中當前正在執行的程式碼行發出。 *stack_level* 為 1 的是呼叫 :c:"
"func:`PyErr_WarnEx` 的函式，2 是其上方的函式，依此類推。"

#: ../../c-api/exceptions.rst:321
#, fuzzy
msgid ""
"Warning categories must be subclasses of :c:data:`PyExc_Warning`; :c:data:"
"`PyExc_Warning` is a subclass of :c:data:`PyExc_Exception`; the default "
"warning category is :c:data:`PyExc_RuntimeWarning`. The standard Python "
"warning categories are available as global variables whose names are "
"enumerated at :ref:`standardwarningcategories`."
msgstr ""
"警告類別必須是 :c:data:`PyExc_Warning` 的子類別； :c:data:`PyExc_Warning` "
"是 :c:data:`PyExc_Exception` 的子類別；預設警告類別是:c:data:"
"`PyExc_RuntimeWarning`。標準 Python 警告類別可用作全局變數，其名稱在 :ref:"
"`standardwarningcategories` 中枚舉。"

#: ../../c-api/exceptions.rst:327
#, fuzzy
msgid ""
"For information about warning control, see the documentation for the :mod:"
"`warnings` module and the :option:`-W` option in the command line "
"documentation.  There is no C API for warning control."
msgstr ""
"有關警告控制的資訊，請參閱命令列文檔中的 :mod:`warnings` 模組和 :option:`-W` "
"選項的文檔。沒有用於警告控制的 C API。"

#: ../../c-api/exceptions.rst:334
#, fuzzy
msgid ""
"Issue a warning message with explicit control over all warning attributes.  "
"This is a straightforward wrapper around the Python function :func:`warnings."
"warn_explicit`; see there for more information.  The *module* and *registry* "
"arguments may be set to ``NULL`` to get the default effect described there."
msgstr ""
"發出警告消息，明確控制所有警告屬性。這是 Python 函式的直接包裝器 :func:"
"`warnings.warn_explicit`；在那裡查看更多資訊。 *module* 和 *registry* 參數可"
"以設定為 ``NULL`` 以獲得那裡描述的預設效果。"

#: ../../c-api/exceptions.rst:345
#, fuzzy
msgid ""
"Similar to :c:func:`PyErr_WarnExplicitObject` except that *message* and "
"*module* are UTF-8 encoded strings, and *filename* is decoded from the :term:"
"`filesystem encoding and error handler`."
msgstr ""
"與:c:func:`PyErr_WarnExplicitObject` 類似，除了 *message* 和 *module* 是 "
"UTF-8 編碼字串，*filename* 從 :term:`文件系統編碼和錯誤處理程式` 解碼。"

#: ../../c-api/exceptions.rst:352
#, fuzzy
msgid ""
"Function similar to :c:func:`PyErr_WarnEx`, but use :c:func:"
"`PyUnicode_FromFormat` to format the warning message.  *format* is an ASCII-"
"encoded string."
msgstr ""
"功能類似於:c:func:`PyErr_WarnEx`，但使用:c:func:`PyUnicode_FromFormat` 格式化"
"警告資訊。 *format* 是一個 ASCII 編碼的字串。"

#: ../../c-api/exceptions.rst:361
#, fuzzy
msgid ""
"Function similar to :c:func:`PyErr_WarnFormat`, but *category* is :exc:"
"`ResourceWarning` and it passes *source* to :func:`warnings.WarningMessage`."
msgstr ""
"功能類似於:c:func:`PyErr_WarnFormat`，但*category* 是 :exc:`ResourceWarning` "
"並將*source* 傳遞給 :func:`warnings.WarningMessage`。"

#: ../../c-api/exceptions.rst:368
#, fuzzy
msgid "Querying the error indicator"
msgstr "查詢錯誤指示器"

#: ../../c-api/exceptions.rst:372
#, fuzzy
msgid ""
"Test whether the error indicator is set.  If set, return the exception "
"*type* (the first argument to the last call to one of the ``PyErr_Set*`` "
"functions or to :c:func:`PyErr_Restore`).  If not set, return ``NULL``.  You "
"do not own a reference to the return value, so you do not need to :c:func:"
"`Py_DECREF` it."
msgstr ""
"測試是否設定了錯誤指示器。如果設定，則回傳例外 *type*（最後一次呼叫 "
"``PyErr_Set*`` 函式或 :c:func:`PyErr_Restore` 的第一個參數）。如果未設定，則"
"回傳 ``NULL`` 。您不擁有對回傳值的引用，因此您不需要 :c:func:`Py_DECREF` 它。"

#: ../../c-api/exceptions.rst:378
#, fuzzy
msgid "The caller must hold the GIL."
msgstr "呼叫者必須持有 GIL。"

#: ../../c-api/exceptions.rst:382
#, fuzzy
msgid ""
"Do not compare the return value to a specific exception; use :c:func:"
"`PyErr_ExceptionMatches` instead, shown below.  (The comparison could easily "
"fail since the exception may be an instance instead of a class, in the case "
"of a class exception, or it may be a subclass of the expected exception.)"
msgstr ""
"不要將回傳值與特定例外進行比較；使用 :c:func:`PyErr_ExceptionMatches` 代替，"
"如下所示。 （比較很容易失敗，因為在類例外的情況下，例外可能是實例而不是類，或"
"者它可能是預期例外的子類別。）"

#: ../../c-api/exceptions.rst:390
#, fuzzy
msgid ""
"Equivalent to ``PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)``.  This "
"should only be called when an exception is actually set; a memory access "
"violation will occur if no exception has been raised."
msgstr ""
"等同於``PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)``。只有在實際設定"
"例外時才應呼叫它；如果沒有引發例外，將發生記憶體訪問衝突。"

#: ../../c-api/exceptions.rst:397
#, fuzzy
msgid ""
"Return true if the *given* exception matches the exception type in *exc*.  "
"If *exc* is a class object, this also returns true when *given* is an "
"instance of a subclass.  If *exc* is a tuple, all exception types in the "
"tuple (and recursively in subtuples) are searched for a match."
msgstr ""
"如果 *given* 例外與 *exc* 中的例外型別匹配，則回傳 true。如果 *exc* 是一個類"
"物件，當 *given* 是一個子類別的實例時，這也會回傳 true。如果 *exc* 是一個元"
"組，則搜索元組中的所有例外型別（以及遞迴子元組中的例外型別）以進行匹配。"

#: ../../c-api/exceptions.rst:405
#, fuzzy
msgid ""
"Retrieve the error indicator into three variables whose addresses are "
"passed. If the error indicator is not set, set all three variables to "
"``NULL``.  If it is set, it will be cleared and you own a reference to each "
"object retrieved.  The value and traceback object may be ``NULL`` even when "
"the type object is not."
msgstr ""
"將錯誤指示器檢索到傳遞地址的三個變數中。如果未設定錯誤指示器，請將所有三個變"
"數設定為 ``NULL`` 。如果已設定，它將被清除並且您擁有對每個檢索到的物件的引"
"用。值和回溯物件可能是 ``NULL`` ，即使型別對像不是。"

#: ../../c-api/exceptions.rst:412
#, fuzzy
msgid ""
"This function is normally only used by code that needs to catch exceptions "
"or by code that needs to save and restore the error indicator temporarily, e."
"g.::"
msgstr ""
"此函式通常僅由需要捕獲例外的程式碼或需要臨時保存和恢復錯誤指示器的程式碼使"
"用，例如："

#: ../../c-api/exceptions.rst:427
#, fuzzy
msgid ""
"Set  the error indicator from the three objects.  If the error indicator is "
"already set, it is cleared first.  If the objects are ``NULL``, the error "
"indicator is cleared.  Do not pass a ``NULL`` type and non-``NULL`` value or "
"traceback.  The exception type should be a class.  Do not pass an invalid "
"exception type or value. (Violating these rules will cause subtle problems "
"later.)  This call takes away a reference to each object: you must own a "
"reference to each object before the call and after the call you no longer "
"own these references.  (If you don't understand this, don't use this "
"function.  I warned you.)"
msgstr ""
"從三個對像中設定錯誤指示器。如果錯誤指示器已經設定，則首先將其清除。如果物件"
"為 ``NULL`` ，則清除錯誤指示器。不要傳遞 ``NULL`` 型別和非 ``NULL`` 值或回"
"溯。例外型別應該是一個類。不要傳遞無效的例外型別或值。 （違反這些規則會在以後"
"引起微妙的問題。）這個呼叫會帶走對每個物件的引用：在呼叫之前你必須擁有對每個"
"物件的引用，而在呼叫之後你不再擁有這些引用。 （如果你不明白這一點，不要使用這"
"個功能。我警告過你。）"

#: ../../c-api/exceptions.rst:439
#, fuzzy
msgid ""
"This function is normally only used by code that needs to save and restore "
"the error indicator temporarily.  Use :c:func:`PyErr_Fetch` to save the "
"current error indicator."
msgstr ""
"此函式通常僅供需要臨時保存和恢復錯誤指示符的程式碼使用。使用 :c:func:"
"`PyErr_Fetch` 保存當前錯誤指示符。"

#: ../../c-api/exceptions.rst:446
#, fuzzy
msgid ""
"Under certain circumstances, the values returned by :c:func:`PyErr_Fetch` "
"below can be \"unnormalized\", meaning that ``*exc`` is a class object but "
"``*val`` is not an instance of the  same class.  This function can be used "
"to instantiate the class in that case.  If the values are already "
"normalized, nothing happens. The delayed normalization is implemented to "
"improve performance."
msgstr ""
"在某些情況下，下面的 :c:func:`PyErr_Fetch` 回傳的值可能是“未規範化的”，這意味"
"著 ``*exc`` 是一個類物件，但 ``*val`` 不是同一類的實例.在這種情況下，此函式可"
"用於實例化該類。如果這些值已經標準化，則什麼也不會發生。實施延遲歸一化以提高"
"性能。"

#: ../../c-api/exceptions.rst:454
#, fuzzy
msgid ""
"This function *does not* implicitly set the ``__traceback__`` attribute on "
"the exception value. If setting the traceback appropriately is desired, the "
"following additional snippet is needed::"
msgstr ""
"此函式*不會*隱式設定例外值的``__traceback__`` 屬性。如果需要適當地設定回溯，"
"則需要以下附加程式碼段::"

#: ../../c-api/exceptions.rst:465
#, fuzzy
msgid ""
"Retrieve the active exception instance, as would be returned by :func:`sys."
"exception`. This refers to an exception that was *already caught*, not to an "
"exception that was freshly raised. Returns a new reference to the exception "
"or ``NULL``. Does not modify the interpreter's exception state."
msgstr ""
"檢索活動的例外實例，如 :func:`sys.exception` 回傳的那樣。這是指*已經捕獲*的例"
"外，而不是新提出的例外。回傳對例外或 ``NULL`` 的新引用。不修改直譯器的例外狀"
"態。"

#: ../../c-api/exceptions.rst:472
#, fuzzy
msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_SetHandledException` to restore or "
"clear the exception state."
msgstr ""
"要處理例外的程式碼通常不使用此函式。相反，它可以在程式碼需要臨時保存和恢復例"
"外狀態時使用。使用:c:func:`PyErr_SetHandledException` 恢復或清除例外狀態。"

#: ../../c-api/exceptions.rst:481
#, fuzzy
msgid ""
"Set the active exception, as known from ``sys.exception()``.  This refers to "
"an exception that was *already caught*, not to an exception that was freshly "
"raised. To clear the exception state, pass ``NULL``."
msgstr ""
"設定活動例外，如 ``sys.exception()`` 所知。這是指*已經捕獲*的例外，而不是新提"
"出的例外。要清除例外狀態，請傳遞 ``NULL`` 。"

#: ../../c-api/exceptions.rst:488
#, fuzzy
msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_GetHandledException` to get the "
"exception state."
msgstr ""
"要處理例外的程式碼通常不使用此函式。相反，它可以在程式碼需要臨時保存和恢復例"
"外狀態時使用。使用 :c:func:`PyErr_GetHandledException` 獲取例外狀態。"

#: ../../c-api/exceptions.rst:497
#, fuzzy
msgid ""
"Retrieve the old-style representation of the exception info, as known from :"
"func:`sys.exc_info`.  This refers to an exception that was *already caught*, "
"not to an exception that was freshly raised.  Returns new references for the "
"three objects, any of which may be ``NULL``.  Does not modify the exception "
"info state.  This function is kept for backwards compatibility. Prefer "
"using :c:func:`PyErr_GetHandledException`."
msgstr ""
"檢索例外資訊的舊式表示，如 :func:`sys.exc_info` 所示。這是指*已經捕獲*的例"
"外，而不是新提出的例外。回傳三個物件的新引用，其中任何一個都可能為 "
"``NULL`` 。不修改例外資訊狀態。保留此功能是為了向後相容。更喜歡使用 :c:func:"
"`PyErr_GetHandledException`。"

#: ../../c-api/exceptions.rst:506
#, fuzzy
msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_SetExcInfo` to restore or clear the "
"exception state."
msgstr ""
"要處理例外的程式碼通常不使用此函式。相反，它可以在程式碼需要臨時保存和恢復例"
"外狀態時使用。使用:c:func:`PyErr_SetExcInfo` 恢復或清除例外狀態。"

#: ../../c-api/exceptions.rst:516
#, fuzzy
msgid ""
"Set the exception info, as known from ``sys.exc_info()``.  This refers to an "
"exception that was *already caught*, not to an exception that was freshly "
"raised.  This function steals the references of the arguments. To clear the "
"exception state, pass ``NULL`` for all three arguments. This function is "
"kept for backwards compatibility. Prefer using :c:func:"
"`PyErr_SetHandledException`."
msgstr ""
"設定例外資訊，如 ``sys.exc_info()`` 所知。這是指*已經捕獲*的例外，而不是新提"
"出的例外。此函式竊取參數的引用。要清除例外狀態，請為所有三個參數傳遞 "
"``NULL`` 。保留此功能是為了向後相容。更喜歡使用 :c:func:"
"`PyErr_SetHandledException`。"

#: ../../c-api/exceptions.rst:525
#, fuzzy
msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_GetExcInfo` to read the exception "
"state."
msgstr ""
"要處理例外的程式碼通常不使用此函式。相反，它可以在程式碼需要臨時保存和恢復例"
"外狀態時使用。使用 :c:func:`PyErr_GetExcInfo` 讀取例外狀態。"

#: ../../c-api/exceptions.rst:532
#, fuzzy
msgid ""
"The ``type`` and ``traceback`` arguments are no longer used and can be NULL. "
"The interpreter now derives them from the exception instance (the ``value`` "
"argument). The function still steals references of all three arguments."
msgstr ""
"``type`` 和 ``traceback`` 參數不再使用，可以為 NULL。直譯器現在從例外實例"
"（``value`` 參數）派生它們。該函式仍然竊取所有三個參數的引用。"

#: ../../c-api/exceptions.rst:540
#, fuzzy
msgid "Signal Handling"
msgstr "信號處理"

#: ../../c-api/exceptions.rst:550
#, fuzzy
msgid "This function interacts with Python's signal handling."
msgstr "此函式與 Python 的信號處理交互。"

#: ../../c-api/exceptions.rst:552
#, fuzzy
msgid ""
"If the function is called from the main thread and under the main Python "
"interpreter, it checks whether a signal has been sent to the processes and "
"if so, invokes the corresponding signal handler.  If the :mod:`signal` "
"module is supported, this can invoke a signal handler written in Python."
msgstr ""
"如果該函式是從主執行緒和主 Python 直譯器下呼叫的，它會檢查信號是否已發送到行"
"程，如果是，則呼叫相應的信號處理程式。如果支援 :mod:`signal` 模組，這可以呼叫"
"用 Python 編寫的信號處理程式。"

#: ../../c-api/exceptions.rst:557
#, fuzzy
msgid ""
"The function attempts to handle all pending signals, and then returns ``0``. "
"However, if a Python signal handler raises an exception, the error indicator "
"is set and the function returns ``-1`` immediately (such that other pending "
"signals may not have been handled yet: they will be on the next :c:func:"
"`PyErr_CheckSignals()` invocation)."
msgstr ""
"該函式嘗試處理所有未決信號，然後回傳 ``0``。但是，如果 Python 信號處理程式引"
"發例外，則設定錯誤指示器並且函式立即回傳 ``-1``（這樣其他未決信號可能尚未處"
"理：它們將在下一個 :c:func :`PyErr_CheckSignals()` 呼叫）。"

#: ../../c-api/exceptions.rst:563
#, fuzzy
msgid ""
"If the function is called from a non-main thread, or under a non-main Python "
"interpreter, it does nothing and returns ``0``."
msgstr ""
"如果該函式是從非主執行緒或在非主 Python 直譯器下呼叫的，則它什麼都不做並回傳 "
"``0``。"

#: ../../c-api/exceptions.rst:566
#, fuzzy
msgid ""
"This function can be called by long-running C code that wants to be "
"interruptible by user requests (such as by pressing Ctrl-C)."
msgstr ""
"此函式可由希望被使用者請求中斷（例如通過按 Ctrl-C）的長時間運行的 C 程式碼呼"
"叫。"

#: ../../c-api/exceptions.rst:570
#, fuzzy
msgid ""
"The default Python signal handler for :const:`SIGINT` raises the :exc:"
"`KeyboardInterrupt` exception."
msgstr ""
":const:`SIGINT` 的預設 Python 信號處理程式會引發 :exc:`KeyboardInterrupt` 例"
"外。"

#: ../../c-api/exceptions.rst:581
#, fuzzy
msgid ""
"Simulate the effect of a :const:`SIGINT` signal arriving. This is equivalent "
"to ``PyErr_SetInterruptEx(SIGINT)``."
msgstr ""
"模擬 :const:`SIGINT` 信號到達的效果。這相當於"
"``PyErr_SetInterruptEx(SIGINT)``。"

#: ../../c-api/exceptions.rst:585 ../../c-api/exceptions.rst:612
#, fuzzy
msgid ""
"This function is async-signal-safe.  It can be called without the :term:"
"`GIL` and from a C signal handler."
msgstr ""
"此函式是非同步信號安全的。它可以在沒有 GIL 的情況下從 C 信號處理程式中呼叫。"

#: ../../c-api/exceptions.rst:595
#, fuzzy
msgid ""
"Simulate the effect of a signal arriving. The next time :c:func:"
"`PyErr_CheckSignals` is called,  the Python signal handler for the given "
"signal number will be called."
msgstr ""
"模擬信號到達的效果。下次呼叫 :c:func:`PyErr_CheckSignals` 時，將呼叫給定信號"
"編號的 Python 信號處理程式。"

#: ../../c-api/exceptions.rst:599
#, fuzzy
msgid ""
"This function can be called by C code that sets up its own signal handling "
"and wants Python signal handlers to be invoked as expected when an "
"interruption is requested (for example when the user presses Ctrl-C to "
"interrupt an operation)."
msgstr ""
"此函式可以由 C 程式碼呼叫，它設定自己的信號處理，並希望在請求中斷時按預期呼"
"叫 Python 信號處理程式（例如，當使用者按 Ctrl-C 中斷操作時）。"

#: ../../c-api/exceptions.rst:604
#, fuzzy
msgid ""
"If the given signal isn't handled by Python (it was set to :data:`signal."
"SIG_DFL` or :data:`signal.SIG_IGN`), it will be ignored."
msgstr ""
"如果給定的信號不是由 Python 處理的（它被設定為 :data:`signal.SIG_DFL` 或 :"
"data:`signal.SIG_IGN`），它將被忽略。"

#: ../../c-api/exceptions.rst:607
#, fuzzy
msgid ""
"If *signum* is outside of the allowed range of signal numbers, ``-1`` is "
"returned.  Otherwise, ``0`` is returned.  The error indicator is never "
"changed by this function."
msgstr ""
"如果 *signum* 超出信號編號的允許範圍，則回傳 ``-1``。否則，回傳 ``0``。此函式"
"永遠不會更改錯誤指示器。"

#: ../../c-api/exceptions.rst:620
#, fuzzy
msgid ""
"This utility function specifies a file descriptor to which the signal number "
"is written as a single byte whenever a signal is received. *fd* must be non-"
"blocking. It returns the previous such file descriptor."
msgstr ""
"此實用程式函式指定一個文件描述器，每當接收到信號時，信號編號將作為單個位元組"
"寫入該文件描述器。 *fd* 必須是非阻塞的。它回傳以前的此類文件描述器。"

#: ../../c-api/exceptions.rst:624
#, fuzzy
msgid ""
"The value ``-1`` disables the feature; this is the initial state. This is "
"equivalent to :func:`signal.set_wakeup_fd` in Python, but without any error "
"checking.  *fd* should be a valid file descriptor.  The function should only "
"be called from the main thread."
msgstr ""
"值 ``-1``禁用該功能；這是初始狀態。這相當於 Python 中的 :func:`signal."
"set_wakeup_fd`，但沒有任何錯誤檢查。 *fd* 應該是一個有效的文件描述器。該函式"
"只能從主執行緒呼叫。"

#: ../../c-api/exceptions.rst:629
#, fuzzy
msgid "On Windows, the function now also supports socket handles."
msgstr "在 Windows 上，該函式現在還支援 socket 句柄。"

#: ../../c-api/exceptions.rst:634
msgid "Exception Classes"
msgstr "例外類別"

#: ../../c-api/exceptions.rst:638
#, fuzzy
msgid ""
"This utility function creates and returns a new exception class. The *name* "
"argument must be the name of the new exception, a C string of the form "
"``module.classname``.  The *base* and *dict* arguments are normally "
"``NULL``. This creates a class object derived from :exc:`Exception` "
"(accessible in C as :c:data:`PyExc_Exception`)."
msgstr ""
"這個實用函式建立並回傳一個新的例外類。 *name* 參數必須是新例外的名稱，一個形"
"式為 ``module.classname`` 的 C 字串。 *base* 和 *dict* 參數通常為 ``NULL`` 。"
"這將建立一個派生自 :exc:`Exception` 的類物件（在 C 中可作為 :c:data:"
"`PyExc_Exception` 訪問）。"

#: ../../c-api/exceptions.rst:644
#, fuzzy
msgid ""
"The :attr:`__module__` attribute of the new class is set to the first part "
"(up to the last dot) of the *name* argument, and the class name is set to "
"the last part (after the last dot).  The *base* argument can be used to "
"specify alternate base classes; it can either be only one class or a tuple "
"of classes. The *dict* argument can be used to specify a dictionary of class "
"variables and methods."
msgstr ""
"新類的 :attr:`__module__` 屬性設定為 *name* 參數的第一部分（到最後一個點），"
"類名設定為最後部分（最後一個點之後）。 *base* 參數可用於指定備用基底類別；它"
"可以只是一個類，也可以是類的元組。 *dict* 參數可用於指定類變數和方法的字典。"

#: ../../c-api/exceptions.rst:653
#, fuzzy
msgid ""
"Same as :c:func:`PyErr_NewException`, except that the new exception class "
"can easily be given a docstring: If *doc* is non-``NULL``, it will be used "
"as the docstring for the exception class."
msgstr ""
"與:c:func:`PyErr_NewException` 相同，除了新的例外類可以很容易地被賦予一個文檔"
"字串：如果 *doc* 是非``NULL``，它將被用作例外類的文檔字串。"

#: ../../c-api/exceptions.rst:661
msgid "Exception Objects"
msgstr "例外物件"

#: ../../c-api/exceptions.rst:665
#, fuzzy
msgid ""
"Return the traceback associated with the exception as a new reference, as "
"accessible from Python through :attr:`__traceback__`.  If there is no "
"traceback associated, this returns ``NULL``."
msgstr ""
"將與例外關聯的回溯作為新引用回傳，可通過 :attr:`__traceback__` 從 Python 訪"
"問。如果沒有關聯的回溯，則回傳 ``NULL`` 。"

#: ../../c-api/exceptions.rst:672
#, fuzzy
msgid ""
"Set the traceback associated with the exception to *tb*.  Use ``Py_None`` to "
"clear it."
msgstr "將與例外關聯的回溯設定為 *tb*。使用 ``Py_None`` 清除它。"

#: ../../c-api/exceptions.rst:678
#, fuzzy
msgid ""
"Return the context (another exception instance during whose handling *ex* "
"was raised) associated with the exception as a new reference, as accessible "
"from Python through :attr:`__context__`.  If there is no context associated, "
"this returns ``NULL``."
msgstr ""
"將與例外關聯的上下文（在處理 *ex* 期間引發的另一個例外實例）作為新引用回傳，"
"可通過 :attr:`__context__` 從 Python 訪問。如果沒有關聯的上下文，則回傳 "
"``NULL`` 。"

#: ../../c-api/exceptions.rst:686
#, fuzzy
msgid ""
"Set the context associated with the exception to *ctx*.  Use ``NULL`` to "
"clear it.  There is no type check to make sure that *ctx* is an exception "
"instance. This steals a reference to *ctx*."
msgstr ""
"將與例外關聯的上下文設定為 *ctx*。使用 ``NULL`` 清除它。沒有型別檢查來確保 "
"*ctx* 是一個例外實例。這竊取了對 *ctx* 的引用。"

#: ../../c-api/exceptions.rst:693
#, fuzzy
msgid ""
"Return the cause (either an exception instance, or :const:`None`, set by "
"``raise ... from ...``) associated with the exception as a new reference, as "
"accessible from Python through :attr:`__cause__`."
msgstr ""
"回傳與例外關聯的原因（例外實例或 None，由 ``raise ... from ...`` 設定）作為新"
"引用，可從 Python 中通過 :attr: 訪問__原因__`。"

#: ../../c-api/exceptions.rst:700
#, fuzzy
msgid ""
"Set the cause associated with the exception to *cause*.  Use ``NULL`` to "
"clear it.  There is no type check to make sure that *cause* is either an "
"exception instance or :const:`None`.  This steals a reference to *cause*."
msgstr ""
"將與例外關聯的原因設定為 *cause*。使用 ``NULL`` 清除它。沒有型別檢查來確保 "
"*cause* 是例外實例或 :const:`None`。這竊取了對 *cause* 的引用。"

#: ../../c-api/exceptions.rst:704
#, fuzzy
msgid ""
":attr:`__suppress_context__` is implicitly set to ``True`` by this function."
msgstr ":attr:`__suppress_context__` 被這個函式隱式設定為 ``True``。"

#: ../../c-api/exceptions.rst:710
#, fuzzy
msgid "Unicode Exception Objects"
msgstr "Unicode 例外物件"

#: ../../c-api/exceptions.rst:712
#, fuzzy
msgid ""
"The following functions are used to create and modify Unicode exceptions "
"from C."
msgstr "以下函式用於建立和修改 C 中的 Unicode 例外。"

#: ../../c-api/exceptions.rst:716
#, fuzzy
msgid ""
"Create a :class:`UnicodeDecodeError` object with the attributes *encoding*, "
"*object*, *length*, *start*, *end* and *reason*. *encoding* and *reason* are "
"UTF-8 encoded strings."
msgstr ""
"使用屬性 *encoding*、*object*、*length*、*start*、*end* 和 *reason* 建立一"
"個 :class:`UnicodeDecodeError` 物件。 *encoding* 和 *reason* 是 UTF-8 編碼的"
"字串。"

#: ../../c-api/exceptions.rst:723
#, fuzzy
msgid "Return the *encoding* attribute of the given exception object."
msgstr "回傳給定例外物件的 *encoding* 屬性。"

#: ../../c-api/exceptions.rst:729
#, fuzzy
msgid "Return the *object* attribute of the given exception object."
msgstr "回傳給定例外物件的 *object* 屬性。"

#: ../../c-api/exceptions.rst:735
#, fuzzy
msgid ""
"Get the *start* attribute of the given exception object and place it into "
"*\\*start*.  *start* must not be ``NULL``.  Return ``0`` on success, ``-1`` "
"on failure."
msgstr ""
"獲取給定例外物件的 *start* 屬性並將其放入 *\\*start*。 *start* 不能為 "
"``NULL`` 。成功回傳 ``0``，失敗回傳 ``-1``。"

#: ../../c-api/exceptions.rst:743
#, fuzzy
msgid ""
"Set the *start* attribute of the given exception object to *start*.  Return "
"``0`` on success, ``-1`` on failure."
msgstr ""
"將給定例外物件的 *start* 屬性設定為 *start*。成功回傳 ``0``，失敗回傳 "
"``-1``。"

#: ../../c-api/exceptions.rst:750
#, fuzzy
msgid ""
"Get the *end* attribute of the given exception object and place it into "
"*\\*end*.  *end* must not be ``NULL``.  Return ``0`` on success, ``-1`` on "
"failure."
msgstr ""
"獲取給定例外物件的 *end* 屬性並將其放入 *\\*end*。 *end* 不能為 ``NULL`` 。成"
"功回傳 ``0``，失敗回傳 ``-1``。"

#: ../../c-api/exceptions.rst:758
#, fuzzy
msgid ""
"Set the *end* attribute of the given exception object to *end*.  Return "
"``0`` on success, ``-1`` on failure."
msgstr ""
"將給定例外物件的 *end* 屬性設定為 *end*。成功回傳 ``0``，失敗回傳 ``-1``。"

#: ../../c-api/exceptions.rst:765
#, fuzzy
msgid "Return the *reason* attribute of the given exception object."
msgstr "回傳給定例外物件的 *reason* 屬性。"

#: ../../c-api/exceptions.rst:771
#, fuzzy
msgid ""
"Set the *reason* attribute of the given exception object to *reason*.  "
"Return ``0`` on success, ``-1`` on failure."
msgstr ""
"將給定例外物件的 *reason* 屬性設定為 *reason*。成功回傳 ``0``，失敗回傳 "
"``-1``。"

#: ../../c-api/exceptions.rst:778
msgid "Recursion Control"
msgstr "遞迴控制"

#: ../../c-api/exceptions.rst:780
#, fuzzy
msgid ""
"These two functions provide a way to perform safe recursive calls at the C "
"level, both in the core and in extension modules.  They are needed if the "
"recursive code does not necessarily invoke Python code (which tracks its "
"recursion depth automatically). They are also not needed for *tp_call* "
"implementations because the :ref:`call protocol <call>` takes care of "
"recursion handling."
msgstr ""
"這兩個函式提供了一種在 C 級別執行安全遞迴呼叫的方法，包括在核心模組和擴充模組"
"中。如果遞迴程式碼不一定呼叫 Python 程式碼（自動跟踪其遞迴深度），則需要它"
"們。 *tp_call* 實作也不需要它們，因為 :ref:`call 協定 <call>` 負責遞迴處理。"

#: ../../c-api/exceptions.rst:789
#, fuzzy
msgid "Marks a point where a recursive C-level call is about to be performed."
msgstr "標記將要執行遞迴 C 級呼叫的點。"

#: ../../c-api/exceptions.rst:791
#, fuzzy
msgid ""
"If :const:`USE_STACKCHECK` is defined, this function checks if the OS stack "
"overflowed using :c:func:`PyOS_CheckStack`.  In this is the case, it sets a :"
"exc:`MemoryError` and returns a nonzero value."
msgstr ""
"如果定義了 :const:`USE_STACKCHECK`，則此函式使用:c:func:`PyOS_CheckStack` 檢"
"查操作系統堆疊是否溢出。在這種情況下，它會設定一個 MemoryError 並回傳一個非零"
"值。"

#: ../../c-api/exceptions.rst:795
#, fuzzy
msgid ""
"The function then checks if the recursion limit is reached.  If this is the "
"case, a :exc:`RecursionError` is set and a nonzero value is returned. "
"Otherwise, zero is returned."
msgstr ""
"然後該函式檢查是否達到遞迴限制。如果是這種情況，則會設定 RecursionError 並回"
"傳非零值。否則，回傳零。"

#: ../../c-api/exceptions.rst:799
#, fuzzy
msgid ""
"*where* should be a UTF-8 encoded string such as ``\" in instance check\"`` "
"to be concatenated to the :exc:`RecursionError` message caused by the "
"recursion depth limit."
msgstr ""
"*where* 應該是 UTF-8 編碼的字串，例如 ``\" in instance check\"`` 連接到由遞迴"
"深度限制引起的 RecursionError 消息。"

#: ../../c-api/exceptions.rst:803 ../../c-api/exceptions.rst:811
msgid "This function is now also available in the limited API."
msgstr "此功能現在也可在受限 API 中使用。"

#: ../../c-api/exceptions.rst:808
#, fuzzy
msgid ""
"Ends a :c:func:`Py_EnterRecursiveCall`.  Must be called once for each "
"*successful* invocation of :c:func:`Py_EnterRecursiveCall`."
msgstr ""
"結束一個 :c:func:`Py_EnterRecursiveCall`。每次*成功*呼叫 :c:func:"
"`Py_EnterRecursiveCall` 時必須呼叫一次。"

#: ../../c-api/exceptions.rst:814
#, fuzzy
msgid ""
"Properly implementing :c:member:`~PyTypeObject.tp_repr` for container types "
"requires special recursion handling.  In addition to protecting the stack, :"
"c:member:`~PyTypeObject.tp_repr` also needs to track objects to prevent "
"cycles.  The following two functions facilitate this functionality.  "
"Effectively, these are the C equivalent to :func:`reprlib.recursive_repr`."
msgstr ""
"為容器型別正確實施 :c:member:`~PyTypeObject.tp_repr` 需要特殊的遞迴處理。除了"
"保護堆疊，:c:member:`~PyTypeObject.tp_repr` 還需要跟踪對像以防止循環。以下兩"
"個函式有助於實作此功能。實際上，這些是等同於 :func:`reprlib.recursive_repr` "
"的 C 語言。"

#: ../../c-api/exceptions.rst:822
#, fuzzy
msgid ""
"Called at the beginning of the :c:member:`~PyTypeObject.tp_repr` "
"implementation to detect cycles."
msgstr "在 :c:member:`~PyTypeObject.tp_repr` 實作的開頭呼叫以檢測循環。"

#: ../../c-api/exceptions.rst:825
#, fuzzy
msgid ""
"If the object has already been processed, the function returns a positive "
"integer.  In that case the :c:member:`~PyTypeObject.tp_repr` implementation "
"should return a string object indicating a cycle.  As examples, :class:"
"`dict` objects return ``{...}`` and :class:`list` objects return ``[...]``."
msgstr ""
"如果對像已經被處理過，函式回傳一個正整數。在那種情況下，:c:member:"
"`~PyTypeObject.tp_repr` 實作應該回傳一個字串物件來指示一個循環。例如，:class:"
"`dict` 物件回傳 ``{...}`` 和 :class:`list` 物件回傳 ``[...]``。"

#: ../../c-api/exceptions.rst:831
#, fuzzy
msgid ""
"The function will return a negative integer if the recursion limit is "
"reached.  In that case the :c:member:`~PyTypeObject.tp_repr` implementation "
"should typically return ``NULL``."
msgstr ""
"如果達到遞迴限制，該函式將回傳一個負整數。在那種情況下，:c:member:"
"`~PyTypeObject.tp_repr` 實作通常應該回傳 ``NULL``。"

#: ../../c-api/exceptions.rst:835
#, fuzzy
msgid ""
"Otherwise, the function returns zero and the :c:member:`~PyTypeObject."
"tp_repr` implementation can continue normally."
msgstr ""
"否則，該函式回傳零並且 :c:member:`~PyTypeObject.tp_repr` 實作可以正常繼續。"

#: ../../c-api/exceptions.rst:840
#, fuzzy
msgid ""
"Ends a :c:func:`Py_ReprEnter`.  Must be called once for each invocation of :"
"c:func:`Py_ReprEnter` that returns zero."
msgstr ""
"結束一個 :c:function:`Py_ReprEnter`。每次呼叫回傳零的 Py_ReprEnter 都必須呼叫"
"一次。"

#: ../../c-api/exceptions.rst:847
msgid "Standard Exceptions"
msgstr "標準例外"

#: ../../c-api/exceptions.rst:849
#, fuzzy
msgid ""
"All standard Python exceptions are available as global variables whose names "
"are ``PyExc_`` followed by the Python exception name.  These have the type :"
"c:expr:`PyObject*`; they are all class objects.  For completeness, here are "
"all the variables:"
msgstr ""
"所有標準 Python 例外都可以作為全局變數使用，其名稱為“PyExc_”後跟 Python 例外"
"名稱。它們的型別是 :c:expr:`PyObject*`;它們都是類物件。為了完整起見，這裡是所"
"有變數："

#: ../../c-api/exceptions.rst:910 ../../c-api/exceptions.rst:1043
#: ../../c-api/exceptions.rst:1088
msgid "C Name"
msgstr "C 名稱"

#: ../../c-api/exceptions.rst:910 ../../c-api/exceptions.rst:1088
msgid "Python Name"
msgstr "Python 名稱"

#: ../../c-api/exceptions.rst:910 ../../c-api/exceptions.rst:1043
#: ../../c-api/exceptions.rst:1088
msgid "Notes"
msgstr "註解"

#: ../../c-api/exceptions.rst:912
msgid ":c:data:`PyExc_BaseException`"
msgstr ":c:data:`PyExc_BaseException`"

#: ../../c-api/exceptions.rst:912
msgid ":exc:`BaseException`"
msgstr ":exc:`BaseException`"

#: ../../c-api/exceptions.rst:912 ../../c-api/exceptions.rst:914
#: ../../c-api/exceptions.rst:916 ../../c-api/exceptions.rst:962
#: ../../c-api/exceptions.rst:974
msgid "[1]_"
msgstr "[1]_"

#: ../../c-api/exceptions.rst:914
msgid ":c:data:`PyExc_Exception`"
msgstr ":c:data:`PyExc_Exception`"

#: ../../c-api/exceptions.rst:914
msgid ":exc:`Exception`"
msgstr ":exc:`Exception`"

#: ../../c-api/exceptions.rst:916
msgid ":c:data:`PyExc_ArithmeticError`"
msgstr ":c:data:`PyExc_ArithmeticError`"

#: ../../c-api/exceptions.rst:916
msgid ":exc:`ArithmeticError`"
msgstr ":exc:`ArithmeticError`"

#: ../../c-api/exceptions.rst:918
msgid ":c:data:`PyExc_AssertionError`"
msgstr ":c:data:`PyExc_AssertionError`"

#: ../../c-api/exceptions.rst:918
msgid ":exc:`AssertionError`"
msgstr ":exc:`AssertionError`"

#: ../../c-api/exceptions.rst:920
msgid ":c:data:`PyExc_AttributeError`"
msgstr ":c:data:`PyExc_AttributeError`"

#: ../../c-api/exceptions.rst:920
msgid ":exc:`AttributeError`"
msgstr ":exc:`AttributeError`"

#: ../../c-api/exceptions.rst:922
msgid ":c:data:`PyExc_BlockingIOError`"
msgstr ":c:data:`PyExc_BlockingIOError`"

#: ../../c-api/exceptions.rst:922
msgid ":exc:`BlockingIOError`"
msgstr ":exc:`BlockingIOError`"

#: ../../c-api/exceptions.rst:924
msgid ":c:data:`PyExc_BrokenPipeError`"
msgstr ":c:data:`PyExc_BrokenPipeError`"

#: ../../c-api/exceptions.rst:924
msgid ":exc:`BrokenPipeError`"
msgstr ":exc:`BrokenPipeError`"

#: ../../c-api/exceptions.rst:926
msgid ":c:data:`PyExc_BufferError`"
msgstr ":c:data:`PyExc_BufferError`"

#: ../../c-api/exceptions.rst:926
msgid ":exc:`BufferError`"
msgstr ":exc:`BufferError`"

#: ../../c-api/exceptions.rst:928
msgid ":c:data:`PyExc_ChildProcessError`"
msgstr ":c:data:`PyExc_ChildProcessError`"

#: ../../c-api/exceptions.rst:928
msgid ":exc:`ChildProcessError`"
msgstr ":exc:`ChildProcessError`"

#: ../../c-api/exceptions.rst:930
msgid ":c:data:`PyExc_ConnectionAbortedError`"
msgstr ":c:data:`PyExc_ConnectionAbortedError`"

#: ../../c-api/exceptions.rst:930
msgid ":exc:`ConnectionAbortedError`"
msgstr ":exc:`ConnectionAbortedError`"

#: ../../c-api/exceptions.rst:932
msgid ":c:data:`PyExc_ConnectionError`"
msgstr ":c:data:`PyExc_ConnectionError`"

#: ../../c-api/exceptions.rst:932
msgid ":exc:`ConnectionError`"
msgstr ":exc:`ConnectionError`"

#: ../../c-api/exceptions.rst:934
msgid ":c:data:`PyExc_ConnectionRefusedError`"
msgstr ":c:data:`PyExc_ConnectionRefusedError`"

#: ../../c-api/exceptions.rst:934
msgid ":exc:`ConnectionRefusedError`"
msgstr ":exc:`ConnectionRefusedError`"

#: ../../c-api/exceptions.rst:936
msgid ":c:data:`PyExc_ConnectionResetError`"
msgstr ":c:data:`PyExc_ConnectionResetError`"

#: ../../c-api/exceptions.rst:936
msgid ":exc:`ConnectionResetError`"
msgstr ":exc:`ConnectionResetError`"

#: ../../c-api/exceptions.rst:938
msgid ":c:data:`PyExc_EOFError`"
msgstr ":c:data:`PyExc_EOFError`"

#: ../../c-api/exceptions.rst:938
msgid ":exc:`EOFError`"
msgstr ":exc:`EOFError`"

#: ../../c-api/exceptions.rst:940
msgid ":c:data:`PyExc_FileExistsError`"
msgstr ":c:data:`PyExc_FileExistsError`"

#: ../../c-api/exceptions.rst:940
msgid ":exc:`FileExistsError`"
msgstr ":exc:`FileExistsError`"

#: ../../c-api/exceptions.rst:942
msgid ":c:data:`PyExc_FileNotFoundError`"
msgstr ":c:data:`PyExc_FileNotFoundError`"

#: ../../c-api/exceptions.rst:942
msgid ":exc:`FileNotFoundError`"
msgstr ":exc:`FileNotFoundError`"

#: ../../c-api/exceptions.rst:944
msgid ":c:data:`PyExc_FloatingPointError`"
msgstr ":c:data:`PyExc_FloatingPointError`"

#: ../../c-api/exceptions.rst:944
msgid ":exc:`FloatingPointError`"
msgstr ":exc:`FloatingPointError`"

#: ../../c-api/exceptions.rst:946
msgid ":c:data:`PyExc_GeneratorExit`"
msgstr ":c:data:`PyExc_GeneratorExit`"

#: ../../c-api/exceptions.rst:946
msgid ":exc:`GeneratorExit`"
msgstr ":exc:`GeneratorExit`"

#: ../../c-api/exceptions.rst:948
msgid ":c:data:`PyExc_ImportError`"
msgstr ":c:data:`PyExc_ImportError`"

#: ../../c-api/exceptions.rst:948
msgid ":exc:`ImportError`"
msgstr ":exc:`ImportError`"

#: ../../c-api/exceptions.rst:950
msgid ":c:data:`PyExc_IndentationError`"
msgstr ":c:data:`PyExc_IndentationError`"

#: ../../c-api/exceptions.rst:950
msgid ":exc:`IndentationError`"
msgstr ":exc:`IndentationError`"

#: ../../c-api/exceptions.rst:952
msgid ":c:data:`PyExc_IndexError`"
msgstr ":c:data:`PyExc_IndexError`"

#: ../../c-api/exceptions.rst:952
msgid ":exc:`IndexError`"
msgstr ":exc:`IndexError`"

#: ../../c-api/exceptions.rst:954
msgid ":c:data:`PyExc_InterruptedError`"
msgstr ":c:data:`PyExc_InterruptedError`"

#: ../../c-api/exceptions.rst:954
msgid ":exc:`InterruptedError`"
msgstr ":exc:`InterruptedError`"

#: ../../c-api/exceptions.rst:956
msgid ":c:data:`PyExc_IsADirectoryError`"
msgstr ":c:data:`PyExc_IsADirectoryError`"

#: ../../c-api/exceptions.rst:956
msgid ":exc:`IsADirectoryError`"
msgstr ":exc:`IsADirectoryError`"

#: ../../c-api/exceptions.rst:958
msgid ":c:data:`PyExc_KeyError`"
msgstr ":c:data:`PyExc_KeyError`"

#: ../../c-api/exceptions.rst:958
msgid ":exc:`KeyError`"
msgstr ":exc:`KeyError`"

#: ../../c-api/exceptions.rst:960
msgid ":c:data:`PyExc_KeyboardInterrupt`"
msgstr ":c:data:`PyExc_KeyboardInterrupt`"

#: ../../c-api/exceptions.rst:960
msgid ":exc:`KeyboardInterrupt`"
msgstr ":exc:`KeyboardInterrupt`"

#: ../../c-api/exceptions.rst:962
msgid ":c:data:`PyExc_LookupError`"
msgstr ":c:data:`PyExc_LookupError`"

#: ../../c-api/exceptions.rst:962
msgid ":exc:`LookupError`"
msgstr ":exc:`LookupError`"

#: ../../c-api/exceptions.rst:964
msgid ":c:data:`PyExc_MemoryError`"
msgstr ":c:data:`PyExc_MemoryError`"

#: ../../c-api/exceptions.rst:964
msgid ":exc:`MemoryError`"
msgstr ":exc:`MemoryError`"

#: ../../c-api/exceptions.rst:966
msgid ":c:data:`PyExc_ModuleNotFoundError`"
msgstr ":c:data:`PyExc_ModuleNotFoundError`"

#: ../../c-api/exceptions.rst:966
msgid ":exc:`ModuleNotFoundError`"
msgstr ":exc:`ModuleNotFoundError`"

#: ../../c-api/exceptions.rst:968
msgid ":c:data:`PyExc_NameError`"
msgstr ":c:data:`PyExc_NameError`"

#: ../../c-api/exceptions.rst:968
msgid ":exc:`NameError`"
msgstr ":exc:`NameError`"

#: ../../c-api/exceptions.rst:970
msgid ":c:data:`PyExc_NotADirectoryError`"
msgstr ":c:data:`PyExc_NotADirectoryError`"

#: ../../c-api/exceptions.rst:970
msgid ":exc:`NotADirectoryError`"
msgstr ":exc:`NotADirectoryError`"

#: ../../c-api/exceptions.rst:972
msgid ":c:data:`PyExc_NotImplementedError`"
msgstr ":c:data:`PyExc_NotImplementedError`"

#: ../../c-api/exceptions.rst:972
msgid ":exc:`NotImplementedError`"
msgstr ":exc:`NotImplementedError`"

#: ../../c-api/exceptions.rst:974
msgid ":c:data:`PyExc_OSError`"
msgstr ":c:data:`PyExc_OSError`"

#: ../../c-api/exceptions.rst:974
msgid ":exc:`OSError`"
msgstr ":exc:`OSError`"

#: ../../c-api/exceptions.rst:976
msgid ":c:data:`PyExc_OverflowError`"
msgstr ":c:data:`PyExc_OverflowError`"

#: ../../c-api/exceptions.rst:976
msgid ":exc:`OverflowError`"
msgstr ":exc:`OverflowError`"

#: ../../c-api/exceptions.rst:978
msgid ":c:data:`PyExc_PermissionError`"
msgstr ":c:data:`PyExc_PermissionError`"

#: ../../c-api/exceptions.rst:978
msgid ":exc:`PermissionError`"
msgstr ":exc:`PermissionError`"

#: ../../c-api/exceptions.rst:980
msgid ":c:data:`PyExc_ProcessLookupError`"
msgstr ":c:data:`PyExc_ProcessLookupError`"

#: ../../c-api/exceptions.rst:980
msgid ":exc:`ProcessLookupError`"
msgstr ":exc:`ProcessLookupError`"

#: ../../c-api/exceptions.rst:982
msgid ":c:data:`PyExc_RecursionError`"
msgstr ":c:data:`PyExc_RecursionError`"

#: ../../c-api/exceptions.rst:982
msgid ":exc:`RecursionError`"
msgstr ":exc:`RecursionError`"

#: ../../c-api/exceptions.rst:984
msgid ":c:data:`PyExc_ReferenceError`"
msgstr ":c:data:`PyExc_ReferenceError`"

#: ../../c-api/exceptions.rst:984
msgid ":exc:`ReferenceError`"
msgstr ":exc:`ReferenceError`"

#: ../../c-api/exceptions.rst:986
msgid ":c:data:`PyExc_RuntimeError`"
msgstr ":c:data:`PyExc_RuntimeError`"

#: ../../c-api/exceptions.rst:986
msgid ":exc:`RuntimeError`"
msgstr ":exc:`RuntimeError`"

#: ../../c-api/exceptions.rst:988
msgid ":c:data:`PyExc_StopAsyncIteration`"
msgstr ":c:data:`PyExc_StopAsyncIteration`"

#: ../../c-api/exceptions.rst:988
msgid ":exc:`StopAsyncIteration`"
msgstr ":exc:`StopAsyncIteration`"

#: ../../c-api/exceptions.rst:990
msgid ":c:data:`PyExc_StopIteration`"
msgstr ":c:data:`PyExc_StopIteration`"

#: ../../c-api/exceptions.rst:990
msgid ":exc:`StopIteration`"
msgstr ":exc:`StopIteration`"

#: ../../c-api/exceptions.rst:992
msgid ":c:data:`PyExc_SyntaxError`"
msgstr ":c:data:`PyExc_SyntaxError`"

#: ../../c-api/exceptions.rst:992
msgid ":exc:`SyntaxError`"
msgstr ":exc:`SyntaxError`"

#: ../../c-api/exceptions.rst:994
msgid ":c:data:`PyExc_SystemError`"
msgstr ":c:data:`PyExc_SystemError`"

#: ../../c-api/exceptions.rst:994
msgid ":exc:`SystemError`"
msgstr ":exc:`SystemError`"

#: ../../c-api/exceptions.rst:996
msgid ":c:data:`PyExc_SystemExit`"
msgstr ":c:data:`PyExc_SystemExit`"

#: ../../c-api/exceptions.rst:996
msgid ":exc:`SystemExit`"
msgstr ":exc:`SystemExit`"

#: ../../c-api/exceptions.rst:998
msgid ":c:data:`PyExc_TabError`"
msgstr ":c:data:`PyExc_TabError`"

#: ../../c-api/exceptions.rst:998
msgid ":exc:`TabError`"
msgstr ":exc:`TabError`"

#: ../../c-api/exceptions.rst:1000
msgid ":c:data:`PyExc_TimeoutError`"
msgstr ":c:data:`PyExc_TimeoutError`"

#: ../../c-api/exceptions.rst:1000
msgid ":exc:`TimeoutError`"
msgstr ":exc:`TimeoutError`"

#: ../../c-api/exceptions.rst:1002
msgid ":c:data:`PyExc_TypeError`"
msgstr ":c:data:`PyExc_TypeError`"

#: ../../c-api/exceptions.rst:1002
msgid ":exc:`TypeError`"
msgstr ":exc:`TypeError`"

#: ../../c-api/exceptions.rst:1004
msgid ":c:data:`PyExc_UnboundLocalError`"
msgstr ":c:data:`PyExc_UnboundLocalError`"

#: ../../c-api/exceptions.rst:1004
msgid ":exc:`UnboundLocalError`"
msgstr ":exc:`UnboundLocalError`"

#: ../../c-api/exceptions.rst:1006
msgid ":c:data:`PyExc_UnicodeDecodeError`"
msgstr ":c:data:`PyExc_UnicodeDecodeError`"

#: ../../c-api/exceptions.rst:1006
msgid ":exc:`UnicodeDecodeError`"
msgstr ":exc:`UnicodeDecodeError`"

#: ../../c-api/exceptions.rst:1008
msgid ":c:data:`PyExc_UnicodeEncodeError`"
msgstr ":c:data:`PyExc_UnicodeEncodeError`"

#: ../../c-api/exceptions.rst:1008
msgid ":exc:`UnicodeEncodeError`"
msgstr ":exc:`UnicodeEncodeError`"

#: ../../c-api/exceptions.rst:1010
msgid ":c:data:`PyExc_UnicodeError`"
msgstr ":c:data:`PyExc_UnicodeError`"

#: ../../c-api/exceptions.rst:1010
msgid ":exc:`UnicodeError`"
msgstr ":exc:`UnicodeError`"

#: ../../c-api/exceptions.rst:1012
msgid ":c:data:`PyExc_UnicodeTranslateError`"
msgstr ":c:data:`PyExc_UnicodeTranslateError`"

#: ../../c-api/exceptions.rst:1012
msgid ":exc:`UnicodeTranslateError`"
msgstr ":exc:`UnicodeTranslateError`"

#: ../../c-api/exceptions.rst:1014
msgid ":c:data:`PyExc_ValueError`"
msgstr ":c:data:`PyExc_ValueError`"

#: ../../c-api/exceptions.rst:1014
msgid ":exc:`ValueError`"
msgstr ":exc:`ValueError`"

#: ../../c-api/exceptions.rst:1016
msgid ":c:data:`PyExc_ZeroDivisionError`"
msgstr ":c:data:`PyExc_ZeroDivisionError`"

#: ../../c-api/exceptions.rst:1016
msgid ":exc:`ZeroDivisionError`"
msgstr ":exc:`ZeroDivisionError`"

#: ../../c-api/exceptions.rst:1019
msgid ""
":c:data:`PyExc_BlockingIOError`, :c:data:`PyExc_BrokenPipeError`, :c:data:"
"`PyExc_ChildProcessError`, :c:data:`PyExc_ConnectionError`, :c:data:"
"`PyExc_ConnectionAbortedError`, :c:data:`PyExc_ConnectionRefusedError`, :c:"
"data:`PyExc_ConnectionResetError`, :c:data:`PyExc_FileExistsError`, :c:data:"
"`PyExc_FileNotFoundError`, :c:data:`PyExc_InterruptedError`, :c:data:"
"`PyExc_IsADirectoryError`, :c:data:`PyExc_NotADirectoryError`, :c:data:"
"`PyExc_PermissionError`, :c:data:`PyExc_ProcessLookupError` and :c:data:"
"`PyExc_TimeoutError` were introduced following :pep:`3151`."
msgstr ""
":c:data:`PyExc_BlockingIOError`, :c:data:`PyExc_BrokenPipeError`, :c:data:"
"`PyExc_ChildProcessError`, :c:data:`PyExc_ConnectionError`, :c:data:"
"`PyExc_ConnectionAbortedError`, :c:data:`PyExc_ConnectionRefusedError`, :c:"
"data:`PyExc_ConnectionResetError`, :c:data:`PyExc_FileExistsError`, :c:data:"
"`PyExc_FileNotFoundError`, :c:data:`PyExc_InterruptedError`, :c:data:"
"`PyExc_IsADirectoryError`, :c:data:`PyExc_NotADirectoryError`, :c:data:"
"`PyExc_PermissionError`, :c:data:`PyExc_ProcessLookupError` 和 :c:data:"
"`PyExc_TimeoutError` 是在 :pep:`3151` 被引入。"

#: ../../c-api/exceptions.rst:1029
msgid ":c:data:`PyExc_StopAsyncIteration` and :c:data:`PyExc_RecursionError`."
msgstr ""
":c:data:`PyExc_StopAsyncIteration` 和 :c:data:`PyExc_RecursionError`\\ 。"

#: ../../c-api/exceptions.rst:1032
msgid ":c:data:`PyExc_ModuleNotFoundError`."
msgstr ":c:data:`PyExc_ModuleNotFoundError`\\ 。"

#: ../../c-api/exceptions.rst:1035
#, fuzzy
msgid "These are compatibility aliases to :c:data:`PyExc_OSError`:"
msgstr "這些是 :c:data:`PyExc_OSError` 的相容性別名："

#: ../../c-api/exceptions.rst:1045
msgid ":c:data:`PyExc_EnvironmentError`"
msgstr ":c:data:`PyExc_EnvironmentError`"

#: ../../c-api/exceptions.rst:1047
msgid ":c:data:`PyExc_IOError`"
msgstr ":c:data:`PyExc_IOError`"

#: ../../c-api/exceptions.rst:1049
msgid ":c:data:`PyExc_WindowsError`"
msgstr ":c:data:`PyExc_WindowsError`"

#: ../../c-api/exceptions.rst:1049
msgid "[2]_"
msgstr "[2]_"

#: ../../c-api/exceptions.rst:1052
#, fuzzy
msgid "These aliases used to be separate exception types."
msgstr "這些別名曾經是單獨的例外型別。"

#: ../../c-api/exceptions.rst:1055 ../../c-api/exceptions.rst:1116
msgid "Notes:"
msgstr "註解："

#: ../../c-api/exceptions.rst:1058
#, fuzzy
msgid "This is a base class for other standard exceptions."
msgstr "這是其他標準例外的基底類別。"

#: ../../c-api/exceptions.rst:1061
#, fuzzy
msgid ""
"Only defined on Windows; protect code that uses this by testing that the "
"preprocessor macro ``MS_WINDOWS`` is defined."
msgstr ""
"僅在 Windows 上定義；通過測試是否定義了預處理器巨集“MS_WINDOWS”來保護使用它的"
"程式碼。"

#: ../../c-api/exceptions.rst:1067
#, fuzzy
msgid "Standard Warning Categories"
msgstr "標準警告類別"

#: ../../c-api/exceptions.rst:1069
#, fuzzy
msgid ""
"All standard Python warning categories are available as global variables "
"whose names are ``PyExc_`` followed by the Python exception name. These have "
"the type :c:expr:`PyObject*`; they are all class objects. For completeness, "
"here are all the variables:"
msgstr ""
"所有標準的 Python 警告類別都可以作為全局變數使用，其名稱為“PyExc_”後跟 "
"Python 例外名稱。它們的型別是 :c:expr:`PyObject*`;它們都是類物件。為了完整起"
"見，這裡是所有變數："

#: ../../c-api/exceptions.rst:1090
msgid ":c:data:`PyExc_Warning`"
msgstr ":c:data:`PyExc_Warning`"

#: ../../c-api/exceptions.rst:1090
msgid ":exc:`Warning`"
msgstr ":exc:`Warning`"

#: ../../c-api/exceptions.rst:1090
msgid "[3]_"
msgstr "[3]_"

#: ../../c-api/exceptions.rst:1092
msgid ":c:data:`PyExc_BytesWarning`"
msgstr ":c:data:`PyExc_BytesWarning`"

#: ../../c-api/exceptions.rst:1092
msgid ":exc:`BytesWarning`"
msgstr ":exc:`BytesWarning`"

#: ../../c-api/exceptions.rst:1094
msgid ":c:data:`PyExc_DeprecationWarning`"
msgstr ":c:data:`PyExc_DeprecationWarning`"

#: ../../c-api/exceptions.rst:1094
msgid ":exc:`DeprecationWarning`"
msgstr ":exc:`DeprecationWarning`"

#: ../../c-api/exceptions.rst:1096
msgid ":c:data:`PyExc_FutureWarning`"
msgstr ":c:data:`PyExc_FutureWarning`"

#: ../../c-api/exceptions.rst:1096
msgid ":exc:`FutureWarning`"
msgstr ":exc:`FutureWarning`"

#: ../../c-api/exceptions.rst:1098
msgid ":c:data:`PyExc_ImportWarning`"
msgstr ":c:data:`PyExc_ImportWarning`"

#: ../../c-api/exceptions.rst:1098
msgid ":exc:`ImportWarning`"
msgstr ":exc:`ImportWarning`"

#: ../../c-api/exceptions.rst:1100
msgid ":c:data:`PyExc_PendingDeprecationWarning`"
msgstr ":c:data:`PyExc_PendingDeprecationWarning`"

#: ../../c-api/exceptions.rst:1100
msgid ":exc:`PendingDeprecationWarning`"
msgstr ":exc:`PendingDeprecationWarning`"

#: ../../c-api/exceptions.rst:1102
msgid ":c:data:`PyExc_ResourceWarning`"
msgstr ":c:data:`PyExc_ResourceWarning`"

#: ../../c-api/exceptions.rst:1102
msgid ":exc:`ResourceWarning`"
msgstr ":exc:`ResourceWarning`"

#: ../../c-api/exceptions.rst:1104
msgid ":c:data:`PyExc_RuntimeWarning`"
msgstr ":c:data:`PyExc_RuntimeWarning`"

#: ../../c-api/exceptions.rst:1104
msgid ":exc:`RuntimeWarning`"
msgstr ":exc:`RuntimeWarning`"

#: ../../c-api/exceptions.rst:1106
msgid ":c:data:`PyExc_SyntaxWarning`"
msgstr ":c:data:`PyExc_SyntaxWarning`"

#: ../../c-api/exceptions.rst:1106
msgid ":exc:`SyntaxWarning`"
msgstr ":exc:`SyntaxWarning`"

#: ../../c-api/exceptions.rst:1108
msgid ":c:data:`PyExc_UnicodeWarning`"
msgstr ":c:data:`PyExc_UnicodeWarning`"

#: ../../c-api/exceptions.rst:1108
msgid ":exc:`UnicodeWarning`"
msgstr ":exc:`UnicodeWarning`"

#: ../../c-api/exceptions.rst:1110
msgid ":c:data:`PyExc_UserWarning`"
msgstr ":c:data:`PyExc_UserWarning`"

#: ../../c-api/exceptions.rst:1110
msgid ":exc:`UserWarning`"
msgstr ":exc:`UserWarning`"

#: ../../c-api/exceptions.rst:1113
msgid ":c:data:`PyExc_ResourceWarning`."
msgstr ":c:data:`PyExc_ResourceWarning`."

#: ../../c-api/exceptions.rst:1119
#, fuzzy
msgid "This is a base class for other standard warning categories."
msgstr "這是其他標準警告種類的基底類別。"
