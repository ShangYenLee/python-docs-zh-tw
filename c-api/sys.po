# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Ching-Lung Chuang, 2015
# Leon H., 2017
# Liang-Bo Wang <me@liang2.tw>, 2015
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-24 00:16+0000\n"
"PO-Revision-Date: 2023-05-02 17:19+0800\n"
"Last-Translator: Matt Wang <mattwang44@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../c-api/sys.rst:6
msgid "Operating System Utilities"
msgstr "作業系統工具"

#: ../../c-api/sys.rst:10
#, fuzzy
msgid ""
"Return the file system representation for *path*. If the object is a :class:"
"`str` or :class:`bytes` object, then its reference count is incremented. If "
"the object implements the :class:`os.PathLike` interface, then :meth:`~os."
"PathLike.__fspath__` is returned as long as it is a :class:`str` or :class:"
"`bytes` object. Otherwise :exc:`TypeError` is raised and ``NULL`` is "
"returned."
msgstr ""
"回傳 *path* 的文件系統表示。如果對像是 :class:`str` 或 :class:`bytes` 物件，"
"則其引用計數會增加。如果物件實作了 os.PathLike 介面，那麼只要它是 str 或 "
"bytes 物件，就會回傳 ~os.PathLike.__fspath__ 。否則會引發 TypeError 並回傳 "
"NULL。"

#: ../../c-api/sys.rst:22
#, fuzzy
msgid ""
"Return true (nonzero) if the standard I/O file *fp* with name *filename* is "
"deemed interactive.  This is the case for files for which "
"``isatty(fileno(fp))`` is true.  If the global flag :c:data:"
"`Py_InteractiveFlag` is true, this function also returns true if the "
"*filename* pointer is ``NULL`` or if the name is equal to one of the strings "
"``'<stdin>'`` or ``'???'``."
msgstr ""
"如果名稱為 *filename* 的標準 I/O 文件 *fp* 被認為是交互式的，則回傳真（非"
"零）。這是 ``isatty(fileno(fp))`` 為真的文件的情況。如果全局旗標 :c:data:"
"`Py_InteractiveFlag` 為真，如果 *filename* 指標為 ``NULL`` 或者名稱等於字串之"
"一 ``'<stdin>'，此函式也回傳 true `` 或 ``'???'``。"

#: ../../c-api/sys.rst:31
#, fuzzy
msgid ""
"Function to prepare some internal state before a process fork.  This should "
"be called before calling :c:func:`fork` or any similar function that clones "
"the current process. Only available on systems where :c:func:`fork` is "
"defined."
msgstr ""
"在行程分叉之前準備一些內部狀態的函式。這應該在呼叫 :c:func:`fork` 或克隆當前"
"行程的任何類似函式之前呼叫。僅在定義了 :c:func:`fork` 的系統上可用。"

#: ../../c-api/sys.rst:37
#, fuzzy
msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" thread "
"<fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-interpreter-"
"support>`).  The same is true for ``PyOS_BeforeFork()``."
msgstr ""
"C :c:func:`fork` 呼叫只能從 :ref:`\"main\" thread <fork-and-threads>`（屬於 :"
"ref:`\"main\" 直譯器 <sub-interpreter-support >`). ``PyOS_BeforeFork()`` 也是"
"如此。"

#: ../../c-api/sys.rst:47
#, fuzzy
msgid ""
"Function to update some internal state after a process fork.  This should be "
"called from the parent process after calling :c:func:`fork` or any similar "
"function that clones the current process, regardless of whether process "
"cloning was successful. Only available on systems where :c:func:`fork` is "
"defined."
msgstr ""
"在行程分叉後更新某些內部狀態的函式。這應該在呼叫 :c:func:`fork` 或克隆當前行"
"程的任何類似函式之後從父行程呼叫，無論行程克隆是否成功。僅在定義了 :c:func:"
"`fork` 的系統上可用。"

#: ../../c-api/sys.rst:54
#, fuzzy
msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" thread "
"<fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-interpreter-"
"support>`).  The same is true for ``PyOS_AfterFork_Parent()``."
msgstr ""
"C :c:func:`fork` 呼叫只能從 :ref:`\"main\" thread <fork-and-threads>`（屬於 :"
"ref:`\"main\" 直譯器 <sub-interpreter-support >`). "
"``PyOS_AfterFork_Parent()`` 也是如此。"

#: ../../c-api/sys.rst:64
#, fuzzy
msgid ""
"Function to update internal interpreter state after a process fork. This "
"must be called from the child process after calling :c:func:`fork`, or any "
"similar function that clones the current process, if there is any chance the "
"process will call back into the Python interpreter. Only available on "
"systems where :c:func:`fork` is defined."
msgstr ""
"在行程分叉後更新內部直譯器狀態的函式。這必須在呼叫 :c:func:`fork` 或克隆當前"
"行程的任何類似函式之後從子行程呼叫，如果行程有任何機會回呼 Python 直譯器。僅"
"在定義了 :c:func:`fork` 的系統上可用。"

#: ../../c-api/sys.rst:71
#, fuzzy
msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" thread "
"<fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-interpreter-"
"support>`).  The same is true for ``PyOS_AfterFork_Child()``."
msgstr ""
"C :c:func:`fork` 呼叫只能從 :ref:`\"main\" thread <fork-and-threads>`（屬於 :"
"ref:`\"main\" 直譯器 <sub-interpreter-support >`). "
"``PyOS_AfterFork_Child()`` 也是如此。"

#: ../../c-api/sys.rst:79
#, fuzzy
msgid ""
":func:`os.register_at_fork` allows registering custom Python functions to be "
"called by :c:func:`PyOS_BeforeFork()`, :c:func:`PyOS_AfterFork_Parent` and  :"
"c:func:`PyOS_AfterFork_Child`."
msgstr ""
":func:`os.register_at_fork` 允許註冊由 :c:func:`PyOS_BeforeFork()`、:c:func:"
"`PyOS_AfterFork_Parent` 和 :c:func:`PyOS_AfterFork_Child` 呼叫的自定義 "
"Python 函式。"

#: ../../c-api/sys.rst:86
#, fuzzy
msgid ""
"Function to update some internal state after a process fork; this should be "
"called in the new process if the Python interpreter will continue to be "
"used. If a new executable is loaded into the new process, this function does "
"not need to be called."
msgstr ""
"在行程分叉後更新一些內部狀態的函式；如果將繼續使用 Python 直譯器，則應在新行"
"程中呼叫它。如果將新的可執行文件加載到新行程中，則不需要呼叫此函式。"

#: ../../c-api/sys.rst:91
#, fuzzy
msgid "This function is superseded by :c:func:`PyOS_AfterFork_Child()`."
msgstr "此函式已被 :c:func:`PyOS_AfterFork_Child()` 取代。"

#: ../../c-api/sys.rst:97
#, fuzzy
msgid ""
"Return true when the interpreter runs out of stack space.  This is a "
"reliable check, but is only available when :const:`USE_STACKCHECK` is "
"defined (currently on certain versions of Windows using the Microsoft Visual "
"C++ compiler). :const:`USE_STACKCHECK` will be defined automatically; you "
"should never change the definition in your own code."
msgstr ""
"當直譯器用完堆疊空間時回傳 true。這是一個可靠的檢查，但只有在定義了 :const:"
"`USE_STACKCHECK` 時才可用（目前在某些使用 Microsoft Visual C++ 編譯器的 "
"Windows 版本上）。 :const:`USE_STACKCHECK` 將被自動定義；你永遠不應該改變你自"
"己程式碼中的定義。"

#: ../../c-api/sys.rst:106
#, fuzzy
msgid ""
"Return the current signal handler for signal *i*.  This is a thin wrapper "
"around either :c:func:`sigaction` or :c:func:`signal`.  Do not call those "
"functions directly! :c:type:`PyOS_sighandler_t` is a typedef alias for :c:"
"expr:`void (\\*)(int)`."
msgstr ""
"回傳信號 *i* 的當前信號處理程式。這是 :c:func:`sigaction` 或 :c:func:"
"`signal` 的薄包裝。不要直接呼叫那些函式！ :c:type:`PyOS_sighandler_t` 是 :c:"
"expr:`void (\\*)(int)` 的 typedef 別名。"

#: ../../c-api/sys.rst:114
#, fuzzy
msgid ""
"Set the signal handler for signal *i* to be *h*; return the old signal "
"handler. This is a thin wrapper around either :c:func:`sigaction` or :c:func:"
"`signal`.  Do not call those functions directly!  :c:type:"
"`PyOS_sighandler_t` is a typedef alias for :c:expr:`void (\\*)(int)`."
msgstr ""
"將信號 *i* 的信號處理程式設定為 *h*；回傳舊的信號處理程式。這是 :c:func:"
"`sigaction` 或 :c:func:`signal` 的薄包裝。不要直接呼叫那些函式！ :c:type:"
"`PyOS_sighandler_t` 是 :c:expr:`void (\\*)(int)` 的 typedef 別名。"

#: ../../c-api/sys.rst:122
#, fuzzy
msgid ""
"This function should not be called directly: use the :c:type:`PyConfig` API "
"with the :c:func:`PyConfig_SetBytesString` function which ensures that :ref:"
"`Python is preinitialized <c-preinit>`."
msgstr ""
"不應直接呼叫此函式：使用 PyConfig API 和 PyConfig_SetBytesString 函式確保 "
"Python 被預初始化 <c-preinit>。"

#: ../../c-api/sys.rst:126 ../../c-api/sys.rst:193
#, fuzzy
msgid ""
"This function must not be called before :ref:`Python is preinitialized <c-"
"preinit>` and so that the LC_CTYPE locale is properly configured: see the :c:"
"func:`Py_PreInitialize` function."
msgstr ""
"在 :ref:`Python 被預初始化 <c-preinit>` 之前不得呼叫此函式，以便正確配置 "
"LC_CTYPE 語言環境：請參閱 :c:func:`Py_PreInitialize` 函式。"

#: ../../c-api/sys.rst:130
#, fuzzy
msgid ""
"Decode a byte string from the :term:`filesystem encoding and error handler`. "
"If the error handler is :ref:`surrogateescape error handler "
"<surrogateescape>`, undecodable bytes are decoded as characters in range "
"U+DC80..U+DCFF; and if a byte sequence can be decoded as a surrogate "
"character, the bytes are escaped using the surrogateescape error handler "
"instead of decoding them."
msgstr ""
"從 :term:`filesystem encoding and error handler` 解碼位元組字串。如果錯誤處理"
"程式是 :ref:`surrogateescape 錯誤處理程式 <surrogateescape>`，則不可解碼的位"
"元組將被解碼為 U+DC80..U+DCFF 範圍內的字元；如果一個位元組序列可以被解碼為代"
"理字元，則使用 surrogateescape 錯誤處理程式轉義位元組而不是解碼它們。"

#: ../../c-api/sys.rst:137
#, fuzzy
msgid ""
"Return a pointer to a newly allocated wide character string, use :c:func:"
"`PyMem_RawFree` to free the memory. If size is not ``NULL``, write the "
"number of wide characters excluding the null character into ``*size``"
msgstr ""
"回傳指向新分配的寬字串的指標，使用 :c:func:`PyMem_RawFree` 釋放記憶體。如果"
"size不為``NULL``，將除空字元外的寬字元數寫入``*size``"

#: ../../c-api/sys.rst:141
#, fuzzy
msgid ""
"Return ``NULL`` on decoding error or memory allocation error. If *size* is "
"not ``NULL``, ``*size`` is set to ``(size_t)-1`` on memory error or set to "
"``(size_t)-2`` on decoding error."
msgstr ""
"在解碼錯誤或記憶體分配錯誤時回傳 ``NULL`` 。如果 *size* 不是 ``NULL`` ，"
"則“*size”在記憶體錯誤時設定為“(size_t)-1”，在解碼錯誤時設定為“(size_t)-2”。"

#: ../../c-api/sys.rst:145 ../../c-api/sys.rst:185
#, fuzzy
msgid ""
"The :term:`filesystem encoding and error handler` are selected by :c:func:"
"`PyConfig_Read`: see :c:member:`~PyConfig.filesystem_encoding` and :c:member:"
"`~PyConfig.filesystem_errors` members of :c:type:`PyConfig`."
msgstr ""
":term:`文件系統編碼和錯誤處理程式` 由:c:func:`PyConfig_Read` 選擇：參見 :c:"
"member:`~PyConfig.filesystem_encoding` 和 :c:member:`~PyConfig."
"filesystem_errors` 的成員 :c:type:`PyConfig`。"

#: ../../c-api/sys.rst:149
#, fuzzy
msgid ""
"Decoding errors should never happen, unless there is a bug in the C library."
msgstr "解碼錯誤永遠不會發生，除非 C 庫中存在錯誤。"

#: ../../c-api/sys.rst:152
#, fuzzy
msgid ""
"Use the :c:func:`Py_EncodeLocale` function to encode the character string "
"back to a byte string."
msgstr "使用 :c:func:`Py_EncodeLocale` 函式將字串編碼回位元組字串。"

#: ../../c-api/sys.rst:157
#, fuzzy
msgid ""
"The :c:func:`PyUnicode_DecodeFSDefaultAndSize` and :c:func:"
"`PyUnicode_DecodeLocaleAndSize` functions."
msgstr ""
":c:func:`PyUnicode_DecodeFSDefaultAndSize` 和 :c:func:"
"`PyUnicode_DecodeLocaleAndSize` 函式。"

#: ../../c-api/sys.rst:162 ../../c-api/sys.rst:204
#, fuzzy
msgid ""
"The function now uses the UTF-8 encoding in the :ref:`Python UTF-8 Mode "
"<utf8-mode>`."
msgstr "該函式現在在 :ref:`Python UTF-8 模式 <utf8-mode>` 中使用 UTF-8 編碼。"

#: ../../c-api/sys.rst:166
#, fuzzy
msgid ""
"The function now uses the UTF-8 encoding on Windows if :c:data:"
"`Py_LegacyWindowsFSEncodingFlag` is zero;"
msgstr ""
"如果 Py_LegacyWindowsFSEncodingFlag 為零，該函式現在在 Windows 上使用 UTF-8 "
"編碼；"

#: ../../c-api/sys.rst:173
#, fuzzy
msgid ""
"Encode a wide character string to the :term:`filesystem encoding and error "
"handler`. If the error handler is :ref:`surrogateescape error handler "
"<surrogateescape>`, surrogate characters in the range U+DC80..U+DCFF are "
"converted to bytes 0x80..0xFF."
msgstr ""
"將寬字串編碼為 :term:`文件系統編碼和錯誤處理程式`。如果錯誤處理程式是 :ref:"
"`surrogateescape 錯誤處理程式 <surrogateescape>`，則 U+DC80..U+DCFF 範圍內的"
"代理項字元將轉換為位元組 0x80..0xFF。"

#: ../../c-api/sys.rst:178
#, fuzzy
msgid ""
"Return a pointer to a newly allocated byte string, use :c:func:`PyMem_Free` "
"to free the memory. Return ``NULL`` on encoding error or memory allocation "
"error."
msgstr ""
"回傳指向新分配的位元組字串的指標，使用 :c:func:`PyMem_Free` 釋放記憶體。在編"
"碼錯誤或記憶體分配錯誤時回傳 ``NULL`` 。"

#: ../../c-api/sys.rst:182
#, fuzzy
msgid ""
"If error_pos is not ``NULL``, ``*error_pos`` is set to ``(size_t)-1`` on "
"success,  or set to the index of the invalid character on encoding error."
msgstr ""
"如果 error_pos 不為 ``NULL`` ，則“*error_pos”在成功時設定為“(size_t)-1”，或在"
"編碼錯誤時設定為無效字元的索引。"

#: ../../c-api/sys.rst:189
#, fuzzy
msgid ""
"Use the :c:func:`Py_DecodeLocale` function to decode the bytes string back "
"to a wide character string."
msgstr "使用 :c:func:`Py_DecodeLocale` 函式將位元組字串解碼回寬字串。"

#: ../../c-api/sys.rst:199
#, fuzzy
msgid ""
"The :c:func:`PyUnicode_EncodeFSDefault` and :c:func:`PyUnicode_EncodeLocale` "
"functions."
msgstr ""
":c:func:`PyUnicode_EncodeFSDefault` 和 :c:func:`PyUnicode_EncodeLocale` 函"
"式。"

#: ../../c-api/sys.rst:208
#, fuzzy
msgid ""
"The function now uses the UTF-8 encoding on Windows if :c:data:"
"`Py_LegacyWindowsFSEncodingFlag` is zero."
msgstr ""
"如果 Py_LegacyWindowsFSEncodingFlag 為零，該函式現在在 Windows 上使用 UTF-8 "
"編碼。"

#: ../../c-api/sys.rst:216
msgid "System Functions"
msgstr "系統函式"

#: ../../c-api/sys.rst:218
#, fuzzy
msgid ""
"These are utility functions that make functionality from the :mod:`sys` "
"module accessible to C code.  They all work with the current interpreter "
"thread's :mod:`sys` module's dict, which is contained in the internal thread "
"state structure."
msgstr ""
"這些實用函式使 C 程式碼可以訪問 :mod:`sys` 模組的功能。它們都與當前直譯器執行"
"緒的 :mod:`sys` 模組的字典一起工作，它包含在內部執行緒狀態結構中。"

#: ../../c-api/sys.rst:224
#, fuzzy
msgid ""
"Return the object *name* from the :mod:`sys` module or ``NULL`` if it does "
"not exist, without setting an exception."
msgstr ""
"從 :mod:`sys` 模組回傳物件 *name* 或 ``NULL`` 如果它不存在，而不設定例外。"

#: ../../c-api/sys.rst:229
#, fuzzy
msgid ""
"Set *name* in the :mod:`sys` module to *v* unless *v* is ``NULL``, in which "
"case *name* is deleted from the sys module. Returns ``0`` on success, ``-1`` "
"on error."
msgstr ""
"將 :mod:`sys` 模組中的 *name* 設定為 *v* 除非 *v* 為 ``NULL``，在這種情況下，"
"*name* 將從 sys 模組中刪除。成功回傳 ``0``，錯誤回傳 ``-1``。"

#: ../../c-api/sys.rst:235
#, fuzzy
msgid ""
"Reset :data:`sys.warnoptions` to an empty list. This function may be called "
"prior to :c:func:`Py_Initialize`."
msgstr ""
"將 :data:`sys.warnoptions` 重置為空列表。此函式可以在 :c:func:"
"`Py_Initialize` 之前呼叫。"

#: ../../c-api/sys.rst:240 ../../c-api/sys.rst:251
#, fuzzy
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"warnoptions` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""
"保留此 API 是為了向後相容：設定 :c:member:`PyConfig.warnoptions` 應該改為使"
"用，請參閱 :ref:`Python 初始化配置 <init-config>`。"

#: ../../c-api/sys.rst:244
#, fuzzy
msgid ""
"Append *s* to :data:`sys.warnoptions`. This function must be called prior "
"to :c:func:`Py_Initialize` in order to affect the warnings filter list."
msgstr ""
"將 *s* 附加到 :data:`sys.warnoptions`。必須在 :c:func:`Py_Initialize` 之前呼"
"叫此函式才能影響警告過濾器列表。"

#: ../../c-api/sys.rst:255
#, fuzzy
msgid "Append *unicode* to :data:`sys.warnoptions`."
msgstr "將 *unicode* 附加到 :data:`sys.warnoptions`。"

#: ../../c-api/sys.rst:257
#, fuzzy
msgid ""
"Note: this function is not currently usable from outside the CPython "
"implementation, as it must be called prior to the implicit import of :mod:"
"`warnings` in :c:func:`Py_Initialize` to be effective, but can't be called "
"until enough of the runtime has been initialized to permit the creation of "
"Unicode objects."
msgstr ""
"注意：此函式目前不能從 CPython 實作之外使用，因為它必須在隱式導入 :c:func:"
"`Py_Initialize` 中的 :mod:`warnings` 之前呼叫才能生效，但不能呼叫直到足夠的運"
"行時被初始化以允許建立 Unicode 物件。"

#: ../../c-api/sys.rst:267
#, fuzzy
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"module_search_paths` and :c:member:`PyConfig.module_search_paths_set` should "
"be used instead, see :ref:`Python Initialization Configuration <init-"
"config>`."
msgstr ""
"保留此 API 是為了向後相容：設定 :c:member:`PyConfig.module_search_paths` 和:"
"c:member:`PyConfig.module_search_paths_set` 應改為使用，請參閱 :ref:`Python "
"初始化配置 <init-config>`。"

#: ../../c-api/sys.rst:272
#, fuzzy
msgid ""
"Set :data:`sys.path` to a list object of paths found in *path* which should "
"be a list of paths separated with the platform's search path delimiter (``:"
"`` on Unix, ``;`` on Windows)."
msgstr ""
"將 :data:`sys.path` 設定為在 *path* 中找到的路徑列表物件，它應該是用平台的搜"
"索路徑定界符分隔的路徑列表（Unix 上為 ``:``，Windows 上為``;``） )."

#: ../../c-api/sys.rst:280
#, fuzzy
msgid ""
"Write the output string described by *format* to :data:`sys.stdout`.  No "
"exceptions are raised, even if truncation occurs (see below)."
msgstr ""
"將 *format* 描述的輸出字串寫入 :data:`sys.stdout`。不會引發例外，即使發生截斷"
"（見下文）。"

#: ../../c-api/sys.rst:283
#, fuzzy
msgid ""
"*format* should limit the total size of the formatted output string to 1000 "
"bytes or less -- after 1000 bytes, the output string is truncated. In "
"particular, this means that no unrestricted \"%s\" formats should occur; "
"these should be limited using \"%.<N>s\" where <N> is a decimal number "
"calculated so that <N> plus the maximum size of other formatted text does "
"not exceed 1000 bytes.  Also watch out for \"%f\", which can print hundreds "
"of digits for very large numbers."
msgstr ""
"*format* 應將格式化輸出字串的總大小限制為 1000 位元組或更少——超過 1000 位元組"
"後，輸出字串將被截斷。特別是，這意味著不應出現不受限制的“%s”格式；這些應該使"
"用“%.<N>s”進行限制，其中 <N> 是計算的十進位數，以便 <N> 加上其他格式化文本的"
"最大大小不超過 1000 位元組。還要注意“%f”，它可以為非常大的數字印出數百位數"
"字。"

#: ../../c-api/sys.rst:291
#, fuzzy
msgid ""
"If a problem occurs, or :data:`sys.stdout` is unset, the formatted message "
"is written to the real (C level) *stdout*."
msgstr ""
"如果出現問題，或者 :data:`sys.stdout` 未設定，格式化消息將寫入真實（C 級別）"
"*stdout*。"

#: ../../c-api/sys.rst:296
#, fuzzy
msgid ""
"As :c:func:`PySys_WriteStdout`, but write to :data:`sys.stderr` or *stderr* "
"instead."
msgstr ""
"作為 :c:func:`PySys_WriteStdout`，但改為寫入 :data:`sys.stderr` 或 *stderr*。"

#: ../../c-api/sys.rst:301
#, fuzzy
msgid ""
"Function similar to PySys_WriteStdout() but format the message using :c:func:"
"`PyUnicode_FromFormatV` and don't truncate the message to an arbitrary "
"length."
msgstr ""
"功能與 PySys_WriteStdout() 類似，但使用 PyUnicode_FromFormatV 格式化消息，並"
"且不會將消息截斷為任意長度。"

#: ../../c-api/sys.rst:309
#, fuzzy
msgid ""
"As :c:func:`PySys_FormatStdout`, but write to :data:`sys.stderr` or *stderr* "
"instead."
msgstr ""
"作為 :c:func:`PySys_FormatStdout`，但改為寫入 :data:`sys.stderr` 或 "
"*stderr*。"

#: ../../c-api/sys.rst:316
#, fuzzy
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"xoptions` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""
"保留此 API 是為了向後相容：應改用設定 :c:member:`PyConfig.xoptions`，請參閱 :"
"ref:`Python 初始化配置 <init-config>`。"

#: ../../c-api/sys.rst:320
#, fuzzy
msgid ""
"Parse *s* as a set of :option:`-X` options and add them to the current "
"options mapping as returned by :c:func:`PySys_GetXOptions`. This function "
"may be called prior to :c:func:`Py_Initialize`."
msgstr ""
"將 *s* 解析為一組 :option:`-X` 選項，並將它們新增到 :c:func:"
"`PySys_GetXOptions` 回傳的當前選項映射中。此函式可以在 :c:func:"
"`Py_Initialize` 之前呼叫。"

#: ../../c-api/sys.rst:330
#, fuzzy
msgid ""
"Return the current dictionary of :option:`-X` options, similarly to :data:"
"`sys._xoptions`.  On error, ``NULL`` is returned and an exception is set."
msgstr ""
"回傳 :option:`-X` 選項的當前字典，類似於 :data:`sys._xoptions`。出錯時，回傳 "
"``NULL`` 並設定例外。"

#: ../../c-api/sys.rst:339
#, fuzzy
msgid ""
"Raise an auditing event with any active hooks. Return zero for success and "
"non-zero with an exception set on failure."
msgstr "使用任何活動掛鉤引發審核事件。成功時回傳零，失敗時回傳非零並設定例外。"

#: ../../c-api/sys.rst:342
#, fuzzy
msgid ""
"If any hooks have been added, *format* and other arguments will be used to "
"construct a tuple to pass. Apart from ``N``, the same format characters as "
"used in :c:func:`Py_BuildValue` are available. If the built value is not a "
"tuple, it will be added into a single-element tuple. (The ``N`` format "
"option consumes a reference, but since there is no way to know whether "
"arguments to this function will be consumed, using it may cause reference "
"leaks.)"
msgstr ""
"如果新增了任何鉤子，*format* 和其他參數將用於構造要傳遞的元組。除了 ``N`` 之"
"外，還可以使用與 :c:func:`Py_BuildValue` 中使用的相同格式字元。如果構建的值不"
"是元組，它將被新增到一個單元素元組中。 （``N`` 格式選項消耗一個引用，但由於無"
"法知道是否會消耗此函式的參數，因此使用它可能會導致引用洩漏。）"

#: ../../c-api/sys.rst:350
#, fuzzy
msgid ""
"Note that ``#`` format characters should always be treated as :c:type:"
"`Py_ssize_t`, regardless of whether ``PY_SSIZE_T_CLEAN`` was defined."
msgstr ""
"請注意，``#`` 格式字元應始終被視為 :c:type:`Py_ssize_t`，無論是否定義了 "
"``PY_SSIZE_T_CLEAN``。"

#: ../../c-api/sys.rst:353
#, fuzzy
msgid ":func:`sys.audit` performs the same function from Python code."
msgstr ":func:`sys.audit` 從 Python 程式碼執行相同的功能。"

#: ../../c-api/sys.rst:359
#, fuzzy
msgid ""
"Require :c:type:`Py_ssize_t` for ``#`` format characters. Previously, an "
"unavoidable deprecation warning was raised."
msgstr ""
"需要 :c:type:`Py_ssize_t` 用於 `#`` 格式字元。以前，提出了一個不可避免的棄用"
"警告。"

#: ../../c-api/sys.rst:365
#, fuzzy
msgid ""
"Append the callable *hook* to the list of active auditing hooks. Return zero "
"on success and non-zero on failure. If the runtime has been initialized, "
"also set an error on failure. Hooks added through this API are called for "
"all interpreters created by the runtime."
msgstr ""
"將可呼叫的 *hook* 新增到活動審計掛鉤列表中。成功回傳零，失敗回傳非零。如果運"
"行時已初始化，還設定失敗時的錯誤。通過此 API 新增的掛鉤會為運行時建立的所有直"
"譯器呼叫。"

#: ../../c-api/sys.rst:371
#, fuzzy
msgid ""
"The *userData* pointer is passed into the hook function. Since hook "
"functions may be called from different runtimes, this pointer should not "
"refer directly to Python state."
msgstr ""
"*userData* 指標被傳遞到掛鉤函式中。由於可能會從不同的運行時呼叫掛鉤函式，因此"
"該指標不應直接指向 Python 狀態。"

#: ../../c-api/sys.rst:375
#, fuzzy
msgid ""
"This function is safe to call before :c:func:`Py_Initialize`. When called "
"after runtime initialization, existing audit hooks are notified and may "
"silently abort the operation by raising an error subclassed from :class:"
"`Exception` (other errors will not be silenced)."
msgstr ""
"在 :c:func:`Py_Initialize` 之前呼叫此函式是安全的。在運行時初始化後呼叫時，現"
"有的審計掛鉤會收到通知，並且可能會通過引發從 Exception 子類別化的錯誤來靜默中"
"止操作（其他錯誤不會被沉默）。"

#: ../../c-api/sys.rst:380
#, fuzzy
msgid ""
"The hook function is of type :c:expr:`int (*)(const char *event, PyObject "
"*args, void *userData)`, where *args* is guaranteed to be a :c:type:"
"`PyTupleObject`. The hook function is always called with the GIL held by the "
"Python interpreter that raised the event."
msgstr ""
"鉤子函式的型別是:c:expr:`int (*)(const char *event, PyObject *args, void "
"*userData)`，其中 *args* 保證是:c:type:`PyTupleObject`。鉤子函式總是用引發事"
"件的 Python 直譯器持有的 GIL 呼叫。"

#: ../../c-api/sys.rst:385
#, fuzzy
msgid ""
"See :pep:`578` for a detailed description of auditing.  Functions in the "
"runtime and standard library that raise events are listed in the :ref:`audit "
"events table <audit-events>`. Details are in each function's documentation."
msgstr ""
"有關審核的詳細說明，請參閱 :pep:`578`。引發事件的運行時和標準庫中的函式列在 :"
"ref:`審計事件表 <audit-events>` 中。詳細資訊在每個函式的文檔中。"

#: ../../c-api/sys.rst:390
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sys.addaudithook`` with no "
"arguments."
msgstr ""
"引發一個不附帶引數的\\ :ref:`稽核事件 <auditing>` ``sys.addaudithook``。"

#: ../../c-api/sys.rst:392
#, fuzzy
msgid ""
"If the interpreter is initialized, this function raises a auditing event "
"``sys.addaudithook`` with no arguments. If any existing hooks raise an "
"exception derived from :class:`Exception`, the new hook will not be added "
"and the exception is cleared. As a result, callers cannot assume that their "
"hook has been added unless they control all existing hooks."
msgstr ""
"如果直譯器已初始化，此函式會引發一個不帶參數的審計事件“sys.addaudithook”。如"
"果任何現有掛鉤引發派生自 :class:`Exception` 的例外，則不會新增新掛鉤並清除例"
"外。因此，呼叫者不能假設他們的鉤子已被新增，除非他們控制所有現有的鉤子。"

#: ../../c-api/sys.rst:404
msgid "Process Control"
msgstr "行程控制 (Process Control)"

#: ../../c-api/sys.rst:411
#, fuzzy
msgid ""
"Print a fatal error message and kill the process.  No cleanup is performed. "
"This function should only be invoked when a condition is detected that would "
"make it dangerous to continue using the Python interpreter; e.g., when the "
"object administration appears to be corrupted.  On Unix, the standard C "
"library function :c:func:`abort` is called which will attempt to produce a :"
"file:`core` file."
msgstr ""
"印出致命錯誤消息並終止行程。不執行清理。僅當檢測到會使繼續使用 Python 直譯器"
"變得危險的情況時才應呼叫此函式；例如，當對像管理似乎已損壞時。在 Unix 上，呼"
"叫標準 C 庫函式 :c:func:`abort` 將嘗試生成一個 :file:`core` 文件。"

#: ../../c-api/sys.rst:418
#, fuzzy
msgid ""
"The ``Py_FatalError()`` function is replaced with a macro which logs "
"automatically the name of the current function, unless the "
"``Py_LIMITED_API`` macro is defined."
msgstr ""
"``Py_FatalError()`` 函式被替換為自動記錄當前函式名稱的巨集，除非定義了 "
"``Py_LIMITED_API`` 巨集。"

#: ../../c-api/sys.rst:422
#, fuzzy
msgid "Log the function name automatically."
msgstr "自動記錄函式名稱。"

#: ../../c-api/sys.rst:432
#, fuzzy
msgid ""
"Exit the current process.  This calls :c:func:`Py_FinalizeEx` and then calls "
"the standard C library function ``exit(status)``.  If :c:func:"
"`Py_FinalizeEx` indicates an error, the exit status is set to 120."
msgstr ""
"退出當前行程。這會呼叫 :c:func:`Py_FinalizeEx`，然後呼叫標準 C 庫函式 "
"``exit(status)``。如果 :c:func:`Py_FinalizeEx` 指示錯誤，則退出狀態設定為 "
"120。"

#: ../../c-api/sys.rst:436
#, fuzzy
msgid "Errors from finalization no longer ignored."
msgstr "終結錯誤不再被忽略。"

#: ../../c-api/sys.rst:446
#, fuzzy
msgid ""
"Register a cleanup function to be called by :c:func:`Py_FinalizeEx`.  The "
"cleanup function will be called with no arguments and should return no "
"value.  At most 32 cleanup functions can be registered.  When the "
"registration is successful, :c:func:`Py_AtExit` returns ``0``; on failure, "
"it returns ``-1``.  The cleanup function registered last is called first. "
"Each cleanup function will be called at most once.  Since Python's internal "
"finalization will have completed before the cleanup function, no Python APIs "
"should be called by *func*."
msgstr ""
"註冊一個由 :c:func:`Py_FinalizeEx` 呼叫的清理函式。清理函式將在沒有參數的情況"
"下呼叫，並且不應回傳任何值。最多可以註冊 32 個清理函式。當註冊成功時，:c:"
"func:`Py_AtExit` 回傳 ``0``；失敗時，它回傳 ``-1``。最後註冊的清理函式首先被"
"呼叫。每個清理函式最多被呼叫一次。由於 Python 的內部終結將在清理函式之前完"
"成，因此 *func* 不應呼叫任何 Python API。"
