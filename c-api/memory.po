# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Ching-Lung Chuang, 2015
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-04 00:20+0000\n"
"PO-Revision-Date: 2018-05-23 14:06+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../c-api/memory.rst:8
msgid "Memory Management"
msgstr "記憶體管理"

#: ../../c-api/memory.rst:17
msgid "Overview"
msgstr "總覽"

#: ../../c-api/memory.rst:19
#, fuzzy
msgid ""
"Memory management in Python involves a private heap containing all Python "
"objects and data structures. The management of this private heap is ensured "
"internally by the *Python memory manager*.  The Python memory manager has "
"different components which deal with various dynamic storage management "
"aspects, like sharing, segmentation, preallocation or caching."
msgstr ""
"Python 中的記憶體管理涉及一個包含所有 Python 物件和資料結構的私有堆。這個私有"
"堆的管理由 *Python 記憶體管理器* 在內部確保。 Python 記憶體管理器有不同的組件"
"來處理各種動態儲存管理方面，如共享、分段、預分配或快取。"

#: ../../c-api/memory.rst:25
#, fuzzy
msgid ""
"At the lowest level, a raw memory allocator ensures that there is enough "
"room in the private heap for storing all Python-related data by interacting "
"with the memory manager of the operating system. On top of the raw memory "
"allocator, several object-specific allocators operate on the same heap and "
"implement distinct memory management policies adapted to the peculiarities "
"of every object type. For example, integer objects are managed differently "
"within the heap than strings, tuples or dictionaries because integers imply "
"different storage requirements and speed/space tradeoffs. The Python memory "
"manager thus delegates some of the work to the object-specific allocators, "
"but ensures that the latter operate within the bounds of the private heap."
msgstr ""
"在最低階別，原始記憶體分配器通過與操作系統的記憶體管理器交互，確保私有堆中有"
"足夠的空間來儲存所有與 Python 相關的資料。在原始記憶體分配器之上，幾個特定於"
"物件的分配器在同一個堆上運行，並實施適合每種對像型別特性的不同記憶體管理策"
"略。例如，整數對像在堆中的管理方式不同於字串、元組或字典，因為整數意味著不同"
"的儲存要求和速度/空間權衡。 Python 記憶體管理器因此將一些工作委託給物件特定的"
"分配器，但確保後者在私有堆的範圍內運行。"

#: ../../c-api/memory.rst:36
#, fuzzy
msgid ""
"It is important to understand that the management of the Python heap is "
"performed by the interpreter itself and that the user has no control over "
"it, even if they regularly manipulate object pointers to memory blocks "
"inside that heap.  The allocation of heap space for Python objects and other "
"internal buffers is performed on demand by the Python memory manager through "
"the Python/C API functions listed in this document."
msgstr ""
"重要的是要了解 Python 堆的管理是由直譯器本身執行的，使用者無法控制它，即使他"
"們定期操作指向該堆內記憶體塊的物件指標也是如此。 Python 物件和其他內部緩衝區"
"的堆空間分配由 Python 記憶體管理器通過本文檔中列出的 Python/C API 函式按需執"
"行。"

#: ../../c-api/memory.rst:49
#, fuzzy
msgid ""
"To avoid memory corruption, extension writers should never try to operate on "
"Python objects with the functions exported by the C library: :c:func:"
"`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`.  This will "
"result in  mixed calls between the C allocator and the Python memory manager "
"with fatal consequences, because they implement different algorithms and "
"operate on different heaps.  However, one may safely allocate and release "
"memory blocks with the C library allocator for individual purposes, as shown "
"in the following example::"
msgstr ""
"為避免記憶體損壞，擴充編寫者不應嘗試使用 C 庫導出的函式對 Python 物件進行操"
"作：:c:func:`malloc`、:c:func:`calloc`、:c:func:`realloc`和 :c:func:`free`。"
"這將導致 C 分配器和 Python 記憶體管理器之間的混合呼叫，帶來致命的後果，因為它"
"們實作不同的演算法並在不同的堆上運行。但是，可以出於個別目的使用 C 庫分配器安"
"全地分配和釋放記憶體塊，如以下示例所示："

#: ../../c-api/memory.rst:68
#, fuzzy
msgid ""
"In this example, the memory request for the I/O buffer is handled by the C "
"library allocator. The Python memory manager is involved only in the "
"allocation of the bytes object returned as a result."
msgstr ""
"在此示例中，I/O 緩衝區的記憶體請求由 C 庫分配器處理。 Python 記憶體管理器只參"
"與作為結果回傳的位元組物件的分配。"

#: ../../c-api/memory.rst:72
#, fuzzy
msgid ""
"In most situations, however, it is recommended to allocate memory from the "
"Python heap specifically because the latter is under control of the Python "
"memory manager. For example, this is required when the interpreter is "
"extended with new object types written in C. Another reason for using the "
"Python heap is the desire to *inform* the Python memory manager about the "
"memory needs of the extension module. Even when the requested memory is used "
"exclusively for internal, highly specific purposes, delegating all memory "
"requests to the Python memory manager causes the interpreter to have a more "
"accurate image of its memory footprint as a whole. Consequently, under "
"certain circumstances, the Python memory manager may or may not trigger "
"appropriate actions, like garbage collection, memory compaction or other "
"preventive procedures. Note that by using the C library allocator as shown "
"in the previous example, the allocated memory for the I/O buffer escapes "
"completely the Python memory manager."
msgstr ""
"然而，在大多數情況下，建議專門從 Python 堆分配記憶體，因為後者受 Python 記憶"
"體管理器的控制。例如，當用 C 編寫的新對像型別擴充直譯器時，這是必需的。使用 "
"Python 堆的另一個原因是希望*通知*Python 記憶體管理器擴充模組的記憶體需求。即"
"使請求的記憶體專門用於內部、高度特定的目的，將所有記憶體請求委託給 Python 記"
"憶體管理器也會使直譯器對其記憶體佔用情況有一個更準確的整體印象。因此，在某些"
"情況下，Python 記憶體管理器可能會或可能不會觸發適當的操作，如垃圾收集、記憶體"
"壓縮或其他預防程式。請注意，通過使用前面示例中所示的 C 庫分配器，為 I/O 緩衝"
"區分配的記憶體完全脫離了 Python 記憶體管理器。"

#: ../../c-api/memory.rst:88
#, fuzzy
msgid ""
"The :envvar:`PYTHONMALLOC` environment variable can be used to configure the "
"memory allocators used by Python."
msgstr ":envvar:`PYTHONMALLOC` 環境變數可用於配置 Python 使用的記憶體分配器。"

#: ../../c-api/memory.rst:91
#, fuzzy
msgid ""
"The :envvar:`PYTHONMALLOCSTATS` environment variable can be used to print "
"statistics of the :ref:`pymalloc memory allocator <pymalloc>` every time a "
"new pymalloc object arena is created, and on shutdown."
msgstr ""
":envvar:`PYTHONMALLOCSTATS` 環境變數可用於印出 :ref:`pymalloc 記憶體分配器 "
"<pymalloc>` 每次建立新的 pymalloc 物件區域時以及關閉時的統計資訊。"

#: ../../c-api/memory.rst:96
#, fuzzy
msgid "Allocator Domains"
msgstr "分配器域"

#: ../../c-api/memory.rst:100
#, fuzzy
msgid ""
"All allocating functions belong to one of three different \"domains\" (see "
"also :c:type:`PyMemAllocatorDomain`). These domains represent different "
"allocation strategies and are optimized for different purposes. The specific "
"details on how every domain allocates memory or what internal functions each "
"domain calls is considered an implementation detail, but for debugging "
"purposes a simplified table can be found at :ref:`here <default-memory-"
"allocators>`. There is no hard requirement to use the memory returned by the "
"allocation functions belonging to a given domain for only the purposes "
"hinted by that domain (although this is the recommended practice). For "
"example, one could use the memory returned by :c:func:`PyMem_RawMalloc` for "
"allocating Python objects or the memory returned by :c:func:"
"`PyObject_Malloc` for allocating memory for buffers."
msgstr ""
"所有分配函式都屬於三個不同「域」之一（另請參見 :c:type:"
"`PyMemAllocatorDomain`）。這些域代表不同的分配策略，並針對不同的目的進行了最"
"佳化。有關每個域如何分配記憶體或每個域呼叫哪些內部函式的具體細節被視為實作細"
"節，但出於除錯目的，可以在 :ref:`here <default-memory-allocators>` 找到簡化"
"表。沒有硬性要求將屬於給定域的分配函式回傳的記憶體僅用於該域暗示的目的（儘管"
"這是推薦的做法）。例如，可以使用 :c:func:`PyMem_RawMalloc` 回傳的記憶體來分"
"配 Python 物件，或者使用 :c:func:`PyObject_Malloc` 回傳的記憶體來為緩衝區分配"
"記憶體。"

#: ../../c-api/memory.rst:112
#, fuzzy
msgid "The three allocation domains are:"
msgstr "三個分配域是："

#: ../../c-api/memory.rst:114
#, fuzzy
msgid ""
"Raw domain: intended for allocating memory for general-purpose memory "
"buffers where the allocation *must* go to the system allocator or where the "
"allocator can operate without the :term:`GIL`. The memory is requested "
"directly to the system."
msgstr ""
"原始域：用於為通用記憶體緩衝區分配記憶體，其中分配*必須*進入系統分配器，或者"
"分配器可以在沒有 GIL 的情況下運行。直接向系統請求記憶體。"

#: ../../c-api/memory.rst:119
#, fuzzy
msgid ""
"\"Mem\" domain: intended for allocating memory for Python buffers and "
"general-purpose memory buffers where the allocation must be performed with "
"the :term:`GIL` held. The memory is taken from the Python private heap."
msgstr ""
" ``Mem``域：用於為 Python 緩衝區和通用記憶體緩衝區分配記憶體，其中必須使用 "
"GIL 執行分配。記憶體取自 Python 私有堆。"

#: ../../c-api/memory.rst:123
#, fuzzy
msgid ""
"Object domain: intended for allocating memory belonging to Python objects. "
"The memory is taken from the Python private heap."
msgstr "物件域：用於分配屬於 Python 物件的記憶體。記憶體取自 Python 私有堆。"

#: ../../c-api/memory.rst:126
#, fuzzy
msgid ""
"When freeing memory previously allocated by the allocating functions "
"belonging to a given domain,the matching specific deallocating functions "
"must be used. For example, :c:func:`PyMem_Free` must be used to free memory "
"allocated using :c:func:`PyMem_Malloc`."
msgstr ""
"當釋放先前由屬於給定域的分配函式分配的記憶體時，必須使用匹配的特定釋放函式。"
"例如，:c:func:`PyMem_Free` 必須用於釋放使用 :c:func:`PyMem_Malloc` 分配的記憶"
"體。"

#: ../../c-api/memory.rst:131
#, fuzzy
msgid "Raw Memory Interface"
msgstr "原始記憶體介面"

#: ../../c-api/memory.rst:133
#, fuzzy
msgid ""
"The following function sets are wrappers to the system allocator. These "
"functions are thread-safe, the :term:`GIL <global interpreter lock>` does "
"not need to be held."
msgstr ""
"以下函式集是系統分配器的包裝器。這些函式是執行緒安全的，不需要持有 GIL "
"<global interpreter lock>。"

#: ../../c-api/memory.rst:137
#, fuzzy
msgid ""
"The :ref:`default raw memory allocator <default-memory-allocators>` uses the "
"following functions: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` "
"and :c:func:`free`; call ``malloc(1)`` (or ``calloc(1, 1)``) when requesting "
"zero bytes."
msgstr ""
":ref:`預設原始記憶體分配器 <default-memory-allocators>` 使用以下函式：:c:"
"func:`malloc`、:c:func:`calloc`、:c:func:`realloc` 和： c:func:`免費`；請求零"
"位元組時呼叫``malloc(1)``（或``calloc(1, 1)``）。"

#: ../../c-api/memory.rst:146 ../../c-api/memory.rst:217
#: ../../c-api/memory.rst:325
#, fuzzy
msgid ""
"Allocates *n* bytes and returns a pointer of type :c:expr:`void*` to the "
"allocated memory, or ``NULL`` if the request fails."
msgstr ""
"分配 *n* 位元組並回傳一個型別為 :c:expr:`void*` 的指標到分配的記憶體，如果請"
"求失敗則回傳 ``NULL``。"

#: ../../c-api/memory.rst:149
#, fuzzy
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyMem_RawMalloc(1)`` had been called instead. The memory will not "
"have been initialized in any way."
msgstr ""
"如果可能，請求零位元組回傳一個不同的非 ``NULL`` 指標，就好"
"像“PyMem_RawMalloc(1)”被呼叫了一樣。記憶體不會以任何方式初始化。"

#: ../../c-api/memory.rst:156 ../../c-api/memory.rst:227
#: ../../c-api/memory.rst:335
#, fuzzy
msgid ""
"Allocates *nelem* elements each whose size in bytes is *elsize* and returns "
"a pointer of type :c:expr:`void*` to the allocated memory, or ``NULL`` if "
"the request fails. The memory is initialized to zeros."
msgstr ""
"分配 *nelem* 元素，每個元素的位元組大小為 *elsize* 並回傳型別為 :c:expr:"
"`void*` 的指標到分配的記憶體，如果請求失敗則回傳 ``NULL``。記憶體被初始化為"
"零。"

#: ../../c-api/memory.rst:160
#, fuzzy
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyMem_RawCalloc(1, 1)`` had been "
"called instead."
msgstr ""
"如果可能，請求零個元素或大小為零位元組的元素回傳一個不同的非 ``NULL`` 指標，"
"就好像“PyMem_RawCalloc(1, 1)”被呼叫了一樣。"

#: ../../c-api/memory.rst:169 ../../c-api/memory.rst:240
#: ../../c-api/memory.rst:348
#, fuzzy
msgid ""
"Resizes the memory block pointed to by *p* to *n* bytes. The contents will "
"be unchanged to the minimum of the old and the new sizes."
msgstr ""
"將 *p* 指向的記憶體塊調整為 *n* 位元組。內容將保持不變，以舊尺寸和新尺寸中的"
"最小尺寸為準。"

#: ../../c-api/memory.rst:172
#, fuzzy
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_RawMalloc(n)``; else "
"if *n* is equal to zero, the memory block is resized but is not freed, and "
"the returned pointer is non-``NULL``."
msgstr ""
"如果 *p* 為 ``NULL`` ，則呼叫等同於“PyMem_RawMalloc(n)”；否則，如果 *n* 等於"
"零，記憶體塊會調整大小但不會被釋放，並且回傳的指標是非 ``NULL`` 。"

#: ../../c-api/memory.rst:176
#, fuzzy
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to :c:"
"func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or :c:func:"
"`PyMem_RawCalloc`."
msgstr ""
"除非 *p* 為 ``NULL``，否則它必須由先前呼叫 PyMem_RawMalloc、PyMem_RawRealloc "
"或 PyMem_RawCalloc 回傳。"

#: ../../c-api/memory.rst:180
#, fuzzy
msgid ""
"If the request fails, :c:func:`PyMem_RawRealloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"如果請求失敗，:c:func:`PyMem_RawRealloc` 回傳 ``NULL`` 並且 *p* 仍然是指向前"
"一個記憶體區域的有效指標。"

#: ../../c-api/memory.rst:186
#, fuzzy
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a "
"previous call to :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or :c:"
"func:`PyMem_RawCalloc`.  Otherwise, or if ``PyMem_RawFree(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""
"釋放 *p* 指向的記憶體塊，它必須由之前呼叫 PyMem_RawMalloc、PyMem_RawRealloc "
"或 PyMem_RawCalloc 回傳。否則，或者如果之前呼叫過“PyMem_RawFree(p)”，則會發生"
"未定義的行為。"

#: ../../c-api/memory.rst:191 ../../c-api/memory.rst:261
#: ../../c-api/memory.rst:369
#, fuzzy
msgid "If *p* is ``NULL``, no operation is performed."
msgstr "如果 *p* 為 ``NULL`` ，則不執行任何操作。"

#: ../../c-api/memory.rst:197
#, fuzzy
msgid "Memory Interface"
msgstr "記憶體介面"

#: ../../c-api/memory.rst:199 ../../c-api/memory.rst:305
#, fuzzy
msgid ""
"The following function sets, modeled after the ANSI C standard, but "
"specifying behavior when requesting zero bytes, are available for allocating "
"and releasing memory from the Python heap."
msgstr ""
"以下函式集以 ANSI C 標準為模型，但在請求零位元組時指定行為，可用於從 Python "
"堆分配和釋放記憶體。"

#: ../../c-api/memory.rst:203
#, fuzzy
msgid ""
"The :ref:`default memory allocator <default-memory-allocators>` uses the :"
"ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
":ref:`預設記憶體分配器 <default-memory-allocators>` 使用 :ref:`pymalloc 記憶"
"體分配器 <pymalloc>`。"

#: ../../c-api/memory.rst:208 ../../c-api/memory.rst:320
#, fuzzy
msgid ""
"The :term:`GIL <global interpreter lock>` must be held when using these "
"functions."
msgstr "使用這些函式時必須持有 GIL <global interpreter lock>。"

#: ../../c-api/memory.rst:213
#, fuzzy
msgid ""
"The default allocator is now pymalloc instead of system :c:func:`malloc`."
msgstr "預設分配器現在是 pymalloc 而不是系統 :c:func:`malloc`。"

#: ../../c-api/memory.rst:220
#, fuzzy
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyMem_Malloc(1)`` had been called instead. The memory will not have "
"been initialized in any way."
msgstr ""
"如果可能，請求零位元組回傳一個不同的非 ``NULL`` 指標，就好"
"像“PyMem_Malloc(1)”被呼叫了一樣。記憶體不會以任何方式初始化。"

#: ../../c-api/memory.rst:231
#, fuzzy
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyMem_Calloc(1, 1)`` had been "
"called instead."
msgstr ""
"如果可能，請求零個元素或大小為零位元組的元素回傳一個不同的非 ``NULL`` 指標，"
"就好像“PyMem_Calloc(1, 1)”被呼叫了一樣。"

#: ../../c-api/memory.rst:243
#, fuzzy
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_Malloc(n)``; else if "
"*n* is equal to zero, the memory block is resized but is not freed, and the "
"returned pointer is non-``NULL``."
msgstr ""
"如果 *p* 為 ``NULL`` ，則呼叫等同於“PyMem_Malloc(n)”；否則，如果 *n* 等於零，"
"記憶體塊會調整大小但不會被釋放，並且回傳的指標是非 ``NULL`` 。"

#: ../../c-api/memory.rst:247
#, fuzzy
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to :c:"
"func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or :c:func:`PyMem_Calloc`."
msgstr ""
"除非 *p* 為 ``NULL``，否則它必須由先前呼叫 PyMem_Malloc、PyMem_Realloc 或 "
"PyMem_Calloc 回傳。"

#: ../../c-api/memory.rst:250
#, fuzzy
msgid ""
"If the request fails, :c:func:`PyMem_Realloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"如果請求失敗，:c:func:`PyMem_Realloc` 回傳 ``NULL`` 並且 *p* 仍然是指向前一個"
"記憶體區域的有效指標。"

#: ../../c-api/memory.rst:256
#, fuzzy
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a "
"previous call to :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or :c:func:"
"`PyMem_Calloc`.  Otherwise, or if ``PyMem_Free(p)`` has been called before, "
"undefined behavior occurs."
msgstr ""
"釋放 *p* 指向的記憶體塊，它必須由之前呼叫 PyMem_Malloc、PyMem_Realloc 或 "
"PyMem_Calloc 回傳。否則，或者如果之前呼叫過“PyMem_Free(p)”，則會發生未定義的"
"行為。"

#: ../../c-api/memory.rst:263
#, fuzzy
msgid ""
"The following type-oriented macros are provided for convenience.  Note  that "
"*TYPE* refers to any C type."
msgstr ""
"為方便起見，提供了以下面向型別的巨集。請注意，*TYPE* 指的是任何 C 型別。"

#: ../../c-api/memory.rst:269
#, fuzzy
msgid ""
"Same as :c:func:`PyMem_Malloc`, but allocates ``(n * sizeof(TYPE))`` bytes "
"of memory.  Returns a pointer cast to :c:expr:`TYPE*`.  The memory will not "
"have been initialized in any way."
msgstr ""
"與:c:func:`PyMem_Malloc` 相同，但分配``(n * sizeof(TYPE))`` 位元組的記憶體。"
"回傳轉換為 :c:expr:`TYPE*` 的指標。記憶體不會以任何方式初始化。"

#: ../../c-api/memory.rst:276
#, fuzzy
msgid ""
"Same as :c:func:`PyMem_Realloc`, but the memory block is resized to ``(n * "
"sizeof(TYPE))`` bytes.  Returns a pointer cast to :c:expr:`TYPE*`. On "
"return, *p* will be a pointer to the new memory area, or ``NULL`` in the "
"event of failure."
msgstr ""
"與:c:func:`PyMem_Realloc` 相同，但記憶體塊大小調整為 ``(n * sizeof(TYPE))`` "
"位元組。回傳轉換為 :c:expr:`TYPE*` 的指標。回傳時，*p* 將是指向新記憶體區域的"
"指標，或者在失敗時為 ``NULL`` 。"

#: ../../c-api/memory.rst:281
#, fuzzy
msgid ""
"This is a C preprocessor macro; *p* is always reassigned.  Save the original "
"value of *p* to avoid losing memory when handling errors."
msgstr ""
"這是一個 C 預處理器巨集； *p* 總是被重新分配。保存 *p* 的原始值以避免在處理錯"
"誤時丟失記憶體。"

#: ../../c-api/memory.rst:287
msgid "Same as :c:func:`PyMem_Free`."
msgstr "和 :c:func:`PyMem_Free` 相同。"

#: ../../c-api/memory.rst:289
#, fuzzy
msgid ""
"In addition, the following macro sets are provided for calling the Python "
"memory allocator directly, without involving the C API functions listed "
"above. However, note that their use does not preserve binary compatibility "
"across Python versions and is therefore deprecated in extension modules."
msgstr ""
"此外，還提供了以下巨集集，用於直接呼叫 Python 記憶體分配器，而無需涉及上面列"
"出的 C API 函式。但是，請注意，它們的使用不會保留跨 Python 版本的二進位相容"
"性，因此在擴充模組中已棄用。"

#: ../../c-api/memory.rst:294
msgid "``PyMem_MALLOC(size)``"
msgstr "``PyMem_MALLOC(size)``"

#: ../../c-api/memory.rst:295
msgid "``PyMem_NEW(type, size)``"
msgstr "``PyMem_NEW(type, size)``"

#: ../../c-api/memory.rst:296
msgid "``PyMem_REALLOC(ptr, size)``"
msgstr "``PyMem_REALLOC(ptr, size)``"

#: ../../c-api/memory.rst:297
msgid "``PyMem_RESIZE(ptr, type, size)``"
msgstr "``PyMem_RESIZE(ptr, type, size)``"

#: ../../c-api/memory.rst:298
msgid "``PyMem_FREE(ptr)``"
msgstr "``PyMem_FREE(ptr)``"

#: ../../c-api/memory.rst:299
msgid "``PyMem_DEL(ptr)``"
msgstr "``PyMem_DEL(ptr)``"

#: ../../c-api/memory.rst:303
#, fuzzy
msgid "Object allocators"
msgstr "物件分配器"

#: ../../c-api/memory.rst:310
#, fuzzy
msgid ""
"There is no guarantee that the memory returned by these allocators can be "
"successfully cast to a Python object when intercepting the allocating "
"functions in this domain by the methods described in the :ref:`Customize "
"Memory Allocators <customize-memory-allocators>` section."
msgstr ""
"當通過自定義記憶體分配器 <customize-memory-allocators> 部分中描述的方法攔截此"
"域中的分配函式時，無法保證這些分配器回傳的記憶體可以成功轉換為 Python 物件。"

#: ../../c-api/memory.rst:315
#, fuzzy
msgid ""
"The :ref:`default object allocator <default-memory-allocators>` uses the :"
"ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
":ref:`預設物件分配器 <default-memory-allocators>` 使用 :ref:`pymalloc 記憶體"
"分配器 <pymalloc>`。"

#: ../../c-api/memory.rst:328
#, fuzzy
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyObject_Malloc(1)`` had been called instead. The memory will not "
"have been initialized in any way."
msgstr ""
"如果可能，請求零位元組回傳一個不同的非 ``NULL`` 指標，就好"
"像“PyObject_Malloc(1)”被呼叫了一樣。記憶體不會以任何方式初始化。"

#: ../../c-api/memory.rst:339
#, fuzzy
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyObject_Calloc(1, 1)`` had been "
"called instead."
msgstr ""
"如果可能，請求零個元素或大小為零位元組的元素會回傳一個不同的非 ``NULL`` 指"
"標，就好像“PyObject_Calloc(1, 1)”已被呼叫一樣。"

#: ../../c-api/memory.rst:351
#, fuzzy
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyObject_Malloc(n)``; else "
"if *n* is equal to zero, the memory block is resized but is not freed, and "
"the returned pointer is non-``NULL``."
msgstr ""
"如果 *p* 為 ``NULL`` ，則呼叫等同於“PyObject_Malloc(n)”；否則，如果 *n* 等於"
"零，記憶體塊會調整大小但不會被釋放，並且回傳的指標是非 ``NULL`` 。"

#: ../../c-api/memory.rst:355
#, fuzzy
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to :c:"
"func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or :c:func:"
"`PyObject_Calloc`."
msgstr ""
"除非 *p* 為 ``NULL``，否則它必須由先前呼叫 PyObject_Malloc、PyObject_Realloc "
"或 PyObject_Calloc 回傳。"

#: ../../c-api/memory.rst:358
#, fuzzy
msgid ""
"If the request fails, :c:func:`PyObject_Realloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"如果請求失敗，:c:func:`PyObject_Realloc` 回傳 ``NULL`` 並且 *p* 仍然是指向前"
"一個記憶體區域的有效指標。"

#: ../../c-api/memory.rst:364
#, fuzzy
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a "
"previous call to :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or :c:"
"func:`PyObject_Calloc`.  Otherwise, or if ``PyObject_Free(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""
"釋放 *p* 指向的記憶體塊，該記憶體塊必須由之前呼叫 PyObject_Malloc、"
"PyObject_Realloc 或 PyObject_Calloc 回傳。否則，或者如果之前呼叫過 "
"PyObject_Free(p)，則會發生未定義的行為。"

#: ../../c-api/memory.rst:375
#, fuzzy
msgid "Default Memory Allocators"
msgstr "預設記憶體分配器"

#: ../../c-api/memory.rst:377
#, fuzzy
msgid "Default memory allocators:"
msgstr "預設記憶體分配器："

#: ../../c-api/memory.rst:380
#, fuzzy
msgid "Configuration"
msgstr "配置"

#: ../../c-api/memory.rst:380
#, fuzzy
msgid "Name"
msgstr "姓名"

#: ../../c-api/memory.rst:380
msgid "PyMem_RawMalloc"
msgstr "PyMem_RawMalloc"

#: ../../c-api/memory.rst:380
msgid "PyMem_Malloc"
msgstr "PyMem_Malloc"

#: ../../c-api/memory.rst:380
msgid "PyObject_Malloc"
msgstr "PyObject_Malloc"

#: ../../c-api/memory.rst:382
#, fuzzy
msgid "Release build"
msgstr "發布版本"

#: ../../c-api/memory.rst:382
msgid "``\"pymalloc\"``"
msgstr "``\"pymalloc\"``"

#: ../../c-api/memory.rst:382 ../../c-api/memory.rst:384
msgid "``malloc``"
msgstr "``malloc``"

#: ../../c-api/memory.rst:382
msgid "``pymalloc``"
msgstr "``pymalloc``"

#: ../../c-api/memory.rst:383
#, fuzzy
msgid "Debug build"
msgstr "除錯構建"

#: ../../c-api/memory.rst:383
msgid "``\"pymalloc_debug\"``"
msgstr "``\"pymalloc_debug\"``"

#: ../../c-api/memory.rst:383 ../../c-api/memory.rst:385
#, fuzzy
msgid "``malloc`` + debug"
msgstr "``malloc`` + 除錯"

#: ../../c-api/memory.rst:383
#, fuzzy
msgid "``pymalloc`` + debug"
msgstr "``pymalloc`` + 除錯"

#: ../../c-api/memory.rst:384
#, fuzzy
msgid "Release build, without pymalloc"
msgstr "發布版本，沒有 pymalloc"

#: ../../c-api/memory.rst:384
msgid "``\"malloc\"``"
msgstr "``\"malloc\"``"

#: ../../c-api/memory.rst:385
#, fuzzy
msgid "Debug build, without pymalloc"
msgstr "除錯構建，沒有 pymalloc"

#: ../../c-api/memory.rst:385
msgid "``\"malloc_debug\"``"
msgstr "``\"malloc_debug\"``"

#: ../../c-api/memory.rst:388
#, fuzzy
msgid "Legend:"
msgstr "傳奇："

#: ../../c-api/memory.rst:390
msgid "Name: value for :envvar:`PYTHONMALLOC` environment variable."
msgstr "名稱： :envvar:`PYTHONMALLOC` 環境變數的值。"

#: ../../c-api/memory.rst:391
#, fuzzy
msgid ""
"``malloc``: system allocators from the standard C library, C functions: :c:"
"func:`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`."
msgstr ""
"``malloc``：來自標準 C 庫的系統分配器，C 函式：:c:func:`malloc`、:c:func:"
"`calloc`、:c:func:`realloc` 和 :c:func:`免費`。"

#: ../../c-api/memory.rst:393
#, fuzzy
msgid "``pymalloc``: :ref:`pymalloc memory allocator <pymalloc>`."
msgstr "``pymalloc``: :ref:`pymalloc 記憶體分配器 <pymalloc>`。"

#: ../../c-api/memory.rst:394
#, fuzzy
msgid ""
"\"+ debug\": with :ref:`debug hooks on the Python memory allocators <pymem-"
"debug-hooks>`."
msgstr ""
"“+ debug”：使用 :ref:`Python 記憶體分配器上的除錯掛鉤 <pymem-debug-hooks>`。"

#: ../../c-api/memory.rst:396
#, fuzzy
msgid "\"Debug build\": :ref:`Python build in debug mode <debug-build>`."
msgstr "“除錯構建”：:ref:`除錯模式下的 Python 構建 <debug-build>`。"

#: ../../c-api/memory.rst:401
#, fuzzy
msgid "Customize Memory Allocators"
msgstr "自定義記憶體分配器"

#: ../../c-api/memory.rst:407
#, fuzzy
msgid ""
"Structure used to describe a memory block allocator. The structure has the "
"following fields:"
msgstr "用於描述記憶體塊分配器的結構。該結構具有以下欄位："

#: ../../c-api/memory.rst:411 ../../c-api/memory.rst:649
#, fuzzy
msgid "Field"
msgstr "欄位"

#: ../../c-api/memory.rst:411 ../../c-api/memory.rst:649
msgid "Meaning"
msgstr "意義"

#: ../../c-api/memory.rst:413 ../../c-api/memory.rst:651
msgid "``void *ctx``"
msgstr "``void *ctx``"

#: ../../c-api/memory.rst:413 ../../c-api/memory.rst:651
#, fuzzy
msgid "user context passed as first argument"
msgstr "作為第一個參數傳遞的使用者上下文"

#: ../../c-api/memory.rst:415
msgid "``void* malloc(void *ctx, size_t size)``"
msgstr "``void* malloc(void *ctx, size_t size)``"

#: ../../c-api/memory.rst:415
#, fuzzy
msgid "allocate a memory block"
msgstr "分配一個記憶體塊"

#: ../../c-api/memory.rst:417
msgid "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"
msgstr "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"

#: ../../c-api/memory.rst:417
#, fuzzy
msgid "allocate a memory block initialized with zeros"
msgstr "分配一個用零初始化的記憶體塊"

#: ../../c-api/memory.rst:420
msgid "``void* realloc(void *ctx, void *ptr, size_t new_size)``"
msgstr "``void* realloc(void *ctx, void *ptr, size_t new_size)``"

#: ../../c-api/memory.rst:420
#, fuzzy
msgid "allocate or resize a memory block"
msgstr "分配或調整記憶體塊"

#: ../../c-api/memory.rst:422
msgid "``void free(void *ctx, void *ptr)``"
msgstr "``void free(void *ctx, void *ptr)``"

#: ../../c-api/memory.rst:422
#, fuzzy
msgid "free a memory block"
msgstr "釋放記憶體塊"

#: ../../c-api/memory.rst:425
#, fuzzy
msgid ""
"The :c:type:`PyMemAllocator` structure was renamed to :c:type:"
"`PyMemAllocatorEx` and a new ``calloc`` field was added."
msgstr ""
":c:type:`PyMemAllocator` 結構重命名為 :c:type:`PyMemAllocatorEx` 並新增了一個"
"新的 ``calloc`` 欄位。"

#: ../../c-api/memory.rst:432
#, fuzzy
msgid "Enum used to identify an allocator domain. Domains:"
msgstr "用於標識分配器域的枚舉。域："

#: ../../c-api/memory.rst:436 ../../c-api/memory.rst:445
#: ../../c-api/memory.rst:454
msgid "Functions:"
msgstr "函式："

#: ../../c-api/memory.rst:438
msgid ":c:func:`PyMem_RawMalloc`"
msgstr ":c:func:`PyMem_RawMalloc`"

#: ../../c-api/memory.rst:439
msgid ":c:func:`PyMem_RawRealloc`"
msgstr ":c:func:`PyMem_RawRealloc`"

#: ../../c-api/memory.rst:440
msgid ":c:func:`PyMem_RawCalloc`"
msgstr ":c:func:`PyMem_RawCalloc`"

#: ../../c-api/memory.rst:441
msgid ":c:func:`PyMem_RawFree`"
msgstr ":c:func:`PyMem_RawFree`"

#: ../../c-api/memory.rst:447
msgid ":c:func:`PyMem_Malloc`,"
msgstr ":c:func:`PyMem_Malloc`,"

#: ../../c-api/memory.rst:448
msgid ":c:func:`PyMem_Realloc`"
msgstr ":c:func:`PyMem_Realloc`"

#: ../../c-api/memory.rst:449
msgid ":c:func:`PyMem_Calloc`"
msgstr ":c:func:`PyMem_Calloc`"

#: ../../c-api/memory.rst:450
msgid ":c:func:`PyMem_Free`"
msgstr ":c:func:`PyMem_Free`"

#: ../../c-api/memory.rst:456
msgid ":c:func:`PyObject_Malloc`"
msgstr ":c:func:`PyObject_Malloc`"

#: ../../c-api/memory.rst:457
msgid ":c:func:`PyObject_Realloc`"
msgstr ":c:func:`PyObject_Realloc`"

#: ../../c-api/memory.rst:458
msgid ":c:func:`PyObject_Calloc`"
msgstr ":c:func:`PyObject_Calloc`"

#: ../../c-api/memory.rst:459
msgid ":c:func:`PyObject_Free`"
msgstr ":c:func:`PyObject_Free`"

#: ../../c-api/memory.rst:463
#, fuzzy
msgid "Get the memory block allocator of the specified domain."
msgstr "獲取指定域的記憶體塊分配器。"

#: ../../c-api/memory.rst:468
#, fuzzy
msgid "Set the memory block allocator of the specified domain."
msgstr "設定指定域的記憶體塊分配器。"

#: ../../c-api/memory.rst:470
#, fuzzy
msgid ""
"The new allocator must return a distinct non-``NULL`` pointer when "
"requesting zero bytes."
msgstr "請求零位元組時，新分配器必須回傳一個不同的非 ``NULL`` 指標。"

#: ../../c-api/memory.rst:473
#, fuzzy
msgid ""
"For the :c:data:`PYMEM_DOMAIN_RAW` domain, the allocator must be thread-"
"safe: the :term:`GIL <global interpreter lock>` is not held when the "
"allocator is called."
msgstr ""
"對於:c:data:`PYMEM_DOMAIN_RAW` 域，分配器必須是執行緒安全的：:term:`GIL "
"<global interpreter lock>` 在分配器被呼叫時不被持有。"

#: ../../c-api/memory.rst:477
#, fuzzy
msgid ""
"If the new allocator is not a hook (does not call the previous allocator), "
"the :c:func:`PyMem_SetupDebugHooks` function must be called to reinstall the "
"debug hooks on top on the new allocator."
msgstr ""
"如果新分配器不是掛鉤（不呼叫以前的分配器），則必須呼叫 PyMem_SetupDebugHooks "
"函式以在新分配器的頂部重新安裝除錯掛鉤。"

#: ../../c-api/memory.rst:481
#, fuzzy
msgid ""
"See also :c:member:`PyPreConfig.allocator` and :ref:`Preinitialize Python "
"with PyPreConfig <c-preinit>`."
msgstr ""
"另見:c:member:`PyPreConfig.allocator` 和 :ref:`Preinitialize Python with "
"PyPreConfig <c-preinit>`。"

#: ../../c-api/memory.rst:486
#, fuzzy
msgid ":c:func:`PyMem_SetAllocator` does have the following contract:"
msgstr ":c:func:`PyMem_SetAllocator` 確實有以下契約："

#: ../../c-api/memory.rst:488
#, fuzzy
msgid ""
"It can be called after :c:func:`Py_PreInitialize` and before :c:func:"
"`Py_InitializeFromConfig` to install a custom memory allocator. There are no "
"restrictions over the installed allocator other than the ones imposed by the "
"domain (for instance, the Raw Domain allows the allocator to be called "
"without the GIL held). See :ref:`the section on allocator domains <allocator-"
"domains>` for more information."
msgstr ""
"它可以在 :c:func:`Py_PreInitialize` 之後和 :c:func:`Py_InitializeFromConfig` "
"之前呼叫以安裝自定義記憶體分配器。除了域施加的限制外，對已安裝的分配器沒有任"
"何限制（例如，原始域允許在不持有 GIL 的情況下呼叫分配器）。有關詳細資訊，請參"
"閱 :ref:`有關分配器域的部分 <allocator-domains>`。"

#: ../../c-api/memory.rst:496
#, fuzzy
msgid ""
"If called after Python has finish initializing (after :c:func:"
"`Py_InitializeFromConfig` has been called) the allocator **must** wrap the "
"existing allocator. Substituting the current allocator for some other "
"arbitrary one is **not supported**."
msgstr ""
"如果在 Python 完成初始化後呼叫（在呼叫 :c:func:`Py_InitializeFromConfig` 之"
"後）分配器**必須**包裝現有的分配器。 **不支援**將當前分配器替換為其他任意分配"
"器。"

#: ../../c-api/memory.rst:505
#, fuzzy
msgid ""
"Setup :ref:`debug hooks in the Python memory allocators <pymem-debug-hooks>` "
"to detect memory errors."
msgstr ""
"在 Python 記憶體分配器 <pymem-debug-hooks> 中設定除錯掛鉤以檢測記憶體錯誤。"

#: ../../c-api/memory.rst:512
#, fuzzy
msgid "Debug hooks on the Python memory allocators"
msgstr "Python 記憶體分配器上的除錯掛鉤"

#: ../../c-api/memory.rst:514
#, fuzzy
msgid ""
"When :ref:`Python is built in debug mode <debug-build>`, the :c:func:"
"`PyMem_SetupDebugHooks` function is called at the :ref:`Python "
"preinitialization <c-preinit>` to setup debug hooks on Python memory "
"allocators to detect memory errors."
msgstr ""
"當 :ref:`Python 在除錯模式下構建 <debug-build>` 時，:ref:"
"`PyMem_SetupDebugHooks` 函式在 :ref:`Python 預初始化 <c-preinit>` 被呼叫以在 "
"Python 上設定除錯掛鉤記憶體分配器來檢測記憶體錯誤。"

#: ../../c-api/memory.rst:519
#, fuzzy
msgid ""
"The :envvar:`PYTHONMALLOC` environment variable can be used to install debug "
"hooks on a Python compiled in release mode (ex: ``PYTHONMALLOC=debug``)."
msgstr ""
":envvar:`PYTHONMALLOC` 環境變數可用於在以發布模式編譯的 Python 上安裝除錯掛鉤"
"（例如：``PYTHONMALLOC=debug``）。"

#: ../../c-api/memory.rst:522
#, fuzzy
msgid ""
"The :c:func:`PyMem_SetupDebugHooks` function can be used to set debug hooks "
"after calling :c:func:`PyMem_SetAllocator`."
msgstr ""
":c:func:`PyMem_SetupDebugHooks` 函式可用於在呼叫 :c:func:"
"`PyMem_SetAllocator` 後設定除錯掛鉤。"

#: ../../c-api/memory.rst:525
#, fuzzy
msgid ""
"These debug hooks fill dynamically allocated memory blocks with special, "
"recognizable bit patterns. Newly allocated memory is filled with the byte "
"``0xCD`` (``PYMEM_CLEANBYTE``), freed memory is filled with the byte "
"``0xDD`` (``PYMEM_DEADBYTE``). Memory blocks are surrounded by \"forbidden "
"bytes\" filled with the byte ``0xFD`` (``PYMEM_FORBIDDENBYTE``). Strings of "
"these bytes are unlikely to be valid addresses, floats, or ASCII strings."
msgstr ""
"這些除錯掛鉤使用特殊的、可識別的位模式填充動態分配的記憶體塊。新分配的記憶體"
"用位元組 ``0xCD``（“PYMEM_CLEANBYTE”）填充，釋放的記憶體用位元組 ``0xDD``"
"（“PYMEM_DEADBYTE”）填充。記憶體塊被填充位元組 ``0xFD``"
"（“PYMEM_FORBIDDENBYTE”）的“禁止位元組”包圍。這些位元組的字串不太可能是有效地"
"址、浮點數或 ASCII 字串。"

#: ../../c-api/memory.rst:532
#, fuzzy
msgid "Runtime checks:"
msgstr "運行時檢查："

#: ../../c-api/memory.rst:534
#, fuzzy
msgid ""
"Detect API violations. For example, detect if :c:func:`PyObject_Free` is "
"called on a memory block allocated by :c:func:`PyMem_Malloc`."
msgstr ""
"檢測 API 違規。例如，檢測 :c:func:`PyObject_Free` 是否在由 :c:func:"
"`PyMem_Malloc` 分配的記憶體塊上呼叫。"

#: ../../c-api/memory.rst:536
#, fuzzy
msgid "Detect write before the start of the buffer (buffer underflow)."
msgstr "在緩衝區開始之前檢測寫入（緩衝區下溢）。"

#: ../../c-api/memory.rst:537
#, fuzzy
msgid "Detect write after the end of the buffer (buffer overflow)."
msgstr "在緩衝區結束後檢測寫入（緩衝區溢出）。"

#: ../../c-api/memory.rst:538
#, fuzzy
msgid ""
"Check that the :term:`GIL <global interpreter lock>` is held when allocator "
"functions of :c:data:`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) and :"
"c:data:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) domains are called."
msgstr ""
"檢查 :term:`GIL <global interpreter lock>` 在 :c:data:`PYMEM_DOMAIN_OBJ` "
"(ex: :c:func:`PyObject_Malloc`) 和 :c:data:`PYMEM_DOMAIN_MEM` ( ex: :c:func:"
"`PyMem_Malloc`) 域被呼叫。"

#: ../../c-api/memory.rst:543
#, fuzzy
msgid ""
"On error, the debug hooks use the :mod:`tracemalloc` module to get the "
"traceback where a memory block was allocated. The traceback is only "
"displayed if :mod:`tracemalloc` is tracing Python memory allocations and the "
"memory block was traced."
msgstr ""
"出錯時，除錯掛鉤使用 :mod:`tracemalloc` 模組獲取記憶體塊分配位置的回溯。只有"
"在 :mod:`tracemalloc` 正在跟踪 Python 記憶體分配並且記憶體塊被跟踪時才會顯示"
"回溯。"

#: ../../c-api/memory.rst:548
#, fuzzy
msgid ""
"Let *S* = ``sizeof(size_t)``. ``2*S`` bytes are added at each end of each "
"block of *N* bytes requested.  The memory layout is like so, where p "
"represents the address returned by a malloc-like or realloc-like function "
"(``p[i:j]`` means the slice of bytes from ``*(p+i)`` inclusive up to "
"``*(p+j)`` exclusive; note that the treatment of negative indices differs "
"from a Python slice):"
msgstr ""
"讓 *S* = ``sizeof(size_t)``。 ``2*S`` 位元組被新增到每個請求的 *N* 位元組塊的"
"每一端。記憶體佈局是這樣的，其中 p 表示由類似 malloc 或 realloc 的函式回傳的"
"地址（``p[i:j]`` 表示來自``*(p+i)`` 的位元組片包含到 ``*(p+j)`` 不包含在內；"
"請注意負索引的處理不同於 Python 切片）："

#: ../../c-api/memory.rst:555
msgid "``p[-2*S:-S]``"
msgstr "``p[-2*S:-S]``"

#: ../../c-api/memory.rst:555
#, fuzzy
msgid ""
"Number of bytes originally asked for.  This is a size_t, big-endian (easier "
"to read in a memory dump)."
msgstr ""
"最初請求的位元組數。這是一個 size_t，big-endian（更容易在記憶體轉儲中讀取）。"

#: ../../c-api/memory.rst:562
msgid "``p[-S]``"
msgstr "``p[-S]``"

#: ../../c-api/memory.rst:558
#, fuzzy
msgid "API identifier (ASCII character):"
msgstr "API 標識符（ASCII 字元）："

#: ../../c-api/memory.rst:560
msgid "``'r'`` for :c:data:`PYMEM_DOMAIN_RAW`."
msgstr "``'r'`` 用於 :c:data:`PYMEM_DOMAIN_RAW`。"

#: ../../c-api/memory.rst:561
msgid "``'m'`` for :c:data:`PYMEM_DOMAIN_MEM`."
msgstr "``'m'`` 用於 :c:data:`PYMEM_DOMAIN_MEM`。"

#: ../../c-api/memory.rst:562
msgid "``'o'`` for :c:data:`PYMEM_DOMAIN_OBJ`."
msgstr "``'o'`` 用於 :c:data:`PYMEM_DOMAIN_OBJ`。"

#: ../../c-api/memory.rst:565
msgid "``p[-S+1:0]``"
msgstr "``p[-S+1:0]``"

#: ../../c-api/memory.rst:565
#, fuzzy
msgid "Copies of PYMEM_FORBIDDENBYTE.  Used to catch under- writes and reads."
msgstr "PYMEM_FORBIDDENBYTE 的副本。用於捕獲欠寫和讀取。"

#: ../../c-api/memory.rst:574
msgid "``p[0:N]``"
msgstr "``p[0:N]``"

#: ../../c-api/memory.rst:568
#, fuzzy
msgid ""
"The requested memory, filled with copies of PYMEM_CLEANBYTE, used to catch "
"reference to uninitialized memory.  When a realloc-like function is called "
"requesting a larger memory block, the new excess bytes are also filled with "
"PYMEM_CLEANBYTE.  When a free-like function is called, these are overwritten "
"with PYMEM_DEADBYTE, to catch reference to freed memory.  When a realloc- "
"like function is called requesting a smaller memory block, the excess old "
"bytes are also filled with PYMEM_DEADBYTE."
msgstr ""
"請求的記憶體，充滿了 PYMEM_CLEANBYTE 的副本，用於捕獲對未初始化記憶體的引用。"
"當呼叫類似 realloc 的函式請求更大的記憶體塊時，新的多餘位元組也會用 "
"PYMEM_CLEANBYTE 填充。當呼叫類似自由的函式時，這些將被 PYMEM_DEADBYTE 覆蓋，"
"以捕獲對已釋放記憶體的引用。當呼叫類似 realloc 的函式來請求更小的記憶體塊時，"
"多餘的舊位元組也會用 PYMEM_DEADBYTE 填充。"

#: ../../c-api/memory.rst:577
msgid "``p[N:N+S]``"
msgstr "``p[N:N+S]``"

#: ../../c-api/memory.rst:577
#, fuzzy
msgid "Copies of PYMEM_FORBIDDENBYTE.  Used to catch over- writes and reads."
msgstr "PYMEM_FORBIDDENBYTE 的副本。用於捕獲重寫和讀取。"

#: ../../c-api/memory.rst:588
msgid "``p[N+S:N+2*S]``"
msgstr "``p[N+S:N+2*S]``"

#: ../../c-api/memory.rst:580
#, fuzzy
msgid ""
"Only used if the ``PYMEM_DEBUG_SERIALNO`` macro is defined (not defined by "
"default)."
msgstr "僅在定義了``PYMEM_DEBUG_SERIALNO`` 巨集時使用（預設情況下未定義）。"

#: ../../c-api/memory.rst:583
#, fuzzy
msgid ""
"A serial number, incremented by 1 on each call to a malloc-like or realloc-"
"like function.  Big-endian ``size_t``.  If \"bad memory\" is detected later, "
"the serial number gives an excellent way to set a breakpoint on the next "
"run, to capture the instant at which this block was passed out.  The static "
"function bumpserialno() in obmalloc.c is the only place the serial number is "
"incremented, and exists so you can set such a breakpoint easily."
msgstr ""
"一個序列號，每次呼叫 malloc-like 或 realloc-like 函式時遞增 1。大端 "
"``size_t``。如果稍後檢測到“壞記憶體”，序列號提供了一種在下一次運行時設定斷點"
"的極好方法，以捕獲該塊被傳遞的瞬間。 obmalloc.c 中的靜態函式 bumpserialno() "
"是序列號唯一遞增的地方，並且存在因此您可以輕鬆設定這樣的斷點。"

#: ../../c-api/memory.rst:590
#, fuzzy
msgid ""
"A realloc-like or free-like function first checks that the "
"PYMEM_FORBIDDENBYTE bytes at each end are intact.  If they've been altered, "
"diagnostic output is written to stderr, and the program is aborted via "
"Py_FatalError().  The other main failure mode is provoking a memory error "
"when a program reads up one of the special bit patterns and tries to use it "
"as an address.  If you get in a debugger then and look at the object, you're "
"likely to see that it's entirely filled with PYMEM_DEADBYTE (meaning freed "
"memory is getting used) or PYMEM_CLEANBYTE (meaning uninitialized memory is "
"getting used)."
msgstr ""
"類似 realloc 或 free 的函式首先檢查兩端的 PYMEM_FORBIDDENBYTE 位元組是否完好"
"無損。如果它們已被更改，診斷輸出將寫入 stderr，程式將通過 Py_FatalError() 中"
"止。另一種主要故障模式是當程式讀取一種特殊位模式並嘗試將其用作地址時引發記憶"
"體錯誤。如果您隨後進入除錯器並查看該物件，您可能會看到它完全被 PYMEM_DEADBYTE"
"（表示正在使用釋放的記憶體）或 PYMEM_CLEANBYTE（表示正在使用未初始化的記憶"
"體）填充。"

#: ../../c-api/memory.rst:599
#, fuzzy
msgid ""
"The :c:func:`PyMem_SetupDebugHooks` function now also works on Python "
"compiled in release mode.  On error, the debug hooks now use :mod:"
"`tracemalloc` to get the traceback where a memory block was allocated. The "
"debug hooks now also check if the GIL is held when functions of :c:data:"
"`PYMEM_DOMAIN_OBJ` and :c:data:`PYMEM_DOMAIN_MEM` domains are called."
msgstr ""
":c:func:`PyMem_SetupDebugHooks` 函式現在也適用於以發布模式編譯的 Python。出現"
"錯誤時，除錯掛鉤現在使用 :mod:`tracemalloc` 獲取記憶體塊分配位置的回溯。除錯"
"掛鉤現在還會檢查在呼叫 PYMEM_DOMAIN_OBJ 和 PYMEM_DOMAIN_MEM 域的函式時是否保"
"留 GIL。"

#: ../../c-api/memory.rst:607
#, fuzzy
msgid ""
"Byte patterns ``0xCB`` (``PYMEM_CLEANBYTE``), ``0xDB`` (``PYMEM_DEADBYTE``) "
"and ``0xFB`` (``PYMEM_FORBIDDENBYTE``) have been replaced with ``0xCD``, "
"``0xDD`` and ``0xFD`` to use the same values than Windows CRT debug "
"``malloc()`` and ``free()``."
msgstr ""
"位元組模式 ``0xCB``（“PYMEM_CLEANBYTE”）、 ``0xDB``（“PYMEM_DEADBYTE”）和 "
"``0xFB``（“PYMEM_FORBIDDENBYTE”）已被 ``0xCD``替換， ``0xDD`` 和 ``0xFD`` 使"
"用與 Windows CRT 除錯 ``malloc()`` 和 ``free()`` 相同的值。"

#: ../../c-api/memory.rst:617
#, fuzzy
msgid "The pymalloc allocator"
msgstr "pymalloc 分配器"

#: ../../c-api/memory.rst:619
#, fuzzy
msgid ""
"Python has a *pymalloc* allocator optimized for small objects (smaller or "
"equal to 512 bytes) with a short lifetime. It uses memory mappings called "
"\"arenas\" with a fixed size of 256 KiB. It falls back to :c:func:"
"`PyMem_RawMalloc` and :c:func:`PyMem_RawRealloc` for allocations larger than "
"512 bytes."
msgstr ""
"Python 有一個針對生命週期較短的小物件（小於或等於 512 位元組）最佳化的 "
"*pymalloc* 分配器。它使用稱為 ``arenas``的記憶體映射，固定大小為 256 KiB。對"
"於大於 512 位元組的分配，它回落到 :c:func:`PyMem_RawMalloc` 和 :c:func:"
"`PyMem_RawRealloc`。"

#: ../../c-api/memory.rst:624
#, fuzzy
msgid ""
"*pymalloc* is the :ref:`default allocator <default-memory-allocators>` of "
"the :c:data:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) and :c:data:"
"`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) domains."
msgstr ""
"*pymalloc* 是 :ref:`預設分配器 <default-memory-allocators>` 的 :c:data:"
"`PYMEM_DOMAIN_MEM`（例如：:c:func:`PyMem_Malloc`）和 :c:data:"
"`PYMEM_DOMAIN_OBJ` （例如：:c:func:`PyObject_Malloc`）域。"

#: ../../c-api/memory.rst:628
#, fuzzy
msgid "The arena allocator uses the following functions:"
msgstr "競技場分配器使用以下函式："

#: ../../c-api/memory.rst:630
#, fuzzy
msgid ":c:func:`VirtualAlloc` and :c:func:`VirtualFree` on Windows,"
msgstr ":c:func:`VirtualAlloc` 和 :c:func:`VirtualFree` 在 Windows 上，"

#: ../../c-api/memory.rst:631
#, fuzzy
msgid ":c:func:`mmap` and :c:func:`munmap` if available,"
msgstr ":c:func:`mmap` 和 :c:func:`munmap` 如果可用，"

#: ../../c-api/memory.rst:632
#, fuzzy
msgid ":c:func:`malloc` and :c:func:`free` otherwise."
msgstr "否則 :c:func:`malloc` 和 :c:func:`free`。"

#: ../../c-api/memory.rst:634
#, fuzzy
msgid ""
"This allocator is disabled if Python is configured with the :option:`--"
"without-pymalloc` option. It can also be disabled at runtime using the :"
"envvar:`PYTHONMALLOC` environment variable (ex: ``PYTHONMALLOC=malloc``)."
msgstr ""
"如果使用 :option:`--without-pymalloc` 選項配置 Python，則禁用此分配器。它也可"
"以在運行時使用 PYTHONMALLOC 環境變數（例如：``PYTHONMALLOC=malloc``）禁用。"

#: ../../c-api/memory.rst:639
#, fuzzy
msgid "Customize pymalloc Arena Allocator"
msgstr "自定義 pymalloc Arena 分配器"

#: ../../c-api/memory.rst:645
#, fuzzy
msgid ""
"Structure used to describe an arena allocator. The structure has three "
"fields:"
msgstr "用於描述競技場分配器的結構。該結構包含三個欄位："

#: ../../c-api/memory.rst:653
msgid "``void* alloc(void *ctx, size_t size)``"
msgstr "``void* alloc(void *ctx, size_t size)``"

#: ../../c-api/memory.rst:653
#, fuzzy
msgid "allocate an arena of size bytes"
msgstr "分配大小位元組的競技場"

#: ../../c-api/memory.rst:655
msgid "``void free(void *ctx, void *ptr, size_t size)``"
msgstr "``void free(void *ctx, void *ptr, size_t size)``"

#: ../../c-api/memory.rst:655
#, fuzzy
msgid "free an arena"
msgstr "免費競技場"

#: ../../c-api/memory.rst:660
#, fuzzy
msgid "Get the arena allocator."
msgstr "獲取競技場分配器。"

#: ../../c-api/memory.rst:664
#, fuzzy
msgid "Set the arena allocator."
msgstr "設定競技場分配器。"

#: ../../c-api/memory.rst:668
#, fuzzy
msgid "tracemalloc C API"
msgstr "tracemalloc C API"

#: ../../c-api/memory.rst:674
#, fuzzy
msgid "Track an allocated memory block in the :mod:`tracemalloc` module."
msgstr "在 :mod:`tracemalloc` 模組中跟踪分配的記憶體塊。"

#: ../../c-api/memory.rst:676
#, fuzzy
msgid ""
"Return ``0`` on success, return ``-1`` on error (failed to allocate memory "
"to store the trace). Return ``-2`` if tracemalloc is disabled."
msgstr ""
"成功回傳 ``0``，錯誤回傳 ``-1``（無法分配記憶體來儲存跟踪）。如果禁用了 "
"tracemalloc，則回傳 ``-2``。"

#: ../../c-api/memory.rst:679
#, fuzzy
msgid "If memory block is already tracked, update the existing trace."
msgstr "如果已經跟踪記憶體塊，則更新現有跟踪。"

#: ../../c-api/memory.rst:683
#, fuzzy
msgid ""
"Untrack an allocated memory block in the :mod:`tracemalloc` module. Do "
"nothing if the block was not tracked."
msgstr ""
"在 :mod:`tracemalloc` 模組中取消跟踪分配的記憶體塊。如果塊未被跟踪，則不執行"
"任何操作。"

#: ../../c-api/memory.rst:686
#, fuzzy
msgid "Return ``-2`` if tracemalloc is disabled, otherwise return ``0``."
msgstr "如果禁用了 tracemalloc，則回傳 ``-2``，否則回傳 ``0``。"

#: ../../c-api/memory.rst:692
msgid "Examples"
msgstr "範例"

#: ../../c-api/memory.rst:694
#, fuzzy
msgid ""
"Here is the example from section :ref:`memoryoverview`, rewritten so that "
"the I/O buffer is allocated from the Python heap by using the first function "
"set::"
msgstr ""
"這是來自 :ref:`memoryoverview` 部分的示例，重寫後使用第一個函式集從 Python 堆"
"中分配 I/O 緩衝區::"

#: ../../c-api/memory.rst:707
#, fuzzy
msgid "The same code using the type-oriented function set::"
msgstr "使用面向型別的函式集的相同程式碼::"

#: ../../c-api/memory.rst:719
#, fuzzy
msgid ""
"Note that in the two examples above, the buffer is always manipulated via "
"functions belonging to the same set. Indeed, it is required to use the same "
"memory API family for a given memory block, so that the risk of mixing "
"different allocators is reduced to a minimum. The following code sequence "
"contains two errors, one of which is labeled as *fatal* because it mixes two "
"different allocators operating on different heaps. ::"
msgstr ""
"請注意，在上面的兩個示例中，緩衝區總是通過屬於同一集合的函式進行操作。實際"
"上，需要對給定的記憶體塊使用相同的記憶體 API 系列，這樣混合不同分配器的風險就"
"會降至最低。以下程式碼序列包含兩個錯誤，其中一個被標記為*致命*，因為它混合了"
"在不同堆上運行的兩個不同分配器。 ::"

#: ../../c-api/memory.rst:734
#, fuzzy
msgid ""
"In addition to the functions aimed at handling raw memory blocks from the "
"Python heap, objects in Python are allocated and released with :c:func:"
"`PyObject_New`, :c:func:`PyObject_NewVar` and :c:func:`PyObject_Del`."
msgstr ""
"除了旨在處理 Python 堆中的原始記憶體塊的函式外，Python 中的對像還使用 "
"PyObject_New、PyObject_NewVar 和 PyObject_Del 進行分配和釋放."

#: ../../c-api/memory.rst:738
#, fuzzy
msgid ""
"These will be explained in the next chapter on defining and implementing new "
"object types in C."
msgstr "這些將在下一章有關在 C 中定義和實作新對像型別的內容中進行解釋。"
