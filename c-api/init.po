# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Adrian Liaw <adrianliaw2000@gmail.com>, 2018
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-16 00:18+0000\n"
"PO-Revision-Date: 2023-04-24 20:49+0800\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../c-api/init.rst:8
#, fuzzy
msgid "Initialization, Finalization, and Threads"
msgstr "初始化、終結和執行緒"

#: ../../c-api/init.rst:10
#, fuzzy
msgid "See also :ref:`Python Initialization Configuration <init-config>`."
msgstr "另見 :ref:`Python 初始化配置 <init-config>`。"

#: ../../c-api/init.rst:15
#, fuzzy
msgid "Before Python Initialization"
msgstr "Python 初始化之前"

#: ../../c-api/init.rst:17
#, fuzzy
msgid ""
"In an application embedding  Python, the :c:func:`Py_Initialize` function "
"must be called before using any other Python/C API functions; with the "
"exception of a few functions and the :ref:`global configuration variables "
"<global-conf-vars>`."
msgstr ""
"在嵌入 Python 的應用程式中，必須在使用任何其他 Python/C API 函式之前呼叫 :c:"
"func:`Py_Initialize` 函式；除了一些函式和 :ref:`全局配置變數 <global-conf-"
"vars>`。"

#: ../../c-api/init.rst:22
#, fuzzy
msgid ""
"The following functions can be safely called before Python is initialized:"
msgstr "在 Python 初始化之前可以安全地呼叫以下函式："

#: ../../c-api/init.rst:24
#, fuzzy
msgid "Configuration functions:"
msgstr "配置功能："

#: ../../c-api/init.rst:26
msgid ":c:func:`PyImport_AppendInittab`"
msgstr ":c:func:`PyImport_AppendInittab`"

#: ../../c-api/init.rst:27
msgid ":c:func:`PyImport_ExtendInittab`"
msgstr ":c:func:`PyImport_ExtendInittab`"

#: ../../c-api/init.rst:28
msgid ":c:func:`PyInitFrozenExtensions`"
msgstr ":c:func:`PyInitFrozenExtensions`"

#: ../../c-api/init.rst:29
msgid ":c:func:`PyMem_SetAllocator`"
msgstr ":c:func:`PyMem_SetAllocator`"

#: ../../c-api/init.rst:30
msgid ":c:func:`PyMem_SetupDebugHooks`"
msgstr ":c:func:`PyMem_SetupDebugHooks`"

#: ../../c-api/init.rst:31
msgid ":c:func:`PyObject_SetArenaAllocator`"
msgstr ":c:func:`PyObject_SetArenaAllocator`"

#: ../../c-api/init.rst:32
msgid ":c:func:`Py_SetPath`"
msgstr ":c:func:`Py_SetPath`"

#: ../../c-api/init.rst:33
msgid ":c:func:`Py_SetProgramName`"
msgstr ":c:func:`Py_SetProgramName`"

#: ../../c-api/init.rst:34
msgid ":c:func:`Py_SetPythonHome`"
msgstr ":c:func:`Py_SetPythonHome`"

#: ../../c-api/init.rst:35
msgid ":c:func:`Py_SetStandardStreamEncoding`"
msgstr ":c:func:`Py_SetStandardStreamEncoding`"

#: ../../c-api/init.rst:36
msgid ":c:func:`PySys_AddWarnOption`"
msgstr ":c:func:`PySys_AddWarnOption`"

#: ../../c-api/init.rst:37
msgid ":c:func:`PySys_AddXOption`"
msgstr ":c:func:`PySys_AddXOption`"

#: ../../c-api/init.rst:38
msgid ":c:func:`PySys_ResetWarnOptions`"
msgstr ":c:func:`PySys_ResetWarnOptions`"

#: ../../c-api/init.rst:40
#, fuzzy
msgid "Informative functions:"
msgstr "資訊功能："

#: ../../c-api/init.rst:42
msgid ":c:func:`Py_IsInitialized`"
msgstr ":c:func:`Py_IsInitialized`"

#: ../../c-api/init.rst:43
msgid ":c:func:`PyMem_GetAllocator`"
msgstr ":c:func:`PyMem_GetAllocator`"

#: ../../c-api/init.rst:44
msgid ":c:func:`PyObject_GetArenaAllocator`"
msgstr ":c:func:`PyObject_GetArenaAllocator`"

#: ../../c-api/init.rst:45
msgid ":c:func:`Py_GetBuildInfo`"
msgstr ":c:func:`Py_GetBuildInfo`"

#: ../../c-api/init.rst:46
msgid ":c:func:`Py_GetCompiler`"
msgstr ":c:func:`Py_GetCompiler`"

#: ../../c-api/init.rst:47
msgid ":c:func:`Py_GetCopyright`"
msgstr ":c:func:`Py_GetCopyright`"

#: ../../c-api/init.rst:48
msgid ":c:func:`Py_GetPlatform`"
msgstr ":c:func:`Py_GetPlatform`"

#: ../../c-api/init.rst:49
msgid ":c:func:`Py_GetVersion`"
msgstr ":c:func:`Py_GetVersion`"

#: ../../c-api/init.rst:51
#, fuzzy
msgid "Utilities:"
msgstr "公用事業："

#: ../../c-api/init.rst:53
msgid ":c:func:`Py_DecodeLocale`"
msgstr ":c:func:`Py_DecodeLocale`"

#: ../../c-api/init.rst:55
#, fuzzy
msgid "Memory allocators:"
msgstr "記憶體分配器："

#: ../../c-api/init.rst:57
msgid ":c:func:`PyMem_RawMalloc`"
msgstr ":c:func:`PyMem_RawMalloc`"

#: ../../c-api/init.rst:58
msgid ":c:func:`PyMem_RawRealloc`"
msgstr ":c:func:`PyMem_RawRealloc`"

#: ../../c-api/init.rst:59
msgid ":c:func:`PyMem_RawCalloc`"
msgstr ":c:func:`PyMem_RawCalloc`"

#: ../../c-api/init.rst:60
msgid ":c:func:`PyMem_RawFree`"
msgstr ":c:func:`PyMem_RawFree`"

#: ../../c-api/init.rst:64
#, fuzzy
msgid ""
"The following functions **should not be called** before :c:func:"
"`Py_Initialize`: :c:func:`Py_EncodeLocale`, :c:func:`Py_GetPath`, :c:func:"
"`Py_GetPrefix`, :c:func:`Py_GetExecPrefix`, :c:func:"
"`Py_GetProgramFullPath`, :c:func:`Py_GetPythonHome`, :c:func:"
"`Py_GetProgramName` and :c:func:`PyEval_InitThreads`."
msgstr ""
"以下函式**不應在 :c:func:`Py_Initialize` 之前呼叫**：:c:func:"
"`Py_EncodeLocale`、:c:func:`Py_GetPath`、:c:func:`Py_GetPrefix`、:c :func:"
"`Py_GetExecPrefix`、:c:func:`Py_GetProgramFullPath`、:c:func:"
"`Py_GetPythonHome`、:c:func:`Py_GetProgramName` 和 :c:func:"
"`PyEval_InitThreads`。"

#: ../../c-api/init.rst:74
#, fuzzy
msgid "Global configuration variables"
msgstr "全局配置變數"

#: ../../c-api/init.rst:76
#, fuzzy
msgid ""
"Python has variables for the global configuration to control different "
"features and options. By default, these flags are controlled by :ref:"
"`command line options <using-on-interface-options>`."
msgstr ""
"Python 具有用於全局配置的變數來控制不同的功能和選項。預設情況下，這些旗標由 :"
"ref:`命令列選項 <using-on-interface-options>` 控制。"

#: ../../c-api/init.rst:80
#, fuzzy
msgid ""
"When a flag is set by an option, the value of the flag is the number of "
"times that the option was set. For example, ``-b`` sets :c:data:"
"`Py_BytesWarningFlag` to 1 and ``-bb`` sets :c:data:`Py_BytesWarningFlag` to "
"2."
msgstr ""
"當選項設定旗標時，旗標的值是設定選項的次數。例如，``-b`` 將 :c:data:"
"`Py_BytesWarningFlag` 設定為 1，``-bb`` 將 :c:data:`Py_BytesWarningFlag` 設定"
"為 2。"

#: ../../c-api/init.rst:86
#, fuzzy
msgid ""
"Issue a warning when comparing :class:`bytes` or :class:`bytearray` with :"
"class:`str` or :class:`bytes` with :class:`int`.  Issue an error if greater "
"or equal to ``2``."
msgstr ""
"比較 :class:`bytes` 或 :class:`bytearray` 與 :class:`str` 或 :class:`bytes` "
"與 :class:`int` 時發出警告。如果大於或等於 ``2``，則發出錯誤。"

#: ../../c-api/init.rst:90
msgid "Set by the :option:`-b` option."
msgstr "由 :option:`-b` 選項設定。"

#: ../../c-api/init.rst:94
#, fuzzy
msgid ""
"Turn on parser debugging output (for expert only, depending on compilation "
"options)."
msgstr "打開解析器除錯輸出（僅供專家使用，具體取決於編譯選項）。"

#: ../../c-api/init.rst:97
msgid ""
"Set by the :option:`-d` option and the :envvar:`PYTHONDEBUG` environment "
"variable."
msgstr "由 :option:`-d` 選項與 :envvar:`PYTHONDEBUG` 環境變數設定。"

#: ../../c-api/init.rst:102
#, fuzzy
msgid ""
"If set to non-zero, Python won't try to write ``.pyc`` files on the import "
"of source modules."
msgstr "如果設定為非零，Python 將不會嘗試在導入源模組時寫入 ``.pyc`` 文件。"

#: ../../c-api/init.rst:105
msgid ""
"Set by the :option:`-B` option and the :envvar:`PYTHONDONTWRITEBYTECODE` "
"environment variable."
msgstr ""
"由 :option:`-B` 選項與 :envvar:`PYTHONDONTWRITEBYTECODE` 環境變數設定。"

#: ../../c-api/init.rst:110
#, fuzzy
msgid ""
"Suppress error messages when calculating the module search path in :c:func:"
"`Py_GetPath`."
msgstr "在 :c:func:`Py_GetPath` 中計算模組搜索路徑時抑制錯誤消息。"

#: ../../c-api/init.rst:113
#, fuzzy
msgid "Private flag used by ``_freeze_module`` and ``frozenmain`` programs."
msgstr "``_freeze_module`` 和 ``frozenmain`` 程式使用的私有旗標。"

#: ../../c-api/init.rst:117
msgid ""
"Set to ``1`` if the :envvar:`PYTHONHASHSEED` environment variable is set to "
"a non-empty string."
msgstr ""
"如果環境變數 :envvar:`PYTHONHASHSEED` 被設定為一個非空字串則設為 ``1``。"

#: ../../c-api/init.rst:120
#, fuzzy
msgid ""
"If the flag is non-zero, read the :envvar:`PYTHONHASHSEED` environment "
"variable to initialize the secret hash seed."
msgstr "如果該旗標不為零，請讀取 PYTHONHASHSEED 環境變數以初始化秘密雜湊種子。"

#: ../../c-api/init.rst:125
#, fuzzy
msgid ""
"Ignore all :envvar:`PYTHON*` environment variables, e.g. :envvar:"
"`PYTHONPATH` and :envvar:`PYTHONHOME`, that might be set."
msgstr ""
"忽略所有 :envvar:`PYTHON*` 環境變數，例如 :envvar:`PYTHONPATH` 和 :envvar:"
"`PYTHONHOME`，可能會被設定。"

#: ../../c-api/init.rst:128
msgid "Set by the :option:`-E` and :option:`-I` options."
msgstr "由 :option:`-E` 與 :option:`-I` 選項設定。"

#: ../../c-api/init.rst:132
#, fuzzy
msgid ""
"When a script is passed as first argument or the :option:`-c` option is "
"used, enter interactive mode after executing the script or the command, even "
"when :data:`sys.stdin` does not appear to be a terminal."
msgstr ""
"當腳本作為第一個參數傳遞或使用 :option:`-c` 選項時，在執行腳本或命令後進入交"
"互模式，即使 :data:`sys.stdin` 看起來不是終端。"

#: ../../c-api/init.rst:136
msgid ""
"Set by the :option:`-i` option and the :envvar:`PYTHONINSPECT` environment "
"variable."
msgstr "由 :option:`-i` 選項與 :envvar:`PYTHONINSPECT` 環境變數設定。"

#: ../../c-api/init.rst:141
msgid "Set by the :option:`-i` option."
msgstr "由 :option:`-i` 選項設定。"

#: ../../c-api/init.rst:145
#, fuzzy
msgid ""
"Run Python in isolated mode. In isolated mode :data:`sys.path` contains "
"neither the script's directory nor the user's site-packages directory."
msgstr ""
"以隔離模式運行 Python。在隔離模式下 :data:`sys.path` 既不包含腳本的目錄，也不"
"包含使用者的站點包目錄。"

#: ../../c-api/init.rst:148
msgid "Set by the :option:`-I` option."
msgstr "由 :option:`-i` 選項設定。"

#: ../../c-api/init.rst:154
#, fuzzy
msgid ""
"If the flag is non-zero, use the ``mbcs`` encoding with ``replace`` error "
"handler, instead of the UTF-8 encoding with ``surrogatepass`` error handler, "
"for the :term:`filesystem encoding and error handler`."
msgstr ""
"如果旗標非零，則使用帶有 ``replace`` 錯誤處理程式的 ``mbcs`` 編碼，而不是帶"
"有 ``surrogatepass`` 錯誤處理程式的 UTF-8 編碼，用於文件系統編碼和錯誤處理程"
"式`。"

#: ../../c-api/init.rst:158
msgid ""
"Set to ``1`` if the :envvar:`PYTHONLEGACYWINDOWSFSENCODING` environment "
"variable is set to a non-empty string."
msgstr ""
"如果環境變數 :envvar:`PYTHONLEGACYWINDOWSFSENCODING` 被設定為一個非空字串則設"
"為 ``1``。"

#: ../../c-api/init.rst:161
msgid "See :pep:`529` for more details."
msgstr "更多詳情請見 :pep:`529`\\ 。"

#: ../../c-api/init.rst:163 ../../c-api/init.rst:175
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`適用 <availability>`：Windows。"

#: ../../c-api/init.rst:167
#, fuzzy
msgid ""
"If the flag is non-zero, use :class:`io.FileIO` instead of :class:"
"`WindowsConsoleIO` for :mod:`sys` standard streams."
msgstr ""
"如果旗標不為零，則使用 :class:`io.FileIO` 而不是 :class:`WindowsConsoleIO` 用"
"於 :mod:`sys` 標準流。"

#: ../../c-api/init.rst:170
#, fuzzy
msgid ""
"Set to ``1`` if the :envvar:`PYTHONLEGACYWINDOWSSTDIO` environment variable "
"is set to a non-empty string."
msgstr "如果 PYTHONLEGACYWINDOWSSTDIO 環境變數設定為非空字串，則設定為 1。"

#: ../../c-api/init.rst:173
msgid "See :pep:`528` for more details."
msgstr "更多詳情請見 :pep:`528`\\ 。"

#: ../../c-api/init.rst:179
#, fuzzy
msgid ""
"Disable the import of the module :mod:`site` and the site-dependent "
"manipulations of :data:`sys.path` that it entails.  Also disable these "
"manipulations if :mod:`site` is explicitly imported later (call :func:`site."
"main` if you want them to be triggered)."
msgstr ""
"禁用模組 :mod:`site` 的導入和它需要的 :data:`sys.path` 的站點相關操作。如果稍"
"後顯式導入 :mod:`site`，也禁用這些操作（如果您希望觸發它們，請呼叫 :func:"
"`site.main`）。"

#: ../../c-api/init.rst:184
msgid "Set by the :option:`-S` option."
msgstr "由 :option:`-S` 選項設定。"

#: ../../c-api/init.rst:188
#, fuzzy
msgid ""
"Don't add the :data:`user site-packages directory <site.USER_SITE>` to :data:"
"`sys.path`."
msgstr ""
"不要將 :data:`user site-packages 目錄 <site.USER_SITE>` 新增到 :data:`sys."
"path`。"

#: ../../c-api/init.rst:191
msgid ""
"Set by the :option:`-s` and :option:`-I` options, and the :envvar:"
"`PYTHONNOUSERSITE` environment variable."
msgstr ""
"由 :option:`-s` 選項、:option:`-I` 選項與 :envvar:`PYTHONNOUSERSITE` 環境變數"
"設定。"

#: ../../c-api/init.rst:196
msgid ""
"Set by the :option:`-O` option and the :envvar:`PYTHONOPTIMIZE` environment "
"variable."
msgstr "由 :option:`-O` 選項與 :envvar:`PYTHONOPTIMIZE` 環境變數設定。"

#: ../../c-api/init.rst:201
#, fuzzy
msgid ""
"Don't display the copyright and version messages even in interactive mode."
msgstr "即使在交互模式下也不要顯示版權和版本消息。"

#: ../../c-api/init.rst:203
msgid "Set by the :option:`-q` option."
msgstr "由 :option:`-q` 選項設定。"

#: ../../c-api/init.rst:209
#, fuzzy
msgid "Force the stdout and stderr streams to be unbuffered."
msgstr "強制不緩衝 stdout 和 stderr 流。"

#: ../../c-api/init.rst:211
msgid ""
"Set by the :option:`-u` option and the :envvar:`PYTHONUNBUFFERED` "
"environment variable."
msgstr "由 :option:`-u` 選項與 :envvar:`PYTHONUNBUFFERED` 環境變數設定。"

#: ../../c-api/init.rst:216
#, fuzzy
msgid ""
"Print a message each time a module is initialized, showing the place "
"(filename or built-in module) from which it is loaded.  If greater or equal "
"to ``2``, print a message for each file that is checked for when searching "
"for a module. Also provides information on module cleanup at exit."
msgstr ""
"每次初始化模組時印出一條消息，顯示加載它的位置（文件名或內建模組）。如果大於"
"或等於 ``2``，則為搜索模組時檢查的每個文件印出一條消息。還提供有關退出時模組"
"清理的資訊。"

#: ../../c-api/init.rst:221
msgid ""
"Set by the :option:`-v` option and the :envvar:`PYTHONVERBOSE` environment "
"variable."
msgstr "由 :option:`-v` 選項與 :envvar:`PYTHONVERBOSE` 環境變數設定。"

#: ../../c-api/init.rst:226
#, fuzzy
msgid "Initializing and finalizing the interpreter"
msgstr "初始化和完成直譯器"

#: ../../c-api/init.rst:244
#, fuzzy
msgid ""
"Initialize the Python interpreter.  In an application embedding  Python, "
"this should be called before using any other Python/C API functions; see :"
"ref:`Before Python Initialization <pre-init-safe>` for the few exceptions."
msgstr ""
"初始化 Python 直譯器。在嵌入 Python 的應用程式中，應在使用任何其他 Python/C "
"API 函式之前呼叫它；有關少數例外情況，請參閱 :ref:`Before Python "
"Initialization <pre-init-safe>`。"

#: ../../c-api/init.rst:248
#, fuzzy
msgid ""
"This initializes the table of loaded modules (``sys.modules``), and creates "
"the fundamental modules :mod:`builtins`, :mod:`__main__` and :mod:`sys`.  It "
"also initializes the module search path (``sys.path``). It does not set "
"``sys.argv``; use :c:func:`PySys_SetArgvEx` for that.  This is a no-op when "
"called for a second time (without calling :c:func:`Py_FinalizeEx` first).  "
"There is no return value; it is a fatal error if the initialization fails."
msgstr ""
"這會初始化加載模組表 (``sys.modules``)，並建立基本模組 :mod:`builtins`、:mod:"
"`__main__` 和 :mod:`sys`。它還會初始化模組搜索路徑（``sys.path``）。它不設定 "
"``sys.argv``；為此使用:c:func:`PySys_SetArgvEx`。這是第二次呼叫時的空操作（沒"
"有先呼叫 :c:func:`Py_FinalizeEx`）。沒有回傳值；如果初始化失敗，則為致命錯"
"誤。"

#: ../../c-api/init.rst:257
#, fuzzy
msgid ""
"On Windows, changes the console mode from ``O_TEXT`` to ``O_BINARY``, which "
"will also affect non-Python uses of the console using the C Runtime."
msgstr ""
"在 Windows 上，將控制台模式從“O_TEXT”更改為“O_BINARY”，這也會影響使用 C 運行"
"時的控制台的非 Python 使用。"

#: ../../c-api/init.rst:263
#, fuzzy
msgid ""
"This function works like :c:func:`Py_Initialize` if *initsigs* is ``1``. If "
"*initsigs* is ``0``, it skips initialization registration of signal "
"handlers, which might be useful when Python is embedded."
msgstr ""
"如果 *initsigs* 為 ``1``，此函式的工作方式類似於 :c:func:`Py_Initialize`。如"
"果 *initsigs* 為 ``0``，它會跳過信號處理程式的初始化註冊，這在嵌入 Python 時"
"可能很有用。"

#: ../../c-api/init.rst:270
#, fuzzy
msgid ""
"Return true (nonzero) when the Python interpreter has been initialized, "
"false (zero) if not.  After :c:func:`Py_FinalizeEx` is called, this returns "
"false until :c:func:`Py_Initialize` is called again."
msgstr ""
"Python 直譯器初始化後回傳真（非零），否則回傳假（零）。在呼叫 :c:func:"
"`Py_FinalizeEx` 之後，回傳 false 直到再次呼叫 :c:func:`Py_Initialize`。"

#: ../../c-api/init.rst:277
#, fuzzy
msgid ""
"Undo all initializations made by :c:func:`Py_Initialize` and subsequent use "
"of Python/C API functions, and destroy all sub-interpreters (see :c:func:"
"`Py_NewInterpreter` below) that were created and not yet destroyed since the "
"last call to :c:func:`Py_Initialize`.  Ideally, this frees all memory "
"allocated by the Python interpreter.  This is a no-op when called for a "
"second time (without calling :c:func:`Py_Initialize` again first).  Normally "
"the return value is ``0``.  If there were errors during finalization "
"(flushing buffered data), ``-1`` is returned."
msgstr ""
"撤消由 Py_Initialize 進行的所有初始化以及隨後對 Python/C API 函式的使用，並銷"
"毀所有自最後呼叫 :c:func:`Py_Initialize`。理想情況下，這會釋放 Python 直譯器"
"分配的所有記憶體。這是第二次呼叫時的空操作（無需先再次呼叫 :c:func:"
"`Py_Initialize`）。通常回傳值為 ``0``。如果在完成過程中出現錯誤（刷新緩衝資"
"料），則回傳 ``-1``。"

#: ../../c-api/init.rst:286
#, fuzzy
msgid ""
"This function is provided for a number of reasons.  An embedding application "
"might want to restart Python without having to restart the application "
"itself. An application that has loaded the Python interpreter from a "
"dynamically loadable library (or DLL) might want to free all memory "
"allocated by Python before unloading the DLL. During a hunt for memory leaks "
"in an application a developer might want to free all memory allocated by "
"Python before exiting from the application."
msgstr ""
"出於多種原因提供此功能。嵌入應用程式可能希望在不必重新啟動應用程式本身的情況"
"下重新啟動 Python。從動態可加載庫（或 DLL）加載 Python 直譯器的應用程式可能希"
"望在卸載 DLL 之前釋放 Python 分配的所有記憶體。在尋找應用程式中的記憶體洩漏期"
"間，開發人員可能希望在退出應用程式之前釋放 Python 分配的所有記憶體。"

#: ../../c-api/init.rst:294
#, fuzzy
msgid ""
"**Bugs and caveats:** The destruction of modules and objects in modules is "
"done in random order; this may cause destructors (:meth:`__del__` methods) "
"to fail when they depend on other objects (even functions) or modules.  "
"Dynamically loaded extension modules loaded by Python are not unloaded.  "
"Small amounts of memory allocated by the Python interpreter may not be freed "
"(if you find a leak, please report it).  Memory tied up in circular "
"references between objects is not freed.  Some memory allocated by extension "
"modules may not be freed.  Some extensions may not work properly if their "
"initialization routine is called more than once; this can happen if an "
"application calls :c:func:`Py_Initialize` and :c:func:`Py_FinalizeEx` more "
"than once."
msgstr ""
"**Bugs and caveats:** 模組和模組中物件的銷毀是隨機進行的；這可能會導致析構函"
"式（:meth:`__del__` 方法）在依賴於其他物件（甚至函式）或模組時失敗。由 "
"Python 加載的動態加載的擴充模組不會被卸載。 Python 直譯器分配的少量記憶體可能"
"不會被釋放（如果發現洩漏，請報告）。在物件之間的循環引用中佔用的記憶體不會被"
"釋放。一些由擴充模組分配的記憶體可能不會被釋放。如果多次呼叫它們的初始化例"
"程，某些擴充可能無法正常工作；如果應用程式呼叫 :c:func:`Py_Initialize` 和 :c:"
"func:`Py_FinalizeEx` 不止一次，就會發生這種情況。"

#: ../../c-api/init.rst:305
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython."
"_PySys_ClearAuditHooks`` with no arguments."
msgstr ""
"引發一個不附帶引數的\\ :ref:`稽核事件 <auditing>` ``cpython."
"_PySys_ClearAuditHooks``。"

#: ../../c-api/init.rst:311
#, fuzzy
msgid ""
"This is a backwards-compatible version of :c:func:`Py_FinalizeEx` that "
"disregards the return value."
msgstr "這是 :c:func:`Py_FinalizeEx` 的向後相容版本，忽略了回傳值。"

#: ../../c-api/init.rst:316
#, fuzzy
msgid "Process-wide parameters"
msgstr "行程範圍的參數"

#: ../../c-api/init.rst:326
#, fuzzy
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"stdio_encoding` and :c:member:`PyConfig.stdio_errors` should be used "
"instead, see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"保留此 API 是為了向後相容：設定 :c:member:`PyConfig.stdio_encoding` 和:c:"
"member:`PyConfig.stdio_errors` 應該改為使用，請參閱 :ref:`Python 初始化配置 "
"<init-config>`。"

#: ../../c-api/init.rst:331
#, fuzzy
msgid ""
"This function should be called before :c:func:`Py_Initialize`, if it is "
"called at all. It specifies which encoding and error handling to use with "
"standard IO, with the same meanings as in :func:`str.encode`."
msgstr ""
"這個函式應該在 :c:func:`Py_Initialize` 之前呼叫，如果它被呼叫的話。它指定與標"
"準 IO 一起使用的編碼和錯誤處理，與 :func:`str.encode` 中的含義相同。"

#: ../../c-api/init.rst:335
#, fuzzy
msgid ""
"It overrides :envvar:`PYTHONIOENCODING` values, and allows embedding code to "
"control IO encoding when the environment variable does not work."
msgstr ""
"它覆蓋 :envvar:`PYTHONIOENCODING` 值，並允許在環境變數不起作用時嵌入程式碼來"
"控制 IO 編碼。"

#: ../../c-api/init.rst:338
#, fuzzy
msgid ""
"*encoding* and/or *errors* may be ``NULL`` to use :envvar:`PYTHONIOENCODING` "
"and/or default values (depending on other settings)."
msgstr ""
"*encoding* 和/或 *errors* 可能是 ``NULL`` 以使用 :envvar:`PYTHONIOENCODING` "
"和/或預設值（取決於其他設定）。"

#: ../../c-api/init.rst:342
#, fuzzy
msgid ""
"Note that :data:`sys.stderr` always uses the \"backslashreplace\" error "
"handler, regardless of this (or any other) setting."
msgstr ""
"請注意 :data:`sys.stderr` 始終使用 ``backslashreplace`` 錯誤處理程式，無論此"
"（或任何其他）設定如何。"

#: ../../c-api/init.rst:345
#, fuzzy
msgid ""
"If :c:func:`Py_FinalizeEx` is called, this function will need to be called "
"again in order to affect subsequent calls to :c:func:`Py_Initialize`."
msgstr ""
"如果 :c:func:`Py_FinalizeEx` 被呼叫，則需要再次呼叫此函式以影響對 :c:func:"
"`Py_Initialize` 的後續呼叫。"

#: ../../c-api/init.rst:348
#, fuzzy
msgid ""
"Returns ``0`` if successful, a nonzero value on error (e.g. calling after "
"the interpreter has already been initialized)."
msgstr ""
"如果成功則回傳 ``0``，錯誤時回傳一個非零值（例如，在直譯器已經初始化之後呼"
"叫）。"

#: ../../c-api/init.rst:363
#, fuzzy
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"program_name` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""
"保留此 API 是為了向後相容：應改用設定 :c:member:`PyConfig.program_name`，請參"
"閱 :ref:`Python 初始化配置 <init-config>`。"

#: ../../c-api/init.rst:367
#, fuzzy
msgid ""
"This function should be called before :c:func:`Py_Initialize` is called for "
"the first time, if it is called at all.  It tells the interpreter the value "
"of the ``argv[0]`` argument to the :c:func:`main` function of the program "
"(converted to wide characters). This is used by :c:func:`Py_GetPath` and "
"some other functions below to find the Python run-time libraries relative to "
"the interpreter executable.  The default value is ``'python'``.  The "
"argument should point to a zero-terminated wide character string in static "
"storage whose contents will not change for the duration of the program's "
"execution.  No code in the Python interpreter will change the contents of "
"this storage."
msgstr ""
"這個函式應該在 :c:func:`Py_Initialize` 第一次被呼叫之前被呼叫，如果它被呼叫的"
"話。它告訴直譯器程式的 :c:func:`main` 函式的 ``argv[0]`` 參數的值（轉換為寬字"
"元）。 :c:func:`Py_GetPath` 和下面的一些其他函式使用它來查找與直譯器可執行文"
"件相關的 Python 運行時庫。預設值是 ``'python'``。該參數應指向靜態儲存中以零結"
"尾的寬字串，其內容在程式執行期間不會更改。 Python 直譯器中的任何程式碼都不會"
"更改此儲存的內容。"

#: ../../c-api/init.rst:378 ../../c-api/init.rst:529 ../../c-api/init.rst:644
#: ../../c-api/init.rst:680 ../../c-api/init.rst:706
#, fuzzy
msgid ""
"Use :c:func:`Py_DecodeLocale` to decode a bytes string to get a :c:expr:"
"`wchar_*` string."
msgstr ""
"使用 :c:function:`Py_DecodeLocale` 解碼位元組字串以獲得 :c:expr:`wchar_t*` 字"
"串。"

#: ../../c-api/init.rst:388
#, fuzzy
msgid ""
"Return the program name set with :c:func:`Py_SetProgramName`, or the "
"default. The returned string points into static storage; the caller should "
"not modify its value."
msgstr ""
"回傳使用 :c:func:`Py_SetProgramName` 或預設設定的程式名稱。回傳的字串指向靜態"
"儲存；呼叫者不應修改其值。"

#: ../../c-api/init.rst:392 ../../c-api/init.rst:411 ../../c-api/init.rst:452
#: ../../c-api/init.rst:471 ../../c-api/init.rst:495 ../../c-api/init.rst:718
#, fuzzy
msgid ""
"This function should not be called before :c:func:`Py_Initialize`, otherwise "
"it returns ``NULL``."
msgstr "此函式不應在 :c:func:`Py_Initialize` 之前呼叫，否則回傳 ``NULL``。"

#: ../../c-api/init.rst:395 ../../c-api/init.rst:414 ../../c-api/init.rst:455
#: ../../c-api/init.rst:474 ../../c-api/init.rst:500 ../../c-api/init.rst:721
#, fuzzy
msgid "It now returns ``NULL`` if called before :c:func:`Py_Initialize`."
msgstr "如果在 :c:func:`Py_Initialize` 之前呼叫，它現在回傳 ``NULL``。"

#: ../../c-api/init.rst:401
#, fuzzy
msgid ""
"Return the *prefix* for installed platform-independent files. This is "
"derived through a number of complicated rules from the program name set "
"with :c:func:`Py_SetProgramName` and some environment variables; for "
"example, if the program name is ``'/usr/local/bin/python'``, the prefix is "
"``'/usr/local'``. The returned string points into static storage; the caller "
"should not modify its value.  This corresponds to the :makevar:`prefix` "
"variable in the top-level :file:`Makefile` and the :option:`--prefix` "
"argument to the :program:`configure` script at build time.  The value is "
"available to Python code as ``sys.prefix``. It is only useful on Unix.  See "
"also the next function."
msgstr ""
"回傳已安裝的獨立於平台的文件的 *prefix*。這是通過使用 Py_SetProgramName 和一"
"些環境變數設定的程式名稱通過許多複雜的規則得出的；例如，如果程式名稱是 ``'/"
"usr/local/bin/python'``，則前綴是 ``'/usr/local'``。回傳的字串指向靜態儲存；"
"呼叫者不應修改其值。這對應於頂級 :file:`Makefile` 中的 :makevar:`prefix` 變數"
"和構建時 :program:`configure` 腳本的 :option:`--prefix` 參數。該值作為 sys."
"prefix 可用於 Python 程式碼。它只在 Unix 上有用。另見下一個函式。"

#: ../../c-api/init.rst:420
#, fuzzy
msgid ""
"Return the *exec-prefix* for installed platform-*dependent* files.  This is "
"derived through a number of complicated rules from the program name set "
"with :c:func:`Py_SetProgramName` and some environment variables; for "
"example, if the program name is ``'/usr/local/bin/python'``, the exec-prefix "
"is ``'/usr/local'``.  The returned string points into static storage; the "
"caller should not modify its value.  This corresponds to the :makevar:"
"`exec_prefix` variable in the top-level :file:`Makefile` and the ``--exec-"
"prefix`` argument to the :program:`configure` script at build  time.  The "
"value is available to Python code as ``sys.exec_prefix``.  It is only useful "
"on Unix."
msgstr ""
"為安裝的平台*依賴*文件回傳*exec-prefix*。這是通過使用 Py_SetProgramName 和一"
"些環境變數設定的程式名稱通過許多複雜的規則得出的；例如，如果程式名稱是“/usr/"
"local/bin/python”，則執行前綴是“/usr/local”。回傳的字串指向靜態儲存；呼叫者不"
"應修改其值。這對應於頂層 Makefile 中的 exec_prefix 變數和構建時 configure 腳"
"本的 --exec-prefix 參數。該值作為 sys.exec_prefix 可用於 Python 程式碼。它只"
"在 Unix 上有用。"

#: ../../c-api/init.rst:430
#, fuzzy
msgid ""
"Background: The exec-prefix differs from the prefix when platform dependent "
"files (such as executables and shared libraries) are installed in a "
"different directory tree.  In a typical installation, platform dependent "
"files may be installed in the :file:`/usr/local/plat` subtree while platform "
"independent may be installed in :file:`/usr/local`."
msgstr ""
"背景：exec-prefix 與平台相關文件（例如可執行文件和共享庫）安裝在不同目錄樹中"
"時的前綴不同。在典型安裝中，平台相關文件可能安裝在 :file:`/usr/local/plat` 子"
"樹中，而平台無關文件可能安裝在 :file:`/usr/local` 中。"

#: ../../c-api/init.rst:436
#, fuzzy
msgid ""
"Generally speaking, a platform is a combination of hardware and software "
"families, e.g.  Sparc machines running the Solaris 2.x operating system are "
"considered the same platform, but Intel machines running Solaris 2.x are "
"another platform, and Intel machines running Linux are yet another "
"platform.  Different major revisions of the same operating system generally "
"also form different platforms.  Non-Unix operating systems are a different "
"story; the installation strategies on those systems are so different that "
"the prefix and exec-prefix are meaningless, and set to the empty string. "
"Note that compiled Python bytecode files are platform independent (but not "
"independent from the Python version by which they were compiled!)."
msgstr ""
"一般來說，平台是硬件和軟件系列的組合，例如運行 Solaris 2.x 操作系統的 Sparc "
"機器被認為是同一平台，但運行 Solaris 2.x 的 Intel 機器是另一個平台，而運行 "
"Linux 的 Intel 機器又是另一個平台。同一操作系統的不同主要修訂版通常也形成不同"
"的平台。非 Unix 操作系統是另一回事。這些系統上的安裝策略非常不同，以至於 "
"prefix 和 exec-prefix 沒有意義，並設定為空字串。請注意，已編譯的 Python 位元"
"組碼文件是平台獨立的（但不獨立於編譯它們的 Python 版本！）。"

#: ../../c-api/init.rst:447
#, fuzzy
msgid ""
"System administrators will know how to configure the :program:`mount` or :"
"program:`automount` programs to share :file:`/usr/local` between platforms "
"while having :file:`/usr/local/plat` be a different filesystem for each "
"platform."
msgstr ""
"系統管理員將知道如何配置 :program:`mount` 或 :program:`automount` 程式以在平"
"台之間共享 :file:`/usr/local` 同時讓 :file:`/usr/local/plat` 成為一個每個平台"
"的不同文件系統。"

#: ../../c-api/init.rst:465
#, fuzzy
msgid ""
"Return the full program name of the Python executable; this is  computed as "
"a side-effect of deriving the default module search path  from the program "
"name (set by :c:func:`Py_SetProgramName` above). The returned string points "
"into static storage; the caller should not modify its value.  The value is "
"available to Python code as ``sys.executable``."
msgstr ""
"回傳 Python 可執行文件的完整程式名；這是從程式名稱（由上面的 "
"Py_SetProgramName 設定）派生預設模組搜索路徑的副作用計算得出的。回傳的字串指"
"向靜態儲存；呼叫者不應修改其值。該值可作為 ``sys.executable`` 用於 Python 程"
"式碼。"

#: ../../c-api/init.rst:485
#, fuzzy
msgid ""
"Return the default module search path; this is computed from the program "
"name (set by :c:func:`Py_SetProgramName` above) and some environment "
"variables. The returned string consists of a series of directory names "
"separated by a platform dependent delimiter character.  The delimiter "
"character is ``':'`` on Unix and macOS, ``';'`` on Windows.  The returned "
"string points into static storage; the caller should not modify its value.  "
"The list :data:`sys.path` is initialized with this value on interpreter "
"startup; it can be (and usually is) modified later to change the search path "
"for loading modules."
msgstr ""
"回傳預設的模組搜索路徑；這是根據程式名稱（由上面的 Py_SetProgramName 設定）和"
"一些環境變數計算得出的。回傳的字串由一系列由平台相關的分隔符分隔的目錄名稱組"
"成。分隔符在 Unix 和 macOS 上是 ``':'``，在 Windows 上是 ``';'``。回傳的字串"
"指向靜態儲存；呼叫者不應修改其值。列表 :data:`sys.path` 在直譯器啟動時用這個"
"值初始化；它可以（通常是）稍後修改以更改加載模組的搜索路徑。"

#: ../../c-api/init.rst:511
#, fuzzy
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"module_search_paths` and :c:member:`PyConfig.module_search_paths_set` should "
"be used instead, see :ref:`Python Initialization Configuration <init-"
"config>`."
msgstr ""
"保留此 API 是為了向後相容：設定 :c:member:`PyConfig.module_search_paths` 和:"
"c:member:`PyConfig.module_search_paths_set` 應改為使用，請參閱 :ref:`Python "
"初始化配置 <init-config>`。"

#: ../../c-api/init.rst:516
#, fuzzy
msgid ""
"Set the default module search path.  If this function is called before :c:"
"func:`Py_Initialize`, then :c:func:`Py_GetPath` won't attempt to compute a "
"default search path but uses the one provided instead.  This is useful if "
"Python is embedded by an application that has full knowledge of the location "
"of all modules.  The path components should be separated by the platform "
"dependent delimiter character, which is ``':'`` on Unix and macOS, ``';'`` "
"on Windows."
msgstr ""
"設定預設模組搜索路徑。如果在 :c:func:`Py_Initialize` 之前呼叫此函式，則 :c:"
"func:`Py_GetPath` 不會嘗試計算預設搜索路徑，而是使用提供的搜索路徑。如果 "
"Python 被完全了解所有模組位置的應用程式嵌入，這將很有用。路徑組件應由平台相關"
"的定界符分隔，在 Unix 和 macOS 上為 ``':'``，在 Windows 上為 ``';'``。"

#: ../../c-api/init.rst:524
#, fuzzy
msgid ""
"This also causes :data:`sys.executable` to be set to the program full path "
"(see :c:func:`Py_GetProgramFullPath`) and for :data:`sys.prefix` and :data:"
"`sys.exec_prefix` to be empty.  It is up to the caller to modify these if "
"required after calling :c:func:`Py_Initialize`."
msgstr ""
"這也會導致 :data:`sys.executable` 被設定為程式完整路徑（參見 :c:func:"
"`Py_GetProgramFullPath`）以及 :data:`sys.prefix` 和 :data:`sys.exec_prefix` "
"到是空的。如果需要，呼叫者可以在呼叫 Py_Initialize 後修改它們。"

#: ../../c-api/init.rst:532
#, fuzzy
msgid ""
"The path argument is copied internally, so the caller may free it after the "
"call completes."
msgstr "路徑參數在內部複製，因此呼叫者可以在呼叫完成後釋放它。"

#: ../../c-api/init.rst:535
#, fuzzy
msgid ""
"The program full path is now used for :data:`sys.executable`, instead of the "
"program name."
msgstr "程式完整路徑現在用於 :data:`sys.executable`，而不是程式名稱。"

#: ../../c-api/init.rst:544
#, fuzzy
msgid ""
"Return the version of this Python interpreter.  This is a string that looks "
"something like ::"
msgstr "回傳此 Python 直譯器的版本。這是一個類似於 :: 的字串"

#: ../../c-api/init.rst:551
#, fuzzy
msgid ""
"The first word (up to the first space character) is the current Python "
"version; the first characters are the major and minor version separated by a "
"period.  The returned string points into static storage; the caller should "
"not modify its value.  The value is available to Python code as :data:`sys."
"version`."
msgstr ""
"第一個單詞（直到第一個空格字元）是當前的 Python 版本；第一個字元是用句點分隔"
"的主要版本和次要版本。回傳的字串指向靜態儲存；呼叫者不應修改其值。該值可用於 "
"Python 程式碼，如 :data:`sys.version`。"

#: ../../c-api/init.rst:556
#, fuzzy
msgid "See also the :c:var:`Py_Version` constant."
msgstr "另見 :c:var:`Py_Version` 常數。"

#: ../../c-api/init.rst:563
#, fuzzy
msgid ""
"Return the platform identifier for the current platform.  On Unix, this is "
"formed from the \"official\" name of the operating system, converted to "
"lower case, followed by the major revision number; e.g., for Solaris 2.x, "
"which is also known as SunOS 5.x, the value is ``'sunos5'``.  On macOS, it "
"is ``'darwin'``.  On Windows, it is ``'win'``.  The returned string points "
"into static storage; the caller should not modify its value.  The value is "
"available to Python code as ``sys.platform``."
msgstr ""
"回傳當前平台的平台標識符。在 Unix 上，這是由操作系統的“官方”名稱組成，轉換為"
"小寫，後跟主要修訂號；例如，對於也稱為 SunOS 5.x 的 Solaris 2.x，該值為 "
"``'sunos5'``。在 macOS 上，它是 ``'darwin'``。在 Windows 上，它是 ``'win'``。"
"回傳的字串指向靜態儲存；呼叫者不應修改其值。該值可作為 ``sys.platform`` 用於 "
"Python 程式碼。"

#: ../../c-api/init.rst:574
#, fuzzy
msgid ""
"Return the official copyright string for the current Python version, for "
"example"
msgstr "例如，回傳當前 Python 版本的官方版權字串"

#: ../../c-api/init.rst:576
msgid "``'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam'``"
msgstr "``'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam'``"

#: ../../c-api/init.rst:580
#, fuzzy
msgid ""
"The returned string points into static storage; the caller should not modify "
"its value.  The value is available to Python code as ``sys.copyright``."
msgstr ""
"回傳的字串指向靜態儲存；呼叫者不應修改其值。該值可作為 ``sys.copyright`` 用"
"於 Python 程式碼。"

#: ../../c-api/init.rst:586
#, fuzzy
msgid ""
"Return an indication of the compiler used to build the current Python "
"version, in square brackets, for example::"
msgstr "在方括號中回傳用於構建當前 Python 版本的編譯器的指示，例如："

#: ../../c-api/init.rst:593 ../../c-api/init.rst:607
#, fuzzy
msgid ""
"The returned string points into static storage; the caller should not modify "
"its value.  The value is available to Python code as part of the variable "
"``sys.version``."
msgstr ""
"回傳的字串指向靜態儲存；呼叫者不應修改其值。該值作為變數“sys.version”的一部分"
"可用於 Python 程式碼。"

#: ../../c-api/init.rst:600
#, fuzzy
msgid ""
"Return information about the sequence number and build date and time  of the "
"current Python interpreter instance, for example ::"
msgstr "回傳有關當前 Python 直譯器實例的序列號和構建日期和時間的資訊，例如 ::"

#: ../../c-api/init.rst:619
#, fuzzy
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"argv`, :c:member:`PyConfig.parse_argv` and :c:member:`PyConfig.safe_path` "
"should be used instead, see :ref:`Python Initialization Configuration <init-"
"config>`."
msgstr ""
"保留此 API 是為了向後相容：設定 :c:member:`PyConfig.argv`、:c:member:"
"`PyConfig.parse_argv` 和 :c:member:`PyConfig.safe_path` 應該改為使用，請參"
"閱：ref： `Python 初始化配置 <init-config>`。"

#: ../../c-api/init.rst:624
#, fuzzy
msgid ""
"Set :data:`sys.argv` based on *argc* and *argv*.  These parameters are "
"similar to those passed to the program's :c:func:`main` function with the "
"difference that the first entry should refer to the script file to be "
"executed rather than the executable hosting the Python interpreter.  If "
"there isn't a script that will be run, the first entry in *argv* can be an "
"empty string.  If this function fails to initialize :data:`sys.argv`, a "
"fatal condition is signalled using :c:func:`Py_FatalError`."
msgstr ""
"基於 *argc* 和 *argv* 設定 :data:`sys.argv`。這些參數類似於傳遞給程式的 :c:"
"func:`main` 函式的參數，不同之處在於第一個條目應該引用要執行的腳本文件，而不"
"是託管 Python 直譯器的可執行文件。如果沒有要運行的腳本，*argv* 中的第一個條目"
"可以是空字串。如果此函式無法初始化 :data:`sys.argv`，則會使用 :c:func:"
"`Py_FatalError` 發出致命情況信號。"

#: ../../c-api/init.rst:632
#, fuzzy
msgid ""
"If *updatepath* is zero, this is all the function does.  If *updatepath* is "
"non-zero, the function also modifies :data:`sys.path` according to the "
"following algorithm:"
msgstr ""
"如果 *updatepath* 為零，這就是該函式所做的全部。如果 *updatepath* 不為零，該"
"函式還會根據以下演算法修改 :data:`sys.path`："

#: ../../c-api/init.rst:636
#, fuzzy
msgid ""
"If the name of an existing script is passed in ``argv[0]``, the absolute "
"path of the directory where the script is located is prepended to :data:`sys."
"path`."
msgstr ""
"如果在 ``argv[0]`` 中傳遞現有腳本的名稱，腳本所在目錄的絕對路徑將被新增到 :"
"data:`sys.path` 之前。"

#: ../../c-api/init.rst:639
#, fuzzy
msgid ""
"Otherwise (that is, if *argc* is ``0`` or ``argv[0]`` doesn't point to an "
"existing file name), an empty string is prepended to :data:`sys.path`, which "
"is the same as prepending the current working directory (``\".\"``)."
msgstr ""
"否則（也就是說，如果 *argc* 是 ``0`` 或 ``argv[0]`` 不指向現有文件名），一個"
"空字串被新增到 :data:`sys.path` 之前，這與在當前工作目錄前加上 (``\".\"``) 相"
"同。"

#: ../../c-api/init.rst:647 ../../c-api/init.rst:683
#, fuzzy
msgid ""
"See also :c:member:`PyConfig.orig_argv` and :c:member:`PyConfig.argv` "
"members of the :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"另見 :c:member:`PyConfig.orig_argv` 和:c:member:`PyConfig.argv` Python 初始化"
"配置 <init-config> 的成員。"

#: ../../c-api/init.rst:651
#, fuzzy
msgid ""
"It is recommended that applications embedding the Python interpreter for "
"purposes other than executing a single script pass ``0`` as *updatepath*, "
"and update :data:`sys.path` themselves if desired. See `CVE-2008-5983 "
"<https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5983>`_."
msgstr ""
"建議嵌入 Python 直譯器的應用程式除了執行單個腳本之外，還可以將 ``0``作為 "
"*updatepath* 傳遞，並在需要時自行更新 sys.path。請參閱`CVE-2008-5983 "
"<https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5983>`_。"

#: ../../c-api/init.rst:656
#, fuzzy
msgid ""
"On versions before 3.1.3, you can achieve the same effect by manually "
"popping the first :data:`sys.path` element after having called :c:func:"
"`PySys_SetArgv`, for example using::"
msgstr ""
"在 3.1.3 之前的版本中，您可以通過在呼叫 :c:func:`PySys_SetArgv` 後手動彈出第"
"一個 :data:`sys.path` 元素來實作相同的效果，例如使用 ::"

#: ../../c-api/init.rst:672
#, fuzzy
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"argv` and :c:member:`PyConfig.parse_argv` should be used instead, see :ref:"
"`Python Initialization Configuration <init-config>`."
msgstr ""
"保留此 API 是為了向後相容：設定 :c:member:`PyConfig.argv` 和:c:member:"
"`PyConfig.parse_argv` 應該改為使用，請參閱 :ref:`Python 初始化配置 <init-"
"config>`。"

#: ../../c-api/init.rst:676
#, fuzzy
msgid ""
"This function works like :c:func:`PySys_SetArgvEx` with *updatepath* set to "
"``1`` unless the :program:`python` interpreter was started with the :option:"
"`-I`."
msgstr ""
"此函式的工作方式類似於 :c:func:`PySys_SetArgvEx`，*updatepath* 設定為 ``1``，"
"除非 :program:`python` 直譯器是使用 :option:`-I` 啟動的。"

#: ../../c-api/init.rst:686
#, fuzzy
msgid "The *updatepath* value depends on :option:`-I`."
msgstr "*updatepath* 值取決於 :option:`-I`。"

#: ../../c-api/init.rst:693
#, fuzzy
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"home` should be used instead, see :ref:`Python Initialization Configuration "
"<init-config>`."
msgstr ""
"保留此 API 是為了向後相容：應改用設定 :c:member:`PyConfig.home`，請參閱 :ref:"
"`Python 初始化配置 <init-config>`。"

#: ../../c-api/init.rst:697
#, fuzzy
msgid ""
"Set the default \"home\" directory, that is, the location of the standard "
"Python libraries.  See :envvar:`PYTHONHOME` for the meaning of the argument "
"string."
msgstr ""
"設定預設的 \"home\" 目錄，即標準 Python 庫的位置。有關參數字串的含義，請參"
"見 :envvar:`PYTHONHOME`。"

#: ../../c-api/init.rst:701
#, fuzzy
msgid ""
"The argument should point to a zero-terminated character string in static "
"storage whose contents will not change for the duration of the program's "
"execution.  No code in the Python interpreter will change the contents of "
"this storage."
msgstr ""
"該參數應指向靜態儲存中的一個以零結尾的字串，其內容在程式執行期間不會改變。 "
"Python 直譯器中的任何程式碼都不會更改此儲存的內容。"

#: ../../c-api/init.rst:714
#, fuzzy
msgid ""
"Return the default \"home\", that is, the value set by a previous call to :c:"
"func:`Py_SetPythonHome`, or the value of the :envvar:`PYTHONHOME` "
"environment variable if it is set."
msgstr ""
"回傳預設的 ``home``，即之前呼叫 Py_SetPythonHome 設定的值，或者 PYTHONHOME 環"
"境變數的值（如果已設定）。"

#: ../../c-api/init.rst:728
#, fuzzy
msgid "Thread State and the Global Interpreter Lock"
msgstr "執行緒狀態和全局直譯器鎖"

#: ../../c-api/init.rst:735
#, fuzzy
msgid ""
"The Python interpreter is not fully thread-safe.  In order to support multi-"
"threaded Python programs, there's a global lock, called the :term:`global "
"interpreter lock` or :term:`GIL`, that must be held by the current thread "
"before it can safely access Python objects. Without the lock, even the "
"simplest operations could cause problems in a multi-threaded program: for "
"example, when two threads simultaneously increment the reference count of "
"the same object, the reference count could end up being incremented only "
"once instead of twice."
msgstr ""
"Python 直譯器不是完全執行緒安全的。為了支援多執行緒 Python 程式，有一個全局"
"鎖，稱為 :term:`global interpreter lock` 或 :term:`GIL`，當前執行緒必須持有它"
"才能安全訪問 Python 物件。如果沒有鎖，即使是最簡單的操作也會在多執行緒程式中"
"引起問題：例如，當兩個執行緒同時增加同一個物件的引用計數時，引用計數最終可能"
"只增加一次而不是兩次。"

#: ../../c-api/init.rst:745
#, fuzzy
msgid ""
"Therefore, the rule exists that only the thread that has acquired the :term:"
"`GIL` may operate on Python objects or call Python/C API functions. In order "
"to emulate concurrency of execution, the interpreter regularly tries to "
"switch threads (see :func:`sys.setswitchinterval`).  The lock is also "
"released around potentially blocking I/O operations like reading or writing "
"a file, so that other Python threads can run in the meantime."
msgstr ""
"因此，存在只有獲得 GIL 的執行緒才可以對 Python 物件進行操作或呼叫 Python/C "
"API 函式的規則。為了模擬執行的並發性，直譯器會定期嘗試切換執行緒（參見 :func:"
"`sys.setswitchinterval`）。鎖也會在可能阻塞的 I/O 操作（如讀取或寫入文件）周"
"圍釋放，以便其他 Python 執行緒可以同時運行。"

#: ../../c-api/init.rst:756
#, fuzzy
msgid ""
"The Python interpreter keeps some thread-specific bookkeeping information "
"inside a data structure called :c:type:`PyThreadState`.  There's also one "
"global variable pointing to the current :c:type:`PyThreadState`: it can be "
"retrieved using :c:func:`PyThreadState_Get`."
msgstr ""
"Python 直譯器在名為 PyThreadState 的資料結構中保留了一些特定於執行緒的簿記資"
"訊。還有一個指向當前:c:type:`PyThreadState` 的全局變數：可以使用:c:func:"
"`PyThreadState_Get` 檢索它。"

#: ../../c-api/init.rst:762
#, fuzzy
msgid "Releasing the GIL from extension code"
msgstr "從擴充程式碼中釋放 GIL"

#: ../../c-api/init.rst:764
#, fuzzy
msgid ""
"Most extension code manipulating the :term:`GIL` has the following simple "
"structure::"
msgstr "大多數操作 GIL 的擴充程式碼都具有以下簡單結構："

#: ../../c-api/init.rst:773
#, fuzzy
msgid "This is so common that a pair of macros exists to simplify it::"
msgstr "這很常見，因此存在一對巨集來簡化它::"

#: ../../c-api/init.rst:783
#, fuzzy
msgid ""
"The :c:macro:`Py_BEGIN_ALLOW_THREADS` macro opens a new block and declares a "
"hidden local variable; the :c:macro:`Py_END_ALLOW_THREADS` macro closes the "
"block."
msgstr ""
":c:macro:`Py_BEGIN_ALLOW_THREADS` 巨集打開一個新塊並聲明一個隱藏的局部變"
"數； :c:macro:`Py_END_ALLOW_THREADS` 巨集關閉塊。"

#: ../../c-api/init.rst:787
#, fuzzy
msgid "The block above expands to the following code::"
msgstr "上面的塊擴充為以下程式碼::"

#: ../../c-api/init.rst:799
#, fuzzy
msgid ""
"Here is how these functions work: the global interpreter lock is used to "
"protect the pointer to the current thread state.  When releasing the lock "
"and saving the thread state, the current thread state pointer must be "
"retrieved before the lock is released (since another thread could "
"immediately acquire the lock and store its own thread state in the global "
"variable). Conversely, when acquiring the lock and restoring the thread "
"state, the lock must be acquired before storing the thread state pointer."
msgstr ""
"以下是這些函式的工作原理：全局直譯器鎖用於保護指向當前執行緒狀態的指標。釋放"
"鎖並保存執行緒狀態時，必須在釋放鎖之前檢索當前執行緒狀態指標（因為另一個執行"
"緒可以立即獲取鎖並將自己的執行緒狀態儲存在全局變數中）。反之，在獲取鎖和恢復"
"執行緒狀態時，必須在儲存執行緒狀態指標之前獲取鎖。"

#: ../../c-api/init.rst:808
#, fuzzy
msgid ""
"Calling system I/O functions is the most common use case for releasing the "
"GIL, but it can also be useful before calling long-running computations "
"which don't need access to Python objects, such as compression or "
"cryptographic functions operating over memory buffers.  For example, the "
"standard :mod:`zlib` and :mod:`hashlib` modules release the GIL when "
"compressing or hashing data."
msgstr ""
"呼叫系統 I/O 函式是釋放 GIL 最常見的用例，但在呼叫不需要訪問 Python 物件的長"
"時間運行的計算之前它也很有用，例如在記憶體緩衝區上運行的壓縮或加密函式。例"
"如，標準 :mod:`zlib` 和 :mod:`hashlib` 模組在壓縮或散列資料時釋放 GIL。"

#: ../../c-api/init.rst:819
#, fuzzy
msgid "Non-Python created threads"
msgstr "非 Python 建立的執行緒"

#: ../../c-api/init.rst:821
#, fuzzy
msgid ""
"When threads are created using the dedicated Python APIs (such as the :mod:"
"`threading` module), a thread state is automatically associated to them and "
"the code showed above is therefore correct.  However, when threads are "
"created from C (for example by a third-party library with its own thread "
"management), they don't hold the GIL, nor is there a thread state structure "
"for them."
msgstr ""
"當使用專用 Python API（例如 :mod:`threading` 模組）建立執行緒時，執行緒狀態會"
"自動關聯到它們，因此上面顯示的程式碼是正確的。但是，當執行緒是從 C 建立的（例"
"如，由具有自己的執行緒管理的第三方庫）時，它們不持有 GIL，也沒有執行緒狀態結"
"構。"

#: ../../c-api/init.rst:828
#, fuzzy
msgid ""
"If you need to call Python code from these threads (often this will be part "
"of a callback API provided by the aforementioned third-party library), you "
"must first register these threads with the interpreter by creating a thread "
"state data structure, then acquiring the GIL, and finally storing their "
"thread state pointer, before you can start using the Python/C API.  When you "
"are done, you should reset the thread state pointer, release the GIL, and "
"finally free the thread state data structure."
msgstr ""
"如果您需要從這些執行緒呼叫 Python 程式碼（通常這將是上述第三方庫提供的回呼 "
"API 的一部分），您必須首先通過建立執行緒狀態資料結構向直譯器註冊這些執行緒，"
"然後獲取GIL，並最終儲存它們的執行緒狀態指標，然後才能開始使用 Python/C API。"
"完成後，您應該重置執行緒狀態指標，釋放 GIL，最後釋放執行緒狀態資料結構。"

#: ../../c-api/init.rst:836
#, fuzzy
msgid ""
"The :c:func:`PyGILState_Ensure` and :c:func:`PyGILState_Release` functions "
"do all of the above automatically.  The typical idiom for calling into "
"Python from a C thread is::"
msgstr ""
":c:func:`PyGILState_Ensure` 和 :c:func:`PyGILState_Release` 函式會自動執行上"
"述所有操作。從 C 執行緒呼叫 Python 的典型用法是："

#: ../../c-api/init.rst:850
#, fuzzy
msgid ""
"Note that the ``PyGILState_*`` functions assume there is only one global "
"interpreter (created automatically by :c:func:`Py_Initialize`).  Python "
"supports the creation of additional interpreters (using :c:func:"
"`Py_NewInterpreter`), but mixing multiple interpreters and the "
"``PyGILState_*`` API is unsupported."
msgstr ""
"請注意，``PyGILState_*`` 函式假定只有一個全局直譯器（由 :c:func:"
"`Py_Initialize` 自動建立）。 Python 支援建立額外的直譯器（使用 :c:func:"
"`Py_NewInterpreter`），但不支援混合多個直譯器和``PyGILState_*`` API。"

#: ../../c-api/init.rst:860
#, fuzzy
msgid "Cautions about fork()"
msgstr "fork()注意事項"

#: ../../c-api/init.rst:862
#, fuzzy
msgid ""
"Another important thing to note about threads is their behaviour in the face "
"of the C :c:func:`fork` call. On most systems with :c:func:`fork`, after a "
"process forks only the thread that issued the fork will exist.  This has a "
"concrete impact both on how locks must be handled and on all stored state in "
"CPython's runtime."
msgstr ""
"關於執行緒的另一個需要注意的重要事項是它們在 C:c:func:`fork` 呼叫面前的行為。"
"在大多數帶有 :c:func:`fork` 的系統上，在行程分叉後，只有發出分叉的執行緒會存"
"在。這對必須如何處理鎖以及 CPython 運行時中的所有儲存狀態都有具體的影響。"

#: ../../c-api/init.rst:868
#, fuzzy
msgid ""
"The fact that only the \"current\" thread remains means any locks held by "
"other threads will never be released. Python solves this for :func:`os.fork` "
"by acquiring the locks it uses internally before the fork, and releasing "
"them afterwards. In addition, it resets any :ref:`lock-objects` in the "
"child. When extending or embedding Python, there is no way to inform Python "
"of additional (non-Python) locks that need to be acquired before or reset "
"after a fork. OS facilities such as :c:func:`pthread_atfork` would need to "
"be used to accomplish the same thing. Additionally, when extending or "
"embedding Python, calling :c:func:`fork` directly rather than through :func:"
"`os.fork` (and returning to or calling into Python) may result in a deadlock "
"by one of Python's internal locks being held by a thread that is defunct "
"after the fork. :c:func:`PyOS_AfterFork_Child` tries to reset the necessary "
"locks, but is not always able to."
msgstr ""
"只有“當前”執行緒保留的事實意味著永遠不會釋放其他執行緒持有的任何鎖。 Python "
"通過在 fork 之前獲取它在內部使用的鎖並在之後釋放它們來為 os.fork 解決這個問"
"題。此外，它會重置子對像中的任何 :ref:`lock-objects`。擴充或嵌入 Python 時，"
"無法通知 Python 需要在分叉之前獲取或重置的額外（非 Python）鎖。需要使用 :c:"
"func:`pthread_atfork` 等操作系統設施來完成同樣的事情。此外，在擴充或嵌入 "
"Python 時，直接呼叫 :c:func:`fork` 而不是通過 :func:`os.fork`（並回傳或呼叫 "
"Python）可能會導致 Python 內部鎖之一的死鎖由分叉後失效的執行緒持有。 :c:func:"
"`PyOS_AfterFork_Child` 嘗試重置必要的鎖，但並不總是能夠。"

#: ../../c-api/init.rst:883
#, fuzzy
msgid ""
"The fact that all other threads go away also means that CPython's runtime "
"state there must be cleaned up properly, which :func:`os.fork` does.  This "
"means finalizing all other :c:type:`PyThreadState` objects belonging to the "
"current interpreter and all other :c:type:`PyInterpreterState` objects.  Due "
"to this and the special nature of the :ref:`\"main\" interpreter <sub-"
"interpreter-support>`, :c:func:`fork` should only be called in that "
"interpreter's \"main\" thread, where the CPython global runtime was "
"originally initialized. The only exception is if :c:func:`exec` will be "
"called immediately after."
msgstr ""
"所有其他執行緒都消失的事實也意味著 CPython 的運行時狀態必須正確清理，而 :"
"func:`os.fork` 確實如此。這意味著完成屬於當前直譯器的所有其他 :c:type:"
"`PyThreadState` 物件和所有其他 :c:type:`PyInterpreterState` 物件。由於這個"
"和 :ref:`\"main\" 直譯器 <sub-interpreter-support>` 的特殊性質，:c:func:"
"`fork` 應該只在該直譯器的「主」執行緒中呼叫，其中 CPython 全局運行時最初被初"
"始化。唯一的例外是如果 :c:func:`exec` 將在之後立即被呼叫。"

#: ../../c-api/init.rst:896
msgid "High-level API"
msgstr "高階 API"

#: ../../c-api/init.rst:898
#, fuzzy
msgid ""
"These are the most commonly used types and functions when writing C "
"extension code, or when embedding the Python interpreter:"
msgstr "這些是編寫 C 擴充程式碼或嵌入 Python 直譯器時最常用的型別和函式："

#: ../../c-api/init.rst:903
#, fuzzy
msgid ""
"This data structure represents the state shared by a number of cooperating "
"threads.  Threads belonging to the same interpreter share their module "
"administration and a few other internal items. There are no public members "
"in this structure."
msgstr ""
"該資料結構表示由多個協作執行緒共享的狀態。屬於同一個直譯器的執行緒共享它們的"
"模組管理和一些其他內部項目。此結構中沒有公開成員。"

#: ../../c-api/init.rst:908
#, fuzzy
msgid ""
"Threads belonging to different interpreters initially share nothing, except "
"process state like available memory, open file descriptors and such.  The "
"global interpreter lock is also shared by all threads, regardless of to "
"which interpreter they belong."
msgstr ""
"屬於不同直譯器的執行緒最初不共享任何東西，除了可用記憶體、打開的文件描述器等"
"行程狀態。全局直譯器鎖也由所有執行緒共享，無論它們屬於哪個直譯器。"

#: ../../c-api/init.rst:916
#, fuzzy
msgid ""
"This data structure represents the state of a single thread.  The only "
"public data member is :attr:`interp` (:c:expr:`PyInterpreterState *`), which "
"points to this thread's interpreter state."
msgstr ""
"該資料結構表示單個執行緒的狀態。唯一的公開資料成員是 :attr:`interp` (:c:expr:"
"`PyInterpreterState *`)，它指向該執行緒的直譯器狀態。"

#: ../../c-api/init.rst:929
#, fuzzy
msgid "Deprecated function which does nothing."
msgstr "不推薦使用的函式，什麼都不做。"

#: ../../c-api/init.rst:931
#, fuzzy
msgid ""
"In Python 3.6 and older, this function created the GIL if it didn't exist."
msgstr "在 Python 3.6 及更早版本中，如果 GIL 不存在，此函式將建立它。"

#: ../../c-api/init.rst:933
msgid "The function now does nothing."
msgstr "此函式現在不會做任何事情。"

#: ../../c-api/init.rst:936
#, fuzzy
msgid ""
"This function is now called by :c:func:`Py_Initialize()`, so you don't have "
"to call it yourself anymore."
msgstr "此函式現在由 :c:func:`Py_Initialize()` 呼叫，因此您不必再自己呼叫它。"

#: ../../c-api/init.rst:940
#, fuzzy
msgid ""
"This function cannot be called before :c:func:`Py_Initialize()` anymore."
msgstr "不能再在 :c:func:`Py_Initialize()` 之前呼叫此函式。"

#: ../../c-api/init.rst:950
#, fuzzy
msgid ""
"Returns a non-zero value if :c:func:`PyEval_InitThreads` has been called.  "
"This function can be called without holding the GIL, and therefore can be "
"used to avoid calls to the locking API when running single-threaded."
msgstr ""
"如果 :c:func:`PyEval_InitThreads` 已被呼叫，則回傳一個非零值。無需持有 GIL 即"
"可呼叫此函式，因此可用於避免在單執行緒運行時呼叫鎖定 API。"

#: ../../c-api/init.rst:954
#, fuzzy
msgid "The :term:`GIL` is now initialized by :c:func:`Py_Initialize()`."
msgstr ":term:`GIL` 現在由 :c:func:`Py_Initialize()` 初始化。"

#: ../../c-api/init.rst:962
#, fuzzy
msgid ""
"Release the global interpreter lock (if it has been created) and reset the "
"thread state to ``NULL``, returning the previous thread state (which is not "
"``NULL``).  If the lock has been created, the current thread must have "
"acquired it."
msgstr ""
"釋放全局直譯器鎖（如果已建立）並將執行緒狀態重置為 ``NULL`` ，回傳先前的執行"
"緒狀態（不是 ``NULL`` ）。如果鎖已經建立，則當前執行緒一定已經獲取了它。"

#: ../../c-api/init.rst:970
#, fuzzy
msgid ""
"Acquire the global interpreter lock (if it has been created) and set the "
"thread state to *tstate*, which must not be ``NULL``.  If the lock has been "
"created, the current thread must not have acquired it, otherwise deadlock "
"ensues."
msgstr ""
"獲取全局直譯器鎖（如果已建立）並將執行緒狀態設定為 *tstate*，它不能為 "
"``NULL`` 。如果已經建立了鎖，則當前執行緒一定沒有獲取到它，否則就會發生死鎖。"

#: ../../c-api/init.rst:976 ../../c-api/init.rst:1022 ../../c-api/init.rst:1304
#: ../../c-api/init.rst:1342
#, fuzzy
msgid ""
"Calling this function from a thread when the runtime is finalizing will "
"terminate the thread, even if the thread was not created by Python. You can "
"use :c:func:`_Py_IsFinalizing` or :func:`sys.is_finalizing` to check if the "
"interpreter is in process of being finalized before calling this function to "
"avoid unwanted termination."
msgstr ""
"在運行時結束時從執行緒呼叫此函式將終止執行緒，即使該執行緒不是由 Python 建立"
"的。您可以使用 :c:func:`_Py_IsFinalizing` 或 :func:`sys.is_finalizing` 在呼叫"
"此函式之前檢查直譯器是否正在完成，以避免意外終止。"

#: ../../c-api/init.rst:984
#, fuzzy
msgid ""
"Return the current thread state.  The global interpreter lock must be held. "
"When the current thread state is ``NULL``, this issues a fatal error (so "
"that the caller needn't check for ``NULL``)."
msgstr ""
"回傳當前執行緒狀態。必須持有全局直譯器鎖。噹噹前執行緒狀態為 ``NULL`` 時，這"
"會發出一個致命錯誤（這樣呼叫者就不需要檢查 ``NULL`` ）。"

#: ../../c-api/init.rst:991
#, fuzzy
msgid ""
"Swap the current thread state with the thread state given by the argument "
"*tstate*, which may be ``NULL``.  The global interpreter lock must be held "
"and is not released."
msgstr ""
"將當前執行緒狀態與參數 *tstate* 給出的執行緒狀態交換，該參數可能為 "
"``NULL`` 。全局直譯器鎖必須被持有並且不會被釋放。"

#: ../../c-api/init.rst:996
#, fuzzy
msgid ""
"The following functions use thread-local storage, and are not compatible "
"with sub-interpreters:"
msgstr "以下函式使用執行緒本地儲存，並且與子直譯器不相容："

#: ../../c-api/init.rst:1001
#, fuzzy
msgid ""
"Ensure that the current thread is ready to call the Python C API regardless "
"of the current state of Python, or of the global interpreter lock. This may "
"be called as many times as desired by a thread as long as each call is "
"matched with a call to :c:func:`PyGILState_Release`. In general, other "
"thread-related APIs may be used between :c:func:`PyGILState_Ensure` and :c:"
"func:`PyGILState_Release` calls as long as the thread state is restored to "
"its previous state before the Release().  For example, normal usage of the :"
"c:macro:`Py_BEGIN_ALLOW_THREADS` and :c:macro:`Py_END_ALLOW_THREADS` macros "
"is acceptable."
msgstr ""
"確保當前執行緒已準備好呼叫 Python C API，而不管 Python 或全局直譯器鎖的當前狀"
"態如何。只要每次呼叫都與對 PyGILState_Release 的呼叫相匹配，執行緒就可以根據"
"需要多次呼叫它。一般來說，只要執行緒狀態恢復到 Release() 之前的狀態，就可以"
"在 PyGILState_Ensure 和 PyGILState_Release 呼叫之間使用其他與執行緒相關的 "
"API。例如，正常使用 :c:macro:`Py_BEGIN_ALLOW_THREADS` 和 :c:macro:"
"`Py_END_ALLOW_THREADS` 巨集是可以接受的。"

#: ../../c-api/init.rst:1011
#, fuzzy
msgid ""
"The return value is an opaque \"handle\" to the thread state when :c:func:"
"`PyGILState_Ensure` was called, and must be passed to :c:func:"
"`PyGILState_Release` to ensure Python is left in the same state. Even though "
"recursive calls are allowed, these handles *cannot* be shared - each unique "
"call to :c:func:`PyGILState_Ensure` must save the handle for its call to :c:"
"func:`PyGILState_Release`."
msgstr ""
"回傳值是呼叫 PyGILState_Ensure 時執行緒狀態的不透明“句柄”，必須傳遞給 "
"PyGILState_Release 以確保 Python 保持相同狀態。即使遞迴呼叫是允許的，這些句"
"柄 *不能* 共享 - 每個對 PyGILState_Ensure 的唯一呼叫都必須保存其對 "
"PyGILState_Release 呼叫的句柄。"

#: ../../c-api/init.rst:1018
#, fuzzy
msgid ""
"When the function returns, the current thread will hold the GIL and be able "
"to call arbitrary Python code.  Failure is a fatal error."
msgstr ""
"當函式回傳時，當前執行緒將持有 GIL 並能夠呼叫任意 Python 程式碼。失敗是致命錯"
"誤。"

#: ../../c-api/init.rst:1030
#, fuzzy
msgid ""
"Release any resources previously acquired.  After this call, Python's state "
"will be the same as it was prior to the corresponding :c:func:"
"`PyGILState_Ensure` call (but generally this state will be unknown to the "
"caller, hence the use of the GILState API)."
msgstr ""
"釋放之前獲得的任何資源。在此呼叫之後，Python 的狀態將與相應的 "
"PyGILState_Ensure 呼叫之前的狀態相同（但通常呼叫者不知道此狀態，因此使用了 "
"GILState API）。"

#: ../../c-api/init.rst:1035
#, fuzzy
msgid ""
"Every call to :c:func:`PyGILState_Ensure` must be matched by a call to :c:"
"func:`PyGILState_Release` on the same thread."
msgstr ""
"對 :c:func:`PyGILState_Ensure` 的每次呼叫都必須與同一執行緒上對 :c:func:"
"`PyGILState_Release` 的呼叫相匹配。"

#: ../../c-api/init.rst:1041
#, fuzzy
msgid ""
"Get the current thread state for this thread.  May return ``NULL`` if no "
"GILState API has been used on the current thread.  Note that the main thread "
"always has such a thread-state, even if no auto-thread-state call has been "
"made on the main thread.  This is mainly a helper/diagnostic function."
msgstr ""
"獲取此執行緒的當前執行緒狀態。如果在當前執行緒上沒有使用 GILState API，則可能"
"回傳 ``NULL`` 。請注意，主執行緒始終具有這樣的執行緒狀態，即使沒有在主執行緒"
"上進行自動執行緒狀態呼叫也是如此。這主要是一個輔助/診斷功能。"

#: ../../c-api/init.rst:1049
#, fuzzy
msgid ""
"Return ``1`` if the current thread is holding the GIL and ``0`` otherwise. "
"This function can be called from any thread at any time. Only if it has had "
"its Python thread state initialized and currently is holding the GIL will it "
"return ``1``. This is mainly a helper/diagnostic function.  It can be useful "
"for example in callback contexts or memory allocation functions when knowing "
"that the GIL is locked can allow the caller to perform sensitive actions or "
"otherwise behave differently."
msgstr ""
"如果當前執行緒持有 GIL，則回傳 ``1``，否則回傳 ``0``。可以隨時從任何執行緒呼"
"叫此函式。只有當它的 Python 執行緒狀態已經初始化並且當前持有 GIL 時，它才會回"
"傳 ``1``。這主要是一個輔助/診斷功能。例如，當知道 GIL 被鎖定可以允許呼叫者執"
"行敏感操作或以其他方式表現不同時，它在回呼上下文或記憶體分配函式中很有用。"

#: ../../c-api/init.rst:1061
#, fuzzy
msgid ""
"The following macros are normally used without a trailing semicolon; look "
"for example usage in the Python source distribution."
msgstr ""
"以下巨集通常在沒有尾隨分號的情況下使用；在 Python 源程式碼分發中查找示例用"
"法。"

#: ../../c-api/init.rst:1067
#, fuzzy
msgid ""
"This macro expands to ``{ PyThreadState *_save; _save = PyEval_SaveThread();"
"``. Note that it contains an opening brace; it must be matched with a "
"following :c:macro:`Py_END_ALLOW_THREADS` macro.  See above for further "
"discussion of this macro."
msgstr ""
"這個巨集擴充為``{ PyThreadState *_save; _save = PyEval_SaveThread();``。請注"
"意，它包含一個左括號；它必須與以下 :c:macro:`Py_END_ALLOW_THREADS` 巨集匹配。"
"有關此巨集的進一步討論，請參見上文。"

#: ../../c-api/init.rst:1075
#, fuzzy
msgid ""
"This macro expands to ``PyEval_RestoreThread(_save); }``. Note that it "
"contains a closing brace; it must be matched with an earlier :c:macro:"
"`Py_BEGIN_ALLOW_THREADS` macro.  See above for further discussion of this "
"macro."
msgstr ""
"這個巨集擴充為``PyEval_RestoreThread(_save); }``。請注意，它包含一個右括號；"
"它必須與早期的 :c:macro:`Py_BEGIN_ALLOW_THREADS` 巨集匹配。有關此巨集的進一步"
"討論，請參見上文。"

#: ../../c-api/init.rst:1083
#, fuzzy
msgid ""
"This macro expands to ``PyEval_RestoreThread(_save);``: it is equivalent to :"
"c:macro:`Py_END_ALLOW_THREADS` without the closing brace."
msgstr ""
"這個巨集擴充為``PyEval_RestoreThread(_save);``：它等同於沒有右括號的:c:macro:"
"`Py_END_ALLOW_THREADS`。"

#: ../../c-api/init.rst:1089
#, fuzzy
msgid ""
"This macro expands to ``_save = PyEval_SaveThread();``: it is equivalent to :"
"c:macro:`Py_BEGIN_ALLOW_THREADS` without the opening brace and variable "
"declaration."
msgstr ""
"這個巨集擴充為 ``_save = PyEval_SaveThread();``：它等同於 :c:macro:"
"`Py_BEGIN_ALLOW_THREADS` 沒有左括號和變數聲明。"

#: ../../c-api/init.rst:1095
msgid "Low-level API"
msgstr "低階 API"

#: ../../c-api/init.rst:1097
#, fuzzy
msgid ""
"All of the following functions must be called after :c:func:`Py_Initialize`."
msgstr "以下所有函式都必須在 :c:func:`Py_Initialize` 之後呼叫。"

#: ../../c-api/init.rst:1099
#, fuzzy
msgid ":c:func:`Py_Initialize()` now initializes the :term:`GIL`."
msgstr ":c:func:`Py_Initialize()` 現在初始化 :term:`GIL`。"

#: ../../c-api/init.rst:1105
#, fuzzy
msgid ""
"Create a new interpreter state object.  The global interpreter lock need not "
"be held, but may be held if it is necessary to serialize calls to this "
"function."
msgstr ""
"建立一個新的直譯器狀態物件。不需要持有全局直譯器鎖，但如果需要序列化對此函式"
"的呼叫，則可以持有。"

#: ../../c-api/init.rst:1109
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython."
"PyInterpreterState_New`` with no arguments."
msgstr ""
"引發一個不附帶引數的\\ :ref:`稽核事件 <auditing>` ``cpython."
"PyInterpreterState_New``。"

#: ../../c-api/init.rst:1114
#, fuzzy
msgid ""
"Reset all information in an interpreter state object.  The global "
"interpreter lock must be held."
msgstr "重置直譯器狀態對像中的所有資訊。必須持有全局直譯器鎖。"

#: ../../c-api/init.rst:1117
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython."
"PyInterpreterState_Clear`` with no arguments."
msgstr ""
"引發一個不附帶引數的\\ :ref:`稽核事件 <auditing>` ``cpython."
"PyInterpreterState_Clear``。"

#: ../../c-api/init.rst:1122
#, fuzzy
msgid ""
"Destroy an interpreter state object.  The global interpreter lock need not "
"be held.  The interpreter state must have been reset with a previous call "
"to :c:func:`PyInterpreterState_Clear`."
msgstr ""
"銷毀直譯器狀態物件。不需要持有全局直譯器鎖。直譯器狀態必須已通過先前呼叫 :c:"
"func:`PyInterpreterState_Clear` 重置。"

#: ../../c-api/init.rst:1129
#, fuzzy
msgid ""
"Create a new thread state object belonging to the given interpreter object. "
"The global interpreter lock need not be held, but may be held if it is "
"necessary to serialize calls to this function."
msgstr ""
"建立屬於給定直譯器物件的新執行緒狀態物件。不需要持有全局直譯器鎖，但如果需要"
"序列化對此函式的呼叫，則可以持有。"

#: ../../c-api/init.rst:1136
#, fuzzy
msgid ""
"Reset all information in a thread state object.  The global interpreter lock "
"must be held."
msgstr "重置執行緒狀態對像中的所有資訊。必須持有全局直譯器鎖。"

#: ../../c-api/init.rst:1139
#, fuzzy
msgid ""
"This function now calls the :c:member:`PyThreadState.on_delete` callback. "
"Previously, that happened in :c:func:`PyThreadState_Delete`."
msgstr ""
"此函式現在呼叫 :c:member:`PyThreadState.on_delete` 回呼。以前，這發生在 :c:"
"func:`PyThreadState_Delete` 中。"

#: ../../c-api/init.rst:1146
#, fuzzy
msgid ""
"Destroy a thread state object.  The global interpreter lock need not be "
"held. The thread state must have been reset with a previous call to :c:func:"
"`PyThreadState_Clear`."
msgstr ""
"銷毀執行緒狀態物件。不需要持有全局直譯器鎖。執行緒狀態必須已通過先前呼叫 "
"PyThreadState_Clear 進行了重置。"

#: ../../c-api/init.rst:1153
#, fuzzy
msgid ""
"Destroy the current thread state and release the global interpreter lock. "
"Like :c:func:`PyThreadState_Delete`, the global interpreter lock need not be "
"held. The thread state must have been reset with a previous call to :c:func:"
"`PyThreadState_Clear`."
msgstr ""
"銷毀當前執行緒狀態並釋放全局直譯器鎖。像 :c:func:`PyThreadState_Delete` 一"
"樣，不需要持有全局直譯器鎖。執行緒狀態必須已通過先前呼叫 PyThreadState_Clear "
"進行了重置。"

#: ../../c-api/init.rst:1161
#, fuzzy
msgid "Get the current frame of the Python thread state *tstate*."
msgstr "獲取 Python 執行緒狀態 *tstate* 的當前幀。"

#: ../../c-api/init.rst:1163
#, fuzzy
msgid ""
"Return a :term:`strong reference`. Return ``NULL`` if no frame is currently "
"executing."
msgstr ""
"回傳一個 :term:`strong reference`。如果當前沒有正在執行的幀，則回傳 "
"``NULL`` 。"

#: ../../c-api/init.rst:1166
msgid "See also :c:func:`PyEval_GetFrame`."
msgstr "也請見 :c:func:`PyEval_GetFrame`\\ 。"

#: ../../c-api/init.rst:1168 ../../c-api/init.rst:1177
#: ../../c-api/init.rst:1186
msgid "*tstate* must not be ``NULL``."
msgstr "*tstate* 不可為 ``NULL``。"

#: ../../c-api/init.rst:1175
#, fuzzy
msgid ""
"Get the unique thread state identifier of the Python thread state *tstate*."
msgstr "獲取 Python 執行緒狀態 *tstate* 的唯一執行緒狀態標識符。"

#: ../../c-api/init.rst:1184
#, fuzzy
msgid "Get the interpreter of the Python thread state *tstate*."
msgstr "獲取 Python 執行緒狀態 *tstate* 的直譯器。"

#: ../../c-api/init.rst:1193
#, fuzzy
msgid "Suspend tracing and profiling in the Python thread state *tstate*."
msgstr "在 Python 執行緒狀態 *tstate* 中暫停跟踪和分析。"

#: ../../c-api/init.rst:1195
#, fuzzy
msgid "Resume them using the :c:func:`PyThreadState_LeaveTracing` function."
msgstr "使用 PyThreadState_LeaveTracing 函式恢復它們。"

#: ../../c-api/init.rst:1202
#, fuzzy
msgid ""
"Resume tracing and profiling in the Python thread state *tstate* suspended "
"by the :c:func:`PyThreadState_EnterTracing` function."
msgstr ""
"在由 PyThreadState_EnterTracing 函式暫停的 Python 執行緒狀態 *state* 中恢復跟"
"踪和分析。"

#: ../../c-api/init.rst:1205
#, fuzzy
msgid ""
"See also :c:func:`PyEval_SetTrace` and :c:func:`PyEval_SetProfile` functions."
msgstr "另見 :c:func:`PyEval_SetTrace` 和 :c:func:`PyEval_SetProfile` 函式。"

#: ../../c-api/init.rst:1213
#, fuzzy
msgid "Get the current interpreter."
msgstr "獲取當前的直譯器。"

#: ../../c-api/init.rst:1215
#, fuzzy
msgid ""
"Issue a fatal error if there no current Python thread state or no current "
"interpreter. It cannot return NULL."
msgstr ""
"如果沒有當前 Python 執行緒狀態或沒有當前直譯器，則發出致命錯誤。它不能回傳 "
"NULL。"

#: ../../c-api/init.rst:1218 ../../c-api/init.rst:1228
#, fuzzy
msgid "The caller must hold the GIL."
msgstr "呼叫者必須持有 GIL。"

#: ../../c-api/init.rst:1225
#, fuzzy
msgid ""
"Return the interpreter's unique ID.  If there was any error in doing so then "
"``-1`` is returned and an error is set."
msgstr "回傳直譯器的唯一 ID。如果這樣做有任何錯誤，則回傳 ``-1``並設定錯誤。"

#: ../../c-api/init.rst:1235
#, fuzzy
msgid ""
"Return a dictionary in which interpreter-specific data may be stored. If "
"this function returns ``NULL`` then no exception has been raised and the "
"caller should assume no interpreter-specific dict is available."
msgstr ""
"回傳一個字典，其中可以儲存特定於直譯器的資料。如果此函式回傳 ``NULL`` ，則沒"
"有引發例外，呼叫者應假定沒有特定於直譯器的字典可用。"

#: ../../c-api/init.rst:1239
#, fuzzy
msgid ""
"This is not a replacement for :c:func:`PyModule_GetState()`, which "
"extensions should use to store interpreter-specific state information."
msgstr ""
"這不是 :c:func:`PyModule_GetState()` 的替代品，擴充應該使用它來儲存特定於直譯"
"器的狀態資訊。"

#: ../../c-api/init.rst:1246
#, fuzzy
msgid "Type of a frame evaluation function."
msgstr "幀評估函式的型別。"

#: ../../c-api/init.rst:1248
#, fuzzy
msgid ""
"The *throwflag* parameter is used by the ``throw()`` method of generators: "
"if non-zero, handle the current exception."
msgstr ""
"*throwflag* 參數由生成器的 ``throw()`` 方法使用：如果非零，則處理當前例外。"

#: ../../c-api/init.rst:1251
#, fuzzy
msgid "The function now takes a *tstate* parameter."
msgstr "該函式現在採用 *tstate* 參數。"

#: ../../c-api/init.rst:1254
#, fuzzy
msgid ""
"The *frame* parameter changed from ``PyFrameObject*`` to "
"``_PyInterpreterFrame*``."
msgstr "*frame* 參數從“PyFrameObject*”更改為“_PyInterpreterFrame*”。"

#: ../../c-api/init.rst:1259
#, fuzzy
msgid "Get the frame evaluation function."
msgstr "獲取幀評估函式。"

#: ../../c-api/init.rst:1261 ../../c-api/init.rst:1269
#, fuzzy
msgid "See the :pep:`523` \"Adding a frame evaluation API to CPython\"."
msgstr "請參閱 :pep:`523` “將框架評估 API 新增到 CPython”。"

#: ../../c-api/init.rst:1267
#, fuzzy
msgid "Set the frame evaluation function."
msgstr "設定幀評估函式。"

#: ../../c-api/init.rst:1276
#, fuzzy
msgid ""
"Return a dictionary in which extensions can store thread-specific state "
"information.  Each extension should use a unique key to use to store state "
"in the dictionary.  It is okay to call this function when no current thread "
"state is available. If this function returns ``NULL``, no exception has been "
"raised and the caller should assume no current thread state is available."
msgstr ""
"回傳一個字典，擴充可以在其中儲存執行緒特定的狀態資訊。每個擴充都應該使用一個"
"唯一的鍵來在字典中儲存狀態。當沒有當前執行緒狀態可用時呼叫此函式是可以的。如"
"果此函式回傳 ``NULL`` ，則沒有引發例外，呼叫者應假定當前執行緒狀態不可用。"

#: ../../c-api/init.rst:1285
#, fuzzy
msgid ""
"Asynchronously raise an exception in a thread. The *id* argument is the "
"thread id of the target thread; *exc* is the exception object to be raised. "
"This function does not steal any references to *exc*. To prevent naive "
"misuse, you must write your own C extension to call this.  Must be called "
"with the GIL held. Returns the number of thread states modified; this is "
"normally one, but will be zero if the thread id isn't found.  If *exc* is :"
"const:`NULL`, the pending exception (if any) for the thread is cleared. This "
"raises no exceptions."
msgstr ""
"在執行緒中非同步引發例外。 *id* 參數是目標執行緒的執行緒 id； *exc* 是要引發"
"的例外物件。此函式不會竊取對 *exc* 的任何引用。為了防止天真的誤用，您必須編寫"
"自己的 C 擴充來呼叫它。必須在持有 GIL 的情況下呼叫。回傳修改的執行緒狀態數；"
"這通常是一個，但如果找不到執行緒 ID 則將為零。如果 *exc* 是 :const:`NULL`，則"
"清除執行緒的掛起例外（如果有）。這沒有例外。"

#: ../../c-api/init.rst:1293
#, fuzzy
msgid ""
"The type of the *id* parameter changed from :c:expr:`long` to :c:expr:"
"`unsigned long`."
msgstr "*id* 參數的型別從 :c:expr:`long` 更改為 :c:expr:`unsigned long`。"

#: ../../c-api/init.rst:1299
#, fuzzy
msgid ""
"Acquire the global interpreter lock and set the current thread state to "
"*tstate*, which must not be ``NULL``.  The lock must have been created "
"earlier. If this thread already has the lock, deadlock ensues."
msgstr ""
"獲取全局直譯器鎖並將當前執行緒狀態設定為*tstate*，它不能為``NULL``。鎖必須早"
"先建立。如果該執行緒已經擁有鎖，則會發生死鎖。"

#: ../../c-api/init.rst:1310 ../../c-api/init.rst:1348
#, fuzzy
msgid ""
"Updated to be consistent with :c:func:`PyEval_RestoreThread`, :c:func:"
"`Py_END_ALLOW_THREADS`, and :c:func:`PyGILState_Ensure`, and terminate the "
"current thread if called while the interpreter is finalizing."
msgstr ""
"更新為與:c:func:`PyEval_RestoreThread`、:c:func:`Py_END_ALLOW_THREADS` 和:c:"
"func:`PyGILState_Ensure` 一致，如果在直譯器完成時呼叫，則終止當前執行緒。"

#: ../../c-api/init.rst:1315
#, fuzzy
msgid ""
":c:func:`PyEval_RestoreThread` is a higher-level function which is always "
"available (even when threads have not been initialized)."
msgstr ""
":c:func:`PyEval_RestoreThread` 是一個高階函式，它始終可用（即使執行緒尚未初始"
"化）。"

#: ../../c-api/init.rst:1321
#, fuzzy
msgid ""
"Reset the current thread state to ``NULL`` and release the global "
"interpreter lock.  The lock must have been created earlier and must be held "
"by the current thread.  The *tstate* argument, which must not be ``NULL``, "
"is only used to check that it represents the current thread state --- if it "
"isn't, a fatal error is reported."
msgstr ""
"將當前執行緒狀態重置為 ``NULL`` 並釋放全局直譯器鎖。鎖必須早先建立，並且必須"
"由當前執行緒持有。 *tstate* 參數不能為 ``NULL`` ，僅用於檢查它是否表示當前執"
"行緒狀態——如果不是，則報告致命錯誤。"

#: ../../c-api/init.rst:1327
#, fuzzy
msgid ""
":c:func:`PyEval_SaveThread` is a higher-level function which is always "
"available (even when threads have not been initialized)."
msgstr ""
":c:func:`PyEval_SaveThread` 是一個高階函式，它始終可用（即使執行緒尚未初始"
"化）。"

#: ../../c-api/init.rst:1333
#, fuzzy
msgid ""
"Acquire the global interpreter lock.  The lock must have been created "
"earlier. If this thread already has the lock, a deadlock ensues."
msgstr ""
"獲取全局直譯器鎖。鎖必須早先建立。如果該執行緒已經擁有鎖，則會發生死鎖。"

#: ../../c-api/init.rst:1336
#, fuzzy
msgid ""
"This function does not update the current thread state.  Please use :c:func:"
"`PyEval_RestoreThread` or :c:func:`PyEval_AcquireThread` instead."
msgstr ""
"該函式不更新當前執行緒狀態。請改用:c:func:`PyEval_RestoreThread` 或:c:func:"
"`PyEval_AcquireThread`。"

#: ../../c-api/init.rst:1356
#, fuzzy
msgid ""
"Release the global interpreter lock.  The lock must have been created "
"earlier."
msgstr "釋放全局直譯器鎖。鎖必須早先建立。"

#: ../../c-api/init.rst:1358
#, fuzzy
msgid ""
"This function does not update the current thread state.  Please use :c:func:"
"`PyEval_SaveThread` or :c:func:`PyEval_ReleaseThread` instead."
msgstr ""
"該函式不更新當前執行緒狀態。請改用 :c:func:`PyEval_SaveThread` 或 :c:func:"
"`PyEval_ReleaseThread`。"

#: ../../c-api/init.rst:1367
#, fuzzy
msgid "Sub-interpreter support"
msgstr "副翻譯支援"

#: ../../c-api/init.rst:1369
#, fuzzy
msgid ""
"While in most uses, you will only embed a single Python interpreter, there "
"are cases where you need to create several independent interpreters in the "
"same process and perhaps even in the same thread. Sub-interpreters allow you "
"to do that."
msgstr ""
"雖然在大多數情況下，您只會嵌入一個 Python 直譯器，但在某些情況下，您需要在同"
"一行程甚至可能在同一執行緒中建立多個獨立的直譯器。副口譯員允許您這樣做。"

#: ../../c-api/init.rst:1374
#, fuzzy
msgid ""
"The \"main\" interpreter is the first one created when the runtime "
"initializes. It is usually the only Python interpreter in a process.  Unlike "
"sub-interpreters, the main interpreter has unique process-global "
"responsibilities like signal handling.  It is also responsible for execution "
"during runtime initialization and is usually the active interpreter during "
"runtime finalization.  The :c:func:`PyInterpreterState_Main` function "
"returns a pointer to its state."
msgstr ""
"「主」直譯器是運行時初始化時建立的第一個直譯器。它通常是行程中唯一的 Python "
"直譯器。與子直譯器不同，主直譯器具有獨特的行程全局職責，如信號處理。它還負責"
"運行時初始化期間的執行，並且通常是運行時終結期間的活動直譯器。 :c:func:"
"`PyInterpreterState_Main` 函式回傳指向其狀態的指標。"

#: ../../c-api/init.rst:1381
#, fuzzy
msgid ""
"You can switch between sub-interpreters using the :c:func:"
"`PyThreadState_Swap` function. You can create and destroy them using the "
"following functions:"
msgstr ""
"您可以使用 PyThreadState_Swap 函式在子直譯器之間切換。您可以使用以下函式建立"
"和銷毀它們："

#: ../../c-api/init.rst:1395
#, fuzzy
msgid ""
"Create a new sub-interpreter.  This is an (almost) totally separate "
"environment for the execution of Python code.  In particular, the new "
"interpreter has separate, independent versions of all imported modules, "
"including the fundamental modules :mod:`builtins`, :mod:`__main__` and :mod:"
"`sys`.  The table of loaded modules (``sys.modules``) and the module search "
"path (``sys.path``) are also separate.  The new environment has no ``sys."
"argv`` variable.  It has new standard I/O stream file objects ``sys.stdin``, "
"``sys.stdout`` and ``sys.stderr`` (however these refer to the same "
"underlying file descriptors)."
msgstr ""
"建立一個新的子直譯器。這是一個（幾乎）完全獨立的 Python 程式碼執行環境。特別"
"是，新的直譯器具有所有導入模組的獨立版本，包括基本模組 :mod:`builtins`、:mod:"
"`__main__` 和 :mod:`sys`。加載模組表（``sys.modules``）和模組搜索路徑（``sys."
"path``）也是分開的。新環境沒有 ``sys.argv`` 變數。它有新的標準 I/O 流文件物"
"件 ``sys.stdin``、``sys.stdout`` 和 ``sys.stderr``（但是這些指的是相同的底層"
"文件描述器）。"

#: ../../c-api/init.rst:1405
#, fuzzy
msgid ""
"The return value points to the first thread state created in the new sub-"
"interpreter.  This thread state is made in the current thread state. Note "
"that no actual thread is created; see the discussion of thread states "
"below.  If creation of the new interpreter is unsuccessful, ``NULL`` is "
"returned; no exception is set since the exception state is stored in the "
"current thread state and there may not be a current thread state.  (Like all "
"other Python/C API functions, the global interpreter lock must be held "
"before calling this function and is still held when it returns; however, "
"unlike most other Python/C API functions, there needn't be a current thread "
"state on entry.)"
msgstr ""
"回傳值指向在新的子直譯器中建立的第一個執行緒狀態。此執行緒狀態是在當前執行緒"
"狀態中建立的。請注意，沒有建立實際的執行緒；請參閱下面對執行緒狀態的討論。如"
"果建立新直譯器不成功，則回傳 NULL；沒有設定例外，因為例外狀態儲存在當前執行緒"
"狀態中，並且可能沒有當前執行緒狀態。 （與所有其他 Python/C API 函式一樣，全局"
"直譯器鎖必須在呼叫此函式之前持有，並且在它回傳時仍然持有；但是，與大多數其他 "
"Python/C API 函式不同，在入口。）"

#: ../../c-api/init.rst:1420
#, fuzzy
msgid "Extension modules are shared between (sub-)interpreters as follows:"
msgstr "擴充模組在（子）直譯器之間共享，如下所示："

#: ../../c-api/init.rst:1422
#, fuzzy
msgid ""
"For modules using multi-phase initialization, e.g. :c:func:"
"`PyModule_FromDefAndSpec`, a separate module object is created and "
"initialized for each interpreter. Only C-level static and global variables "
"are shared between these module objects."
msgstr ""
"對於使用多階段初始化的模組，例如:c:func:`PyModule_FromDefAndSpec`，為每個直譯"
"器建立並初始化一個單獨的模組物件。這些模組物件之間僅共享 C 級靜態和全局變數。"

#: ../../c-api/init.rst:1428
#, fuzzy
msgid ""
"For modules using single-phase initialization, e.g. :c:func:"
"`PyModule_Create`, the first time a particular extension is imported, it is "
"initialized normally, and a (shallow) copy of its module's dictionary is "
"squirreled away. When the same extension is imported by another "
"(sub-)interpreter, a new module is initialized and filled with the contents "
"of this copy; the extension's ``init`` function is not called. Objects in "
"the module's dictionary thus end up shared across (sub-)interpreters, which "
"might cause unwanted behavior (see `Bugs and caveats`_ below)."
msgstr ""
"對於使用單相初始化的模組，例如:c:func:`PyModule_Create`，第一次導入特定擴充"
"時，它會正常初始化，並且會儲存其模組字典的（淺）副本。當相同的擴充被另一個"
"（子）直譯器導入時，一個新的模組被初始化並填充這個副本的內容；擴充的 "
"``init`` 函式沒有被呼叫。因此，模組字典中的物件最終會在（子）直譯器之間共享，"
"這可能會導致不需要的行為（請參閱下面的“錯誤和警告”）。"

#: ../../c-api/init.rst:1439
#, fuzzy
msgid ""
"Note that this is different from what happens when an extension is imported "
"after the interpreter has been completely re-initialized by calling :c:func:"
"`Py_FinalizeEx` and :c:func:`Py_Initialize`; in that case, the extension's "
"``initmodule`` function *is* called again. As with multi-phase "
"initialization, this means that only C-level static and global variables are "
"shared between these modules."
msgstr ""
"請注意，這與在通過呼叫 Py_FinalizeEx 和 Py_Initialize 完全重新初始化直譯器之"
"後導入擴充時發生的情況不同；在這種情況下，擴充的 ``initmodule`` 函式*被*再次"
"呼叫。與多階段初始化一樣，這意味著這些模組之間僅共享 C 級靜態和全局變數。"

#: ../../c-api/init.rst:1453
#, fuzzy
msgid ""
"Destroy the (sub-)interpreter represented by the given thread state. The "
"given thread state must be the current thread state.  See the discussion of "
"thread states below.  When the call returns, the current thread state is "
"``NULL``.  All thread states associated with this interpreter are "
"destroyed.  (The global interpreter lock must be held before calling this "
"function and is still held when it returns.)  :c:func:`Py_FinalizeEx` will "
"destroy all sub-interpreters that haven't been explicitly destroyed at that "
"point."
msgstr ""
"銷毀由給定執行緒狀態表示的（子）直譯器。給定的執行緒狀態必須是當前執行緒狀"
"態。請參閱下面對執行緒狀態的討論。當呼叫回傳時，當前執行緒狀態為 ``NULL`` 。"
"與該直譯器關聯的所有執行緒狀態都被銷毀。 （全局直譯器鎖必須在呼叫此函式之前持"
"有，並且在它回傳時仍然持有。）:c:func:`Py_FinalizeEx` 將銷毀此時尚未明確銷毀"
"的所有子直譯器。"

#: ../../c-api/init.rst:1463
#, fuzzy
msgid "Bugs and caveats"
msgstr "錯誤和注意事項"

#: ../../c-api/init.rst:1465
#, fuzzy
msgid ""
"Because sub-interpreters (and the main interpreter) are part of the same "
"process, the insulation between them isn't perfect --- for example, using "
"low-level file operations like  :func:`os.close` they can (accidentally or "
"maliciously) affect each other's open files.  Because of the way extensions "
"are shared between (sub-)interpreters, some extensions may not work "
"properly; this is especially likely when using single-phase initialization "
"or (static) global variables. It is possible to insert objects created in "
"one sub-interpreter into a namespace of another (sub-)interpreter; this "
"should be avoided if possible."
msgstr ""
"因為子直譯器（和主直譯器）是同一個行程的一部分，它們之間的隔離並不完美——例"
"如，使用像 :func:`os.close` 這樣的低階文件操作，它們可以（不小心或惡意）影響"
"彼此打開的文件。由於（子）直譯器之間共享擴充的方式，某些擴充可能無法正常工"
"作；這在使用單階段初始化或（靜態）全局變數時尤其可能發生。可以將在一個子直譯"
"器中建立的物件插入到另一個（子）直譯器的名稱空間中；如果可能的話，應該避免這"
"種情況。"

#: ../../c-api/init.rst:1475
#, fuzzy
msgid ""
"Special care should be taken to avoid sharing user-defined functions, "
"methods, instances or classes between sub-interpreters, since import "
"operations executed by such objects may affect the wrong (sub-)interpreter's "
"dictionary of loaded modules. It is equally important to avoid sharing "
"objects from which the above are reachable."
msgstr ""
"應特別注意避免在子直譯器之間共享使用者定義的函式、方法、實例或類，因為由此類"
"物件執行的導入操作可能會影響錯誤的（子）直譯器加載模組的字典。同樣重要的是避"
"免共享可訪問上述物件的物件。"

#: ../../c-api/init.rst:1481
#, fuzzy
msgid ""
"Also note that combining this functionality with ``PyGILState_*`` APIs is "
"delicate, because these APIs assume a bijection between Python thread states "
"and OS-level threads, an assumption broken by the presence of sub-"
"interpreters. It is highly recommended that you don't switch sub-"
"interpreters between a pair of matching :c:func:`PyGILState_Ensure` and :c:"
"func:`PyGILState_Release` calls. Furthermore, extensions (such as :mod:"
"`ctypes`) using these APIs to allow calling of Python code from non-Python "
"created threads will probably be broken when using sub-interpreters."
msgstr ""
"另請注意，將此功能與 ``PyGILState_*`` API 結合起來很微妙，因為這些 API 假定 "
"Python 執行緒狀態和操作系統級執行緒之間存在雙射，而子直譯器的存在打破了這一假"
"設。強烈建議您不要在一對匹配的 PyGILState_Ensure 和 PyGILState_Release 呼叫之"
"間切換子直譯器。此外，使用這些 API 允許從非 Python 建立的執行緒呼叫 Python 程"
"式碼的擴充（例如 :mod:`ctypes`）在使用子直譯器時可能會被破壞。"

#: ../../c-api/init.rst:1492
#, fuzzy
msgid "Asynchronous Notifications"
msgstr "非同步通知"

#: ../../c-api/init.rst:1494
#, fuzzy
msgid ""
"A mechanism is provided to make asynchronous notifications to the main "
"interpreter thread.  These notifications take the form of a function pointer "
"and a void pointer argument."
msgstr ""
"提供了一種機制來向主直譯器執行緒發出非同步通知。這些通知採用函式指標和空指標"
"參數的形式。"

#: ../../c-api/init.rst:1503
#, fuzzy
msgid ""
"Schedule a function to be called from the main interpreter thread.  On "
"success, ``0`` is returned and *func* is queued for being called in the main "
"thread.  On failure, ``-1`` is returned without setting any exception."
msgstr ""
"安排一個函式從主直譯器執行緒呼叫。成功時，回傳 ``0`` 並且 *func* 排隊等待在主"
"執行緒中呼叫。失敗時，回傳 ``-1``而不設定任何例外。"

#: ../../c-api/init.rst:1507
#, fuzzy
msgid ""
"When successfully queued, *func* will be *eventually* called from the main "
"interpreter thread with the argument *arg*.  It will be called "
"asynchronously with respect to normally running Python code, but with both "
"these conditions met:"
msgstr ""
"當成功排隊時，*func* 將*最終*從主直譯器執行緒使用參數*arg* 呼叫。它將相對於正"
"常運行的 Python 程式碼非同步呼叫，但同時滿足以下兩個條件："

#: ../../c-api/init.rst:1512
#, fuzzy
msgid "on a :term:`bytecode` boundary;"
msgstr "在 :term:`bytecode` 邊界上；"

#: ../../c-api/init.rst:1513
#, fuzzy
msgid ""
"with the main thread holding the :term:`global interpreter lock` (*func* can "
"therefore use the full C API)."
msgstr ""
"主執行緒持有 :term:`global interpreter lock`（*func* 因此可以使用完整的 C "
"API）。"

#: ../../c-api/init.rst:1516
#, fuzzy
msgid ""
"*func* must return ``0`` on success, or ``-1`` on failure with an exception "
"set.  *func* won't be interrupted to perform another asynchronous "
"notification recursively, but it can still be interrupted to switch threads "
"if the global interpreter lock is released."
msgstr ""
"*func* 必須在成功時回傳 ``0``，或在失敗時回傳 ``-1``並設定例外。 *func* 不會"
"被中斷去遞迴執行另一個非同步通知，但是如果全局直譯器鎖被釋放，它仍然可以被中"
"斷去切換執行緒。"

#: ../../c-api/init.rst:1521
#, fuzzy
msgid ""
"This function doesn't need a current thread state to run, and it doesn't "
"need the global interpreter lock."
msgstr "此函式不需要當前執行緒狀態即可運行，也不需要全局直譯器鎖。"

#: ../../c-api/init.rst:1524
#, fuzzy
msgid ""
"To call this function in a subinterpreter, the caller must hold the GIL. "
"Otherwise, the function *func* can be scheduled to be called from the wrong "
"interpreter."
msgstr ""
"要在子直譯器中呼叫此函式，呼叫者必須持有 GIL。否則，函式 *func* 可能會被錯誤"
"的直譯器呼叫。"

#: ../../c-api/init.rst:1529
#, fuzzy
msgid ""
"This is a low-level function, only useful for very special cases. There is "
"no guarantee that *func* will be called as quick as possible.  If the main "
"thread is busy executing a system call, *func* won't be called before the "
"system call returns.  This function is generally **not** suitable for "
"calling Python code from arbitrary C threads.  Instead, use the :ref:"
"`PyGILState API<gilstate>`."
msgstr ""
"這是一個低階函式，只對非常特殊的情況有用。不能保證 *func* 會盡快被呼叫。如果"
"主執行緒正忙於執行系統呼叫，*func* 將不會在系統呼叫回傳之前被呼叫。這個函式一"
"般**不**適合從任意 C 執行緒呼叫 Python 程式碼。相反，請使用 PyGILState "
"API<gilstate>`。"

#: ../../c-api/init.rst:1536
#, fuzzy
msgid ""
"If this function is called in a subinterpreter, the function *func* is now "
"scheduled to be called from the subinterpreter, rather than being called "
"from the main interpreter. Each subinterpreter now has its own list of "
"scheduled calls."
msgstr ""
"如果在子直譯器中呼叫此函式，函式 *func* 現在計劃從子直譯器呼叫，而不是從主直"
"譯器呼叫。每個子直譯器現在都有自己的預定呼叫列表。"

#: ../../c-api/init.rst:1547
#, fuzzy
msgid "Profiling and Tracing"
msgstr "剖析和追踪"

#: ../../c-api/init.rst:1552
#, fuzzy
msgid ""
"The Python interpreter provides some low-level support for attaching "
"profiling and execution tracing facilities.  These are used for profiling, "
"debugging, and coverage analysis tools."
msgstr ""
"Python 直譯器為附加分析和執行跟踪工具提供了一些低階支援。這些用於分析、除錯和"
"覆蓋率分析工具。"

#: ../../c-api/init.rst:1556
#, fuzzy
msgid ""
"This C interface allows the profiling or tracing code to avoid the overhead "
"of calling through Python-level callable objects, making a direct C function "
"call instead.  The essential attributes of the facility have not changed; "
"the interface allows trace functions to be installed per-thread, and the "
"basic events reported to the trace function are the same as had been "
"reported to the Python-level trace functions in previous versions."
msgstr ""
"此 C 介面允許分析或跟踪程式碼避免通過 Python 級可呼叫物件呼叫的開銷，而是直接"
"呼叫 C 函式。設施的基本屬性沒有改變；該介面允許為每個執行緒安裝跟踪函式，報告"
"給跟踪函式的基本事件與之前版本報告給 Python 級跟踪函式的事件相同。"

#: ../../c-api/init.rst:1566
#, fuzzy
msgid ""
"The type of the trace function registered using :c:func:`PyEval_SetProfile` "
"and :c:func:`PyEval_SetTrace`. The first parameter is the object passed to "
"the registration function as *obj*, *frame* is the frame object to which the "
"event pertains, *what* is one of the constants :const:`PyTrace_CALL`, :const:"
"`PyTrace_EXCEPTION`, :const:`PyTrace_LINE`, :const:`PyTrace_RETURN`, :const:"
"`PyTrace_C_CALL`, :const:`PyTrace_C_EXCEPTION`, :const:`PyTrace_C_RETURN`, "
"or :const:`PyTrace_OPCODE`, and *arg* depends on the value of *what*:"
msgstr ""
"使用 PyEval_SetProfile 和 PyEval_SetTrace 註冊的跟踪函式的型別。第一個參數是"
"作為 *obj* 傳遞給註冊函式的物件，*frame* 是事件所屬的框架物件，*what* 是常數"
"之一 :const:`PyTrace_CALL`, :const:`PyTrace_EXCEPTION` , :const:"
"`PyTrace_LINE`, :const:`PyTrace_RETURN`, :const:`PyTrace_C_CALL`, :const:"
"`PyTrace_C_EXCEPTION`, :const:`PyTrace_C_RETURN`, :const:`PyTrace_OPCODE`, "
"*arg* 取決於*什麼*的價值："

#: ../../c-api/init.rst:1575
#, fuzzy
msgid "Value of *what*"
msgstr "*什麼*的價值"

#: ../../c-api/init.rst:1575
#, fuzzy
msgid "Meaning of *arg*"
msgstr "*arg* 的含義"

#: ../../c-api/init.rst:1577
msgid ":const:`PyTrace_CALL`"
msgstr ":const:`PyTrace_CALL`"

#: ../../c-api/init.rst:1577 ../../c-api/init.rst:1582
#: ../../c-api/init.rst:1593
msgid "Always :c:data:`Py_None`."
msgstr "總是 :c:data:`Py_None`。"

#: ../../c-api/init.rst:1579
msgid ":const:`PyTrace_EXCEPTION`"
msgstr ":const:`PyTrace_EXCEPTION`"

#: ../../c-api/init.rst:1579
#, fuzzy
msgid "Exception information as returned by :func:`sys.exc_info`."
msgstr ":func:`sys.exc_info` 回傳的例外資訊。"

#: ../../c-api/init.rst:1582
msgid ":const:`PyTrace_LINE`"
msgstr ":const:`PyTrace_LINE`"

#: ../../c-api/init.rst:1584
msgid ":const:`PyTrace_RETURN`"
msgstr ":const:`PyTrace_RETURN`"

#: ../../c-api/init.rst:1584
#, fuzzy
msgid ""
"Value being returned to the caller, or ``NULL`` if caused by an exception."
msgstr "回傳給呼叫者的值，如果由例外引起則為 ``NULL`` 。"

#: ../../c-api/init.rst:1587
msgid ":const:`PyTrace_C_CALL`"
msgstr ":const:`PyTrace_C_CALL`"

#: ../../c-api/init.rst:1587 ../../c-api/init.rst:1589
#: ../../c-api/init.rst:1591
#, fuzzy
msgid "Function object being called."
msgstr "被呼叫的函式物件。"

#: ../../c-api/init.rst:1589
msgid ":const:`PyTrace_C_EXCEPTION`"
msgstr ":const:`PyTrace_C_EXCEPTION`"

#: ../../c-api/init.rst:1591
msgid ":const:`PyTrace_C_RETURN`"
msgstr ":const:`PyTrace_C_RETURN`"

#: ../../c-api/init.rst:1593
msgid ":const:`PyTrace_OPCODE`"
msgstr ":const:`PyTrace_OPCODE`"

#: ../../c-api/init.rst:1598
#, fuzzy
msgid ""
"The value of the *what* parameter to a :c:type:`Py_tracefunc` function when "
"a new call to a function or method is being reported, or a new entry into a "
"generator. Note that the creation of the iterator for a generator function "
"is not reported as there is no control transfer to the Python bytecode in "
"the corresponding frame."
msgstr ""
"當報告對函式或方法的新呼叫或生成器的新條目時，Py_tracefunc 函式的 *what* 參數"
"的值。請注意，生成器函式的疊代器的建立不會被報告，因為在相應的幀中沒有控制轉"
"移到 Python 位元組碼。"

#: ../../c-api/init.rst:1607
#, fuzzy
msgid ""
"The value of the *what* parameter to a :c:type:`Py_tracefunc` function when "
"an exception has been raised.  The callback function is called with this "
"value for *what* when after any bytecode is processed after which the "
"exception becomes set within the frame being executed.  The effect of this "
"is that as exception propagation causes the Python stack to unwind, the "
"callback is called upon return to each frame as the exception propagates.  "
"Only trace functions receives these events; they are not needed by the "
"profiler."
msgstr ""
"引發例外時 Py_tracefunc 函式的 *what* 參數的值。當任何位元組碼被處理之後，例"
"外被設定在正在執行的幀中時，回呼函式被呼叫為 *what* 的這個值。這樣做的效果"
"是，當例外傳播導致 Python 堆疊展開時，回呼會在例外傳播時回傳到每個幀時被呼"
"叫。只有跟踪函式接收這些事件；探查器不需要它們。"

#: ../../c-api/init.rst:1618
#, fuzzy
msgid ""
"The value passed as the *what* parameter to a :c:type:`Py_tracefunc` "
"function (but not a profiling function) when a line-number event is being "
"reported. It may be disabled for a frame by setting :attr:`f_trace_lines` to "
"*0* on that frame."
msgstr ""
"當報告行號事件時，該值作為 *what* 參數傳遞給 Py_tracefunc 函式（但不是分析函"
"式）。可以通過在該幀上將 :attr:`f_trace_lines` 設定為 *0* 來為該幀禁用它。"

#: ../../c-api/init.rst:1625
#, fuzzy
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a call is about to return."
msgstr ":c:type:`Py_tracefunc` 的 *what* 參數的值在呼叫即將回傳時起作用。"

#: ../../c-api/init.rst:1631
#, fuzzy
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function is about to be called."
msgstr ":c:type:`Py_tracefunc` 的 *what* 參數的值在即將呼叫 C 函式時起作用。"

#: ../../c-api/init.rst:1637
#, fuzzy
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function has raised an exception."
msgstr "當 C 函式引發例外時，Py_tracefunc 的 *what* 參數值起作用。"

#: ../../c-api/init.rst:1643
#, fuzzy
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function has returned."
msgstr ":c:type:`Py_tracefunc` 的 *what* 參數的值在 C 函式回傳時起作用。"

#: ../../c-api/init.rst:1649
#, fuzzy
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions (but "
"not profiling functions) when a new opcode is about to be executed.  This "
"event is not emitted by default: it must be explicitly requested by setting :"
"attr:`f_trace_opcodes` to *1* on the frame."
msgstr ""
":c:type:`Py_tracefunc` 的 *what* 參數的值在即將執行新操作碼時起作用（但不是分"
"析函式）。預設情況下不會發出此事件：必須通過在框架上將 f_trace_opcodes 設定"
"為 *1* 來明確請求。"

#: ../../c-api/init.rst:1657
#, fuzzy
msgid ""
"Set the profiler function to *func*.  The *obj* parameter is passed to the "
"function as its first parameter, and may be any Python object, or ``NULL``.  "
"If the profile function needs to maintain state, using a different value for "
"*obj* for each thread provides a convenient and thread-safe place to store "
"it.  The profile function is called for all monitored events except :const:"
"`PyTrace_LINE` :const:`PyTrace_OPCODE` and :const:`PyTrace_EXCEPTION`."
msgstr ""
"將探查器函式設定為 *func*。 *obj* 參數作為第一個參數傳遞給函式，可以是任何 "
"Python 物件，或 ``NULL`` 。如果配置文件函式需要維護狀態，則為每個執行緒使用不"
"同的 *obj* 值可以提供一個方便且執行緒安全的儲存位置。為除 PyTrace_LINE、"
"PyTrace_OPCODE 和 PyTrace_EXCEPTION 之外的所有監視事件呼叫配置文件函式。"

#: ../../c-api/init.rst:1664
msgid "See also the :func:`sys.setprofile` function."
msgstr "請見 :func:`sys.setprofile` 函式。"

#: ../../c-api/init.rst:1666 ../../c-api/init.rst:1680
msgid "The caller must hold the :term:`GIL`."
msgstr "呼叫者必須持有 :term:`GIL`。"

#: ../../c-api/init.rst:1671
#, fuzzy
msgid ""
"Set the tracing function to *func*.  This is similar to :c:func:"
"`PyEval_SetProfile`, except the tracing function does receive line-number "
"events and per-opcode events, but does not receive any event related to C "
"function objects being called.  Any trace function registered using :c:func:"
"`PyEval_SetTrace` will not receive :const:`PyTrace_C_CALL`, :const:"
"`PyTrace_C_EXCEPTION` or :const:`PyTrace_C_RETURN` as a value for the *what* "
"parameter."
msgstr ""
"將跟踪函式設定為 *func*。這類似於 :c:func:`PyEval_SetProfile`，除了跟踪函式確"
"實接收行號事件和每個操作碼事件，但不接收與被呼叫的 C 函式物件相關的任何事件。"
"使用 PyEval_SetTrace 註冊的任何跟踪函式都不會接收 PyTrace_C_CALL、"
"PyTrace_C_EXCEPTION 或 PyTrace_C_RETURN 作為 *what* 參數的值。"

#: ../../c-api/init.rst:1678
msgid "See also the :func:`sys.settrace` function."
msgstr "也請見 :func:`sys.settrace` 函式。"

#: ../../c-api/init.rst:1686
#, fuzzy
msgid "Advanced Debugger Support"
msgstr "進階除錯器支援"

#: ../../c-api/init.rst:1691
#, fuzzy
msgid ""
"These functions are only intended to be used by advanced debugging tools."
msgstr "這些函式僅供高階除錯工具使用。"

#: ../../c-api/init.rst:1696
#, fuzzy
msgid ""
"Return the interpreter state object at the head of the list of all such "
"objects."
msgstr "回傳所有此類物件列表開頭的直譯器狀態物件。"

#: ../../c-api/init.rst:1701
#, fuzzy
msgid "Return the main interpreter state object."
msgstr "回傳主直譯器狀態物件。"

#: ../../c-api/init.rst:1706
#, fuzzy
msgid ""
"Return the next interpreter state object after *interp* from the list of all "
"such objects."
msgstr "從所有此類物件的列表中回傳 *interp* 之後的下一個直譯器狀態物件。"

#: ../../c-api/init.rst:1712
#, fuzzy
msgid ""
"Return the pointer to the first :c:type:`PyThreadState` object in the list "
"of threads associated with the interpreter *interp*."
msgstr ""
"回傳指向與直譯器 *interp* 關聯的執行緒列表中第一個 PyThreadState 物件的指標。"

#: ../../c-api/init.rst:1718
#, fuzzy
msgid ""
"Return the next thread state object after *tstate* from the list of all such "
"objects belonging to the same :c:type:`PyInterpreterState` object."
msgstr ""
"從屬於同一 PyInterpreterState 物件的所有此類物件的列表中回傳 *tstate* 之後的"
"下一個執行緒狀態物件。"

#: ../../c-api/init.rst:1725
#, fuzzy
msgid "Thread Local Storage Support"
msgstr "執行緒本地儲存支援"

#: ../../c-api/init.rst:1729
#, fuzzy
msgid ""
"The Python interpreter provides low-level support for thread-local storage "
"(TLS) which wraps the underlying native TLS implementation to support the "
"Python-level thread local storage API (:class:`threading.local`).  The "
"CPython C level APIs are similar to those offered by pthreads and Windows: "
"use a thread key and functions to associate a :c:expr:`void*` value per "
"thread."
msgstr ""
"Python 直譯器為執行緒本地儲存 (TLS) 提供低階支援，它包裝了底層本地 TLS 實作以"
"支援 Python 級執行緒本地儲存 API (:class:`threading.local`)。 CPython C 級 "
"API 類似於 pthreads 和 Windows 提供的 API：使用執行緒鍵和函式來關聯每個執行緒"
"的 :c:expr:`void*` 值。"

#: ../../c-api/init.rst:1736
#, fuzzy
msgid ""
"The GIL does *not* need to be held when calling these functions; they supply "
"their own locking."
msgstr "呼叫這些函式時 *不需要* 保持 GIL；他們提供自己的鎖定。"

#: ../../c-api/init.rst:1739
#, fuzzy
msgid ""
"Note that :file:`Python.h` does not include the declaration of the TLS APIs, "
"you need to include :file:`pythread.h` to use thread-local storage."
msgstr ""
"請注意 :file:`Python.h` 不包含 TLS API 的聲明，您需要包含 :file:`pythread.h` "
"才能使用執行緒本地儲存。"

#: ../../c-api/init.rst:1743
#, fuzzy
msgid ""
"None of these API functions handle memory management on behalf of the :c:"
"expr:`void*` values.  You need to allocate and deallocate them yourself. If "
"the :c:expr:`void*` values happen to be :c:expr:`PyObject*`, these functions "
"don't do refcount operations on them either."
msgstr ""
"這些 API 函式都沒有代表 :c:expr:`void*` 值處理記憶體管理。您需要自己分配和解"
"除分配它們。如果 :c:expr:`void*` 值恰好是 :c:expr:`PyObject*`，這些函式也不會"
"對其進行引用計數操作。"

#: ../../c-api/init.rst:1751
#, fuzzy
msgid "Thread Specific Storage (TSS) API"
msgstr "執行緒特定儲存 (TSS) API"

#: ../../c-api/init.rst:1753
#, fuzzy
msgid ""
"TSS API is introduced to supersede the use of the existing TLS API within "
"the CPython interpreter.  This API uses a new type :c:type:`Py_tss_t` "
"instead of :c:expr:`int` to represent thread keys."
msgstr ""
"引入 TSS API 以取代 CPython 直譯器中現有 TLS API 的使用。此 API 使用新型別 :"
"c:type:`Py_tss_t` 代替 :c:expr:`int` 來表示執行緒鍵。"

#: ../../c-api/init.rst:1759
#, fuzzy
msgid "\"A New C-API for Thread-Local Storage in CPython\" (:pep:`539`)"
msgstr "“CPython 中用於執行緒本地儲存的新 C-API”(:pep:`539`)"

#: ../../c-api/init.rst:1764
#, fuzzy
msgid ""
"This data structure represents the state of a thread key, the definition of "
"which may depend on the underlying TLS implementation, and it has an "
"internal field representing the key's initialization state.  There are no "
"public members in this structure."
msgstr ""
"此資料結構表示執行緒密鑰的狀態，其定義可能取決於底層 TLS 實作，並且它有一個內"
"部欄位表示密鑰的初始化狀態。此結構中沒有公開成員。"

#: ../../c-api/init.rst:1769
#, fuzzy
msgid ""
"When :ref:`Py_LIMITED_API <stable>` is not defined, static allocation of "
"this type by :c:macro:`Py_tss_NEEDS_INIT` is allowed."
msgstr ""
"當 :ref:`Py_LIMITED_API <stable>` 未定義時，允許通過 :c:macro:"
"`Py_tss_NEEDS_INIT` 靜態分配此型別。"

#: ../../c-api/init.rst:1775
#, fuzzy
msgid ""
"This macro expands to the initializer for :c:type:`Py_tss_t` variables. Note "
"that this macro won't be defined with :ref:`Py_LIMITED_API <stable>`."
msgstr ""
"此巨集擴充為 :c:type:`Py_tss_t` 變數的初始值設定項。請注意，此巨集不會使用 :"
"ref:`Py_LIMITED_API <stable>` 定義。"

#: ../../c-api/init.rst:1780
#, fuzzy
msgid "Dynamic Allocation"
msgstr "動態分配"

#: ../../c-api/init.rst:1782
#, fuzzy
msgid ""
"Dynamic allocation of the :c:type:`Py_tss_t`, required in extension modules "
"built with :ref:`Py_LIMITED_API <stable>`, where static allocation of this "
"type is not possible due to its implementation being opaque at build time."
msgstr ""
":c:type:`Py_tss_t` 的動態分配，在使用 :ref:`Py_LIMITED_API <stable>` 構建的擴"
"充模組中需要，由於其實作在構建時不透明，因此無法進行此型別的靜態分配。"

#: ../../c-api/init.rst:1789
#, fuzzy
msgid ""
"Return a value which is the same state as a value initialized with :c:macro:"
"`Py_tss_NEEDS_INIT`, or ``NULL`` in the case of dynamic allocation failure."
msgstr ""
"回傳一個值，該值與使用 :c:macro:`Py_tss_NEEDS_INIT` 初始化的值狀態相同，或者"
"在動態分配失敗的情況下回傳 ``NULL``。"

#: ../../c-api/init.rst:1796
#, fuzzy
msgid ""
"Free the given *key* allocated by :c:func:`PyThread_tss_alloc`, after first "
"calling :c:func:`PyThread_tss_delete` to ensure any associated thread locals "
"have been unassigned. This is a no-op if the *key* argument is ``NULL``."
msgstr ""
"在第一次呼叫 :c:func:`PyThread_tss_delete` 後釋放由 PyThread_tss_alloc 分配的"
"給定 *key* 以確保已取消分配任何關聯的執行緒局部變數。如果 *key* 參數是 "
"``NULL`` ，這是一個空操作。"

#: ../../c-api/init.rst:1802
#, fuzzy
msgid ""
"A freed key becomes a dangling pointer. You should reset the key to ``NULL``."
msgstr "釋放的鍵變成懸空指標。您應該將密鑰重置為 ``NULL`` 。"

#: ../../c-api/init.rst:1807
#, fuzzy
msgid "Methods"
msgstr "方法"

#: ../../c-api/init.rst:1809
#, fuzzy
msgid ""
"The parameter *key* of these functions must not be ``NULL``.  Moreover, the "
"behaviors of :c:func:`PyThread_tss_set` and :c:func:`PyThread_tss_get` are "
"undefined if the given :c:type:`Py_tss_t` has not been initialized by :c:"
"func:`PyThread_tss_create`."
msgstr ""
"這些函式的參數 *key* 不能為 ``NULL`` 。此外，如果給定的 Py_tss_t 未被 "
"PyThread_tss_create 初始化，則 PyThread_tss_set 和 PyThread_tss_get 的行為是"
"未定義的。"

#: ../../c-api/init.rst:1817
#, fuzzy
msgid ""
"Return a non-zero value if the given :c:type:`Py_tss_t` has been initialized "
"by :c:func:`PyThread_tss_create`."
msgstr ""
"如果給定的 Py_tss_t 已被 PyThread_tss_create 初始化，則回傳一個非零值。"

#: ../../c-api/init.rst:1823
#, fuzzy
msgid ""
"Return a zero value on successful initialization of a TSS key.  The behavior "
"is undefined if the value pointed to by the *key* argument is not "
"initialized by :c:macro:`Py_tss_NEEDS_INIT`.  This function can be called "
"repeatedly on the same key -- calling it on an already initialized key is a "
"no-op and immediately returns success."
msgstr ""
"成功初始化 TSS 密鑰時回傳零值。如果 *key* 參數指向的值未被 :c:macro:"
"`Py_tss_NEEDS_INIT` 初始化，則行為未定義。可以在同一個鍵上重複呼叫此函式——在"
"已初始化的鍵上呼叫它是空操作，並立即回傳成功。"

#: ../../c-api/init.rst:1832
#, fuzzy
msgid ""
"Destroy a TSS key to forget the values associated with the key across all "
"threads, and change the key's initialization state to uninitialized.  A "
"destroyed key is able to be initialized again by :c:func:"
"`PyThread_tss_create`. This function can be called repeatedly on the same "
"key -- calling it on an already destroyed key is a no-op."
msgstr ""
"銷毀 TSS 密鑰以忘記所有執行緒中與密鑰關聯的值，並將密鑰的初始化狀態更改為未初"
"始化。銷毀的密鑰可以通過 :c:func:`PyThread_tss_create` 再次初始化。可以在同一"
"個鍵上重複呼叫此函式——在已銷毀的鍵上呼叫它是空操作。"

#: ../../c-api/init.rst:1841
#, fuzzy
msgid ""
"Return a zero value to indicate successfully associating a :c:expr:`void*` "
"value with a TSS key in the current thread.  Each thread has a distinct "
"mapping of the key to a :c:expr:`void*` value."
msgstr ""
"回傳零值表示成功將 :c:expr:`void*` 值與當前執行緒中的 TSS 鍵相關聯。每個執行"
"緒都有一個獨特的鍵映射到 :c:expr:`void*` 值。"

#: ../../c-api/init.rst:1848
#, fuzzy
msgid ""
"Return the :c:expr:`void*` value associated with a TSS key in the current "
"thread.  This returns ``NULL`` if no value is associated with the key in the "
"current thread."
msgstr ""
"回傳與當前執行緒中的 TSS 鍵關聯的 :c:expr:`void*` 值。如果沒有值與當前執行緒"
"中的鍵相關聯，則回傳 ``NULL`` 。"

#: ../../c-api/init.rst:1856
#, fuzzy
msgid "Thread Local Storage (TLS) API"
msgstr "執行緒本地儲存 (TLS) API"

#: ../../c-api/init.rst:1858
#, fuzzy
msgid ""
"This API is superseded by :ref:`Thread Specific Storage (TSS) API <thread-"
"specific-storage-api>`."
msgstr ""
"此 API 已被 :ref:`Thread Specific Storage (TSS) API <thread-specific-storage-"
"api>` 取代。"

#: ../../c-api/init.rst:1863
#, fuzzy
msgid ""
"This version of the API does not support platforms where the native TLS key "
"is defined in a way that cannot be safely cast to ``int``.  On such "
"platforms, :c:func:`PyThread_create_key` will return immediately with a "
"failure status, and the other TLS functions will all be no-ops on such "
"platforms."
msgstr ""
"此版本的 API 不支援以無法安全轉換為 ``int``的方式定義本機 TLS 密鑰的平台。在"
"這樣的平台上，:c:func:`PyThread_create_key` 將立即回傳失敗狀態，並且其他 TLS "
"函式在這樣的平台上都將是空操作。"

#: ../../c-api/init.rst:1868
#, fuzzy
msgid ""
"Due to the compatibility problem noted above, this version of the API should "
"not be used in new code."
msgstr "由於上述相容性問題，不應在新程式碼中使用此版本的 API。"
