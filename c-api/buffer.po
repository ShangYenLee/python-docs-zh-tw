# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-15 20:43+0000\n"
"PO-Revision-Date: 2018-05-23 14:30+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/buffer.rst:11
msgid "Buffer Protocol"
msgstr "緩衝協定 (Buffer Protocol)"

#: ../../c-api/buffer.rst:18
#, fuzzy
msgid ""
"Certain objects available in Python wrap access to an underlying memory "
"array or *buffer*.  Such objects include the built-in :class:`bytes` and :"
"class:`bytearray`, and some extension types like :class:`array.array`. Third-"
"party libraries may define their own types for special purposes, such as "
"image processing or numeric analysis."
msgstr ""
"Python 中可用的某些物件包裝了對底層記憶體數組或 *buffer* "
"的訪問。這些物件包括內建的 :class:`bytes` "
"和 :class:`bytearray`，以及一些擴充型別，如 :class:`array."
"array`。第三方庫可能會為特殊用途定義自己的型別，例如圖像處理或數值分析。"

#: ../../c-api/buffer.rst:24
#, fuzzy
msgid ""
"While each of these types have their own semantics, they share the common "
"characteristic of being backed by a possibly large memory buffer.  It is "
"then desirable, in some situations, to access that buffer directly and "
"without intermediate copying."
msgstr "雖然這些型別中的每一種都有自己的語義，但它們具有共同的特徵，即由可能很大的記"
"憶體緩衝區支援。在某些情況下，需要直接訪問該緩衝區而無需中間複製。"

#: ../../c-api/buffer.rst:29
#, fuzzy
msgid ""
"Python provides such a facility at the C level in the form of the :ref:"
"`buffer protocol <bufferobjects>`.  This protocol has two sides:"
msgstr ""
"Python 以 :ref:`buffer protocol <bufferobjects>` 的形式在 C "
"級別提供了這樣的功能。該協定有兩個方面："

#: ../../c-api/buffer.rst:34
#, fuzzy
msgid ""
"on the producer side, a type can export a \"buffer interface\" which allows "
"objects of that type to expose information about their underlying buffer. "
"This interface is described in the section :ref:`buffer-structs`;"
msgstr ""
"在生產者方面，一個型別可以導出一個“緩衝區介面”，它允許該型別的物件公開有關其"
"底層緩衝區的資訊。該介面在 :ref:`buffer-structs` 部分進行了描述；"

#: ../../c-api/buffer.rst:38
#, fuzzy
msgid ""
"on the consumer side, several means are available to obtain a pointer to the "
"raw underlying data of an object (for example a method parameter)."
msgstr "在消費者方面，有幾種方法可用於獲取指向物件原始基礎資料的指標（例如方法參數）"
"。"

#: ../../c-api/buffer.rst:41
#, fuzzy
msgid ""
"Simple objects such as :class:`bytes` and :class:`bytearray` expose their "
"underlying buffer in byte-oriented form.  Other forms are possible; for "
"example, the elements exposed by an :class:`array.array` can be multi-byte "
"values."
msgstr ""
"像 bytes 和 bytearray 這樣的簡單對像以面向位元組的形式公開它們的底層緩衝區。"
"其他形式也是可能的；例如，array.array 公開的元素可以是多位元組值。"

#: ../../c-api/buffer.rst:45
#, fuzzy
msgid ""
"An example consumer of the buffer interface is the :meth:`~io.BufferedIOBase."
"write` method of file objects: any object that can export a series of bytes "
"through the buffer interface can be written to a file.  While :meth:`write` "
"only needs read-only access to the internal contents of the object passed to "
"it, other methods such as :meth:`~io.BufferedIOBase.readinto` need write "
"access to the contents of their argument.  The buffer interface allows "
"objects to selectively allow or reject exporting of read-write and read-only "
"buffers."
msgstr ""
"緩衝區介面的一個示例消費者是文件物件的 :meth:`~io.BufferedIOBase.write` "
"方法：任何可以通過緩衝區介面導出一系列位元組的對像都可以寫入文件。雖然 "
":meth:`write` 只需要對傳遞給它的物件的內部內容進行只讀訪問，但其他方法如 "
":meth:`~io.BufferedIOBase.readinto` 需要對其參數內容的寫訪問權限。緩衝區介面"
"允許對像有選擇地允許或拒絕導出讀寫和只讀緩衝區。"

#: ../../c-api/buffer.rst:53
#, fuzzy
msgid ""
"There are two ways for a consumer of the buffer interface to acquire a "
"buffer over a target object:"
msgstr "緩衝區介面的使用者可以通過兩種方式獲取目標對像上的緩衝區："

#: ../../c-api/buffer.rst:56
#, fuzzy
msgid "call :c:func:`PyObject_GetBuffer` with the right parameters;"
msgstr "使用正確的參數呼叫 :c:func:`PyObject_GetBuffer`；"

#: ../../c-api/buffer.rst:58
#, fuzzy
msgid ""
"call :c:func:`PyArg_ParseTuple` (or one of its siblings) with one of the "
"``y*``, ``w*`` or ``s*`` :ref:`format codes <arg-parsing>`."
msgstr ""
"使用 ``y*``、``w*`` 或 ``s*`` "
"之一呼叫 :c:func:`PyArg_ParseTuple`（或其兄弟姐妹之一） :ref:`格式程式碼 "
"<arg-parsing >`。"

#: ../../c-api/buffer.rst:61
#, fuzzy
msgid ""
"In both cases, :c:func:`PyBuffer_Release` must be called when the buffer "
"isn't needed anymore.  Failure to do so could lead to various issues such as "
"resource leaks."
msgstr ""
"在這兩種情況下，當不再需要緩衝區時，必須呼叫 "
":c:func:`PyBuffer_Release`。如果不這樣做可能會導致各種問題，例如資源洩漏。"

#: ../../c-api/buffer.rst:69
#, fuzzy
msgid "Buffer structure"
msgstr "緩衝結構"

#: ../../c-api/buffer.rst:71
#, fuzzy
msgid ""
"Buffer structures (or simply \"buffers\") are useful as a way to expose the "
"binary data from another object to the Python programmer.  They can also be "
"used as a zero-copy slicing mechanism.  Using their ability to reference a "
"block of memory, it is possible to expose any data to the Python programmer "
"quite easily.  The memory could be a large, constant array in a C extension, "
"it could be a raw block of memory for manipulation before passing to an "
"operating system library, or it could be used to pass around structured data "
"in its native, in-memory format."
msgstr ""
"緩衝區結構（或簡稱為“緩衝區”）可用作將二進位資料從另一個物件公開給 Python "
"程式員的一種方式。它們也可以用作零拷貝切片機制。利用它們引用記憶體塊的能力，"
"可以很容易地將任何資料暴露給 Python 程式員。記憶體可以是 C 擴充中的一個大常數"
"數組，它可以是一個原始記憶體塊，用於在傳遞給操作系統庫之前進行操作，或者它可"
"以用於以其本機記憶體格式傳遞結構化資料."

#: ../../c-api/buffer.rst:80
#, fuzzy
msgid ""
"Contrary to most data types exposed by the Python interpreter, buffers are "
"not :c:type:`PyObject` pointers but rather simple C structures.  This allows "
"them to be created and copied very simply.  When a generic wrapper around a "
"buffer is needed, a :ref:`memoryview <memoryview-objects>` object can be "
"created."
msgstr ""
"與 Python 直譯器公開的大多數資料型別相反，緩衝區不是 PyObject 指標，"
"而是簡單的 C "
"結構。這使得它們的建立和復制非常簡單。當需要圍繞緩衝區的通用包裝器時，"
"可以建立一個 :ref:`memoryview <memoryview-objects>` 物件。"

#: ../../c-api/buffer.rst:86
#, fuzzy
msgid ""
"For short instructions how to write an exporting object, see :ref:`Buffer "
"Object Structures <buffer-structs>`. For obtaining a buffer, see :c:func:"
"`PyObject_GetBuffer`."
msgstr ""
"有關如何編寫導出物件的簡短說明，請參閱 :ref:`Buffer Object Structures <buffer-"
"structs>`。要獲取緩衝區，請參閱:c:func:`PyObject_GetBuffer`。"

#: ../../c-api/buffer.rst:94
#, fuzzy
msgid ""
"A pointer to the start of the logical structure described by the buffer "
"fields. This can be any location within the underlying physical memory block "
"of the exporter. For example, with negative :c:member:`~Py_buffer.strides` "
"the value may point to the end of the memory block."
msgstr ""
"指向緩衝區欄位描述的邏輯結構開始的指標。這可以是導出器的底層物理記憶體塊中的"
"任何位置。例如，負數 :c:member:`~Py_buffer.strides` "
"的值可能指向記憶體塊的末尾。"

#: ../../c-api/buffer.rst:99
#, fuzzy
msgid ""
"For :term:`contiguous` arrays, the value points to the beginning of the "
"memory block."
msgstr "對於 :term:`contiguous` 數組，該值指向記憶體塊的開頭。"

#: ../../c-api/buffer.rst:104
#, fuzzy
msgid ""
"A new reference to the exporting object. The reference is owned by the "
"consumer and automatically decremented and set to ``NULL`` by :c:func:"
"`PyBuffer_Release`. The field is the equivalent of the return value of any "
"standard C-API function."
msgstr ""
"對導出物件的新引用。該引用由消費者擁有，並自動遞減並由 PyBuffer_Release "
"設定為 ``NULL`` 。該欄位相當於任何標準 C-API 函式的回傳值。"

#: ../../c-api/buffer.rst:109
#, fuzzy
msgid ""
"As a special case, for *temporary* buffers that are wrapped by :c:func:"
"`PyMemoryView_FromBuffer` or :c:func:`PyBuffer_FillInfo` this field is "
"``NULL``. In general, exporting objects MUST NOT use this scheme."
msgstr ""
"作為一種特殊情況，對於由 :c:func:`PyMemoryView_FromBuffer` 或 "
":c:func:`PyBuffer_FillInfo` "
"包裝的*臨時*緩衝區，此欄位為 ``NULL`` 。通常，導出對像不得使用此方案。"

#: ../../c-api/buffer.rst:116
#, fuzzy
msgid ""
"``product(shape) * itemsize``. For contiguous arrays, this is the length of "
"the underlying memory block. For non-contiguous arrays, it is the length "
"that the logical structure would have if it were copied to a contiguous "
"representation."
msgstr "``產品（形狀）* itemsize``。對於連續數組，這是底層記憶體塊的長度。對於非連續"
"數組，它是邏輯結構在復製到連續表示時的長度。"

#: ../../c-api/buffer.rst:121
#, fuzzy
msgid ""
"Accessing ``((char *)buf)[0] up to ((char *)buf)[len-1]`` is only valid if "
"the buffer has been obtained by a request that guarantees contiguity. In "
"most cases such a request will be :c:macro:`PyBUF_SIMPLE` or :c:macro:"
"`PyBUF_WRITABLE`."
msgstr ""
"訪問 ``((char *)buf)[0] 直到 ((char *)buf)[len-1]`` 僅當緩衝區已通過保證連續"
"性的請求獲得時才有效。在大多數情況下，這樣的請求將是:c:macro:`PyBUF_SIMPLE` "
"或:c:macro:`PyBUF_WRITABLE`。"

#: ../../c-api/buffer.rst:127
#, fuzzy
msgid ""
"An indicator of whether the buffer is read-only. This field is controlled by "
"the :c:macro:`PyBUF_WRITABLE` flag."
msgstr "緩衝區是否為只讀的指示符。該欄位由 :c:macro:`PyBUF_WRITABLE` 旗標控制。"

#: ../../c-api/buffer.rst:132
#, fuzzy
msgid ""
"Item size in bytes of a single element. Same as the value of :func:`struct."
"calcsize` called on non-``NULL`` :c:member:`~Py_buffer.format` values."
msgstr ""
"單個元素的項目大小（以位元組為單位）。與在非 NULL :c:member:~"
"Py_buffer.format 值上呼叫的 struct.calcsize 的值相同。"

#: ../../c-api/buffer.rst:135
#, fuzzy
msgid ""
"Important exception: If a consumer requests a buffer without the :c:macro:"
"`PyBUF_FORMAT` flag, :c:member:`~Py_buffer.format` will be set to  "
"``NULL``,  but :c:member:`~Py_buffer.itemsize` still has the value for the "
"original format."
msgstr ""
"重要例外：如果消費者請求沒有 PyBUF_FORMAT 旗標的緩衝區，:c:member:`~Py_buffer"
".format` 將設定為 ``NULL``，但 :c:member:`~ Py_buffer.itemsize` "
"仍然具有原始格式的值。"

#: ../../c-api/buffer.rst:140
#, fuzzy
msgid ""
"If :c:member:`~Py_buffer.shape` is present, the equality ``product(shape) * "
"itemsize == len`` still holds and the consumer can use :c:member:`~Py_buffer."
"itemsize` to navigate the buffer."
msgstr ""
"如果 :c:member:`~Py_buffer.shape` 存在，等式 ``product(shape) * itemsize == "
"len`` 仍然成立，消費者可以使用 :c:member:`~Py_buffer.itemsize` "
"進行導航緩衝區。"

#: ../../c-api/buffer.rst:144
#, fuzzy
msgid ""
"If :c:member:`~Py_buffer.shape` is ``NULL`` as a result of a :c:macro:"
"`PyBUF_SIMPLE` or a :c:macro:`PyBUF_WRITABLE` request, the consumer must "
"disregard :c:member:`~Py_buffer.itemsize` and assume ``itemsize == 1``."
msgstr ""
"如果 :c:member:`~Py_buffer.shape` 由於 :c:macro:`PyBUF_SIMPLE` 或 "
":c:macro:`PyBUF_WRITABLE` 請求而為 ``NULL``，消費者必須忽略 "
":c:成員：`~Py_buffer.itemsize` 並假設``itemsize == 1``。"

#: ../../c-api/buffer.rst:150
#, fuzzy
msgid ""
"A *NUL* terminated string in :mod:`struct` module style syntax describing "
"the contents of a single item. If this is ``NULL``, ``\"B\"`` (unsigned "
"bytes) is assumed."
msgstr ":mod:`struct` 模組樣式語法中的 *NUL* "
"終止字串，描述單個項目的內容。如果這是 ``NULL`` ，則假定為 ``B``（無符號位元組）。"

#: ../../c-api/buffer.rst:154
#, fuzzy
msgid "This field is controlled by the :c:macro:`PyBUF_FORMAT` flag."
msgstr "該欄位由 :c:macro:`PyBUF_FORMAT` 旗標控制。"

#: ../../c-api/buffer.rst:158
#, fuzzy
msgid ""
"The number of dimensions the memory represents as an n-dimensional array. If "
"it is ``0``, :c:member:`~Py_buffer.buf` points to a single item representing "
"a scalar. In this case, :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer."
"strides` and :c:member:`~Py_buffer.suboffsets` MUST be ``NULL``."
msgstr ""
"記憶體表示為 n 維數組的維數。如果它是 ``0``，:c:member:`~Py_buffer.buf` "
"指向表示標量的單個項目。在這種情況下，:c:member:`~Py_buffer."
"shape`、:c:member:`~Py_buffer.strides` 和:c:member:`~Py_buffer.suboffsets` "
"必須為 ``NULL``。"

#: ../../c-api/buffer.rst:163
#, fuzzy
msgid ""
"The macro :c:macro:`PyBUF_MAX_NDIM` limits the maximum number of dimensions "
"to 64. Exporters MUST respect this limit, consumers of multi-dimensional "
"buffers SHOULD be able to handle up to :c:macro:`PyBUF_MAX_NDIM` dimensions."
msgstr ""
"巨集:c:macro:`PyBUF_MAX_NDIM` 將最大維度數限制為 64。出口商必須遵守此限制，多"
"維緩衝區的消費者應該能夠處理最多:c:macro:`PyBUF_MAX_NDIM` 維度。"

#: ../../c-api/buffer.rst:169
#, fuzzy
msgid ""
"An array of :c:type:`Py_ssize_t` of length :c:member:`~Py_buffer.ndim` "
"indicating the shape of the memory as an n-dimensional array. Note that "
"``shape[0] * ... * shape[ndim-1] * itemsize`` MUST be equal to :c:member:"
"`~Py_buffer.len`."
msgstr ""
"長度為 :c:member:`~Py_buffer.ndim` 的 :c:type:`Py_ssize_t` 數組，"
"表示記憶體的形狀為 n 維數組。請注意，``shape[0] * ... * shape[ndim-1] * "
"itemsize`` 必須等於 :c:member:`~Py_buffer.len`。"

#: ../../c-api/buffer.rst:174
#, fuzzy
msgid ""
"Shape values are restricted to ``shape[n] >= 0``. The case ``shape[n] == 0`` "
"requires special attention. See `complex arrays`_ for further information."
msgstr "形狀值僅限於 ``shape[n] >= 0``。 ``shape[n] == 0`` "
"的情況需要特別注意。有關詳細資訊，請參閱“複雜數組”。"

#: ../../c-api/buffer.rst:178
#, fuzzy
msgid "The shape array is read-only for the consumer."
msgstr "形狀數組對於消費者是只讀的。"

#: ../../c-api/buffer.rst:182
#, fuzzy
msgid ""
"An array of :c:type:`Py_ssize_t` of length :c:member:`~Py_buffer.ndim` "
"giving the number of bytes to skip to get to a new element in each dimension."
msgstr ""
"一個長度為 :c:member:`~Py_buffer.ndim` 的 :c:type:`Py_ssize_t` "
"數組，給出要跳過的位元組數以獲取每個維度中的新元素。"

#: ../../c-api/buffer.rst:186
#, fuzzy
msgid ""
"Stride values can be any integer. For regular arrays, strides are usually "
"positive, but a consumer MUST be able to handle the case ``strides[n] <= "
"0``. See `complex arrays`_ for further information."
msgstr ""
"步幅值可以是任何整數。對於常規數組，步幅通常是正數，但消費者必須能夠處理“stri"
"des[n] <= 0”的情況。有關詳細資訊，請參閱“複雜數組”。"

#: ../../c-api/buffer.rst:190
#, fuzzy
msgid "The strides array is read-only for the consumer."
msgstr "strides 數組對於消費者來說是只讀的。"

#: ../../c-api/buffer.rst:194
#, fuzzy
msgid ""
"An array of :c:type:`Py_ssize_t` of length :c:member:`~Py_buffer.ndim`. If "
"``suboffsets[n] >= 0``, the values stored along the nth dimension are "
"pointers and the suboffset value dictates how many bytes to add to each "
"pointer after de-referencing. A suboffset value that is negative indicates "
"that no de-referencing should occur (striding in a contiguous memory block)."
msgstr ""
"長度為 :c:member:`~Py_buffer.ndim` 的 :c:type:`Py_ssize_t` 數組。如果 "
"``suboffsets[n] >= 0``，則沿第 n 個維度儲存的值是指標，並且 suboffset 值指示"
"在取消引用後向每個指標新增多少位元組。負的子偏移值表示不應發生取消引用（跨入"
"連續的記憶體塊）。"

#: ../../c-api/buffer.rst:201
#, fuzzy
msgid ""
"If all suboffsets are negative (i.e. no de-referencing is needed), then this "
"field must be ``NULL`` (the default value)."
msgstr "如果所有子偏移量都是負數（即不需要取消引用），則此欄位必須為 ``NULL`` （預設值）"
"。"

#: ../../c-api/buffer.rst:204
#, fuzzy
msgid ""
"This type of array representation is used by the Python Imaging Library "
"(PIL). See `complex arrays`_ for further information how to access elements "
"of such an array."
msgstr "這種型別的數組表示由 Python 圖像庫 (PIL) "
"使用。有關如何訪問此類數組元素的更多資訊，請參閱“複雜數組”。"

#: ../../c-api/buffer.rst:208
#, fuzzy
msgid "The suboffsets array is read-only for the consumer."
msgstr "suboffsets 數組對於消費者是只讀的。"

#: ../../c-api/buffer.rst:212
#, fuzzy
msgid ""
"This is for use internally by the exporting object. For example, this might "
"be re-cast as an integer by the exporter and used to store flags about "
"whether or not the shape, strides, and suboffsets arrays must be freed when "
"the buffer is released. The consumer MUST NOT alter this value."
msgstr ""
"這是供導出對像在內部使用。例如，這可能會被導出器重新轉換為整數，並用於儲存有"
"關在釋放緩衝區時是否必須釋放形狀、步幅和子偏移數組的旗標。消費者不得更改此值"
"。"

#: ../../c-api/buffer.rst:221
#, fuzzy
msgid "Buffer request types"
msgstr "緩衝請求型別"

#: ../../c-api/buffer.rst:223
#, fuzzy
msgid ""
"Buffers are usually obtained by sending a buffer request to an exporting "
"object via :c:func:`PyObject_GetBuffer`. Since the complexity of the logical "
"structure of the memory can vary drastically, the consumer uses the *flags* "
"argument to specify the exact buffer type it can handle."
msgstr ""
"緩衝區通常通過 PyObject_GetBuffer "
"嚮導出物件發送緩衝區請求來獲得。由於記憶體邏輯結構的複雜性可能有很大差異，"
"消費者使用 *flags* 參數來指定它可以處理的確切緩衝區型別。"

#: ../../c-api/buffer.rst:228
#, fuzzy
msgid ""
"All :c:data:`Py_buffer` fields are unambiguously defined by the request type."
msgstr "所有 :c:data:`Py_buffer` 欄位都由請求型別明確定義。"

#: ../../c-api/buffer.rst:232
#, fuzzy
msgid "request-independent fields"
msgstr "與請求無關的欄位"

#: ../../c-api/buffer.rst:233
#, fuzzy
msgid ""
"The following fields are not influenced by *flags* and must always be filled "
"in with the correct values: :c:member:`~Py_buffer.obj`, :c:member:"
"`~Py_buffer.buf`, :c:member:`~Py_buffer.len`, :c:member:`~Py_buffer."
"itemsize`, :c:member:`~Py_buffer.ndim`."
msgstr ""
"以下欄位不受 *flags* 的影響，必須始終填寫正確的值：:c:member:`~Py_buffer.obj`"
", :c:member:`~Py_buffer.buf`, :c:member: `~Py_buffer."
"len`、:c:member:`~Py_buffer.itemsize`、:c:member:`~Py_buffer.ndim`。"

#: ../../c-api/buffer.rst:239
#, fuzzy
msgid "readonly, format"
msgstr "只讀，格式化"

#: ../../c-api/buffer.rst:243
#, fuzzy
msgid ""
"Controls the :c:member:`~Py_buffer.readonly` field. If set, the exporter "
"MUST provide a writable buffer or else report failure. Otherwise, the "
"exporter MAY provide either a read-only or writable buffer, but the choice "
"MUST be consistent for all consumers."
msgstr ""
"控制 :c:member:`~Py_buffer.readonly` 欄位。如果設定，導出器必須提供可寫緩衝區"
"，否則報告失敗。否則，導出器可以提供只讀或可寫緩衝區，但選擇必須對所有消費者"
"都是一致的。"

#: ../../c-api/buffer.rst:250
#, fuzzy
msgid ""
"Controls the :c:member:`~Py_buffer.format` field. If set, this field MUST be "
"filled in correctly. Otherwise, this field MUST be ``NULL``."
msgstr "控制 :c:member:`~Py_buffer.format` "
"欄位。如果設定，則必須正確填寫此欄位。否則，該欄位必須為 ``NULL`` 。"

#: ../../c-api/buffer.rst:254
#, fuzzy
msgid ""
":c:macro:`PyBUF_WRITABLE` can be \\|'d to any of the flags in the next "
"section. Since :c:macro:`PyBUF_SIMPLE` is defined as 0, :c:macro:"
"`PyBUF_WRITABLE` can be used as a stand-alone flag to request a simple "
"writable buffer."
msgstr ""
":c:macro:`PyBUF_WRITABLE` 可以 \\|'d 到下一節中的任何旗標。由於 "
":c:macro:`PyBUF_SIMPLE` 被定義為 0，因此 :c:macro:`PyBUF_WRITABLE` "
"可以用作一個獨立的旗標來請求一個簡單的可寫緩衝區。"

#: ../../c-api/buffer.rst:258
#, fuzzy
msgid ""
":c:macro:`PyBUF_FORMAT` can be \\|'d to any of the flags except :c:macro:"
"`PyBUF_SIMPLE`. The latter already implies format ``B`` (unsigned bytes)."
msgstr ""
":c:macro:`PyBUF_FORMAT` 可以 \\|'d 到除 :c:macro:`PyBUF_SIMPLE` "
"之外的任何旗標。後者已經暗示了格式 ``B`` （無符號位元組）。"

#: ../../c-api/buffer.rst:263
#, fuzzy
msgid "shape, strides, suboffsets"
msgstr "形狀、步幅、子偏移量"

#: ../../c-api/buffer.rst:265
#, fuzzy
msgid ""
"The flags that control the logical structure of the memory are listed in "
"decreasing order of complexity. Note that each flag contains all bits of the "
"flags below it."
msgstr "控制記憶體邏輯結構的旗標按複雜度降序排列。請注意，每個旗標都包含其下方旗標的"
"所有位。"

#: ../../c-api/buffer.rst:272 ../../c-api/buffer.rst:296
#: ../../c-api/buffer.rst:321
#, fuzzy
msgid "Request"
msgstr "要求"

#: ../../c-api/buffer.rst:272 ../../c-api/buffer.rst:296
#: ../../c-api/buffer.rst:321
#, fuzzy
msgid "shape"
msgstr "形狀"

#: ../../c-api/buffer.rst:272 ../../c-api/buffer.rst:296
#: ../../c-api/buffer.rst:321
#, fuzzy
msgid "strides"
msgstr "大步前進"

#: ../../c-api/buffer.rst:272 ../../c-api/buffer.rst:296
#: ../../c-api/buffer.rst:321
#, fuzzy
msgid "suboffsets"
msgstr "子偏移量"

#: ../../c-api/buffer.rst:274 ../../c-api/buffer.rst:276
#: ../../c-api/buffer.rst:278 ../../c-api/buffer.rst:298
#: ../../c-api/buffer.rst:300 ../../c-api/buffer.rst:302
#: ../../c-api/buffer.rst:304 ../../c-api/buffer.rst:323
#: ../../c-api/buffer.rst:325 ../../c-api/buffer.rst:327
#: ../../c-api/buffer.rst:329 ../../c-api/buffer.rst:331
#: ../../c-api/buffer.rst:333 ../../c-api/buffer.rst:335
#: ../../c-api/buffer.rst:337
#, fuzzy
msgid "yes"
msgstr "是"

#: ../../c-api/buffer.rst:274 ../../c-api/buffer.rst:323
#: ../../c-api/buffer.rst:325
#, fuzzy
msgid "if needed"
msgstr "如果需要的話"

#: ../../c-api/buffer.rst:276 ../../c-api/buffer.rst:278
#: ../../c-api/buffer.rst:280 ../../c-api/buffer.rst:298
#: ../../c-api/buffer.rst:300 ../../c-api/buffer.rst:302
#: ../../c-api/buffer.rst:304 ../../c-api/buffer.rst:327
#: ../../c-api/buffer.rst:329 ../../c-api/buffer.rst:331
#: ../../c-api/buffer.rst:333 ../../c-api/buffer.rst:335
#: ../../c-api/buffer.rst:337
msgid "NULL"
msgstr "NULL"

#: ../../c-api/buffer.rst:287
#, fuzzy
msgid "contiguity requests"
msgstr "鄰接請求"

#: ../../c-api/buffer.rst:289
#, fuzzy
msgid ""
"C or Fortran :term:`contiguity <contiguous>` can be explicitly requested, "
"with and without stride information. Without stride information, the buffer "
"must be C-contiguous."
msgstr ""
"C 或 Fortran :term:`contiguity <contiguous>` "
"可以顯式請求，有或沒有步幅資訊。沒有跨步資訊，緩衝區必須是 C 連續的。"

#: ../../c-api/buffer.rst:296 ../../c-api/buffer.rst:321
#, fuzzy
msgid "contig"
msgstr "重疊群"

#: ../../c-api/buffer.rst:298 ../../c-api/buffer.rst:304
#: ../../c-api/buffer.rst:335 ../../c-api/buffer.rst:337
msgid "C"
msgstr "C"

#: ../../c-api/buffer.rst:300
msgid "F"
msgstr "F"

#: ../../c-api/buffer.rst:302
msgid "C or F"
msgstr "C 或 F"

#: ../../c-api/buffer.rst:304
msgid ":c:macro:`PyBUF_ND`"
msgstr ":c:macro:`PyBUF_ND`"

#: ../../c-api/buffer.rst:309
#, fuzzy
msgid "compound requests"
msgstr "複合請求"

#: ../../c-api/buffer.rst:311
#, fuzzy
msgid ""
"All possible requests are fully defined by some combination of the flags in "
"the previous section. For convenience, the buffer protocol provides "
"frequently used combinations as single flags."
msgstr "所有可能的請求都完全由上一節中的一些旗標組合定義。為方便起見，緩衝協定提供了"
"常用的組合作為單個旗標。"

#: ../../c-api/buffer.rst:315
#, fuzzy
msgid ""
"In the following table *U* stands for undefined contiguity. The consumer "
"would have to call :c:func:`PyBuffer_IsContiguous` to determine contiguity."
msgstr "在下表中，*U* 代表未定義的連續性。消費者必須呼叫 PyBuffer_IsContiguous "
"來確定連續性。"

#: ../../c-api/buffer.rst:321
#, fuzzy
msgid "readonly"
msgstr "只讀"

#: ../../c-api/buffer.rst:321
#, fuzzy
msgid "format"
msgstr "格式"

#: ../../c-api/buffer.rst:323 ../../c-api/buffer.rst:325
#: ../../c-api/buffer.rst:327 ../../c-api/buffer.rst:329
#: ../../c-api/buffer.rst:331 ../../c-api/buffer.rst:333
msgid "U"
msgstr "U"

#: ../../c-api/buffer.rst:323 ../../c-api/buffer.rst:327
#: ../../c-api/buffer.rst:331 ../../c-api/buffer.rst:335
msgid "0"
msgstr "0"

#: ../../c-api/buffer.rst:325 ../../c-api/buffer.rst:329
#: ../../c-api/buffer.rst:333 ../../c-api/buffer.rst:337
msgid "1 or 0"
msgstr "1 或 0"

#: ../../c-api/buffer.rst:342
#, fuzzy
msgid "Complex arrays"
msgstr "複雜數組"

#: ../../c-api/buffer.rst:345
#, fuzzy
msgid "NumPy-style: shape and strides"
msgstr "NumPy 風格：形狀和步幅"

#: ../../c-api/buffer.rst:347
#, fuzzy
msgid ""
"The logical structure of NumPy-style arrays is defined by :c:member:"
"`~Py_buffer.itemsize`, :c:member:`~Py_buffer.ndim`, :c:member:`~Py_buffer."
"shape` and :c:member:`~Py_buffer.strides`."
msgstr ""
"NumPy 樣式數組的邏輯結構由:c:member:`~Py_buffer."
"itemsize`、:c:member:`~Py_buffer.ndim`、:c:member:`~Py_buffer.shape` "
"和:c:成員：`~Py_buffer.strides`。"

#: ../../c-api/buffer.rst:350
#, fuzzy
msgid ""
"If ``ndim == 0``, the memory location pointed to by :c:member:`~Py_buffer."
"buf` is interpreted as a scalar of size :c:member:`~Py_buffer.itemsize`. In "
"that case, both :c:member:`~Py_buffer.shape` and :c:member:`~Py_buffer."
"strides` are ``NULL``."
msgstr ""
"如果 ``ndim == 0``，則 :c:member:`~Py_buffer.buf` "
"指向的記憶體位置被解釋為大小為 :c:member:`~Py_buffer.itemsize` "
"的標量。在那種情況下，:c:member:`~Py_buffer.shape` 和 :c:member:`~Py_buffer."
"strides` 都是 ``NULL``。"

#: ../../c-api/buffer.rst:354
#, fuzzy
msgid ""
"If :c:member:`~Py_buffer.strides` is ``NULL``, the array is interpreted as a "
"standard n-dimensional C-array. Otherwise, the consumer must access an n-"
"dimensional array as follows:"
msgstr ""
"如果 :c:member:`~Py_buffer.strides` 為 ``NULL``，則該數組被解釋為標準的 n 維 "
"C 數組。否則，消費者必須訪問一個 n 維數組，如下所示："

#: ../../c-api/buffer.rst:364
#, fuzzy
msgid ""
"As noted above, :c:member:`~Py_buffer.buf` can point to any location within "
"the actual memory block. An exporter can check the validity of a buffer with "
"this function:"
msgstr "如上所述，:c:member:`~Py_buffer.buf` "
"可以指向實際記憶體塊中的任何位置。導出器可以使用此函式檢查緩衝區的有效性："

#: ../../c-api/buffer.rst:398
#, fuzzy
msgid "PIL-style: shape, strides and suboffsets"
msgstr "PIL 風格：形狀、步幅和子偏移量"

#: ../../c-api/buffer.rst:400
#, fuzzy
msgid ""
"In addition to the regular items, PIL-style arrays can contain pointers that "
"must be followed in order to get to the next element in a dimension. For "
"example, the regular three-dimensional C-array ``char v[2][2][3]`` can also "
"be viewed as an array of 2 pointers to 2 two-dimensional arrays: ``char "
"(*v[2])[2][3]``. In suboffsets representation, those two pointers can be "
"embedded at the start of :c:member:`~Py_buffer.buf`, pointing to two ``char "
"x[2][3]`` arrays that can be located anywhere in memory."
msgstr ""
"除了常規項之外，PIL "
"樣式數組還可以包含指標，必須遵循這些指標才能到達維度中的下一個元素。例如，"
"常規的三維 C 數組 ``char v[2][2][3]`` 也可以看作是指向 2 個二維數組的 2 "
"個指標的數組：``char (*v[ 2])[2][3]``。在子偏移表示中，這兩個指標可以嵌入到 "
":c:member:`~Py_buffer.buf` 的開頭，指向兩個可以位於記憶體中任何位置的 ``char "
"x[2][3]`` 數組。"

#: ../../c-api/buffer.rst:409
#, fuzzy
msgid ""
"Here is a function that returns a pointer to the element in an N-D array "
"pointed to by an N-dimensional index when there are both non-``NULL`` "
"strides and suboffsets::"
msgstr "這是一個函式，當存在非 ``NULL`` 步長和子偏移時，該函式回傳指向 N 維索引指向的 N "
"維數組中元素的指標："

#: ../../c-api/buffer.rst:428
#, fuzzy
msgid "Buffer-related functions"
msgstr "緩衝區相關函式"

#: ../../c-api/buffer.rst:432
#, fuzzy
msgid ""
"Return ``1`` if *obj* supports the buffer interface otherwise ``0``.  When "
"``1`` is returned, it doesn't guarantee that :c:func:`PyObject_GetBuffer` "
"will succeed.  This function always succeeds."
msgstr ""
"如果 *obj* 支援緩衝區介面，則回傳 ``1``，否則回傳 ``0``。當回傳 ``1`` 時，它不保證 "
":c:func:`PyObject_GetBuffer` 會成功。這個函式總是成功的。"

#: ../../c-api/buffer.rst:439
#, fuzzy
msgid ""
"Send a request to *exporter* to fill in *view* as specified by  *flags*. If "
"the exporter cannot provide a buffer of the exact type, it MUST raise :c:"
"data:`PyExc_BufferError`, set ``view->obj`` to ``NULL`` and return ``-1``."
msgstr ""
"向 *exporter* 發送請求以填寫 *flags* 指定的 *view*。如果導出器不能提供確切型"
"別的緩衝區，它必須引發:c:data:`PyExc_BufferError`，將``view->obj``設定為``NUL"
"L``並回傳``-1``。"

#: ../../c-api/buffer.rst:444
#, fuzzy
msgid ""
"On success, fill in *view*, set ``view->obj`` to a new reference to "
"*exporter* and return 0. In the case of chained buffer providers that "
"redirect requests to a single object, ``view->obj`` MAY refer to this object "
"instead of *exporter* (See :ref:`Buffer Object Structures <buffer-structs>`)."
msgstr ""
"成功時，填寫 *view*，將 ``view->obj`` 設定為對 *exporter* 的新引用並回傳 "
"0。對於將請求重定向到單個物件的鍊式緩衝區提供程式，``view-> obj`` "
"可以引用此物件而不是 *exporter*（參見 :ref:`Buffer Object Structures "
"<buffer-structs>`）。"

#: ../../c-api/buffer.rst:449
#, fuzzy
msgid ""
"Successful calls to :c:func:`PyObject_GetBuffer` must be paired with calls "
"to :c:func:`PyBuffer_Release`, similar to :c:func:`malloc` and :c:func:"
"`free`. Thus, after the consumer is done with the buffer, :c:func:"
"`PyBuffer_Release` must be called exactly once."
msgstr ""
"對 :c:func:`PyObject_GetBuffer` 的成功呼叫必須與對 :c:func:`PyBuffer_Release`"
" 的呼叫配對，類似於 :c:func:`malloc` 和 "
":c:func:`free`。因此，在消費者使用完緩衝區後，:c:func:`PyBuffer_Release` "
"必須恰好呼叫一次。"

#: ../../c-api/buffer.rst:457
#, fuzzy
msgid ""
"Release the buffer *view* and decrement the reference count for ``view-"
">obj``. This function MUST be called when the buffer is no longer being "
"used, otherwise reference leaks may occur."
msgstr "釋放緩衝區 *view* 並減少 ``view->obj`` "
"的引用計數。當不再使用緩衝區時必須呼叫此函式，否則可能會發生引用洩漏。"

#: ../../c-api/buffer.rst:461
#, fuzzy
msgid ""
"It is an error to call this function on a buffer that was not obtained via :"
"c:func:`PyObject_GetBuffer`."
msgstr "在不是通過 :c:func:`PyObject_GetBuffer` 獲得的緩衝區上呼叫此函式是錯誤的。"

#: ../../c-api/buffer.rst:467
#, fuzzy
msgid ""
"Return the implied :c:data:`~Py_buffer.itemsize` from :c:data:`~Py_buffer."
"format`. On error, raise an exception and return -1."
msgstr ""
"從 :c:data:`~Py_buffer.format` 回傳隱含的 :c:data:`~Py_buffer."
"itemsize`。出錯時，引發例外並回傳 -1。"

#: ../../c-api/buffer.rst:475
#, fuzzy
msgid ""
"Return ``1`` if the memory defined by the *view* is C-style (*order* is "
"``'C'``) or Fortran-style (*order* is ``'F'``) :term:`contiguous` or either "
"one (*order* is ``'A'``).  Return ``0`` otherwise.  This function always "
"succeeds."
msgstr ""
"如果 *view* 定義的記憶體是 C 風格（*order* 是 ``'C'``）或 Fortran "
"風格（*order* 是 ``'F'``），則回傳 ``1``： term:`contiguous` "
"或其中之一（*order* 是 ``'A'``）。否則回傳 ``0``。這個函式總是成功的。"

#: ../../c-api/buffer.rst:482
#, fuzzy
msgid ""
"Get the memory area pointed to by the *indices* inside the given *view*. "
"*indices* must point to an array of ``view->ndim`` indices."
msgstr "獲取給定 *view* 中 *indices* 指向的記憶體區域。 *indices* 必須指向 "
"``view->ndim`` 索引數組。"

#: ../../c-api/buffer.rst:488
#, fuzzy
msgid ""
"Copy contiguous *len* bytes from *buf* to *view*. *fort* can be ``'C'`` or "
"``'F'`` (for C-style or Fortran-style ordering). ``0`` is returned on "
"success, ``-1`` on error."
msgstr ""
"將連續的 *len* 個位元組從 *buf* 複製到 *view*。 *fort* 可以是 ``C``或 ``F``（用於 "
"C 風格或 Fortran 風格的排序）。 ``0`` 成功回傳，``-1`` 出錯。"

#: ../../c-api/buffer.rst:495
#, fuzzy
msgid ""
"Copy *len* bytes from *src* to its contiguous representation in *buf*. "
"*order* can be ``'C'`` or ``'F'`` or ``'A'`` (for C-style or Fortran-style "
"ordering or either one). ``0`` is returned on success, ``-1`` on error."
msgstr ""
"將 *len* 位元組從 *src* 複製到它在 *buf* 中的連續表示。 *order* 可以是 "
"``'C'`` 或 ``'F'`` 或 ``'A'`` （用於 C 風格或 Fortran 風格的排序或其中之一）。"
" ``0`` 成功回傳，``-1`` 出錯。"

#: ../../c-api/buffer.rst:499
#, fuzzy
msgid "This function fails if *len* != *src->len*."
msgstr "如果 *len* != *src->len*，此函式失敗。"

#: ../../c-api/buffer.rst:504
#, fuzzy
msgid ""
"Copy data from *src* to *dest* buffer. Can convert between C-style and or "
"Fortran-style buffers."
msgstr "將資料從 *src* 複製到 *dest* 緩衝區。可以在 C 風格和/或 Fortran "
"風格緩衝區之間轉換。"

#: ../../c-api/buffer.rst:507
#, fuzzy
msgid "``0`` is returned on success, ``-1`` on error."
msgstr "``0`` 成功回傳，``-1`` 出錯。"

#: ../../c-api/buffer.rst:511
#, fuzzy
msgid ""
"Fill the *strides* array with byte-strides of a :term:`contiguous` (C-style "
"if *order* is ``'C'`` or Fortran-style if *order* is ``'F'``) array of the "
"given shape with the given number of bytes per element."
msgstr ""
"用 :term:`contiguous` 的位元組步長填充 *strides* 數組（如果 *order* 為 "
"``'C'`` 則為 C 風格，如果 *order* 為 ``'F'`` 則為 Fortran 風格) "
"給定形狀的數組，每個元素具有給定的位元組數。"

#: ../../c-api/buffer.rst:518
#, fuzzy
msgid ""
"Handle buffer requests for an exporter that wants to expose *buf* of size "
"*len* with writability set according to *readonly*. *buf* is interpreted as "
"a sequence of unsigned bytes."
msgstr ""
"處理導出器的緩衝區請求，該導出器想要公開大小為 *len* 且可寫性設定為 "
"*readonly* 的 *buf*。 *buf* 被解釋為無符號位元組序列。"

#: ../../c-api/buffer.rst:522
#, fuzzy
msgid ""
"The *flags* argument indicates the request type. This function always fills "
"in *view* as specified by flags, unless *buf* has been designated as read-"
"only and :c:macro:`PyBUF_WRITABLE` is set in *flags*."
msgstr ""
"*flags* 參數指示請求型別。此函式始終按照旗標指定的方式填充 *view*，除非 *buf*"
" 已指定為只讀且 :c:macro:`PyBUF_WRITABLE` 已在 *flags* 中設定。"

#: ../../c-api/buffer.rst:526
#, fuzzy
msgid ""
"On success, set ``view->obj`` to a new reference to *exporter* and return 0. "
"Otherwise, raise :c:data:`PyExc_BufferError`, set ``view->obj`` to ``NULL`` "
"and return ``-1``;"
msgstr ""
"成功時，將 ``view->obj`` 設定為對 *exporter* 的新引用並回傳 "
"0。否則，引發 :c:data:`PyExc_BufferError`，將 ``view->obj`` 設定為 ``NULL` ` "
"並回傳 ``-1``；"

#: ../../c-api/buffer.rst:530
#, fuzzy
msgid ""
"If this function is used as part of a :ref:`getbufferproc <buffer-structs>`, "
"*exporter* MUST be set to the exporting object and *flags* must be passed "
"unmodified. Otherwise, *exporter* MUST be ``NULL``."
msgstr ""
"如果此函式用作 :ref:`getbufferproc <buffer-structs>` 的一部分，*exporter* "
"必須設定為導出物件，*flags* 必須不加修改地傳遞。否則，*exporter* "
"必須為 ``NULL`` 。"
