# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Ching-Lung Chuang, 2015
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-15 20:43+0000\n"
"PO-Revision-Date: 2018-05-23 14:06+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../c-api/import.rst:6
msgid "Importing Modules"
msgstr "匯入模組"

#: ../../c-api/import.rst:16
#, fuzzy
msgid ""
"This is a simplified interface to :c:func:`PyImport_ImportModuleEx` below, "
"leaving the *globals* and *locals* arguments set to ``NULL`` and *level* set "
"to 0.  When the *name* argument contains a dot (when it specifies a "
"submodule of a package), the *fromlist* argument is set to the list "
"``['*']`` so that the return value is the named module rather than the top-"
"level package containing it as would otherwise be the case.  (Unfortunately, "
"this has an additional side effect when *name* in fact specifies a "
"subpackage instead of a submodule: the submodules specified in the package's "
"``__all__`` variable are  loaded.)  Return a new reference to the imported "
"module, or ``NULL`` with an exception set on failure.  A failing import of a "
"module doesn't leave the module in :data:`sys.modules`."
msgstr ""
"這是下面 :c:func:`PyImport_ImportModuleEx` 的簡化介面，將 *globals* 和 "
"*locals* 參數設定為 ``NULL`` 並將 *level* 設定為 0。當 *name* 參數包含一個點"
"時（當它指定包的子模組時），*fromlist* 參數被設定為列表``['*']`` 以便回傳值是"
"命名模組而不是包含它的頂級包不然的話。 （不幸的是，當 *name* 實際上指定了一個"
"子包而不是子模組時，這會產生額外的副作用：加載包的 ``__all__`` 變數中指定的子"
"模組。）回傳對導入模組的新引用，或者 ` `NULL`` 失敗時設定例外。模組導入失敗不"
"會將模組留在 :data:`sys.modules` 中。"

#: ../../c-api/import.rst:28 ../../c-api/import.rst:89
#, fuzzy
msgid "This function always uses absolute imports."
msgstr "此函式始終使用絕對導入。"

#: ../../c-api/import.rst:33
#, fuzzy
msgid "This function is a deprecated alias of :c:func:`PyImport_ImportModule`."
msgstr "此函式是 :c:func:`PyImport_ImportModule` 的已棄用別名。"

#: ../../c-api/import.rst:35
#, fuzzy
msgid ""
"This function used to fail immediately when the import lock was held by "
"another thread.  In Python 3.3 though, the locking scheme switched to per-"
"module locks for most purposes, so this function's special behaviour isn't "
"needed anymore."
msgstr ""
"當另一個執行緒持有導入鎖時，此函式過去會立即失敗。不過在 Python 3.3 中，鎖定"
"方案在大多數情況下都切換為按模組鎖定，因此不再需要此函式的特殊行為。"

#: ../../c-api/import.rst:46
#, fuzzy
msgid ""
"Import a module.  This is best described by referring to the built-in Python "
"function :func:`__import__`."
msgstr "導入一個模組。最好通過參考內建 Python 函式 :func:`__import__` 來描述。"

#: ../../c-api/import.rst:49 ../../c-api/import.rst:65
#, fuzzy
msgid ""
"The return value is a new reference to the imported module or top-level "
"package, or ``NULL`` with an exception set on failure.  Like for :func:"
"`__import__`, the return value when a submodule of a package was requested "
"is normally the top-level package, unless a non-empty *fromlist* was given."
msgstr ""
"回傳值是對導入模組或頂級包的新引用，或者失敗時設定例外的 ``NULL`` 。與 :func:"
"`__import__` 一樣，請求包的子模組時的回傳值通常是頂級包，除非給出非空 "
"*fromlist*。"

#: ../../c-api/import.rst:55
#, fuzzy
msgid ""
"Failing imports remove incomplete module objects, like with :c:func:"
"`PyImport_ImportModule`."
msgstr "導入失敗會刪除不完整的模組物件，例如 :c:func:`PyImport_ImportModule`。"

#: ../../c-api/import.rst:61
#, fuzzy
msgid ""
"Import a module.  This is best described by referring to the built-in Python "
"function :func:`__import__`, as the standard :func:`__import__` function "
"calls this function directly."
msgstr ""
"導入一個模組。這最好通過參考內建 Python 函式 :func:`__import__` 來描述，因為"
"標準 :func:`__import__` 函式直接呼叫此函式。"

#: ../../c-api/import.rst:75
#, fuzzy
msgid ""
"Similar to :c:func:`PyImport_ImportModuleLevelObject`, but the name is a "
"UTF-8 encoded string instead of a Unicode object."
msgstr ""
"類似於 :c:func:`PyImport_ImportModuleLevelObject`，但名稱是 UTF-8 編碼字串而"
"不是 Unicode 物件。"

#: ../../c-api/import.rst:78
msgid "Negative values for *level* are no longer accepted."
msgstr "不再接受 *level* 的負值。"

#: ../../c-api/import.rst:83
#, fuzzy
msgid ""
"This is a higher-level interface that calls the current \"import hook "
"function\" (with an explicit *level* of 0, meaning absolute import).  It "
"invokes the :func:`__import__` function from the ``__builtins__`` of the "
"current globals.  This means that the import is done using whatever import "
"hooks are installed in the current environment."
msgstr ""
"這是呼叫當前“導入鉤子函式”的更高階別的介面（顯式*級別*為 0，表示絕對導入）。"
"它從當前全局變數的 __builtins__ 呼叫 :func:`__import__` 函式。這意味著導入是"
"使用當前環境中安裝的任何導入掛鉤完成的。"

#: ../../c-api/import.rst:94
#, fuzzy
msgid ""
"Reload a module.  Return a new reference to the reloaded module, or ``NULL`` "
"with an exception set on failure (the module still exists in this case)."
msgstr ""
"重新加載一個模組。回傳對重新加載的模組的新引用，或者在失敗時設定例外的 "
"``NULL`` （在這種情況下模組仍然存在）。"

#: ../../c-api/import.rst:100
#, fuzzy
msgid ""
"Return the module object corresponding to a module name.  The *name* "
"argument may be of the form ``package.module``. First check the modules "
"dictionary if there's one there, and if not, create a new one and insert it "
"in the modules dictionary. Return ``NULL`` with an exception set on failure."
msgstr ""
"回傳與模組名稱對應的模組物件。 *name* 參數可以是 ``package.module`` 的形式。"
"首先檢查 modules 字典是否存在，如果沒有，則建立一個新的並將其插入到 modules "
"字典中。回傳 ``NULL`` 並在失敗時設定例外。"

#: ../../c-api/import.rst:107
#, fuzzy
msgid ""
"This function does not load or import the module; if the module wasn't "
"already loaded, you will get an empty module object. Use :c:func:"
"`PyImport_ImportModule` or one of its variants to import a module.  Package "
"structures implied by a dotted name for *name* are not created if not "
"already present."
msgstr ""
"此函式不加載或導入模組；如果模組尚未加載，您將得到一個空的模組物件。使用 :c:"
"func:`PyImport_ImportModule` 或其變體之一來導入模組。如果不存在，則不會建立"
"由 *name* 的帶點名稱暗示的包結構。"

#: ../../c-api/import.rst:117
#, fuzzy
msgid ""
"Similar to :c:func:`PyImport_AddModuleObject`, but the name is a UTF-8 "
"encoded string instead of a Unicode object."
msgstr ""
"類似於 :c:func:`PyImport_AddModuleObject`，但名稱是 UTF-8 編碼字串而不是 "
"Unicode 物件。"

#: ../../c-api/import.rst:125
#, fuzzy
msgid ""
"Given a module name (possibly of the form ``package.module``) and a code "
"object read from a Python bytecode file or obtained from the built-in "
"function :func:`compile`, load the module.  Return a new reference to the "
"module object, or ``NULL`` with an exception set if an error occurred.  "
"*name* is removed from :attr:`sys.modules` in error cases, even if *name* "
"was already in :attr:`sys.modules` on entry to :c:func:"
"`PyImport_ExecCodeModule`.  Leaving incompletely initialized modules in :"
"attr:`sys.modules` is dangerous, as imports of such modules have no way to "
"know that the module object is an unknown (and probably damaged with respect "
"to the module author's intents) state."
msgstr ""
"給定一個模組名稱（可能的形式為``package.module``）和一個從 Python 位元組碼文"
"件讀取或從內建函式 :func:`compile` 獲得的程式碼物件，加載模組。回傳對模組物件"
"的新引用，如果發生錯誤，則回傳帶有例外集的 ``NULL`` 。 *name* 在錯誤情況下"
"從 :attr:`sys.modules` 中刪除，即使 *name* 已經在 :attr:`sys.modules` 進入 :"
"c:func:`PyImport_ExecCodeModule`。在 :attr:`sys.modules` 中留下未完全初始化的"
"模組是危險的，因為導入此類模組無法知道模組物件處於未知狀態（並且可能已損壞模"
"組作者的意圖）狀態。"

#: ../../c-api/import.rst:135
#, fuzzy
msgid ""
"The module's :attr:`__spec__` and :attr:`__loader__` will be set, if not set "
"already, with the appropriate values.  The spec's loader will be set to the "
"module's ``__loader__`` (if set) and to an instance of :class:"
"`SourceFileLoader` otherwise."
msgstr ""
"模組的 :attr:`__spec__` 和 :attr:`__loader__` 將設定為適當的值（如果尚未設"
"定）。規範的加載器將設定為模組的 ``__loader__``（如果已設定），否則設定為 :"
"class:`SourceFileLoader` 的實例。"

#: ../../c-api/import.rst:140
#, fuzzy
msgid ""
"The module's :attr:`__file__` attribute will be set to the code object's :c:"
"member:`co_filename`.  If applicable, :attr:`__cached__` will also be set."
msgstr ""
"模組的 :attr:`__file__` 屬性將設定為程式碼物件的 :c:member:`co_filename`。如"
"果適用，:attr:`__cached__` 也將被設定。"

#: ../../c-api/import.rst:144
#, fuzzy
msgid ""
"This function will reload the module if it was already imported.  See :c:"
"func:`PyImport_ReloadModule` for the intended way to reload a module."
msgstr ""
"如果模組已經導入，此函式將重新加載模組。請參閱:c:func:"
"`PyImport_ReloadModule` 以了解重新加載模組的預期方式。"

#: ../../c-api/import.rst:147
#, fuzzy
msgid ""
"If *name* points to a dotted name of the form ``package.module``, any "
"package structures not already created will still not be created."
msgstr ""
"如果 *name* 指向形式為“package.module”的帶點名稱，任何尚未建立的包結構仍將不"
"會被建立。"

#: ../../c-api/import.rst:150
msgid ""
"See also :c:func:`PyImport_ExecCodeModuleEx` and :c:func:"
"`PyImport_ExecCodeModuleWithPathnames`."
msgstr ""
"另見 :c:func:`PyImport_ExecCodeModuleEx` 和 :c:func:"
"`PyImport_ExecCodeModuleWithPathnames`。"

#: ../../c-api/import.rst:156
#, fuzzy
msgid ""
"Like :c:func:`PyImport_ExecCodeModule`, but the :attr:`__file__` attribute "
"of the module object is set to *pathname* if it is non-``NULL``."
msgstr ""
"類似於 :c:func:`PyImport_ExecCodeModule`，但模組物件的 :attr:`__file__` 屬性"
"設定為 *pathname* 如果它是非 ``NULL``。"

#: ../../c-api/import.rst:159
msgid "See also :c:func:`PyImport_ExecCodeModuleWithPathnames`."
msgstr "也請見 :c:func:`PyImport_ExecCodeModuleWithPathnames`\\ 。"

#: ../../c-api/import.rst:164
#, fuzzy
msgid ""
"Like :c:func:`PyImport_ExecCodeModuleEx`, but the :attr:`__cached__` "
"attribute of the module object is set to *cpathname* if it is non-``NULL``.  "
"Of the three functions, this is the preferred one to use."
msgstr ""
"像:c:func:`PyImport_ExecCodeModuleEx`，但是模組物件的 :attr:`__cached__` 屬性"
"設定為*cpathname*，如果它是非``NULL``。在這三個功能中，這是首選使用的功能。"

#: ../../c-api/import.rst:173
#, fuzzy
msgid ""
"Like :c:func:`PyImport_ExecCodeModuleObject`, but *name*, *pathname* and "
"*cpathname* are UTF-8 encoded strings. Attempts are also made to figure out "
"what the value for *pathname* should be from *cpathname* if the former is "
"set to ``NULL``."
msgstr ""
"類似於 :c:func:`PyImport_ExecCodeModuleObject`，但 *name*、*pathname* 和 "
"*cpathname* 是 UTF-8 編碼的字串。如果前者設定為 ``NULL`` ，還會嘗試從 "
"*cpathname* 中找出 *pathname* 的值。"

#: ../../c-api/import.rst:179
#, fuzzy
msgid ""
"Uses :func:`imp.source_from_cache()` in calculating the source path if only "
"the bytecode path is provided."
msgstr ""
"如果僅提供位元組碼路徑，則使用 :func:`imp.source_from_cache()` 計算源路徑。"

#: ../../c-api/import.rst:186
#, fuzzy
msgid ""
"Return the magic number for Python bytecode files (a.k.a. :file:`.pyc` "
"file). The magic number should be present in the first four bytes of the "
"bytecode file, in little-endian byte order. Returns ``-1`` on error."
msgstr ""
"回傳 Python 位元組碼文件（也稱為 :file:`.pyc` 文件）的幻數。幻數應該以小端位"
"元組順序出現在位元組碼文件的前四個位元組中。出錯時回傳 ``-1``。"

#: ../../c-api/import.rst:190
msgid "Return value of ``-1`` upon failure."
msgstr "當失敗時回傳 ``-1``。"

#: ../../c-api/import.rst:196
#, fuzzy
msgid ""
"Return the magic tag string for :pep:`3147` format Python bytecode file "
"names.  Keep in mind that the value at ``sys.implementation.cache_tag`` is "
"authoritative and should be used instead of this function."
msgstr ""
"回傳 :pep:`3147` 格式 Python 位元組碼文件名的魔術標籤字串。請記住，``sys."
"implementation.cache_tag`` 中的值是權威的，應該代替此函式使用。"

#: ../../c-api/import.rst:204
#, fuzzy
msgid ""
"Return the dictionary used for the module administration (a.k.a. ``sys."
"modules``).  Note that this is a per-interpreter variable."
msgstr ""
"回傳用於模組管理的字典（又名``sys.modules``）。請注意，這是一個直譯器變數。"

#: ../../c-api/import.rst:209
#, fuzzy
msgid ""
"Return the already imported module with the given name.  If the module has "
"not been imported yet then returns ``NULL`` but does not set an error.  "
"Returns ``NULL`` and sets an error if the lookup failed."
msgstr ""
"回傳具有給定名稱的已導入模組。如果模組尚未導入，則回傳 ``NULL`` 但不設定錯"
"誤。如果查找失敗，則回傳 ``NULL`` 並設定錯誤。"

#: ../../c-api/import.rst:217
#, fuzzy
msgid ""
"Return a finder object for a :data:`sys.path`/:attr:`pkg.__path__` item "
"*path*, possibly by fetching it from the :data:`sys.path_importer_cache` "
"dict.  If it wasn't yet cached, traverse :data:`sys.path_hooks` until a hook "
"is found that can handle the path item.  Return ``None`` if no hook could; "
"this tells our caller that the :term:`path based finder` could not find a "
"finder for this path item. Cache the result in :data:`sys."
"path_importer_cache`. Return a new reference to the finder object."
msgstr ""
"為 :data:`sys.path`/:attr:`pkg.__path__` item *path* 回傳一個 finder 物件，可"
"能是通過從 :data:`sys.path_importer_cache` 字典中獲取它。如果尚未快取，遍歷 :"
"data:`sys.path_hooks` 直到找到可以處理路徑項的鉤子。如果沒有鉤子可以回傳"
"``None``；這告訴我們的呼叫者 :term:`path based finder` 找不到該路徑項的查找"
"器。將結果快取在 sys.path_importer_cache 中。回傳對查找器物件的新引用。"

#: ../../c-api/import.rst:228
#, fuzzy
msgid ""
"Load a frozen module named *name*.  Return ``1`` for success, ``0`` if the "
"module is not found, and ``-1`` with an exception set if the initialization "
"failed.  To access the imported module on a successful load, use :c:func:"
"`PyImport_ImportModule`.  (Note the misnomer --- this function would reload "
"the module if it was already imported.)"
msgstr ""
"加載一個名為 *name* 的凍結模組。成功回傳 ``1``，如果未找到模組則回傳 ``0``，"
"如果初始化失敗則回傳 ``-1``並設定例外。要在成功加載時訪問導入的模組，請使用:"
"c:func:`PyImport_ImportModule`。 （注意用詞不當——如果模組已經導入，此函式將重"
"新加載模組。）"

#: ../../c-api/import.rst:236
#, fuzzy
msgid "The ``__file__`` attribute is no longer set on the module."
msgstr "``__file__`` 屬性不再在模組上設定。"

#: ../../c-api/import.rst:242
#, fuzzy
msgid ""
"Similar to :c:func:`PyImport_ImportFrozenModuleObject`, but the name is a "
"UTF-8 encoded string instead of a Unicode object."
msgstr ""
"類似於 :c:func:`PyImport_ImportFrozenModuleObject`，但名稱是 UTF-8 編碼字串而"
"不是 Unicode 物件。"

#: ../../c-api/import.rst:250
#, fuzzy
msgid ""
"This is the structure type definition for frozen module descriptors, as "
"generated by the :program:`freeze` utility (see :file:`Tools/freeze/` in the "
"Python source distribution).  Its definition, found in :file:`Include/import."
"h`, is::"
msgstr ""
"這是凍結模組描述器的結構型別定義，由 :program:`freeze` 實用程式生成（請參閱 "
"Python 源程式碼分發中的 :file:`Tools/freeze/`）。它的定義位於 :file:`Include/"
"import.h` 中，是："

#: ../../c-api/import.rst:262
#, fuzzy
msgid ""
"The new ``is_package`` field indicates whether the module is a package or "
"not. This replaces setting the ``size`` field to a negative value."
msgstr ""
"新的 ``is_package`` 欄位指示模組是否為包。這取代了將 ``size`` 欄位設定為負"
"值。"

#: ../../c-api/import.rst:268
#, fuzzy
msgid ""
"This pointer is initialized to point to an array of :c:struct:`_frozen` "
"records, terminated by one whose members are all ``NULL`` or zero.  When a "
"frozen module is imported, it is searched in this table.  Third-party code "
"could play tricks with this to provide a dynamically created collection of "
"frozen modules."
msgstr ""
"該指標被初始化為指向 :c:struct:`_frozen` 記錄的數組，以其成員全部為 ``NULL`` "
"或零的記錄終止。導入凍結模組時，會在該表中進行搜索。第三方程式碼可以利用它來"
"提供動態建立的凍結模組集合。"

#: ../../c-api/import.rst:276
#, fuzzy
msgid ""
"Add a single module to the existing table of built-in modules.  This is a "
"convenience wrapper around :c:func:`PyImport_ExtendInittab`, returning "
"``-1`` if the table could not be extended.  The new module can be imported "
"by the name *name*, and uses the function *initfunc* as the initialization "
"function called on the first attempted import.  This should be called "
"before :c:func:`Py_Initialize`."
msgstr ""
"將單個模組新增到現有的內建模組表中。這是 :c:func:`PyImport_ExtendInittab` 的"
"便利包裝器，如果無法擴充表則回傳 ``-1``。新模組可以通過名稱 *name* 導入，並使"
"用函式 *initfunc* 作為在第一次嘗試導入時呼叫的初始化函式。這應該在 :c:func:"
"`Py_Initialize` 之前呼叫。"

#: ../../c-api/import.rst:286
#, fuzzy
msgid ""
"Structure describing a single entry in the list of built-in modules.  Each "
"of these structures gives the name and initialization function for a module "
"built into the interpreter.  The name is an ASCII encoded string.  Programs "
"which embed Python may use an array of these structures in conjunction with :"
"c:func:`PyImport_ExtendInittab` to provide additional built-in modules. The "
"structure is defined in :file:`Include/import.h` as::"
msgstr ""
"描述內建模組列表中單個條目的結構。這些結構中的每一個都為直譯器內建的模組提供"
"了名稱和初始化函式。名稱是 ASCII 編碼的字串。嵌入 Python 的程式可以將這些結構"
"的數組與:c:func:`PyImport_ExtendInittab` 結合使用，以提供額外的內建模組。該結"
"構在 :file:`Include/import.h` 中定義為："

#: ../../c-api/import.rst:301
#, fuzzy
msgid ""
"Add a collection of modules to the table of built-in modules.  The *newtab* "
"array must end with a sentinel entry which contains ``NULL`` for the :attr:"
"`name` field; failure to provide the sentinel value can result in a memory "
"fault. Returns ``0`` on success or ``-1`` if insufficient memory could be "
"allocated to extend the internal table.  In the event of failure, no modules "
"are added to the internal table.  This must be called before :c:func:"
"`Py_Initialize`."
msgstr ""
"將模組集合新增到內建模組表中。 *newtab* 數組必須以一個哨兵條目結尾，該條目包"
"含 :attr:`name` 欄位的 ``NULL``；未能提供標記值可能會導致記憶體錯誤。成功時回"
"傳 ``0``，如果分配的記憶體不足以擴充內部表，則回傳 ``-1``。如果發生故障，則不"
"會將任何模組新增到內部表中。這必須在 :c:func:`Py_Initialize` 之前呼叫。"

#: ../../c-api/import.rst:308
#, fuzzy
msgid ""
"If Python is initialized multiple times, :c:func:`PyImport_AppendInittab` "
"or :c:func:`PyImport_ExtendInittab` must be called before each Python "
"initialization."
msgstr ""
"如果 Python 被多次初始化，則必須在每次 Python 初始化之前呼叫 :c:func:"
"`PyImport_AppendInittab` 或 :c:func:`PyImport_ExtendInittab`。"
