# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-09-13 00:11+0000\n"
"PO-Revision-Date: 2015-12-09 17:51+0000\n"
"Last-Translator: Liang-Bo Wang <me@liang2.tw>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../c-api/memoryview.rst:9
msgid "MemoryView objects"
msgstr "MemoryView 物件"

#: ../../c-api/memoryview.rst:11
#, fuzzy
msgid ""
"A :class:`memoryview` object exposes the C level :ref:`buffer interface "
"<bufferobjects>` as a Python object which can then be passed around like any "
"other object."
msgstr ""
":class:`memoryview` 物件將 C 級 :ref:`buffer interface <bufferobjects>` 公開"
"為 Python 物件，然後可以像任何其他對像一樣傳遞。"

#: ../../c-api/memoryview.rst:18
#, fuzzy
msgid ""
"Create a memoryview object from an object that provides the buffer "
"interface. If *obj* supports writable buffer exports, the memoryview object "
"will be read/write, otherwise it may be either read-only or read/write at "
"the discretion of the exporter."
msgstr ""
"從提供緩衝區介面的物件建立記憶體視圖物件。如果 *obj* 支援可寫緩衝區導出，則 "
"memoryview 物件將是可讀/可寫的，否則它可能是只讀的或可讀/寫的，由導出器自行決"
"定。"

#: ../../c-api/memoryview.rst:25
#, fuzzy
msgid ""
"Create a memoryview object using *mem* as the underlying buffer. *flags* can "
"be one of :c:macro:`PyBUF_READ` or :c:macro:`PyBUF_WRITE`."
msgstr ""
"使用 *mem* 作為底層緩衝區建立一個 memoryview 物件。 *flags* 可以是 :c:macro:"
"`PyBUF_READ` 或 :c:macro:`PyBUF_WRITE` 之一。"

#: ../../c-api/memoryview.rst:32
#, fuzzy
msgid ""
"Create a memoryview object wrapping the given buffer structure *view*. For "
"simple byte buffers, :c:func:`PyMemoryView_FromMemory` is the preferred "
"function."
msgstr ""
"建立一個包裝給定緩衝區結構 *view* 的 memoryview 物件。對於簡單的位元組緩衝"
"區，:c:func:`PyMemoryView_FromMemory` 是首選函式。"

#: ../../c-api/memoryview.rst:38
#, fuzzy
msgid ""
"Create a memoryview object to a :term:`contiguous` chunk of memory (in "
"either 'C' or 'F'ortran *order*) from an object that defines the buffer "
"interface. If memory is contiguous, the memoryview object points to the "
"original memory. Otherwise, a copy is made and the memoryview points to a "
"new bytes object."
msgstr ""
"從定義緩衝區介面的物件建立一個 memoryview 對像到 :term:`contiguous` 記憶體塊"
"（在 ``C``或 ``F``ortran *order* 中）。如果記憶體是連續的，則記憶體視圖物件指"
"向原始記憶體。否則，將建立一個副本並且記憶體視圖指向一個新的位元組物件。"

#: ../../c-api/memoryview.rst:47
#, fuzzy
msgid ""
"Return true if the object *obj* is a memoryview object.  It is not currently "
"allowed to create subclasses of :class:`memoryview`.  This function always "
"succeeds."
msgstr ""
"如果物件 *obj* 是一個 memoryview 物件，則回傳 true。目前不允許建立 "
"memoryview 的子類別。這個函式總是成功的。"

#: ../../c-api/memoryview.rst:54
#, fuzzy
msgid ""
"Return a pointer to the memoryview's private copy of the exporter's buffer. "
"*mview* **must** be a memoryview instance; this macro doesn't check its "
"type, you must do it yourself or you will risk crashes."
msgstr ""
"回傳指嚮導出器緩衝區的記憶體視圖私有副本的指標。 *mview* **必須**是一個 "
"memoryview 實例；這個巨集不檢查它的型別，你必須自己做，否則你會有崩潰的風險。"

#: ../../c-api/memoryview.rst:60
#, fuzzy
msgid ""
"Return either a pointer to the exporting object that the memoryview is based "
"on or ``NULL`` if the memoryview has been created by one of the functions :c:"
"func:`PyMemoryView_FromMemory` or :c:func:`PyMemoryView_FromBuffer`. *mview* "
"**must** be a memoryview instance."
msgstr ""
"如果記憶體視圖是由以下函式之一建立的，則回傳指向記憶體視圖所基於的導出物件的"
"指標或 ``NULL`` 。 *mview* **必須** 是一個 memoryview 實例。"
