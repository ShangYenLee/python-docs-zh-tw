# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-05 00:16+0000\n"
"PO-Revision-Date: 2023-05-02 17:22+0800\n"
"Last-Translator: Matt Wang <mattwang44@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../c-api/typeobj.rst:6
msgid "Type Objects"
msgstr "型別物件"

#: ../../c-api/typeobj.rst:8
#, fuzzy
msgid ""
"Perhaps one of the most important structures of the Python object system is "
"the structure that defines a new type: the :c:type:`PyTypeObject` "
"structure.  Type objects can be handled using any of the ``PyObject_*`` or "
"``PyType_*`` functions, but do not offer much that's interesting to most "
"Python applications. These objects are fundamental to how objects behave, so "
"they are very important to the interpreter itself and to any extension "
"module that implements new types."
msgstr ""
"也許 Python 物件系統最重要的結構之一是定義新型別的結構：:c:type:"
"`PyTypeObject` 結構。型別物件可以使用任何``PyObject_*`` 或``PyType_*`` 函式來"
"處理，但不會提供大多數 Python 應用程式感興趣的東西。這些對像是物件行為方式的"
"基礎，因此它們對直譯器本身和任何實作新型別的擴充模組都非常重要。"

#: ../../c-api/typeobj.rst:16
#, fuzzy
msgid ""
"Type objects are fairly large compared to most of the standard types. The "
"reason for the size is that each type object stores a large number of "
"values, mostly C function pointers, each of which implements a small part of "
"the type's functionality.  The fields of the type object are examined in "
"detail in this section.  The fields will be described in the order in which "
"they occur in the structure."
msgstr ""
"與大多數標準型別相比，型別物件相當大。大小的原因是每個型別對像都儲存了大量的"
"值，主要是 C 函式指標，每個值都實作了該型別的一小部分功能。本節將詳細檢查型別"
"物件的欄位。這些欄位將按照它們在結構中出現的順序進行描述。"

#: ../../c-api/typeobj.rst:23
#, fuzzy
msgid ""
"In addition to the following quick reference, the :ref:`typedef-examples` "
"section provides at-a-glance insight into the meaning and use of :c:type:"
"`PyTypeObject`."
msgstr ""
"除了以下快速參考之外，:ref:`typedef-examples` 部分還提供了對 :c:type:"
"`PyTypeObject` 的含義和用法的概覽。"

#: ../../c-api/typeobj.rst:29
#, fuzzy
msgid "Quick Reference"
msgstr "快速參考"

#: ../../c-api/typeobj.rst:34
#, fuzzy
msgid "\"tp slots\""
msgstr "“TP插槽”"

#: ../../c-api/typeobj.rst:40
#, fuzzy
msgid "PyTypeObject Slot [#slots]_"
msgstr "PyTypeObject 插槽 [#slots]_"

#: ../../c-api/typeobj.rst:40 ../../c-api/typeobj.rst:199
#, fuzzy
msgid ":ref:`Type <slot-typedefs-table>`"
msgstr ":ref:`Type <slot-typedefs-table>`"

#: ../../c-api/typeobj.rst:40
#, fuzzy
msgid "special methods/attrs"
msgstr "特殊方法/屬性"

#: ../../c-api/typeobj.rst:40
#, fuzzy
msgid "Info [#cols]_"
msgstr "資訊[#cols]_"

#: ../../c-api/typeobj.rst:42
msgid "O"
msgstr "O"

#: ../../c-api/typeobj.rst:42
msgid "T"
msgstr "T"

#: ../../c-api/typeobj.rst:42
msgid "D"
msgstr "D"

#: ../../c-api/typeobj.rst:42
msgid "I"
msgstr "I"

#: ../../c-api/typeobj.rst:44
msgid "<R> :c:member:`~PyTypeObject.tp_name`"
msgstr "<R> :c:member:`~PyTypeObject.tp_name`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:44
#: ../../c-api/typeobj.rst:86
msgid "const char *"
msgstr "const char *"

#: ../../c-api/typeobj.rst:44
msgid "__name__"
msgstr "__name__"

#: ../../c-api/typeobj.rst:44 ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:48 ../../c-api/typeobj.rst:50
#: ../../c-api/typeobj.rst:52 ../../c-api/typeobj.rst:62
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:72
#: ../../c-api/typeobj.rst:74 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:84
#: ../../c-api/typeobj.rst:86 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
#: ../../c-api/typeobj.rst:99 ../../c-api/typeobj.rst:101
#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:105
#: ../../c-api/typeobj.rst:107 ../../c-api/typeobj.rst:109
#: ../../c-api/typeobj.rst:111 ../../c-api/typeobj.rst:115
#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:124
#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:128
#: ../../c-api/typeobj.rst:130 ../../c-api/typeobj.rst:146
msgid "X"
msgstr "X"

#: ../../c-api/typeobj.rst:46
msgid ":c:member:`~PyTypeObject.tp_basicsize`"
msgstr ":c:member:`~PyTypeObject.tp_basicsize`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:48 ../../c-api/typeobj.rst:52
#: ../../c-api/typeobj.rst:99 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:414
msgid ":c:type:`Py_ssize_t`"
msgstr ":c:type:`Py_ssize_t`"

#: ../../c-api/typeobj.rst:48
msgid ":c:member:`~PyTypeObject.tp_itemsize`"
msgstr ":c:member:`~PyTypeObject.tp_itemsize`"

#: ../../c-api/typeobj.rst:50
msgid ":c:member:`~PyTypeObject.tp_dealloc`"
msgstr ":c:member:`~PyTypeObject.tp_dealloc`"

#: ../../c-api/typeobj.rst:50 ../../c-api/typeobj.rst:142
#: ../../c-api/typeobj.rst:146 ../../c-api/typeobj.rst:344
msgid ":c:type:`destructor`"
msgstr ":c:type:`destructor`"

#: ../../c-api/typeobj.rst:52
msgid ":c:member:`~PyTypeObject.tp_vectorcall_offset`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall_offset`"

#: ../../c-api/typeobj.rst:54
msgid "(:c:member:`~PyTypeObject.tp_getattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_getattr`)"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:368
msgid ":c:type:`getattrfunc`"
msgstr ":c:type:`getattrfunc`"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:76
msgid "__getattribute__, __getattr__"
msgstr "__getattribute__, __getattr__"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:57
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
msgid "G"
msgstr "G"

#: ../../c-api/typeobj.rst:57
msgid "(:c:member:`~PyTypeObject.tp_setattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_setattr`)"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:373
msgid ":c:type:`setattrfunc`"
msgstr ":c:type:`setattrfunc`"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:79
msgid "__setattr__, __delattr__"
msgstr "__setattr__, __delattr__"

#: ../../c-api/typeobj.rst:60
msgid ":c:member:`~PyTypeObject.tp_as_async`"
msgstr ":c:member:`~PyTypeObject.tp_as_async`"

#: ../../c-api/typeobj.rst:60
msgid ":c:type:`PyAsyncMethods` *"
msgstr ":c:type:`PyAsyncMethods` *"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
msgid ":ref:`sub-slots`"
msgstr ":ref:`sub-slots`"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
#: ../../c-api/typeobj.rst:82
msgid "%"
msgstr "%"

#: ../../c-api/typeobj.rst:62
msgid ":c:member:`~PyTypeObject.tp_repr`"
msgstr ":c:member:`~PyTypeObject.tp_repr`"

#: ../../c-api/typeobj.rst:62 ../../c-api/typeobj.rst:74
#: ../../c-api/typeobj.rst:366
msgid ":c:type:`reprfunc`"
msgstr ":c:type:`reprfunc`"

#: ../../c-api/typeobj.rst:62
msgid "__repr__"
msgstr "__repr__"

#: ../../c-api/typeobj.rst:64
msgid ":c:member:`~PyTypeObject.tp_as_number`"
msgstr ":c:member:`~PyTypeObject.tp_as_number`"

#: ../../c-api/typeobj.rst:64
msgid ":c:type:`PyNumberMethods` *"
msgstr ":c:type:`PyNumberMethods` *"

#: ../../c-api/typeobj.rst:66
msgid ":c:member:`~PyTypeObject.tp_as_sequence`"
msgstr ":c:member:`~PyTypeObject.tp_as_sequence`"

#: ../../c-api/typeobj.rst:66
msgid ":c:type:`PySequenceMethods` *"
msgstr ":c:type:`PySequenceMethods` *"

#: ../../c-api/typeobj.rst:68
msgid ":c:member:`~PyTypeObject.tp_as_mapping`"
msgstr ":c:member:`~PyTypeObject.tp_as_mapping`"

#: ../../c-api/typeobj.rst:68
msgid ":c:type:`PyMappingMethods` *"
msgstr ":c:type:`PyMappingMethods` *"

#: ../../c-api/typeobj.rst:70
msgid ":c:member:`~PyTypeObject.tp_hash`"
msgstr ":c:member:`~PyTypeObject.tp_hash`"

#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:402
msgid ":c:type:`hashfunc`"
msgstr ":c:type:`hashfunc`"

#: ../../c-api/typeobj.rst:70
msgid "__hash__"
msgstr "__hash__"

#: ../../c-api/typeobj.rst:72
msgid ":c:member:`~PyTypeObject.tp_call`"
msgstr ":c:member:`~PyTypeObject.tp_call`"

#: ../../c-api/typeobj.rst:72 ../../c-api/typeobj.rst:235
#: ../../c-api/typeobj.rst:238 ../../c-api/typeobj.rst:438
msgid ":c:type:`ternaryfunc`"
msgstr ":c:type:`ternaryfunc`"

#: ../../c-api/typeobj.rst:72
msgid "__call__"
msgstr "__call__"

#: ../../c-api/typeobj.rst:74
msgid ":c:member:`~PyTypeObject.tp_str`"
msgstr ":c:member:`~PyTypeObject.tp_str`"

#: ../../c-api/typeobj.rst:74
msgid "__str__"
msgstr "__str__"

#: ../../c-api/typeobj.rst:76
msgid ":c:member:`~PyTypeObject.tp_getattro`"
msgstr ":c:member:`~PyTypeObject.tp_getattro`"

#: ../../c-api/typeobj.rst:76 ../../c-api/typeobj.rst:379
msgid ":c:type:`getattrofunc`"
msgstr ":c:type:`getattrofunc`"

#: ../../c-api/typeobj.rst:79
msgid ":c:member:`~PyTypeObject.tp_setattro`"
msgstr ":c:member:`~PyTypeObject.tp_setattro`"

#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:384
msgid ":c:type:`setattrofunc`"
msgstr ":c:type:`setattrofunc`"

#: ../../c-api/typeobj.rst:82
msgid ":c:member:`~PyTypeObject.tp_as_buffer`"
msgstr ":c:member:`~PyTypeObject.tp_as_buffer`"

#: ../../c-api/typeobj.rst:82
msgid ":c:type:`PyBufferProcs` *"
msgstr ":c:type:`PyBufferProcs` *"

#: ../../c-api/typeobj.rst:84
msgid ":c:member:`~PyTypeObject.tp_flags`"
msgstr ":c:member:`~PyTypeObject.tp_flags`"

#: ../../c-api/typeobj.rst:84
msgid "unsigned long"
msgstr "unsigned long"

#: ../../c-api/typeobj.rst:84 ../../c-api/typeobj.rst:99
#: ../../c-api/typeobj.rst:113 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:126
#: ../../c-api/typeobj.rst:128
msgid "?"
msgstr "?"

#: ../../c-api/typeobj.rst:86
msgid ":c:member:`~PyTypeObject.tp_doc`"
msgstr ":c:member:`~PyTypeObject.tp_doc`"

#: ../../c-api/typeobj.rst:86
msgid "__doc__"
msgstr "__doc__"

#: ../../c-api/typeobj.rst:88
msgid ":c:member:`~PyTypeObject.tp_traverse`"
msgstr ":c:member:`~PyTypeObject.tp_traverse`"

#: ../../c-api/typeobj.rst:88 ../../c-api/typeobj.rst:348
msgid ":c:type:`traverseproc`"
msgstr ":c:type:`traverseproc`"

#: ../../c-api/typeobj.rst:90
msgid ":c:member:`~PyTypeObject.tp_clear`"
msgstr ":c:member:`~PyTypeObject.tp_clear`"

#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:130
#: ../../c-api/typeobj.rst:246 ../../c-api/typeobj.rst:427
msgid ":c:type:`inquiry`"
msgstr ":c:type:`inquiry`"

#: ../../c-api/typeobj.rst:92
msgid ":c:member:`~PyTypeObject.tp_richcompare`"
msgstr ":c:member:`~PyTypeObject.tp_richcompare`"

#: ../../c-api/typeobj.rst:92 ../../c-api/typeobj.rst:404
msgid ":c:type:`richcmpfunc`"
msgstr ":c:type:`richcmpfunc`"

#: ../../c-api/typeobj.rst:92
msgid "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"
msgstr "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"

#: ../../c-api/typeobj.rst:99
msgid ":c:member:`~PyTypeObject.tp_weaklistoffset`"
msgstr ":c:member:`~PyTypeObject.tp_weaklistoffset`"

#: ../../c-api/typeobj.rst:101
msgid ":c:member:`~PyTypeObject.tp_iter`"
msgstr ":c:member:`~PyTypeObject.tp_iter`"

#: ../../c-api/typeobj.rst:101 ../../c-api/typeobj.rst:410
msgid ":c:type:`getiterfunc`"
msgstr ":c:type:`getiterfunc`"

#: ../../c-api/typeobj.rst:101
msgid "__iter__"
msgstr "__iter__"

#: ../../c-api/typeobj.rst:103
msgid ":c:member:`~PyTypeObject.tp_iternext`"
msgstr ":c:member:`~PyTypeObject.tp_iternext`"

#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:412
msgid ":c:type:`iternextfunc`"
msgstr ":c:type:`iternextfunc`"

#: ../../c-api/typeobj.rst:103
msgid "__next__"
msgstr "__next__"

#: ../../c-api/typeobj.rst:105
msgid ":c:member:`~PyTypeObject.tp_methods`"
msgstr ":c:member:`~PyTypeObject.tp_methods`"

#: ../../c-api/typeobj.rst:105
msgid ":c:type:`PyMethodDef` []"
msgstr ":c:type:`PyMethodDef` []"

#: ../../c-api/typeobj.rst:107
msgid ":c:member:`~PyTypeObject.tp_members`"
msgstr ":c:member:`~PyTypeObject.tp_members`"

#: ../../c-api/typeobj.rst:107
msgid ":c:type:`PyMemberDef` []"
msgstr ":c:type:`PyMemberDef` []"

#: ../../c-api/typeobj.rst:109
msgid ":c:member:`~PyTypeObject.tp_getset`"
msgstr ":c:member:`~PyTypeObject.tp_getset`"

#: ../../c-api/typeobj.rst:109
msgid ":c:type:`PyGetSetDef` []"
msgstr ":c:type:`PyGetSetDef` []"

#: ../../c-api/typeobj.rst:111
msgid ":c:member:`~PyTypeObject.tp_base`"
msgstr ":c:member:`~PyTypeObject.tp_base`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:111
msgid ":c:type:`PyTypeObject` *"
msgstr ":c:type:`PyTypeObject` *"

#: ../../c-api/typeobj.rst:111
msgid "__base__"
msgstr "__base__"

#: ../../c-api/typeobj.rst:113
msgid ":c:member:`~PyTypeObject.tp_dict`"
msgstr ":c:member:`~PyTypeObject.tp_dict`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:113
#: ../../c-api/typeobj.rst:132 ../../c-api/typeobj.rst:134
#: ../../c-api/typeobj.rst:136 ../../c-api/typeobj.rst:138
#: ../../c-api/typeobj.rst:140 ../../c-api/typeobj.rst:339
#: ../../c-api/typeobj.rst:354 ../../c-api/typeobj.rst:366
#: ../../c-api/typeobj.rst:368 ../../c-api/typeobj.rst:379
#: ../../c-api/typeobj.rst:390 ../../c-api/typeobj.rst:402
#: ../../c-api/typeobj.rst:404 ../../c-api/typeobj.rst:410
#: ../../c-api/typeobj.rst:412 ../../c-api/typeobj.rst:414
#: ../../c-api/typeobj.rst:429 ../../c-api/typeobj.rst:433
#: ../../c-api/typeobj.rst:438 ../../c-api/typeobj.rst:444
msgid ":c:type:`PyObject` *"
msgstr ":c:type:`PyObject` *"

#: ../../c-api/typeobj.rst:113
msgid "__dict__"
msgstr "__dict__"

#: ../../c-api/typeobj.rst:115
msgid ":c:member:`~PyTypeObject.tp_descr_get`"
msgstr ":c:member:`~PyTypeObject.tp_descr_get`"

#: ../../c-api/typeobj.rst:115 ../../c-api/typeobj.rst:390
msgid ":c:type:`descrgetfunc`"
msgstr ":c:type:`descrgetfunc`"

#: ../../c-api/typeobj.rst:115
msgid "__get__"
msgstr "__get__"

#: ../../c-api/typeobj.rst:117
msgid ":c:member:`~PyTypeObject.tp_descr_set`"
msgstr ":c:member:`~PyTypeObject.tp_descr_set`"

#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:396
msgid ":c:type:`descrsetfunc`"
msgstr ":c:type:`descrsetfunc`"

#: ../../c-api/typeobj.rst:117
msgid "__set__, __delete__"
msgstr "__set__, __delete__"

#: ../../c-api/typeobj.rst:120
msgid ":c:member:`~PyTypeObject.tp_dictoffset`"
msgstr ":c:member:`~PyTypeObject.tp_dictoffset`"

#: ../../c-api/typeobj.rst:122
msgid ":c:member:`~PyTypeObject.tp_init`"
msgstr ":c:member:`~PyTypeObject.tp_init`"

#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:360
msgid ":c:type:`initproc`"
msgstr ":c:type:`initproc`"

#: ../../c-api/typeobj.rst:122
msgid "__init__"
msgstr "__init__"

#: ../../c-api/typeobj.rst:124
msgid ":c:member:`~PyTypeObject.tp_alloc`"
msgstr ":c:member:`~PyTypeObject.tp_alloc`"

#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:339
msgid ":c:type:`allocfunc`"
msgstr ":c:type:`allocfunc`"

#: ../../c-api/typeobj.rst:126
msgid ":c:member:`~PyTypeObject.tp_new`"
msgstr ":c:member:`~PyTypeObject.tp_new`"

#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:354
msgid ":c:type:`newfunc`"
msgstr ":c:type:`newfunc`"

#: ../../c-api/typeobj.rst:126
msgid "__new__"
msgstr "__new__"

#: ../../c-api/typeobj.rst:128
msgid ":c:member:`~PyTypeObject.tp_free`"
msgstr ":c:member:`~PyTypeObject.tp_free`"

#: ../../c-api/typeobj.rst:128 ../../c-api/typeobj.rst:346
msgid ":c:type:`freefunc`"
msgstr ":c:type:`freefunc`"

#: ../../c-api/typeobj.rst:130
msgid ":c:member:`~PyTypeObject.tp_is_gc`"
msgstr ":c:member:`~PyTypeObject.tp_is_gc`"

#: ../../c-api/typeobj.rst:132
msgid "<:c:member:`~PyTypeObject.tp_bases`>"
msgstr "<:c:member:`~PyTypeObject.tp_bases`>"

#: ../../c-api/typeobj.rst:132
msgid "__bases__"
msgstr "__bases__"

#: ../../c-api/typeobj.rst:132 ../../c-api/typeobj.rst:134
msgid "~"
msgstr "~"

#: ../../c-api/typeobj.rst:134
msgid "<:c:member:`~PyTypeObject.tp_mro`>"
msgstr "<:c:member:`~PyTypeObject.tp_mro`>"

#: ../../c-api/typeobj.rst:134
msgid "__mro__"
msgstr "__mro__"

#: ../../c-api/typeobj.rst:136
msgid "[:c:member:`~PyTypeObject.tp_cache`]"
msgstr "[:c:member:`~PyTypeObject.tp_cache`]"

#: ../../c-api/typeobj.rst:138
msgid "[:c:member:`~PyTypeObject.tp_subclasses`]"
msgstr "[:c:member:`~PyTypeObject.tp_subclasses`]"

#: ../../c-api/typeobj.rst:138
msgid "__subclasses__"
msgstr "__subclasses__"

#: ../../c-api/typeobj.rst:140
msgid "[:c:member:`~PyTypeObject.tp_weaklist`]"
msgstr "[:c:member:`~PyTypeObject.tp_weaklist`]"

#: ../../c-api/typeobj.rst:142
msgid "(:c:member:`~PyTypeObject.tp_del`)"
msgstr "(:c:member:`~PyTypeObject.tp_del`)"

#: ../../c-api/typeobj.rst:144
msgid "[:c:member:`~PyTypeObject.tp_version_tag`]"
msgstr "[:c:member:`~PyTypeObject.tp_version_tag`]"

#: ../../c-api/typeobj.rst:144
msgid "unsigned int"
msgstr "unsigned int"

#: ../../c-api/typeobj.rst:146
msgid ":c:member:`~PyTypeObject.tp_finalize`"
msgstr ":c:member:`~PyTypeObject.tp_finalize`"

#: ../../c-api/typeobj.rst:146
msgid "__del__"
msgstr "__del__"

#: ../../c-api/typeobj.rst:148
msgid ":c:member:`~PyTypeObject.tp_vectorcall`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall`"

#: ../../c-api/typeobj.rst:148
msgid ":c:type:`vectorcallfunc`"
msgstr ":c:type:`vectorcallfunc`"

#: ../../c-api/typeobj.rst:153
#, fuzzy
msgid ""
"**()**: A slot name in parentheses indicates it is (effectively) deprecated."
msgstr "**()**：括號中的插槽名稱表示它已（有效）棄用。"

#: ../../c-api/typeobj.rst:155
#, fuzzy
msgid ""
"**<>**: Names in angle brackets should be initially set to ``NULL`` and "
"treated as read-only."
msgstr "**<>**：尖括號中的名稱最初應設定為 ``NULL`` 並視為只讀。"

#: ../../c-api/typeobj.rst:158
#, fuzzy
msgid "**[]**: Names in square brackets are for internal use only."
msgstr "**[]**：方括號中的名稱僅供內部使用。"

#: ../../c-api/typeobj.rst:160
#, fuzzy
msgid ""
"**<R>** (as a prefix) means the field is required (must be non-``NULL``)."
msgstr "**<R>**（作為前綴）表示該欄位是必需的（必須是非 ``NULL`` ）。"

#: ../../c-api/typeobj.rst:162
#, fuzzy
msgid "Columns:"
msgstr "列："

#: ../../c-api/typeobj.rst:164
#, fuzzy
msgid "**\"O\"**:  set on :c:type:`PyBaseObject_Type`"
msgstr "** ``O``**：在 :c:type:`PyBaseObject_Type` 上設定"

#: ../../c-api/typeobj.rst:166
#, fuzzy
msgid "**\"T\"**:  set on :c:type:`PyType_Type`"
msgstr "** ``T``**：在 :c:type:`PyType_Type` 上設定"

#: ../../c-api/typeobj.rst:168
#, fuzzy
msgid "**\"D\"**:  default (if slot is set to ``NULL``)"
msgstr "** ``D``**：預設值（如果插槽設定為 ``NULL`` ）"

#: ../../c-api/typeobj.rst:178
#, fuzzy
msgid "**\"I\"**:  inheritance"
msgstr "** ``我``**：繼承"

#: ../../c-api/typeobj.rst:187
#, fuzzy
msgid ""
"Note that some slots are effectively inherited through the normal attribute "
"lookup chain."
msgstr "請注意，某些插槽是通過普通屬性查找鏈有效繼承的。"

#: ../../c-api/typeobj.rst:193
#, fuzzy
msgid "sub-slots"
msgstr "子槽"

#: ../../c-api/typeobj.rst:199
#, fuzzy
msgid "Slot"
msgstr "投幣口"

#: ../../c-api/typeobj.rst:199
#, fuzzy
msgid "special methods"
msgstr "特殊方法"

#: ../../c-api/typeobj.rst:202
msgid ":c:member:`~PyAsyncMethods.am_await`"
msgstr ":c:member:`~PyAsyncMethods.am_await`"

#: ../../c-api/typeobj.rst:202 ../../c-api/typeobj.rst:204
#: ../../c-api/typeobj.rst:206 ../../c-api/typeobj.rst:240
#: ../../c-api/typeobj.rst:242 ../../c-api/typeobj.rst:244
#: ../../c-api/typeobj.rst:248 ../../c-api/typeobj.rst:275
#: ../../c-api/typeobj.rst:279 ../../c-api/typeobj.rst:289
#: ../../c-api/typeobj.rst:429
msgid ":c:type:`unaryfunc`"
msgstr ":c:type:`unaryfunc`"

#: ../../c-api/typeobj.rst:202
msgid "__await__"
msgstr "__await__"

#: ../../c-api/typeobj.rst:204
msgid ":c:member:`~PyAsyncMethods.am_aiter`"
msgstr ":c:member:`~PyAsyncMethods.am_aiter`"

#: ../../c-api/typeobj.rst:204
msgid "__aiter__"
msgstr "__aiter__"

#: ../../c-api/typeobj.rst:206
msgid ":c:member:`~PyAsyncMethods.am_anext`"
msgstr ":c:member:`~PyAsyncMethods.am_anext`"

#: ../../c-api/typeobj.rst:206
msgid "__anext__"
msgstr "__anext__"

#: ../../c-api/typeobj.rst:208
msgid ":c:member:`~PyAsyncMethods.am_send`"
msgstr ":c:member:`~PyAsyncMethods.am_send`"

#: ../../c-api/typeobj.rst:208
msgid ":c:type:`sendfunc`"
msgstr ":c:type:`sendfunc`"

#: ../../c-api/typeobj.rst:212
msgid ":c:member:`~PyNumberMethods.nb_add`"
msgstr ":c:member:`~PyNumberMethods.nb_add`"

#: ../../c-api/typeobj.rst:212 ../../c-api/typeobj.rst:215
#: ../../c-api/typeobj.rst:217 ../../c-api/typeobj.rst:220
#: ../../c-api/typeobj.rst:222 ../../c-api/typeobj.rst:225
#: ../../c-api/typeobj.rst:227 ../../c-api/typeobj.rst:230
#: ../../c-api/typeobj.rst:232 ../../c-api/typeobj.rst:250
#: ../../c-api/typeobj.rst:253 ../../c-api/typeobj.rst:255
#: ../../c-api/typeobj.rst:258 ../../c-api/typeobj.rst:260
#: ../../c-api/typeobj.rst:263 ../../c-api/typeobj.rst:265
#: ../../c-api/typeobj.rst:268 ../../c-api/typeobj.rst:270
#: ../../c-api/typeobj.rst:273 ../../c-api/typeobj.rst:281
#: ../../c-api/typeobj.rst:283 ../../c-api/typeobj.rst:285
#: ../../c-api/typeobj.rst:287 ../../c-api/typeobj.rst:291
#: ../../c-api/typeobj.rst:294 ../../c-api/typeobj.rst:300
#: ../../c-api/typeobj.rst:309 ../../c-api/typeobj.rst:320
#: ../../c-api/typeobj.rst:433
msgid ":c:type:`binaryfunc`"
msgstr ":c:type:`binaryfunc`"

#: ../../c-api/typeobj.rst:212
msgid "__add__ __radd__"
msgstr "__add__ __radd__"

#: ../../c-api/typeobj.rst:215
msgid ":c:member:`~PyNumberMethods.nb_inplace_add`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_add`"

#: ../../c-api/typeobj.rst:215 ../../c-api/typeobj.rst:320
msgid "__iadd__"
msgstr "__iadd__"

#: ../../c-api/typeobj.rst:217
msgid ":c:member:`~PyNumberMethods.nb_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_subtract`"

#: ../../c-api/typeobj.rst:217
msgid "__sub__ __rsub__"
msgstr "__sub__ __rsub__"

#: ../../c-api/typeobj.rst:220
msgid ":c:member:`~PyNumberMethods.nb_inplace_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_subtract`"

#: ../../c-api/typeobj.rst:220
msgid "__isub__"
msgstr "__isub__"

#: ../../c-api/typeobj.rst:222
msgid ":c:member:`~PyNumberMethods.nb_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_multiply`"

#: ../../c-api/typeobj.rst:222
msgid "__mul__ __rmul__"
msgstr "__mul__ __rmul__"

#: ../../c-api/typeobj.rst:225
msgid ":c:member:`~PyNumberMethods.nb_inplace_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_multiply`"

#: ../../c-api/typeobj.rst:225 ../../c-api/typeobj.rst:322
msgid "__imul__"
msgstr "__imul__"

#: ../../c-api/typeobj.rst:227
msgid ":c:member:`~PyNumberMethods.nb_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_remainder`"

#: ../../c-api/typeobj.rst:227
msgid "__mod__ __rmod__"
msgstr "__mod__ __rmod__"

#: ../../c-api/typeobj.rst:230
msgid ":c:member:`~PyNumberMethods.nb_inplace_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_remainder`"

#: ../../c-api/typeobj.rst:230
msgid "__imod__"
msgstr "__imod__"

#: ../../c-api/typeobj.rst:232
msgid ":c:member:`~PyNumberMethods.nb_divmod`"
msgstr ":c:member:`~PyNumberMethods.nb_divmod`"

#: ../../c-api/typeobj.rst:232
msgid "__divmod__ __rdivmod__"
msgstr "__divmod__ __rdivmod__"

#: ../../c-api/typeobj.rst:235
msgid ":c:member:`~PyNumberMethods.nb_power`"
msgstr ":c:member:`~PyNumberMethods.nb_power`"

#: ../../c-api/typeobj.rst:235
msgid "__pow__ __rpow__"
msgstr "__pow__ __rpow__"

#: ../../c-api/typeobj.rst:238
msgid ":c:member:`~PyNumberMethods.nb_inplace_power`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_power`"

#: ../../c-api/typeobj.rst:238
msgid "__ipow__"
msgstr "__ipow__"

#: ../../c-api/typeobj.rst:240
msgid ":c:member:`~PyNumberMethods.nb_negative`"
msgstr ":c:member:`~PyNumberMethods.nb_negative`"

#: ../../c-api/typeobj.rst:240
msgid "__neg__"
msgstr "__neg__"

#: ../../c-api/typeobj.rst:242
msgid ":c:member:`~PyNumberMethods.nb_positive`"
msgstr ":c:member:`~PyNumberMethods.nb_positive`"

#: ../../c-api/typeobj.rst:242
msgid "__pos__"
msgstr "__pos__"

#: ../../c-api/typeobj.rst:244
msgid ":c:member:`~PyNumberMethods.nb_absolute`"
msgstr ":c:member:`~PyNumberMethods.nb_absolute`"

#: ../../c-api/typeobj.rst:244
msgid "__abs__"
msgstr "__abs__"

#: ../../c-api/typeobj.rst:246
msgid ":c:member:`~PyNumberMethods.nb_bool`"
msgstr ":c:member:`~PyNumberMethods.nb_bool`"

#: ../../c-api/typeobj.rst:246
msgid "__bool__"
msgstr "__bool__"

#: ../../c-api/typeobj.rst:248
msgid ":c:member:`~PyNumberMethods.nb_invert`"
msgstr ":c:member:`~PyNumberMethods.nb_invert`"

#: ../../c-api/typeobj.rst:248
msgid "__invert__"
msgstr "__invert__"

#: ../../c-api/typeobj.rst:250
msgid ":c:member:`~PyNumberMethods.nb_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_lshift`"

#: ../../c-api/typeobj.rst:250
msgid "__lshift__ __rlshift__"
msgstr "__lshift__ __rlshift__"

#: ../../c-api/typeobj.rst:253
msgid ":c:member:`~PyNumberMethods.nb_inplace_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_lshift`"

#: ../../c-api/typeobj.rst:253
msgid "__ilshift__"
msgstr "__ilshift__"

#: ../../c-api/typeobj.rst:255
msgid ":c:member:`~PyNumberMethods.nb_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_rshift`"

#: ../../c-api/typeobj.rst:255
msgid "__rshift__ __rrshift__"
msgstr "__rshift__ __rrshift__"

#: ../../c-api/typeobj.rst:258
msgid ":c:member:`~PyNumberMethods.nb_inplace_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_rshift`"

#: ../../c-api/typeobj.rst:258
msgid "__irshift__"
msgstr "__irshift__"

#: ../../c-api/typeobj.rst:260
msgid ":c:member:`~PyNumberMethods.nb_and`"
msgstr ":c:member:`~PyNumberMethods.nb_and`"

#: ../../c-api/typeobj.rst:260
msgid "__and__ __rand__"
msgstr "__and__ __rand__"

#: ../../c-api/typeobj.rst:263
msgid ":c:member:`~PyNumberMethods.nb_inplace_and`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_and`"

#: ../../c-api/typeobj.rst:263
msgid "__iand__"
msgstr "__iand__"

#: ../../c-api/typeobj.rst:265
msgid ":c:member:`~PyNumberMethods.nb_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_xor`"

#: ../../c-api/typeobj.rst:265
msgid "__xor__ __rxor__"
msgstr "__xor__ __rxor__"

#: ../../c-api/typeobj.rst:268
msgid ":c:member:`~PyNumberMethods.nb_inplace_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_xor`"

#: ../../c-api/typeobj.rst:268
msgid "__ixor__"
msgstr "__ixor__"

#: ../../c-api/typeobj.rst:270
msgid ":c:member:`~PyNumberMethods.nb_or`"
msgstr ":c:member:`~PyNumberMethods.nb_or`"

#: ../../c-api/typeobj.rst:270
msgid "__or__ __ror__"
msgstr "__or__ __ror__"

#: ../../c-api/typeobj.rst:273
msgid ":c:member:`~PyNumberMethods.nb_inplace_or`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_or`"

#: ../../c-api/typeobj.rst:273
msgid "__ior__"
msgstr "__ior__"

#: ../../c-api/typeobj.rst:275
msgid ":c:member:`~PyNumberMethods.nb_int`"
msgstr ":c:member:`~PyNumberMethods.nb_int`"

#: ../../c-api/typeobj.rst:275
msgid "__int__"
msgstr "__int__"

#: ../../c-api/typeobj.rst:277
msgid ":c:member:`~PyNumberMethods.nb_reserved`"
msgstr ":c:member:`~PyNumberMethods.nb_reserved`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:277
#: ../../c-api/typeobj.rst:344 ../../c-api/typeobj.rst:346
#: ../../c-api/typeobj.rst:427
msgid "void *"
msgstr "void *"

#: ../../c-api/typeobj.rst:279
msgid ":c:member:`~PyNumberMethods.nb_float`"
msgstr ":c:member:`~PyNumberMethods.nb_float`"

#: ../../c-api/typeobj.rst:279
msgid "__float__"
msgstr "__float__"

#: ../../c-api/typeobj.rst:281
msgid ":c:member:`~PyNumberMethods.nb_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_floor_divide`"

#: ../../c-api/typeobj.rst:281
msgid "__floordiv__"
msgstr "__floordiv__"

#: ../../c-api/typeobj.rst:283
msgid ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"

#: ../../c-api/typeobj.rst:283
msgid "__ifloordiv__"
msgstr "__ifloordiv__"

#: ../../c-api/typeobj.rst:285
msgid ":c:member:`~PyNumberMethods.nb_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_true_divide`"

#: ../../c-api/typeobj.rst:285
msgid "__truediv__"
msgstr "__truediv__"

#: ../../c-api/typeobj.rst:287
msgid ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"

#: ../../c-api/typeobj.rst:287
msgid "__itruediv__"
msgstr "__itruediv__"

#: ../../c-api/typeobj.rst:289
msgid ":c:member:`~PyNumberMethods.nb_index`"
msgstr ":c:member:`~PyNumberMethods.nb_index`"

#: ../../c-api/typeobj.rst:289
msgid "__index__"
msgstr "__index__"

#: ../../c-api/typeobj.rst:291
msgid ":c:member:`~PyNumberMethods.nb_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_matrix_multiply`"

#: ../../c-api/typeobj.rst:291
msgid "__matmul__ __rmatmul__"
msgstr "__matmul__ __rmatmul__"

#: ../../c-api/typeobj.rst:294
msgid ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"

#: ../../c-api/typeobj.rst:294
msgid "__imatmul__"
msgstr "__imatmul__"

#: ../../c-api/typeobj.rst:298
msgid ":c:member:`~PyMappingMethods.mp_length`"
msgstr ":c:member:`~PyMappingMethods.mp_length`"

#: ../../c-api/typeobj.rst:298 ../../c-api/typeobj.rst:307
#: ../../c-api/typeobj.rst:414
msgid ":c:type:`lenfunc`"
msgstr ":c:type:`lenfunc`"

#: ../../c-api/typeobj.rst:298 ../../c-api/typeobj.rst:307
msgid "__len__"
msgstr "__len__"

#: ../../c-api/typeobj.rst:300
msgid ":c:member:`~PyMappingMethods.mp_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_subscript`"

#: ../../c-api/typeobj.rst:300 ../../c-api/typeobj.rst:313
msgid "__getitem__"
msgstr "__getitem__"

#: ../../c-api/typeobj.rst:302
msgid ":c:member:`~PyMappingMethods.mp_ass_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_ass_subscript`"

#: ../../c-api/typeobj.rst:302 ../../c-api/typeobj.rst:460
msgid ":c:type:`objobjargproc`"
msgstr ":c:type:`objobjargproc`"

#: ../../c-api/typeobj.rst:302
msgid "__setitem__, __delitem__"
msgstr "__setitem__, __delitem__"

#: ../../c-api/typeobj.rst:307
msgid ":c:member:`~PySequenceMethods.sq_length`"
msgstr ":c:member:`~PySequenceMethods.sq_length`"

#: ../../c-api/typeobj.rst:309
msgid ":c:member:`~PySequenceMethods.sq_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_concat`"

#: ../../c-api/typeobj.rst:309
msgid "__add__"
msgstr "__add__"

#: ../../c-api/typeobj.rst:311
msgid ":c:member:`~PySequenceMethods.sq_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_repeat`"

#: ../../c-api/typeobj.rst:311 ../../c-api/typeobj.rst:313
#: ../../c-api/typeobj.rst:322 ../../c-api/typeobj.rst:444
msgid ":c:type:`ssizeargfunc`"
msgstr ":c:type:`ssizeargfunc`"

#: ../../c-api/typeobj.rst:311
msgid "__mul__"
msgstr "__mul__"

#: ../../c-api/typeobj.rst:313
msgid ":c:member:`~PySequenceMethods.sq_item`"
msgstr ":c:member:`~PySequenceMethods.sq_item`"

#: ../../c-api/typeobj.rst:315
msgid ":c:member:`~PySequenceMethods.sq_ass_item`"
msgstr ":c:member:`~PySequenceMethods.sq_ass_item`"

#: ../../c-api/typeobj.rst:315 ../../c-api/typeobj.rst:449
msgid ":c:type:`ssizeobjargproc`"
msgstr ":c:type:`ssizeobjargproc`"

#: ../../c-api/typeobj.rst:315
msgid "__setitem__ __delitem__"
msgstr "__setitem__ __delitem__"

#: ../../c-api/typeobj.rst:318
msgid ":c:member:`~PySequenceMethods.sq_contains`"
msgstr ":c:member:`~PySequenceMethods.sq_contains`"

#: ../../c-api/typeobj.rst:318 ../../c-api/typeobj.rst:455
msgid ":c:type:`objobjproc`"
msgstr ":c:type:`objobjproc`"

#: ../../c-api/typeobj.rst:318
msgid "__contains__"
msgstr "__contains__"

#: ../../c-api/typeobj.rst:320
msgid ":c:member:`~PySequenceMethods.sq_inplace_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_concat`"

#: ../../c-api/typeobj.rst:322
msgid ":c:member:`~PySequenceMethods.sq_inplace_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_repeat`"

#: ../../c-api/typeobj.rst:326
msgid ":c:member:`~PyBufferProcs.bf_getbuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_getbuffer`"

#: ../../c-api/typeobj.rst:326
msgid ":c:func:`getbufferproc`"
msgstr ":c:func:`getbufferproc`"

#: ../../c-api/typeobj.rst:328
msgid ":c:member:`~PyBufferProcs.bf_releasebuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_releasebuffer`"

#: ../../c-api/typeobj.rst:328
msgid ":c:func:`releasebufferproc`"
msgstr ":c:func:`releasebufferproc`"

#: ../../c-api/typeobj.rst:334
#, fuzzy
msgid "slot typedefs"
msgstr "插槽型別定義"

#: ../../c-api/typeobj.rst:337
msgid "typedef"
msgstr "typedef"

#: ../../c-api/typeobj.rst:337
#, fuzzy
msgid "Parameter Types"
msgstr "參數型別"

#: ../../c-api/typeobj.rst:337
#, fuzzy
msgid "Return Type"
msgstr "回傳型別"

#: ../../c-api/typeobj.rst:344 ../../c-api/typeobj.rst:346
#: ../../c-api/typeobj.rst:422
msgid "void"
msgstr "void"

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`visitproc`"
msgstr ":c:type:`visitproc`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:348
#: ../../c-api/typeobj.rst:360 ../../c-api/typeobj.rst:373
#: ../../c-api/typeobj.rst:384 ../../c-api/typeobj.rst:396
#: ../../c-api/typeobj.rst:416 ../../c-api/typeobj.rst:427
#: ../../c-api/typeobj.rst:449 ../../c-api/typeobj.rst:455
#: ../../c-api/typeobj.rst:460
msgid "int"
msgstr "int"

#: ../../c-api/typeobj.rst:402
msgid "Py_hash_t"
msgstr "Py_hash_t"

#: ../../c-api/typeobj.rst:416
msgid ":c:type:`getbufferproc`"
msgstr ":c:type:`getbufferproc`"

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`Py_buffer` *"
msgstr ":c:type:`Py_buffer` *"

#: ../../c-api/typeobj.rst:422
msgid ":c:type:`releasebufferproc`"
msgstr ":c:type:`releasebufferproc`"

#: ../../c-api/typeobj.rst:467
msgid "See :ref:`slot-typedefs` below for more detail."
msgstr "更多細節請見下方的 :ref:`slot-typedefs`。"

#: ../../c-api/typeobj.rst:471
#, fuzzy
msgid "PyTypeObject Definition"
msgstr "PyTypeObject 定義"

#: ../../c-api/typeobj.rst:473
#, fuzzy
msgid ""
"The structure definition for :c:type:`PyTypeObject` can be found in :file:"
"`Include/object.h`.  For convenience of reference, this repeats the "
"definition found there:"
msgstr ""
":c:type:`PyTypeObject` 的結構定義可以在 :file:`Include/object.h` 中找到。為了"
"方便參考，這裡重複了那裡的定義："

#: ../../c-api/typeobj.rst:483
#, fuzzy
msgid "PyObject Slots"
msgstr "PyObject 插槽"

#: ../../c-api/typeobj.rst:485
#, fuzzy
msgid ""
"The type object structure extends the :c:type:`PyVarObject` structure. The :"
"attr:`ob_size` field is used for dynamic types (created by :func:`type_new`, "
"usually called from a class statement). Note that :c:data:`PyType_Type` (the "
"metatype) initializes :c:member:`~PyTypeObject.tp_itemsize`, which means "
"that its instances (i.e. type objects) *must* have the :attr:`ob_size` field."
msgstr ""
"型別物件結構擴充了 PyVarObject 結構。 :attr:`ob_size` 欄位用於動態型別（由 :"
"func:`type_new` 建立，通常從類語句中呼叫）。請注意 :c:data:`PyType_Type`（元"
"型別）初始化 :c:member:`~PyTypeObject.tp_itemsize`，這意味著它的實例（即型別"
"物件）*必須*具有 :attr:`ob_size` 欄位。"

#: ../../c-api/typeobj.rst:494
#, fuzzy
msgid ""
"This is the type object's reference count, initialized to ``1`` by the "
"``PyObject_HEAD_INIT`` macro.  Note that for :ref:`statically allocated type "
"objects <static-types>`, the type's instances (objects whose :attr:`ob_type` "
"points back to the type) do *not* count as references.  But for :ref:"
"`dynamically allocated type objects <heap-types>`, the instances *do* count "
"as references."
msgstr ""
"這是型別物件的引用計數，由 PyObject_HEAD_INIT 巨集初始化為 1。請注意，對於 :"
"ref:`statically allocated type objects <static-types>`，該型別的實例（其 :"
"attr:`ob_type` 指向該型別的物件）*不*算作引用。但是對於 :ref:`動態分配的型別"
"物件 <heap-types>`，實例*確實*算作引用。"

#: ../../c-api/typeobj.rst:501 ../../c-api/typeobj.rst:524
#: ../../c-api/typeobj.rst:546 ../../c-api/typeobj.rst:560
#: ../../c-api/typeobj.rst:604 ../../c-api/typeobj.rst:647
#: ../../c-api/typeobj.rst:705 ../../c-api/typeobj.rst:743
#: ../../c-api/typeobj.rst:763 ../../c-api/typeobj.rst:780
#: ../../c-api/typeobj.rst:798 ../../c-api/typeobj.rst:822
#: ../../c-api/typeobj.rst:839 ../../c-api/typeobj.rst:851
#: ../../c-api/typeobj.rst:863 ../../c-api/typeobj.rst:896
#: ../../c-api/typeobj.rst:914 ../../c-api/typeobj.rst:934
#: ../../c-api/typeobj.rst:955 ../../c-api/typeobj.rst:981
#: ../../c-api/typeobj.rst:1000 ../../c-api/typeobj.rst:1016
#: ../../c-api/typeobj.rst:1053 ../../c-api/typeobj.rst:1064
#: ../../c-api/typeobj.rst:1074 ../../c-api/typeobj.rst:1084
#: ../../c-api/typeobj.rst:1098 ../../c-api/typeobj.rst:1116
#: ../../c-api/typeobj.rst:1139 ../../c-api/typeobj.rst:1186
#: ../../c-api/typeobj.rst:1201 ../../c-api/typeobj.rst:1220
#: ../../c-api/typeobj.rst:1250 ../../c-api/typeobj.rst:1272
#: ../../c-api/typeobj.rst:1288 ../../c-api/typeobj.rst:1356
#: ../../c-api/typeobj.rst:1423 ../../c-api/typeobj.rst:1482
#: ../../c-api/typeobj.rst:1512 ../../c-api/typeobj.rst:1544
#: ../../c-api/typeobj.rst:1567 ../../c-api/typeobj.rst:1580
#: ../../c-api/typeobj.rst:1595 ../../c-api/typeobj.rst:1609
#: ../../c-api/typeobj.rst:1639 ../../c-api/typeobj.rst:1659
#: ../../c-api/typeobj.rst:1685 ../../c-api/typeobj.rst:1703
#: ../../c-api/typeobj.rst:1736 ../../c-api/typeobj.rst:1787
#: ../../c-api/typeobj.rst:1804 ../../c-api/typeobj.rst:1845
#: ../../c-api/typeobj.rst:1867 ../../c-api/typeobj.rst:1899
#: ../../c-api/typeobj.rst:1927 ../../c-api/typeobj.rst:1940
#: ../../c-api/typeobj.rst:1950 ../../c-api/typeobj.rst:1959
#: ../../c-api/typeobj.rst:1969 ../../c-api/typeobj.rst:1983
#: ../../c-api/typeobj.rst:2029 ../../c-api/typeobj.rst:2052
#, fuzzy
msgid "**Inheritance:**"
msgstr "**遺產：**"

#: ../../c-api/typeobj.rst:503 ../../c-api/typeobj.rst:562
#: ../../c-api/typeobj.rst:606
#, fuzzy
msgid "This field is not inherited by subtypes."
msgstr "該欄位不被子型別繼承。"

#: ../../c-api/typeobj.rst:508
#, fuzzy
msgid ""
"This is the type's type, in other words its metatype.  It is initialized by "
"the argument to the ``PyObject_HEAD_INIT`` macro, and its value should "
"normally be ``&PyType_Type``.  However, for dynamically loadable extension "
"modules that must be usable on Windows (at least), the compiler complains "
"that this is not a valid initializer.  Therefore, the convention is to pass "
"``NULL`` to the ``PyObject_HEAD_INIT`` macro and to initialize this field "
"explicitly at the start of the module's initialization function, before "
"doing anything else.  This is typically done like this::"
msgstr ""
"這是型別的型別，換句話說就是它的元型別。它由 ``PyObject_HEAD_INIT`` 巨集的參"
"數初始化，其值通常應為 ``&PyType_Type``。但是，對於必須在 Windows 上可用（至"
"少）的動態可加載擴充模組，編譯器會抱怨這不是有效的初始化程式。因此，約定是將 "
"``NULL`` 傳遞給“PyObject_HEAD_INIT”巨集，並在模組的初始化函式開始時顯式初始化"
"此欄位，然後再執行任何其他操作。這通常是這樣完成的："

#: ../../c-api/typeobj.rst:519
#, fuzzy
msgid ""
"This should be done before any instances of the type are created. :c:func:"
"`PyType_Ready` checks if :attr:`ob_type` is ``NULL``, and if so, initializes "
"it to the :attr:`ob_type` field of the base class. :c:func:`PyType_Ready` "
"will not change this field if it is non-zero."
msgstr ""
"這應該在建立該型別的任何實例之前完成。 :c:func:`PyType_Ready` 檢查 :attr:"
"`ob_type` 是否為 ``NULL``，如果是，則將其初始化為基底類別的 :attr:`ob_type` "
"欄位。 :c:func:`PyType_Ready` 如果不為零，則不會更改此欄位。"

#: ../../c-api/typeobj.rst:526 ../../c-api/typeobj.rst:707
#: ../../c-api/typeobj.rst:824 ../../c-api/typeobj.rst:916
#: ../../c-api/typeobj.rst:936 ../../c-api/typeobj.rst:1546
#: ../../c-api/typeobj.rst:1569 ../../c-api/typeobj.rst:1687
#: ../../c-api/typeobj.rst:1705 ../../c-api/typeobj.rst:1789
#: ../../c-api/typeobj.rst:1901 ../../c-api/typeobj.rst:2031
#, fuzzy
msgid "This field is inherited by subtypes."
msgstr "該欄位由子型別繼承。"

#: ../../c-api/typeobj.rst:532
#, fuzzy
msgid ""
"These fields are only present when the macro ``Py_TRACE_REFS`` is defined "
"(see the :option:`configure --with-trace-refs option <--with-trace-refs>`)."
msgstr ""
"這些欄位僅在定義巨集 Py_TRACE_REFS 時存在（請參閱 :option:`配置 --with-trace-"
"refs 選項 <--with-trace-refs>`）。"

#: ../../c-api/typeobj.rst:535
#, fuzzy
msgid ""
"Their initialization to ``NULL`` is taken care of by the "
"``PyObject_HEAD_INIT`` macro.  For :ref:`statically allocated objects "
"<static-types>`, these fields always remain ``NULL``.  For :ref:`dynamically "
"allocated objects <heap-types>`, these two fields are used to link the "
"object into a doubly linked list of *all* live objects on the heap."
msgstr ""
"它們對 NULL 的初始化由 PyObject_HEAD_INIT 巨集負責。對於 :ref:`statically "
"allocated objects <static-types>`，這些欄位始終保持為 ``NULL``。對於 :ref:"
"`dynamically allocated objects <heap-types>`，這兩個欄位用於將物件鏈接到堆上*"
"所有*活動物件的雙向鍊錶中。"

#: ../../c-api/typeobj.rst:541
#, fuzzy
msgid ""
"This could be used for various debugging purposes; currently the only uses "
"are the :func:`sys.getobjects` function and to print the objects that are "
"still alive at the end of a run when the environment variable :envvar:"
"`PYTHONDUMPREFS` is set."
msgstr ""
"這可以用於各種除錯目的；目前唯一的用途是 :func:`sys.getobjects` 函式，並在設"
"定環境變數 :envvar:`PYTHONDUMPREFS` 時印出運行結束時仍然存在的物件。"

#: ../../c-api/typeobj.rst:548
#, fuzzy
msgid "These fields are not inherited by subtypes."
msgstr "這些欄位不被子型別繼承。"

#: ../../c-api/typeobj.rst:552
#, fuzzy
msgid "PyVarObject Slots"
msgstr "PyVarObject 槽"

#: ../../c-api/typeobj.rst:556
#, fuzzy
msgid ""
"For :ref:`statically allocated type objects <static-types>`, this should be "
"initialized to zero. For :ref:`dynamically allocated type objects <heap-"
"types>`, this field has a special internal meaning."
msgstr ""
"對於 :ref:`statically allocated type objects <static-types>`，這應該初始化為"
"零。對於 :ref:`dynamically allocated type objects <heap-types>`，該欄位具有特"
"殊的內部含義。"

#: ../../c-api/typeobj.rst:566
#, fuzzy
msgid "PyTypeObject Slots"
msgstr "PyTypeObject 插槽"

#: ../../c-api/typeobj.rst:568
#, fuzzy
msgid ""
"Each slot has a section describing inheritance.  If :c:func:`PyType_Ready` "
"may set a value when the field is set to ``NULL`` then there will also be a "
"\"Default\" section.  (Note that many fields set on :c:type:"
"`PyBaseObject_Type` and :c:type:`PyType_Type` effectively act as defaults.)"
msgstr ""
"每個插槽都有一個描述繼承的部分。如果 :c:func:`PyType_Ready` 可以在欄位設定為 "
"``NULL`` 時設定一個值，那麼也會有一個“預設”部分。 （請注意，在 :c:type:"
"`PyBaseObject_Type` 和 :c:type:`PyType_Type` 上設定的許多欄位有效地充當預設"
"值。）"

#: ../../c-api/typeobj.rst:575
#, fuzzy
msgid ""
"Pointer to a NUL-terminated string containing the name of the type. For "
"types that are accessible as module globals, the string should be the full "
"module name, followed by a dot, followed by the type name; for built-in "
"types, it should be just the type name.  If the module is a submodule of a "
"package, the full package name is part of the full module name.  For "
"example, a type named :class:`T` defined in module :mod:`M` in subpackage :"
"mod:`Q` in package :mod:`P` should have the :c:member:`~PyTypeObject."
"tp_name` initializer ``\"P.Q.M.T\"``."
msgstr ""
"指向包含型別名稱的以 NUL 結尾的字串的指標。對於可以作為模組全局變數訪問的型"
"別，字串應該是完整的模組名稱，後跟一個點，然後是型別名稱；對於內建型別，它應"
"該只是型別名稱。如果模組是包的子模組，則完整的包名稱是完整模組名稱的一部分。"
"例如，在子包 :mod:`Q` 中的模組 :mod:`M` 中定義的名為 :class:`T` 的型別應該具"
"有 :c:member:`~PyTypeObject.tp_name ` 初始化器 ``\"P.Q.M.T\"``。"

#: ../../c-api/typeobj.rst:583
#, fuzzy
msgid ""
"For :ref:`dynamically allocated type objects <heap-types>`, this should just "
"be the type name, and the module name explicitly stored in the type dict as "
"the value for key ``'__module__'``."
msgstr ""
"對於 :ref:`動態分配的型別物件 <heap-types>`，這應該只是型別名稱，以及顯式儲存"
"在型別字典中的模組名稱作為鍵 ``'__module__'`` 的值。"

#: ../../c-api/typeobj.rst:588
#, fuzzy
msgid ""
"For :ref:`statically allocated type objects <static-types>`, the *tp_name* "
"field should contain a dot. Everything before the last dot is made "
"accessible as the :attr:`__module__` attribute, and everything after the "
"last dot is made accessible as the :attr:`~definition.__name__` attribute."
msgstr ""
"對於 :ref:`statically allocated type objects <static-types>`，*tp_name* 欄位"
"應包含一個點。最後一個點之前的所有內容都可以作為 :attr:`__module__` 屬性訪"
"問，最後一個點之後的所有內容都可以作為 :attr:`~definition.__name__` 屬性訪"
"問。"

#: ../../c-api/typeobj.rst:594
#, fuzzy
msgid ""
"If no dot is present, the entire :c:member:`~PyTypeObject.tp_name` field is "
"made accessible as the :attr:`~definition.__name__` attribute, and the :attr:"
"`__module__` attribute is undefined (unless explicitly set in the "
"dictionary, as explained above).  This means your type will be impossible to "
"pickle.  Additionally, it will not be listed in module documentations "
"created with pydoc."
msgstr ""
"如果不存在點，則整個 :c:member:`~PyTypeObject.tp_name` 欄位可作為 :attr:"
"`~definition.__name__` 屬性訪問，並且 :attr:`__module__` 屬性未定義（除非明確"
"說明設定在字典中，如上所述）。這意味著您的型別將無法醃製。此外，它不會列在使"
"用 pydoc 建立的模組文檔中。"

#: ../../c-api/typeobj.rst:600
#, fuzzy
msgid ""
"This field must not be ``NULL``.  It is the only required field in :c:func:"
"`PyTypeObject` (other than potentially :c:member:`~PyTypeObject."
"tp_itemsize`)."
msgstr ""
"該欄位不能為 ``NULL`` 。它是 :c:func:`PyTypeObject` 中唯一必需的欄位（除了可"
"能的 :c:member:`~PyTypeObject.tp_itemsize`）。"

#: ../../c-api/typeobj.rst:612
#, fuzzy
msgid ""
"These fields allow calculating the size in bytes of instances of the type."
msgstr "這些欄位允許計算型別實例的位元組大小。"

#: ../../c-api/typeobj.rst:614
#, fuzzy
msgid ""
"There are two kinds of types: types with fixed-length instances have a zero :"
"c:member:`~PyTypeObject.tp_itemsize` field, types with variable-length "
"instances have a non-zero :c:member:`~PyTypeObject.tp_itemsize` field.  For "
"a type with fixed-length instances, all instances have the same size, given "
"in :c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"有兩種型別：具有固定長度實例的型別具有零 :c:member:`~PyTypeObject."
"tp_itemsize` 欄位，具有可變長度實例的型別具有非零 :c:member:`~PyTypeObject."
"tp_itemsize `領域。對於具有固定長度實例的型別，所有實例都具有相同的大小，在 :"
"c:member:`~PyTypeObject.tp_basicsize` 中給出。"

#: ../../c-api/typeobj.rst:619
#, fuzzy
msgid ""
"For a type with variable-length instances, the instances must have an :attr:"
"`ob_size` field, and the instance size is :c:member:`~PyTypeObject."
"tp_basicsize` plus N times :c:member:`~PyTypeObject.tp_itemsize`, where N is "
"the \"length\" of the object.  The value of N is typically stored in the "
"instance's :attr:`ob_size` field.  There are exceptions:  for example, ints "
"use a negative :attr:`ob_size` to indicate a negative number, and N is "
"``abs(ob_size)`` there.  Also, the presence of an :attr:`ob_size` field in "
"the instance layout doesn't mean that the instance structure is variable-"
"length (for example, the structure for the list type has fixed-length "
"instances, yet those instances have a meaningful :attr:`ob_size` field)."
msgstr ""
"對於具有可變長度實例的型別，實例必須具有 :attr:`ob_size` 欄位，並且實例大小"
"為:c:member:`~PyTypeObject.tp_basicsize` 加上 N 倍:c:member:`~PyTypeObject。 "
"tp_itemsize`，其中 N 是物件的“長度”。 N 的值通常儲存在實例的 ob_size 欄位中。"
"也有例外：例如，整數使用負數 :attr:`ob_size` 表示負數，N 是 "
"``abs(ob_size)``。此外，實例佈局中存在 ob_size 欄位並不意味著實例結構是可變長"
"度的（例如，列表型別的結構具有固定長度的實例，但這些實例具有有意義的 :attr:"
"`ob_size` 欄位）。"

#: ../../c-api/typeobj.rst:630
#, fuzzy
msgid ""
"The basic size includes the fields in the instance declared by the macro :c:"
"macro:`PyObject_HEAD` or :c:macro:`PyObject_VAR_HEAD` (whichever is used to "
"declare the instance struct) and this in turn includes the :attr:`_ob_prev` "
"and :attr:`_ob_next` fields if they are present.  This means that the only "
"correct way to get an initializer for the :c:member:`~PyTypeObject."
"tp_basicsize` is to use the ``sizeof`` operator on the struct used to "
"declare the instance layout. The basic size does not include the GC header "
"size."
msgstr ""
"基本大小包括由巨集聲明的實例中的欄位 :c:macro:`PyObject_HEAD` 或 :c:macro:"
"`PyObject_VAR_HEAD`（無論哪個用於聲明實例結構），這又包括 :attr:` _ob_prev` "
"和 :attr:`_ob_next` 欄位（如果存在）。這意味著獲取 :c:member:`~PyTypeObject."
"tp_basicsize` 的初始化程式的唯一正確方法是在用於聲明實例佈局的結構上使用 "
"``sizeof`` 運算符。基本大小不包括 GC 頭大小。"

#: ../../c-api/typeobj.rst:638
#, fuzzy
msgid ""
"A note about alignment: if the variable items require a particular "
"alignment, this should be taken care of by the value of :c:member:"
"`~PyTypeObject.tp_basicsize`.  Example: suppose a type implements an array "
"of ``double``. :c:member:`~PyTypeObject.tp_itemsize` is ``sizeof(double)``. "
"It is the programmer's responsibility that :c:member:`~PyTypeObject."
"tp_basicsize` is a multiple of ``sizeof(double)`` (assuming this is the "
"alignment requirement for ``double``)."
msgstr ""
"關於對齊的注意事項：如果變數項目需要特定的對齊方式，則應通過 :c:member:"
"`~PyTypeObject.tp_basicsize` 的值來處理。示例：假設一個型別實作了一個 "
"``double`` 的數組。 :c:member:`~PyTypeObject.tp_itemsize` 是"
"``sizeof(double)``。 :c:member:`~PyTypeObject.tp_basicsize` 是 "
"``sizeof(double)`` 的倍數是程式員的責任（假設這是 ``double`` 的對齊要求）。"

#: ../../c-api/typeobj.rst:645
#, fuzzy
msgid ""
"For any type with variable-length instances, this field must not be ``NULL``."
msgstr "對於任何具有可變長度實例的型別，此欄位不得為 ``NULL`` 。"

#: ../../c-api/typeobj.rst:649
#, fuzzy
msgid ""
"These fields are inherited separately by subtypes.  If the base type has a "
"non-zero :c:member:`~PyTypeObject.tp_itemsize`, it is generally not safe to "
"set :c:member:`~PyTypeObject.tp_itemsize` to a different non-zero value in a "
"subtype (though this depends on the implementation of the base type)."
msgstr ""
"這些欄位由子型別單獨繼承。如果基型別具有非零值 :c:member:`~PyTypeObject."
"tp_itemsize`，則在子型別中將:c:member:`~PyTypeObject.tp_itemsize` 設定為不同"
"的非零值通常是不安全的（儘管這取決於基型別的實作）。"

#: ../../c-api/typeobj.rst:657
#, fuzzy
msgid ""
"A pointer to the instance destructor function.  This function must be "
"defined unless the type guarantees that its instances will never be "
"deallocated (as is the case for the singletons ``None`` and ``Ellipsis``).  "
"The function signature is::"
msgstr ""
"指向實例析構函式的指標。必須定義此函式，除非型別保證其實例永遠不會被釋放（就"
"像單例 ``None``和 ``Ellipsis`` 的情況）。函式簽名是："

#: ../../c-api/typeobj.rst:663
#, fuzzy
msgid ""
"The destructor function is called by the :c:func:`Py_DECREF` and :c:func:"
"`Py_XDECREF` macros when the new reference count is zero.  At this point, "
"the instance is still in existence, but there are no references to it.  The "
"destructor function should free all references which the instance owns, free "
"all memory buffers owned by the instance (using the freeing function "
"corresponding to the allocation function used to allocate the buffer), and "
"call the type's :c:member:`~PyTypeObject.tp_free` function.  If the type is "
"not subtypable (doesn't have the :const:`Py_TPFLAGS_BASETYPE` flag bit set), "
"it is permissible to call the object deallocator directly instead of via :c:"
"member:`~PyTypeObject.tp_free`.  The object deallocator should be the one "
"used to allocate the instance; this is normally :c:func:`PyObject_Del` if "
"the instance was allocated using :c:func:`PyObject_New` or :c:func:"
"`PyObject_VarNew`, or :c:func:`PyObject_GC_Del` if the instance was "
"allocated using :c:func:`PyObject_GC_New` or :c:func:`PyObject_GC_NewVar`."
msgstr ""
"當新引用計數為零時，析構函式由 Py_DECREF 和 Py_XDECREF 巨集呼叫。此時，該實例"
"仍然存在，但沒有對它的引用。析構函式應該釋放實例擁有的所有引用，釋放實例擁有"
"的所有記憶體緩衝區（使用與用於分配緩衝區的分配函式對應的釋放函式），並呼叫型"
"別的 :c:member:`~PyTypeObject。 tp_free 函式。如果型別不可子型別化（沒有設定 "
"Py_TPFLAGS_BASETYPE 旗標位），則允許直接呼叫物件釋放器，而不是通過 :c:member:"
"`~PyTypeObject.tp_free`。物件釋放器應該是用於分配實例的那個；這通常是 :c:"
"func:`PyObject_Del` 如果實例是使用 :c:func:`PyObject_New` 或 :c:func:"
"`PyObject_VarNew` 分配的，或者 :c:func:`PyObject_GC_Del` 如果實例是使用分配"
"的:c:func:`PyObject_GC_New` 或 :c:func:`PyObject_GC_NewVar`。"

#: ../../c-api/typeobj.rst:678
#, fuzzy
msgid ""
"If the type supports garbage collection (has the :const:`Py_TPFLAGS_HAVE_GC` "
"flag bit set), the destructor should call :c:func:`PyObject_GC_UnTrack` "
"before clearing any member fields."
msgstr ""
"如果型別支援垃圾回收（設定了 Py_TPFLAGS_HAVE_GC 旗標位），析構函式應在清除任"
"何成員欄位之前呼叫 PyObject_GC_UnTrack。"

#: ../../c-api/typeobj.rst:690
#, fuzzy
msgid ""
"Finally, if the type is heap allocated (:const:`Py_TPFLAGS_HEAPTYPE`), the "
"deallocator should decrement the reference count for its type object after "
"calling the type deallocator. In order to avoid dangling pointers, the "
"recommended way to achieve this is:"
msgstr ""
"最後，如果型別是堆分配的 (:const:`Py_TPFLAGS_HEAPTYPE`)，釋放器應該在呼叫型別"
"釋放器後減少其型別物件的引用計數。為了避免懸掛指標，推薦的實作方式是："

#: ../../c-api/typeobj.rst:712
#, fuzzy
msgid ""
"An optional offset to a per-instance function that implements calling the "
"object using the :ref:`vectorcall protocol <vectorcall>`, a more efficient "
"alternative of the simpler :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"每個實例函式的可選偏移量，該函式使用 vectorcall 協定 <vectorcall>` 實作呼叫物"
"件，這是更簡單的 :c:member:`~PyTypeObject.tp_call` 的更有效替代方法。"

#: ../../c-api/typeobj.rst:717
#, fuzzy
msgid ""
"This field is only used if the flag :const:`Py_TPFLAGS_HAVE_VECTORCALL` is "
"set. If so, this must be a positive integer containing the offset in the "
"instance of a :c:type:`vectorcallfunc` pointer."
msgstr ""
"此欄位僅在設定旗標 Py_TPFLAGS_HAVE_VECTORCALL 時使用。如果是這樣，這必須是一"
"個正整數，其中包含:c:type:`vectorcallfunc` 指標實例中的偏移量。"

#: ../../c-api/typeobj.rst:721
#, fuzzy
msgid ""
"The *vectorcallfunc* pointer may be ``NULL``, in which case the instance "
"behaves as if :const:`Py_TPFLAGS_HAVE_VECTORCALL` was not set: calling the "
"instance falls back to :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"*vectorcallfunc* 指標可能為 ``NULL`` ，在這種情況下，實例的行為就像未設定："
"const:`Py_TPFLAGS_HAVE_VECTORCALL`：呼叫實例回落到 :c:member:`~PyTypeObject."
"tp_call`。"

#: ../../c-api/typeobj.rst:725
#, fuzzy
msgid ""
"Any class that sets ``Py_TPFLAGS_HAVE_VECTORCALL`` must also set :c:member:"
"`~PyTypeObject.tp_call` and make sure its behaviour is consistent with the "
"*vectorcallfunc* function. This can be done by setting *tp_call* to :c:func:"
"`PyVectorcall_Call`."
msgstr ""
"任何設定 ``Py_TPFLAGS_HAVE_VECTORCALL`` 的類還必須設定 :c:member:"
"`~PyTypeObject.tp_call` 並確保其行為與 *vectorcallfunc* 函式一致。這可以通過"
"將 *tp_call* 設定為 :c:func:`PyVectorcall_Call` 來完成。"

#: ../../c-api/typeobj.rst:732
#, fuzzy
msgid ""
"It is not recommended for :ref:`mutable heap types <heap-types>` to "
"implement the vectorcall protocol. When a user sets :attr:`__call__` in "
"Python code, only *tp_call* is updated, likely making it inconsistent with "
"the vectorcall function."
msgstr ""
"不建議 :ref:`可變堆型別 <heap-types>` 實作 vectorcall 協定。當使用者在 "
"Python 程式碼中設定 :attr:`__call__` 時，只有 *tp_call* 被更新，可能與 "
"vectorcall 函式不一致。"

#: ../../c-api/typeobj.rst:739
#, fuzzy
msgid ""
"Before version 3.8, this slot was named ``tp_print``. In Python 2.x, it was "
"used for printing to a file. In Python 3.0 to 3.7, it was unused."
msgstr ""
"在 3.8 版之前，這個插槽被命名為“tp_print”。在 Python 2.x 中，它用於印出到文"
"件。在 Python 3.0 到 3.7 中，它未被使用。"

#: ../../c-api/typeobj.rst:745
#, fuzzy
msgid ""
"This field is always inherited. However, the :const:"
"`Py_TPFLAGS_HAVE_VECTORCALL` flag is not always inherited. If it's not, then "
"the subclass won't use :ref:`vectorcall <vectorcall>`, except when :c:func:"
"`PyVectorcall_Call` is explicitly called. This is in particular the case for "
"types without the :const:`Py_TPFLAGS_IMMUTABLETYPE` flag set (including "
"subclasses defined in Python)."
msgstr ""
"該欄位始終是繼承的。然而，:const:`Py_TPFLAGS_HAVE_VECTORCALL` 旗標並不總是被"
"繼承。如果不是，那麼子類別將不會使用 :ref:`vectorcall <vectorcall>`，除非顯式"
"呼叫:c:func:`PyVectorcall_Call`。對於沒有設定 Py_TPFLAGS_IMMUTABLETYPE 旗標的"
"型別（包括在 Python 中定義的子類別）來說尤其如此。"

#: ../../c-api/typeobj.rst:757
#, fuzzy
msgid "An optional pointer to the get-attribute-string function."
msgstr "指向 get-attribute-string 函式的可選指標。"

#: ../../c-api/typeobj.rst:759
#, fuzzy
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_getattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"此欄位已棄用。定義時，它應該指向一個與 :c:member:`~PyTypeObject.tp_getattro` "
"函式作用相同的函式，但使用 C 字串而不是 Python 字串物件來提供屬性名稱。"

#: ../../c-api/typeobj.rst:765 ../../c-api/typeobj.rst:957
#, fuzzy
msgid "Group: :attr:`tp_getattr`, :attr:`tp_getattro`"
msgstr "組：:attr:`tp_getattr`, :attr:`tp_getattro`"

#: ../../c-api/typeobj.rst:767
#, fuzzy
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"此欄位由子型別與 :c:member:`~PyTypeObject.tp_getattro` 一起繼承：子型別從其基"
"底類別繼承 :c:member:`~PyTypeObject.tp_getattr` 和 :c:member:`~PyTypeObject."
"tp_getattro`當子型別的 :c:member:`~PyTypeObject.tp_getattr` 和 :c:member:"
"`~PyTypeObject.tp_getattro` 都是 ``NULL`` 時鍵入。"

#: ../../c-api/typeobj.rst:774 ../../c-api/typeobj.rst:970
#, fuzzy
msgid ""
"An optional pointer to the function for setting and deleting attributes."
msgstr "指向用於設定和刪除屬性的函式的可選指標。"

#: ../../c-api/typeobj.rst:776
#, fuzzy
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_setattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"此欄位已棄用。定義時，它應該指向一個與 :c:member:`~PyTypeObject.tp_setattro` "
"函式作用相同的函式，但使用 C 字串而不是 Python 字串物件來提供屬性名稱。"

#: ../../c-api/typeobj.rst:782 ../../c-api/typeobj.rst:983
#, fuzzy
msgid "Group: :attr:`tp_setattr`, :attr:`tp_setattro`"
msgstr "組：:attr:`tp_setattr`, :attr:`tp_setattro`"

#: ../../c-api/typeobj.rst:784
#, fuzzy
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"此欄位由子型別與 :c:member:`~PyTypeObject.tp_setattro` 一起繼承：子型別從其基"
"底類別繼承 :c:member:`~PyTypeObject.tp_setattr` 和 :c:member:`~PyTypeObject."
"tp_setattro`當子型別的 :c:member:`~PyTypeObject.tp_setattr` 和 :c:member:"
"`~PyTypeObject.tp_setattro` 都是 ``NULL`` 時鍵入。"

#: ../../c-api/typeobj.rst:791
#, fuzzy
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement :term:`awaitable` and :term:`asynchronous iterator` "
"protocols at the C-level.  See :ref:`async-structs` for details."
msgstr ""
"指向一個附加結構的指標，該結構包含僅與在 C 級實作 awaitable 和 asynchronous "
"iterator 協定的物件相關的欄位。有關詳細資訊，請參閱 :ref:`async-structs`。"

#: ../../c-api/typeobj.rst:795
#, fuzzy
msgid "Formerly known as ``tp_compare`` and ``tp_reserved``."
msgstr "以前稱為“tp_compare”和“tp_reserved”。"

#: ../../c-api/typeobj.rst:800
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_as_async` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
":c:member:`~PyTypeObject.tp_as_async` 欄位不被繼承，但包含的欄位是單獨繼承"
"的。"

#: ../../c-api/typeobj.rst:808
#, fuzzy
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`repr`."
msgstr "指向實作內建函式 :func:`repr` 的函式的可選指標。"

#: ../../c-api/typeobj.rst:811
#, fuzzy
msgid "The signature is the same as for :c:func:`PyObject_Repr`::"
msgstr "簽名與 :c:func:`PyObject_Repr`:: 相同"

#: ../../c-api/typeobj.rst:815
#, fuzzy
msgid ""
"The function must return a string or a Unicode object.  Ideally, this "
"function should return a string that, when passed to :func:`eval`, given a "
"suitable environment, returns an object with the same value.  If this is not "
"feasible, it should return a string starting with ``'<'`` and ending with "
"``'>'`` from which both the type and the value of the object can be deduced."
msgstr ""
"該函式必須回傳一個字串或一個 Unicode 物件。理想情況下，此函式應回傳一個字串，"
"當傳遞給 :func:`eval` 時，給定一個合適的環境，回傳一個具有相同值的物件。如果"
"這不可行，它應該回傳一個以 ``'<'`` 開頭並以 ``'>'`` 結尾的字串，從中可以推斷"
"出物件的型別和值。"

#: ../../c-api/typeobj.rst:826 ../../c-api/typeobj.rst:938
#: ../../c-api/typeobj.rst:963 ../../c-api/typeobj.rst:989
#: ../../c-api/typeobj.rst:1031 ../../c-api/typeobj.rst:1491
#: ../../c-api/typeobj.rst:1643 ../../c-api/typeobj.rst:1664
#: ../../c-api/typeobj.rst:1755 ../../c-api/typeobj.rst:1791
#: ../../c-api/typeobj.rst:1809 ../../c-api/typeobj.rst:1851
#: ../../c-api/typeobj.rst:1872 ../../c-api/typeobj.rst:1903
msgid "**Default:**"
msgstr "**預設：**"

#: ../../c-api/typeobj.rst:828
#, fuzzy
msgid ""
"When this field is not set, a string of the form ``<%s object at %p>`` is "
"returned, where ``%s`` is replaced by the type name, and ``%p`` by the "
"object's memory address."
msgstr ""
"如果未設定此欄位，則回傳形式為“<%s object at %p>”的字串，其中“%s”替換為型別名"
"稱，“%p”替換為物件的記憶體地址。"

#: ../../c-api/typeobj.rst:835
#, fuzzy
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the number protocol.  These fields are documented "
"in :ref:`number-structs`."
msgstr ""
"指向附加結構的指標，該結構包含僅與實作數字協定的物件相關的欄位。這些欄位記錄"
"在 :ref:`number-structs` 中。"

#: ../../c-api/typeobj.rst:841
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_as_number` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
":c:member:`~PyTypeObject.tp_as_number` 欄位不被繼承，但包含的欄位是單獨繼承"
"的。"

#: ../../c-api/typeobj.rst:847
#, fuzzy
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the sequence protocol.  These fields are documented "
"in :ref:`sequence-structs`."
msgstr ""
"指向附加結構的指標，該結構包含僅與實作序列協定的物件相關的欄位。這些欄位記錄"
"在 :ref:`sequence-structs` 中。"

#: ../../c-api/typeobj.rst:853
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_as_sequence` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
":c:member:`~PyTypeObject.tp_as_sequence` 欄位不被繼承，但包含的欄位是單獨繼承"
"的。"

#: ../../c-api/typeobj.rst:859
#, fuzzy
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the mapping protocol.  These fields are documented "
"in :ref:`mapping-structs`."
msgstr ""
"指向附加結構的指標，該結構包含僅與實作映射協定的物件相關的欄位。這些欄位記錄"
"在 :ref:`mapping-structs` 中。"

#: ../../c-api/typeobj.rst:865
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_as_mapping` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
":c:member:`~PyTypeObject.tp_as_mapping` 欄位不被繼承，但包含的欄位是單獨繼承"
"的。"

#: ../../c-api/typeobj.rst:873
#, fuzzy
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`hash`."
msgstr "指向實作內建函式 :func:`hash` 的函式的可選指標。"

#: ../../c-api/typeobj.rst:876
#, fuzzy
msgid "The signature is the same as for :c:func:`PyObject_Hash`::"
msgstr "簽名與 :c:func:`PyObject_Hash`:: 相同"

#: ../../c-api/typeobj.rst:880
#, fuzzy
msgid ""
"The value ``-1`` should not be returned as a normal return value; when an "
"error occurs during the computation of the hash value, the function should "
"set an exception and return ``-1``."
msgstr ""
"值 ``-1``不應作為正常回傳值回傳；當雜湊值計算過程中發生錯誤時，該函式應設定例"
"外並回傳 ``-1``。"

#: ../../c-api/typeobj.rst:884
#, fuzzy
msgid ""
"When this field is not set (*and* :attr:`tp_richcompare` is not set), an "
"attempt to take the hash of the object raises :exc:`TypeError`. This is the "
"same as setting it to :c:func:`PyObject_HashNotImplemented`."
msgstr ""
"如果未設定此欄位（*和* :attr:`tp_richcompare` 未設定），嘗試獲取物件的雜湊值"
"會引發 :exc:`TypeError`。這與將其設定為相同 :c:func:"
"`PyObject_HashNotImplemented`。"

#: ../../c-api/typeobj.rst:888
#, fuzzy
msgid ""
"This field can be set explicitly to :c:func:`PyObject_HashNotImplemented` to "
"block inheritance of the hash method from a parent type. This is interpreted "
"as the equivalent of ``__hash__ = None`` at the Python level, causing "
"``isinstance(o, collections.Hashable)`` to correctly return ``False``. Note "
"that the converse is also true - setting ``__hash__ = None`` on a class at "
"the Python level will result in the ``tp_hash`` slot being set to :c:func:"
"`PyObject_HashNotImplemented`."
msgstr ""
"該欄位可以顯式設定為 PyObject_HashNotImplemented 以阻止從父型別繼承可雜湊方"
"法。這在 Python 級別被解釋為等同於 ``__hash__ = None``，導致 ``isinstance(o, "
"collections.Hashable)`` 正確回傳 ``False``。請注意，反之亦然——在 Python 級別"
"的類上設定 ``__hash__ = None`` 將導致 ``tp_hash`` 槽被設定為 :c:func:"
"`PyObject_HashNotImplemented`。"

#: ../../c-api/typeobj.rst:898 ../../c-api/typeobj.rst:1484
#, fuzzy
msgid "Group: :attr:`tp_hash`, :attr:`tp_richcompare`"
msgstr "組：:attr:`tp_hash`, :attr:`tp_richcompare`"

#: ../../c-api/typeobj.rst:900
#, fuzzy
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_richcompare`: a subtype inherits both of :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash`, when the subtype's :c:"
"member:`~PyTypeObject.tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` "
"are both ``NULL``."
msgstr ""
"該欄位由子型別與 :c:member:`~PyTypeObject.tp_richcompare` 一起繼承：子型別同"
"時繼承 :c:member:`~PyTypeObject.tp_richcompare` 和 :c:member:`~PyTypeObject."
"tp_hash`，當子型別的 :c:member:`~PyTypeObject.tp_richcompare` 和 :c:member:"
"`~PyTypeObject.tp_hash` 都是 ``NULL``。"

#: ../../c-api/typeobj.rst:908
#, fuzzy
msgid ""
"An optional pointer to a function that implements calling the object.  This "
"should be ``NULL`` if the object is not callable.  The signature is the same "
"as for :c:func:`PyObject_Call`::"
msgstr ""
"指向實作呼叫物件的函式的可選指標。如果對像不可呼叫，這應該是 ``NULL`` 。簽名"
"與 :c:func:`PyObject_Call`:: 相同"

#: ../../c-api/typeobj.rst:921
#, fuzzy
msgid ""
"An optional pointer to a function that implements the built-in operation :"
"func:`str`.  (Note that :class:`str` is a type now, and :func:`str` calls "
"the constructor for that type.  This constructor calls :c:func:"
"`PyObject_Str` to do the actual work, and :c:func:`PyObject_Str` will call "
"this handler.)"
msgstr ""
"指向實作內建操作 :func:`str` 的函式的可選指標。 （請注意 :class:`str` 現在是"
"一個型別，而 :func:`str` 呼叫該型別的構造函式。此構造函式呼叫 :c:func:"
"`PyObject_Str` 來完成實際工作，並且 :c:func :`PyObject_Str` 將呼叫此處理程"
"式。）"

#: ../../c-api/typeobj.rst:926
#, fuzzy
msgid "The signature is the same as for :c:func:`PyObject_Str`::"
msgstr "簽名與 :c:func:`PyObject_Str`:: 相同"

#: ../../c-api/typeobj.rst:930
#, fuzzy
msgid ""
"The function must return a string or a Unicode object.  It should be a "
"\"friendly\" string representation of the object, as this is the "
"representation that will be used, among other things, by the :func:`print` "
"function."
msgstr ""
"該函式必須回傳一個字串或一個 Unicode 物件。它應該是物件的“友好”字串表示形式，"
"因為除其他外，:func:`print` 函式將使用這種表示形式。"

#: ../../c-api/typeobj.rst:940
#, fuzzy
msgid ""
"When this field is not set, :c:func:`PyObject_Repr` is called to return a "
"string representation."
msgstr "如果未設定此欄位，則呼叫 PyObject_Repr 以回傳字串表示形式。"

#: ../../c-api/typeobj.rst:946
#, fuzzy
msgid "An optional pointer to the get-attribute function."
msgstr "指向 get-attribute 函式的可選指標。"

#: ../../c-api/typeobj.rst:948
#, fuzzy
msgid "The signature is the same as for :c:func:`PyObject_GetAttr`::"
msgstr "簽名與 :c:func:`PyObject_GetAttr`:: 相同："

#: ../../c-api/typeobj.rst:952
#, fuzzy
msgid ""
"It is usually convenient to set this field to :c:func:"
"`PyObject_GenericGetAttr`, which implements the normal way of looking for "
"object attributes."
msgstr ""
"將此欄位設定為 PyObject_GenericGetAttr 通常很方便，它實作了查找物件屬性的正常"
"方式。"

#: ../../c-api/typeobj.rst:959
#, fuzzy
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"此欄位由子型別與 :c:member:`~PyTypeObject.tp_getattr` 一起繼承：子型別從其基"
"底類別繼承 :c:member:`~PyTypeObject.tp_getattr` 和 :c:member:`~PyTypeObject."
"tp_getattro`當子型別的 :c:member:`~PyTypeObject.tp_getattr` 和 :c:member:"
"`~PyTypeObject.tp_getattro` 都是 ``NULL`` 時鍵入。"

#: ../../c-api/typeobj.rst:965
#, fuzzy
msgid ":c:type:`PyBaseObject_Type` uses :c:func:`PyObject_GenericGetAttr`."
msgstr ":c:type:`PyBaseObject_Type` 使用 :c:func:`PyObject_GenericGetAttr`。"

#: ../../c-api/typeobj.rst:972
#, fuzzy
msgid "The signature is the same as for :c:func:`PyObject_SetAttr`::"
msgstr "簽名與 :c:func:`PyObject_SetAttr`:: 相同"

#: ../../c-api/typeobj.rst:976
#, fuzzy
msgid ""
"In addition, setting *value* to ``NULL`` to delete an attribute must be "
"supported.  It is usually convenient to set this field to :c:func:"
"`PyObject_GenericSetAttr`, which implements the normal way of setting object "
"attributes."
msgstr ""
"此外，必須支援將 *value* 設定為 ``NULL`` 以刪除屬性。將此欄位設定為 "
"PyObject_GenericSetAttr 通常很方便，它實作了設定物件屬性的正常方式。"

#: ../../c-api/typeobj.rst:985
#, fuzzy
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"此欄位由子型別與 :c:member:`~PyTypeObject.tp_setattr` 一起繼承：子型別從其基"
"底類別繼承 :c:member:`~PyTypeObject.tp_setattr` 和 :c:member:`~PyTypeObject."
"tp_setattro`當子型別的 :c:member:`~PyTypeObject.tp_setattr` 和 :c:member:"
"`~PyTypeObject.tp_setattro` 都是 ``NULL`` 時鍵入。"

#: ../../c-api/typeobj.rst:991
#, fuzzy
msgid ":c:type:`PyBaseObject_Type` uses :c:func:`PyObject_GenericSetAttr`."
msgstr ":c:type:`PyBaseObject_Type` 使用 :c:func:`PyObject_GenericSetAttr`。"

#: ../../c-api/typeobj.rst:996
#, fuzzy
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the buffer interface.  These fields are documented "
"in :ref:`buffer-structs`."
msgstr ""
"指向附加結構的指標，該結構包含僅與實作緩衝區介面的物件相關的欄位。這些欄位記"
"錄在 :ref:`buffer-structs` 中。"

#: ../../c-api/typeobj.rst:1002
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_as_buffer` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
":c:member:`~PyTypeObject.tp_as_buffer` 欄位不被繼承，但包含的欄位是單獨繼承"
"的。"

#: ../../c-api/typeobj.rst:1008
#, fuzzy
msgid ""
"This field is a bit mask of various flags.  Some flags indicate variant "
"semantics for certain situations; others are used to indicate that certain "
"fields in the type object (or in the extension structures referenced via :c:"
"member:`~PyTypeObject.tp_as_number`, :c:member:`~PyTypeObject."
"tp_as_sequence`, :c:member:`~PyTypeObject.tp_as_mapping`, and :c:member:"
"`~PyTypeObject.tp_as_buffer`) that were historically not always present are "
"valid; if such a flag bit is clear, the type fields it guards must not be "
"accessed and must be considered to have a zero or ``NULL`` value instead."
msgstr ""
"該欄位是各種旗標的位掩碼。一些旗標表示某些情況下的變體語義；其他用於指示型別"
"對像中的某些欄位（或在通過引用的擴充結構中:c:member:`~PyTypeObject."
"tp_as_number`，:c:member:`~PyTypeObject.tp_as_sequence`，:c:member:` "
"~PyTypeObject.tp_as_mapping` 和 :c:member:`~PyTypeObject.tp_as_buffer`) 歷史"
"上並不總是存在的是有效的；如果這樣的旗標位是明確的，則不得訪問它保護的型別欄"
"位，並且必須將其視為具有零或 ``NULL`` 值。"

#: ../../c-api/typeobj.rst:1018
#, fuzzy
msgid ""
"Inheritance of this field is complicated.  Most flag bits are inherited "
"individually, i.e. if the base type has a flag bit set, the subtype inherits "
"this flag bit.  The flag bits that pertain to extension structures are "
"strictly inherited if the extension structure is inherited, i.e. the base "
"type's value of the flag bit is copied into the subtype together with a "
"pointer to the extension structure.  The :const:`Py_TPFLAGS_HAVE_GC` flag "
"bit is inherited together with the :c:member:`~PyTypeObject.tp_traverse` "
"and :c:member:`~PyTypeObject.tp_clear` fields, i.e. if the :const:"
"`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the :c:member:"
"`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` fields in "
"the subtype exist and have ``NULL`` values."
msgstr ""
"這個欄位的繼承很複雜。大多數旗標位是單獨繼承的，即如果基型別設定了旗標位，則"
"子型別繼承該旗標位。如果擴充結構是繼承的，則屬於擴充結構的旗標位是嚴格繼承"
"的，即旗標位的基本型別值與指向擴充結構的指標一起復製到子型別中。 :const:"
"`Py_TPFLAGS_HAVE_GC` 旗標位與 :c:member:`~PyTypeObject.tp_traverse` 和 :c:"
"member:`~PyTypeObject.tp_clear` 欄位一起繼承，即如果 :const:"
"`Py_TPFLAGS_HAVE_GC` 旗標位在子型別中是明確的，子型別中的:c:member:"
"`~PyTypeObject.tp_traverse` 和:c:member:`~PyTypeObject.tp_clear` 欄位存在並且"
"具有``NULL`` 值。"

#: ../../c-api/typeobj.rst:1033
#, fuzzy
msgid ""
":c:type:`PyBaseObject_Type` uses ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."
msgstr ""
":c:type:`PyBaseObject_Type` 使用``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``。"

#: ../../c-api/typeobj.rst:1036
#, fuzzy
msgid "**Bit Masks:**"
msgstr "**位掩碼：**"

#: ../../c-api/typeobj.rst:1038
#, fuzzy
msgid ""
"The following bit masks are currently defined; these can be ORed together "
"using the ``|`` operator to form the value of the :c:member:`~PyTypeObject."
"tp_flags` field.  The macro :c:func:`PyType_HasFeature` takes a type and a "
"flags value, *tp* and *f*, and checks whether ``tp->tp_flags & f`` is non-"
"zero."
msgstr ""
"當前定義了以下位掩碼；這些可以使用 ``|`` 運算符進行或運算以形成 :c:member:"
"`~PyTypeObject.tp_flags` 欄位的值。巨集:c:func:`PyType_HasFeature` 採用型別和"
"旗標值 *tp* 和 *f*，並檢查 ``tp->tp_flags & f`` 是否非零。"

#: ../../c-api/typeobj.rst:1045
#, fuzzy
msgid ""
"This bit is set when the type object itself is allocated on the heap, for "
"example, types created dynamically using :c:func:`PyType_FromSpec`.  In this "
"case, the :attr:`ob_type` field of its instances is considered a reference "
"to the type, and the type object is INCREF'ed when a new instance is "
"created, and DECREF'ed when an instance is destroyed (this does not apply to "
"instances of subtypes; only the type referenced by the instance's ob_type "
"gets INCREF'ed or DECREF'ed)."
msgstr ""
"當型別物件本身在堆上分配時設定此位，例如，使用 :c:func:`PyType_FromSpec` 動態"
"建立的型別。在這種情況下，其實例的 :attr:`ob_type` 欄位被認為是對該型別的引"
"用，並且型別對像在建立新實例時被 INCREF'ed，在實例被銷毀時被 DECREF'ed（這確"
"實不適用於子型別的實例；只有實例的 ob_type 引用的型別得到 INCREF'ed 或 "
"DECREF'ed）。"

#: ../../c-api/typeobj.rst:1055 ../../c-api/typeobj.rst:1066
#: ../../c-api/typeobj.rst:1076 ../../c-api/typeobj.rst:1086
#: ../../c-api/typeobj.rst:1118
msgid "???"
msgstr "???"

#: ../../c-api/typeobj.rst:1060
#, fuzzy
msgid ""
"This bit is set when the type can be used as the base type of another type.  "
"If this bit is clear, the type cannot be subtyped (similar to a \"final\" "
"class in Java)."
msgstr ""
"當型別可以用作另一種型別的基型別時設定此位。如果該位被清除，則該型別不能被子"
"型別化（類似於 Java 中的 ``final``類）。"

#: ../../c-api/typeobj.rst:1071
#, fuzzy
msgid ""
"This bit is set when the type object has been fully initialized by :c:func:"
"`PyType_Ready`."
msgstr "當型別對像已被 PyType_Ready 完全初始化時設定此位。"

#: ../../c-api/typeobj.rst:1081
#, fuzzy
msgid ""
"This bit is set while :c:func:`PyType_Ready` is in the process of "
"initializing the type object."
msgstr "此位在 :c:func:`PyType_Ready` 正在初始化型別物件的過程中設定。"

#: ../../c-api/typeobj.rst:1091
#, fuzzy
msgid ""
"This bit is set when the object supports garbage collection.  If this bit is "
"set, instances must be created using :c:func:`PyObject_GC_New` and destroyed "
"using :c:func:`PyObject_GC_Del`.  More information in section :ref:"
"`supporting-cycle-detection`.  This bit also implies that the GC-related "
"fields :c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject."
"tp_clear` are present in the type object."
msgstr ""
"當物件支援垃圾回收時設定該位。如果設定了該位，則實例必須使用 PyObject_GC_New "
"建立並使用 PyObject_GC_Del 銷毀。更多資訊見 :ref:`supporting-cycle-"
"detection` 部分。該位還暗示 GC 相關欄位 :c:member:`~PyTypeObject."
"tp_traverse` 和 :c:member:`~PyTypeObject.tp_clear` 存在於型別對像中。"

#: ../../c-api/typeobj.rst:1100 ../../c-api/typeobj.rst:1358
#: ../../c-api/typeobj.rst:1425
#, fuzzy
msgid ""
"Group: :const:`Py_TPFLAGS_HAVE_GC`, :attr:`tp_traverse`, :attr:`tp_clear`"
msgstr ""
"群組： :const:`Py_TPFLAGS_HAVE_GC`, :attr:`tp_traverse`, :attr:`tp_clear`"

#: ../../c-api/typeobj.rst:1102
#, fuzzy
msgid ""
"The :const:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with the :"
"attr:`tp_traverse` and :attr:`tp_clear` fields, i.e.  if the :const:"
"`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the :attr:"
"`tp_traverse` and :attr:`tp_clear` fields in the subtype exist and have "
"``NULL`` values."
msgstr ""
":const:`Py_TPFLAGS_HAVE_GC` 旗標位與 :attr:`tp_traverse` 和 :attr:`tp_clear` "
"欄位一起繼承，即如果 :const:`Py_TPFLAGS_HAVE_GC` 旗標位在子型別和 :attr:子型"
"別中的 `tp_traverse` 和 :attr:`tp_clear` 欄位存在並且具有 ``NULL`` 值。"

#: ../../c-api/typeobj.rst:1112
#, fuzzy
msgid ""
"This is a bitmask of all the bits that pertain to the existence of certain "
"fields in the type object and its extension structures. Currently, it "
"includes the following bits: :const:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."
msgstr ""
"這是與型別物件及其擴充結構中某些欄位的存在有關的所有位的位掩碼。目前，它包括"
"以下位：:const:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`。"

#: ../../c-api/typeobj.rst:1123
#, fuzzy
msgid "This bit indicates that objects behave like unbound methods."
msgstr "該位指示物件的行為類似於未綁定的方法。"

#: ../../c-api/typeobj.rst:1125
#, fuzzy
msgid "If this flag is set for ``type(meth)``, then:"
msgstr "如果為 ``type(meth)`` 設定了這個旗標，那麼："

#: ../../c-api/typeobj.rst:1127
#, fuzzy
msgid ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (with ``obj`` not None) must be "
"equivalent to ``meth(obj, *args, **kwds)``."
msgstr ""
"``meth.__get__(obj, cls)(*args, **kwds)``（其中 ``obj`` 不是 None）必須等同"
"於 ``meth(obj, *args, **kwds)``。"

#: ../../c-api/typeobj.rst:1130
#, fuzzy
msgid ""
"``meth.__get__(None, cls)(*args, **kwds)`` must be equivalent to "
"``meth(*args, **kwds)``."
msgstr ""
"``meth.__get__(None, cls)(*args, **kwds)`` 必須等同於 ``meth(*args, "
"**kwds)``。"

#: ../../c-api/typeobj.rst:1133
#, fuzzy
msgid ""
"This flag enables an optimization for typical method calls like ``obj."
"meth()``: it avoids creating a temporary \"bound method\" object for ``obj."
"meth``."
msgstr ""
"此旗標啟用對典型方法呼叫的最佳化，如 ``obj.meth()``：它避免為 ``obj.meth`` 建"
"立一個臨時的“綁定方法”物件。"

#: ../../c-api/typeobj.rst:1141
#, fuzzy
msgid ""
"This flag is never inherited by types without the :const:"
"`Py_TPFLAGS_IMMUTABLETYPE` flag set.  For extension types, it is inherited "
"whenever :c:member:`~PyTypeObject.tp_descr_get` is inherited."
msgstr ""
"沒有設定 Py_TPFLAGS_IMMUTABLETYPE 旗標的型別永遠不會繼承此旗標。對於擴充型"
"別，只要 :c:member:`~PyTypeObject.tp_descr_get` 被繼承，它就會被繼承。"

#: ../../c-api/typeobj.rst:1158
#, fuzzy
msgid ""
"These flags are used by functions such as :c:func:`PyLong_Check` to quickly "
"determine if a type is a subclass of a built-in type; such specific checks "
"are faster than a generic check, like :c:func:`PyObject_IsInstance`. Custom "
"types that inherit from built-ins should have their :c:member:`~PyTypeObject."
"tp_flags` set appropriately, or the code that interacts with such types will "
"behave differently depending on what kind of check is used."
msgstr ""
":c:func:`PyLong_Check` 等函式使用這些旗標來快速確定型別是否是內建型別的子類"
"別；此類特定檢查比一般檢查更快，例如 :c:func:`PyObject_IsInstance`。從內建函"
"式繼承的自定義型別應該適當地設定它們的 :c:member:`~PyTypeObject.tp_flags`，否"
"則與此類型別交互的程式碼將根據使用的檢查型別而有所不同。"

#: ../../c-api/typeobj.rst:1169
#, fuzzy
msgid ""
"This bit is set when the :c:member:`~PyTypeObject.tp_finalize` slot is "
"present in the type structure."
msgstr "當型別結構中存在 :c:member:`~PyTypeObject.tp_finalize` 槽時設定此位。"

#: ../../c-api/typeobj.rst:1174
#, fuzzy
msgid ""
"This flag isn't necessary anymore, as the interpreter assumes the :c:member:"
"`~PyTypeObject.tp_finalize` slot is always present in the type structure."
msgstr ""
"這個旗標不再是必需的，因為直譯器假定 :c:member:`~PyTypeObject.tp_finalize` 插"
"槽始終存在於型別結構中。"

#: ../../c-api/typeobj.rst:1182
#, fuzzy
msgid ""
"This bit is set when the class implements the :ref:`vectorcall protocol "
"<vectorcall>`. See :c:member:`~PyTypeObject.tp_vectorcall_offset` for "
"details."
msgstr ""
"該位在類實作 vectorcall 協定 <vectorcall> 時設定。有關詳細資訊，請參閱:c:"
"member:`~PyTypeObject.tp_vectorcall_offset`。"

#: ../../c-api/typeobj.rst:1188
#, fuzzy
msgid ""
"This bit is inherited for types with the :const:`Py_TPFLAGS_IMMUTABLETYPE` "
"flag set, if :c:member:`~PyTypeObject.tp_call` is also inherited."
msgstr ""
"如果 :const:`Py_TPFLAGS_IMMUTABLETYPE` 旗標集的型別繼承了該位，如果 :c:"
"member:`~PyTypeObject.tp_call` 也被繼承。"

#: ../../c-api/typeobj.rst:1196
#, fuzzy
msgid ""
"This bit is set for type objects that are immutable: type attributes cannot "
"be set nor deleted."
msgstr "為不可變的型別物件設定此位：不能設定或刪除型別屬性。"

#: ../../c-api/typeobj.rst:1198
#, fuzzy
msgid ""
":c:func:`PyType_Ready` automatically applies this flag to :ref:`static types "
"<static-types>`."
msgstr ""
":c:func:`PyType_Ready` 自動將此旗標應用於 :ref:`static 型別 <static-types>`。"

#: ../../c-api/typeobj.rst:1203
#, fuzzy
msgid "This flag is not inherited."
msgstr "此旗標不會被繼承。"

#: ../../c-api/typeobj.rst:1209
#, fuzzy
msgid ""
"Disallow creating instances of the type: set :c:member:`~PyTypeObject."
"tp_new` to NULL and don't create the ``__new__`` key in the type dictionary."
msgstr ""
"不允許建立型別的實例：將 :c:member:`~PyTypeObject.tp_new` 設定為 NULL 並且不"
"要在型別字典中建立 ``__new__`` 鍵。"

#: ../../c-api/typeobj.rst:1213
#, fuzzy
msgid ""
"The flag must be set before creating the type, not after. For example, it "
"must be set before :c:func:`PyType_Ready` is called on the type."
msgstr ""
"旗標必須在建立型別之前設定，而不是之後。例如，它必須在 :c:func:"
"`PyType_Ready` 被呼叫之前設定。"

#: ../../c-api/typeobj.rst:1216
#, fuzzy
msgid ""
"The flag is set automatically on :ref:`static types <static-types>` if :c:"
"member:`~PyTypeObject.tp_base` is NULL or ``&PyBaseObject_Type`` and :c:"
"member:`~PyTypeObject.tp_new` is NULL."
msgstr ""
"如果:c:member:`~PyTypeObject.tp_base` 為 NULL 或 ``&PyBaseObject_Type`` 和:c:"
"member:`~PyTypeObject.tp_new`，則該旗標會自動設定為 :ref:`static types "
"<static-types>`一片空白。"

#: ../../c-api/typeobj.rst:1222
#, fuzzy
msgid ""
"This flag is not inherited. However, subclasses will not be instantiable "
"unless they provide a non-NULL :c:member:`~PyTypeObject.tp_new` (which is "
"only possible via the C API)."
msgstr ""
"此旗標不會被繼承。但是，子類別將不可實例化，除非它們提供非 NULL :c:member:"
"`~PyTypeObject.tp_new`（這只能通過 C API 實作）。"

#: ../../c-api/typeobj.rst:1229
#, fuzzy
msgid ""
"To disallow instantiating a class directly but allow instantiating its "
"subclasses (e.g. for an :term:`abstract base class`), do not use this flag. "
"Instead, make :c:member:`~PyTypeObject.tp_new` only succeed for subclasses."
msgstr ""
"要禁止直接實例化一個類但允許實例化它的子類別（例如 :term:`抽象基底類別`），請"
"不要使用此旗標。相反，使 :c:member:`~PyTypeObject.tp_new` 僅對子類別成功。"

#: ../../c-api/typeobj.rst:1240
#, fuzzy
msgid ""
"This bit indicates that instances of the class may match mapping patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Mapping`, and "
"unset when registering :class:`collections.abc.Sequence`."
msgstr ""
"此位指示類的實例在用作 :keyword:`match` 塊的主題時可能匹配映射模式。它在註冊"
"或子類別化 :class:`collections.abc.Mapping` 時自動設定，並在註冊 :class:"
"`collections.abc.Sequence` 時取消設定。"

#: ../../c-api/typeobj.rst:1247 ../../c-api/typeobj.rst:1269
#, fuzzy
msgid ""
":const:`Py_TPFLAGS_MAPPING` and :const:`Py_TPFLAGS_SEQUENCE` are mutually "
"exclusive; it is an error to enable both flags simultaneously."
msgstr ""
":const:`Py_TPFLAGS_MAPPING` 和 :const:`Py_TPFLAGS_SEQUENCE` 是互斥的；同時啟"
"用兩個旗標是錯誤的。"

#: ../../c-api/typeobj.rst:1252
#, fuzzy
msgid ""
"This flag is inherited by types that do not already set :const:"
"`Py_TPFLAGS_SEQUENCE`."
msgstr "此旗標由尚未設定的型別繼承 :const:`Py_TPFLAGS_SEQUENCE`。"

#: ../../c-api/typeobj.rst:1255 ../../c-api/typeobj.rst:1277
#, fuzzy
msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` -- 結構模式匹配：規範"

#: ../../c-api/typeobj.rst:1262
#, fuzzy
msgid ""
"This bit indicates that instances of the class may match sequence patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Sequence`, and "
"unset when registering :class:`collections.abc.Mapping`."
msgstr ""
"該位指示類的實例在用作 :keyword:`match` 塊的主題時可能匹配序列模式。它在註冊"
"或繼承 collections.abc.Sequence 時自動設定，並在註冊 collections.abc.Mapping "
"時取消設定。"

#: ../../c-api/typeobj.rst:1274
#, fuzzy
msgid ""
"This flag is inherited by types that do not already set :const:"
"`Py_TPFLAGS_MAPPING`."
msgstr "此旗標由尚未設定的型別繼承 :const:`Py_TPFLAGS_MAPPING`。"

#: ../../c-api/typeobj.rst:1284
#, fuzzy
msgid ""
"An optional pointer to a NUL-terminated C string giving the docstring for "
"this type object.  This is exposed as the :attr:`__doc__` attribute on the "
"type and instances of the type."
msgstr ""
"指向以 NUL 結尾的 C 字串的可選指標，給出此型別物件的文檔字串。這作為型別和型"
"別實例的 :attr:`__doc__` 屬性公開。"

#: ../../c-api/typeobj.rst:1290
#, fuzzy
msgid "This field is *not* inherited by subtypes."
msgstr "該欄位*不*由子型別繼承。"

#: ../../c-api/typeobj.rst:1295
#, fuzzy
msgid ""
"An optional pointer to a traversal function for the garbage collector.  This "
"is only used if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The "
"signature is::"
msgstr ""
"指向垃圾收集器遍歷函式的可選指標。這僅在設定了 Py_TPFLAGS_HAVE_GC 旗標位時使"
"用。簽名是：："

#: ../../c-api/typeobj.rst:1300 ../../c-api/typeobj.rst:1420
#, fuzzy
msgid ""
"More information about Python's garbage collection scheme can be found in "
"section :ref:`supporting-cycle-detection`."
msgstr ""
"有關 Python 垃圾收集方案的更多資訊，請參閱 :ref:`supporting-cycle-detection` "
"部分。"

#: ../../c-api/typeobj.rst:1303
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` pointer is used by the garbage "
"collector to detect reference cycles. A typical implementation of a :c:"
"member:`~PyTypeObject.tp_traverse` function simply calls :c:func:`Py_VISIT` "
"on each of the instance's members that are Python objects that the instance "
"owns. For example, this is function :c:func:`local_traverse` from the :mod:"
"`_thread` extension module::"
msgstr ""
"垃圾收集器使用 :c:member:`~PyTypeObject.tp_traverse` 指標來檢測引用循環。 :c:"
"member:`~PyTypeObject.tp_traverse` 函式的典型實作只是簡單地呼叫 :c:func:"
"`Py_VISIT` 在每個實例的成員上，這些成員是實例擁有的 Python 物件。例如，這是來"
"自 :mod:`_thread` 擴充模組的函式 :c:func:`local_traverse`::"

#: ../../c-api/typeobj.rst:1318
#, fuzzy
msgid ""
"Note that :c:func:`Py_VISIT` is called only on those members that can "
"participate in reference cycles.  Although there is also a ``self->key`` "
"member, it can only be ``NULL`` or a Python string and therefore cannot be "
"part of a reference cycle."
msgstr ""
"請注意 :c:func:`Py_VISIT` 僅在那些可以參與引用循環的成員上呼叫。雖然還有一個 "
"``self->key`` 成員，但它只能是 ``NULL`` 或 Python 字串，因此不能成為引用循環"
"的一部分。"

#: ../../c-api/typeobj.rst:1322
#, fuzzy
msgid ""
"On the other hand, even if you know a member can never be part of a cycle, "
"as a debugging aid you may want to visit it anyway just so the :mod:`gc` "
"module's :func:`~gc.get_referents` function will include it."
msgstr ""
"另一方面，即使您知道某個成員永遠不會成為循環的一部分，作為除錯輔助工具，您可"
"能仍想訪問它，只是 :mod:`gc` 模組的 :func:`~gc.get_referents` 函式將包括它。"

#: ../../c-api/typeobj.rst:1327
#, fuzzy
msgid ""
"When implementing :c:member:`~PyTypeObject.tp_traverse`, only the members "
"that the instance *owns* (by having :term:`strong references <strong "
"reference>` to them) must be visited. For instance, if an object supports "
"weak references via the :c:member:`~PyTypeObject.tp_weaklist` slot, the "
"pointer supporting the linked list (what *tp_weaklist* points to) must "
"**not** be visited as the instance does not directly own the weak references "
"to itself (the weakreference list is there to support the weak reference "
"machinery, but the instance has no strong reference to the elements inside "
"it, as they are allowed to be removed even if the instance is still alive)."
msgstr ""
"實施:c:member:`~PyTypeObject.tp_traverse` 時，必須只訪問實例*擁有*的成員（通"
"過對它們進行強引用<strong reference>`）。例如，如果一個物件通過 :c:member:"
"`~PyTypeObject.tp_weaklist` 槽支援弱引用，則支援鍊錶的指標（*tp_weaklist* 指"
"向的內容）必須**不**像實例那樣被訪問不直接擁有對自身的弱引用（弱引用列表用於"
"支援弱引用機制，但實例沒有對其內部元素的強引用，因為即使實例仍然存在，也允許"
"刪除它們）。"

#: ../../c-api/typeobj.rst:1338
#, fuzzy
msgid ""
"Note that :c:func:`Py_VISIT` requires the *visit* and *arg* parameters to :c:"
"func:`local_traverse` to have these specific names; don't name them just "
"anything."
msgstr ""
"請注意 :c:func:`Py_VISIT` 要求 :c:func:`local_traverse` 的 *visit* 和 *arg* "
"參數具有這些特定名稱；不要隨意命名它們。"

#: ../../c-api/typeobj.rst:1342
#, fuzzy
msgid ""
"Instances of :ref:`heap-allocated types <heap-types>` hold a reference to "
"their type. Their traversal function must therefore either visit :c:func:"
"`Py_TYPE(self) <Py_TYPE>`, or delegate this responsibility by calling "
"``tp_traverse`` of another heap-allocated type (such as a heap-allocated "
"superclass). If they do not, the type object may not be garbage-collected."
msgstr ""
":ref:`heap-allocated types <heap-types>` 的實例持有對其型別的引用。因此，它們"
"的遍歷函式必須訪問 :c:func:`Py_TYPE(self) <Py_TYPE>`，或者通過呼叫另一個堆分"
"配型別（例如堆分配超類）的``tp_traverse`` 來委派此職責。如果不這樣做，則型別"
"物件可能不會被垃圾回收。"

#: ../../c-api/typeobj.rst:1351
#, fuzzy
msgid ""
"Heap-allocated types are expected to visit ``Py_TYPE(self)`` in "
"``tp_traverse``.  In earlier versions of Python, due to `bug 40217 <https://"
"bugs.python.org/issue40217>`_, doing this may lead to crashes in subclasses."
msgstr ""
"堆分配型別預計會在 ``tp_traverse`` 中訪問 ``Py_TYPE(self)``。在較早版本的 "
"Python 中，由於 `bug 40217 <https://bugs.python.org/issue40217>`_，這樣做可能"
"會導致子類別崩潰。"

#: ../../c-api/typeobj.rst:1360
#, fuzzy
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_clear` and the :const:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:"
"member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"該欄位由子型別與 :c:member:`~PyTypeObject.tp_clear` 和 :const:"
"`Py_TPFLAGS_HAVE_GC` 旗標位一起繼承：旗標位、:c:member:`~PyTypeObject."
"tp_traverse` 和 :c: member:`~PyTypeObject.tp_clear`如果在子型別中全為零，則都"
"是從基型別繼承的。"

#: ../../c-api/typeobj.rst:1368
#, fuzzy
msgid ""
"An optional pointer to a clear function for the garbage collector. This is "
"only used if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The signature "
"is::"
msgstr ""
"指向垃圾收集器清除函式的可選指標。這僅在設定了 Py_TPFLAGS_HAVE_GC 旗標位時使"
"用。簽名是：："

#: ../../c-api/typeobj.rst:1373
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_clear` member function is used to break "
"reference cycles in cyclic garbage detected by the garbage collector.  Taken "
"together, all :c:member:`~PyTypeObject.tp_clear` functions in the system "
"must combine to break all reference cycles.  This is subtle, and if in any "
"doubt supply a :c:member:`~PyTypeObject.tp_clear` function.  For example, "
"the tuple type does not implement a :c:member:`~PyTypeObject.tp_clear` "
"function, because it's possible to prove that no reference cycle can be "
"composed entirely of tuples. Therefore the :c:member:`~PyTypeObject."
"tp_clear` functions of other types must be sufficient to break any cycle "
"containing a tuple.  This isn't immediately obvious, and there's rarely a "
"good reason to avoid implementing :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
":c:member:`~PyTypeObject.tp_clear` 成員函式用於中斷垃圾收集器檢測到的循環垃圾"
"中的引用循環。總而言之，系統中的所有 :c:member:`~PyTypeObject.tp_clear` 函式"
"必須結合起來才能打破所有引用循環。這很微妙，如果有任何疑問，請提供一個 :c:"
"member:`~PyTypeObject.tp_clear` 函式。例如，元組型別沒有實作 :c:member:"
"`~PyTypeObject.tp_clear` 函式，因為可以證明沒有引用循環可以完全由元組組成。因"
"此，其他型別的 :c:member:`~PyTypeObject.tp_clear` 函式必須足以打破任何包含元"
"組的循環。這不是很明顯，而且很少有充分的理由避免實施 :c:member:"
"`~PyTypeObject.tp_clear`。"

#: ../../c-api/typeobj.rst:1383
#, fuzzy
msgid ""
"Implementations of :c:member:`~PyTypeObject.tp_clear` should drop the "
"instance's references to those of its members that may be Python objects, "
"and set its pointers to those members to ``NULL``, as in the following "
"example::"
msgstr ""
":c:member:`~PyTypeObject.tp_clear` 的實作應該刪除實例對其可能是 Python 物件的"
"成員的引用，並將其指向這些成員的指標設定為``NULL``，如下例所示："

#: ../../c-api/typeobj.rst:1397
#, fuzzy
msgid ""
"The :c:func:`Py_CLEAR` macro should be used, because clearing references is "
"delicate:  the reference to the contained object must not be decremented "
"until after the pointer to the contained object is set to ``NULL``.  This is "
"because decrementing the reference count may cause the contained object to "
"become trash, triggering a chain of reclamation activity that may include "
"invoking arbitrary Python code (due to finalizers, or weakref callbacks, "
"associated with the contained object). If it's possible for such code to "
"reference *self* again, it's important that the pointer to the contained "
"object be ``NULL`` at that time, so that *self* knows the contained object "
"can no longer be used.  The :c:func:`Py_CLEAR` macro performs the operations "
"in a safe order."
msgstr ""
":c:func:`Py_CLEAR` 巨集應該被使用，因為清除引用是微妙的：在指向包含物件的指標"
"被設定為 ``NULL`` 之前，對包含物件的引用不能遞減。這是因為減少引用計數可能會"
"導致包含的對像變成垃圾，從而觸發回收活動鏈，其中可能包括呼叫任意 Python 程式"
"碼（由於與包含的物件相關聯的終結器或弱引用回呼）。如果這樣的程式碼有可能再次"
"引用 *self*，重要的是指向包含物件的指標此時為 ``NULL`` ，這樣 *self* 就知道不"
"能再使用包含的物件。 :c:func:`Py_CLEAR` 巨集以安全順序執行操作。"

#: ../../c-api/typeobj.rst:1408
#, fuzzy
msgid ""
"Note that :c:member:`~PyTypeObject.tp_clear` is not *always* called before "
"an instance is deallocated. For example, when reference counting is enough "
"to determine that an object is no longer used, the cyclic garbage collector "
"is not involved and :c:member:`~PyTypeObject.tp_dealloc` is called directly."
msgstr ""
"請注意 :c:member:`~PyTypeObject.tp_clear` 並非*總是*在釋放實例之前呼叫。例"
"如，當引用計數足以確定一個對像不再被使用時，循環垃圾收集器不參與，直接呼叫:c:"
"member:`~PyTypeObject.tp_dealloc`。"

#: ../../c-api/typeobj.rst:1414
#, fuzzy
msgid ""
"Because the goal of :c:member:`~PyTypeObject.tp_clear` functions is to break "
"reference cycles, it's not necessary to clear contained objects like Python "
"strings or Python integers, which can't participate in reference cycles. On "
"the other hand, it may be convenient to clear all contained Python objects, "
"and write the type's :c:member:`~PyTypeObject.tp_dealloc` function to "
"invoke :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
"因為 :c:member:`~PyTypeObject.tp_clear` 函式的目標是打破引用循環，所以沒有必"
"要清除包含的物件，如 Python 字串或 Python 整數，它們不能參與引用循環。另一方"
"面，清除所有包含的 Python 物件並編寫型別的 :c:member:`~PyTypeObject."
"tp_dealloc` 函式來呼叫 :c:member:`~PyTypeObject.tp_clear` 可能很方便。"

#: ../../c-api/typeobj.rst:1427
#, fuzzy
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_traverse` and the :const:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:"
"member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"該欄位由子型別與 :c:member:`~PyTypeObject.tp_traverse` 和 :const:"
"`Py_TPFLAGS_HAVE_GC` 旗標位一起繼承：旗標位、:c:member:`~PyTypeObject."
"tp_traverse` 和 :c: member:`~PyTypeObject.tp_clear`如果在子型別中全為零，則都"
"是從基型別繼承的。"

#: ../../c-api/typeobj.rst:1435
#, fuzzy
msgid ""
"An optional pointer to the rich comparison function, whose signature is::"
msgstr "指向富比較函式的可選指標，其簽名為："

#: ../../c-api/typeobj.rst:1439
#, fuzzy
msgid ""
"The first parameter is guaranteed to be an instance of the type that is "
"defined by :c:type:`PyTypeObject`."
msgstr "第一個參數保證是 :c:type:`PyTypeObject` 定義的型別的實例。"

#: ../../c-api/typeobj.rst:1442
#, fuzzy
msgid ""
"The function should return the result of the comparison (usually ``Py_True`` "
"or ``Py_False``).  If the comparison is undefined, it must return "
"``Py_NotImplemented``, if another error occurred it must return ``NULL`` and "
"set an exception condition."
msgstr ""
"該函式應該回傳比較的結果（通常是 ``Py_True`` 或 ``Py_False``）。如果比較未定"
"義，則必須回傳 Py_NotImplemented，如果發生另一個錯誤，則必須回傳 NULL 並設定"
"例外條件。"

#: ../../c-api/typeobj.rst:1447
#, fuzzy
msgid ""
"The following constants are defined to be used as the third argument for :c:"
"member:`~PyTypeObject.tp_richcompare` and for :c:func:`PyObject_RichCompare`:"
msgstr ""
"以下常數被定義為用作 :c:member:`~PyTypeObject.tp_richcompare` 和 :c:func:"
"`PyObject_RichCompare` 的第三個參數："

#: ../../c-api/typeobj.rst:1451
msgid "Constant"
msgstr "常數"

#: ../../c-api/typeobj.rst:1451
#, fuzzy
msgid "Comparison"
msgstr "比較"

#: ../../c-api/typeobj.rst:1453
msgid ":const:`Py_LT`"
msgstr ":const:`Py_LT`"

#: ../../c-api/typeobj.rst:1453
msgid "``<``"
msgstr "``<``"

#: ../../c-api/typeobj.rst:1455
msgid ":const:`Py_LE`"
msgstr ":const:`Py_LE`"

#: ../../c-api/typeobj.rst:1455
msgid "``<=``"
msgstr "``<=``"

#: ../../c-api/typeobj.rst:1457
msgid ":const:`Py_EQ`"
msgstr ":const:`Py_EQ`"

#: ../../c-api/typeobj.rst:1457
msgid "``==``"
msgstr "``==``"

#: ../../c-api/typeobj.rst:1459
msgid ":const:`Py_NE`"
msgstr ":const:`Py_NE`"

#: ../../c-api/typeobj.rst:1459
msgid "``!=``"
msgstr "``!=``"

#: ../../c-api/typeobj.rst:1461
msgid ":const:`Py_GT`"
msgstr ":const:`Py_GT`"

#: ../../c-api/typeobj.rst:1461
msgid "``>``"
msgstr "``>``"

#: ../../c-api/typeobj.rst:1463
msgid ":const:`Py_GE`"
msgstr ":const:`Py_GE`"

#: ../../c-api/typeobj.rst:1463
msgid "``>=``"
msgstr "``>=``"

#: ../../c-api/typeobj.rst:1466
#, fuzzy
msgid ""
"The following macro is defined to ease writing rich comparison functions:"
msgstr "定義了以下巨集以簡化編寫豐富的比較函式："

#: ../../c-api/typeobj.rst:1470
#, fuzzy
msgid ""
"Return ``Py_True`` or ``Py_False`` from the function, depending on the "
"result of a comparison. VAL_A and VAL_B must be orderable by C comparison "
"operators (for example, they may be C ints or floats). The third argument "
"specifies the requested operation, as for :c:func:`PyObject_RichCompare`."
msgstr ""
"根據比較的結果，從函式回傳``Py_True`` 或``Py_False``。 VAL_A 和 VAL_B 必須可"
"由 C 比較運算符排序（例如，它們可以是 C 整數或浮點數）。第三個參數指定請求的"
"操作，如 :c:func:`PyObject_RichCompare`。"

#: ../../c-api/typeobj.rst:1476
#, fuzzy
msgid "The return value's reference count is properly incremented."
msgstr "回傳值的引用計數已正確遞增。"

#: ../../c-api/typeobj.rst:1478
#, fuzzy
msgid "On error, sets an exception and returns ``NULL`` from the function."
msgstr "出錯時，設定例外並從函式回傳 ``NULL`` 。"

#: ../../c-api/typeobj.rst:1486
#, fuzzy
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_hash`: a subtype inherits :c:member:`~PyTypeObject.tp_richcompare` and :c:"
"member:`~PyTypeObject.tp_hash` when the subtype's :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` are both ``NULL``."
msgstr ""
"此欄位由子型別與 :c:member:`~PyTypeObject.tp_hash` 一起繼承：當子型別為： c:"
"member:`~PyTypeObject.tp_richcompare` 和 :c:member:`~PyTypeObject.tp_hash` 都"
"是 ``NULL``。"

#: ../../c-api/typeobj.rst:1493
#, fuzzy
msgid ""
":c:type:`PyBaseObject_Type` provides a :attr:`tp_richcompare` "
"implementation, which may be inherited.  However, if only :attr:`tp_hash` is "
"defined, not even the inherited function is used and instances of the type "
"will not be able to participate in any comparisons."
msgstr ""
":c:type:`PyBaseObject_Type` 提供了一個 :attr:`tp_richcompare` 實作，它可以被"
"繼承。但是，如果只定義了 :attr:`tp_hash`，則即使繼承的函式也不會被使用，並且"
"該型別的實例將無法參與任何比較。"

#: ../../c-api/typeobj.rst:1502
#, fuzzy
msgid ""
"If the instances of this type are weakly referenceable, this field is "
"greater than zero and contains the offset in the instance structure of the "
"weak reference list head (ignoring the GC header, if present); this offset "
"is used by :c:func:`PyObject_ClearWeakRefs` and the ``PyWeakref_*`` "
"functions.  The instance structure needs to include a field of type :c:expr:"
"`PyObject*` which is initialized to ``NULL``."
msgstr ""
"如果該型別的實例是弱引用的，則該欄位大於零並且包含弱引用列表頭的實例結構中的"
"偏移量（忽略 GC 頭，如果存在）；此偏移量由 :c:func:`PyObject_ClearWeakRefs` "
"和 ``PyWeakref_*`` 函式使用。實例結構需要包含一個型別為 :c:expr:`PyObject*` "
"的欄位，它被初始化為 ``NULL``。"

#: ../../c-api/typeobj.rst:1509
#, fuzzy
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_weaklist`; that "
"is the list head for weak references to the type object itself."
msgstr ""
"不要將此欄位與 :c:member:`~PyTypeObject.tp_weaklist` 混淆；這是對型別物件本身"
"的弱引用的列表頭。"

#: ../../c-api/typeobj.rst:1514
#, fuzzy
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype uses a "
"different weak reference list head than the base type.  Since the list head "
"is always found via :c:member:`~PyTypeObject.tp_weaklistoffset`, this should "
"not be a problem."
msgstr ""
"該欄位由子型別繼承，但請參閱下面列出的規則。子型別可以覆蓋此偏移量；這意味著"
"子型別使用與基型別不同的弱引用列表頭。由於列表頭總是通過 :c:member:"
"`~PyTypeObject.tp_weaklistoffset` 找到的，所以這應該不是問題。"

#: ../../c-api/typeobj.rst:1519
#, fuzzy
msgid ""
"When a type defined by a class statement has no :attr:`~object.__slots__` "
"declaration, and none of its base types are weakly referenceable, the type "
"is made weakly referenceable by adding a weak reference list head slot to "
"the instance layout and setting the :c:member:`~PyTypeObject."
"tp_weaklistoffset` of that slot's offset."
msgstr ""
"當類語句定義的型別沒有 :attr:`~object.__slots__` 聲明，並且它的基型別都不是弱"
"引用時，通過向實例佈局新增弱引用列表頭槽來使該型別弱引用設定該插槽偏移量的 :"
"c:member:`~PyTypeObject.tp_weaklistoffset`。"

#: ../../c-api/typeobj.rst:1524
#, fuzzy
msgid ""
"When a type's :attr:`__slots__` declaration contains a slot named :attr:"
"`__weakref__`, that slot becomes the weak reference list head for instances "
"of the type, and the slot's offset is stored in the type's :c:member:"
"`~PyTypeObject.tp_weaklistoffset`."
msgstr ""
"當一個型別的 :attr:`__slots__` 聲明包含一個名為 :attr:`__weakref__` 的插槽"
"時，該插槽成為該型別實例的弱引用列表頭，並且該插槽的偏移量儲存在該型別的 :c:"
"member:` ~PyTypeObject.tp_weaklistoffset`。"

#: ../../c-api/typeobj.rst:1529
#, fuzzy
msgid ""
"When a type's :attr:`__slots__` declaration does not contain a slot named :"
"attr:`__weakref__`, the type inherits its :c:member:`~PyTypeObject."
"tp_weaklistoffset` from its base type."
msgstr ""
"當型別的 :attr:`__slots__` 聲明不包含名為 :attr:`__weakref__` 的槽時，該型別"
"從其基型別繼承其 :c:member:`~PyTypeObject.tp_weaklistoffset`。"

#: ../../c-api/typeobj.rst:1536
#, fuzzy
msgid ""
"An optional pointer to a function that returns an :term:`iterator` for the "
"object.  Its presence normally signals that the instances of this type are :"
"term:`iterable` (although sequences may be iterable without this function)."
msgstr ""
"指向函式的可選指標，該函式回傳物件的疊代器。它的存在通常表明這種型別的實例"
"是 :term:`iterable`（儘管序列在沒有這個函式的情況下可能是可疊代的）。"

#: ../../c-api/typeobj.rst:1540
#, fuzzy
msgid "This function has the same signature as :c:func:`PyObject_GetIter`::"
msgstr "此函式與:c:func:`PyObject_GetIter`:: 具有相同的簽名："

#: ../../c-api/typeobj.rst:1551
#, fuzzy
msgid ""
"An optional pointer to a function that returns the next item in an :term:"
"`iterator`. The signature is::"
msgstr "指向函式的可選指標，該函式回傳 :term:`iterator` 中的下一項。簽名是：："

#: ../../c-api/typeobj.rst:1556
#, fuzzy
msgid ""
"When the iterator is exhausted, it must return ``NULL``; a :exc:"
"`StopIteration` exception may or may not be set.  When another error occurs, "
"it must return ``NULL`` too.  Its presence signals that the instances of "
"this type are iterators."
msgstr ""
"當疊代器耗盡時，它必須回傳 ``NULL`` ；一個 :exc:`StopIteration` 例外可能會或"
"可能不會被設定。當另一個錯誤發生時，它也必須回傳 ``NULL`` 。它的存在表明這種"
"型別的實例是疊代器。"

#: ../../c-api/typeobj.rst:1561
#, fuzzy
msgid ""
"Iterator types should also define the :c:member:`~PyTypeObject.tp_iter` "
"function, and that function should return the iterator instance itself (not "
"a new iterator instance)."
msgstr ""
"疊代器型別還應該定義 :c:member:`~PyTypeObject.tp_iter` 函式，並且該函式應該回"
"傳疊代器實例本身（而不是新的疊代器實例）。"

#: ../../c-api/typeobj.rst:1565
#, fuzzy
msgid "This function has the same signature as :c:func:`PyIter_Next`."
msgstr "此函式與 :c:func:`PyIter_Next` 具有相同的簽名。"

#: ../../c-api/typeobj.rst:1574
#, fuzzy
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMethodDef` structures, declaring regular methods of this type."
msgstr ""
"一個可選的指標，指向靜態的以 ``NULL`` 結尾的 PyMethodDef 結構數組，聲明這種型"
"別的常規方法。"

#: ../../c-api/typeobj.rst:1577
#, fuzzy
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a method descriptor."
msgstr ""
"對於數組中的每個條目，都會將一個條目新增到型別的字典（請參閱下面的 :c:member:"
"`~PyTypeObject.tp_dict`），其中包含一個方法描述器。"

#: ../../c-api/typeobj.rst:1582
#, fuzzy
msgid ""
"This field is not inherited by subtypes (methods are inherited through a "
"different mechanism)."
msgstr "該欄位不被子型別繼承（方法通過不同的機制繼承）。"

#: ../../c-api/typeobj.rst:1588
#, fuzzy
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMemberDef` structures, declaring regular data members (fields or slots) "
"of instances of this type."
msgstr ""
"指向 PyMemberDef 結構的靜態 ``NULL`` 終止數組的可選指標，聲明此型別實例的常規"
"資料成員（欄位或槽）。"

#: ../../c-api/typeobj.rst:1592
#, fuzzy
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a member descriptor."
msgstr ""
"對於數組中的每個條目，都會將一個條目新增到型別的字典中（請參閱下面的 :c:"
"member:`~PyTypeObject.tp_dict`），其中包含一個成員描述器。"

#: ../../c-api/typeobj.rst:1597
#, fuzzy
msgid ""
"This field is not inherited by subtypes (members are inherited through a "
"different mechanism)."
msgstr "該欄位不被子型別繼承（成員通過不同的機制繼承）。"

#: ../../c-api/typeobj.rst:1603
#, fuzzy
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyGetSetDef` structures, declaring computed attributes of instances of this "
"type."
msgstr ""
"指向靜態 PyGetSetDef 結構的以``NULL`` 結尾的靜態數組的可選指標，聲明此型別實"
"例的計算屬性。"

#: ../../c-api/typeobj.rst:1606
#, fuzzy
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a getset descriptor."
msgstr ""
"對於數組中的每個條目，都會將一個條目新增到型別的字典中（請參閱下面的 :c:"
"member:`~PyTypeObject.tp_dict`），其中包含一個 getset 描述器。"

#: ../../c-api/typeobj.rst:1611
#, fuzzy
msgid ""
"This field is not inherited by subtypes (computed attributes are inherited "
"through a different mechanism)."
msgstr "該欄位不被子型別繼承（計算屬性通過不同的機制繼承）。"

#: ../../c-api/typeobj.rst:1617
#, fuzzy
msgid ""
"An optional pointer to a base type from which type properties are "
"inherited.  At this level, only single inheritance is supported; multiple "
"inheritance require dynamically creating a type object by calling the "
"metatype."
msgstr ""
"指向從中繼承型別屬性的基型別的可選指標。在此級別，僅支援單繼承；多重繼承需要"
"通過呼叫元型別動態建立型別物件。"

#: ../../c-api/typeobj.rst:1625
#, fuzzy
msgid ""
"Slot initialization is subject to the rules of initializing globals. C99 "
"requires the initializers to be \"address constants\".  Function designators "
"like :c:func:`PyType_GenericNew`, with implicit conversion to a pointer, are "
"valid C99 address constants."
msgstr ""
"插槽初始化受初始化全局變數的規則約束。 C99 要求初始化器是“地址常數”。像 :c:"
"func:`PyType_GenericNew` 這樣的函式指示符，隱式轉換為指標，是有效的 C99 地址"
"常數。"

#: ../../c-api/typeobj.rst:1630
#, fuzzy
msgid ""
"However, the unary '&' operator applied to a non-static variable like :c:"
"func:`PyBaseObject_Type` is not required to produce an address constant.  "
"Compilers may support this (gcc does), MSVC does not. Both compilers are "
"strictly standard conforming in this particular behavior."
msgstr ""
"但是，應用於非靜態變數（如 PyBaseObject_Type）的一元 ``&``運算符不需要生成地"
"址常數。編譯器可能支援這個（gcc 支援），MSVC 不支援。兩種編譯器都嚴格符合此特"
"定行為的標準。"

#: ../../c-api/typeobj.rst:1636
#, fuzzy
msgid ""
"Consequently, :c:member:`~PyTypeObject.tp_base` should be set in the "
"extension module's init function."
msgstr ""
"因此，應該在擴充模組的 init 函式中設定 :c:member:`~PyTypeObject.tp_base`。"

#: ../../c-api/typeobj.rst:1641
#, fuzzy
msgid "This field is not inherited by subtypes (obviously)."
msgstr "該欄位不會被子型別繼承（很明顯）。"

#: ../../c-api/typeobj.rst:1645
#, fuzzy
msgid ""
"This field defaults to ``&PyBaseObject_Type`` (which to Python programmers "
"is known as the type :class:`object`)."
msgstr ""
"此欄位預設為 ``&PyBaseObject_Type``（Python 程式員稱為型別 :class:"
"`object`）。"

#: ../../c-api/typeobj.rst:1651
#, fuzzy
msgid "The type's dictionary is stored here by :c:func:`PyType_Ready`."
msgstr "型別的字典由 :c:func:`PyType_Ready` 儲存在這裡。"

#: ../../c-api/typeobj.rst:1653
#, fuzzy
msgid ""
"This field should normally be initialized to ``NULL`` before PyType_Ready is "
"called; it may also be initialized to a dictionary containing initial "
"attributes for the type.  Once :c:func:`PyType_Ready` has initialized the "
"type, extra attributes for the type may be added to this dictionary only if "
"they don't correspond to overloaded operations (like :meth:`__add__`)."
msgstr ""
"在呼叫 PyType_Ready 之前，通常應將此欄位初始化為 ``NULL`` ；它也可以被初始化"
"為一個包含該型別初始屬性的字典。一旦 :c:func:`PyType_Ready` 初始化了型別，只"
"有當它們不對應於重載操作（如 :meth:`__add__`）時，才可以將型別的額外屬性新增"
"到此字典中。"

#: ../../c-api/typeobj.rst:1661
#, fuzzy
msgid ""
"This field is not inherited by subtypes (though the attributes defined in "
"here are inherited through a different mechanism)."
msgstr "該欄位不被子型別繼承（儘管此處定義的屬性是通過不同的機制繼承的）。"

#: ../../c-api/typeobj.rst:1666
#, fuzzy
msgid ""
"If this field is ``NULL``, :c:func:`PyType_Ready` will assign a new "
"dictionary to it."
msgstr "如果此欄位為 ``NULL`` ，PyType_Ready 將為其分配一個新字典。"

#: ../../c-api/typeobj.rst:1671
#, fuzzy
msgid ""
"It is not safe to use :c:func:`PyDict_SetItem` on or otherwise modify :c:"
"member:`~PyTypeObject.tp_dict` with the dictionary C-API."
msgstr "使用字典 C-API 或以其他方式修改 :c:func:`PyDict_SetItem` 是不安全的。"

#: ../../c-api/typeobj.rst:1677
#, fuzzy
msgid "An optional pointer to a \"descriptor get\" function."
msgstr "指向“描述器獲取”函式的可選指標。"

#: ../../c-api/typeobj.rst:1679 ../../c-api/typeobj.rst:1695
#: ../../c-api/typeobj.rst:1770 ../../c-api/typeobj.rst:1800
#: ../../c-api/typeobj.rst:1824
#, fuzzy
msgid "The function signature is::"
msgstr "函式簽名是："

#: ../../c-api/typeobj.rst:1692
#, fuzzy
msgid ""
"An optional pointer to a function for setting and deleting a descriptor's "
"value."
msgstr "指向用於設定和刪除描述器值的函式的可選指標。"

#: ../../c-api/typeobj.rst:1699
#, fuzzy
msgid "The *value* argument is set to ``NULL`` to delete the value."
msgstr "*value* 參數設定為 ``NULL`` 以刪除該值。"

#: ../../c-api/typeobj.rst:1710
#, fuzzy
msgid ""
"If the instances of this type have a dictionary containing instance "
"variables, this field is non-zero and contains the offset in the instances "
"of the type of the instance variable dictionary; this offset is used by :c:"
"func:`PyObject_GenericGetAttr`."
msgstr ""
"如果該型別的實例有一個包含實例變數的字典，則該欄位不為零，包含該實例變數字典"
"的型別在實例中的偏移量；此偏移量由 :c:func:`PyObject_GenericGetAttr` 使用。"

#: ../../c-api/typeobj.rst:1715
#, fuzzy
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_dict`; that is "
"the dictionary for attributes of the type object itself."
msgstr ""
"不要將此欄位與 :c:member:`~PyTypeObject.tp_dict` 混淆；那是型別物件本身的屬性"
"的字典。"

#: ../../c-api/typeobj.rst:1718
#, fuzzy
msgid ""
"If the value of this field is greater than zero, it specifies the offset "
"from the start of the instance structure.  If the value is less than zero, "
"it specifies the offset from the *end* of the instance structure.  A "
"negative offset is more expensive to use, and should only be used when the "
"instance structure contains a variable-length part.  This is used for "
"example to add an instance variable dictionary to subtypes of :class:`str` "
"or :class:`tuple`. Note that the :c:member:`~PyTypeObject.tp_basicsize` "
"field should account for the dictionary added to the end in that case, even "
"though the dictionary is not included in the basic object layout.  On a "
"system with a pointer size of 4 bytes, :c:member:`~PyTypeObject."
"tp_dictoffset` should be set to ``-4`` to indicate that the dictionary is at "
"the very end of the structure."
msgstr ""
"如果此欄位的值大於零，則它指定從實例結構開始的偏移量。如果該值小於零，則它指"
"定從實例結構的 *end* 開始的偏移量。負偏移量的使用成本更高，僅當實例結構包含可"
"變長度部分時才應使用。例如，這用於將實例變數字典新增到 :class:`str` 或 :"
"class:`tuple` 的子型別。請注意，在這種情況下，:c:member:`~PyTypeObject."
"tp_basicsize` 欄位應說明新增到末尾的字典，即使該字典未包含在基本物件佈局中。"
"在指標大小為 4 位元組的系統上，:c:member:`~PyTypeObject.tp_dictoffset` 應設定"
"為 ``-4`` 以指示字典位於結構的末尾。"

#: ../../c-api/typeobj.rst:1730
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_dictoffset` should be regarded as write-"
"only. To get the pointer to the dictionary call :c:func:"
"`PyObject_GenericGetDict`. Calling :c:func:`PyObject_GenericGetDict` may "
"need to allocate memory for the dictionary, so it is may be more efficient "
"to call :c:func:`PyObject_GetAttr` when accessing an attribute on the object."
msgstr ""
":c:member:`~PyTypeObject.tp_dictoffset` 應該被視為只寫。要獲取指向字典呼叫的"
"指標 :c:func:`PyObject_GenericGetDict`。呼叫:c:func:"
"`PyObject_GenericGetDict` 可能需要為字典分配記憶體，因此在訪問物件的屬性時呼"
"叫:c:func:`PyObject_GetAttr` 可能更有效。"

#: ../../c-api/typeobj.rst:1738
#, fuzzy
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype instances "
"store the dictionary at a difference offset than the base type.  Since the "
"dictionary is always found via :c:member:`~PyTypeObject.tp_dictoffset`, this "
"should not be a problem."
msgstr ""
"該欄位由子型別繼承，但請參閱下面列出的規則。子型別可以覆蓋此偏移量；這意味著"
"子型別實例將字典儲存在與基型別不同的偏移量處。由於字典總是通過 :c:member:"
"`~PyTypeObject.tp_dictoffset` 找到，所以這應該不是問題。"

#: ../../c-api/typeobj.rst:1743
#, fuzzy
msgid ""
"When a type defined by a class statement has no :attr:`~object.__slots__` "
"declaration, and none of its base types has an instance variable dictionary, "
"a dictionary slot is added to the instance layout and the :c:member:"
"`~PyTypeObject.tp_dictoffset` is set to that slot's offset."
msgstr ""
"當類語句定義的型別沒有 :attr:`~object.__slots__` 聲明，並且其基型別都沒有實例"
"變數字典時，字典槽將新增到實例佈局和 :c:member: ~PyTypeObject.tp_dictoffset` "
"設定為該插槽的偏移量。"

#: ../../c-api/typeobj.rst:1748
#, fuzzy
msgid ""
"When a type defined by a class statement has a :attr:`__slots__` "
"declaration, the type inherits its :c:member:`~PyTypeObject.tp_dictoffset` "
"from its base type."
msgstr ""
"當類語句定義的型別具有 :attr:`__slots__` 聲明時，該型別從其基型別繼承其 :c:"
"member:`~PyTypeObject.tp_dictoffset`。"

#: ../../c-api/typeobj.rst:1751
#, fuzzy
msgid ""
"(Adding a slot named :attr:`~object.__dict__` to the :attr:`__slots__` "
"declaration does not have the expected effect, it just causes confusion.  "
"Maybe this should be added as a feature just like :attr:`__weakref__` "
"though.)"
msgstr ""
"（將名為 :attr:`~object.__dict__` 的插槽新增到 :attr:`__slots__` 聲明沒有預期"
"的效果，它只會引起混淆。也許這應該作為一個功能新增，就像 :attr:`__weakref__ `"
"雖然。）"

#: ../../c-api/typeobj.rst:1757
#, fuzzy
msgid ""
"This slot has no default.  For :ref:`static types <static-types>`, if the "
"field is ``NULL`` then no :attr:`__dict__` gets created for instances."
msgstr ""
"該插槽沒有預設值。對於 :ref:`static types <static-types>`，如果該欄位為 "
"``NULL``，則不會為實例建立 :attr:`__dict__`。"

#: ../../c-api/typeobj.rst:1763
#, fuzzy
msgid "An optional pointer to an instance initialization function."
msgstr "指向實例初始化函式的可選指標。"

#: ../../c-api/typeobj.rst:1765
#, fuzzy
msgid ""
"This function corresponds to the :meth:`__init__` method of classes.  Like :"
"meth:`__init__`, it is possible to create an instance without calling :meth:"
"`__init__`, and it is possible to reinitialize an instance by calling its :"
"meth:`__init__` method again."
msgstr ""
"這個函式對應類的 :meth:`__init__` 方法。像 :meth:`__init__` 一樣，可以在不呼"
"叫 :meth:`__init__` 的情況下建立一個實例，並且可以通過再次呼叫它的 :meth:"
"`__init__` 方法來重新初始化一個實例。"

#: ../../c-api/typeobj.rst:1774
#, fuzzy
msgid ""
"The self argument is the instance to be initialized; the *args* and *kwds* "
"arguments represent positional and keyword arguments of the call to :meth:"
"`__init__`."
msgstr ""
"self 參數是要初始化的實例； *args* 和 *kwds* 參數表示呼叫 :meth:`__init__` 的"
"位置參數和關鍵字參數。"

#: ../../c-api/typeobj.rst:1778
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_init` function, if not ``NULL``, is called "
"when an instance is created normally by calling its type, after the type's :"
"c:member:`~PyTypeObject.tp_new` function has returned an instance of the "
"type.  If the :c:member:`~PyTypeObject.tp_new` function returns an instance "
"of some other type that is not a subtype of the original type, no :c:member:"
"`~PyTypeObject.tp_init` function is called; if :c:member:`~PyTypeObject."
"tp_new` returns an instance of a subtype of the original type, the "
"subtype's :c:member:`~PyTypeObject.tp_init` is called."
msgstr ""
":c:member:`~PyTypeObject.tp_init` 函式，如果不是 ``NULL``，則在通過呼叫其型別"
"正常建立實例時，在型別的 :c:member:`~PyTypeObject.tp_new` 函式之後被呼叫已回"
"傳該型別的一個實例。如果 :c:member:`~PyTypeObject.tp_new` 函式回傳某個其他型"
"別的實例，該型別不是原始型別的子型別，則不會呼叫 :c:member:`~PyTypeObject."
"tp_init` 函式；如果 :c:member:`~PyTypeObject.tp_new` 回傳原始型別的子型別的實"
"例，則呼叫子型別的 :c:member:`~PyTypeObject.tp_init`。"

#: ../../c-api/typeobj.rst:1785
#, fuzzy
msgid "Returns ``0`` on success, ``-1`` and sets an exception on error."
msgstr "成功回傳 ``0``， ``-1``並在出錯時設定例外。"

#: ../../c-api/typeobj.rst:1793
#, fuzzy
msgid ""
"For :ref:`static types <static-types>` this field does not have a default."
msgstr "對於 :ref:`static types <static-types>` 此欄位沒有預設值。"

#: ../../c-api/typeobj.rst:1798
#, fuzzy
msgid "An optional pointer to an instance allocation function."
msgstr "指向實例分配函式的可選指標。"

#: ../../c-api/typeobj.rst:1806
#, fuzzy
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)."
msgstr "該欄位由靜態子型別繼承，但不由動態子型別（由類語句建立的子型別）繼承。"

#: ../../c-api/typeobj.rst:1811
#, fuzzy
msgid ""
"For dynamic subtypes, this field is always set to :c:func:"
"`PyType_GenericAlloc`, to force a standard heap allocation strategy."
msgstr ""
"對於動態子型別，此欄位始終設定為 :c:func:`PyType_GenericAlloc`，以強制執行標"
"準堆分配策略。"

#: ../../c-api/typeobj.rst:1815
#, fuzzy
msgid ""
"For static subtypes, :c:type:`PyBaseObject_Type` uses :c:func:"
"`PyType_GenericAlloc`.  That is the recommended value for all statically "
"defined types."
msgstr ""
"對於靜態子型別，:c:type:`PyBaseObject_Type` 使用:c:func:"
"`PyType_GenericAlloc`。這是所有靜態定義型別的推薦值。"

#: ../../c-api/typeobj.rst:1822
#, fuzzy
msgid "An optional pointer to an instance creation function."
msgstr "指向實例建立函式的可選指標。"

#: ../../c-api/typeobj.rst:1828
#, fuzzy
msgid ""
"The *subtype* argument is the type of the object being created; the *args* "
"and *kwds* arguments represent positional and keyword arguments of the call "
"to the type.  Note that *subtype* doesn't have to equal the type whose :c:"
"member:`~PyTypeObject.tp_new` function is called; it may be a subtype of "
"that type (but not an unrelated type)."
msgstr ""
"*subtype* 參數是正在建立的物件的型別； *args* 和 *kwds* 參數表示呼叫型別的位"
"置參數和關鍵字參數。請注意，*subtype* 不必等於其 :c:member:`~PyTypeObject."
"tp_new` 函式被呼叫的型別；它可能是該型別的子型別（但不是不相關的型別）。"

#: ../../c-api/typeobj.rst:1834
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_new` function should call ``subtype-"
">tp_alloc(subtype, nitems)`` to allocate space for the object, and then do "
"only as much further initialization as is absolutely necessary.  "
"Initialization that can safely be ignored or repeated should be placed in "
"the :c:member:`~PyTypeObject.tp_init` handler.  A good rule of thumb is that "
"for immutable types, all initialization should take place in :c:member:"
"`~PyTypeObject.tp_new`, while for mutable types, most initialization should "
"be deferred to :c:member:`~PyTypeObject.tp_init`."
msgstr ""
":c:member:`~PyTypeObject.tp_new` 函式應該呼叫 ``subtype->tp_alloc(subtype, "
"nitems)`` 來為物件分配空間，然後只做絕對必要的進一步初始化。可以安全地忽略或"
"重複的初始化應該放在 :c:member:`~PyTypeObject.tp_init` 處理程式中。一個好的經"
"驗法則是，對於不可變型別，所有初始化都應該在 :c:member:`~PyTypeObject."
"tp_new` 中進行，而對於可變型別，大多數初始化應該推遲到 :c:member:"
"`~PyTypeObject.tp_init `。"

#: ../../c-api/typeobj.rst:1842
#, fuzzy
msgid ""
"Set the :const:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag to disallow creating "
"instances of the type in Python."
msgstr ""
"設定 Py_TPFLAGS_DISALLOW_INSTANTIATION 旗標以禁止在 Python 中建立該型別的實"
"例。"

#: ../../c-api/typeobj.rst:1847
#, fuzzy
msgid ""
"This field is inherited by subtypes, except it is not inherited by :ref:"
"`static types <static-types>` whose :c:member:`~PyTypeObject.tp_base` is "
"``NULL`` or ``&PyBaseObject_Type``."
msgstr ""
"此欄位由子型別繼承，除了它不由 :ref:`static types <static-types>` 繼承，其 :"
"c:member:`~PyTypeObject.tp_base` 為 ``NULL`` 或 ``&PyBaseObject_Type``。"

#: ../../c-api/typeobj.rst:1853
#, fuzzy
msgid ""
"For :ref:`static types <static-types>` this field has no default. This means "
"if the slot is defined as ``NULL``, the type cannot be called to create new "
"instances; presumably there is some other way to create instances, like a "
"factory function."
msgstr ""
"對於 :ref:`static types <static-types>` 此欄位沒有預設值。這意味著如果插槽定"
"義為 ``NULL`` ，則無法呼叫該型別來建立新實例；大概還有其他一些方法來建立實"
"例，比如工廠函式。"

#: ../../c-api/typeobj.rst:1861
#, fuzzy
msgid ""
"An optional pointer to an instance deallocation function.  Its signature is::"
msgstr "指向實例釋放函式的可選指標。它的簽名是："

#: ../../c-api/typeobj.rst:1865
#, fuzzy
msgid ""
"An initializer that is compatible with this signature is :c:func:"
"`PyObject_Free`."
msgstr "與此簽名相容的初始化器是:c:func:`PyObject_Free`。"

#: ../../c-api/typeobj.rst:1869
#, fuzzy
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)"
msgstr "該欄位由靜態子型別繼承，但不由動態子型別（由類語句建立的子型別）繼承"

#: ../../c-api/typeobj.rst:1874
#, fuzzy
msgid ""
"In dynamic subtypes, this field is set to a deallocator suitable to match :c:"
"func:`PyType_GenericAlloc` and the value of the :const:`Py_TPFLAGS_HAVE_GC` "
"flag bit."
msgstr ""
"在動態子型別中，此欄位設定為適合匹配 PyType_GenericAlloc 和 "
"Py_TPFLAGS_HAVE_GC 旗標位的值的釋放器。"

#: ../../c-api/typeobj.rst:1878
#, fuzzy
msgid "For static subtypes, :c:type:`PyBaseObject_Type` uses PyObject_Del."
msgstr "對於靜態子型別，:c:type:`PyBaseObject_Type` 使用 PyObject_Del。"

#: ../../c-api/typeobj.rst:1883
#, fuzzy
msgid "An optional pointer to a function called by the garbage collector."
msgstr "指向垃圾收集器呼叫的函式的可選指標。"

#: ../../c-api/typeobj.rst:1885
#, fuzzy
msgid ""
"The garbage collector needs to know whether a particular object is "
"collectible or not.  Normally, it is sufficient to look at the object's "
"type's :c:member:`~PyTypeObject.tp_flags` field, and check the :const:"
"`Py_TPFLAGS_HAVE_GC` flag bit.  But some types have a mixture of statically "
"and dynamically allocated instances, and the statically allocated instances "
"are not collectible.  Such types should define this function; it should "
"return ``1`` for a collectible instance, and ``0`` for a non-collectible "
"instance. The signature is::"
msgstr ""
"垃圾收集器需要知道特定對像是否可收集。通常，查看對像型別的 :c:member:"
"`~PyTypeObject.tp_flags` 欄位並檢查 :const:`Py_TPFLAGS_HAVE_GC` 旗標位就足夠"
"了。但是有些型別混合了靜態和動態分配的實例，而靜態分配的實例是不可回收的。這"
"些型別應該定義這個函式；它應該為可收集的實例回傳 ``1``，為不可收集的實例回傳 "
"``0``。簽名是：："

#: ../../c-api/typeobj.rst:1895
#, fuzzy
msgid ""
"(The only example of this are types themselves.  The metatype, :c:data:"
"`PyType_Type`, defines this function to distinguish between statically and :"
"ref:`dynamically allocated types <heap-types>`.)"
msgstr ""
"（唯一的例子是型別本身。元型別 :c:data:`PyType_Type` 定義了這個函式來區分靜態"
"和 :ref:`動態分配的型別 <heap-types>`。）"

#: ../../c-api/typeobj.rst:1905
#, fuzzy
msgid ""
"This slot has no default.  If this field is ``NULL``, :const:"
"`Py_TPFLAGS_HAVE_GC` is used as the functional equivalent."
msgstr ""
"該插槽沒有預設值。如果此欄位為 ``NULL`` ，則 Py_TPFLAGS_HAVE_GC 用作等效功"
"能。"

#: ../../c-api/typeobj.rst:1911
#, fuzzy
msgid "Tuple of base types."
msgstr "基本型別的元組。"

#: ../../c-api/typeobj.rst:1913 ../../c-api/typeobj.rst:1937
#, fuzzy
msgid ""
"This field should be set to ``NULL`` and treated as read-only. Python will "
"fill it in when the type is :c:func:`initialized <PyType_Ready>`."
msgstr ""
"此欄位應設定為 ``NULL`` 並視為只讀。當型別為 :c:func:`initialized "
"<PyType_Ready>` 時，Python 將填充它。"

#: ../../c-api/typeobj.rst:1916
#, fuzzy
msgid ""
"For dynamically created classes, the ``Py_tp_bases`` :c:type:`slot "
"<PyType_Slot>` can be used instead of the *bases* argument of :c:func:"
"`PyType_FromSpecWithBases`. The argument form is preferred."
msgstr ""
"對於動態建立的類，可以使用 ``Py_tp_bases`` :c:type:`slot <PyType_Slot>` 代"
"替 :c:func:`PyType_FromSpecWithBases` 的 *bases* 參數。首選論證形式。"

#: ../../c-api/typeobj.rst:1923
#, fuzzy
msgid ""
"Multiple inheritance does not work well for statically defined types. If you "
"set ``tp_bases`` to a tuple, Python will not raise an error, but some slots "
"will only be inherited from the first base."
msgstr ""
"多重繼承不適用於靜態定義的型別。如果將 ``tp_bases`` 設定為一個元組，Python 不"
"會引發錯誤，但某些插槽只會從第一個基數繼承。"

#: ../../c-api/typeobj.rst:1929 ../../c-api/typeobj.rst:1952
#: ../../c-api/typeobj.rst:1961 ../../c-api/typeobj.rst:1971
#: ../../c-api/typeobj.rst:1985
#, fuzzy
msgid "This field is not inherited."
msgstr "該欄位不被繼承。"

#: ../../c-api/typeobj.rst:1934
#, fuzzy
msgid ""
"Tuple containing the expanded set of base types, starting with the type "
"itself and ending with :class:`object`, in Method Resolution Order."
msgstr ""
"包含擴充的基本型別集的元組，以型別本身開始，以 :class:`object` 結束，按照方法"
"解析順序。"

#: ../../c-api/typeobj.rst:1942
#, fuzzy
msgid ""
"This field is not inherited; it is calculated fresh by :c:func:"
"`PyType_Ready`."
msgstr "該欄位不被繼承；它由 :c:func:`PyType_Ready` 重新計算。"

#: ../../c-api/typeobj.rst:1948
#, fuzzy
msgid "Unused.  Internal use only."
msgstr "沒用過。僅供內部使用。"

#: ../../c-api/typeobj.rst:1957
#, fuzzy
msgid "List of weak references to subclasses.  Internal use only."
msgstr "對子類別的弱引用列表。僅供內部使用。"

#: ../../c-api/typeobj.rst:1966
#, fuzzy
msgid ""
"Weak reference list head, for weak references to this type object.  Not "
"inherited.  Internal use only."
msgstr "弱引用列表頭，用於對該型別物件的弱引用。不繼承。僅供內部使用。"

#: ../../c-api/typeobj.rst:1976
#, fuzzy
msgid ""
"This field is deprecated.  Use :c:member:`~PyTypeObject.tp_finalize` instead."
msgstr "此欄位已棄用。使用 :c:member:`~PyTypeObject.tp_finalize` 代替。"

#: ../../c-api/typeobj.rst:1981
#, fuzzy
msgid "Used to index into the method cache.  Internal use only."
msgstr "用於索引方法快取。僅供內部使用。"

#: ../../c-api/typeobj.rst:1990
#, fuzzy
msgid ""
"An optional pointer to an instance finalization function.  Its signature is::"
msgstr "指向實例終結函式的可選指標。它的簽名是："

#: ../../c-api/typeobj.rst:1994
#, fuzzy
msgid ""
"If :c:member:`~PyTypeObject.tp_finalize` is set, the interpreter calls it "
"once when finalizing an instance.  It is called either from the garbage "
"collector (if the instance is part of an isolated reference cycle) or just "
"before the object is deallocated.  Either way, it is guaranteed to be called "
"before attempting to break reference cycles, ensuring that it finds the "
"object in a sane state."
msgstr ""
"如果設定了 :c:member:`~PyTypeObject.tp_finalize`，直譯器會在完成實例時呼叫它"
"一次。它可以從垃圾收集器中呼叫（如果實例是獨立引用循環的一部分），也可以在對"
"像被釋放之前呼叫。無論哪種方式，它都保證在嘗試打破引用循環之前被呼叫，確保它"
"找到處於正常狀態的物件。"

#: ../../c-api/typeobj.rst:2001
#, fuzzy
msgid ""
":c:member:`~PyTypeObject.tp_finalize` should not mutate the current "
"exception status; therefore, a recommended way to write a non-trivial "
"finalizer is::"
msgstr ""
":c:member:`~PyTypeObject.tp_finalize` 不應改變當前的例外狀態；因此，編寫非平"
"凡終結器的推薦方法是："

#: ../../c-api/typeobj.rst:2018
#, fuzzy
msgid ""
"Also, note that, in a garbage collected Python, :c:member:`~PyTypeObject."
"tp_dealloc` may be called from any Python thread, not just the thread which "
"created the object (if the object becomes part of a refcount cycle, that "
"cycle might be collected by a garbage collection on any thread).  This is "
"not a problem for Python API calls, since the thread on which tp_dealloc is "
"called will own the Global Interpreter Lock (GIL). However, if the object "
"being destroyed in turn destroys objects from some other C or C++ library, "
"care should be taken to ensure that destroying those objects on the thread "
"which called tp_dealloc will not violate any assumptions of the library."
msgstr ""
"另外，請注意，在垃圾收集的 Python 中，:c:member:`~PyTypeObject.tp_dealloc` 可"
"以從任何 Python 執行緒呼叫，而不僅僅是建立物件的執行緒（如果物件成為引用計數"
"週期的一部分，則循環可能會被任何執行緒上的垃圾收集器收集）。這對於 Python "
"API 呼叫不是問題，因為呼叫 tp_dealloc 的執行緒將擁有全局直譯器鎖 (GIL)。但"
"是，如果被銷毀的物件又銷毀了其他一些 C 或 C++ 庫中的物件，則應注意確保在呼叫 "
"tp_dealloc 的執行緒上銷毀這些對像不會違反庫的任何假設。"

#: ../../c-api/typeobj.rst:2037
#, fuzzy
msgid ""
"Before version 3.8 it was necessary to set the :const:"
"`Py_TPFLAGS_HAVE_FINALIZE` flags bit in order for this field to be used.  "
"This is no longer required."
msgstr ""
"在 3.8 版之前，必須設定 Py_TPFLAGS_HAVE_FINALIZE 旗標位才能使用此欄位。這不再"
"需要。"

#: ../../c-api/typeobj.rst:2041
#, fuzzy
msgid "\"Safe object finalization\" (:pep:`442`)"
msgstr "“安全物件終結”(:pep:`442`)"

#: ../../c-api/typeobj.rst:2046
#, fuzzy
msgid ""
"Vectorcall function to use for calls of this type object. In other words, it "
"is used to implement :ref:`vectorcall <vectorcall>` for ``type.__call__``. "
"If ``tp_vectorcall`` is ``NULL``, the default call implementation using :"
"attr:`__new__` and :attr:`__init__` is used."
msgstr ""
"用於呼叫此型別物件的 Vectorcall 函式。換句話說，它用於為 type.__call__ 實作 :"
"ref:`vectorcall <vectorcall>`。如果 ``tp_vectorcall`` 為 ``NULL``，則使用使"
"用 :attr:`__new__` 和 :attr:`__init__` 的預設呼叫實作。"

#: ../../c-api/typeobj.rst:2054
#, fuzzy
msgid "This field is never inherited."
msgstr "該欄位永遠不會被繼承。"

#: ../../c-api/typeobj.rst:2056
#, fuzzy
msgid "(the field exists since 3.8 but it's only used since 3.9)"
msgstr "（該欄位從 3.8 開始存在，但僅從 3.9 開始使用）"

#: ../../c-api/typeobj.rst:2062
#, fuzzy
msgid "Static Types"
msgstr "靜態型別"

#: ../../c-api/typeobj.rst:2064
#, fuzzy
msgid ""
"Traditionally, types defined in C code are *static*, that is, a static :c:"
"type:`PyTypeObject` structure is defined directly in code and initialized "
"using :c:func:`PyType_Ready`."
msgstr ""
"傳統上，C 程式碼中定義的型別是 *static*，即直接在程式碼中定義靜態 "
"PyTypeObject 結構並使用 PyType_Ready 初始化。"

#: ../../c-api/typeobj.rst:2068
#, fuzzy
msgid ""
"This results in types that are limited relative to types defined in Python:"
msgstr "這導致型別相對於 Python 中定義的型別受到限制："

#: ../../c-api/typeobj.rst:2070
#, fuzzy
msgid ""
"Static types are limited to one base, i.e. they cannot use multiple "
"inheritance."
msgstr "靜態型別僅限於一個基礎，即它們不能使用多重繼承。"

#: ../../c-api/typeobj.rst:2072
#, fuzzy
msgid ""
"Static type objects (but not necessarily their instances) are immutable. It "
"is not possible to add or modify the type object's attributes from Python."
msgstr ""
"靜態型別物件（但不一定是它們的實例）是不可變的。無法從 Python 新增或修改型別"
"物件的屬性。"

#: ../../c-api/typeobj.rst:2074
#, fuzzy
msgid ""
"Static type objects are shared across :ref:`sub-interpreters <sub-"
"interpreter-support>`, so they should not include any subinterpreter-"
"specific state."
msgstr ""
"靜態型別對像在 :ref:`sub-interpreters <sub-interpreter-support>` 之間共享，因"
"此它們不應包含任何子直譯器特定的狀態。"

#: ../../c-api/typeobj.rst:2078
#, fuzzy
msgid ""
"Also, since :c:type:`PyTypeObject` is only part of the :ref:`Limited API "
"<stable>` as an opaque struct, any extension modules using static types must "
"be compiled for a specific Python minor version."
msgstr ""
"此外，由於 :c:type:`PyTypeObject` 只是作為不透明結構的 :ref:`Limited API "
"<stable>` 的一部分，因此必須針對特定的 Python 次要版本編譯任何使用靜態型別的"
"擴充模組。"

#: ../../c-api/typeobj.rst:2086
#, fuzzy
msgid "Heap Types"
msgstr "堆型別"

#: ../../c-api/typeobj.rst:2088
#, fuzzy
msgid ""
"An alternative to :ref:`static types <static-types>` is *heap-allocated "
"types*, or *heap types* for short, which correspond closely to classes "
"created by Python's ``class`` statement. Heap types have the :const:"
"`Py_TPFLAGS_HEAPTYPE` flag set."
msgstr ""
":ref:`static types <static-types>` 的替代方法是 *heap-allocated types*，或簡"
"稱 *heap types*，它與 Python 的 ``class`` 語句建立的類密切相關。堆型別設定了 "
"Py_TPFLAGS_HEAPTYPE 旗標。"

#: ../../c-api/typeobj.rst:2093
#, fuzzy
msgid ""
"This is done by filling a :c:type:`PyType_Spec` structure and calling :c:"
"func:`PyType_FromSpec`, :c:func:`PyType_FromSpecWithBases`, or :c:func:"
"`PyType_FromModuleAndSpec`."
msgstr ""
"這是通過填充 PyType_Spec 結構並呼叫 PyType_FromSpec、"
"PyType_FromSpecWithBases 或 PyType_FromModuleAndSpec 來完成的。"

#: ../../c-api/typeobj.rst:2101
#, fuzzy
msgid "Number Object Structures"
msgstr "數字物件結構"

#: ../../c-api/typeobj.rst:2108
#, fuzzy
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the number protocol.  Each function is used by the function of "
"similar name documented in the :ref:`number` section."
msgstr ""
"該結構包含指向對像用於實作數字協定的函式的指標。每個函式都由 :ref:`number` 部"
"分中記錄的具有相似名稱的函式使用。"

#: ../../c-api/typeobj.rst:2114 ../../c-api/typeobj.rst:2438
#, fuzzy
msgid "Here is the structure definition::"
msgstr "這是結構定義::"

#: ../../c-api/typeobj.rst:2161
#, fuzzy
msgid ""
"Binary and ternary functions must check the type of all their operands, and "
"implement the necessary conversions (at least one of the operands is an "
"instance of the defined type).  If the operation is not defined for the "
"given operands, binary and ternary functions must return "
"``Py_NotImplemented``, if another error occurred they must return ``NULL`` "
"and set an exception."
msgstr ""
"二元和三元函式必須檢查其所有操作數的型別，並實施必要的轉換（至少一個操作數是"
"已定義型別的實例）。如果沒有為給定的操作數定義操作，二元和三元函式必須回"
"傳“Py_NotImplemented”，如果發生另一個錯誤，它們必須回傳 ``NULL`` 並設定例外。"

#: ../../c-api/typeobj.rst:2170
#, fuzzy
msgid ""
"The :c:data:`nb_reserved` field should always be ``NULL``.  It was "
"previously called :c:data:`nb_long`, and was renamed in Python 3.0.1."
msgstr ""
":c:data:`nb_reserved` 欄位應始終為 ``NULL``。它以前稱為 :c:data:`nb_long`，並"
"在 Python 3.0.1 中重命名。"

#: ../../c-api/typeobj.rst:2215
#, fuzzy
msgid "Mapping Object Structures"
msgstr "映射物件結構"

#: ../../c-api/typeobj.rst:2222
#, fuzzy
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the mapping protocol.  It has three members:"
msgstr "該結構包含指向對像用於實作映射協定的函式的指標。它有三個成員："

#: ../../c-api/typeobj.rst:2227
#, fuzzy
msgid ""
"This function is used by :c:func:`PyMapping_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  This slot may be set to "
"``NULL`` if the object has no defined length."
msgstr ""
"此函式由 :c:func:`PyMapping_Size` 和 :c:func:`PyObject_Size` 使用，並具有相同"
"的簽名。如果對像沒有定義長度，則此槽可以設定為 ``NULL`` 。"

#: ../../c-api/typeobj.rst:2233
#, fuzzy
msgid ""
"This function is used by :c:func:`PyObject_GetItem` and :c:func:"
"`PySequence_GetSlice`, and has the same signature as :c:func:`!"
"PyObject_GetItem`.  This slot must be filled for the :c:func:"
"`PyMapping_Check` function to return ``1``, it can be ``NULL`` otherwise."
msgstr ""
"此函式由 :c:func:`PyObject_GetItem` 和 :c:func:`PySequence_GetSlice` 使用，並"
"具有與 :c:func:`!PyObject_GetItem` 相同的簽名。必須為 PyMapping_Check 函式填"
"充此插槽以回傳 ``1``，否則它可以為 ``NULL``。"

#: ../../c-api/typeobj.rst:2241
#, fuzzy
msgid ""
"This function is used by :c:func:`PyObject_SetItem`, :c:func:"
"`PyObject_DelItem`, :c:func:`PyObject_SetSlice` and :c:func:"
"`PyObject_DelSlice`.  It has the same signature as :c:func:`!"
"PyObject_SetItem`, but *v* can also be set to ``NULL`` to delete an item.  "
"If this slot is ``NULL``, the object does not support item assignment and "
"deletion."
msgstr ""
"此函式由 PyObject_SetItem、PyObject_DelItem、PyObject_SetSlice 和 "
"PyObject_DelSlice 使用。它與 :c:func:`!PyObject_SetItem` 具有相同的簽名，但 "
"*v* 也可以設定為 ``NULL`` 以刪除項目。如果此插槽為 ``NULL`` ，則該對像不支援"
"項目分配和刪除。"

#: ../../c-api/typeobj.rst:2252
#, fuzzy
msgid "Sequence Object Structures"
msgstr "序列物件結構"

#: ../../c-api/typeobj.rst:2259
#, fuzzy
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the sequence protocol."
msgstr "該結構包含指向對像用於實作序列協定的函式的指標。"

#: ../../c-api/typeobj.rst:2264
#, fuzzy
msgid ""
"This function is used by :c:func:`PySequence_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  It is also used for handling "
"negative indices via the :c:member:`~PySequenceMethods.sq_item` and the :c:"
"member:`~PySequenceMethods.sq_ass_item` slots."
msgstr ""
"此函式由 :c:func:`PySequence_Size` 和 :c:func:`PyObject_Size` 使用，並具有相"
"同的簽名。它還用於通過 :c:member:`~PySequenceMethods.sq_item` 和 :c:member:"
"`~PySequenceMethods.sq_ass_item` 插槽處理負索引。"

#: ../../c-api/typeobj.rst:2271
#, fuzzy
msgid ""
"This function is used by :c:func:`PySequence_Concat` and has the same "
"signature.  It is also used by the ``+`` operator, after trying the numeric "
"addition via the :c:member:`~PyNumberMethods.nb_add` slot."
msgstr ""
"此函式由 :c:func:`PySequence_Concat` 使用並具有相同的簽名。在通過 :c:member:"
"`~PyNumberMethods.nb_add` 插槽嘗試數字加法後，它也被 ``+`` 運算符使用。"

#: ../../c-api/typeobj.rst:2277
#, fuzzy
msgid ""
"This function is used by :c:func:`PySequence_Repeat` and has the same "
"signature.  It is also used by the ``*`` operator, after trying numeric "
"multiplication via the :c:member:`~PyNumberMethods.nb_multiply` slot."
msgstr ""
"此函式由 :c:func:`PySequence_Repeat` 使用並具有相同的簽名。在通過 :c:member:"
"`~PyNumberMethods.nb_multiply` 插槽嘗試數字乘法後，``*`` 運算符也使用它。"

#: ../../c-api/typeobj.rst:2283
#, fuzzy
msgid ""
"This function is used by :c:func:`PySequence_GetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_GetItem`, after trying the "
"subscription via the :c:member:`~PyMappingMethods.mp_subscript` slot. This "
"slot must be filled for the :c:func:`PySequence_Check` function to return "
"``1``, it can be ``NULL`` otherwise."
msgstr ""
"此函式由 :c:func:`PySequence_GetItem` 使用並具有相同的簽名。在嘗試通過 :c:"
"member:`~PyMappingMethods.mp_subscript` 插槽訂閱後，它也被 :c:func:"
"`PyObject_GetItem` 使用。必須為 PySequence_Check 函式填充此槽以回傳 ``1``，否"
"則它可以為 ``NULL``。"

#: ../../c-api/typeobj.rst:2289
#, fuzzy
msgid ""
"Negative indexes are handled as follows: if the :attr:`sq_length` slot is "
"filled, it is called and the sequence length is used to compute a positive "
"index which is passed to :attr:`sq_item`.  If :attr:`sq_length` is ``NULL``, "
"the index is passed as is to the function."
msgstr ""
"負索引的處理方式如下：如果 sq_length 槽已滿，則呼叫它並使用序列長度計算傳遞"
"給 sq_item 的正索引。如果 :attr:`sq_length` 是 ``NULL``，則索引按原樣傳遞給函"
"式。"

#: ../../c-api/typeobj.rst:2296
#, fuzzy
msgid ""
"This function is used by :c:func:`PySequence_SetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_SetItem` and :c:func:"
"`PyObject_DelItem`, after trying the item assignment and deletion via the :c:"
"member:`~PyMappingMethods.mp_ass_subscript` slot. This slot may be left to "
"``NULL`` if the object does not support item assignment and deletion."
msgstr ""
"此函式由 :c:func:`PySequence_SetItem` 使用並具有相同的簽名。它也被:c:func:"
"`PyObject_SetItem` 和:c:func:`PyObject_DelItem` 使用，在嘗試通過 :c:member:"
"`~PyMappingMethods.mp_ass_subscript` 插槽分配和刪除項目之後。如果對像不支援項"
"目分配和刪除，則此插槽可能會保留為 ``NULL`` 。"

#: ../../c-api/typeobj.rst:2305
#, fuzzy
msgid ""
"This function may be used by :c:func:`PySequence_Contains` and has the same "
"signature.  This slot may be left to ``NULL``, in this case :c:func:`!"
"PySequence_Contains` simply traverses the sequence until it finds a match."
msgstr ""
"此函式可由 :c:func:`PySequence_Contains` 使用並具有相同的簽名。這個插槽可能留"
"給 ``NULL`` ，在這種情況下 :c:func:`!PySequence_Contains` 簡單地遍歷序列直到"
"找到匹配項。"

#: ../../c-api/typeobj.rst:2312
#, fuzzy
msgid ""
"This function is used by :c:func:`PySequence_InPlaceConcat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceConcat` "
"will fall back to :c:func:`PySequence_Concat`.  It is also used by the "
"augmented assignment ``+=``, after trying numeric in-place addition via the :"
"c:member:`~PyNumberMethods.nb_inplace_add` slot."
msgstr ""
"此函式由 :c:func:`PySequence_InPlaceConcat` 使用並具有相同的簽名。它應該修改"
"它的第一個操作數，然後回傳它。這個插槽可能留給 ``NULL``，在這種情況下 :c:"
"func:`!PySequence_InPlaceConcat` 將退回到 :c:func:`PySequence_Concat`。在通"
"過 :c:member:`~PyNumberMethods.nb_inplace_add` 槽嘗試數字就地加法後，它也被增"
"強賦值 ``+=`` 使用。"

#: ../../c-api/typeobj.rst:2321
#, fuzzy
msgid ""
"This function is used by :c:func:`PySequence_InPlaceRepeat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceRepeat` "
"will fall back to :c:func:`PySequence_Repeat`.  It is also used by the "
"augmented assignment ``*=``, after trying numeric in-place multiplication "
"via the :c:member:`~PyNumberMethods.nb_inplace_multiply` slot."
msgstr ""
"此函式由 :c:func:`PySequence_InPlaceRepeat` 使用並具有相同的簽名。它應該修改"
"它的第一個操作數，然後回傳它。這個插槽可能留給 ``NULL``，在這種情況下 :c:"
"func:`!PySequence_InPlaceRepeat` 將退回到 :c:func:`PySequence_Repeat`。在通"
"過 :c:member:`~PyNumberMethods.nb_inplace_multiply` 插槽嘗試數字就地乘法後，"
"它也被增強賦值``*=`` 使用。"

#: ../../c-api/typeobj.rst:2332
#, fuzzy
msgid "Buffer Object Structures"
msgstr "緩衝區物件結構"

#: ../../c-api/typeobj.rst:2340
#, fuzzy
msgid ""
"This structure holds pointers to the functions required by the :ref:`Buffer "
"protocol <bufferobjects>`. The protocol defines how an exporter object can "
"expose its internal data to consumer objects."
msgstr ""
"此結構包含指向 :ref:`Buffer 協定 <bufferobjects>` 所需函式的指標。該協定定義"
"了導出器對像如何將其內部資料公開給消費者物件。"

#: ../../c-api/typeobj.rst:2346 ../../c-api/typeobj.rst:2395
#: ../../c-api/typeobj.rst:2449 ../../c-api/typeobj.rst:2460
#: ../../c-api/typeobj.rst:2472 ../../c-api/typeobj.rst:2481
#, fuzzy
msgid "The signature of this function is::"
msgstr "這個函式的簽名是："

#: ../../c-api/typeobj.rst:2350
#, fuzzy
msgid ""
"Handle a request to *exporter* to fill in *view* as specified by *flags*. "
"Except for point (3), an implementation of this function MUST take these "
"steps:"
msgstr ""
"處理對 *exporter* 的請求，以按照 *flags* 的規定填寫 *view*。除第 (3) 點外，此"
"功能的實作必須採取以下步驟："

#: ../../c-api/typeobj.rst:2354
#, fuzzy
msgid ""
"Check if the request can be met. If not, raise :c:data:`PyExc_BufferError`, "
"set :c:expr:`view->obj` to ``NULL`` and return ``-1``."
msgstr ""
"檢查是否可以滿足請求。如果不是，則引發:c:data:`PyExc_BufferError`，將:c:expr:"
"`view->obj` 設定為``NULL`` 並回傳``-1``。"

#: ../../c-api/typeobj.rst:2357
#, fuzzy
msgid "Fill in the requested fields."
msgstr "填寫要求的欄位。"

#: ../../c-api/typeobj.rst:2359
#, fuzzy
msgid "Increment an internal counter for the number of exports."
msgstr "增加出口數量的內部計數器。"

#: ../../c-api/typeobj.rst:2361
#, fuzzy
msgid ""
"Set :c:expr:`view->obj` to *exporter* and increment :c:expr:`view->obj`."
msgstr "將 :c:expr:`view->obj` 設定為 *exporter* 並遞增 :c:expr:`view->obj`。"

#: ../../c-api/typeobj.rst:2363
#, fuzzy
msgid "Return ``0``."
msgstr "回傳 ``0``。"

#: ../../c-api/typeobj.rst:2365
#, fuzzy
msgid ""
"If *exporter* is part of a chain or tree of buffer providers, two main "
"schemes can be used:"
msgstr "如果 *exporter* 是緩衝區提供者鍊或樹的一部分，則可以使用兩個主要方案："

#: ../../c-api/typeobj.rst:2368
#, fuzzy
msgid ""
"Re-export: Each member of the tree acts as the exporting object and sets :c:"
"expr:`view->obj` to a new reference to itself."
msgstr ""
"重新導出：樹的每個成員都充當導出物件並將 :c:expr:`view->obj` 設定為對自身的新"
"引用。"

#: ../../c-api/typeobj.rst:2371
#, fuzzy
msgid ""
"Redirect: The buffer request is redirected to the root object of the tree. "
"Here, :c:expr:`view->obj` will be a new reference to the root object."
msgstr ""
"重定向：緩衝請求被重定向到樹的根物件。在這裡，:c:expr:`view->obj` 將是對根物"
"件的新引用。"

#: ../../c-api/typeobj.rst:2375
#, fuzzy
msgid ""
"The individual fields of *view* are described in section :ref:`Buffer "
"structure <buffer-structure>`, the rules how an exporter must react to "
"specific requests are in section :ref:`Buffer request types <buffer-request-"
"types>`."
msgstr ""
"*view* 的各個欄位在 :ref:`Buffer structure <buffer-structure>` 部分中描述，導"
"出器必須如何對特定請求做出反應的規則在 :ref:`Buffer request types <buffer-"
"request-types 部分中>`。"

#: ../../c-api/typeobj.rst:2380
#, fuzzy
msgid ""
"All memory pointed to in the :c:type:`Py_buffer` structure belongs to the "
"exporter and must remain valid until there are no consumers left. :c:member:"
"`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer."
"strides`, :c:member:`~Py_buffer.suboffsets` and :c:member:`~Py_buffer."
"internal` are read-only for the consumer."
msgstr ""
":c:type:`Py_buffer` 結構中指向的所有記憶體都屬於導出器，並且必須保持有效，直"
"到沒有消費者離開。 :c:member:`~Py_buffer.format`, :c:member:`~Py_buffer."
"shape`, :c:member:`~Py_buffer.strides`, :c:member:`~Py_buffer.suboffsets` "
"和 :c :member:`~Py_buffer.internal` 對消費者是只讀的。"

#: ../../c-api/typeobj.rst:2387
#, fuzzy
msgid ""
":c:func:`PyBuffer_FillInfo` provides an easy way of exposing a simple bytes "
"buffer while dealing correctly with all request types."
msgstr ""
":c:func:`PyBuffer_FillInfo` 提供了一種簡單的方法來公開簡單的位元組緩衝區，同"
"時正確處理所有請求型別。"

#: ../../c-api/typeobj.rst:2390
#, fuzzy
msgid ""
":c:func:`PyObject_GetBuffer` is the interface for the consumer that wraps "
"this function."
msgstr ":c:func:`PyObject_GetBuffer` 是包裝此函式的消費者介面。"

#: ../../c-api/typeobj.rst:2399
#, fuzzy
msgid ""
"Handle a request to release the resources of the buffer. If no resources "
"need to be released, :c:member:`PyBufferProcs.bf_releasebuffer` may be "
"``NULL``. Otherwise, a standard implementation of this function will take "
"these optional steps:"
msgstr ""
"處理釋放緩衝區資源的請求。如果沒有資源需要釋放，:c:member:`PyBufferProcs."
"bf_releasebuffer` 可能是 ``NULL``。否則，此函式的標準實作將採取以下可選步驟："

#: ../../c-api/typeobj.rst:2404
#, fuzzy
msgid "Decrement an internal counter for the number of exports."
msgstr "減少出口數量的內部計數器。"

#: ../../c-api/typeobj.rst:2406
#, fuzzy
msgid "If the counter is ``0``, free all memory associated with *view*."
msgstr "如果計數器為 ``0``，則釋放與 *view* 關聯的所有記憶體。"

#: ../../c-api/typeobj.rst:2408
#, fuzzy
msgid ""
"The exporter MUST use the :c:member:`~Py_buffer.internal` field to keep "
"track of buffer-specific resources. This field is guaranteed to remain "
"constant, while a consumer MAY pass a copy of the original buffer as the "
"*view* argument."
msgstr ""
"導出器必須使用 :c:member:`~Py_buffer.internal` 欄位來跟踪特定於緩衝區的資源。"
"該欄位保證保持不變，而消費者可以將原始緩衝區的副本作為 *view* 參數傳遞。"

#: ../../c-api/typeobj.rst:2414
#, fuzzy
msgid ""
"This function MUST NOT decrement :c:expr:`view->obj`, since that is done "
"automatically in :c:func:`PyBuffer_Release` (this scheme is useful for "
"breaking reference cycles)."
msgstr ""
"此函式不得遞減 :c:expr:`view->obj`，因為這是在 :c:func:`PyBuffer_Release` 中"
"自動完成的（此方案對於打破引用循環很有用）。"

#: ../../c-api/typeobj.rst:2419
#, fuzzy
msgid ""
":c:func:`PyBuffer_Release` is the interface for the consumer that wraps this "
"function."
msgstr ":c:func:`PyBuffer_Release` 是包裝此函式的消費者介面。"

#: ../../c-api/typeobj.rst:2427
#, fuzzy
msgid "Async Object Structures"
msgstr "非同步物件結構"

#: ../../c-api/typeobj.rst:2435
#, fuzzy
msgid ""
"This structure holds pointers to the functions required to implement :term:"
"`awaitable` and :term:`asynchronous iterator` objects."
msgstr ""
"此結構包含指向實作 awaitable 和 asynchronous iterator 物件所需函式的指標。"

#: ../../c-api/typeobj.rst:2453
#, fuzzy
msgid ""
"The returned object must be an :term:`iterator`, i.e. :c:func:`PyIter_Check` "
"must return ``1`` for it."
msgstr ""
"回傳的物件必須是一個疊代器，即 :c:func:`PyIter_Check` 必須為它回傳 ``1``。"

#: ../../c-api/typeobj.rst:2456
#, fuzzy
msgid ""
"This slot may be set to ``NULL`` if an object is not an :term:`awaitable`."
msgstr "如果一個對像不是 :term:`awaitable`，這個槽可以被設定為 ``NULL``。"

#: ../../c-api/typeobj.rst:2464
#, fuzzy
msgid ""
"Must return an :term:`asynchronous iterator` object. See :meth:`__anext__` "
"for details."
msgstr ""
"必須回傳一個 :term:`asynchronous iterator` 物件。有關詳細資訊，請參閱 :meth:"
"`__anext__`。"

#: ../../c-api/typeobj.rst:2467
#, fuzzy
msgid ""
"This slot may be set to ``NULL`` if an object does not implement "
"asynchronous iteration protocol."
msgstr "如果一個對像沒有實作非同步疊代協定，這個槽可以被設定為 ``NULL`` 。"

#: ../../c-api/typeobj.rst:2476
#, fuzzy
msgid ""
"Must return an :term:`awaitable` object.  See :meth:`__anext__` for details. "
"This slot may be set to ``NULL``."
msgstr ""
"必須回傳一個 :term:`awaitable` 物件。有關詳細資訊，請參閱 :meth:`__anext__`。"
"這個插槽可以設定為 ``NULL`` 。"

#: ../../c-api/typeobj.rst:2485
#, fuzzy
msgid ""
"See :c:func:`PyIter_Send` for details. This slot may be set to ``NULL``."
msgstr ""
"有關詳細資訊，請參閱:c:func:`PyIter_Send`。這個插槽可以設定為 ``NULL`` 。"

#: ../../c-api/typeobj.rst:2494
#, fuzzy
msgid "Slot Type typedefs"
msgstr "插槽型別型別定義"

#: ../../c-api/typeobj.rst:2498
#, fuzzy
msgid ""
"The purpose of this function is to separate memory allocation from memory "
"initialization.  It should return a pointer to a block of memory of adequate "
"length for the instance, suitably aligned, and initialized to zeros, but "
"with :attr:`ob_refcnt` set to ``1`` and :attr:`ob_type` set to the type "
"argument.  If the type's :c:member:`~PyTypeObject.tp_itemsize` is non-zero, "
"the object's :attr:`ob_size` field should be initialized to *nitems* and the "
"length of the allocated memory block should be ``tp_basicsize + "
"nitems*tp_itemsize``, rounded up to a multiple of ``sizeof(void*)``; "
"otherwise, *nitems* is not used and the length of the block should be :c:"
"member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"該函式的目的是將記憶體分配與記憶體初始化分開。它應該回傳一個指向記憶體塊的指"
"標，該記憶體塊的長度適合實例，適當對齊並初始化為零，但 ob_refcnt 設定為 1 且 "
"ob_type 設定為型別參數。如果型別的 :c:member:`~PyTypeObject.tp_itemsize` 是非"
"零的，物件的 :attr:`ob_size` 欄位應該被初始化為 *nitems* 並且分配的記憶體塊的"
"長度應該是 ``tp_basicsize + nitems *tp_itemsize``，四捨五入為 "
"``sizeof(void*)`` 的倍數；否則，不使用 *nitems* 並且塊的長度應為 :c:member:"
"`~PyTypeObject.tp_basicsize`。"

#: ../../c-api/typeobj.rst:2508
#, fuzzy
msgid ""
"This function should not do any other instance initialization, not even to "
"allocate additional memory; that should be done by :c:member:`~PyTypeObject."
"tp_new`."
msgstr ""
"這個函式不應該做任何其他實例初始化，甚至不分配額外的記憶體；這應該由 :c:"
"member:`~PyTypeObject.tp_new` 完成。"

#: ../../c-api/typeobj.rst:2515
msgid "See :c:member:`~PyTypeObject.tp_free`."
msgstr "請見 :c:member:`~PyTypeObject.tp_free`。"

#: ../../c-api/typeobj.rst:2519
msgid "See :c:member:`~PyTypeObject.tp_new`."
msgstr "請見 :c:member:`~PyTypeObject.tp_new`。"

#: ../../c-api/typeobj.rst:2523
msgid "See :c:member:`~PyTypeObject.tp_init`."
msgstr "請見 :c:member:`~PyTypeObject.tp_init`。"

#: ../../c-api/typeobj.rst:2527
msgid "See :c:member:`~PyTypeObject.tp_repr`."
msgstr "請見 :c:member:`~PyTypeObject.tp_repr`。"

#: ../../c-api/typeobj.rst:2531 ../../c-api/typeobj.rst:2540
#, fuzzy
msgid "Return the value of the named attribute for the object."
msgstr "回傳物件的命名屬性的值。"

#: ../../c-api/typeobj.rst:2535 ../../c-api/typeobj.rst:2546
#, fuzzy
msgid ""
"Set the value of the named attribute for the object. The value argument is "
"set to ``NULL`` to delete the attribute."
msgstr "為物件設定命名屬性的值。 value 參數設定為 ``NULL`` 以刪除該屬性。"

#: ../../c-api/typeobj.rst:2542
msgid "See :c:member:`~PyTypeObject.tp_getattro`."
msgstr "請見 :c:member:`~PyTypeObject.tp_getattro`。"

#: ../../c-api/typeobj.rst:2549
msgid "See :c:member:`~PyTypeObject.tp_setattro`."
msgstr "請見 :c:member:`~PyTypeObject.tp_setattro`。"

#: ../../c-api/typeobj.rst:2553
msgid "See :c:member:`~PyTypeObject.tp_descr_get`."
msgstr "請見 :c:member:`~PyTypeObject.tp_descr_get`。"

#: ../../c-api/typeobj.rst:2557
msgid "See :c:member:`~PyTypeObject.tp_descr_set`."
msgstr "請見 :c:member:`~PyTypeObject.tp_descr_set`。"

#: ../../c-api/typeobj.rst:2561
msgid "See :c:member:`~PyTypeObject.tp_hash`."
msgstr "請見 :c:member:`~PyTypeObject.tp_hash`。"

#: ../../c-api/typeobj.rst:2565
msgid "See :c:member:`~PyTypeObject.tp_richcompare`."
msgstr "請見 :c:member:`~PyTypeObject.tp_richcompare`。"

#: ../../c-api/typeobj.rst:2569
msgid "See :c:member:`~PyTypeObject.tp_iter`."
msgstr "請見 :c:member:`~PyTypeObject.tp_iter`。"

#: ../../c-api/typeobj.rst:2573
msgid "See :c:member:`~PyTypeObject.tp_iternext`."
msgstr "請見 :c:member:`~PyTypeObject.tp_iternext`。"

#: ../../c-api/typeobj.rst:2587
msgid "See :c:member:`~PyAsyncMethods.am_send`."
msgstr "請見 :c:member:`~PyAsyncMethods.am_send`。"

#: ../../c-api/typeobj.rst:2603
msgid "Examples"
msgstr "範例"

#: ../../c-api/typeobj.rst:2605
#, fuzzy
msgid ""
"The following are simple examples of Python type definitions.  They include "
"common usage you may encounter.  Some demonstrate tricky corner cases.  For "
"more examples, practical info, and a tutorial, see :ref:`defining-new-types` "
"and :ref:`new-types-topics`."
msgstr ""
"以下是 Python 型別定義的簡單示例。它們包括您可能遇到的常見用法。一些展示了棘"
"手的角落案例。有關更多示例、實用資訊和教程，請參閱 :ref:`defining-new-types` "
"和 :ref:`new-types-topics`。"

#: ../../c-api/typeobj.rst:2610
#, fuzzy
msgid "A basic :ref:`static type <static-types>`::"
msgstr "一個基本的\\ :ref:`靜態型別 <static-types>`::"

#: ../../c-api/typeobj.rst:2627
#, fuzzy
msgid ""
"You may also find older code (especially in the CPython code base) with a "
"more verbose initializer::"
msgstr ""
"您可能還會發現帶有更冗長初始化程式的舊程式碼（尤其是在 CPython 程式碼庫中）::"

#: ../../c-api/typeobj.rst:2671
#, fuzzy
msgid "A type that supports weakrefs, instance dicts, and hashing::"
msgstr "一種支援弱引用、實例字典和可雜湊的型別::"

#: ../../c-api/typeobj.rst:2698
#, fuzzy
msgid ""
"A str subclass that cannot be subclassed and cannot be called to create "
"instances (e.g. uses a separate factory func) using :c:data:"
"`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag::"
msgstr ""
"一個 str 子類別，不能被子類別化，也不能被呼叫來建立實例（例如，使用單獨的工廠"
"函式）使用 :c:data:`Py_TPFLAGS_DISALLOW_INSTANTIATION` 旗標::"

#: ../../c-api/typeobj.rst:2717
#, fuzzy
msgid ""
"The simplest :ref:`static type <static-types>` with fixed-length instances::"
msgstr "最簡單的 :ref:`static 型別 <static-types>` 具有固定長度的實例::"

#: ../../c-api/typeobj.rst:2728
#, fuzzy
msgid ""
"The simplest :ref:`static type <static-types>` with variable-length "
"instances::"
msgstr "最簡單的 :ref:`static 型別 <static-types>` 具有可變長度實例::"
