# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Leon H., 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-18 00:17+0000\n"
"PO-Revision-Date: 2018-05-23 14:32+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../c-api/module.rst:6
msgid "Module Objects"
msgstr "模組物件模組"

#: ../../c-api/module.rst:15
#, fuzzy
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python module type.  "
"This is exposed to Python programs as ``types.ModuleType``."
msgstr ""
":c:type:`PyTypeObject` 的這個實例表示 Python 模組型別。這作為 types."
"ModuleType 暴露給 Python 程式。"

#: ../../c-api/module.rst:21
#, fuzzy
msgid ""
"Return true if *p* is a module object, or a subtype of a module object. This "
"function always succeeds."
msgstr ""
"如果 *p* 是模組對像或模組物件的子型別，則回傳 true。這個函式總是成功的。"

#: ../../c-api/module.rst:27
#, fuzzy
msgid ""
"Return true if *p* is a module object, but not a subtype of :c:data:"
"`PyModule_Type`.  This function always succeeds."
msgstr ""
"如果 *p* 是模組物件，但不是 PyModule_Type 的子型別，則回傳 true。這個函式總是"
"成功的。"

#: ../../c-api/module.rst:40
#, fuzzy
msgid ""
"Return a new module object with the :attr:`__name__` attribute set to "
"*name*. The module's :attr:`__name__`, :attr:`__doc__`, :attr:`__package__`, "
"and :attr:`__loader__` attributes are filled in (all but :attr:`__name__` "
"are set to ``None``); the caller is responsible for providing a :attr:"
"`__file__` attribute."
msgstr ""
"回傳一個新的模組物件，並將 :attr:`__name__` 屬性設定為 *name*。模組的 :attr:"
"`__name__`、:attr:`__doc__`、:attr:`__package__` 和 :attr:`__loader__` 屬性被"
"填充（除 :attr:`__name__` 之外的所有屬性都設定為 ``None` `);呼叫者負責提供 :"
"attr:`__file__` 屬性。"

#: ../../c-api/module.rst:48
msgid ":attr:`__package__` and :attr:`__loader__` are set to ``None``."
msgstr ":attr:`__package__` 和 :attr:`__loader__` 被設為 ``None``。"

#: ../../c-api/module.rst:54
#, fuzzy
msgid ""
"Similar to :c:func:`PyModule_NewObject`, but the name is a UTF-8 encoded "
"string instead of a Unicode object."
msgstr ""
"類似於 :c:func:`PyModule_NewObject`，但名稱是 UTF-8 編碼字串而不是 Unicode 物"
"件。"

#: ../../c-api/module.rst:62
#, fuzzy
msgid ""
"Return the dictionary object that implements *module*'s namespace; this "
"object is the same as the :attr:`~object.__dict__` attribute of the module "
"object. If *module* is not a module object (or a subtype of a module "
"object), :exc:`SystemError` is raised and ``NULL`` is returned."
msgstr ""
"回傳實作 *module* 命名空間的字典物件；此物件與模組物件的 :attr:`~object."
"__dict__` 屬性相同。如果 *module* 不是模組物件（或模組物件的子型別），則會引"
"發 SystemError 並回傳 NULL。"

#: ../../c-api/module.rst:67
#, fuzzy
msgid ""
"It is recommended extensions use other ``PyModule_*`` and ``PyObject_*`` "
"functions rather than directly manipulate a module's :attr:`~object."
"__dict__`."
msgstr ""
"建議擴充使用其他``PyModule_*`` 和``PyObject_*`` 函式而不是直接操作模組的:"
"attr:`~object.__dict__`。"

#: ../../c-api/module.rst:78
#, fuzzy
msgid ""
"Return *module*'s :attr:`__name__` value.  If the module does not provide "
"one, or if it is not a string, :exc:`SystemError` is raised and ``NULL`` is "
"returned."
msgstr ""
"回傳 *module* 的 :attr:`__name__` 值。如果模組沒有提供，或者它不是字串，則會"
"引發 :exc:`SystemError` 並回傳 ``NULL``。"

#: ../../c-api/module.rst:86
#, fuzzy
msgid ""
"Similar to :c:func:`PyModule_GetNameObject` but return the name encoded to "
"``'utf-8'``."
msgstr ""
"類似於 :c:func:`PyModule_GetNameObject` 但回傳編碼為 ``'utf-8'`` 的名稱。"

#: ../../c-api/module.rst:91
#, fuzzy
msgid ""
"Return the \"state\" of the module, that is, a pointer to the block of "
"memory allocated at module creation time, or ``NULL``.  See :c:member:"
"`PyModuleDef.m_size`."
msgstr ""
"回傳模組的「狀態」，即指向模組建立時分配的記憶體塊的指標，或 ``NULL`` 。請參"
"閱 :c:member:`PyModuleDef.m_size`。"

#: ../../c-api/module.rst:98
#, fuzzy
msgid ""
"Return a pointer to the :c:type:`PyModuleDef` struct from which the module "
"was created, or ``NULL`` if the module wasn't created from a definition."
msgstr ""
"回傳指向建立模組的 PyModuleDef 結構的指標，如果模組不是從定義建立的，則回傳 "
"NULL。"

#: ../../c-api/module.rst:108
#, fuzzy
msgid ""
"Return the name of the file from which *module* was loaded using *module*'s :"
"attr:`__file__` attribute.  If this is not defined, or if it is not a "
"unicode string, raise :exc:`SystemError` and return ``NULL``; otherwise "
"return a reference to a Unicode object."
msgstr ""
"使用 *module* 的 :attr:`__file__` 屬性回傳從中加載 *module* 的文件的名稱。如"
"果未定義，或者如果它不是 unicode 字串，則引發 :exc:`SystemError` 並回傳 "
"``NULL``；否則回傳對 Unicode 物件的引用。"

#: ../../c-api/module.rst:118
#, fuzzy
msgid ""
"Similar to :c:func:`PyModule_GetFilenameObject` but return the filename "
"encoded to 'utf-8'."
msgstr ""
"類似於 :c:func:`PyModule_GetFilenameObject` 但回傳編碼為 'utf-8' 的文件名。"

#: ../../c-api/module.rst:121
#, fuzzy
msgid ""
":c:func:`PyModule_GetFilename` raises :c:type:`UnicodeEncodeError` on "
"unencodable filenames, use :c:func:`PyModule_GetFilenameObject` instead."
msgstr ""
":c:func:`PyModule_GetFilename` 在無法編碼的文件名上引發 :c:type:"
"`UnicodeEncodeError`，請改用 :c:func:`PyModule_GetFilenameObject`。"

#: ../../c-api/module.rst:129
msgid "Initializing C modules"
msgstr "初始化 C 模組"

#: ../../c-api/module.rst:131
#, fuzzy
msgid ""
"Modules objects are usually created from extension modules (shared libraries "
"which export an initialization function), or compiled-in modules (where the "
"initialization function is added using :c:func:`PyImport_AppendInittab`). "
"See :ref:`building` or :ref:`extending-with-embedding` for details."
msgstr ""
"模組物件通常是從擴充模組（導出初始化函式的共享庫）或編譯模組（使用 "
"PyImport_AppendInittab 新增初始化函式）建立的。有關詳細資訊，請參閱：ref："
"`building` 或 :ref:`extending-with-embedding`。"

#: ../../c-api/module.rst:136
#, fuzzy
msgid ""
"The initialization function can either pass a module definition instance to :"
"c:func:`PyModule_Create`, and return the resulting module object, or request "
"\"multi-phase initialization\" by returning the definition struct itself."
msgstr ""
"初始化函式可以將模組定義實例傳遞給:c:func:`PyModule_Create`，並回傳生成的模組"
"物件，或者通過回傳定義結構本身來請求“多階段初始化”。"

#: ../../c-api/module.rst:142
#, fuzzy
msgid ""
"The module definition struct, which holds all information needed to create a "
"module object. There is usually only one statically initialized variable of "
"this type for each module."
msgstr ""
"模組定義結構，它包含建立模組物件所需的所有資訊。每個模組通常只有一個這種型別"
"的靜態初始化變數。"

#: ../../c-api/module.rst:148
#, fuzzy
msgid "Always initialize this member to :const:`PyModuleDef_HEAD_INIT`."
msgstr "始終將此成員初始化為 :const:`PyModuleDef_HEAD_INIT`。"

#: ../../c-api/module.rst:152
msgid "Name for the new module."
msgstr "新模組的名稱。"

#: ../../c-api/module.rst:156
#, fuzzy
msgid ""
"Docstring for the module; usually a docstring variable created with :c:macro:"
"`PyDoc_STRVAR` is used."
msgstr ""
"模組的文檔字串；通常使用使用 :c:macro:`PyDoc_STRVAR` 建立的文檔字串變數。"

#: ../../c-api/module.rst:161
#, fuzzy
msgid ""
"Module state may be kept in a per-module memory area that can be retrieved "
"with :c:func:`PyModule_GetState`, rather than in static globals. This makes "
"modules safe for use in multiple sub-interpreters."
msgstr ""
"模組狀態可以保存在每個模組的記憶體區域中，可以使用 PyModule_GetState 檢索，而"
"不是靜態全局變數。這使得模組可以安全地用於多個子直譯器。"

#: ../../c-api/module.rst:165
#, fuzzy
msgid ""
"This memory area is allocated based on *m_size* on module creation, and "
"freed when the module object is deallocated, after the :c:member:`m_free` "
"function has been called, if present."
msgstr ""
"此記憶體區域是根據模組建立時的 *m_size* 分配的，並在模組對像被釋放時釋放，在"
"呼叫 :c:member:`m_free` 函式（如果存在）之後。"

#: ../../c-api/module.rst:169
#, fuzzy
msgid ""
"Setting ``m_size`` to ``-1`` means that the module does not support sub-"
"interpreters, because it has global state."
msgstr ""
"將 ``m_size`` 設定為 ``-1`` 意味著該模組不支援子直譯器，因為它具有全局狀態。"

#: ../../c-api/module.rst:172
#, fuzzy
msgid ""
"Setting it to a non-negative value means that the module can be re-"
"initialized and specifies the additional amount of memory it requires for "
"its state. Non-negative ``m_size`` is required for multi-phase "
"initialization."
msgstr ""
"將其設定為非負值意味著模組可以重新初始化並指定其狀態所需的額外記憶體量。多階"
"段初始化需要非負“m_size”。"

#: ../../c-api/module.rst:177
msgid "See :PEP:`3121` for more details."
msgstr "更多詳情請見 :pep:`3121`\\ 。"

#: ../../c-api/module.rst:181
#, fuzzy
msgid ""
"A pointer to a table of module-level functions, described by :c:type:"
"`PyMethodDef` values.  Can be ``NULL`` if no functions are present."
msgstr ""
"指向模組級函式表的指標，由 PyMethodDef 值描述。如果不存在函式，則可以為 "
"``NULL`` 。"

#: ../../c-api/module.rst:186
#, fuzzy
msgid ""
"An array of slot definitions for multi-phase initialization, terminated by a "
"``{0, NULL}`` entry. When using single-phase initialization, *m_slots* must "
"be ``NULL``."
msgstr ""
"用於多階段初始化的槽定義數組，以“{0，NULL}”條目終止。使用單相初始化時，"
"*m_slots* 必須為 ``NULL`` 。"

#: ../../c-api/module.rst:192
#, fuzzy
msgid ""
"Prior to version 3.5, this member was always set to ``NULL``, and was "
"defined as:"
msgstr "在 3.5 版本之前，這個成員總是被設定為 ``NULL`` ，並且被定義為："

#: ../../c-api/module.rst:199
#, fuzzy
msgid ""
"A traversal function to call during GC traversal of the module object, or "
"``NULL`` if not needed."
msgstr "在模組物件的 GC 遍歷期間呼叫的遍歷函式，如果不需要則為 ``NULL`` 。"

#: ../../c-api/module.rst:202 ../../c-api/module.rst:217
#: ../../c-api/module.rst:238
#, fuzzy
msgid ""
"This function is not called if the module state was requested but is not "
"allocated yet. This is the case immediately after the module is created and "
"before the module is executed (:c:data:`Py_mod_exec` function). More "
"precisely, this function is not called if :c:member:`m_size` is greater than "
"0 and the module state (as returned by :c:func:`PyModule_GetState`) is "
"``NULL``."
msgstr ""
"如果模組狀態已請求但尚未分配，則不會呼叫此函式。這是在建立模組之後和執行模組"
"之前立即發生的情況（:c:data:`Py_mod_exec` 函式）。更準確地說，如果 m_size 大"
"於 0 並且模組狀態（由 PyModule_GetState 回傳）為 NULL，則不會呼叫此函式。"

#: ../../c-api/module.rst:209 ../../c-api/module.rst:230
#: ../../c-api/module.rst:245
#, fuzzy
msgid "No longer called before the module state is allocated."
msgstr "在分配模組狀態之前不再呼叫。"

#: ../../c-api/module.rst:214
#, fuzzy
msgid ""
"A clear function to call during GC clearing of the module object, or "
"``NULL`` if not needed."
msgstr "在 GC 清除模組物件期間呼叫的清除函式，如果不需要則為 ``NULL`` 。"

#: ../../c-api/module.rst:224
#, fuzzy
msgid ""
"Like :c:member:`PyTypeObject.tp_clear`, this function is not *always* called "
"before a module is deallocated. For example, when reference counting is "
"enough to determine that an object is no longer used, the cyclic garbage "
"collector is not involved and :c:member:`~PyModuleDef.m_free` is called "
"directly."
msgstr ""
"像 :c:member:`PyTypeObject.tp_clear` 一樣，這個函式並不*總是*在模組被釋放之前"
"被呼叫。例如，當引用計數足以確定一個對像不再被使用時，循環垃圾收集器不參與，"
"直接呼叫:c:member:`~PyModuleDef.m_free`。"

#: ../../c-api/module.rst:235
#, fuzzy
msgid ""
"A function to call during deallocation of the module object, or ``NULL`` if "
"not needed."
msgstr "在釋放模組物件期間呼叫的函式，如果不需要則為 ``NULL`` 。"

#: ../../c-api/module.rst:249
#, fuzzy
msgid "Single-phase initialization"
msgstr "單相初始化"

#: ../../c-api/module.rst:251
#, fuzzy
msgid ""
"The module initialization function may create and return the module object "
"directly. This is referred to as \"single-phase initialization\", and uses "
"one of the following two module creation functions:"
msgstr ""
"模組初始化函式可以直接建立和回傳模組物件。這被稱為“單階段初始化”，並使用以下"
"兩個模組建立函式之一："

#: ../../c-api/module.rst:257
#, fuzzy
msgid ""
"Create a new module object, given the definition in *def*.  This behaves "
"like :c:func:`PyModule_Create2` with *module_api_version* set to :const:"
"`PYTHON_API_VERSION`."
msgstr ""
"根據 *def* 中的定義建立一個新的模組物件。這表現得像 :c:func:"
"`PyModule_Create2`，*module_api_version* 設定為 :const:`PYTHON_API_VERSION`。"

#: ../../c-api/module.rst:264
#, fuzzy
msgid ""
"Create a new module object, given the definition in *def*, assuming the API "
"version *module_api_version*.  If that version does not match the version of "
"the running interpreter, a :exc:`RuntimeWarning` is emitted."
msgstr ""
"建立一個新的模組物件，給定 *def* 中的定義，假定 API 版本 "
"*module_api_version*。如果該版本與正在運行的直譯器的版本不匹配，則會發出 :"
"exc:`RuntimeWarning`。"

#: ../../c-api/module.rst:270
#, fuzzy
msgid ""
"Most uses of this function should be using :c:func:`PyModule_Create` "
"instead; only use this if you are sure you need it."
msgstr ""
"這個函式的大多數用途應該使用 :c:func:`PyModule_Create` 代替；只有在確定需要時"
"才使用它。"

#: ../../c-api/module.rst:273
#, fuzzy
msgid ""
"Before it is returned from in the initialization function, the resulting "
"module object is typically populated using functions like :c:func:"
"`PyModule_AddObjectRef`."
msgstr ""
"在從初始化函式中回傳之前，生成的模組物件通常使用 :c:func:"
"`PyModule_AddObjectRef` 等函式進行填充。"

#: ../../c-api/module.rst:279
#, fuzzy
msgid "Multi-phase initialization"
msgstr "多階段初始化"

#: ../../c-api/module.rst:281
#, fuzzy
msgid ""
"An alternate way to specify extensions is to request \"multi-phase "
"initialization\". Extension modules created this way behave more like Python "
"modules: the initialization is split between the *creation phase*, when the "
"module object is created, and the *execution phase*, when it is populated. "
"The distinction is similar to the :py:meth:`__new__` and :py:meth:`__init__` "
"methods of classes."
msgstr ""
"指定擴充的另一種方法是請求“多階段初始化”。以這種方式建立的擴充模組的行為更像 "
"Python 模組：初始化分為*建立階段*（建立模組物件時）和*執行階段*（填充時）。區"
"別類似於類的 :py:meth:`__new__` 和 :py:meth:`__init__` 方法。"

#: ../../c-api/module.rst:288
#, fuzzy
msgid ""
"Unlike modules created using single-phase initialization, these modules are "
"not singletons: if the *sys.modules* entry is removed and the module is re-"
"imported, a new module object is created, and the old module is subject to "
"normal garbage collection -- as with Python modules. By default, multiple "
"modules created from the same definition should be independent: changes to "
"one should not affect the others. This means that all state should be "
"specific to the module object (using e.g. using :c:func:"
"`PyModule_GetState`), or its contents (such as the module's :attr:`__dict__` "
"or individual classes created with :c:func:`PyType_FromSpec`)."
msgstr ""
"與使用單階段初始化建立的模組不同，這些模組不是單例：如果刪除 *sys.modules* 條"
"目並重新導入模組，則會建立一個新的模組物件，並且舊模組會進行正常的垃圾回收-- "
"與 Python 模組一樣。預設情況下，根據相同定義建立的多個模組應該是獨立的：對一"
"個模組的更改不應影響其他模組。這意味著所有狀態都應該特定於模組物件（例如使"
"用 :c:func:`PyModule_GetState`）或其內容（例如模組的 :attr:`__dict__` 或使"
"用 :c:func 建立的各個類： `PyType_FromSpec`）。"

#: ../../c-api/module.rst:298
#, fuzzy
msgid ""
"All modules created using multi-phase initialization are expected to "
"support :ref:`sub-interpreters <sub-interpreter-support>`. Making sure "
"multiple modules are independent is typically enough to achieve this."
msgstr ""
"使用多階段初始化建立的所有模組都應支援 :ref:`sub-interpreters <sub-"
"interpreter-support>`。確保多個模組是獨立的通常足以實作這一點。"

#: ../../c-api/module.rst:302
#, fuzzy
msgid ""
"To request multi-phase initialization, the initialization function "
"(PyInit_modulename) returns a :c:type:`PyModuleDef` instance with non-empty :"
"c:member:`~PyModuleDef.m_slots`. Before it is returned, the ``PyModuleDef`` "
"instance must be initialized with the following function:"
msgstr ""
"要請求多階段初始化，初始化函式 (PyInit_modulename) 回傳一個具有非空 :c:type:"
"`PyModuleDef` 實例:c:member:`~PyModuleDef.m_slots`。在回傳之前，"
"``PyModuleDef`` 實例必須使用以下函式進行初始化："

#: ../../c-api/module.rst:309
#, fuzzy
msgid ""
"Ensures a module definition is a properly initialized Python object that "
"correctly reports its type and reference count."
msgstr "確保模組定義是正確初始化的 Python 物件，可以正確報告其型別和引用計數。"

#: ../../c-api/module.rst:312
#, fuzzy
msgid "Returns *def* cast to ``PyObject*``, or ``NULL`` if an error occurred."
msgstr "回傳 *def* 轉換為 ``PyObject*``，如果發生錯誤則回傳 ``NULL``。"

#: ../../c-api/module.rst:316
#, fuzzy
msgid ""
"The *m_slots* member of the module definition must point to an array of "
"``PyModuleDef_Slot`` structures:"
msgstr "模組定義的 *m_slots* 成員必須指向一個 ``PyModuleDef_Slot`` 結構數組："

#: ../../c-api/module.rst:323
#, fuzzy
msgid "A slot ID, chosen from the available values explained below."
msgstr "從下面解釋的可用值中選擇的插槽 ID。"

#: ../../c-api/module.rst:327
#, fuzzy
msgid "Value of the slot, whose meaning depends on the slot ID."
msgstr "插槽的值，其含義取決於插槽ID。"

#: ../../c-api/module.rst:331
#, fuzzy
msgid "The *m_slots* array must be terminated by a slot with id 0."
msgstr "*m_slots* 數組必須以 id 為 0 的槽結束。"

#: ../../c-api/module.rst:333
#, fuzzy
msgid "The available slot types are:"
msgstr "可用的插槽型別有："

#: ../../c-api/module.rst:337
#, fuzzy
msgid ""
"Specifies a function that is called to create the module object itself. The "
"*value* pointer of this slot must point to a function of the signature:"
msgstr ""
"指定呼叫以建立模組物件本身的函式。該插槽的 *value* 指標必須指向簽名的函式："

#: ../../c-api/module.rst:342
#, fuzzy
msgid ""
"The function receives a :py:class:`~importlib.machinery.ModuleSpec` "
"instance, as defined in :PEP:`451`, and the module definition. It should "
"return a new module object, or set an error and return ``NULL``."
msgstr ""
"該函式接收 :py:class:`~importlib.machinery.ModuleSpec` 實例，如 :PEP:`451` 中"
"所定義，以及模組定義。它應該回傳一個新的模組物件，或者設定一個錯誤並回傳 "
"``NULL`` 。"

#: ../../c-api/module.rst:347
#, fuzzy
msgid ""
"This function should be kept minimal. In particular, it should not call "
"arbitrary Python code, as trying to import the same module again may result "
"in an infinite loop."
msgstr ""
"這個功能應該保持最小。特別是，它不應呼叫任意 Python 程式碼，因為嘗試再次導入"
"同一模組可能會導致無限循環。"

#: ../../c-api/module.rst:351
#, fuzzy
msgid ""
"Multiple ``Py_mod_create`` slots may not be specified in one module "
"definition."
msgstr "一個模組定義中不能指定多個 ``Py_mod_create`` 槽。"

#: ../../c-api/module.rst:354
#, fuzzy
msgid ""
"If ``Py_mod_create`` is not specified, the import machinery will create a "
"normal module object using :c:func:`PyModule_New`. The name is taken from "
"*spec*, not the definition, to allow extension modules to dynamically adjust "
"to their place in the module hierarchy and be imported under different names "
"through symlinks, all while sharing a single module definition."
msgstr ""
"如果未指定 ``Py_mod_create``，導入機制將使用 PyModule_New 建立一個普通的模組"
"物件。該名稱取自 *spec*，而不是定義，以允許擴充模組動態調整它們在模組層次結構"
"中的位置，並通過符號鏈接以不同的名稱導入，同時共享單個模組定義。"

#: ../../c-api/module.rst:360
#, fuzzy
msgid ""
"There is no requirement for the returned object to be an instance of :c:type:"
"`PyModule_Type`. Any type can be used, as long as it supports setting and "
"getting import-related attributes. However, only ``PyModule_Type`` instances "
"may be returned if the ``PyModuleDef`` has non-``NULL`` ``m_traverse``, "
"``m_clear``, ``m_free``; non-zero ``m_size``; or slots other than "
"``Py_mod_create``."
msgstr ""
"沒有要求回傳的對像是 :c:type:`PyModule_Type` 的實例。可以使用任何型別，只要它"
"支援設定和獲取與導入相關的屬性。但是，如果 ``PyModuleDef`` 具有非 ``NULL`` "
"``m_traverse``、``m_clear``、``m_free``，則只能回傳 ``PyModule_Type`` 實例；"
"非零“m_size”；或 ``Py_mod_create`` 以外的插槽。"

#: ../../c-api/module.rst:369
#, fuzzy
msgid ""
"Specifies a function that is called to *execute* the module. This is "
"equivalent to executing the code of a Python module: typically, this "
"function adds classes and constants to the module. The signature of the "
"function is:"
msgstr ""
"指定呼叫以*執行*模組的函式。這相當於執行 Python 模組的程式碼：通常，此函式將"
"類和常數新增到模組。該函式的簽名是："

#: ../../c-api/module.rst:376
#, fuzzy
msgid ""
"If multiple ``Py_mod_exec`` slots are specified, they are processed in the "
"order they appear in the *m_slots* array."
msgstr ""
"如果指定了多個 ``Py_mod_exec`` 槽，它們將按照它們在 *m_slots* 數組中出現的順"
"序進行處理。"

#: ../../c-api/module.rst:379
#, fuzzy
msgid "See :PEP:`489` for more details on multi-phase initialization."
msgstr "有關多階段初始化的更多詳細資訊，請參見 :PEP:`489`。"

#: ../../c-api/module.rst:382
#, fuzzy
msgid "Low-level module creation functions"
msgstr "低階模組建立函式"

#: ../../c-api/module.rst:384
#, fuzzy
msgid ""
"The following functions are called under the hood when using multi-phase "
"initialization. They can be used directly, for example when creating module "
"objects dynamically. Note that both ``PyModule_FromDefAndSpec`` and "
"``PyModule_ExecDef`` must be called to fully initialize a module."
msgstr ""
"使用多階段初始化時，將在後台呼叫以下函式。它們可以直接使用，例如在動態建立模"
"組物件時。請注意，必須呼叫 ``PyModule_FromDefAndSpec`` 和 "
"``PyModule_ExecDef`` 才能完全初始化模組。"

#: ../../c-api/module.rst:391
#, fuzzy
msgid ""
"Create a new module object, given the definition in *def* and the ModuleSpec "
"*spec*.  This behaves like :c:func:`PyModule_FromDefAndSpec2` with "
"*module_api_version* set to :const:`PYTHON_API_VERSION`."
msgstr ""
"根據 *def* 和 ModuleSpec *spec* 中的定義，建立一個新的模組物件。這與 "
"*module_api_version* 設定為 :const:`PYTHON_API_VERSION` 的 :c:func:"
"`PyModule_FromDefAndSpec2` 類似。"

#: ../../c-api/module.rst:399
#, fuzzy
msgid ""
"Create a new module object, given the definition in *def* and the ModuleSpec "
"*spec*, assuming the API version *module_api_version*. If that version does "
"not match the version of the running interpreter, a :exc:`RuntimeWarning` is "
"emitted."
msgstr ""
"建立一個新的模組物件，給定 *def* 和 ModuleSpec *spec* 中的定義，假定 API 版"
"本 *module_api_version*。如果該版本與正在運行的直譯器的版本不匹配，則會發出 :"
"exc:`RuntimeWarning`。"

#: ../../c-api/module.rst:406
#, fuzzy
msgid ""
"Most uses of this function should be using :c:func:`PyModule_FromDefAndSpec` "
"instead; only use this if you are sure you need it."
msgstr ""
"這個函式的大多數用途應該改用:c:func:`PyModule_FromDefAndSpec`；只有在確定需要"
"時才使用它。"

#: ../../c-api/module.rst:413
#, fuzzy
msgid "Process any execution slots (:c:data:`Py_mod_exec`) given in *def*."
msgstr "處理 *def* 中給出的任何執行槽 (:c:data:`Py_mod_exec`)。"

#: ../../c-api/module.rst:419
#, fuzzy
msgid ""
"Set the docstring for *module* to *docstring*. This function is called "
"automatically when creating a module from ``PyModuleDef``, using either "
"``PyModule_Create`` or ``PyModule_FromDefAndSpec``."
msgstr ""
"將 *module* 的文檔字串設定為 *docstring*。當使"
"用“PyModule_Create”或“PyModule_FromDefAndSpec”從 ``PyModuleDef`` 建立模組時，"
"會自動呼叫此函式。"

#: ../../c-api/module.rst:428
#, fuzzy
msgid ""
"Add the functions from the ``NULL`` terminated *functions* array to "
"*module*. Refer to the :c:type:`PyMethodDef` documentation for details on "
"individual entries (due to the lack of a shared module namespace, module "
"level \"functions\" implemented in C typically receive the module as their "
"first parameter, making them similar to instance methods on Python classes). "
"This function is called automatically when creating a module from "
"``PyModuleDef``, using either ``PyModule_Create`` or "
"``PyModule_FromDefAndSpec``."
msgstr ""
"將以 ``NULL`` 結尾的 *functions* 數組中的函式新增到 *module*。有關各個條目的"
"詳細資訊，請參閱:c:type:`PyMethodDef` 文檔（由於缺少共享模組命名空間，在 C 中"
"實作的模組級“函式”通常接收模組作為其第一個參數，使它們類似於實例Python 類上的"
"方法）。當使用“PyModule_Create”或“PyModule_FromDefAndSpec”從 ``PyModuleDef`` "
"建立模組時，會自動呼叫此函式。"

#: ../../c-api/module.rst:440
msgid "Support functions"
msgstr "支援功能"

#: ../../c-api/module.rst:442
#, fuzzy
msgid ""
"The module initialization function (if using single phase initialization) or "
"a function called from a module execution slot (if using multi-phase "
"initialization), can use the following functions to help initialize the "
"module state:"
msgstr ""
"模組初始化函式（如果使用單階段初始化）或從模組執行槽呼叫的函式（如果使用多階"
"段初始化）可以使用以下函式來幫助初始化模組狀態："

#: ../../c-api/module.rst:449
#, fuzzy
msgid ""
"Add an object to *module* as *name*.  This is a convenience function which "
"can be used from the module's initialization function."
msgstr ""
"將物件新增到 *module* 作為 *name*。這是一個方便的函式，可以從模組的初始化函式"
"中使用。"

#: ../../c-api/module.rst:452
msgid ""
"On success, return ``0``. On error, raise an exception and return ``-1``."
msgstr "成功時，回傳 ``0``。出錯時，引發例外並回傳 ``-1``。"

#: ../../c-api/module.rst:454
#, fuzzy
msgid ""
"Return ``NULL`` if *value* is ``NULL``. It must be called with an exception "
"raised in this case."
msgstr ""
"如果 *value* 為 ``NULL`` ，則回傳 ``NULL`` 。在這種情況下，必須在引發例外的情"
"況下呼叫它。"

#: ../../c-api/module.rst:457 ../../c-api/module.rst:506
msgid "Example usage::"
msgstr ""
"用法範例：\n"
"\n"
"::"

#: ../../c-api/module.rst:471 ../../c-api/module.rst:524
#, fuzzy
msgid ""
"The example can also be written without checking explicitly if *obj* is "
"``NULL``::"
msgstr "該示例也可以在不顯式檢查 *obj* 是否為 ``NULL`` 的情況下編寫："

#: ../../c-api/module.rst:483 ../../c-api/module.rst:540
#, fuzzy
msgid ""
"Note that ``Py_XDECREF()`` should be used instead of ``Py_DECREF()`` in this "
"case, since *obj* can be ``NULL``."
msgstr ""
"請注意，在這種情況下，應該使用 ``Py_XDECREF()`` 而不是 ``Py_DECREF()``，因為 "
"*obj* 可以是 ``NULL``。"

#: ../../c-api/module.rst:491
#, fuzzy
msgid ""
"Similar to :c:func:`PyModule_AddObjectRef`, but steals a reference to "
"*value* on success (if it returns ``0``)."
msgstr ""
"類似於 :c:func:`PyModule_AddObjectRef`，但在成功時竊取對 *value* 的引用（如果"
"它回傳 ``0``）。"

#: ../../c-api/module.rst:494
#, fuzzy
msgid ""
"The new :c:func:`PyModule_AddObjectRef` function is recommended, since it is "
"easy to introduce reference leaks by misusing the :c:func:"
"`PyModule_AddObject` function."
msgstr ""
"推薦使用新的 :c:func:`PyModule_AddObjectRef` 函式，因為誤用 :c:func:"
"`PyModule_AddObject` 函式很容易引入引用洩漏。"

#: ../../c-api/module.rst:500
#, fuzzy
msgid ""
"Unlike other functions that steal references, ``PyModule_AddObject()`` only "
"decrements the reference count of *value* **on success**."
msgstr ""
"與竊取引用的其他函式不同，``PyModule_AddObject()`` 僅在成功時減少 *value* ** "
"的引用計數**。"

#: ../../c-api/module.rst:503
#, fuzzy
msgid ""
"This means that its return value must be checked, and calling code must :c:"
"func:`Py_DECREF` *value* manually on error."
msgstr ""
"這意味著必須檢查其回傳值，並且呼叫程式碼必須在錯誤時手動 :c:func:`Py_DECREF` "
"*value*。"

#: ../../c-api/module.rst:546
#, fuzzy
msgid ""
"Add an integer constant to *module* as *name*.  This convenience function "
"can be used from the module's initialization function. Return ``-1`` on "
"error, ``0`` on success."
msgstr ""
"將整數常數新增到 *module* 作為 *name*。這個方便的函式可以從模組的初始化函式中"
"使用。錯誤回傳 ``-1``，成功回傳 ``0``。"

#: ../../c-api/module.rst:553
#, fuzzy
msgid ""
"Add a string constant to *module* as *name*.  This convenience function can "
"be used from the module's initialization function.  The string *value* must "
"be ``NULL``-terminated.  Return ``-1`` on error, ``0`` on success."
msgstr ""
"新增一個字串常數到 *module* 作為 *name*。這個方便的函式可以從模組的初始化函式"
"中使用。字串 *value* 必須以 ``NULL`` 結尾。錯誤回傳 ``-1``，成功回傳 ``0``。"

#: ../../c-api/module.rst:560
#, fuzzy
msgid ""
"Add an int constant to *module*. The name and the value are taken from "
"*macro*. For example ``PyModule_AddIntMacro(module, AF_INET)`` adds the int "
"constant *AF_INET* with the value of *AF_INET* to *module*. Return ``-1`` on "
"error, ``0`` on success."
msgstr ""
"向 *module* 新增一個 int 常數。名稱和值取自 *macro*。例如，"
"``PyModule_AddIntMacro(module, AF_INET)`` 將值為 *AF_INET* 的 int 常數 "
"*AF_INET* 新增到 *module*。錯誤回傳 ``-1``，成功回傳 ``0``。"

#: ../../c-api/module.rst:568
msgid "Add a string constant to *module*."
msgstr "向 *module* 新增一個字串常數。"

#: ../../c-api/module.rst:572
#, fuzzy
msgid ""
"Add a type object to *module*. The type object is finalized by calling "
"internally :c:func:`PyType_Ready`. The name of the type object is taken from "
"the last component of :c:member:`~PyTypeObject.tp_name` after dot. Return "
"``-1`` on error, ``0`` on success."
msgstr ""
"將型別物件新增到 *module*。型別物件通過內部呼叫 :c:func:`PyType_Ready` 來完"
"成。型別物件的名稱取自 :c:member:`~PyTypeObject.tp_name` 點後的最後一個組件。"
"錯誤回傳 ``-1``，成功回傳 ``0``。"

#: ../../c-api/module.rst:582
#, fuzzy
msgid "Module lookup"
msgstr "模組查找"

#: ../../c-api/module.rst:584
#, fuzzy
msgid ""
"Single-phase initialization creates singleton modules that can be looked up "
"in the context of the current interpreter. This allows the module object to "
"be retrieved later with only a reference to the module definition."
msgstr ""
"單階段初始化建立可以在當前直譯器的上下文中查找的單例模組。這允許稍後僅通過引"
"用模組定義來檢索模組物件。"

#: ../../c-api/module.rst:588
#, fuzzy
msgid ""
"These functions will not work on modules created using multi-phase "
"initialization, since multiple such modules can be created from a single "
"definition."
msgstr ""
"這些函式不適用於使用多階段初始化建立的模組，因為可以從單個定義建立多個此類模"
"組。"

#: ../../c-api/module.rst:593
#, fuzzy
msgid ""
"Returns the module object that was created from *def* for the current "
"interpreter. This method requires that the module object has been attached "
"to the interpreter state with :c:func:`PyState_AddModule` beforehand. In "
"case the corresponding module object is not found or has not been attached "
"to the interpreter state yet, it returns ``NULL``."
msgstr ""
"回傳從 *def* 為當前直譯器建立的模組物件。此方法要求模組對像已預先附加到直譯器"
"狀態 :c:func:`PyState_AddModule`。如果未找到相應的模組對像或尚未附加到直譯器"
"狀態，則回傳 ``NULL`` 。"

#: ../../c-api/module.rst:600
#, fuzzy
msgid ""
"Attaches the module object passed to the function to the interpreter state. "
"This allows the module object to be accessible via :c:func:"
"`PyState_FindModule`."
msgstr ""
"將傳遞給函式的模組物件附加到直譯器狀態。這允許通過 :c:func:"
"`PyState_FindModule` 訪問模組物件。"

#: ../../c-api/module.rst:603
#, fuzzy
msgid "Only effective on modules created using single-phase initialization."
msgstr "僅對使用單階段初始化建立的模組有效。"

#: ../../c-api/module.rst:605
#, fuzzy
msgid ""
"Python calls ``PyState_AddModule`` automatically after importing a module, "
"so it is unnecessary (but harmless) to call it from module initialization "
"code. An explicit call is needed only if the module's own init code "
"subsequently calls ``PyState_FindModule``. The function is mainly intended "
"for implementing alternative import mechanisms (either by calling it "
"directly, or by referring to its implementation for details of the required "
"state updates)."
msgstr ""
"導入模組後，Python 會自動呼叫 PyState_AddModule，因此無需（但無害）從模組初始"
"化程式碼中呼叫它。僅當模組自己的初始化程式碼隨後呼叫“PyState_FindModule”時才"
"需要顯式呼叫。該函式主要用於實作替代導入機制（通過直接呼叫它，或通過參考其實"
"作以獲取所需狀態更新的詳細資訊）。"

#: ../../c-api/module.rst:613 ../../c-api/module.rst:624
msgid "The caller must hold the GIL."
msgstr "呼叫者必須持有 GIL。"

#: ../../c-api/module.rst:615
msgid "Return 0 on success or -1 on failure."
msgstr "成功回傳 0，失敗回傳 -1。"

#: ../../c-api/module.rst:621
#, fuzzy
msgid ""
"Removes the module object created from *def* from the interpreter state. "
"Return 0 on success or -1 on failure."
msgstr "從直譯器狀態中刪除從 *def* 建立的模組物件。成功回傳 0，失敗回傳 -1。"
