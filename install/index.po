# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Leon H., 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-31 08:13+0000\n"
"PO-Revision-Date: 2018-05-23 14:37+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../install/index.rst:7
msgid "Installing Python Modules (Legacy version)"
msgstr "安裝 Python 模組（舊版）"

#: ../../install/index.rst:0
msgid "Author"
msgstr "作者"

#: ../../install/index.rst:9
msgid "Greg Ward"
msgstr "Greg Ward"

#: ../../install/index.rst:15
#, fuzzy
msgid ""
"The entire ``distutils`` package has been deprecated and will be removed in "
"Python 3.12. This documentation is retained as a reference only, and will be "
"removed with the package. See the :ref:`What's New <distutils-deprecated>` "
"entry for more information."
msgstr ""
"整個 ``distutils`` 包已被棄用，並將在 Python 3.12 "
"中刪除。此文檔僅作為參考保留，並將隨軟件包一起刪除。有關詳細資訊，請參閱 "
":ref:`What's New <distutils-deprecated>` 條目。"

#: ../../install/index.rst:23
msgid ":ref:`installing-index`"
msgstr ":ref:`installing-index`"

#: ../../install/index.rst:23
#, fuzzy
msgid ""
"The up to date module installation documentation. For regular Python usage, "
"you almost certainly want that document rather than this one."
msgstr "最新的模組安裝文檔。對於常規的 Python "
"用法，您幾乎肯定需要那個文檔而不是這個文檔。"

#: ../../distutils/_setuptools_disclaimer.rst:3
#, fuzzy
msgid ""
"This document is being retained solely until the ``setuptools`` "
"documentation at https://setuptools.readthedocs.io/en/latest/setuptools.html "
"independently covers all of the relevant information currently included here."
msgstr ""
"本文檔僅保留到 https://setuptools.readthedocs.io/en/latest/setuptools.html "
"上的 ``setuptools``文檔獨立涵蓋當前包含在此處的所有相關資訊。"

#: ../../install/index.rst:30
#, fuzzy
msgid ""
"This guide only covers the basic tools for building and distributing "
"extensions that are provided as part of this version of Python. Third party "
"tools offer easier to use and more secure alternatives. Refer to the `quick "
"recommendations section <https://packaging.python.org/guides/tool-"
"recommendations/>`__ in the Python Packaging User Guide for more information."
msgstr ""
"本指南僅涵蓋用於構建和分發作為此版本 Python 的一部分提供的擴充的基本工具。第"
"三方工具提供更易於使用和更安全的替代方案。有關詳細資訊，請參閱《Python "
"打包使用者指南》中的“快速建議”部分 <https://packaging.python.org/guides/"
"tool-recommendations/>`__。"

#: ../../install/index.rst:41
msgid "Introduction"
msgstr "簡介"

#: ../../install/index.rst:43
#, fuzzy
msgid ""
"In Python 2.0, the ``distutils`` API was first added to the standard "
"library. This provided Linux distro maintainers with a standard way of "
"converting Python projects into Linux distro packages, and system "
"administrators with a standard way of installing them directly onto target "
"systems."
msgstr ""
"在 Python 2.0 中，``distutils`` API 首先被新增到標準庫中。這為 Linux "
"發行版維護者提供了一種將 Python 項目轉換為 Linux 發行版包的標準方法，並為系統"
"管理員提供了一種將它們直接安裝到目標系統上的標準方法。"

#: ../../install/index.rst:48
#, fuzzy
msgid ""
"In the many years since Python 2.0 was released, tightly coupling the build "
"system and package installer to the language runtime release cycle has "
"turned out to be problematic, and it is now recommended that projects use "
"the ``pip`` package installer and the ``setuptools`` build system, rather "
"than using ``distutils`` directly."
msgstr ""
"自 Python 2.0 發布以來的許多年裡，構建系統和包安裝程式與語言運行時發布週期的"
"緊密耦合已被證明是有問題的，現在建議項目使用 ``pip``包安裝程式和“ `setuptools`` "
"構建系統，而不是直接使用 ``distutils``。"

#: ../../install/index.rst:54
#, fuzzy
msgid ""
"See :ref:`installing-index` and :ref:`distributing-index` for more details."
msgstr "有關詳細資訊，請參閱 :ref:`installing-index` 和 :ref:`distributing-index`。"

#: ../../install/index.rst:56
#, fuzzy
msgid ""
"This legacy documentation is being retained only until we're confident that "
"the ``setuptools`` documentation covers everything needed."
msgstr "只有在我們確信 ``setuptools`` "
"文檔涵蓋了所有需要的內容之前，才會保留此遺留文檔。"

#: ../../install/index.rst:62
#, fuzzy
msgid "Distutils based source distributions"
msgstr "基於 Distutils 的源程式碼發行版"

#: ../../install/index.rst:64
#, fuzzy
msgid ""
"If you download a module source distribution, you can tell pretty quickly if "
"it was packaged and distributed in the standard way, i.e. using the "
"Distutils. First, the distribution's name and version number will be "
"featured prominently in the name of the downloaded archive, e.g. :file:"
"`foo-1.0.tar.gz` or :file:`widget-0.9.7.zip`.  Next, the archive will unpack "
"into a similarly named directory: :file:`foo-1.0` or :file:`widget-0.9.7`.  "
"Additionally, the distribution will contain a setup script :file:`setup.py`, "
"and a file named :file:`README.txt` or possibly just :file:`README`, which "
"should explain that building and installing the module distribution is a "
"simple matter of running one command from a terminal::"
msgstr ""
"如果您下載了一個模組源程式碼分發版，您可以很快判斷它是否以標準方式打包和分發"
"，即使用 Distutils。首先，發行版的名稱和版本號將在下載檔案的名稱中突出顯示，"
"例如 :file:`foo-1.0.tar.gz` 或 :file:`widget-0.9.7."
"zip`。接下來，存檔將解壓到一個類似命名的目錄中：:file:`foo-1.0` 或 "
":file:`widget-0.9.7`。此外，分發版將包含一個安裝腳本 setup.py 和一個名為 "
"README.txt 或可能只是 README "
"的文件，這應該解釋構建和安裝模組分發版從終端運行一個命令是一件簡單的事情::"

#: ../../install/index.rst:77
#, fuzzy
msgid ""
"For Windows, this command should be run from a command prompt window (:"
"menuselection:`Start --> Accessories`)::"
msgstr "對於 Windows，此命令應從命令提示符窗口運行（:menuselection:`Start --> "
"Accessories`）::"

#: ../../install/index.rst:82
#, fuzzy
msgid ""
"If all these things are true, then you already know how to build and install "
"the modules you've just downloaded:  Run the command above. Unless you need "
"to install things in a non-standard way or customize the build process, you "
"don't really need this manual.  Or rather, the above command is everything "
"you need to get out of this manual."
msgstr ""
"如果所有這些都是真的，那麼您已經知道如何構建和安裝您剛剛下載的模組：運行上面"
"的命令。除非您需要以非標準方式安裝東西或自定義構建過程，否則您實際上並不需要"
"本手冊。或者更確切地說，上面的命令是您從本手冊中獲得所需的一切。"

#: ../../install/index.rst:92
#, fuzzy
msgid "Standard Build and Install"
msgstr "標準構建和安裝"

#: ../../install/index.rst:94
#, fuzzy
msgid ""
"As described in section :ref:`inst-new-standard`, building and installing a "
"module distribution using the Distutils is usually one simple command to run "
"from a terminal::"
msgstr "如 :ref:`inst-new-standard` 部分所述，使用 Distutils "
"構建和安裝模組分發通常是從終端運行的一個簡單命令::"

#: ../../install/index.rst:104
#, fuzzy
msgid "Platform variations"
msgstr "平台變化"

#: ../../install/index.rst:106
#, fuzzy
msgid ""
"You should always run the setup command from the distribution root "
"directory, i.e. the top-level subdirectory that the module source "
"distribution unpacks into.  For example, if you've just downloaded a module "
"source distribution :file:`foo-1.0.tar.gz` onto a Unix system, the normal "
"thing to do is::"
msgstr ""
"您應該始終從分髮根目錄運行設定命令，即模組源分發解壓縮到的頂級子目錄。例如，"
"如果您剛剛將模組源程式碼分發版 :file:`foo-1.0.tar.gz` 下載到 Unix "
"系統上，通常要做的事情是："

#: ../../install/index.rst:115
#, fuzzy
msgid ""
"On Windows, you'd probably download :file:`foo-1.0.zip`.  If you downloaded "
"the archive file to :file:`C:\\\\Temp`, then it would unpack into :file:`C:\\"
"\\Temp\\\\foo-1.0`; you can use either an archive manipulator with a "
"graphical user interface (such as WinZip) or a command-line tool (such as :"
"program:`unzip` or :program:`pkunzip`) to unpack the archive.  Then, open a "
"command prompt window and run::"
msgstr ""
"在 Windows 上，您可能會下載 :file:`foo-1.0."
"zip`。如果您將存檔文件下載到 :file:`C:\\\\Temp`，那麼它將解壓到 :file:`C:\\"
"\\Temp\\\\foo-1.0`；您可以使用帶有圖形使用者界面的存檔操縱器（例如 "
"WinZip）或命令列工具（例如 :program:`unzip` 或 "
":program:`pkunzip`）來解壓縮存檔。然後，打開命令提示符窗口並運行："

#: ../../install/index.rst:129
#, fuzzy
msgid "Splitting the job up"
msgstr "拆分工作"

#: ../../install/index.rst:131
#, fuzzy
msgid ""
"Running ``setup.py install`` builds and installs all modules in one run.  If "
"you prefer to work incrementally---especially useful if you want to "
"customize the build process, or if things are going wrong---you can use the "
"setup script to do one thing at a time.  This is particularly helpful when "
"the build and install will be done by different users---for example, you "
"might want to build a module distribution and hand it off to a system "
"administrator for installation (or do it yourself, with super-user "
"privileges)."
msgstr ""
"運行 ``setup.py install`` 一次構建並安裝所有模組。如果您更喜歡增量工作——如果"
"您想要自定義構建過程，或者出現問題時尤其有用——您可以使用安裝腳本一次做一件事"
"。當構建和安裝將由不同的使用者完成時，這特別有用——例如，您可能想要構建一個模"
"組分發並將其交給系統管理員進行安裝（或者您自己進行，具有超級使用者權限） )."

#: ../../install/index.rst:139
#, fuzzy
msgid ""
"For example, you can build everything in one step, and then install "
"everything in a second step, by invoking the setup script twice::"
msgstr "例如，您可以一步構建所有內容，然後在第二步中安裝所有內容，方法是呼叫安裝腳本"
"兩次："

#: ../../install/index.rst:145
#, fuzzy
msgid ""
"If you do this, you will notice that running the :command:`install` command "
"first runs the :command:`build` command, which---in this case---quickly "
"notices that it has nothing to do, since everything in the :file:`build` "
"directory is up-to-date."
msgstr ""
"如果你這樣做，你會注意到運行 :command:`install` 命令首先運行 :command:`build`"
" 命令，在這種情況下，它很快就會注意到它沒有任何作用，因為一切在 :file:`build`"
" 目錄中是最新的。"

#: ../../install/index.rst:150
#, fuzzy
msgid ""
"You may not need this ability to break things down often if all you do is "
"install modules downloaded off the 'net, but it's very handy for more "
"advanced tasks.  If you get into distributing your own Python modules and "
"extensions, you'll run lots of individual Distutils commands on their own."
msgstr ""
"如果您所做的只是安裝從“網上”下載的模組，您可能不需要這種經常分解東西的能力，"
"但它對於更高階的任務來說非常方便。如果您開始分發自己的 Python 模組和擴充，"
"您將自己運行許多單獨的 Distutils 命令。"

#: ../../install/index.rst:159
#, fuzzy
msgid "How building works"
msgstr "建築是如何運作的"

#: ../../install/index.rst:161
#, fuzzy
msgid ""
"As implied above, the :command:`build` command is responsible for putting "
"the files to install into a *build directory*.  By default, this is :file:"
"`build` under the distribution root; if you're excessively concerned with "
"speed, or want to keep the source tree pristine, you can change the build "
"directory with the :option:`!--build-base` option. For example::"
msgstr ""
"如上所述，:command:`build` 命令負責將要安裝的文件放入 *build "
"目錄*。預設情況下，這是分髮根目錄下的 "
":file:`build`；如果您過分關注速度，或者想保持源程式碼樹的原始狀態，"
"您可以使用 :option:`!--build-base` 選項更改構建目錄。例如：："

#: ../../install/index.rst:169
#, fuzzy
msgid ""
"(Or you could do this permanently with a directive in your system or "
"personal Distutils configuration file; see section :ref:`inst-config-"
"files`.)  Normally, this isn't necessary."
msgstr ""
"（或者您可以使用系統或個人 Distutils 配置文件中的指令永久執行此操作；請參閱 "
":ref:`inst-config-files` 部分。）通常，這不是必需的。"

#: ../../install/index.rst:173
#, fuzzy
msgid "The default layout for the build tree is as follows::"
msgstr "構建樹的預設佈局如下："

#: ../../install/index.rst:180
#, fuzzy
msgid ""
"where ``<plat>`` expands to a brief description of the current OS/hardware "
"platform and Python version.  The first form, with just a :file:`lib` "
"directory, is used for \"pure module distributions\"---that is, module "
"distributions that include only pure Python modules.  If a module "
"distribution contains any extensions (modules written in C/C++), then the "
"second form, with two ``<plat>`` directories, is used.  In that case, the :"
"file:`temp.{plat}` directory holds temporary files generated by the compile/"
"link process that don't actually get installed.  In either case, the :file:"
"`lib` (or :file:`lib.{plat}`) directory contains all Python modules (pure "
"Python and extensions) that will be installed."
msgstr ""
"其中 ``<plat>`` 擴充為對當前操作系統/硬件平台和 Python "
"版本的簡要描述。第一種形式，只有一個 :file:`lib` 目錄，用於“純模組分發”——"
"即只包含純 Python 模組的模組分發。如果模組分發包含任何擴充（用 C/C++ "
"編寫的模組），則使用第二種形式，帶有兩個 ``<plat>`` "
"目錄。在這種情況下，:file:`temp.{plat}` 目錄包含編譯/鏈接過程生成的臨時文件，"
"這些文件實際上並未安裝。在任何一種情況下，:file:`lib`（或 "
":file:`lib.{plat}`）目錄包含將安裝的所有 Python 模組（純 Python 和擴充）。"

#: ../../install/index.rst:190
#, fuzzy
msgid ""
"In the future, more directories will be added to handle Python scripts, "
"documentation, binary executables, and whatever else is needed to handle the "
"job of installing Python modules and applications."
msgstr "將來，將新增更多目錄來處理 Python 腳本、文檔、二進位可執行文件以及處理安裝 "
"Python 模組和應用程式所需的任何其他內容。"

#: ../../install/index.rst:198
#, fuzzy
msgid "How installation works"
msgstr "安裝工作原理"

#: ../../install/index.rst:200
#, fuzzy
msgid ""
"After the :command:`build` command runs (whether you run it explicitly, or "
"the :command:`install` command does it for you), the work of the :command:"
"`install` command is relatively simple: all it has to do is copy everything "
"under :file:`build/lib` (or :file:`build/lib.{plat}`) to your chosen "
"installation directory."
msgstr ""
"在 :command:`build` 命令運行後（無論你顯式運行它，還是 :command:`install` "
"命令為你完成），:command:`install` 命令的工作相對簡單：它有要做的是將 :file:`"
"build/lib`（或 :file:`build/lib.{plat}`）下的所有內容複製到您選擇的安裝目錄。"

#: ../../install/index.rst:206
#, fuzzy
msgid ""
"If you don't choose an installation directory---i.e., if you just run "
"``setup.py install``\\ ---then the :command:`install` command installs to "
"the standard location for third-party Python modules.  This location varies "
"by platform and by how you built/installed Python itself.  On Unix (and "
"macOS, which is also Unix-based), it also depends on whether the module "
"distribution being installed is pure Python or contains extensions (\"non-"
"pure\"):"
msgstr ""
"如果你不選擇安裝目錄——即，如果你只是運行 ``setup.py install``\\ "
"---然後 :command:`install` 命令安裝到第三方 Python 模組的標準位置."
"此位置因平台以及您構建/安裝 Python 本身的方式而異。在 Unix（和同樣基於 Unix "
"的 macOS）上，它還取決於安裝的模組分發是純 Python 還是包含擴充（“非純”）："

#: ../../install/index.rst:216
msgid "Platform"
msgstr "平台"

#: ../../install/index.rst:216
#, fuzzy
msgid "Standard installation location"
msgstr "標準安裝位置"

#: ../../install/index.rst:216
#, fuzzy
msgid "Default value"
msgstr "預設值"

#: ../../install/index.rst:216 ../../install/index.rst:742
#: ../../install/index.rst:754
msgid "Notes"
msgstr "註解"

#: ../../install/index.rst:218
#, fuzzy
msgid "Unix (pure)"
msgstr "Unix（純）"

#: ../../install/index.rst:218 ../../install/index.rst:431
msgid ":file:`{prefix}/lib/python{X.Y}/site-packages`"
msgstr ":file:`{prefix}/lib/python{X.Y}/site-packages`"

#: ../../install/index.rst:218 ../../install/index.rst:220
msgid ":file:`/usr/local/lib/python{X.Y}/site-packages`"
msgstr ":file:`/usr/local/lib/python{X.Y}/site-packages`"

#: ../../install/index.rst:218 ../../install/index.rst:220
#: ../../install/index.rst:744
msgid "\\(1)"
msgstr "\\(1)"

#: ../../install/index.rst:220
#, fuzzy
msgid "Unix (non-pure)"
msgstr "Unix（非純）"

#: ../../install/index.rst:220 ../../install/index.rst:432
msgid ":file:`{exec-prefix}/lib/python{X.Y}/site-packages`"
msgstr ":file:`{exec-prefix}/lib/python{X.Y}/site-packages`"

#: ../../install/index.rst:222
msgid "Windows"
msgstr "Windows"

#: ../../install/index.rst:222 ../../install/index.rst:483
msgid ":file:`{prefix}\\\\Lib\\\\site-packages`"
msgstr ":file:`{prefix}\\\\Lib\\\\site-packages`"

#: ../../install/index.rst:222
msgid ":file:`C:\\\\Python{XY}\\\\Lib\\\\site-packages`"
msgstr ":file:`C:\\\\Python{XY}\\\\Lib\\\\site-packages`"

#: ../../install/index.rst:222 ../../install/index.rst:746
msgid "\\(2)"
msgstr "\\(2)"

#: ../../install/index.rst:225 ../../install/index.rst:766
msgid "Notes:"
msgstr "註解："

#: ../../install/index.rst:228
#, fuzzy
msgid ""
"Most Linux distributions include Python as a standard part of the system, "
"so :file:`{prefix}` and :file:`{exec-prefix}` are usually both :file:`/usr` "
"on Linux.  If you build Python yourself on Linux (or any Unix-like system), "
"the default :file:`{prefix}` and :file:`{exec-prefix}` are :file:`/usr/"
"local`."
msgstr ""
"大多數 Linux 發行版都將 Python 作為系統的標準部分，因此 :file:`{prefix}` 和 "
":file:`{exec-prefix}` 在 Linux 上通常都是 :file:`/usr`。如果你在 Linux（"
"或任何類 Unix 系統）上自己構建 Python，預設的 :file:`{prefix}` 和 :file:`{exec-"
"prefix}` 是 :file:`/usr/local`。"

#: ../../install/index.rst:234
#, fuzzy
msgid ""
"The default installation directory on Windows was :file:`C:\\\\Program Files"
"\\\\Python` under Python 1.6a1, 1.5.2, and earlier."
msgstr ""
"在 Python 1.6a1、1.5.2 和更早版本下，Windows 上的預設安裝目錄是 :file:`C:\\"
"\\Program Files\\\\Python`。"

#: ../../install/index.rst:237
#, fuzzy
msgid ""
":file:`{prefix}` and :file:`{exec-prefix}` stand for the directories that "
"Python is installed to, and where it finds its libraries at run-time.  They "
"are always the same under Windows, and very often the same under Unix and "
"macOS.  You can find out what your Python installation uses for :file:"
"`{prefix}` and :file:`{exec-prefix}` by running Python in interactive mode "
"and typing a few simple commands. Under Unix, just type ``python`` at the "
"shell prompt.  Under Windows, choose :menuselection:`Start --> Programs --> "
"Python X.Y --> Python (command line)`.   Once the interpreter is started, "
"you type Python code at the prompt.  For example, on my Linux system, I type "
"the three Python statements shown below, and get the output as shown, to "
"find out my :file:`{prefix}` and :file:`{exec-prefix}`:"
msgstr ""
":file:`{prefix}` 和 :file:`{exec-prefix}` 代表 Python "
"安裝到的目錄，以及它在運行時找到其庫的位置。它們在 Windows 下總是相同的，在 "
"Unix 和 macOS 下也經常相同。您可以通過在交互模式下運行 Python "
"並鍵入一些簡單的命令來了解您的 Python 安裝對 :file:`{prefix}` 和 :file"
":`{exec-prefix}` 使用了什麼。在 Unix 下，只需在 shell 提示符下鍵入 "
"``python``。在 Windows 下，選擇 :menuselection:`Start --> Programs --> "
"Python X.Y --> Python (command line)`。直譯器啟動後，您可以在提示符下鍵入 "
"Python 程式碼。例如，在我的 Linux 系統上，我鍵入如下所示的三個 Python "
"語句，並獲得如下所示的輸出，以找出我的 :file:`{prefix}` 和 :file:`{exec-"
"prefix}`："

#: ../../install/index.rst:259
#, fuzzy
msgid ""
"A few other placeholders are used in this document: :file:`{X.Y}` stands for "
"the version of Python, for example ``3.2``; :file:`{abiflags}` will be "
"replaced by the value of :data:`sys.abiflags` or the empty string for "
"platforms which don't define ABI flags; :file:`{distname}` will be replaced "
"by the name of the module distribution being installed.  Dots and "
"capitalization are important in the paths; for example, a value that uses "
"``python3.2`` on UNIX will typically use ``Python32`` on Windows."
msgstr ""
"本文檔中使用了一些其他佔位符：:file:`{X.Y}` 代表 Python 的版本，例如 ``3."
"2``； :file:`{abiflags}` 將替換為 :data:`sys.abiflags` 的值或未定義 ABI "
"旗標的平台的空字串； :file:`{distname}` "
"將替換為正在安裝的模組分發的名稱。點和大寫在路徑中很重要；例如，在 UNIX "
"上使用 ``python3.2`` 的值通常在 Windows 上使用 ``Python32``。"

#: ../../install/index.rst:267
#, fuzzy
msgid ""
"If you don't want to install modules to the standard location, or if you "
"don't have permission to write there, then you need to read about alternate "
"installations in section :ref:`inst-alt-install`.  If you want to customize "
"your installation directories more heavily, see section :ref:`inst-custom-"
"install` on custom installations."
msgstr ""
"如果您不想將模組安裝到標準位置，或者您沒有在那裡寫入的權限，那麼您需要閱讀 "
":ref:`inst-alt-install` "
"部分中的替代安裝。如果你想更多地自定義你的安裝目錄，請參閱自定義安裝部分：ref"
":`inst-custom-install`。"

#: ../../install/index.rst:277
#, fuzzy
msgid "Alternate Installation"
msgstr "備用安裝"

#: ../../install/index.rst:279
#, fuzzy
msgid ""
"Often, it is necessary or desirable to install modules to a location other "
"than the standard location for third-party Python modules.  For example, on "
"a Unix system you might not have permission to write to the standard third-"
"party module directory.  Or you might wish to try out a module before making "
"it a standard part of your local Python installation.  This is especially "
"true when upgrading a distribution already present: you want to make sure "
"your existing base of scripts still works with the new version before "
"actually upgrading."
msgstr ""
"通常，有必要或希望將模組安裝到第三方 Python 模組的標準位置以外的位置。例如，"
"在 Unix 系統上，您可能沒有寫入標準第三方模組目錄的權限。或者，"
"您可能希望在將某個模組作為本地 Python 安裝的標準部分之前對其進行試用。升級已"
"經存在的發行版時尤其如此：在實際升級之前，您要確保現有的腳本庫仍適用於新版本"
"。"

#: ../../install/index.rst:287
#, fuzzy
msgid ""
"The Distutils :command:`install` command is designed to make installing "
"module distributions to an alternate location simple and painless.  The "
"basic idea is that you supply a base directory for the installation, and "
"the :command:`install` command picks a set of directories (called an "
"*installation scheme*) under this base directory in which to install files.  "
"The details differ across platforms, so read whichever of the following "
"sections applies to you."
msgstr ""
"Distutils :command:`install` 命令旨在使將模組分發版安裝到備用位置變得簡單而輕"
"鬆。基本思想是您為安裝提供一個基本目錄，然後 :command:`install` 命令在這個基"
"本目錄下選擇一組目錄（稱為*安裝方案*）來安裝文件。詳細資訊因平台而異，因此請"
"閱讀以下適用於您的部分。"

#: ../../install/index.rst:295
#, fuzzy
msgid ""
"Note that the various alternate installation schemes are mutually exclusive: "
"you can pass ``--user``, or ``--home``, or ``--prefix`` and ``--exec-"
"prefix``, or ``--install-base`` and ``--install-platbase``, but you can't "
"mix from these groups."
msgstr ""
"請注意，各種備用安裝方案是相互排斥的：您可以通過``--user``，或``--home``，或`"
"`--prefix``和``--exec-prefix``，或 ``--install-base`` 和 ``--install-"
"platbase``，但您不能混合使用這些組。"

#: ../../install/index.rst:304
#, fuzzy
msgid "Alternate installation: the user scheme"
msgstr "備用安裝：使用者方案"

#: ../../install/index.rst:306
#, fuzzy
msgid ""
"This scheme is designed to be the most convenient solution for users that "
"don't have write permission to the global site-packages directory or don't "
"want to install into it.  It is enabled with a simple option::"
msgstr "該方案旨在為沒有全局站點包目錄寫入權限或不想安裝到其中的使用者提供最方便的解"
"決方案。它通過一個簡單的選項啟用::"

#: ../../install/index.rst:312
#, fuzzy
msgid ""
"Files will be installed into subdirectories of :data:`site.USER_BASE` "
"(written as :file:`{userbase}` hereafter).  This scheme installs pure Python "
"modules and extension modules in the same location (also known as :data:"
"`site.USER_SITE`). Here are the values for UNIX, including macOS:"
msgstr ""
"文件將被安裝到 :data:`site.USER_BASE` 的子目錄中（以下寫為 "
":file:`{userbase}`）。該方案將純 Python 模組和擴充模組安裝在同一位置（也稱為 "
":data:`site.USER_SITE`）。以下是 UNIX 的值，包括 macOS："

#: ../../install/index.rst:318 ../../install/index.rst:329
#: ../../install/index.rst:380 ../../install/index.rst:429
#: ../../install/index.rst:481 ../../install/index.rst:506
#: ../../install/index.rst:742 ../../install/index.rst:754
#, fuzzy
msgid "Type of file"
msgstr "文件型別"

#: ../../install/index.rst:318 ../../install/index.rst:329
#: ../../install/index.rst:380 ../../install/index.rst:429
#: ../../install/index.rst:481
#, fuzzy
msgid "Installation directory"
msgstr "安裝目錄"

#: ../../install/index.rst:320 ../../install/index.rst:331
#: ../../install/index.rst:382 ../../install/index.rst:483
msgid "modules"
msgstr "模組"

#: ../../install/index.rst:320
msgid ":file:`{userbase}/lib/python{X.Y}/site-packages`"
msgstr ":file:`{userbase}/lib/python{X.Y}/site-packages`"

#: ../../install/index.rst:321 ../../install/index.rst:332
#: ../../install/index.rst:383 ../../install/index.rst:433
#: ../../install/index.rst:484 ../../install/index.rst:511
#, fuzzy
msgid "scripts"
msgstr "劇本"

#: ../../install/index.rst:321
msgid ":file:`{userbase}/bin`"
msgstr ":file:`{userbase}/bin`"

#: ../../install/index.rst:322 ../../install/index.rst:333
#: ../../install/index.rst:384 ../../install/index.rst:434
#: ../../install/index.rst:485 ../../install/index.rst:512
#, fuzzy
msgid "data"
msgstr "資料"

#: ../../install/index.rst:322 ../../install/index.rst:333
msgid ":file:`{userbase}`"
msgstr ":file:`{userbase}`"

#: ../../install/index.rst:323 ../../install/index.rst:334
#: ../../install/index.rst:385 ../../install/index.rst:435
#: ../../install/index.rst:486 ../../install/index.rst:513
#, fuzzy
msgid "C headers"
msgstr "C標頭檔"

#: ../../install/index.rst:323
msgid ":file:`{userbase}/include/python{X.Y}{abiflags}/{distname}`"
msgstr ":file:`{userbase}/include/python{X.Y}{abiflags}/{distname}`"

#: ../../install/index.rst:326
#, fuzzy
msgid "And here are the values used on Windows:"
msgstr "以下是 Windows 上使用的值："

#: ../../install/index.rst:331
msgid ":file:`{userbase}\\\\Python{XY}\\\\site-packages`"
msgstr ":file:`{userbase}\\\\Python{XY}\\\\site-packages`"

#: ../../install/index.rst:332
msgid ":file:`{userbase}\\\\Python{XY}\\\\Scripts`"
msgstr ":file:`{userbase}\\\\Python{XY}\\\\Scripts`"

#: ../../install/index.rst:334
msgid ":file:`{userbase}\\\\Python{XY}\\\\Include\\\\{distname}`"
msgstr ":file:`{userbase}\\\\Python{XY}\\\\Include\\\\{distname}`"

#: ../../install/index.rst:337
#, fuzzy
msgid ""
"The advantage of using this scheme compared to the other ones described "
"below is that the user site-packages directory is under normal conditions "
"always included in :data:`sys.path` (see :mod:`site` for more information), "
"which means that there is no additional step to perform after running the :"
"file:`setup.py` script to finalize the installation."
msgstr ""
"與下面描述的其他方案相比，"
"使用此方案的優勢在於使用者站點包目錄在正常情況下始終包含在 :data:`sys.path` "
"中（有關更多資訊，請參見 :mod:`site`），這意味著在運行 :file:`setup.py` "
"腳本完成安裝後無需執行額外的步驟。"

#: ../../install/index.rst:343
#, fuzzy
msgid ""
"The :command:`build_ext` command also has a ``--user`` option to add :file:"
"`{userbase}/include` to the compiler search path for header files and :file:"
"`{userbase}/lib` to the compiler search path for libraries as well as to the "
"runtime search path for shared C libraries (rpath)."
msgstr ""
":command:`build_ext` 命令還有一個 ``--user`` 選項，用於將 "
":file:`{userbase}/include` 新增到標頭檔的編譯器搜索路徑和 "
":file:`{userbase}/lib`庫的編譯器搜索路徑以及共享 C 庫 (rpath) "
"的運行時搜索路徑。"

#: ../../install/index.rst:352
#, fuzzy
msgid "Alternate installation: the home scheme"
msgstr "備用安裝：家庭方案"

#: ../../install/index.rst:354
#, fuzzy
msgid ""
"The idea behind the \"home scheme\" is that you build and maintain a "
"personal stash of Python modules.  This scheme's name is derived from the "
"idea of a \"home\" directory on Unix, since it's not unusual for a Unix user "
"to make their home directory have a layout similar to :file:`/usr/` or :file:"
"`/usr/local/`. This scheme can be used by anyone, regardless of the "
"operating system they are installing for."
msgstr ""
"“home scheme”背後的想法是構建和維護 Python 模組的個人儲存。該方案的名稱源自 "
"Unix 上 ``主``目錄的概念，因為 Unix 使用者將其主目錄設定為類似於 :file:`/usr/` "
"或 :file:`/usr "
"的佈局並不罕見/本地/`。任何人都可以使用此方案，無論他們安裝的操作系統是什麼。"

#: ../../install/index.rst:361
#, fuzzy
msgid "Installing a new module distribution is as simple as ::"
msgstr "安裝一個新的模組分發就像 :: 一樣簡單"

#: ../../install/index.rst:365
#, fuzzy
msgid ""
"where you can supply any directory you like for the :option:`!--home` "
"option.  On Unix, lazy typists can just type a tilde (``~``); the :command:"
"`install` command will expand this to your home directory::"
msgstr ""
"您可以在其中為 :option:`!--home` 選項提供您喜歡的任何目錄。在 Unix 上，"
"懶惰的打字員可以只輸入波浪號 (``~``)； :command:`install` "
"命令會將其擴充到您的主目錄::"

#: ../../install/index.rst:371
#, fuzzy
msgid ""
"To make Python find the distributions installed with this scheme, you may "
"have to :ref:`modify Python's search path <inst-search-path>` or edit :mod:"
"`sitecustomize` (see :mod:`site`) to call :func:`site.addsitedir` or edit :"
"data:`sys.path`."
msgstr ""
"要讓 Python 找到使用此方案安裝的發行版，您可能需要修改 Python 的搜索路徑 "
"<inst-search-path> 或編輯 sitecustomize（參見 site）來呼叫 :func:`site."
"addsitedir` 或編輯 :data:`sys.path`。"

#: ../../install/index.rst:376
#, fuzzy
msgid ""
"The :option:`!--home` option defines the installation base directory.  Files "
"are installed to the following directories under the installation base as "
"follows:"
msgstr ":option:`!--home` 選項定義安裝基目錄。文件安裝到安裝庫下的以下目錄如下："

#: ../../install/index.rst:382
msgid ":file:`{home}/lib/python`"
msgstr ":file:`{home}/lib/python`"

#: ../../install/index.rst:383
msgid ":file:`{home}/bin`"
msgstr ":file:`{home}/bin`"

#: ../../install/index.rst:384
msgid ":file:`{home}`"
msgstr ":file:`{home}`"

#: ../../install/index.rst:385
msgid ":file:`{home}/include/python/{distname}`"
msgstr ":file:`{home}/include/python/{distname}`"

#: ../../install/index.rst:388
#, fuzzy
msgid "(Mentally replace slashes with backslashes if you're on Windows.)"
msgstr "（如果您使用的是 Windows，請在心裡用反斜杠替換斜杠。）"

#: ../../install/index.rst:394
#, fuzzy
msgid "Alternate installation: Unix (the prefix scheme)"
msgstr "備用安裝：Unix（前綴方案）"

#: ../../install/index.rst:396
#, fuzzy
msgid ""
"The \"prefix scheme\" is useful when you wish to use one Python installation "
"to perform the build/install (i.e., to run the setup script), but install "
"modules into the third-party module directory of a different Python "
"installation (or something that looks like a different Python "
"installation).  If this sounds a trifle unusual, it is---that's why the user "
"and home schemes come before.  However, there are at least two known cases "
"where the prefix scheme will be useful."
msgstr ""
"當您希望使用一個 Python 安裝來執行構建/安裝（即運行安裝腳本），"
"但將模組安裝到另一個 Python 安裝的第三方模組目錄（或其他看起來像是不同的 "
"Python 安裝）。如果這聽起來有點不尋常，那就是——這就是使用者和家庭方案出現在前"
"面的原因。然而，至少有兩個已知的前綴方案有用的案例。"

#: ../../install/index.rst:403
#, fuzzy
msgid ""
"First, consider that many Linux distributions put Python in :file:`/usr`, "
"rather than the more traditional :file:`/usr/local`.  This is entirely "
"appropriate, since in those cases Python is part of \"the system\" rather "
"than a local add-on. However, if you are installing Python modules from "
"source, you probably want them to go in :file:`/usr/local/lib/python2.{X}` "
"rather than :file:`/usr/lib/python2.{X}`.  This can be done with ::"
msgstr ""
"首先，考慮到許多 Linux 發行版將 Python "
"放在 :file:`/usr`，而不是更傳統的 :file:`/usr/"
"local`。這是完全合適的，因為在那些情況下，Python "
"是“系統”的一部分，而不是本地附加組件。但是，如果您從源程式碼安裝 Python "
"模組，您可能希望它們進入 :file:`/usr/local/lib/python2.{X}` 而不是 :file:`/usr/"
"lib/python2.{X }`。這可以通過 :: 來完成"

#: ../../install/index.rst:412
#, fuzzy
msgid ""
"Another possibility is a network filesystem where the name used to write to "
"a remote directory is different from the name used to read it: for example, "
"the Python interpreter accessed as :file:`/usr/local/bin/python` might "
"search for modules in :file:`/usr/local/lib/python2.{X}`, but those modules "
"would have to be installed to, say, :file:`/mnt/{@server}/export/lib/python2."
"{X}`.  This could be done with ::"
msgstr ""
"另一種可能性是網絡文件系統，其中用於寫入遠程目錄的名稱與用於讀取它的名稱不同"
"：例如，作為 :file:`/usr/local/bin/python` 訪問的 Python "
"直譯器可能會搜索 :file:`/usr/local/lib/python2.{X}` "
"中的模組，但這些模組必須安裝到，比如說，:file:`/mnt/{@server}/export/lib/"
"python2. {X}`。這可以通過 :: 來完成"

#: ../../install/index.rst:421
#, fuzzy
msgid ""
"In either case, the :option:`!--prefix` option defines the installation "
"base, and the :option:`!--exec-prefix` option defines the platform-specific "
"installation base, which is used for platform-specific files.  (Currently, "
"this just means non-pure module distributions, but could be expanded to C "
"libraries, binary executables, etc.)  If :option:`!--exec-prefix` is not "
"supplied, it defaults to :option:`!--prefix`.  Files are installed as "
"follows:"
msgstr ""
"在任何一種情況下，:option:`!--prefix` 選項定義安裝基礎，而 :option:`!--exec-"
"prefix` 選項定義特定於平台的安裝基礎，用於特定於平台的文件. "
"（目前，這僅意味著非純模組分發，但可以擴充到 C 庫、二進位可執行文件等。）"
"如果未提供 :option:`!--exec-prefix`，則預設為 :option:`! "
"--前綴`。文件安裝如下："

#: ../../install/index.rst:431 ../../install/index.rst:508
#, fuzzy
msgid "Python modules"
msgstr "Python模組"

#: ../../install/index.rst:432 ../../install/index.rst:509
#, fuzzy
msgid "extension modules"
msgstr "擴充模組"

#: ../../install/index.rst:433
msgid ":file:`{prefix}/bin`"
msgstr ":file:`{prefix}/bin`"

#: ../../install/index.rst:434 ../../install/index.rst:485
msgid ":file:`{prefix}`"
msgstr ":file:`{prefix}`"

#: ../../install/index.rst:435
msgid ":file:`{prefix}/include/python{X.Y}{abiflags}/{distname}`"
msgstr ":file:`{prefix}/include/python{X.Y}{abiflags}/{distname}`"

#: ../../install/index.rst:438
#, fuzzy
msgid ""
"There is no requirement that :option:`!--prefix` or :option:`!--exec-prefix` "
"actually point to an alternate Python installation; if the directories "
"listed above do not already exist, they are created at installation time."
msgstr ""
"不要求 :option:`!--prefix` 或 :option:`!--exec-prefix` 實際上指向備用 Python "
"安裝；如果上面列出的目錄尚不存在，它們將在安裝時建立。"

#: ../../install/index.rst:442
#, fuzzy
msgid ""
"Incidentally, the real reason the prefix scheme is important is simply that "
"a standard Unix installation uses the prefix scheme, but with :option:`!--"
"prefix` and :option:`!--exec-prefix` supplied by Python itself as ``sys."
"prefix`` and ``sys.exec_prefix``.  Thus, you might think you'll never use "
"the prefix scheme, but every time you run ``python setup.py install`` "
"without any other options, you're using it."
msgstr ""
"順便說一句，前綴方案很重要的真正原因僅僅是標準的 Unix 安裝使用前綴方案，但是 "
":option:`!--prefix` 和 :option:`!--exec-prefix` 由 Python 本身提供``sys."
"prefix`` 和 ``sys.exec_prefix``。因此，您可能認為您永遠不會使用前綴方案，"
"但每次您在沒有任何其他選項的情況下運行 ``python setup.py install`` "
"時，您都在使用它。"

#: ../../install/index.rst:449
#, fuzzy
msgid ""
"Note that installing extensions to an alternate Python installation has no "
"effect on how those extensions are built: in particular, the Python header "
"files (:file:`Python.h` and friends) installed with the Python interpreter "
"used to run the setup script will be used in compiling extensions.  It is "
"your responsibility to ensure that the interpreter used to run extensions "
"installed in this way is compatible with the interpreter used to build "
"them.  The best way to do this is to ensure that the two interpreters are "
"the same version of Python (possibly different builds, or possibly copies of "
"the same build).  (Of course, if your :option:`!--prefix` and :option:`!--"
"exec-prefix` don't even point to an alternate Python installation, this is "
"immaterial.)"
msgstr ""
"請注意，將擴充安裝到備用 Python 安裝不會影響這些擴充的構建方式：特別是，"
"與用於運行安裝腳本的 Python 直譯器一起安裝的 Python 標頭檔（:file:`Python.h` "
"和朋友）將用於編譯擴充。您有責任確保用於運行以這種方式安裝的擴充的直譯器與用"
"於構建它們的直譯器相容。最好的方法是確保兩個直譯器是相同版本的 "
"Python（可能是不同的構建，或者可能是同一構建的副本）。 （當然，如果您的 "
":option:`!--prefix` 和 :option:`!--exec-prefix` 甚至不指向備用 Python "
"安裝，這無關緊要。）"

#: ../../install/index.rst:464
#, fuzzy
msgid "Alternate installation: Windows (the prefix scheme)"
msgstr "備用安裝：Windows（前綴方案）"

#: ../../install/index.rst:466
#, fuzzy
msgid ""
"Windows has no concept of a user's home directory, and since the standard "
"Python installation under Windows is simpler than under Unix, the :option:"
"`!--prefix` option has traditionally been used to install additional "
"packages in separate locations on Windows. ::"
msgstr ""
"Windows 沒有使用者主目錄的概念，並且由於 Windows 下的標準 Python 安裝比 Unix "
"下的安裝簡單，因此 :option:`!--prefix` 選項傳統上用於在 Windows "
"上的不同位置安裝其他包。 ::"

#: ../../install/index.rst:473
#, fuzzy
msgid ""
"to install modules to the :file:`\\\\Temp\\\\Python` directory on the "
"current drive."
msgstr "將模組安裝到當前驅動器上的 :file:`\\\\Temp\\\\Python` 目錄。"

#: ../../install/index.rst:475
#, fuzzy
msgid ""
"The installation base is defined by the :option:`!--prefix` option; the :"
"option:`!--exec-prefix` option is not supported under Windows, which means "
"that pure Python modules and extension modules are installed into the same "
"location. Files are installed as follows:"
msgstr ""
"安裝基礎由 :option:`!--prefix` 選項定義； Windows 不支援 :option:`!--exec-"
"prefix` 選項，這意味著純 Python 模組和擴充模組安裝在同一位置。文件安裝如下："

#: ../../install/index.rst:484
msgid ":file:`{prefix}\\\\Scripts`"
msgstr ":file:`{prefix}\\\\Scripts`"

#: ../../install/index.rst:486
msgid ":file:`{prefix}\\\\Include\\\\{distname}`"
msgstr ":file:`{prefix}\\\\Include\\\\{distname}`"

#: ../../install/index.rst:493
#, fuzzy
msgid "Custom Installation"
msgstr "自定義安裝"

#: ../../install/index.rst:495
#, fuzzy
msgid ""
"Sometimes, the alternate installation schemes described in section :ref:"
"`inst-alt-install` just don't do what you want.  You might want to tweak "
"just one or two directories while keeping everything under the same base "
"directory, or you might want to completely redefine the installation "
"scheme.  In either case, you're creating a *custom installation scheme*."
msgstr ""
"有時，在 :ref:`inst-alt-install` 部分中描述的替代安裝方案並不能滿足您的要求。"
"您可能只想調整一兩個目錄，同時將所有內容都保存在同一基本目錄下，或者您可能想"
"要完全重新定義安裝方案。無論哪種情況，您都在建立*自定義安裝方案*。"

#: ../../install/index.rst:501
#, fuzzy
msgid ""
"To create a custom installation scheme, you start with one of the alternate "
"schemes and override some of the installation directories used for the "
"various types of files, using these options:"
msgstr "要建立自定義安裝方案，您可以從其中一種替代方案開始，並使用以下選項覆蓋用於各"
"種型別文件的一些安裝目錄："

#: ../../install/index.rst:506
#, fuzzy
msgid "Override option"
msgstr "覆蓋選項"

#: ../../install/index.rst:508
msgid "``--install-purelib``"
msgstr "``--install-purelib``"

#: ../../install/index.rst:509
msgid "``--install-platlib``"
msgstr "``--install-platlib``"

#: ../../install/index.rst:510
#, fuzzy
msgid "all modules"
msgstr "所有模組"

#: ../../install/index.rst:510
msgid "``--install-lib``"
msgstr "``--install-lib``"

#: ../../install/index.rst:511
msgid "``--install-scripts``"
msgstr "``--install-scripts``"

#: ../../install/index.rst:512
msgid "``--install-data``"
msgstr "``--install-data``"

#: ../../install/index.rst:513
msgid "``--install-headers``"
msgstr "``--install-headers``"

#: ../../install/index.rst:516
#, fuzzy
msgid ""
"These override options can be relative, absolute, or explicitly defined in "
"terms of one of the installation base directories. (There are two "
"installation base directories, and they are normally the same---they only "
"differ when you use the Unix \"prefix scheme\" and supply different ``--"
"prefix`` and ``--exec-prefix`` options; using ``--install-lib`` will "
"override values computed or given for ``--install-purelib`` and ``--install-"
"platlib``, and is recommended for schemes that don't make a difference "
"between Python and extension modules.)"
msgstr ""
"這些覆蓋選項可以是相對的、絕對的，或者根據其中一個安裝基目錄顯式定義。 "
"（有兩個安裝基礎目錄，它們通常是相同的——它們僅在您使用 Unix“前綴方案”"
"並提供不同的 ``--prefix`` 和 ``--exec-prefix`` 選項時不同; 使用 ``--install-"
"lib`` 將覆蓋為 ``--install-purelib`` 和 ``--install-platlib`` "
"計算或給出的值，建議用於沒有區別的方案在 Python 和擴充模組之間。）"

#: ../../install/index.rst:525
#, fuzzy
msgid ""
"For example, say you're installing a module distribution to your home "
"directory under Unix---but you want scripts to go in :file:`~/scripts` "
"rather than :file:`~/bin`. As you might expect, you can override this "
"directory with the :option:`!--install-scripts` option; in this case, it "
"makes most sense to supply a relative path, which will be interpreted "
"relative to the installation base directory (your home directory, in this "
"case)::"
msgstr ""
"例如，假設您要在 Unix 下將模組分發安裝到您的主目錄中——但您希望將腳本放在 "
":file:`~/scripts` 而不是 :file:`~/bin` 中。如您所料，您可以使用 :option"
":`!--install-scripts` 選項覆蓋此目錄；在這種情況下，提供相對路徑最有意義，該"
"路徑將相對於安裝基目錄（在本例中為您的主目錄）進行解釋："

#: ../../install/index.rst:534
#, fuzzy
msgid ""
"Another Unix example: suppose your Python installation was built and "
"installed with a prefix of :file:`/usr/local/python`, so under a standard  "
"installation scripts will wind up in :file:`/usr/local/python/bin`.  If you "
"want them in :file:`/usr/local/bin` instead, you would supply this absolute "
"directory for the :option:`!--install-scripts` option::"
msgstr ""
"另一個 Unix 示例：假設您的 Python 安裝是使用前綴 :file:`/usr/local/python` "
"構建和安裝的，因此在標準安裝腳本下，腳本將在 :file:`/usr/local/python/bin "
"中結束`。如果你想把它們放在 :file:`/usr/local/bin` 中，你可以為:option"
":`!--install-scripts` 選項提供這個絕對目錄::"

#: ../../install/index.rst:542
#, fuzzy
msgid ""
"(This performs an installation using the \"prefix scheme\", where the prefix "
"is whatever your Python interpreter was installed with--- :file:`/usr/local/"
"python` in this case.)"
msgstr ""
"（這會使用“前綴方案”執行安裝，其中前綴是安裝 Python 直譯器時使用的任何內容——"
"在本例中為 :file:`/usr/local/python`。）"

#: ../../install/index.rst:546
#, fuzzy
msgid ""
"If you maintain Python on Windows, you might want third-party modules to "
"live in a subdirectory of :file:`{prefix}`, rather than right in :file:"
"`{prefix}` itself.  This is almost as easy as customizing the script "
"installation directory---you just have to remember that there are two types "
"of modules to worry about, Python and extension modules, which can "
"conveniently be both controlled by one option::"
msgstr ""
"如果您在 Windows 上維護 Python，您可能希望第三方模組位於 :file:`{prefix}` "
"的子目錄中，而不是直接位於 :file:`{prefix}` 本身。這幾乎和自定義腳本安裝目錄"
"一樣簡單——你只需要記住有兩種型別的模組需要擔心，Python "
"和擴充模組，它們可以通過一個選項方便地控制："

#: ../../install/index.rst:555
#, fuzzy
msgid ""
"The specified installation directory is relative to :file:`{prefix}`.  Of "
"course, you also have to ensure that this directory is in Python's module "
"search path, such as by putting a :file:`.pth` file in a site directory "
"(see :mod:`site`).  See section :ref:`inst-search-path` to find out how to "
"modify Python's search path."
msgstr ""
"指定的安裝目錄是相對於 :file:`{prefix}` 的。當然，您還必須確保此目錄在 "
"Python 的模組搜索路徑中，例如將 :file:`.pth` 文件放在站點目錄中（參見 "
":mod:`site`）。請參閱 :ref:`inst-search-path` 部分以了解如何修改 Python "
"的搜索路徑。"

#: ../../install/index.rst:561
#, fuzzy
msgid ""
"If you want to define an entire installation scheme, you just have to supply "
"all of the installation directory options.  The recommended way to do this "
"is to supply relative paths; for example, if you want to maintain all Python "
"module-related files under :file:`python` in your home directory, and you "
"want a separate directory for each platform that you use your home directory "
"from, you might define the following installation scheme::"
msgstr ""
"如果你想定義一個完整的安裝方案，你只需要提供所有的安裝目錄選項。推薦的方法是"
"提供相對路徑；例如，如果您想在您的主目錄中的 :file:`python` 下維護所有與 "
"Python 模組相關的文件，並且您希望為您使用主目錄的每個平台建立一個單獨的目錄，"
"您可以定義以下安裝方案::"

#: ../../install/index.rst:574
#, fuzzy
msgid "or, equivalently, ::"
msgstr "或者，等效地，::"

#: ../../install/index.rst:582
#, fuzzy
msgid ""
"``$PLAT`` is not (necessarily) an environment variable---it will be expanded "
"by the Distutils as it parses your command line options, just as it does "
"when parsing your configuration file(s)."
msgstr "``$PLAT`` 不是（必然）環境變數——它會在 Distutils "
"解析您的命令列選項時被擴充，就像它在解析您的配置文件時所做的那樣。"

#: ../../install/index.rst:586
#, fuzzy
msgid ""
"Obviously, specifying the entire installation scheme every time you install "
"a new module distribution would be very tedious.  Thus, you can put these "
"options into your Distutils config file (see section :ref:`inst-config-"
"files`):"
msgstr ""
"顯然，每次安裝新的模組分發時都指定整個安裝方案會非常繁瑣。因此，"
"您可以將這些選項放入您的 Distutils 配置文件中（參見 :ref:`inst-config-files` "
"部分）："

#: ../../install/index.rst:599
#, fuzzy
msgid "or, equivalently,"
msgstr "或者，等價地，"

#: ../../install/index.rst:610
#, fuzzy
msgid ""
"Note that these two are *not* equivalent if you supply a different "
"installation base directory when you run the setup script.  For example, ::"
msgstr "請注意，如果您在運行安裝腳本時提供不同的安裝基目錄，則這兩者 *不* "
"等效。例如， ：："

#: ../../install/index.rst:615
#, fuzzy
msgid ""
"would install pure modules to :file:`/tmp/python/lib` in the first case, and "
"to :file:`/tmp/lib` in the second case.  (For the second case, you probably "
"want to supply an installation base of :file:`/tmp/python`.)"
msgstr ""
"在第一種情況下將純模組安裝到 :file:`/tmp/python/"
"lib`，在第二種情況下安裝到 :file:`/tmp/lib`。 （對於第二種情況，"
"您可能希望提供 :file:`/tmp/python` 的安裝基礎。）"

#: ../../install/index.rst:619
#, fuzzy
msgid ""
"You probably noticed the use of ``$HOME`` and ``$PLAT`` in the sample "
"configuration file input.  These are Distutils configuration variables, "
"which bear a strong resemblance to environment variables. In fact, you can "
"use environment variables in config files on platforms that have such a "
"notion but the Distutils additionally define a few extra variables that may "
"not be in your environment, such as ``$PLAT``.  (And of course, on systems "
"that don't have environment variables, such as Mac OS 9, the configuration "
"variables supplied by the Distutils are the only ones you can use.) See "
"section :ref:`inst-config-files` for details."
msgstr ""
"您可能注意到在示例配置文件輸入中使用了``$HOME`` 和``$PLAT``。這些是 "
"Distutils 配置變數，與環境變數非常相似。事實上，您可以在具有此類概念的平台上"
"的配置文件中使用環境變數，但 Distutils "
"還額外定義了一些可能不在您的環境中的額外變數，例如 ``$PLAT``。 "
"（當然，在沒有環境變數的系統上，例如 Mac OS 9，Distutils "
"提供的配置變數是您唯一可以使用的。）參見 :ref:`inst-config-files` "
"部分了解細節。"

#: ../../install/index.rst:629
#, fuzzy
msgid ""
"When a :ref:`virtual environment <venv-def>` is activated, any options that "
"change the installation path will be ignored from all distutils "
"configuration files to prevent inadvertently installing projects outside of "
"the virtual environment."
msgstr ""
"當 :ref:`虛擬環境 <venv-def>` 被激活時，所有 distutils "
"配置文件都將忽略任何更改安裝路徑的選項，以防止無意中在虛擬環境之外安裝項目。"

#: ../../install/index.rst:643
#, fuzzy
msgid "Modifying Python's Search Path"
msgstr "修改 Python 的搜索路徑"

#: ../../install/index.rst:645
#, fuzzy
msgid ""
"When the Python interpreter executes an :keyword:`import` statement, it "
"searches for both Python code and extension modules along a search path.  A "
"default value for the path is configured into the Python binary when the "
"interpreter is built. You can determine the path by importing the :mod:`sys` "
"module and printing the value of ``sys.path``.   ::"
msgstr ""
"當 Python 直譯器執行 :keyword:`import` 語句時，它會沿著搜索路徑搜索 Python "
"程式碼和擴充模組。構建直譯器時，路徑的預設值被配置到 Python 二進位文件中。"
"您可以通過導入 :mod:`sys` 模組並印出 ``sys.path`` 的值來確定路徑。 ::"

#: ../../install/index.rst:662
#, fuzzy
msgid ""
"The null string in ``sys.path`` represents the current working directory."
msgstr "``sys.path`` 中的空字串表示當前工作目錄。"

#: ../../install/index.rst:664
#, fuzzy
msgid ""
"The expected convention for locally installed packages is to put them in "
"the :file:`{...}/site-packages/` directory, but you may want to install "
"Python modules into some arbitrary directory.  For example, your site may "
"have a convention of keeping all software related to the web server under :"
"file:`/www`. Add-on Python modules might then belong in :file:`/www/python`, "
"and in order to import them, this directory must be added to ``sys.path``.  "
"There are several different ways to add the directory."
msgstr ""
"本地安裝包的預期約定是將它們放在 :file:`{...}/site-packages/` 目錄中，"
"但您可能希望將 Python "
"模組安裝到某個任意目錄中。例如，您的站點可能有一個約定，將與 Web "
"伺服器相關的所有軟件都保存在 :file:`/www` 下。附加 Python 模組可能屬於 "
":file:`/www/python`，為了導入它們，必須將此目錄新增到 ``sys."
"path``。新增目錄有幾種不同的方法。"

#: ../../install/index.rst:672
#, fuzzy
msgid ""
"The most convenient way is to add a path configuration file to a directory "
"that's already on Python's path, usually to the :file:`.../site-packages/` "
"directory.  Path configuration files have an extension of :file:`.pth`, and "
"each line must contain a single path that will be appended to ``sys.path``.  "
"(Because the new paths are appended to ``sys.path``, modules in the added "
"directories will not override standard modules.  This means you can't use "
"this mechanism for installing fixed versions of standard modules.)"
msgstr ""
"最方便的方法是將路徑配置文件新增到 Python 路徑上已有的目錄，通常是 :file"
":`.../site-packages/` 目錄。路徑配置文件的擴充名為 :file:`.pth`，"
"每行必須包含一個將附加到 ``sys.path`` 的路徑。 （因為新路徑附加到“sys.path”，"
"新增目錄中的模組不會覆蓋標準模組。這意味著您不能使用此機制來安裝標準模組的固"
"定版本。）"

#: ../../install/index.rst:680
#, fuzzy
msgid ""
"Paths can be absolute or relative, in which case they're relative to the "
"directory containing the :file:`.pth` file.  See the documentation of the :"
"mod:`site` module for more information."
msgstr ""
"路徑可以是絕對路徑或相對路徑，在這種情況下它們是相對於包含 :file:`.pth` "
"文件的目錄。有關更多資訊，請參閱 :mod:`site` 模組的文檔。"

#: ../../install/index.rst:684
#, fuzzy
msgid ""
"A slightly less convenient way is to edit the :file:`site.py` file in "
"Python's standard library, and modify ``sys.path``.  :file:`site.py` is "
"automatically imported when the Python interpreter is executed, unless the :"
"option:`-S` switch is supplied to suppress this behaviour.  So you could "
"simply edit :file:`site.py` and add two lines to it:"
msgstr ""
"一種不太方便的方法是編輯 Python 標準庫中的 :file:`site.py` 文件，並修改 ``sys"
".path``。 :file:`site.py` 會在執行 Python "
"直譯器時自動導入，除非提供了 :option:`-S` 開關來抑制這種行為。"
"所以你可以簡單地編輯 :file:`site.py` 並向其中新增兩行："

#: ../../install/index.rst:695
#, fuzzy
msgid ""
"However, if you reinstall the same major version of Python (perhaps when "
"upgrading from 2.2 to 2.2.2, for example) :file:`site.py` will be "
"overwritten by the stock version.  You'd have to remember that it was "
"modified and save a copy before doing the installation."
msgstr ""
"但是，如果您重新安裝相同的主要版本的 Python（例如，可能從 2.2 升級到 2.2.2 "
"時） :file:`site.py` "
"將被原始版本覆蓋。您必須記住它已被修改並在安裝之前保存一份副本。"

#: ../../install/index.rst:700
#, fuzzy
msgid ""
"There are two environment variables that can modify ``sys.path``. :envvar:"
"`PYTHONHOME` sets an alternate value for the prefix of the Python "
"installation.  For example, if :envvar:`PYTHONHOME` is set to ``/www/"
"python``, the search path will be set to ``['', '/www/python/lib/pythonX."
"Y/', '/www/python/lib/pythonX.Y/plat-linux2', ...]``."
msgstr ""
"有兩個環境變數可以修改``sys.path``。 :envvar:`PYTHONHOME` 為 Python "
"安裝的前綴設定一個備用值。例如，如果 :envvar:`PYTHONHOME` 設定為 ``/www/"
"python``，則搜索路徑將設定為 ``['', '/www/python/lib/pythonX.Y/', ' /www/"
"python/lib/pythonX.Y/plat-linux2', ...]``。"

#: ../../install/index.rst:706
#, fuzzy
msgid ""
"The :envvar:`PYTHONPATH` variable can be set to a list of paths that will be "
"added to the beginning of ``sys.path``.  For example, if :envvar:"
"`PYTHONPATH` is set to ``/www/python:/opt/py``, the search path will begin "
"with ``['/www/python', '/opt/py']``.  (Note that directories must exist in "
"order to be added to ``sys.path``; the :mod:`site` module removes paths that "
"don't exist.)"
msgstr ""
":envvar:`PYTHONPATH` 變數可以設定為將新增到 ``sys.path`` "
"開頭的路徑列表。例如，如果 :envvar:`PYTHONPATH` 設定為``/www/python:/opt/"
"py``，搜索路徑將以``['/www/python', '/opt/py'] 開頭``。 （請注意，"
"目錄必須存在才能新增到 ``sys.path``；:mod:`site` 模組會刪除不存在的路徑。）"

#: ../../install/index.rst:713
#, fuzzy
msgid ""
"Finally, ``sys.path`` is just a regular Python list, so any Python "
"application can modify it by adding or removing entries."
msgstr "最後，``sys.path`` 只是一個常規的 Python 列表，因此任何 Python "
"應用程式都可以通過新增或刪除條目來修改它。"

#: ../../install/index.rst:720
#, fuzzy
msgid "Distutils Configuration Files"
msgstr "Distutils 配置文件"

#: ../../install/index.rst:722
#, fuzzy
msgid ""
"As mentioned above, you can use Distutils configuration files to record "
"personal or site preferences for any Distutils options.  That is, any option "
"to any command can be stored in one of two or three (depending on your "
"platform) configuration files, which will be consulted before the command-"
"line is parsed. This means that configuration files will override default "
"values, and the command-line will in turn override configuration files.  "
"Furthermore, if multiple configuration files apply, values from \"earlier\" "
"files are overridden by \"later\" files."
msgstr ""
"如上所述，您可以使用 Distutils 配置文件來記錄任何 Distutils 選項的個人或站點"
"首選項。也就是說，任何命令的任何選項都可以儲存在兩個或三個（取決於您的平台）"
"配置文件之一中，這些文件將在解析命令列之前進行查詢。這意味著配置文件將覆蓋預"
"設值，命令列將依次覆蓋配置文件。此外，如果應用多個配置文件，“較早”文件中的值"
"將被“較晚”文件覆蓋。"

#: ../../install/index.rst:735
#, fuzzy
msgid "Location and names of config files"
msgstr "配置文件的位置和名稱"

#: ../../install/index.rst:737
#, fuzzy
msgid ""
"The names and locations of the configuration files vary slightly across "
"platforms.  On Unix and macOS, the three configuration files (in the order "
"they are processed) are:"
msgstr "配置文件的名稱和位置在不同平台上略有不同。在 Unix 和 macOS "
"上，三個配置文件（按照它們被處理的順序）是："

#: ../../install/index.rst:742 ../../install/index.rst:754
#, fuzzy
msgid "Location and filename"
msgstr "位置和文件名"

#: ../../install/index.rst:744 ../../install/index.rst:756
#, fuzzy
msgid "system"
msgstr "系統"

#: ../../install/index.rst:744
msgid ":file:`{prefix}/lib/python{ver}/distutils/distutils.cfg`"
msgstr ":file:`{prefix}/lib/python{ver}/distutils/distutils.cfg`"

#: ../../install/index.rst:746 ../../install/index.rst:758
#, fuzzy
msgid "personal"
msgstr "個人的"

#: ../../install/index.rst:746
msgid ":file:`$HOME/.pydistutils.cfg`"
msgstr ":file:`$HOME/.pydistutils.cfg`"

#: ../../install/index.rst:748 ../../install/index.rst:760
#, fuzzy
msgid "local"
msgstr "當地的"

#: ../../install/index.rst:748 ../../install/index.rst:760
msgid ":file:`setup.cfg`"
msgstr ":file:`setup.cfg`"

#: ../../install/index.rst:748 ../../install/index.rst:760
msgid "\\(3)"
msgstr "\\(3)"

#: ../../install/index.rst:751
#, fuzzy
msgid "And on Windows, the configuration files are:"
msgstr "在 Windows 上，配置文件是："

#: ../../install/index.rst:756
msgid ":file:`{prefix}\\\\Lib\\\\distutils\\\\distutils.cfg`"
msgstr ":file:`{prefix}\\\\Lib\\\\distutils\\\\distutils.cfg`"

#: ../../install/index.rst:756
msgid "\\(4)"
msgstr "\\(4)"

#: ../../install/index.rst:758
msgid ":file:`%HOME%\\\\pydistutils.cfg`"
msgstr ":file:`%HOME%\\\\pydistutils.cfg`"

#: ../../install/index.rst:758
msgid "\\(5)"
msgstr "\\(5)"

#: ../../install/index.rst:763
#, fuzzy
msgid ""
"On all platforms, the \"personal\" file can be temporarily disabled by "
"passing the ``--no-user-cfg`` option."
msgstr "在所有平台上，可以通過傳遞 ``--no-user-cfg`` 選項暫時禁用“個人”文件。"

#: ../../install/index.rst:769
#, fuzzy
msgid ""
"Strictly speaking, the system-wide configuration file lives in the directory "
"where the Distutils are installed; under Python 1.6 and later on Unix, this "
"is as shown. For Python 1.5.2, the Distutils will normally be installed to :"
"file:`{prefix}/lib/python1.5/site-packages/distutils`, so the system "
"configuration file should be put there under Python 1.5.2."
msgstr ""
"嚴格來說，系統範圍的配置文件位於安裝 Distutils 的目錄中；在 Python 1.6 "
"和更高版本的 Unix 下，如圖所示。對於 Python 1.5.2，Distutils "
"通常會安裝到 :file:`{prefix}/lib/python1.5/site-packages/distutils`，"
"所以系統配置文件應該放在 Python 1.5.2 下。"

#: ../../install/index.rst:776
#, fuzzy
msgid ""
"On Unix, if the :envvar:`HOME` environment variable is not defined, the "
"user's home directory will be determined with the :func:`getpwuid` function "
"from the standard :mod:`pwd` module. This is done by the :func:`os.path."
"expanduser` function used by Distutils."
msgstr ""
"在 Unix 上，如果未定義 :envvar:`HOME` 環境變數，則使用者的主目錄將由標準 "
":mod:`pwd` 模組中的 :func:`getpwuid` 函式確定。這是由 Distutils 使用的 "
"os.path.expanduser 函式完成的。"

#: ../../install/index.rst:782
#, fuzzy
msgid ""
"I.e., in the current directory (usually the location of the setup script)."
msgstr "即，在當前目錄中（通常是安裝腳本的位置）。"

#: ../../install/index.rst:785
#, fuzzy
msgid ""
"(See also note (1).)  Under Python 1.6 and later, Python's default "
"\"installation prefix\" is :file:`C:\\\\Python`, so the system configuration "
"file is normally :file:`C:\\\\Python\\\\Lib\\\\distutils\\\\distutils.cfg`. "
"Under Python 1.5.2, the default prefix was :file:`C:\\\\Program Files\\"
"\\Python`, and the Distutils were not part of the standard library---so the "
"system configuration file would be :file:`C:\\\\Program Files\\\\Python\\"
"\\distutils\\\\distutils.cfg` in a standard Python 1.5.2 installation under "
"Windows."
msgstr ""
"（另見註（1）。）在Python 1.6及以後版本，Python預設的“安裝前綴”是 :file:`C:\\"
"\\Python`，所以系統配置文件一般是 :file:`C:\\\\Python\\ \\Lib\\\\distutils\\"
"\\distutils.cfg`。在 Python 1.5.2 下，預設前綴是 :file:`C:\\\\Program Files\\"
"\\Python`，並且 Distutils 不是標準庫的一部分——所以系統配置文件是 :file:`C :\\"
"\\Program Files\\\\Python\\\\distutils\\\\distutils.cfg` 在 Windows 下的標準 "
"Python 1.5.2 安裝中。"

#: ../../install/index.rst:794
#, fuzzy
msgid ""
"On Windows, if the :envvar:`HOME` environment variable is not defined, :"
"envvar:`USERPROFILE` then :envvar:`HOMEDRIVE` and :envvar:`HOMEPATH` will be "
"tried. This is done by the :func:`os.path.expanduser` function used by "
"Distutils."
msgstr ""
"在 Windows 上，如果未定義 :envvar:`HOME` 環境變數，則將嘗試 "
":envvar:`USERPROFILE` :envvar:`HOMEDRIVE` 和 :envvar:`HOMEPATH`。這是由 "
"Distutils 使用的 os.path.expanduser 函式完成的。"

#: ../../install/index.rst:803
#, fuzzy
msgid "Syntax of config files"
msgstr "配置文件的語法"

#: ../../install/index.rst:805
#, fuzzy
msgid ""
"The Distutils configuration files all have the same syntax.  The config "
"files are grouped into sections.  There is one section for each Distutils "
"command, plus a ``global`` section for global options that affect every "
"command.  Each section consists of one option per line, specified as "
"``option=value``."
msgstr ""
"Distutils 配置文件都具有相同的語法。配置文件分為幾個部分。每個 Distutils "
"命令都有一個部分，還有一個 ``global`` 部分用於影響每個命令的全局選項。每個部"
"分每行包含一個選項，指定為“option=value”。"

#: ../../install/index.rst:810
#, fuzzy
msgid ""
"For example, the following is a complete config file that just forces all "
"commands to run quietly by default:"
msgstr "例如，以下是一個完整的配置文件，它只是強制所有命令在預設情況下安靜地運行："

#: ../../install/index.rst:818
#, fuzzy
msgid ""
"If this is installed as the system config file, it will affect all "
"processing of any Python module distribution by any user on the current "
"system.  If it is installed as your personal config file (on systems that "
"support them), it will affect only module distributions processed by you.  "
"And if it is used as the :file:`setup.cfg` for a particular module "
"distribution, it affects only that distribution."
msgstr ""
"如果它作為系統配置文件安裝，它將影響當前系統上任何使用者對任何 Python 模組分"
"發的所有處理。如果它作為你的個人配置文件安裝（在支援它們的系統上），它只會影"
"響你處理的模組分發。如果它用作特定模組分發的 setup.cfg，它只會影響該分發。"

#: ../../install/index.rst:825
#, fuzzy
msgid ""
"You could override the default \"build base\" directory and make the :"
"command:`build\\*` commands always forcibly rebuild all files with the "
"following:"
msgstr "您可以覆蓋預設的“build base”目錄並使 :command:`build\\*` "
"命令始終使用以下內容強制重建所有文件："

#: ../../install/index.rst:835
#, fuzzy
msgid "which corresponds to the command-line arguments ::"
msgstr "對應於命令列參數 ::"

#: ../../install/index.rst:839
#, fuzzy
msgid ""
"except that including the :command:`build` command on the command-line means "
"that command will be run.  Including a particular command in config files "
"has no such implication; it only means that if the command is run, the "
"options in the config file will apply.  (Or if other commands that derive "
"values from it are run, they will use the values in the config file.)"
msgstr ""
"除了在命令列中包含 :command:`build` 命令意味著該命令將被運行。在配置文件中包"
"含特定命令沒有這樣的含義；這僅意味著如果運行該命令，將應用配置文件中的選項。 "
"（或者，如果運行從中派生值的其他命令，它們將使用配置文件中的值。）"

#: ../../install/index.rst:845
#, fuzzy
msgid ""
"You can find out the complete list of options for any command using the :"
"option:`!--help` option, e.g.::"
msgstr "您可以使用 :option:`!--help` 選項找到任何命令的完整選項列表，例如："

#: ../../install/index.rst:850
#, fuzzy
msgid ""
"and you can find out the complete list of global options by using :option:"
"`!--help` without a command::"
msgstr "您可以通過使用 :option:`!--help` 而不使用命令來找出全局選項的完整列表::"

#: ../../install/index.rst:855
#, fuzzy
msgid ""
"See also the \"Reference\" section of the \"Distributing Python Modules\" "
"manual."
msgstr "另請參閱“分發 Python 模組”手冊的“參考”部分。"

#: ../../install/index.rst:861
#, fuzzy
msgid "Building Extensions: Tips and Tricks"
msgstr "構建擴充：提示和技巧"

#: ../../install/index.rst:863
#, fuzzy
msgid ""
"Whenever possible, the Distutils try to use the configuration information "
"made available by the Python interpreter used to run the :file:`setup.py` "
"script. For example, the same compiler and linker flags used to compile "
"Python will also be used for compiling extensions.  Usually this will work "
"well, but in complicated situations this might be inappropriate.  This "
"section discusses how to override the usual Distutils behaviour."
msgstr ""
"只要有可能，Distutils 就會嘗試使用用於運行 setup.py 腳本的 Python "
"直譯器提供的配置資訊。例如，用於編譯 Python 的相同編譯器和鏈接器旗標也將用於"
"編譯擴充。通常這會很好地工作，但在復雜的情況下這可能是不合適的。"
"本節討論如何覆蓋通常的 Distutils 行為。"

#: ../../install/index.rst:874
#, fuzzy
msgid "Tweaking compiler/linker flags"
msgstr "調整編譯器/鏈接器旗標"

#: ../../install/index.rst:876
#, fuzzy
msgid ""
"Compiling a Python extension written in C or C++ will sometimes require "
"specifying custom flags for the compiler and linker in order to use a "
"particular library or produce a special kind of object code. This is "
"especially true if the extension hasn't been tested on your platform, or if "
"you're trying to cross-compile Python."
msgstr ""
"編譯用 C 或 C++ 編寫的 Python 擴充有時需要為編譯器和鏈接器指定自定義旗標，以"
"便使用特定的庫或生成特殊型別的目標程式碼。如果擴充尚未在您的平台上進行測試，"
"或者您正在嘗試交叉編譯 Python，則尤其如此。"

#: ../../install/index.rst:882
#, fuzzy
msgid ""
"In the most general case, the extension author might have foreseen that "
"compiling the extensions would be complicated, and provided a :file:`Setup` "
"file for you to edit.  This will likely only be done if the module "
"distribution contains many separate extension modules, or if they often "
"require elaborate sets of compiler flags in order to work."
msgstr ""
"在大多數情況下，擴充作者可能已經預見到編譯擴充會很複雜，並提供了一個 "
":file:`Setup` 文件供您編輯。只有當模組分發包含許多單獨的擴充模組，或者如果它"
"們經常需要精心設計的編譯器旗標集才能工作時，才可能這樣做。"

#: ../../install/index.rst:888
#, fuzzy
msgid ""
"A :file:`Setup` file, if present, is parsed in order to get a list of "
"extensions to build.  Each line in a :file:`Setup` describes a single "
"module.  Lines have the following structure::"
msgstr ""
"一個 :file:`Setup` 文件（如果存在）被解析以獲取要構建的擴充列表。 "
":file:`Setup` 中的每一行都描述了一個模組。行具有以下結構::"

#: ../../install/index.rst:895
#, fuzzy
msgid "Let's examine each of the fields in turn."
msgstr "讓我們依次檢查每個欄位。"

#: ../../install/index.rst:897
#, fuzzy
msgid ""
"*module* is the name of the extension module to be built, and should be a "
"valid Python identifier.  You can't just change this in order to rename a "
"module (edits to the source code would also be needed), so this should be "
"left alone."
msgstr ""
"*module* 是要構建的擴充模組的名稱，應該是一個有效的 Python 標識符。您不能僅僅"
"為了重命名模組而更改它（還需要對源程式碼進行編輯），因此應該保留它。"

#: ../../install/index.rst:901
#, fuzzy
msgid ""
"*sourcefile* is anything that's likely to be a source code file, at least "
"judging by the filename.  Filenames ending in :file:`.c` are assumed to be "
"written in C, filenames ending in :file:`.C`, :file:`.cc`, and :file:`.c++` "
"are assumed to be C++, and filenames ending in :file:`.m` or :file:`.mm` are "
"assumed to be in Objective C."
msgstr ""
"*sourcefile* 是任何可能是源程式碼文件的東西，至少從文件名來看是這樣。以 "
":file:`.c` 結尾的文件名假定為用 C 編寫的，以 :file:`.C`、:file:`.cc` 和 "
":file:`.c++` 結尾的文件名假定為 C++ , 以及以 :file:`.m` 或 :file:`.mm` "
"結尾的文件名被假定為在 Objective C 中。"

#: ../../install/index.rst:907
#, fuzzy
msgid ""
"*cpparg* is an argument for the C preprocessor,  and is anything starting "
"with :option:`!-I`, :option:`!-D`, :option:`!-U` or :option:`!-C`."
msgstr ""
"*cpparg* 是 C 預處理器的參數，可以是任何以 "
":option:`!-I`、:option:`!-D`、:option:`!-U` 或 :option:`!-C 開頭的內容`。"

#: ../../install/index.rst:910
#, fuzzy
msgid ""
"*library* is anything ending in :file:`.a` or beginning with :option:`!-l` "
"or :option:`!-L`."
msgstr "*library* 是以 :file:`.a` 結尾或以 :option:`!-l` 或 :option:`!-L` "
"開頭的任何內容。"

#: ../../install/index.rst:913
#, fuzzy
msgid ""
"If a particular platform requires a special library on your platform, you "
"can add it by editing the :file:`Setup` file and running ``python setup.py "
"build``. For example, if the module defined by the line ::"
msgstr ""
"如果特定平台需要您平台上的特殊庫，您可以通過編輯 :file:`Setup` 文件並運行 ``"
"python setup.py build`` 來新增它。例如，如果模組由行 ::"

#: ../../install/index.rst:919
#, fuzzy
msgid ""
"must be linked with the math library :file:`libm.a` on your platform, simply "
"add :option:`!-lm` to the line::"
msgstr "必須與您平台上的數學庫 :file:`libm.a` 鏈接，只需將 :option:`!-lm` 新增到行::"

#: ../../install/index.rst:924
#, fuzzy
msgid ""
"Arbitrary switches intended for the compiler or the linker can be supplied "
"with the :option:`!-Xcompiler` *arg* and :option:`!-Xlinker` *arg* options::"
msgstr ""
"用於編譯器或鏈接器的任意開關可以與 :option:`!-Xcompiler` *arg* "
"和 :option:`!-Xlinker` *arg* 選項一起提供："

#: ../../install/index.rst:929
#, fuzzy
msgid ""
"The next option after :option:`!-Xcompiler` and :option:`!-Xlinker` will be "
"appended to the proper command line, so in the above example the compiler "
"will be passed the :option:`!-o32` option, and the linker will be passed :"
"option:`!-shared`.  If a compiler option requires an argument, you'll have "
"to supply multiple :option:`!-Xcompiler` options; for example, to pass ``-x c"
"++`` the :file:`Setup` file would have to contain ``-Xcompiler -x -Xcompiler "
"c++``."
msgstr ""
":option:`!-Xcompiler` 和 :option:`!-Xlinker` "
"之後的下一個選項將附加到正確的命令列，因此在上面的示例中，編譯器將傳遞 "
":option:`!-o32` 選項, "
"鏈接器將被傳遞 :option:`!-shared`。如果編譯器選項需要參數，則必須提供多個 "
":option:`!-Xcompiler` 選項；例如，要傳遞 ``-x c++`` :file:`Setup` "
"文件必須包含 ``-Xcompiler -x -Xcompiler c++``。"

#: ../../install/index.rst:936
#, fuzzy
msgid ""
"Compiler flags can also be supplied through setting the :envvar:`CFLAGS` "
"environment variable.  If set, the contents of :envvar:`CFLAGS` will be "
"added to the compiler flags specified in the  :file:`Setup` file."
msgstr "也可以通過設定 CFLAGS 環境變數來提供編譯器旗標。如果設定，CFLAGS "
"的內容將新增到 Setup 文件中指定的編譯器旗標中。"

#: ../../install/index.rst:944
#, fuzzy
msgid "Using non-Microsoft compilers on Windows"
msgstr "在 Windows 上使用非 Microsoft 編譯器"

#: ../../install/index.rst:951
#, fuzzy
msgid "Borland/CodeGear C++"
msgstr "Borland/CodeGear C++"

#: ../../install/index.rst:953
#, fuzzy
msgid ""
"This subsection describes the necessary steps to use Distutils with the "
"Borland C++ compiler version 5.5.  First you have to know that Borland's "
"object file format (OMF) is different from the format used by the Python "
"version you can download from the Python or ActiveState web site.  (Python "
"is built with Microsoft Visual C++, which uses COFF as the object file "
"format.) For this reason you have to convert Python's library :file:"
"`python25.lib` into the Borland format.  You can do this as follows:"
msgstr ""
"本小節描述了將 Distutils 與 Borland C++ 編譯器 5.5 "
"版一起使用的必要步驟。首先，您必須知道 Borland 的目標文件格式 (OMF) "
"不同於您可以從 Python 或 ActiveState 網站下載的 Python 版本使用的格式。 （"
"Python 是用 Microsoft Visual C++ 構建的，它使用 COFF "
"作為目標文件格式。）因此，您必須將 Python 的庫 :file:`python25.lib` 轉換為 "
"Borland 格式。您可以按如下方式執行此操作："

#: ../../install/index.rst:968
#, fuzzy
msgid ""
"The :file:`coff2omf` program comes with the Borland compiler.  The file :"
"file:`python25.lib` is in the :file:`Libs` directory of your Python "
"installation.  If your extension uses other libraries (zlib, ...) you have "
"to convert them too."
msgstr ""
":file:`coff2omf` 程式隨 Borland 編譯器一起提供。文件 :file:`python25.lib` "
"位於 Python 安裝的 :file:`Libs` "
"目錄中。如果您的擴充使用其他庫（zlib，...），您也必須轉換它們。"

#: ../../install/index.rst:973
#, fuzzy
msgid ""
"The converted files have to reside in the same directories as the normal "
"libraries."
msgstr "轉換後的文件必須位於與普通庫相同的目錄中。"

#: ../../install/index.rst:976
#, fuzzy
msgid ""
"How does Distutils manage to use these libraries with their changed names?  "
"If the extension needs a library (eg. :file:`foo`) Distutils checks first if "
"it finds a library with suffix :file:`_bcpp` (eg. :file:`foo_bcpp.lib`) and "
"then uses this library.  In the case it doesn't find such a special library "
"it uses the default name (:file:`foo.lib`.) [#]_"
msgstr ""
"Distutils "
"如何設法使用這些名稱更改後的庫？如果擴充需要一個庫（例如 :file:`foo`），"
"Distutils 首先檢查它是否找到後綴為 :file:`_bcpp` 的庫（例如 :file:`foo_bcpp.l"
"ib`），然後使用這個庫。如果它沒有找到這樣一個特殊的庫，它會使用預設名稱（:fil"
"e:`foo.lib`。）[#]_"

#: ../../install/index.rst:982
#, fuzzy
msgid ""
"To let Distutils compile your extension with Borland C++ you now have to "
"type::"
msgstr "要讓 Distutils 使用 Borland C++ 編譯您的擴充，您現在必須輸入："

#: ../../install/index.rst:986
#, fuzzy
msgid ""
"If you want to use the Borland C++ compiler as the default, you could "
"specify this in your personal or system-wide configuration file for "
"Distutils (see section :ref:`inst-config-files`.)"
msgstr ""
"如果你想使用 Borland C++ 編譯器作為預設編譯器，你可以在你的個人或系統範圍的 "
"Distutils 配置文件中指定它（參見 :ref:`inst-config-files` 部分。）"

#: ../../install/index.rst:995
#, fuzzy
msgid "`C++Builder Compiler <https://www.embarcadero.com/products>`_"
msgstr "`C++Builder 編譯器 <https://www.embarcadero.com/products>`_"

#: ../../install/index.rst:994
#, fuzzy
msgid ""
"Information about the free C++ compiler from Borland, including links to the "
"download pages."
msgstr "關於來自 Borland 的免費 C++ 編譯器的資訊，包括下載頁面的鏈接。"

#: ../../install/index.rst:998
#, fuzzy
msgid ""
"`Creating Python Extensions Using Borland's Free Compiler <http://www."
"cyberus.ca/~g_will/pyExtenDL.shtml>`_"
msgstr ""
"`使用 Borland 的免費編譯器建立 Python 擴充 <http://www.cyberus.ca/~g_will/"
"pyExtenDL.shtml>`_"

#: ../../install/index.rst:998
#, fuzzy
msgid ""
"Document describing how to use Borland's free command-line C++ compiler to "
"build Python."
msgstr "描述如何使用 Borland 的免費命令列 C++ 編譯器構建 Python 的文檔。"

#: ../../install/index.rst:1003
#, fuzzy
msgid "GNU C / Cygwin / MinGW"
msgstr "GNU C / Cygwin / MinGW"

#: ../../install/index.rst:1005
#, fuzzy
msgid ""
"This section describes the necessary steps to use Distutils with the GNU C/C+"
"+ compilers in their Cygwin and MinGW distributions. [#]_ For a Python "
"interpreter that was built with Cygwin, everything should work without any "
"of these following steps."
msgstr ""
"本節描述了在其 Cygwin 和 MinGW 發行版中將 Distutils 與 GNU C/C++ "
"編譯器一起使用的必要步驟。 [#]_ 對於使用 Cygwin 構建的 Python "
"直譯器，無需執行以下任何步驟，一切都應該可以正常工作。"

#: ../../install/index.rst:1010
#, fuzzy
msgid ""
"Not all extensions can be built with MinGW or Cygwin, but many can.  "
"Extensions most likely to not work are those that use C++ or depend on "
"Microsoft Visual C extensions."
msgstr ""
"並非所有擴充都可以使用 MinGW 或 Cygwin 構建，但很多都可以。"
"最有可能不起作用的擴充是那些使用 C++ 或依賴於 Microsoft Visual C 擴充的擴充。"

#: ../../install/index.rst:1014
#, fuzzy
msgid "To let Distutils compile your extension with Cygwin you have to type::"
msgstr "要讓 Distutils 使用 Cygwin 編譯您的擴充，您必須輸入："

#: ../../install/index.rst:1018
#, fuzzy
msgid "and for Cygwin in no-cygwin mode [#]_ or for MinGW type::"
msgstr "對於非 cygwin 模式下的 Cygwin [#]_ 或對於 MinGW 型別："

#: ../../install/index.rst:1022
#, fuzzy
msgid ""
"If you want to use any of these options/compilers as default, you should "
"consider writing it in your personal or system-wide configuration file for "
"Distutils (see section :ref:`inst-config-files`.)"
msgstr ""
"如果您想預設使用這些選項/編譯器中的任何一個，"
"您應該考慮將其寫入您的個人或系統範圍的 Distutils 配置文件（請參閱 :ref:`inst-"
"config-files` 部分。）"

#: ../../install/index.rst:1027
#, fuzzy
msgid "Older Versions of Python and MinGW"
msgstr "舊版本的 Python 和 MinGW"

#: ../../install/index.rst:1028
#, fuzzy
msgid ""
"The following instructions only apply if you're using a version of Python "
"inferior to 2.4.1 with a MinGW inferior to 3.0.0 (with "
"binutils-2.13.90-20030111-1)."
msgstr ""
"以下說明僅適用於使用低於 2.4.1 的 Python 版本和低於 3.0.0 的 MinGW（使用 "
"binutils-2.13.90-20030111-1）的情況。"

#: ../../install/index.rst:1032
#, fuzzy
msgid ""
"These compilers require some special libraries.  This task is more complex "
"than for Borland's C++, because there is no program to convert the library.  "
"First you have to create a list of symbols which the Python DLL exports. "
"(You can find a good program for this task at https://sourceforge.net/"
"projects/mingw/files/MinGW/Extension/pexports/)."
msgstr ""
"這些編譯器需要一些特殊的庫。這個任務比 Borland 的 C++ "
"更複雜，因為沒有程式來轉換庫。首先，您必須建立 Python DLL 導出的符號列表。 （"
"您可以在 https://sourceforge.net/projects/mingw/files/MinGW/Extension/"
"pexports/ 找到適合此任務的好程式）。"

#: ../../install/index.rst:1045
#, fuzzy
msgid ""
"The location of an installed :file:`python25.dll` will depend on the "
"installation options and the version and language of Windows.  In a \"just "
"for me\" installation, it will appear in the root of the installation "
"directory.  In a shared installation, it will be located in the system "
"directory."
msgstr ""
"安裝的 :file:`python25.dll` 的位置將取決於安裝選項以及 Windows "
"的版本和語言。在“just for "
"me”安裝中，它將出現在安裝目錄的根目錄中。在共享安裝中，它將位於系統目錄中。"

#: ../../install/index.rst:1050
#, fuzzy
msgid ""
"Then you can create from these information an import library for gcc. ::"
msgstr "然後您可以根據這些資訊為 gcc 建立一個導入庫。 ::"

#: ../../install/index.rst:1054
#, fuzzy
msgid ""
"The resulting library has to be placed in the same directory as :file:"
"`python25.lib`. (Should be the :file:`libs` directory under your Python "
"installation directory.)"
msgstr ""
"生成的庫必須放在與 :file:`python25.lib` 相同的目錄中。 （應該是 Python "
"安裝目錄下的 :file:`libs` 目錄。）"

#: ../../install/index.rst:1058
#, fuzzy
msgid ""
"If your extension uses other libraries (zlib,...) you might  have to convert "
"them too. The converted files have to reside in the same directories as the "
"normal libraries do."
msgstr "如果您的擴充使用其他庫（zlib，...），您可能也必須轉換它們。轉換後的文件必須與"
"普通庫位於相同的目錄中。"

#: ../../install/index.rst:1065
#, fuzzy
msgid ""
"`Building Python modules on MS Windows platform with MinGW <https://old.zope."
"dev/Members/als/tips/win32_mingw_modules>`_"
msgstr ""
"`使用 MinGW 在 MS Windows 平台上構建 Python 模組 <https://old.zope.dev/"
"Members/als/tips/win32_mingw_modules>`_"

#: ../../install/index.rst:1066
#, fuzzy
msgid ""
"Information about building the required libraries for the MinGW environment."
msgstr "有關為 MinGW 環境構建所需庫的資訊。"

#: ../../install/index.rst:1070
msgid "Footnotes"
msgstr "註解"

#: ../../install/index.rst:1071
#, fuzzy
msgid ""
"This also means you could replace all existing COFF-libraries with OMF-"
"libraries of the same name."
msgstr "這也意味著您可以用同名的 OMF 庫替換所有現有的 COFF 庫。"

#: ../../install/index.rst:1074
msgid "Check https://www.sourceware.org/cygwin/ for more information"
msgstr "更多資訊請見 https://www.sourceware.org/cygwin/"

#: ../../install/index.rst:1076
#, fuzzy
msgid ""
"Then you have no POSIX emulation available, but you also don't need :file:"
"`cygwin1.dll`."
msgstr "那麼你沒有可用的 POSIX 仿真，但你也不需要 :file:`cygwin1.dll`。"
